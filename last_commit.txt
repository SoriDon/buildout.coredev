Repository: plone.tiles


Branch: refs/heads/master
Date: 2016-02-16T13:14:41+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.tiles/commit/0521250108e0e9714001af66ef43d9d33c0fc2cc

add section ZCML Reference to README.rst

Files changed:
M CHANGELOG.rst
M README.rst
M plone/tiles/meta.py

diff --git a/CHANGELOG.rst b/CHANGELOG.rst
index ebfc34d..ea9f431 100644
--- a/CHANGELOG.rst
+++ b/CHANGELOG.rst
@@ -4,8 +4,11 @@ Changelog
 1.5.2 (unreleased)
 ------------------
 
-- Nothing changed yet.
+- add section "ZCML Reference" to README.rst.
+  [jensens]
 
+- PEP8, make code-analysis happy, fix RST and docstyle.
+  [jensens]
 
 1.5.1 (2015-10-09)
 ------------------
diff --git a/README.rst b/README.rst
index bd4509c..d949f78 100644
--- a/README.rst
+++ b/README.rst
@@ -1,14 +1,13 @@
 plone.tiles
 ===========
 
-``plone.tiles`` implements low-level, non-Plone/Zope2-specific support for
-creating "tiles" in the Deco layout system.
-
-.. contents::
-
 .. image:: https://secure.travis-ci.org/plone/plone.tiles.png
    :target: http://travis-ci.org/plone/plone.tiles
 
+``plone.tiles`` implements a low-level, non-Plone/Zope2-specific support for creating "tiles".
+
+.. contents::
+
 
 Introduction
 ------------
@@ -52,20 +51,22 @@ There are three interfaces describing tiles in this package:
   of a given type on the same layout, the annotations are keyed by the
   tile `__name__`.
 
-In addition, tiles are described by `ITileType`, which contains attributes
-for the tile name, title, description, add permission and schema (if
-required).
+Internally tiles are described by ``ITileType``.
+It contains attributes for the tile name, title, description, add permission and schema (if required).
+
+A properly configured tile consists of
+
+- a utility providing ``ITileType`` with the same name as the tile browser view.
+- a browser view providing ``IBasicTile`` or one of its derivatives.
+
+The directive ``<plone:tile ... />`` is used to register both of these components in one go.
+
+To support creation of appropriate tile links, ``plone.tiles.data`` contains two methods:
 
-A properly configured tile, then, consists of a browser view providing
-`IBasicTile` or one of its derivatives, and a utility providing `ITileType`
-with the same name as the tile browser view. There is a convenience ZCML
-directive - `<plone:tile />` - to register both of these components in one
-go.
+1) ``encode()`` and
+2) ``decode()``
 
-To support creation of appropriate tile links, `plone.tiles.data` contains two
-methods - `encode()` and `decode()` - to help turn a data dictionary into a
-query string and turn a `request.form` dict into a data dict that complies
-with a tile's schema interface.
+to help turn a data dictionary into a query string and turn a `request.form` dict into a data dict that complies with a tile's schema interface.
 
 
 Creating a Simple Tile
@@ -80,20 +81,17 @@ The most basic tile looks like this::
         def __call__(self):
             return u"<html><body><p>Hello world</p></body></html>"
 
-Note that the tile is expected to return a complete HTML document. This will
-be interpolated into the page output according to the following rules:
+Note that the tile is expected to return a complete HTML document.
+This will be interpolated into the page output according to the following rules:
 
-* The contents of the tile's ``<head />`` section is appended to the output
-  document's ``<head />`` section.
-* The contents of the tile's ``<body />`` section will replace the tile
-  placeholder as indicated by the tile link.
+* The contents of the tile's ``<head />`` section is appended to the output document's ``<head />`` section.
+* The contents of the tile's ``<body />`` section will replace the tile placeholder as indicated by the tile link.
 
-Note that this package does *not* provide these interpolations. For a Plone
-implementation of the interpolation algorithm, see `plone.app.blocks`_
+Note that this package does *not* provide these interpolations.
+For a Plone implementation of the interpolation algorithm, see `plone.app.blocks`_
 
-If you require a persistent tile, subclass `plone.tiles.PersistentTile`
-instead. You may also need a schema interface if you want a configurable
-transient or persistent tile.
+If you require a persistent tile, subclass ``plone.tiles.PersistentTile`` instead.
+You may also need a schema interface if you want a configurable transient or persistent tile.
 
 To register the tile, use ZCML like this::
 
@@ -115,13 +113,10 @@ To register the tile, use ZCML like this::
 
     </configure>
 
-The first five attributes describe the tile by configuring an appropriate
-`ITileType` directive. The rest mimics the `<browser:page />` directive,
-so you can specify a `template` file and omit the `class`, or use both a
-`template` and `class`.
+The first five attributes describe the tile by configuring an appropriate ``ITileType`` directive.
+The rest mimics the ``<browser:page />`` directive, so you can specify a ``template`` file and omit the ``class``, or use both a ``template`` and ``class``.
 
-If you want to register a persistent tile with a custom schema, but a template
-only, you can do e.g.::
+If you want to register a persistent tile with a custom schema, but a template only, you can do e.g.::
 
         <plone:tile
             name="sample.persistenttile"
@@ -135,11 +130,9 @@ only, you can do e.g.::
             for="*"
             />
 
-If you want to override an existing tile, e.g. with a new layer or more
-specific context, you *must* omit the tile metadata (title, description, icon,
-add permission or schema). If you include any metadata you will get a conflict
-error on Zope startup. This example shows how to use a different template
-for our tile::
+If you want to override an existing tile, e.g. with a new layer or more specific context,
+you *must* omit the tile metadata (title, description, icon, add permission or schema).
+If you include any metadata you will get a conflict error on Zope startup. This example shows how to use a different template for our tile::
 
         <plone:tile
             name="sample.persistenttile"
@@ -149,6 +142,96 @@ for our tile::
             layer=".interfaces.IMyLayer"
             />
 
+ZCML Reference
+--------------
+
+The ``plone:tile`` directive uses the namespace ``xmlns:plone="http://namespaces.plone.org/plone"``.
+In order to enable it loading of its ``meta.zcml`` is needed, use::
+
+    <include package="plone.tiles" file="meta.zcml" />
+
+When registering a tile, in the background two registrations are done:
+
+1) How to **add** the tile (registered as a utility component as a instance of ``plone.tiles.type.TileType``).
+
+   It is possible to register a tile without adding capabilities.
+   However, such a tile needs to be directly called, there wont be any TTW adding possible.
+
+   This registration can be done once only.
+
+   This registration uses the following attributes:
+
+   - ``name`` (required)
+   - ``title`` (required)
+   - ``description``
+   - ``icon`` (optional)
+   - ``add_permission`` (required)
+   - ``edit_permission`` (optional)
+   - ``delete_permission`` (optional)
+   - ``schema`` (optional)
+
+2) How to **render** the tile (as a usal page).
+
+   It is possible to register different renderers for the same ``name`` but for different contexts (``for`` or ``layer``).
+
+   This registration uses the following attributes:
+
+   - ``name`` (required)
+   - ``for`` (optional)
+   - ``layer`` (optional)
+   - ``class`` (this or template or both is required)
+   - ``template`` (this or template or both is required)
+   - ``permission`` (required)
+
+The **directives attributes** have the following meaning:
+
+``name``
+    A unique, dotted name for the tile.
+
+``title``
+    A user friendly title, used when configuring the tile.
+
+``description``
+    A longer summary of the tile's purpose and function.
+
+``icon``
+    Image that represents tile purpose and function.
+
+``permission``
+    Name of the permission required to view the tile.
+
+``add_permission``
+    Name of the permission required to instantiate the tile.
+
+``edit_permission``
+    Name of the permission required to modify the tile.
+    Defaults to the ``add_permission``.
+
+``delete_permission``
+    Name of the permission required to remove the tile.
+    Defaults to the ``add_permission``.
+
+``schema``
+    Configuration schema for the tile.
+    This is used to create standard add/edit forms.
+
+``for``
+    The interface or class this tile is available for.
+
+``layer``
+    The layer (request marker interface) the tile is available for.
+
+``class``
+    Class implementing this tile. A browser view providing ``IBasicTile`` or one of its derivates.
+
+``template``
+    The name of a template that renders this tile.
+    Refers to a file containing a page template.
+
+
+Further Reading
+---------------
+
 See `tiles.rst` and `directives.rst` for more details.
 
 .. _plone.app.blocks: http://pypi.python.org/pypi/plone.app.blocks
diff --git a/plone/tiles/meta.py b/plone/tiles/meta.py
index 401573b..5a6ce20 100644
--- a/plone/tiles/meta.py
+++ b/plone/tiles/meta.py
@@ -1,27 +1,19 @@
 # -*- coding: utf-8 -*-
 
-from zope.interface import Interface
-
-from zope import schema
-from zope.configuration.fields import (
-    GlobalObject, GlobalInterface, MessageID, Path)
-from zope.security.zcml import Permission
-
-from zope.configuration.exceptions import ConfigurationError
-
-from zope.publisher.interfaces.browser import IDefaultBrowserLayer
-
 from plone.tiles.interfaces import ITileType
-from plone.tiles.type import TileType
 from plone.tiles.tile import Tile
-
+from plone.tiles.type import TileType
+from Products.Five.browser.metaconfigure import page
+from zope import schema
 from zope.component.zcml import utility
-
-try:
-    from Products.Five.browser.metaconfigure import page
-    assert page  # silence pyflakes
-except ImportError:
-    from zope.app.publisher.browser.viewmeta import page
+from zope.configuration.exceptions import ConfigurationError
+from zope.configuration.fields import GlobalInterface
+from zope.configuration.fields import GlobalObject
+from zope.configuration.fields import MessageID
+from zope.configuration.fields import Path
+from zope.interface import Interface
+from zope.publisher.interfaces.browser import IDefaultBrowserLayer
+from zope.security.zcml import Permission
 
 
 class ITileDirective(Interface):
@@ -112,8 +104,13 @@ def tile(_context, name, title=None, description=None, icon=None,
     """Implements the <plone:tile /> directive
     """
 
-    if title is not None or description is not None or icon is not None or \
-            add_permission is not None or schema is not None:
+    if (
+        title is not None or
+        description is not None or
+        icon is not None or
+        add_permission is not None or
+        schema is not None
+    ):
         if title is None or add_permission is None:
             raise ConfigurationError(
                 u"When configuring a new type of tile, 'title' and "
@@ -123,14 +120,20 @@ def tile(_context, name, title=None, description=None, icon=None,
 
         utility(_context, provides=ITileType, component=type_, name=name)
 
-    if for_ is not None or layer is not None or class_ is not None or \
-            template is not None or permission is not None:
+    if (
+        for_ is not None or
+        layer is not None or
+        class_ is not None or
+        template is not None or
+        permission is not None
+    ):
         if class_ is None and template is None:
-            raise ConfigurationError(u"When configuring a tile, 'class' "
-                                     u"or 'template' must be given.")
+            raise ConfigurationError(
+                u"'class' or 'template' must be given when configuring a tile."
+            )
         if permission is None:
-            raise ConfigurationError(u"When configuring a tile, 'permission' "
-                                     u"is required")
+            raise ConfigurationError(
+                u"When configuring a tile, 'permission' is required")
 
         if for_ is None:
             for_ = Interface


Repository: plone.tiles


Branch: refs/heads/master
Date: 2016-02-16T13:17:03+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.tiles/commit/763edeb8ba1ac364274f4aae8fc829c230a4e280

merge master

Files changed:
A .isort.cfg
M .travis.yml
M README.rst
M bootstrap.py
M plone/__init__.py
M plone/tiles/absoluteurl.py
M plone/tiles/data.py
M plone/tiles/esi.py
M plone/tiles/fieldtypeconverters.py
M plone/tiles/interfaces.py
M plone/tiles/tests.py
M plone/tiles/tile.py
M plone/tiles/type.py
M setup.py
M test-4.2.x.cfg
M test-4.3.x.cfg
M test-5.x.cfg

diff --git a/.isort.cfg b/.isort.cfg
new file mode 100644
index 0000000..fb79921
--- /dev/null
+++ b/.isort.cfg
@@ -0,0 +1,5 @@
+[settings]
+force_alphabetical_sort=True
+force_single_line=True
+lines_after_imports=2
+line_length=200
diff --git a/.travis.yml b/.travis.yml
index 51555f8..bf856f8 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,13 +1,20 @@
 language: python
 python: 2.7
 sudo: false
-cache:
-  directories:
-  - eggs
 env:
 - PLONE_VERSION=4.2.x
 - PLONE_VERSION=4.3.x
 - PLONE_VERSION=5.x
+cache:
+  pip: true
+  directories:
+  - $HOME/buildout-cache
+before_install:
+  - mkdir -p $HOME/buildout-cache/{eggs,downloads}
+  - mkdir $HOME/.buildout
+  - echo "[buildout]" > $HOME/.buildout/default.cfg
+  - echo "download-cache = $HOME/buildout-cache/downloads" >> $HOME/.buildout/default.cfg
+  - echo "eggs-directory = $HOME/buildout-cache/eggs" >> $HOME/.buildout/default.cfg
 install:
 - python bootstrap.py -c test-$PLONE_VERSION.cfg
 - bin/buildout -N -t 3 -c test-$PLONE_VERSION.cfg annotate
diff --git a/README.rst b/README.rst
index d949f78..944e01c 100644
--- a/README.rst
+++ b/README.rst
@@ -12,44 +12,48 @@ plone.tiles
 Introduction
 ------------
 
-For the purposes of this package, a tile is a browser view and an associated
-utility providing some metadata about that view. The metadata includes a title
-and description, an 'add' permission and optionally a schema interface
-describing configurable aspects of the tile. The idea is that a UI (such as
-Deco) can present the user with a list of insertable tiles and optionally
-render a form to configure the tile upon insertion.
+For the purposes of this package,
+a tile is a browser view and an associated utility providing some metadata about that view.
+The metadata includes a title and description,
+an 'add' permission and optionally a schema interface describing configurable aspects of the tile.
+The idea is that a UI (such as Deco) can present the user with a list of insertable tiles and optionally render a form to configure the tile upon insertion.
 
-A tile is inserted into a layout as a link::
+A tile is inserted into a layout as a link:
+
+.. code_block:: xml
 
     <link rel="tile" target="placeholder" href="./@@sample.tile/tile1?option1=value1" />
 
-The sub-path (`tile1` in this case) is used to set the tile `id` attribute.
-This allows the tile to know its unique id, and, in the case of persistent
-tiles, look up its data. `sample.tile` is the name of the browser view that
-implements the tile. This is made available as the `__name__` attribute. Other
-parameters may be turned into tile data, available under the `data` attribute,
-a dict, for regular tiles. For persistent tiles (those deriving from the
-`PersistentTile` base class), the data is fetched from annotations instead,
+The sub-path (``tile1`` in this case) is used to set the tile ``id`` attribute.
+This allows the tile to know its unique id, and, in the case of persistent tiles, look up its data.
+``sample.tile`` is the name of the browser view that implements the tile.
+This is made available as the ``__name__`` attribute.
+Other parameters may be turned into tile data, available under the ``data`` attribute, a dict, for regular tiles.
+For persistent tiles
+(those deriving from the ``PersistentTile`` base class),
+the data is fetched from annotations instead,
 based on the tile id.
 
 There are three interfaces describing tiles in this package:
 
-* `IBasicTile` is the low-level interface for tiles. It extends
-  `IBrowserView` to describe the semantics of the `__name__` and  `id`
-  attributes.
-* `ITile` describes a tile that can be configured with some data. The data
-  is accessible via a dict called `data`. The default implementation of this
-  interface, `plone.tiles.Tile`, will use the schema of the tile type and
-  the query string (`self.request.form`) to construct that dictionary. This
-  interface also describes an attribute `url`, which gives the canonical
-  tile URL, including the id sub-path and any query string parameters. (Note
-  that tiles also correctly implement `IAbsoluteURL`.)
-* `IPersistentTile` describes a tile that stores its configuration in
-  object annotations, and is needed when configuration values cannot be
-  encoded into a query string. The default implementation is in
-  `plone.tiles.PersistentTile`. To make it possible to have several tiles
-  of a given type on the same layout, the annotations are keyed by the
-  tile `__name__`.
+``IBasicTile``
+    is the low-level interface for tiles.
+    It extends ``IBrowserView`` to describe the semantics of the ``__name__`` and  ``id`` attributes.
+``ITile``
+    describes a tile that can be configured with some data.
+    The data is accessible via a dict called ``data``.
+    The default implementation of this interface, ``plone.tiles.Tile``,
+    will use the schema of the tile type and the query string (``self.request.form``) to construct that dictionary.
+    This interface also describes an attribute ``url``,
+    which gives the canonical tile URL,
+    including the id sub-path and any query string parameters.
+    (Note that tiles also correctly implement ``IAbsoluteURL``.)
+```IPersistentTile``
+    describes a tile that stores its configuration in object annotations,
+    and is needed when configuration values cannot be encoded into a query string.
+    The default implementation is in ``plone.tiles.PersistentTile``.
+    To make it possible to have several tiles of a given type on the same layout,
+    the annotations are keyed by the tile ``__name__``.
 
 Internally tiles are described by ``ITileType``.
 It contains attributes for the tile name, title, description, add permission and schema (if required).
@@ -72,7 +76,9 @@ to help turn a data dictionary into a query string and turn a `request.form` dic
 Creating a Simple Tile
 ----------------------
 
-The most basic tile looks like this::
+The most basic tile looks like this:
+
+.. code_block:: python
 
     from plone.tiles import Tile
 
diff --git a/bootstrap.py b/bootstrap.py
index c90ed48..ed57894 100644
--- a/bootstrap.py
+++ b/bootstrap.py
@@ -16,112 +16,163 @@
 Simply run this script in a directory containing a buildout.cfg.
 The script accepts buildout command-line options, so you can
 use the -c option to specify an alternate configuration file.
-
-$Id$
 """
 
-import os, shutil, sys, tempfile, urllib2
+import os
+import shutil
+import sys
+import tempfile
+
 from optparse import OptionParser
 
 tmpeggs = tempfile.mkdtemp()
 
-is_jython = sys.platform.startswith('java')
-
-# parsing arguments
-parser = OptionParser(
-    'This is a custom version of the zc.buildout %prog script.  It is '
-    'intended to meet a temporary need if you encounter problems with '
-    'the zc.buildout 1.5 release.')
-parser.add_option("-v", "--version", dest="version", default='1.5.2',
-                          help='Use a specific zc.buildout version.  *This '
-                          'bootstrap script defaults to '
-                          '1.5.2, unlike usual buildout bootstrap scripts.*')
-parser.add_option("-d", "--distribute",
-                   action="store_true", dest="distribute", default=False,
-                   help="Use Disribute rather than Setuptools.")
-
-parser.add_option("-c", None, action="store", dest="config_file",
-                   help=("Specify the path to the buildout configuration "
-                         "file to be used."))
+usage = '''\
+[DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]
 
-options, args = parser.parse_args()
+Bootstraps a buildout-based project.
+
+Simply run this script in a directory containing a buildout.cfg, using the
+Python that you want bin/buildout to use.
+
+Note that by using --find-links to point to local resources, you can keep 
+this script from going over the network.
+'''
+
+parser = OptionParser(usage=usage)
+parser.add_option("-v", "--version", help="use a specific zc.buildout version")
+
+parser.add_option("-t", "--accept-buildout-test-releases",
+                  dest='accept_buildout_test_releases',
+                  action="store_true", default=False,
+                  help=("Normally, if you do not specify a --version, the "
+                        "bootstrap script and buildout gets the newest "
+                        "*final* versions of zc.buildout and its recipes and "
+                        "extensions for you.  If you use this flag, "
+                        "bootstrap and buildout will get the newest releases "
+                        "even if they are alphas or betas."))
+parser.add_option("-c", "--config-file",
+                  help=("Specify the path to the buildout configuration "
+                        "file to be used."))
+parser.add_option("-f", "--find-links",
+                  help=("Specify a URL to search for buildout releases"))
+parser.add_option("--allow-site-packages",
+                  action="store_true", default=False,
+                  help=("Let bootstrap.py use existing site packages"))
 
-# if -c was provided, we push it back into args for buildout' main function
-if options.config_file is not None:
-    args += ['-c', options.config_file]
 
-if options.version is not None:
-    VERSION = '==%s' % options.version
-else:
-    VERSION = ''
+options, args = parser.parse_args()
 
-USE_DISTRIBUTE = options.distribute
-args = args + ['bootstrap']
+######################################################################
+# load/install setuptools
 
-to_reload = False
 try:
-    import pkg_resources
-    if not hasattr(pkg_resources, '_distribute'):
-        to_reload = True
-        raise ImportError
-except ImportError:
-    ez = {}
-    if USE_DISTRIBUTE:
-        exec urllib2.urlopen('http://python-distribute.org/distribute_setup.py'
-                         ).read() in ez
-        ez['use_setuptools'](to_dir=tmpeggs, download_delay=0, no_fake=True)
-    else:
-        exec urllib2.urlopen('http://peak.telecommunity.com/dist/ez_setup.py'
-                             ).read() in ez
-        ez['use_setuptools'](to_dir=tmpeggs, download_delay=0)
-
-    if to_reload:
-        reload(pkg_resources)
-    else:
+    if options.allow_site_packages:
+        import setuptools
         import pkg_resources
-
-if sys.platform == 'win32':
-    def quote(c):
-        if ' ' in c:
-            return '"%s"' % c # work around spawn lamosity on windows
-        else:
-            return c
-else:
-    def quote (c):
-        return c
-
-ws  = pkg_resources.working_set
-
-if USE_DISTRIBUTE:
-    requirement = 'distribute'
-else:
-    requirement = 'setuptools'
-
-env = dict(os.environ,
-           PYTHONPATH=
-           ws.find(pkg_resources.Requirement.parse(requirement)).location
-           )
-
-cmd = [quote(sys.executable),
-       '-c',
-       quote('from setuptools.command.easy_install import main; main()'),
-       '-mqNxd',
-       quote(tmpeggs)]
-
-if 'bootstrap-testing-find-links' in os.environ:
-    cmd.extend(['-f', os.environ['bootstrap-testing-find-links']])
-
-cmd.append('zc.buildout' + VERSION)
-
-if is_jython:
-    import subprocess
-    exitcode = subprocess.Popen(cmd, env=env).wait()
-else: # Windows prefers this, apparently; otherwise we would prefer subprocess
-    exitcode = os.spawnle(*([os.P_WAIT, sys.executable] + cmd + [env]))
-assert exitcode == 0
+    from urllib.request import urlopen
+except ImportError:
+    from urllib2 import urlopen
+
+ez = {}
+exec(urlopen('https://bootstrap.pypa.io/ez_setup.py').read(), ez)
+
+if not options.allow_site_packages:
+    # ez_setup imports site, which adds site packages
+    # this will remove them from the path to ensure that incompatible versions 
+    # of setuptools are not in the path
+    import site
+    # inside a virtualenv, there is no 'getsitepackages'. 
+    # We can't remove these reliably
+    if hasattr(site, 'getsitepackages'):
+        for sitepackage_path in site.getsitepackages():
+            sys.path[:] = [x for x in sys.path if sitepackage_path not in x]
+
+setup_args = dict(to_dir=tmpeggs, download_delay=0)
+ez['use_setuptools'](**setup_args)
+import setuptools
+import pkg_resources
+
+# This does not (always?) update the default working set.  We will
+# do it.
+for path in sys.path:
+    if path not in pkg_resources.working_set.entries:
+        pkg_resources.working_set.add_entry(path)
+
+######################################################################
+# Install buildout
+
+ws = pkg_resources.working_set
+
+cmd = [sys.executable, '-c',
+       'from setuptools.command.easy_install import main; main()',
+       '-mZqNxd', tmpeggs]
+
+find_links = os.environ.get(
+    'bootstrap-testing-find-links',
+    options.find_links or
+    ('http://downloads.buildout.org/'
+     if options.accept_buildout_test_releases else None)
+    )
+if find_links:
+    cmd.extend(['-f', find_links])
+
+setuptools_path = ws.find(
+    pkg_resources.Requirement.parse('setuptools')).location
+
+requirement = 'zc.buildout'
+version = options.version
+if version is None and not options.accept_buildout_test_releases:
+    # Figure out the most recent final version of zc.buildout.
+    import setuptools.package_index
+    _final_parts = '*final-', '*final'
+
+    def _final_version(parsed_version):
+        for part in parsed_version:
+            if (part[:1] == '*') and (part not in _final_parts):
+                return False
+        return True
+    index = setuptools.package_index.PackageIndex(
+        search_path=[setuptools_path])
+    if find_links:
+        index.add_find_links((find_links,))
+    req = pkg_resources.Requirement.parse(requirement)
+    if index.obtain(req) is not None:
+        best = []
+        bestv = None
+        for dist in index[req.project_name]:
+            distv = dist.parsed_version
+            if _final_version(distv):
+                if bestv is None or distv > bestv:
+                    best = [dist]
+                    bestv = distv
+                elif distv == bestv:
+                    best.append(dist)
+        if best:
+            best.sort()
+            version = best[-1].version
+if version:
+    requirement = '=='.join((requirement, version))
+cmd.append(requirement)
+
+import subprocess
+if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:
+    raise Exception(
+        "Failed to execute command:\n%s" % repr(cmd)[1:-1])
+
+######################################################################
+# Import and run buildout
 
 ws.add_entry(tmpeggs)
-ws.require('zc.buildout' + VERSION)
+ws.require(requirement)
 import zc.buildout.buildout
+
+if not [a for a in args if '=' not in a]:
+    args.append('bootstrap')
+
+# if -c was provided, we push it back into args for buildout' main function
+if options.config_file is not None:
+    args[0:0] = ['-c', options.config_file]
+
 zc.buildout.buildout.main(args)
 shutil.rmtree(tmpeggs)
diff --git a/plone/__init__.py b/plone/__init__.py
index f48ad10..68c04af 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1,6 +1,2 @@
-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
-try:
-    __import__('pkg_resources').declare_namespace(__name__)
-except ImportError:
-    from pkgutil import extend_path
-    __path__ = extend_path(__path__, __name__)
+# -*- coding: utf-8 -*-
+__import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/tiles/absoluteurl.py b/plone/tiles/absoluteurl.py
index 9e86186..dbc3fba 100644
--- a/plone/tiles/absoluteurl.py
+++ b/plone/tiles/absoluteurl.py
@@ -1,15 +1,15 @@
 # -*- coding: utf-8 -*-
 
-import urllib
-
+from plone.tiles.data import encode
+from plone.tiles.interfaces import ITileDataManager
+from plone.tiles.interfaces import ITileType
 from zope.component import getMultiAdapter
 from zope.component import queryUtility
-
-from zope.traversing.browser.interfaces import IAbsoluteURL
 from zope.traversing.browser.absoluteurl import AbsoluteURL
+from zope.traversing.browser.interfaces import IAbsoluteURL
+
+import urllib
 
-from plone.tiles.interfaces import ITileType, ITileDataManager
-from plone.tiles.data import encode
 
 _safe = '@+'
 
@@ -22,7 +22,7 @@ def __str__(self):
         tile = self.context
         request = self.request
 
-        id = tile.id
+        tid = tile.id
         name = tile.__name__
         context = tile.__parent__
 
@@ -30,8 +30,8 @@ def __str__(self):
             raise TypeError("Insufficient context to determine URL")
 
         tileFragment = "@@" + urllib.quote(name.encode('utf-8'), _safe)
-        if id:
-            tileFragment += '/' + urllib.quote(id.encode('utf-8'), _safe)
+        if tid:
+            tileFragment += '/' + urllib.quote(tid.encode('utf-8'), _safe)
 
         absolute_url = getMultiAdapter((context, request), IAbsoluteURL)
         try:
@@ -45,13 +45,13 @@ def breadcrumbs(self):
         tile = self.context
         request = self.request
 
-        id = tile.id
+        tid = tile.id
         name = tile.__name__
         context = tile.__parent__
 
         tileFragment = "@@" + urllib.quote(name.encode('utf-8'), _safe)
-        if id:
-            tileFragment += '/' + urllib.quote(id.encode('utf-8'), _safe)
+        if tid:
+            tileFragment += '/' + urllib.quote(tid.encode('utf-8'), _safe)
 
         base = tuple(
             getMultiAdapter((context, request), IAbsoluteURL).breadcrumbs())
diff --git a/plone/tiles/data.py b/plone/tiles/data.py
index 268a3be..24af156 100644
--- a/plone/tiles/data.py
+++ b/plone/tiles/data.py
@@ -1,25 +1,27 @@
 # -*- coding: utf-8 -*-
-import logging
-import urllib
-from zope.interface import implements
-from zope.interface import implementer
-from zope.interface import Interface
-from zope.component import adapts
+from persistent.dict import PersistentDict
+from plone.tiles.interfaces import IFieldTypeConverter
+from plone.tiles.interfaces import IPersistentTile
+from plone.tiles.interfaces import ITile
+from plone.tiles.interfaces import ITileDataContext
+from plone.tiles.interfaces import ITileDataManager
+from plone.tiles.interfaces import ITileType
+from zope.annotation.interfaces import IAnnotations
 from zope.component import adapter
-from zope.component import queryUtility
+from zope.component import adapts
 from zope.component import getMultiAdapter
+from zope.component import queryUtility
 from zope.component.interfaces import ComponentLookupError
-from zope.schema import getFieldsInOrder
+from zope.interface import implementer
+from zope.interface import implements
+from zope.interface import Interface
 from zope.schema import getFields
+from zope.schema import getFieldsInOrder
 from zope.schema.interfaces import ISequence
-from zope.annotation.interfaces import IAnnotations
-from plone.tiles.interfaces import ITileType
-from plone.tiles.interfaces import ITile
-from plone.tiles.interfaces import IPersistentTile
-from plone.tiles.interfaces import ITileDataManager
-from plone.tiles.interfaces import ITileDataContext
-from plone.tiles.interfaces import IFieldTypeConverter
-from persistent.dict import PersistentDict
+
+import logging
+import urllib
+
 
 try:
     import json
@@ -299,7 +301,8 @@ def decode(data, schema, missing=True):
             for item in value:
                 if isinstance(item, str):
                     value = unicode(item, 'utf-8')
-                if field.value_type._type and not isinstance(item, field.value_type._type):
+                if field.value_type._type and not isinstance(
+                        item, field.value_type._type):
                     item = value_type_field_type(item)
                 converted.append(item)
 
diff --git a/plone/tiles/esi.py b/plone/tiles/esi.py
index 8cdc45e..69518cb 100644
--- a/plone/tiles/esi.py
+++ b/plone/tiles/esi.py
@@ -1,11 +1,14 @@
 # -*- coding: utf-8 -*-
 
-import re
-
+from plone.tiles.interfaces import ESI_HEADER
+from plone.tiles.interfaces import ESI_HEADER_KEY
+from plone.tiles.interfaces import IESIRendered
+from plone.tiles.tile import PersistentTile
+from plone.tiles.tile import Tile
 from zope.interface import implements
 
-from plone.tiles.interfaces import IESIRendered, ESI_HEADER, ESI_HEADER_KEY
-from plone.tiles.tile import Tile, PersistentTile
+import re
+
 
 HEAD_CHILDREN = re.compile(r'<head[^>]*>(.*)</head>', re.I | re.S)
 BODY_CHILDREN = re.compile(r'<body[^>]*>(.*)</body>', re.I | re.S)
diff --git a/plone/tiles/fieldtypeconverters.py b/plone/tiles/fieldtypeconverters.py
index 379f1cf..903bff6 100644
--- a/plone/tiles/fieldtypeconverters.py
+++ b/plone/tiles/fieldtypeconverters.py
@@ -1,11 +1,11 @@
 # -*- coding: utf-8 -*-
 
-from zope.interface import implements
 from plone.tiles.interfaces import IFieldTypeConverter
+from zope.interface import implementer
 
 
+@implementer(IFieldTypeConverter)
 class NoConverter(object):
-    implements(IFieldTypeConverter)
 
     def __init__(self, field):
         self.field = field
diff --git a/plone/tiles/interfaces.py b/plone/tiles/interfaces.py
index 67ceb1b..5a43ea1 100644
--- a/plone/tiles/interfaces.py
+++ b/plone/tiles/interfaces.py
@@ -1,11 +1,12 @@
 # -*- coding: utf-8 -*-
 
 from zope.interface import Interface
-import zope.schema
-
 from zope.interface.interfaces import IInterface
 from zope.publisher.interfaces.browser import IBrowserView
 
+import zope.schema
+
+
 ESI_HEADER = 'X-ESI-Enabled'
 ESI_HEADER_KEY = 'HTTP_' + ESI_HEADER.replace('-', '_').upper()
 
diff --git a/plone/tiles/tests.py b/plone/tiles/tests.py
index 7e9bc08..8de88c5 100644
--- a/plone/tiles/tests.py
+++ b/plone/tiles/tests.py
@@ -1,18 +1,20 @@
 # -*- coding: utf-8 -*-
 
-import unittest2 as unittest
-import doctest
-from plone.testing import Layer, layered
-from plone.testing import zca, z2
-
+from plone.testing import Layer
+from plone.testing import layered
+from plone.testing import z2
+from plone.testing import zca
+from plone.tiles import PersistentTile
+from plone.tiles import Tile
+from zope import schema
 from zope.configuration import xmlconfig
+from zope.interface import Interface
 
-# For directive tests
+import doctest
+import unittest2 as unittest
 
-from zope.interface import Interface
-from zope import schema
 
-from plone.tiles import Tile, PersistentTile
+# For directive tests
 
 
 class IDummySchema(Interface):
@@ -28,6 +30,7 @@ class IDummyLayer(Interface):
 
 
 class DummyTile(Tile):
+
     def __call__(self):
         return u"dummy"
 
diff --git a/plone/tiles/tile.py b/plone/tiles/tile.py
index b6cea78..529538f 100644
--- a/plone/tiles/tile.py
+++ b/plone/tiles/tile.py
@@ -3,11 +3,12 @@
 from plone.tiles.interfaces import ITile
 from plone.tiles.interfaces import ITileDataManager
 from zope.component import queryMultiAdapter
-from zope.interface import implements
+from zope.interface import implementer
 from zope.publisher.browser import BrowserView
 from zope.traversing.browser.absoluteurl import absoluteURL
 
 
+@implementer(ITile)
 class Tile(BrowserView):
     """Basic implementation of a transient tile. Subclasses should override
     __call__ or set an 'index' variable to point to a view page template file.
@@ -26,8 +27,6 @@ class Tile(BrowserView):
       `foo`.
     """
 
-    implements(ITile)
-
     __cachedData = None
     __cachedURL = None
 
@@ -97,9 +96,8 @@ def url(self):
         return absoluteURL(self, self.request)
 
 
+@implementer(IPersistentTile)
 class PersistentTile(Tile):
     """Base class for persistent tiles. Identical to `Tile`, except that the
     data dict is never serialized with the URL.
     """
-
-    implements(IPersistentTile)
diff --git a/plone/tiles/type.py b/plone/tiles/type.py
index a89738d..6a33f54 100644
--- a/plone/tiles/type.py
+++ b/plone/tiles/type.py
@@ -1,15 +1,14 @@
 # -*- coding: utf-8 -*-
 
-from zope.interface import implements
 from plone.tiles.interfaces import ITileType
+from zope.interface import implementer
 
 
+@implementer(ITileType)
 class TileType(object):
     """A utility that describes a type of tile
     """
 
-    implements(ITileType)
-
     def __init__(self, name, title, add_permission, edit_permission=None,
                  delete_permission=None, description=None, icon=None,
                  schema=None):
diff --git a/setup.py b/setup.py
index 4bd3042..c6f51fa 100644
--- a/setup.py
+++ b/setup.py
@@ -1,6 +1,9 @@
-import os
-from setuptools import setup
+# -*- coding: utf-8 -*-
 from setuptools import find_packages
+from setuptools import setup
+
+import os
+
 
 version = '1.5.2.dev0'
 
diff --git a/test-4.2.x.cfg b/test-4.2.x.cfg
index 2ddcdb1..96331dd 100644
--- a/test-4.2.x.cfg
+++ b/test-4.2.x.cfg
@@ -19,3 +19,6 @@ flake8-ignore = E501,C901
 
 [versions]
 coverage = 3.7
+
+# dont fight with setuptools versions
+setuptools =
diff --git a/test-4.3.x.cfg b/test-4.3.x.cfg
index 2af8913..b7f24e6 100644
--- a/test-4.3.x.cfg
+++ b/test-4.3.x.cfg
@@ -19,3 +19,6 @@ flake8-ignore = E501,C901
 
 [versions]
 coverage = 3.7
+
+# dont fight with setuptools versions
+setuptools =
diff --git a/test-5.x.cfg b/test-5.x.cfg
index fccbaaf..f41f343 100644
--- a/test-5.x.cfg
+++ b/test-5.x.cfg
@@ -20,3 +20,6 @@ flake8-ignore = E501,C901
 
 [versions]
 coverage = 3.7
+
+# dont fight with setuptools versions
+setuptools =


