Repository: plone.app.z3cform


Branch: refs/heads/master
Date: 2022-08-10T14:22:01+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.z3cform/commit/380af10b41be06656cdec27ebae21cc23263e5cd

remove Py2 fallbacks, run pyupgrade, do not depend on CMFPlone

Files changed:
A news/150.bugfix
M plone/__init__.py
M plone/app/__init__.py
M plone/app/z3cform/__init__.py
M plone/app/z3cform/converters.py
M plone/app/z3cform/csrf.py
M plone/app/z3cform/factories.py
M plone/app/z3cform/inline_validation.py
M plone/app/z3cform/interfaces.py
M plone/app/z3cform/layout.py
M plone/app/z3cform/profiles.zcml
M plone/app/z3cform/tests/__init__.py
M plone/app/z3cform/tests/example.py
M plone/app/z3cform/tests/layer.py
M plone/app/z3cform/tests/test_csrf.py
M plone/app/z3cform/tests/test_utils.py
M plone/app/z3cform/tests/test_widget.py
M plone/app/z3cform/tests/test_widgets.py
M plone/app/z3cform/tests/tests.py
M plone/app/z3cform/utils.py
M plone/app/z3cform/views.py
M plone/app/z3cform/widget.py
M plone/app/z3cform/wysiwyg/__init__.py
M plone/app/z3cform/wysiwyg/widget.py
M pyproject.toml
M setup.py

b'diff --git a/news/150.bugfix b/news/150.bugfix\nnew file mode 100644\nindex 00000000..291b9d4d\n--- /dev/null\n+++ b/news/150.bugfix\n@@ -0,0 +1,3 @@\n+Leftovers of Py 2 removed (with pyupgrade and manual edits). then run black & isort.\n+Do not depend on CMFPlone any longer (circular dependency), but on plone.base.\n+[jensens]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af4..5284146e 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 68c04af4..5284146e 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/z3cform/__init__.py b/plone/app/z3cform/__init__.py\nindex 40a96afc..e69de29b 100644\n--- a/plone/app/z3cform/__init__.py\n+++ b/plone/app/z3cform/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/z3cform/converters.py b/plone/app/z3cform/converters.py\nindex 06660ebe..9bff58e0 100644\n--- a/plone/app/z3cform/converters.py\n+++ b/plone/app/z3cform/converters.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import date\n from datetime import datetime\n from datetime import time\n@@ -14,8 +13,7 @@\n from plone.app.z3cform.interfaces import ITimeWidget\n from plone.uuid.interfaces import IUUID\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.utils import safe_callable\n-from six.moves import urllib\n+from plone.base.utils import safe_callable\n from z3c.form.converter import BaseDataConverter\n from z3c.form.converter import CollectionSequenceDataConverter\n from z3c.form.converter import SequenceDataConverter\n@@ -34,7 +32,7 @@\n \n import json\n import pytz\n-import six\n+import urllib\n \n \n @adapter(IDate, IDateWidget)\n@@ -51,9 +49,8 @@ def toWidgetValue(self, value):\n         :rtype: string\n         """\n         if value is self.field.missing_value:\n-            return u\'\'\n-        return (\'{value.year:}-{value.month:02}-{value.day:02}\'\n-                ).format(value=value)\n+            return ""\n+        return ("{value.year:}-{value.month:02}-{value.day:02}").format(value=value)\n \n     def toFieldValue(self, value):\n         """Converts from widget value to field.\n@@ -66,7 +63,7 @@ def toFieldValue(self, value):\n         """\n         if not value:\n             return self.field.missing_value\n-        return date(*map(int, value.split(\'-\')))\n+        return date(*map(int, value.split("-")))\n \n \n @adapter(IDatetime, IDatetimeWidget)\n@@ -83,9 +80,11 @@ def toWidgetValue(self, value):\n         :rtype: string\n         """\n         if value is self.field.missing_value:\n-            return u\'\'\n-        return (\'{value.year:}-{value.month:02}-{value.day:02}T\'\n-                \'{value.hour:02}:{value.minute:02}\').format(value=value)\n+            return ""\n+        return (\n+            "{value.year:}-{value.month:02}-{value.day:02}T"\n+            "{value.hour:02}:{value.minute:02}"\n+        ).format(value=value)\n \n     def toFieldValue(self, value):\n         """Converts from widget value to field.\n@@ -98,20 +97,23 @@ def toFieldValue(self, value):\n         """\n         if not value:\n             return self.field.missing_value\n-        tmp = value.split(\'T\')\n+        tmp = value.split("T")\n         if not tmp[0]:\n             return self.field.missing_value\n-        value = tmp[0].split(\'-\')\n-        if len(tmp) == 2 and \':\' in tmp[1]:\n-            value += tmp[1].split(\':\')\n+        value = tmp[0].split("-")\n+        if len(tmp) == 2 and ":" in tmp[1]:\n+            value += tmp[1].split(":")\n         else:\n-            value += [\'00\', \'00\']\n+            value += ["00", "00"]\n \n         # TODO: respect the selected zone from the widget and just fall back\n         # to default_zone\n         default_zone = self.widget.default_timezone\n-        zone = default_zone(self.widget.context)\\\n-            if safe_callable(default_zone) else default_zone\n+        zone = (\n+            default_zone(self.widget.context)\n+            if safe_callable(default_zone)\n+            else default_zone\n+        )\n         ret = datetime(*map(int, value))\n         if zone:\n             tzinfo = pytz.timezone(zone)\n@@ -127,17 +129,16 @@ class TimeWidgetConverter(BaseDataConverter):\n \n     def toWidgetValue(self, value):\n         if value == self.field.missing_value:\n-            return u\'\'\n+            return ""\n         return value.strftime("%H:%M")\n \n     def toFieldValue(self, value):\n-        if value == u\'\':\n+        if value == "":\n             return self.field.missing_value\n         return time(*map(int, value.split(":")))\n \n \n-class SelectWidgetConverterBase(object):\n-\n+class SelectWidgetConverterBase:\n     def toFieldValue(self, value):\n         """Converts from widget value to field.\n \n@@ -148,25 +149,24 @@ def toFieldValue(self, value):\n         :returns: List of items\n         :rtype: list | tuple | set\n         """\n-        separator = getattr(self.widget, \'separator\', \';\')\n-        if isinstance(value, six.string_types):\n+        separator = getattr(self.widget, "separator", ";")\n+        if isinstance(value, str):\n             value = value.strip()\n             if value:\n                 value = value.split(separator)\n             else:\n                 return self.field.missing_value\n-        elif value == (u\'\',):\n+        elif value == ("",):\n             return self.field.missing_value\n-        return super(SelectWidgetConverterBase, self).toFieldValue(value)\n+        return super().toFieldValue(value)\n \n \n @adapter(IField, ISelectWidget)\n class SequenceSelectWidgetConverter(\n-        SelectWidgetConverterBase,\n-        SequenceDataConverter,\n+    SelectWidgetConverterBase,\n+    SequenceDataConverter,\n ):\n-    """Data converter for IField fields using the SelectWidget.\n-    """\n+    """Data converter for IField fields using the SelectWidget."""\n \n \n @adapter(ICollection, ISelectWidget)\n@@ -174,14 +174,12 @@ class SelectWidgetConverter(\n     SelectWidgetConverterBase,\n     CollectionSequenceDataConverter,\n ):\n-    """Data converter for ICollection fields using the SelectWidget.\n-    """\n+    """Data converter for ICollection fields using the SelectWidget."""\n \n \n @adapter(ICollection, IAjaxSelectWidget)\n class AjaxSelectWidgetConverter(BaseDataConverter):\n-    """Data converter for ICollection fields using the AjaxSelectWidget.\n-    """\n+    """Data converter for ICollection fields using the AjaxSelectWidget."""\n \n     def toWidgetValue(self, value):\n         """Converts from field value to widget tokenized widget value.\n@@ -204,8 +202,8 @@ def toWidgetValue(self, value):\n                     continue\n                 except (LookupError, ValueError):\n                     pass\n-            tokenized_value.append(six.text_type(term_value))\n-        return getattr(self.widget, \'separator\', \';\').join(tokenized_value)\n+            tokenized_value.append(str(term_value))\n+        return getattr(self.widget, "separator", ";").join(tokenized_value)\n \n     def toFieldValue(self, value):\n         """Converts from widget value to field.\n@@ -224,7 +222,7 @@ def toFieldValue(self, value):\n         valueType = self.field.value_type._type\n         if isinstance(valueType, tuple):\n             valueType = valueType[0]\n-        separator = getattr(self.widget, \'separator\', \';\')\n+        separator = getattr(self.widget, "separator", ";")\n         self.widget.update()  # needed to have a vocabulary\n         vocabulary = self.widget.get_vocabulary()\n         untokenized_value = []\n@@ -247,8 +245,7 @@ def toFieldValue(self, value):\n \n @adapter(IRelation, IRelatedItemsWidget)\n class RelationChoiceRelatedItemsWidgetConverter(BaseDataConverter):\n-    """Data converter for RelationChoice fields using the RelatedItemsWidget.\n-    """\n+    """Data converter for RelationChoice fields using the RelatedItemsWidget."""\n \n     def toWidgetValue(self, value):\n         if not value:\n@@ -259,9 +256,9 @@ def toFieldValue(self, value):\n         if not value:\n             return self.field.missing_value\n         try:\n-            catalog = getToolByName(self.widget.context, \'portal_catalog\')\n+            catalog = getToolByName(self.widget.context, "portal_catalog")\n         except AttributeError:\n-            catalog = getToolByName(getSite(), \'portal_catalog\')\n+            catalog = getToolByName(getSite(), "portal_catalog")\n \n         res = catalog(UID=value)\n         if res:\n@@ -298,7 +295,7 @@ def toWidgetValue(self, value):\n         """\n         if not value:\n             return self.field.missing_value\n-        separator = getattr(self.widget, \'separator\', \';\')\n+        separator = getattr(self.widget, "separator", ";")\n         if IRelationList.providedBy(self.field):\n             return separator.join([IUUID(o) for o in value if o])\n         else:\n@@ -320,30 +317,30 @@ def toFieldValue(self, value):\n         if isinstance(collectionType, tuple):\n             collectionType = collectionType[-1]\n \n-        separator = getattr(self.widget, \'separator\', \';\')\n+        separator = getattr(self.widget, "separator", ";")\n         # Some widgets (like checkbox) return lists\n-        if isinstance(value, six.string_types):\n+        if isinstance(value, str):\n             value = value.split(separator)\n \n         if IRelationList.providedBy(self.field):\n             try:\n-                catalog = getToolByName(self.widget.context, \'portal_catalog\')\n+                catalog = getToolByName(self.widget.context, "portal_catalog")\n             except AttributeError:\n-                catalog = getToolByName(getSite(), \'portal_catalog\')\n+                catalog = getToolByName(getSite(), "portal_catalog")\n \n-            objects = {item.UID: item.getObject()\n-                       for item in catalog(UID=value) if item}\n+            objects = {\n+                item.UID: item.getObject() for item in catalog(UID=value) if item\n+            }\n \n-            return collectionType(objects[uid]\n-                                  for uid in value\n-                                  if uid in objects.keys())\n+            return collectionType(\n+                objects[uid] for uid in value if uid in objects.keys()\n+            )\n         else:\n-            valueType = getattr(self.field.value_type, \'_type\', six.text_type)\n+            valueType = getattr(self.field.value_type, "_type", str)\n             if valueType is None:\n-                valueType = six.text_type\n-            if not six.PY2 and valueType == six.binary_type:\n-                return collectionType(\n-                    valueType(v, encoding=\'utf8\') for v in value)\n+                valueType = str\n+            if valueType == bytes:\n+                return collectionType(valueType(v, encoding="utf8") for v in value)\n             return collectionType(valueType(v) for v in value)\n \n \n@@ -385,7 +382,7 @@ def toWidgetValue(self, value):\n         :rtype: string\n         """\n         if not value:\n-            return \'[]\'\n+            return "[]"\n         return json.dumps(value)\n \n     def toFieldValue(self, value):\n@@ -411,33 +408,33 @@ class LinkWidgetDataConverter(BaseDataConverter):\n     """Data converter for the enhanced link widget."""\n \n     def toWidgetValue(self, value):\n-        value = super(LinkWidgetDataConverter, self).toWidgetValue(value)\n+        value = super().toWidgetValue(value)\n         result = {\n-            \'internal\': u\'\',\n-            \'external\': u\'\',\n-            \'email\': u\'\',\n-            \'email_subject\': u\'\',\n+            "internal": "",\n+            "external": "",\n+            "email": "",\n+            "email_subject": "",\n         }\n         if not value:\n             return result\n-        if value.startswith(\'mailto:\'):\n+        if value.startswith("mailto:"):\n             # Handle mail URLs\n-            value = value[7:]   # strip mailto from beginning\n-            if \'?subject=\' in value:\n-                email, email_subject = value.split(\'?subject=\')\n-                result[\'email\'] = email\n-                result[\'email_subject\'] = email_subject\n+            value = value[7:]  # strip mailto from beginning\n+            if "?subject=" in value:\n+                email, email_subject = value.split("?subject=")\n+                result["email"] = email\n+                result["email_subject"] = email_subject\n             else:\n-                result[\'email\'] = value\n+                result["email"] = value\n         else:\n             uuid = None\n             portal = getSite()\n             is_same_domain = utils.is_same_domain(value, portal.absolute_url())\n             is_absolute = utils.is_absolute(value)\n-            if \'/resolveuid/\' in value and (not is_absolute or is_same_domain):\n+            if "/resolveuid/" in value and (not is_absolute or is_same_domain):\n                 # Take the UUID part of a resolveuid url, but onl if it\'s on\n                 # the same domain.\n-                uuid = value.rsplit(\'/\', 1)[-1]\n+                uuid = value.rsplit("/", 1)[-1]\n             elif not is_absolute or is_absolute and is_same_domain:\n                 # Handle relative URLs or absolute URLs on the same domain.\n                 parsed = urllib.parse.urlparse(value)\n@@ -448,17 +445,14 @@ def toWidgetValue(self, value):\n                     # to uids\n                     pass\n                 else:\n-                    path = utils.replace_link_variables_by_paths(\n-                        portal, parsed.path)\n-                    if six.PY2:\n-                        path = path.encode(\'ascii\', \'ignore\')\n+                    path = utils.replace_link_variables_by_paths(portal, parsed.path)\n                     obj = portal.unrestrictedTraverse(path=path, default=None)\n                     if obj is not None:\n                         uuid = IUUID(obj, None)\n             if uuid is not None:\n-                result[\'internal\'] = uuid\n+                result["internal"] = uuid\n             else:\n-                result[\'external\'] = value\n+                result["external"] = value\n         return result\n \n     def toFieldValue(self, value):\n@@ -467,21 +461,21 @@ def toFieldValue(self, value):\n         if not value:\n             return self.field.missing_value\n         if isinstance(value, dict):\n-            internal = value.get(\'internal\')\n-            external = value.get(\'external\')\n-            email = value.get(\'email\')\n+            internal = value.get("internal")\n+            external = value.get("external")\n+            email = value.get("email")\n         else:\n             return value\n         if internal:\n-            url = \'${portal_url}/resolveuid/\' + internal\n+            url = "${portal_url}/resolveuid/" + internal\n         elif email:\n-            subject = value.get(\'email_subject\')\n-            if email[:7] != \'mailto:\':\n-                email = u\'mailto:\' + email\n+            subject = value.get("email_subject")\n+            if email[:7] != "mailto:":\n+                email = "mailto:" + email\n             if not subject:\n                 url = email\n             else:\n-                url = u\'{email}?subject={subject}\'.format(\n+                url = "{email}?subject={subject}".format(\n                     email=email,\n                     subject=subject,\n                 )\n@@ -492,17 +486,16 @@ def toFieldValue(self, value):\n \n @adapter(IBool, ISingleCheckBoxBoolWidget)\n class BoolSingleCheckboxDataConverter(BaseDataConverter):\n-    """Special converter between boolean fields and single checkbox widgets.\n-    """\n+    """Special converter between boolean fields and single checkbox widgets."""\n \n     def toWidgetValue(self, value):\n         """Convert from Python bool to token sequence representation."""\n         if value:\n-            return [\'selected\']\n-        return [\'unselected\']\n+            return ["selected"]\n+        return ["unselected"]\n \n     def toFieldValue(self, value):\n         """See interfaces.IDataConverter"""\n         # consider all different from true as false,\n         # this way it works with one checkbox\n-        return bool(value and value[0] == \'selected\')\n+        return bool(value and value[0] == "selected")\ndiff --git a/plone/app/z3cform/csrf.py b/plone/app/z3cform/csrf.py\nindex 4eaaf6db..b69484ee 100644\n--- a/plone/app/z3cform/csrf.py\n+++ b/plone/app/z3cform/csrf.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.z3cform.interfaces import IPloneFormLayer\n from plone.protect import CheckAuthenticator\n from z3c.form.button import ButtonActions\n@@ -16,7 +15,7 @@ class AuthenticatedButtonActions(ButtonActions):\n     """\n \n     def execute(self):\n-        if getattr(self.form, \'enableCSRFProtection\', False):\n+        if getattr(self.form, "enableCSRFProtection", False):\n             if self.executedActions:\n                 CheckAuthenticator(self.request)\n-        super(AuthenticatedButtonActions, self).execute()\n+        super().execute()\ndiff --git a/plone/app/z3cform/factories.py b/plone/app/z3cform/factories.py\nindex 0bddc811..85022a30 100644\n--- a/plone/app/z3cform/factories.py\n+++ b/plone/app/z3cform/factories.py\n@@ -1,15 +1,13 @@\n-# -*- coding: utf-8 -*-\n-from zope.interface import implementer\n-from plone.namedfile.storages import MAXCHUNKSIZE\n from plone.namedfile.interfaces import IStorage\n+from plone.namedfile.storages import MAXCHUNKSIZE\n+from zope.interface import implementer\n \n \n @implementer(IStorage)\n-class Zope2FileUploadStorable(object):\n-\n+class Zope2FileUploadStorable:\n     def store(self, data, blob):\n         data.seek(0)\n-        with blob.open(\'w\') as fp:\n+        with blob.open("w") as fp:\n             block = data.read(MAXCHUNKSIZE)\n             while block:\n                 fp.write(block)\ndiff --git a/plone/app/z3cform/inline_validation.py b/plone/app/z3cform/inline_validation.py\nindex 54beed94..cf26c848 100644\n--- a/plone/app/z3cform/inline_validation.py\n+++ b/plone/app/z3cform/inline_validation.py\n@@ -1,7 +1,7 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_base\n-from Products.CMFPlone.utils import normalizeString\n+from plone.i18n.normalizer.interfaces import IIDNormalizer\n from Products.Five import BrowserView\n+from zope.component import queryUtility\n from zope.i18n import translate\n from zope.i18nmessageid import Message\n \n@@ -9,13 +9,12 @@\n \n \n class InlineValidationView(BrowserView):\n-    """Validate a form and return the error message for a particular field as JSON.\n-    """\n+    """Validate a form and return the error message for a particular field as JSON."""\n \n     def __call__(self, fname=None, fset=None):\n-        self.request.response.setHeader(\'Content-Type\', \'application/json\')\n+        self.request.response.setHeader("Content-Type", "application/json")\n \n-        res = {\'errmsg\': \'\'}\n+        res = {"errmsg": ""}\n \n         if fname is None:\n             return json.dumps(res)\n@@ -29,7 +28,7 @@ def __call__(self, fname=None, fset=None):\n         except (AttributeError, TypeError):\n             return json.dumps(res)\n \n-        if getattr(form, \'extractData\', None):\n+        if getattr(form, "extractData", None):\n             data, errors = form.extractData()\n         else:\n             return json.dumps(res)\n@@ -42,13 +41,17 @@ def __call__(self, fname=None, fset=None):\n             except (ValueError, TypeError):\n                 # try to match fieldset on group name\n                 def _name(group):\n-                    return getattr(group, \'__name__\', group.label)\n-                group_match = list(filter(\n-                    lambda group: normalizeString(_name(group)) == fset,\n-                    form.groups,\n-                ))\n+                    return getattr(group, "__name__", group.label)\n+\n+                normalize = queryUtility(IIDNormalizer).normalize\n+                group_match = list(\n+                    filter(\n+                        lambda group: normalize(_name(group)) == fset,\n+                        form.groups,\n+                    )\n+                )\n                 if not group_match:\n-                    raise ValueError(\'Fieldset specified, but not found.\')\n+                    raise ValueError("Fieldset specified, but not found.")\n                 form = group_match[0]\n \n         index = len(form.prefix) + len(form.widgets.prefix)\n@@ -62,5 +65,5 @@ def _name(group):\n         if isinstance(validationError, Message):\n             validationError = translate(validationError, context=self.request)\n \n-        res[\'errmsg\'] = validationError or \'\'\n+        res["errmsg"] = validationError or ""\n         return json.dumps(res)\ndiff --git a/plone/app/z3cform/interfaces.py b/plone/app/z3cform/interfaces.py\nindex d50d6b15..6ffce277 100644\n--- a/plone/app/z3cform/interfaces.py\n+++ b/plone/app/z3cform/interfaces.py\n@@ -1,5 +1,6 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.textfield.widget import IRichTextWidget as patextfield_IRichTextWidget  # noqa\n+from plone.app.textfield.widget import (\n+    IRichTextWidget as patextfield_IRichTextWidget,\n+)  # noqa\n from z3c.form.interfaces import IFormLayer\n from z3c.form.interfaces import IRadioWidget\n from z3c.form.interfaces import ISelectWidget as IBaseSelectWidget\n@@ -86,5 +87,6 @@ def renderForValue(value):\n         words it is a term token.\n         """\n \n+\n class IRichTextWidgetInputModeRenderer(Interface):\n     """Marker interface to render multiple wysiwyg editors"""\ndiff --git a/plone/app/z3cform/layout.py b/plone/app/z3cform/layout.py\nindex e6eea713..741f90e4 100644\n--- a/plone/app/z3cform/layout.py\n+++ b/plone/app/z3cform/layout.py\n@@ -1,9 +1,8 @@\n-# -*- coding: utf-8 -*-\n import zope.deferredimport\n \n \n zope.deferredimport.deprecated(\n-    \'Import from plone.z3cform.layout instead.\',\n-    FormWrapper=\'plone.z3cform.layout:FormWrapper\',\n-    wrap_form=\'plone.z3cform.layout:wrap_form\',\n+    "Import from plone.z3cform.layout instead.",\n+    FormWrapper="plone.z3cform.layout:FormWrapper",\n+    wrap_form="plone.z3cform.layout:wrap_form",\n )\ndiff --git a/plone/app/z3cform/profiles.zcml b/plone/app/z3cform/profiles.zcml\nindex 9e358d4f..b74de448 100644\n--- a/plone/app/z3cform/profiles.zcml\n+++ b/plone/app/z3cform/profiles.zcml\n@@ -11,7 +11,7 @@\n       description="Adds support for rendering z3c.form forms in Plone"\n       directory="profiles/default"\n       provides="Products.GenericSetup.interfaces.EXTENSION"\n-      for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+      for="plone.base.interfaces.IPloneSiteRoot"\n       />\n \n </configure>\ndiff --git a/plone/app/z3cform/tests/__init__.py b/plone/app/z3cform/tests/__init__.py\nindex 40a96afc..e69de29b 100644\n--- a/plone/app/z3cform/tests/__init__.py\n+++ b/plone/app/z3cform/tests/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/z3cform/tests/example.py b/plone/app/z3cform/tests/example.py\nindex 325ed4be..5938b0ae 100644\n--- a/plone/app/z3cform/tests/example.py\n+++ b/plone/app/z3cform/tests/example.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.z3cform.layout import FormWrapper\n from z3c.form import button\n from z3c.form import field\n@@ -13,25 +12,24 @@\n \n \n class MySchema(Interface):\n-    age = schema.Int(title=u\'Age\')\n+    age = schema.Int(title="Age")\n \n \n class MyContentProvider(ContentProviderBase):\n-\n     def render(self):\n-        return \'My test content provider\'\n+        return "My test content provider"\n \n \n @implementer(IFieldsAndContentProvidersForm)\n class MyForm(form.Form):\n     contentProviders = ContentProviders()\n-    contentProviders[\'myContentProvider\'] = MyContentProvider\n+    contentProviders["myContentProvider"] = MyContentProvider\n     # defining a contentProvider position is mandatory...\n-    contentProviders[\'myContentProvider\'].position = 0\n-    label = u\'Please enter your age\'\n+    contentProviders["myContentProvider"].position = 0\n+    label = "Please enter your age"\n     ignoreContext = True  # don\'t use context to get widget data\n \n-    @button.buttonAndHandler(u\'Apply\')\n+    @button.buttonAndHandler("Apply")\n     def handleApply(self, action):\n         data, errors = self.extractData()\n \n@@ -41,23 +39,25 @@ class MyFormWrapper(FormWrapper):\n \n \n class MyGroupSchema(Interface):\n-    name = schema.TextLine(title=u\'name\')\n+    name = schema.TextLine(title="name")\n \n \n class MyGroup(group.Group):\n-    label = u\'Secondary Group\'\n-    __name__ = u\'MyGroup\'\n+    label = "Secondary Group"\n+    __name__ = "MyGroup"\n     fields = field.Fields(MyGroupSchema)\n \n \n class MyGroupForm(group.GroupForm, form.Form):\n     fields = field.Fields(MySchema)\n-    label = u\'Please enter your age and Name\'\n+    label = "Please enter your age and Name"\n     ignoreContext = True  # don\'t use context to get widget data\n \n-    groups = [MyGroup, ]\n+    groups = [\n+        MyGroup,\n+    ]\n \n-    @button.buttonAndHandler(u\'Apply\')\n+    @button.buttonAndHandler("Apply")\n     def handleApply(self, action):\n         data, errors = self.extractData()\n \n@@ -67,17 +67,19 @@ class MyGroupFormWrapper(FormWrapper):\n \n \n class MyMultiSchema(Interface):\n-    ages = schema.Dict(title=u\'ages\',\n-                       key_type=schema.TextLine(title=u\'name\'),\n-                       value_type=schema.Int(title=u\'age\', default=38))\n+    ages = schema.Dict(\n+        title="ages",\n+        key_type=schema.TextLine(title="name"),\n+        value_type=schema.Int(title="age", default=38),\n+    )\n \n \n class MyMultiForm(form.Form):\n     fields = field.Fields(MyMultiSchema)\n-    label = u\'Please enter the names and ages for each person\'\n+    label = "Please enter the names and ages for each person"\n     ignoreContext = True  # don\'t use context to get widget data\n \n-    @button.buttonAndHandler(u\'Apply\')\n+    @button.buttonAndHandler("Apply")\n     def handleApply(self, action):\n         data, errors = self.extractData()\n \ndiff --git a/plone/app/z3cform/tests/layer.py b/plone/app/z3cform/tests/layer.py\nindex b1263f84..98e0afba 100644\n--- a/plone/app/z3cform/tests/layer.py\n+++ b/plone/app/z3cform/tests/layer.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.testing import PLONE_FIXTURE\n from plone.app.testing import PloneSandboxLayer\n from plone.app.testing.layers import IntegrationTesting\n@@ -9,27 +8,30 @@ class PAZ3CFormLayer(PloneSandboxLayer):\n     defaultBases = (PLONE_FIXTURE,)\n \n     def setUpZope(self, app, configurationContext):\n-        z2.installProduct(app, \'Products.DateRecurringIndex\')\n+        z2.installProduct(app, "Products.DateRecurringIndex")\n \n         import plone.app.contenttypes\n-        self.loadZCML(package=plone.app.contenttypes,\n-                      context=configurationContext)\n+\n+        self.loadZCML(package=plone.app.contenttypes, context=configurationContext)\n \n         import plone.app.z3cform\n-        self.loadZCML(package=plone.app.z3cform,\n-                      context=configurationContext)\n+\n+        self.loadZCML(package=plone.app.z3cform, context=configurationContext)\n         import plone.app.z3cform.tests\n-        self.loadZCML(name=\'testing.zcml\',\n-                      package=plone.app.z3cform.tests,\n-                      context=configurationContext)\n+\n+        self.loadZCML(\n+            name="testing.zcml",\n+            package=plone.app.z3cform.tests,\n+            context=configurationContext,\n+        )\n \n     def setUpPloneSite(self, portal):\n-        self.applyProfile(portal, \'plone.app.contenttypes:default\')\n-        self.applyProfile(portal, \'plone.app.z3cform:default\')\n+        self.applyProfile(portal, "plone.app.contenttypes:default")\n+        self.applyProfile(portal, "plone.app.z3cform:default")\n \n \n PAZ3CForm_FIXTURE = PAZ3CFormLayer()\n PAZ3CForm_INTEGRATION_TESTING = IntegrationTesting(\n     bases=(PAZ3CForm_FIXTURE,),\n-    name=\'plone.app.z3cform:Integration\',\n+    name="plone.app.z3cform:Integration",\n )\ndiff --git a/plone/app/z3cform/tests/test_csrf.py b/plone/app/z3cform/tests/test_csrf.py\nindex a9a1ffc0..f0ca055c 100644\n--- a/plone/app/z3cform/tests/test_csrf.py\n+++ b/plone/app/z3cform/tests/test_csrf.py\n@@ -1,20 +1,17 @@\n-# -*- coding: utf-8 -*-\n from plone.protect.tests.case import KeyringTestCase\n \n \n class TestAuthenticatedButtonActions(KeyringTestCase):\n-\n     def test_execute(self):\n         from Acquisition import Implicit\n-        from Testing.makerequest import makerequest\n         from plone.app.z3cform.csrf import AuthenticatedButtonActions\n         from plone.protect import createToken\n+        from Testing.makerequest import makerequest\n \n-        class DummyForm(object):\n+        class DummyForm:\n             enableCSRFProtection = True\n \n-        class DummyAction(object):\n-\n+        class DummyAction:\n             def isExecuted(self):\n                 return True\n \n@@ -23,9 +20,9 @@ def execute(self):\n \n         form = DummyForm()\n         request = makerequest(Implicit()).REQUEST\n-        request.form[\'_authenticator\'] = createToken()\n+        request.form["_authenticator"] = createToken()\n         actions = AuthenticatedButtonActions(form, request, None)\n-        actions[\'foo\'] = DummyAction()\n+        actions["foo"] = DummyAction()\n \n         actions.execute()\n         # If we got here without raising Unauthorized, the test passed.\ndiff --git a/plone/app/z3cform/tests/test_utils.py b/plone/app/z3cform/tests/test_utils.py\nindex e6a068db..91ca2f36 100644\n--- a/plone/app/z3cform/tests/test_utils.py\n+++ b/plone/app/z3cform/tests/test_utils.py\n@@ -1,9 +1,7 @@\n-# -*- coding: utf-8 -*-\n import unittest\n \n \n class TestUnitCallCallables(unittest.TestCase):\n-\n     def test_simple(self):\n         from plone.app.z3cform.utils import call_callables\n \n@@ -11,7 +9,7 @@ def test_simple(self):\n         test_compare = 1\n         test_out = call_callables(\n             test_in,\n-            \'funny return value\',\n+            "funny return value",\n         )\n         self.assertEqual(test_out, test_compare)\n \n@@ -21,10 +19,10 @@ def test_simple_function(self):\n         def test_in(x):\n             return x\n \n-        test_compare = \'funny return value\'\n+        test_compare = "funny return value"\n         test_out = call_callables(\n             test_in,\n-            \'funny return value\',\n+            "funny return value",\n         )\n         self.assertEqual(test_out, test_compare)\n \n@@ -32,10 +30,10 @@ def test_list(self):\n         from plone.app.z3cform.utils import call_callables\n \n         test_in = [1, 2, 3, lambda x: x]\n-        test_compare = [1, 2, 3, \'funny return value\']\n+        test_compare = [1, 2, 3, "funny return value"]\n         test_out = call_callables(\n             test_in,\n-            \'funny return value\',\n+            "funny return value",\n         )\n         self.assertEqual(test_out, test_compare)\n \n@@ -43,10 +41,10 @@ def test_tuple(self):\n         from plone.app.z3cform.utils import call_callables\n \n         test_in = (1, 2, 3, lambda x: x)\n-        test_compare = (1, 2, 3, \'funny return value\')\n+        test_compare = (1, 2, 3, "funny return value")\n         test_out = call_callables(\n             test_in,\n-            \'funny return value\',\n+            "funny return value",\n         )\n         self.assertEqual(test_out, test_compare)\n \n@@ -54,73 +52,102 @@ def test_complex(self):\n         from plone.app.z3cform.utils import call_callables\n \n         test_in = {\n-            \'normal\': 123,\n-            \'list\': [1, 2, 3, lambda x: x, [11, 22, 33, lambda x: x, (44, 55, 66, lambda x: x)]],  # noqa\n-            \'tuple\': (1, 2, 3, lambda x: x, (11, 22, 33, lambda x: x, [44, 55, 66, lambda x: x])),  # noqa\n-            \'dict\': {\n-                \'subnormal\': 456,\n-                \'sublist\': [4, 5, 6, lambda x: x],\n-                \'subtuple\': (4, 5, 6, lambda x: x),\n-                \'subdict\': {\n-                    \'subsubnormal\': 789,\n-                    \'subsublist\': [7, 8, 9, lambda x: x],\n-                    \'subsubtuple\': (7, 8, 9, lambda x: x),\n+            "normal": 123,\n+            "list": [\n+                1,\n+                2,\n+                3,\n+                lambda x: x,\n+                [11, 22, 33, lambda x: x, (44, 55, 66, lambda x: x)],\n+            ],  # noqa\n+            "tuple": (\n+                1,\n+                2,\n+                3,\n+                lambda x: x,\n+                (11, 22, 33, lambda x: x, [44, 55, 66, lambda x: x]),\n+            ),  # noqa\n+            "dict": {\n+                "subnormal": 456,\n+                "sublist": [4, 5, 6, lambda x: x],\n+                "subtuple": (4, 5, 6, lambda x: x),\n+                "subdict": {\n+                    "subsubnormal": 789,\n+                    "subsublist": [7, 8, 9, lambda x: x],\n+                    "subsubtuple": (7, 8, 9, lambda x: x),\n                 },\n             },\n         }\n \n         test_compare = {\n-            \'normal\': 123,\n-            \'list\': [1, 2, 3, \'funny return value\', [11, 22, 33, \'funny return value\', (44, 55, 66, \'funny return value\')]],  # noqa\n-            \'tuple\': (1, 2, 3, \'funny return value\', (11, 22, 33, \'funny return value\', [44, 55, 66, \'funny return value\'])),  # noqa\n-            \'dict\': {\n-                \'subnormal\': 456,\n-                \'sublist\': [4, 5, 6, \'funny return value\'],\n-                \'subtuple\': (4, 5, 6, \'funny return value\'),\n-                \'subdict\': {\n-                    \'subsubnormal\': 789,\n-                    \'subsublist\': [7, 8, 9, \'funny return value\'],\n-                    \'subsubtuple\': (7, 8, 9, \'funny return value\'),\n+            "normal": 123,\n+            "list": [\n+                1,\n+                2,\n+                3,\n+                "funny return value",\n+                [11, 22, 33, "funny return value", (44, 55, 66, "funny return value")],\n+            ],  # noqa\n+            "tuple": (\n+                1,\n+                2,\n+                3,\n+                "funny return value",\n+                (11, 22, 33, "funny return value", [44, 55, 66, "funny return value"]),\n+            ),  # noqa\n+            "dict": {\n+                "subnormal": 456,\n+                "sublist": [4, 5, 6, "funny return value"],\n+                "subtuple": (4, 5, 6, "funny return value"),\n+                "subdict": {\n+                    "subsubnormal": 789,\n+                    "subsublist": [7, 8, 9, "funny return value"],\n+                    "subsubtuple": (7, 8, 9, "funny return value"),\n                 },\n             },\n         }\n \n         test_out = call_callables(\n             test_in,\n-            \'funny return value\',\n+            "funny return value",\n         )\n \n         self.assertEqual(test_out, test_compare)\n \n \n class TestUtils(unittest.TestCase):\n-\n     def test_is_absolute(self):\n         from plone.app.z3cform.utils import is_absolute\n \n-        self.assertTrue(is_absolute(\'https://plone.org/\'))\n-        self.assertTrue(is_absolute(\'http://plone.org/\'))\n-        self.assertTrue(is_absolute(\'webdav://plone.org/\'))\n-        self.assertTrue(not is_absolute(\'./path/to/site\'))\n-        self.assertTrue(not is_absolute(\'/resolveuid/\'))\n+        self.assertTrue(is_absolute("https://plone.org/"))\n+        self.assertTrue(is_absolute("http://plone.org/"))\n+        self.assertTrue(is_absolute("webdav://plone.org/"))\n+        self.assertTrue(not is_absolute("./path/to/site"))\n+        self.assertTrue(not is_absolute("/resolveuid/"))\n \n     def test_is_same_domain(self):\n         from plone.app.z3cform.utils import is_same_domain\n \n         # Those use the same protocol and are on the same domaain\n-        self.assertTrue(is_same_domain(\n-            \'https://plone.org/doc1\',\n-            \'https://plone.org/doc2/doc3\',\n-        ))\n+        self.assertTrue(\n+            is_same_domain(\n+                "https://plone.org/doc1",\n+                "https://plone.org/doc2/doc3",\n+            )\n+        )\n \n         # These are two completly different URLs\n-        self.assertTrue(not is_same_domain(\n-            \'https://domain1.com\',\n-            \'https://anotherdomain.com\',\n-        ))\n+        self.assertTrue(\n+            not is_same_domain(\n+                "https://domain1.com",\n+                "https://anotherdomain.com",\n+            )\n+        )\n \n         # Here, different transport protocols are used. Returning False.\n-        self.assertTrue(not is_same_domain(\n-            \'https://plone.org\',\n-            \'http://plone.org\',\n-        ))\n+        self.assertTrue(\n+            not is_same_domain(\n+                "https://plone.org",\n+                "http://plone.org",\n+            )\n+        )\ndiff --git a/plone/app/z3cform/tests/test_widget.py b/plone/app/z3cform/tests/test_widget.py\nindex 1c248577..008d63e1 100644\n--- a/plone/app/z3cform/tests/test_widget.py\n+++ b/plone/app/z3cform/tests/test_widget.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.z3cform.interfaces import IPloneFormLayer\n from plone.app.z3cform.tests.layer import PAZ3CForm_INTEGRATION_TESTING\n from plone.app.z3cform.wysiwyg.widget import WysiwygWidget\n@@ -14,11 +13,11 @@ class TestRequest(publisher.browser.TestRequest):\n     pass\n \n \n-class TestForm(object):\n+class TestForm:\n     context = None\n \n \n-class NoAcquisitionAware(object):\n+class NoAcquisitionAware:\n     context = None\n     request = TestRequest()\n \n@@ -41,10 +40,12 @@ def test_missing_aq_chain(self):\n         widget.form = TestForm()\n         widget.form.context = obj\n         widget.update()\n-        self.assertTrue(hasattr(widget.form.context, \'aq_chain\'))\n+        self.assertTrue(hasattr(widget.form.context, "aq_chain"))\n \n \n def test_suite():\n-    return unittest.TestSuite([\n-        unittest.makeSuite(TestWidget),\n-    ])\n+    return unittest.TestSuite(\n+        [\n+            unittest.defaultTestLoader.loadTestsFromTestCase(TestWidget),\n+        ]\n+    )\ndiff --git a/plone/app/z3cform/tests/test_widgets.py b/plone/app/z3cform/tests/test_widgets.py\nindex 90f74483..d2331384 100644\n--- a/plone/app/z3cform/tests/test_widgets.py\n+++ b/plone/app/z3cform/tests/test_widgets.py\n@@ -1,10 +1,8 @@\n-# -*- coding: utf-8 -*-\n from datetime import date\n from datetime import datetime\n from datetime import time\n from json import loads\n from lxml import html\n-from mock import Mock\n from plone.app.contentlisting.contentlisting import ContentListing\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n@@ -20,7 +18,9 @@\n from plone.supermodel.model import Schema\n from plone.testing.zca import UNIT_TESTING\n from plone.uuid.interfaces import IUUID\n-from Products.CMFPlone.interfaces import IMarkupSchema\n+from plone.base.interfaces import IMarkupSchema\n+from unittest import mock\n+from unittest.mock import Mock\n from z3c.form.form import EditForm\n from z3c.form.form import Form\n from z3c.form.interfaces import IFormLayer\n@@ -54,20 +54,18 @@\n from zope.schema.vocabulary import SimpleVocabulary\n \n import json\n-import mock\n import pytz\n-import six\n import unittest\n \n \n @provider(IVocabularyFactory)\n def example_vocabulary_factory(context, query=None):\n-    items = [u\'One\', u\'Two\', u\'Three\']\n+    items = ["One", "Two", "Three"]\n     tmp = SimpleVocabulary(\n         [\n             SimpleTerm(\n                 item.lower(),  # value\n-                token=\'token_{0}\'.format(item.lower()),\n+                token=f"token_{item.lower()}",\n                 title=item,\n             )\n             for item in items\n@@ -79,10 +77,9 @@ def example_vocabulary_factory(context, query=None):\n \n \n class BaseWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n-        self.field = TextLine(__name__=\'textlinefield\')\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n+        self.field = TextLine(__name__="textlinefield")\n         self.maxDiff = 999999\n \n     def test_widget_pattern_notimplemented(self):\n@@ -94,12 +91,12 @@ def test_widget_pattern_notimplemented(self):\n             widget._base_args,\n         )\n \n-        widget.pattern = \'example\'\n+        widget.pattern = "example"\n \n         self.assertEqual(\n             {\n-                \'pattern\': \'example\',\n-                \'pattern_options\': {},\n+                "pattern": "example",\n+                "pattern_options": {},\n             },\n             widget._base_args(),\n         )\n@@ -110,7 +107,7 @@ def test_widget_base_notimplemented(self):\n \n         widget = BaseWidget(self.request)\n         widget.field = self.field\n-        widget.pattern = \'example\'\n+        widget.pattern = "example"\n \n         self.assertRaises(\n             PatternNotImplemented,\n@@ -130,28 +127,29 @@ def test_widget_base_custom_css(self):\n \n         widget = BaseWidget(self.request)\n         widget.field = self.field\n-        widget.pattern = \'example\'\n-        widget.klass = \'very-custom-class\'\n+        widget.pattern = "example"\n+        widget.klass = "very-custom-class"\n         widget._base = InputWidget\n \n         self.assertEqual(\n             \'<input class="pat-example very-custom-class" type="text"/>\',\n-            widget.render())\n+            widget.render(),\n+        )\n \n     def test_widget_base_pattern_options_with_functions(self):\n         from plone.app.widgets.base import InputWidget\n         from plone.app.z3cform.widget import BaseWidget\n \n         widget = BaseWidget(self.request)\n-        widget.context = \'testcontext\'\n+        widget.context = "testcontext"\n         widget.field = self.field\n-        widget.pattern = \'example\'\n+        widget.pattern = "example"\n         widget._base = InputWidget\n         widget.pattern_options = {\n-            \'subdict\': {\n-                \'subsubnormal\': 789,\n-                \'subsublist\': [7, 8, 9, lambda x: x],\n-                \'subsubtuple\': (7, 8, 9, lambda x: x),\n+            "subdict": {\n+                "subsubnormal": 789,\n+                "subsublist": [7, 8, 9, lambda x: x],\n+                "subsubtuple": (7, 8, 9, lambda x: x),\n             },\n         }\n         output = widget.render()\n@@ -160,103 +158,105 @@ def test_widget_base_pattern_options_with_functions(self):\n         # <input class="pat-example"\n         #        type="text"\n         #        data-pat-example="$JSON_ENCODED_OPTIONS" />\'\n-        self.assertRegexpMatches(widget.render(), \'<input .*/>\')\n+        self.assertRegex(widget.render(), "<input .*/>")\n         # We cannot foresee how the options are encoded\n         # so we will extract the attributes with lxml\n         # and be sure that they will match what we expect\n         observed_attrib = html.fromstring(output).attrib\n         self.assertEqual(\n             sorted(observed_attrib),\n-            [\'class\', \'data-pat-example\', \'type\'],\n+            ["class", "data-pat-example", "type"],\n         )\n-        self.assertEqual(observed_attrib[\'class\'], \'pat-example\')\n-        self.assertEqual(observed_attrib[\'type\'], \'text\')\n+        self.assertEqual(observed_attrib["class"], "pat-example")\n+        self.assertEqual(observed_attrib["type"], "text")\n         self.assertDictEqual(\n-            loads(observed_attrib[\'data-pat-example\']),\n+            loads(observed_attrib["data-pat-example"]),\n             {\n-                \'subdict\': {\n-                    \'subsubnormal\': 789,\n-                    \'subsublist\': [7, 8, 9, \'testcontext\'],\n-                    \'subsubtuple\': [7, 8, 9, \'testcontext\'],\n+                "subdict": {\n+                    "subsubnormal": 789,\n+                    "subsublist": [7, 8, 9, "testcontext"],\n+                    "subsubtuple": [7, 8, 9, "testcontext"],\n                 },\n             },\n         )\n \n \n class DateWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n         from plone.app.z3cform.widget import DateWidget\n \n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n-        self.field = Date(__name__=\'datefield\')\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n+        self.field = Date(__name__="datefield")\n         self.field.required = False\n         self.widget = DateWidget(self.request)\n         self.widget.field = self.field\n-        self.widget.pattern_options = {\'date\': {\'firstDay\': 0}}\n+        self.widget.pattern_options = {"date": {"firstDay": 0}}\n \n     def test_widget(self):\n         current_year = datetime.today().year\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'pattern\': \'date-picker\',\n-                \'pattern_options\': {\'behavior\': \'native\',\n-                                    \'clear\': \'Clear\',\n-                                    \'date\': {\'firstDay\': 0},\n-                                    \'first-day\': 0,\n-                                    \'today\': \'Today\',\n-                                    \'week-numbers\': \'show\'},\n-                \'value\': \'\',\n+                "name": None,\n+                "pattern": "date-picker",\n+                "pattern_options": {\n+                    "behavior": "native",\n+                    "clear": "Clear",\n+                    "date": {"firstDay": 0},\n+                    "first-day": 0,\n+                    "today": "Today",\n+                    "week-numbers": "show",\n+                },\n+                "value": "",\n             },\n             self.widget._base_args(),\n         )\n \n     def test_widget_required(self):\n-        """Required fields should not have a "Clear" button.\n-        """\n+        """Required fields should not have a "Clear" button."""\n         self.field.required = True\n         base_args = self.widget._base_args()\n-        self.assertEqual(base_args[\'pattern_options\'][\'clear\'], False)\n+        self.assertEqual(base_args["pattern_options"]["clear"], False)\n \n     def test_data_converter(self):\n         from plone.app.z3cform.widget import DateWidgetConverter\n+\n         converter = DateWidgetConverter(self.field, self.widget)\n \n         self.assertEqual(\n             converter.field.missing_value,\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n         )\n \n         self.assertEqual(\n             date(2000, 10, 30),\n-            converter.toFieldValue(\'2000-10-30\'),\n+            converter.toFieldValue("2000-10-30"),\n         )\n \n         self.assertEqual(\n             date(21, 10, 30),\n-            converter.toFieldValue(\'21-10-30\'),\n+            converter.toFieldValue("21-10-30"),\n         )\n \n         self.assertEqual(\n-            \'\',\n+            "",\n             converter.toWidgetValue(converter.field.missing_value),\n         )\n \n         self.assertEqual(\n-            \'2000-10-30\',\n+            "2000-10-30",\n             converter.toWidgetValue(date(2000, 10, 30)),\n         )\n \n         self.assertEqual(\n-            \'21-10-30\',\n+            "21-10-30",\n             converter.toWidgetValue(date(21, 10, 30)),\n         )\n \n     def test_fieldwidget(self):\n         from plone.app.z3cform.widget import DateFieldWidget\n         from plone.app.z3cform.widget import DateWidget\n-        field = Mock(__name__=\'field\', title=u\'\', required=True)\n+\n+        field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n         widget = DateFieldWidget(field, request)\n         self.assertTrue(isinstance(widget, DateWidget))\n@@ -265,83 +265,84 @@ def test_fieldwidget(self):\n \n \n class DatetimeWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n         from plone.app.z3cform.widget import DatetimeWidget\n \n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n-        self.field = Datetime(__name__=\'datetimefield\')\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n+        self.field = Datetime(__name__="datetimefield")\n         self.field.required = False\n         self.widget = DatetimeWidget(self.request)\n         self.widget.field = self.field\n         self.widget.pattern_options = {\n-            \'date\': {\'firstDay\': 0},\n-            \'time\': {\'interval\': 15},\n+            "date": {"firstDay": 0},\n+            "time": {"interval": 15},\n         }\n \n     def test_widget(self):\n         current_year = datetime.today().year\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'pattern\': \'datetime-picker\',\n-                \'pattern_options\': {\'behavior\': \'native\',\n-                                    \'clear\': \'Clear\',\n-                                    \'date\': {\'firstDay\': 0},\n-                                    \'first-day\': 0,\n-                                    \'time\': {\'interval\': 15},\n-                                    \'today\': \'Today\',\n-                                    \'week-numbers\': \'show\'},\n-                \'value\': \'\',\n+                "name": None,\n+                "pattern": "datetime-picker",\n+                "pattern_options": {\n+                    "behavior": "native",\n+                    "clear": "Clear",\n+                    "date": {"firstDay": 0},\n+                    "first-day": 0,\n+                    "time": {"interval": 15},\n+                    "today": "Today",\n+                    "week-numbers": "show",\n+                },\n+                "value": "",\n             },\n             self.widget._base_args(),\n         )\n \n     def test_widget_required(self):\n-        """Required fields should not have a "Clear" button.\n-        """\n+        """Required fields should not have a "Clear" button."""\n         self.field.required = True\n         base_args = self.widget._base_args()\n-        self.assertEqual(base_args[\'pattern_options\'][\'clear\'], False)\n+        self.assertEqual(base_args["pattern_options"]["clear"], False)\n \n     def test_data_converter(self):\n         from plone.app.z3cform.widget import DatetimeWidgetConverter\n+\n         converter = DatetimeWidgetConverter(self.field, self.widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             converter.field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'2000-10-30T15:40\'),\n+            converter.toFieldValue("2000-10-30T15:40"),\n             datetime(2000, 10, 30, 15, 40),\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'21-10-30T15:40\'),\n+            converter.toFieldValue("21-10-30T15:40"),\n             datetime(21, 10, 30, 15, 40),\n         )\n \n         self.assertEqual(\n             converter.toWidgetValue(converter.field.missing_value),\n-            \'\',\n+            "",\n         )\n \n         self.assertEqual(\n             converter.toWidgetValue(datetime(2000, 10, 30, 15, 40)),\n-            \'2000-10-30T15:40\',\n+            "2000-10-30T15:40",\n         )\n \n         self.assertEqual(\n             converter.toWidgetValue(datetime(21, 10, 30, 15, 40)),\n-            \'21-10-30T15:40\',\n+            "21-10-30T15:40",\n         )\n \n     def test_data_converter__no_timezone(self):\n-        """When no timezone is set, don\'t apply one.\n-        """\n+        """When no timezone is set, don\'t apply one."""\n         from plone.app.z3cform.widget import DatetimeWidgetConverter\n+\n         context = Mock()\n \n         dt = datetime(2013, 11, 13, 10, 20)\n@@ -351,7 +352,7 @@ def test_data_converter__no_timezone(self):\n \n         converter = DatetimeWidgetConverter(self.field, self.widget)\n         self.assertEqual(\n-            converter.toFieldValue(\'2013-11-13T10:20\'),\n+            converter.toFieldValue("2013-11-13T10:20"),\n             datetime(2013, 11, 13, 10, 20),\n         )\n \n@@ -360,20 +361,20 @@ def test_data_converter__no_timezone(self):\n         self.widget.default_timezone = None\n \n     def test_data_converter__timezone_id(self):\n-        """When a (pytz) timezone id is set, use that.\n-        """\n+        """When a (pytz) timezone id is set, use that."""\n         from plone.app.z3cform.widget import DatetimeWidgetConverter\n+\n         context = Mock()\n \n         dt = datetime(2013, 11, 13, 10, 20)\n         setattr(context, self.field.getName(), dt)\n         self.widget.context = context\n-        self.widget.default_timezone = \'Europe/Amsterdam\'\n-        tz = pytz.timezone(\'Europe/Amsterdam\')\n+        self.widget.default_timezone = "Europe/Amsterdam"\n+        tz = pytz.timezone("Europe/Amsterdam")\n \n         converter = DatetimeWidgetConverter(self.field, self.widget)\n         self.assertEqual(\n-            converter.toFieldValue(\'2013-11-13T10:20\'),\n+            converter.toFieldValue("2013-11-13T10:20"),\n             tz.localize(datetime(2013, 11, 13, 10, 20)),\n         )\n \n@@ -386,17 +387,18 @@ def test_data_converter__timezone_callback(self):\n         use that.\n         """\n         from plone.app.z3cform.widget import DatetimeWidgetConverter\n+\n         context = Mock()\n \n         dt = datetime(2013, 11, 13, 10, 20)\n         setattr(context, self.field.getName(), dt)\n         self.widget.context = context\n-        self.widget.default_timezone = lambda context: \'Europe/Amsterdam\'\n-        tz = pytz.timezone(\'Europe/Amsterdam\')\n+        self.widget.default_timezone = lambda context: "Europe/Amsterdam"\n+        tz = pytz.timezone("Europe/Amsterdam")\n \n         converter = DatetimeWidgetConverter(self.field, self.widget)\n         self.assertEqual(\n-            converter.toFieldValue(\'2013-11-13T10:20\'),\n+            converter.toFieldValue("2013-11-13T10:20"),\n             tz.localize(datetime(2013, 11, 13, 10, 20)),\n         )\n \n@@ -407,7 +409,8 @@ def test_data_converter__timezone_callback(self):\n     def test_fieldwidget(self):\n         from plone.app.z3cform.widget import DatetimeFieldWidget\n         from plone.app.z3cform.widget import DatetimeWidget\n-        field = Mock(__name__=\'field\', title=u\'\', required=True)\n+\n+        field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n         widget = DatetimeFieldWidget(field, request)\n         self.assertTrue(isinstance(widget, DatetimeWidget))\n@@ -416,47 +419,48 @@ def test_fieldwidget(self):\n \n \n class TimeWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n         from plone.app.z3cform.widget import TimeWidget\n \n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n-        self.field = Time(__name__=\'timefield\')\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n+        self.field = Time(__name__="timefield")\n         self.field.required = False\n         self.widget = TimeWidget(self.request)\n         self.widget.field = self.field\n \n     def test_widget(self):\n-        self.assertIn("<input type=\\"time\\"", self.widget.render())\n+        self.assertIn(\'<input type="time"\', self.widget.render())\n \n     def test_data_converter(self):\n         from plone.app.z3cform.converters import TimeWidgetConverter\n+\n         converter = TimeWidgetConverter(self.field, self.widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             converter.field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'15:40\'),\n+            converter.toFieldValue("15:40"),\n             time(15, 40),\n         )\n \n         self.assertEqual(\n             converter.toWidgetValue(converter.field.missing_value),\n-            \'\',\n+            "",\n         )\n \n         self.assertEqual(\n             converter.toWidgetValue(time(15, 40)),\n-            \'15:40\',\n+            "15:40",\n         )\n \n     def test_fieldwidget(self):\n         from plone.app.z3cform.widget import TimeFieldWidget\n         from plone.app.z3cform.widget import TimeWidget\n-        field = Mock(__name__=\'field\', title=u\'\', required=True)\n+\n+        field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n         widget = TimeFieldWidget(field, request)\n         self.assertTrue(isinstance(widget, TimeWidget))\n@@ -465,46 +469,48 @@ def test_fieldwidget(self):\n \n \n class SelectWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n         alsoProvides(self.request, IFormLayer)\n \n         # ITerms Adapters are needed for data converter\n         from z3c.form import term\n \n         import zope.component\n+\n         zope.component.provideAdapter(term.CollectionTerms)\n         zope.component.provideAdapter(term.CollectionTermsVocabulary)\n         zope.component.provideAdapter(term.CollectionTermsSource)\n \n     def tearDown(self):\n         from z3c.form import term\n+\n         base.unregisterAdapter(term.CollectionTerms)\n         base.unregisterAdapter(term.CollectionTermsVocabulary)\n         base.unregisterAdapter(term.CollectionTermsSource)\n \n     def test_widget(self):\n         from plone.app.z3cform.widget import SelectWidget\n+\n         widget = SelectWidget(self.request)\n-        widget.id = \'test-widget\'\n+        widget.id = "test-widget"\n         widget.field = Choice(\n-            __name__=\'selectfield\',\n-            values=[\'one\', \'two\', \'three\'],\n+            __name__="selectfield",\n+            values=["one", "two", "three"],\n         )\n         widget.terms = widget.field.vocabulary\n         widget.field.required = True\n         self.assertEqual(\n             {\n-                \'multiple\': None,\n-                \'name\': None,\n-                \'pattern_options\': {},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": None,\n+                "name": None,\n+                "pattern_options": {},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -513,16 +519,16 @@ def test_widget(self):\n         widget.field.required = False\n         self.assertEqual(\n             {\n-                \'multiple\': None,\n-                \'name\': None,\n-                \'pattern_options\': {\'allowClear\': True},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (u\'\', u\'\'),\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": None,\n+                "name": None,\n+                "pattern_options": {"allowClear": True},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("", ""),\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -532,15 +538,15 @@ def test_widget(self):\n         widget.multiple = True\n         self.assertEqual(\n             {\n-                \'multiple\': True,\n-                \'name\': None,\n-                \'pattern_options\': {\'separator\': \';\'},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": True,\n+                "name": None,\n+                "pattern_options": {"separator": ";"},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -550,32 +556,32 @@ def test_widget(self):\n         widget.multiple = True\n         self.assertEqual(\n             {\n-                \'multiple\': True,\n-                \'name\': None,\n-                \'pattern_options\': {\'allowClear\': True, \'separator\': \';\'},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": True,\n+                "name": None,\n+                "pattern_options": {"allowClear": True, "separator": ";"},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n         )\n \n-        widget.value = \'one\'\n+        widget.value = "one"\n         self.assertEqual(\n             {\n-                \'multiple\': True,\n-                \'name\': None,\n-                \'pattern_options\': {\'allowClear\': True, \'separator\': \';\'},\n-                \'pattern\': \'select2\',\n-                \'value\': (\'one\'),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": True,\n+                "name": None,\n+                "pattern_options": {"allowClear": True, "separator": ";"},\n+                "pattern": "select2",\n+                "value": ("one"),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -583,26 +589,26 @@ def test_widget(self):\n \n     def test_widget_list_orderable(self):\n         from plone.app.z3cform.widget import SelectWidget\n+\n         widget = SelectWidget(self.request)\n-        widget.id = \'test-widget\'\n-        widget.separator = \'.\'\n+        widget.id = "test-widget"\n+        widget.separator = "."\n         widget.field = List(\n-            __name__=\'selectfield\',\n-            value_type=Choice(values=[\'one\', \'two\', \'three\']),\n+            __name__="selectfield",\n+            value_type=Choice(values=["one", "two", "three"]),\n         )\n         widget.terms = widget.field.value_type.vocabulary\n         self.assertEqual(\n             {\n-                \'multiple\': True,\n-                \'name\': None,\n-                \'pattern_options\': {\n-                    \'orderable\': True, \'separator\': \'.\'},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": True,\n+                "name": None,\n+                "pattern_options": {"orderable": True, "separator": "."},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -610,25 +616,25 @@ def test_widget_list_orderable(self):\n \n     def test_widget_tuple_orderable(self):\n         from plone.app.z3cform.widget import SelectWidget\n+\n         widget = SelectWidget(self.request)\n-        widget.id = \'test-widget\'\n+        widget.id = "test-widget"\n         widget.field = Tuple(\n-            __name__=\'selectfield\',\n-            value_type=Choice(values=[\'one\', \'two\', \'three\']),\n+            __name__="selectfield",\n+            value_type=Choice(values=["one", "two", "three"]),\n         )\n         widget.terms = widget.field.value_type.vocabulary\n         self.assertEqual(\n             {\n-                \'multiple\': True,\n-                \'name\': None,\n-                \'pattern_options\': {\n-                    \'orderable\': True, \'separator\': \';\'},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": True,\n+                "name": None,\n+                "pattern_options": {"orderable": True, "separator": ";"},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -636,25 +642,26 @@ def test_widget_tuple_orderable(self):\n \n     def test_widget_set_not_orderable(self):\n         from plone.app.z3cform.widget import SelectWidget\n+\n         widget = SelectWidget(self.request)\n-        widget.id = \'test-widget\'\n+        widget.id = "test-widget"\n         # A set is not orderable\n         widget.field = Set(\n-            __name__=\'selectfield\',\n-            value_type=Choice(values=[\'one\', \'two\', \'three\']),\n+            __name__="selectfield",\n+            value_type=Choice(values=["one", "two", "three"]),\n         )\n         widget.terms = widget.field.value_type.vocabulary\n         self.assertEqual(\n             {\n-                \'multiple\': True,\n-                \'name\': None,\n-                \'pattern_options\': {\'separator\': \';\'},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": True,\n+                "name": None,\n+                "pattern_options": {"separator": ";"},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -662,27 +669,28 @@ def test_widget_set_not_orderable(self):\n \n     def test_widget_extract(self):\n         from plone.app.z3cform.widget import SelectWidget\n+\n         widget = SelectWidget(self.request)\n         widget.field = Choice(\n-            __name__=\'selectfield\',\n-            values=[\'one\', \'two\', \'three\'],\n+            __name__="selectfield",\n+            values=["one", "two", "three"],\n         )\n-        widget.name = \'selectfield\'\n-        self.request.form[\'selectfield\'] = \'one\'\n-        self.assertEqual(widget.extract(), \'one\')\n+        widget.name = "selectfield"\n+        self.request.form["selectfield"] = "one"\n+        self.assertEqual(widget.extract(), "one")\n         widget.multiple = True\n-        self.request.form[\'selectfield\'] = \'one;two\'\n-        self.assertEqual(widget.extract(), \'one;two\')\n+        self.request.form["selectfield"] = "one;two"\n+        self.assertEqual(widget.extract(), "one;two")\n \n     def test_data_converter_list(self):\n         from plone.app.z3cform.converters import SelectWidgetConverter\n         from plone.app.z3cform.widget import SelectWidget\n \n         field = List(\n-            __name__=\'listfield\',\n+            __name__="listfield",\n             value_type=Choice(\n-                __name__=\'selectfield\',\n-                values=[\'one\', \'two\', \'three\'],\n+                __name__="selectfield",\n+                values=["one", "two", "three"],\n             ),\n         )\n         widget = SelectWidget(self.request)\n@@ -691,13 +699,13 @@ def test_data_converter_list(self):\n         converter = SelectWidgetConverter(field, widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'one;two;three\'),\n-            [\'one\', \'two\', \'three\'],\n+            converter.toFieldValue("one;two;three"),\n+            ["one", "two", "three"],\n         )\n \n         self.assertEqual(\n@@ -705,19 +713,20 @@ def test_data_converter_list(self):\n             [],\n         )\n \n-        widget.separator = \',\'\n+        widget.separator = ","\n         self.assertEqual(\n-            converter.toFieldValue(\'one,two,three\'),\n-            [\'one\', \'two\', \'three\'],\n+            converter.toFieldValue("one,two,three"),\n+            ["one", "two", "three"],\n         )\n         self.assertRaises(\n             LookupError,\n-            converter.toFieldValue, \'one;two;three\',\n+            converter.toFieldValue,\n+            "one;two;three",\n         )\n \n         self.assertEqual(\n-            converter.toWidgetValue([\'one\', \'two\', \'three\']),\n-            [\'one\', \'two\', \'three\'],\n+            converter.toWidgetValue(["one", "two", "three"]),\n+            ["one", "two", "three"],\n         )\n \n     def test_data_converter_tuple(self):\n@@ -725,10 +734,10 @@ def test_data_converter_tuple(self):\n         from plone.app.z3cform.widget import SelectWidget\n \n         field = Tuple(\n-            __name__=\'tuplefield\',\n+            __name__="tuplefield",\n             value_type=Choice(\n-                __name__=\'selectfield\',\n-                values=[\'one\', \'two\', \'three\'],\n+                __name__="selectfield",\n+                values=["one", "two", "three"],\n             ),\n         )\n         widget = SelectWidget(self.request)\n@@ -737,13 +746,13 @@ def test_data_converter_tuple(self):\n         converter = SelectWidgetConverter(field, widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'one;two;three\'),\n-            (\'one\', \'two\', \'three\'),\n+            converter.toFieldValue("one;two;three"),\n+            ("one", "two", "three"),\n         )\n \n         self.assertEqual(\n@@ -752,24 +761,25 @@ def test_data_converter_tuple(self):\n         )\n \n         self.assertEqual(\n-            converter.toWidgetValue((\'one\', \'two\', \'three\')),\n-            [\'one\', \'two\', \'three\'],\n+            converter.toWidgetValue(("one", "two", "three")),\n+            ["one", "two", "three"],\n         )\n \n     def test_data_converter_handles_empty_value(self):\n         from plone.app.z3cform.converters import SelectWidgetConverter\n         from plone.app.z3cform.widget import SelectWidget\n \n-        field = Tuple(__name__=\'tuplefield\',\n-                      value_type=Choice(__name__=\'selectfield\',\n-                                        values=[\'one\', \'two\', \'three\']))\n+        field = Tuple(\n+            __name__="tuplefield",\n+            value_type=Choice(__name__="selectfield", values=["one", "two", "three"]),\n+        )\n         widget = SelectWidget(self.request)\n         widget.field = field\n         widget.multiple = True\n         converter = SelectWidgetConverter(field, widget)\n \n         self.assertEqual(\n-            converter.toFieldValue((u\'\',)),\n+            converter.toFieldValue(("",)),\n             field.missing_value,\n         )\n \n@@ -779,37 +789,49 @@ def test_widget_optgroup(self):\n         """\n         from plone.app.z3cform.widget import SelectWidget\n         from z3c.form import term\n+\n         widget = SelectWidget(self.request)\n-        widget.field = Choice(vocabulary=vocabulary.TreeVocabulary.fromDict({\n-            (\'foo_group\', \'Foo Group\'): {\n-                (\'bar_group\', \'Bar Group\'): {},\n-                (\'qux_group\', \'Qux Group\'): {},\n-            },\n-            (\'corge_group\', \'Corge Group\'): {\n-                (\'grault_group\', \'Grault Group\'): {},\n-                (\'garply_group\', \'Garply Group\'): {},\n-            },\n-        }))\n+        widget.field = Choice(\n+            vocabulary=vocabulary.TreeVocabulary.fromDict(\n+                {\n+                    ("foo_group", "Foo Group"): {\n+                        ("bar_group", "Bar Group"): {},\n+                        ("qux_group", "Qux Group"): {},\n+                    },\n+                    ("corge_group", "Corge Group"): {\n+                        ("grault_group", "Grault Group"): {},\n+                        ("garply_group", "Garply Group"): {},\n+                    },\n+                }\n+            )\n+        )\n         # Usse term.CollectionTermsVocabulary to simulate a named vocabulary\n         # factory lookup\n         widget.terms = term.CollectionTermsVocabulary(\n-            context=None, request=self.request, form=None, field=None,\n-            widget=widget, vocabulary=widget.field.vocabulary)\n+            context=None,\n+            request=self.request,\n+            form=None,\n+            field=None,\n+            widget=widget,\n+            vocabulary=widget.field.vocabulary,\n+        )\n         widget.updateTerms()\n         html = widget.render()\n         self.assertNotIn(\n-            \'<option value="foo_group">\', html,\n-            \'Top level vocab item rendered as <option...>\')\n+            \'<option value="foo_group">\',\n+            html,\n+            "Top level vocab item rendered as <option...>",\n+        )\n         self.assertIn(\n-            \'<optgroup label="Foo Group">\', html,\n-            \'Rendered select widget missing an <optgroup...>\')\n+            \'<optgroup label="Foo Group">\',\n+            html,\n+            "Rendered select widget missing an <optgroup...>",\n+        )\n \n         base_args = widget._base_args()\n         pattern_widget = widget._base(**base_args)\n         items = pattern_widget.items\n-        self.assertIsInstance(\n-            items, dict,\n-            \'Wrong widget items type\')\n+        self.assertIsInstance(items, dict, "Wrong widget items type")\n \n \n class AjaxSelectWidgetTests(unittest.TestCase):\n@@ -818,50 +840,51 @@ class AjaxSelectWidgetTests(unittest.TestCase):\n     maxDiff = None\n \n     def setUp(self):\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n-        provideUtility(example_vocabulary_factory, name=u\'example\')\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n+        provideUtility(example_vocabulary_factory, name="example")\n \n     def test_widget(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n+\n         widget = AjaxSelectWidget(self.request)\n         widget.update()\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\'separator\': \';\'},\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {"separator": ";"},\n             },\n             widget._base_args(),\n         )\n \n-        widget.vocabulary = \'example\'\n+        widget.vocabulary = "example"\n         self.assertEqual(\n             widget._base_args(),\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\n-                    \'vocabularyUrl\': \'/@@getVocabulary?name=example\',\n-                    \'separator\': \';\',\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {\n+                    "vocabularyUrl": "/@@getVocabulary?name=example",\n+                    "separator": ";",\n                 },\n             },\n         )\n \n-        widget.value = \'token_three;token_two\'\n+        widget.value = "token_three;token_two"\n         self.assertDictEqual(\n             {\n-                \'name\': None,\n-                \'value\': \'token_three;token_two\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\n-                    \'vocabularyUrl\': \'/@@getVocabulary?name=example\',\n-                    \'initialValues\': {\n-                        \'token_three\': u\'Three\',\n-                        \'token_two\': u\'Two\',\n+                "name": None,\n+                "value": "token_three;token_two",\n+                "pattern": "select2",\n+                "pattern_options": {\n+                    "vocabularyUrl": "/@@getVocabulary?name=example",\n+                    "initialValues": {\n+                        "token_three": "Three",\n+                        "token_two": "Two",\n                     },\n-                    \'separator\': \';\',\n+                    "separator": ";",\n                 },\n             },\n             widget._base_args(),\n@@ -869,43 +892,46 @@ def test_widget(self):\n \n     def test_widget_list_orderable(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n+\n         widget = AjaxSelectWidget(self.request)\n-        widget.field = List(__name__=\'selectfield\')\n+        widget.field = List(__name__="selectfield")\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\'orderable\': True, \'separator\': \';\'},\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {"orderable": True, "separator": ";"},\n             },\n             widget._base_args(),\n         )\n \n     def test_widget_tuple_orderable(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n+\n         widget = AjaxSelectWidget(self.request)\n-        widget.field = Tuple(__name__=\'selectfield\')\n+        widget.field = Tuple(__name__="selectfield")\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\'orderable\': True, \'separator\': \';\'},\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {"orderable": True, "separator": ";"},\n             },\n             widget._base_args(),\n         )\n \n     def test_widget_set_not_orderable(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n+\n         widget = AjaxSelectWidget(self.request)\n         # A set is not orderable\n-        widget.field = Set(__name__=\'selectfield\')\n+        widget.field = Set(__name__="selectfield")\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\'separator\': \';\'},\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {"separator": ";"},\n             },\n             widget._base_args(),\n         )\n@@ -913,22 +939,22 @@ def test_widget_set_not_orderable(self):\n     def test_widget_choice(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n         from zope.schema.interfaces import ISource\n+\n         widget = AjaxSelectWidget(self.request)\n         source = Mock()\n         alsoProvides(source, ISource)\n-        widget.field = Choice(__name__=\'choicefield\', source=source)\n-        widget.name = \'choicefield\'\n+        widget.field = Choice(__name__="choicefield", source=source)\n+        widget.name = "choicefield"\n         self.assertEqual(\n             {\n-                \'name\': \'choicefield\',\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\n-                    \'separator\': \';\',\n-                    \'maximumSelectionSize\': 1,\n-                    \'allowNewItems\': \'false\',\n-                    \'vocabularyUrl\':\n-                        \'http://127.0.0.1/++widget++choicefield/@@getSource\',\n+                "name": "choicefield",\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {\n+                    "separator": ";",\n+                    "maximumSelectionSize": 1,\n+                    "allowNewItems": "false",\n+                    "vocabularyUrl": "http://127.0.0.1/++widget++choicefield/@@getSource",\n                 },\n             },\n             widget._base_args(),\n@@ -936,32 +962,33 @@ def test_widget_choice(self):\n \n     def test_widget_addform_url_on_addform(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n+\n         widget = AjaxSelectWidget(self.request)\n         form = Mock(parentForm=None)\n         from z3c.form.interfaces import IAddForm\n         from zope.interface import directlyProvides  # noqa\n+\n         directlyProvides(form, IAddForm)  # noqa\n-        form.request = {\'URL\': \'http://addform_url\'}\n+        form.request = {"URL": "http://addform_url"}\n         widget.form = form\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\'separator\': \';\'},\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {"separator": ";"},\n             },\n             widget._base_args(),\n         )\n-        widget.vocabulary = \'vocabulary1\'\n+        widget.vocabulary = "vocabulary1"\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\n-                    \'separator\': \';\',\n-                    \'vocabularyUrl\':\n-                    \'http://addform_url/@@getVocabulary?name=vocabulary1\',\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {\n+                    "separator": ";",\n+                    "vocabularyUrl": "http://addform_url/@@getVocabulary?name=vocabulary1",\n                 },\n             },\n             widget._base_args(),\n@@ -971,19 +998,19 @@ def test_data_converter_list(self):\n         from plone.app.z3cform.converters import AjaxSelectWidgetConverter\n         from plone.app.z3cform.widget import AjaxSelectWidget\n \n-        field = List(__name__=\'listfield\', value_type=TextLine())\n+        field = List(__name__="listfield", value_type=TextLine())\n         widget = AjaxSelectWidget(self.request)\n         widget.field = field\n         converter = AjaxSelectWidgetConverter(field, widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'123;456;789\'),\n-            [\'123\', \'456\', \'789\'],\n+            converter.toFieldValue("123;456;789"),\n+            ["123", "456", "789"],\n         )\n \n         self.assertEqual(\n@@ -992,8 +1019,8 @@ def test_data_converter_list(self):\n         )\n \n         self.assertEqual(\n-            converter.toWidgetValue([\'123\', \'456\', \'789\']),\n-            \'123;456;789\',\n+            converter.toWidgetValue(["123", "456", "789"]),\n+            "123;456;789",\n         )\n \n     def test_data_converter_collection_with_vocabulary(self):\n@@ -1001,9 +1028,9 @@ def test_data_converter_collection_with_vocabulary(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n \n         field = Tuple(\n-            __name__=\'listfield\',\n+            __name__="listfield",\n             value_type=Choice(\n-                vocabulary=\'example\',\n+                vocabulary="example",\n             ),\n         )\n         widget = AjaxSelectWidget(self.request)\n@@ -1011,13 +1038,13 @@ def test_data_converter_collection_with_vocabulary(self):\n         converter = AjaxSelectWidgetConverter(field, widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'token_one;token_two;token_three\'),\n-            (\'one\', \'two\', \'three\'),\n+            converter.toFieldValue("token_one;token_two;token_three"),\n+            ("one", "two", "three"),\n         )\n \n         self.assertEqual(\n@@ -1026,27 +1053,27 @@ def test_data_converter_collection_with_vocabulary(self):\n         )\n \n         self.assertEqual(\n-            converter.toWidgetValue([\'123\', \'456\', \'789\']),\n-            \'123;456;789\',\n+            converter.toWidgetValue(["123", "456", "789"]),\n+            "123;456;789",\n         )\n \n     def test_data_converter_tuple(self):\n         from plone.app.z3cform.converters import AjaxSelectWidgetConverter\n         from plone.app.z3cform.widget import AjaxSelectWidget\n \n-        field = Tuple(__name__=\'tuplefield\', value_type=TextLine())\n+        field = Tuple(__name__="tuplefield", value_type=TextLine())\n         widget = AjaxSelectWidget(self.request)\n         widget.field = field\n         converter = AjaxSelectWidgetConverter(field, widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'123;456;789\'),\n-            (\'123\', \'456\', \'789\'),\n+            converter.toFieldValue("123;456;789"),\n+            ("123", "456", "789"),\n         )\n \n         self.assertEqual(\n@@ -1055,14 +1082,15 @@ def test_data_converter_tuple(self):\n         )\n \n         self.assertEqual(\n-            converter.toWidgetValue((\'123\', \'456\', \'789\')),\n-            \'123;456;789\',\n+            converter.toWidgetValue(("123", "456", "789")),\n+            "123;456;789",\n         )\n \n     def test_fieldwidget(self):\n         from plone.app.z3cform.widget import AjaxSelectFieldWidget\n         from plone.app.z3cform.widget import AjaxSelectWidget\n-        field = Mock(__name__=\'field\', title=u\'\', required=True)\n+\n+        field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n         widget = AjaxSelectFieldWidget(field, request)\n         self.assertTrue(isinstance(widget, AjaxSelectWidget))\n@@ -1072,7 +1100,8 @@ def test_fieldwidget(self):\n     def test_fieldwidget_sequence(self):\n         from plone.app.z3cform.widget import AjaxSelectFieldWidget\n         from plone.app.z3cform.widget import AjaxSelectWidget\n-        field = Mock(__name__=\'field\', title=u\'\', required=True)\n+\n+        field = Mock(__name__="field", title="", required=True)\n         vocabulary = Mock()\n         request = Mock()\n         widget = AjaxSelectFieldWidget(field, vocabulary, request)\n@@ -1086,74 +1115,76 @@ class AjaxSelectWidgetIntegrationTests(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n \n     def test_keywords_can_add(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n \n-        portal = self.layer[\'portal\']\n-        setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+        portal = self.layer["portal"]\n+        setRoles(portal, TEST_USER_ID, ["Manager"])\n         widget = AjaxSelectWidget(self.request)\n         widget.context = portal\n-        widget.vocabulary = \'plone.app.vocabularies.Keywords\'\n+        widget.vocabulary = "plone.app.vocabularies.Keywords"\n         self.assertEqual(\n-            widget._base_args()[\'pattern_options\'][\'allowNewItems\'],\n-            \'true\',\n+            widget._base_args()["pattern_options"]["allowNewItems"],\n+            "true",\n         )\n \n     def test_keywords_cannot_add(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n \n-        portal = self.layer[\'portal\']\n+        portal = self.layer["portal"]\n         widget = AjaxSelectWidget(self.request)\n         widget.context = portal\n-        widget.vocabulary = \'plone.app.vocabularies.Keywords\'\n+        widget.vocabulary = "plone.app.vocabularies.Keywords"\n         self.assertEqual(\n-            widget._base_args()[\'pattern_options\'][\'allowNewItems\'],\n-            \'false\',\n+            widget._base_args()["pattern_options"]["allowNewItems"],\n+            "false",\n         )\n \n \n class QueryStringWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n \n     def test_converter_toWidgetValue(self):\n         from plone.app.z3cform.converters import QueryStringDataConverter\n+\n         converter = QueryStringDataConverter(List(), None)\n-        self.assertEqual(converter.toWidgetValue(None), u\'[]\')\n-        self.assertEqual(converter.toWidgetValue([]), u\'[]\')\n+        self.assertEqual(converter.toWidgetValue(None), "[]")\n+        self.assertEqual(converter.toWidgetValue([]), "[]")\n \n     def test_converter_empty_value(self):\n         from plone.app.z3cform.converters import QueryStringDataConverter\n+\n         converter = QueryStringDataConverter(List(), None)\n-        self.assertEqual(converter.toFieldValue(u\'\'), None)\n-        self.assertEqual(converter.toFieldValue(u\'[]\'), None)\n+        self.assertEqual(converter.toFieldValue(""), None)\n+        self.assertEqual(converter.toFieldValue("[]"), None)\n \n     @mock.patch(\n-        \'plone.app.widgets.utils.get_date_options\',\n+        "plone.app.widgets.utils.get_date_options",\n         new=lambda *args, **kwargs: None,\n     )\n     @mock.patch(\n-        \'plone.app.widgets.utils.get_relateditems_options\',\n+        "plone.app.widgets.utils.get_relateditems_options",\n         new=lambda *args, **kwargs: None,\n     )\n     def test_widget(self):\n         from plone.app.z3cform.widget import QueryStringWidget\n+\n         widget = QueryStringWidget(self.request)\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'querystring\',\n-                \'pattern_options\': {\n-                    \'indexOptionsUrl\': \'/@@qsOptions\',\n-                    \'previewCountURL\': \'/@@querybuildernumberofresults\',\n-                    \'previewURL\': \'/@@querybuilder_html_results\',\n-                    \'patternAjaxSelectOptions\': {\'separator\': \';\'},\n-                    \'patternDateOptions\': None,\n-                    \'patternRelateditemsOptions\': None,\n+                "name": None,\n+                "value": "",\n+                "pattern": "querystring",\n+                "pattern_options": {\n+                    "indexOptionsUrl": "/@@qsOptions",\n+                    "previewCountURL": "/@@querybuildernumberofresults",\n+                    "previewURL": "/@@querybuilder_html_results",\n+                    "patternAjaxSelectOptions": {"separator": ";"},\n+                    "patternDateOptions": None,\n+                    "patternRelateditemsOptions": None,\n                 },\n             },\n             widget._base_args(),\n@@ -1165,10 +1196,10 @@ class RelatedItemsWidgetIntegrationTests(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n+        self.portal = self.layer["portal"]\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n         setRequest(self.request)\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def assertDictContainsSubsetReplacement(self, actual, expected):\n         """assertDictContainsSubset was removed in Python 3.2, see:\n@@ -1180,10 +1211,11 @@ def assertDictContainsSubsetReplacement(self, actual, expected):\n \n     def test_related_items_widget(self):\n         from plone.app.z3cform.widget import RelatedItemsWidget\n-        EXPECTED_ROOT_PATH = \'/plone\'\n-        EXPECTED_ROOT_URL = \'http://nohost/plone\'\n-        EXPECTED_BASE_PATH = \'/plone\'\n-        EXPECTED_VOCAB_URL = \'http://nohost/plone/@@getVocabulary?name=plone.app.vocabularies.Catalog\'  # noqa\n+\n+        EXPECTED_ROOT_PATH = "/plone"\n+        EXPECTED_ROOT_URL = "http://nohost/plone"\n+        EXPECTED_BASE_PATH = "/plone"\n+        EXPECTED_VOCAB_URL = "http://nohost/plone/@@getVocabulary?name=plone.app.vocabularies.Catalog"  # noqa\n \n         widget = RelatedItemsWidget(self.request)\n         widget.context = self.portal\n@@ -1193,31 +1225,32 @@ def test_related_items_widget(self):\n \n         self.assertEqual(\n             EXPECTED_ROOT_PATH,\n-            result[\'pattern_options\'][\'rootPath\'],\n+            result["pattern_options"]["rootPath"],\n         )\n         self.assertEqual(\n             EXPECTED_ROOT_URL,\n-            result[\'pattern_options\'][\'rootUrl\'],\n+            result["pattern_options"]["rootUrl"],\n         )\n         self.assertEqual(\n             EXPECTED_BASE_PATH,\n-            result[\'pattern_options\'][\'basePath\'],\n+            result["pattern_options"]["basePath"],\n         )\n         self.assertEqual(\n             EXPECTED_VOCAB_URL,\n-            result[\'pattern_options\'][\'vocabularyUrl\'],\n+            result["pattern_options"]["vocabularyUrl"],\n         )\n \n     def test_related_items_widget_nav_root(self):\n         from plone.app.layout.navigation.interfaces import INavigationRoot\n         from plone.app.z3cform.widget import RelatedItemsWidget\n-        EXPECTED_ROOT_PATH = \'/plone\'\n-        EXPECTED_ROOT_URL = \'http://nohost/plone\'\n-        EXPECTED_BASE_PATH = \'/plone/subfolder\'\n-        EXPECTED_VOCAB_URL = \'http://nohost/plone/@@getVocabulary?name=plone.app.vocabularies.Catalog\'  # noqa\n \n-        self.portal.invokeFactory(\'Folder\', \'subfolder\')\n-        subfolder = self.portal[\'subfolder\']\n+        EXPECTED_ROOT_PATH = "/plone"\n+        EXPECTED_ROOT_URL = "http://nohost/plone"\n+        EXPECTED_BASE_PATH = "/plone/subfolder"\n+        EXPECTED_VOCAB_URL = "http://nohost/plone/@@getVocabulary?name=plone.app.vocabularies.Catalog"  # noqa\n+\n+        self.portal.invokeFactory("Folder", "subfolder")\n+        subfolder = self.portal["subfolder"]\n         alsoProvides(subfolder, INavigationRoot)\n \n         widget = RelatedItemsWidget(self.request)\n@@ -1227,27 +1260,25 @@ def test_related_items_widget_nav_root(self):\n \n         self.assertEqual(\n             EXPECTED_ROOT_PATH,\n-            result[\'pattern_options\'][\'rootPath\'],\n+            result["pattern_options"]["rootPath"],\n         )\n         self.assertEqual(\n             EXPECTED_ROOT_URL,\n-            result[\'pattern_options\'][\'rootUrl\'],\n+            result["pattern_options"]["rootUrl"],\n         )\n         self.assertEqual(\n             EXPECTED_BASE_PATH,\n-            result[\'pattern_options\'][\'basePath\'],\n+            result["pattern_options"]["basePath"],\n         )\n         self.assertEqual(\n             EXPECTED_VOCAB_URL,\n-            result[\'pattern_options\'][\'vocabularyUrl\'],\n+            result["pattern_options"]["vocabularyUrl"],\n         )\n \n \n class IRelationsType(Interface):\n-    single = RelationChoice(title=u\'Single\',\n-                            required=False, values=[])\n-    multiple = RelationList(title=u\'Multiple (Relations field)\',\n-                            required=False)\n+    single = RelationChoice(title="Single", required=False, values=[])\n+    multiple = RelationList(title="Multiple (Relations field)", required=False)\n \n \n class RelatedItemsWidgetTemplateIntegrationTests(unittest.TestCase):\n@@ -1255,38 +1286,39 @@ class RelatedItemsWidgetTemplateIntegrationTests(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_related_items_widget_display_template(self):\n-        rel_fti = DexterityFTI(\n-            \'RelationsType\',\n-            schema=IRelationsType.__identifier__\n-        )\n-        self.portal.portal_types._setObject(\'RelationsType\', rel_fti)\n+        rel_fti = DexterityFTI("RelationsType", schema=IRelationsType.__identifier__)\n+        self.portal.portal_types._setObject("RelationsType", rel_fti)\n \n         intids = getUtility(IIntIds)\n \n-        self.portal.invokeFactory(\'RelationsType\', \'source\', title=u\'A Source\')\n-        self.portal.invokeFactory(\'RelationsType\', \'target\', title=u\'A Target\')\n-        self.portal.invokeFactory(\'Document\', \'doc\', title=u\'A Document\')\n-        source = self.portal[\'source\']\n-        target = self.portal[\'target\']\n-        doc = self.portal[\'doc\']\n+        self.portal.invokeFactory("RelationsType", "source", title="A Source")\n+        self.portal.invokeFactory("RelationsType", "target", title="A Target")\n+        self.portal.invokeFactory("Document", "doc", title="A Document")\n+        source = self.portal["source"]\n+        target = self.portal["target"]\n+        doc = self.portal["doc"]\n \n         # Add some relations\n         source.single = RelationValue(intids.getId(target))\n-        source.multiple = [RelationValue(intids.getId(target)), RelationValue(intids.getId(doc))]\n+        source.multiple = [\n+            RelationValue(intids.getId(target)),\n+            RelationValue(intids.getId(doc)),\n+        ]\n \n         # Update relations\n         from zope.event import notify\n         from zope.lifecycleevent import ObjectModifiedEvent\n+\n         notify(ObjectModifiedEvent(source))\n-        default_view = source.restrictedTraverse(\'@@view\')\n+        default_view = source.restrictedTraverse("@@view")\n         default_view.update()\n \n-        single = default_view.w[\'single\']\n+        single = default_view.w["single"]\n         self.assertIsInstance(single, RelatedItemsWidget)\n         self.assertTrue(single.value, target.UID())\n         items = single.items()\n@@ -1295,14 +1327,19 @@ def test_related_items_widget_display_template(self):\n \n         template = getMultiAdapter(\n             (source, self.request, single.form, single.field, single),\n-            IPageTemplate, name=single.mode)\n-        self.assertTrue(template.filename.endswith(\'relateditems_display.pt\'))\n+            IPageTemplate,\n+            name=single.mode,\n+        )\n+        self.assertTrue(template.filename.endswith("relateditems_display.pt"))\n         html = template(single)\n-        self.assertIn(\'<span class="contenttype-relationstype state-missing-value url">A Target</span>\', html)\n+        self.assertIn(\n+            \'<span class="contenttype-relationstype state-missing-value url">A Target</span>\',\n+            html,\n+        )\n \n-        multiple = default_view.w[\'multiple\']\n+        multiple = default_view.w["multiple"]\n         self.assertIsInstance(multiple, RelatedItemsWidget)\n-        self.assertTrue(multiple.value, \';\'.join([target.UID(), doc.UID()]))\n+        self.assertTrue(multiple.value, ";".join([target.UID(), doc.UID()]))\n         items = multiple.items()\n         self.assertIsInstance(items, ContentListing)\n         self.assertTrue(items[0].UID, target.UID())\n@@ -1310,42 +1347,51 @@ def test_related_items_widget_display_template(self):\n \n         template = getMultiAdapter(\n             (source, self.request, multiple.form, multiple.field, multiple),\n-            IPageTemplate, name=multiple.mode)\n-        self.assertTrue(template.filename.endswith(\'relateditems_display.pt\'))\n+            IPageTemplate,\n+            name=multiple.mode,\n+        )\n+        self.assertTrue(template.filename.endswith("relateditems_display.pt"))\n         html = template(multiple)\n-        self.assertIn(\'<span class="contenttype-relationstype state-missing-value url">A Target</span>\', html)\n-        self.assertIn(\'<span class="contenttype-document state-missing-value url">A Document</span>\', html)\n+        self.assertIn(\n+            \'<span class="contenttype-relationstype state-missing-value url">A Target</span>\',\n+            html,\n+        )\n+        self.assertIn(\n+            \'<span class="contenttype-document state-missing-value url">A Document</span>\',\n+            html,\n+        )\n \n \n class RelatedItemsWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n \n     @mock.patch(\n-        \'plone.app.widgets.utils.getToolByName\',\n-        new=Mock(return_value=Mock(return_value=\'testuser\')),\n+        "plone.app.widgets.utils.getToolByName",\n+        new=Mock(return_value=Mock(return_value="testuser")),\n     )\n     def test_single_selection(self):\n         """The pattern_options value for maximumSelectionSize should\n         be 1 when the field only allows a single selection."""\n         from plone.app.z3cform.widget import RelatedItemsFieldWidget\n-        context = Mock(absolute_url=lambda: \'fake_url\',\n-                       getPhysicalPath=lambda: [\'\', \'site\'])\n+\n+        context = Mock(\n+            absolute_url=lambda: "fake_url", getPhysicalPath=lambda: ["", "site"]\n+        )\n         field = Choice(\n-            __name__=\'selectfield\',\n-            values=[\'one\', \'two\', \'three\'],\n+            __name__="selectfield",\n+            values=["one", "two", "three"],\n         )\n         widget = RelatedItemsFieldWidget(field, self.request)\n         widget.context = context\n         widget.update()\n         base_args = widget._base_args()\n-        pattern_options = base_args[\'pattern_options\']\n-        self.assertEqual(pattern_options.get(\'maximumSelectionSize\', 0), 1)\n+        pattern_options = base_args["pattern_options"]\n+        self.assertEqual(pattern_options.get("maximumSelectionSize", 0), 1)\n \n     @mock.patch(\n-        \'plone.app.widgets.utils.getToolByName\',\n-        new=Mock(return_value=Mock(return_value=\'testuser\')),\n+        "plone.app.widgets.utils.getToolByName",\n+        new=Mock(return_value=Mock(return_value="testuser")),\n     )\n     def test_multiple_selection(self):\n         """The pattern_options key maximumSelectionSize shouldn\'t be\n@@ -1354,30 +1400,34 @@ def test_multiple_selection(self):\n         from zope.schema.interfaces import ISource\n         from zope.schema.vocabulary import VocabularyRegistry\n \n-        context = Mock(absolute_url=lambda: \'fake_url\',\n-                       getPhysicalPath=lambda: [\'\', \'site\'])\n+        context = Mock(\n+            absolute_url=lambda: "fake_url", getPhysicalPath=lambda: ["", "site"]\n+        )\n         field = List(\n-            __name__=\'selectfield\',\n-            value_type=Choice(vocabulary=\'foobar\'),\n+            __name__="selectfield",\n+            value_type=Choice(vocabulary="foobar"),\n         )\n         widget = RelatedItemsFieldWidget(field, self.request)\n         widget.context = context\n \n         vocab = Mock()\n         alsoProvides(vocab, ISource)\n-        with mock.patch.object(VocabularyRegistry, \'get\', return_value=vocab):\n+        with mock.patch.object(VocabularyRegistry, "get", return_value=vocab):\n             widget.update()\n             base_args = widget._base_args()\n-        patterns_options = base_args[\'pattern_options\']\n-        self.assertFalse(\'maximumSelectionSize\' in patterns_options)\n+        patterns_options = base_args["pattern_options"]\n+        self.assertFalse("maximumSelectionSize" in patterns_options)\n         self.assertEqual(\n-            patterns_options[\'vocabularyUrl\'],\n-            \'/@@getVocabulary?name=foobar&field=selectfield\',\n+            patterns_options["vocabularyUrl"],\n+            "/@@getVocabulary?name=foobar&field=selectfield",\n         )\n \n     def test_converter_RelationChoice(self):\n-        from plone.app.z3cform.converters import RelationChoiceRelatedItemsWidgetConverter\n-        brain = Mock(getObject=Mock(return_value=\'obj\'))\n+        from plone.app.z3cform.converters import (\n+            RelationChoiceRelatedItemsWidgetConverter,\n+        )\n+\n+        brain = Mock(getObject=Mock(return_value="obj"))\n         portal_catalog = Mock(return_value=[brain])\n         widget = Mock()\n         converter = RelationChoiceRelatedItemsWidgetConverter(\n@@ -1386,95 +1436,98 @@ def test_converter_RelationChoice(self):\n         )\n \n         with mock.patch(\n-            \'plone.app.z3cform.converters.IUUID\',\n-            return_value=\'id\',\n+            "plone.app.z3cform.converters.IUUID",\n+            return_value="id",\n         ):\n-            self.assertEqual(converter.toWidgetValue(\'obj\'), \'id\')\n+            self.assertEqual(converter.toWidgetValue("obj"), "id")\n         self.assertEqual(converter.toWidgetValue(None), None)\n \n         with mock.patch(\n-            \'plone.app.z3cform.converters.getToolByName\',\n+            "plone.app.z3cform.converters.getToolByName",\n             return_value=portal_catalog,\n         ):\n-            self.assertEqual(converter.toFieldValue(\'id\'), \'obj\')\n+            self.assertEqual(converter.toFieldValue("id"), "obj")\n         self.assertEqual(converter.toFieldValue(None), None)\n \n     def test_converter_RelationList(self):\n         from plone.app.z3cform.converters import RelatedItemsDataConverter\n         from z3c.relationfield.interfaces import IRelationList\n+\n         field = List()\n         alsoProvides(field, IRelationList)\n-        brain1 = Mock(getObject=Mock(return_value=\'obj1\'), UID=\'id1\')\n-        brain2 = Mock(getObject=Mock(return_value=\'obj2\'), UID=\'id2\')\n+        brain1 = Mock(getObject=Mock(return_value="obj1"), UID="id1")\n+        brain2 = Mock(getObject=Mock(return_value="obj2"), UID="id2")\n         portal_catalog = Mock(return_value=[brain1, brain2])\n-        widget = Mock(separator=\';\')\n+        widget = Mock(separator=";")\n         converter = RelatedItemsDataConverter(field, widget)\n \n         self.assertEqual(converter.toWidgetValue(None), None)\n         with mock.patch(\n-            \'plone.app.z3cform.converters.IUUID\',\n-            side_effect=[\'id1\', \'id2\'],\n+            "plone.app.z3cform.converters.IUUID",\n+            side_effect=["id1", "id2"],\n         ):\n             self.assertEqual(\n-                converter.toWidgetValue([\'obj1\', \'obj2\']),\n-                \'id1;id2\',\n+                converter.toWidgetValue(["obj1", "obj2"]),\n+                "id1;id2",\n             )\n \n         self.assertEqual(converter.toFieldValue(None), None)\n         with mock.patch(\n-            \'plone.app.z3cform.converters.getToolByName\',\n+            "plone.app.z3cform.converters.getToolByName",\n             return_value=portal_catalog,\n         ):\n             self.assertEqual(\n-                converter.toFieldValue(\'id1;id2\'),\n-                [\'obj1\', \'obj2\'],\n+                converter.toFieldValue("id1;id2"),\n+                ["obj1", "obj2"],\n             )\n \n     def test_converter_List_of_Choice(self):\n         from plone.app.z3cform.converters import RelatedItemsDataConverter\n+\n         fields = (\n             List(),\n             List(value_type=TextLine()),\n             List(value_type=BytesLine()),\n-            List(value_type=Choice(values=[\'one\', \'two\', \'three\'])),\n+            List(value_type=Choice(values=["one", "two", "three"])),\n         )\n         for field in fields:\n             expected_value_type = getattr(\n                 field.value_type,\n-                \'_type\',\n-                six.text_type,\n+                "_type",\n+                str,\n             )\n             if expected_value_type is None:\n-                expected_value_type = six.text_type\n-            widget = Mock(separator=\';\')\n+                expected_value_type = str\n+            widget = Mock(separator=";")\n             converter = RelatedItemsDataConverter(field, widget)\n \n             self.assertEqual(converter.toWidgetValue(None), None)\n             self.assertEqual(\n-                converter.toWidgetValue([\'id1\', \'id2\']),\n-                \'id1;id2\',\n+                converter.toWidgetValue(["id1", "id2"]),\n+                "id1;id2",\n             )\n \n             self.assertEqual(converter.toFieldValue(None), None)\n-            if not six.PY2 and expected_value_type == six.binary_type:\n-                expected = [b\'id1\', b\'id2\']\n+            if expected_value_type == bytes:\n+                expected = [b"id1", b"id2"]\n             else:\n-                expected = [\'id1\', \'id2\']\n+                expected = ["id1", "id2"]\n             self.assertEqual(\n-                converter.toFieldValue(\'id1;id2\'),\n+                converter.toFieldValue("id1;id2"),\n                 expected,\n             )\n \n             self.assertEqual(converter.toFieldValue(None), None)\n             self.assertEqual(\n-                type(converter.toFieldValue(\'id1;id2\')[0]),\n+                type(converter.toFieldValue("id1;id2")[0]),\n                 expected_value_type,\n             )\n \n     def test_fieldwidget(self):\n         from plone.app.z3cform.widget import RelatedItemsFieldWidget\n         from plone.app.z3cform.widget import RelatedItemsWidget\n-        field = Mock(__name__=\'field\', title=u\'\', required=True)\n+\n+        field = Mock(__name__="field", title="", required=True)\n         vocabulary = Mock()\n         request = Mock()\n         widget = RelatedItemsFieldWidget(field, vocabulary, request)\n@@ -1485,18 +1538,19 @@ def test_fieldwidget(self):\n \n def add_mock_fti(portal):\n     # Fake DX Type\n-    fti = DexterityFTI(\'dx_mock\')\n-    portal.portal_types._setObject(\'dx_mock\', fti)\n-    fti.klass = \'plone.dexterity.content.Item\'\n-    fti.schema = \'plone.app.widgets.tests.test_dx.IMockSchema\'\n+    fti = DexterityFTI("dx_mock")\n+    portal.portal_types._setObject("dx_mock", fti)\n+    fti.klass = "plone.dexterity.content.Item"\n+    fti.schema = "plone.app.widgets.tests.test_dx.IMockSchema"\n     fti.filter_content_types = False\n-    fti.behaviors = (\'plone.app.dexterity.behaviors.metadata.IBasic\',)\n+    fti.behaviors = ("plone.app.dexterity.behaviors.metadata.IBasic",)\n \n \n def _custom_field_widget(field, request):\n     from plone.app.z3cform.widget import AjaxSelectWidget\n+\n     widget = FieldWidget(field, AjaxSelectWidget(request))\n-    widget.vocabulary = \'plone.app.vocabularies.PortalTypes\'\n+    widget.vocabulary = "plone.app.vocabularies.PortalTypes"\n     return widget\n \n \n@@ -1507,17 +1561,17 @@ class RichTextWidgetTests(unittest.TestCase):\n     def setUp(self):\n         from plone.app.textfield import RichText as RichTextField\n \n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n         # since we are using a plone integration layer, we do\n         # not need to use the TestRequest class and we do not want\n         # to since the tinymce pattern requires a more properly\n         # setup zope2 request object to work correctly in tests\n-        self.request = self.layer[\'request\']\n+        self.request = self.layer["request"]\n \n         class IWithText(Interface):\n-            text = RichTextField(title=u\'Text\')\n+            text = RichTextField(title="Text")\n \n-        self.field = IWithText[\'text\']\n+        self.field = IWithText["text"]\n \n     def test_widget_params(self):\n         from plone.app.z3cform.widget import RichTextWidget\n@@ -1527,27 +1581,27 @@ def test_widget_params(self):\n         widget.context = self.portal\n         widget.update()\n         base_args = widget._base_args()\n-        self.assertEqual(base_args[\'name\'], \'text\')\n-        self.assertEqual(base_args[\'value\'], u\'\')\n-        self.assertEqual(base_args[\'pattern\'], \'tinymce\')\n+        self.assertEqual(base_args["name"], "text")\n+        self.assertEqual(base_args["value"], "")\n+        self.assertEqual(base_args["pattern"], "tinymce")\n \n-        prependToUrl = \'/plone/resolveuid/\'\n+        prependToUrl = "/plone/resolveuid/"\n         self.assertEqual(\n-            base_args[\'pattern_options\'][\'prependToUrl\'],\n+            base_args["pattern_options"]["prependToUrl"],\n             prependToUrl,\n         )\n         self.assertEqual(\n-            base_args[\'pattern_options\'][\'upload\'][\'relativePath\'],\n-            \'@@fileUpload\',\n+            base_args["pattern_options"]["upload"]["relativePath"],\n+            "@@fileUpload",\n         )\n \n     def test_widget_params_different_contexts(self):\n         from plone.app.z3cform.widget import RichTextWidget\n \n-        setRoles(self.portal, TEST_USER_ID, [\'Contributor\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Contributor"])\n \n         widget = FieldWidget(self.field, RichTextWidget(self.request))\n-        self.portal.invokeFactory(\'Folder\', \'sub\')\n+        self.portal.invokeFactory("Folder", "sub")\n         sub = self.portal.sub\n         form = Form(sub, self.request)\n \n@@ -1557,8 +1611,8 @@ def test_widget_params_different_contexts(self):\n         base_args = widget._base_args()\n \n         self.assertEqual(\n-            base_args[\'pattern_options\'][\'relatedItems\'][\'basePath\'],\n-            \'/plone\',\n+            base_args["pattern_options"]["relatedItems"]["basePath"],\n+            "/plone",\n         )\n \n         # sub context\n@@ -1567,8 +1621,8 @@ def test_widget_params_different_contexts(self):\n         base_args = widget._base_args()\n \n         self.assertEqual(\n-            base_args[\'pattern_options\'][\'relatedItems\'][\'basePath\'],\n-            \'/plone/sub\',\n+            base_args["pattern_options"]["relatedItems"]["basePath"],\n+            "/plone/sub",\n         )\n \n         # form context\n@@ -1577,8 +1631,8 @@ def test_widget_params_different_contexts(self):\n         base_args = widget._base_args()\n \n         self.assertEqual(\n-            base_args[\'pattern_options\'][\'relatedItems\'][\'basePath\'],\n-            \'/plone/sub\',\n+            base_args["pattern_options"]["relatedItems"]["basePath"],\n+            "/plone/sub",\n         )\n \n         # non-contentish context\n@@ -1587,8 +1641,8 @@ def test_widget_params_different_contexts(self):\n         base_args = widget._base_args()\n \n         self.assertEqual(\n-            base_args[\'pattern_options\'][\'relatedItems\'][\'basePath\'],\n-            \'/plone\',\n+            base_args["pattern_options"]["relatedItems"]["basePath"],\n+            "/plone",\n         )\n \n     def test_widget_values(self):\n@@ -1598,18 +1652,17 @@ def test_widget_values(self):\n         widget = FieldWidget(self.field, RichTextWidget(self.request))\n         # set the context so we can get tinymce settings\n         widget.context = self.portal\n-        widget.value = RichTextValue(u\'Lorem ipsum \\u2026\')\n+        widget.value = RichTextValue("Lorem ipsum \\u2026")\n         base_args = widget._base_args()\n-        self.assertEqual(base_args[\'value\'], u\'Lorem ipsum \\u2026\')\n+        self.assertEqual(base_args["value"], "Lorem ipsum \\u2026")\n \n-    def _set_mimetypes(self, default=\'text/html\', allowed=(\'text/html\')):\n-        """Set portal\'s mimetype settings.\n-        """\n+    def _set_mimetypes(self, default="text/html", allowed=("text/html")):\n+        """Set portal\'s mimetype settings."""\n         if IMarkupSchema:\n             registry = getUtility(IRegistry)\n             self.settings = registry.forInterface(\n                 IMarkupSchema,\n-                prefix=\'plone\',\n+                prefix="plone",\n             )\n             self.settings.default_type = default\n             self.settings.allowed_types = allowed\n@@ -1620,16 +1673,17 @@ def test_dx_tinymcewidget_single_mimetype(self):\n         """\n         if IMarkupSchema:\n             # if not, don\'t run this test\n-            self._set_mimetypes(allowed=(\'text/html\',))\n+            self._set_mimetypes(allowed=("text/html",))\n             from plone.app.z3cform.widget import RichTextWidget\n+\n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             # set the context so we can get tinymce settings\n             widget.context = self.portal\n             rendered = widget.render()\n \n-            self.assertTrue(\'<select\' not in rendered)\n-            self.assertTrue(\'pat-tinymce\' in rendered)\n-            self.assertTrue(\'data-pat-tinymce\' in rendered)\n+            self.assertTrue("<select" not in rendered)\n+            self.assertTrue("pat-tinymce" in rendered)\n+            self.assertTrue("data-pat-tinymce" in rendered)\n \n     def test_dx_tinymcewidget_multiple_mimetypes_create(self):\n         """A RichTextWidget with multiple available mimetypes should render a\n@@ -1638,19 +1692,21 @@ def test_dx_tinymcewidget_multiple_mimetypes_create(self):\n         """\n         if IMarkupSchema:\n             # if not, don\'t run this test\n-            self._set_mimetypes(allowed=(\'text/html\', \'text/plain\'))\n+            self._set_mimetypes(allowed=("text/html", "text/plain"))\n             from plone.app.z3cform.widget import RichTextWidget\n+\n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             # set the context so we can get tinymce settings\n             widget.context = self.portal\n             rendered = widget.render()\n \n-            self.assertTrue(\'<select\' in rendered)\n-            self.assertTrue(\'pat-textareamimetypeselector\' in rendered)\n-            self.assertTrue(\'data-pat-textareamimetypeselector\' in rendered)\n+            self.assertTrue("<select" in rendered)\n+            self.assertTrue("pat-textareamimetypeselector" in rendered)\n+            self.assertTrue("data-pat-textareamimetypeselector" in rendered)\n             self.assertTrue(\n-                \'<option value="text/html" selected="selected">\' in rendered)\n-            self.assertTrue(\'pat-tinymce\' not in rendered)\n+                \'<option value="text/html" selected="selected">\' in rendered\n+            )\n+            self.assertTrue("pat-tinymce" not in rendered)\n \n     def test_dx_tinymcewidget_multiple_mimetypes_edit(self):\n         """A RichTextWidget with multiple available mimetypes should render a\n@@ -1659,46 +1715,49 @@ def test_dx_tinymcewidget_multiple_mimetypes_edit(self):\n         """\n         if IMarkupSchema:\n             # if not, don\'t run this test\n-            self._set_mimetypes(allowed=(\'text/html\', \'text/plain\'))\n+            self._set_mimetypes(allowed=("text/html", "text/plain"))\n             from plone.app.textfield.value import RichTextValue\n             from plone.app.z3cform.widget import RichTextWidget\n+\n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             # set the context so we can get tinymce settings\n             widget.context = self.portal\n-            widget.value = RichTextValue(u\'Hello world\', mimeType=\'text/plain\')\n+            widget.value = RichTextValue("Hello world", mimeType="text/plain")\n             rendered = widget.render()\n \n-            self.assertTrue(\'<select\' in rendered)\n-            self.assertTrue(\'pat-textareamimetypeselector\' in rendered)\n-            self.assertTrue(\'data-pat-textareamimetypeselector\' in rendered)\n+            self.assertTrue("<select" in rendered)\n+            self.assertTrue("pat-textareamimetypeselector" in rendered)\n+            self.assertTrue("data-pat-textareamimetypeselector" in rendered)\n             self.assertTrue(\n                 \'<option value="text/plain" selected="selected">\' in rendered,\n             )\n-            self.assertTrue(\'pat-tinymce\' not in rendered)\n+            self.assertTrue("pat-tinymce" not in rendered)\n \n     def test_use_default_editor_value(self):\n-        """ Use dummy utility registered in testing.zcml """\n+        """Use dummy utility registered in testing.zcml"""\n         if IMarkupSchema:\n             # if not, don\'t run this test\n-            self._set_mimetypes(allowed=(\'text/html\',))\n+            self._set_mimetypes(allowed=("text/html",))\n             registry = getUtility(IRegistry)\n-            from Products.CMFPlone.interfaces import IEditingSchema\n-            proxy = registry.forInterface(IEditingSchema, check=False,\n-                                            prefix=\'plone\')\n-            proxy.available_editors = [u\'dummy\', u\'TinyMCE\']\n-            proxy.default_editor = u\'dummy\'\n+            from plone.base.interfaces import IEditingSchema\n+\n+            proxy = registry.forInterface(IEditingSchema, check=False, prefix="plone")\n+            proxy.available_editors = ["dummy", "TinyMCE"]\n+            proxy.default_editor = "dummy"\n             from plone.app.z3cform.widget import RichTextWidget\n+\n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             widget.context = self.portal\n             rendered = widget.render()\n-            self.assertTrue(\'<p>dummy</p>\' in rendered)\n+            self.assertTrue("<p>dummy</p>" in rendered)\n \n-            proxy.default_editor = u\'TinyMCE\'\n+            proxy.default_editor = "TinyMCE"\n             from plone.app.z3cform.widget import RichTextWidget\n+\n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             widget.context = self.portal\n             rendered = widget.render()\n-            self.assertTrue(\'pat-tinymce\' in rendered)\n+            self.assertTrue("pat-tinymce" in rendered)\n \n \n class LinkWidgetIntegrationTests(unittest.TestCase):\n@@ -1706,142 +1765,151 @@ class LinkWidgetIntegrationTests(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n+        self.portal = self.layer["portal"]\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n         setRequest(self.request)\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_link_widget__pattern_options(self):\n         from plone.app.z3cform.widget import LinkWidget\n+\n         widget = LinkWidget(self.request)\n \n         pattern_data = json.loads(widget.pattern_data())\n         self.assertEqual(\n-            pattern_data[\'vocabularyUrl\'],\n-            \'http://nohost/plone/@@getVocabulary?name=plone.app.vocabularies.Catalog\',  # noqa\n+            pattern_data["vocabularyUrl"],\n+            "http://nohost/plone/@@getVocabulary?name=plone.app.vocabularies.Catalog",  # noqa\n         )\n-        self.assertEqual(pattern_data[\'maximumSelectionSize\'], 1)\n+        self.assertEqual(pattern_data["maximumSelectionSize"], 1)\n \n     def test_link_widget__extract_internal(self):\n         from plone.app.z3cform.widget import LinkWidget\n+\n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n-        widget.name = \'testlinkwidget\'\n+        widget.name = "testlinkwidget"\n         widget.update()\n \n-        self.request.form[\'testlinkwidget.internal\'] = \'abc\'\n+        self.request.form["testlinkwidget.internal"] = "abc"\n         self.assertEqual(\n             widget.extract(),\n-            u\'${portal_url}/resolveuid/abc\',\n+            "${portal_url}/resolveuid/abc",\n         )\n \n     def test_link_widget__extract_external(self):\n         from plone.app.z3cform.widget import LinkWidget\n+\n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n-        widget.name = \'testlinkwidget\'\n+        widget.name = "testlinkwidget"\n         widget.update()\n \n-        self.request.form[\'testlinkwidget.external\'] = \'https://plone.org\'\n+        self.request.form["testlinkwidget.external"] = "https://plone.org"\n         self.assertEqual(\n             widget.extract(),\n-            u\'https://plone.org\',\n+            "https://plone.org",\n         )\n \n     def test_link_widget__extract_email(self):\n         from plone.app.z3cform.widget import LinkWidget\n+\n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n-        widget.name = \'testlinkwidget\'\n+        widget.name = "testlinkwidget"\n         widget.update()\n \n-        self.request.form[\'testlinkwidget.email\'] = \'dev@plone.org\'\n+        self.request.form["testlinkwidget.email"] = "dev@plone.org"\n         self.assertEqual(\n             widget.extract(),\n-            u\'mailto:dev@plone.org\',\n+            "mailto:dev@plone.org",\n         )\n \n     def test_link_widget__extract_email_including_mailto(self):\n         from plone.app.z3cform.widget import LinkWidget\n+\n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n-        widget.name = \'testlinkwidget\'\n+        widget.name = "testlinkwidget"\n         widget.update()\n \n-        self.request.form[\'testlinkwidget.email\'] = \'mailto:dev@plone.org\'\n+        self.request.form["testlinkwidget.email"] = "mailto:dev@plone.org"\n         self.assertEqual(\n             widget.extract(),\n-            u\'mailto:dev@plone.org\',\n+            "mailto:dev@plone.org",\n         )\n \n     def test_link_widget__data_converter(self):\n         from plone.app.z3cform.converters import LinkWidgetDataConverter\n         from plone.app.z3cform.widget import LinkWidget\n \n-        field = TextLine(__name__=\'linkfield\')\n+        field = TextLine(__name__="linkfield")\n         widget = LinkWidget(self.request)\n         converter = LinkWidgetDataConverter(field, widget)\n \n-        self.portal.invokeFactory(\'Folder\', \'test\')\n+        self.portal.invokeFactory("Folder", "test")\n         portal_url = self.portal.absolute_url()\n-        portal_path = \'/\'.join(self.portal.getPhysicalPath())\n+        portal_path = "/".join(self.portal.getPhysicalPath())\n \n         # Test empty value\n-        widget_value = converter.toWidgetValue(u\'\')\n-        self.assertEqual(widget_value[\'internal\'], u\'\')\n-        self.assertEqual(widget_value[\'external\'], u\'\')\n-        self.assertEqual(widget_value[\'email\'], u\'\')\n+        widget_value = converter.toWidgetValue("")\n+        self.assertEqual(widget_value["internal"], "")\n+        self.assertEqual(widget_value["external"], "")\n+        self.assertEqual(widget_value["email"], "")\n \n         # Test external URLs\n         self.assertEqual(\n-            converter.toWidgetValue(u\'https://plone.org\')[\'external\'],\n-            u\'https://plone.org\',\n+            converter.toWidgetValue("https://plone.org")["external"],\n+            "https://plone.org",\n         )\n \n         # Test relative resolveuid URLs\n         self.assertEqual(\n-            converter.toWidgetValue(u\'/resolveuid/1234\')[\'internal\'],\n-            u\'1234\',\n+            converter.toWidgetValue("/resolveuid/1234")["internal"],\n+            "1234",\n         )\n \n         # Test absolute resolveuid URLs on the same domain\n         self.assertEqual(\n-            converter.toWidgetValue(portal_url + \'/resolveuid/1234\')[\'internal\'],  # noqa\n-            u\'1234\',\n+            converter.toWidgetValue(portal_url + "/resolveuid/1234")[\n+                "internal"\n+            ],  # noqa\n+            "1234",\n         )\n \n         # Test absolute resolveuid URLs on a different domain\n         self.assertEqual(\n-            converter.toWidgetValue(u\'http://anyurl/resolveuid/1234\')[\'external\'],  # noqa\n-            u\'http://anyurl/resolveuid/1234\',\n+            converter.toWidgetValue("http://anyurl/resolveuid/1234")[\n+                "external"\n+            ],  # noqa\n+            "http://anyurl/resolveuid/1234",\n         )\n \n         # Test interrnal URL paths\n         self.assertEqual(\n-            converter.toWidgetValue(portal_path + \'/test\')[\'internal\'],\n+            converter.toWidgetValue(portal_path + "/test")["internal"],\n             IUUID(self.portal.test),\n         )\n \n         # Test absolute interrnal URLs\n         self.assertEqual(\n-            converter.toWidgetValue(portal_url + \'/test\')[\'internal\'],\n+            converter.toWidgetValue(portal_url + "/test")["internal"],\n             IUUID(self.portal.test),\n         )\n \n         # Test mail\n         self.assertEqual(\n-            converter.toWidgetValue(u\'mailto:me\')[\'email\'],\n-            u\'me\',\n+            converter.toWidgetValue("mailto:me")["email"],\n+            "me",\n         )\n \n         # Test mail with subject\n         self.assertEqual(\n-            converter.toWidgetValue(u\'mailto:me?subject=jep\')[\'email\'],\n-            u\'me\',\n+            converter.toWidgetValue("mailto:me?subject=jep")["email"],\n+            "me",\n         )\n         self.assertEqual(\n-            converter.toWidgetValue(u\'mailto:me?subject=jep\')[\'email_subject\'],\n-            u\'jep\',\n+            converter.toWidgetValue("mailto:me?subject=jep")["email_subject"],\n+            "jep",\n         )\n \n \n@@ -1850,18 +1918,17 @@ class WidgetCustomizingIntegrationTests(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def test_widget_base_wrapper_css(self):\n-\n         class ITestDateSchema(Schema):\n \n-            widget(\'my_date\', DateWidget, wrapper_css_class=\'foo\')\n-            my_date = Date(title=u\'My Date\')\n+            widget("my_date", DateWidget, wrapper_css_class="foo")\n+            my_date = Date(title="My Date")\n \n         class TestForm(AutoExtensibleForm, EditForm):\n \n             ignoreContext = True\n             schema = ITestDateSchema\n \n-        render = TestForm(self.layer[\'portal\'], self.layer[\'request\'])\n+        render = TestForm(self.layer["portal"], self.layer["request"])\n         self.assertIn(\n             \'empty foo" data-fieldname="form.widgets.my_date"\',\n             render(),\ndiff --git a/plone/app/z3cform/tests/tests.py b/plone/app/z3cform/tests/tests.py\nindex baf525bd..6229cc58 100644\n--- a/plone/app/z3cform/tests/tests.py\n+++ b/plone/app/z3cform/tests/tests.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.z3cform.tests.layer import PAZ3CForm_INTEGRATION_TESTING\n from plone.browserlayer.layer import mark_layer\n from plone.testing import layered\n@@ -16,51 +15,54 @@ class IntegrationTests(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n         event = BeforeTraverseEvent(self.portal, self.request)\n         mark_layer(self.portal, event)\n \n     def test_layer_applied(self):\n         from plone.app.z3cform.interfaces import IPloneFormLayer\n+\n         self.assertTrue(IPloneFormLayer.providedBy(self.portal.REQUEST))\n \n     def test_default_templates(self):\n-        form = self.portal.restrictedTraverse(\'test-form\')\n+        form = self.portal.restrictedTraverse("test-form")\n         rendered = form()\n         # look for something only in the Plone-specific @@ploneform-macros\n-        self.assertTrue(\'documentFirstHeading\' in rendered)\n+        self.assertTrue("documentFirstHeading" in rendered)\n \n     def test_content_provider(self):\n-        form = self.portal.restrictedTraverse(\'test-form\')\n+        form = self.portal.restrictedTraverse("test-form")\n         rendered = form()\n-        self.assertTrue(\'My test content provider\' in rendered)\n+        self.assertTrue("My test content provider" in rendered)\n \n \n def test_suite():\n-    inlineValidationTests = layered(doctest.DocFileSuite(\n-        \'inline_validation.rst\',\n-        package=\'plone.app.z3cform\',\n-        optionflags=(\n-            doctest.ELLIPSIS |\n-            doctest.NORMALIZE_WHITESPACE\n-        ),\n-    ), layer=PAZ3CForm_INTEGRATION_TESTING)\n-\n-    suite = unittest.TestSuite([\n-        unittest.makeSuite(IntegrationTests),\n+    inlineValidationTests = layered(\n         doctest.DocFileSuite(\n-            \'wysiwyg/README.rst\',\n-            package=\'plone.app.z3cform\',\n-            setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown,\n+            "inline_validation.rst",\n+            package="plone.app.z3cform",\n+            optionflags=(doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE),\n         ),\n-        doctest.DocTestSuite(\n-            \'plone.app.z3cform.wysiwyg.widget\',\n-            package=\'plone.app.z3cform\',\n-            setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown,\n-        ),\n-        inlineValidationTests,\n-    ])\n+        layer=PAZ3CForm_INTEGRATION_TESTING,\n+    )\n+\n+    suite = unittest.TestSuite(\n+        [\n+            unittest.defaultTestLoader.loadTestsFromTestCase(IntegrationTests),\n+            doctest.DocFileSuite(\n+                "wysiwyg/README.rst",\n+                package="plone.app.z3cform",\n+                setUp=zope.component.testing.setUp,\n+                tearDown=zope.component.testing.tearDown,\n+            ),\n+            doctest.DocTestSuite(\n+                "plone.app.z3cform.wysiwyg.widget",\n+                package="plone.app.z3cform",\n+                setUp=zope.component.testing.setUp,\n+                tearDown=zope.component.testing.tearDown,\n+            ),\n+            inlineValidationTests,\n+        ]\n+    )\n     return suite\ndiff --git a/plone/app/z3cform/utils.py b/plone/app/z3cform/utils.py\nindex de9c9272..f420d87e 100644\n--- a/plone/app/z3cform/utils.py\n+++ b/plone/app/z3cform/utils.py\n@@ -1,17 +1,10 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_base\n from Products.CMFCore.interfaces import IContentish\n from Products.CMFCore.interfaces import IFolderish\n-from six.moves import urllib\n from zope.component.hooks import getSite\n+from zope.globalrequest import getRequest\n \n-\n-try:\n-    from zope.globalrequest import getRequest\n-    getRequest  # pyflakes\n-except ImportError:\n-    # Fake it\n-    getRequest = object\n+import urllib\n \n \n def closest_content(context=None):\n@@ -23,7 +16,7 @@ def closest_content(context=None):\n         return c\n     # Subforms (e.g. DataGridField) may not have a context set, find out\n     # what page is being published\n-    c = getattr(getRequest(), \'PUBLISHED\', None)\n+    c = getattr(getRequest(), "PUBLISHED", None)\n     c = _valid_context(c)\n     if c is not None:\n         return c\n@@ -32,7 +25,7 @@ def closest_content(context=None):\n     c = _valid_context(c)\n     if c is not None:\n         return c\n-    raise ValueError(\'Cannot find suitable context to bind to source\')\n+    raise ValueError("Cannot find suitable context to bind to source")\n \n \n def _valid_context(context):\n@@ -41,11 +34,11 @@ def _valid_context(context):\n     seen = set()\n     while context is not None and id(aq_base(context)) not in seen:\n         seen.add(id(aq_base(context)))\n-        if (IContentish.providedBy(context) or IFolderish.providedBy(context)):\n+        if IContentish.providedBy(context) or IFolderish.providedBy(context):\n             return context\n-        parent = getattr(context, \'__parent__\', None)\n+        parent = getattr(context, "__parent__", None)\n         if parent is None:\n-            parent = getattr(context, \'context\', None)\n+            parent = getattr(context, "context", None)\n         context = parent\n \n     return None\n@@ -59,20 +52,11 @@ def call_callables(value, *args, **kwargs):\n     if callable(value):\n         ret = value(*args, **kwargs)\n     elif isinstance(value, list):\n-        ret = [\n-            call_callables(v, *args, **kwargs)\n-            for v in value\n-        ]\n+        ret = [call_callables(v, *args, **kwargs) for v in value]\n     elif isinstance(value, tuple):\n-        ret = tuple(\n-            call_callables(v, *args, **kwargs)\n-            for v in value\n-        )\n+        ret = tuple(call_callables(v, *args, **kwargs) for v in value)\n     elif isinstance(value, dict):\n-        ret = {\n-            k: call_callables(v, *args, **kwargs)\n-            for k, v in value.items()\n-        }\n+        ret = {k: call_callables(v, *args, **kwargs) for k, v in value.items()}\n     return ret\n \n \n@@ -83,25 +67,25 @@ def replace_link_variables_by_paths(context, url):\n     """\n \n     def _replace_variable_by_path(url, variable, obj):\n-        path = \'/\'.join(obj.getPhysicalPath())\n+        path = "/".join(obj.getPhysicalPath())\n         return url.replace(variable, path)\n \n     if not url:\n         return url\n \n-    portal_state = context.restrictedTraverse(\'@@plone_portal_state\')\n+    portal_state = context.restrictedTraverse("@@plone_portal_state")\n \n-    if \'${navigation_root_url}\' in url:\n+    if "${navigation_root_url}" in url:\n         url = _replace_variable_by_path(\n             url,\n-            \'${navigation_root_url}\',\n+            "${navigation_root_url}",\n             portal_state.navigation_root(),\n         )\n \n-    if \'${portal_url}\' in url:\n+    if "${portal_url}" in url:\n         url = _replace_variable_by_path(\n             url,\n-            \'${portal_url}\',\n+            "${portal_url}",\n             portal_state.portal(),\n         )\n \n@@ -116,8 +100,7 @@ def is_absolute(url):\n \n \n def is_same_domain(url1, url2):\n-    """Return ``True``, if url1 is on the same protocol and domain than url2.\n-    """\n+    """Return ``True``, if url1 is on the same protocol and domain than url2."""\n     purl1 = urllib.parse.urlparse(url1)\n     purl2 = urllib.parse.urlparse(url2)\n     return purl1.scheme == purl2.scheme and purl1.netloc == purl2.netloc\ndiff --git a/plone/app/z3cform/views.py b/plone/app/z3cform/views.py\nindex f7b94e2e..76991936 100644\n--- a/plone/app/z3cform/views.py\n+++ b/plone/app/z3cform/views.py\n@@ -1,72 +1,72 @@\n-# -*- coding: utf-8 -*-\n-import os.path\n-import plone.app.z3cform\n-import plone.app.z3cform.interfaces\n-import plone.z3cform.interfaces\n-import plone.z3cform.templates\n-import z3c.form.interfaces\n-\n-from Products.Five.browser import BrowserView\n-from Products.Five.browser.metaconfigure import ViewMixinForTemplates\n from plone.dexterity.browser.add import DefaultAddForm\n from plone.dexterity.browser.add import DefaultAddView\n from plone.dexterity.browser.edit import DefaultEditForm\n from plone.dexterity.interfaces import IDexterityEditForm\n from plone.z3cform import layout\n+from Products.Five.browser import BrowserView\n+from Products.Five.browser.metaconfigure import ViewMixinForTemplates\n from z3c.form.error import ErrorViewTemplateFactory\n from zope.browserpage.viewpagetemplatefile import ViewPageTemplateFile\n from zope.interface import classImplements\n \n+import os.path\n+import plone.app.z3cform\n+import plone.app.z3cform.interfaces\n+import plone.z3cform.interfaces\n+import plone.z3cform.templates\n+import z3c.form.interfaces\n+\n \n def path(filepart):\n     return os.path.join(\n         os.path.dirname(plone.app.z3cform.__file__),\n-        \'templates\',\n+        "templates",\n         filepart,\n     )\n \n+\n # Override the layout wrapper view default template with a more Plone-looking\n # one\n \n \n layout_factory = plone.z3cform.templates.ZopeTwoFormTemplateFactory(\n-    path(\'layout.pt\'),\n+    path("layout.pt"),\n     form=plone.z3cform.interfaces.IFormWrapper,\n-    request=plone.app.z3cform.interfaces.IPloneFormLayer)\n+    request=plone.app.z3cform.interfaces.IPloneFormLayer,\n+)\n \n # Override the form for the standard full-page form rendering\n \n form_factory = plone.z3cform.templates.ZopeTwoFormTemplateFactory(\n-    path(\'form.pt\'),\n+    path("form.pt"),\n     form=z3c.form.interfaces.IForm,\n-    request=plone.app.z3cform.interfaces.IPloneFormLayer)\n+    request=plone.app.z3cform.interfaces.IPloneFormLayer,\n+)\n \n \n # The ploneform-macros view\n class Macros(BrowserView):\n-\n     def __getitem__(self, key):\n         return self.index.macros[key]\n \n \n # The widget rendering templates need to be Zope 3 templates\n class RenderWidget(ViewMixinForTemplates, BrowserView):\n-    index = ViewPageTemplateFile(\'templates/widget.pt\')\n+    index = ViewPageTemplateFile("templates/widget.pt")\n \n \n class RenderContentProvider(ViewMixinForTemplates, BrowserView):\n-    index = ViewPageTemplateFile(\'templates/contentprovider-widget.pt\')\n+    index = ViewPageTemplateFile("templates/contentprovider-widget.pt")\n \n \n ErrorViewTemplate = ErrorViewTemplateFactory(\n-    os.path.join(os.path.dirname(__file__), \'templates/error.pt\'),\n-    \'text/html\')\n-\n+    os.path.join(os.path.dirname(__file__), "templates/error.pt"), "text/html"\n+)\n \n-class BootstrapActions(object):\n \n+class BootstrapActions:\n     def updateActions(self):\n-        super(BootstrapActions, self).updateActions()\n+        super().updateActions()\n \n         for a in self.actions:\n             if a == "save":\n@@ -79,7 +79,7 @@ def updateActions(self):\n \n # Dexterity Add/Edit Form overrides\n class AddForm(BootstrapActions, DefaultAddForm):\n-    """ with bootstrap actions """\n+    """with bootstrap actions"""\n \n \n class AddView(DefaultAddView):\n@@ -87,7 +87,7 @@ class AddView(DefaultAddView):\n \n \n class EditForm(BootstrapActions, DefaultEditForm):\n-    """ with bootstrap actions """\n+    """with bootstrap actions"""\n \n \n EditView = layout.wrap_form(EditForm)\ndiff --git a/plone/app/z3cform/widget.py b/plone/app/z3cform/widget.py\nindex e16eb9f8..96e186bc 100644\n--- a/plone/app/z3cform/widget.py\n+++ b/plone/app/z3cform/widget.py\n@@ -1,6 +1,6 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_base\n from Acquisition import ImplicitAcquisitionWrapper\n+from collections import UserDict\n from lxml import etree\n from OFS.interfaces import ISimpleItem\n from plone.app.contentlisting.interfaces import IContentListing\n@@ -35,15 +35,13 @@\n from plone.app.z3cform.interfaces import ITimeWidget\n from plone.app.z3cform.utils import call_callables\n from plone.app.z3cform.utils import closest_content\n+from plone.base.utils import safe_text\n from plone.registry.interfaces import IRegistry\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.utils import safe_unicode\n-from six.moves import UserDict\n from z3c.form import interfaces as form_ifaces\n from z3c.form.browser.checkbox import SingleCheckBoxWidget\n from z3c.form.browser.select import SelectWidget as z3cform_SelectWidget\n from z3c.form.browser.text import TextWidget as z3cform_TextWidget\n-from z3c.form.browser.widget import HTMLInputWidget\n from z3c.form.interfaces import IEditForm\n from z3c.form.interfaces import IFieldWidget\n from z3c.form.interfaces import IForm\n@@ -53,7 +51,6 @@\n from z3c.form.widget import FieldWidget\n from z3c.form.widget import Widget\n from zope.component import adapter\n-from zope.component import ComponentLookupError\n from zope.component import getUtility\n from zope.component import queryUtility\n from zope.component.hooks import getSite\n@@ -71,7 +68,6 @@\n \n import collections\n import json\n-import six\n \n \n class BaseWidget(Widget):\n@@ -79,10 +75,7 @@ class BaseWidget(Widget):\n \n     pattern = None\n     pattern_options = {}\n-    _adapterValueAttributes = (\n-        Widget._adapterValueAttributes +\n-        (\'pattern_options\',)\n-    )\n+    _adapterValueAttributes = Widget._adapterValueAttributes + ("pattern_options",)\n \n     def _base(self, pattern, pattern_options={}):\n         """Base widget class."""\n@@ -101,8 +94,8 @@ def _base_args(self):\n         if self.pattern is None:\n             raise PatternNotImplemented("\'pattern\' option is not provided.")\n         return {\n-            \'pattern\': self.pattern,\n-            \'pattern_options\': self.pattern_options.copy(),\n+            "pattern": self.pattern,\n+            "pattern_options": self.pattern_options.copy(),\n         }\n \n     def render(self):\n@@ -111,36 +104,36 @@ def render(self):\n         :returns: Widget\'s HTML.\n         :rtype: string\n         """\n-        if self.mode != \'input\':\n-            return super(BaseWidget, self).render()\n+        if self.mode != "input":\n+            return super().render()\n \n         _base_args = self._base_args()\n-        _base_args[\'pattern_options\'] = call_callables(\n-            _base_args[\'pattern_options\'],\n+        _base_args["pattern_options"] = call_callables(\n+            _base_args["pattern_options"],\n             self.context,\n         )\n \n         pattern_widget = self._base(**_base_args)\n-        if getattr(self, \'klass\', False):\n-            pattern_widget.klass = u\'{0} {1}\'.format(\n+        if getattr(self, "klass", False):\n+            pattern_widget.klass = "{} {}".format(\n                 pattern_widget.klass,\n                 self.klass,\n             )\n         return pattern_widget.render()\n \n     def is_subform_widget(self):\n-        return getattr(aq_base(self.form), \'parentForm\', None) is not None\n+        return getattr(aq_base(self.form), "parentForm", None) is not None\n \n \n @implementer_only(IDateWidget)\n class DateWidget(BaseWidget, z3cform_TextWidget):\n     """Date widget for z3c.form."""\n \n-    _base_type = \'date\'\n+    _base_type = "date"\n     _converter = DateWidgetConverter\n-    _formater = \'date\'\n+    _formater = "date"\n \n-    pattern = \'date-picker\'\n+    pattern = "date-picker"\n     pattern_options = BaseWidget.pattern_options.copy()\n \n     def _base(self, **kw):\n@@ -161,18 +154,17 @@ def _base_args(self):\n         :returns: Arguments which will be passed to _base\n         :rtype: dict\n         """\n-        args = super(DateWidget, self)._base_args()\n-        args[\'name\'] = self.name\n-        args[\'value\'] = (self.request.get(self.name,\n-                                          self.value) or u\'\').strip()\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = (self.request.get(self.name, self.value) or "").strip()\n \n-        args.setdefault(\'pattern_options\', {})\n+        args.setdefault("pattern_options", {})\n         if self.field.required:\n             # Required fields should not have a "Clear" button\n-            args[\'pattern_options\'][\'clear\'] = False\n-        args[\'pattern_options\'] = dict_merge(\n-            get_date_options(self.request),\n-            args[\'pattern_options\'])\n+            args["pattern_options"]["clear"] = False\n+        args["pattern_options"] = dict_merge(\n+            get_date_options(self.request), args["pattern_options"]\n+        )\n \n         return args\n \n@@ -182,21 +174,20 @@ def render(self):\n         :returns: Widget\'s HTML.\n         :rtype: string\n         """\n-        if self.mode != \'display\':\n+        if self.mode != "display":\n             self.addClass("form-control")\n-            return super(DateWidget, self).render()\n+            return super().render()\n \n         if not self.value:\n-            return \'\'\n+            return ""\n \n-        field_value = self._converter(\n-            self.field, self).toFieldValue(self.value)\n+        field_value = self._converter(self.field, self).toFieldValue(self.value)\n         if field_value is self.field.missing_value:\n-            return u\'\'\n+            return ""\n \n         formatter = self.request.locale.dates.getFormatter(\n             self._formater,\n-            \'short\',\n+            "short",\n         )\n         if field_value.year > 1900:\n             return formatter.format(field_value)\n@@ -215,32 +206,32 @@ class DatetimeWidget(DateWidget):\n     :type default_timezone: String or callback\n \n     """\n-    _base_type = \'datetime-local\'\n+\n+    _base_type = "datetime-local"\n     _converter = DatetimeWidgetConverter\n-    _formater = \'dateTime\'\n+    _formater = "dateTime"\n \n-    pattern = \'datetime-picker\'\n+    pattern = "datetime-picker"\n     default_timezone = None\n \n \n @implementer_only(ITimeWidget)\n class TimeWidget(BaseWidget, z3cform_TextWidget):\n \n-    pattern = \'\'\n+    pattern = ""\n \n     def _base(self, **kw):\n         return InputWidget(\n             type="time",\n             name=self.name,\n-            value=(self.request.get(self.name,\n-                self.value) or u\'\').strip(),\n+            value=(self.request.get(self.name, self.value) or "").strip(),\n             **kw,\n         )\n \n     def render(self):\n-        if self.mode != \'display\':\n+        if self.mode != "display":\n             self.addClass("form-control")\n-        return super(TimeWidget, self).render()\n+        return super().render()\n \n \n @implementer_only(ISelectWidget)\n@@ -249,12 +240,12 @@ class SelectWidget(BaseWidget, z3cform_SelectWidget):\n \n     _base = BaseSelectWidget\n \n-    pattern = \'select2\'\n+    pattern = "select2"\n     pattern_options = BaseWidget.pattern_options.copy()\n \n-    separator = \';\'\n-    noValueToken = u\'\'\n-    noValueMessage = u\'\'\n+    separator = ";"\n+    noValueToken = ""\n+    noValueMessage = ""\n     multiple = None\n     orderable = False\n     required = True\n@@ -273,12 +264,11 @@ def items(self):\n             for group_term, option_terms in terms.items():\n                 group_widget = type(self)(self.request)\n                 group_widget.terms = option_terms\n-                group_label = (\n-                    group_term.title or group_term.value or group_term.token)\n+                group_label = group_term.title or group_term.value or group_term.token\n                 groups[group_label] = super(SelectWidget, group_widget).items\n             return groups\n         else:\n-            return super(SelectWidget, self).items\n+            return super().items\n \n     def _base_args(self):\n         """Method which will calculate _base class arguments.\n@@ -294,27 +284,27 @@ def _base_args(self):\n         :returns: Arguments which will be passed to _base\n         :rtype: dict\n         """\n-        args = super(SelectWidget, self)._base_args()\n-        args[\'name\'] = self.name\n-        args[\'value\'] = self.value\n-        args[\'multiple\'] = self.multiple\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = self.value\n+        args["multiple"] = self.multiple\n \n         self.required = self.field.required\n \n-        options = args.setdefault(\'pattern_options\', {})\n+        options = args.setdefault("pattern_options", {})\n         if self.multiple or ICollection.providedBy(self.field):\n-            args[\'multiple\'] = self.multiple = True\n+            args["multiple"] = self.multiple = True\n \n         # ISequence represents an orderable collection\n         if ISequence.providedBy(self.field) or self.orderable:\n-            options[\'orderable\'] = True\n+            options["orderable"] = True\n \n         if self.multiple:\n-            options[\'separator\'] = self.separator\n+            options["separator"] = self.separator\n \n         # Allow to clear field value if it is not required\n         if not self.required:\n-            options[\'allowClear\'] = True\n+            options["allowClear"] = True\n \n         base_items = self.items\n         if callable(base_items):\n@@ -329,21 +319,20 @@ def makeItem(item):\n             """\n             Gather the information needed by the widget for the given term.\n             """\n-            if not isinstance(item[\'content\'], six.string_types):\n-                item[\'content\'] = translate(\n-                    item[\'content\'],\n-                    context=self.request,\n-                    default=item[\'value\'])\n-            return (item[\'value\'], item[\'content\'])\n+            if not isinstance(item["content"], str):\n+                item["content"] = translate(\n+                    item["content"], context=self.request, default=item["value"]\n+                )\n+            return (item["value"], item["content"])\n \n         if isinstance(base_items, dict):\n             items = collections.OrderedDict(\n-                (group_label, [\n-                    makeItem(base_item) for base_item in group_options])\n-                for group_label, group_options in base_items.items())\n+                (group_label, [makeItem(base_item) for base_item in group_options])\n+                for group_label, group_options in base_items.items()\n+            )\n         else:\n             items = [makeItem(item) for item in base_items]\n-        args[\'items\'] = items\n+        args["items"] = items\n \n         return args\n \n@@ -351,8 +340,10 @@ def extract(self, default=NO_VALUE):\n         """Override extract to handle delimited response values.\n         Skip the vocabulary validation provided in the parent\n         method, since it\'s not ever done for single selects."""\n-        if (self.name not in self.request and\n-                self.name + \'-empty-marker\' in self.request):\n+        if (\n+            self.name not in self.request\n+            and self.name + "-empty-marker" in self.request\n+        ):\n             return []\n         return self.request.get(self.name, default)\n \n@@ -363,12 +354,12 @@ class AjaxSelectWidget(BaseWidget, z3cform_TextWidget):\n \n     _base = InputWidget\n \n-    pattern = \'select2\'\n+    pattern = "select2"\n     pattern_options = BaseWidget.pattern_options.copy()\n \n-    separator = \';\'\n+    separator = ";"\n     vocabulary = None\n-    vocabulary_view = \'@@getVocabulary\'\n+    vocabulary_view = "@@getVocabulary"\n     orderable = False\n \n     def _view_context(self):\n@@ -387,7 +378,7 @@ def _view_context(self):\n         return view_context\n \n     def get_vocabulary(self):\n-        if self.vocabulary and isinstance(self.vocabulary, six.text_type):\n+        if self.vocabulary and isinstance(self.vocabulary, str):\n             factory = queryUtility(\n                 IVocabularyFactory,\n                 self.vocabulary,\n@@ -401,10 +392,10 @@ def display_items(self):\n             tokens = self.value.split(self.separator)\n             vocabulary = self.get_vocabulary()\n             for token in tokens:\n-                item = {\'token\': token, \'title\': token}\n+                item = {"token": token, "title": token}\n                 if vocabulary is not None:\n                     try:\n-                        item[\'title\'] = vocabulary.getTermByToken(token).title\n+                        item["title"] = vocabulary.getTermByToken(token).title\n                     except LookupError:\n                         pass\n                 yield item\n@@ -414,35 +405,38 @@ def has_multiple_values(self):\n \n     def _ajaxselect_options(self):\n         options = {\n-            \'separator\': self.separator,\n+            "separator": self.separator,\n         }\n         if self.vocabulary:\n-            options[\'vocabularyUrl\'] = \'{0}/{1}?name={2}\'.format(\n+            options["vocabularyUrl"] = "{}/{}?name={}".format(\n                 get_context_url(self._view_context()),\n                 self.vocabulary_view,\n                 self.vocabulary,\n             )\n             field_name = self.field and self.field.__name__ or None\n             if field_name:\n-                options[\'vocabularyUrl\'] += \'&field={0}\'.format(field_name)\n+                options["vocabularyUrl"] += f"&field={field_name}"\n             vocabulary = self.get_vocabulary()\n             if vocabulary is not None and self.value:\n-                options[\'initialValues\'] = dict()\n+                options["initialValues"] = dict()\n                 for token in self.value.split(self.separator):\n                     try:\n                         term = vocabulary.getTermByToken(token)\n-                        options[\'initialValues\'][term.token] = term.title\n+                        options["initialValues"][term.token] = term.title\n                     except LookupError:\n-                        options[\'initialValues\'][token] = token\n+                        options["initialValues"][token] = token\n \n         return options\n \n     def update(self):\n-        super(AjaxSelectWidget, self).update()\n-        field = getattr(self, \'field\', None)\n-        field = getattr(field, \'value_type\', field)\n-        if (not self.vocabulary and field is not None and\n-                getattr(field, \'vocabularyName\', None)):\n+        super().update()\n+        field = getattr(self, "field", None)\n+        field = getattr(field, "value_type", field)\n+        if (\n+            not self.vocabulary\n+            and field is not None\n+            and getattr(field, "vocabularyName", None)\n+        ):\n             self.vocabulary = field.vocabularyName\n \n     def _base_args(self):\n@@ -457,49 +451,50 @@ def _base_args(self):\n         :returns: Arguments which will be passed to _base\n         :rtype: dict\n         """\n-        args = super(AjaxSelectWidget, self)._base_args()\n-        args[\'name\'] = self.name\n-        args[\'value\'] = self.value\n-        args.setdefault(\'pattern_options\', {})\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = self.value\n+        args.setdefault("pattern_options", {})\n         context = self.context\n         field = None\n \n         if IChoice.providedBy(self.field):\n-            args[\'pattern_options\'][\'maximumSelectionSize\'] = 1\n+            args["pattern_options"]["maximumSelectionSize"] = 1\n             field = self.field\n         elif ICollection.providedBy(self.field):\n             field = self.field.value_type\n         if IChoice.providedBy(field):\n-            args[\'pattern_options\'][\'allowNewItems\'] = \'false\'\n+            args["pattern_options"]["allowNewItems"] = "false"\n \n-        args[\'pattern_options\'] = dict_merge(\n-            self._ajaxselect_options(),\n-            args[\'pattern_options\'])\n+        args["pattern_options"] = dict_merge(\n+            self._ajaxselect_options(), args["pattern_options"]\n+        )\n \n-        if field and getattr(field, \'vocabulary\', None):\n+        if field and getattr(field, "vocabulary", None):\n             form_url = self.request.getURL()\n-            source_url = \'{0:s}/++widget++{1:s}/@@getSource\'.format(\n+            source_url = "{:s}/++widget++{:s}/@@getSource".format(\n                 form_url,\n                 self.name,\n             )\n-            args[\'pattern_options\'][\'vocabularyUrl\'] = source_url\n+            args["pattern_options"]["vocabularyUrl"] = source_url\n \n         # ISequence represents an orderable collection\n         if ISequence.providedBy(self.field) or self.orderable:\n-            args[\'pattern_options\'][\'orderable\'] = True\n+            args["pattern_options"]["orderable"] = True\n \n-        if self.vocabulary == \'plone.app.vocabularies.Keywords\':\n-            membership = getToolByName(context, \'portal_membership\')\n+        if self.vocabulary == "plone.app.vocabularies.Keywords":\n+            membership = getToolByName(context, "portal_membership")\n             user = membership.getAuthenticatedMember()\n \n             registry = getUtility(IRegistry)\n             roles_allowed_to_add_keywords = registry.get(\n-                \'plone.roles_allowed_to_add_keywords\', set())\n+                "plone.roles_allowed_to_add_keywords", set()\n+            )\n             roles = set(user.getRolesInContext(context))\n             allowNewItems = bool(\n                 roles.intersection(roles_allowed_to_add_keywords),\n             )\n-            args[\'pattern_options\'][\'allowNewItems\'] = str(\n+            args["pattern_options"]["allowNewItems"] = str(\n                 allowNewItems,\n             ).lower()\n \n@@ -512,29 +507,29 @@ class RelatedItemsWidget(BaseWidget, z3cform_TextWidget):\n \n     _base = InputWidget\n \n-    pattern = \'relateditems\'\n+    pattern = "relateditems"\n     pattern_options = BaseWidget.pattern_options.copy()\n \n-    separator = \';\'\n+    separator = ";"\n     vocabulary = None\n     vocabulary_override = False\n-    vocabulary_view = \'@@getVocabulary\'\n+    vocabulary_view = "@@getVocabulary"\n     orderable = False\n \n     def update(self):\n-        super(RelatedItemsWidget, self).update()\n-        field = getattr(self, \'field\', None)\n+        super().update()\n+        field = getattr(self, "field", None)\n         if ICollection.providedBy(self.field):\n             field = self.field.value_type\n         if (\n-            not self.vocabulary and\n-            field is not None and\n-            getattr(field, \'vocabularyName\', None)\n+            not self.vocabulary\n+            and field is not None\n+            and getattr(field, "vocabularyName", None)\n         ):\n             self.vocabulary = field.vocabularyName\n             self.vocabulary_override = True\n         else:\n-            self.vocabulary = \'plone.app.vocabularies.Catalog\'\n+            self.vocabulary = "plone.app.vocabularies.Catalog"\n \n     def _base_args(self):\n         """Method which will calculate _base class arguments.\n@@ -548,15 +543,15 @@ def _base_args(self):\n         :returns: Arguments which will be passed to _base\n         :rtype: dict\n         """\n-        args = super(RelatedItemsWidget, self)._base_args()\n+        args = super()._base_args()\n \n-        args[\'name\'] = self.name\n-        args[\'value\'] = self.value\n-        args.setdefault(\'pattern_options\', {})\n+        args["name"] = self.name\n+        args["value"] = self.value\n+        args.setdefault("pattern_options", {})\n \n         field = None\n         if IChoice.providedBy(self.field):\n-            args[\'pattern_options\'][\'maximumSelectionSize\'] = 1\n+            args["pattern_options"]["maximumSelectionSize"] = 1\n             field = self.field\n         elif ICollection.providedBy(self.field):\n             field = self.field.value_type\n@@ -583,37 +578,37 @@ def _base_args(self):\n             # view_context is defined above already\n \n         root_search_mode = (\n-            args[\'pattern_options\'].get(\'mode\', None) and\n-            \'basePath\' not in args[\'pattern_options\']\n+            args["pattern_options"].get("mode", None)\n+            and "basePath" not in args["pattern_options"]\n         )\n \n-        args[\'pattern_options\'] = dict_merge(\n+        args["pattern_options"] = dict_merge(\n             get_relateditems_options(\n                 view_context,\n-                args[\'value\'],\n+                args["value"],\n                 self.separator,\n                 vocabulary_name,\n                 self.vocabulary_view,\n                 field_name,\n             ),\n-            args[\'pattern_options\'],\n+            args["pattern_options"],\n         )\n         if root_search_mode:\n             # Delete default basePath option in search mode, when no basePath\n             # was explicitly set.\n-            del args[\'pattern_options\'][\'basePath\']\n+            del args["pattern_options"]["basePath"]\n         if (\n-            not self.vocabulary_override and\n-            field and\n-            getattr(field, \'vocabulary\', None)\n+            not self.vocabulary_override\n+            and field\n+            and getattr(field, "vocabulary", None)\n         ):\n             # widget vocab takes precedence over field\n             form_url = self.request.getURL()\n-            source_url = \'{0:s}/++widget++{1:s}/@@getSource\'.format(\n+            source_url = "{:s}/++widget++{:s}/@@getSource".format(\n                 form_url,\n                 self.name,\n             )\n-            args[\'pattern_options\'][\'vocabularyUrl\'] = source_url\n+            args["pattern_options"]["vocabularyUrl"] = source_url\n \n         return args\n \n@@ -628,13 +623,13 @@ def items(self):\n         results = []\n         if not self.value:\n             return results\n-        separator = getattr(self, \'separator\', \';\')\n+        separator = getattr(self, "separator", ";")\n         uuids = self.value.split(separator)\n \n         try:\n-            catalog = getToolByName(self.context, \'portal_catalog\')\n+            catalog = getToolByName(self.context, "portal_catalog")\n         except AttributeError:\n-            catalog = getToolByName(getSite(), \'portal_catalog\')\n+            catalog = getToolByName(getSite(), "portal_catalog")\n \n         brains = catalog(UID=uuids)\n         # restore original order\n@@ -648,10 +643,10 @@ class QueryStringWidget(BaseWidget, z3cform_TextWidget):\n \n     _base = InputWidget\n \n-    pattern = \'querystring\'\n+    pattern = "querystring"\n     pattern_options = BaseWidget.pattern_options.copy()\n \n-    querystring_view = \'@@qsOptions\'\n+    querystring_view = "@@qsOptions"\n \n     def _base_args(self):\n         """Method which will calculate _base class arguments.\n@@ -665,14 +660,15 @@ def _base_args(self):\n         :returns: Arguments which will be passed to _base\n         :rtype: dict\n         """\n-        args = super(QueryStringWidget, self)._base_args()\n-        args[\'name\'] = self.name\n-        args[\'value\'] = self.value\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = self.value\n \n-        args.setdefault(\'pattern_options\', {})\n-        args[\'pattern_options\'] = dict_merge(\n+        args.setdefault("pattern_options", {})\n+        args["pattern_options"] = dict_merge(\n             get_querystring_options(self.context, self.querystring_view),\n-            args[\'pattern_options\'])\n+            args["pattern_options"],\n+        )\n \n         return args\n \n@@ -686,12 +682,12 @@ class RichTextWidget(BaseWidget, patext_RichTextWidget):\n     pattern_options = BaseWidget.pattern_options.copy()\n \n     def __init__(self, *args, **kwargs):\n-        super(RichTextWidget, self).__init__(*args, **kwargs)\n+        super().__init__(*args, **kwargs)\n         self._pattern = None\n \n     def wrapped_context(self):\n-        """"We need to wrap the context to be able to acquire the root\n-            of the site to get tools, as done in plone.app.textfield"""\n+        """ "We need to wrap the context to be able to acquire the root\n+        of the site to get tools, as done in plone.app.textfield"""\n         context = self.context\n         content = closest_content(context)\n         if context.__class__ == dict:\n@@ -701,28 +697,28 @@ def wrapped_context(self):\n     @property\n     def pattern(self):\n         """dynamically grab the actual pattern name so it will\n-           work with custom visual editors"""\n+        work with custom visual editors"""\n         if self._pattern is None:\n             self._pattern = self.getWysiwygEditor()\n         return self._pattern\n \n     def _base_args(self):\n-        args = super(RichTextWidget, self)._base_args()\n-        args[\'name\'] = self.name\n-        value = self.value and self.value.raw or u\'\'\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        value = self.value and self.value.raw or ""\n         value = self.request.get(self.name, value)\n-        args[\'value\'] = value\n+        args["value"] = value\n \n-        args.setdefault(\'pattern_options\', {})\n+        args.setdefault("pattern_options", {})\n         merged_options = dict_merge(\n             get_tinymce_options(\n                 self.wrapped_context(),\n                 self.field,\n                 self.request,\n             ),\n-            args[\'pattern_options\'],\n+            args["pattern_options"],\n         )\n-        args[\'pattern_options\'] = merged_options\n+        args["pattern_options"] = merged_options\n \n         return args\n \n@@ -732,85 +728,83 @@ def render(self):\n         :returns: Widget\'s HTML.\n         :rtype: string\n         """\n-        if self.mode != \'display\':\n+        if self.mode != "display":\n             renderer = queryUtility(\n                 IRichTextWidgetInputModeRenderer,\n                 name=self.getWysiwygEditor(),\n-                default=tinymce_richtextwidget_render\n+                default=tinymce_richtextwidget_render,\n             )\n             return renderer(self)\n \n         if not self.value:\n-            return \'\'\n+            return ""\n \n         if isinstance(self.value, RichTextValue):\n             return self.value.output_relative_to(self.context)\n \n-        return super(RichTextWidget, self).render()\n+        return super().render()\n \n     def render_input_mode(self):\n-            # MODE "INPUT"\n-            rendered = \'\'\n-            allowed_mime_types = self.allowedMimeTypes()\n-            if not allowed_mime_types or len(allowed_mime_types) <= 1:\n-                # Display textarea with default widget\n-                rendered = super(RichTextWidget, self).render()\n-            else:\n-                # Let pat-textarea-mimetype-selector choose the widget\n-\n-                # Initialize the widget without a pattern\n-                base_args = self._base_args()\n-                pattern_options = base_args[\'pattern_options\']\n-                del base_args[\'pattern\']\n-                del base_args[\'pattern_options\']\n-                textarea_widget = self._base(None, None, **base_args)\n-                textarea_widget.klass = \'form-control\'\n-                mt_pattern_name = \'{0}{1}\'.format(\n-                    self._base._klass_prefix,\n-                    \'textareamimetypeselector\',\n-                )\n+        # MODE "INPUT"\n+        rendered = ""\n+        allowed_mime_types = self.allowedMimeTypes()\n+        if not allowed_mime_types or len(allowed_mime_types) <= 1:\n+            # Display textarea with default widget\n+            rendered = super().render()\n+        else:\n+            # Let pat-textarea-mimetype-selector choose the widget\n+\n+            # Initialize the widget without a pattern\n+            base_args = self._base_args()\n+            pattern_options = base_args["pattern_options"]\n+            del base_args["pattern"]\n+            del base_args["pattern_options"]\n+            textarea_widget = self._base(None, None, **base_args)\n+            textarea_widget.klass = "form-control"\n+            mt_pattern_name = "{}{}".format(\n+                self._base._klass_prefix,\n+                "textareamimetypeselector",\n+            )\n \n-                # Initialize mimetype selector pattern\n-                # TODO: default_mime_type returns \'text/html\', regardless of\n-                # settings. fix in plone.app.textfield\n-                value_mime_type = self.value.mimeType if self.value\\\n-                    else self.field.default_mime_type\n-                mt_select = etree.Element(\'select\')\n-                mt_select.attrib[\'id\'] = \'{0}_text_format\'.format(self.id)\n-                mt_select.attrib[\'name\'] = \'{0}.mimeType\'.format(self.name)\n-                mt_select.attrib[\'class\'] = \'form-select {0}\'.format(\n-                    mt_pattern_name)\n-                mt_select.attrib[\n-                    \'data-{0}\'.format(mt_pattern_name)\n-                ] = json.dumps(\n-                    {\n-                        \'textareaName\': self.name,\n-                        \'widgets\': {\n-                            \'text/html\': {  # TODO: currently, we only support\n-                                            # richtext widget config for\n-                                            # \'text/html\', no other mimetypes.\n-                                \'pattern\': self.pattern,\n-                                \'patternOptions\': pattern_options,\n-                            },\n+            # Initialize mimetype selector pattern\n+            # TODO: default_mime_type returns \'text/html\', regardless of\n+            # settings. fix in plone.app.textfield\n+            value_mime_type = (\n+                self.value.mimeType if self.value else self.field.default_mime_type\n+            )\n+            mt_select = etree.Element("select")\n+            mt_select.attrib["id"] = f"{self.id}_text_format"\n+            mt_select.attrib["name"] = f"{self.name}.mimeType"\n+            mt_select.attrib["class"] = "form-select {}".format(mt_pattern_name)\n+            mt_select.attrib[f"data-{mt_pattern_name}"] = json.dumps(\n+                {\n+                    "textareaName": self.name,\n+                    "widgets": {\n+                        "text/html": {  # TODO: currently, we only support\n+                            # richtext widget config for\n+                            # \'text/html\', no other mimetypes.\n+                            "pattern": self.pattern,\n+                            "patternOptions": pattern_options,\n                         },\n                     },\n-                )\n+                },\n+            )\n \n-                # Create a list of allowed mime types\n-                for mt in allowed_mime_types:\n-                    opt = etree.Element(\'option\')\n-                    opt.attrib[\'value\'] = mt\n-                    if value_mime_type == mt:\n-                        opt.attrib[\'selected\'] = \'selected\'\n-                    opt.text = mt\n-                    mt_select.append(opt)\n-\n-                # Render the combined widget\n-                rendered = u\'{0}\\n{1}\'.format(\n-                    textarea_widget.render(),\n-                    etree.tostring(mt_select, encoding=\'unicode\'),\n-                )\n-            return rendered\n+            # Create a list of allowed mime types\n+            for mt in allowed_mime_types:\n+                opt = etree.Element("option")\n+                opt.attrib["value"] = mt\n+                if value_mime_type == mt:\n+                    opt.attrib["selected"] = "selected"\n+                opt.text = mt\n+                mt_select.append(opt)\n+\n+            # Render the combined widget\n+            rendered = "{}\\n{}".format(\n+                textarea_widget.render(),\n+                etree.tostring(mt_select, encoding="unicode"),\n+            )\n+        return rendered\n \n \n def tinymce_richtextwidget_render(widget):\n@@ -828,36 +822,36 @@ class LinkWidget(z3cform_TextWidget):\n \n     def pattern_data(self):\n         pattern_data = {\n-            \'vocabularyUrl\': \'{0}/@@getVocabulary?name=plone.app.vocabularies.Catalog\'.format(  # noqa\n+            "vocabularyUrl": "{}/@@getVocabulary?name=plone.app.vocabularies.Catalog".format(  # noqa\n                 getSite().absolute_url(0),\n             ),\n-            \'maximumSelectionSize\': 1,\n+            "maximumSelectionSize": 1,\n         }\n         return json.dumps(pattern_data)\n \n     def extract(self, default=NO_VALUE):\n         form = self.request.form\n-        internal = form.get(self.name + \'.internal\')\n-        external = form.get(self.name + \'.external\')\n-        email = form.get(self.name + \'.email\')\n+        internal = form.get(self.name + ".internal")\n+        external = form.get(self.name + ".external")\n+        email = form.get(self.name + ".email")\n         if internal:\n-            url = \'${portal_url}/resolveuid/\' + internal\n+            url = "${portal_url}/resolveuid/" + internal\n         elif email:\n-            subject = form.get(self.name + \'.subject\')\n-            if email[:7] != \'mailto:\':\n-                email = \'mailto:\' + email\n+            subject = form.get(self.name + ".subject")\n+            if email[:7] != "mailto:":\n+                email = "mailto:" + email\n             if not subject:\n                 url = email\n             else:\n-                url = \'{email}?subject={subject}\'.format(\n+                url = "{email}?subject={subject}".format(\n                     email=email,\n                     subject=subject,\n                 )\n         else:\n-            url = external   # the default is `http://` so we land here\n+            url = external  # the default is `http://` so we land here\n         if url:\n-            self.request.form[self.name] = safe_unicode(url)\n-        return super(LinkWidget, self).extract(default=default)\n+            self.request.form[self.name] = safe_text(url)\n+        return super().extract(default=default)\n \n \n @implementer(IFieldWidget)\n@@ -915,13 +909,13 @@ def LinkFieldWidget(field, request):\n class SingleCheckBoxBoolWidget(SingleCheckBoxWidget):\n     """Single Input type checkbox widget implementation."""\n \n-    klass = u\'single-checkbox-bool-widget\'\n+    klass = "single-checkbox-bool-widget"\n \n     @property\n     def label(self):\n-        if self.mode == \'input\':\n-            return u\'\'\n-        return getattr(self, \'_label\', u\'\')\n+        if self.mode == "input":\n+            return ""\n+        return getattr(self, "_label", "")\n \n     @label.setter\n     def label(self, value):\n@@ -929,38 +923,42 @@ def label(self, value):\n \n     @property\n     def description(self):\n-        if self.mode == \'input\':\n-            return u\'\'\n-        return getattr(self, \'_description\', u\'\')\n+        if self.mode == "input":\n+            return ""\n+        return getattr(self, "_description", "")\n \n     @description.setter\n     def description(self, value):\n         self._description = value\n \n     def updateTerms(self):\n-        if self.mode == \'input\':\n+        if self.mode == "input":\n             # in input mode use only one checkbox with true\n             self.terms = Terms()\n-            self.terms.terms = SimpleVocabulary((\n-                TermWithDescription(\n-                    True,\n-                    \'selected\',\n-                    getattr(self, \'_label\', None) or self.field.title,\n-                    getattr(\n-                        self,\n-                        \'_description\',\n-                        None,\n-                    ) or self.field.description,\n-                ),\n-            ))\n+            self.terms.terms = SimpleVocabulary(\n+                (\n+                    TermWithDescription(\n+                        True,\n+                        "selected",\n+                        getattr(self, "_label", None) or self.field.title,\n+                        getattr(\n+                            self,\n+                            "_description",\n+                            None,\n+                        )\n+                        or self.field.description,\n+                    ),\n+                )\n+            )\n             return self.terms\n         if not self.terms:\n             self.terms = Terms()\n             self.terms.terms = SimpleVocabulary(\n                 [\n-                    SimpleTerm(*args) for args in [\n-                        (True, \'selected\', BoolTerms.trueLabel),\n-                        (False, \'unselected\', BoolTerms.falseLabel),\n+                    SimpleTerm(*args)\n+                    for args in [\n+                        (True, "selected", BoolTerms.trueLabel),\n+                        (False, "unselected", BoolTerms.falseLabel),\n                     ]\n                 ],\n             )\n@@ -968,11 +966,11 @@ def updateTerms(self):\n \n     @property\n     def items(self):\n-        result = super(SingleCheckBoxBoolWidget, self).items\n+        result = super().items\n         for record in result:\n-            term = self.terms.terms.getTermByToken(record[\'value\'])\n-            record[\'description\'] = getattr(term, \'description\', \'\')\n-            record[\'required\'] = self.required\n+            term = self.terms.terms.getTermByToken(record["value"])\n+            record["description"] = getattr(term, "description", "")\n+            record["required"] = self.required\n         return result\n \n \ndiff --git a/plone/app/z3cform/wysiwyg/__init__.py b/plone/app/z3cform/wysiwyg/__init__.py\nindex f7b239e0..614ff05b 100644\n--- a/plone/app/z3cform/wysiwyg/__init__.py\n+++ b/plone/app/z3cform/wysiwyg/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n # Convenience import\n from plone.app.z3cform.wysiwyg.widget import WysiwygFieldWidget\n \ndiff --git a/plone/app/z3cform/wysiwyg/widget.py b/plone/app/z3cform/wysiwyg/widget.py\nindex bbba908a..09bc9d7d 100644\n--- a/plone/app/z3cform/wysiwyg/widget.py\n+++ b/plone/app/z3cform/wysiwyg/widget.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.component import adapter\n from zope.component.hooks import getSite\n from zope.interface import implementer\n@@ -14,7 +13,7 @@\n import zope.schema.interfaces\n \n \n-logger = logging.getLogger(\'plone.app.z3cform\')\n+logger = logging.getLogger("plone.app.z3cform")\n \n \n class IWysiwygWidget(z3c.form.interfaces.ITextAreaWidget):\n@@ -24,8 +23,8 @@ class IWysiwygWidget(z3c.form.interfaces.ITextAreaWidget):\n @implementer_only(IWysiwygWidget)\n class WysiwygWidget(z3c.form.browser.textarea.TextAreaWidget):\n \n-    klass = u\'kupu-widget\'\n-    value = u\'\'\n+    klass = "kupu-widget"\n+    value = ""\n \n     def update(self):\n         super(z3c.form.browser.textarea.TextAreaWidget, self).update()\n@@ -35,9 +34,10 @@ def update(self):\n         # ``context/portal_this`` if context is not wrapped already.\n         # Any attempts to satisfy the Kupu template in a less idiotic\n         # way failed:\n-        if getattr(self.form.context, \'aq_inner\', None) is None:\n+        if getattr(self.form.context, "aq_inner", None) is None:\n             self.form.context = Acquisition.ImplicitAcquisitionWrapper(\n-                self.form.context, getSite())\n+                self.form.context, getSite()\n+            )\n \n \n @adapter(zope.schema.interfaces.IField, z3c.form.interfaces.IFormLayer)\n@@ -45,8 +45,8 @@ def update(self):\n def WysiwygFieldWidget(field, request):\n     """IFieldWidget factory for WysiwygWidget."""\n     warnings.warn(\n-        \'plone.app.z3cform.wysiwyg.WysiwygFieldWidget is deprecated and\'\n-        \'will be removed in Plone 5.1\',\n+        "plone.app.z3cform.wysiwyg.WysiwygFieldWidget is deprecated and"\n+        "will be removed in Plone 5.1",\n         DeprecationWarning,\n     )\n     return z3c.form.widget.FieldWidget(field, WysiwygWidget(request))\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615de..4dca6482 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -18,3 +18,10 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[tool.isort]\n+# black compatible Plone isort rules:\n+profile = "black"\n+force_alphabetical_sort = true\n+force_single_line = true\n+lines_after_imports = 2\n\\ No newline at end of file\ndiff --git a/setup.py b/setup.py\nindex 41984ffc..71dc0981 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -51,27 +51,16 @@ def read(*rnames):\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'Acquisition\',\n         \'plone.app.textfield>=1.3.6\',\n         \'plone.app.widgets>=2.4.2.dev0\',\n+        \'plone.base\',\n         \'plone.protect\',\n-        \'plone.z3cform>=0.5.11dev\',\n-        \'Products.CMFCore\',\n-        \'Products.CMFPlone\',\n         \'setuptools\',\n-        \'six\',\n         \'z3c.form >= 4.0\',\n         \'z3c.formwidget.query\',\n-        \'zope.browserpage\',\n-        \'zope.component\',\n         \'zope.deprecation\',\n         \'zope.globalrequest\',\n-        \'zope.i18n\',\n-        \'zope.i18nmessageid\',\n-        \'zope.interface\',\n-        \'zope.schema\',\n-        \'zope.traversing\',\n-        \'Zope2\',\n+        \'Zope\',\n     ],\n     extras_require={\n         \'tests\': [\n'

Repository: plone.app.z3cform


Branch: refs/heads/master
Date: 2022-08-10T17:29:32+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.z3cform/commit/fb61a1b86de580aa001179f32efb7b2cd30172b8

Merge pull request #150 from plone/cleanup

remove Py2 fallbacks, run pyupgrade, do not depend on CMFPlone

Files changed:
A news/150.bugfix
M plone/__init__.py
M plone/app/__init__.py
M plone/app/z3cform/__init__.py
M plone/app/z3cform/converters.py
M plone/app/z3cform/csrf.py
M plone/app/z3cform/factories.py
M plone/app/z3cform/inline_validation.py
M plone/app/z3cform/interfaces.py
M plone/app/z3cform/layout.py
M plone/app/z3cform/profiles.zcml
M plone/app/z3cform/tests/__init__.py
M plone/app/z3cform/tests/example.py
M plone/app/z3cform/tests/layer.py
M plone/app/z3cform/tests/test_csrf.py
M plone/app/z3cform/tests/test_utils.py
M plone/app/z3cform/tests/test_widget.py
M plone/app/z3cform/tests/test_widgets.py
M plone/app/z3cform/tests/tests.py
M plone/app/z3cform/utils.py
M plone/app/z3cform/views.py
M plone/app/z3cform/widget.py
M plone/app/z3cform/wysiwyg/__init__.py
M plone/app/z3cform/wysiwyg/widget.py
M pyproject.toml
M setup.py

b'diff --git a/news/150.bugfix b/news/150.bugfix\nnew file mode 100644\nindex 00000000..291b9d4d\n--- /dev/null\n+++ b/news/150.bugfix\n@@ -0,0 +1,3 @@\n+Leftovers of Py 2 removed (with pyupgrade and manual edits). then run black & isort.\n+Do not depend on CMFPlone any longer (circular dependency), but on plone.base.\n+[jensens]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af4..5284146e 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 68c04af4..5284146e 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/z3cform/__init__.py b/plone/app/z3cform/__init__.py\nindex 40a96afc..e69de29b 100644\n--- a/plone/app/z3cform/__init__.py\n+++ b/plone/app/z3cform/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/z3cform/converters.py b/plone/app/z3cform/converters.py\nindex 06660ebe..9bff58e0 100644\n--- a/plone/app/z3cform/converters.py\n+++ b/plone/app/z3cform/converters.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import date\n from datetime import datetime\n from datetime import time\n@@ -14,8 +13,7 @@\n from plone.app.z3cform.interfaces import ITimeWidget\n from plone.uuid.interfaces import IUUID\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.utils import safe_callable\n-from six.moves import urllib\n+from plone.base.utils import safe_callable\n from z3c.form.converter import BaseDataConverter\n from z3c.form.converter import CollectionSequenceDataConverter\n from z3c.form.converter import SequenceDataConverter\n@@ -34,7 +32,7 @@\n \n import json\n import pytz\n-import six\n+import urllib\n \n \n @adapter(IDate, IDateWidget)\n@@ -51,9 +49,8 @@ def toWidgetValue(self, value):\n         :rtype: string\n         """\n         if value is self.field.missing_value:\n-            return u\'\'\n-        return (\'{value.year:}-{value.month:02}-{value.day:02}\'\n-                ).format(value=value)\n+            return ""\n+        return ("{value.year:}-{value.month:02}-{value.day:02}").format(value=value)\n \n     def toFieldValue(self, value):\n         """Converts from widget value to field.\n@@ -66,7 +63,7 @@ def toFieldValue(self, value):\n         """\n         if not value:\n             return self.field.missing_value\n-        return date(*map(int, value.split(\'-\')))\n+        return date(*map(int, value.split("-")))\n \n \n @adapter(IDatetime, IDatetimeWidget)\n@@ -83,9 +80,11 @@ def toWidgetValue(self, value):\n         :rtype: string\n         """\n         if value is self.field.missing_value:\n-            return u\'\'\n-        return (\'{value.year:}-{value.month:02}-{value.day:02}T\'\n-                \'{value.hour:02}:{value.minute:02}\').format(value=value)\n+            return ""\n+        return (\n+            "{value.year:}-{value.month:02}-{value.day:02}T"\n+            "{value.hour:02}:{value.minute:02}"\n+        ).format(value=value)\n \n     def toFieldValue(self, value):\n         """Converts from widget value to field.\n@@ -98,20 +97,23 @@ def toFieldValue(self, value):\n         """\n         if not value:\n             return self.field.missing_value\n-        tmp = value.split(\'T\')\n+        tmp = value.split("T")\n         if not tmp[0]:\n             return self.field.missing_value\n-        value = tmp[0].split(\'-\')\n-        if len(tmp) == 2 and \':\' in tmp[1]:\n-            value += tmp[1].split(\':\')\n+        value = tmp[0].split("-")\n+        if len(tmp) == 2 and ":" in tmp[1]:\n+            value += tmp[1].split(":")\n         else:\n-            value += [\'00\', \'00\']\n+            value += ["00", "00"]\n \n         # TODO: respect the selected zone from the widget and just fall back\n         # to default_zone\n         default_zone = self.widget.default_timezone\n-        zone = default_zone(self.widget.context)\\\n-            if safe_callable(default_zone) else default_zone\n+        zone = (\n+            default_zone(self.widget.context)\n+            if safe_callable(default_zone)\n+            else default_zone\n+        )\n         ret = datetime(*map(int, value))\n         if zone:\n             tzinfo = pytz.timezone(zone)\n@@ -127,17 +129,16 @@ class TimeWidgetConverter(BaseDataConverter):\n \n     def toWidgetValue(self, value):\n         if value == self.field.missing_value:\n-            return u\'\'\n+            return ""\n         return value.strftime("%H:%M")\n \n     def toFieldValue(self, value):\n-        if value == u\'\':\n+        if value == "":\n             return self.field.missing_value\n         return time(*map(int, value.split(":")))\n \n \n-class SelectWidgetConverterBase(object):\n-\n+class SelectWidgetConverterBase:\n     def toFieldValue(self, value):\n         """Converts from widget value to field.\n \n@@ -148,25 +149,24 @@ def toFieldValue(self, value):\n         :returns: List of items\n         :rtype: list | tuple | set\n         """\n-        separator = getattr(self.widget, \'separator\', \';\')\n-        if isinstance(value, six.string_types):\n+        separator = getattr(self.widget, "separator", ";")\n+        if isinstance(value, str):\n             value = value.strip()\n             if value:\n                 value = value.split(separator)\n             else:\n                 return self.field.missing_value\n-        elif value == (u\'\',):\n+        elif value == ("",):\n             return self.field.missing_value\n-        return super(SelectWidgetConverterBase, self).toFieldValue(value)\n+        return super().toFieldValue(value)\n \n \n @adapter(IField, ISelectWidget)\n class SequenceSelectWidgetConverter(\n-        SelectWidgetConverterBase,\n-        SequenceDataConverter,\n+    SelectWidgetConverterBase,\n+    SequenceDataConverter,\n ):\n-    """Data converter for IField fields using the SelectWidget.\n-    """\n+    """Data converter for IField fields using the SelectWidget."""\n \n \n @adapter(ICollection, ISelectWidget)\n@@ -174,14 +174,12 @@ class SelectWidgetConverter(\n     SelectWidgetConverterBase,\n     CollectionSequenceDataConverter,\n ):\n-    """Data converter for ICollection fields using the SelectWidget.\n-    """\n+    """Data converter for ICollection fields using the SelectWidget."""\n \n \n @adapter(ICollection, IAjaxSelectWidget)\n class AjaxSelectWidgetConverter(BaseDataConverter):\n-    """Data converter for ICollection fields using the AjaxSelectWidget.\n-    """\n+    """Data converter for ICollection fields using the AjaxSelectWidget."""\n \n     def toWidgetValue(self, value):\n         """Converts from field value to widget tokenized widget value.\n@@ -204,8 +202,8 @@ def toWidgetValue(self, value):\n                     continue\n                 except (LookupError, ValueError):\n                     pass\n-            tokenized_value.append(six.text_type(term_value))\n-        return getattr(self.widget, \'separator\', \';\').join(tokenized_value)\n+            tokenized_value.append(str(term_value))\n+        return getattr(self.widget, "separator", ";").join(tokenized_value)\n \n     def toFieldValue(self, value):\n         """Converts from widget value to field.\n@@ -224,7 +222,7 @@ def toFieldValue(self, value):\n         valueType = self.field.value_type._type\n         if isinstance(valueType, tuple):\n             valueType = valueType[0]\n-        separator = getattr(self.widget, \'separator\', \';\')\n+        separator = getattr(self.widget, "separator", ";")\n         self.widget.update()  # needed to have a vocabulary\n         vocabulary = self.widget.get_vocabulary()\n         untokenized_value = []\n@@ -247,8 +245,7 @@ def toFieldValue(self, value):\n \n @adapter(IRelation, IRelatedItemsWidget)\n class RelationChoiceRelatedItemsWidgetConverter(BaseDataConverter):\n-    """Data converter for RelationChoice fields using the RelatedItemsWidget.\n-    """\n+    """Data converter for RelationChoice fields using the RelatedItemsWidget."""\n \n     def toWidgetValue(self, value):\n         if not value:\n@@ -259,9 +256,9 @@ def toFieldValue(self, value):\n         if not value:\n             return self.field.missing_value\n         try:\n-            catalog = getToolByName(self.widget.context, \'portal_catalog\')\n+            catalog = getToolByName(self.widget.context, "portal_catalog")\n         except AttributeError:\n-            catalog = getToolByName(getSite(), \'portal_catalog\')\n+            catalog = getToolByName(getSite(), "portal_catalog")\n \n         res = catalog(UID=value)\n         if res:\n@@ -298,7 +295,7 @@ def toWidgetValue(self, value):\n         """\n         if not value:\n             return self.field.missing_value\n-        separator = getattr(self.widget, \'separator\', \';\')\n+        separator = getattr(self.widget, "separator", ";")\n         if IRelationList.providedBy(self.field):\n             return separator.join([IUUID(o) for o in value if o])\n         else:\n@@ -320,30 +317,30 @@ def toFieldValue(self, value):\n         if isinstance(collectionType, tuple):\n             collectionType = collectionType[-1]\n \n-        separator = getattr(self.widget, \'separator\', \';\')\n+        separator = getattr(self.widget, "separator", ";")\n         # Some widgets (like checkbox) return lists\n-        if isinstance(value, six.string_types):\n+        if isinstance(value, str):\n             value = value.split(separator)\n \n         if IRelationList.providedBy(self.field):\n             try:\n-                catalog = getToolByName(self.widget.context, \'portal_catalog\')\n+                catalog = getToolByName(self.widget.context, "portal_catalog")\n             except AttributeError:\n-                catalog = getToolByName(getSite(), \'portal_catalog\')\n+                catalog = getToolByName(getSite(), "portal_catalog")\n \n-            objects = {item.UID: item.getObject()\n-                       for item in catalog(UID=value) if item}\n+            objects = {\n+                item.UID: item.getObject() for item in catalog(UID=value) if item\n+            }\n \n-            return collectionType(objects[uid]\n-                                  for uid in value\n-                                  if uid in objects.keys())\n+            return collectionType(\n+                objects[uid] for uid in value if uid in objects.keys()\n+            )\n         else:\n-            valueType = getattr(self.field.value_type, \'_type\', six.text_type)\n+            valueType = getattr(self.field.value_type, "_type", str)\n             if valueType is None:\n-                valueType = six.text_type\n-            if not six.PY2 and valueType == six.binary_type:\n-                return collectionType(\n-                    valueType(v, encoding=\'utf8\') for v in value)\n+                valueType = str\n+            if valueType == bytes:\n+                return collectionType(valueType(v, encoding="utf8") for v in value)\n             return collectionType(valueType(v) for v in value)\n \n \n@@ -385,7 +382,7 @@ def toWidgetValue(self, value):\n         :rtype: string\n         """\n         if not value:\n-            return \'[]\'\n+            return "[]"\n         return json.dumps(value)\n \n     def toFieldValue(self, value):\n@@ -411,33 +408,33 @@ class LinkWidgetDataConverter(BaseDataConverter):\n     """Data converter for the enhanced link widget."""\n \n     def toWidgetValue(self, value):\n-        value = super(LinkWidgetDataConverter, self).toWidgetValue(value)\n+        value = super().toWidgetValue(value)\n         result = {\n-            \'internal\': u\'\',\n-            \'external\': u\'\',\n-            \'email\': u\'\',\n-            \'email_subject\': u\'\',\n+            "internal": "",\n+            "external": "",\n+            "email": "",\n+            "email_subject": "",\n         }\n         if not value:\n             return result\n-        if value.startswith(\'mailto:\'):\n+        if value.startswith("mailto:"):\n             # Handle mail URLs\n-            value = value[7:]   # strip mailto from beginning\n-            if \'?subject=\' in value:\n-                email, email_subject = value.split(\'?subject=\')\n-                result[\'email\'] = email\n-                result[\'email_subject\'] = email_subject\n+            value = value[7:]  # strip mailto from beginning\n+            if "?subject=" in value:\n+                email, email_subject = value.split("?subject=")\n+                result["email"] = email\n+                result["email_subject"] = email_subject\n             else:\n-                result[\'email\'] = value\n+                result["email"] = value\n         else:\n             uuid = None\n             portal = getSite()\n             is_same_domain = utils.is_same_domain(value, portal.absolute_url())\n             is_absolute = utils.is_absolute(value)\n-            if \'/resolveuid/\' in value and (not is_absolute or is_same_domain):\n+            if "/resolveuid/" in value and (not is_absolute or is_same_domain):\n                 # Take the UUID part of a resolveuid url, but onl if it\'s on\n                 # the same domain.\n-                uuid = value.rsplit(\'/\', 1)[-1]\n+                uuid = value.rsplit("/", 1)[-1]\n             elif not is_absolute or is_absolute and is_same_domain:\n                 # Handle relative URLs or absolute URLs on the same domain.\n                 parsed = urllib.parse.urlparse(value)\n@@ -448,17 +445,14 @@ def toWidgetValue(self, value):\n                     # to uids\n                     pass\n                 else:\n-                    path = utils.replace_link_variables_by_paths(\n-                        portal, parsed.path)\n-                    if six.PY2:\n-                        path = path.encode(\'ascii\', \'ignore\')\n+                    path = utils.replace_link_variables_by_paths(portal, parsed.path)\n                     obj = portal.unrestrictedTraverse(path=path, default=None)\n                     if obj is not None:\n                         uuid = IUUID(obj, None)\n             if uuid is not None:\n-                result[\'internal\'] = uuid\n+                result["internal"] = uuid\n             else:\n-                result[\'external\'] = value\n+                result["external"] = value\n         return result\n \n     def toFieldValue(self, value):\n@@ -467,21 +461,21 @@ def toFieldValue(self, value):\n         if not value:\n             return self.field.missing_value\n         if isinstance(value, dict):\n-            internal = value.get(\'internal\')\n-            external = value.get(\'external\')\n-            email = value.get(\'email\')\n+            internal = value.get("internal")\n+            external = value.get("external")\n+            email = value.get("email")\n         else:\n             return value\n         if internal:\n-            url = \'${portal_url}/resolveuid/\' + internal\n+            url = "${portal_url}/resolveuid/" + internal\n         elif email:\n-            subject = value.get(\'email_subject\')\n-            if email[:7] != \'mailto:\':\n-                email = u\'mailto:\' + email\n+            subject = value.get("email_subject")\n+            if email[:7] != "mailto:":\n+                email = "mailto:" + email\n             if not subject:\n                 url = email\n             else:\n-                url = u\'{email}?subject={subject}\'.format(\n+                url = "{email}?subject={subject}".format(\n                     email=email,\n                     subject=subject,\n                 )\n@@ -492,17 +486,16 @@ def toFieldValue(self, value):\n \n @adapter(IBool, ISingleCheckBoxBoolWidget)\n class BoolSingleCheckboxDataConverter(BaseDataConverter):\n-    """Special converter between boolean fields and single checkbox widgets.\n-    """\n+    """Special converter between boolean fields and single checkbox widgets."""\n \n     def toWidgetValue(self, value):\n         """Convert from Python bool to token sequence representation."""\n         if value:\n-            return [\'selected\']\n-        return [\'unselected\']\n+            return ["selected"]\n+        return ["unselected"]\n \n     def toFieldValue(self, value):\n         """See interfaces.IDataConverter"""\n         # consider all different from true as false,\n         # this way it works with one checkbox\n-        return bool(value and value[0] == \'selected\')\n+        return bool(value and value[0] == "selected")\ndiff --git a/plone/app/z3cform/csrf.py b/plone/app/z3cform/csrf.py\nindex 4eaaf6db..b69484ee 100644\n--- a/plone/app/z3cform/csrf.py\n+++ b/plone/app/z3cform/csrf.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.z3cform.interfaces import IPloneFormLayer\n from plone.protect import CheckAuthenticator\n from z3c.form.button import ButtonActions\n@@ -16,7 +15,7 @@ class AuthenticatedButtonActions(ButtonActions):\n     """\n \n     def execute(self):\n-        if getattr(self.form, \'enableCSRFProtection\', False):\n+        if getattr(self.form, "enableCSRFProtection", False):\n             if self.executedActions:\n                 CheckAuthenticator(self.request)\n-        super(AuthenticatedButtonActions, self).execute()\n+        super().execute()\ndiff --git a/plone/app/z3cform/factories.py b/plone/app/z3cform/factories.py\nindex 0bddc811..85022a30 100644\n--- a/plone/app/z3cform/factories.py\n+++ b/plone/app/z3cform/factories.py\n@@ -1,15 +1,13 @@\n-# -*- coding: utf-8 -*-\n-from zope.interface import implementer\n-from plone.namedfile.storages import MAXCHUNKSIZE\n from plone.namedfile.interfaces import IStorage\n+from plone.namedfile.storages import MAXCHUNKSIZE\n+from zope.interface import implementer\n \n \n @implementer(IStorage)\n-class Zope2FileUploadStorable(object):\n-\n+class Zope2FileUploadStorable:\n     def store(self, data, blob):\n         data.seek(0)\n-        with blob.open(\'w\') as fp:\n+        with blob.open("w") as fp:\n             block = data.read(MAXCHUNKSIZE)\n             while block:\n                 fp.write(block)\ndiff --git a/plone/app/z3cform/inline_validation.py b/plone/app/z3cform/inline_validation.py\nindex 54beed94..cf26c848 100644\n--- a/plone/app/z3cform/inline_validation.py\n+++ b/plone/app/z3cform/inline_validation.py\n@@ -1,7 +1,7 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_base\n-from Products.CMFPlone.utils import normalizeString\n+from plone.i18n.normalizer.interfaces import IIDNormalizer\n from Products.Five import BrowserView\n+from zope.component import queryUtility\n from zope.i18n import translate\n from zope.i18nmessageid import Message\n \n@@ -9,13 +9,12 @@\n \n \n class InlineValidationView(BrowserView):\n-    """Validate a form and return the error message for a particular field as JSON.\n-    """\n+    """Validate a form and return the error message for a particular field as JSON."""\n \n     def __call__(self, fname=None, fset=None):\n-        self.request.response.setHeader(\'Content-Type\', \'application/json\')\n+        self.request.response.setHeader("Content-Type", "application/json")\n \n-        res = {\'errmsg\': \'\'}\n+        res = {"errmsg": ""}\n \n         if fname is None:\n             return json.dumps(res)\n@@ -29,7 +28,7 @@ def __call__(self, fname=None, fset=None):\n         except (AttributeError, TypeError):\n             return json.dumps(res)\n \n-        if getattr(form, \'extractData\', None):\n+        if getattr(form, "extractData", None):\n             data, errors = form.extractData()\n         else:\n             return json.dumps(res)\n@@ -42,13 +41,17 @@ def __call__(self, fname=None, fset=None):\n             except (ValueError, TypeError):\n                 # try to match fieldset on group name\n                 def _name(group):\n-                    return getattr(group, \'__name__\', group.label)\n-                group_match = list(filter(\n-                    lambda group: normalizeString(_name(group)) == fset,\n-                    form.groups,\n-                ))\n+                    return getattr(group, "__name__", group.label)\n+\n+                normalize = queryUtility(IIDNormalizer).normalize\n+                group_match = list(\n+                    filter(\n+                        lambda group: normalize(_name(group)) == fset,\n+                        form.groups,\n+                    )\n+                )\n                 if not group_match:\n-                    raise ValueError(\'Fieldset specified, but not found.\')\n+                    raise ValueError("Fieldset specified, but not found.")\n                 form = group_match[0]\n \n         index = len(form.prefix) + len(form.widgets.prefix)\n@@ -62,5 +65,5 @@ def _name(group):\n         if isinstance(validationError, Message):\n             validationError = translate(validationError, context=self.request)\n \n-        res[\'errmsg\'] = validationError or \'\'\n+        res["errmsg"] = validationError or ""\n         return json.dumps(res)\ndiff --git a/plone/app/z3cform/interfaces.py b/plone/app/z3cform/interfaces.py\nindex d50d6b15..6ffce277 100644\n--- a/plone/app/z3cform/interfaces.py\n+++ b/plone/app/z3cform/interfaces.py\n@@ -1,5 +1,6 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.textfield.widget import IRichTextWidget as patextfield_IRichTextWidget  # noqa\n+from plone.app.textfield.widget import (\n+    IRichTextWidget as patextfield_IRichTextWidget,\n+)  # noqa\n from z3c.form.interfaces import IFormLayer\n from z3c.form.interfaces import IRadioWidget\n from z3c.form.interfaces import ISelectWidget as IBaseSelectWidget\n@@ -86,5 +87,6 @@ def renderForValue(value):\n         words it is a term token.\n         """\n \n+\n class IRichTextWidgetInputModeRenderer(Interface):\n     """Marker interface to render multiple wysiwyg editors"""\ndiff --git a/plone/app/z3cform/layout.py b/plone/app/z3cform/layout.py\nindex e6eea713..741f90e4 100644\n--- a/plone/app/z3cform/layout.py\n+++ b/plone/app/z3cform/layout.py\n@@ -1,9 +1,8 @@\n-# -*- coding: utf-8 -*-\n import zope.deferredimport\n \n \n zope.deferredimport.deprecated(\n-    \'Import from plone.z3cform.layout instead.\',\n-    FormWrapper=\'plone.z3cform.layout:FormWrapper\',\n-    wrap_form=\'plone.z3cform.layout:wrap_form\',\n+    "Import from plone.z3cform.layout instead.",\n+    FormWrapper="plone.z3cform.layout:FormWrapper",\n+    wrap_form="plone.z3cform.layout:wrap_form",\n )\ndiff --git a/plone/app/z3cform/profiles.zcml b/plone/app/z3cform/profiles.zcml\nindex 9e358d4f..b74de448 100644\n--- a/plone/app/z3cform/profiles.zcml\n+++ b/plone/app/z3cform/profiles.zcml\n@@ -11,7 +11,7 @@\n       description="Adds support for rendering z3c.form forms in Plone"\n       directory="profiles/default"\n       provides="Products.GenericSetup.interfaces.EXTENSION"\n-      for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+      for="plone.base.interfaces.IPloneSiteRoot"\n       />\n \n </configure>\ndiff --git a/plone/app/z3cform/tests/__init__.py b/plone/app/z3cform/tests/__init__.py\nindex 40a96afc..e69de29b 100644\n--- a/plone/app/z3cform/tests/__init__.py\n+++ b/plone/app/z3cform/tests/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/z3cform/tests/example.py b/plone/app/z3cform/tests/example.py\nindex 325ed4be..5938b0ae 100644\n--- a/plone/app/z3cform/tests/example.py\n+++ b/plone/app/z3cform/tests/example.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.z3cform.layout import FormWrapper\n from z3c.form import button\n from z3c.form import field\n@@ -13,25 +12,24 @@\n \n \n class MySchema(Interface):\n-    age = schema.Int(title=u\'Age\')\n+    age = schema.Int(title="Age")\n \n \n class MyContentProvider(ContentProviderBase):\n-\n     def render(self):\n-        return \'My test content provider\'\n+        return "My test content provider"\n \n \n @implementer(IFieldsAndContentProvidersForm)\n class MyForm(form.Form):\n     contentProviders = ContentProviders()\n-    contentProviders[\'myContentProvider\'] = MyContentProvider\n+    contentProviders["myContentProvider"] = MyContentProvider\n     # defining a contentProvider position is mandatory...\n-    contentProviders[\'myContentProvider\'].position = 0\n-    label = u\'Please enter your age\'\n+    contentProviders["myContentProvider"].position = 0\n+    label = "Please enter your age"\n     ignoreContext = True  # don\'t use context to get widget data\n \n-    @button.buttonAndHandler(u\'Apply\')\n+    @button.buttonAndHandler("Apply")\n     def handleApply(self, action):\n         data, errors = self.extractData()\n \n@@ -41,23 +39,25 @@ class MyFormWrapper(FormWrapper):\n \n \n class MyGroupSchema(Interface):\n-    name = schema.TextLine(title=u\'name\')\n+    name = schema.TextLine(title="name")\n \n \n class MyGroup(group.Group):\n-    label = u\'Secondary Group\'\n-    __name__ = u\'MyGroup\'\n+    label = "Secondary Group"\n+    __name__ = "MyGroup"\n     fields = field.Fields(MyGroupSchema)\n \n \n class MyGroupForm(group.GroupForm, form.Form):\n     fields = field.Fields(MySchema)\n-    label = u\'Please enter your age and Name\'\n+    label = "Please enter your age and Name"\n     ignoreContext = True  # don\'t use context to get widget data\n \n-    groups = [MyGroup, ]\n+    groups = [\n+        MyGroup,\n+    ]\n \n-    @button.buttonAndHandler(u\'Apply\')\n+    @button.buttonAndHandler("Apply")\n     def handleApply(self, action):\n         data, errors = self.extractData()\n \n@@ -67,17 +67,19 @@ class MyGroupFormWrapper(FormWrapper):\n \n \n class MyMultiSchema(Interface):\n-    ages = schema.Dict(title=u\'ages\',\n-                       key_type=schema.TextLine(title=u\'name\'),\n-                       value_type=schema.Int(title=u\'age\', default=38))\n+    ages = schema.Dict(\n+        title="ages",\n+        key_type=schema.TextLine(title="name"),\n+        value_type=schema.Int(title="age", default=38),\n+    )\n \n \n class MyMultiForm(form.Form):\n     fields = field.Fields(MyMultiSchema)\n-    label = u\'Please enter the names and ages for each person\'\n+    label = "Please enter the names and ages for each person"\n     ignoreContext = True  # don\'t use context to get widget data\n \n-    @button.buttonAndHandler(u\'Apply\')\n+    @button.buttonAndHandler("Apply")\n     def handleApply(self, action):\n         data, errors = self.extractData()\n \ndiff --git a/plone/app/z3cform/tests/layer.py b/plone/app/z3cform/tests/layer.py\nindex b1263f84..98e0afba 100644\n--- a/plone/app/z3cform/tests/layer.py\n+++ b/plone/app/z3cform/tests/layer.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.testing import PLONE_FIXTURE\n from plone.app.testing import PloneSandboxLayer\n from plone.app.testing.layers import IntegrationTesting\n@@ -9,27 +8,30 @@ class PAZ3CFormLayer(PloneSandboxLayer):\n     defaultBases = (PLONE_FIXTURE,)\n \n     def setUpZope(self, app, configurationContext):\n-        z2.installProduct(app, \'Products.DateRecurringIndex\')\n+        z2.installProduct(app, "Products.DateRecurringIndex")\n \n         import plone.app.contenttypes\n-        self.loadZCML(package=plone.app.contenttypes,\n-                      context=configurationContext)\n+\n+        self.loadZCML(package=plone.app.contenttypes, context=configurationContext)\n \n         import plone.app.z3cform\n-        self.loadZCML(package=plone.app.z3cform,\n-                      context=configurationContext)\n+\n+        self.loadZCML(package=plone.app.z3cform, context=configurationContext)\n         import plone.app.z3cform.tests\n-        self.loadZCML(name=\'testing.zcml\',\n-                      package=plone.app.z3cform.tests,\n-                      context=configurationContext)\n+\n+        self.loadZCML(\n+            name="testing.zcml",\n+            package=plone.app.z3cform.tests,\n+            context=configurationContext,\n+        )\n \n     def setUpPloneSite(self, portal):\n-        self.applyProfile(portal, \'plone.app.contenttypes:default\')\n-        self.applyProfile(portal, \'plone.app.z3cform:default\')\n+        self.applyProfile(portal, "plone.app.contenttypes:default")\n+        self.applyProfile(portal, "plone.app.z3cform:default")\n \n \n PAZ3CForm_FIXTURE = PAZ3CFormLayer()\n PAZ3CForm_INTEGRATION_TESTING = IntegrationTesting(\n     bases=(PAZ3CForm_FIXTURE,),\n-    name=\'plone.app.z3cform:Integration\',\n+    name="plone.app.z3cform:Integration",\n )\ndiff --git a/plone/app/z3cform/tests/test_csrf.py b/plone/app/z3cform/tests/test_csrf.py\nindex a9a1ffc0..f0ca055c 100644\n--- a/plone/app/z3cform/tests/test_csrf.py\n+++ b/plone/app/z3cform/tests/test_csrf.py\n@@ -1,20 +1,17 @@\n-# -*- coding: utf-8 -*-\n from plone.protect.tests.case import KeyringTestCase\n \n \n class TestAuthenticatedButtonActions(KeyringTestCase):\n-\n     def test_execute(self):\n         from Acquisition import Implicit\n-        from Testing.makerequest import makerequest\n         from plone.app.z3cform.csrf import AuthenticatedButtonActions\n         from plone.protect import createToken\n+        from Testing.makerequest import makerequest\n \n-        class DummyForm(object):\n+        class DummyForm:\n             enableCSRFProtection = True\n \n-        class DummyAction(object):\n-\n+        class DummyAction:\n             def isExecuted(self):\n                 return True\n \n@@ -23,9 +20,9 @@ def execute(self):\n \n         form = DummyForm()\n         request = makerequest(Implicit()).REQUEST\n-        request.form[\'_authenticator\'] = createToken()\n+        request.form["_authenticator"] = createToken()\n         actions = AuthenticatedButtonActions(form, request, None)\n-        actions[\'foo\'] = DummyAction()\n+        actions["foo"] = DummyAction()\n \n         actions.execute()\n         # If we got here without raising Unauthorized, the test passed.\ndiff --git a/plone/app/z3cform/tests/test_utils.py b/plone/app/z3cform/tests/test_utils.py\nindex e6a068db..91ca2f36 100644\n--- a/plone/app/z3cform/tests/test_utils.py\n+++ b/plone/app/z3cform/tests/test_utils.py\n@@ -1,9 +1,7 @@\n-# -*- coding: utf-8 -*-\n import unittest\n \n \n class TestUnitCallCallables(unittest.TestCase):\n-\n     def test_simple(self):\n         from plone.app.z3cform.utils import call_callables\n \n@@ -11,7 +9,7 @@ def test_simple(self):\n         test_compare = 1\n         test_out = call_callables(\n             test_in,\n-            \'funny return value\',\n+            "funny return value",\n         )\n         self.assertEqual(test_out, test_compare)\n \n@@ -21,10 +19,10 @@ def test_simple_function(self):\n         def test_in(x):\n             return x\n \n-        test_compare = \'funny return value\'\n+        test_compare = "funny return value"\n         test_out = call_callables(\n             test_in,\n-            \'funny return value\',\n+            "funny return value",\n         )\n         self.assertEqual(test_out, test_compare)\n \n@@ -32,10 +30,10 @@ def test_list(self):\n         from plone.app.z3cform.utils import call_callables\n \n         test_in = [1, 2, 3, lambda x: x]\n-        test_compare = [1, 2, 3, \'funny return value\']\n+        test_compare = [1, 2, 3, "funny return value"]\n         test_out = call_callables(\n             test_in,\n-            \'funny return value\',\n+            "funny return value",\n         )\n         self.assertEqual(test_out, test_compare)\n \n@@ -43,10 +41,10 @@ def test_tuple(self):\n         from plone.app.z3cform.utils import call_callables\n \n         test_in = (1, 2, 3, lambda x: x)\n-        test_compare = (1, 2, 3, \'funny return value\')\n+        test_compare = (1, 2, 3, "funny return value")\n         test_out = call_callables(\n             test_in,\n-            \'funny return value\',\n+            "funny return value",\n         )\n         self.assertEqual(test_out, test_compare)\n \n@@ -54,73 +52,102 @@ def test_complex(self):\n         from plone.app.z3cform.utils import call_callables\n \n         test_in = {\n-            \'normal\': 123,\n-            \'list\': [1, 2, 3, lambda x: x, [11, 22, 33, lambda x: x, (44, 55, 66, lambda x: x)]],  # noqa\n-            \'tuple\': (1, 2, 3, lambda x: x, (11, 22, 33, lambda x: x, [44, 55, 66, lambda x: x])),  # noqa\n-            \'dict\': {\n-                \'subnormal\': 456,\n-                \'sublist\': [4, 5, 6, lambda x: x],\n-                \'subtuple\': (4, 5, 6, lambda x: x),\n-                \'subdict\': {\n-                    \'subsubnormal\': 789,\n-                    \'subsublist\': [7, 8, 9, lambda x: x],\n-                    \'subsubtuple\': (7, 8, 9, lambda x: x),\n+            "normal": 123,\n+            "list": [\n+                1,\n+                2,\n+                3,\n+                lambda x: x,\n+                [11, 22, 33, lambda x: x, (44, 55, 66, lambda x: x)],\n+            ],  # noqa\n+            "tuple": (\n+                1,\n+                2,\n+                3,\n+                lambda x: x,\n+                (11, 22, 33, lambda x: x, [44, 55, 66, lambda x: x]),\n+            ),  # noqa\n+            "dict": {\n+                "subnormal": 456,\n+                "sublist": [4, 5, 6, lambda x: x],\n+                "subtuple": (4, 5, 6, lambda x: x),\n+                "subdict": {\n+                    "subsubnormal": 789,\n+                    "subsublist": [7, 8, 9, lambda x: x],\n+                    "subsubtuple": (7, 8, 9, lambda x: x),\n                 },\n             },\n         }\n \n         test_compare = {\n-            \'normal\': 123,\n-            \'list\': [1, 2, 3, \'funny return value\', [11, 22, 33, \'funny return value\', (44, 55, 66, \'funny return value\')]],  # noqa\n-            \'tuple\': (1, 2, 3, \'funny return value\', (11, 22, 33, \'funny return value\', [44, 55, 66, \'funny return value\'])),  # noqa\n-            \'dict\': {\n-                \'subnormal\': 456,\n-                \'sublist\': [4, 5, 6, \'funny return value\'],\n-                \'subtuple\': (4, 5, 6, \'funny return value\'),\n-                \'subdict\': {\n-                    \'subsubnormal\': 789,\n-                    \'subsublist\': [7, 8, 9, \'funny return value\'],\n-                    \'subsubtuple\': (7, 8, 9, \'funny return value\'),\n+            "normal": 123,\n+            "list": [\n+                1,\n+                2,\n+                3,\n+                "funny return value",\n+                [11, 22, 33, "funny return value", (44, 55, 66, "funny return value")],\n+            ],  # noqa\n+            "tuple": (\n+                1,\n+                2,\n+                3,\n+                "funny return value",\n+                (11, 22, 33, "funny return value", [44, 55, 66, "funny return value"]),\n+            ),  # noqa\n+            "dict": {\n+                "subnormal": 456,\n+                "sublist": [4, 5, 6, "funny return value"],\n+                "subtuple": (4, 5, 6, "funny return value"),\n+                "subdict": {\n+                    "subsubnormal": 789,\n+                    "subsublist": [7, 8, 9, "funny return value"],\n+                    "subsubtuple": (7, 8, 9, "funny return value"),\n                 },\n             },\n         }\n \n         test_out = call_callables(\n             test_in,\n-            \'funny return value\',\n+            "funny return value",\n         )\n \n         self.assertEqual(test_out, test_compare)\n \n \n class TestUtils(unittest.TestCase):\n-\n     def test_is_absolute(self):\n         from plone.app.z3cform.utils import is_absolute\n \n-        self.assertTrue(is_absolute(\'https://plone.org/\'))\n-        self.assertTrue(is_absolute(\'http://plone.org/\'))\n-        self.assertTrue(is_absolute(\'webdav://plone.org/\'))\n-        self.assertTrue(not is_absolute(\'./path/to/site\'))\n-        self.assertTrue(not is_absolute(\'/resolveuid/\'))\n+        self.assertTrue(is_absolute("https://plone.org/"))\n+        self.assertTrue(is_absolute("http://plone.org/"))\n+        self.assertTrue(is_absolute("webdav://plone.org/"))\n+        self.assertTrue(not is_absolute("./path/to/site"))\n+        self.assertTrue(not is_absolute("/resolveuid/"))\n \n     def test_is_same_domain(self):\n         from plone.app.z3cform.utils import is_same_domain\n \n         # Those use the same protocol and are on the same domaain\n-        self.assertTrue(is_same_domain(\n-            \'https://plone.org/doc1\',\n-            \'https://plone.org/doc2/doc3\',\n-        ))\n+        self.assertTrue(\n+            is_same_domain(\n+                "https://plone.org/doc1",\n+                "https://plone.org/doc2/doc3",\n+            )\n+        )\n \n         # These are two completly different URLs\n-        self.assertTrue(not is_same_domain(\n-            \'https://domain1.com\',\n-            \'https://anotherdomain.com\',\n-        ))\n+        self.assertTrue(\n+            not is_same_domain(\n+                "https://domain1.com",\n+                "https://anotherdomain.com",\n+            )\n+        )\n \n         # Here, different transport protocols are used. Returning False.\n-        self.assertTrue(not is_same_domain(\n-            \'https://plone.org\',\n-            \'http://plone.org\',\n-        ))\n+        self.assertTrue(\n+            not is_same_domain(\n+                "https://plone.org",\n+                "http://plone.org",\n+            )\n+        )\ndiff --git a/plone/app/z3cform/tests/test_widget.py b/plone/app/z3cform/tests/test_widget.py\nindex 1c248577..008d63e1 100644\n--- a/plone/app/z3cform/tests/test_widget.py\n+++ b/plone/app/z3cform/tests/test_widget.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.z3cform.interfaces import IPloneFormLayer\n from plone.app.z3cform.tests.layer import PAZ3CForm_INTEGRATION_TESTING\n from plone.app.z3cform.wysiwyg.widget import WysiwygWidget\n@@ -14,11 +13,11 @@ class TestRequest(publisher.browser.TestRequest):\n     pass\n \n \n-class TestForm(object):\n+class TestForm:\n     context = None\n \n \n-class NoAcquisitionAware(object):\n+class NoAcquisitionAware:\n     context = None\n     request = TestRequest()\n \n@@ -41,10 +40,12 @@ def test_missing_aq_chain(self):\n         widget.form = TestForm()\n         widget.form.context = obj\n         widget.update()\n-        self.assertTrue(hasattr(widget.form.context, \'aq_chain\'))\n+        self.assertTrue(hasattr(widget.form.context, "aq_chain"))\n \n \n def test_suite():\n-    return unittest.TestSuite([\n-        unittest.makeSuite(TestWidget),\n-    ])\n+    return unittest.TestSuite(\n+        [\n+            unittest.defaultTestLoader.loadTestsFromTestCase(TestWidget),\n+        ]\n+    )\ndiff --git a/plone/app/z3cform/tests/test_widgets.py b/plone/app/z3cform/tests/test_widgets.py\nindex 90f74483..d2331384 100644\n--- a/plone/app/z3cform/tests/test_widgets.py\n+++ b/plone/app/z3cform/tests/test_widgets.py\n@@ -1,10 +1,8 @@\n-# -*- coding: utf-8 -*-\n from datetime import date\n from datetime import datetime\n from datetime import time\n from json import loads\n from lxml import html\n-from mock import Mock\n from plone.app.contentlisting.contentlisting import ContentListing\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n@@ -20,7 +18,9 @@\n from plone.supermodel.model import Schema\n from plone.testing.zca import UNIT_TESTING\n from plone.uuid.interfaces import IUUID\n-from Products.CMFPlone.interfaces import IMarkupSchema\n+from plone.base.interfaces import IMarkupSchema\n+from unittest import mock\n+from unittest.mock import Mock\n from z3c.form.form import EditForm\n from z3c.form.form import Form\n from z3c.form.interfaces import IFormLayer\n@@ -54,20 +54,18 @@\n from zope.schema.vocabulary import SimpleVocabulary\n \n import json\n-import mock\n import pytz\n-import six\n import unittest\n \n \n @provider(IVocabularyFactory)\n def example_vocabulary_factory(context, query=None):\n-    items = [u\'One\', u\'Two\', u\'Three\']\n+    items = ["One", "Two", "Three"]\n     tmp = SimpleVocabulary(\n         [\n             SimpleTerm(\n                 item.lower(),  # value\n-                token=\'token_{0}\'.format(item.lower()),\n+                token=f"token_{item.lower()}",\n                 title=item,\n             )\n             for item in items\n@@ -79,10 +77,9 @@ def example_vocabulary_factory(context, query=None):\n \n \n class BaseWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n-        self.field = TextLine(__name__=\'textlinefield\')\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n+        self.field = TextLine(__name__="textlinefield")\n         self.maxDiff = 999999\n \n     def test_widget_pattern_notimplemented(self):\n@@ -94,12 +91,12 @@ def test_widget_pattern_notimplemented(self):\n             widget._base_args,\n         )\n \n-        widget.pattern = \'example\'\n+        widget.pattern = "example"\n \n         self.assertEqual(\n             {\n-                \'pattern\': \'example\',\n-                \'pattern_options\': {},\n+                "pattern": "example",\n+                "pattern_options": {},\n             },\n             widget._base_args(),\n         )\n@@ -110,7 +107,7 @@ def test_widget_base_notimplemented(self):\n \n         widget = BaseWidget(self.request)\n         widget.field = self.field\n-        widget.pattern = \'example\'\n+        widget.pattern = "example"\n \n         self.assertRaises(\n             PatternNotImplemented,\n@@ -130,28 +127,29 @@ def test_widget_base_custom_css(self):\n \n         widget = BaseWidget(self.request)\n         widget.field = self.field\n-        widget.pattern = \'example\'\n-        widget.klass = \'very-custom-class\'\n+        widget.pattern = "example"\n+        widget.klass = "very-custom-class"\n         widget._base = InputWidget\n \n         self.assertEqual(\n             \'<input class="pat-example very-custom-class" type="text"/>\',\n-            widget.render())\n+            widget.render(),\n+        )\n \n     def test_widget_base_pattern_options_with_functions(self):\n         from plone.app.widgets.base import InputWidget\n         from plone.app.z3cform.widget import BaseWidget\n \n         widget = BaseWidget(self.request)\n-        widget.context = \'testcontext\'\n+        widget.context = "testcontext"\n         widget.field = self.field\n-        widget.pattern = \'example\'\n+        widget.pattern = "example"\n         widget._base = InputWidget\n         widget.pattern_options = {\n-            \'subdict\': {\n-                \'subsubnormal\': 789,\n-                \'subsublist\': [7, 8, 9, lambda x: x],\n-                \'subsubtuple\': (7, 8, 9, lambda x: x),\n+            "subdict": {\n+                "subsubnormal": 789,\n+                "subsublist": [7, 8, 9, lambda x: x],\n+                "subsubtuple": (7, 8, 9, lambda x: x),\n             },\n         }\n         output = widget.render()\n@@ -160,103 +158,105 @@ def test_widget_base_pattern_options_with_functions(self):\n         # <input class="pat-example"\n         #        type="text"\n         #        data-pat-example="$JSON_ENCODED_OPTIONS" />\'\n-        self.assertRegexpMatches(widget.render(), \'<input .*/>\')\n+        self.assertRegex(widget.render(), "<input .*/>")\n         # We cannot foresee how the options are encoded\n         # so we will extract the attributes with lxml\n         # and be sure that they will match what we expect\n         observed_attrib = html.fromstring(output).attrib\n         self.assertEqual(\n             sorted(observed_attrib),\n-            [\'class\', \'data-pat-example\', \'type\'],\n+            ["class", "data-pat-example", "type"],\n         )\n-        self.assertEqual(observed_attrib[\'class\'], \'pat-example\')\n-        self.assertEqual(observed_attrib[\'type\'], \'text\')\n+        self.assertEqual(observed_attrib["class"], "pat-example")\n+        self.assertEqual(observed_attrib["type"], "text")\n         self.assertDictEqual(\n-            loads(observed_attrib[\'data-pat-example\']),\n+            loads(observed_attrib["data-pat-example"]),\n             {\n-                \'subdict\': {\n-                    \'subsubnormal\': 789,\n-                    \'subsublist\': [7, 8, 9, \'testcontext\'],\n-                    \'subsubtuple\': [7, 8, 9, \'testcontext\'],\n+                "subdict": {\n+                    "subsubnormal": 789,\n+                    "subsublist": [7, 8, 9, "testcontext"],\n+                    "subsubtuple": [7, 8, 9, "testcontext"],\n                 },\n             },\n         )\n \n \n class DateWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n         from plone.app.z3cform.widget import DateWidget\n \n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n-        self.field = Date(__name__=\'datefield\')\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n+        self.field = Date(__name__="datefield")\n         self.field.required = False\n         self.widget = DateWidget(self.request)\n         self.widget.field = self.field\n-        self.widget.pattern_options = {\'date\': {\'firstDay\': 0}}\n+        self.widget.pattern_options = {"date": {"firstDay": 0}}\n \n     def test_widget(self):\n         current_year = datetime.today().year\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'pattern\': \'date-picker\',\n-                \'pattern_options\': {\'behavior\': \'native\',\n-                                    \'clear\': \'Clear\',\n-                                    \'date\': {\'firstDay\': 0},\n-                                    \'first-day\': 0,\n-                                    \'today\': \'Today\',\n-                                    \'week-numbers\': \'show\'},\n-                \'value\': \'\',\n+                "name": None,\n+                "pattern": "date-picker",\n+                "pattern_options": {\n+                    "behavior": "native",\n+                    "clear": "Clear",\n+                    "date": {"firstDay": 0},\n+                    "first-day": 0,\n+                    "today": "Today",\n+                    "week-numbers": "show",\n+                },\n+                "value": "",\n             },\n             self.widget._base_args(),\n         )\n \n     def test_widget_required(self):\n-        """Required fields should not have a "Clear" button.\n-        """\n+        """Required fields should not have a "Clear" button."""\n         self.field.required = True\n         base_args = self.widget._base_args()\n-        self.assertEqual(base_args[\'pattern_options\'][\'clear\'], False)\n+        self.assertEqual(base_args["pattern_options"]["clear"], False)\n \n     def test_data_converter(self):\n         from plone.app.z3cform.widget import DateWidgetConverter\n+\n         converter = DateWidgetConverter(self.field, self.widget)\n \n         self.assertEqual(\n             converter.field.missing_value,\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n         )\n \n         self.assertEqual(\n             date(2000, 10, 30),\n-            converter.toFieldValue(\'2000-10-30\'),\n+            converter.toFieldValue("2000-10-30"),\n         )\n \n         self.assertEqual(\n             date(21, 10, 30),\n-            converter.toFieldValue(\'21-10-30\'),\n+            converter.toFieldValue("21-10-30"),\n         )\n \n         self.assertEqual(\n-            \'\',\n+            "",\n             converter.toWidgetValue(converter.field.missing_value),\n         )\n \n         self.assertEqual(\n-            \'2000-10-30\',\n+            "2000-10-30",\n             converter.toWidgetValue(date(2000, 10, 30)),\n         )\n \n         self.assertEqual(\n-            \'21-10-30\',\n+            "21-10-30",\n             converter.toWidgetValue(date(21, 10, 30)),\n         )\n \n     def test_fieldwidget(self):\n         from plone.app.z3cform.widget import DateFieldWidget\n         from plone.app.z3cform.widget import DateWidget\n-        field = Mock(__name__=\'field\', title=u\'\', required=True)\n+\n+        field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n         widget = DateFieldWidget(field, request)\n         self.assertTrue(isinstance(widget, DateWidget))\n@@ -265,83 +265,84 @@ def test_fieldwidget(self):\n \n \n class DatetimeWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n         from plone.app.z3cform.widget import DatetimeWidget\n \n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n-        self.field = Datetime(__name__=\'datetimefield\')\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n+        self.field = Datetime(__name__="datetimefield")\n         self.field.required = False\n         self.widget = DatetimeWidget(self.request)\n         self.widget.field = self.field\n         self.widget.pattern_options = {\n-            \'date\': {\'firstDay\': 0},\n-            \'time\': {\'interval\': 15},\n+            "date": {"firstDay": 0},\n+            "time": {"interval": 15},\n         }\n \n     def test_widget(self):\n         current_year = datetime.today().year\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'pattern\': \'datetime-picker\',\n-                \'pattern_options\': {\'behavior\': \'native\',\n-                                    \'clear\': \'Clear\',\n-                                    \'date\': {\'firstDay\': 0},\n-                                    \'first-day\': 0,\n-                                    \'time\': {\'interval\': 15},\n-                                    \'today\': \'Today\',\n-                                    \'week-numbers\': \'show\'},\n-                \'value\': \'\',\n+                "name": None,\n+                "pattern": "datetime-picker",\n+                "pattern_options": {\n+                    "behavior": "native",\n+                    "clear": "Clear",\n+                    "date": {"firstDay": 0},\n+                    "first-day": 0,\n+                    "time": {"interval": 15},\n+                    "today": "Today",\n+                    "week-numbers": "show",\n+                },\n+                "value": "",\n             },\n             self.widget._base_args(),\n         )\n \n     def test_widget_required(self):\n-        """Required fields should not have a "Clear" button.\n-        """\n+        """Required fields should not have a "Clear" button."""\n         self.field.required = True\n         base_args = self.widget._base_args()\n-        self.assertEqual(base_args[\'pattern_options\'][\'clear\'], False)\n+        self.assertEqual(base_args["pattern_options"]["clear"], False)\n \n     def test_data_converter(self):\n         from plone.app.z3cform.widget import DatetimeWidgetConverter\n+\n         converter = DatetimeWidgetConverter(self.field, self.widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             converter.field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'2000-10-30T15:40\'),\n+            converter.toFieldValue("2000-10-30T15:40"),\n             datetime(2000, 10, 30, 15, 40),\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'21-10-30T15:40\'),\n+            converter.toFieldValue("21-10-30T15:40"),\n             datetime(21, 10, 30, 15, 40),\n         )\n \n         self.assertEqual(\n             converter.toWidgetValue(converter.field.missing_value),\n-            \'\',\n+            "",\n         )\n \n         self.assertEqual(\n             converter.toWidgetValue(datetime(2000, 10, 30, 15, 40)),\n-            \'2000-10-30T15:40\',\n+            "2000-10-30T15:40",\n         )\n \n         self.assertEqual(\n             converter.toWidgetValue(datetime(21, 10, 30, 15, 40)),\n-            \'21-10-30T15:40\',\n+            "21-10-30T15:40",\n         )\n \n     def test_data_converter__no_timezone(self):\n-        """When no timezone is set, don\'t apply one.\n-        """\n+        """When no timezone is set, don\'t apply one."""\n         from plone.app.z3cform.widget import DatetimeWidgetConverter\n+\n         context = Mock()\n \n         dt = datetime(2013, 11, 13, 10, 20)\n@@ -351,7 +352,7 @@ def test_data_converter__no_timezone(self):\n \n         converter = DatetimeWidgetConverter(self.field, self.widget)\n         self.assertEqual(\n-            converter.toFieldValue(\'2013-11-13T10:20\'),\n+            converter.toFieldValue("2013-11-13T10:20"),\n             datetime(2013, 11, 13, 10, 20),\n         )\n \n@@ -360,20 +361,20 @@ def test_data_converter__no_timezone(self):\n         self.widget.default_timezone = None\n \n     def test_data_converter__timezone_id(self):\n-        """When a (pytz) timezone id is set, use that.\n-        """\n+        """When a (pytz) timezone id is set, use that."""\n         from plone.app.z3cform.widget import DatetimeWidgetConverter\n+\n         context = Mock()\n \n         dt = datetime(2013, 11, 13, 10, 20)\n         setattr(context, self.field.getName(), dt)\n         self.widget.context = context\n-        self.widget.default_timezone = \'Europe/Amsterdam\'\n-        tz = pytz.timezone(\'Europe/Amsterdam\')\n+        self.widget.default_timezone = "Europe/Amsterdam"\n+        tz = pytz.timezone("Europe/Amsterdam")\n \n         converter = DatetimeWidgetConverter(self.field, self.widget)\n         self.assertEqual(\n-            converter.toFieldValue(\'2013-11-13T10:20\'),\n+            converter.toFieldValue("2013-11-13T10:20"),\n             tz.localize(datetime(2013, 11, 13, 10, 20)),\n         )\n \n@@ -386,17 +387,18 @@ def test_data_converter__timezone_callback(self):\n         use that.\n         """\n         from plone.app.z3cform.widget import DatetimeWidgetConverter\n+\n         context = Mock()\n \n         dt = datetime(2013, 11, 13, 10, 20)\n         setattr(context, self.field.getName(), dt)\n         self.widget.context = context\n-        self.widget.default_timezone = lambda context: \'Europe/Amsterdam\'\n-        tz = pytz.timezone(\'Europe/Amsterdam\')\n+        self.widget.default_timezone = lambda context: "Europe/Amsterdam"\n+        tz = pytz.timezone("Europe/Amsterdam")\n \n         converter = DatetimeWidgetConverter(self.field, self.widget)\n         self.assertEqual(\n-            converter.toFieldValue(\'2013-11-13T10:20\'),\n+            converter.toFieldValue("2013-11-13T10:20"),\n             tz.localize(datetime(2013, 11, 13, 10, 20)),\n         )\n \n@@ -407,7 +409,8 @@ def test_data_converter__timezone_callback(self):\n     def test_fieldwidget(self):\n         from plone.app.z3cform.widget import DatetimeFieldWidget\n         from plone.app.z3cform.widget import DatetimeWidget\n-        field = Mock(__name__=\'field\', title=u\'\', required=True)\n+\n+        field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n         widget = DatetimeFieldWidget(field, request)\n         self.assertTrue(isinstance(widget, DatetimeWidget))\n@@ -416,47 +419,48 @@ def test_fieldwidget(self):\n \n \n class TimeWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n         from plone.app.z3cform.widget import TimeWidget\n \n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n-        self.field = Time(__name__=\'timefield\')\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n+        self.field = Time(__name__="timefield")\n         self.field.required = False\n         self.widget = TimeWidget(self.request)\n         self.widget.field = self.field\n \n     def test_widget(self):\n-        self.assertIn("<input type=\\"time\\"", self.widget.render())\n+        self.assertIn(\'<input type="time"\', self.widget.render())\n \n     def test_data_converter(self):\n         from plone.app.z3cform.converters import TimeWidgetConverter\n+\n         converter = TimeWidgetConverter(self.field, self.widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             converter.field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'15:40\'),\n+            converter.toFieldValue("15:40"),\n             time(15, 40),\n         )\n \n         self.assertEqual(\n             converter.toWidgetValue(converter.field.missing_value),\n-            \'\',\n+            "",\n         )\n \n         self.assertEqual(\n             converter.toWidgetValue(time(15, 40)),\n-            \'15:40\',\n+            "15:40",\n         )\n \n     def test_fieldwidget(self):\n         from plone.app.z3cform.widget import TimeFieldWidget\n         from plone.app.z3cform.widget import TimeWidget\n-        field = Mock(__name__=\'field\', title=u\'\', required=True)\n+\n+        field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n         widget = TimeFieldWidget(field, request)\n         self.assertTrue(isinstance(widget, TimeWidget))\n@@ -465,46 +469,48 @@ def test_fieldwidget(self):\n \n \n class SelectWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n         alsoProvides(self.request, IFormLayer)\n \n         # ITerms Adapters are needed for data converter\n         from z3c.form import term\n \n         import zope.component\n+\n         zope.component.provideAdapter(term.CollectionTerms)\n         zope.component.provideAdapter(term.CollectionTermsVocabulary)\n         zope.component.provideAdapter(term.CollectionTermsSource)\n \n     def tearDown(self):\n         from z3c.form import term\n+\n         base.unregisterAdapter(term.CollectionTerms)\n         base.unregisterAdapter(term.CollectionTermsVocabulary)\n         base.unregisterAdapter(term.CollectionTermsSource)\n \n     def test_widget(self):\n         from plone.app.z3cform.widget import SelectWidget\n+\n         widget = SelectWidget(self.request)\n-        widget.id = \'test-widget\'\n+        widget.id = "test-widget"\n         widget.field = Choice(\n-            __name__=\'selectfield\',\n-            values=[\'one\', \'two\', \'three\'],\n+            __name__="selectfield",\n+            values=["one", "two", "three"],\n         )\n         widget.terms = widget.field.vocabulary\n         widget.field.required = True\n         self.assertEqual(\n             {\n-                \'multiple\': None,\n-                \'name\': None,\n-                \'pattern_options\': {},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": None,\n+                "name": None,\n+                "pattern_options": {},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -513,16 +519,16 @@ def test_widget(self):\n         widget.field.required = False\n         self.assertEqual(\n             {\n-                \'multiple\': None,\n-                \'name\': None,\n-                \'pattern_options\': {\'allowClear\': True},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (u\'\', u\'\'),\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": None,\n+                "name": None,\n+                "pattern_options": {"allowClear": True},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("", ""),\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -532,15 +538,15 @@ def test_widget(self):\n         widget.multiple = True\n         self.assertEqual(\n             {\n-                \'multiple\': True,\n-                \'name\': None,\n-                \'pattern_options\': {\'separator\': \';\'},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": True,\n+                "name": None,\n+                "pattern_options": {"separator": ";"},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -550,32 +556,32 @@ def test_widget(self):\n         widget.multiple = True\n         self.assertEqual(\n             {\n-                \'multiple\': True,\n-                \'name\': None,\n-                \'pattern_options\': {\'allowClear\': True, \'separator\': \';\'},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": True,\n+                "name": None,\n+                "pattern_options": {"allowClear": True, "separator": ";"},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n         )\n \n-        widget.value = \'one\'\n+        widget.value = "one"\n         self.assertEqual(\n             {\n-                \'multiple\': True,\n-                \'name\': None,\n-                \'pattern_options\': {\'allowClear\': True, \'separator\': \';\'},\n-                \'pattern\': \'select2\',\n-                \'value\': (\'one\'),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": True,\n+                "name": None,\n+                "pattern_options": {"allowClear": True, "separator": ";"},\n+                "pattern": "select2",\n+                "value": ("one"),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -583,26 +589,26 @@ def test_widget(self):\n \n     def test_widget_list_orderable(self):\n         from plone.app.z3cform.widget import SelectWidget\n+\n         widget = SelectWidget(self.request)\n-        widget.id = \'test-widget\'\n-        widget.separator = \'.\'\n+        widget.id = "test-widget"\n+        widget.separator = "."\n         widget.field = List(\n-            __name__=\'selectfield\',\n-            value_type=Choice(values=[\'one\', \'two\', \'three\']),\n+            __name__="selectfield",\n+            value_type=Choice(values=["one", "two", "three"]),\n         )\n         widget.terms = widget.field.value_type.vocabulary\n         self.assertEqual(\n             {\n-                \'multiple\': True,\n-                \'name\': None,\n-                \'pattern_options\': {\n-                    \'orderable\': True, \'separator\': \'.\'},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": True,\n+                "name": None,\n+                "pattern_options": {"orderable": True, "separator": "."},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -610,25 +616,25 @@ def test_widget_list_orderable(self):\n \n     def test_widget_tuple_orderable(self):\n         from plone.app.z3cform.widget import SelectWidget\n+\n         widget = SelectWidget(self.request)\n-        widget.id = \'test-widget\'\n+        widget.id = "test-widget"\n         widget.field = Tuple(\n-            __name__=\'selectfield\',\n-            value_type=Choice(values=[\'one\', \'two\', \'three\']),\n+            __name__="selectfield",\n+            value_type=Choice(values=["one", "two", "three"]),\n         )\n         widget.terms = widget.field.value_type.vocabulary\n         self.assertEqual(\n             {\n-                \'multiple\': True,\n-                \'name\': None,\n-                \'pattern_options\': {\n-                    \'orderable\': True, \'separator\': \';\'},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": True,\n+                "name": None,\n+                "pattern_options": {"orderable": True, "separator": ";"},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -636,25 +642,26 @@ def test_widget_tuple_orderable(self):\n \n     def test_widget_set_not_orderable(self):\n         from plone.app.z3cform.widget import SelectWidget\n+\n         widget = SelectWidget(self.request)\n-        widget.id = \'test-widget\'\n+        widget.id = "test-widget"\n         # A set is not orderable\n         widget.field = Set(\n-            __name__=\'selectfield\',\n-            value_type=Choice(values=[\'one\', \'two\', \'three\']),\n+            __name__="selectfield",\n+            value_type=Choice(values=["one", "two", "three"]),\n         )\n         widget.terms = widget.field.value_type.vocabulary\n         self.assertEqual(\n             {\n-                \'multiple\': True,\n-                \'name\': None,\n-                \'pattern_options\': {\'separator\': \';\'},\n-                \'pattern\': \'select2\',\n-                \'value\': (),\n-                \'items\': [\n-                    (\'one\', \'one\'),\n-                    (\'two\', \'two\'),\n-                    (\'three\', \'three\'),\n+                "multiple": True,\n+                "name": None,\n+                "pattern_options": {"separator": ";"},\n+                "pattern": "select2",\n+                "value": (),\n+                "items": [\n+                    ("one", "one"),\n+                    ("two", "two"),\n+                    ("three", "three"),\n                 ],\n             },\n             widget._base_args(),\n@@ -662,27 +669,28 @@ def test_widget_set_not_orderable(self):\n \n     def test_widget_extract(self):\n         from plone.app.z3cform.widget import SelectWidget\n+\n         widget = SelectWidget(self.request)\n         widget.field = Choice(\n-            __name__=\'selectfield\',\n-            values=[\'one\', \'two\', \'three\'],\n+            __name__="selectfield",\n+            values=["one", "two", "three"],\n         )\n-        widget.name = \'selectfield\'\n-        self.request.form[\'selectfield\'] = \'one\'\n-        self.assertEqual(widget.extract(), \'one\')\n+        widget.name = "selectfield"\n+        self.request.form["selectfield"] = "one"\n+        self.assertEqual(widget.extract(), "one")\n         widget.multiple = True\n-        self.request.form[\'selectfield\'] = \'one;two\'\n-        self.assertEqual(widget.extract(), \'one;two\')\n+        self.request.form["selectfield"] = "one;two"\n+        self.assertEqual(widget.extract(), "one;two")\n \n     def test_data_converter_list(self):\n         from plone.app.z3cform.converters import SelectWidgetConverter\n         from plone.app.z3cform.widget import SelectWidget\n \n         field = List(\n-            __name__=\'listfield\',\n+            __name__="listfield",\n             value_type=Choice(\n-                __name__=\'selectfield\',\n-                values=[\'one\', \'two\', \'three\'],\n+                __name__="selectfield",\n+                values=["one", "two", "three"],\n             ),\n         )\n         widget = SelectWidget(self.request)\n@@ -691,13 +699,13 @@ def test_data_converter_list(self):\n         converter = SelectWidgetConverter(field, widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'one;two;three\'),\n-            [\'one\', \'two\', \'three\'],\n+            converter.toFieldValue("one;two;three"),\n+            ["one", "two", "three"],\n         )\n \n         self.assertEqual(\n@@ -705,19 +713,20 @@ def test_data_converter_list(self):\n             [],\n         )\n \n-        widget.separator = \',\'\n+        widget.separator = ","\n         self.assertEqual(\n-            converter.toFieldValue(\'one,two,three\'),\n-            [\'one\', \'two\', \'three\'],\n+            converter.toFieldValue("one,two,three"),\n+            ["one", "two", "three"],\n         )\n         self.assertRaises(\n             LookupError,\n-            converter.toFieldValue, \'one;two;three\',\n+            converter.toFieldValue,\n+            "one;two;three",\n         )\n \n         self.assertEqual(\n-            converter.toWidgetValue([\'one\', \'two\', \'three\']),\n-            [\'one\', \'two\', \'three\'],\n+            converter.toWidgetValue(["one", "two", "three"]),\n+            ["one", "two", "three"],\n         )\n \n     def test_data_converter_tuple(self):\n@@ -725,10 +734,10 @@ def test_data_converter_tuple(self):\n         from plone.app.z3cform.widget import SelectWidget\n \n         field = Tuple(\n-            __name__=\'tuplefield\',\n+            __name__="tuplefield",\n             value_type=Choice(\n-                __name__=\'selectfield\',\n-                values=[\'one\', \'two\', \'three\'],\n+                __name__="selectfield",\n+                values=["one", "two", "three"],\n             ),\n         )\n         widget = SelectWidget(self.request)\n@@ -737,13 +746,13 @@ def test_data_converter_tuple(self):\n         converter = SelectWidgetConverter(field, widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'one;two;three\'),\n-            (\'one\', \'two\', \'three\'),\n+            converter.toFieldValue("one;two;three"),\n+            ("one", "two", "three"),\n         )\n \n         self.assertEqual(\n@@ -752,24 +761,25 @@ def test_data_converter_tuple(self):\n         )\n \n         self.assertEqual(\n-            converter.toWidgetValue((\'one\', \'two\', \'three\')),\n-            [\'one\', \'two\', \'three\'],\n+            converter.toWidgetValue(("one", "two", "three")),\n+            ["one", "two", "three"],\n         )\n \n     def test_data_converter_handles_empty_value(self):\n         from plone.app.z3cform.converters import SelectWidgetConverter\n         from plone.app.z3cform.widget import SelectWidget\n \n-        field = Tuple(__name__=\'tuplefield\',\n-                      value_type=Choice(__name__=\'selectfield\',\n-                                        values=[\'one\', \'two\', \'three\']))\n+        field = Tuple(\n+            __name__="tuplefield",\n+            value_type=Choice(__name__="selectfield", values=["one", "two", "three"]),\n+        )\n         widget = SelectWidget(self.request)\n         widget.field = field\n         widget.multiple = True\n         converter = SelectWidgetConverter(field, widget)\n \n         self.assertEqual(\n-            converter.toFieldValue((u\'\',)),\n+            converter.toFieldValue(("",)),\n             field.missing_value,\n         )\n \n@@ -779,37 +789,49 @@ def test_widget_optgroup(self):\n         """\n         from plone.app.z3cform.widget import SelectWidget\n         from z3c.form import term\n+\n         widget = SelectWidget(self.request)\n-        widget.field = Choice(vocabulary=vocabulary.TreeVocabulary.fromDict({\n-            (\'foo_group\', \'Foo Group\'): {\n-                (\'bar_group\', \'Bar Group\'): {},\n-                (\'qux_group\', \'Qux Group\'): {},\n-            },\n-            (\'corge_group\', \'Corge Group\'): {\n-                (\'grault_group\', \'Grault Group\'): {},\n-                (\'garply_group\', \'Garply Group\'): {},\n-            },\n-        }))\n+        widget.field = Choice(\n+            vocabulary=vocabulary.TreeVocabulary.fromDict(\n+                {\n+                    ("foo_group", "Foo Group"): {\n+                        ("bar_group", "Bar Group"): {},\n+                        ("qux_group", "Qux Group"): {},\n+                    },\n+                    ("corge_group", "Corge Group"): {\n+                        ("grault_group", "Grault Group"): {},\n+                        ("garply_group", "Garply Group"): {},\n+                    },\n+                }\n+            )\n+        )\n         # Usse term.CollectionTermsVocabulary to simulate a named vocabulary\n         # factory lookup\n         widget.terms = term.CollectionTermsVocabulary(\n-            context=None, request=self.request, form=None, field=None,\n-            widget=widget, vocabulary=widget.field.vocabulary)\n+            context=None,\n+            request=self.request,\n+            form=None,\n+            field=None,\n+            widget=widget,\n+            vocabulary=widget.field.vocabulary,\n+        )\n         widget.updateTerms()\n         html = widget.render()\n         self.assertNotIn(\n-            \'<option value="foo_group">\', html,\n-            \'Top level vocab item rendered as <option...>\')\n+            \'<option value="foo_group">\',\n+            html,\n+            "Top level vocab item rendered as <option...>",\n+        )\n         self.assertIn(\n-            \'<optgroup label="Foo Group">\', html,\n-            \'Rendered select widget missing an <optgroup...>\')\n+            \'<optgroup label="Foo Group">\',\n+            html,\n+            "Rendered select widget missing an <optgroup...>",\n+        )\n \n         base_args = widget._base_args()\n         pattern_widget = widget._base(**base_args)\n         items = pattern_widget.items\n-        self.assertIsInstance(\n-            items, dict,\n-            \'Wrong widget items type\')\n+        self.assertIsInstance(items, dict, "Wrong widget items type")\n \n \n class AjaxSelectWidgetTests(unittest.TestCase):\n@@ -818,50 +840,51 @@ class AjaxSelectWidgetTests(unittest.TestCase):\n     maxDiff = None\n \n     def setUp(self):\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n-        provideUtility(example_vocabulary_factory, name=u\'example\')\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n+        provideUtility(example_vocabulary_factory, name="example")\n \n     def test_widget(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n+\n         widget = AjaxSelectWidget(self.request)\n         widget.update()\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\'separator\': \';\'},\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {"separator": ";"},\n             },\n             widget._base_args(),\n         )\n \n-        widget.vocabulary = \'example\'\n+        widget.vocabulary = "example"\n         self.assertEqual(\n             widget._base_args(),\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\n-                    \'vocabularyUrl\': \'/@@getVocabulary?name=example\',\n-                    \'separator\': \';\',\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {\n+                    "vocabularyUrl": "/@@getVocabulary?name=example",\n+                    "separator": ";",\n                 },\n             },\n         )\n \n-        widget.value = \'token_three;token_two\'\n+        widget.value = "token_three;token_two"\n         self.assertDictEqual(\n             {\n-                \'name\': None,\n-                \'value\': \'token_three;token_two\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\n-                    \'vocabularyUrl\': \'/@@getVocabulary?name=example\',\n-                    \'initialValues\': {\n-                        \'token_three\': u\'Three\',\n-                        \'token_two\': u\'Two\',\n+                "name": None,\n+                "value": "token_three;token_two",\n+                "pattern": "select2",\n+                "pattern_options": {\n+                    "vocabularyUrl": "/@@getVocabulary?name=example",\n+                    "initialValues": {\n+                        "token_three": "Three",\n+                        "token_two": "Two",\n                     },\n-                    \'separator\': \';\',\n+                    "separator": ";",\n                 },\n             },\n             widget._base_args(),\n@@ -869,43 +892,46 @@ def test_widget(self):\n \n     def test_widget_list_orderable(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n+\n         widget = AjaxSelectWidget(self.request)\n-        widget.field = List(__name__=\'selectfield\')\n+        widget.field = List(__name__="selectfield")\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\'orderable\': True, \'separator\': \';\'},\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {"orderable": True, "separator": ";"},\n             },\n             widget._base_args(),\n         )\n \n     def test_widget_tuple_orderable(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n+\n         widget = AjaxSelectWidget(self.request)\n-        widget.field = Tuple(__name__=\'selectfield\')\n+        widget.field = Tuple(__name__="selectfield")\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\'orderable\': True, \'separator\': \';\'},\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {"orderable": True, "separator": ";"},\n             },\n             widget._base_args(),\n         )\n \n     def test_widget_set_not_orderable(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n+\n         widget = AjaxSelectWidget(self.request)\n         # A set is not orderable\n-        widget.field = Set(__name__=\'selectfield\')\n+        widget.field = Set(__name__="selectfield")\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\'separator\': \';\'},\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {"separator": ";"},\n             },\n             widget._base_args(),\n         )\n@@ -913,22 +939,22 @@ def test_widget_set_not_orderable(self):\n     def test_widget_choice(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n         from zope.schema.interfaces import ISource\n+\n         widget = AjaxSelectWidget(self.request)\n         source = Mock()\n         alsoProvides(source, ISource)\n-        widget.field = Choice(__name__=\'choicefield\', source=source)\n-        widget.name = \'choicefield\'\n+        widget.field = Choice(__name__="choicefield", source=source)\n+        widget.name = "choicefield"\n         self.assertEqual(\n             {\n-                \'name\': \'choicefield\',\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\n-                    \'separator\': \';\',\n-                    \'maximumSelectionSize\': 1,\n-                    \'allowNewItems\': \'false\',\n-                    \'vocabularyUrl\':\n-                        \'http://127.0.0.1/++widget++choicefield/@@getSource\',\n+                "name": "choicefield",\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {\n+                    "separator": ";",\n+                    "maximumSelectionSize": 1,\n+                    "allowNewItems": "false",\n+                    "vocabularyUrl": "http://127.0.0.1/++widget++choicefield/@@getSource",\n                 },\n             },\n             widget._base_args(),\n@@ -936,32 +962,33 @@ def test_widget_choice(self):\n \n     def test_widget_addform_url_on_addform(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n+\n         widget = AjaxSelectWidget(self.request)\n         form = Mock(parentForm=None)\n         from z3c.form.interfaces import IAddForm\n         from zope.interface import directlyProvides  # noqa\n+\n         directlyProvides(form, IAddForm)  # noqa\n-        form.request = {\'URL\': \'http://addform_url\'}\n+        form.request = {"URL": "http://addform_url"}\n         widget.form = form\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\'separator\': \';\'},\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {"separator": ";"},\n             },\n             widget._base_args(),\n         )\n-        widget.vocabulary = \'vocabulary1\'\n+        widget.vocabulary = "vocabulary1"\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'select2\',\n-                \'pattern_options\': {\n-                    \'separator\': \';\',\n-                    \'vocabularyUrl\':\n-                    \'http://addform_url/@@getVocabulary?name=vocabulary1\',\n+                "name": None,\n+                "value": "",\n+                "pattern": "select2",\n+                "pattern_options": {\n+                    "separator": ";",\n+                    "vocabularyUrl": "http://addform_url/@@getVocabulary?name=vocabulary1",\n                 },\n             },\n             widget._base_args(),\n@@ -971,19 +998,19 @@ def test_data_converter_list(self):\n         from plone.app.z3cform.converters import AjaxSelectWidgetConverter\n         from plone.app.z3cform.widget import AjaxSelectWidget\n \n-        field = List(__name__=\'listfield\', value_type=TextLine())\n+        field = List(__name__="listfield", value_type=TextLine())\n         widget = AjaxSelectWidget(self.request)\n         widget.field = field\n         converter = AjaxSelectWidgetConverter(field, widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'123;456;789\'),\n-            [\'123\', \'456\', \'789\'],\n+            converter.toFieldValue("123;456;789"),\n+            ["123", "456", "789"],\n         )\n \n         self.assertEqual(\n@@ -992,8 +1019,8 @@ def test_data_converter_list(self):\n         )\n \n         self.assertEqual(\n-            converter.toWidgetValue([\'123\', \'456\', \'789\']),\n-            \'123;456;789\',\n+            converter.toWidgetValue(["123", "456", "789"]),\n+            "123;456;789",\n         )\n \n     def test_data_converter_collection_with_vocabulary(self):\n@@ -1001,9 +1028,9 @@ def test_data_converter_collection_with_vocabulary(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n \n         field = Tuple(\n-            __name__=\'listfield\',\n+            __name__="listfield",\n             value_type=Choice(\n-                vocabulary=\'example\',\n+                vocabulary="example",\n             ),\n         )\n         widget = AjaxSelectWidget(self.request)\n@@ -1011,13 +1038,13 @@ def test_data_converter_collection_with_vocabulary(self):\n         converter = AjaxSelectWidgetConverter(field, widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'token_one;token_two;token_three\'),\n-            (\'one\', \'two\', \'three\'),\n+            converter.toFieldValue("token_one;token_two;token_three"),\n+            ("one", "two", "three"),\n         )\n \n         self.assertEqual(\n@@ -1026,27 +1053,27 @@ def test_data_converter_collection_with_vocabulary(self):\n         )\n \n         self.assertEqual(\n-            converter.toWidgetValue([\'123\', \'456\', \'789\']),\n-            \'123;456;789\',\n+            converter.toWidgetValue(["123", "456", "789"]),\n+            "123;456;789",\n         )\n \n     def test_data_converter_tuple(self):\n         from plone.app.z3cform.converters import AjaxSelectWidgetConverter\n         from plone.app.z3cform.widget import AjaxSelectWidget\n \n-        field = Tuple(__name__=\'tuplefield\', value_type=TextLine())\n+        field = Tuple(__name__="tuplefield", value_type=TextLine())\n         widget = AjaxSelectWidget(self.request)\n         widget.field = field\n         converter = AjaxSelectWidgetConverter(field, widget)\n \n         self.assertEqual(\n-            converter.toFieldValue(\'\'),\n+            converter.toFieldValue(""),\n             field.missing_value,\n         )\n \n         self.assertEqual(\n-            converter.toFieldValue(\'123;456;789\'),\n-            (\'123\', \'456\', \'789\'),\n+            converter.toFieldValue("123;456;789"),\n+            ("123", "456", "789"),\n         )\n \n         self.assertEqual(\n@@ -1055,14 +1082,15 @@ def test_data_converter_tuple(self):\n         )\n \n         self.assertEqual(\n-            converter.toWidgetValue((\'123\', \'456\', \'789\')),\n-            \'123;456;789\',\n+            converter.toWidgetValue(("123", "456", "789")),\n+            "123;456;789",\n         )\n \n     def test_fieldwidget(self):\n         from plone.app.z3cform.widget import AjaxSelectFieldWidget\n         from plone.app.z3cform.widget import AjaxSelectWidget\n-        field = Mock(__name__=\'field\', title=u\'\', required=True)\n+\n+        field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n         widget = AjaxSelectFieldWidget(field, request)\n         self.assertTrue(isinstance(widget, AjaxSelectWidget))\n@@ -1072,7 +1100,8 @@ def test_fieldwidget(self):\n     def test_fieldwidget_sequence(self):\n         from plone.app.z3cform.widget import AjaxSelectFieldWidget\n         from plone.app.z3cform.widget import AjaxSelectWidget\n-        field = Mock(__name__=\'field\', title=u\'\', required=True)\n+\n+        field = Mock(__name__="field", title="", required=True)\n         vocabulary = Mock()\n         request = Mock()\n         widget = AjaxSelectFieldWidget(field, vocabulary, request)\n@@ -1086,74 +1115,76 @@ class AjaxSelectWidgetIntegrationTests(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n \n     def test_keywords_can_add(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n \n-        portal = self.layer[\'portal\']\n-        setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+        portal = self.layer["portal"]\n+        setRoles(portal, TEST_USER_ID, ["Manager"])\n         widget = AjaxSelectWidget(self.request)\n         widget.context = portal\n-        widget.vocabulary = \'plone.app.vocabularies.Keywords\'\n+        widget.vocabulary = "plone.app.vocabularies.Keywords"\n         self.assertEqual(\n-            widget._base_args()[\'pattern_options\'][\'allowNewItems\'],\n-            \'true\',\n+            widget._base_args()["pattern_options"]["allowNewItems"],\n+            "true",\n         )\n \n     def test_keywords_cannot_add(self):\n         from plone.app.z3cform.widget import AjaxSelectWidget\n \n-        portal = self.layer[\'portal\']\n+        portal = self.layer["portal"]\n         widget = AjaxSelectWidget(self.request)\n         widget.context = portal\n-        widget.vocabulary = \'plone.app.vocabularies.Keywords\'\n+        widget.vocabulary = "plone.app.vocabularies.Keywords"\n         self.assertEqual(\n-            widget._base_args()[\'pattern_options\'][\'allowNewItems\'],\n-            \'false\',\n+            widget._base_args()["pattern_options"]["allowNewItems"],\n+            "false",\n         )\n \n \n class QueryStringWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n \n     def test_converter_toWidgetValue(self):\n         from plone.app.z3cform.converters import QueryStringDataConverter\n+\n         converter = QueryStringDataConverter(List(), None)\n-        self.assertEqual(converter.toWidgetValue(None), u\'[]\')\n-        self.assertEqual(converter.toWidgetValue([]), u\'[]\')\n+        self.assertEqual(converter.toWidgetValue(None), "[]")\n+        self.assertEqual(converter.toWidgetValue([]), "[]")\n \n     def test_converter_empty_value(self):\n         from plone.app.z3cform.converters import QueryStringDataConverter\n+\n         converter = QueryStringDataConverter(List(), None)\n-        self.assertEqual(converter.toFieldValue(u\'\'), None)\n-        self.assertEqual(converter.toFieldValue(u\'[]\'), None)\n+        self.assertEqual(converter.toFieldValue(""), None)\n+        self.assertEqual(converter.toFieldValue("[]"), None)\n \n     @mock.patch(\n-        \'plone.app.widgets.utils.get_date_options\',\n+        "plone.app.widgets.utils.get_date_options",\n         new=lambda *args, **kwargs: None,\n     )\n     @mock.patch(\n-        \'plone.app.widgets.utils.get_relateditems_options\',\n+        "plone.app.widgets.utils.get_relateditems_options",\n         new=lambda *args, **kwargs: None,\n     )\n     def test_widget(self):\n         from plone.app.z3cform.widget import QueryStringWidget\n+\n         widget = QueryStringWidget(self.request)\n         self.assertEqual(\n             {\n-                \'name\': None,\n-                \'value\': u\'\',\n-                \'pattern\': \'querystring\',\n-                \'pattern_options\': {\n-                    \'indexOptionsUrl\': \'/@@qsOptions\',\n-                    \'previewCountURL\': \'/@@querybuildernumberofresults\',\n-                    \'previewURL\': \'/@@querybuilder_html_results\',\n-                    \'patternAjaxSelectOptions\': {\'separator\': \';\'},\n-                    \'patternDateOptions\': None,\n-                    \'patternRelateditemsOptions\': None,\n+                "name": None,\n+                "value": "",\n+                "pattern": "querystring",\n+                "pattern_options": {\n+                    "indexOptionsUrl": "/@@qsOptions",\n+                    "previewCountURL": "/@@querybuildernumberofresults",\n+                    "previewURL": "/@@querybuilder_html_results",\n+                    "patternAjaxSelectOptions": {"separator": ";"},\n+                    "patternDateOptions": None,\n+                    "patternRelateditemsOptions": None,\n                 },\n             },\n             widget._base_args(),\n@@ -1165,10 +1196,10 @@ class RelatedItemsWidgetIntegrationTests(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n+        self.portal = self.layer["portal"]\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n         setRequest(self.request)\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def assertDictContainsSubsetReplacement(self, actual, expected):\n         """assertDictContainsSubset was removed in Python 3.2, see:\n@@ -1180,10 +1211,11 @@ def assertDictContainsSubsetReplacement(self, actual, expected):\n \n     def test_related_items_widget(self):\n         from plone.app.z3cform.widget import RelatedItemsWidget\n-        EXPECTED_ROOT_PATH = \'/plone\'\n-        EXPECTED_ROOT_URL = \'http://nohost/plone\'\n-        EXPECTED_BASE_PATH = \'/plone\'\n-        EXPECTED_VOCAB_URL = \'http://nohost/plone/@@getVocabulary?name=plone.app.vocabularies.Catalog\'  # noqa\n+\n+        EXPECTED_ROOT_PATH = "/plone"\n+        EXPECTED_ROOT_URL = "http://nohost/plone"\n+        EXPECTED_BASE_PATH = "/plone"\n+        EXPECTED_VOCAB_URL = "http://nohost/plone/@@getVocabulary?name=plone.app.vocabularies.Catalog"  # noqa\n \n         widget = RelatedItemsWidget(self.request)\n         widget.context = self.portal\n@@ -1193,31 +1225,32 @@ def test_related_items_widget(self):\n \n         self.assertEqual(\n             EXPECTED_ROOT_PATH,\n-            result[\'pattern_options\'][\'rootPath\'],\n+            result["pattern_options"]["rootPath"],\n         )\n         self.assertEqual(\n             EXPECTED_ROOT_URL,\n-            result[\'pattern_options\'][\'rootUrl\'],\n+            result["pattern_options"]["rootUrl"],\n         )\n         self.assertEqual(\n             EXPECTED_BASE_PATH,\n-            result[\'pattern_options\'][\'basePath\'],\n+            result["pattern_options"]["basePath"],\n         )\n         self.assertEqual(\n             EXPECTED_VOCAB_URL,\n-            result[\'pattern_options\'][\'vocabularyUrl\'],\n+            result["pattern_options"]["vocabularyUrl"],\n         )\n \n     def test_related_items_widget_nav_root(self):\n         from plone.app.layout.navigation.interfaces import INavigationRoot\n         from plone.app.z3cform.widget import RelatedItemsWidget\n-        EXPECTED_ROOT_PATH = \'/plone\'\n-        EXPECTED_ROOT_URL = \'http://nohost/plone\'\n-        EXPECTED_BASE_PATH = \'/plone/subfolder\'\n-        EXPECTED_VOCAB_URL = \'http://nohost/plone/@@getVocabulary?name=plone.app.vocabularies.Catalog\'  # noqa\n \n-        self.portal.invokeFactory(\'Folder\', \'subfolder\')\n-        subfolder = self.portal[\'subfolder\']\n+        EXPECTED_ROOT_PATH = "/plone"\n+        EXPECTED_ROOT_URL = "http://nohost/plone"\n+        EXPECTED_BASE_PATH = "/plone/subfolder"\n+        EXPECTED_VOCAB_URL = "http://nohost/plone/@@getVocabulary?name=plone.app.vocabularies.Catalog"  # noqa\n+\n+        self.portal.invokeFactory("Folder", "subfolder")\n+        subfolder = self.portal["subfolder"]\n         alsoProvides(subfolder, INavigationRoot)\n \n         widget = RelatedItemsWidget(self.request)\n@@ -1227,27 +1260,25 @@ def test_related_items_widget_nav_root(self):\n \n         self.assertEqual(\n             EXPECTED_ROOT_PATH,\n-            result[\'pattern_options\'][\'rootPath\'],\n+            result["pattern_options"]["rootPath"],\n         )\n         self.assertEqual(\n             EXPECTED_ROOT_URL,\n-            result[\'pattern_options\'][\'rootUrl\'],\n+            result["pattern_options"]["rootUrl"],\n         )\n         self.assertEqual(\n             EXPECTED_BASE_PATH,\n-            result[\'pattern_options\'][\'basePath\'],\n+            result["pattern_options"]["basePath"],\n         )\n         self.assertEqual(\n             EXPECTED_VOCAB_URL,\n-            result[\'pattern_options\'][\'vocabularyUrl\'],\n+            result["pattern_options"]["vocabularyUrl"],\n         )\n \n \n class IRelationsType(Interface):\n-    single = RelationChoice(title=u\'Single\',\n-                            required=False, values=[])\n-    multiple = RelationList(title=u\'Multiple (Relations field)\',\n-                            required=False)\n+    single = RelationChoice(title="Single", required=False, values=[])\n+    multiple = RelationList(title="Multiple (Relations field)", required=False)\n \n \n class RelatedItemsWidgetTemplateIntegrationTests(unittest.TestCase):\n@@ -1255,38 +1286,39 @@ class RelatedItemsWidgetTemplateIntegrationTests(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_related_items_widget_display_template(self):\n-        rel_fti = DexterityFTI(\n-            \'RelationsType\',\n-            schema=IRelationsType.__identifier__\n-        )\n-        self.portal.portal_types._setObject(\'RelationsType\', rel_fti)\n+        rel_fti = DexterityFTI("RelationsType", schema=IRelationsType.__identifier__)\n+        self.portal.portal_types._setObject("RelationsType", rel_fti)\n \n         intids = getUtility(IIntIds)\n \n-        self.portal.invokeFactory(\'RelationsType\', \'source\', title=u\'A Source\')\n-        self.portal.invokeFactory(\'RelationsType\', \'target\', title=u\'A Target\')\n-        self.portal.invokeFactory(\'Document\', \'doc\', title=u\'A Document\')\n-        source = self.portal[\'source\']\n-        target = self.portal[\'target\']\n-        doc = self.portal[\'doc\']\n+        self.portal.invokeFactory("RelationsType", "source", title="A Source")\n+        self.portal.invokeFactory("RelationsType", "target", title="A Target")\n+        self.portal.invokeFactory("Document", "doc", title="A Document")\n+        source = self.portal["source"]\n+        target = self.portal["target"]\n+        doc = self.portal["doc"]\n \n         # Add some relations\n         source.single = RelationValue(intids.getId(target))\n-        source.multiple = [RelationValue(intids.getId(target)), RelationValue(intids.getId(doc))]\n+        source.multiple = [\n+            RelationValue(intids.getId(target)),\n+            RelationValue(intids.getId(doc)),\n+        ]\n \n         # Update relations\n         from zope.event import notify\n         from zope.lifecycleevent import ObjectModifiedEvent\n+\n         notify(ObjectModifiedEvent(source))\n-        default_view = source.restrictedTraverse(\'@@view\')\n+        default_view = source.restrictedTraverse("@@view")\n         default_view.update()\n \n-        single = default_view.w[\'single\']\n+        single = default_view.w["single"]\n         self.assertIsInstance(single, RelatedItemsWidget)\n         self.assertTrue(single.value, target.UID())\n         items = single.items()\n@@ -1295,14 +1327,19 @@ def test_related_items_widget_display_template(self):\n \n         template = getMultiAdapter(\n             (source, self.request, single.form, single.field, single),\n-            IPageTemplate, name=single.mode)\n-        self.assertTrue(template.filename.endswith(\'relateditems_display.pt\'))\n+            IPageTemplate,\n+            name=single.mode,\n+        )\n+        self.assertTrue(template.filename.endswith("relateditems_display.pt"))\n         html = template(single)\n-        self.assertIn(\'<span class="contenttype-relationstype state-missing-value url">A Target</span>\', html)\n+        self.assertIn(\n+            \'<span class="contenttype-relationstype state-missing-value url">A Target</span>\',\n+            html,\n+        )\n \n-        multiple = default_view.w[\'multiple\']\n+        multiple = default_view.w["multiple"]\n         self.assertIsInstance(multiple, RelatedItemsWidget)\n-        self.assertTrue(multiple.value, \';\'.join([target.UID(), doc.UID()]))\n+        self.assertTrue(multiple.value, ";".join([target.UID(), doc.UID()]))\n         items = multiple.items()\n         self.assertIsInstance(items, ContentListing)\n         self.assertTrue(items[0].UID, target.UID())\n@@ -1310,42 +1347,51 @@ def test_related_items_widget_display_template(self):\n \n         template = getMultiAdapter(\n             (source, self.request, multiple.form, multiple.field, multiple),\n-            IPageTemplate, name=multiple.mode)\n-        self.assertTrue(template.filename.endswith(\'relateditems_display.pt\'))\n+            IPageTemplate,\n+            name=multiple.mode,\n+        )\n+        self.assertTrue(template.filename.endswith("relateditems_display.pt"))\n         html = template(multiple)\n-        self.assertIn(\'<span class="contenttype-relationstype state-missing-value url">A Target</span>\', html)\n-        self.assertIn(\'<span class="contenttype-document state-missing-value url">A Document</span>\', html)\n+        self.assertIn(\n+            \'<span class="contenttype-relationstype state-missing-value url">A Target</span>\',\n+            html,\n+        )\n+        self.assertIn(\n+            \'<span class="contenttype-document state-missing-value url">A Document</span>\',\n+            html,\n+        )\n \n \n class RelatedItemsWidgetTests(unittest.TestCase):\n-\n     def setUp(self):\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n \n     @mock.patch(\n-        \'plone.app.widgets.utils.getToolByName\',\n-        new=Mock(return_value=Mock(return_value=\'testuser\')),\n+        "plone.app.widgets.utils.getToolByName",\n+        new=Mock(return_value=Mock(return_value="testuser")),\n     )\n     def test_single_selection(self):\n         """The pattern_options value for maximumSelectionSize should\n         be 1 when the field only allows a single selection."""\n         from plone.app.z3cform.widget import RelatedItemsFieldWidget\n-        context = Mock(absolute_url=lambda: \'fake_url\',\n-                       getPhysicalPath=lambda: [\'\', \'site\'])\n+\n+        context = Mock(\n+            absolute_url=lambda: "fake_url", getPhysicalPath=lambda: ["", "site"]\n+        )\n         field = Choice(\n-            __name__=\'selectfield\',\n-            values=[\'one\', \'two\', \'three\'],\n+            __name__="selectfield",\n+            values=["one", "two", "three"],\n         )\n         widget = RelatedItemsFieldWidget(field, self.request)\n         widget.context = context\n         widget.update()\n         base_args = widget._base_args()\n-        pattern_options = base_args[\'pattern_options\']\n-        self.assertEqual(pattern_options.get(\'maximumSelectionSize\', 0), 1)\n+        pattern_options = base_args["pattern_options"]\n+        self.assertEqual(pattern_options.get("maximumSelectionSize", 0), 1)\n \n     @mock.patch(\n-        \'plone.app.widgets.utils.getToolByName\',\n-        new=Mock(return_value=Mock(return_value=\'testuser\')),\n+        "plone.app.widgets.utils.getToolByName",\n+        new=Mock(return_value=Mock(return_value="testuser")),\n     )\n     def test_multiple_selection(self):\n         """The pattern_options key maximumSelectionSize shouldn\'t be\n@@ -1354,30 +1400,34 @@ def test_multiple_selection(self):\n         from zope.schema.interfaces import ISource\n         from zope.schema.vocabulary import VocabularyRegistry\n \n-        context = Mock(absolute_url=lambda: \'fake_url\',\n-                       getPhysicalPath=lambda: [\'\', \'site\'])\n+        context = Mock(\n+            absolute_url=lambda: "fake_url", getPhysicalPath=lambda: ["", "site"]\n+        )\n         field = List(\n-            __name__=\'selectfield\',\n-            value_type=Choice(vocabulary=\'foobar\'),\n+            __name__="selectfield",\n+            value_type=Choice(vocabulary="foobar"),\n         )\n         widget = RelatedItemsFieldWidget(field, self.request)\n         widget.context = context\n \n         vocab = Mock()\n         alsoProvides(vocab, ISource)\n-        with mock.patch.object(VocabularyRegistry, \'get\', return_value=vocab):\n+        with mock.patch.object(VocabularyRegistry, "get", return_value=vocab):\n             widget.update()\n             base_args = widget._base_args()\n-        patterns_options = base_args[\'pattern_options\']\n-        self.assertFalse(\'maximumSelectionSize\' in patterns_options)\n+        patterns_options = base_args["pattern_options"]\n+        self.assertFalse("maximumSelectionSize" in patterns_options)\n         self.assertEqual(\n-            patterns_options[\'vocabularyUrl\'],\n-            \'/@@getVocabulary?name=foobar&field=selectfield\',\n+            patterns_options["vocabularyUrl"],\n+            "/@@getVocabulary?name=foobar&field=selectfield",\n         )\n \n     def test_converter_RelationChoice(self):\n-        from plone.app.z3cform.converters import RelationChoiceRelatedItemsWidgetConverter\n-        brain = Mock(getObject=Mock(return_value=\'obj\'))\n+        from plone.app.z3cform.converters import (\n+            RelationChoiceRelatedItemsWidgetConverter,\n+        )\n+\n+        brain = Mock(getObject=Mock(return_value="obj"))\n         portal_catalog = Mock(return_value=[brain])\n         widget = Mock()\n         converter = RelationChoiceRelatedItemsWidgetConverter(\n@@ -1386,95 +1436,98 @@ def test_converter_RelationChoice(self):\n         )\n \n         with mock.patch(\n-            \'plone.app.z3cform.converters.IUUID\',\n-            return_value=\'id\',\n+            "plone.app.z3cform.converters.IUUID",\n+            return_value="id",\n         ):\n-            self.assertEqual(converter.toWidgetValue(\'obj\'), \'id\')\n+            self.assertEqual(converter.toWidgetValue("obj"), "id")\n         self.assertEqual(converter.toWidgetValue(None), None)\n \n         with mock.patch(\n-            \'plone.app.z3cform.converters.getToolByName\',\n+            "plone.app.z3cform.converters.getToolByName",\n             return_value=portal_catalog,\n         ):\n-            self.assertEqual(converter.toFieldValue(\'id\'), \'obj\')\n+            self.assertEqual(converter.toFieldValue("id"), "obj")\n         self.assertEqual(converter.toFieldValue(None), None)\n \n     def test_converter_RelationList(self):\n         from plone.app.z3cform.converters import RelatedItemsDataConverter\n         from z3c.relationfield.interfaces import IRelationList\n+\n         field = List()\n         alsoProvides(field, IRelationList)\n-        brain1 = Mock(getObject=Mock(return_value=\'obj1\'), UID=\'id1\')\n-        brain2 = Mock(getObject=Mock(return_value=\'obj2\'), UID=\'id2\')\n+        brain1 = Mock(getObject=Mock(return_value="obj1"), UID="id1")\n+        brain2 = Mock(getObject=Mock(return_value="obj2"), UID="id2")\n         portal_catalog = Mock(return_value=[brain1, brain2])\n-        widget = Mock(separator=\';\')\n+        widget = Mock(separator=";")\n         converter = RelatedItemsDataConverter(field, widget)\n \n         self.assertEqual(converter.toWidgetValue(None), None)\n         with mock.patch(\n-            \'plone.app.z3cform.converters.IUUID\',\n-            side_effect=[\'id1\', \'id2\'],\n+            "plone.app.z3cform.converters.IUUID",\n+            side_effect=["id1", "id2"],\n         ):\n             self.assertEqual(\n-                converter.toWidgetValue([\'obj1\', \'obj2\']),\n-                \'id1;id2\',\n+                converter.toWidgetValue(["obj1", "obj2"]),\n+                "id1;id2",\n             )\n \n         self.assertEqual(converter.toFieldValue(None), None)\n         with mock.patch(\n-            \'plone.app.z3cform.converters.getToolByName\',\n+            "plone.app.z3cform.converters.getToolByName",\n             return_value=portal_catalog,\n         ):\n             self.assertEqual(\n-                converter.toFieldValue(\'id1;id2\'),\n-                [\'obj1\', \'obj2\'],\n+                converter.toFieldValue("id1;id2"),\n+                ["obj1", "obj2"],\n             )\n \n     def test_converter_List_of_Choice(self):\n         from plone.app.z3cform.converters import RelatedItemsDataConverter\n+\n         fields = (\n             List(),\n             List(value_type=TextLine()),\n             List(value_type=BytesLine()),\n-            List(value_type=Choice(values=[\'one\', \'two\', \'three\'])),\n+            List(value_type=Choice(values=["one", "two", "three"])),\n         )\n         for field in fields:\n             expected_value_type = getattr(\n                 field.value_type,\n-                \'_type\',\n-                six.text_type,\n+                "_type",\n+                str,\n             )\n             if expected_value_type is None:\n-                expected_value_type = six.text_type\n-            widget = Mock(separator=\';\')\n+                expected_value_type = str\n+            widget = Mock(separator=";")\n             converter = RelatedItemsDataConverter(field, widget)\n \n             self.assertEqual(converter.toWidgetValue(None), None)\n             self.assertEqual(\n-                converter.toWidgetValue([\'id1\', \'id2\']),\n-                \'id1;id2\',\n+                converter.toWidgetValue(["id1", "id2"]),\n+                "id1;id2",\n             )\n \n             self.assertEqual(converter.toFieldValue(None), None)\n-            if not six.PY2 and expected_value_type == six.binary_type:\n-                expected = [b\'id1\', b\'id2\']\n+            if expected_value_type == bytes:\n+                expected = [b"id1", b"id2"]\n             else:\n-                expected = [\'id1\', \'id2\']\n+                expected = ["id1", "id2"]\n             self.assertEqual(\n-                converter.toFieldValue(\'id1;id2\'),\n+                converter.toFieldValue("id1;id2"),\n                 expected,\n             )\n \n             self.assertEqual(converter.toFieldValue(None), None)\n             self.assertEqual(\n-                type(converter.toFieldValue(\'id1;id2\')[0]),\n+                type(converter.toFieldValue("id1;id2")[0]),\n                 expected_value_type,\n             )\n \n     def test_fieldwidget(self):\n         from plone.app.z3cform.widget import RelatedItemsFieldWidget\n         from plone.app.z3cform.widget import RelatedItemsWidget\n-        field = Mock(__name__=\'field\', title=u\'\', required=True)\n+\n+        field = Mock(__name__="field", title="", required=True)\n         vocabulary = Mock()\n         request = Mock()\n         widget = RelatedItemsFieldWidget(field, vocabulary, request)\n@@ -1485,18 +1538,19 @@ def test_fieldwidget(self):\n \n def add_mock_fti(portal):\n     # Fake DX Type\n-    fti = DexterityFTI(\'dx_mock\')\n-    portal.portal_types._setObject(\'dx_mock\', fti)\n-    fti.klass = \'plone.dexterity.content.Item\'\n-    fti.schema = \'plone.app.widgets.tests.test_dx.IMockSchema\'\n+    fti = DexterityFTI("dx_mock")\n+    portal.portal_types._setObject("dx_mock", fti)\n+    fti.klass = "plone.dexterity.content.Item"\n+    fti.schema = "plone.app.widgets.tests.test_dx.IMockSchema"\n     fti.filter_content_types = False\n-    fti.behaviors = (\'plone.app.dexterity.behaviors.metadata.IBasic\',)\n+    fti.behaviors = ("plone.app.dexterity.behaviors.metadata.IBasic",)\n \n \n def _custom_field_widget(field, request):\n     from plone.app.z3cform.widget import AjaxSelectWidget\n+\n     widget = FieldWidget(field, AjaxSelectWidget(request))\n-    widget.vocabulary = \'plone.app.vocabularies.PortalTypes\'\n+    widget.vocabulary = "plone.app.vocabularies.PortalTypes"\n     return widget\n \n \n@@ -1507,17 +1561,17 @@ class RichTextWidgetTests(unittest.TestCase):\n     def setUp(self):\n         from plone.app.textfield import RichText as RichTextField\n \n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n         # since we are using a plone integration layer, we do\n         # not need to use the TestRequest class and we do not want\n         # to since the tinymce pattern requires a more properly\n         # setup zope2 request object to work correctly in tests\n-        self.request = self.layer[\'request\']\n+        self.request = self.layer["request"]\n \n         class IWithText(Interface):\n-            text = RichTextField(title=u\'Text\')\n+            text = RichTextField(title="Text")\n \n-        self.field = IWithText[\'text\']\n+        self.field = IWithText["text"]\n \n     def test_widget_params(self):\n         from plone.app.z3cform.widget import RichTextWidget\n@@ -1527,27 +1581,27 @@ def test_widget_params(self):\n         widget.context = self.portal\n         widget.update()\n         base_args = widget._base_args()\n-        self.assertEqual(base_args[\'name\'], \'text\')\n-        self.assertEqual(base_args[\'value\'], u\'\')\n-        self.assertEqual(base_args[\'pattern\'], \'tinymce\')\n+        self.assertEqual(base_args["name"], "text")\n+        self.assertEqual(base_args["value"], "")\n+        self.assertEqual(base_args["pattern"], "tinymce")\n \n-        prependToUrl = \'/plone/resolveuid/\'\n+        prependToUrl = "/plone/resolveuid/"\n         self.assertEqual(\n-            base_args[\'pattern_options\'][\'prependToUrl\'],\n+            base_args["pattern_options"]["prependToUrl"],\n             prependToUrl,\n         )\n         self.assertEqual(\n-            base_args[\'pattern_options\'][\'upload\'][\'relativePath\'],\n-            \'@@fileUpload\',\n+            base_args["pattern_options"]["upload"]["relativePath"],\n+            "@@fileUpload",\n         )\n \n     def test_widget_params_different_contexts(self):\n         from plone.app.z3cform.widget import RichTextWidget\n \n-        setRoles(self.portal, TEST_USER_ID, [\'Contributor\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Contributor"])\n \n         widget = FieldWidget(self.field, RichTextWidget(self.request))\n-        self.portal.invokeFactory(\'Folder\', \'sub\')\n+        self.portal.invokeFactory("Folder", "sub")\n         sub = self.portal.sub\n         form = Form(sub, self.request)\n \n@@ -1557,8 +1611,8 @@ def test_widget_params_different_contexts(self):\n         base_args = widget._base_args()\n \n         self.assertEqual(\n-            base_args[\'pattern_options\'][\'relatedItems\'][\'basePath\'],\n-            \'/plone\',\n+            base_args["pattern_options"]["relatedItems"]["basePath"],\n+            "/plone",\n         )\n \n         # sub context\n@@ -1567,8 +1621,8 @@ def test_widget_params_different_contexts(self):\n         base_args = widget._base_args()\n \n         self.assertEqual(\n-            base_args[\'pattern_options\'][\'relatedItems\'][\'basePath\'],\n-            \'/plone/sub\',\n+            base_args["pattern_options"]["relatedItems"]["basePath"],\n+            "/plone/sub",\n         )\n \n         # form context\n@@ -1577,8 +1631,8 @@ def test_widget_params_different_contexts(self):\n         base_args = widget._base_args()\n \n         self.assertEqual(\n-            base_args[\'pattern_options\'][\'relatedItems\'][\'basePath\'],\n-            \'/plone/sub\',\n+            base_args["pattern_options"]["relatedItems"]["basePath"],\n+            "/plone/sub",\n         )\n \n         # non-contentish context\n@@ -1587,8 +1641,8 @@ def test_widget_params_different_contexts(self):\n         base_args = widget._base_args()\n \n         self.assertEqual(\n-            base_args[\'pattern_options\'][\'relatedItems\'][\'basePath\'],\n-            \'/plone\',\n+            base_args["pattern_options"]["relatedItems"]["basePath"],\n+            "/plone",\n         )\n \n     def test_widget_values(self):\n@@ -1598,18 +1652,17 @@ def test_widget_values(self):\n         widget = FieldWidget(self.field, RichTextWidget(self.request))\n         # set the context so we can get tinymce settings\n         widget.context = self.portal\n-        widget.value = RichTextValue(u\'Lorem ipsum \\u2026\')\n+        widget.value = RichTextValue("Lorem ipsum \\u2026")\n         base_args = widget._base_args()\n-        self.assertEqual(base_args[\'value\'], u\'Lorem ipsum \\u2026\')\n+        self.assertEqual(base_args["value"], "Lorem ipsum \\u2026")\n \n-    def _set_mimetypes(self, default=\'text/html\', allowed=(\'text/html\')):\n-        """Set portal\'s mimetype settings.\n-        """\n+    def _set_mimetypes(self, default="text/html", allowed=("text/html")):\n+        """Set portal\'s mimetype settings."""\n         if IMarkupSchema:\n             registry = getUtility(IRegistry)\n             self.settings = registry.forInterface(\n                 IMarkupSchema,\n-                prefix=\'plone\',\n+                prefix="plone",\n             )\n             self.settings.default_type = default\n             self.settings.allowed_types = allowed\n@@ -1620,16 +1673,17 @@ def test_dx_tinymcewidget_single_mimetype(self):\n         """\n         if IMarkupSchema:\n             # if not, don\'t run this test\n-            self._set_mimetypes(allowed=(\'text/html\',))\n+            self._set_mimetypes(allowed=("text/html",))\n             from plone.app.z3cform.widget import RichTextWidget\n+\n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             # set the context so we can get tinymce settings\n             widget.context = self.portal\n             rendered = widget.render()\n \n-            self.assertTrue(\'<select\' not in rendered)\n-            self.assertTrue(\'pat-tinymce\' in rendered)\n-            self.assertTrue(\'data-pat-tinymce\' in rendered)\n+            self.assertTrue("<select" not in rendered)\n+            self.assertTrue("pat-tinymce" in rendered)\n+            self.assertTrue("data-pat-tinymce" in rendered)\n \n     def test_dx_tinymcewidget_multiple_mimetypes_create(self):\n         """A RichTextWidget with multiple available mimetypes should render a\n@@ -1638,19 +1692,21 @@ def test_dx_tinymcewidget_multiple_mimetypes_create(self):\n         """\n         if IMarkupSchema:\n             # if not, don\'t run this test\n-            self._set_mimetypes(allowed=(\'text/html\', \'text/plain\'))\n+            self._set_mimetypes(allowed=("text/html", "text/plain"))\n             from plone.app.z3cform.widget import RichTextWidget\n+\n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             # set the context so we can get tinymce settings\n             widget.context = self.portal\n             rendered = widget.render()\n \n-            self.assertTrue(\'<select\' in rendered)\n-            self.assertTrue(\'pat-textareamimetypeselector\' in rendered)\n-            self.assertTrue(\'data-pat-textareamimetypeselector\' in rendered)\n+            self.assertTrue("<select" in rendered)\n+            self.assertTrue("pat-textareamimetypeselector" in rendered)\n+            self.assertTrue("data-pat-textareamimetypeselector" in rendered)\n             self.assertTrue(\n-                \'<option value="text/html" selected="selected">\' in rendered)\n-            self.assertTrue(\'pat-tinymce\' not in rendered)\n+                \'<option value="text/html" selected="selected">\' in rendered\n+            )\n+            self.assertTrue("pat-tinymce" not in rendered)\n \n     def test_dx_tinymcewidget_multiple_mimetypes_edit(self):\n         """A RichTextWidget with multiple available mimetypes should render a\n@@ -1659,46 +1715,49 @@ def test_dx_tinymcewidget_multiple_mimetypes_edit(self):\n         """\n         if IMarkupSchema:\n             # if not, don\'t run this test\n-            self._set_mimetypes(allowed=(\'text/html\', \'text/plain\'))\n+            self._set_mimetypes(allowed=("text/html", "text/plain"))\n             from plone.app.textfield.value import RichTextValue\n             from plone.app.z3cform.widget import RichTextWidget\n+\n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             # set the context so we can get tinymce settings\n             widget.context = self.portal\n-            widget.value = RichTextValue(u\'Hello world\', mimeType=\'text/plain\')\n+            widget.value = RichTextValue("Hello world", mimeType="text/plain")\n             rendered = widget.render()\n \n-            self.assertTrue(\'<select\' in rendered)\n-            self.assertTrue(\'pat-textareamimetypeselector\' in rendered)\n-            self.assertTrue(\'data-pat-textareamimetypeselector\' in rendered)\n+            self.assertTrue("<select" in rendered)\n+            self.assertTrue("pat-textareamimetypeselector" in rendered)\n+            self.assertTrue("data-pat-textareamimetypeselector" in rendered)\n             self.assertTrue(\n                 \'<option value="text/plain" selected="selected">\' in rendered,\n             )\n-            self.assertTrue(\'pat-tinymce\' not in rendered)\n+            self.assertTrue("pat-tinymce" not in rendered)\n \n     def test_use_default_editor_value(self):\n-        """ Use dummy utility registered in testing.zcml """\n+        """Use dummy utility registered in testing.zcml"""\n         if IMarkupSchema:\n             # if not, don\'t run this test\n-            self._set_mimetypes(allowed=(\'text/html\',))\n+            self._set_mimetypes(allowed=("text/html",))\n             registry = getUtility(IRegistry)\n-            from Products.CMFPlone.interfaces import IEditingSchema\n-            proxy = registry.forInterface(IEditingSchema, check=False,\n-                                            prefix=\'plone\')\n-            proxy.available_editors = [u\'dummy\', u\'TinyMCE\']\n-            proxy.default_editor = u\'dummy\'\n+            from plone.base.interfaces import IEditingSchema\n+\n+            proxy = registry.forInterface(IEditingSchema, check=False, prefix="plone")\n+            proxy.available_editors = ["dummy", "TinyMCE"]\n+            proxy.default_editor = "dummy"\n             from plone.app.z3cform.widget import RichTextWidget\n+\n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             widget.context = self.portal\n             rendered = widget.render()\n-            self.assertTrue(\'<p>dummy</p>\' in rendered)\n+            self.assertTrue("<p>dummy</p>" in rendered)\n \n-            proxy.default_editor = u\'TinyMCE\'\n+            proxy.default_editor = "TinyMCE"\n             from plone.app.z3cform.widget import RichTextWidget\n+\n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             widget.context = self.portal\n             rendered = widget.render()\n-            self.assertTrue(\'pat-tinymce\' in rendered)\n+            self.assertTrue("pat-tinymce" in rendered)\n \n \n class LinkWidgetIntegrationTests(unittest.TestCase):\n@@ -1706,142 +1765,151 @@ class LinkWidgetIntegrationTests(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = TestRequest(environ={\'HTTP_ACCEPT_LANGUAGE\': \'en\'})\n+        self.portal = self.layer["portal"]\n+        self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n         setRequest(self.request)\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_link_widget__pattern_options(self):\n         from plone.app.z3cform.widget import LinkWidget\n+\n         widget = LinkWidget(self.request)\n \n         pattern_data = json.loads(widget.pattern_data())\n         self.assertEqual(\n-            pattern_data[\'vocabularyUrl\'],\n-            \'http://nohost/plone/@@getVocabulary?name=plone.app.vocabularies.Catalog\',  # noqa\n+            pattern_data["vocabularyUrl"],\n+            "http://nohost/plone/@@getVocabulary?name=plone.app.vocabularies.Catalog",  # noqa\n         )\n-        self.assertEqual(pattern_data[\'maximumSelectionSize\'], 1)\n+        self.assertEqual(pattern_data["maximumSelectionSize"], 1)\n \n     def test_link_widget__extract_internal(self):\n         from plone.app.z3cform.widget import LinkWidget\n+\n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n-        widget.name = \'testlinkwidget\'\n+        widget.name = "testlinkwidget"\n         widget.update()\n \n-        self.request.form[\'testlinkwidget.internal\'] = \'abc\'\n+        self.request.form["testlinkwidget.internal"] = "abc"\n         self.assertEqual(\n             widget.extract(),\n-            u\'${portal_url}/resolveuid/abc\',\n+            "${portal_url}/resolveuid/abc",\n         )\n \n     def test_link_widget__extract_external(self):\n         from plone.app.z3cform.widget import LinkWidget\n+\n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n-        widget.name = \'testlinkwidget\'\n+        widget.name = "testlinkwidget"\n         widget.update()\n \n-        self.request.form[\'testlinkwidget.external\'] = \'https://plone.org\'\n+        self.request.form["testlinkwidget.external"] = "https://plone.org"\n         self.assertEqual(\n             widget.extract(),\n-            u\'https://plone.org\',\n+            "https://plone.org",\n         )\n \n     def test_link_widget__extract_email(self):\n         from plone.app.z3cform.widget import LinkWidget\n+\n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n-        widget.name = \'testlinkwidget\'\n+        widget.name = "testlinkwidget"\n         widget.update()\n \n-        self.request.form[\'testlinkwidget.email\'] = \'dev@plone.org\'\n+        self.request.form["testlinkwidget.email"] = "dev@plone.org"\n         self.assertEqual(\n             widget.extract(),\n-            u\'mailto:dev@plone.org\',\n+            "mailto:dev@plone.org",\n         )\n \n     def test_link_widget__extract_email_including_mailto(self):\n         from plone.app.z3cform.widget import LinkWidget\n+\n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n-        widget.name = \'testlinkwidget\'\n+        widget.name = "testlinkwidget"\n         widget.update()\n \n-        self.request.form[\'testlinkwidget.email\'] = \'mailto:dev@plone.org\'\n+        self.request.form["testlinkwidget.email"] = "mailto:dev@plone.org"\n         self.assertEqual(\n             widget.extract(),\n-            u\'mailto:dev@plone.org\',\n+            "mailto:dev@plone.org",\n         )\n \n     def test_link_widget__data_converter(self):\n         from plone.app.z3cform.converters import LinkWidgetDataConverter\n         from plone.app.z3cform.widget import LinkWidget\n \n-        field = TextLine(__name__=\'linkfield\')\n+        field = TextLine(__name__="linkfield")\n         widget = LinkWidget(self.request)\n         converter = LinkWidgetDataConverter(field, widget)\n \n-        self.portal.invokeFactory(\'Folder\', \'test\')\n+        self.portal.invokeFactory("Folder", "test")\n         portal_url = self.portal.absolute_url()\n-        portal_path = \'/\'.join(self.portal.getPhysicalPath())\n+        portal_path = "/".join(self.portal.getPhysicalPath())\n \n         # Test empty value\n-        widget_value = converter.toWidgetValue(u\'\')\n-        self.assertEqual(widget_value[\'internal\'], u\'\')\n-        self.assertEqual(widget_value[\'external\'], u\'\')\n-        self.assertEqual(widget_value[\'email\'], u\'\')\n+        widget_value = converter.toWidgetValue("")\n+        self.assertEqual(widget_value["internal"], "")\n+        self.assertEqual(widget_value["external"], "")\n+        self.assertEqual(widget_value["email"], "")\n \n         # Test external URLs\n         self.assertEqual(\n-            converter.toWidgetValue(u\'https://plone.org\')[\'external\'],\n-            u\'https://plone.org\',\n+            converter.toWidgetValue("https://plone.org")["external"],\n+            "https://plone.org",\n         )\n \n         # Test relative resolveuid URLs\n         self.assertEqual(\n-            converter.toWidgetValue(u\'/resolveuid/1234\')[\'internal\'],\n-            u\'1234\',\n+            converter.toWidgetValue("/resolveuid/1234")["internal"],\n+            "1234",\n         )\n \n         # Test absolute resolveuid URLs on the same domain\n         self.assertEqual(\n-            converter.toWidgetValue(portal_url + \'/resolveuid/1234\')[\'internal\'],  # noqa\n-            u\'1234\',\n+            converter.toWidgetValue(portal_url + "/resolveuid/1234")[\n+                "internal"\n+            ],  # noqa\n+            "1234",\n         )\n \n         # Test absolute resolveuid URLs on a different domain\n         self.assertEqual(\n-            converter.toWidgetValue(u\'http://anyurl/resolveuid/1234\')[\'external\'],  # noqa\n-            u\'http://anyurl/resolveuid/1234\',\n+            converter.toWidgetValue("http://anyurl/resolveuid/1234")[\n+                "external"\n+            ],  # noqa\n+            "http://anyurl/resolveuid/1234",\n         )\n \n         # Test interrnal URL paths\n         self.assertEqual(\n-            converter.toWidgetValue(portal_path + \'/test\')[\'internal\'],\n+            converter.toWidgetValue(portal_path + "/test")["internal"],\n             IUUID(self.portal.test),\n         )\n \n         # Test absolute interrnal URLs\n         self.assertEqual(\n-            converter.toWidgetValue(portal_url + \'/test\')[\'internal\'],\n+            converter.toWidgetValue(portal_url + "/test")["internal"],\n             IUUID(self.portal.test),\n         )\n \n         # Test mail\n         self.assertEqual(\n-            converter.toWidgetValue(u\'mailto:me\')[\'email\'],\n-            u\'me\',\n+            converter.toWidgetValue("mailto:me")["email"],\n+            "me",\n         )\n \n         # Test mail with subject\n         self.assertEqual(\n-            converter.toWidgetValue(u\'mailto:me?subject=jep\')[\'email\'],\n-            u\'me\',\n+            converter.toWidgetValue("mailto:me?subject=jep")["email"],\n+            "me",\n         )\n         self.assertEqual(\n-            converter.toWidgetValue(u\'mailto:me?subject=jep\')[\'email_subject\'],\n-            u\'jep\',\n+            converter.toWidgetValue("mailto:me?subject=jep")["email_subject"],\n+            "jep",\n         )\n \n \n@@ -1850,18 +1918,17 @@ class WidgetCustomizingIntegrationTests(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def test_widget_base_wrapper_css(self):\n-\n         class ITestDateSchema(Schema):\n \n-            widget(\'my_date\', DateWidget, wrapper_css_class=\'foo\')\n-            my_date = Date(title=u\'My Date\')\n+            widget("my_date", DateWidget, wrapper_css_class="foo")\n+            my_date = Date(title="My Date")\n \n         class TestForm(AutoExtensibleForm, EditForm):\n \n             ignoreContext = True\n             schema = ITestDateSchema\n \n-        render = TestForm(self.layer[\'portal\'], self.layer[\'request\'])\n+        render = TestForm(self.layer["portal"], self.layer["request"])\n         self.assertIn(\n             \'empty foo" data-fieldname="form.widgets.my_date"\',\n             render(),\ndiff --git a/plone/app/z3cform/tests/tests.py b/plone/app/z3cform/tests/tests.py\nindex baf525bd..6229cc58 100644\n--- a/plone/app/z3cform/tests/tests.py\n+++ b/plone/app/z3cform/tests/tests.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.z3cform.tests.layer import PAZ3CForm_INTEGRATION_TESTING\n from plone.browserlayer.layer import mark_layer\n from plone.testing import layered\n@@ -16,51 +15,54 @@ class IntegrationTests(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n         event = BeforeTraverseEvent(self.portal, self.request)\n         mark_layer(self.portal, event)\n \n     def test_layer_applied(self):\n         from plone.app.z3cform.interfaces import IPloneFormLayer\n+\n         self.assertTrue(IPloneFormLayer.providedBy(self.portal.REQUEST))\n \n     def test_default_templates(self):\n-        form = self.portal.restrictedTraverse(\'test-form\')\n+        form = self.portal.restrictedTraverse("test-form")\n         rendered = form()\n         # look for something only in the Plone-specific @@ploneform-macros\n-        self.assertTrue(\'documentFirstHeading\' in rendered)\n+        self.assertTrue("documentFirstHeading" in rendered)\n \n     def test_content_provider(self):\n-        form = self.portal.restrictedTraverse(\'test-form\')\n+        form = self.portal.restrictedTraverse("test-form")\n         rendered = form()\n-        self.assertTrue(\'My test content provider\' in rendered)\n+        self.assertTrue("My test content provider" in rendered)\n \n \n def test_suite():\n-    inlineValidationTests = layered(doctest.DocFileSuite(\n-        \'inline_validation.rst\',\n-        package=\'plone.app.z3cform\',\n-        optionflags=(\n-            doctest.ELLIPSIS |\n-            doctest.NORMALIZE_WHITESPACE\n-        ),\n-    ), layer=PAZ3CForm_INTEGRATION_TESTING)\n-\n-    suite = unittest.TestSuite([\n-        unittest.makeSuite(IntegrationTests),\n+    inlineValidationTests = layered(\n         doctest.DocFileSuite(\n-            \'wysiwyg/README.rst\',\n-            package=\'plone.app.z3cform\',\n-            setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown,\n+            "inline_validation.rst",\n+            package="plone.app.z3cform",\n+            optionflags=(doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE),\n         ),\n-        doctest.DocTestSuite(\n-            \'plone.app.z3cform.wysiwyg.widget\',\n-            package=\'plone.app.z3cform\',\n-            setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown,\n-        ),\n-        inlineValidationTests,\n-    ])\n+        layer=PAZ3CForm_INTEGRATION_TESTING,\n+    )\n+\n+    suite = unittest.TestSuite(\n+        [\n+            unittest.defaultTestLoader.loadTestsFromTestCase(IntegrationTests),\n+            doctest.DocFileSuite(\n+                "wysiwyg/README.rst",\n+                package="plone.app.z3cform",\n+                setUp=zope.component.testing.setUp,\n+                tearDown=zope.component.testing.tearDown,\n+            ),\n+            doctest.DocTestSuite(\n+                "plone.app.z3cform.wysiwyg.widget",\n+                package="plone.app.z3cform",\n+                setUp=zope.component.testing.setUp,\n+                tearDown=zope.component.testing.tearDown,\n+            ),\n+            inlineValidationTests,\n+        ]\n+    )\n     return suite\ndiff --git a/plone/app/z3cform/utils.py b/plone/app/z3cform/utils.py\nindex de9c9272..f420d87e 100644\n--- a/plone/app/z3cform/utils.py\n+++ b/plone/app/z3cform/utils.py\n@@ -1,17 +1,10 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_base\n from Products.CMFCore.interfaces import IContentish\n from Products.CMFCore.interfaces import IFolderish\n-from six.moves import urllib\n from zope.component.hooks import getSite\n+from zope.globalrequest import getRequest\n \n-\n-try:\n-    from zope.globalrequest import getRequest\n-    getRequest  # pyflakes\n-except ImportError:\n-    # Fake it\n-    getRequest = object\n+import urllib\n \n \n def closest_content(context=None):\n@@ -23,7 +16,7 @@ def closest_content(context=None):\n         return c\n     # Subforms (e.g. DataGridField) may not have a context set, find out\n     # what page is being published\n-    c = getattr(getRequest(), \'PUBLISHED\', None)\n+    c = getattr(getRequest(), "PUBLISHED", None)\n     c = _valid_context(c)\n     if c is not None:\n         return c\n@@ -32,7 +25,7 @@ def closest_content(context=None):\n     c = _valid_context(c)\n     if c is not None:\n         return c\n-    raise ValueError(\'Cannot find suitable context to bind to source\')\n+    raise ValueError("Cannot find suitable context to bind to source")\n \n \n def _valid_context(context):\n@@ -41,11 +34,11 @@ def _valid_context(context):\n     seen = set()\n     while context is not None and id(aq_base(context)) not in seen:\n         seen.add(id(aq_base(context)))\n-        if (IContentish.providedBy(context) or IFolderish.providedBy(context)):\n+        if IContentish.providedBy(context) or IFolderish.providedBy(context):\n             return context\n-        parent = getattr(context, \'__parent__\', None)\n+        parent = getattr(context, "__parent__", None)\n         if parent is None:\n-            parent = getattr(context, \'context\', None)\n+            parent = getattr(context, "context", None)\n         context = parent\n \n     return None\n@@ -59,20 +52,11 @@ def call_callables(value, *args, **kwargs):\n     if callable(value):\n         ret = value(*args, **kwargs)\n     elif isinstance(value, list):\n-        ret = [\n-            call_callables(v, *args, **kwargs)\n-            for v in value\n-        ]\n+        ret = [call_callables(v, *args, **kwargs) for v in value]\n     elif isinstance(value, tuple):\n-        ret = tuple(\n-            call_callables(v, *args, **kwargs)\n-            for v in value\n-        )\n+        ret = tuple(call_callables(v, *args, **kwargs) for v in value)\n     elif isinstance(value, dict):\n-        ret = {\n-            k: call_callables(v, *args, **kwargs)\n-            for k, v in value.items()\n-        }\n+        ret = {k: call_callables(v, *args, **kwargs) for k, v in value.items()}\n     return ret\n \n \n@@ -83,25 +67,25 @@ def replace_link_variables_by_paths(context, url):\n     """\n \n     def _replace_variable_by_path(url, variable, obj):\n-        path = \'/\'.join(obj.getPhysicalPath())\n+        path = "/".join(obj.getPhysicalPath())\n         return url.replace(variable, path)\n \n     if not url:\n         return url\n \n-    portal_state = context.restrictedTraverse(\'@@plone_portal_state\')\n+    portal_state = context.restrictedTraverse("@@plone_portal_state")\n \n-    if \'${navigation_root_url}\' in url:\n+    if "${navigation_root_url}" in url:\n         url = _replace_variable_by_path(\n             url,\n-            \'${navigation_root_url}\',\n+            "${navigation_root_url}",\n             portal_state.navigation_root(),\n         )\n \n-    if \'${portal_url}\' in url:\n+    if "${portal_url}" in url:\n         url = _replace_variable_by_path(\n             url,\n-            \'${portal_url}\',\n+            "${portal_url}",\n             portal_state.portal(),\n         )\n \n@@ -116,8 +100,7 @@ def is_absolute(url):\n \n \n def is_same_domain(url1, url2):\n-    """Return ``True``, if url1 is on the same protocol and domain than url2.\n-    """\n+    """Return ``True``, if url1 is on the same protocol and domain than url2."""\n     purl1 = urllib.parse.urlparse(url1)\n     purl2 = urllib.parse.urlparse(url2)\n     return purl1.scheme == purl2.scheme and purl1.netloc == purl2.netloc\ndiff --git a/plone/app/z3cform/views.py b/plone/app/z3cform/views.py\nindex f7b94e2e..76991936 100644\n--- a/plone/app/z3cform/views.py\n+++ b/plone/app/z3cform/views.py\n@@ -1,72 +1,72 @@\n-# -*- coding: utf-8 -*-\n-import os.path\n-import plone.app.z3cform\n-import plone.app.z3cform.interfaces\n-import plone.z3cform.interfaces\n-import plone.z3cform.templates\n-import z3c.form.interfaces\n-\n-from Products.Five.browser import BrowserView\n-from Products.Five.browser.metaconfigure import ViewMixinForTemplates\n from plone.dexterity.browser.add import DefaultAddForm\n from plone.dexterity.browser.add import DefaultAddView\n from plone.dexterity.browser.edit import DefaultEditForm\n from plone.dexterity.interfaces import IDexterityEditForm\n from plone.z3cform import layout\n+from Products.Five.browser import BrowserView\n+from Products.Five.browser.metaconfigure import ViewMixinForTemplates\n from z3c.form.error import ErrorViewTemplateFactory\n from zope.browserpage.viewpagetemplatefile import ViewPageTemplateFile\n from zope.interface import classImplements\n \n+import os.path\n+import plone.app.z3cform\n+import plone.app.z3cform.interfaces\n+import plone.z3cform.interfaces\n+import plone.z3cform.templates\n+import z3c.form.interfaces\n+\n \n def path(filepart):\n     return os.path.join(\n         os.path.dirname(plone.app.z3cform.__file__),\n-        \'templates\',\n+        "templates",\n         filepart,\n     )\n \n+\n # Override the layout wrapper view default template with a more Plone-looking\n # one\n \n \n layout_factory = plone.z3cform.templates.ZopeTwoFormTemplateFactory(\n-    path(\'layout.pt\'),\n+    path("layout.pt"),\n     form=plone.z3cform.interfaces.IFormWrapper,\n-    request=plone.app.z3cform.interfaces.IPloneFormLayer)\n+    request=plone.app.z3cform.interfaces.IPloneFormLayer,\n+)\n \n # Override the form for the standard full-page form rendering\n \n form_factory = plone.z3cform.templates.ZopeTwoFormTemplateFactory(\n-    path(\'form.pt\'),\n+    path("form.pt"),\n     form=z3c.form.interfaces.IForm,\n-    request=plone.app.z3cform.interfaces.IPloneFormLayer)\n+    request=plone.app.z3cform.interfaces.IPloneFormLayer,\n+)\n \n \n # The ploneform-macros view\n class Macros(BrowserView):\n-\n     def __getitem__(self, key):\n         return self.index.macros[key]\n \n \n # The widget rendering templates need to be Zope 3 templates\n class RenderWidget(ViewMixinForTemplates, BrowserView):\n-    index = ViewPageTemplateFile(\'templates/widget.pt\')\n+    index = ViewPageTemplateFile("templates/widget.pt")\n \n \n class RenderContentProvider(ViewMixinForTemplates, BrowserView):\n-    index = ViewPageTemplateFile(\'templates/contentprovider-widget.pt\')\n+    index = ViewPageTemplateFile("templates/contentprovider-widget.pt")\n \n \n ErrorViewTemplate = ErrorViewTemplateFactory(\n-    os.path.join(os.path.dirname(__file__), \'templates/error.pt\'),\n-    \'text/html\')\n-\n+    os.path.join(os.path.dirname(__file__), "templates/error.pt"), "text/html"\n+)\n \n-class BootstrapActions(object):\n \n+class BootstrapActions:\n     def updateActions(self):\n-        super(BootstrapActions, self).updateActions()\n+        super().updateActions()\n \n         for a in self.actions:\n             if a == "save":\n@@ -79,7 +79,7 @@ def updateActions(self):\n \n # Dexterity Add/Edit Form overrides\n class AddForm(BootstrapActions, DefaultAddForm):\n-    """ with bootstrap actions """\n+    """with bootstrap actions"""\n \n \n class AddView(DefaultAddView):\n@@ -87,7 +87,7 @@ class AddView(DefaultAddView):\n \n \n class EditForm(BootstrapActions, DefaultEditForm):\n-    """ with bootstrap actions """\n+    """with bootstrap actions"""\n \n \n EditView = layout.wrap_form(EditForm)\ndiff --git a/plone/app/z3cform/widget.py b/plone/app/z3cform/widget.py\nindex e16eb9f8..96e186bc 100644\n--- a/plone/app/z3cform/widget.py\n+++ b/plone/app/z3cform/widget.py\n@@ -1,6 +1,6 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_base\n from Acquisition import ImplicitAcquisitionWrapper\n+from collections import UserDict\n from lxml import etree\n from OFS.interfaces import ISimpleItem\n from plone.app.contentlisting.interfaces import IContentListing\n@@ -35,15 +35,13 @@\n from plone.app.z3cform.interfaces import ITimeWidget\n from plone.app.z3cform.utils import call_callables\n from plone.app.z3cform.utils import closest_content\n+from plone.base.utils import safe_text\n from plone.registry.interfaces import IRegistry\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.utils import safe_unicode\n-from six.moves import UserDict\n from z3c.form import interfaces as form_ifaces\n from z3c.form.browser.checkbox import SingleCheckBoxWidget\n from z3c.form.browser.select import SelectWidget as z3cform_SelectWidget\n from z3c.form.browser.text import TextWidget as z3cform_TextWidget\n-from z3c.form.browser.widget import HTMLInputWidget\n from z3c.form.interfaces import IEditForm\n from z3c.form.interfaces import IFieldWidget\n from z3c.form.interfaces import IForm\n@@ -53,7 +51,6 @@\n from z3c.form.widget import FieldWidget\n from z3c.form.widget import Widget\n from zope.component import adapter\n-from zope.component import ComponentLookupError\n from zope.component import getUtility\n from zope.component import queryUtility\n from zope.component.hooks import getSite\n@@ -71,7 +68,6 @@\n \n import collections\n import json\n-import six\n \n \n class BaseWidget(Widget):\n@@ -79,10 +75,7 @@ class BaseWidget(Widget):\n \n     pattern = None\n     pattern_options = {}\n-    _adapterValueAttributes = (\n-        Widget._adapterValueAttributes +\n-        (\'pattern_options\',)\n-    )\n+    _adapterValueAttributes = Widget._adapterValueAttributes + ("pattern_options",)\n \n     def _base(self, pattern, pattern_options={}):\n         """Base widget class."""\n@@ -101,8 +94,8 @@ def _base_args(self):\n         if self.pattern is None:\n             raise PatternNotImplemented("\'pattern\' option is not provided.")\n         return {\n-            \'pattern\': self.pattern,\n-            \'pattern_options\': self.pattern_options.copy(),\n+            "pattern": self.pattern,\n+            "pattern_options": self.pattern_options.copy(),\n         }\n \n     def render(self):\n@@ -111,36 +104,36 @@ def render(self):\n         :returns: Widget\'s HTML.\n         :rtype: string\n         """\n-        if self.mode != \'input\':\n-            return super(BaseWidget, self).render()\n+        if self.mode != "input":\n+            return super().render()\n \n         _base_args = self._base_args()\n-        _base_args[\'pattern_options\'] = call_callables(\n-            _base_args[\'pattern_options\'],\n+        _base_args["pattern_options"] = call_callables(\n+            _base_args["pattern_options"],\n             self.context,\n         )\n \n         pattern_widget = self._base(**_base_args)\n-        if getattr(self, \'klass\', False):\n-            pattern_widget.klass = u\'{0} {1}\'.format(\n+        if getattr(self, "klass", False):\n+            pattern_widget.klass = "{} {}".format(\n                 pattern_widget.klass,\n                 self.klass,\n             )\n         return pattern_widget.render()\n \n     def is_subform_widget(self):\n-        return getattr(aq_base(self.form), \'parentForm\', None) is not None\n+        return getattr(aq_base(self.form), "parentForm", None) is not None\n \n \n @implementer_only(IDateWidget)\n class DateWidget(BaseWidget, z3cform_TextWidget):\n     """Date widget for z3c.form."""\n \n-    _base_type = \'date\'\n+    _base_type = "date"\n     _converter = DateWidgetConverter\n-    _formater = \'date\'\n+    _formater = "date"\n \n-    pattern = \'date-picker\'\n+    pattern = "date-picker"\n     pattern_options = BaseWidget.pattern_options.copy()\n \n     def _base(self, **kw):\n@@ -161,18 +154,17 @@ def _base_args(self):\n         :returns: Arguments which will be passed to _base\n         :rtype: dict\n         """\n-        args = super(DateWidget, self)._base_args()\n-        args[\'name\'] = self.name\n-        args[\'value\'] = (self.request.get(self.name,\n-                                          self.value) or u\'\').strip()\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = (self.request.get(self.name, self.value) or "").strip()\n \n-        args.setdefault(\'pattern_options\', {})\n+        args.setdefault("pattern_options", {})\n         if self.field.required:\n             # Required fields should not have a "Clear" button\n-            args[\'pattern_options\'][\'clear\'] = False\n-        args[\'pattern_options\'] = dict_merge(\n-            get_date_options(self.request),\n-            args[\'pattern_options\'])\n+            args["pattern_options"]["clear"] = False\n+        args["pattern_options"] = dict_merge(\n+            get_date_options(self.request), args["pattern_options"]\n+        )\n \n         return args\n \n@@ -182,21 +174,20 @@ def render(self):\n         :returns: Widget\'s HTML.\n         :rtype: string\n         """\n-        if self.mode != \'display\':\n+        if self.mode != "display":\n             self.addClass("form-control")\n-            return super(DateWidget, self).render()\n+            return super().render()\n \n         if not self.value:\n-            return \'\'\n+            return ""\n \n-        field_value = self._converter(\n-            self.field, self).toFieldValue(self.value)\n+        field_value = self._converter(self.field, self).toFieldValue(self.value)\n         if field_value is self.field.missing_value:\n-            return u\'\'\n+            return ""\n \n         formatter = self.request.locale.dates.getFormatter(\n             self._formater,\n-            \'short\',\n+            "short",\n         )\n         if field_value.year > 1900:\n             return formatter.format(field_value)\n@@ -215,32 +206,32 @@ class DatetimeWidget(DateWidget):\n     :type default_timezone: String or callback\n \n     """\n-    _base_type = \'datetime-local\'\n+\n+    _base_type = "datetime-local"\n     _converter = DatetimeWidgetConverter\n-    _formater = \'dateTime\'\n+    _formater = "dateTime"\n \n-    pattern = \'datetime-picker\'\n+    pattern = "datetime-picker"\n     default_timezone = None\n \n \n @implementer_only(ITimeWidget)\n class TimeWidget(BaseWidget, z3cform_TextWidget):\n \n-    pattern = \'\'\n+    pattern = ""\n \n     def _base(self, **kw):\n         return InputWidget(\n             type="time",\n             name=self.name,\n-            value=(self.request.get(self.name,\n-                self.value) or u\'\').strip(),\n+            value=(self.request.get(self.name, self.value) or "").strip(),\n             **kw,\n         )\n \n     def render(self):\n-        if self.mode != \'display\':\n+        if self.mode != "display":\n             self.addClass("form-control")\n-        return super(TimeWidget, self).render()\n+        return super().render()\n \n \n @implementer_only(ISelectWidget)\n@@ -249,12 +240,12 @@ class SelectWidget(BaseWidget, z3cform_SelectWidget):\n \n     _base = BaseSelectWidget\n \n-    pattern = \'select2\'\n+    pattern = "select2"\n     pattern_options = BaseWidget.pattern_options.copy()\n \n-    separator = \';\'\n-    noValueToken = u\'\'\n-    noValueMessage = u\'\'\n+    separator = ";"\n+    noValueToken = ""\n+    noValueMessage = ""\n     multiple = None\n     orderable = False\n     required = True\n@@ -273,12 +264,11 @@ def items(self):\n             for group_term, option_terms in terms.items():\n                 group_widget = type(self)(self.request)\n                 group_widget.terms = option_terms\n-                group_label = (\n-                    group_term.title or group_term.value or group_term.token)\n+                group_label = group_term.title or group_term.value or group_term.token\n                 groups[group_label] = super(SelectWidget, group_widget).items\n             return groups\n         else:\n-            return super(SelectWidget, self).items\n+            return super().items\n \n     def _base_args(self):\n         """Method which will calculate _base class arguments.\n@@ -294,27 +284,27 @@ def _base_args(self):\n         :returns: Arguments which will be passed to _base\n         :rtype: dict\n         """\n-        args = super(SelectWidget, self)._base_args()\n-        args[\'name\'] = self.name\n-        args[\'value\'] = self.value\n-        args[\'multiple\'] = self.multiple\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = self.value\n+        args["multiple"] = self.multiple\n \n         self.required = self.field.required\n \n-        options = args.setdefault(\'pattern_options\', {})\n+        options = args.setdefault("pattern_options", {})\n         if self.multiple or ICollection.providedBy(self.field):\n-            args[\'multiple\'] = self.multiple = True\n+            args["multiple"] = self.multiple = True\n \n         # ISequence represents an orderable collection\n         if ISequence.providedBy(self.field) or self.orderable:\n-            options[\'orderable\'] = True\n+            options["orderable"] = True\n \n         if self.multiple:\n-            options[\'separator\'] = self.separator\n+            options["separator"] = self.separator\n \n         # Allow to clear field value if it is not required\n         if not self.required:\n-            options[\'allowClear\'] = True\n+            options["allowClear"] = True\n \n         base_items = self.items\n         if callable(base_items):\n@@ -329,21 +319,20 @@ def makeItem(item):\n             """\n             Gather the information needed by the widget for the given term.\n             """\n-            if not isinstance(item[\'content\'], six.string_types):\n-                item[\'content\'] = translate(\n-                    item[\'content\'],\n-                    context=self.request,\n-                    default=item[\'value\'])\n-            return (item[\'value\'], item[\'content\'])\n+            if not isinstance(item["content"], str):\n+                item["content"] = translate(\n+                    item["content"], context=self.request, default=item["value"]\n+                )\n+            return (item["value"], item["content"])\n \n         if isinstance(base_items, dict):\n             items = collections.OrderedDict(\n-                (group_label, [\n-                    makeItem(base_item) for base_item in group_options])\n-                for group_label, group_options in base_items.items())\n+                (group_label, [makeItem(base_item) for base_item in group_options])\n+                for group_label, group_options in base_items.items()\n+            )\n         else:\n             items = [makeItem(item) for item in base_items]\n-        args[\'items\'] = items\n+        args["items"] = items\n \n         return args\n \n@@ -351,8 +340,10 @@ def extract(self, default=NO_VALUE):\n         """Override extract to handle delimited response values.\n         Skip the vocabulary validation provided in the parent\n         method, since it\'s not ever done for single selects."""\n-        if (self.name not in self.request and\n-                self.name + \'-empty-marker\' in self.request):\n+        if (\n+            self.name not in self.request\n+            and self.name + "-empty-marker" in self.request\n+        ):\n             return []\n         return self.request.get(self.name, default)\n \n@@ -363,12 +354,12 @@ class AjaxSelectWidget(BaseWidget, z3cform_TextWidget):\n \n     _base = InputWidget\n \n-    pattern = \'select2\'\n+    pattern = "select2"\n     pattern_options = BaseWidget.pattern_options.copy()\n \n-    separator = \';\'\n+    separator = ";"\n     vocabulary = None\n-    vocabulary_view = \'@@getVocabulary\'\n+    vocabulary_view = "@@getVocabulary"\n     orderable = False\n \n     def _view_context(self):\n@@ -387,7 +378,7 @@ def _view_context(self):\n         return view_context\n \n     def get_vocabulary(self):\n-        if self.vocabulary and isinstance(self.vocabulary, six.text_type):\n+        if self.vocabulary and isinstance(self.vocabulary, str):\n             factory = queryUtility(\n                 IVocabularyFactory,\n                 self.vocabulary,\n@@ -401,10 +392,10 @@ def display_items(self):\n             tokens = self.value.split(self.separator)\n             vocabulary = self.get_vocabulary()\n             for token in tokens:\n-                item = {\'token\': token, \'title\': token}\n+                item = {"token": token, "title": token}\n                 if vocabulary is not None:\n                     try:\n-                        item[\'title\'] = vocabulary.getTermByToken(token).title\n+                        item["title"] = vocabulary.getTermByToken(token).title\n                     except LookupError:\n                         pass\n                 yield item\n@@ -414,35 +405,38 @@ def has_multiple_values(self):\n \n     def _ajaxselect_options(self):\n         options = {\n-            \'separator\': self.separator,\n+            "separator": self.separator,\n         }\n         if self.vocabulary:\n-            options[\'vocabularyUrl\'] = \'{0}/{1}?name={2}\'.format(\n+            options["vocabularyUrl"] = "{}/{}?name={}".format(\n                 get_context_url(self._view_context()),\n                 self.vocabulary_view,\n                 self.vocabulary,\n             )\n             field_name = self.field and self.field.__name__ or None\n             if field_name:\n-                options[\'vocabularyUrl\'] += \'&field={0}\'.format(field_name)\n+                options["vocabularyUrl"] += f"&field={field_name}"\n             vocabulary = self.get_vocabulary()\n             if vocabulary is not None and self.value:\n-                options[\'initialValues\'] = dict()\n+                options["initialValues"] = dict()\n                 for token in self.value.split(self.separator):\n                     try:\n                         term = vocabulary.getTermByToken(token)\n-                        options[\'initialValues\'][term.token] = term.title\n+                        options["initialValues"][term.token] = term.title\n                     except LookupError:\n-                        options[\'initialValues\'][token] = token\n+                        options["initialValues"][token] = token\n \n         return options\n \n     def update(self):\n-        super(AjaxSelectWidget, self).update()\n-        field = getattr(self, \'field\', None)\n-        field = getattr(field, \'value_type\', field)\n-        if (not self.vocabulary and field is not None and\n-                getattr(field, \'vocabularyName\', None)):\n+        super().update()\n+        field = getattr(self, "field", None)\n+        field = getattr(field, "value_type", field)\n+        if (\n+            not self.vocabulary\n+            and field is not None\n+            and getattr(field, "vocabularyName", None)\n+        ):\n             self.vocabulary = field.vocabularyName\n \n     def _base_args(self):\n@@ -457,49 +451,50 @@ def _base_args(self):\n         :returns: Arguments which will be passed to _base\n         :rtype: dict\n         """\n-        args = super(AjaxSelectWidget, self)._base_args()\n-        args[\'name\'] = self.name\n-        args[\'value\'] = self.value\n-        args.setdefault(\'pattern_options\', {})\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = self.value\n+        args.setdefault("pattern_options", {})\n         context = self.context\n         field = None\n \n         if IChoice.providedBy(self.field):\n-            args[\'pattern_options\'][\'maximumSelectionSize\'] = 1\n+            args["pattern_options"]["maximumSelectionSize"] = 1\n             field = self.field\n         elif ICollection.providedBy(self.field):\n             field = self.field.value_type\n         if IChoice.providedBy(field):\n-            args[\'pattern_options\'][\'allowNewItems\'] = \'false\'\n+            args["pattern_options"]["allowNewItems"] = "false"\n \n-        args[\'pattern_options\'] = dict_merge(\n-            self._ajaxselect_options(),\n-            args[\'pattern_options\'])\n+        args["pattern_options"] = dict_merge(\n+            self._ajaxselect_options(), args["pattern_options"]\n+        )\n \n-        if field and getattr(field, \'vocabulary\', None):\n+        if field and getattr(field, "vocabulary", None):\n             form_url = self.request.getURL()\n-            source_url = \'{0:s}/++widget++{1:s}/@@getSource\'.format(\n+            source_url = "{:s}/++widget++{:s}/@@getSource".format(\n                 form_url,\n                 self.name,\n             )\n-            args[\'pattern_options\'][\'vocabularyUrl\'] = source_url\n+            args["pattern_options"]["vocabularyUrl"] = source_url\n \n         # ISequence represents an orderable collection\n         if ISequence.providedBy(self.field) or self.orderable:\n-            args[\'pattern_options\'][\'orderable\'] = True\n+            args["pattern_options"]["orderable"] = True\n \n-        if self.vocabulary == \'plone.app.vocabularies.Keywords\':\n-            membership = getToolByName(context, \'portal_membership\')\n+        if self.vocabulary == "plone.app.vocabularies.Keywords":\n+            membership = getToolByName(context, "portal_membership")\n             user = membership.getAuthenticatedMember()\n \n             registry = getUtility(IRegistry)\n             roles_allowed_to_add_keywords = registry.get(\n-                \'plone.roles_allowed_to_add_keywords\', set())\n+                "plone.roles_allowed_to_add_keywords", set()\n+            )\n             roles = set(user.getRolesInContext(context))\n             allowNewItems = bool(\n                 roles.intersection(roles_allowed_to_add_keywords),\n             )\n-            args[\'pattern_options\'][\'allowNewItems\'] = str(\n+            args["pattern_options"]["allowNewItems"] = str(\n                 allowNewItems,\n             ).lower()\n \n@@ -512,29 +507,29 @@ class RelatedItemsWidget(BaseWidget, z3cform_TextWidget):\n \n     _base = InputWidget\n \n-    pattern = \'relateditems\'\n+    pattern = "relateditems"\n     pattern_options = BaseWidget.pattern_options.copy()\n \n-    separator = \';\'\n+    separator = ";"\n     vocabulary = None\n     vocabulary_override = False\n-    vocabulary_view = \'@@getVocabulary\'\n+    vocabulary_view = "@@getVocabulary"\n     orderable = False\n \n     def update(self):\n-        super(RelatedItemsWidget, self).update()\n-        field = getattr(self, \'field\', None)\n+        super().update()\n+        field = getattr(self, "field", None)\n         if ICollection.providedBy(self.field):\n             field = self.field.value_type\n         if (\n-            not self.vocabulary and\n-            field is not None and\n-            getattr(field, \'vocabularyName\', None)\n+            not self.vocabulary\n+            and field is not None\n+            and getattr(field, "vocabularyName", None)\n         ):\n             self.vocabulary = field.vocabularyName\n             self.vocabulary_override = True\n         else:\n-            self.vocabulary = \'plone.app.vocabularies.Catalog\'\n+            self.vocabulary = "plone.app.vocabularies.Catalog"\n \n     def _base_args(self):\n         """Method which will calculate _base class arguments.\n@@ -548,15 +543,15 @@ def _base_args(self):\n         :returns: Arguments which will be passed to _base\n         :rtype: dict\n         """\n-        args = super(RelatedItemsWidget, self)._base_args()\n+        args = super()._base_args()\n \n-        args[\'name\'] = self.name\n-        args[\'value\'] = self.value\n-        args.setdefault(\'pattern_options\', {})\n+        args["name"] = self.name\n+        args["value"] = self.value\n+        args.setdefault("pattern_options", {})\n \n         field = None\n         if IChoice.providedBy(self.field):\n-            args[\'pattern_options\'][\'maximumSelectionSize\'] = 1\n+            args["pattern_options"]["maximumSelectionSize"] = 1\n             field = self.field\n         elif ICollection.providedBy(self.field):\n             field = self.field.value_type\n@@ -583,37 +578,37 @@ def _base_args(self):\n             # view_context is defined above already\n \n         root_search_mode = (\n-            args[\'pattern_options\'].get(\'mode\', None) and\n-            \'basePath\' not in args[\'pattern_options\']\n+            args["pattern_options"].get("mode", None)\n+            and "basePath" not in args["pattern_options"]\n         )\n \n-        args[\'pattern_options\'] = dict_merge(\n+        args["pattern_options"] = dict_merge(\n             get_relateditems_options(\n                 view_context,\n-                args[\'value\'],\n+                args["value"],\n                 self.separator,\n                 vocabulary_name,\n                 self.vocabulary_view,\n                 field_name,\n             ),\n-            args[\'pattern_options\'],\n+            args["pattern_options"],\n         )\n         if root_search_mode:\n             # Delete default basePath option in search mode, when no basePath\n             # was explicitly set.\n-            del args[\'pattern_options\'][\'basePath\']\n+            del args["pattern_options"]["basePath"]\n         if (\n-            not self.vocabulary_override and\n-            field and\n-            getattr(field, \'vocabulary\', None)\n+            not self.vocabulary_override\n+            and field\n+            and getattr(field, "vocabulary", None)\n         ):\n             # widget vocab takes precedence over field\n             form_url = self.request.getURL()\n-            source_url = \'{0:s}/++widget++{1:s}/@@getSource\'.format(\n+            source_url = "{:s}/++widget++{:s}/@@getSource".format(\n                 form_url,\n                 self.name,\n             )\n-            args[\'pattern_options\'][\'vocabularyUrl\'] = source_url\n+            args["pattern_options"]["vocabularyUrl"] = source_url\n \n         return args\n \n@@ -628,13 +623,13 @@ def items(self):\n         results = []\n         if not self.value:\n             return results\n-        separator = getattr(self, \'separator\', \';\')\n+        separator = getattr(self, "separator", ";")\n         uuids = self.value.split(separator)\n \n         try:\n-            catalog = getToolByName(self.context, \'portal_catalog\')\n+            catalog = getToolByName(self.context, "portal_catalog")\n         except AttributeError:\n-            catalog = getToolByName(getSite(), \'portal_catalog\')\n+            catalog = getToolByName(getSite(), "portal_catalog")\n \n         brains = catalog(UID=uuids)\n         # restore original order\n@@ -648,10 +643,10 @@ class QueryStringWidget(BaseWidget, z3cform_TextWidget):\n \n     _base = InputWidget\n \n-    pattern = \'querystring\'\n+    pattern = "querystring"\n     pattern_options = BaseWidget.pattern_options.copy()\n \n-    querystring_view = \'@@qsOptions\'\n+    querystring_view = "@@qsOptions"\n \n     def _base_args(self):\n         """Method which will calculate _base class arguments.\n@@ -665,14 +660,15 @@ def _base_args(self):\n         :returns: Arguments which will be passed to _base\n         :rtype: dict\n         """\n-        args = super(QueryStringWidget, self)._base_args()\n-        args[\'name\'] = self.name\n-        args[\'value\'] = self.value\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = self.value\n \n-        args.setdefault(\'pattern_options\', {})\n-        args[\'pattern_options\'] = dict_merge(\n+        args.setdefault("pattern_options", {})\n+        args["pattern_options"] = dict_merge(\n             get_querystring_options(self.context, self.querystring_view),\n-            args[\'pattern_options\'])\n+            args["pattern_options"],\n+        )\n \n         return args\n \n@@ -686,12 +682,12 @@ class RichTextWidget(BaseWidget, patext_RichTextWidget):\n     pattern_options = BaseWidget.pattern_options.copy()\n \n     def __init__(self, *args, **kwargs):\n-        super(RichTextWidget, self).__init__(*args, **kwargs)\n+        super().__init__(*args, **kwargs)\n         self._pattern = None\n \n     def wrapped_context(self):\n-        """"We need to wrap the context to be able to acquire the root\n-            of the site to get tools, as done in plone.app.textfield"""\n+        """ "We need to wrap the context to be able to acquire the root\n+        of the site to get tools, as done in plone.app.textfield"""\n         context = self.context\n         content = closest_content(context)\n         if context.__class__ == dict:\n@@ -701,28 +697,28 @@ def wrapped_context(self):\n     @property\n     def pattern(self):\n         """dynamically grab the actual pattern name so it will\n-           work with custom visual editors"""\n+        work with custom visual editors"""\n         if self._pattern is None:\n             self._pattern = self.getWysiwygEditor()\n         return self._pattern\n \n     def _base_args(self):\n-        args = super(RichTextWidget, self)._base_args()\n-        args[\'name\'] = self.name\n-        value = self.value and self.value.raw or u\'\'\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        value = self.value and self.value.raw or ""\n         value = self.request.get(self.name, value)\n-        args[\'value\'] = value\n+        args["value"] = value\n \n-        args.setdefault(\'pattern_options\', {})\n+        args.setdefault("pattern_options", {})\n         merged_options = dict_merge(\n             get_tinymce_options(\n                 self.wrapped_context(),\n                 self.field,\n                 self.request,\n             ),\n-            args[\'pattern_options\'],\n+            args["pattern_options"],\n         )\n-        args[\'pattern_options\'] = merged_options\n+        args["pattern_options"] = merged_options\n \n         return args\n \n@@ -732,85 +728,83 @@ def render(self):\n         :returns: Widget\'s HTML.\n         :rtype: string\n         """\n-        if self.mode != \'display\':\n+        if self.mode != "display":\n             renderer = queryUtility(\n                 IRichTextWidgetInputModeRenderer,\n                 name=self.getWysiwygEditor(),\n-                default=tinymce_richtextwidget_render\n+                default=tinymce_richtextwidget_render,\n             )\n             return renderer(self)\n \n         if not self.value:\n-            return \'\'\n+            return ""\n \n         if isinstance(self.value, RichTextValue):\n             return self.value.output_relative_to(self.context)\n \n-        return super(RichTextWidget, self).render()\n+        return super().render()\n \n     def render_input_mode(self):\n-            # MODE "INPUT"\n-            rendered = \'\'\n-            allowed_mime_types = self.allowedMimeTypes()\n-            if not allowed_mime_types or len(allowed_mime_types) <= 1:\n-                # Display textarea with default widget\n-                rendered = super(RichTextWidget, self).render()\n-            else:\n-                # Let pat-textarea-mimetype-selector choose the widget\n-\n-                # Initialize the widget without a pattern\n-                base_args = self._base_args()\n-                pattern_options = base_args[\'pattern_options\']\n-                del base_args[\'pattern\']\n-                del base_args[\'pattern_options\']\n-                textarea_widget = self._base(None, None, **base_args)\n-                textarea_widget.klass = \'form-control\'\n-                mt_pattern_name = \'{0}{1}\'.format(\n-                    self._base._klass_prefix,\n-                    \'textareamimetypeselector\',\n-                )\n+        # MODE "INPUT"\n+        rendered = ""\n+        allowed_mime_types = self.allowedMimeTypes()\n+        if not allowed_mime_types or len(allowed_mime_types) <= 1:\n+            # Display textarea with default widget\n+            rendered = super().render()\n+        else:\n+            # Let pat-textarea-mimetype-selector choose the widget\n+\n+            # Initialize the widget without a pattern\n+            base_args = self._base_args()\n+            pattern_options = base_args["pattern_options"]\n+            del base_args["pattern"]\n+            del base_args["pattern_options"]\n+            textarea_widget = self._base(None, None, **base_args)\n+            textarea_widget.klass = "form-control"\n+            mt_pattern_name = "{}{}".format(\n+                self._base._klass_prefix,\n+                "textareamimetypeselector",\n+            )\n \n-                # Initialize mimetype selector pattern\n-                # TODO: default_mime_type returns \'text/html\', regardless of\n-                # settings. fix in plone.app.textfield\n-                value_mime_type = self.value.mimeType if self.value\\\n-                    else self.field.default_mime_type\n-                mt_select = etree.Element(\'select\')\n-                mt_select.attrib[\'id\'] = \'{0}_text_format\'.format(self.id)\n-                mt_select.attrib[\'name\'] = \'{0}.mimeType\'.format(self.name)\n-                mt_select.attrib[\'class\'] = \'form-select {0}\'.format(\n-                    mt_pattern_name)\n-                mt_select.attrib[\n-                    \'data-{0}\'.format(mt_pattern_name)\n-                ] = json.dumps(\n-                    {\n-                        \'textareaName\': self.name,\n-                        \'widgets\': {\n-                            \'text/html\': {  # TODO: currently, we only support\n-                                            # richtext widget config for\n-                                            # \'text/html\', no other mimetypes.\n-                                \'pattern\': self.pattern,\n-                                \'patternOptions\': pattern_options,\n-                            },\n+            # Initialize mimetype selector pattern\n+            # TODO: default_mime_type returns \'text/html\', regardless of\n+            # settings. fix in plone.app.textfield\n+            value_mime_type = (\n+                self.value.mimeType if self.value else self.field.default_mime_type\n+            )\n+            mt_select = etree.Element("select")\n+            mt_select.attrib["id"] = f"{self.id}_text_format"\n+            mt_select.attrib["name"] = f"{self.name}.mimeType"\n+            mt_select.attrib["class"] = "form-select {}".format(mt_pattern_name)\n+            mt_select.attrib[f"data-{mt_pattern_name}"] = json.dumps(\n+                {\n+                    "textareaName": self.name,\n+                    "widgets": {\n+                        "text/html": {  # TODO: currently, we only support\n+                            # richtext widget config for\n+                            # \'text/html\', no other mimetypes.\n+                            "pattern": self.pattern,\n+                            "patternOptions": pattern_options,\n                         },\n                     },\n-                )\n+                },\n+            )\n \n-                # Create a list of allowed mime types\n-                for mt in allowed_mime_types:\n-                    opt = etree.Element(\'option\')\n-                    opt.attrib[\'value\'] = mt\n-                    if value_mime_type == mt:\n-                        opt.attrib[\'selected\'] = \'selected\'\n-                    opt.text = mt\n-                    mt_select.append(opt)\n-\n-                # Render the combined widget\n-                rendered = u\'{0}\\n{1}\'.format(\n-                    textarea_widget.render(),\n-                    etree.tostring(mt_select, encoding=\'unicode\'),\n-                )\n-            return rendered\n+            # Create a list of allowed mime types\n+            for mt in allowed_mime_types:\n+                opt = etree.Element("option")\n+                opt.attrib["value"] = mt\n+                if value_mime_type == mt:\n+                    opt.attrib["selected"] = "selected"\n+                opt.text = mt\n+                mt_select.append(opt)\n+\n+            # Render the combined widget\n+            rendered = "{}\\n{}".format(\n+                textarea_widget.render(),\n+                etree.tostring(mt_select, encoding="unicode"),\n+            )\n+        return rendered\n \n \n def tinymce_richtextwidget_render(widget):\n@@ -828,36 +822,36 @@ class LinkWidget(z3cform_TextWidget):\n \n     def pattern_data(self):\n         pattern_data = {\n-            \'vocabularyUrl\': \'{0}/@@getVocabulary?name=plone.app.vocabularies.Catalog\'.format(  # noqa\n+            "vocabularyUrl": "{}/@@getVocabulary?name=plone.app.vocabularies.Catalog".format(  # noqa\n                 getSite().absolute_url(0),\n             ),\n-            \'maximumSelectionSize\': 1,\n+            "maximumSelectionSize": 1,\n         }\n         return json.dumps(pattern_data)\n \n     def extract(self, default=NO_VALUE):\n         form = self.request.form\n-        internal = form.get(self.name + \'.internal\')\n-        external = form.get(self.name + \'.external\')\n-        email = form.get(self.name + \'.email\')\n+        internal = form.get(self.name + ".internal")\n+        external = form.get(self.name + ".external")\n+        email = form.get(self.name + ".email")\n         if internal:\n-            url = \'${portal_url}/resolveuid/\' + internal\n+            url = "${portal_url}/resolveuid/" + internal\n         elif email:\n-            subject = form.get(self.name + \'.subject\')\n-            if email[:7] != \'mailto:\':\n-                email = \'mailto:\' + email\n+            subject = form.get(self.name + ".subject")\n+            if email[:7] != "mailto:":\n+                email = "mailto:" + email\n             if not subject:\n                 url = email\n             else:\n-                url = \'{email}?subject={subject}\'.format(\n+                url = "{email}?subject={subject}".format(\n                     email=email,\n                     subject=subject,\n                 )\n         else:\n-            url = external   # the default is `http://` so we land here\n+            url = external  # the default is `http://` so we land here\n         if url:\n-            self.request.form[self.name] = safe_unicode(url)\n-        return super(LinkWidget, self).extract(default=default)\n+            self.request.form[self.name] = safe_text(url)\n+        return super().extract(default=default)\n \n \n @implementer(IFieldWidget)\n@@ -915,13 +909,13 @@ def LinkFieldWidget(field, request):\n class SingleCheckBoxBoolWidget(SingleCheckBoxWidget):\n     """Single Input type checkbox widget implementation."""\n \n-    klass = u\'single-checkbox-bool-widget\'\n+    klass = "single-checkbox-bool-widget"\n \n     @property\n     def label(self):\n-        if self.mode == \'input\':\n-            return u\'\'\n-        return getattr(self, \'_label\', u\'\')\n+        if self.mode == "input":\n+            return ""\n+        return getattr(self, "_label", "")\n \n     @label.setter\n     def label(self, value):\n@@ -929,38 +923,42 @@ def label(self, value):\n \n     @property\n     def description(self):\n-        if self.mode == \'input\':\n-            return u\'\'\n-        return getattr(self, \'_description\', u\'\')\n+        if self.mode == "input":\n+            return ""\n+        return getattr(self, "_description", "")\n \n     @description.setter\n     def description(self, value):\n         self._description = value\n \n     def updateTerms(self):\n-        if self.mode == \'input\':\n+        if self.mode == "input":\n             # in input mode use only one checkbox with true\n             self.terms = Terms()\n-            self.terms.terms = SimpleVocabulary((\n-                TermWithDescription(\n-                    True,\n-                    \'selected\',\n-                    getattr(self, \'_label\', None) or self.field.title,\n-                    getattr(\n-                        self,\n-                        \'_description\',\n-                        None,\n-                    ) or self.field.description,\n-                ),\n-            ))\n+            self.terms.terms = SimpleVocabulary(\n+                (\n+                    TermWithDescription(\n+                        True,\n+                        "selected",\n+                        getattr(self, "_label", None) or self.field.title,\n+                        getattr(\n+                            self,\n+                            "_description",\n+                            None,\n+                        )\n+                        or self.field.description,\n+                    ),\n+                )\n+            )\n             return self.terms\n         if not self.terms:\n             self.terms = Terms()\n             self.terms.terms = SimpleVocabulary(\n                 [\n-                    SimpleTerm(*args) for args in [\n-                        (True, \'selected\', BoolTerms.trueLabel),\n-                        (False, \'unselected\', BoolTerms.falseLabel),\n+                    SimpleTerm(*args)\n+                    for args in [\n+                        (True, "selected", BoolTerms.trueLabel),\n+                        (False, "unselected", BoolTerms.falseLabel),\n                     ]\n                 ],\n             )\n@@ -968,11 +966,11 @@ def updateTerms(self):\n \n     @property\n     def items(self):\n-        result = super(SingleCheckBoxBoolWidget, self).items\n+        result = super().items\n         for record in result:\n-            term = self.terms.terms.getTermByToken(record[\'value\'])\n-            record[\'description\'] = getattr(term, \'description\', \'\')\n-            record[\'required\'] = self.required\n+            term = self.terms.terms.getTermByToken(record["value"])\n+            record["description"] = getattr(term, "description", "")\n+            record["required"] = self.required\n         return result\n \n \ndiff --git a/plone/app/z3cform/wysiwyg/__init__.py b/plone/app/z3cform/wysiwyg/__init__.py\nindex f7b239e0..614ff05b 100644\n--- a/plone/app/z3cform/wysiwyg/__init__.py\n+++ b/plone/app/z3cform/wysiwyg/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n # Convenience import\n from plone.app.z3cform.wysiwyg.widget import WysiwygFieldWidget\n \ndiff --git a/plone/app/z3cform/wysiwyg/widget.py b/plone/app/z3cform/wysiwyg/widget.py\nindex bbba908a..09bc9d7d 100644\n--- a/plone/app/z3cform/wysiwyg/widget.py\n+++ b/plone/app/z3cform/wysiwyg/widget.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.component import adapter\n from zope.component.hooks import getSite\n from zope.interface import implementer\n@@ -14,7 +13,7 @@\n import zope.schema.interfaces\n \n \n-logger = logging.getLogger(\'plone.app.z3cform\')\n+logger = logging.getLogger("plone.app.z3cform")\n \n \n class IWysiwygWidget(z3c.form.interfaces.ITextAreaWidget):\n@@ -24,8 +23,8 @@ class IWysiwygWidget(z3c.form.interfaces.ITextAreaWidget):\n @implementer_only(IWysiwygWidget)\n class WysiwygWidget(z3c.form.browser.textarea.TextAreaWidget):\n \n-    klass = u\'kupu-widget\'\n-    value = u\'\'\n+    klass = "kupu-widget"\n+    value = ""\n \n     def update(self):\n         super(z3c.form.browser.textarea.TextAreaWidget, self).update()\n@@ -35,9 +34,10 @@ def update(self):\n         # ``context/portal_this`` if context is not wrapped already.\n         # Any attempts to satisfy the Kupu template in a less idiotic\n         # way failed:\n-        if getattr(self.form.context, \'aq_inner\', None) is None:\n+        if getattr(self.form.context, "aq_inner", None) is None:\n             self.form.context = Acquisition.ImplicitAcquisitionWrapper(\n-                self.form.context, getSite())\n+                self.form.context, getSite()\n+            )\n \n \n @adapter(zope.schema.interfaces.IField, z3c.form.interfaces.IFormLayer)\n@@ -45,8 +45,8 @@ def update(self):\n def WysiwygFieldWidget(field, request):\n     """IFieldWidget factory for WysiwygWidget."""\n     warnings.warn(\n-        \'plone.app.z3cform.wysiwyg.WysiwygFieldWidget is deprecated and\'\n-        \'will be removed in Plone 5.1\',\n+        "plone.app.z3cform.wysiwyg.WysiwygFieldWidget is deprecated and"\n+        "will be removed in Plone 5.1",\n         DeprecationWarning,\n     )\n     return z3c.form.widget.FieldWidget(field, WysiwygWidget(request))\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615de..4dca6482 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -18,3 +18,10 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[tool.isort]\n+# black compatible Plone isort rules:\n+profile = "black"\n+force_alphabetical_sort = true\n+force_single_line = true\n+lines_after_imports = 2\n\\ No newline at end of file\ndiff --git a/setup.py b/setup.py\nindex 41984ffc..71dc0981 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -51,27 +51,16 @@ def read(*rnames):\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'Acquisition\',\n         \'plone.app.textfield>=1.3.6\',\n         \'plone.app.widgets>=2.4.2.dev0\',\n+        \'plone.base\',\n         \'plone.protect\',\n-        \'plone.z3cform>=0.5.11dev\',\n-        \'Products.CMFCore\',\n-        \'Products.CMFPlone\',\n         \'setuptools\',\n-        \'six\',\n         \'z3c.form >= 4.0\',\n         \'z3c.formwidget.query\',\n-        \'zope.browserpage\',\n-        \'zope.component\',\n         \'zope.deprecation\',\n         \'zope.globalrequest\',\n-        \'zope.i18n\',\n-        \'zope.i18nmessageid\',\n-        \'zope.interface\',\n-        \'zope.schema\',\n-        \'zope.traversing\',\n-        \'Zope2\',\n+        \'Zope\',\n     ],\n     extras_require={\n         \'tests\': [\n'

