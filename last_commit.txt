Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T21:43:26+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/a1513cf6e99cb1104b6bac5e6e573d3fbb173d9a

Support using the 'in' operator for paths.

'path in storage' would use storage.__iter__ until now,
and it would not use the _canonical method to strip a trailing slash.
Now we simply define '__contains__' to be the same as 'has_path'.
Makes it more Pythonic.

Files changed:
A news/xxx.bugfix
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_storage.py

b"diff --git a/news/xxx.bugfix b/news/xxx.bugfix\nnew file mode 100644\nindex 0000000..699758f\n--- /dev/null\n+++ b/news/xxx.bugfix\n@@ -0,0 +1,2 @@\n+Support using the 'in' operator for paths.\n+[maurits]\ndiff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex d48cac9..a79c2d2 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -79,6 +79,8 @@ def has_path(self, old_path):\n         old_path = self._canonical(old_path)\n         return old_path in self._paths\n \n+    __contains__ = has_path\n+\n     def get(self, old_path, default=None):\n         old_path = self._canonical(old_path)\n         return self._paths.get(old_path, default)\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 01413bd..aa3cbca 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -19,6 +19,8 @@ def test_storage_one_redirect(self):\n         self.assertEqual(st.get('/foo'), '/bar')\n         self.assertFalse(st.has_path('/bar'))\n         self.assertListEqual(st.redirects('/bar'), ['/foo'])\n+        self.assertIn('/foo', st)\n+        self.assertNotIn('/bar', st)\n \n     def test_storage_no_slash(self):\n         # Standard Plone will created redirects with key\n@@ -31,6 +33,8 @@ def test_storage_no_slash(self):\n         self.assertEqual(st.get('foo'), 'bar')\n         self.assertFalse(st.has_path('bar'))\n         self.assertListEqual(st.redirects('bar'), ['foo'])\n+        self.assertIn('foo', st)\n+        self.assertNotIn('bar', st)\n \n     def test_storage_nested(self):\n         # Since Plone will created redirects with key\n@@ -42,6 +46,8 @@ def test_storage_nested(self):\n         self.assertEqual(st.get('/plone/some/path'), '/plone/a/different/path')\n         self.assertFalse(st.has_path('/plone/a/different/path'))\n         self.assertListEqual(st.redirects('/plone/a/different/path'), ['/plone/some/path'])\n+        self.assertIn('/plone/some/path', st)\n+        self.assertNotIn('/plone/a/different/path', st)\n \n     def test_storage_trailing_slash(self):\n         # trailing slashes are ignored\n@@ -51,6 +57,8 @@ def test_storage_trailing_slash(self):\n         self.assertTrue(st.has_path('/foo/'))\n         self.assertEqual(st.get('/foo/'), '/bar')\n         self.assertListEqual(st.redirects('/bar/'), ['/foo'])\n+        self.assertIn('/foo/', st)\n+        self.assertNotIn('/bar/', st)\n \n         # This goes the other way around too\n         self.assertFalse(st.has_path('/quux'))\n@@ -58,6 +66,8 @@ def test_storage_trailing_slash(self):\n         self.assertTrue(st.has_path('/quux'))\n         self.assertEqual(st.get('/quux'), '/baaz')\n         self.assertListEqual(st.redirects('/baaz'), ['/quux'])\n+        self.assertIn('/quux', st)\n+        self.assertNotIn('/baaz', st)\n \n     def test_storage_two_redirects(self):\n         # Add multiple redirects.\n@@ -67,6 +77,9 @@ def test_storage_two_redirects(self):\n         self.assertTrue(st.has_path('/baz'))\n         self.assertEqual(st.get('/baz'), '/bar')\n         self.assertListEqual(sorted(st.redirects('/bar')), ['/baz', '/foo'])\n+        self.assertIn('/foo', st)\n+        self.assertIn('/baz', st)\n+        self.assertNotIn('/bar', st)\n \n     def test_storage_update_redirect(self):\n         # Update a redirect\n@@ -78,6 +91,7 @@ def test_storage_update_redirect(self):\n         self.assertEqual(st.get('/foo'), '/quux')\n         self.assertListEqual(st.redirects('/bar'), ['/baz'])\n         self.assertListEqual(st.redirects('/quux'), ['/foo'])\n+        self.assertIn('/foo', st)\n \n     def test_storage_remove_redirect(self):\n         # Remove a redirect\n@@ -87,6 +101,7 @@ def test_storage_remove_redirect(self):\n         self.assertFalse(st.has_path('/foo'))\n         self.assertEqual(st.get('/foo', default='_notfound_'), '_notfound_')\n         self.assertListEqual(st.redirects('/bar'), [])\n+        self.assertNotIn('/foo', st)\n \n     def test_storage_chain(self):\n         # Update a redirect in a chain\n@@ -107,6 +122,8 @@ def test_storage_chain(self):\n             sorted(st.redirects('/wilma')), ['/barney', '/fred']\n         )\n         self.assertListEqual(sorted(st.redirects('/barney')), [])\n+        self.assertIn('/fred', st)\n+        self.assertIn('/barney', st)\n \n     def test_storage_destroy_target(self):\n         # Destroy the target of a redirect\n@@ -117,6 +134,8 @@ def test_storage_destroy_target(self):\n         self.assertFalse(st.has_path('/barney'))\n         self.assertFalse(st.has_path('/fred'))\n         self.assertListEqual(st.redirects('/wilma'), [])\n+        self.assertNotIn('/fred', st)\n+        self.assertNotIn('/barney', st)\n \n     def test_storage_iterator(self):\n         # We can get an iterator over all existing paths\n@@ -139,6 +158,7 @@ def test_storage_no_circular(self):\n         self.assertFalse(st.has_path('/circle'))\n         self.assertEqual(st.get('/circle', '_marker_'), '_marker_')\n         self.assertListEqual(st.redirects('/circle'), [])\n+        self.assertNotIn('/circle', st)\n \n     def test_storage_three_step_circular_rename(self):\n         # What about three step circular rename ?\n@@ -180,6 +200,9 @@ def test_storage_three_step_circular_rename(self):\n         self.assertIsNone(st.get('first'))\n         self.assertEqual(st.get('second'), 'first')\n         self.assertEqual(st.get('third'), 'first')\n+        self.assertNotIn('first', st)\n+        self.assertIn('second', st)\n+        self.assertIn('third', st)\n \n         # And same for the back references.\n         self.assertListEqual(st.redirects('first'), ['second', 'third'])\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T21:43:26+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/48c6420025860908edc58d753bb0c266b3131ff0

Support using storage[old_path] to get the new path.

Possibly this raises a KeyError.

Files changed:
M news/xxx.bugfix
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_storage.py

b'diff --git a/news/xxx.bugfix b/news/xxx.bugfix\nindex 699758f..33af295 100644\n--- a/news/xxx.bugfix\n+++ b/news/xxx.bugfix\n@@ -1,2 +1,3 @@\n Support using the \'in\' operator for paths.\n+Support using storage[old_path] to get the new path, possibly raising KeyError.\n [maurits]\ndiff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex a79c2d2..07362c1 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -7,6 +7,9 @@\n from plone.app.redirector.interfaces import IRedirectionStorage\n \n \n+_marker = object()\n+\n+\n @implementer(IRedirectionStorage)\n class RedirectionStorage(Persistent):\n     """Stores old paths to new paths.\n@@ -85,6 +88,12 @@ def get(self, old_path, default=None):\n         old_path = self._canonical(old_path)\n         return self._paths.get(old_path, default)\n \n+    def __getitem__(self, old_path):\n+        result = self.get(old_path, default=_marker)\n+        if result is _marker:\n+            raise KeyError(old_path)\n+        return result\n+\n     def redirects(self, new_path):\n         new_path = self._canonical(new_path)\n         return [a for a in self._rpaths.get(new_path, [])]\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex aa3cbca..8bc3ac5 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -21,6 +21,9 @@ def test_storage_one_redirect(self):\n         self.assertListEqual(st.redirects(\'/bar\'), [\'/foo\'])\n         self.assertIn(\'/foo\', st)\n         self.assertNotIn(\'/bar\', st)\n+        self.assertEqual(st[\'/foo\'], \'/bar\')\n+        with self.assertRaises(KeyError):\n+            st[\'/bar\']\n \n     def test_storage_no_slash(self):\n         # Standard Plone will created redirects with key\n@@ -35,6 +38,9 @@ def test_storage_no_slash(self):\n         self.assertListEqual(st.redirects(\'bar\'), [\'foo\'])\n         self.assertIn(\'foo\', st)\n         self.assertNotIn(\'bar\', st)\n+        self.assertEqual(st[\'foo\'], \'bar\')\n+        with self.assertRaises(KeyError):\n+            st[\'bar\']\n \n     def test_storage_nested(self):\n         # Since Plone will created redirects with key\n@@ -48,6 +54,9 @@ def test_storage_nested(self):\n         self.assertListEqual(st.redirects(\'/plone/a/different/path\'), [\'/plone/some/path\'])\n         self.assertIn(\'/plone/some/path\', st)\n         self.assertNotIn(\'/plone/a/different/path\', st)\n+        self.assertEqual(st[\'/plone/some/path\'], \'/plone/a/different/path\')\n+        with self.assertRaises(KeyError):\n+            st[\'/plone/a/different/path\']\n \n     def test_storage_trailing_slash(self):\n         # trailing slashes are ignored\n@@ -59,6 +68,9 @@ def test_storage_trailing_slash(self):\n         self.assertListEqual(st.redirects(\'/bar/\'), [\'/foo\'])\n         self.assertIn(\'/foo/\', st)\n         self.assertNotIn(\'/bar/\', st)\n+        self.assertEqual(st[\'/foo/\'], \'/bar\')\n+        with self.assertRaises(KeyError):\n+            st[\'/bar/\']\n \n         # This goes the other way around too\n         self.assertFalse(st.has_path(\'/quux\'))\n@@ -68,6 +80,9 @@ def test_storage_trailing_slash(self):\n         self.assertListEqual(st.redirects(\'/baaz\'), [\'/quux\'])\n         self.assertIn(\'/quux\', st)\n         self.assertNotIn(\'/baaz\', st)\n+        self.assertEqual(st[\'/quux\'], \'/baaz\')\n+        with self.assertRaises(KeyError):\n+            st[\'/baaz\']\n \n     def test_storage_two_redirects(self):\n         # Add multiple redirects.\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T21:43:26+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/339f285afb94dd89825c899ff28bae2dcea23a7f

Support using storage[old_path] to set or delete new paths.

Files changed:
M news/xxx.bugfix
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_storage.py

b"diff --git a/news/xxx.bugfix b/news/xxx.bugfix\nindex 33af295..cca7dab 100644\n--- a/news/xxx.bugfix\n+++ b/news/xxx.bugfix\n@@ -1,3 +1,4 @@\n Support using the 'in' operator for paths.\n Support using storage[old_path] to get the new path, possibly raising KeyError.\n+Support using storage[old_path] to set or delete new paths.\n [maurits]\ndiff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex 07362c1..4f6131a 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -59,6 +59,8 @@ def add(self, old_path, new_path):\n         self._paths[old_path] = new_path\n         self._rpaths.setdefault(new_path, OOSet()).insert(old_path)\n \n+    __setitem__ = add\n+\n     def remove(self, old_path):\n         old_path = self._canonical(old_path)\n         new_path = self._paths.get(old_path, None)\n@@ -69,6 +71,8 @@ def remove(self, old_path):\n                 self._rpaths[new_path].remove(old_path)\n         del self._paths[old_path]\n \n+    __delitem__ = remove\n+\n     def destroy(self, new_path):\n         new_path = self._canonical(new_path)\n         for p in self._rpaths.get(new_path, []):\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 8bc3ac5..b50b6f4 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -84,7 +84,7 @@ def test_storage_trailing_slash(self):\n         with self.assertRaises(KeyError):\n             st['/baaz']\n \n-    def test_storage_two_redirects(self):\n+    def test_storage_two_redirects_plain(self):\n         # Add multiple redirects.\n         st = RedirectionStorage()\n         st.add('/foo', '/bar')\n@@ -96,6 +96,18 @@ def test_storage_two_redirects(self):\n         self.assertIn('/baz', st)\n         self.assertNotIn('/bar', st)\n \n+    def test_storage_two_redirects_pythonic(self):\n+        # Add multiple redirects.\n+        st = RedirectionStorage()\n+        st['/foo'] = '/bar'\n+        st['/baz'] = '/bar'\n+        self.assertTrue(st.has_path('/baz'))\n+        self.assertEqual(st.get('/baz'), '/bar')\n+        self.assertListEqual(sorted(st.redirects('/bar')), ['/baz', '/foo'])\n+        self.assertIn('/foo', st)\n+        self.assertIn('/baz', st)\n+        self.assertNotIn('/bar', st)\n+\n     def test_storage_update_redirect(self):\n         # Update a redirect\n         st = RedirectionStorage()\n@@ -108,7 +120,7 @@ def test_storage_update_redirect(self):\n         self.assertListEqual(st.redirects('/quux'), ['/foo'])\n         self.assertIn('/foo', st)\n \n-    def test_storage_remove_redirect(self):\n+    def test_storage_remove_redirect_plain(self):\n         # Remove a redirect\n         st = RedirectionStorage()\n         st.add('/foo', '/bar')\n@@ -117,6 +129,28 @@ def test_storage_remove_redirect(self):\n         self.assertEqual(st.get('/foo', default='_notfound_'), '_notfound_')\n         self.assertListEqual(st.redirects('/bar'), [])\n         self.assertNotIn('/foo', st)\n+        with self.assertRaises(KeyError):\n+            st.remove('/foo')\n+\n+    def test_storage_remove_redirect_pythonic(self):\n+        # Remove a redirect\n+        st = RedirectionStorage()\n+        st['/foo'] = '/bar'\n+        self.assertIn('/foo', st)\n+        del st['/foo']\n+        self.assertNotIn('/foo', st)\n+        with self.assertRaises(KeyError):\n+            st['/foo']\n+        self.assertListEqual(st.redirects('/bar'), [])\n+\n+        # test with extra slash\n+        st['/foo'] = '/bar'\n+        self.assertIn('/foo', st)\n+        del st['/foo/']\n+        self.assertNotIn('/foo', st)\n+        with self.assertRaises(KeyError):\n+            st['/foo/']\n+        self.assertListEqual(st.redirects('/bar'), [])\n \n     def test_storage_chain(self):\n         # Update a redirect in a chain\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T21:43:26+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/b754c1bc8787904fd95021ed230cdd2d6dc36b01

Support using len(storage) to get the number of paths.

Files changed:
M news/xxx.bugfix
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_storage.py

b"diff --git a/news/xxx.bugfix b/news/xxx.bugfix\nindex cca7dab..bf0ca4a 100644\n--- a/news/xxx.bugfix\n+++ b/news/xxx.bugfix\n@@ -1,4 +1,5 @@\n Support using the 'in' operator for paths.\n Support using storage[old_path] to get the new path, possibly raising KeyError.\n Support using storage[old_path] to set or delete new paths.\n+Support using len(storage) to get the number of paths.\n [maurits]\ndiff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex 4f6131a..5f9913b 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -109,3 +109,6 @@ def _canonical(self, path):\n \n     def __iter__(self):\n         return iter(self._paths)\n+\n+    def __len__(self):\n+        return len(self._paths)\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex b50b6f4..9f2d7e0 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -200,6 +200,20 @@ def test_storage_iterator(self):\n         st.add('/barney', '/wilma')\n         self.assertListEqual(sorted(st), ['/barney', '/baz', '/foo'])\n \n+    def test_storage_len(self):\n+        # We can get the length of the storage (number of old paths).\n+        st = RedirectionStorage()\n+        self.assertEqual(len(st), 0)\n+\n+        # Add one\n+        st['/baz'] = '/bar'\n+        self.assertEqual(len(st), 1)\n+\n+        # Now add some more\n+        st['/foo'] = '/bar'\n+        st['/barney'] = '/wilma'\n+        self.assertEqual(len(st), 3)\n+\n     def test_storage_no_circular(self):\n         # Circular references are ignored\n         st = RedirectionStorage()\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T21:43:26+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/96cf70d206456b0a8e6d16b043f957a43834c308

Added performance tests.

Call with `export PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER=100000` to enable.

Files changed:
A plone/app/redirector/tests/test_performance.py
M news/xxx.bugfix

b'diff --git a/news/xxx.bugfix b/news/xxx.bugfix\nindex bf0ca4a..7b2a874 100644\n--- a/news/xxx.bugfix\n+++ b/news/xxx.bugfix\n@@ -2,4 +2,5 @@ Support using the \'in\' operator for paths.\n Support using storage[old_path] to get the new path, possibly raising KeyError.\n Support using storage[old_path] to set or delete new paths.\n Support using len(storage) to get the number of paths.\n+Added performance tests.  Call with ``export PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER=100000`` to enable.\n [maurits]\ndiff --git a/plone/app/redirector/tests/test_performance.py b/plone/app/redirector/tests/test_performance.py\nnew file mode 100644\nindex 0000000..9132ecd\n--- /dev/null\n+++ b/plone/app/redirector/tests/test_performance.py\n@@ -0,0 +1,85 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.redirector.storage import RedirectionStorage\n+from time import time\n+\n+import os\n+import unittest\n+\n+\n+env_name = \'PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER\'\n+NUMBER = int(os.getenv(env_name, 0))\n+\n+\n+class TestStoragePerformance(unittest.TestCase):\n+    """Test the performance of the RedirectionStorage class.\n+    """\n+\n+    @unittest.skipIf(NUMBER <= 0, \'{0} env variable not set\'.format(env_name))\n+    def test_storage_performance(self):\n+        """Test the performance of some of the code.\n+\n+        This is skipped by default, unless you set an environment variable.\n+        If you don\'t set this, or set this to zero or less, you will see\n+        a skip reason when you run the tests with enough verbosity:\n+\n+            $ bin/test -s plone.app.redirector -m test_performance -vvv\n+\n+        Sample run with one hundred thousand inserts:\n+\n+            $ PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER=100000 \\\n+                bin/test -s plone.app.redirector -m test_performance\n+            ...\n+            Running plone.app.redirector storage performance tests.\n+            Inserting 100000 paths...\n+            Inserting: 0.74 seconds\n+            Getting length: 0.00 seconds\n+            Getting iterator: 0.00 seconds\n+            Listing all: 0.01 seconds\n+            Listing and getting each single one: 0.16 seconds\n+\n+        """\n+        st = RedirectionStorage()\n+\n+        start_time = time()\n+        print(\'\\nRunning plone.app.redirector storage performance tests.\')\n+        print(\'Inserting {0} paths...\'.format(NUMBER))\n+        for i in range(NUMBER):\n+            st[\'/old/{0}\'.format(i)] = \'/new/{0}\'.format(i)\n+        insert_time = time()\n+        insert_seconds = insert_time - start_time\n+        print(\'Inserting: {0:.2f} seconds\'.format(insert_seconds))\n+\n+        # len\n+        self.assertEqual(len(st), NUMBER)\n+        length_time = time()\n+        length_seconds = length_time - insert_time\n+        print(\'Getting length: {0:.2f} seconds\'.format(length_seconds))\n+\n+        # iter\n+        iter(st)\n+        iter_time = time()\n+        iter_seconds = iter_time - length_time\n+        print(\'Getting iterator: {0:.2f} seconds\'.format(iter_seconds))\n+\n+        # list\n+        list(st)\n+        list_time = time()\n+        list_seconds = list_time - iter_time\n+        print(\'Listing all: {0:.2f} seconds\'.format(list_seconds))\n+\n+        # list + get\n+        for key in st:\n+            st[key]\n+        getall_time = time()\n+        getall_seconds = getall_time - list_time\n+        print(\n+            \'Listing and getting each single one: {0:.2f} seconds\'.format(\n+                getall_seconds\n+            )\n+        )\n+\n+\n+def test_suite():\n+    suite = unittest.TestSuite()\n+    suite.addTest(unittest.makeSuite(TestStoragePerformance))\n+    return suite\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T22:18:03+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/8a75ae06550c0fb9fa88b897f269007e9b427831

Use timeit context manager to report on the performance.

Files changed:
M plone/app/redirector/tests/test_performance.py

b'diff --git a/plone/app/redirector/tests/test_performance.py b/plone/app/redirector/tests/test_performance.py\nindex 9132ecd..ffca978 100644\n--- a/plone/app/redirector/tests/test_performance.py\n+++ b/plone/app/redirector/tests/test_performance.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from contextlib import contextmanager\n from plone.app.redirector.storage import RedirectionStorage\n from time import time\n \n@@ -14,6 +15,27 @@ class TestStoragePerformance(unittest.TestCase):\n     """Test the performance of the RedirectionStorage class.\n     """\n \n+    @contextmanager\n+    def timeit(self, message, limit=0):\n+        start = time()\n+        yield\n+        end = time()\n+        total = end - start\n+        # Allow taking at least 0.1 seconds.  Otherwise a really low NUMBER\n+        # like 0 may give errors like this:\n+        # AssertionError: Listing all takes too long: 0.00 seconds (max 1e-06)\n+        limit = max(limit, 0.1)\n+        if total > limit:\n+            self.fail(\n+                \'{0} takes too long: {1:.2f} seconds (max {2})\'.format(\n+                    message, total, limit\n+                )\n+            )\n+        else:\n+            print(\n+                \'{0}: {1:.2f} seconds (max {2})\'.format(message, total, limit)\n+            )\n+\n     @unittest.skipIf(NUMBER <= 0, \'{0} env variable not set\'.format(env_name))\n     def test_storage_performance(self):\n         """Test the performance of some of the code.\n@@ -24,59 +46,47 @@ def test_storage_performance(self):\n \n             $ bin/test -s plone.app.redirector -m test_performance -vvv\n \n-        Sample run with one hundred thousand inserts:\n+        Sample run with one million inserts:\n \n-            $ PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER=100000 \\\n+            $ PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER=1000000 \\\n                 bin/test -s plone.app.redirector -m test_performance\n             ...\n             Running plone.app.redirector storage performance tests.\n-            Inserting 100000 paths...\n-            Inserting: 0.74 seconds\n-            Getting length: 0.00 seconds\n-            Getting iterator: 0.00 seconds\n-            Listing all: 0.01 seconds\n-            Listing and getting each single one: 0.16 seconds\n+            Inserting 1000000 paths...\n+            Inserting: 9.39 seconds (max 1000.0)\n+            Getting length: 0.01 seconds (max 0.1)\n+            Getting iterator: 0.00 seconds (max 0.1)\n+            Listing all: 0.05 seconds (max 1.0)\n+            Listing and getting each single one: 1.82 seconds (max 10.0)\n \n         """\n         st = RedirectionStorage()\n \n-        start_time = time()\n         print(\'\\nRunning plone.app.redirector storage performance tests.\')\n         print(\'Inserting {0} paths...\'.format(NUMBER))\n-        for i in range(NUMBER):\n-            st[\'/old/{0}\'.format(i)] = \'/new/{0}\'.format(i)\n-        insert_time = time()\n-        insert_seconds = insert_time - start_time\n-        print(\'Inserting: {0:.2f} seconds\'.format(insert_seconds))\n-\n-        # len\n-        self.assertEqual(len(st), NUMBER)\n-        length_time = time()\n-        length_seconds = length_time - insert_time\n-        print(\'Getting length: {0:.2f} seconds\'.format(length_seconds))\n-\n-        # iter\n-        iter(st)\n-        iter_time = time()\n-        iter_seconds = iter_time - length_time\n-        print(\'Getting iterator: {0:.2f} seconds\'.format(iter_seconds))\n-\n-        # list\n-        list(st)\n-        list_time = time()\n-        list_seconds = list_time - iter_time\n-        print(\'Listing all: {0:.2f} seconds\'.format(list_seconds))\n-\n-        # list + get\n-        for key in st:\n-            st[key]\n-        getall_time = time()\n-        getall_seconds = getall_time - list_time\n-        print(\n-            \'Listing and getting each single one: {0:.2f} seconds\'.format(\n-                getall_seconds\n-            )\n-        )\n+        # Can take long.  But 10.000 per second should be no problem.\n+        with self.timeit(\'Inserting\', NUMBER / 10000.0):\n+            for i in range(NUMBER):\n+                st[\'/old/{0}\'.format(i)] = \'/new/{0}\'.format(i)\n+\n+        # Should be almost instantaneous.\n+        with self.timeit(\'Getting length\'):\n+            self.assertEqual(len(st), NUMBER)\n+\n+        # Should be almost instantaneous.\n+        with self.timeit(\'Getting iterator\'):\n+            iter(st)\n+\n+        # Should be fairly quick.\n+        with self.timeit(\'Listing all\', NUMBER / 1000000.0):\n+            list(st)\n+\n+        # Should be reasonably quick, but the time is noticeable.\n+        with self.timeit(\n+            \'Listing and getting each single one\', NUMBER / 100000.0\n+        ):\n+            for key in st:\n+                st[key]\n \n \n def test_suite():\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T22:18:40+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/82133eedc7cf25fe3b2d7f3af7f9bf393d3ba54d

Renamed news snippet.

Files changed:
A news/13.bugfix
D news/xxx.bugfix

b'diff --git a/news/xxx.bugfix b/news/13.bugfix\nsimilarity index 100%\nrename from news/xxx.bugfix\nrename to news/13.bugfix\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T22:45:34+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/9e0b1253071c8ae83624be221de48feea8652d55

Always run performance tests, but default with a low number of paths.

Raise assertionError when this is too slow.
Don't print anything else.
Only print stuff when the PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER environment variable is set.

Files changed:
M plone/app/redirector/tests/test_performance.py

b'diff --git a/plone/app/redirector/tests/test_performance.py b/plone/app/redirector/tests/test_performance.py\nindex ffca978..0c1efba 100644\n--- a/plone/app/redirector/tests/test_performance.py\n+++ b/plone/app/redirector/tests/test_performance.py\n@@ -8,7 +8,17 @@\n \n \n env_name = \'PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER\'\n-NUMBER = int(os.getenv(env_name, 0))\n+if env_name in os.environ:\n+    # This could fail with a ValueError, but that seems a fine error message.\n+    NUMBER = int(os.getenv(env_name))\n+    VERBOSE = True\n+else:\n+    # No environment variable set.\n+    # Pick a relatively low number so the run is fast.\n+    # And don\'t be verbose, don\'t print anything:\n+    # only give an assertion error when it is really slow.\n+    NUMBER = 10000\n+    VERBOSE = False\n \n \n class TestStoragePerformance(unittest.TestCase):\n@@ -31,7 +41,7 @@ def timeit(self, message, limit=0):\n                     message, total, limit\n                 )\n             )\n-        else:\n+        elif VERBOSE:\n             print(\n                 \'{0}: {1:.2f} seconds (max {2})\'.format(message, total, limit)\n             )\n@@ -61,9 +71,10 @@ def test_storage_performance(self):\n \n         """\n         st = RedirectionStorage()\n+        if VERBOSE:\n+            print(\'\\nRunning plone.app.redirector storage performance tests.\')\n+            print(\'Inserting {0} paths...\'.format(NUMBER))\n \n-        print(\'\\nRunning plone.app.redirector storage performance tests.\')\n-        print(\'Inserting {0} paths...\'.format(NUMBER))\n         # Can take long.  But 10.000 per second should be no problem.\n         with self.timeit(\'Inserting\', NUMBER / 10000.0):\n             for i in range(NUMBER):\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T22:55:06+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/99efffd87ffa01a4dd01699891799f79acb18cc9

Never skip the performance tests.

The previous commit had the effect that they were run by default,
and only were skipped when the env variable was zero.
But that does not make much sense.

Also, even with a high test verbosity level (`bin/test -vvvvvv`),
sometimes the skip reason was shown and sometimes not.
The length of the reason seemed to matter at some point, but I could not get a grip on that.

Files changed:
M plone/app/redirector/tests/test_performance.py

b'diff --git a/plone/app/redirector/tests/test_performance.py b/plone/app/redirector/tests/test_performance.py\nindex 0c1efba..633865d 100644\n--- a/plone/app/redirector/tests/test_performance.py\n+++ b/plone/app/redirector/tests/test_performance.py\n@@ -10,7 +10,7 @@\n env_name = \'PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER\'\n if env_name in os.environ:\n     # This could fail with a ValueError, but that seems a fine error message.\n-    NUMBER = int(os.getenv(env_name))\n+    NUMBER = max(int(os.getenv(env_name)), 1)\n     VERBOSE = True\n else:\n     # No environment variable set.\n@@ -46,16 +46,9 @@ def timeit(self, message, limit=0):\n                 \'{0}: {1:.2f} seconds (max {2})\'.format(message, total, limit)\n             )\n \n-    @unittest.skipIf(NUMBER <= 0, \'{0} env variable not set\'.format(env_name))\n     def test_storage_performance(self):\n         """Test the performance of some of the code.\n \n-        This is skipped by default, unless you set an environment variable.\n-        If you don\'t set this, or set this to zero or less, you will see\n-        a skip reason when you run the tests with enough verbosity:\n-\n-            $ bin/test -s plone.app.redirector -m test_performance -vvv\n-\n         Sample run with one million inserts:\n \n             $ PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER=1000000 \\\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-14T10:22:18+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.redirector/commit/4db8952384ce1674acf056d96560ecf7edaaf794

Merge pull request #15 from plone/maurits-more-pythonic

Support more Pythonic use of the RedirectionStorage

Files changed:
A news/13.bugfix
A plone/app/redirector/tests/test_performance.py
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_storage.py

b'diff --git a/news/13.bugfix b/news/13.bugfix\nnew file mode 100644\nindex 0000000..7b2a874\n--- /dev/null\n+++ b/news/13.bugfix\n@@ -0,0 +1,6 @@\n+Support using the \'in\' operator for paths.\n+Support using storage[old_path] to get the new path, possibly raising KeyError.\n+Support using storage[old_path] to set or delete new paths.\n+Support using len(storage) to get the number of paths.\n+Added performance tests.  Call with ``export PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER=100000`` to enable.\n+[maurits]\ndiff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex d48cac9..5f9913b 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -7,6 +7,9 @@\n from plone.app.redirector.interfaces import IRedirectionStorage\n \n \n+_marker = object()\n+\n+\n @implementer(IRedirectionStorage)\n class RedirectionStorage(Persistent):\n     """Stores old paths to new paths.\n@@ -56,6 +59,8 @@ def add(self, old_path, new_path):\n         self._paths[old_path] = new_path\n         self._rpaths.setdefault(new_path, OOSet()).insert(old_path)\n \n+    __setitem__ = add\n+\n     def remove(self, old_path):\n         old_path = self._canonical(old_path)\n         new_path = self._paths.get(old_path, None)\n@@ -66,6 +71,8 @@ def remove(self, old_path):\n                 self._rpaths[new_path].remove(old_path)\n         del self._paths[old_path]\n \n+    __delitem__ = remove\n+\n     def destroy(self, new_path):\n         new_path = self._canonical(new_path)\n         for p in self._rpaths.get(new_path, []):\n@@ -79,10 +86,18 @@ def has_path(self, old_path):\n         old_path = self._canonical(old_path)\n         return old_path in self._paths\n \n+    __contains__ = has_path\n+\n     def get(self, old_path, default=None):\n         old_path = self._canonical(old_path)\n         return self._paths.get(old_path, default)\n \n+    def __getitem__(self, old_path):\n+        result = self.get(old_path, default=_marker)\n+        if result is _marker:\n+            raise KeyError(old_path)\n+        return result\n+\n     def redirects(self, new_path):\n         new_path = self._canonical(new_path)\n         return [a for a in self._rpaths.get(new_path, [])]\n@@ -94,3 +109,6 @@ def _canonical(self, path):\n \n     def __iter__(self):\n         return iter(self._paths)\n+\n+    def __len__(self):\n+        return len(self._paths)\ndiff --git a/plone/app/redirector/tests/test_performance.py b/plone/app/redirector/tests/test_performance.py\nnew file mode 100644\nindex 0000000..633865d\n--- /dev/null\n+++ b/plone/app/redirector/tests/test_performance.py\n@@ -0,0 +1,99 @@\n+# -*- coding: utf-8 -*-\n+from contextlib import contextmanager\n+from plone.app.redirector.storage import RedirectionStorage\n+from time import time\n+\n+import os\n+import unittest\n+\n+\n+env_name = \'PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER\'\n+if env_name in os.environ:\n+    # This could fail with a ValueError, but that seems a fine error message.\n+    NUMBER = max(int(os.getenv(env_name)), 1)\n+    VERBOSE = True\n+else:\n+    # No environment variable set.\n+    # Pick a relatively low number so the run is fast.\n+    # And don\'t be verbose, don\'t print anything:\n+    # only give an assertion error when it is really slow.\n+    NUMBER = 10000\n+    VERBOSE = False\n+\n+\n+class TestStoragePerformance(unittest.TestCase):\n+    """Test the performance of the RedirectionStorage class.\n+    """\n+\n+    @contextmanager\n+    def timeit(self, message, limit=0):\n+        start = time()\n+        yield\n+        end = time()\n+        total = end - start\n+        # Allow taking at least 0.1 seconds.  Otherwise a really low NUMBER\n+        # like 0 may give errors like this:\n+        # AssertionError: Listing all takes too long: 0.00 seconds (max 1e-06)\n+        limit = max(limit, 0.1)\n+        if total > limit:\n+            self.fail(\n+                \'{0} takes too long: {1:.2f} seconds (max {2})\'.format(\n+                    message, total, limit\n+                )\n+            )\n+        elif VERBOSE:\n+            print(\n+                \'{0}: {1:.2f} seconds (max {2})\'.format(message, total, limit)\n+            )\n+\n+    def test_storage_performance(self):\n+        """Test the performance of some of the code.\n+\n+        Sample run with one million inserts:\n+\n+            $ PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER=1000000 \\\n+                bin/test -s plone.app.redirector -m test_performance\n+            ...\n+            Running plone.app.redirector storage performance tests.\n+            Inserting 1000000 paths...\n+            Inserting: 9.39 seconds (max 1000.0)\n+            Getting length: 0.01 seconds (max 0.1)\n+            Getting iterator: 0.00 seconds (max 0.1)\n+            Listing all: 0.05 seconds (max 1.0)\n+            Listing and getting each single one: 1.82 seconds (max 10.0)\n+\n+        """\n+        st = RedirectionStorage()\n+        if VERBOSE:\n+            print(\'\\nRunning plone.app.redirector storage performance tests.\')\n+            print(\'Inserting {0} paths...\'.format(NUMBER))\n+\n+        # Can take long.  But 10.000 per second should be no problem.\n+        with self.timeit(\'Inserting\', NUMBER / 10000.0):\n+            for i in range(NUMBER):\n+                st[\'/old/{0}\'.format(i)] = \'/new/{0}\'.format(i)\n+\n+        # Should be almost instantaneous.\n+        with self.timeit(\'Getting length\'):\n+            self.assertEqual(len(st), NUMBER)\n+\n+        # Should be almost instantaneous.\n+        with self.timeit(\'Getting iterator\'):\n+            iter(st)\n+\n+        # Should be fairly quick.\n+        with self.timeit(\'Listing all\', NUMBER / 1000000.0):\n+            list(st)\n+\n+        # Should be reasonably quick, but the time is noticeable.\n+        with self.timeit(\n+            \'Listing and getting each single one\', NUMBER / 100000.0\n+        ):\n+            for key in st:\n+                st[key]\n+\n+\n+def test_suite():\n+    suite = unittest.TestSuite()\n+    suite.addTest(unittest.makeSuite(TestStoragePerformance))\n+    return suite\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 01413bd..9f2d7e0 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -19,6 +19,11 @@ def test_storage_one_redirect(self):\n         self.assertEqual(st.get(\'/foo\'), \'/bar\')\n         self.assertFalse(st.has_path(\'/bar\'))\n         self.assertListEqual(st.redirects(\'/bar\'), [\'/foo\'])\n+        self.assertIn(\'/foo\', st)\n+        self.assertNotIn(\'/bar\', st)\n+        self.assertEqual(st[\'/foo\'], \'/bar\')\n+        with self.assertRaises(KeyError):\n+            st[\'/bar\']\n \n     def test_storage_no_slash(self):\n         # Standard Plone will created redirects with key\n@@ -31,6 +36,11 @@ def test_storage_no_slash(self):\n         self.assertEqual(st.get(\'foo\'), \'bar\')\n         self.assertFalse(st.has_path(\'bar\'))\n         self.assertListEqual(st.redirects(\'bar\'), [\'foo\'])\n+        self.assertIn(\'foo\', st)\n+        self.assertNotIn(\'bar\', st)\n+        self.assertEqual(st[\'foo\'], \'bar\')\n+        with self.assertRaises(KeyError):\n+            st[\'bar\']\n \n     def test_storage_nested(self):\n         # Since Plone will created redirects with key\n@@ -42,6 +52,11 @@ def test_storage_nested(self):\n         self.assertEqual(st.get(\'/plone/some/path\'), \'/plone/a/different/path\')\n         self.assertFalse(st.has_path(\'/plone/a/different/path\'))\n         self.assertListEqual(st.redirects(\'/plone/a/different/path\'), [\'/plone/some/path\'])\n+        self.assertIn(\'/plone/some/path\', st)\n+        self.assertNotIn(\'/plone/a/different/path\', st)\n+        self.assertEqual(st[\'/plone/some/path\'], \'/plone/a/different/path\')\n+        with self.assertRaises(KeyError):\n+            st[\'/plone/a/different/path\']\n \n     def test_storage_trailing_slash(self):\n         # trailing slashes are ignored\n@@ -51,6 +66,11 @@ def test_storage_trailing_slash(self):\n         self.assertTrue(st.has_path(\'/foo/\'))\n         self.assertEqual(st.get(\'/foo/\'), \'/bar\')\n         self.assertListEqual(st.redirects(\'/bar/\'), [\'/foo\'])\n+        self.assertIn(\'/foo/\', st)\n+        self.assertNotIn(\'/bar/\', st)\n+        self.assertEqual(st[\'/foo/\'], \'/bar\')\n+        with self.assertRaises(KeyError):\n+            st[\'/bar/\']\n \n         # This goes the other way around too\n         self.assertFalse(st.has_path(\'/quux\'))\n@@ -58,8 +78,13 @@ def test_storage_trailing_slash(self):\n         self.assertTrue(st.has_path(\'/quux\'))\n         self.assertEqual(st.get(\'/quux\'), \'/baaz\')\n         self.assertListEqual(st.redirects(\'/baaz\'), [\'/quux\'])\n+        self.assertIn(\'/quux\', st)\n+        self.assertNotIn(\'/baaz\', st)\n+        self.assertEqual(st[\'/quux\'], \'/baaz\')\n+        with self.assertRaises(KeyError):\n+            st[\'/baaz\']\n \n-    def test_storage_two_redirects(self):\n+    def test_storage_two_redirects_plain(self):\n         # Add multiple redirects.\n         st = RedirectionStorage()\n         st.add(\'/foo\', \'/bar\')\n@@ -67,6 +92,21 @@ def test_storage_two_redirects(self):\n         self.assertTrue(st.has_path(\'/baz\'))\n         self.assertEqual(st.get(\'/baz\'), \'/bar\')\n         self.assertListEqual(sorted(st.redirects(\'/bar\')), [\'/baz\', \'/foo\'])\n+        self.assertIn(\'/foo\', st)\n+        self.assertIn(\'/baz\', st)\n+        self.assertNotIn(\'/bar\', st)\n+\n+    def test_storage_two_redirects_pythonic(self):\n+        # Add multiple redirects.\n+        st = RedirectionStorage()\n+        st[\'/foo\'] = \'/bar\'\n+        st[\'/baz\'] = \'/bar\'\n+        self.assertTrue(st.has_path(\'/baz\'))\n+        self.assertEqual(st.get(\'/baz\'), \'/bar\')\n+        self.assertListEqual(sorted(st.redirects(\'/bar\')), [\'/baz\', \'/foo\'])\n+        self.assertIn(\'/foo\', st)\n+        self.assertIn(\'/baz\', st)\n+        self.assertNotIn(\'/bar\', st)\n \n     def test_storage_update_redirect(self):\n         # Update a redirect\n@@ -78,8 +118,9 @@ def test_storage_update_redirect(self):\n         self.assertEqual(st.get(\'/foo\'), \'/quux\')\n         self.assertListEqual(st.redirects(\'/bar\'), [\'/baz\'])\n         self.assertListEqual(st.redirects(\'/quux\'), [\'/foo\'])\n+        self.assertIn(\'/foo\', st)\n \n-    def test_storage_remove_redirect(self):\n+    def test_storage_remove_redirect_plain(self):\n         # Remove a redirect\n         st = RedirectionStorage()\n         st.add(\'/foo\', \'/bar\')\n@@ -87,6 +128,29 @@ def test_storage_remove_redirect(self):\n         self.assertFalse(st.has_path(\'/foo\'))\n         self.assertEqual(st.get(\'/foo\', default=\'_notfound_\'), \'_notfound_\')\n         self.assertListEqual(st.redirects(\'/bar\'), [])\n+        self.assertNotIn(\'/foo\', st)\n+        with self.assertRaises(KeyError):\n+            st.remove(\'/foo\')\n+\n+    def test_storage_remove_redirect_pythonic(self):\n+        # Remove a redirect\n+        st = RedirectionStorage()\n+        st[\'/foo\'] = \'/bar\'\n+        self.assertIn(\'/foo\', st)\n+        del st[\'/foo\']\n+        self.assertNotIn(\'/foo\', st)\n+        with self.assertRaises(KeyError):\n+            st[\'/foo\']\n+        self.assertListEqual(st.redirects(\'/bar\'), [])\n+\n+        # test with extra slash\n+        st[\'/foo\'] = \'/bar\'\n+        self.assertIn(\'/foo\', st)\n+        del st[\'/foo/\']\n+        self.assertNotIn(\'/foo\', st)\n+        with self.assertRaises(KeyError):\n+            st[\'/foo/\']\n+        self.assertListEqual(st.redirects(\'/bar\'), [])\n \n     def test_storage_chain(self):\n         # Update a redirect in a chain\n@@ -107,6 +171,8 @@ def test_storage_chain(self):\n             sorted(st.redirects(\'/wilma\')), [\'/barney\', \'/fred\']\n         )\n         self.assertListEqual(sorted(st.redirects(\'/barney\')), [])\n+        self.assertIn(\'/fred\', st)\n+        self.assertIn(\'/barney\', st)\n \n     def test_storage_destroy_target(self):\n         # Destroy the target of a redirect\n@@ -117,6 +183,8 @@ def test_storage_destroy_target(self):\n         self.assertFalse(st.has_path(\'/barney\'))\n         self.assertFalse(st.has_path(\'/fred\'))\n         self.assertListEqual(st.redirects(\'/wilma\'), [])\n+        self.assertNotIn(\'/fred\', st)\n+        self.assertNotIn(\'/barney\', st)\n \n     def test_storage_iterator(self):\n         # We can get an iterator over all existing paths\n@@ -132,6 +200,20 @@ def test_storage_iterator(self):\n         st.add(\'/barney\', \'/wilma\')\n         self.assertListEqual(sorted(st), [\'/barney\', \'/baz\', \'/foo\'])\n \n+    def test_storage_len(self):\n+        # We can get the length of the storage (number of old paths).\n+        st = RedirectionStorage()\n+        self.assertEqual(len(st), 0)\n+\n+        # Add one\n+        st[\'/baz\'] = \'/bar\'\n+        self.assertEqual(len(st), 1)\n+\n+        # Now add some more\n+        st[\'/foo\'] = \'/bar\'\n+        st[\'/barney\'] = \'/wilma\'\n+        self.assertEqual(len(st), 3)\n+\n     def test_storage_no_circular(self):\n         # Circular references are ignored\n         st = RedirectionStorage()\n@@ -139,6 +221,7 @@ def test_storage_no_circular(self):\n         self.assertFalse(st.has_path(\'/circle\'))\n         self.assertEqual(st.get(\'/circle\', \'_marker_\'), \'_marker_\')\n         self.assertListEqual(st.redirects(\'/circle\'), [])\n+        self.assertNotIn(\'/circle\', st)\n \n     def test_storage_three_step_circular_rename(self):\n         # What about three step circular rename ?\n@@ -180,6 +263,9 @@ def test_storage_three_step_circular_rename(self):\n         self.assertIsNone(st.get(\'first\'))\n         self.assertEqual(st.get(\'second\'), \'first\')\n         self.assertEqual(st.get(\'third\'), \'first\')\n+        self.assertNotIn(\'first\', st)\n+        self.assertIn(\'second\', st)\n+        self.assertIn(\'third\', st)\n \n         # And same for the back references.\n         self.assertListEqual(st.redirects(\'first\'), [\'second\', \'third\'])\n'

