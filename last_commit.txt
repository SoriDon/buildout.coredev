Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-11T18:13:40+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/336e2ac8da028aac3d3cd7e68af4637fc8db754b

Store date information in new _dates structure.

Can be used as basis for removing for example all redirects that are older than a year.

Files changed:
A news/17.feature
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_performance.py
M plone/app/redirector/tests/test_storage.py

b"diff --git a/news/17.feature b/news/17.feature\nnew file mode 100644\nindex 0000000..20f7c4b\n--- /dev/null\n+++ b/news/17.feature\n@@ -0,0 +1,3 @@\n+Store date information in new _dates structure.\n+Can be used as basis for removing for example all redirects that are older than a year.\n+[maurits]\ndiff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex 91c12c3..f171002 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -3,7 +3,7 @@\n \n from persistent import Persistent\n from BTrees.OOBTree import OOBTree, OOSet\n-\n+from DateTime import DateTime\n from plone.app.redirector.interfaces import IRedirectionStorage\n \n \n@@ -32,8 +32,9 @@ def clear(self):\n         # but making them fresh seems cleaner and faster.\n         self._paths = OOBTree()\n         self._rpaths = OOBTree()\n+        self._dates = OOBTree()\n \n-    def add(self, old_path, new_path):\n+    def add(self, old_path, new_path, now=None):\n         old_path = self._canonical(old_path)\n         new_path = self._canonical(new_path)\n \n@@ -56,6 +57,7 @@ def add(self, old_path, new_path):\n                 self._rpaths.setdefault(new_path, OOSet()).insert(p)\n             else:\n                 del self._paths[new_path]\n+                self._dates.pop(new_path, None)\n \n         # Remove reverse paths for old_path\n         if old_path in self._rpaths:\n@@ -63,12 +65,16 @@ def add(self, old_path, new_path):\n \n         self._paths[old_path] = new_path\n         self._rpaths.setdefault(new_path, OOSet()).insert(old_path)\n+        if now is None:\n+            now = DateTime()\n+        self._dates[old_path] = now\n \n     __setitem__ = add\n \n     def update(self, info):\n+        now = DateTime()\n         for key, value in info.items():\n-            self.add(key, value)\n+            self.add(key, value, now=now)\n \n     def remove(self, old_path):\n         old_path = self._canonical(old_path)\n@@ -79,14 +85,26 @@ def remove(self, old_path):\n             else:\n                 self._rpaths[new_path].remove(old_path)\n         del self._paths[old_path]\n+        # _dates are a new addition, so be forgiving when nothing is found.\n+        # We can create a method for setting a date for all in migration.\n+        self._dates.pop(old_path, None)\n \n     __delitem__ = remove\n \n+    def _rebuild_dates(self):\n+        # Rebuild the _dates information.\n+        # Can be used in migration to initialize the _dates.\n+        now = DateTime()\n+        self._dates.clear()\n+        for path in self._paths:\n+            self._dates[path] = now\n+\n     def destroy(self, new_path):\n         new_path = self._canonical(new_path)\n         for p in self._rpaths.get(new_path, []):\n             if p in self._paths:\n                 del self._paths[p]\n+                self._dates.pop(p, None)\n         if new_path in self._rpaths:\n             if new_path in self._rpaths:\n                 del self._rpaths[new_path]\ndiff --git a/plone/app/redirector/tests/test_performance.py b/plone/app/redirector/tests/test_performance.py\nindex c8821db..a41bab3 100644\n--- a/plone/app/redirector/tests/test_performance.py\n+++ b/plone/app/redirector/tests/test_performance.py\n@@ -136,3 +136,9 @@ def test_storage_performance(self):\n         ):\n             for key in st:\n                 st[key]\n+\n+        # Can take long.  But 10.000 per second should be no problem.\n+        with self.timeit(\n+            'Rebuilding the _dates structure for migration', NUMBER / 100000.0\n+        ):\n+            st._rebuild_dates()\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 1967798..54dbd5b 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -120,6 +120,7 @@ def test_storage_clear(self):\n         # Test the internal structures directly\n         self.assertEqual(len(st._paths), 0)\n         self.assertEqual(len(st._rpaths), 0)\n+        self.assertEqual(len(st._dates), 0)\n \n     def test_storage_update_redirect(self):\n         # Update a redirect\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-11T18:20:23+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/91e75b865889b3706c3fcf76c0ba30e7294e1ed7

Try saving date.

Files changed:
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_storage.py

b'diff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex f171002..5bf9991 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -32,7 +32,6 @@ def clear(self):\n         # but making them fresh seems cleaner and faster.\n         self._paths = OOBTree()\n         self._rpaths = OOBTree()\n-        self._dates = OOBTree()\n \n     def add(self, old_path, new_path, now=None):\n         old_path = self._canonical(old_path)\n@@ -57,17 +56,15 @@ def add(self, old_path, new_path, now=None):\n                 self._rpaths.setdefault(new_path, OOSet()).insert(p)\n             else:\n                 del self._paths[new_path]\n-                self._dates.pop(new_path, None)\n \n         # Remove reverse paths for old_path\n         if old_path in self._rpaths:\n             del self._rpaths[old_path]\n \n-        self._paths[old_path] = new_path\n-        self._rpaths.setdefault(new_path, OOSet()).insert(old_path)\n         if now is None:\n             now = DateTime()\n-        self._dates[old_path] = now\n+        self._paths[old_path] = (new_path, now)\n+        self._rpaths.setdefault(new_path, OOSet()).insert(old_path)\n \n     __setitem__ = add\n \n@@ -85,9 +82,6 @@ def remove(self, old_path):\n             else:\n                 self._rpaths[new_path].remove(old_path)\n         del self._paths[old_path]\n-        # _dates are a new addition, so be forgiving when nothing is found.\n-        # We can create a method for setting a date for all in migration.\n-        self._dates.pop(old_path, None)\n \n     __delitem__ = remove\n \n@@ -95,16 +89,17 @@ def _rebuild_dates(self):\n         # Rebuild the _dates information.\n         # Can be used in migration to initialize the _dates.\n         now = DateTime()\n-        self._dates.clear()\n         for path in self._paths:\n-            self._dates[path] = now\n+            new_path = self._paths[path]\n+            if isinstance(new_path, tuple):\n+                continue\n+            self._paths[path] = (new_path, now)       \n \n     def destroy(self, new_path):\n         new_path = self._canonical(new_path)\n         for p in self._rpaths.get(new_path, []):\n             if p in self._paths:\n                 del self._paths[p]\n-                self._dates.pop(p, None)\n         if new_path in self._rpaths:\n             if new_path in self._rpaths:\n                 del self._rpaths[new_path]\n@@ -117,7 +112,11 @@ def has_path(self, old_path):\n \n     def get(self, old_path, default=None):\n         old_path = self._canonical(old_path)\n-        return self._paths.get(old_path, default)\n+        new_path = self._paths.get(old_path, default)\n+        if isinstance(new_path, tuple):\n+            # (new_path, date)\n+            return new_path[0]\n+        return new_path\n \n     def __getitem__(self, old_path):\n         result = self.get(old_path, default=_marker)\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 54dbd5b..1967798 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -120,7 +120,6 @@ def test_storage_clear(self):\n         # Test the internal structures directly\n         self.assertEqual(len(st._paths), 0)\n         self.assertEqual(len(st._rpaths), 0)\n-        self.assertEqual(len(st._dates), 0)\n \n     def test_storage_update_redirect(self):\n         # Update a redirect\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-12T11:15:14+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/677874ea9cd885f9bbabec5db167c8371ce7654e

Fixed code so the new date information is handled transparantly.

Using storage.get will only return the path like before, not any date information.

Files changed:
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_performance.py

b"diff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex 5bf9991..644eee0 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -41,7 +41,7 @@ def add(self, old_path, new_path, now=None):\n             return\n \n         # Forget any existing reverse paths to old_path\n-        existing_target = self._paths.get(old_path, None)\n+        existing_target = self.get(old_path)\n         if (existing_target is not None) and (\n             existing_target in self._rpaths):\n             if len(self._rpaths[existing_target]) == 1:\n@@ -49,10 +49,20 @@ def add(self, old_path, new_path, now=None):\n             else:\n                 self._rpaths[existing_target].remove(old_path)\n \n+        if now is None:\n+            now = DateTime()\n+        full_value = (new_path, now)\n+\n         # Update any references that pointed to old_path\n         for p in self.redirects(old_path):\n             if p != new_path:\n-                self._paths[p] = new_path\n+                old_full_value = self._paths[p]\n+                if isinstance(old_full_value, tuple):\n+                    # keep date\n+                    new_full_value = (new_path, old_full_value[1])\n+                else:\n+                    new_full_value = full_value\n+                self._paths[p] = new_full_value\n                 self._rpaths.setdefault(new_path, OOSet()).insert(p)\n             else:\n                 del self._paths[new_path]\n@@ -61,9 +71,7 @@ def add(self, old_path, new_path, now=None):\n         if old_path in self._rpaths:\n             del self._rpaths[old_path]\n \n-        if now is None:\n-            now = DateTime()\n-        self._paths[old_path] = (new_path, now)\n+        self._paths[old_path] = full_value\n         self._rpaths.setdefault(new_path, OOSet()).insert(old_path)\n \n     __setitem__ = add\n@@ -75,7 +83,7 @@ def update(self, info):\n \n     def remove(self, old_path):\n         old_path = self._canonical(old_path)\n-        new_path = self._paths.get(old_path, None)\n+        new_path = self.get(old_path)\n         if new_path is not None and new_path in self._rpaths:\n             if len(self._rpaths[new_path]) == 1:\n                 del self._rpaths[new_path]\n@@ -86,8 +94,8 @@ def remove(self, old_path):\n     __delitem__ = remove\n \n     def _rebuild_dates(self):\n-        # Rebuild the _dates information.\n-        # Can be used in migration to initialize the _dates.\n+        # Rebuild the dates information.\n+        # Can be used in migration to initialize the dates.\n         now = DateTime()\n         for path in self._paths:\n             new_path = self._paths[path]\ndiff --git a/plone/app/redirector/tests/test_performance.py b/plone/app/redirector/tests/test_performance.py\nindex a41bab3..2f7b83b 100644\n--- a/plone/app/redirector/tests/test_performance.py\n+++ b/plone/app/redirector/tests/test_performance.py\n@@ -139,6 +139,6 @@ def test_storage_performance(self):\n \n         # Can take long.  But 10.000 per second should be no problem.\n         with self.timeit(\n-            'Rebuilding the _dates structure for migration', NUMBER / 100000.0\n+            'Rebuilding the dates structure for migration', NUMBER / 100000.0\n         ):\n             st._rebuild_dates()\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-12T11:20:24+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/5ff9d3ab93f5f50a451711dccfcb447d18307528

Keep track of manual redirects.

Files changed:
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_performance.py

b"diff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex 644eee0..d884349 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -33,7 +33,7 @@ def clear(self):\n         self._paths = OOBTree()\n         self._rpaths = OOBTree()\n \n-    def add(self, old_path, new_path, now=None):\n+    def add(self, old_path, new_path, now=None, manual=False):\n         old_path = self._canonical(old_path)\n         new_path = self._canonical(new_path)\n \n@@ -51,20 +51,24 @@ def add(self, old_path, new_path, now=None):\n \n         if now is None:\n             now = DateTime()\n-        full_value = (new_path, now)\n+        full_value = (new_path, now, manual)\n \n         # Update any references that pointed to old_path\n         for p in self.redirects(old_path):\n             if p != new_path:\n                 old_full_value = self._paths[p]\n                 if isinstance(old_full_value, tuple):\n-                    # keep date\n-                    new_full_value = (new_path, old_full_value[1])\n+                    # keep date and manual\n+                    new_full_value = (\n+                        new_path, old_full_value[1], old_full_value[2])\n                 else:\n                     new_full_value = full_value\n                 self._paths[p] = new_full_value\n                 self._rpaths.setdefault(new_path, OOSet()).insert(p)\n             else:\n+                # There is an existing redirect from new_path to old_path.\n+                # We now want to update new_path to point to new_path.\n+                # This is not useful, so we delete it.\n                 del self._paths[new_path]\n \n         # Remove reverse paths for old_path\n@@ -76,10 +80,12 @@ def add(self, old_path, new_path, now=None):\n \n     __setitem__ = add\n \n-    def update(self, info):\n+    def update(self, info, manual=True):\n+        # Bulk update information.\n+        # Calling update will usually be done for manual additions (csv upload).\n         now = DateTime()\n         for key, value in info.items():\n-            self.add(key, value, now=now)\n+            self.add(key, value, now=now, manual=manual)\n \n     def remove(self, old_path):\n         old_path = self._canonical(old_path)\n@@ -93,15 +99,18 @@ def remove(self, old_path):\n \n     __delitem__ = remove\n \n-    def _rebuild_dates(self):\n-        # Rebuild the dates information.\n+    def _rebuild(self):\n+        # Rebuild the information.\n         # Can be used in migration to initialize the dates.\n         now = DateTime()\n         for path in self._paths:\n             new_path = self._paths[path]\n             if isinstance(new_path, tuple):\n                 continue\n-            self._paths[path] = (new_path, now)       \n+            # Store as tuple: (new_path, date, manual).\n+            # We cannot know if this was a manual redirect or not.\n+            # For safety we register this as a manual one.\n+            self._paths[path] = (new_path, now, True)\n \n     def destroy(self, new_path):\n         new_path = self._canonical(new_path)\ndiff --git a/plone/app/redirector/tests/test_performance.py b/plone/app/redirector/tests/test_performance.py\nindex 2f7b83b..d238206 100644\n--- a/plone/app/redirector/tests/test_performance.py\n+++ b/plone/app/redirector/tests/test_performance.py\n@@ -139,6 +139,6 @@ def test_storage_performance(self):\n \n         # Can take long.  But 10.000 per second should be no problem.\n         with self.timeit(\n-            'Rebuilding the dates structure for migration', NUMBER / 100000.0\n+            'Rebuilding the structure for migration', NUMBER / 100000.0\n         ):\n-            st._rebuild_dates()\n+            st._rebuild()\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-12T11:48:19+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/eea55a80760f50826fcc443971db7ce1be697bce

When rebuilding _paths, rebuild _rpaths completely fresh.

Files changed:
M plone/app/redirector/storage.py

b'diff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex d884349..fab24ce 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -100,17 +100,31 @@ def remove(self, old_path):\n     __delitem__ = remove\n \n     def _rebuild(self):\n-        # Rebuild the information.\n-        # Can be used in migration to initialize the dates.\n+        """Rebuild the information.\n+\n+        Can be used in migration to initialize the date and manual information.\n+\n+        For good measure, this also rebuild the _rpaths structure:\n+        the _paths structure is leading.  For one million paths,\n+        the _paths rebuilding takes 1 second,\n+        and the _rpaths an extra 3 seconds.  Seems fine, as this should\n+        rarely be used.\n+        """\n         now = DateTime()\n-        for path in self._paths:\n-            new_path = self._paths[path]\n-            if isinstance(new_path, tuple):\n-                continue\n-            # Store as tuple: (new_path, date, manual).\n-            # We cannot know if this was a manual redirect or not.\n-            # For safety we register this as a manual one.\n-            self._paths[path] = (new_path, now, True)\n+        self._rpaths = OOBTree()\n+        for old_path in self._paths:\n+            new_info = self._paths[old_path]\n+            if isinstance(new_info, tuple):\n+                new_path = new_info[0]\n+            else:\n+                # Store as tuple: (new_path, date, manual).\n+                # We cannot know if this was a manual redirect or not.\n+                # For safety we register this as a manual one.\n+                new_path = new_info\n+                new_info = (new_path, now, True)\n+                self._paths[old_path] = new_info\n+            self._rpaths.setdefault(new_path, OOSet()).insert(old_path)\n+\n \n     def destroy(self, new_path):\n         new_path = self._canonical(new_path)\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-12T12:26:16+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/926c3813a7065d4db7fef60eb515004768b16e6b

Added tests for storing date and manual.

Files changed:
M plone/app/redirector/tests/test_storage.py

b"diff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 1967798..f8334f8 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from DateTime import DateTime\n from plone.app.redirector.storage import RedirectionStorage\n \n import unittest\n@@ -84,6 +85,63 @@ def test_storage_trailing_slash(self):\n         with self.assertRaises(KeyError):\n             st['/baaz']\n \n+    def test_storage_date(self):\n+        # Add one redirect\n+        st = RedirectionStorage()\n+        time1 = DateTime()\n+        st.add('/foo', '/bar')\n+        time2 = DateTime()\n+        # Check the internals: we now store a date (and manual True/False).\n+        info = st._paths['/foo']\n+        self.assertIsInstance(info, tuple)\n+        self.assertTrue(time1 < info[1] < time2)\n+        # Use an explicit date.\n+        now = DateTime(2000, 12, 31)\n+        st.add('/exp', '/bar', now=now)\n+        info = st._paths['/exp']\n+        self.assertIsInstance(info, tuple)\n+        self.assertEqual(info[1], now)\n+        # Update with a different date.\n+        st.add('/exp', '/bar', now=time1)\n+        info = st._paths['/exp']\n+        self.assertIsInstance(info, tuple)\n+        self.assertEqual(info[1], time1)\n+        # Update with an implicit date.\n+        st.add('/exp', '/bar')\n+        time3 = DateTime()\n+        info = st._paths['/exp']\n+        self.assertIsInstance(info, tuple)\n+        self.assertTrue(time2 < info[1] < time3)\n+\n+    def test_storage_manual(self):\n+        # Add one redirect\n+        st = RedirectionStorage()\n+        st.add('/foo', '/bar')\n+        # Check the internals: we now store manual True/False (and a date).\n+        info = st._paths['/foo']\n+        self.assertIsInstance(info, tuple)\n+        self.assertIsInstance(info[2], bool)\n+        self.assertFalse(info[2])\n+        # Store a manual one.\n+        st.add('/exp', '/bar', manual=True)\n+        info = st._paths['/exp']\n+        self.assertIsInstance(info, tuple)\n+        self.assertIsInstance(info[2], bool)\n+        self.assertTrue(info[2])\n+        # Update to non-manual (the default).\n+        st.add('/exp', '/bar')\n+        info = st._paths['/exp']\n+        self.assertIsInstance(info, tuple)\n+        self.assertIsInstance(info[2], bool)\n+        self.assertFalse(info[2])\n+        # Make the original non-manual one manual.\n+        st.add('/foo', '/bar', manual=True)\n+        # Check the internals: we now store manual True/False (and a date).\n+        info = st._paths['/foo']\n+        self.assertIsInstance(info, tuple)\n+        self.assertIsInstance(info[2], bool)\n+        self.assertTrue(info[2])\n+\n     def test_storage_two_redirects_plain(self):\n         # Add multiple redirects.\n         st = RedirectionStorage()\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-12T12:27:25+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/647e2a7406237aa3093534b06b8304216f7eb9a4

Run black on storage and test_storage.

Files changed:
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_storage.py

b"diff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex fab24ce..7faf49d 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -42,8 +42,7 @@ def add(self, old_path, new_path, now=None, manual=False):\n \n         # Forget any existing reverse paths to old_path\n         existing_target = self.get(old_path)\n-        if (existing_target is not None) and (\n-            existing_target in self._rpaths):\n+        if (existing_target is not None) and (existing_target in self._rpaths):\n             if len(self._rpaths[existing_target]) == 1:\n                 del self._rpaths[existing_target]\n             else:\n@@ -60,7 +59,10 @@ def add(self, old_path, new_path, now=None, manual=False):\n                 if isinstance(old_full_value, tuple):\n                     # keep date and manual\n                     new_full_value = (\n-                        new_path, old_full_value[1], old_full_value[2])\n+                        new_path,\n+                        old_full_value[1],\n+                        old_full_value[2],\n+                    )\n                 else:\n                     new_full_value = full_value\n                 self._paths[p] = new_full_value\n@@ -125,7 +127,6 @@ def _rebuild(self):\n                 self._paths[old_path] = new_info\n             self._rpaths.setdefault(new_path, OOSet()).insert(old_path)\n \n-\n     def destroy(self, new_path):\n         new_path = self._canonical(new_path)\n         for p in self._rpaths.get(new_path, []):\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex f8334f8..b31725a 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -52,7 +52,9 @@ def test_storage_nested(self):\n         self.assertTrue(st.has_path('/plone/some/path'))\n         self.assertEqual(st.get('/plone/some/path'), '/plone/a/different/path')\n         self.assertFalse(st.has_path('/plone/a/different/path'))\n-        self.assertListEqual(st.redirects('/plone/a/different/path'), ['/plone/some/path'])\n+        self.assertListEqual(\n+            st.redirects('/plone/a/different/path'), ['/plone/some/path']\n+        )\n         self.assertIn('/plone/some/path', st)\n         self.assertNotIn('/plone/a/different/path', st)\n         self.assertEqual(st['/plone/some/path'], '/plone/a/different/path')\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-12T12:54:33+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/58bab0e38e2814b993c41ea3291c519c94e6ce5d

Added test for the _rebuild method.

Files changed:
M plone/app/redirector/tests/test_storage.py

b"diff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex b31725a..65db73f 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -351,3 +351,53 @@ def test_storage_non_string_path_fails(self):\n             st[0] = '/bar'\n         with self.assertRaises(AttributeError):\n             st['/foo'] = 0\n+\n+    def test_rebuild(self):\n+        # Rebuild the internal information.\n+        # This is mostly meant to be used in migration\n+        # to initialize the date and manual information.\n+        st = RedirectionStorage()\n+        # Should run fine on an empty storage.\n+        st._rebuild()\n+        # Set internals directly.\n+        st._paths['/old'] = '/new'\n+        st._paths['/older'] = '/new'\n+        st._rpaths['/unused'] = '/unknown'\n+        self.assertIsInstance(st._paths['/old'], str)\n+        self.assertEqual(st._paths['/old'], '/new')\n+        self.assertEqual(len(st._paths), 2)\n+        self.assertEqual(len(st._rpaths), 1)\n+\n+        # Rebuild\n+        time1 = DateTime()\n+        st._rebuild()\n+        time2 = DateTime()\n+        # The _paths should be tuples now\n+        self.assertEqual(len(st._paths), 2)\n+        info = st._paths['/old']\n+        self.assertIsInstance(info, tuple)\n+        # Both were pointing to /new, and that should stay the same\n+        self.assertSetEqual(set([path[0] for path in st._paths.values()]), set(['/new']))\n+        # Date should be set to the same for all.\n+        self.assertIsInstance(info[1], DateTime)\n+        new_time = info[1]\n+        self.assertTrue(time1 < new_time < time2)\n+        self.assertSetEqual(set([path[1] for path in st._paths.values()]), set([new_time]))\n+        # manual is set to True when migrating to tuples:\n+        self.assertEqual(info[2], True)\n+        # _rpaths should be filled now with only the new one.\n+        self.assertEqual(len(st._rpaths), 1)\n+        self.assertNotIn('/unused', st._rpaths)\n+        self.assertEqual(list(st._rpaths['/new']), ['/old', '/older'])\n+\n+        # Rebuild again.  Nothing fundamentally should have changed,\n+        # except that the _rpaths have been recreated.\n+        old_paths = st._paths\n+        old_rpaths = st._rpaths\n+        st._rebuild()\n+        self.assertIs(old_paths, st._paths)\n+        self.assertIsNot(old_rpaths, st._rpaths)\n+        self.assertEqual(list(old_rpaths), list(st._rpaths))\n+        self.assertSetEqual(set([path[0] for path in st._paths.values()]), set(['/new']))\n+        self.assertSetEqual(set([path[1] for path in st._paths.values()]), set([new_time]))\n+        self.assertSetEqual(set([path[2] for path in st._paths.values()]), set([True]))\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-12T13:04:31+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/d87ce02dc8bf913e3608a70f322e12d4f5ebe8cd

Added some clarifying notes in the add method.

Files changed:
M plone/app/redirector/storage.py

b'diff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex 7faf49d..1f50e75 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -43,6 +43,8 @@ def add(self, old_path, new_path, now=None, manual=False):\n         # Forget any existing reverse paths to old_path\n         existing_target = self.get(old_path)\n         if (existing_target is not None) and (existing_target in self._rpaths):\n+            # old_path was pointing to existing_target, but now we want it to\n+            # point to new_path.  So remove the existing reverse path.\n             if len(self._rpaths[existing_target]) == 1:\n                 del self._rpaths[existing_target]\n             else:\n@@ -54,6 +56,8 @@ def add(self, old_path, new_path, now=None, manual=False):\n \n         # Update any references that pointed to old_path\n         for p in self.redirects(old_path):\n+            # p points to old_path, but old_path will point to new_path,\n+            # so we update p to point to new_path directly.\n             if p != new_path:\n                 old_full_value = self._paths[p]\n                 if isinstance(old_full_value, tuple):\n@@ -73,7 +77,9 @@ def add(self, old_path, new_path, now=None, manual=False):\n                 # This is not useful, so we delete it.\n                 del self._paths[new_path]\n \n-        # Remove reverse paths for old_path\n+        # Remove reverse paths for old_path.  If old_path was being\n+        # redirected to, the above code will have updated those redirects,\n+        # so this reverse redirect info is no longer needed.\n         if old_path in self._rpaths:\n             del self._rpaths[old_path]\n \n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-12T14:10:32+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/61069b0f103954c6cfe478ff2a3a1dff90efbe49

Rebuild: look for inconsistenties and fix them.

Check for paths that are both in paths and in rpaths.

Files changed:
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_storage.py

b"diff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex 1f50e75..6e2446e 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -133,6 +133,24 @@ def _rebuild(self):\n                 self._paths[old_path] = new_info\n             self._rpaths.setdefault(new_path, OOSet()).insert(old_path)\n \n+        # Look for inconsistenties and fix them:\n+        # paths that are both in paths and in rpaths.\n+        bads = [\n+            new_path for new_path in self._rpaths if new_path in self._paths\n+        ]\n+        for new_path in bads:\n+            newer_path = self._paths[new_path][0]\n+            for old_path in self._rpaths[new_path]:\n+                # old_path points to new_path,\n+                # but new_path points to newer_path.\n+                # So update old_path to point to newer_path.\n+                info = self._paths[old_path]\n+                info = (newer_path, info[1], info[2])\n+                self._paths[old_path] = info\n+                self._rpaths[newer_path].insert(old_path)\n+            # self._rpaths[new_path] is empty now\n+            del self._rpaths[new_path]\n+\n     def destroy(self, new_path):\n         new_path = self._canonical(new_path)\n         for p in self._rpaths.get(new_path, []):\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 65db73f..82fc39f 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -362,42 +362,69 @@ def test_rebuild(self):\n         # Set internals directly.\n         st._paths['/old'] = '/new'\n         st._paths['/older'] = '/new'\n+        st._paths['/first'] = '/second'\n         st._rpaths['/unused'] = '/unknown'\n+        # Add some bad redirects, which should have been updated to point to /new.\n+        st._paths['/bad'] = '/old'\n+        st._paths['/worse'] = '/old'\n+        st._paths['/worst'] = '/worse'\n         self.assertIsInstance(st._paths['/old'], str)\n         self.assertEqual(st._paths['/old'], '/new')\n-        self.assertEqual(len(st._paths), 2)\n+        self.assertEqual(len(st._paths), 6)\n         self.assertEqual(len(st._rpaths), 1)\n \n         # Rebuild\n         time1 = DateTime()\n         st._rebuild()\n         time2 = DateTime()\n-        # The _paths should be tuples now\n-        self.assertEqual(len(st._paths), 2)\n+        # The _paths should be tuples now.\n+        self.assertEqual(\n+            sorted(list(st._paths)),\n+            ['/bad', '/first', '/old', '/older', '/worse', '/worst'],\n+        )\n         info = st._paths['/old']\n         self.assertIsInstance(info, tuple)\n-        # Both were pointing to /new, and that should stay the same\n-        self.assertSetEqual(set([path[0] for path in st._paths.values()]), set(['/new']))\n+        # The good ones were pointing to /new or /second, which should stay the same,\n+        # but the bad ones have been updated to point to new as well.\n+        self.assertSetEqual(\n+            set([path[0] for path in st._paths.values()]),\n+            set(['/new', '/second']),\n+        )\n         # Date should be set to the same for all.\n         self.assertIsInstance(info[1], DateTime)\n         new_time = info[1]\n         self.assertTrue(time1 < new_time < time2)\n-        self.assertSetEqual(set([path[1] for path in st._paths.values()]), set([new_time]))\n+        self.assertSetEqual(\n+            set([path[1] for path in st._paths.values()]), set([new_time])\n+        )\n         # manual is set to True when migrating to tuples:\n         self.assertEqual(info[2], True)\n         # _rpaths should be filled now with only the new one.\n-        self.assertEqual(len(st._rpaths), 1)\n+        self.assertEqual(len(st._rpaths), 2)\n         self.assertNotIn('/unused', st._rpaths)\n-        self.assertEqual(list(st._rpaths['/new']), ['/old', '/older'])\n+        self.assertEqual(sorted(list(st._rpaths['/second'])), ['/first'])\n+        self.assertEqual(\n+            sorted(list(st._rpaths['/new'])),\n+            ['/bad', '/old', '/older', '/worse', '/worst'],\n+        )\n \n         # Rebuild again.  Nothing fundamentally should have changed,\n-        # except that the _rpaths have been recreated.\n+        # except that _rpaths have been recreated.\n         old_paths = st._paths\n         old_rpaths = st._rpaths\n         st._rebuild()\n         self.assertIs(old_paths, st._paths)\n         self.assertIsNot(old_rpaths, st._rpaths)\n-        self.assertEqual(list(old_rpaths), list(st._rpaths))\n-        self.assertSetEqual(set([path[0] for path in st._paths.values()]), set(['/new']))\n-        self.assertSetEqual(set([path[1] for path in st._paths.values()]), set([new_time]))\n-        self.assertSetEqual(set([path[2] for path in st._paths.values()]), set([True]))\n+        self.assertListEqual(\n+            sorted(list(old_rpaths)), sorted(list(st._rpaths))\n+        )\n+        self.assertSetEqual(\n+            set([path[0] for path in st._paths.values()]),\n+            set(['/new', '/second']),\n+        )\n+        self.assertSetEqual(\n+            set([path[1] for path in st._paths.values()]), set([new_time])\n+        )\n+        self.assertSetEqual(\n+            set([path[2] for path in st._paths.values()]), set([True])\n+        )\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-13T14:46:56+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/7f18db0c6fb508fc4e7f0a3c3746130f3745e3cb

storage.update: accept tuples as values.

Files changed:
M plone/app/redirector/storage.py

b'diff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex 6e2446e..f48790b 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -93,7 +93,12 @@ def update(self, info, manual=True):\n         # Calling update will usually be done for manual additions (csv upload).\n         now = DateTime()\n         for key, value in info.items():\n-            self.add(key, value, now=now, manual=manual)\n+            if isinstance(value, tuple):\n+                # This is (new path, datetime, manual),\n+                # where datetime may be None.\n+                self.add(key, value[0], now=value[1] or now, manual=value[2])\n+            else:\n+                self.add(key, value, now=now, manual=manual)\n \n     def remove(self, old_path):\n         old_path = self._canonical(old_path)\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-13T23:37:30+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/ff72409ce78718cb0048ae4e7701a5c9d020ceb2

storage: added get_full method to return the tuple.

Or return a fresh tuple of (new path, datetime=None, manual=True) in case the data is a simple path.

Files changed:
M plone/app/redirector/storage.py

b'diff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex f48790b..dbb2d97 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -175,10 +175,18 @@ def get(self, old_path, default=None):\n         old_path = self._canonical(old_path)\n         new_path = self._paths.get(old_path, default)\n         if isinstance(new_path, tuple):\n-            # (new_path, date)\n+            # (new_path, date, manual)\n             return new_path[0]\n         return new_path\n \n+    def get_full(self, old_path, default=None):\n+        old_path = self._canonical(old_path)\n+        new_path = self._paths.get(old_path, default)\n+        if isinstance(new_path, tuple):\n+            # (new_path, date, manual)\n+            return new_path\n+        return (new_path, None, True)\n+\n     def __getitem__(self, old_path):\n         result = self.get(old_path, default=_marker)\n         if result is _marker:\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-15T09:13:07+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/d6904a98966d7655d9d1143d5777b7ada11da418

Test storage.get_full.

Files changed:
M plone/app/redirector/tests/test_storage.py

b"diff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 82fc39f..43f7ebf 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -26,6 +26,31 @@ def test_storage_one_redirect(self):\n         with self.assertRaises(KeyError):\n             st['/bar']\n \n+    def test_storage_get_full_standard(self):\n+        # get_full gets the full tuple instead of only the path\n+        st = RedirectionStorage()\n+        time1 = DateTime()\n+        st.add('/foo', '/bar', now=time1, manual=False)\n+        full = st.get_full('/foo')\n+        self.assertIsInstance(full, tuple)\n+        self.assertEqual(full, st._paths['/foo'])\n+        self.assertEqual(full[0], '/bar')\n+        self.assertEqual(full[1], time1)\n+        self.assertFalse(full[2])  # manual\n+\n+    def test_storage_get_full_fallback(self):\n+        # get_full gets the full tuple,\n+        # even if the unmigrated data only has the path\n+        st = RedirectionStorage()\n+        st._paths['/foo'] = '/bar'\n+        self.assertEqual(st._paths['/foo'], '/bar')\n+        full = st.get_full('/foo')\n+        self.assertIsInstance(full, tuple)\n+        self.assertEqual(full[0], '/bar')\n+        # Instead of a DateTime, we get None in the fallback\n+        self.assertIsNone(full[1])\n+        self.assertTrue(full[2])  # manual\n+\n     def test_storage_no_slash(self):\n         # Standard Plone will created redirects with key\n         # /plone-site-id/some/path.\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-15T09:54:11+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/7475179ddb58db926e347e38a77b92cd4b6b6bd8

Test storage.update.

Files changed:
M plone/app/redirector/tests/test_storage.py

b"diff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 43f7ebf..7000d9b 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -377,6 +377,109 @@ def test_storage_non_string_path_fails(self):\n         with self.assertRaises(AttributeError):\n             st['/foo'] = 0\n \n+    def test_storage_update_paths(self):\n+        st = RedirectionStorage()\n+        info = {}\n+        time1 = DateTime()\n+        for i in range(10):\n+            info['/old/{0}'.format(i)] = '/new/{0}'.format(i)\n+        st.update(info)\n+        time2 = DateTime()\n+        self.assertEqual(len(st), 10)\n+        self.assertEqual(st.get('/old/0'), '/new/0')\n+        self.assertEqual(st.get('/old/1'), '/new/1')\n+        self.assertTrue(time1 < st.get_full('/old/0')[1] < time2)\n+        self.assertTrue(st.get_full('/old/0')[2])\n+\n+    def test_storage_update_tuple(self):\n+        st = RedirectionStorage()\n+        info = {}\n+        for i in range(10):\n+            info['/old/{0}'.format(i)] = (\n+                '/new/{0}'.format(i),\n+                DateTime(),\n+                False,\n+            )\n+        st.update(info)\n+        self.assertEqual(st.get('/old/0'), '/new/0')\n+        self.assertEqual(st.get('/old/1'), '/new/1')\n+        self.assertEqual(st.get_full('/old/0'), info['/old/0'])\n+\n+    def test_storage_update_keeps_info(self):\n+        st = RedirectionStorage()\n+        info = {}\n+        time1 = DateTime()\n+        time2 = DateTime()\n+        info['/old/1'] = ('/new', time1, False)\n+        info['/old/2'] = ('/new', time2, True)\n+        st.update(info)\n+        self.assertEqual(len(st), 2)\n+        self.assertEqual(st.get('/old/1'), '/new')\n+        self.assertEqual(st.get('/old/2'), '/new')\n+        self.assertListEqual(\n+            sorted(st.redirects('/new')), ['/old/1', '/old/2']\n+        )\n+        self.assertEqual(st.get_full('/old/1'), info['/old/1'])\n+        self.assertEqual(st.get_full('/old/2'), info['/old/2'])\n+        # New info\n+        del info['/old/1']\n+        time3 = DateTime()\n+        info['/old/2'] = ('/new/2', time2, False)\n+        info['/old/3'] = ('/new', time3, True)\n+        st.update(info)\n+        self.assertEqual(len(st), 3)\n+        self.assertEqual(st.get('/old/1'), '/new')\n+        self.assertEqual(st.get('/old/2'), '/new/2')\n+        self.assertEqual(st.get('/old/3'), '/new')\n+        self.assertListEqual(\n+            sorted(st.redirects('/new')), ['/old/1', '/old/3']\n+        )\n+        self.assertListEqual(sorted(st.redirects('/new/2')), ['/old/2'])\n+        self.assertEqual(st.get_full('/old/2'), info['/old/2'])\n+        self.assertEqual(st.get_full('/old/3'), info['/old/3'])\n+\n+    def test_storage_update_mixed(self):\n+        st = RedirectionStorage()\n+        info = {}\n+        time1 = DateTime()\n+        for i in range(10):\n+            info['/old/{0}'.format(i)] = '/new/{0}'.format(i)\n+        for i in range(10, 20):\n+            info['/old/{0}'.format(i)] = (\n+                '/new/{0}'.format(i),\n+                DateTime(),\n+                False,\n+            )\n+        for i in range(20, 30):\n+            info['/old/{0}'.format(i)] = ('/new/{0}'.format(i), None, True)\n+        st.update(info)\n+        time2 = DateTime()\n+        self.assertEqual(len(st), 30)\n+        self.assertEqual(st.get('/old/0'), '/new/0')\n+        self.assertEqual(st.get('/old/1'), '/new/1')\n+        self.assertTrue(time1 < st.get_full('/old/0')[1] < time2)\n+        self.assertTrue(st.get_full('/old/0')[2])\n+        self.assertEqual(st.get('/old/10'), '/new/10')\n+        self.assertEqual(st.get('/old/11'), '/new/11')\n+        self.assertEqual(st.get_full('/old/10'), info['/old/10'])\n+        self.assertEqual(st.get('/old/20'), '/new/20')\n+        self.assertEqual(st.get('/old/21'), '/new/21')\n+        self.assertTrue(time1 < st.get_full('/old/20')[1] < time2)\n+        self.assertTrue(st.get_full('/old/20')[2])\n+        # Update again with the same info.\n+        # This may set new dates.\n+        st.update(info)\n+        time3 = DateTime()\n+        self.assertEqual(len(st), 30)\n+        self.assertEqual(st.get('/old/0'), '/new/0')\n+        self.assertTrue(time2 < st.get_full('/old/0')[1] < time3)\n+        self.assertTrue(st.get_full('/old/0')[2])\n+        self.assertEqual(st.get('/old/10'), '/new/10')\n+        self.assertEqual(st.get_full('/old/10'), info['/old/10'])\n+        self.assertEqual(st.get('/old/20'), '/new/20')\n+        self.assertTrue(time2 < st.get_full('/old/20')[1] < time3)\n+        self.assertTrue(st.get_full('/old/20')[2])\n+\n     def test_rebuild(self):\n         # Rebuild the internal information.\n         # This is mostly meant to be used in migration\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-03-15T15:47:44+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/b4ff8deffb891215151f030b19ff49062f9be577

Added news snippets for 17 and 18.

See also https://github.com/plone/Products.CMFPlone/issues/2799

Files changed:
A news/18.feature
M news/17.feature

b'diff --git a/news/17.feature b/news/17.feature\nindex 20f7c4b..1691e05 100644\n--- a/news/17.feature\n+++ b/news/17.feature\n@@ -1,3 +1,3 @@\n-Store date information in new _dates structure.\n+Store date information in the paths.\n Can be used as basis for removing for example all redirects that are older than a year.\n [maurits]\ndiff --git a/news/18.feature b/news/18.feature\nnew file mode 100644\nindex 0000000..d9886fa\n--- /dev/null\n+++ b/news/18.feature\n@@ -0,0 +1,2 @@\n+Keep track if a redirect was added manually or automatically.\n+[maurits]\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-04-11T11:04:58+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.redirector/commit/86707ce350512b302628056967d01659e919c2e7

Merge pull request #19 from plone/maurits-extend-paths

Implement features: store date and manual

Files changed:
A news/17.feature
A news/18.feature
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_performance.py
M plone/app/redirector/tests/test_storage.py

b'diff --git a/news/17.feature b/news/17.feature\nnew file mode 100644\nindex 0000000..1691e05\n--- /dev/null\n+++ b/news/17.feature\n@@ -0,0 +1,3 @@\n+Store date information in the paths.\n+Can be used as basis for removing for example all redirects that are older than a year.\n+[maurits]\ndiff --git a/news/18.feature b/news/18.feature\nnew file mode 100644\nindex 0000000..d9886fa\n--- /dev/null\n+++ b/news/18.feature\n@@ -0,0 +1,2 @@\n+Keep track if a redirect was added manually or automatically.\n+[maurits]\ndiff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex 91c12c3..dbb2d97 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -3,7 +3,7 @@\n \n from persistent import Persistent\n from BTrees.OOBTree import OOBTree, OOSet\n-\n+from DateTime import DateTime\n from plone.app.redirector.interfaces import IRedirectionStorage\n \n \n@@ -33,7 +33,7 @@ def clear(self):\n         self._paths = OOBTree()\n         self._rpaths = OOBTree()\n \n-    def add(self, old_path, new_path):\n+    def add(self, old_path, new_path, now=None, manual=False):\n         old_path = self._canonical(old_path)\n         new_path = self._canonical(new_path)\n \n@@ -41,38 +41,68 @@ def add(self, old_path, new_path):\n             return\n \n         # Forget any existing reverse paths to old_path\n-        existing_target = self._paths.get(old_path, None)\n-        if (existing_target is not None) and (\n-            existing_target in self._rpaths):\n+        existing_target = self.get(old_path)\n+        if (existing_target is not None) and (existing_target in self._rpaths):\n+            # old_path was pointing to existing_target, but now we want it to\n+            # point to new_path.  So remove the existing reverse path.\n             if len(self._rpaths[existing_target]) == 1:\n                 del self._rpaths[existing_target]\n             else:\n                 self._rpaths[existing_target].remove(old_path)\n \n+        if now is None:\n+            now = DateTime()\n+        full_value = (new_path, now, manual)\n+\n         # Update any references that pointed to old_path\n         for p in self.redirects(old_path):\n+            # p points to old_path, but old_path will point to new_path,\n+            # so we update p to point to new_path directly.\n             if p != new_path:\n-                self._paths[p] = new_path\n+                old_full_value = self._paths[p]\n+                if isinstance(old_full_value, tuple):\n+                    # keep date and manual\n+                    new_full_value = (\n+                        new_path,\n+                        old_full_value[1],\n+                        old_full_value[2],\n+                    )\n+                else:\n+                    new_full_value = full_value\n+                self._paths[p] = new_full_value\n                 self._rpaths.setdefault(new_path, OOSet()).insert(p)\n             else:\n+                # There is an existing redirect from new_path to old_path.\n+                # We now want to update new_path to point to new_path.\n+                # This is not useful, so we delete it.\n                 del self._paths[new_path]\n \n-        # Remove reverse paths for old_path\n+        # Remove reverse paths for old_path.  If old_path was being\n+        # redirected to, the above code will have updated those redirects,\n+        # so this reverse redirect info is no longer needed.\n         if old_path in self._rpaths:\n             del self._rpaths[old_path]\n \n-        self._paths[old_path] = new_path\n+        self._paths[old_path] = full_value\n         self._rpaths.setdefault(new_path, OOSet()).insert(old_path)\n \n     __setitem__ = add\n \n-    def update(self, info):\n+    def update(self, info, manual=True):\n+        # Bulk update information.\n+        # Calling update will usually be done for manual additions (csv upload).\n+        now = DateTime()\n         for key, value in info.items():\n-            self.add(key, value)\n+            if isinstance(value, tuple):\n+                # This is (new path, datetime, manual),\n+                # where datetime may be None.\n+                self.add(key, value[0], now=value[1] or now, manual=value[2])\n+            else:\n+                self.add(key, value, now=now, manual=manual)\n \n     def remove(self, old_path):\n         old_path = self._canonical(old_path)\n-        new_path = self._paths.get(old_path, None)\n+        new_path = self.get(old_path)\n         if new_path is not None and new_path in self._rpaths:\n             if len(self._rpaths[new_path]) == 1:\n                 del self._rpaths[new_path]\n@@ -82,6 +112,50 @@ def remove(self, old_path):\n \n     __delitem__ = remove\n \n+    def _rebuild(self):\n+        """Rebuild the information.\n+\n+        Can be used in migration to initialize the date and manual information.\n+\n+        For good measure, this also rebuild the _rpaths structure:\n+        the _paths structure is leading.  For one million paths,\n+        the _paths rebuilding takes 1 second,\n+        and the _rpaths an extra 3 seconds.  Seems fine, as this should\n+        rarely be used.\n+        """\n+        now = DateTime()\n+        self._rpaths = OOBTree()\n+        for old_path in self._paths:\n+            new_info = self._paths[old_path]\n+            if isinstance(new_info, tuple):\n+                new_path = new_info[0]\n+            else:\n+                # Store as tuple: (new_path, date, manual).\n+                # We cannot know if this was a manual redirect or not.\n+                # For safety we register this as a manual one.\n+                new_path = new_info\n+                new_info = (new_path, now, True)\n+                self._paths[old_path] = new_info\n+            self._rpaths.setdefault(new_path, OOSet()).insert(old_path)\n+\n+        # Look for inconsistenties and fix them:\n+        # paths that are both in paths and in rpaths.\n+        bads = [\n+            new_path for new_path in self._rpaths if new_path in self._paths\n+        ]\n+        for new_path in bads:\n+            newer_path = self._paths[new_path][0]\n+            for old_path in self._rpaths[new_path]:\n+                # old_path points to new_path,\n+                # but new_path points to newer_path.\n+                # So update old_path to point to newer_path.\n+                info = self._paths[old_path]\n+                info = (newer_path, info[1], info[2])\n+                self._paths[old_path] = info\n+                self._rpaths[newer_path].insert(old_path)\n+            # self._rpaths[new_path] is empty now\n+            del self._rpaths[new_path]\n+\n     def destroy(self, new_path):\n         new_path = self._canonical(new_path)\n         for p in self._rpaths.get(new_path, []):\n@@ -99,7 +173,19 @@ def has_path(self, old_path):\n \n     def get(self, old_path, default=None):\n         old_path = self._canonical(old_path)\n-        return self._paths.get(old_path, default)\n+        new_path = self._paths.get(old_path, default)\n+        if isinstance(new_path, tuple):\n+            # (new_path, date, manual)\n+            return new_path[0]\n+        return new_path\n+\n+    def get_full(self, old_path, default=None):\n+        old_path = self._canonical(old_path)\n+        new_path = self._paths.get(old_path, default)\n+        if isinstance(new_path, tuple):\n+            # (new_path, date, manual)\n+            return new_path\n+        return (new_path, None, True)\n \n     def __getitem__(self, old_path):\n         result = self.get(old_path, default=_marker)\ndiff --git a/plone/app/redirector/tests/test_performance.py b/plone/app/redirector/tests/test_performance.py\nindex c8821db..d238206 100644\n--- a/plone/app/redirector/tests/test_performance.py\n+++ b/plone/app/redirector/tests/test_performance.py\n@@ -136,3 +136,9 @@ def test_storage_performance(self):\n         ):\n             for key in st:\n                 st[key]\n+\n+        # Can take long.  But 10.000 per second should be no problem.\n+        with self.timeit(\n+            \'Rebuilding the structure for migration\', NUMBER / 100000.0\n+        ):\n+            st._rebuild()\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 1967798..7000d9b 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from DateTime import DateTime\n from plone.app.redirector.storage import RedirectionStorage\n \n import unittest\n@@ -25,6 +26,31 @@ def test_storage_one_redirect(self):\n         with self.assertRaises(KeyError):\n             st[\'/bar\']\n \n+    def test_storage_get_full_standard(self):\n+        # get_full gets the full tuple instead of only the path\n+        st = RedirectionStorage()\n+        time1 = DateTime()\n+        st.add(\'/foo\', \'/bar\', now=time1, manual=False)\n+        full = st.get_full(\'/foo\')\n+        self.assertIsInstance(full, tuple)\n+        self.assertEqual(full, st._paths[\'/foo\'])\n+        self.assertEqual(full[0], \'/bar\')\n+        self.assertEqual(full[1], time1)\n+        self.assertFalse(full[2])  # manual\n+\n+    def test_storage_get_full_fallback(self):\n+        # get_full gets the full tuple,\n+        # even if the unmigrated data only has the path\n+        st = RedirectionStorage()\n+        st._paths[\'/foo\'] = \'/bar\'\n+        self.assertEqual(st._paths[\'/foo\'], \'/bar\')\n+        full = st.get_full(\'/foo\')\n+        self.assertIsInstance(full, tuple)\n+        self.assertEqual(full[0], \'/bar\')\n+        # Instead of a DateTime, we get None in the fallback\n+        self.assertIsNone(full[1])\n+        self.assertTrue(full[2])  # manual\n+\n     def test_storage_no_slash(self):\n         # Standard Plone will created redirects with key\n         # /plone-site-id/some/path.\n@@ -51,7 +77,9 @@ def test_storage_nested(self):\n         self.assertTrue(st.has_path(\'/plone/some/path\'))\n         self.assertEqual(st.get(\'/plone/some/path\'), \'/plone/a/different/path\')\n         self.assertFalse(st.has_path(\'/plone/a/different/path\'))\n-        self.assertListEqual(st.redirects(\'/plone/a/different/path\'), [\'/plone/some/path\'])\n+        self.assertListEqual(\n+            st.redirects(\'/plone/a/different/path\'), [\'/plone/some/path\']\n+        )\n         self.assertIn(\'/plone/some/path\', st)\n         self.assertNotIn(\'/plone/a/different/path\', st)\n         self.assertEqual(st[\'/plone/some/path\'], \'/plone/a/different/path\')\n@@ -84,6 +112,63 @@ def test_storage_trailing_slash(self):\n         with self.assertRaises(KeyError):\n             st[\'/baaz\']\n \n+    def test_storage_date(self):\n+        # Add one redirect\n+        st = RedirectionStorage()\n+        time1 = DateTime()\n+        st.add(\'/foo\', \'/bar\')\n+        time2 = DateTime()\n+        # Check the internals: we now store a date (and manual True/False).\n+        info = st._paths[\'/foo\']\n+        self.assertIsInstance(info, tuple)\n+        self.assertTrue(time1 < info[1] < time2)\n+        # Use an explicit date.\n+        now = DateTime(2000, 12, 31)\n+        st.add(\'/exp\', \'/bar\', now=now)\n+        info = st._paths[\'/exp\']\n+        self.assertIsInstance(info, tuple)\n+        self.assertEqual(info[1], now)\n+        # Update with a different date.\n+        st.add(\'/exp\', \'/bar\', now=time1)\n+        info = st._paths[\'/exp\']\n+        self.assertIsInstance(info, tuple)\n+        self.assertEqual(info[1], time1)\n+        # Update with an implicit date.\n+        st.add(\'/exp\', \'/bar\')\n+        time3 = DateTime()\n+        info = st._paths[\'/exp\']\n+        self.assertIsInstance(info, tuple)\n+        self.assertTrue(time2 < info[1] < time3)\n+\n+    def test_storage_manual(self):\n+        # Add one redirect\n+        st = RedirectionStorage()\n+        st.add(\'/foo\', \'/bar\')\n+        # Check the internals: we now store manual True/False (and a date).\n+        info = st._paths[\'/foo\']\n+        self.assertIsInstance(info, tuple)\n+        self.assertIsInstance(info[2], bool)\n+        self.assertFalse(info[2])\n+        # Store a manual one.\n+        st.add(\'/exp\', \'/bar\', manual=True)\n+        info = st._paths[\'/exp\']\n+        self.assertIsInstance(info, tuple)\n+        self.assertIsInstance(info[2], bool)\n+        self.assertTrue(info[2])\n+        # Update to non-manual (the default).\n+        st.add(\'/exp\', \'/bar\')\n+        info = st._paths[\'/exp\']\n+        self.assertIsInstance(info, tuple)\n+        self.assertIsInstance(info[2], bool)\n+        self.assertFalse(info[2])\n+        # Make the original non-manual one manual.\n+        st.add(\'/foo\', \'/bar\', manual=True)\n+        # Check the internals: we now store manual True/False (and a date).\n+        info = st._paths[\'/foo\']\n+        self.assertIsInstance(info, tuple)\n+        self.assertIsInstance(info[2], bool)\n+        self.assertTrue(info[2])\n+\n     def test_storage_two_redirects_plain(self):\n         # Add multiple redirects.\n         st = RedirectionStorage()\n@@ -291,3 +376,183 @@ def test_storage_non_string_path_fails(self):\n             st[0] = \'/bar\'\n         with self.assertRaises(AttributeError):\n             st[\'/foo\'] = 0\n+\n+    def test_storage_update_paths(self):\n+        st = RedirectionStorage()\n+        info = {}\n+        time1 = DateTime()\n+        for i in range(10):\n+            info[\'/old/{0}\'.format(i)] = \'/new/{0}\'.format(i)\n+        st.update(info)\n+        time2 = DateTime()\n+        self.assertEqual(len(st), 10)\n+        self.assertEqual(st.get(\'/old/0\'), \'/new/0\')\n+        self.assertEqual(st.get(\'/old/1\'), \'/new/1\')\n+        self.assertTrue(time1 < st.get_full(\'/old/0\')[1] < time2)\n+        self.assertTrue(st.get_full(\'/old/0\')[2])\n+\n+    def test_storage_update_tuple(self):\n+        st = RedirectionStorage()\n+        info = {}\n+        for i in range(10):\n+            info[\'/old/{0}\'.format(i)] = (\n+                \'/new/{0}\'.format(i),\n+                DateTime(),\n+                False,\n+            )\n+        st.update(info)\n+        self.assertEqual(st.get(\'/old/0\'), \'/new/0\')\n+        self.assertEqual(st.get(\'/old/1\'), \'/new/1\')\n+        self.assertEqual(st.get_full(\'/old/0\'), info[\'/old/0\'])\n+\n+    def test_storage_update_keeps_info(self):\n+        st = RedirectionStorage()\n+        info = {}\n+        time1 = DateTime()\n+        time2 = DateTime()\n+        info[\'/old/1\'] = (\'/new\', time1, False)\n+        info[\'/old/2\'] = (\'/new\', time2, True)\n+        st.update(info)\n+        self.assertEqual(len(st), 2)\n+        self.assertEqual(st.get(\'/old/1\'), \'/new\')\n+        self.assertEqual(st.get(\'/old/2\'), \'/new\')\n+        self.assertListEqual(\n+            sorted(st.redirects(\'/new\')), [\'/old/1\', \'/old/2\']\n+        )\n+        self.assertEqual(st.get_full(\'/old/1\'), info[\'/old/1\'])\n+        self.assertEqual(st.get_full(\'/old/2\'), info[\'/old/2\'])\n+        # New info\n+        del info[\'/old/1\']\n+        time3 = DateTime()\n+        info[\'/old/2\'] = (\'/new/2\', time2, False)\n+        info[\'/old/3\'] = (\'/new\', time3, True)\n+        st.update(info)\n+        self.assertEqual(len(st), 3)\n+        self.assertEqual(st.get(\'/old/1\'), \'/new\')\n+        self.assertEqual(st.get(\'/old/2\'), \'/new/2\')\n+        self.assertEqual(st.get(\'/old/3\'), \'/new\')\n+        self.assertListEqual(\n+            sorted(st.redirects(\'/new\')), [\'/old/1\', \'/old/3\']\n+        )\n+        self.assertListEqual(sorted(st.redirects(\'/new/2\')), [\'/old/2\'])\n+        self.assertEqual(st.get_full(\'/old/2\'), info[\'/old/2\'])\n+        self.assertEqual(st.get_full(\'/old/3\'), info[\'/old/3\'])\n+\n+    def test_storage_update_mixed(self):\n+        st = RedirectionStorage()\n+        info = {}\n+        time1 = DateTime()\n+        for i in range(10):\n+            info[\'/old/{0}\'.format(i)] = \'/new/{0}\'.format(i)\n+        for i in range(10, 20):\n+            info[\'/old/{0}\'.format(i)] = (\n+                \'/new/{0}\'.format(i),\n+                DateTime(),\n+                False,\n+            )\n+        for i in range(20, 30):\n+            info[\'/old/{0}\'.format(i)] = (\'/new/{0}\'.format(i), None, True)\n+        st.update(info)\n+        time2 = DateTime()\n+        self.assertEqual(len(st), 30)\n+        self.assertEqual(st.get(\'/old/0\'), \'/new/0\')\n+        self.assertEqual(st.get(\'/old/1\'), \'/new/1\')\n+        self.assertTrue(time1 < st.get_full(\'/old/0\')[1] < time2)\n+        self.assertTrue(st.get_full(\'/old/0\')[2])\n+        self.assertEqual(st.get(\'/old/10\'), \'/new/10\')\n+        self.assertEqual(st.get(\'/old/11\'), \'/new/11\')\n+        self.assertEqual(st.get_full(\'/old/10\'), info[\'/old/10\'])\n+        self.assertEqual(st.get(\'/old/20\'), \'/new/20\')\n+        self.assertEqual(st.get(\'/old/21\'), \'/new/21\')\n+        self.assertTrue(time1 < st.get_full(\'/old/20\')[1] < time2)\n+        self.assertTrue(st.get_full(\'/old/20\')[2])\n+        # Update again with the same info.\n+        # This may set new dates.\n+        st.update(info)\n+        time3 = DateTime()\n+        self.assertEqual(len(st), 30)\n+        self.assertEqual(st.get(\'/old/0\'), \'/new/0\')\n+        self.assertTrue(time2 < st.get_full(\'/old/0\')[1] < time3)\n+        self.assertTrue(st.get_full(\'/old/0\')[2])\n+        self.assertEqual(st.get(\'/old/10\'), \'/new/10\')\n+        self.assertEqual(st.get_full(\'/old/10\'), info[\'/old/10\'])\n+        self.assertEqual(st.get(\'/old/20\'), \'/new/20\')\n+        self.assertTrue(time2 < st.get_full(\'/old/20\')[1] < time3)\n+        self.assertTrue(st.get_full(\'/old/20\')[2])\n+\n+    def test_rebuild(self):\n+        # Rebuild the internal information.\n+        # This is mostly meant to be used in migration\n+        # to initialize the date and manual information.\n+        st = RedirectionStorage()\n+        # Should run fine on an empty storage.\n+        st._rebuild()\n+        # Set internals directly.\n+        st._paths[\'/old\'] = \'/new\'\n+        st._paths[\'/older\'] = \'/new\'\n+        st._paths[\'/first\'] = \'/second\'\n+        st._rpaths[\'/unused\'] = \'/unknown\'\n+        # Add some bad redirects, which should have been updated to point to /new.\n+        st._paths[\'/bad\'] = \'/old\'\n+        st._paths[\'/worse\'] = \'/old\'\n+        st._paths[\'/worst\'] = \'/worse\'\n+        self.assertIsInstance(st._paths[\'/old\'], str)\n+        self.assertEqual(st._paths[\'/old\'], \'/new\')\n+        self.assertEqual(len(st._paths), 6)\n+        self.assertEqual(len(st._rpaths), 1)\n+\n+        # Rebuild\n+        time1 = DateTime()\n+        st._rebuild()\n+        time2 = DateTime()\n+        # The _paths should be tuples now.\n+        self.assertEqual(\n+            sorted(list(st._paths)),\n+            [\'/bad\', \'/first\', \'/old\', \'/older\', \'/worse\', \'/worst\'],\n+        )\n+        info = st._paths[\'/old\']\n+        self.assertIsInstance(info, tuple)\n+        # The good ones were pointing to /new or /second, which should stay the same,\n+        # but the bad ones have been updated to point to new as well.\n+        self.assertSetEqual(\n+            set([path[0] for path in st._paths.values()]),\n+            set([\'/new\', \'/second\']),\n+        )\n+        # Date should be set to the same for all.\n+        self.assertIsInstance(info[1], DateTime)\n+        new_time = info[1]\n+        self.assertTrue(time1 < new_time < time2)\n+        self.assertSetEqual(\n+            set([path[1] for path in st._paths.values()]), set([new_time])\n+        )\n+        # manual is set to True when migrating to tuples:\n+        self.assertEqual(info[2], True)\n+        # _rpaths should be filled now with only the new one.\n+        self.assertEqual(len(st._rpaths), 2)\n+        self.assertNotIn(\'/unused\', st._rpaths)\n+        self.assertEqual(sorted(list(st._rpaths[\'/second\'])), [\'/first\'])\n+        self.assertEqual(\n+            sorted(list(st._rpaths[\'/new\'])),\n+            [\'/bad\', \'/old\', \'/older\', \'/worse\', \'/worst\'],\n+        )\n+\n+        # Rebuild again.  Nothing fundamentally should have changed,\n+        # except that _rpaths have been recreated.\n+        old_paths = st._paths\n+        old_rpaths = st._rpaths\n+        st._rebuild()\n+        self.assertIs(old_paths, st._paths)\n+        self.assertIsNot(old_rpaths, st._rpaths)\n+        self.assertListEqual(\n+            sorted(list(old_rpaths)), sorted(list(st._rpaths))\n+        )\n+        self.assertSetEqual(\n+            set([path[0] for path in st._paths.values()]),\n+            set([\'/new\', \'/second\']),\n+        )\n+        self.assertSetEqual(\n+            set([path[1] for path in st._paths.values()]), set([new_time])\n+        )\n+        self.assertSetEqual(\n+            set([path[2] for path in st._paths.values()]), set([True])\n+        )\n'

