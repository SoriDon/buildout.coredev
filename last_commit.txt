Repository: plone.restapi


Branch: refs/heads/master
Date: 2019-03-06T11:31:36+01:00
Author: Thomas Buchberger (buchi) <t.buchberger@4teamwork.ch>
Commit: https://github.com/plone/plone.restapi/commit/2f520919d446f7e6c211efb139d905dd1827773c

Fix TUS upload events

- When a file is created with TUS upload, fire created et al. events.
- When a file is replaced with TUS upload, fire modified event.
- Acquisition wrap newly created objects during deserialization.

Files changed:
A news/689.bugfix
M src/plone/restapi/services/content/tus.py
M src/plone/restapi/tests/test_tus.py

b"diff --git a/news/689.bugfix b/news/689.bugfix\nnew file mode 100644\nindex 00000000..691a32d6\n--- /dev/null\n+++ b/news/689.bugfix\n@@ -0,0 +1,3 @@\n+Fix TUS upload events `#689 <https://github.com/plone/plone.restapi/issues/689>`_.\n+[buchi]\n+\ndiff --git a/src/plone/restapi/services/content/tus.py b/src/plone/restapi/services/content/tus.py\nindex 5bf9d612..cc600aa5 100644\n--- a/src/plone/restapi/services/content/tus.py\n+++ b/src/plone/restapi/services/content/tus.py\n@@ -1,7 +1,10 @@\n # -*- coding: utf-8 -*-\n+from Acquisition import aq_base\n+from Acquisition.interfaces import IAcquirer\n from AccessControl.SecurityManagement import getSecurityManager\n from Products.CMFCore.utils import getToolByName\n from Products.CMFPlone.utils import base_hasattr\n+from Products.CMFPlone.utils import safe_hasattr\n from base64 import b64decode\n from email.utils import formatdate\n from fnmatch import fnmatch\n@@ -248,6 +251,12 @@ def reply(self):\n             if not fieldname:\n                 return self.error('Bad Request', 'Fieldname required', 400)\n \n+            # Acquisition wrap temporarily for deserialization\n+            temporarily_wrapped = False\n+            if IAcquirer.providedBy(obj) and not safe_hasattr(obj, 'aq_base'):\n+                obj = obj.__of__(self.context)\n+                temporarily_wrapped = True\n+\n             # Update field with file data\n             deserializer = queryMultiAdapter(\n                 (obj, self.request), IDeserializeFromJson)\n@@ -258,11 +267,15 @@ def reply(self):\n                         obj.portal_type),\n                     501)\n             try:\n-                deserializer(data={fieldname: tus_upload})\n+                deserializer(\n+                    data={fieldname: tus_upload}, create=mode == 'create')\n             except DeserializationError as e:\n                 return self.error(\n                     'Deserialization Error', str(e), 400)\n \n+            if temporarily_wrapped:\n+                obj = aq_base(obj)\n+\n             if mode == 'create':\n                 if not getattr(deserializer, 'notifies_create', False):\n                     notify(ObjectCreatedEvent(obj))\ndiff --git a/src/plone/restapi/tests/test_tus.py b/src/plone/restapi/tests/test_tus.py\nindex e7ec7858..8a2eb839 100644\n--- a/src/plone/restapi/tests/test_tus.py\n+++ b/src/plone/restapi/tests/test_tus.py\n@@ -1,25 +1,29 @@\n # -*- coding: utf-8 -*-\n-from DateTime import DateTime\n-from six import BytesIO\n from base64 import b64encode\n+from DateTime import DateTime\n+from OFS.interfaces import IObjectWillBeAddedEvent\n from plone import api\n+from plone.app.testing import login\n+from plone.app.testing import setRoles\n from plone.app.testing import SITE_OWNER_NAME\n from plone.app.testing import SITE_OWNER_PASSWORD\n from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n from plone.app.testing import TEST_USER_PASSWORD\n-from plone.app.testing import login\n-from plone.app.testing import setRoles\n from plone.rest.cors import CORSPolicy\n from plone.rest.interfaces import ICORSPolicy\n-from plone.restapi.services.content.tus import TUSUpload\n from plone.restapi import HAS_AT\n+from plone.restapi.services.content.tus import TUSUpload\n from plone.restapi.testing import PLONE_RESTAPI_AT_FUNCTIONAL_TESTING\n from plone.restapi.testing import PLONE_RESTAPI_DX_FUNCTIONAL_TESTING\n from plone.restapi.testing import RelativeSession\n+from six import BytesIO\n from zope.component import getGlobalSiteManager\n from zope.component import provideAdapter\n from zope.interface import Interface\n+from zope.lifecycleevent.interfaces import IObjectAddedEvent\n+from zope.lifecycleevent.interfaces import IObjectCreatedEvent\n+from zope.lifecycleevent.interfaces import IObjectModifiedEvent\n from zope.publisher.interfaces.browser import IBrowserRequest\n \n import os\n@@ -399,6 +403,114 @@ def test_tus_can_replace_pdf_file(self):\n         self.assertEqual(UPLOAD_PDF_FILENAME, self.file.file.filename)\n         self.assertEqual(pdf_file_size, self.file.file.size)\n \n+    def test_create_with_tus_fires_proper_events(self):\n+        sm = getGlobalSiteManager()\n+        fired_events = []\n+\n+        def record_event(event):\n+            fired_events.append(event.__class__.__name__)\n+\n+        sm.registerHandler(record_event, (IObjectCreatedEvent,))\n+        sm.registerHandler(record_event, (IObjectWillBeAddedEvent,))\n+        sm.registerHandler(record_event, (IObjectAddedEvent,))\n+        sm.registerHandler(record_event, (IObjectModifiedEvent,))\n+\n+        # initialize the upload with POST\n+        pdf_file_path = os.path.join(os.path.dirname(__file__),\n+                                     UPLOAD_PDF_FILENAME)\n+        pdf_file_size = os.path.getsize(pdf_file_path)\n+        metadata = _prepare_metadata(UPLOAD_PDF_FILENAME, UPLOAD_PDF_MIMETYPE)\n+        response = self.api_session.post(\n+            self.upload_url,\n+            headers={'Tus-Resumable': '1.0.0',\n+                     'Upload-Length': str(pdf_file_size),\n+                     'Upload-Metadata': metadata}\n+        )\n+        self.assertEqual(response.status_code, 201)\n+        location = response.headers['Location']\n+\n+        # upload the data with PATCH\n+        with open(pdf_file_path, 'rb') as pdf_file:\n+            response = self.api_session.patch(\n+                location,\n+                headers={\n+                    'Content-Type': 'application/offset+octet-stream',\n+                    'Upload-Offset': '0',\n+                    'Tus-Resumable': '1.0.0'\n+                },\n+                data=pdf_file)\n+        self.assertEqual(response.status_code, 204)\n+\n+        self.assertEqual(\n+            fired_events,\n+            [\n+                'ObjectCreatedEvent',\n+                'ObjectWillBeAddedEvent',\n+                'ObjectAddedEvent',\n+                'ContainerModifiedEvent',\n+            ])\n+\n+        sm.unregisterHandler(record_event, (IObjectCreatedEvent,))\n+        sm.unregisterHandler(record_event, (IObjectWillBeAddedEvent,))\n+        sm.unregisterHandler(record_event, (IObjectAddedEvent,))\n+        sm.unregisterHandler(record_event, (IObjectModifiedEvent,))\n+\n+    def test_replace_with_tus_fires_proper_events(self):\n+        # Create a test file\n+        self.file = api.content.create(container=self.portal,\n+                                       type='File',\n+                                       id='testfile',\n+                                       title='Testfile')\n+        transaction.commit()\n+\n+        sm = getGlobalSiteManager()\n+        fired_events = []\n+\n+        def record_event(event):\n+            fired_events.append(event.__class__.__name__)\n+\n+        sm.registerHandler(record_event, (IObjectCreatedEvent,))\n+        sm.registerHandler(record_event, (IObjectWillBeAddedEvent,))\n+        sm.registerHandler(record_event, (IObjectAddedEvent,))\n+        sm.registerHandler(record_event, (IObjectModifiedEvent,))\n+\n+        # initialize the upload with POST\n+        pdf_file_path = os.path.join(os.path.dirname(__file__),\n+                                     UPLOAD_PDF_FILENAME)\n+        pdf_file_size = os.path.getsize(pdf_file_path)\n+        metadata = _prepare_metadata(UPLOAD_PDF_FILENAME, UPLOAD_PDF_MIMETYPE)\n+        response = self.api_session.post(\n+            '{}/@tus-replace'.format(self.file.absolute_url()),\n+            headers={'Tus-Resumable': '1.0.0',\n+                     'Upload-Length': str(pdf_file_size),\n+                     'Upload-Metadata': metadata}\n+        )\n+        self.assertEqual(response.status_code, 201)\n+        location = response.headers['Location']\n+\n+        # upload the data with PATCH\n+        with open(pdf_file_path, 'rb') as pdf_file:\n+            response = self.api_session.patch(\n+                location,\n+                headers={\n+                    'Content-Type': 'application/offset+octet-stream',\n+                    'Upload-Offset': '0',\n+                    'Tus-Resumable': '1.0.0'\n+                },\n+                data=pdf_file)\n+        self.assertEqual(response.status_code, 204)\n+\n+        self.assertEqual(\n+            fired_events,\n+            [\n+                'ObjectModifiedEvent',\n+            ])\n+\n+        sm.unregisterHandler(record_event, (IObjectCreatedEvent,))\n+        sm.unregisterHandler(record_event, (IObjectWillBeAddedEvent,))\n+        sm.unregisterHandler(record_event, (IObjectAddedEvent,))\n+        sm.unregisterHandler(record_event, (IObjectModifiedEvent,))\n+\n     def tearDown(self):\n         self.api_session.close()\n         client_home = os.environ.get('CLIENT_HOME')\n"

Repository: plone.restapi


Branch: refs/heads/master
Date: 2019-03-06T11:31:36+01:00
Author: Thomas Buchberger (buchi) <t.buchberger@4teamwork.ch>
Commit: https://github.com/plone/plone.restapi/commit/bc28977700206fe5f9db604f34226757bfdde359

Refactor TUS upload to satisfy max complexity

Files changed:
M src/plone/restapi/services/content/tus.py

b"diff --git a/src/plone/restapi/services/content/tus.py b/src/plone/restapi/services/content/tus.py\nindex cc600aa5..524e7c57 100644\n--- a/src/plone/restapi/services/content/tus.py\n+++ b/src/plone/restapi/services/content/tus.py\n@@ -220,72 +220,11 @@ def reply(self):\n         if hasattr(request_body, 'raw'):  # Unwrap io.BufferedRandom\n             request_body = request_body.raw\n         tus_upload.write(request_body, offset)\n+        offset = tus_upload.offset()\n \n         if tus_upload.finished:\n-            offset = tus_upload.offset()\n-            filename = metadata.get('filename', '')\n-            content_type = metadata.get('content-type',\n-                                        'application/octet-stream')\n-            mode = metadata.get('mode', 'create')\n-            fieldname = metadata.get('fieldname')\n-\n-            if mode == 'create':\n-                type_ = metadata.get('@type')\n-                if type_ is None:\n-                    ctr = getToolByName(self.context, 'content_type_registry')\n-                    type_ = ctr.findTypeName(\n-                        filename.lower(), content_type, '') or 'File'\n-\n-                obj = create(self.context, type_)\n-            else:\n-                obj = self.context\n-\n-            if not fieldname:\n-                info = IPrimaryFieldInfo(obj, None)\n-                if info is not None:\n-                    fieldname = info.fieldname\n-                elif base_hasattr(obj, 'getPrimaryField'):\n-                    field = obj.getPrimaryField()\n-                    fieldname = field.getName()\n-\n-            if not fieldname:\n-                return self.error('Bad Request', 'Fieldname required', 400)\n-\n-            # Acquisition wrap temporarily for deserialization\n-            temporarily_wrapped = False\n-            if IAcquirer.providedBy(obj) and not safe_hasattr(obj, 'aq_base'):\n-                obj = obj.__of__(self.context)\n-                temporarily_wrapped = True\n-\n-            # Update field with file data\n-            deserializer = queryMultiAdapter(\n-                (obj, self.request), IDeserializeFromJson)\n-            if deserializer is None:\n-                return self.error(\n-                    'Not Implemented',\n-                    'Cannot deserialize type {}'.format(\n-                        obj.portal_type),\n-                    501)\n-            try:\n-                deserializer(\n-                    data={fieldname: tus_upload}, create=mode == 'create')\n-            except DeserializationError as e:\n-                return self.error(\n-                    'Deserialization Error', str(e), 400)\n-\n-            if temporarily_wrapped:\n-                obj = aq_base(obj)\n-\n-            if mode == 'create':\n-                if not getattr(deserializer, 'notifies_create', False):\n-                    notify(ObjectCreatedEvent(obj))\n-                obj = add(self.context, obj)\n-\n-            tus_upload.close()\n-            tus_upload.cleanup()\n-            self.request.response.setHeader('Location', obj.absolute_url())\n+            self.create_or_modify_content(tus_upload)\n         else:\n-            offset = tus_upload.offset()\n             self.request.response.setHeader(\n                 'Upload-Expires', tus_upload.expires())\n \n@@ -294,6 +233,70 @@ def reply(self):\n         self.request.response.setStatus(204, lock=1)\n         return super(UploadPatch, self).reply()\n \n+    def create_or_modify_content(self, tus_upload):\n+        metadata = tus_upload.metadata()\n+        filename = metadata.get('filename', '')\n+        content_type = metadata.get('content-type',\n+                                    'application/octet-stream')\n+        mode = metadata.get('mode', 'create')\n+        fieldname = metadata.get('fieldname')\n+\n+        if mode == 'create':\n+            type_ = metadata.get('@type')\n+            if type_ is None:\n+                ctr = getToolByName(self.context, 'content_type_registry')\n+                type_ = ctr.findTypeName(\n+                    filename.lower(), content_type, '') or 'File'\n+\n+            obj = create(self.context, type_)\n+        else:\n+            obj = self.context\n+\n+        if not fieldname:\n+            info = IPrimaryFieldInfo(obj, None)\n+            if info is not None:\n+                fieldname = info.fieldname\n+            elif base_hasattr(obj, 'getPrimaryField'):\n+                field = obj.getPrimaryField()\n+                fieldname = field.getName()\n+\n+        if not fieldname:\n+            return self.error('Bad Request', 'Fieldname required', 400)\n+\n+        # Acquisition wrap temporarily for deserialization\n+        temporarily_wrapped = False\n+        if IAcquirer.providedBy(obj) and not safe_hasattr(obj, 'aq_base'):\n+            obj = obj.__of__(self.context)\n+            temporarily_wrapped = True\n+\n+        # Update field with file data\n+        deserializer = queryMultiAdapter(\n+            (obj, self.request), IDeserializeFromJson)\n+        if deserializer is None:\n+            return self.error(\n+                'Not Implemented',\n+                'Cannot deserialize type {}'.format(\n+                    obj.portal_type),\n+                501)\n+        try:\n+            deserializer(\n+                data={fieldname: tus_upload}, create=mode == 'create')\n+        except DeserializationError as e:\n+            return self.error(\n+                'Deserialization Error', str(e), 400)\n+\n+        if temporarily_wrapped:\n+            obj = aq_base(obj)\n+\n+        if mode == 'create':\n+            if not getattr(deserializer, 'notifies_create', False):\n+                notify(ObjectCreatedEvent(obj))\n+            obj = add(self.context, obj)\n+\n+        tus_upload.close()\n+        tus_upload.cleanup()\n+        self.request.response.setHeader('Location', obj.absolute_url())\n+\n \n class TUSUpload(object):\n \n"

Repository: plone.restapi


Branch: refs/heads/master
Date: 2019-03-06T16:24:55+01:00
Author: Timo Stollenwerk (tisto) <tisto@users.noreply.github.com>
Commit: https://github.com/plone/plone.restapi/commit/be3f3ba86a7e36331a8a45f48d88208be55a446e

Merge pull request #685 from plone/fix-tus-events

Fix TUS upload events

Files changed:
A news/689.bugfix
M src/plone/restapi/services/content/tus.py
M src/plone/restapi/tests/test_tus.py

b"diff --git a/news/689.bugfix b/news/689.bugfix\nnew file mode 100644\nindex 00000000..691a32d6\n--- /dev/null\n+++ b/news/689.bugfix\n@@ -0,0 +1,3 @@\n+Fix TUS upload events `#689 <https://github.com/plone/plone.restapi/issues/689>`_.\n+[buchi]\n+\ndiff --git a/src/plone/restapi/services/content/tus.py b/src/plone/restapi/services/content/tus.py\nindex 5bf9d612..524e7c57 100644\n--- a/src/plone/restapi/services/content/tus.py\n+++ b/src/plone/restapi/services/content/tus.py\n@@ -1,7 +1,10 @@\n # -*- coding: utf-8 -*-\n+from Acquisition import aq_base\n+from Acquisition.interfaces import IAcquirer\n from AccessControl.SecurityManagement import getSecurityManager\n from Products.CMFCore.utils import getToolByName\n from Products.CMFPlone.utils import base_hasattr\n+from Products.CMFPlone.utils import safe_hasattr\n from base64 import b64decode\n from email.utils import formatdate\n from fnmatch import fnmatch\n@@ -217,62 +220,11 @@ def reply(self):\n         if hasattr(request_body, 'raw'):  # Unwrap io.BufferedRandom\n             request_body = request_body.raw\n         tus_upload.write(request_body, offset)\n+        offset = tus_upload.offset()\n \n         if tus_upload.finished:\n-            offset = tus_upload.offset()\n-            filename = metadata.get('filename', '')\n-            content_type = metadata.get('content-type',\n-                                        'application/octet-stream')\n-            mode = metadata.get('mode', 'create')\n-            fieldname = metadata.get('fieldname')\n-\n-            if mode == 'create':\n-                type_ = metadata.get('@type')\n-                if type_ is None:\n-                    ctr = getToolByName(self.context, 'content_type_registry')\n-                    type_ = ctr.findTypeName(\n-                        filename.lower(), content_type, '') or 'File'\n-\n-                obj = create(self.context, type_)\n-            else:\n-                obj = self.context\n-\n-            if not fieldname:\n-                info = IPrimaryFieldInfo(obj, None)\n-                if info is not None:\n-                    fieldname = info.fieldname\n-                elif base_hasattr(obj, 'getPrimaryField'):\n-                    field = obj.getPrimaryField()\n-                    fieldname = field.getName()\n-\n-            if not fieldname:\n-                return self.error('Bad Request', 'Fieldname required', 400)\n-\n-            # Update field with file data\n-            deserializer = queryMultiAdapter(\n-                (obj, self.request), IDeserializeFromJson)\n-            if deserializer is None:\n-                return self.error(\n-                    'Not Implemented',\n-                    'Cannot deserialize type {}'.format(\n-                        obj.portal_type),\n-                    501)\n-            try:\n-                deserializer(data={fieldname: tus_upload})\n-            except DeserializationError as e:\n-                return self.error(\n-                    'Deserialization Error', str(e), 400)\n-\n-            if mode == 'create':\n-                if not getattr(deserializer, 'notifies_create', False):\n-                    notify(ObjectCreatedEvent(obj))\n-                obj = add(self.context, obj)\n-\n-            tus_upload.close()\n-            tus_upload.cleanup()\n-            self.request.response.setHeader('Location', obj.absolute_url())\n+            self.create_or_modify_content(tus_upload)\n         else:\n-            offset = tus_upload.offset()\n             self.request.response.setHeader(\n                 'Upload-Expires', tus_upload.expires())\n \n@@ -281,6 +233,70 @@ def reply(self):\n         self.request.response.setStatus(204, lock=1)\n         return super(UploadPatch, self).reply()\n \n+    def create_or_modify_content(self, tus_upload):\n+        metadata = tus_upload.metadata()\n+        filename = metadata.get('filename', '')\n+        content_type = metadata.get('content-type',\n+                                    'application/octet-stream')\n+        mode = metadata.get('mode', 'create')\n+        fieldname = metadata.get('fieldname')\n+\n+        if mode == 'create':\n+            type_ = metadata.get('@type')\n+            if type_ is None:\n+                ctr = getToolByName(self.context, 'content_type_registry')\n+                type_ = ctr.findTypeName(\n+                    filename.lower(), content_type, '') or 'File'\n+\n+            obj = create(self.context, type_)\n+        else:\n+            obj = self.context\n+\n+        if not fieldname:\n+            info = IPrimaryFieldInfo(obj, None)\n+            if info is not None:\n+                fieldname = info.fieldname\n+            elif base_hasattr(obj, 'getPrimaryField'):\n+                field = obj.getPrimaryField()\n+                fieldname = field.getName()\n+\n+        if not fieldname:\n+            return self.error('Bad Request', 'Fieldname required', 400)\n+\n+        # Acquisition wrap temporarily for deserialization\n+        temporarily_wrapped = False\n+        if IAcquirer.providedBy(obj) and not safe_hasattr(obj, 'aq_base'):\n+            obj = obj.__of__(self.context)\n+            temporarily_wrapped = True\n+\n+        # Update field with file data\n+        deserializer = queryMultiAdapter(\n+            (obj, self.request), IDeserializeFromJson)\n+        if deserializer is None:\n+            return self.error(\n+                'Not Implemented',\n+                'Cannot deserialize type {}'.format(\n+                    obj.portal_type),\n+                501)\n+        try:\n+            deserializer(\n+                data={fieldname: tus_upload}, create=mode == 'create')\n+        except DeserializationError as e:\n+            return self.error(\n+                'Deserialization Error', str(e), 400)\n+\n+        if temporarily_wrapped:\n+            obj = aq_base(obj)\n+\n+        if mode == 'create':\n+            if not getattr(deserializer, 'notifies_create', False):\n+                notify(ObjectCreatedEvent(obj))\n+            obj = add(self.context, obj)\n+\n+        tus_upload.close()\n+        tus_upload.cleanup()\n+        self.request.response.setHeader('Location', obj.absolute_url())\n+\n \n class TUSUpload(object):\n \ndiff --git a/src/plone/restapi/tests/test_tus.py b/src/plone/restapi/tests/test_tus.py\nindex e7ec7858..8a2eb839 100644\n--- a/src/plone/restapi/tests/test_tus.py\n+++ b/src/plone/restapi/tests/test_tus.py\n@@ -1,25 +1,29 @@\n # -*- coding: utf-8 -*-\n-from DateTime import DateTime\n-from six import BytesIO\n from base64 import b64encode\n+from DateTime import DateTime\n+from OFS.interfaces import IObjectWillBeAddedEvent\n from plone import api\n+from plone.app.testing import login\n+from plone.app.testing import setRoles\n from plone.app.testing import SITE_OWNER_NAME\n from plone.app.testing import SITE_OWNER_PASSWORD\n from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n from plone.app.testing import TEST_USER_PASSWORD\n-from plone.app.testing import login\n-from plone.app.testing import setRoles\n from plone.rest.cors import CORSPolicy\n from plone.rest.interfaces import ICORSPolicy\n-from plone.restapi.services.content.tus import TUSUpload\n from plone.restapi import HAS_AT\n+from plone.restapi.services.content.tus import TUSUpload\n from plone.restapi.testing import PLONE_RESTAPI_AT_FUNCTIONAL_TESTING\n from plone.restapi.testing import PLONE_RESTAPI_DX_FUNCTIONAL_TESTING\n from plone.restapi.testing import RelativeSession\n+from six import BytesIO\n from zope.component import getGlobalSiteManager\n from zope.component import provideAdapter\n from zope.interface import Interface\n+from zope.lifecycleevent.interfaces import IObjectAddedEvent\n+from zope.lifecycleevent.interfaces import IObjectCreatedEvent\n+from zope.lifecycleevent.interfaces import IObjectModifiedEvent\n from zope.publisher.interfaces.browser import IBrowserRequest\n \n import os\n@@ -399,6 +403,114 @@ def test_tus_can_replace_pdf_file(self):\n         self.assertEqual(UPLOAD_PDF_FILENAME, self.file.file.filename)\n         self.assertEqual(pdf_file_size, self.file.file.size)\n \n+    def test_create_with_tus_fires_proper_events(self):\n+        sm = getGlobalSiteManager()\n+        fired_events = []\n+\n+        def record_event(event):\n+            fired_events.append(event.__class__.__name__)\n+\n+        sm.registerHandler(record_event, (IObjectCreatedEvent,))\n+        sm.registerHandler(record_event, (IObjectWillBeAddedEvent,))\n+        sm.registerHandler(record_event, (IObjectAddedEvent,))\n+        sm.registerHandler(record_event, (IObjectModifiedEvent,))\n+\n+        # initialize the upload with POST\n+        pdf_file_path = os.path.join(os.path.dirname(__file__),\n+                                     UPLOAD_PDF_FILENAME)\n+        pdf_file_size = os.path.getsize(pdf_file_path)\n+        metadata = _prepare_metadata(UPLOAD_PDF_FILENAME, UPLOAD_PDF_MIMETYPE)\n+        response = self.api_session.post(\n+            self.upload_url,\n+            headers={'Tus-Resumable': '1.0.0',\n+                     'Upload-Length': str(pdf_file_size),\n+                     'Upload-Metadata': metadata}\n+        )\n+        self.assertEqual(response.status_code, 201)\n+        location = response.headers['Location']\n+\n+        # upload the data with PATCH\n+        with open(pdf_file_path, 'rb') as pdf_file:\n+            response = self.api_session.patch(\n+                location,\n+                headers={\n+                    'Content-Type': 'application/offset+octet-stream',\n+                    'Upload-Offset': '0',\n+                    'Tus-Resumable': '1.0.0'\n+                },\n+                data=pdf_file)\n+        self.assertEqual(response.status_code, 204)\n+\n+        self.assertEqual(\n+            fired_events,\n+            [\n+                'ObjectCreatedEvent',\n+                'ObjectWillBeAddedEvent',\n+                'ObjectAddedEvent',\n+                'ContainerModifiedEvent',\n+            ])\n+\n+        sm.unregisterHandler(record_event, (IObjectCreatedEvent,))\n+        sm.unregisterHandler(record_event, (IObjectWillBeAddedEvent,))\n+        sm.unregisterHandler(record_event, (IObjectAddedEvent,))\n+        sm.unregisterHandler(record_event, (IObjectModifiedEvent,))\n+\n+    def test_replace_with_tus_fires_proper_events(self):\n+        # Create a test file\n+        self.file = api.content.create(container=self.portal,\n+                                       type='File',\n+                                       id='testfile',\n+                                       title='Testfile')\n+        transaction.commit()\n+\n+        sm = getGlobalSiteManager()\n+        fired_events = []\n+\n+        def record_event(event):\n+            fired_events.append(event.__class__.__name__)\n+\n+        sm.registerHandler(record_event, (IObjectCreatedEvent,))\n+        sm.registerHandler(record_event, (IObjectWillBeAddedEvent,))\n+        sm.registerHandler(record_event, (IObjectAddedEvent,))\n+        sm.registerHandler(record_event, (IObjectModifiedEvent,))\n+\n+        # initialize the upload with POST\n+        pdf_file_path = os.path.join(os.path.dirname(__file__),\n+                                     UPLOAD_PDF_FILENAME)\n+        pdf_file_size = os.path.getsize(pdf_file_path)\n+        metadata = _prepare_metadata(UPLOAD_PDF_FILENAME, UPLOAD_PDF_MIMETYPE)\n+        response = self.api_session.post(\n+            '{}/@tus-replace'.format(self.file.absolute_url()),\n+            headers={'Tus-Resumable': '1.0.0',\n+                     'Upload-Length': str(pdf_file_size),\n+                     'Upload-Metadata': metadata}\n+        )\n+        self.assertEqual(response.status_code, 201)\n+        location = response.headers['Location']\n+\n+        # upload the data with PATCH\n+        with open(pdf_file_path, 'rb') as pdf_file:\n+            response = self.api_session.patch(\n+                location,\n+                headers={\n+                    'Content-Type': 'application/offset+octet-stream',\n+                    'Upload-Offset': '0',\n+                    'Tus-Resumable': '1.0.0'\n+                },\n+                data=pdf_file)\n+        self.assertEqual(response.status_code, 204)\n+\n+        self.assertEqual(\n+            fired_events,\n+            [\n+                'ObjectModifiedEvent',\n+            ])\n+\n+        sm.unregisterHandler(record_event, (IObjectCreatedEvent,))\n+        sm.unregisterHandler(record_event, (IObjectWillBeAddedEvent,))\n+        sm.unregisterHandler(record_event, (IObjectAddedEvent,))\n+        sm.unregisterHandler(record_event, (IObjectModifiedEvent,))\n+\n     def tearDown(self):\n         self.api_session.close()\n         client_home = os.environ.get('CLIENT_HOME')\n"

