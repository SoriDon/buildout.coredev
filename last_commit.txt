Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-16T16:22:44+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/9e831316407afd0dfe69e0c55e55dd752cd1cd96

Pre scale: store non-random uid to prepare space for a scale.

Do not generate the scale yet.
Only generate it when a visitor calls the url of the unique scale.

Note: contains various print statements for debugging.

Files changed:
A news/57.feature
M plone/scale/scale.py
M plone/scale/storage.py

b'diff --git a/news/57.feature b/news/57.feature\nnew file mode 100644\nindex 0000000..87d0d69\n--- /dev/null\n+++ b/news/57.feature\n@@ -0,0 +1,2 @@\n+Pre scale: store non-random uid to prepare space for a scale.\n+[maurits]\ndiff --git a/plone/scale/scale.py b/plone/scale/scale.py\nindex 0a42863..1ea8117 100644\n--- a/plone/scale/scale.py\n+++ b/plone/scale/scale.py\n@@ -143,7 +143,7 @@ def _scale_thumbnail(image, width=None, height=None):\n     return image\n \n \n-def get_scale_mode(mode, direction):\n+def get_scale_mode(mode, direction=None):\n     if direction is not None:\n         warnings.warn(\n             "the \'direction\' option is deprecated, use \'mode\' instead",\ndiff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex 6cab18a..a453f4e 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -1,12 +1,15 @@\n+from .scale import calculate_scaled_dimensions\n+from .scale import get_scale_mode\n from collections.abc import MutableMapping\n from persistent.dict import PersistentDict\n from plone.scale.interfaces import IImageScaleFactory\n-from uuid import uuid4\n+from time import time\n from ZODB.POSException import ConflictError\n from zope.annotation import IAnnotations\n from zope.interface import implementer\n from zope.interface import Interface\n \n+import hashlib\n import logging\n import pprint\n \n@@ -161,55 +164,129 @@ def storage(self):\n     def hash(self, **parameters):\n         return tuple(sorted(parameters.items()))\n \n+    def unhash(self, hash_key):\n+        result = {}\n+        for key, value in hash_key:\n+            result[key] = value\n+        return result\n+\n     def get_info_by_hash(self, hash):\n         for value in self.storage.values():\n             if value["key"] == hash:\n                 return value\n \n-    def scale(self, **parameters):\n+    def hash_key(self, **parameters):\n         key = self.hash(**parameters)\n-        storage = self.storage\n-        info = self.get_info_by_hash(key)\n-        scaling_factory = IImageScaleFactory(self.context, None)\n-        if scaling_factory is None:\n-            # There is nothing more we can do.\n-            # If we have info, return it, even if it is outdated.\n+        fieldname = parameters.get("fieldname", "image")\n+        dimension = parameters.get("width", parameters.get("scale", "none"))\n+        hash_key = hashlib.md5(str(key).encode("utf-8")).hexdigest()\n+        return f"{fieldname}-{dimension}-{hash_key}"\n+\n+    def pre_scale(self, **parameters):\n+        # This does *not* create a scale.\n+        # It only prepares info.\n+        print(f"Pre scale {parameters}")\n+        uid = self.hash_key(**parameters)\n+        # self.clear()\n+        # print(list(self.storage.keys()))\n+        info = self.get(uid)\n+        if info is not None and not self._modified_since(info["modified"]):\n+            print(f"Pre scale returns old {info}")\n             return info\n-        # Do we have info and is it up to date?\n-        outdated_uid = None\n-        if info is not None:\n-            if self._modified_since(info["modified"]):\n-                # We want to remove this outdated scale info,\n-                # but let\'s keep it until we have calculated the new info.\n-                # The assumption here is that it is better to have a slightly\n-                # outdated image than no image at all.\n-                outdated_uid = info["uid"]\n-            else:\n-                return info\n \n-        # There is no info, or it is outdated.  Recreate the scale.\n+        # There is no info, or it is outdated.  Recreate the scale info.\n+        # We need width and height for various reasons.\n+        # Start with a basis.\n+        width = parameters.get("width")\n+        height = parameters.get("height")\n+        if "fieldname" in parameters:\n+            # We should get this in a different way probably.\n+            field = getattr(self.context, parameters["fieldname"], None)\n+            if field:\n+                orig_width, orig_height = field.getImageSize()\n+                mode = get_scale_mode(\n+                    parameters.get("direction")\n+                    or parameters.get("mode")\n+                    or "contain"\n+                )\n+                width, height = calculate_scaled_dimensions(\n+                    orig_width, orig_height, width, height, mode\n+                )\n+        if not (width and height):\n+            width = height = 400\n+        key = self.hash(**parameters)\n+        info = dict(\n+            uid=uid,\n+            key=key,\n+            modified=int(time() * 1000),\n+            # This is a marker to say that this is a not-yet generated scale:\n+            placeholder=True,\n+            width=width,\n+            height=height,\n+        )\n+        self.storage[uid] = info\n+        print(f"Pre scale returns new {info}")\n+        return info\n+\n+    def generate_scale(self, **parameters):\n+        print("Generating scale...")\n+        scaling_factory = IImageScaleFactory(self.context, None)\n+        if scaling_factory is None:\n+            # There is nothing we can do.\n+            return\n         result = scaling_factory(**parameters)\n-        if result is not None:\n-            # storage will be modified:\n-            # good time to also cleanup\n-            self._cleanup()\n-            data, format_, dimensions = result\n-            width, height = dimensions\n-            uid = str(uuid4())\n-            info = dict(\n-                uid=uid,\n-                data=data,\n-                width=width,\n-                height=height,\n-                mimetype=f"image/{format_.lower()}",\n-                key=key,\n-                modified=self.modified_time,\n-            )\n-            if outdated_uid:\n-                del self[outdated_uid]\n-            storage[uid] = info\n+        if result is None:\n+            return\n+        # storage will be modified:\n+        # good time to also cleanup\n+        self._cleanup()\n+        data, format_, dimensions = result\n+        width, height = dimensions\n+        uid = self.hash_key(**parameters)\n+        key = self.hash(**parameters)\n+        info = dict(\n+            uid=uid,\n+            data=data,\n+            width=width,\n+            height=height,\n+            mimetype=f"image/{format_.lower()}",\n+            key=key,\n+            modified=int(time() * 1000),\n+        )\n+        self.storage[uid] = info\n+        print(f"Generated scale: {info}")\n         return info\n \n+    def scale(self, **parameters):\n+        print(f"scale called with {parameters}")\n+        uid = self.hash_key(**parameters)\n+        info = self.get(uid)\n+        if info is None:\n+            # Might be on old-style uuid4 scale\n+            key = self.hash(**parameters)\n+            info = self.get_info_by_hash(key)\n+        if info is not None and "data" in info and not self._modified_since(info["modified"]):\n+            print(f"scale found existing info {info}")\n+            return info\n+        return self.generate_scale(**parameters)\n+\n+    def get_or_generate(self, name):\n+        print(f"get or generate {name}")\n+        info = self.get(name)\n+        if info is None:\n+            print(f"get or generate {name} not found")\n+            return\n+        if info is not None and "data" in info and not self._modified_since(info["modified"]):\n+            print(f"get or generate {name} found {info}")\n+            return info\n+        # This scale has not been generated yet.\n+        # name is expected to be fieldname-dimension-hash_key,\n+        # as generated by the pre_scale method.\n+        # hash_key = name.split("-")[-1]\n+        # parameters = self.unhash(hash_key)\n+        parameters = self.unhash(info["key"])\n+        return self.generate_scale(**parameters)\n+\n     def _cleanup(self):\n         storage = self.storage\n         modified_time = self.modified_time\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-17T19:09:41+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/cd5788615dd56d8ab55268300e1d25922997d5b2

Add pre_scale and get_or_generate to IImageScaleStorage interface.

Files changed:
M plone/scale/storage.py

b'diff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex a453f4e..11b6f6c 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -36,6 +36,12 @@ def __init__(context, modified=None):\n         to return a representation of the last modification date, which\n         can be used to invalidate stored scale data on update."""\n \n+    def pre_scale(**parameters):\n+        """Pre-register a unique id for a scale, without actually scaling.\n+\n+        In other words: no use of Pillow allowed.\n+        """\n+\n     def scale(**parameters):\n         """Find image scale data for the given parameters or create it.\n \n@@ -50,6 +56,12 @@ def scale(**parameters):\n     def __getitem__(uid):\n         """Find image scale data based on its uid."""\n \n+    def get_or_generate(uid):\n+        """Find image scale data based on its uid, or generate it.\n+\n+        Only uids pre-generated by the pre_scale method should be accepted.\n+        """\n+\n \n class ScalesDict(PersistentDict):\n     def raise_conflict(self, saved, new):\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-17T21:54:03+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/b299e3d30dddddaa3ff994c7b952afc275872ce7

We need the modified time in the hash.

Otherwise you get the same hash for the same parameters even if the image is different.

Files changed:
M plone/scale/storage.py
M plone/scale/tests/test_storage.py

b'diff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex 11b6f6c..7f86e27 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -174,7 +174,9 @@ def storage(self):\n         return scales\n \n     def hash(self, **parameters):\n-        return tuple(sorted(parameters.items()))\n+        items = list(parameters.items())\n+        items.append(("modified", self.modified_time))\n+        return tuple(sorted(items))\n \n     def unhash(self, hash_key):\n         result = {}\n@@ -263,7 +265,7 @@ def generate_scale(self, **parameters):\n             height=height,\n             mimetype=f"image/{format_.lower()}",\n             key=key,\n-            modified=int(time() * 1000),\n+            modified=self.modified_time or int(time() * 1000),\n         )\n         self.storage[uid] = info\n         print(f"Generated scale: {info}")\ndiff --git a/plone/scale/tests/test_storage.py b/plone/scale/tests/test_storage.py\nindex 17c2f2b..ea9e784 100644\n--- a/plone/scale/tests/test_storage.py\n+++ b/plone/scale/tests/test_storage.py\n@@ -151,24 +151,41 @@ def testDeleteRemovesItemAndIndex(self):\n     def testCleanUpOldItems(self):\n         self._provide_dummy_scale_adapter()\n         storage = self.storage\n+        orig_modified = storage.modified()\n+        storage.pre_scale(foo=23, bar=42)\n+        self.assertEqual(len(storage), 1)\n         scale_old = storage.scale(foo=23, bar=42)\n-        next_modified = storage.modified() + 1\n+        self.assertEqual(len(storage), 1)\n+        storage.pre_scale(foo=23, bar=42)\n+        scale_old2 = storage.scale(foo=23, bar=42)\n+        self.assertEqual(len(storage), 1)\n+        self.assertEqual(scale_old, scale_old2)\n+        self.assertIn(scale_old["uid"], storage)\n+        next_modified = orig_modified + 10\n         storage.modified = lambda: next_modified\n         scale_new = storage.scale(foo=23, bar=42)\n-        self.assertEqual(len(storage), 1)\n+        self.assertEqual(len(storage), 2)\n         self.assertIn(scale_new["uid"], storage)\n-        self.assertNotIn(scale_old["uid"], storage)\n+        self.assertIn(scale_old["uid"], storage)\n \n         # When modification time is older than a day, too old scales\n         # get purged.\n-        next_modified = storage.modified() + 24 * 60 * 60 * 1000 + 1\n+        next_modified = orig_modified + 24 * 60 * 60 * 1000 + 1\n         storage.modified = lambda: next_modified\n         scale_newer = storage.scale(foo=23, bar=42)\n \n         self.assertIn(scale_newer["uid"], storage)\n+        self.assertIn(scale_new["uid"], storage)\n+        self.assertNotIn(scale_old["uid"], storage)\n+\n+        next_modified = orig_modified + 24 * 60 * 60 * 1000 * 3\n+        storage.modified = lambda: next_modified\n+        scale_even_newer = storage.scale(foo=23, bar=42)\n+        self.assertIn(scale_even_newer["uid"], storage)\n+        self.assertNotIn(scale_newer["uid"], storage)\n         self.assertNotIn(scale_new["uid"], storage)\n         self.assertNotIn(scale_old["uid"], storage)\n-        del storage[scale_newer["uid"]]\n+        del storage[scale_even_newer["uid"]]\n         self.assertEqual(len(storage), 0)\n \n     def testClear(self):\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-17T22:24:30+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/f2134335af4347a856182bb1e091f9a274bcf1ab

Allow width and height to be None in _calculate_all_dimensions.

Should not happen in practice I guess, but helps for plone.namedfile tests.
Just return the original dimensions, and we are fine.

Files changed:
M plone/scale/scale.py
M plone/scale/storage.py

b'diff --git a/plone/scale/scale.py b/plone/scale/scale.py\nindex 1ea8117..2b8715e 100644\n--- a/plone/scale/scale.py\n+++ b/plone/scale/scale.py\n@@ -175,13 +175,15 @@ def _calculate_all_dimensions(\n \n     The other values are required for cropping and scaling."""\n \n-    if width is None and height is None:\n-        raise ValueError("Either width or height need to be given.")\n-\n     if mode not in ("contain", "cover", "scale"):\n         raise ValueError("Unknown scale mode \'%s\'" % mode)\n \n     dimensions = ScaledDimensions()\n+    dimensions.factor_width = dimensions.factor_height = 1.0\n+    if width is None and height is None:\n+        dimensions.final_width = dimensions.target_width = original_width\n+        dimensions.final_height = dimensions.target_height = original_height\n+        return dimensions\n \n     if mode == "scale":\n         # first store original size, as it is possible that we won\'t scale at all\ndiff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex 7f86e27..8688059 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -192,7 +192,9 @@ def get_info_by_hash(self, hash):\n     def hash_key(self, **parameters):\n         key = self.hash(**parameters)\n         fieldname = parameters.get("fieldname", "image")\n-        dimension = parameters.get("width", parameters.get("scale", "none"))\n+        dimension = parameters.get("width", parameters.get("scale"))\n+        if dimension is None:\n+            dimension = 0\n         hash_key = hashlib.md5(str(key).encode("utf-8")).hexdigest()\n         return f"{fieldname}-{dimension}-{hash_key}"\n \n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-17T22:44:31+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/ab11dbd65eb2a6f87bb8831d48408fe8111d3b45

Merge branch 'master' into pre-scale

Files changed:
A news/55.bugfix
M plone/scale/storage.py
M plone/scale/tests/test_storage.py

b'diff --git a/news/55.bugfix b/news/55.bugfix\nnew file mode 100644\nindex 0000000..261a4b6\n--- /dev/null\n+++ b/news/55.bugfix\n@@ -0,0 +1,2 @@\n+Fix cleanup of scales: only throw away outdated scales of the same field.\n+[maurits]\ndiff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex 8688059..7b3fd9b 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -255,7 +255,8 @@ def generate_scale(self, **parameters):\n             return\n         # storage will be modified:\n         # good time to also cleanup\n-        self._cleanup()\n+        fieldname = parameters.get("fieldname")\n+        self._cleanup(fieldname=fieldname)\n         data, format_, dimensions = result\n         width, height = dimensions\n         uid = self.hash_key(**parameters)\n@@ -269,6 +270,8 @@ def generate_scale(self, **parameters):\n             key=key,\n             modified=self.modified_time or int(time() * 1000),\n         )\n+        if fieldname:\n+            info["fieldname"] = fieldname\n         self.storage[uid] = info\n         print(f"Generated scale: {info}")\n         return info\n@@ -303,7 +306,7 @@ def get_or_generate(self, name):\n         parameters = self.unhash(info["key"])\n         return self.generate_scale(**parameters)\n \n-    def _cleanup(self):\n+    def _cleanup(self, fieldname=None):\n         storage = self.storage\n         modified_time = self.modified_time\n         if modified_time is None:\n@@ -316,6 +319,10 @@ def _cleanup(self):\n             # before refactoring\n             if isinstance(key, tuple):\n                 del self[key]\n+            if fieldname and "fieldname" in value and value["fieldname"] != fieldname:\n+                # Leave scales for other fieldnames alone.\n+                # self.modified may have nothing to do with that field.\n+                continue\n             # clear cache from scales older than one day\n             elif self._modified_since(value["modified"], offset=KEEP_SCALE_MILLIS):\n                 del self[key]\n@@ -332,7 +339,7 @@ def __delitem__(self, uid):\n         except KeyError:\n             # This should not happen, but it apparently can happen in corner\n             # cases.  See https://github.com/plone/plone.scale/issues/15\n-            logger.warn("Could not delete key %s from storage.", uid)\n+            logger.warning("Could not delete key %s from storage.", uid)\n \n     def __iter__(self):\n         return iter(self.storage)\ndiff --git a/plone/scale/tests/test_storage.py b/plone/scale/tests/test_storage.py\nindex ea9e784..b646ff1 100644\n--- a/plone/scale/tests/test_storage.py\n+++ b/plone/scale/tests/test_storage.py\n@@ -148,7 +148,21 @@ def testDeleteRemovesItemAndIndex(self):\n         del storage[scale["uid"]]\n         self.assertEqual(len(storage), 0)\n \n-    def testCleanUpOldItems(self):\n+    def test_modified_since(self):\n+        self._provide_dummy_scale_adapter()\n+        storage = self.storage\n+        self.assertEqual(storage.modified(), 42)\n+\n+        self.assertTrue(storage._modified_since(41))\n+        self.assertFalse(storage._modified_since(42))\n+        self.assertFalse(storage._modified_since(43))\n+\n+        self.assertFalse(storage._modified_since(41, offset=1))\n+        self.assertTrue(storage._modified_since(40, offset=1))\n+        self.assertFalse(storage._modified_since(32, offset=10))\n+        self.assertTrue(storage._modified_since(32, offset=9))\n+\n+    def testCleanUpOldItemsForSameParameters(self):\n         self._provide_dummy_scale_adapter()\n         storage = self.storage\n         orig_modified = storage.modified()\n@@ -167,12 +181,33 @@ def testCleanUpOldItems(self):\n         self.assertEqual(len(storage), 2)\n         self.assertIn(scale_new["uid"], storage)\n         self.assertIn(scale_old["uid"], storage)\n+        next_modified = orig_modified + 24 * 60 * 60 * 1000 + 1\n+        storage.modified = lambda: next_modified\n+        scale_newer = storage.scale(foo=23, bar=42)\n+        self.assertIn(scale_newer["uid"], storage)\n+        self.assertIn(scale_new["uid"], storage)\n+        self.assertNotIn(scale_old["uid"], storage)\n+        del storage[scale_newer["uid"]]\n+        del storage[scale_new["uid"]]\n+        self.assertEqual(len(storage), 0)\n+\n+    def testCleanUpOldItemsForDifferentParameters(self):\n+        self._provide_dummy_scale_adapter()\n+        storage = self.storage\n+        scale_old = storage.scale(foo=23, bar=42)\n+        orig_modified = storage.modified()\n+        next_modified = orig_modified + 60000\n+        storage.modified = lambda: next_modified\n+        scale_new = storage.scale(foo=23, bar=50)\n+        self.assertEqual(len(storage), 2)\n+        self.assertIn(scale_new["uid"], storage)\n+        self.assertIn(scale_old["uid"], storage)\n \n         # When modification time is older than a day, too old scales\n         # get purged.\n         next_modified = orig_modified + 24 * 60 * 60 * 1000 + 1\n         storage.modified = lambda: next_modified\n-        scale_newer = storage.scale(foo=23, bar=42)\n+        scale_newer = storage.scale(foo=23, bar=70)\n \n         self.assertIn(scale_newer["uid"], storage)\n         self.assertIn(scale_new["uid"], storage)\n@@ -188,6 +223,35 @@ def testCleanUpOldItems(self):\n         del storage[scale_even_newer["uid"]]\n         self.assertEqual(len(storage), 0)\n \n+    def testCleanUpOldItemsForDifferentFieldname(self):\n+        self._provide_dummy_scale_adapter()\n+        storage = self.storage\n+        scale_image = storage.scale(fieldname="image", bar=42)\n+        next_modified = storage.modified() + 60000\n+        storage.modified = lambda: next_modified\n+        scale_leadimage_old = storage.scale(fieldname="leadimage", bar=50)\n+        self.assertEqual(len(storage), 2)\n+        self.assertIn(scale_leadimage_old["uid"], storage)\n+        self.assertIn(scale_image["uid"], storage)\n+\n+        # When modification time is older than a day, too old scales\n+        # get purged.  But only for the current fieldname.\n+        next_modified = storage.modified() + 24 * 60 * 60 * 1000 + 1\n+        storage.modified = lambda: next_modified\n+        scale_leadimage_new = storage.scale(fieldname="leadimage", bar=70)\n+\n+        self.assertIn(scale_leadimage_new["uid"], storage)\n+        self.assertNotIn(scale_leadimage_old["uid"], storage)\n+        self.assertIn(scale_image["uid"], storage)\n+\n+        # If we manually call cleanup without a fieldname,\n+        # all items are checked.\n+        storage._cleanup()\n+        self.assertIn(scale_leadimage_new["uid"], storage)\n+        self.assertNotIn(scale_image["uid"], storage)\n+        del storage[scale_leadimage_new["uid"]]\n+        self.assertEqual(len(storage), 0)\n+\n     def testClear(self):\n         self._provide_dummy_scale_adapter()\n         storage = self.storage\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-17T23:05:33+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/24d350851beb0f6640fd2a632308495476be712b

Add mimetype with pre=True

Files changed:
M plone/scale/storage.py

b'diff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex 7b3fd9b..a109d6d 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -215,6 +215,7 @@ def pre_scale(self, **parameters):\n         # Start with a basis.\n         width = parameters.get("width")\n         height = parameters.get("height")\n+        mimetype = ""\n         if "fieldname" in parameters:\n             # We should get this in a different way probably.\n             field = getattr(self.context, parameters["fieldname"], None)\n@@ -228,6 +229,7 @@ def pre_scale(self, **parameters):\n                 width, height = calculate_scaled_dimensions(\n                     orig_width, orig_height, width, height, mode\n                 )\n+                mimetype = field.contentType\n         if not (width and height):\n             width = height = 400\n         key = self.hash(**parameters)\n@@ -235,6 +237,7 @@ def pre_scale(self, **parameters):\n             uid=uid,\n             key=key,\n             modified=int(time() * 1000),\n+            mimetype=mimetype,\n             # This is a marker to say that this is a not-yet generated scale:\n             placeholder=True,\n             width=width,\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-18T09:59:04+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/1f3937c653d0ad4843b049841db82dfa3874678b

Set data=None instead of placeholder=True.

We were not yet using placeholder anywhere, only checking the data key.

Files changed:
M plone/scale/storage.py

b'diff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex a109d6d..f62a228 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -238,8 +238,7 @@ def pre_scale(self, **parameters):\n             key=key,\n             modified=int(time() * 1000),\n             mimetype=mimetype,\n-            # This is a marker to say that this is a not-yet generated scale:\n-            placeholder=True,\n+            data=None,\n             width=width,\n             height=height,\n         )\n@@ -287,7 +286,7 @@ def scale(self, **parameters):\n             # Might be on old-style uuid4 scale\n             key = self.hash(**parameters)\n             info = self.get_info_by_hash(key)\n-        if info is not None and "data" in info and not self._modified_since(info["modified"]):\n+        if info is not None and info.get("data") is not None and not self._modified_since(info["modified"]):\n             print(f"scale found existing info {info}")\n             return info\n         return self.generate_scale(**parameters)\n@@ -298,7 +297,7 @@ def get_or_generate(self, name):\n         if info is None:\n             print(f"get or generate {name} not found")\n             return\n-        if info is not None and "data" in info and not self._modified_since(info["modified"]):\n+        if info is not None and info.get("data") is not None and not self._modified_since(info["modified"]):\n             print(f"get or generate {name} found {info}")\n             return info\n         # This scale has not been generated yet.\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-18T10:06:55+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/d59de5a2cc3779a6f58d8194e6cfe7c6d0440428

unhash: remove the "modified" parameter that we added in the hash method.

We want the original parameters only.

Files changed:
M plone/scale/storage.py

b'diff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex f62a228..ce1ce24 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -182,6 +182,9 @@ def unhash(self, hash_key):\n         result = {}\n         for key, value in hash_key:\n             result[key] = value\n+        # Remove the "modified" parameter that we added in the hash method.\n+        # We must have only the original parameters.\n+        result.pop("modified", None)\n         return result\n \n     def get_info_by_hash(self, hash):\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-18T13:06:14+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/1691dade855750a977bbf28c4dc34700348e37bd

get_or_generate: return outdated scales.

Files changed:
M plone/scale/storage.py

b'diff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex ce1ce24..615d0d3 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -60,6 +60,9 @@ def get_or_generate(uid):\n         """Find image scale data based on its uid, or generate it.\n \n         Only uids pre-generated by the pre_scale method should be accepted.\n+\n+        Outdated scales may be returned: this method is called when requesting a scale\n+        on a cached, unique url.  An old cached page may still point to this.\n         """\n \n \n@@ -300,7 +303,10 @@ def get_or_generate(self, name):\n         if info is None:\n             print(f"get or generate {name} not found")\n             return\n-        if info is not None and info.get("data") is not None and not self._modified_since(info["modified"]):\n+        if info is not None and info.get("data") is not None:\n+            # We could check \'self._modified_since(info["modified"])\'.\n+            # But in fact we do not care if this scale is outdated.\n+            # A cached page may point to this, and the browser requests it now.\n             print(f"get or generate {name} found {info}")\n             return info\n         # This scale has not been generated yet.\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-18T13:35:25+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/b18da865ccbab6f87218447a30aac7425442846f

Add tests for pre_scale and get_or_generate.

Files changed:
M plone/scale/tests/test_storage.py

b'diff --git a/plone/scale/tests/test_storage.py b/plone/scale/tests/test_storage.py\nindex b646ff1..2b0d798 100644\n--- a/plone/scale/tests/test_storage.py\n+++ b/plone/scale/tests/test_storage.py\n@@ -74,6 +74,72 @@ def testScaleForNonExistingScaleWithoutCreation(self):\n         scale = storage.scale(foo=23, bar=42)\n         self.assertEqual(scale, None)\n \n+    def testPreScaleNoWidthAndHeight(self):\n+        self._provide_dummy_scale_adapter()\n+        storage = self.storage\n+        # It is actually pretty silly to not pass a width and height.\n+        # We default to 400 then, unless the factory does something different,\n+        # which our dummy scale adapter does.\n+        # But that is not called when using pre_scale.\n+        scale = storage.pre_scale(foo=23, bar=42)\n+        self.assertIn("uid", scale)\n+        self.assertIn("key", scale)\n+        self.assertEqual(scale["data"], None)\n+        self.assertEqual(scale["width"], 400)\n+        self.assertEqual(scale["height"], 400)\n+        # Since in these tests we do not have a real image,\n+        # we have no proper mimetype either.\n+        self.assertEqual(scale["mimetype"], "")\n+\n+    def testPreScaleForNonExistingScale(self):\n+        self._provide_dummy_scale_adapter()\n+        storage = self.storage\n+        scale = storage.pre_scale(width=50, height=80)\n+        self.assertIn("uid", scale)\n+        self.assertIn("key", scale)\n+        self.assertEqual(scale["data"], None)\n+        self.assertEqual(scale["width"], 50)\n+        self.assertEqual(scale["height"], 80)\n+        self.assertEqual(scale["mimetype"], "")\n+        # Request the same pre scale.\n+        scale2 = storage.pre_scale(width=50, height=80)\n+        self.assertEqual(scale2["uid"], scale["uid"])\n+        self.assertEqual(scale2, scale)\n+        # This will really generate the scale.\n+        new_scale = storage.scale(width=50, height=80)\n+        self.assertEqual(new_scale["uid"], scale["uid"])\n+        self.assertIn("key", new_scale)\n+        self.assertEqual(new_scale["data"], "some data")\n+        # Our dummy adapter is silly and does not do anything with\n+        # the requested width and height.\n+        self.assertEqual(new_scale["width"], 42)\n+        self.assertEqual(new_scale["height"], 23)\n+        self.assertEqual(new_scale["mimetype"], "image/png")\n+\n+    def test_get_or_generate(self):\n+        self._provide_dummy_scale_adapter()\n+        storage = self.storage\n+        self.assertIsNone(storage.get("random"))\n+        self.assertIsNone(storage.get_or_generate("random"))\n+        scale = storage.pre_scale(width=50, height=80)\n+        uid = scale["uid"]\n+        self.assertTrue(uid)\n+        # \'get\' gets the pre generated placeholder info\n+        placeholder = storage.get(uid)\n+        self.assertEqual(placeholder["uid"], uid)\n+        self.assertIsNone(placeholder["data"])\n+        self.assertEqual(placeholder["width"], 50)\n+        self.assertEqual(placeholder["height"], 80)\n+        self.assertEqual(placeholder["mimetype"], "")\n+        # \'get_or_generate\' gets the pre generated placeholder info\n+        # and generates the scale.\n+        real = storage.get_or_generate(uid)\n+        self.assertEqual(real["uid"], uid)\n+        self.assertEqual(real["data"], "some data")\n+        self.assertEqual(real["width"], 42)\n+        self.assertEqual(real["height"], 23)\n+        self.assertEqual(real["mimetype"], "image/png")\n+\n     def testScaleForExistingScale(self):\n         self._provide_dummy_scale_adapter()\n         storage = self.storage\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-18T14:19:59+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/282b6e14992ee54967923380efe28010bf6eae4f

Hash the modified time in the uid, not in the hashed key of parameters.

Files changed:
M plone/scale/storage.py

b'diff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex 615d0d3..c3c28cf 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -178,17 +178,10 @@ def storage(self):\n \n     def hash(self, **parameters):\n         items = list(parameters.items())\n-        items.append(("modified", self.modified_time))\n         return tuple(sorted(items))\n \n     def unhash(self, hash_key):\n-        result = {}\n-        for key, value in hash_key:\n-            result[key] = value\n-        # Remove the "modified" parameter that we added in the hash method.\n-        # We must have only the original parameters.\n-        result.pop("modified", None)\n-        return result\n+        return dict(hash_key)\n \n     def get_info_by_hash(self, hash):\n         for value in self.storage.values():\n@@ -196,7 +189,7 @@ def get_info_by_hash(self, hash):\n                 return value\n \n     def hash_key(self, **parameters):\n-        key = self.hash(**parameters)\n+        key = self.hash(modified=self.modified_time, **parameters)\n         fieldname = parameters.get("fieldname", "image")\n         dimension = parameters.get("width", parameters.get("scale"))\n         if dimension is None:\n@@ -310,10 +303,7 @@ def get_or_generate(self, name):\n             print(f"get or generate {name} found {info}")\n             return info\n         # This scale has not been generated yet.\n-        # name is expected to be fieldname-dimension-hash_key,\n-        # as generated by the pre_scale method.\n-        # hash_key = name.split("-")[-1]\n-        # parameters = self.unhash(hash_key)\n+        # Get the parameters used when pre-registering this scale.\n         parameters = self.unhash(info["key"])\n         return self.generate_scale(**parameters)\n \n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-18T16:29:22+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/d3546c4c9bbf597580ca32c8057288b89086051d

Let the hash method be the same as it originally was.

I changed something, later backed it out, but not exactly to the original.
Looks strange when reviewing.

Files changed:
M plone/scale/storage.py

b'diff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex c3c28cf..3a65ca2 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -177,8 +177,7 @@ def storage(self):\n         return scales\n \n     def hash(self, **parameters):\n-        items = list(parameters.items())\n-        return tuple(sorted(items))\n+        return tuple(sorted(parameters.items()))\n \n     def unhash(self, hash_key):\n         return dict(hash_key)\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-18T16:32:03+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/f2adcc83fa413aa0d13867a73bcb2f64803f2e70

Explain the new uid structure.

Files changed:
M plone/scale/storage.py

b'diff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex 3a65ca2..649a9e8 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -194,6 +194,9 @@ def hash_key(self, **parameters):\n         if dimension is None:\n             dimension = 0\n         hash_key = hashlib.md5(str(key).encode("utf-8")).hexdigest()\n+        # We return a uid that is recognizable when you inspect a url in html or\n+        # on the network tab: you immediately see for which field this is and what\n+        # the width is.  This helps during debugging/testing.\n         return f"{fieldname}-{dimension}-{hash_key}"\n \n     def pre_scale(self, **parameters):\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-18T16:41:42+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/8e2ab3d4aa3486b80d6681e0cddce12650496bee

Document the change.

Files changed:
M README.rst
M news/57.feature

b'diff --git a/README.rst b/README.rst\nindex 18a7274..9c40342 100644\n--- a/README.rst\n+++ b/README.rst\n@@ -49,22 +49,24 @@ Usage\n =====\n \n The most common way to use *plone.scale* is from a HTML template.\n-In TAL syntax a typical usage looks like this::\n+In TAL syntax a typical usage looks like this, assuming you have hooked up an ``image-scaling`` view::\n \n   <img tal:define="scales context/@@image-scaling;\n-                   thumbnail python:scales.scale(\'logo\', width=64, height=64)"\n+                   thumbnail python:scales.pre_scale(\'logo\', width=64, height=64)"\n        tal:attributes="src thumbnail/url;\n                        width thumbnail/width;\n                        height thumbnail/height" />\n \n+With the ``pre_scale`` method, no scaling with Pillow actually happens yet.\n+If you call the ``scale`` method instead, the scaling does happen.\n This generates a thumbnail of an image field called *logo* with a maximum size\n of 64x64 pixels. The dimensions of the resulting image (which might not be\n exactly 64x64) are set as attributes on the ``img`` tag to speed up browser\n rendering.\n+Visiting the url will generate the scale if this has not happened yet.\n \n If you prefer Genshi syntax and have the ``IImageScaleStorage`` interface\n in scope the syntax looks like this::\n \n-  <img py:with="thumbnail=IImageScaleStorage(context).scale(\'logo\', width=64, heigh=64)"\n+  <img py:with="thumbnail=IImageScaleStorage(context).pre_scale(\'logo\', width=64, heigh=64)"\n        py:attributes="dict(src=thumbnail.url, width=thumbnail.width, height=thumbnail.height" />\n-\ndiff --git a/news/57.feature b/news/57.feature\nindex 87d0d69..3cf5b90 100644\n--- a/news/57.feature\n+++ b/news/57.feature\n@@ -1,2 +1,6 @@\n Pre scale: store non-random uid to prepare space for a scale.\n+You call ``pre_scale`` to pre-register the scale with a unique id\n+without actually doing any scaling with Pillow.\n+When you later call the ``scale`` method, the scale is generated.\n+You can still call ``scale`` directly without first calling ``pre_scale``.\n [maurits]\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-19T00:15:32+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/4c1790db266a42b4cd94df8c592f3ffc68e6cbd0

Changed prints to logger.debug.

This fixes plone.formwidget.namedfile doctests. :-)

Files changed:
M plone/scale/storage.py

b'diff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex 649a9e8..5bf49e6 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -202,13 +202,13 @@ def hash_key(self, **parameters):\n     def pre_scale(self, **parameters):\n         # This does *not* create a scale.\n         # It only prepares info.\n-        print(f"Pre scale {parameters}")\n+        logger.debug(f"Pre scale {parameters}")\n         uid = self.hash_key(**parameters)\n         # self.clear()\n-        # print(list(self.storage.keys()))\n+        # logger.debug(list(self.storage.keys()))\n         info = self.get(uid)\n         if info is not None and not self._modified_since(info["modified"]):\n-            print(f"Pre scale returns old {info}")\n+            logger.debug(f"Pre scale returns old {info}")\n             return info\n \n         # There is no info, or it is outdated.  Recreate the scale info.\n@@ -244,11 +244,11 @@ def pre_scale(self, **parameters):\n             height=height,\n         )\n         self.storage[uid] = info\n-        print(f"Pre scale returns new {info}")\n+        logger.debug(f"Pre scale returns new {info}")\n         return info\n \n     def generate_scale(self, **parameters):\n-        print("Generating scale...")\n+        logger.debug("Generating scale...")\n         scaling_factory = IImageScaleFactory(self.context, None)\n         if scaling_factory is None:\n             # There is nothing we can do.\n@@ -276,11 +276,11 @@ def generate_scale(self, **parameters):\n         if fieldname:\n             info["fieldname"] = fieldname\n         self.storage[uid] = info\n-        print(f"Generated scale: {info}")\n+        logger.debug(f"Generated scale: {info}")\n         return info\n \n     def scale(self, **parameters):\n-        print(f"scale called with {parameters}")\n+        logger.debug(f"scale called with {parameters}")\n         uid = self.hash_key(**parameters)\n         info = self.get(uid)\n         if info is None:\n@@ -288,21 +288,21 @@ def scale(self, **parameters):\n             key = self.hash(**parameters)\n             info = self.get_info_by_hash(key)\n         if info is not None and info.get("data") is not None and not self._modified_since(info["modified"]):\n-            print(f"scale found existing info {info}")\n+            logger.debug(f"scale found existing info {info}")\n             return info\n         return self.generate_scale(**parameters)\n \n     def get_or_generate(self, name):\n-        print(f"get or generate {name}")\n+        logger.debug(f"get or generate {name}")\n         info = self.get(name)\n         if info is None:\n-            print(f"get or generate {name} not found")\n+            logger.debug(f"get or generate {name} not found")\n             return\n         if info is not None and info.get("data") is not None:\n             # We could check \'self._modified_since(info["modified"])\'.\n             # But in fact we do not care if this scale is outdated.\n             # A cached page may point to this, and the browser requests it now.\n-            print(f"get or generate {name} found {info}")\n+            logger.debug(f"get or generate {name} found {info}")\n             return info\n         # This scale has not been generated yet.\n         # Get the parameters used when pre-registering this scale.\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-20T17:02:13+03:00
Author: MrTango (MrTango) <md@derico.de>
Commit: https://github.com/plone/plone.scale/commit/821fdb67ab9ff646e35527ab773b58d551a4de31

prevent duplicate modified key in hash call

Files changed:
M plone/scale/storage.py

b'diff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex 5bf49e6..6a772a6 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -188,6 +188,8 @@ def get_info_by_hash(self, hash):\n                 return value\n \n     def hash_key(self, **parameters):\n+        if "modified" in parameters:\n+            del parameters["modified"]\n         key = self.hash(modified=self.modified_time, **parameters)\n         fieldname = parameters.get("fieldname", "image")\n         dimension = parameters.get("width", parameters.get("scale"))\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-23T21:48:44+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/35772ffbaf028d690ceb70bb645dd02024e130f6

In pre_scale call scaling_factory.get_original_value.

Otherwise we pre-register a scale for a field that is not there.
Sample error:

```
http://localhost:8080/Plone/@@ajax-search
Traceback (innermost last):
  Module ZPublisher.WSGIPublisher, line 167, in transaction_pubevents
  Module ZPublisher.WSGIPublisher, line 376, in publish_module
  Module ZPublisher.WSGIPublisher, line 271, in publish
  Module ZPublisher.mapply, line 85, in mapply
  Module ZPublisher.WSGIPublisher, line 68, in call_object
  Module Products.CMFPlone.browser.search, line 288, in __call__
  Module Products.CMFPlone.browser.search, line 303, in get_image_tag
  Module plone.memoize.volatile, line 74, in replacement
  Module plone.namedfile.scaling, line 601, in tag
  Module plone.namedfile.scaling, line 583, in tag
  Module plone.namedfile.scaling, line 539, in scale
  Module plone.namedfile.scaling, line 61, in __init__
AttributeError: 'RequestContainer' object has no attribute 'image'
```

This is what causes a test failure in this test:

```
$ bin/test --all -s Products.CMFPlone -m test_robot -t 'Simple Livesearch'
```

Files changed:
M plone/scale/interfaces.py
M plone/scale/storage.py
M plone/scale/tests/test_storage.py

b'diff --git a/plone/scale/interfaces.py b/plone/scale/interfaces.py\nindex 13bcf66..3da969c 100644\n--- a/plone/scale/interfaces.py\n+++ b/plone/scale/interfaces.py\n@@ -59,3 +59,9 @@ def _call__(\n         ``dimensions``\n             is a tuple (width, height)\n         """\n+\n+    def get_original_value():\n+        """Get the image value.\n+\n+        In most cases this will be a NamedBlobImage field.\n+        """\ndiff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex 6a772a6..2edb92a 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -213,6 +213,14 @@ def pre_scale(self, **parameters):\n             logger.debug(f"Pre scale returns old {info}")\n             return info\n \n+        scaling_factory = IImageScaleFactory(self.context, None)\n+        if scaling_factory is None:\n+            # There is nothing we can do.\n+            return\n+        if scaling_factory.get_original_value() is None:\n+            # Either an empty field, or the field does not exist.\n+            return\n+\n         # There is no info, or it is outdated.  Recreate the scale info.\n         # We need width and height for various reasons.\n         # Start with a basis.\ndiff --git a/plone/scale/tests/test_storage.py b/plone/scale/tests/test_storage.py\nindex 2b0d798..b5a4030 100644\n--- a/plone/scale/tests/test_storage.py\n+++ b/plone/scale/tests/test_storage.py\n@@ -36,6 +36,9 @@ def __call__(self, **parameters):\n                     return factory()\n                 return None\n \n+            def get_original_value(self):\n+                return result\n+\n         provideAdapter(DummyISF)\n \n     @property\n@@ -116,6 +119,15 @@ def testPreScaleForNonExistingScale(self):\n         self.assertEqual(new_scale["height"], 23)\n         self.assertEqual(new_scale["mimetype"], "image/png")\n \n+    def testPreScaleForNonExistingField(self):\n+        self._provide_dummy_scale_adapter(None)\n+        storage = self.storage\n+        scale = storage.pre_scale(width=50, height=80)\n+        self.assertIsNone(scale)\n+        # scale does the same.\n+        new_scale = storage.scale(width=50, height=80)\n+        self.assertIsNone(new_scale)\n+\n     def test_get_or_generate(self):\n         self._provide_dummy_scale_adapter()\n         storage = self.storage\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-24T08:46:02+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/bacac4940625596aab489669a91fb5da0513df5c

Merge branch 'master' into pre-scale

This fixes cropping.

Files changed:
A news/53.bugfix
M plone/scale/scale.py
M plone/scale/tests/test_scale.py

b'diff --git a/news/53.bugfix b/news/53.bugfix\nnew file mode 100644\nindex 0000000..86e8462\n--- /dev/null\n+++ b/news/53.bugfix\n@@ -0,0 +1,4 @@\n+Fix cropping when the height is not limited.\n+Create a square then.\n+Not limited means: 65000 or larger, or zero or lower.\n+[maurits]\ndiff --git a/plone/scale/scale.py b/plone/scale/scale.py\nindex 2b8715e..670f2ee 100644\n--- a/plone/scale/scale.py\n+++ b/plone/scale/scale.py\n@@ -13,6 +13,15 @@\n except AttributeError:\n     LANCZOS = PIL.Image.ANTIALIAS\n \n+# When height is higher than this we do not limit the height, but only the width.\n+# Otherwise cropping does not make sense, and in a Pillow you may get an error.\n+# In a Pillow traceback I saw 65500 as maximum.\n+# Several Plone scale definitions have 65536 (2**16).\n+# So pick a number slightly lower for good measure.\n+# A different idea was to use -1 here, so we support this:\n+# a height of 0 or less is ignored.\n+MAX_HEIGHT = 65000\n+\n \n def none_as_int(the_int):\n     """For python 3 compatibility, to make int vs. none comparison possible\n@@ -173,7 +182,10 @@ def _calculate_all_dimensions(\n     final_width and final_height are the dimensions of the resulting image and\n     are always present.\n \n-    The other values are required for cropping and scaling."""\n+    The other values are required for cropping and scaling.\n+    """\n+    if height is not None and (height >= MAX_HEIGHT or height <= 0):\n+        height = None\n \n     if mode not in ("contain", "cover", "scale"):\n         raise ValueError("Unknown scale mode \'%s\'" % mode)\n@@ -219,6 +231,9 @@ def _calculate_all_dimensions(\n         return dimensions\n \n     # now for \'cover\' and \'contain\' scaling\n+    if mode == "contain" and height is None:\n+        # For cropping we need a height.\n+        height = width\n \n     # Determine scale factors needed\n     factor_height = factor_width = None\n@@ -344,13 +359,13 @@ def scalePILImage(image, width=None, height=None, mode="contain", direction=None\n \n     `contain`\n         Alternative spellings: `scale-crop-to-fit`, `down`.\n-        Starts by scaling the smallest dimension to the required\n+        Starts by scaling the relatively smallest dimension to the required\n         size and crops the other dimension if needed.\n \n     `cover`\n         Alternative spellings: `scale-crop-to-fill`, `up`.\n-        Starts by scaling the largest dimension up to the required size\n-        and crops the other dimension if needed.\n+        Scales the relatively largest dimension up to the required size.\n+        Despite the alternative spelling, I see no cropping happening.\n \n     `scale`\n         Alternative spellings: `keep`, `thumbnail`.\ndiff --git a/plone/scale/tests/test_scale.py b/plone/scale/tests/test_scale.py\nindex 2df62a3..d620661 100644\n--- a/plone/scale/tests/test_scale.py\n+++ b/plone/scale/tests/test_scale.py\n@@ -1,9 +1,11 @@\n from io import BytesIO as StringIO\n+from plone.scale.scale import calculate_scaled_dimensions\n from plone.scale.scale import scaleImage\n from plone.scale.scale import scalePILImage\n from plone.scale.tests import TEST_DATA_LOCATION\n from unittest import TestCase\n \n+import functools\n import os.path\n import PIL.Image\n import PIL.ImageDraw\n@@ -125,12 +127,21 @@ def testNoStretchingDownScale(self):\n         self.assertEqual(scaleImage(PNG, 200, 103, "contain")[2], (200, 103))\n \n     def testHugeScale(self):\n-        # the image will be cropped, but not scaled\n-        self.assertEqual(scaleImage(PNG, 400, 99999, "contain")[2], (2, 103))\n+        # The image will be cropped, but not scaled.\n+        # If such a ridiculous height is given, we only look at the width.\n+        self.assertEqual(scaleImage(PNG, 400, 99999, "contain")[2], (400, 400))\n+\n+    def testZeroHeightScale(self):\n+        # In this case we only look at the width.\n+        self.assertEqual(scaleImage(PNG, 400, 0, "contain")[2], (400, 400))\n+\n+    def testNegativeHeightScale(self):\n+        # In this case we only look at the width.\n+        self.assertEqual(scaleImage(PNG, 400, -1, "contain")[2], (400, 400))\n \n     def testCropPreWideScaleUnspecifiedHeight(self):\n         image = scaleImage(PNG, 400, None, "contain")\n-        self.assertEqual(image[2], (400, 490))\n+        self.assertEqual(image[2], (400, 400))\n \n     def testCropPreWideScale(self):\n         image = scaleImage(PNG, 400, 100, "contain")\n@@ -145,10 +156,10 @@ def testCropPreTallScale(self):\n         self.assertEqual(image[2], (100, 400))\n \n     def testRestrictWidthOnlyDownScaleNone(self):\n-        self.assertEqual(scaleImage(PNG, 42, None, "contain")[2], (42, 52))\n+        self.assertEqual(scaleImage(PNG, 42, None, "contain")[2], (42, 42))\n \n     def testRestrictWidthOnlyDownScaleZero(self):\n-        self.assertEqual(scaleImage(PNG, 42, 0, "contain")[2], (42, 52))\n+        self.assertEqual(scaleImage(PNG, 42, 0, "contain")[2], (42, 42))\n \n     def testRestrictHeightOnlyDownScaleNone(self):\n         self.assertEqual(scaleImage(PNG, None, 51, "contain")[2], (42, 51))\n@@ -326,6 +337,62 @@ def testDeprecations(self):\n             self.assertIs(w[0].category, DeprecationWarning)\n             self.assertIn("the \'direction\' option is deprecated", str(w[0].message))\n \n+    def test_calculate_scaled_dimensions_contain(self):\n+        """Test the calculate_scaled_dimensions function.\n+\n+        You pass it:\n+\n+            original_width, original_height, width, height\n+\n+        Plus an optional mode, by default "contain"`.\n+        Alternative spellings: `scale-crop-to-fit`, `down`.\n+        """\n+        calc = calculate_scaled_dimensions\n+        self.assertEqual(calc(1, 1, 1, 1), (1, 1))\n+        self.assertEqual(calc(10, 10, 1, 1), (1, 1))\n+        self.assertEqual(calc(1, 1, 10, 10), (10, 10))\n+        self.assertEqual(calc(10, 20, 10, 10), (10, 10))\n+        # Try the new preview scale.\n+        # This is defined as width 400 and a very large height.\n+        # That does not work at all for cropping.\n+        self.assertEqual(calc(10, 20, 400, 65536), (400, 400))\n+        self.assertEqual(calc(600, 300, 400, 65536), (400, 400))\n+        self.assertEqual(calc(600, 1200, 400, 65536), (400, 400))\n+\n+    def test_calculate_scaled_dimensions_cover(self):\n+        """Test calculate_scaled_dimensions function with mode "cover".\n+\n+        Alternative spellings: `scale-crop-to-fill`, `up`.\n+        Despite what you may think, this does not crop.\n+        """\n+        calc = functools.partial(calculate_scaled_dimensions, mode="cover")\n+        self.assertEqual(calc(1, 1, 1, 1), (1, 1))\n+        self.assertEqual(calc(10, 10, 1, 1), (1, 1))\n+        # Mode "cover" scales up:\n+        self.assertEqual(calc(1, 1, 10, 10), (10, 10))\n+        # If any cropping would happen, the next answer would be (10, 10):\n+        self.assertEqual(calc(10, 20, 10, 10), (5, 10))\n+        # Try the new preview scale:\n+        self.assertEqual(calc(10, 20, 400, 65536), (400, 800))\n+        self.assertEqual(calc(600, 300, 400, 65536), (400, 200))\n+        self.assertEqual(calc(600, 1200, 400, 65536), (400, 800))\n+\n+    def test_calculate_scaled_dimensions_scale(self):\n+        """Test calculate_scaled_dimensions function with mode "scale".\n+\n+        Alternative spellings: `keep`, `thumbnail`.\n+        """\n+        calc = functools.partial(calculate_scaled_dimensions, mode="scale")\n+        self.assertEqual(calc(1, 1, 1, 1), (1, 1))\n+        self.assertEqual(calc(10, 10, 1, 1), (1, 1))\n+        # Mode "scale" only scales down, not up:\n+        self.assertEqual(calc(1, 1, 10, 10), (1, 1))\n+        self.assertEqual(calc(10, 20, 10, 10), (5, 10))\n+        # Try the new preview scale:\n+        self.assertEqual(calc(10, 20, 400, 65536), (10, 20))\n+        self.assertEqual(calc(600, 300, 400, 65536), (400, 200))\n+        self.assertEqual(calc(600, 1200, 400, 65536), (400, 800))\n+\n \n def test_suite():\n     from unittest import defaultTestLoader\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-24T09:04:44+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/7dc3736c20b8d956c792d6db20250b53413bc1b1

Pass fieldname to get_original_value.

Otherwise it depends on having self.fieldname, which is not set here.
Then it falls back to IPrimaryFieldInfo.
In case of a news item with lead image, this does not find anything.

Files changed:
M plone/scale/interfaces.py
M plone/scale/storage.py

b'diff --git a/plone/scale/interfaces.py b/plone/scale/interfaces.py\nindex 3da969c..d743d35 100644\n--- a/plone/scale/interfaces.py\n+++ b/plone/scale/interfaces.py\n@@ -60,8 +60,11 @@ def _call__(\n             is a tuple (width, height)\n         """\n \n-    def get_original_value():\n+    def get_original_value(fieldname=None):\n         """Get the image value.\n \n         In most cases this will be a NamedBlobImage field.\n+        Should accept an optional fieldname keyword argument.\n+        If not passed, and there is no self.fieldname set,\n+        you can try to get it in a different way.\n         """\ndiff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex 2edb92a..a8cc235 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -217,7 +217,8 @@ def pre_scale(self, **parameters):\n         if scaling_factory is None:\n             # There is nothing we can do.\n             return\n-        if scaling_factory.get_original_value() is None:\n+        fieldname = parameters.get("fieldname", None)\n+        if scaling_factory.get_original_value(fieldname=fieldname) is None:\n             # Either an empty field, or the field does not exist.\n             return\n \n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-05-24T09:13:22+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/d0d409dad2ab090193a494efa01e5d42ed0c4cf4

Fix get_original_value in tests.

Files changed:
M plone/scale/tests/test_storage.py

b'diff --git a/plone/scale/tests/test_storage.py b/plone/scale/tests/test_storage.py\nindex b5a4030..9ac541e 100644\n--- a/plone/scale/tests/test_storage.py\n+++ b/plone/scale/tests/test_storage.py\n@@ -36,7 +36,7 @@ def __call__(self, **parameters):\n                     return factory()\n                 return None\n \n-            def get_original_value(self):\n+            def get_original_value(self, fieldname=None):\n                 return result\n \n         provideAdapter(DummyISF)\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-06-09T09:50:14+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/ba783751b4e8514d18e4a865c3f840082a5165df

Give ScaledDimensions an init method.

Set initial values for all properties there.
From review comment https://github.com/plone/plone.scale/pull/57/files#r893129424

Files changed:
M plone/scale/scale.py

b'diff --git a/plone/scale/scale.py b/plone/scale/scale.py\nindex 670f2ee..95380e4 100644\n--- a/plone/scale/scale.py\n+++ b/plone/scale/scale.py\n@@ -171,7 +171,13 @@ def get_scale_mode(mode, direction=None):\n \n \n class ScaledDimensions:\n-    pass\n+\n+    def __init__(self, original_width=0, original_height=0):\n+        self.final_width = self.target_width = original_width\n+        self.final_height = self.target_height = original_height\n+        self.factor_width = self.factor_height = 1.0\n+        self.post_scale_crop = False\n+        self.pre_scale_crop = False\n \n \n def _calculate_all_dimensions(\n@@ -190,18 +196,14 @@ def _calculate_all_dimensions(\n     if mode not in ("contain", "cover", "scale"):\n         raise ValueError("Unknown scale mode \'%s\'" % mode)\n \n-    dimensions = ScaledDimensions()\n-    dimensions.factor_width = dimensions.factor_height = 1.0\n+    dimensions = ScaledDimensions(\n+        original_width=original_width,\n+        original_height=original_height,\n+    )\n     if width is None and height is None:\n-        dimensions.final_width = dimensions.target_width = original_width\n-        dimensions.final_height = dimensions.target_height = original_height\n         return dimensions\n \n     if mode == "scale":\n-        # first store original size, as it is possible that we won\'t scale at all\n-        dimensions.final_width = original_width\n-        dimensions.final_height = original_height\n-\n         # calculate missing sizes\n         if width is None:\n             width = float(original_width) / float(original_height) * height\n'

Repository: plone.scale


Branch: refs/heads/master
Date: 2022-06-09T13:18:28+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.scale/commit/258731910a35f37056a2097d7607e35db964fad1

Merge pull request #57 from plone/pre-scale

Pre scale: store non-random uid to prepare space for a scale.

Files changed:
A news/57.feature
M README.rst
M plone/scale/interfaces.py
M plone/scale/scale.py
M plone/scale/storage.py
M plone/scale/tests/test_storage.py

b'diff --git a/README.rst b/README.rst\nindex 18a7274..9c40342 100644\n--- a/README.rst\n+++ b/README.rst\n@@ -49,22 +49,24 @@ Usage\n =====\n \n The most common way to use *plone.scale* is from a HTML template.\n-In TAL syntax a typical usage looks like this::\n+In TAL syntax a typical usage looks like this, assuming you have hooked up an ``image-scaling`` view::\n \n   <img tal:define="scales context/@@image-scaling;\n-                   thumbnail python:scales.scale(\'logo\', width=64, height=64)"\n+                   thumbnail python:scales.pre_scale(\'logo\', width=64, height=64)"\n        tal:attributes="src thumbnail/url;\n                        width thumbnail/width;\n                        height thumbnail/height" />\n \n+With the ``pre_scale`` method, no scaling with Pillow actually happens yet.\n+If you call the ``scale`` method instead, the scaling does happen.\n This generates a thumbnail of an image field called *logo* with a maximum size\n of 64x64 pixels. The dimensions of the resulting image (which might not be\n exactly 64x64) are set as attributes on the ``img`` tag to speed up browser\n rendering.\n+Visiting the url will generate the scale if this has not happened yet.\n \n If you prefer Genshi syntax and have the ``IImageScaleStorage`` interface\n in scope the syntax looks like this::\n \n-  <img py:with="thumbnail=IImageScaleStorage(context).scale(\'logo\', width=64, heigh=64)"\n+  <img py:with="thumbnail=IImageScaleStorage(context).pre_scale(\'logo\', width=64, heigh=64)"\n        py:attributes="dict(src=thumbnail.url, width=thumbnail.width, height=thumbnail.height" />\n-\ndiff --git a/news/57.feature b/news/57.feature\nnew file mode 100644\nindex 0000000..3cf5b90\n--- /dev/null\n+++ b/news/57.feature\n@@ -0,0 +1,6 @@\n+Pre scale: store non-random uid to prepare space for a scale.\n+You call ``pre_scale`` to pre-register the scale with a unique id\n+without actually doing any scaling with Pillow.\n+When you later call the ``scale`` method, the scale is generated.\n+You can still call ``scale`` directly without first calling ``pre_scale``.\n+[maurits]\ndiff --git a/plone/scale/interfaces.py b/plone/scale/interfaces.py\nindex 13bcf66..d743d35 100644\n--- a/plone/scale/interfaces.py\n+++ b/plone/scale/interfaces.py\n@@ -59,3 +59,12 @@ def _call__(\n         ``dimensions``\n             is a tuple (width, height)\n         """\n+\n+    def get_original_value(fieldname=None):\n+        """Get the image value.\n+\n+        In most cases this will be a NamedBlobImage field.\n+        Should accept an optional fieldname keyword argument.\n+        If not passed, and there is no self.fieldname set,\n+        you can try to get it in a different way.\n+        """\ndiff --git a/plone/scale/scale.py b/plone/scale/scale.py\nindex 1776b40..95380e4 100644\n--- a/plone/scale/scale.py\n+++ b/plone/scale/scale.py\n@@ -152,7 +152,7 @@ def _scale_thumbnail(image, width=None, height=None):\n     return image\n \n \n-def get_scale_mode(mode, direction):\n+def get_scale_mode(mode, direction=None):\n     if direction is not None:\n         warnings.warn(\n             "the \'direction\' option is deprecated, use \'mode\' instead",\n@@ -171,7 +171,13 @@ def get_scale_mode(mode, direction):\n \n \n class ScaledDimensions:\n-    pass\n+\n+    def __init__(self, original_width=0, original_height=0):\n+        self.final_width = self.target_width = original_width\n+        self.final_height = self.target_height = original_height\n+        self.factor_width = self.factor_height = 1.0\n+        self.post_scale_crop = False\n+        self.pre_scale_crop = False\n \n \n def _calculate_all_dimensions(\n@@ -187,19 +193,17 @@ def _calculate_all_dimensions(\n     if height is not None and (height >= MAX_HEIGHT or height <= 0):\n         height = None\n \n-    if width is None and height is None:\n-        raise ValueError("Either width or height need to be given.")\n-\n     if mode not in ("contain", "cover", "scale"):\n         raise ValueError("Unknown scale mode \'%s\'" % mode)\n \n-    dimensions = ScaledDimensions()\n+    dimensions = ScaledDimensions(\n+        original_width=original_width,\n+        original_height=original_height,\n+    )\n+    if width is None and height is None:\n+        return dimensions\n \n     if mode == "scale":\n-        # first store original size, as it is possible that we won\'t scale at all\n-        dimensions.final_width = original_width\n-        dimensions.final_height = original_height\n-\n         # calculate missing sizes\n         if width is None:\n             width = float(original_width) / float(original_height) * height\ndiff --git a/plone/scale/storage.py b/plone/scale/storage.py\nindex 87cedad..a8cc235 100644\n--- a/plone/scale/storage.py\n+++ b/plone/scale/storage.py\n@@ -1,12 +1,15 @@\n+from .scale import calculate_scaled_dimensions\n+from .scale import get_scale_mode\n from collections.abc import MutableMapping\n from persistent.dict import PersistentDict\n from plone.scale.interfaces import IImageScaleFactory\n-from uuid import uuid4\n+from time import time\n from ZODB.POSException import ConflictError\n from zope.annotation import IAnnotations\n from zope.interface import implementer\n from zope.interface import Interface\n \n+import hashlib\n import logging\n import pprint\n \n@@ -33,6 +36,12 @@ def __init__(context, modified=None):\n         to return a representation of the last modification date, which\n         can be used to invalidate stored scale data on update."""\n \n+    def pre_scale(**parameters):\n+        """Pre-register a unique id for a scale, without actually scaling.\n+\n+        In other words: no use of Pillow allowed.\n+        """\n+\n     def scale(**parameters):\n         """Find image scale data for the given parameters or create it.\n \n@@ -47,6 +56,15 @@ def scale(**parameters):\n     def __getitem__(uid):\n         """Find image scale data based on its uid."""\n \n+    def get_or_generate(uid):\n+        """Find image scale data based on its uid, or generate it.\n+\n+        Only uids pre-generated by the pre_scale method should be accepted.\n+\n+        Outdated scales may be returned: this method is called when requesting a scale\n+        on a cached, unique url.  An old cached page may still point to this.\n+        """\n+\n \n class ScalesDict(PersistentDict):\n     def raise_conflict(self, saved, new):\n@@ -161,58 +179,147 @@ def storage(self):\n     def hash(self, **parameters):\n         return tuple(sorted(parameters.items()))\n \n+    def unhash(self, hash_key):\n+        return dict(hash_key)\n+\n     def get_info_by_hash(self, hash):\n         for value in self.storage.values():\n             if value["key"] == hash:\n                 return value\n \n-    def scale(self, **parameters):\n-        key = self.hash(**parameters)\n-        storage = self.storage\n-        info = self.get_info_by_hash(key)\n+    def hash_key(self, **parameters):\n+        if "modified" in parameters:\n+            del parameters["modified"]\n+        key = self.hash(modified=self.modified_time, **parameters)\n+        fieldname = parameters.get("fieldname", "image")\n+        dimension = parameters.get("width", parameters.get("scale"))\n+        if dimension is None:\n+            dimension = 0\n+        hash_key = hashlib.md5(str(key).encode("utf-8")).hexdigest()\n+        # We return a uid that is recognizable when you inspect a url in html or\n+        # on the network tab: you immediately see for which field this is and what\n+        # the width is.  This helps during debugging/testing.\n+        return f"{fieldname}-{dimension}-{hash_key}"\n+\n+    def pre_scale(self, **parameters):\n+        # This does *not* create a scale.\n+        # It only prepares info.\n+        logger.debug(f"Pre scale {parameters}")\n+        uid = self.hash_key(**parameters)\n+        # self.clear()\n+        # logger.debug(list(self.storage.keys()))\n+        info = self.get(uid)\n+        if info is not None and not self._modified_since(info["modified"]):\n+            logger.debug(f"Pre scale returns old {info}")\n+            return info\n+\n         scaling_factory = IImageScaleFactory(self.context, None)\n         if scaling_factory is None:\n-            # There is nothing more we can do.\n-            # If we have info, return it, even if it is outdated.\n-            return info\n-        # Do we have info and is it up to date?\n-        outdated_uid = None\n-        if info is not None:\n-            if self._modified_since(info["modified"]):\n-                # We want to remove this outdated scale info,\n-                # but let\'s keep it until we have calculated the new info.\n-                # The assumption here is that it is better to have a slightly\n-                # outdated image than no image at all.\n-                outdated_uid = info["uid"]\n-            else:\n-                return info\n+            # There is nothing we can do.\n+            return\n+        fieldname = parameters.get("fieldname", None)\n+        if scaling_factory.get_original_value(fieldname=fieldname) is None:\n+            # Either an empty field, or the field does not exist.\n+            return\n \n-        # There is no info, or it is outdated.  Recreate the scale.\n+        # There is no info, or it is outdated.  Recreate the scale info.\n+        # We need width and height for various reasons.\n+        # Start with a basis.\n+        width = parameters.get("width")\n+        height = parameters.get("height")\n+        mimetype = ""\n+        if "fieldname" in parameters:\n+            # We should get this in a different way probably.\n+            field = getattr(self.context, parameters["fieldname"], None)\n+            if field:\n+                orig_width, orig_height = field.getImageSize()\n+                mode = get_scale_mode(\n+                    parameters.get("direction")\n+                    or parameters.get("mode")\n+                    or "contain"\n+                )\n+                width, height = calculate_scaled_dimensions(\n+                    orig_width, orig_height, width, height, mode\n+                )\n+                mimetype = field.contentType\n+        if not (width and height):\n+            width = height = 400\n+        key = self.hash(**parameters)\n+        info = dict(\n+            uid=uid,\n+            key=key,\n+            modified=int(time() * 1000),\n+            mimetype=mimetype,\n+            data=None,\n+            width=width,\n+            height=height,\n+        )\n+        self.storage[uid] = info\n+        logger.debug(f"Pre scale returns new {info}")\n+        return info\n+\n+    def generate_scale(self, **parameters):\n+        logger.debug("Generating scale...")\n+        scaling_factory = IImageScaleFactory(self.context, None)\n+        if scaling_factory is None:\n+            # There is nothing we can do.\n+            return\n         result = scaling_factory(**parameters)\n-        if result is not None:\n-            # storage will be modified:\n-            # good time to also cleanup\n-            fieldname = parameters.get("fieldname")\n-            self._cleanup(fieldname=fieldname)\n-            data, format_, dimensions = result\n-            width, height = dimensions\n-            uid = str(uuid4())\n-            info = dict(\n-                uid=uid,\n-                data=data,\n-                width=width,\n-                height=height,\n-                mimetype=f"image/{format_.lower()}",\n-                key=key,\n-                modified=self.modified_time,\n-            )\n-            if fieldname:\n-                info["fieldname"] = fieldname\n-            if outdated_uid:\n-                del self[outdated_uid]\n-            storage[uid] = info\n+        if result is None:\n+            return\n+        # storage will be modified:\n+        # good time to also cleanup\n+        fieldname = parameters.get("fieldname")\n+        self._cleanup(fieldname=fieldname)\n+        data, format_, dimensions = result\n+        width, height = dimensions\n+        uid = self.hash_key(**parameters)\n+        key = self.hash(**parameters)\n+        info = dict(\n+            uid=uid,\n+            data=data,\n+            width=width,\n+            height=height,\n+            mimetype=f"image/{format_.lower()}",\n+            key=key,\n+            modified=self.modified_time or int(time() * 1000),\n+        )\n+        if fieldname:\n+            info["fieldname"] = fieldname\n+        self.storage[uid] = info\n+        logger.debug(f"Generated scale: {info}")\n         return info\n \n+    def scale(self, **parameters):\n+        logger.debug(f"scale called with {parameters}")\n+        uid = self.hash_key(**parameters)\n+        info = self.get(uid)\n+        if info is None:\n+            # Might be on old-style uuid4 scale\n+            key = self.hash(**parameters)\n+            info = self.get_info_by_hash(key)\n+        if info is not None and info.get("data") is not None and not self._modified_since(info["modified"]):\n+            logger.debug(f"scale found existing info {info}")\n+            return info\n+        return self.generate_scale(**parameters)\n+\n+    def get_or_generate(self, name):\n+        logger.debug(f"get or generate {name}")\n+        info = self.get(name)\n+        if info is None:\n+            logger.debug(f"get or generate {name} not found")\n+            return\n+        if info is not None and info.get("data") is not None:\n+            # We could check \'self._modified_since(info["modified"])\'.\n+            # But in fact we do not care if this scale is outdated.\n+            # A cached page may point to this, and the browser requests it now.\n+            logger.debug(f"get or generate {name} found {info}")\n+            return info\n+        # This scale has not been generated yet.\n+        # Get the parameters used when pre-registering this scale.\n+        parameters = self.unhash(info["key"])\n+        return self.generate_scale(**parameters)\n+\n     def _cleanup(self, fieldname=None):\n         storage = self.storage\n         modified_time = self.modified_time\ndiff --git a/plone/scale/tests/test_storage.py b/plone/scale/tests/test_storage.py\nindex 0f883ca..9ac541e 100644\n--- a/plone/scale/tests/test_storage.py\n+++ b/plone/scale/tests/test_storage.py\n@@ -36,6 +36,9 @@ def __call__(self, **parameters):\n                     return factory()\n                 return None\n \n+            def get_original_value(self, fieldname=None):\n+                return result\n+\n         provideAdapter(DummyISF)\n \n     @property\n@@ -74,6 +77,81 @@ def testScaleForNonExistingScaleWithoutCreation(self):\n         scale = storage.scale(foo=23, bar=42)\n         self.assertEqual(scale, None)\n \n+    def testPreScaleNoWidthAndHeight(self):\n+        self._provide_dummy_scale_adapter()\n+        storage = self.storage\n+        # It is actually pretty silly to not pass a width and height.\n+        # We default to 400 then, unless the factory does something different,\n+        # which our dummy scale adapter does.\n+        # But that is not called when using pre_scale.\n+        scale = storage.pre_scale(foo=23, bar=42)\n+        self.assertIn("uid", scale)\n+        self.assertIn("key", scale)\n+        self.assertEqual(scale["data"], None)\n+        self.assertEqual(scale["width"], 400)\n+        self.assertEqual(scale["height"], 400)\n+        # Since in these tests we do not have a real image,\n+        # we have no proper mimetype either.\n+        self.assertEqual(scale["mimetype"], "")\n+\n+    def testPreScaleForNonExistingScale(self):\n+        self._provide_dummy_scale_adapter()\n+        storage = self.storage\n+        scale = storage.pre_scale(width=50, height=80)\n+        self.assertIn("uid", scale)\n+        self.assertIn("key", scale)\n+        self.assertEqual(scale["data"], None)\n+        self.assertEqual(scale["width"], 50)\n+        self.assertEqual(scale["height"], 80)\n+        self.assertEqual(scale["mimetype"], "")\n+        # Request the same pre scale.\n+        scale2 = storage.pre_scale(width=50, height=80)\n+        self.assertEqual(scale2["uid"], scale["uid"])\n+        self.assertEqual(scale2, scale)\n+        # This will really generate the scale.\n+        new_scale = storage.scale(width=50, height=80)\n+        self.assertEqual(new_scale["uid"], scale["uid"])\n+        self.assertIn("key", new_scale)\n+        self.assertEqual(new_scale["data"], "some data")\n+        # Our dummy adapter is silly and does not do anything with\n+        # the requested width and height.\n+        self.assertEqual(new_scale["width"], 42)\n+        self.assertEqual(new_scale["height"], 23)\n+        self.assertEqual(new_scale["mimetype"], "image/png")\n+\n+    def testPreScaleForNonExistingField(self):\n+        self._provide_dummy_scale_adapter(None)\n+        storage = self.storage\n+        scale = storage.pre_scale(width=50, height=80)\n+        self.assertIsNone(scale)\n+        # scale does the same.\n+        new_scale = storage.scale(width=50, height=80)\n+        self.assertIsNone(new_scale)\n+\n+    def test_get_or_generate(self):\n+        self._provide_dummy_scale_adapter()\n+        storage = self.storage\n+        self.assertIsNone(storage.get("random"))\n+        self.assertIsNone(storage.get_or_generate("random"))\n+        scale = storage.pre_scale(width=50, height=80)\n+        uid = scale["uid"]\n+        self.assertTrue(uid)\n+        # \'get\' gets the pre generated placeholder info\n+        placeholder = storage.get(uid)\n+        self.assertEqual(placeholder["uid"], uid)\n+        self.assertIsNone(placeholder["data"])\n+        self.assertEqual(placeholder["width"], 50)\n+        self.assertEqual(placeholder["height"], 80)\n+        self.assertEqual(placeholder["mimetype"], "")\n+        # \'get_or_generate\' gets the pre generated placeholder info\n+        # and generates the scale.\n+        real = storage.get_or_generate(uid)\n+        self.assertEqual(real["uid"], uid)\n+        self.assertEqual(real["data"], "some data")\n+        self.assertEqual(real["width"], 42)\n+        self.assertEqual(real["height"], 23)\n+        self.assertEqual(real["mimetype"], "image/png")\n+\n     def testScaleForExistingScale(self):\n         self._provide_dummy_scale_adapter()\n         storage = self.storage\n@@ -165,13 +243,29 @@ def test_modified_since(self):\n     def testCleanUpOldItemsForSameParameters(self):\n         self._provide_dummy_scale_adapter()\n         storage = self.storage\n+        orig_modified = storage.modified()\n+        storage.pre_scale(foo=23, bar=42)\n+        self.assertEqual(len(storage), 1)\n         scale_old = storage.scale(foo=23, bar=42)\n-        next_modified = storage.modified() + 1\n+        self.assertEqual(len(storage), 1)\n+        storage.pre_scale(foo=23, bar=42)\n+        scale_old2 = storage.scale(foo=23, bar=42)\n+        self.assertEqual(len(storage), 1)\n+        self.assertEqual(scale_old, scale_old2)\n+        self.assertIn(scale_old["uid"], storage)\n+        next_modified = orig_modified + 10\n         storage.modified = lambda: next_modified\n         scale_new = storage.scale(foo=23, bar=42)\n-        self.assertEqual(len(storage), 1)\n+        self.assertEqual(len(storage), 2)\n+        self.assertIn(scale_new["uid"], storage)\n+        self.assertIn(scale_old["uid"], storage)\n+        next_modified = orig_modified + 24 * 60 * 60 * 1000 + 1\n+        storage.modified = lambda: next_modified\n+        scale_newer = storage.scale(foo=23, bar=42)\n+        self.assertIn(scale_newer["uid"], storage)\n         self.assertIn(scale_new["uid"], storage)\n         self.assertNotIn(scale_old["uid"], storage)\n+        del storage[scale_newer["uid"]]\n         del storage[scale_new["uid"]]\n         self.assertEqual(len(storage), 0)\n \n@@ -196,8 +290,15 @@ def testCleanUpOldItemsForDifferentParameters(self):\n         self.assertIn(scale_newer["uid"], storage)\n         self.assertIn(scale_new["uid"], storage)\n         self.assertNotIn(scale_old["uid"], storage)\n-        del storage[scale_newer["uid"]]\n-        del storage[scale_new["uid"]]\n+\n+        next_modified = orig_modified + 24 * 60 * 60 * 1000 * 3\n+        storage.modified = lambda: next_modified\n+        scale_even_newer = storage.scale(foo=23, bar=42)\n+        self.assertIn(scale_even_newer["uid"], storage)\n+        self.assertNotIn(scale_newer["uid"], storage)\n+        self.assertNotIn(scale_new["uid"], storage)\n+        self.assertNotIn(scale_old["uid"], storage)\n+        del storage[scale_even_newer["uid"]]\n         self.assertEqual(len(storage), 0)\n \n     def testCleanUpOldItemsForDifferentFieldname(self):\n'

