Repository: plone.namedfile


Branch: refs/heads/master
Date: 2016-05-11T17:05:16+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.namedfile/commit/df0184f75cbf6be0d0169c290d48841eb1f8e988

Use latest plone.scale scaling factories.

This include also a code overhaul.

Files changed:
A plone/namedfile/testing.py
A plone/namedfile/testing.zcml
M CHANGES.rst
M plone/namedfile/scaling.py
M plone/namedfile/scaling.zcml
M plone/namedfile/tests/test_blobfile.py
M plone/namedfile/tests/test_doctests.py
M plone/namedfile/tests/test_image.py
M plone/namedfile/tests/test_scaling.py
M plone/namedfile/usage.rst
M setup.py
D plone/namedfile/tests/base.py
D plone/namedfile/tests/testing.zcml

diff --git a/CHANGES.rst b/CHANGES.rst
index b975dd7..63ca37c 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,7 +1,7 @@
 Changelog
 =========
 
-3.0.9 (unreleased)
+3.1.0 (unreleased)
 ------------------
 
 Incompatibilities:
@@ -10,11 +10,12 @@ Incompatibilities:
 
 New:
 
-- *add item here*
+- uses adapter as factory for scales as in plone.scale>=1.5
 
 Fixes:
 
-- *add item here*
+- Fixed test setup to use layers properly.
+  [jensens]
 
 
 3.0.8 (2016-02-26)
diff --git a/plone/namedfile/scaling.py b/plone/namedfile/scaling.py
index c60bb42..338bf81 100644
--- a/plone/namedfile/scaling.py
+++ b/plone/namedfile/scaling.py
@@ -7,7 +7,10 @@
 from plone.namedfile.interfaces import IStableImageScale
 from plone.namedfile.utils import set_headers
 from plone.namedfile.utils import stream_data
+from plone.protect.interfaces import IDisableCSRFProtection
 from plone.rfc822.interfaces import IPrimaryFieldInfo
+from plone.scale.interfaces import IImageScaleFactory
+from plone.scale.interfaces import IScaledImageQuality
 from plone.scale.scale import scaleImage
 from plone.scale.storage import AnnotationStorage
 from Products.Five import BrowserView
@@ -15,6 +18,7 @@
 from ZODB.POSException import ConflictError
 from zope.app.file.file import FileChunk
 from zope.component import queryUtility
+from zope.deprecation import deprecate
 from zope.interface import alsoProvides
 from zope.interface import implementer
 from zope.publisher.interfaces import IPublishTraverse
@@ -22,17 +26,10 @@
 from zope.traversing.interfaces import ITraversable
 from zope.traversing.interfaces import TraversalError
 
-import pkg_resources
+import logging
 
 
-try:
-    pkg_resources.get_distribution('plone.protect>=3.0')
-except (pkg_resources.DistributionNotFound, pkg_resources.VersionConflict):
-    IDisableCSRFProtection = None
-else:
-    # Soft dependency to make this package work without plone.protect
-    from plone.protect.interfaces import IDisableCSRFProtection
-
+logger = logging.getLogger(__name__)
 _marker = object()
 
 
@@ -152,6 +149,99 @@ def traverse(self, name, furtherPath):
                 raise TraversalError(name)
 
 
+@implementer(IImageScaleFactory)
+class DefaultImageScalingFactory(object):
+
+    def __init__(self, context):
+        self.context = context
+
+    def get_quality(self):
+        """Get plone.app.imaging's quality setting"""
+        getScaledImageQuality = queryUtility(IScaledImageQuality)
+        if getScaledImageQuality is None:
+            return None
+        return getScaledImageQuality()
+
+    def create_scale(self, data, direction, height, width, **parameters):
+        return scaleImage(
+            data,
+            direction=direction,
+            height=height,
+            width=width,
+            **parameters
+        )
+
+    def __call__(
+        self,
+        fieldname=None,
+        direction='thumbnail',
+        height=None,
+        width=None,
+        **parameters
+    ):
+
+        """Factory for image scales`.
+        """
+        orig_value = getattr(self.context, fieldname)
+        if orig_value is None:
+            return
+
+        if height is None and width is None:
+            dummy, format_ = orig_value.contentType.split('/', 1)
+            return None, format_, (orig_value._width, orig_value._height)
+        orig_data = None
+        try:
+            orig_data = orig_value.open()
+        except AttributeError:
+            orig_data = getattr(aq_base(orig_value), 'data', orig_value)
+        if not orig_data:
+            return
+
+        # Handle cases where large image data is stored in FileChunks instead
+        # of plain string
+        if isinstance(orig_data, FileChunk):
+            # Convert data to 8-bit string
+            # (FileChunk does not provide read() access)
+            orig_data = str(orig_data)
+
+        # If quality wasn't in the parameters, try the site's default scaling
+        # quality if it exists.
+        if 'quality' not in parameters:
+            quality = self.get_quality()
+            if quality:
+                parameters['quality'] = quality
+
+        try:
+            result = self.create_scale(
+                orig_data,
+                direction=direction,
+                height=height,
+                width=width,
+                **parameters
+            )
+        except (ConflictError, KeyboardInterrupt):
+            raise
+        except Exception:
+            exception(
+                'Could not scale "%r" of %r',
+                orig_value,
+                self.context.absolute_url()
+            )
+            return
+        if result is None:
+            return
+
+        data, format_, dimensions = result
+        mimetype = u'image/{0}'.format(format_.lower())
+        value = orig_value.__class__(
+            data,
+            contentType=mimetype,
+            filename=orig_value.filename
+        )
+        value.fieldname = fieldname
+        return value, format_, dimensions
+
+
 @implementer(ITraversable, IPublishTraverse)
 class ImageScaling(BrowserView):
     """ view used for generating (and storing) image scales """
@@ -166,27 +256,32 @@ def publishTraverse(self, request, name):
         if stack and stack[-1] not in self._ignored_stacks:
             # field and scale name were given...
             scale = stack.pop()
-            image = self.scale(name, scale)             # this is aq-wrapped
+            image = self.scale(name, scale)  # this is an aq-wrapped scale_view
+            if image:
+                return image
         elif '-' in name:
             # we got a uid...
             if '.' in name:
                 name, ext = name.rsplit('.', 1)
             storage = AnnotationStorage(self.context)
             info = storage.get(name)
-            if info is not None:
-                scale_view = ImageScale(self.context, self.request, **info)
-                alsoProvides(scale_view, IStableImageScale)
-                return scale_view.__of__(self.context)
+            if info is None:
+                raise NotFound(self, name, self.request)
+            scale_view = ImageScale(self.context, self.request, **info)
+            alsoProvides(scale_view, IStableImageScale)
+            return scale_view.__of__(self.context)
         else:
             # otherwise `name` must refer to a field...
             if '.' in name:
                 name, ext = name.rsplit('.', 1)
             value = getattr(self.context, name)
             scale_view = ImageScale(
-                self.context, self.request, data=value, fieldname=name)
+                self.context,
+                self.request,
+                data=value,
+                fieldname=name
+            )
             return scale_view.__of__(self.context)
-        if image is not None:
-            return image
         raise NotFound(self, name, self.request)
 
     def traverse(self, name, furtherPath):
@@ -195,7 +290,11 @@ def traverse(self, name, furtherPath):
         value = self.guarded_orig_image(name)
         if not furtherPath:
             image = ImageScale(
-                self.context, self.request, data=value, fieldname=name)
+                self.context,
+                self.request,
+                data=value,
+                fieldname=name
+            )
         else:
             return ImmutableTraverser(self.scale(name, furtherPath[-1]))
 
@@ -205,21 +304,30 @@ def traverse(self, name, furtherPath):
 
     _sizes = {}
 
+    @deprecate('use property available_sizes instead')
     def getAvailableSizes(self, fieldname=None):
+        if fieldname:
+            logger.warn(
+                'fieldname was passed to deprecated getAvailableSizes, but '
+                'will be ignored.'
+            )
+        return self.available_sizes
+
+    @property
+    def available_sizes(self):
         # fieldname is ignored by default
-        getAvailableSizes = queryUtility(IAvailableSizes)
-        if getAvailableSizes is None:
+        sizes_util = queryUtility(IAvailableSizes)
+        if sizes_util is None:
             return self._sizes
-        sizes = getAvailableSizes()
+        sizes = sizes_util()
         if sizes is None:
             return {}
         return sizes
 
-    def _set_sizes(self, value):
+    @available_sizes.setter
+    def available_sizes(self, value):
         self._sizes = value
 
-    available_sizes = property(getAvailableSizes, _set_sizes)
-
     def getImageSize(self, fieldname=None):
         if fieldname is not None:
             value = self.guarded_orig_image(fieldname)
@@ -232,76 +340,6 @@ def getImageSize(self, fieldname=None):
     def guarded_orig_image(self, fieldname):
         return guarded_getattr(self.context, fieldname, None)
 
-    def getQuality(self):
-        """Get plone.app.imaging's quality setting"""
-        # Avoid dependening on version where interface first
-        # appeared.
-        try:
-            from plone.scale.interfaces import IScaledImageQuality
-        except ImportError:
-            return None
-        getScaledImageQuality = queryUtility(IScaledImageQuality)
-        if getScaledImageQuality is None:
-            return None
-        return getScaledImageQuality()
-
-    def create(self,
-               fieldname,
-               direction='thumbnail',
-               height=None,
-               width=None,
-               **parameters):
-        """Factory for image scales, see `IImageScaleStorage.scale`.
-        """
-        orig_value = getattr(self.context, fieldname)
-        if orig_value is None:
-            return
-
-        if height is None and width is None:
-            _, format_ = orig_value.contentType.split('/', 1)
-            return None, format_, (orig_value._width, orig_value._height)
-        orig_data = None
-        try:
-            orig_data = orig_value.open()
-        except AttributeError:
-            orig_data = getattr(aq_base(orig_value), 'data', orig_value)
-        if not orig_data:
-            return
-
-        # Handle cases where large image data is stored in FileChunks instead
-        # of plain string
-        if isinstance(orig_data, FileChunk):
-            # Convert data to 8-bit string
-            # (FileChunk does not provide read() access)
-            orig_data = str(orig_data)
-
-        # If quality wasn't in the parameters, try the site's default scaling
-        # quality if it exists.
-        if 'quality' not in parameters:
-            quality = self.getQuality()
-            if quality:
-                parameters['quality'] = quality
-
-        try:
-            result = scaleImage(orig_data,
-                                direction=direction,
-                                height=height,
-                                width=width,
-                                **parameters)
-        except (ConflictError, KeyboardInterrupt):
-            raise
-        except Exception:
-            exception('could not scale "%r" of %r',
-                      orig_value, self.context.absolute_url())
-            return
-        if result is not None:
-            data, format_, dimensions = result
-            mimetype = u'image/{0}'.format(format_.lower())
-            value = orig_value.__class__(
-                data, contentType=mimetype, filename=orig_value.filename)
-            value.fieldname = fieldname
-            return value, format_, dimensions
-
     def modified(self):
         """Provide a callable to return the modification time of content
         items, so stored image scales can be invalidated.
@@ -316,37 +354,48 @@ def scale(self,
               height=None,
               width=None,
               direction='thumbnail',
-              **parameters):
+              **parameters
+    ):
         if fieldname is None:
-            fieldname = IPrimaryFieldInfo(self.context).fieldname
+            primary_field = IPrimaryFieldInfo(self.context, None)
+            if primary_field is None:
+                return  # 404
+            fieldname = primary_field.fieldname
         if scale is not None:
-            available = self.getAvailableSizes(fieldname)
+            if width is not None or height is not None:
+                logger.warn(
+                    'A scale name and width/heigth are given. Those are'
+                    'mutually exclusive: solved by ignoring width/heigth and '
+                    'taking name'
+                )
+            available = self.available_sizes
             if scale not in available:
-                return None
+                return None  # 404
             width, height = available[scale]
-
         if IDisableCSRFProtection and self.request is not None:
             alsoProvides(self.request, IDisableCSRFProtection)
-
         storage = AnnotationStorage(self.context, self.modified)
-        info = storage.scale(factory=self.create,
-                             fieldname=fieldname,
-                             height=height,
-                             width=width,
-                             direction=direction,
-                             **parameters)
-
-        if info is not None:
-            info['fieldname'] = fieldname
-            scale_view = ImageScale(self.context, self.request, **info)
-            return scale_view.__of__(self.context)
-
-    def tag(self,
-            fieldname=None,
-            scale=None,
-            height=None,
-            width=None,
-            direction='thumbnail',
-            **kwargs):
+        info = storage.scale(
+            fieldname=fieldname,
+            height=height,
+            width=width,
+            direction=direction,
+            **parameters
+        )
+        if info is None:
+            return  # 404
+        info['fieldname'] = fieldname
+        scale_view = ImageScale(self.context, self.request, **info)
+        return scale_view.__of__(self.context)
+
+    def tag(
+        self,
+        fieldname=None,
+        scale=None,
+        height=None,
+        width=None,
+        direction='thumbnail',
+        **kwargs
+    ):
         scale = self.scale(fieldname, scale, height, width, direction)
         return scale.tag(**kwargs) if scale else None
diff --git a/plone/namedfile/scaling.zcml b/plone/namedfile/scaling.zcml
index a962979..07b4099 100644
--- a/plone/namedfile/scaling.zcml
+++ b/plone/namedfile/scaling.zcml
@@ -1,15 +1,16 @@
 <configure
     xmlns="http://namespaces.zope.org/zope"
     xmlns:browser="http://namespaces.zope.org/browser">
-
-  <include package="zope.annotation"/>
-
+  <include package="zope.annotation" />
   <browser:page
-      name="images"
-      for=".interfaces.IImageScaleTraversable"
-      class=".scaling.ImageScaling"
       allowed_attributes="scale"
+      class=".scaling.ImageScaling"
+      for=".interfaces.IImageScaleTraversable"
+      name="images"
       permission="zope2.View"
-      />
-
+  />
+  <adapter
+      factory=".scaling.DefaultImageScalingFactory"
+      for="*"
+  />
 </configure>
diff --git a/plone/namedfile/testing.py b/plone/namedfile/testing.py
new file mode 100644
index 0000000..e716aab
--- /dev/null
+++ b/plone/namedfile/testing.py
@@ -0,0 +1,43 @@
+# -*- coding: utf-8 -*-
+from plone.testing import Layer
+from plone.testing import publisher
+from plone.testing import z2
+from plone.testing import zca
+from plone.testing import zodb
+from zope.configuration import xmlconfig
+
+
+class NamedFileTestLayer(Layer):
+
+    defaultBases = (z2.STARTUP, publisher.PUBLISHER_DIRECTIVES)
+
+    def setUp(self):
+        zca.pushGlobalRegistry()
+
+        import plone.namedfile
+        xmlconfig.file('testing.zcml', plone.namedfile)
+
+        self['zodbDB'] = zodb.stackDemoStorage(
+            self.get('zodbDB'),
+            name='NamedFileFixture'
+        )
+
+    def tearDown(self):
+        # Zap the stacked ZODB
+        self['zodbDB'].close()
+        del self['zodbDB']
+
+        # Zap the stacked zca context
+        zca.popGlobalRegistry()
+
+PLONE_NAMEDFILE_FIXTURE = NamedFileTestLayer()
+
+PLONE_NAMEDFILE_INTEGRATION_TESTING = z2.IntegrationTesting(
+    bases=(PLONE_NAMEDFILE_FIXTURE,),
+    name="plone.namedfile:NamedFileTestLayerIntegration"
+)
+
+PLONE_NAMEDFILE_FUNCTIONAL_TESTING = z2.FunctionalTesting(
+    bases=(PLONE_NAMEDFILE_FIXTURE,),
+    name="plone.namedfile:NamedFileTestLayerFunctional"
+)
diff --git a/plone/namedfile/testing.zcml b/plone/namedfile/testing.zcml
new file mode 100644
index 0000000..c8ac4f0
--- /dev/null
+++ b/plone/namedfile/testing.zcml
@@ -0,0 +1,12 @@
+<configure xmlns="http://namespaces.zope.org/zope">
+
+  <include package="zope.security" file="meta.zcml" />
+  <include package="zope.component" file="meta.zcml" />
+  <include package="zope.browserpage" file="meta.zcml" />
+  <include package="zope.traversing" file="configure.zcml" />
+
+  <permission id="zope2.View" title="View" />
+
+  <include package="plone.namedfile" />
+
+</configure>
diff --git a/plone/namedfile/tests/base.py b/plone/namedfile/tests/base.py
deleted file mode 100644
index 53e6a1c..0000000
--- a/plone/namedfile/tests/base.py
+++ /dev/null
@@ -1,62 +0,0 @@
-# -*- coding: utf-8 -*-
-from StringIO import StringIO
-from Testing import ZopeTestCase as ztc
-from Testing.testbrowser import Browser
-from zope.component import testing
-from zope.configuration import xmlconfig
-
-import os
-import PIL.Image
-
-
-def getFile(filename):
-    """ return contents of the file with the given name """
-    filename = os.path.join(os.path.dirname(__file__), filename)
-    return open(filename, 'r')
-
-
-def setUp(self=None):
-    testing.setUp()
-    xmlconfig.xmlconfig(getFile('testing.zcml'))
-
-
-class NamedFileLayer:
-    setUp = classmethod(setUp)
-    tearDown = classmethod(testing.tearDown)
-
-try:
-    from Testing.ZopeTestCase.layer import ZopeLite
-except ImportError:
-    pass
-else:
-    NamedFileLayer.__bases__ = (ZopeLite,)
-
-
-class ImageTestMixin(object):
-
-    def assertImage(self, data, format_, size):
-        image = PIL.Image.open(StringIO(data))
-        self.assertEqual(image.format, format_)
-        self.assertEqual(image.size, size)
-
-
-class NamedFileTestCase(ztc.TestCase, ImageTestMixin):
-    layer = NamedFileLayer
-
-
-class NamedFileFunctionalTestCase(
-        ztc.Functional,
-        ztc.ZopeTestCase,
-        ImageTestMixin):
-    layer = NamedFileLayer
-
-    def getCredentials(self):
-        return u'{0}:{0}'.format(ztc.user_name, ztc.user_password)
-
-    def getBrowser(self, loggedIn=True):
-        """ instantiate and return a testbrowser for convenience """
-        browser = Browser()
-        if loggedIn:
-            auth = u'Basic {0}'.format(self.getCredentials())
-            browser.addHeader('Authorization', auth)
-        return browser
diff --git a/plone/namedfile/tests/test_blobfile.py b/plone/namedfile/tests/test_blobfile.py
index 346766d..d39f64c 100644
--- a/plone/namedfile/tests/test_blobfile.py
+++ b/plone/namedfile/tests/test_blobfile.py
@@ -22,7 +22,7 @@
 from plone.namedfile.interfaces import INamedBlobFile
 from plone.namedfile.interfaces import INamedBlobImage
 from plone.namedfile.interfaces import IStorage
-from plone.namedfile.tests.base import NamedFileLayer
+from plone.namedfile.testing import PLONE_NAMEDFILE_INTEGRATION_TESTING
 from plone.namedfile.tests.test_image import zptlogo
 from zope.component import provideUtility
 from zope.interface.verify import verifyClass
@@ -33,15 +33,31 @@
 
 
 def registerUtilities():
-    provideUtility(storages.StringStorable(), IStorage, name="__builtin__.str")  # noqa
-    provideUtility(storages.UnicodeStorable(), IStorage, name="__builtin__.unicode")  # noqa
-    provideUtility(storages.FileChunkStorable(), IStorage, name="plone.namedfile.file.FileChunk")  # noqa
-    provideUtility(storages.FileDescriptorStorable(), IStorage, name="__builtin__.file")  # noqa
+    provideUtility(
+        storages.StringStorable(),
+        IStorage,
+        name="__builtin__.str"
+    )
+    provideUtility(
+        storages.UnicodeStorable(),
+        IStorage,
+        name="__builtin__.unicode"
+    )
+    provideUtility(
+        storages.FileChunkStorable(),
+        IStorage,
+        name="plone.namedfile.file.FileChunk"
+    )
+    provideUtility(
+        storages.FileDescriptorStorable(),
+        IStorage,
+        name="__builtin__.file"
+    )
 
 
 class TestImage(unittest.TestCase):
 
-    layer = NamedFileLayer
+    layer = PLONE_NAMEDFILE_INTEGRATION_TESTING
 
     def setUp(self):
         registerUtilities()
diff --git a/plone/namedfile/tests/test_doctests.py b/plone/namedfile/tests/test_doctests.py
index 81fd07a..6be6cb7 100644
--- a/plone/namedfile/tests/test_doctests.py
+++ b/plone/namedfile/tests/test_doctests.py
@@ -1,33 +1,32 @@
 # -*- coding: utf-8 -*-
-from plone.namedfile.tests.base import setUp
-from zope.component.testing import tearDown
+from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING
+from plone.testing import layered
+
 
 import doctest
 import unittest
 
+TEST_FILES = [
+    'usage.rst',
+    'handler.rst',
+    'marshaler.rst',
+    'utils.rst',
+]
 
-def test_suite():
-    return unittest.TestSuite([
-
-        doctest.DocFileSuite(
-            'usage.rst', package='plone.namedfile',
-            setUp=setUp, tearDown=tearDown),
-
-        doctest.DocFileSuite(
-            'handler.rst', package='plone.namedfile',
-            setUp=setUp, tearDown=tearDown),
 
-        doctest.DocFileSuite(
-            'marshaler.rst', package='plone.namedfile',
-            setUp=setUp, tearDown=tearDown),
-
-        doctest.DocFileSuite(
-            'utils.rst', package='plone.namedfile',
-            setUp=setUp, tearDown=tearDown),
-
-        doctest.DocTestSuite('plone.namedfile.file'),
-
-    ])
+def test_suite():
+    return unittest.TestSuite(
+        [
+            layered(
+                doctest.DocFileSuite(
+                    testfile,
+                    package='plone.namedfile',
+                ),
+                PLONE_NAMEDFILE_FUNCTIONAL_TESTING
+            ) for testfile in TEST_FILES
+        ]
+
+    )
 
 if __name__ == '__main__':
     unittest.main(defaultTest='test_suite')
diff --git a/plone/namedfile/tests/test_image.py b/plone/namedfile/tests/test_image.py
index cd03c11..a067141 100644
--- a/plone/namedfile/tests/test_image.py
+++ b/plone/namedfile/tests/test_image.py
@@ -3,13 +3,18 @@
 
 from plone.namedfile.file import NamedImage
 from plone.namedfile.interfaces import INamedImage
-from plone.namedfile.tests.base import getFile
 from plone.namedfile.utils import get_contenttype
 from zope.interface.verify import verifyClass
 
 import unittest
+import os
 
 
+def getFile(filename):
+    """ return contents of the file with the given name """
+    filename = os.path.join(os.path.dirname(__file__), filename)
+    return open(filename, 'r')
+
 zptlogo = (
     'GIF89a\x10\x00\x10\x00\xd5\x00\x00\xff\xff\xff\xff\xff\xfe\xfc\xfd\xfd'
     '\xfa\xfb\xfc\xf7\xf9\xfa\xf5\xf8\xf9\xf3\xf6\xf8\xf2\xf5\xf7\xf0\xf4\xf6'
diff --git a/plone/namedfile/tests/test_scaling.py b/plone/namedfile/tests/test_scaling.py
index 9eeaf31..379968d 100644
--- a/plone/namedfile/tests/test_scaling.py
+++ b/plone/namedfile/tests/test_scaling.py
@@ -6,20 +6,30 @@
 from plone.namedfile.interfaces import IAvailableSizes
 from plone.namedfile.interfaces import IImageScaleTraversable
 from plone.namedfile.scaling import ImageScaling
-from plone.namedfile.tests.base import getFile
-from plone.namedfile.tests.base import NamedFileFunctionalTestCase
-from plone.namedfile.tests.base import NamedFileTestCase
+from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING
+from plone.namedfile.testing import PLONE_NAMEDFILE_INTEGRATION_TESTING
 from plone.scale.interfaces import IScaledImageQuality
+from plone.testing.z2 import Browser
+from StringIO import StringIO
 from zExceptions import Unauthorized
 from zope.annotation import IAttributeAnnotatable
 from zope.component import getGlobalSiteManager
 from zope.component import getSiteManager
 from zope.interface import implementer
 
+import os
+import PIL
 import re
 import time
+import unittest
 
 
+
+def getFile(filename):
+    """ return contents of the file with the given name """
+    filename = os.path.join(os.path.dirname(__file__), filename)
+    return open(filename, 'r')
+
 def wait_to_ensure_modified():
     # modified is measured in milliseconds
     # wait 5ms to ensure modified will have changed
@@ -30,6 +40,13 @@ class IHasImage(IImageScaleTraversable):
     image = NamedImageField()
 
 
+def assertImage(testcase, data, format_, size):
+    image = PIL.Image.open(StringIO(data))
+    testcase.assertEqual(image.format, format_)
+    testcase.assertEqual(image.size, size)
+
+
+
 @implementer(IAttributeAnnotatable, IHasImage)
 class DummyContent(SimpleItem):
     image = None
@@ -49,15 +66,17 @@ def getQuality(self):
         return 1  # as bad as it gets
 
 
-class ImageScalingTests(NamedFileTestCase):
+class ImageScalingTests(unittest.TestCase):
+
+    layer = PLONE_NAMEDFILE_INTEGRATION_TESTING
 
-    def afterSetUp(self):
+    def setUp(self):
         data = getFile('image.gif').read()
         item = DummyContent()
         item.image = NamedImage(data, 'image/gif', u'image.gif')
-        self.app._setOb('item', item)
-        self.item = self.app.item
-        self.scaling = ImageScaling(self.app.item, None)
+        self.layer['app']._setOb('item', item)
+        self.item = self.layer['app'].item
+        self.scaling = ImageScaling(self.item, None)
 
     def testCreateScale(self):
         foo = self.scaling.scale('image', width=100, height=80)
@@ -65,7 +84,7 @@ def testCreateScale(self):
         self.assertEqual(foo.mimetype, 'image/jpeg')
         self.assertEqual(foo.width, 80)
         self.assertEqual(foo.height, 80)
-        self.assertImage(foo.data.data, 'JPEG', (80, 80))
+        assertImage(self, foo.data.data, 'JPEG', (80, 80))
 
     def testCreateScaleWithoutData(self):
         item = DummyContent()
@@ -80,7 +99,7 @@ def testGetScaleByName(self):
         self.assertEqual(foo.mimetype, 'image/jpeg')
         self.assertEqual(foo.width, 60)
         self.assertEqual(foo.height, 60)
-        self.assertImage(foo.data.data, 'JPEG', (60, 60))
+        assertImage(self, foo.data.data, 'JPEG', (60, 60))
         expected_url = re.compile(
             r'http://nohost/item/@@images/[-a-z0-9]{36}\.jpeg')
         self.assertTrue(expected_url.match(foo.absolute_url()))
@@ -191,9 +210,12 @@ def testScaledImageQuality(self):
         self.assertTrue(size_foo > size_bar)
 
 
-class ImageTraverseTests(NamedFileTestCase):
+class ImageTraverseTests(unittest.TestCase):
+
+    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING
 
-    def afterSetUp(self):
+    def setUp(self):
+        self.app = self.layer['app']
         data = getFile('image.gif').read()
         item = DummyContent()
         item.image = NamedImage(data, 'image/gif', u'image.gif')
@@ -201,7 +223,7 @@ def afterSetUp(self):
         self.item = self.app.item
         self._orig_sizes = ImageScaling._sizes
 
-    def beforeTearDown(self):
+    def tearDown(self):
         ImageScaling._sizes = self._orig_sizes
 
     def traverse(self, path=''):
@@ -270,125 +292,109 @@ def testGuardedAccess(self):
         self.item.__allow_access_to_unprotected_subobjects__ = 1
 
 
-class ImagePublisherTests(NamedFileFunctionalTestCase):
+class ImagePublisherTests(unittest.TestCase):
+
+    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING
 
-    def afterSetUp(self):
+    def setUp(self):
+        self.app = self.layer['app']
         data = getFile('image.gif').read()
         item = DummyContent()
         item.image = NamedImage(data, 'image/gif', u'image.gif')
-        self.app._setOb('item', item)
+        self.layer['app']._setOb('item', item)
         self.item = self.app.item
         self.view = self.item.unrestrictedTraverse('@@images')
         self._orig_sizes = ImageScaling._sizes
 
-    def beforeTearDown(self):
+    def tearDown(self):
         ImageScaling._sizes = self._orig_sizes
 
     def testPublishScaleViaUID(self):
         scale = self.view.scale('image', width=64, height=64)
         # make sure the referenced image scale is available
-        url = scale.url.replace('http://nohost', '')
-        response = self.publish(url, basic=self.getCredentials())
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertImage(response.getBody(), 'JPEG', (64, 64))
+        browser = Browser(self.app)
+        browser.open(scale.url)
+        self.assertEqual('image/jpeg', browser.headers['content-type'])
+        assertImage(self, browser.contents, 'JPEG', (64, 64))
 
     def testPublishWebDavScaleViaUID(self):
         scale = self.view.scale('image', width=64, height=64)
         # make sure the referenced image scale is available
-        url = scale.url.replace('http://nohost', '') + '/manage_DAVget'
-        response = self.publish(url, basic=self.getCredentials())
-        self.assertEqual(response.getStatus(), 200)
-        # In plone.app.imaging we get a very different response, which in the
-        # end works out.  It is a bit unclear which of the two responses is
-        # wanted.
-        # self.assertEqual(response.getHeader('Content-Type'),
-        #                  'text/plain; charset=iso-8859-15')
-        # self.assertImage(response.getBody(), 'JPEG', (64, 64))
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertImage(response.getBody(), 'JPEG', (64, 64))
+        browser = Browser(self.app)
+        browser.open(scale.url + '/manage_DAVget')
+        self.assertEqual('image/jpeg', browser.headers['content-type'])
+        assertImage(self, browser.contents, 'JPEG', (64, 64))
 
     def testPublishFTPScaleViaUID(self):
         scale = self.view.scale('image', width=64, height=64)
         # make sure the referenced image scale is available
-        url = scale.url.replace('http://nohost', '') + '/manage_FTPget'
-        response = self.publish(url, basic=self.getCredentials())
+        browser = Browser(self.app)
+        browser.open(scale.url + '/manage_FTPget')
         self.assertEqual(response.getStatus(), 200)
         # Same remark as in testPublishWebDavScaleViaUID is valid here.
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertImage(response.getBody(), 'JPEG', (64, 64))
+        self.assertEqual('image/jpeg', browser.headers['content-type'])
+        assertImage(self, browser.contents, 'JPEG', (64, 64))
 
     def testHeadRequestMethod(self):
         scale = self.view.scale('image', width=64, height=64)
         # make sure the referenced image scale is available
-        url = scale.url.replace('http://nohost', '')
-        get_response = self.publish(url, basic=self.getCredentials())
-        response = self.publish(url,
-                                basic=self.getCredentials(),
-                                request_method='HEAD')
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertEqual(
-            response.getHeader('Content-Length'),
-            str(len(get_response.getBody()))
-        )
-        self.assertEqual(response.getBody(), '')
+        browser = Browser(self.app)
+        browser.open(scale.url)
+        self.browser.open(scale.url)
+        GET_length = len(browser.contents)
+        response = self.browser.open(scale.url, method='HEAD')
+        self.assertEqual('image/jpeg', browser.headers['content-type'])
+        self.assertEqual(browser.headers('Content-Length'), str(GET_length))
+        self.assertEqual(browser.contents, '')
 
     def testPublishThumbViaUID(self):
         ImageScaling._sizes = {'thumb': (128, 128)}
         scale = self.view.scale('image', 'thumb')
         # make sure the referenced image scale is available
-        url = scale.url.replace('http://nohost', '')
-        response = self.publish(url, basic=self.getCredentials())
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertImage(response.getBody(), 'JPEG', (128, 128))
+        browser = Browser(self.app)
+        browser.open(scale.url)
+        self.assertEqual('image/jpeg', browser.headers['content-type'])
+        assertImage(self, browser.contents, 'JPEG', (64, 64))
 
     def testPublishCustomSizeViaUID(self):
         # set custom image sizes
         ImageScaling._sizes = {'foo': (23, 23)}
         scale = self.view.scale('image', 'foo')
         # make sure the referenced image scale is available
-        url = scale.url.replace('http://nohost', '')
-        response = self.publish(url, basic=self.getCredentials())
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertImage(response.getBody(), 'JPEG', (23, 23))
+        browser = Browser(self.app)
+        browser.open(scale.url)
+        self.assertEqual('image/jpeg', browser.headers['content-type'])
+        assertImage(self, browser.contents, 'JPEG', (64, 64))
 
     def testPublishThumbViaName(self):
         ImageScaling._sizes = {'thumb': (128, 128)}
         # make sure traversing works as is and with scaling
-        credentials = self.getCredentials()
+        browser = Browser(self.app)
         # first the field without a scale name
-        response = self.publish('/item/@@images/image', basic=credentials)
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getBody(), getFile('image.gif').read())
-        self.assertEqual(response.getHeader('Content-Type'), 'image/gif')
+        browser.open(self.app.absolute_url() + '/item/@@images/image')
+        self.assertEqual('image/gif', browser.headers['content-type'])
+        self.assertEqual(browser.contents, getFile('image.gif').read())
+
         # and last a scaled version
-        response = self.publish('/item/@@images/image/thumb',
-                                basic=credentials)
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertImage(response.getBody(), 'JPEG', (128, 128))
+        browser.open(self.app.absolute_url() + '/item/@@images/image/thumb')
+        self.assertEqual('image/jpeg', browser.headers['content-type'])
+        assertImage(self, browser.contents, 'JPEG', (64, 64))
 
     def testPublishCustomSizeViaName(self):
         # set custom image sizes
         ImageScaling._sizes = {'foo': (23, 23)}
         # make sure traversing works as expected
-        credentials = self.getCredentials()
-        response = self.publish('/item/@@images/image/foo', basic=credentials)
-        self.assertEqual(response.getStatus(), 200)
-        self.assertImage(response.getBody(), 'JPEG', (23, 23))
+        browser = Browser(self.app)
+        browser.open(self.app.absolute_url() + '/item/@@images/image/foo')
+        assertImage(self, browser.contents, 'JPEG', (23, 23))
 
     def testPublishScaleWithInvalidUID(self):
         scale = self.view.scale('image', width=64, height=64)
-        url = scale.url.replace('http://nohost', '')
         # change the url so it's invalid...
-        url = url.replace('.jpeg', 'x.jpeg')
-        response = self.publish(url, basic=self.getCredentials())
-        self.assertEqual(response.getStatus(), 404)
+        browser = Browser(self.app)
+        browser.raiseHttpErrors = False
+        browser.open(scale.url.replace('.jpeg', 'x.jpeg'))
+        self.assertIn('404', browser.headers['status'])
 
     def testPublishScaleWithInvalidScale(self):
         scale = self.view.scale('image', 'no-such-scale')
@@ -397,6 +403,9 @@ def testPublishScaleWithInvalidScale(self):
     def test_getAvailableSizesWithInvalidScale(self):
         self.assertEqual(self.view.getAvailableSizes('no-such-scale'), {})
 
+    def test_getAvailableSizesWithInvalidScale(self):
+        self.assertEqual(self.view.available_sizes, {})
+
     def test_getImageSizeWithInvalidScale(self):
         self.assertEqual(self.view.getImageSize('no-such-scale'), (0, 0))
 
@@ -404,7 +413,7 @@ def testGuardedAccess(self):
         # make sure it's not possible to access scales of forbidden images
         self.item.__allow_access_to_unprotected_subobjects__ = 0
         ImageScaling._sizes = {'foo': (23, 23)}
-        credentials = self.getCredentials()
+        credentials = self.layer.getCredentials()
         response = self.publish('/item/@@images/image/foo', basic=credentials)
         self.assertEqual(response.getStatus(), 401)
         self.item.__allow_access_to_unprotected_subobjects__ = 1
diff --git a/plone/namedfile/tests/testing.zcml b/plone/namedfile/tests/testing.zcml
deleted file mode 100644
index c8ac4f0..0000000
--- a/plone/namedfile/tests/testing.zcml
+++ /dev/null
@@ -1,12 +0,0 @@
-<configure xmlns="http://namespaces.zope.org/zope">
-
-  <include package="zope.security" file="meta.zcml" />
-  <include package="zope.component" file="meta.zcml" />
-  <include package="zope.browserpage" file="meta.zcml" />
-  <include package="zope.traversing" file="configure.zcml" />
-
-  <permission id="zope2.View" title="View" />
-
-  <include package="plone.namedfile" />
-
-</configure>
diff --git a/plone/namedfile/usage.rst b/plone/namedfile/usage.rst
index 6c10984..c62d1cb 100644
--- a/plone/namedfile/usage.rst
+++ b/plone/namedfile/usage.rst
@@ -3,27 +3,6 @@ Usage
 
 This demonstrates how to use the package.
 
-
-Test setup
-----------
-
-We must first load the package's ZCML::
-
-    >>> configuration = """\
-    ... <configure
-    ...      xmlns="http://namespaces.zope.org/zope"
-    ...      i18n_domain="plone.namedfile.tests">
-    ...
-    ...     <include package="plone.namedfile" />
-    ...
-    ... </configure>
-    ... """
-
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-
 Schema fields
 -------------
 
diff --git a/setup.py b/setup.py
index c1a84f2..5a703b3 100644
--- a/setup.py
+++ b/setup.py
@@ -4,7 +4,7 @@
 import os
 
 
-version = '3.0.9.dev0'
+version = '3.1.0.dev0'
 description = "File types and fields for images, files and blob files with filenames"  # noqa
 long_description = ('\n\n'.join([
     open('README.rst').read(),
@@ -53,7 +53,7 @@
             'lxml',
             'Pillow',
             'plone.namedfile[supermodel, scales]',
-            'Zope2',
+            'plone.testing[z2]',
         ],
         # BBB
         'blobs': [],


Repository: plone.namedfile


Branch: refs/heads/master
Date: 2016-05-11T17:05:51+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.namedfile/commit/ff46f129a3c745abb153bef91d0ec553ced47eac

Fix the test setup and tests.

- fixed test isolation problem
- separate tests for easier debugging
- fix zope.testbrowser tests to commit transaction
- workaround to make a head request

Files changed:
A plone/namedfile/tests/test_scaling_functional.py
M CHANGES.rst
M plone/namedfile/tests/test_blobfile.py
M plone/namedfile/tests/test_scaling.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 63ca37c..2830f19 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -17,6 +17,9 @@ Fixes:
 - Fixed test setup to use layers properly.
   [jensens]
 
+- Fixed test isolation problem in ``test_blobfile.py``.
+  [jensens]
+
 
 3.0.8 (2016-02-26)
 ------------------
diff --git a/plone/namedfile/tests/test_blobfile.py b/plone/namedfile/tests/test_blobfile.py
index d39f64c..020fafb 100644
--- a/plone/namedfile/tests/test_blobfile.py
+++ b/plone/namedfile/tests/test_blobfile.py
@@ -23,6 +23,7 @@
 from plone.namedfile.interfaces import INamedBlobImage
 from plone.namedfile.interfaces import IStorage
 from plone.namedfile.testing import PLONE_NAMEDFILE_INTEGRATION_TESTING
+from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING
 from plone.namedfile.tests.test_image import zptlogo
 from zope.component import provideUtility
 from zope.interface.verify import verifyClass
@@ -103,6 +104,14 @@ def testDataMutatorWithLargeHeader(self):
         image._setData(data)
         self.assertEqual(image.getImageSize(), (1024, 680))
 
+
+class TestImageFunctional(unittest.TestCase):
+
+    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING
+
+    def setUp(self):
+        registerUtilities()
+
     def testCopyBlobs(self):
         from zope.copy import copy
         file = NamedBlobFile()
diff --git a/plone/namedfile/tests/test_scaling.py b/plone/namedfile/tests/test_scaling.py
index 379968d..a7a83bc 100644
--- a/plone/namedfile/tests/test_scaling.py
+++ b/plone/namedfile/tests/test_scaling.py
@@ -9,7 +9,6 @@
 from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING
 from plone.namedfile.testing import PLONE_NAMEDFILE_INTEGRATION_TESTING
 from plone.scale.interfaces import IScaledImageQuality
-from plone.testing.z2 import Browser
 from StringIO import StringIO
 from zExceptions import Unauthorized
 from zope.annotation import IAttributeAnnotatable
@@ -24,12 +23,12 @@
 import unittest
 
 
-
 def getFile(filename):
     """ return contents of the file with the given name """
     filename = os.path.join(os.path.dirname(__file__), filename)
     return open(filename, 'r')
 
+
 def wait_to_ensure_modified():
     # modified is measured in milliseconds
     # wait 5ms to ensure modified will have changed
@@ -46,7 +45,6 @@ def assertImage(testcase, data, format_, size):
     testcase.assertEqual(image.size, size)
 
 
-
 @implementer(IAttributeAnnotatable, IHasImage)
 class DummyContent(SimpleItem):
     image = None
@@ -292,133 +290,6 @@ def testGuardedAccess(self):
         self.item.__allow_access_to_unprotected_subobjects__ = 1
 
 
-class ImagePublisherTests(unittest.TestCase):
-
-    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING
-
-    def setUp(self):
-        self.app = self.layer['app']
-        data = getFile('image.gif').read()
-        item = DummyContent()
-        item.image = NamedImage(data, 'image/gif', u'image.gif')
-        self.layer['app']._setOb('item', item)
-        self.item = self.app.item
-        self.view = self.item.unrestrictedTraverse('@@images')
-        self._orig_sizes = ImageScaling._sizes
-
-    def tearDown(self):
-        ImageScaling._sizes = self._orig_sizes
-
-    def testPublishScaleViaUID(self):
-        scale = self.view.scale('image', width=64, height=64)
-        # make sure the referenced image scale is available
-        browser = Browser(self.app)
-        browser.open(scale.url)
-        self.assertEqual('image/jpeg', browser.headers['content-type'])
-        assertImage(self, browser.contents, 'JPEG', (64, 64))
-
-    def testPublishWebDavScaleViaUID(self):
-        scale = self.view.scale('image', width=64, height=64)
-        # make sure the referenced image scale is available
-        browser = Browser(self.app)
-        browser.open(scale.url + '/manage_DAVget')
-        self.assertEqual('image/jpeg', browser.headers['content-type'])
-        assertImage(self, browser.contents, 'JPEG', (64, 64))
-
-    def testPublishFTPScaleViaUID(self):
-        scale = self.view.scale('image', width=64, height=64)
-        # make sure the referenced image scale is available
-        browser = Browser(self.app)
-        browser.open(scale.url + '/manage_FTPget')
-        self.assertEqual(response.getStatus(), 200)
-        # Same remark as in testPublishWebDavScaleViaUID is valid here.
-        self.assertEqual('image/jpeg', browser.headers['content-type'])
-        assertImage(self, browser.contents, 'JPEG', (64, 64))
-
-    def testHeadRequestMethod(self):
-        scale = self.view.scale('image', width=64, height=64)
-        # make sure the referenced image scale is available
-        browser = Browser(self.app)
-        browser.open(scale.url)
-        self.browser.open(scale.url)
-        GET_length = len(browser.contents)
-        response = self.browser.open(scale.url, method='HEAD')
-        self.assertEqual('image/jpeg', browser.headers['content-type'])
-        self.assertEqual(browser.headers('Content-Length'), str(GET_length))
-        self.assertEqual(browser.contents, '')
-
-    def testPublishThumbViaUID(self):
-        ImageScaling._sizes = {'thumb': (128, 128)}
-        scale = self.view.scale('image', 'thumb')
-        # make sure the referenced image scale is available
-        browser = Browser(self.app)
-        browser.open(scale.url)
-        self.assertEqual('image/jpeg', browser.headers['content-type'])
-        assertImage(self, browser.contents, 'JPEG', (64, 64))
-
-    def testPublishCustomSizeViaUID(self):
-        # set custom image sizes
-        ImageScaling._sizes = {'foo': (23, 23)}
-        scale = self.view.scale('image', 'foo')
-        # make sure the referenced image scale is available
-        browser = Browser(self.app)
-        browser.open(scale.url)
-        self.assertEqual('image/jpeg', browser.headers['content-type'])
-        assertImage(self, browser.contents, 'JPEG', (64, 64))
-
-    def testPublishThumbViaName(self):
-        ImageScaling._sizes = {'thumb': (128, 128)}
-        # make sure traversing works as is and with scaling
-        browser = Browser(self.app)
-        # first the field without a scale name
-        browser.open(self.app.absolute_url() + '/item/@@images/image')
-        self.assertEqual('image/gif', browser.headers['content-type'])
-        self.assertEqual(browser.contents, getFile('image.gif').read())
-
-        # and last a scaled version
-        browser.open(self.app.absolute_url() + '/item/@@images/image/thumb')
-        self.assertEqual('image/jpeg', browser.headers['content-type'])
-        assertImage(self, browser.contents, 'JPEG', (64, 64))
-
-    def testPublishCustomSizeViaName(self):
-        # set custom image sizes
-        ImageScaling._sizes = {'foo': (23, 23)}
-        # make sure traversing works as expected
-        browser = Browser(self.app)
-        browser.open(self.app.absolute_url() + '/item/@@images/image/foo')
-        assertImage(self, browser.contents, 'JPEG', (23, 23))
-
-    def testPublishScaleWithInvalidUID(self):
-        scale = self.view.scale('image', width=64, height=64)
-        # change the url so it's invalid...
-        browser = Browser(self.app)
-        browser.raiseHttpErrors = False
-        browser.open(scale.url.replace('.jpeg', 'x.jpeg'))
-        self.assertIn('404', browser.headers['status'])
-
-    def testPublishScaleWithInvalidScale(self):
-        scale = self.view.scale('image', 'no-such-scale')
-        self.assertEqual(scale, None)
-
-    def test_getAvailableSizesWithInvalidScale(self):
-        self.assertEqual(self.view.getAvailableSizes('no-such-scale'), {})
-
-    def test_getAvailableSizesWithInvalidScale(self):
-        self.assertEqual(self.view.available_sizes, {})
-
-    def test_getImageSizeWithInvalidScale(self):
-        self.assertEqual(self.view.getImageSize('no-such-scale'), (0, 0))
-
-    def testGuardedAccess(self):
-        # make sure it's not possible to access scales of forbidden images
-        self.item.__allow_access_to_unprotected_subobjects__ = 0
-        ImageScaling._sizes = {'foo': (23, 23)}
-        credentials = self.layer.getCredentials()
-        response = self.publish('/item/@@images/image/foo', basic=credentials)
-        self.assertEqual(response.getStatus(), 401)
-        self.item.__allow_access_to_unprotected_subobjects__ = 1
-
-
 def test_suite():
     from unittest import defaultTestLoader
     return defaultTestLoader.loadTestsFromName(__name__)
diff --git a/plone/namedfile/tests/test_scaling_functional.py b/plone/namedfile/tests/test_scaling_functional.py
new file mode 100644
index 0000000..fdbde69
--- /dev/null
+++ b/plone/namedfile/tests/test_scaling_functional.py
@@ -0,0 +1,217 @@
+# -*- coding: utf-8 -*-
+from DateTime import DateTime
+from OFS.SimpleItem import SimpleItem
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
+from plone.namedfile.field import NamedImage as NamedImageField
+from plone.namedfile.file import NamedImage
+from plone.namedfile.interfaces import IImageScaleTraversable
+from plone.namedfile.scaling import ImageScaling
+from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING
+from plone.testing.z2 import Browser
+from StringIO import StringIO
+from zope.annotation import IAttributeAnnotatable
+from zope.interface import implementer
+
+import os
+import PIL
+import time
+import transaction
+import unittest
+
+
+def getFile(filename):
+    """ return contents of the file with the given name """
+    filename = os.path.join(os.path.dirname(__file__), filename)
+    return open(filename, 'r')
+
+
+def wait_to_ensure_modified():
+    # modified is measured in milliseconds
+    # wait 5ms to ensure modified will have changed
+    time.sleep(0.005)
+
+
+class IHasImage(IImageScaleTraversable):
+    image = NamedImageField()
+
+
+def assertImage(testcase, data, format_, size):
+    image = PIL.Image.open(StringIO(data))
+    testcase.assertEqual(image.format, format_)
+    testcase.assertEqual(image.size, size)
+
+
+@implementer(IAttributeAnnotatable, IHasImage)
+class DummyContent(SimpleItem):
+    image = None
+    modified = DateTime
+    id = __name__ = 'item'
+    title = 'foo'
+
+    def Title(self):
+        return self.title
+
+
+class ImagePublisherTests(unittest.TestCase):
+
+    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING
+
+    def setUp(self):
+        data = getFile('image.gif').read()
+        item = DummyContent()
+        item.image = NamedImage(data, 'image/gif', u'image.gif')
+        self.layer['app']._setOb('item', item)
+        self.item = self.layer['app'].item
+        self.view = self.item.unrestrictedTraverse('@@images')
+        self._orig_sizes = ImageScaling._sizes
+
+        self.browser = Browser(self.layer['app'])
+        self.browser.handleErrors = False
+        self.browser.addHeader('Referer', self.layer['app'].absolute_url())
+
+    def tearDown(self):
+        ImageScaling._sizes = self._orig_sizes
+
+    def testPublishScaleViaUID(self):
+        scale = self.view.scale('image', width=64, height=64)
+        transaction.commit()
+        # make sure the referenced image scale is available
+        self.browser.open(scale.url)
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        assertImage(self, self.browser.contents, 'JPEG', (64, 64))
+
+    def testPublishWebDavScaleViaUID(self):
+        scale = self.view.scale('image', width=64, height=64)
+        transaction.commit()
+        # make sure the referenced image scale is available
+        self.browser.open(scale.url + '/manage_DAVget')
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        assertImage(self, self.browser.contents, 'JPEG', (64, 64))
+
+    def testPublishFTPScaleViaUID(self):
+        scale = self.view.scale('image', width=64, height=64)
+        transaction.commit()
+        # make sure the referenced image scale is available
+        self.browser.open(scale.url + '/manage_FTPget')
+        self.assertIn('200', self.browser.headers['status'])
+        # Same remark as in testPublishWebDavScaleViaUID is valid here.
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        assertImage(self, self.browser.contents, 'JPEG', (64, 64))
+
+    def testHeadRequestMethod(self):
+        scale = self.view.scale('image', width=64, height=64)
+        transaction.commit()
+        # make sure the referenced image scale is available
+        self.browser.open(scale.url)
+        GET_length = len(self.browser.contents)
+
+        self.browser = Browser(self.layer['app'])
+        self.browser.handleErrors = False
+        self.browser.addHeader('Referer', self.layer['app'].absolute_url())
+        from urllib2 import Request
+
+        class HeadRequest(Request):
+            def get_method(self):
+                return "HEAD"
+
+        head_request = HeadRequest(scale.url)
+        mbrowser = self.browser.mech_browser
+        mbrowser.open(head_request)
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        self.assertEqual(
+            self.browser.headers['Content-Length'],
+            str(GET_length)
+        )
+        self.assertEqual(self.browser.contents, '')
+
+    def testPublishThumbViaUID(self):
+        ImageScaling._sizes = {'thumb': (128, 128)}
+        scale = self.view.scale('image', 'thumb')
+        transaction.commit()
+        # make sure the referenced image scale is available
+        self.browser.open(scale.url)
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        assertImage(self, self.browser.contents, 'JPEG', (128, 128))
+
+    def testPublishCustomSizeViaUID(self):
+        # set custom image sizes
+        ImageScaling._sizes = {'foo': (23, 23)}
+        scale = self.view.scale('image', 'foo')
+        transaction.commit()
+        # make sure the referenced image scale is available
+        self.browser.open(scale.url)
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        assertImage(self, self.browser.contents, 'JPEG', (23, 23))
+
+    def testPublishThumbViaName(self):
+        ImageScaling._sizes = {'thumb': (128, 128)}
+        transaction.commit()
+
+        # make sure traversing works as is and with scaling
+        # first the field without a scale name
+        self.browser.open(
+            self.layer['app'].absolute_url() + '/item/@@images/image'
+        )
+        self.assertEqual('image/gif', self.browser.headers['content-type'])
+        self.assertEqual(self.browser.contents, getFile('image.gif').read())
+
+        # and last a scaled version
+        self.browser.open(
+            self.layer['app'].absolute_url() + '/item/@@images/image/thumb'
+        )
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        assertImage(self, self.browser.contents, 'JPEG', (128, 128))
+
+    def testPublishCustomSizeViaName(self):
+        # set custom image sizes
+        ImageScaling._sizes = {'foo': (23, 23)}
+        transaction.commit()
+        # make sure traversing works as expected
+        self.browser.open(
+            self.layer['app'].absolute_url() + '/item/@@images/image/foo'
+        )
+        assertImage(self, self.browser.contents, 'JPEG', (23, 23))
+
+    def testPublishScaleWithInvalidUID(self):
+        scale = self.view.scale('image', width=64, height=64)
+        transaction.commit()
+        # change the url so it's invalid...
+        from zExceptions import NotFound
+        with self.assertRaises(NotFound):
+            self.browser.open(scale.url.replace('.jpeg', 'x.jpeg'))
+
+    def testPublishScaleWithInvalidScale(self):
+        scale = self.view.scale('image', 'no-such-scale')
+        transaction.commit()
+        self.assertEqual(scale, None)
+
+    def test_getAvailableSizesWithInvalidScaleMethod(self):
+        self.assertEqual(self.view.getAvailableSizes('no-such-scale'), {})
+
+    def test_getAvailableSizesWithInvalidScaleProperty(self):
+        self.assertEqual(self.view.available_sizes, {})
+
+    def test_getImageSizeWithInvalidScale(self):
+        self.assertEqual(self.view.getImageSize('no-such-scale'), (0, 0))
+
+    def testGuardedAccess(self):
+        # make sure it's not possible to access scales of forbidden images
+        self.item.__allow_access_to_unprotected_subobjects__ = 0
+        ImageScaling._sizes = {'foo': (23, 23)}
+        transaction.commit()
+        self.browser.addHeader(
+            'Authorization',
+            'Basic {0:s}:{1:s}'.format(TEST_USER_NAME, TEST_USER_PASSWORD)
+        )
+        from zExceptions import Unauthorized
+        with self.assertRaises(Unauthorized):
+            self.browser.open(
+                self.layer['app'].absolute_url() + '/item/@@images/image/foo'
+            )
+        self.item.__allow_access_to_unprotected_subobjects__ = 1
+
+
+def test_suite():
+    from unittest import defaultTestLoader
+    return defaultTestLoader.loadTestsFromName(__name__)


Repository: plone.namedfile


Branch: refs/heads/master
Date: 2016-05-11T17:06:42+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.namedfile/commit/ec2ea87d8867f87f848d63df53e27b0cd559a114

overhaul conditional import while at it.

Files changed:
M CHANGES.rst
M plone/namedfile/configure.zcml
M plone/namedfile/handler.py
M plone/namedfile/marshaler.py
M plone/namedfile/scaling.py
M plone/namedfile/storages.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 2830f19..2a7b3ab 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,16 +1,26 @@
 Changelog
 =========
 
-3.1.0 (unreleased)
+4.0.0 (unreleased)
 ------------------
 
 Incompatibilities:
 
-- *add item here*
+- Targets Plone 5.1 only, coredev 5.0 and 4.3 are on 3.0.x branch [jensens]:
+
+  - ``plone.supermodel``, ``plone.scale`` and ``plone.schemaeditor`` are now hard depedencies.
+    The extras  in setup.py are kept for bbb reasons, but are empty.
+    Conditional code is now no longer conditional.
+    This simplifies the code a lot.
+
+  - ``zope.app.file`` is no longer hard dependency.
+    If it is there, its FileChunk implementation is still checked for, otherwise not.
+
 
 New:
 
 - uses adapter as factory for scales as in plone.scale>=1.5
+  [jensens]
 
 Fixes:
 
diff --git a/plone/namedfile/configure.zcml b/plone/namedfile/configure.zcml
index ae665c2..f0f0e29 100644
--- a/plone/namedfile/configure.zcml
+++ b/plone/namedfile/configure.zcml
@@ -18,9 +18,9 @@
       />
 
   <include file="z3c-blobfile.zcml" />
-  <include zcml:condition="installed plone.supermodel" file="handler.zcml" />
-  <include zcml:condition="installed plone.rfc822" file="marshaler.zcml" />
-  <include zcml:condition="installed plone.schemaeditor" file="editor.zcml" />
-  <include zcml:condition="installed plone.scale" file="scaling.zcml" />
+  <include file="handler.zcml" />
+  <include file="marshaler.zcml" />
+  <include file="scaling.zcml" />
+  <include file="editor.zcml" />
 
 </configure>
diff --git a/plone/namedfile/handler.py b/plone/namedfile/handler.py
index 0c50755..2081393 100644
--- a/plone/namedfile/handler.py
+++ b/plone/namedfile/handler.py
@@ -1,23 +1,18 @@
 # -*- coding: utf-8 -*-
-try:
-    from plone.supermodel.exportimport import ObjectHandler
-    HAVE_SUPERMODEL = True
-except ImportError:
-    HAVE_SUPERMODEL = False
+from plone.supermodel.exportimport import ObjectHandler
+from plone.namedfile import field
 
-if HAVE_SUPERMODEL:
-    from plone.namedfile import field
 
-    class FileFieldHandler(ObjectHandler):
-        filteredAttributes = ObjectHandler.filteredAttributes.copy()
-        filteredAttributes.update({
-            'default': 'rw',
-            'missing_value': 'rw',
-            'schema': 'rw'
-        })
+class FileFieldHandler(ObjectHandler):
+    filteredAttributes = ObjectHandler.filteredAttributes.copy()
+    filteredAttributes.update({
+        'default': 'rw',
+        'missing_value': 'rw',
+        'schema': 'rw'
+    })
 
-    NamedFileHandler = FileFieldHandler(field.NamedFile)
-    NamedImageHandler = FileFieldHandler(field.NamedImage)
+NamedFileHandler = FileFieldHandler(field.NamedFile)
+NamedImageHandler = FileFieldHandler(field.NamedImage)
 
-    NamedBlobFileHandler = FileFieldHandler(field.NamedBlobFile)
-    NamedBlobImageHandler = FileFieldHandler(field.NamedBlobImage)
+NamedBlobFileHandler = FileFieldHandler(field.NamedBlobFile)
+NamedBlobImageHandler = FileFieldHandler(field.NamedBlobImage)
diff --git a/plone/namedfile/marshaler.py b/plone/namedfile/marshaler.py
index 4602664..92c3196 100644
--- a/plone/namedfile/marshaler.py
+++ b/plone/namedfile/marshaler.py
@@ -1,100 +1,98 @@
 # -*- coding: utf-8 -*-
-try:
-    from plone.rfc822.defaultfields import BaseFieldMarshaler
-    HAVE_MARSHALER = True
-except ImportError:
-    HAVE_MARSHALER = False
-
-if HAVE_MARSHALER:
-
-    from email.Encoders import encode_base64
-    from plone.namedfile import NamedBlobFile
-    from plone.namedfile import NamedBlobImage
-    from plone.namedfile import NamedFile
-    from plone.namedfile import NamedImage
-    from plone.namedfile.interfaces import INamedBlobFileField
-    from plone.namedfile.interfaces import INamedBlobImageField
-    from plone.namedfile.interfaces import INamedFileField
-    from plone.namedfile.interfaces import INamedImageField
-    from zope.component import adapter
-    from zope.interface import Interface
-
-    class BaseNamedFileFieldMarshaler(BaseFieldMarshaler):
-        """Base marshaler for plone.namedfile values. Actual adapters are
-        registered as subclasses.
-        """
+from email.Encoders import encode_base64
+from plone.namedfile import NamedBlobFile
+from plone.namedfile import NamedBlobImage
+from plone.namedfile import NamedFile
+from plone.namedfile import NamedImage
+from plone.namedfile.interfaces import INamedBlobFileField
+from plone.namedfile.interfaces import INamedBlobImageField
+from plone.namedfile.interfaces import INamedFileField
+from plone.namedfile.interfaces import INamedImageField
+from plone.rfc822.defaultfields import BaseFieldMarshaler
+from zope.component import adapter
+from zope.interface import Interface
+
+
+class BaseNamedFileFieldMarshaler(BaseFieldMarshaler):
+    """Base marshaler for plone.namedfile values. Actual adapters are
+    registered as subclasses.
+    """
 
-        ascii = False
-        factory = None
-
-        def encode(self, value, charset='utf-8', primary=False):
-            # we only support encoding a file value in the body of a message,
-            # never in a header
-            if not primary:
-                raise ValueError(
-                    'File fields can only be marshaled as primary fields')
-            if value is None:
-                return None
-            return value.data
-
-        def decode(
-                self,
-                value,
-                message=None,
-                charset='utf-8',
-                contentType=None,
-                primary=False):
-            filename = None
-            if primary and message is not None:
-                filename = message.get_filename(None)
-            return self.factory(value, contentType or '', filename)
-
-        def getContentType(self):
-            value = self._query()
-            if value is None:
-                return None
-            return value.contentType
-
-        def getCharset(self, default='utf-8'):
+    ascii = False
+    factory = None
+
+    def encode(self, value, charset='utf-8', primary=False):
+        # we only support encoding a file value in the body of a message,
+        # never in a header
+        if not primary:
+            raise ValueError(
+                'File fields can only be marshaled as primary fields')
+        if value is None:
             return None
+        return value.data
 
-        def postProcessMessage(self, message):
-            """Encode message as base64 and set content disposition
-            """
-            value = self._query()
-            if value is not None:
-                filename = value.filename
-                if filename:
-                    message.add_header('Content-Disposition', 'attachment')
-                    message.set_param(
-                        'filename',
-                        filename.encode('utf-8'),
-                        header='Content-Disposition',
-                        charset='utf-8'
-                    )
-
-            encode_base64(message)
-
-    @adapter(Interface, INamedFileField)
-    class NamedFileFieldMarshaler(BaseNamedFileFieldMarshaler):
-        """Marshaler for an INamedFile field
-        """
-        factory = NamedFile
+    def decode(
+            self,
+            value,
+            message=None,
+            charset='utf-8',
+            contentType=None,
+            primary=False):
+        filename = None
+        if primary and message is not None:
+            filename = message.get_filename(None)
+        return self.factory(value, contentType or '', filename)
 
-    @adapter(Interface, INamedImageField)
-    class NamedImageFieldMarshaler(BaseNamedFileFieldMarshaler):
-        """Marshaler for an INamedImage field
-        """
-        factory = NamedImage
+    def getContentType(self):
+        value = self._query()
+        if value is None:
+            return None
+        return value.contentType
 
-    @adapter(Interface, INamedBlobFileField)
-    class NamedBlobFileFieldMarshaler(BaseNamedFileFieldMarshaler):
-        """Marshaler for an INamedBlobFile field
-        """
-        factory = NamedBlobFile
+    def getCharset(self, default='utf-8'):
+        return None
 
-    @adapter(Interface, INamedBlobImageField)
-    class NamedBlobImageFieldMarshaler(BaseNamedFileFieldMarshaler):
-        """Marshaler for an INamedBlobImage field
+    def postProcessMessage(self, message):
+        """Encode message as base64 and set content disposition
         """
-        factory = NamedBlobImage
+        value = self._query()
+        if value is not None:
+            filename = value.filename
+            if filename:
+                message.add_header('Content-Disposition', 'attachment')
+                message.set_param(
+                    'filename',
+                    filename.encode('utf-8'),
+                    header='Content-Disposition',
+                    charset='utf-8'
+                )
+
+        encode_base64(message)
+
+
+@adapter(Interface, INamedFileField)
+class NamedFileFieldMarshaler(BaseNamedFileFieldMarshaler):
+    """Marshaler for an INamedFile field
+    """
+    factory = NamedFile
+
+
+@adapter(Interface, INamedImageField)
+class NamedImageFieldMarshaler(BaseNamedFileFieldMarshaler):
+    """Marshaler for an INamedImage field
+    """
+    factory = NamedImage
+
+
+@adapter(Interface, INamedBlobFileField)
+class NamedBlobFileFieldMarshaler(BaseNamedFileFieldMarshaler):
+    """Marshaler for an INamedBlobFile field
+    """
+    factory = NamedBlobFile
+
+
+@adapter(Interface, INamedBlobImageField)
+class NamedBlobImageFieldMarshaler(BaseNamedFileFieldMarshaler):
+    """Marshaler for an INamedBlobImage field
+    """
+    factory = NamedBlobImage
diff --git a/plone/namedfile/scaling.py b/plone/namedfile/scaling.py
index 338bf81..aeea9f1 100644
--- a/plone/namedfile/scaling.py
+++ b/plone/namedfile/scaling.py
@@ -3,6 +3,7 @@
 from Acquisition import aq_base
 from DateTime import DateTime
 from logging import exception
+from plone.namedfile.file import FILECHUNK_CLASSES
 from plone.namedfile.interfaces import IAvailableSizes
 from plone.namedfile.interfaces import IStableImageScale
 from plone.namedfile.utils import set_headers
@@ -16,7 +17,6 @@
 from Products.Five import BrowserView
 from xml.sax.saxutils import quoteattr
 from ZODB.POSException import ConflictError
-from zope.app.file.file import FileChunk
 from zope.component import queryUtility
 from zope.deprecation import deprecate
 from zope.interface import alsoProvides
@@ -199,7 +199,7 @@ def __call__(
 
         # Handle cases where large image data is stored in FileChunks instead
         # of plain string
-        if isinstance(orig_data, FileChunk):
+        if isinstance(orig_data, tuple(FILECHUNK_CLASSES)):
             # Convert data to 8-bit string
             # (FileChunk does not provide read() access)
             orig_data = str(orig_data)
@@ -348,13 +348,14 @@ def modified(self):
         date = DateTime(context._p_mtime)
         return date.millis()
 
-    def scale(self,
-              fieldname=None,
-              scale=None,
-              height=None,
-              width=None,
-              direction='thumbnail',
-              **parameters
+    def scale(
+        self,
+        fieldname=None,
+        scale=None,
+        height=None,
+        width=None,
+        direction='thumbnail',
+        **parameters
     ):
         if fieldname is None:
             primary_field = IPrimaryFieldInfo(self.context, None)
diff --git a/plone/namedfile/storages.py b/plone/namedfile/storages.py
index f3be5ba..1d12e0a 100644
--- a/plone/namedfile/storages.py
+++ b/plone/namedfile/storages.py
@@ -18,9 +18,8 @@ def store(self, data, blob):
         if not isinstance(data, str):
             raise NotStorable('Could not store data (not of "str" type).')
 
-        fp = blob.open('w')
-        fp.write(data)
-        fp.close()
+        with blob.open('w') as fp:
+            fp.write(data)
 
 
 @implementer(IStorage)
@@ -41,12 +40,11 @@ def store(self, data, blob):
         if not isinstance(data, FileChunk):
             raise NotStorable('Could not store data (not a of "FileChunk" type).')  # noqa
 
-        fp = blob.open('w')
-        chunk = data
-        while chunk:
-            fp.write(chunk._data)
-            chunk = chunk.next
-        fp.close()
+        with blob.open('w') as fp:
+            chunk = data
+            while chunk:
+                fp.write(chunk._data)
+                chunk = chunk.next
 
 
 @implementer(IStorage)
@@ -71,9 +69,8 @@ def store(self, data, blob):
 
         data.seek(0)
 
-        fp = blob.open('w')
-        block = data.read(MAXCHUNKSIZE)
-        while block:
-            fp.write(block)
+        with blob.open('w') as fp:
             block = data.read(MAXCHUNKSIZE)
-        fp.close()
+            while block:
+                fp.write(block)
+                block = data.read(MAXCHUNKSIZE)
diff --git a/setup.py b/setup.py
index 5a703b3..9f5f73d 100644
--- a/setup.py
+++ b/setup.py
@@ -4,8 +4,9 @@
 import os
 
 
-version = '3.1.0.dev0'
-description = "File types and fields for images, files and blob files with filenames"  # noqa
+version = '4.0.0.dev0'
+description = 'File types and fields for images, files and blob files with ' \
+              'filenames'
 long_description = ('\n\n'.join([
     open('README.rst').read(),
     open('CHANGES.rst').read(),
@@ -20,7 +21,7 @@
     long_description=long_description,
     classifiers=[
         "Framework :: Plone",
-        "Framework :: Plone :: 5.0",
+        "Framework :: Plone :: 5.1",
         "Programming Language :: Python",
         "Programming Language :: Python :: 2.7",
         "Topic :: Software Development :: Libraries :: Python Modules",
@@ -36,9 +37,11 @@
     include_package_data=True,
     zip_safe=False,
     install_requires=[
-        'setuptools',
         'plone.rfc822>=1.0b2',
-        'zope.app.file',
+        'plone.scale[storage] >=1.4.999',
+        'plone.schemaeditor',
+        'plone.supermodel',
+        'setuptools',
         'zope.browserpage',
         'zope.component',
         'zope.copy',
@@ -46,17 +49,16 @@
         'zope.traversing',
     ],
     extras_require={
-        'editor': ['plone.schemaeditor'],
-        'scales': ['plone.scale[storage] >=1.1'],
-        'supermodel': ['plone.supermodel'],
         'test': [
             'lxml',
             'Pillow',
-            'plone.namedfile[supermodel, scales]',
             'plone.testing[z2]',
         ],
-        # BBB
+        # BBB - remove in version 5
         'blobs': [],
+        'editor': [],
         'marshaler': [],
+        'scales': [],
+        'supermodel': [],
     },
 )


Repository: plone.namedfile


Branch: refs/heads/master
Date: 2016-05-11T19:43:58+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.namedfile/commit/a7c7d91704cc3b56a0925b2b6572b469ad6834f0

pass scale to factory

Files changed:
M plone/namedfile/scaling.py

diff --git a/plone/namedfile/scaling.py b/plone/namedfile/scaling.py
index aeea9f1..4e44efb 100644
--- a/plone/namedfile/scaling.py
+++ b/plone/namedfile/scaling.py
@@ -177,6 +177,7 @@ def __call__(
         direction='thumbnail',
         height=None,
         width=None,
+        scale=None,
         **parameters
     ):
 


Repository: plone.namedfile


Branch: refs/heads/master
Date: 2016-05-12T11:19:49+02:00
Author: agitator (agitator) <hpeter@agitator.com>
Commit: https://github.com/plone/plone.namedfile/commit/a9a09041d9f39f8344d0e8feca67297c42d86702

Merge pull request #24 from plone/scale-factories

use latest plone.scale scaling factories

Files changed:
A plone/namedfile/testing.py
A plone/namedfile/testing.zcml
A plone/namedfile/tests/test_scaling_functional.py
M CHANGES.rst
M plone/namedfile/configure.zcml
M plone/namedfile/handler.py
M plone/namedfile/marshaler.py
M plone/namedfile/scaling.py
M plone/namedfile/scaling.zcml
M plone/namedfile/storages.py
M plone/namedfile/tests/test_blobfile.py
M plone/namedfile/tests/test_doctests.py
M plone/namedfile/tests/test_image.py
M plone/namedfile/tests/test_scaling.py
M plone/namedfile/usage.rst
M setup.py
D plone/namedfile/tests/base.py
D plone/namedfile/tests/testing.zcml

diff --git a/CHANGES.rst b/CHANGES.rst
index b975dd7..2a7b3ab 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,20 +1,34 @@
 Changelog
 =========
 
-3.0.9 (unreleased)
+4.0.0 (unreleased)
 ------------------
 
 Incompatibilities:
 
-- *add item here*
+- Targets Plone 5.1 only, coredev 5.0 and 4.3 are on 3.0.x branch [jensens]:
+
+  - ``plone.supermodel``, ``plone.scale`` and ``plone.schemaeditor`` are now hard depedencies.
+    The extras  in setup.py are kept for bbb reasons, but are empty.
+    Conditional code is now no longer conditional.
+    This simplifies the code a lot.
+
+  - ``zope.app.file`` is no longer hard dependency.
+    If it is there, its FileChunk implementation is still checked for, otherwise not.
+
 
 New:
 
-- *add item here*
+- uses adapter as factory for scales as in plone.scale>=1.5
+  [jensens]
 
 Fixes:
 
-- *add item here*
+- Fixed test setup to use layers properly.
+  [jensens]
+
+- Fixed test isolation problem in ``test_blobfile.py``.
+  [jensens]
 
 
 3.0.8 (2016-02-26)
diff --git a/plone/namedfile/configure.zcml b/plone/namedfile/configure.zcml
index ae665c2..f0f0e29 100644
--- a/plone/namedfile/configure.zcml
+++ b/plone/namedfile/configure.zcml
@@ -18,9 +18,9 @@
       />
 
   <include file="z3c-blobfile.zcml" />
-  <include zcml:condition="installed plone.supermodel" file="handler.zcml" />
-  <include zcml:condition="installed plone.rfc822" file="marshaler.zcml" />
-  <include zcml:condition="installed plone.schemaeditor" file="editor.zcml" />
-  <include zcml:condition="installed plone.scale" file="scaling.zcml" />
+  <include file="handler.zcml" />
+  <include file="marshaler.zcml" />
+  <include file="scaling.zcml" />
+  <include file="editor.zcml" />
 
 </configure>
diff --git a/plone/namedfile/handler.py b/plone/namedfile/handler.py
index 0c50755..2081393 100644
--- a/plone/namedfile/handler.py
+++ b/plone/namedfile/handler.py
@@ -1,23 +1,18 @@
 # -*- coding: utf-8 -*-
-try:
-    from plone.supermodel.exportimport import ObjectHandler
-    HAVE_SUPERMODEL = True
-except ImportError:
-    HAVE_SUPERMODEL = False
+from plone.supermodel.exportimport import ObjectHandler
+from plone.namedfile import field
 
-if HAVE_SUPERMODEL:
-    from plone.namedfile import field
 
-    class FileFieldHandler(ObjectHandler):
-        filteredAttributes = ObjectHandler.filteredAttributes.copy()
-        filteredAttributes.update({
-            'default': 'rw',
-            'missing_value': 'rw',
-            'schema': 'rw'
-        })
+class FileFieldHandler(ObjectHandler):
+    filteredAttributes = ObjectHandler.filteredAttributes.copy()
+    filteredAttributes.update({
+        'default': 'rw',
+        'missing_value': 'rw',
+        'schema': 'rw'
+    })
 
-    NamedFileHandler = FileFieldHandler(field.NamedFile)
-    NamedImageHandler = FileFieldHandler(field.NamedImage)
+NamedFileHandler = FileFieldHandler(field.NamedFile)
+NamedImageHandler = FileFieldHandler(field.NamedImage)
 
-    NamedBlobFileHandler = FileFieldHandler(field.NamedBlobFile)
-    NamedBlobImageHandler = FileFieldHandler(field.NamedBlobImage)
+NamedBlobFileHandler = FileFieldHandler(field.NamedBlobFile)
+NamedBlobImageHandler = FileFieldHandler(field.NamedBlobImage)
diff --git a/plone/namedfile/marshaler.py b/plone/namedfile/marshaler.py
index 4602664..92c3196 100644
--- a/plone/namedfile/marshaler.py
+++ b/plone/namedfile/marshaler.py
@@ -1,100 +1,98 @@
 # -*- coding: utf-8 -*-
-try:
-    from plone.rfc822.defaultfields import BaseFieldMarshaler
-    HAVE_MARSHALER = True
-except ImportError:
-    HAVE_MARSHALER = False
-
-if HAVE_MARSHALER:
-
-    from email.Encoders import encode_base64
-    from plone.namedfile import NamedBlobFile
-    from plone.namedfile import NamedBlobImage
-    from plone.namedfile import NamedFile
-    from plone.namedfile import NamedImage
-    from plone.namedfile.interfaces import INamedBlobFileField
-    from plone.namedfile.interfaces import INamedBlobImageField
-    from plone.namedfile.interfaces import INamedFileField
-    from plone.namedfile.interfaces import INamedImageField
-    from zope.component import adapter
-    from zope.interface import Interface
-
-    class BaseNamedFileFieldMarshaler(BaseFieldMarshaler):
-        """Base marshaler for plone.namedfile values. Actual adapters are
-        registered as subclasses.
-        """
+from email.Encoders import encode_base64
+from plone.namedfile import NamedBlobFile
+from plone.namedfile import NamedBlobImage
+from plone.namedfile import NamedFile
+from plone.namedfile import NamedImage
+from plone.namedfile.interfaces import INamedBlobFileField
+from plone.namedfile.interfaces import INamedBlobImageField
+from plone.namedfile.interfaces import INamedFileField
+from plone.namedfile.interfaces import INamedImageField
+from plone.rfc822.defaultfields import BaseFieldMarshaler
+from zope.component import adapter
+from zope.interface import Interface
+
+
+class BaseNamedFileFieldMarshaler(BaseFieldMarshaler):
+    """Base marshaler for plone.namedfile values. Actual adapters are
+    registered as subclasses.
+    """
 
-        ascii = False
-        factory = None
-
-        def encode(self, value, charset='utf-8', primary=False):
-            # we only support encoding a file value in the body of a message,
-            # never in a header
-            if not primary:
-                raise ValueError(
-                    'File fields can only be marshaled as primary fields')
-            if value is None:
-                return None
-            return value.data
-
-        def decode(
-                self,
-                value,
-                message=None,
-                charset='utf-8',
-                contentType=None,
-                primary=False):
-            filename = None
-            if primary and message is not None:
-                filename = message.get_filename(None)
-            return self.factory(value, contentType or '', filename)
-
-        def getContentType(self):
-            value = self._query()
-            if value is None:
-                return None
-            return value.contentType
-
-        def getCharset(self, default='utf-8'):
+    ascii = False
+    factory = None
+
+    def encode(self, value, charset='utf-8', primary=False):
+        # we only support encoding a file value in the body of a message,
+        # never in a header
+        if not primary:
+            raise ValueError(
+                'File fields can only be marshaled as primary fields')
+        if value is None:
             return None
+        return value.data
 
-        def postProcessMessage(self, message):
-            """Encode message as base64 and set content disposition
-            """
-            value = self._query()
-            if value is not None:
-                filename = value.filename
-                if filename:
-                    message.add_header('Content-Disposition', 'attachment')
-                    message.set_param(
-                        'filename',
-                        filename.encode('utf-8'),
-                        header='Content-Disposition',
-                        charset='utf-8'
-                    )
-
-            encode_base64(message)
-
-    @adapter(Interface, INamedFileField)
-    class NamedFileFieldMarshaler(BaseNamedFileFieldMarshaler):
-        """Marshaler for an INamedFile field
-        """
-        factory = NamedFile
+    def decode(
+            self,
+            value,
+            message=None,
+            charset='utf-8',
+            contentType=None,
+            primary=False):
+        filename = None
+        if primary and message is not None:
+            filename = message.get_filename(None)
+        return self.factory(value, contentType or '', filename)
 
-    @adapter(Interface, INamedImageField)
-    class NamedImageFieldMarshaler(BaseNamedFileFieldMarshaler):
-        """Marshaler for an INamedImage field
-        """
-        factory = NamedImage
+    def getContentType(self):
+        value = self._query()
+        if value is None:
+            return None
+        return value.contentType
 
-    @adapter(Interface, INamedBlobFileField)
-    class NamedBlobFileFieldMarshaler(BaseNamedFileFieldMarshaler):
-        """Marshaler for an INamedBlobFile field
-        """
-        factory = NamedBlobFile
+    def getCharset(self, default='utf-8'):
+        return None
 
-    @adapter(Interface, INamedBlobImageField)
-    class NamedBlobImageFieldMarshaler(BaseNamedFileFieldMarshaler):
-        """Marshaler for an INamedBlobImage field
+    def postProcessMessage(self, message):
+        """Encode message as base64 and set content disposition
         """
-        factory = NamedBlobImage
+        value = self._query()
+        if value is not None:
+            filename = value.filename
+            if filename:
+                message.add_header('Content-Disposition', 'attachment')
+                message.set_param(
+                    'filename',
+                    filename.encode('utf-8'),
+                    header='Content-Disposition',
+                    charset='utf-8'
+                )
+
+        encode_base64(message)
+
+
+@adapter(Interface, INamedFileField)
+class NamedFileFieldMarshaler(BaseNamedFileFieldMarshaler):
+    """Marshaler for an INamedFile field
+    """
+    factory = NamedFile
+
+
+@adapter(Interface, INamedImageField)
+class NamedImageFieldMarshaler(BaseNamedFileFieldMarshaler):
+    """Marshaler for an INamedImage field
+    """
+    factory = NamedImage
+
+
+@adapter(Interface, INamedBlobFileField)
+class NamedBlobFileFieldMarshaler(BaseNamedFileFieldMarshaler):
+    """Marshaler for an INamedBlobFile field
+    """
+    factory = NamedBlobFile
+
+
+@adapter(Interface, INamedBlobImageField)
+class NamedBlobImageFieldMarshaler(BaseNamedFileFieldMarshaler):
+    """Marshaler for an INamedBlobImage field
+    """
+    factory = NamedBlobImage
diff --git a/plone/namedfile/scaling.py b/plone/namedfile/scaling.py
index c60bb42..4e44efb 100644
--- a/plone/namedfile/scaling.py
+++ b/plone/namedfile/scaling.py
@@ -3,18 +3,22 @@
 from Acquisition import aq_base
 from DateTime import DateTime
 from logging import exception
+from plone.namedfile.file import FILECHUNK_CLASSES
 from plone.namedfile.interfaces import IAvailableSizes
 from plone.namedfile.interfaces import IStableImageScale
 from plone.namedfile.utils import set_headers
 from plone.namedfile.utils import stream_data
+from plone.protect.interfaces import IDisableCSRFProtection
 from plone.rfc822.interfaces import IPrimaryFieldInfo
+from plone.scale.interfaces import IImageScaleFactory
+from plone.scale.interfaces import IScaledImageQuality
 from plone.scale.scale import scaleImage
 from plone.scale.storage import AnnotationStorage
 from Products.Five import BrowserView
 from xml.sax.saxutils import quoteattr
 from ZODB.POSException import ConflictError
-from zope.app.file.file import FileChunk
 from zope.component import queryUtility
+from zope.deprecation import deprecate
 from zope.interface import alsoProvides
 from zope.interface import implementer
 from zope.publisher.interfaces import IPublishTraverse
@@ -22,17 +26,10 @@
 from zope.traversing.interfaces import ITraversable
 from zope.traversing.interfaces import TraversalError
 
-import pkg_resources
+import logging
 
 
-try:
-    pkg_resources.get_distribution('plone.protect>=3.0')
-except (pkg_resources.DistributionNotFound, pkg_resources.VersionConflict):
-    IDisableCSRFProtection = None
-else:
-    # Soft dependency to make this package work without plone.protect
-    from plone.protect.interfaces import IDisableCSRFProtection
-
+logger = logging.getLogger(__name__)
 _marker = object()
 
 
@@ -152,6 +149,100 @@ def traverse(self, name, furtherPath):
                 raise TraversalError(name)
 
 
+@implementer(IImageScaleFactory)
+class DefaultImageScalingFactory(object):
+
+    def __init__(self, context):
+        self.context = context
+
+    def get_quality(self):
+        """Get plone.app.imaging's quality setting"""
+        getScaledImageQuality = queryUtility(IScaledImageQuality)
+        if getScaledImageQuality is None:
+            return None
+        return getScaledImageQuality()
+
+    def create_scale(self, data, direction, height, width, **parameters):
+        return scaleImage(
+            data,
+            direction=direction,
+            height=height,
+            width=width,
+            **parameters
+        )
+
+    def __call__(
+        self,
+        fieldname=None,
+        direction='thumbnail',
+        height=None,
+        width=None,
+        scale=None,
+        **parameters
+    ):
+
+        """Factory for image scales`.
+        """
+        orig_value = getattr(self.context, fieldname)
+        if orig_value is None:
+            return
+
+        if height is None and width is None:
+            dummy, format_ = orig_value.contentType.split('/', 1)
+            return None, format_, (orig_value._width, orig_value._height)
+        orig_data = None
+        try:
+            orig_data = orig_value.open()
+        except AttributeError:
+            orig_data = getattr(aq_base(orig_value), 'data', orig_value)
+        if not orig_data:
+            return
+
+        # Handle cases where large image data is stored in FileChunks instead
+        # of plain string
+        if isinstance(orig_data, tuple(FILECHUNK_CLASSES)):
+            # Convert data to 8-bit string
+            # (FileChunk does not provide read() access)
+            orig_data = str(orig_data)
+
+        # If quality wasn't in the parameters, try the site's default scaling
+        # quality if it exists.
+        if 'quality' not in parameters:
+            quality = self.get_quality()
+            if quality:
+                parameters['quality'] = quality
+
+        try:
+            result = self.create_scale(
+                orig_data,
+                direction=direction,
+                height=height,
+                width=width,
+                **parameters
+            )
+        except (ConflictError, KeyboardInterrupt):
+            raise
+        except Exception:
+            exception(
+                'Could not scale "%r" of %r',
+                orig_value,
+                self.context.absolute_url()
+            )
+            return
+        if result is None:
+            return
+
+        data, format_, dimensions = result
+        mimetype = u'image/{0}'.format(format_.lower())
+        value = orig_value.__class__(
+            data,
+            contentType=mimetype,
+            filename=orig_value.filename
+        )
+        value.fieldname = fieldname
+        return value, format_, dimensions
+
+
 @implementer(ITraversable, IPublishTraverse)
 class ImageScaling(BrowserView):
     """ view used for generating (and storing) image scales """
@@ -166,27 +257,32 @@ def publishTraverse(self, request, name):
         if stack and stack[-1] not in self._ignored_stacks:
             # field and scale name were given...
             scale = stack.pop()
-            image = self.scale(name, scale)             # this is aq-wrapped
+            image = self.scale(name, scale)  # this is an aq-wrapped scale_view
+            if image:
+                return image
         elif '-' in name:
             # we got a uid...
             if '.' in name:
                 name, ext = name.rsplit('.', 1)
             storage = AnnotationStorage(self.context)
             info = storage.get(name)
-            if info is not None:
-                scale_view = ImageScale(self.context, self.request, **info)
-                alsoProvides(scale_view, IStableImageScale)
-                return scale_view.__of__(self.context)
+            if info is None:
+                raise NotFound(self, name, self.request)
+            scale_view = ImageScale(self.context, self.request, **info)
+            alsoProvides(scale_view, IStableImageScale)
+            return scale_view.__of__(self.context)
         else:
             # otherwise `name` must refer to a field...
             if '.' in name:
                 name, ext = name.rsplit('.', 1)
             value = getattr(self.context, name)
             scale_view = ImageScale(
-                self.context, self.request, data=value, fieldname=name)
+                self.context,
+                self.request,
+                data=value,
+                fieldname=name
+            )
             return scale_view.__of__(self.context)
-        if image is not None:
-            return image
         raise NotFound(self, name, self.request)
 
     def traverse(self, name, furtherPath):
@@ -195,7 +291,11 @@ def traverse(self, name, furtherPath):
         value = self.guarded_orig_image(name)
         if not furtherPath:
             image = ImageScale(
-                self.context, self.request, data=value, fieldname=name)
+                self.context,
+                self.request,
+                data=value,
+                fieldname=name
+            )
         else:
             return ImmutableTraverser(self.scale(name, furtherPath[-1]))
 
@@ -205,21 +305,30 @@ def traverse(self, name, furtherPath):
 
     _sizes = {}
 
+    @deprecate('use property available_sizes instead')
     def getAvailableSizes(self, fieldname=None):
+        if fieldname:
+            logger.warn(
+                'fieldname was passed to deprecated getAvailableSizes, but '
+                'will be ignored.'
+            )
+        return self.available_sizes
+
+    @property
+    def available_sizes(self):
         # fieldname is ignored by default
-        getAvailableSizes = queryUtility(IAvailableSizes)
-        if getAvailableSizes is None:
+        sizes_util = queryUtility(IAvailableSizes)
+        if sizes_util is None:
             return self._sizes
-        sizes = getAvailableSizes()
+        sizes = sizes_util()
         if sizes is None:
             return {}
         return sizes
 
-    def _set_sizes(self, value):
+    @available_sizes.setter
+    def available_sizes(self, value):
         self._sizes = value
 
-    available_sizes = property(getAvailableSizes, _set_sizes)
-
     def getImageSize(self, fieldname=None):
         if fieldname is not None:
             value = self.guarded_orig_image(fieldname)
@@ -232,76 +341,6 @@ def getImageSize(self, fieldname=None):
     def guarded_orig_image(self, fieldname):
         return guarded_getattr(self.context, fieldname, None)
 
-    def getQuality(self):
-        """Get plone.app.imaging's quality setting"""
-        # Avoid dependening on version where interface first
-        # appeared.
-        try:
-            from plone.scale.interfaces import IScaledImageQuality
-        except ImportError:
-            return None
-        getScaledImageQuality = queryUtility(IScaledImageQuality)
-        if getScaledImageQuality is None:
-            return None
-        return getScaledImageQuality()
-
-    def create(self,
-               fieldname,
-               direction='thumbnail',
-               height=None,
-               width=None,
-               **parameters):
-        """Factory for image scales, see `IImageScaleStorage.scale`.
-        """
-        orig_value = getattr(self.context, fieldname)
-        if orig_value is None:
-            return
-
-        if height is None and width is None:
-            _, format_ = orig_value.contentType.split('/', 1)
-            return None, format_, (orig_value._width, orig_value._height)
-        orig_data = None
-        try:
-            orig_data = orig_value.open()
-        except AttributeError:
-            orig_data = getattr(aq_base(orig_value), 'data', orig_value)
-        if not orig_data:
-            return
-
-        # Handle cases where large image data is stored in FileChunks instead
-        # of plain string
-        if isinstance(orig_data, FileChunk):
-            # Convert data to 8-bit string
-            # (FileChunk does not provide read() access)
-            orig_data = str(orig_data)
-
-        # If quality wasn't in the parameters, try the site's default scaling
-        # quality if it exists.
-        if 'quality' not in parameters:
-            quality = self.getQuality()
-            if quality:
-                parameters['quality'] = quality
-
-        try:
-            result = scaleImage(orig_data,
-                                direction=direction,
-                                height=height,
-                                width=width,
-                                **parameters)
-        except (ConflictError, KeyboardInterrupt):
-            raise
-        except Exception:
-            exception('could not scale "%r" of %r',
-                      orig_value, self.context.absolute_url())
-            return
-        if result is not None:
-            data, format_, dimensions = result
-            mimetype = u'image/{0}'.format(format_.lower())
-            value = orig_value.__class__(
-                data, contentType=mimetype, filename=orig_value.filename)
-            value.fieldname = fieldname
-            return value, format_, dimensions
-
     def modified(self):
         """Provide a callable to return the modification time of content
         items, so stored image scales can be invalidated.
@@ -310,43 +349,55 @@ def modified(self):
         date = DateTime(context._p_mtime)
         return date.millis()
 
-    def scale(self,
-              fieldname=None,
-              scale=None,
-              height=None,
-              width=None,
-              direction='thumbnail',
-              **parameters):
+    def scale(
+        self,
+        fieldname=None,
+        scale=None,
+        height=None,
+        width=None,
+        direction='thumbnail',
+        **parameters
+    ):
         if fieldname is None:
-            fieldname = IPrimaryFieldInfo(self.context).fieldname
+            primary_field = IPrimaryFieldInfo(self.context, None)
+            if primary_field is None:
+                return  # 404
+            fieldname = primary_field.fieldname
         if scale is not None:
-            available = self.getAvailableSizes(fieldname)
+            if width is not None or height is not None:
+                logger.warn(
+                    'A scale name and width/heigth are given. Those are'
+                    'mutually exclusive: solved by ignoring width/heigth and '
+                    'taking name'
+                )
+            available = self.available_sizes
             if scale not in available:
-                return None
+                return None  # 404
             width, height = available[scale]
-
         if IDisableCSRFProtection and self.request is not None:
             alsoProvides(self.request, IDisableCSRFProtection)
-
         storage = AnnotationStorage(self.context, self.modified)
-        info = storage.scale(factory=self.create,
-                             fieldname=fieldname,
-                             height=height,
-                             width=width,
-                             direction=direction,
-                             **parameters)
-
-        if info is not None:
-            info['fieldname'] = fieldname
-            scale_view = ImageScale(self.context, self.request, **info)
-            return scale_view.__of__(self.context)
-
-    def tag(self,
-            fieldname=None,
-            scale=None,
-            height=None,
-            width=None,
-            direction='thumbnail',
-            **kwargs):
+        info = storage.scale(
+            fieldname=fieldname,
+            height=height,
+            width=width,
+            direction=direction,
+            **parameters
+        )
+        if info is None:
+            return  # 404
+        info['fieldname'] = fieldname
+        scale_view = ImageScale(self.context, self.request, **info)
+        return scale_view.__of__(self.context)
+
+    def tag(
+        self,
+        fieldname=None,
+        scale=None,
+        height=None,
+        width=None,
+        direction='thumbnail',
+        **kwargs
+    ):
         scale = self.scale(fieldname, scale, height, width, direction)
         return scale.tag(**kwargs) if scale else None
diff --git a/plone/namedfile/scaling.zcml b/plone/namedfile/scaling.zcml
index a962979..07b4099 100644
--- a/plone/namedfile/scaling.zcml
+++ b/plone/namedfile/scaling.zcml
@@ -1,15 +1,16 @@
 <configure
     xmlns="http://namespaces.zope.org/zope"
     xmlns:browser="http://namespaces.zope.org/browser">
-
-  <include package="zope.annotation"/>
-
+  <include package="zope.annotation" />
   <browser:page
-      name="images"
-      for=".interfaces.IImageScaleTraversable"
-      class=".scaling.ImageScaling"
       allowed_attributes="scale"
+      class=".scaling.ImageScaling"
+      for=".interfaces.IImageScaleTraversable"
+      name="images"
       permission="zope2.View"
-      />
-
+  />
+  <adapter
+      factory=".scaling.DefaultImageScalingFactory"
+      for="*"
+  />
 </configure>
diff --git a/plone/namedfile/storages.py b/plone/namedfile/storages.py
index f3be5ba..1d12e0a 100644
--- a/plone/namedfile/storages.py
+++ b/plone/namedfile/storages.py
@@ -18,9 +18,8 @@ def store(self, data, blob):
         if not isinstance(data, str):
             raise NotStorable('Could not store data (not of "str" type).')
 
-        fp = blob.open('w')
-        fp.write(data)
-        fp.close()
+        with blob.open('w') as fp:
+            fp.write(data)
 
 
 @implementer(IStorage)
@@ -41,12 +40,11 @@ def store(self, data, blob):
         if not isinstance(data, FileChunk):
             raise NotStorable('Could not store data (not a of "FileChunk" type).')  # noqa
 
-        fp = blob.open('w')
-        chunk = data
-        while chunk:
-            fp.write(chunk._data)
-            chunk = chunk.next
-        fp.close()
+        with blob.open('w') as fp:
+            chunk = data
+            while chunk:
+                fp.write(chunk._data)
+                chunk = chunk.next
 
 
 @implementer(IStorage)
@@ -71,9 +69,8 @@ def store(self, data, blob):
 
         data.seek(0)
 
-        fp = blob.open('w')
-        block = data.read(MAXCHUNKSIZE)
-        while block:
-            fp.write(block)
+        with blob.open('w') as fp:
             block = data.read(MAXCHUNKSIZE)
-        fp.close()
+            while block:
+                fp.write(block)
+                block = data.read(MAXCHUNKSIZE)
diff --git a/plone/namedfile/testing.py b/plone/namedfile/testing.py
new file mode 100644
index 0000000..e716aab
--- /dev/null
+++ b/plone/namedfile/testing.py
@@ -0,0 +1,43 @@
+# -*- coding: utf-8 -*-
+from plone.testing import Layer
+from plone.testing import publisher
+from plone.testing import z2
+from plone.testing import zca
+from plone.testing import zodb
+from zope.configuration import xmlconfig
+
+
+class NamedFileTestLayer(Layer):
+
+    defaultBases = (z2.STARTUP, publisher.PUBLISHER_DIRECTIVES)
+
+    def setUp(self):
+        zca.pushGlobalRegistry()
+
+        import plone.namedfile
+        xmlconfig.file('testing.zcml', plone.namedfile)
+
+        self['zodbDB'] = zodb.stackDemoStorage(
+            self.get('zodbDB'),
+            name='NamedFileFixture'
+        )
+
+    def tearDown(self):
+        # Zap the stacked ZODB
+        self['zodbDB'].close()
+        del self['zodbDB']
+
+        # Zap the stacked zca context
+        zca.popGlobalRegistry()
+
+PLONE_NAMEDFILE_FIXTURE = NamedFileTestLayer()
+
+PLONE_NAMEDFILE_INTEGRATION_TESTING = z2.IntegrationTesting(
+    bases=(PLONE_NAMEDFILE_FIXTURE,),
+    name="plone.namedfile:NamedFileTestLayerIntegration"
+)
+
+PLONE_NAMEDFILE_FUNCTIONAL_TESTING = z2.FunctionalTesting(
+    bases=(PLONE_NAMEDFILE_FIXTURE,),
+    name="plone.namedfile:NamedFileTestLayerFunctional"
+)
diff --git a/plone/namedfile/testing.zcml b/plone/namedfile/testing.zcml
new file mode 100644
index 0000000..c8ac4f0
--- /dev/null
+++ b/plone/namedfile/testing.zcml
@@ -0,0 +1,12 @@
+<configure xmlns="http://namespaces.zope.org/zope">
+
+  <include package="zope.security" file="meta.zcml" />
+  <include package="zope.component" file="meta.zcml" />
+  <include package="zope.browserpage" file="meta.zcml" />
+  <include package="zope.traversing" file="configure.zcml" />
+
+  <permission id="zope2.View" title="View" />
+
+  <include package="plone.namedfile" />
+
+</configure>
diff --git a/plone/namedfile/tests/base.py b/plone/namedfile/tests/base.py
deleted file mode 100644
index 53e6a1c..0000000
--- a/plone/namedfile/tests/base.py
+++ /dev/null
@@ -1,62 +0,0 @@
-# -*- coding: utf-8 -*-
-from StringIO import StringIO
-from Testing import ZopeTestCase as ztc
-from Testing.testbrowser import Browser
-from zope.component import testing
-from zope.configuration import xmlconfig
-
-import os
-import PIL.Image
-
-
-def getFile(filename):
-    """ return contents of the file with the given name """
-    filename = os.path.join(os.path.dirname(__file__), filename)
-    return open(filename, 'r')
-
-
-def setUp(self=None):
-    testing.setUp()
-    xmlconfig.xmlconfig(getFile('testing.zcml'))
-
-
-class NamedFileLayer:
-    setUp = classmethod(setUp)
-    tearDown = classmethod(testing.tearDown)
-
-try:
-    from Testing.ZopeTestCase.layer import ZopeLite
-except ImportError:
-    pass
-else:
-    NamedFileLayer.__bases__ = (ZopeLite,)
-
-
-class ImageTestMixin(object):
-
-    def assertImage(self, data, format_, size):
-        image = PIL.Image.open(StringIO(data))
-        self.assertEqual(image.format, format_)
-        self.assertEqual(image.size, size)
-
-
-class NamedFileTestCase(ztc.TestCase, ImageTestMixin):
-    layer = NamedFileLayer
-
-
-class NamedFileFunctionalTestCase(
-        ztc.Functional,
-        ztc.ZopeTestCase,
-        ImageTestMixin):
-    layer = NamedFileLayer
-
-    def getCredentials(self):
-        return u'{0}:{0}'.format(ztc.user_name, ztc.user_password)
-
-    def getBrowser(self, loggedIn=True):
-        """ instantiate and return a testbrowser for convenience """
-        browser = Browser()
-        if loggedIn:
-            auth = u'Basic {0}'.format(self.getCredentials())
-            browser.addHeader('Authorization', auth)
-        return browser
diff --git a/plone/namedfile/tests/test_blobfile.py b/plone/namedfile/tests/test_blobfile.py
index 346766d..020fafb 100644
--- a/plone/namedfile/tests/test_blobfile.py
+++ b/plone/namedfile/tests/test_blobfile.py
@@ -22,7 +22,8 @@
 from plone.namedfile.interfaces import INamedBlobFile
 from plone.namedfile.interfaces import INamedBlobImage
 from plone.namedfile.interfaces import IStorage
-from plone.namedfile.tests.base import NamedFileLayer
+from plone.namedfile.testing import PLONE_NAMEDFILE_INTEGRATION_TESTING
+from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING
 from plone.namedfile.tests.test_image import zptlogo
 from zope.component import provideUtility
 from zope.interface.verify import verifyClass
@@ -33,15 +34,31 @@
 
 
 def registerUtilities():
-    provideUtility(storages.StringStorable(), IStorage, name="__builtin__.str")  # noqa
-    provideUtility(storages.UnicodeStorable(), IStorage, name="__builtin__.unicode")  # noqa
-    provideUtility(storages.FileChunkStorable(), IStorage, name="plone.namedfile.file.FileChunk")  # noqa
-    provideUtility(storages.FileDescriptorStorable(), IStorage, name="__builtin__.file")  # noqa
+    provideUtility(
+        storages.StringStorable(),
+        IStorage,
+        name="__builtin__.str"
+    )
+    provideUtility(
+        storages.UnicodeStorable(),
+        IStorage,
+        name="__builtin__.unicode"
+    )
+    provideUtility(
+        storages.FileChunkStorable(),
+        IStorage,
+        name="plone.namedfile.file.FileChunk"
+    )
+    provideUtility(
+        storages.FileDescriptorStorable(),
+        IStorage,
+        name="__builtin__.file"
+    )
 
 
 class TestImage(unittest.TestCase):
 
-    layer = NamedFileLayer
+    layer = PLONE_NAMEDFILE_INTEGRATION_TESTING
 
     def setUp(self):
         registerUtilities()
@@ -87,6 +104,14 @@ def testDataMutatorWithLargeHeader(self):
         image._setData(data)
         self.assertEqual(image.getImageSize(), (1024, 680))
 
+
+class TestImageFunctional(unittest.TestCase):
+
+    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING
+
+    def setUp(self):
+        registerUtilities()
+
     def testCopyBlobs(self):
         from zope.copy import copy
         file = NamedBlobFile()
diff --git a/plone/namedfile/tests/test_doctests.py b/plone/namedfile/tests/test_doctests.py
index 81fd07a..6be6cb7 100644
--- a/plone/namedfile/tests/test_doctests.py
+++ b/plone/namedfile/tests/test_doctests.py
@@ -1,33 +1,32 @@
 # -*- coding: utf-8 -*-
-from plone.namedfile.tests.base import setUp
-from zope.component.testing import tearDown
+from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING
+from plone.testing import layered
+
 
 import doctest
 import unittest
 
+TEST_FILES = [
+    'usage.rst',
+    'handler.rst',
+    'marshaler.rst',
+    'utils.rst',
+]
 
-def test_suite():
-    return unittest.TestSuite([
-
-        doctest.DocFileSuite(
-            'usage.rst', package='plone.namedfile',
-            setUp=setUp, tearDown=tearDown),
-
-        doctest.DocFileSuite(
-            'handler.rst', package='plone.namedfile',
-            setUp=setUp, tearDown=tearDown),
 
-        doctest.DocFileSuite(
-            'marshaler.rst', package='plone.namedfile',
-            setUp=setUp, tearDown=tearDown),
-
-        doctest.DocFileSuite(
-            'utils.rst', package='plone.namedfile',
-            setUp=setUp, tearDown=tearDown),
-
-        doctest.DocTestSuite('plone.namedfile.file'),
-
-    ])
+def test_suite():
+    return unittest.TestSuite(
+        [
+            layered(
+                doctest.DocFileSuite(
+                    testfile,
+                    package='plone.namedfile',
+                ),
+                PLONE_NAMEDFILE_FUNCTIONAL_TESTING
+            ) for testfile in TEST_FILES
+        ]
+
+    )
 
 if __name__ == '__main__':
     unittest.main(defaultTest='test_suite')
diff --git a/plone/namedfile/tests/test_image.py b/plone/namedfile/tests/test_image.py
index cd03c11..a067141 100644
--- a/plone/namedfile/tests/test_image.py
+++ b/plone/namedfile/tests/test_image.py
@@ -3,13 +3,18 @@
 
 from plone.namedfile.file import NamedImage
 from plone.namedfile.interfaces import INamedImage
-from plone.namedfile.tests.base import getFile
 from plone.namedfile.utils import get_contenttype
 from zope.interface.verify import verifyClass
 
 import unittest
+import os
 
 
+def getFile(filename):
+    """ return contents of the file with the given name """
+    filename = os.path.join(os.path.dirname(__file__), filename)
+    return open(filename, 'r')
+
 zptlogo = (
     'GIF89a\x10\x00\x10\x00\xd5\x00\x00\xff\xff\xff\xff\xff\xfe\xfc\xfd\xfd'
     '\xfa\xfb\xfc\xf7\xf9\xfa\xf5\xf8\xf9\xf3\xf6\xf8\xf2\xf5\xf7\xf0\xf4\xf6'
diff --git a/plone/namedfile/tests/test_scaling.py b/plone/namedfile/tests/test_scaling.py
index 9eeaf31..a7a83bc 100644
--- a/plone/namedfile/tests/test_scaling.py
+++ b/plone/namedfile/tests/test_scaling.py
@@ -6,18 +6,27 @@
 from plone.namedfile.interfaces import IAvailableSizes
 from plone.namedfile.interfaces import IImageScaleTraversable
 from plone.namedfile.scaling import ImageScaling
-from plone.namedfile.tests.base import getFile
-from plone.namedfile.tests.base import NamedFileFunctionalTestCase
-from plone.namedfile.tests.base import NamedFileTestCase
+from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING
+from plone.namedfile.testing import PLONE_NAMEDFILE_INTEGRATION_TESTING
 from plone.scale.interfaces import IScaledImageQuality
+from StringIO import StringIO
 from zExceptions import Unauthorized
 from zope.annotation import IAttributeAnnotatable
 from zope.component import getGlobalSiteManager
 from zope.component import getSiteManager
 from zope.interface import implementer
 
+import os
+import PIL
 import re
 import time
+import unittest
+
+
+def getFile(filename):
+    """ return contents of the file with the given name """
+    filename = os.path.join(os.path.dirname(__file__), filename)
+    return open(filename, 'r')
 
 
 def wait_to_ensure_modified():
@@ -30,6 +39,12 @@ class IHasImage(IImageScaleTraversable):
     image = NamedImageField()
 
 
+def assertImage(testcase, data, format_, size):
+    image = PIL.Image.open(StringIO(data))
+    testcase.assertEqual(image.format, format_)
+    testcase.assertEqual(image.size, size)
+
+
 @implementer(IAttributeAnnotatable, IHasImage)
 class DummyContent(SimpleItem):
     image = None
@@ -49,15 +64,17 @@ def getQuality(self):
         return 1  # as bad as it gets
 
 
-class ImageScalingTests(NamedFileTestCase):
+class ImageScalingTests(unittest.TestCase):
 
-    def afterSetUp(self):
+    layer = PLONE_NAMEDFILE_INTEGRATION_TESTING
+
+    def setUp(self):
         data = getFile('image.gif').read()
         item = DummyContent()
         item.image = NamedImage(data, 'image/gif', u'image.gif')
-        self.app._setOb('item', item)
-        self.item = self.app.item
-        self.scaling = ImageScaling(self.app.item, None)
+        self.layer['app']._setOb('item', item)
+        self.item = self.layer['app'].item
+        self.scaling = ImageScaling(self.item, None)
 
     def testCreateScale(self):
         foo = self.scaling.scale('image', width=100, height=80)
@@ -65,7 +82,7 @@ def testCreateScale(self):
         self.assertEqual(foo.mimetype, 'image/jpeg')
         self.assertEqual(foo.width, 80)
         self.assertEqual(foo.height, 80)
-        self.assertImage(foo.data.data, 'JPEG', (80, 80))
+        assertImage(self, foo.data.data, 'JPEG', (80, 80))
 
     def testCreateScaleWithoutData(self):
         item = DummyContent()
@@ -80,7 +97,7 @@ def testGetScaleByName(self):
         self.assertEqual(foo.mimetype, 'image/jpeg')
         self.assertEqual(foo.width, 60)
         self.assertEqual(foo.height, 60)
-        self.assertImage(foo.data.data, 'JPEG', (60, 60))
+        assertImage(self, foo.data.data, 'JPEG', (60, 60))
         expected_url = re.compile(
             r'http://nohost/item/@@images/[-a-z0-9]{36}\.jpeg')
         self.assertTrue(expected_url.match(foo.absolute_url()))
@@ -191,9 +208,12 @@ def testScaledImageQuality(self):
         self.assertTrue(size_foo > size_bar)
 
 
-class ImageTraverseTests(NamedFileTestCase):
+class ImageTraverseTests(unittest.TestCase):
+
+    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING
 
-    def afterSetUp(self):
+    def setUp(self):
+        self.app = self.layer['app']
         data = getFile('image.gif').read()
         item = DummyContent()
         item.image = NamedImage(data, 'image/gif', u'image.gif')
@@ -201,7 +221,7 @@ def afterSetUp(self):
         self.item = self.app.item
         self._orig_sizes = ImageScaling._sizes
 
-    def beforeTearDown(self):
+    def tearDown(self):
         ImageScaling._sizes = self._orig_sizes
 
     def traverse(self, path=''):
@@ -270,146 +290,6 @@ def testGuardedAccess(self):
         self.item.__allow_access_to_unprotected_subobjects__ = 1
 
 
-class ImagePublisherTests(NamedFileFunctionalTestCase):
-
-    def afterSetUp(self):
-        data = getFile('image.gif').read()
-        item = DummyContent()
-        item.image = NamedImage(data, 'image/gif', u'image.gif')
-        self.app._setOb('item', item)
-        self.item = self.app.item
-        self.view = self.item.unrestrictedTraverse('@@images')
-        self._orig_sizes = ImageScaling._sizes
-
-    def beforeTearDown(self):
-        ImageScaling._sizes = self._orig_sizes
-
-    def testPublishScaleViaUID(self):
-        scale = self.view.scale('image', width=64, height=64)
-        # make sure the referenced image scale is available
-        url = scale.url.replace('http://nohost', '')
-        response = self.publish(url, basic=self.getCredentials())
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertImage(response.getBody(), 'JPEG', (64, 64))
-
-    def testPublishWebDavScaleViaUID(self):
-        scale = self.view.scale('image', width=64, height=64)
-        # make sure the referenced image scale is available
-        url = scale.url.replace('http://nohost', '') + '/manage_DAVget'
-        response = self.publish(url, basic=self.getCredentials())
-        self.assertEqual(response.getStatus(), 200)
-        # In plone.app.imaging we get a very different response, which in the
-        # end works out.  It is a bit unclear which of the two responses is
-        # wanted.
-        # self.assertEqual(response.getHeader('Content-Type'),
-        #                  'text/plain; charset=iso-8859-15')
-        # self.assertImage(response.getBody(), 'JPEG', (64, 64))
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertImage(response.getBody(), 'JPEG', (64, 64))
-
-    def testPublishFTPScaleViaUID(self):
-        scale = self.view.scale('image', width=64, height=64)
-        # make sure the referenced image scale is available
-        url = scale.url.replace('http://nohost', '') + '/manage_FTPget'
-        response = self.publish(url, basic=self.getCredentials())
-        self.assertEqual(response.getStatus(), 200)
-        # Same remark as in testPublishWebDavScaleViaUID is valid here.
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertImage(response.getBody(), 'JPEG', (64, 64))
-
-    def testHeadRequestMethod(self):
-        scale = self.view.scale('image', width=64, height=64)
-        # make sure the referenced image scale is available
-        url = scale.url.replace('http://nohost', '')
-        get_response = self.publish(url, basic=self.getCredentials())
-        response = self.publish(url,
-                                basic=self.getCredentials(),
-                                request_method='HEAD')
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertEqual(
-            response.getHeader('Content-Length'),
-            str(len(get_response.getBody()))
-        )
-        self.assertEqual(response.getBody(), '')
-
-    def testPublishThumbViaUID(self):
-        ImageScaling._sizes = {'thumb': (128, 128)}
-        scale = self.view.scale('image', 'thumb')
-        # make sure the referenced image scale is available
-        url = scale.url.replace('http://nohost', '')
-        response = self.publish(url, basic=self.getCredentials())
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertImage(response.getBody(), 'JPEG', (128, 128))
-
-    def testPublishCustomSizeViaUID(self):
-        # set custom image sizes
-        ImageScaling._sizes = {'foo': (23, 23)}
-        scale = self.view.scale('image', 'foo')
-        # make sure the referenced image scale is available
-        url = scale.url.replace('http://nohost', '')
-        response = self.publish(url, basic=self.getCredentials())
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertImage(response.getBody(), 'JPEG', (23, 23))
-
-    def testPublishThumbViaName(self):
-        ImageScaling._sizes = {'thumb': (128, 128)}
-        # make sure traversing works as is and with scaling
-        credentials = self.getCredentials()
-        # first the field without a scale name
-        response = self.publish('/item/@@images/image', basic=credentials)
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getBody(), getFile('image.gif').read())
-        self.assertEqual(response.getHeader('Content-Type'), 'image/gif')
-        # and last a scaled version
-        response = self.publish('/item/@@images/image/thumb',
-                                basic=credentials)
-        self.assertEqual(response.getStatus(), 200)
-        self.assertEqual(response.getHeader('Content-Type'), 'image/jpeg')
-        self.assertImage(response.getBody(), 'JPEG', (128, 128))
-
-    def testPublishCustomSizeViaName(self):
-        # set custom image sizes
-        ImageScaling._sizes = {'foo': (23, 23)}
-        # make sure traversing works as expected
-        credentials = self.getCredentials()
-        response = self.publish('/item/@@images/image/foo', basic=credentials)
-        self.assertEqual(response.getStatus(), 200)
-        self.assertImage(response.getBody(), 'JPEG', (23, 23))
-
-    def testPublishScaleWithInvalidUID(self):
-        scale = self.view.scale('image', width=64, height=64)
-        url = scale.url.replace('http://nohost', '')
-        # change the url so it's invalid...
-        url = url.replace('.jpeg', 'x.jpeg')
-        response = self.publish(url, basic=self.getCredentials())
-        self.assertEqual(response.getStatus(), 404)
-
-    def testPublishScaleWithInvalidScale(self):
-        scale = self.view.scale('image', 'no-such-scale')
-        self.assertEqual(scale, None)
-
-    def test_getAvailableSizesWithInvalidScale(self):
-        self.assertEqual(self.view.getAvailableSizes('no-such-scale'), {})
-
-    def test_getImageSizeWithInvalidScale(self):
-        self.assertEqual(self.view.getImageSize('no-such-scale'), (0, 0))
-
-    def testGuardedAccess(self):
-        # make sure it's not possible to access scales of forbidden images
-        self.item.__allow_access_to_unprotected_subobjects__ = 0
-        ImageScaling._sizes = {'foo': (23, 23)}
-        credentials = self.getCredentials()
-        response = self.publish('/item/@@images/image/foo', basic=credentials)
-        self.assertEqual(response.getStatus(), 401)
-        self.item.__allow_access_to_unprotected_subobjects__ = 1
-
-
 def test_suite():
     from unittest import defaultTestLoader
     return defaultTestLoader.loadTestsFromName(__name__)
diff --git a/plone/namedfile/tests/test_scaling_functional.py b/plone/namedfile/tests/test_scaling_functional.py
new file mode 100644
index 0000000..fdbde69
--- /dev/null
+++ b/plone/namedfile/tests/test_scaling_functional.py
@@ -0,0 +1,217 @@
+# -*- coding: utf-8 -*-
+from DateTime import DateTime
+from OFS.SimpleItem import SimpleItem
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
+from plone.namedfile.field import NamedImage as NamedImageField
+from plone.namedfile.file import NamedImage
+from plone.namedfile.interfaces import IImageScaleTraversable
+from plone.namedfile.scaling import ImageScaling
+from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING
+from plone.testing.z2 import Browser
+from StringIO import StringIO
+from zope.annotation import IAttributeAnnotatable
+from zope.interface import implementer
+
+import os
+import PIL
+import time
+import transaction
+import unittest
+
+
+def getFile(filename):
+    """ return contents of the file with the given name """
+    filename = os.path.join(os.path.dirname(__file__), filename)
+    return open(filename, 'r')
+
+
+def wait_to_ensure_modified():
+    # modified is measured in milliseconds
+    # wait 5ms to ensure modified will have changed
+    time.sleep(0.005)
+
+
+class IHasImage(IImageScaleTraversable):
+    image = NamedImageField()
+
+
+def assertImage(testcase, data, format_, size):
+    image = PIL.Image.open(StringIO(data))
+    testcase.assertEqual(image.format, format_)
+    testcase.assertEqual(image.size, size)
+
+
+@implementer(IAttributeAnnotatable, IHasImage)
+class DummyContent(SimpleItem):
+    image = None
+    modified = DateTime
+    id = __name__ = 'item'
+    title = 'foo'
+
+    def Title(self):
+        return self.title
+
+
+class ImagePublisherTests(unittest.TestCase):
+
+    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING
+
+    def setUp(self):
+        data = getFile('image.gif').read()
+        item = DummyContent()
+        item.image = NamedImage(data, 'image/gif', u'image.gif')
+        self.layer['app']._setOb('item', item)
+        self.item = self.layer['app'].item
+        self.view = self.item.unrestrictedTraverse('@@images')
+        self._orig_sizes = ImageScaling._sizes
+
+        self.browser = Browser(self.layer['app'])
+        self.browser.handleErrors = False
+        self.browser.addHeader('Referer', self.layer['app'].absolute_url())
+
+    def tearDown(self):
+        ImageScaling._sizes = self._orig_sizes
+
+    def testPublishScaleViaUID(self):
+        scale = self.view.scale('image', width=64, height=64)
+        transaction.commit()
+        # make sure the referenced image scale is available
+        self.browser.open(scale.url)
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        assertImage(self, self.browser.contents, 'JPEG', (64, 64))
+
+    def testPublishWebDavScaleViaUID(self):
+        scale = self.view.scale('image', width=64, height=64)
+        transaction.commit()
+        # make sure the referenced image scale is available
+        self.browser.open(scale.url + '/manage_DAVget')
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        assertImage(self, self.browser.contents, 'JPEG', (64, 64))
+
+    def testPublishFTPScaleViaUID(self):
+        scale = self.view.scale('image', width=64, height=64)
+        transaction.commit()
+        # make sure the referenced image scale is available
+        self.browser.open(scale.url + '/manage_FTPget')
+        self.assertIn('200', self.browser.headers['status'])
+        # Same remark as in testPublishWebDavScaleViaUID is valid here.
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        assertImage(self, self.browser.contents, 'JPEG', (64, 64))
+
+    def testHeadRequestMethod(self):
+        scale = self.view.scale('image', width=64, height=64)
+        transaction.commit()
+        # make sure the referenced image scale is available
+        self.browser.open(scale.url)
+        GET_length = len(self.browser.contents)
+
+        self.browser = Browser(self.layer['app'])
+        self.browser.handleErrors = False
+        self.browser.addHeader('Referer', self.layer['app'].absolute_url())
+        from urllib2 import Request
+
+        class HeadRequest(Request):
+            def get_method(self):
+                return "HEAD"
+
+        head_request = HeadRequest(scale.url)
+        mbrowser = self.browser.mech_browser
+        mbrowser.open(head_request)
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        self.assertEqual(
+            self.browser.headers['Content-Length'],
+            str(GET_length)
+        )
+        self.assertEqual(self.browser.contents, '')
+
+    def testPublishThumbViaUID(self):
+        ImageScaling._sizes = {'thumb': (128, 128)}
+        scale = self.view.scale('image', 'thumb')
+        transaction.commit()
+        # make sure the referenced image scale is available
+        self.browser.open(scale.url)
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        assertImage(self, self.browser.contents, 'JPEG', (128, 128))
+
+    def testPublishCustomSizeViaUID(self):
+        # set custom image sizes
+        ImageScaling._sizes = {'foo': (23, 23)}
+        scale = self.view.scale('image', 'foo')
+        transaction.commit()
+        # make sure the referenced image scale is available
+        self.browser.open(scale.url)
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        assertImage(self, self.browser.contents, 'JPEG', (23, 23))
+
+    def testPublishThumbViaName(self):
+        ImageScaling._sizes = {'thumb': (128, 128)}
+        transaction.commit()
+
+        # make sure traversing works as is and with scaling
+        # first the field without a scale name
+        self.browser.open(
+            self.layer['app'].absolute_url() + '/item/@@images/image'
+        )
+        self.assertEqual('image/gif', self.browser.headers['content-type'])
+        self.assertEqual(self.browser.contents, getFile('image.gif').read())
+
+        # and last a scaled version
+        self.browser.open(
+            self.layer['app'].absolute_url() + '/item/@@images/image/thumb'
+        )
+        self.assertEqual('image/jpeg', self.browser.headers['content-type'])
+        assertImage(self, self.browser.contents, 'JPEG', (128, 128))
+
+    def testPublishCustomSizeViaName(self):
+        # set custom image sizes
+        ImageScaling._sizes = {'foo': (23, 23)}
+        transaction.commit()
+        # make sure traversing works as expected
+        self.browser.open(
+            self.layer['app'].absolute_url() + '/item/@@images/image/foo'
+        )
+        assertImage(self, self.browser.contents, 'JPEG', (23, 23))
+
+    def testPublishScaleWithInvalidUID(self):
+        scale = self.view.scale('image', width=64, height=64)
+        transaction.commit()
+        # change the url so it's invalid...
+        from zExceptions import NotFound
+        with self.assertRaises(NotFound):
+            self.browser.open(scale.url.replace('.jpeg', 'x.jpeg'))
+
+    def testPublishScaleWithInvalidScale(self):
+        scale = self.view.scale('image', 'no-such-scale')
+        transaction.commit()
+        self.assertEqual(scale, None)
+
+    def test_getAvailableSizesWithInvalidScaleMethod(self):
+        self.assertEqual(self.view.getAvailableSizes('no-such-scale'), {})
+
+    def test_getAvailableSizesWithInvalidScaleProperty(self):
+        self.assertEqual(self.view.available_sizes, {})
+
+    def test_getImageSizeWithInvalidScale(self):
+        self.assertEqual(self.view.getImageSize('no-such-scale'), (0, 0))
+
+    def testGuardedAccess(self):
+        # make sure it's not possible to access scales of forbidden images
+        self.item.__allow_access_to_unprotected_subobjects__ = 0
+        ImageScaling._sizes = {'foo': (23, 23)}
+        transaction.commit()
+        self.browser.addHeader(
+            'Authorization',
+            'Basic {0:s}:{1:s}'.format(TEST_USER_NAME, TEST_USER_PASSWORD)
+        )
+        from zExceptions import Unauthorized
+        with self.assertRaises(Unauthorized):
+            self.browser.open(
+                self.layer['app'].absolute_url() + '/item/@@images/image/foo'
+            )
+        self.item.__allow_access_to_unprotected_subobjects__ = 1
+
+
+def test_suite():
+    from unittest import defaultTestLoader
+    return defaultTestLoader.loadTestsFromName(__name__)
diff --git a/plone/namedfile/tests/testing.zcml b/plone/namedfile/tests/testing.zcml
deleted file mode 100644
index c8ac4f0..0000000
--- a/plone/namedfile/tests/testing.zcml
+++ /dev/null
@@ -1,12 +0,0 @@
-<configure xmlns="http://namespaces.zope.org/zope">
-
-  <include package="zope.security" file="meta.zcml" />
-  <include package="zope.component" file="meta.zcml" />
-  <include package="zope.browserpage" file="meta.zcml" />
-  <include package="zope.traversing" file="configure.zcml" />
-
-  <permission id="zope2.View" title="View" />
-
-  <include package="plone.namedfile" />
-
-</configure>
diff --git a/plone/namedfile/usage.rst b/plone/namedfile/usage.rst
index 6c10984..c62d1cb 100644
--- a/plone/namedfile/usage.rst
+++ b/plone/namedfile/usage.rst
@@ -3,27 +3,6 @@ Usage
 
 This demonstrates how to use the package.
 
-
-Test setup
-----------
-
-We must first load the package's ZCML::
-
-    >>> configuration = """\
-    ... <configure
-    ...      xmlns="http://namespaces.zope.org/zope"
-    ...      i18n_domain="plone.namedfile.tests">
-    ...
-    ...     <include package="plone.namedfile" />
-    ...
-    ... </configure>
-    ... """
-
-    >>> from StringIO import StringIO
-    >>> from zope.configuration import xmlconfig
-    >>> xmlconfig.xmlconfig(StringIO(configuration))
-
-
 Schema fields
 -------------
 
diff --git a/setup.py b/setup.py
index c1a84f2..9f5f73d 100644
--- a/setup.py
+++ b/setup.py
@@ -4,8 +4,9 @@
 import os
 
 
-version = '3.0.9.dev0'
-description = "File types and fields for images, files and blob files with filenames"  # noqa
+version = '4.0.0.dev0'
+description = 'File types and fields for images, files and blob files with ' \
+              'filenames'
 long_description = ('\n\n'.join([
     open('README.rst').read(),
     open('CHANGES.rst').read(),
@@ -20,7 +21,7 @@
     long_description=long_description,
     classifiers=[
         "Framework :: Plone",
-        "Framework :: Plone :: 5.0",
+        "Framework :: Plone :: 5.1",
         "Programming Language :: Python",
         "Programming Language :: Python :: 2.7",
         "Topic :: Software Development :: Libraries :: Python Modules",
@@ -36,9 +37,11 @@
     include_package_data=True,
     zip_safe=False,
     install_requires=[
-        'setuptools',
         'plone.rfc822>=1.0b2',
-        'zope.app.file',
+        'plone.scale[storage] >=1.4.999',
+        'plone.schemaeditor',
+        'plone.supermodel',
+        'setuptools',
         'zope.browserpage',
         'zope.component',
         'zope.copy',
@@ -46,17 +49,16 @@
         'zope.traversing',
     ],
     extras_require={
-        'editor': ['plone.schemaeditor'],
-        'scales': ['plone.scale[storage] >=1.1'],
-        'supermodel': ['plone.supermodel'],
         'test': [
             'lxml',
             'Pillow',
-            'plone.namedfile[supermodel, scales]',
-            'Zope2',
+            'plone.testing[z2]',
         ],
-        # BBB
+        # BBB - remove in version 5
         'blobs': [],
+        'editor': [],
         'marshaler': [],
+        'scales': [],
+        'supermodel': [],
     },
 )


