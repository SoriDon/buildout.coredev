Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/520f05ea278fdf4cba2c08d5854f0393d27c4bfb

Make it possible to run the tests without having ZServer installed.

Files changed:
M .travis.yml
M CHANGES.rst
M setup.py
M src/plone/testing/tests.py
M tox.ini

b"diff --git a/.travis.yml b/.travis.yml\nindex eb3bc5b..5058ba4 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -2,13 +2,13 @@ language: python\n sudo: false\n python:\n     - 2.7\n+env:\n+    - EXTRA=\n+    - EXTRA=-zserver\n install:\n-    - pip install setuptools zc.buildout\n-    - pip install coveralls coverage\n-    - buildout bootstrap\n-    - buildout\n+    - pip install tox\n script:\n-    - coverage run bin/test -v1\n+    - tox -e py${TRAVIS_PYTHON_VERSION//.}$EXTRA\n after_success:\n     - coverage combine\n     - coveralls\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex e47dd40..4355357 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -27,6 +27,8 @@ Bug fixes:\n   + Only support ``Zope >= 4``, no longer support ``Zope2``.\n   + Drop support for Python 2.6.\n \n+- Make it possible to run the tests without having ``ZServer`` installed.\n+\n - No longer use deprecated import for getSite/setSite.\n   [jensens]\n \ndiff --git a/setup.py b/setup.py\nindex a4c7f94..92bc8db 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -25,7 +25,6 @@\n     'zope.testbrowser',\n     'zope.testrunner',\n     'Zope',\n-    'ZServer',\n ]\n \n setup(\n@@ -87,6 +86,7 @@\n         ],\n         'z2': [\n             'Zope',\n+            'ZServer',\n             'zope.component',\n             'zope.testbrowser',\n             'zope.publisher',\ndiff --git a/src/plone/testing/tests.py b/src/plone/testing/tests.py\nindex 16766db..923bc22 100644\n--- a/src/plone/testing/tests.py\n+++ b/src/plone/testing/tests.py\n@@ -8,6 +8,12 @@\n import unittest\n import zope.component.testing\n \n+try:\n+    import ZServer  # noqa\n+except ImportError:\n+    HAS_ZSERVER = False\n+else:\n+    HAS_ZSERVER = True\n \n # This is somewhat retarted. We execute README.rst as a doctest, mainly just\n # to test that the code samples import cleanly and are valid Python. However,\n@@ -68,7 +74,6 @@ def test_suite():\n             'security.rst',\n             'publisher.rst',\n             'zodb.rst',\n-            'z2.rst',\n             setUp=setUp,\n             tearDown=tearDown,\n             optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,\n@@ -81,4 +86,12 @@ def test_suite():\n             optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,\n         ),\n     ])\n+    if HAS_ZSERVER:\n+        suite.addTests([\n+            doctest.DocFileSuite(\n+                'z2.rst',\n+                setUp=setUp,\n+                tearDown=tearDown,\n+                optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,\n+            )])\n     return suite\ndiff --git a/tox.ini b/tox.ini\nindex 4045a1e..126c650 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -1,5 +1,6 @@\n [tox]\n envlist = py27,\n+          py27-zserver\n           coverage-report\n minversion = 1.9\n \n@@ -14,6 +15,10 @@ commands = coverage run {envbindir}/zope-testrunner --path=src --all {posargs:-v\n setenv =\n     COVERAGE_FILE=.coverage.{envname}\n \n+[testenv:py27-zserver]\n+deps = .[test,z2]\n+       {[testenv]deps}\n+\n [testenv:coverage-report]\n basepython = python2.7\n deps = coverage\n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Godefroid Chapelle (gotcha) <gotcha@bubblenet.be>
Commit: https://github.com/plone/plone.testing/commit/a769f96cf11f7a82b5e6e59f3d0477f0b6782ef2

copy files to keep git history

Files changed:
A src/plone/testing/zserver.py
A src/plone/testing/zserver.rst

b'diff --git a/src/plone/testing/zserver.py b/src/plone/testing/zserver.py\nnew file mode 100644\nindex 0000000..b97c2ee\n--- /dev/null\n+++ b/src/plone/testing/zserver.py\n@@ -0,0 +1,1117 @@\n+# -*- coding: utf-8 -*-\n+"""Zope2-specific helpers and layers\n+"""\n+from OFS.metaconfigure import get_packages_to_initialize\n+from plone.testing import Layer\n+from plone.testing import zca\n+from plone.testing import zodb\n+from plone.testing._z2_testbrowser import Browser  # noqa\n+from Testing.ZopeTestCase.ZopeLite import _patched as ZOPETESTCASEALERT\n+from Zope2.App.schema import Zope2VocabularyRegistry\n+from zope.schema.vocabulary import getVocabularyRegistry\n+from zope.schema.vocabulary import setVocabularyRegistry\n+\n+import contextlib\n+import os\n+import transaction\n+\n+\n+try:\n+    from plone.testing._z2_testbrowser import Browser  # noqa # BBB\n+except ImportError:\n+    # Just in case zope.testbrowser causes an import error, don\'t break\n+    pass\n+\n+\n+_INSTALLED_PRODUCTS = {}\n+\n+\n+class TestIsolationBroken(BaseException):\n+    pass\n+\n+\n+def installProduct(app, productName, quiet=False, multiinit=False):\n+    """Install the Zope 2 product with the given name, so that it will show\n+    up in the Zope 2 control panel and have its ``initialize()`` hook called.\n+\n+    The ``STARTUP`` layer or an equivalent layer must have been loaded first.\n+\n+    If ``quiet`` is False, an error will be logged if the product cannot be\n+    found. By default, the function is silent.\n+\n+    Note that products\' ZCML is *not* loaded automatically, even if the\n+    product is in the Products namespace.\n+    """\n+    from App.class_init import InitializeClass\n+    from OFS.Application import get_folder_permissions\n+    from OFS.Application import get_products\n+    from OFS.Application import install_package\n+    from OFS.Application import install_product\n+    from OFS.Folder import Folder\n+    import sys\n+\n+    found = False\n+\n+    if productName in _INSTALLED_PRODUCTS:\n+        return\n+\n+    if productName.startswith(\'Products.\'):\n+        for priority, name, index, productDir in get_products():\n+            if (\'Products.\' + name) == productName:\n+\n+                install_product(\n+                    app,\n+                    productDir,\n+                    name,\n+                    [],\n+                    get_folder_permissions(),\n+                    raise_exc=1)\n+                InitializeClass(Folder)\n+\n+                _INSTALLED_PRODUCTS[productName] = (\n+                    priority,\n+                    name,\n+                    index,\n+                    productDir,\n+                )\n+\n+                found = True\n+                break\n+\n+    else:\n+        packages = tuple(get_packages_to_initialize())\n+        for module, init_func in packages:\n+            if module.__name__ == productName:\n+                install_package(app, module, init_func, raise_exc=1)\n+                _INSTALLED_PRODUCTS[productName] = (module, init_func,)\n+\n+                found = True\n+                if not multiinit:\n+                    break\n+\n+    if not found and not quiet:\n+        sys.stderr.write(\n+            \'Could not install product {0}\\n\'.format(productName)\n+        )\n+        sys.stderr.flush()\n+\n+\n+def uninstallProduct(app, productName, quiet=False):\n+    """Uninstall the given Zope 2 product. This is the inverse of\n+    ``installProduct()`` above.\n+    """\n+\n+    import sys\n+\n+    # from OFS.Folder import Folder\n+    # from OFS.Application import get_folder_permissions\n+    # from App.class_init import InitializeClass\n+\n+    from OFS.Application import Application, get_products\n+\n+    global _INSTALLED_PRODUCTS\n+    found = False\n+\n+    if productName not in _INSTALLED_PRODUCTS:\n+        return\n+\n+    if productName.startswith(\'Products.\'):\n+        for priority, name, index, productDir in get_products():\n+            if (\'Products.\' + name) == productName:\n+\n+                if name in Application.misc_.__dict__:\n+                    delattr(Application.misc_, name)\n+\n+                try:\n+                    cp = app[\'Control_Panel\'][\'Products\']\n+                except KeyError:\n+                    # Zope 4\n+                    pass\n+                else:\n+                    if name in cp:\n+                        product = cp[name]\n+\n+                        app._manage_remove_product_meta_type(product)\n+                        app._manage_remove_product_permission(product)\n+\n+                        del cp[name]\n+\n+                # TODO: Also remove permissions from get_folder_permissions?\n+                # Difficult to know if this would stomp on any other\n+                # permissions\n+                # InitializeClass(Folder)\n+\n+                found = True\n+                break\n+    elif productName in _INSTALLED_PRODUCTS:  # must be a package\n+\n+        module, init_func = _INSTALLED_PRODUCTS[productName]\n+        name = module.__name__\n+\n+        try:\n+            cp = app[\'Control_Panel\'][\'Products\']\n+        except KeyError:\n+            # Zope 4\n+            pass\n+        else:\n+            if name in cp:\n+                product = cp[name]\n+\n+                app._manage_remove_product_meta_type(product)\n+                app._manage_remove_product_permission(product)\n+\n+                del cp[name]\n+\n+        packages = get_packages_to_initialize()\n+        packages.append((module, init_func))\n+        found = True\n+\n+    if found:\n+        del _INSTALLED_PRODUCTS[productName]\n+\n+    if not found and not quiet:\n+        sys.stderr.write(\n+            \'Could not install product {0}\\n\'.format(productName)\n+        )\n+        sys.stderr.flush()\n+\n+\n+def login(userFolder, userName):\n+    """Log in as the given user in the given user folder.\n+    """\n+\n+    from AccessControl.SecurityManagement import newSecurityManager\n+\n+    user = userFolder.getUser(userName)\n+    if user is None:\n+        raise ValueError(\'User could not be found\')\n+    if not hasattr(user, \'aq_base\'):\n+        user = user.__of__(userFolder)\n+    newSecurityManager(None, user)\n+\n+\n+def logout():\n+    """Log out, i.e. become anonymous\n+    """\n+\n+    from AccessControl.SecurityManagement import noSecurityManager\n+    noSecurityManager()\n+\n+\n+def setRoles(userFolder, userId, roles):\n+    """Set the given user\'s roles to a tuple of roles.\n+    """\n+\n+    userFolder.userFolderEditUser(userId, None, list(roles), [])\n+\n+    from AccessControl import getSecurityManager\n+    userName = userFolder.getUserById(userId).getUserName()\n+    if userName == getSecurityManager().getUser().getUserName():\n+        login(userFolder, userName)\n+\n+\n+def makeTestRequest(environ=None):\n+    """Return an HTTPRequest object suitable for testing views."""\n+    from sys import stdin, stdout\n+    from zope.publisher.browser import setDefaultSkin\n+    from ZPublisher.HTTPRequest import HTTPRequest\n+    from ZPublisher.HTTPResponse import HTTPResponse\n+\n+    if environ is None:\n+        environ = {}\n+    environ.setdefault(\'SERVER_NAME\', \'foo\')\n+    environ.setdefault(\'SERVER_PORT\', \'80\')\n+    environ.setdefault(\'REQUEST_METHOD\', \'GET\')\n+\n+    resp = HTTPResponse(stdout=stdout)\n+    req = HTTPRequest(stdin, environ, resp)\n+    req._steps = [\'noobject\']  # Fake a published object.\n+    req[\'ACTUAL_URL\'] = req.get(\'URL\')\n+    setDefaultSkin(req)\n+\n+    return req\n+\n+\n+def addRequestContainer(app, environ=None):\n+    """Add the request container with a fake request to the app object\'s\n+    acquisition context and return the wrapped app object. Additional request\n+    environment values can be passed as a dict ``environ``.\n+    """\n+\n+    from ZPublisher.BaseRequest import RequestContainer\n+    req = makeTestRequest(environ)\n+    requestcontainer = RequestContainer(REQUEST=req)\n+    return app.__of__(requestcontainer)\n+\n+\n+@contextlib.contextmanager\n+def zopeApp(db=None, connection=None, environ=None):\n+    """Context manager for working with the Zope2 app::\n+\n+        with zopeApp() as app:\n+            ...\n+\n+    The ``app`` object has a request container and a simple ``REQUEST``.\n+    To set the request environment, pass a dict ``environ``. See\n+    ``addRequestContainer()`` for details.\n+\n+    Pass a ZODB handle as ``db`` to use a specificdatabase. Alternatively,\n+    pass an open connection as ``connection`` (the connection will not be\n+    closed).\n+    """\n+    import Zope2\n+\n+    closeConn = True\n+    if connection is not None:\n+        closeConn = False\n+\n+    if connection is None and db is not None:\n+        connection = db.open()\n+\n+    app = addRequestContainer(Zope2.app(connection), environ=environ)\n+\n+    if connection is None:\n+        connection = app._p_jar\n+\n+    # exceptions in finally clauses can mask exceptions\n+    # in the preceeding code block. So we catch\n+    # every exception and throw it instead of the exception\n+    # in the finally clause\n+    inner_exception = None\n+    try:\n+        yield app\n+    except Exception as e:\n+        inner_exception = e\n+        try:\n+            transaction.abort()\n+        except Exception as e:\n+            inner_exception = e\n+            raise\n+        raise\n+    else:\n+        try:\n+            transaction.commit()\n+        except Exception as e:\n+            inner_exception = e\n+    finally:\n+        try:\n+            app.REQUEST.close()\n+            if closeConn:\n+                transaction.abort()\n+                connection.close()\n+        except Exception:\n+            if inner_exception:\n+                raise inner_exception\n+            else:\n+                raise\n+\n+\n+# Startup layer - you probably don\'t want to use this one directly\n+\n+class Startup(Layer):\n+    """This layer does what ZopeLite and ZopeTestCase\'s base.TestCase did:\n+    start up a minimal Zope instance and manages the application and\n+    request state.\n+\n+    You probably don\'t want to use this layer directly. Instead, you should\n+    use one of the layers that has it as a base.\n+\n+    The following resources are exposed:\n+\n+    * ``zodbDB`` is the ZODB with the test fixture\n+    * ``configurationContext`` is the ``zope.configuration`` context for\n+      ZCML loading.\n+    * ``host`` and ``port`` are the fake hostname and port number,\n+      respectively.\n+    """\n+\n+    defaultBases = (zca.LAYER_CLEANUP,)\n+\n+    threads = 1\n+\n+    # Layer lifecycle\n+\n+    def setUp(self):\n+        self.setUpDebugMode()\n+        self.setUpClientCache()\n+        self.setUpPatches()\n+        self.setUpThreads()\n+        self.setUpHostPort()\n+        self.setUpDatabase()\n+        self.setUpApp()\n+        self.setUpBasicProducts()\n+        self.setUpZCML()\n+        self.setUpFive()\n+\n+    def tearDown(self):\n+        self.tearDownFive()\n+        self.tearDownZCML()\n+        self.tearDownBasicProducts()\n+        self.tearDownApp()\n+        self.tearDownDatabase()\n+        self.tearDownHostPort()\n+        self.tearDownThreads()\n+        self.tearDownPatches()\n+        self.tearDownClientCache()\n+        self.tearDownDebugMode()\n+\n+    # Layer lifecycle helper methods\n+\n+    def setUpDebugMode(self):\n+        """Switch off debug mode in the global configuration\n+        """\n+\n+        import App.config\n+        config = App.config.getConfiguration()\n+        self._debugMode = config.debug_mode\n+        config.debug_mode = False\n+        App.config.setConfiguration(config)\n+\n+        # Set Python security mode\n+        from AccessControl.Implementation import setImplementation\n+        setImplementation(\'Python\')\n+\n+        # Set a flag so that other code can know that we are running tests.\n+        # Some of the speed-related patches in Plone use this, for instance.\n+        # The name is a BBB artefact from ZopeTestCase :\n+        import os\n+        os.environ[\'ZOPETESTCASE\'] = \'1\'\n+\n+    def tearDownDebugMode(self):\n+        """Return the debug mode flag to its previous state\n+        """\n+\n+        from AccessControl.Implementation import setImplementation\n+        setImplementation(\'C\')\n+\n+        import App.config\n+        config = App.config.getConfiguration()\n+        config.debug_mode = self._debugMode\n+        App.config.setConfiguration(config)\n+        del self._debugMode\n+\n+    def setUpClientCache(self):\n+        """Make sure we use a temporary client cache by altering the global\n+        configuration\n+        """\n+\n+        # Make sure we use a temporary client cache\n+        import App.config\n+        config = App.config.getConfiguration()\n+        self._zeoClientName = getattr(config, \'zeo_client_name\', None)\n+        config.zeo_client_name = None\n+        App.config.setConfiguration(config)\n+\n+    def tearDownClientCache(self):\n+        """Restore the cache configuration to its previous state\n+        """\n+\n+        # Make sure we use a temporary client cache\n+        import App.config\n+        config = App.config.getConfiguration()\n+        config.zeo_client_name = self._zeoClientName\n+        App.config.setConfiguration(config)\n+        del self._zeoClientName\n+\n+    def setUpPatches(self):\n+        """Apply monkey patches that disable unnecessary parts of Zope.\n+        This speeds up the test runs.\n+        """\n+\n+        import OFS.Application\n+        import App.ProductContext\n+        import Zope2.App.startup\n+\n+        # Avoid expensive product import\n+        def null_import_products():\n+            pass\n+        self._OFS_Application_import_products = OFS.Application.import_products\n+        OFS.Application.import_products = null_import_products\n+\n+        # Avoid expensive product installation\n+        def null_initialize(app):\n+            pass\n+        self._OFS_Application_initialize = OFS.Application.initialize\n+        OFS.Application.initialize = null_initialize\n+\n+        # Avoid expensive help registration\n+        try:\n+            self._App_ProductContext_ProductContext_registerHelpTopic = App.ProductContext.ProductContext.registerHelpTopic  # noqa\n+        except AttributeError:\n+            # Zope 4\n+            pass\n+        else:\n+            def null_register_topic(self, id, topic):\n+                pass\n+            App.ProductContext.ProductContext.registerHelpTopic = null_register_topic  # noqa\n+\n+            self._App_ProductContext_ProductContext_registerHelpTitle = App.ProductContext.ProductContext.registerHelpTitle  # noqa\n+\n+            def null_register_title(self, title):\n+                pass\n+            App.ProductContext.ProductContext.registerHelpTitle = null_register_title  # noqa\n+\n+            self._App_ProductContext_ProductContext_registerHelp = App.ProductContext.ProductContext.registerHelp  # noqa\n+\n+            def null_register_help(\n+                    self,\n+                    directory=\'\',\n+                    clear=1,\n+                    title_re=None):\n+                pass\n+            App.ProductContext.ProductContext.registerHelp = null_register_help\n+\n+        # in Zope 2.13, prevent ZCML from loading during App startup\n+        if hasattr(Zope2.App.startup, \'load_zcml\'):\n+            def null_load_zcml():\n+                pass\n+            self._Zope2_App_startup_load_zcml = Zope2.App.startup.load_zcml\n+            Zope2.App.startup.load_zcml = null_load_zcml\n+\n+    def tearDownPatches(self):\n+        """Revert the monkey patches from setUpPatches()\n+        """\n+\n+        import OFS.Application\n+        import App.ProductContext\n+\n+        OFS.Application.import_products = self._OFS_Application_import_products\n+        del self._OFS_Application_import_products\n+\n+        OFS.Application.initialize = self._OFS_Application_initialize\n+        del self._OFS_Application_initialize\n+\n+        try:\n+            App.ProductContext.ProductContext.registerHelpTopic = self._App_ProductContext_ProductContext_registerHelpTopic  # noqa\n+        except AttributeError:\n+            # Zope 4\n+            pass\n+        else:\n+            del self._App_ProductContext_ProductContext_registerHelpTopic\n+\n+            App.ProductContext.ProductContext.registerHelpTitle = self._App_ProductContext_ProductContext_registerHelpTitle  # noqa\n+            del self._App_ProductContext_ProductContext_registerHelpTitle\n+\n+            App.ProductContext.ProductContext.registerHelp = self._App_ProductContext_ProductContext_registerHelp  # noqa\n+            del self._App_ProductContext_ProductContext_registerHelp\n+\n+    def setUpThreads(self):\n+        """Set the thread count for ZServer. This defaults to 1.\n+        """\n+\n+        # We can\'t use setNumberOfThreads() because that function self-\n+        # destructs, literally, when called.\n+\n+        import ZServer.PubCore\n+        self._zserverThreads = ZServer.PubCore._n\n+        ZServer.PubCore._n = self.threads\n+\n+    def tearDownThreads(self):\n+        """Reset the ZServer thread count.\n+        """\n+\n+        import ZServer.PubCore\n+        ZServer.PubCore._n = self._zserverThreads\n+        del self._zserverThreads\n+\n+    def setUpHostPort(self):\n+        """Set up the \'host\' and \'port\' resources\n+        """\n+\n+        self[\'host\'] = \'nohost\'\n+        self[\'port\'] = 80\n+\n+    def tearDownHostPort(self):\n+        """Pop the \'host\' and \'port\' resources\n+        """\n+\n+        del self[\'host\']\n+        del self[\'port\']\n+\n+    def setUpDatabase(self):\n+        """Create a database and stash it in the resource ``zodbDB``. If\n+        that resource exists, create a layered DemoStorage on top of the\n+        base database. Otherwise, create a new resource.\n+\n+        The database is registered in the global configuration so that\n+        Zope 2 app startup will find it. We use a facade object to ensure\n+        that the database that is opened by Zope 2 is in fact the top of\n+        the resource stack.\n+        """\n+        if ZOPETESTCASEALERT:\n+            raise Exception(\'You try to run plone.testing tests together with \'\n+                            \'ZopeTestCase tests. This will result in random \'\n+                            \'failures. Convert the ZopeTestCase Tests or \'\n+                            \'do not run them together\')\n+\n+        import Zope2.Startup.datatypes\n+        import App.config\n+\n+        # Layer a new storage for Zope 2 on top of the one from the base\n+        # layer, if there is one.\n+\n+        self[\'zodbDB\'] = zodb.stackDemoStorage(\n+            self.get(\'zodbDB\'),\n+            name=\'Startup\')\n+\n+        # Create a facade for the database object that will delegate to the\n+        # correct underlying database. This allows resource shadowing to work\n+        # with regular traversal, which relies on a module-level ``DB``\n+        # variable.\n+\n+        class DBFacade(object):\n+\n+            def __init__(self, layer):\n+                self.__layer = layer\n+\n+            @property\n+            def __db(self):\n+                return self.__layer[\'zodbDB\']\n+\n+            def __getattr__(self, name):\n+                return getattr(self.__db, name)\n+\n+        # Create a fake dbtab value in the config so that app startup will\n+        # use this one.\n+\n+        class DBTab(Zope2.Startup.datatypes.DBTab):\n+            """A fake DBTab that causes App.startup() to use our own database.\n+            """\n+\n+            def __init__(self, db):\n+                # value is never used when we have an open db\n+                self.db_factories = {\'testing\': None}\n+                self.mount_paths = {\'/\': \'testing\'}\n+                self.databases = {\'testing\': db}\n+\n+        config = App.config.getConfiguration()\n+        self._dbtab = getattr(config, \'dbtab\', None)\n+        config.dbtab = DBTab(DBFacade(self))\n+        App.config.setConfiguration(config)\n+\n+    def tearDownDatabase(self):\n+        """Close the database and pop the ``zodbDB`` resource. Restore the\n+        global database configuration to its previous state.\n+        """\n+\n+        import App.config\n+        config = App.config.getConfiguration()\n+        config.dbtab = self._dbtab\n+        App.config.setConfiguration(config)\n+        del self._dbtab\n+\n+        # Close and pop the zodbDB resource\n+        transaction.abort()\n+        self[\'zodbDB\'].close()\n+        del self[\'zodbDB\']\n+\n+    def setUpApp(self):\n+        """Trigger Zope startup and set up the application.\n+        """\n+\n+        # If the Testing module has been imported, the testinghome\n+        # variable is set and changes the way Zope2.startup() works.\n+        # We want the standard behavior so we remove it.\n+\n+        import App.config\n+        config = App.config.getConfiguration()\n+        if hasattr(config, \'testinghome\'):\n+            self._testingHome = config.testinghome\n+            del config.testinghome\n+            App.config.setConfiguration(config)\n+\n+        # This uses the DB from the dbtab, as configured in setUpDatabase().\n+        # That DB then gets stored as Zope2.DB and becomes the default.\n+\n+        import Zope2\n+        Zope2.startup()\n+\n+        # At this point, Zope2.DB is set to the test database facade. This is\n+        # the database will be used by default when someone does Zope2.app().\n+\n+    def tearDownApp(self):\n+        """Undo Zope 2 startup by unsetting the global state it creates.\n+        """\n+\n+        import Zope2\n+        Zope2.app()._p_jar.close()\n+\n+        Zope2._began_startup = 0\n+\n+        Zope2.DB = None\n+        Zope2.bobo_application = None\n+        Zope2.zpublisher_transactions_manager = None\n+        Zope2.zpublisher_validated_hook = None\n+        Zope2.zpublisher_exception_hook = None\n+        Zope2.__bobo_before__ = None\n+\n+        import App.config\n+        if hasattr(self, \'_testingHome\'):\n+            config = App.config.getConfiguration()\n+            config.testinghome = self._testingHome\n+            App.config.setConfiguration(config)\n+            del self._testingHome\n+\n+        # Clear out the app reference cached in get_module_info\'s\n+        # \'modules\' parameter default dict. (waaaaa)\n+        import ZPublisher.Publish\n+        defaults = ZPublisher.Publish.get_module_info.func_defaults\n+\n+        if defaults:\n+            d = list(defaults)\n+            d[0] = {}\n+            ZPublisher.Publish.get_module_info.func_defaults = tuple(d)\n+\n+    def setUpBasicProducts(self):\n+        """Install a minimal set of products required for Zope 2.\n+        """\n+\n+        with zopeApp() as app:\n+            installProduct(app, \'Products.PluginIndexes\')\n+            installProduct(app, \'Products.OFSP\')\n+\n+    def tearDownBasicProducts(self):\n+        """Tear down the minimal set of products\n+        """\n+\n+        with zopeApp() as app:\n+            uninstallProduct(app, \'Products.PluginIndexes\')\n+            uninstallProduct(app, \'Products.OFSP\')\n+\n+        # It\'s possible for Five\'s _register_monkies and _meta_type_regs\n+        # global variables to contain duplicates. This causes an unecessary\n+        # error in the LayerCleanup layer\'s tear-down. Guard against that\n+        # here\n+\n+        try:\n+            from OFS import metaconfigure\n+        except ImportError:\n+            # Zope <= 2.12\n+            from Products.Five import fiveconfigure as metaconfigure\n+        metaconfigure._register_monkies = list(\n+            set(metaconfigure._register_monkies))\n+        metaconfigure._meta_type_regs = list(\n+            set(metaconfigure._meta_type_regs))\n+\n+    def setUpZCML(self):\n+        """Load the basic ZCML configuration from Five. Exposes a resource\n+        ``configurationContext`` which can be used to load further ZCML.\n+        """\n+\n+        # Push a new global registry so that we can cleanly tear down all ZCML\n+        from plone.testing import zca\n+        zca.pushGlobalRegistry()\n+\n+        # Load something akin to the default site.zcml without actually auto-\n+        # loading products\n+\n+        self[\'configurationContext\'] = context = zca.stackConfigurationContext(\n+            self.get(\'configurationContext\'))\n+\n+        from zope.configuration import xmlconfig\n+        xmlconfig.string("""\\\n+<configure\n+    xmlns="http://namespaces.zope.org/zope"\n+    xmlns:meta="http://namespaces.zope.org/meta">\n+\n+    <include package="Products.Five" />\n+    <meta:redefinePermission from="zope2.Public" to="zope.Public" />\n+\n+    <securityPolicy component="AccessControl.security.SecurityPolicy" />\n+\n+</configure>\n+""", context=context)\n+\n+    def tearDownZCML(self):\n+        """Tear down the component registry and delete the\n+        ``configurationContext`` resource.\n+        """\n+        # Delete the (possibly stacked) configuration context\n+        del self[\'configurationContext\']\n+\n+        # Zap all globally loaded ZCML\n+        from plone.testing import zca\n+        zca.popGlobalRegistry()\n+\n+    def setUpFive(self):\n+        """Initialize Five without loading the site.zcml file to avoid\n+        loading all Products.* .\n+\n+        This basically pushes a special vocabulary registry that\n+        supports global and local utilities.\n+        """\n+\n+        self._oldVocabularyRegistry = getVocabularyRegistry()\n+        setVocabularyRegistry(Zope2VocabularyRegistry())\n+\n+    def tearDownFive(self):\n+        """Tear down the Five initialization restoring the previous\n+        vocabulary registry.\n+        """\n+\n+        setVocabularyRegistry(self._oldVocabularyRegistry)\n+\n+\n+STARTUP = Startup()\n+\n+\n+# Basic integration and functional test and layers. These are the simplest\n+# Zope 2 layers that are generally useful\n+\n+class IntegrationTesting(Layer):\n+    """This layer extends ``STARTUP`` to add rollback of the transaction\n+    after each test. It does not manage a fixture and has no layer lifecyle,\n+    only a test lifecycle.\n+\n+    The application root is available as the resource ``app`` and the request\n+    is available as the resource ``request``, set up and torn down for each\n+    test.\n+\n+    Hint: If you want to create your own fixture on top of ``STARTUP``,\n+    create a new layer that has ``STARTUP`` as a base. Then instantiate\n+    this layer with your new "fixture" layer as a base, e.g.::\n+\n+        from plone.testing import z2\n+        from plone.testing import Layer\n+\n+        class MyFixture(Layer):\n+\n+            ...\n+\n+        MY_FIXTURE = MyFixture(bases=(z2.STARTUP,), name=\'MyFixture\')\n+        MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Integration\')  # noqa\n+    """\n+\n+    defaultBases = (STARTUP,)\n+\n+    # Test lifecycle\n+\n+    def testSetUp(self):\n+        import Zope2\n+\n+        # Open a new app and save it as the resource ``app``.\n+\n+        environ = {\n+            \'SERVER_NAME\': self[\'host\'],\n+            \'SERVER_PORT\': str(self[\'port\']),\n+        }\n+\n+        app = addRequestContainer(Zope2.app(), environ=environ)\n+        request = app.REQUEST\n+        request[\'PARENTS\'] = [app]\n+\n+        # Make sure we have a zope.globalrequest request\n+        try:\n+            from zope.globalrequest import setRequest\n+            setRequest(request)\n+        except ImportError:\n+            pass\n+\n+        # Start a transaction\n+        transaction.begin()\n+\n+        self._original_commit = transaction.commit\n+\n+        def you_broke_it():\n+            raise TestIsolationBroken("""You are in a Test Layer\n+(IntegrationTesting) that is fast by just aborting transactions between each\n+test.  You just committed something. That breaks the test isolation.  So I stop\n+here and let you fix it.""")\n+\n+        # XXX TODO Restore this.\n+        # Temporarily allow commits in integration tests.\n+        # Plone 5.1 still uses plone.testing 4.1.1, and for Zope 4 integration\n+        # we want master, but without the commit-breaking for now.\n+        # transaction.commit = you_broke_it\n+\n+        # Save resources for tests to access\n+        self[\'app\'] = app\n+        self[\'request\'] = request\n+\n+    def testTearDown(self):\n+\n+        # Abort the transaction\n+        transaction.abort()\n+\n+        transaction.commit = self._original_commit\n+\n+        # Make sure we have a zope.globalrequest request\n+        try:\n+            from zope.globalrequest import setRequest\n+            setRequest(None)\n+        except ImportError:\n+            pass\n+\n+        # Close the database connection and the request\n+        app = self[\'app\']\n+        app.REQUEST.close()\n+        app._p_jar.close()\n+\n+        # Delete the resources\n+        del self[\'request\']\n+        del self[\'app\']\n+\n+\n+INTEGRATION_TESTING = IntegrationTesting()\n+\n+\n+class FunctionalTesting(Layer):\n+    """An alternative to ``INTEGRATION_TESTING`` suitable for functional testing.\n+    This one pushes and pops a ``DemoStorage`` layer for each test. The\n+    net result is that a test may commit safely.\n+\n+    As with ``INTEGRATION_TESTING``, the application root is available as the\n+    resource ``app`` and the request is available as the resource ``request``,\n+    set up and torn down for each test.\n+\n+    Hint: If you want to create your own fixture on top of ``STARTUP``,\n+    create a new layer that has ``STARTUP`` as a base. Then instantiate\n+    this layer with your new "fixture" layer as a base, e.g.::\n+\n+        from plone.testing import z2\n+        from plone.testing import Layer\n+\n+        class MyFixture(Layer):\n+\n+            ...\n+\n+        MY_FIXTURE = MyFixture(bases=(z2.STARTUP,), name=\'MyFixture\')\n+        MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Functional\')  # noqa\n+    """\n+\n+    defaultBases = (STARTUP,)\n+\n+    # Test lifecycle\n+\n+    def testSetUp(self):\n+        import Zope2\n+\n+        # Override zodbDB from the layer setup. Since it was set up by\n+        # this layer, we can\'t just assign a new shadow. We therefore keep\n+        # track of the original so that we can restore it on tear-down.\n+\n+        self[\'zodbDB\'] = zodb.stackDemoStorage(\n+            self.get(\'zodbDB\'),\n+            name=\'FunctionalTest\')\n+\n+        # Save the app\n+\n+        environ = {\n+            \'SERVER_NAME\': self[\'host\'],\n+            \'SERVER_PORT\': str(self[\'port\']),\n+        }\n+\n+        app = addRequestContainer(Zope2.app(), environ=environ)\n+        request = app.REQUEST\n+        request[\'PARENTS\'] = [app]\n+\n+        # Make sure we have a zope.globalrequest request\n+        try:\n+            from zope.globalrequest import setRequest\n+            setRequest(request)\n+        except ImportError:\n+            pass\n+\n+        # Start a transaction\n+        transaction.begin()\n+\n+        # Save resources for the test\n+        self[\'app\'] = app\n+        self[\'request\'] = request\n+\n+    def testTearDown(self):\n+        # Abort any open transactions\n+        transaction.abort()\n+\n+        # Make sure we have a zope.globalrequest request\n+        try:\n+            from zope.globalrequest import setRequest\n+            setRequest(None)\n+        except ImportError:\n+            pass\n+\n+        # Close the database connection and the request\n+        app = self[\'app\']\n+        app.REQUEST.close()\n+        app._p_jar.close()\n+\n+        del self[\'app\']\n+        del self[\'request\']\n+\n+        # Close and discard the database\n+        self[\'zodbDB\'].close()\n+        del self[\'zodbDB\']\n+\n+\n+FUNCTIONAL_TESTING = FunctionalTesting()\n+\n+\n+# More advanced functional testing - running ZServer and FTP server\n+\n+class ZServer(Layer):\n+    """Start a ZServer that accesses the fixture managed by the\n+    ``STARTUP`` layer.\n+\n+    The host and port are available as the resources ``host`` and ``port``,\n+    respectively.\n+\n+    This should *not* be used in parallel with the ``FTP_SERVER`` layer, since\n+    it shares the same async loop.\n+\n+    The ``ZSERVER_FIXTURE`` layer must be used as the base for a layer that\n+    uses the ``FunctionalTesting`` layer class. The ``ZSERVER`` layer is\n+    an example of such a layer.\n+    """\n+\n+    defaultBases = (STARTUP,)\n+\n+    host = os.environ.get(\'ZSERVER_HOST\', \'localhost\')\n+    port = int(os.environ.get(\'ZSERVER_PORT\', 55001))\n+    timeout = 5.0\n+    log = None\n+\n+    def setUp(self):\n+\n+        import time\n+        from threading import Thread\n+\n+        self[\'host\'] = self.host\n+        self[\'port\'] = self.port\n+\n+        self._shutdown = False\n+\n+        self.setUpServer()\n+\n+        self.thread = Thread(\n+            name=\'{0} server\'.format(self.__name__),\n+            target=self.runner,\n+        )\n+\n+        self.thread.start()\n+        time.sleep(0.5)\n+\n+    def tearDown(self):\n+        import time\n+\n+        self._shutdown = True\n+        self.thread.join(self.timeout)\n+        time.sleep(0.5)\n+\n+        self.tearDownServer()\n+\n+        del self[\'host\']\n+        del self[\'port\']\n+\n+    def setUpServer(self):\n+        """Create a ZServer server instance and save it in self.zserver\n+        """\n+\n+        from ZServer import zhttp_server, zhttp_handler, logger\n+        from StringIO import StringIO\n+\n+        log = self.log\n+        if log is None:\n+            log = StringIO()\n+\n+        zopeLog = logger.file_logger(log)\n+\n+        server = zhttp_server(\n+            ip=self.host,\n+            port=self.port,\n+            resolver=None,\n+            logger_object=zopeLog)\n+        zhttpHandler = zhttp_handler(module=\'Zope2\', uri_base=\'\')\n+        server.install_handler(zhttpHandler)\n+\n+        self.zserver = server\n+\n+    def tearDownServer(self):\n+        """Close the ZServer socket\n+        """\n+        self.zserver.close()\n+\n+    # Thread runner\n+\n+    def runner(self):\n+        """Thread runner for the main asyncore loop. This function runs in a\n+        separate thread.\n+        """\n+\n+        import asyncore\n+\n+        # Poll\n+        socket_map = asyncore.socket_map\n+        while socket_map and not self._shutdown:\n+            asyncore.poll(self.timeout, socket_map)\n+\n+\n+# Fixture layer - use as a base layer, but don\'t use directly, as it has no\n+# test lifecycle\n+ZSERVER_FIXTURE = ZServer()\n+\n+# Functional testing layer that uses the ZSERVER_FIXTURE\n+ZSERVER = FunctionalTesting(\n+    bases=(\n+        ZSERVER_FIXTURE,\n+    ),\n+    name=\'ZServer:Functional\')\n+\n+\n+class FTPServer(ZServer):\n+    """FTP variant of the ZServer layer.\n+\n+    This will not play well with the ZServer layer. If you need both\n+    ZServer and FTPServer running together, you can subclass the ZServer\n+    layer class (like this layer class does) and implement setUpServer()\n+    and tearDownServer() to set up and close down two servers on different\n+    ports. They will then share a main loop.\n+\n+    The ``FTP_SERVER_FIXTURE`` layer must be used as the base for a layer that\n+    uses the ``FunctionalTesting`` layer class. The ``FTP_SERVER`` layer is\n+    an example of such a layer.\n+    """\n+\n+    defaultBases = (STARTUP,)\n+\n+    host = os.environ.get(\'FTPSERVER_HOST\', \'localhost\')\n+    port = int(os.environ.get(\'FTPSERVER_PORT\', 55002))\n+    threads = 1\n+    timeout = 5.0\n+    log = None\n+\n+    def setUpServer(self):\n+        """Create an FTP server instance and save it in self.ftpServer\n+        """\n+\n+        from ZServer import logger\n+        from ZServer.FTPServer import FTPServer\n+        from StringIO import StringIO\n+\n+        log = self.log\n+        if log is None:\n+            log = StringIO()\n+\n+        zopeLog = logger.file_logger(log)\n+\n+        self.ftpServer = FTPServer(\n+            \'Zope2\',\n+            ip=self.host,\n+            port=self.port,\n+            logger_object=zopeLog)\n+\n+    def tearDownServer(self):\n+        """Close the FTPServer socket\n+        """\n+        self.ftpServer.close()\n+\n+\n+# Fixture layer - use as a base layer, but don\'t use directly, as it has no\n+# test lifecycle\n+FTP_SERVER_FIXTURE = FTPServer()\n+\n+# Functional testing layer that uses the FTP_SERVER_FIXTURE\n+FTP_SERVER = FunctionalTesting(\n+    bases=(\n+        FTP_SERVER_FIXTURE,\n+    ),\n+    name=\'FTPServer:Functional\')\ndiff --git a/src/plone/testing/zserver.rst b/src/plone/testing/zserver.rst\nnew file mode 100644\nindex 0000000..6479e6a\n--- /dev/null\n+++ b/src/plone/testing/zserver.rst\n@@ -0,0 +1,651 @@\n+Zope 2 layers\n+-------------\n+\n+The Zope 2 layers are found in the module ``plone.testing.z2``:::\n+\n+    >>> from plone.testing import z2\n+\n+For testing, we need a testrunner:::\n+\n+    >>> from zope.testrunner import runner\n+\n+Startup\n+~~~~~~~\n+\n+``STARTUP`` is the base layer for all Zope 2 testing.\n+It sets up a Zope 2 sandbox environment that is suitable for testing.\n+It extends the ``zca.LAYER_CLEANUP`` layer to maximise the chances of having and leaving a pristine environment.\n+\n+**Note**: You should probably use at least ``INTEGRATION_TESTING`` for any real test, although ``STARTUP`` is a useful base layer if you are setting up your own fixture.\n+See the description of ``INTEGRATION_TESTING`` below.::\n+\n+    >>> "%s.%s" % (z2.STARTUP.__module__, z2.STARTUP.__name__,)\n+    \'plone.testing.z2.Startup\'\n+\n+    >>> z2.STARTUP.__bases__\n+    (<Layer \'plone.testing.zca.LayerCleanup\'>,)\n+\n+On layer setup, Zope is initialised in a lightweight manner.\n+This involves certain patches to global modules that Zope manages, to reduce setup time, a database based on ``DemoStorage``, and a minimal set of products that must be installed for Zope 2 to work.\n+A minimal set of ZCML is loaded, but packages in the ``Products`` namespace are not automatically configured.\n+\n+Let\'s just verify that we have an empty component registry before the test:::\n+\n+    >>> from zope.component import getSiteManager\n+    >>> list(getSiteManager().registeredAdapters())\n+    []\n+\n+Five sets a special vocabulary registry upon the layer setup, but there\'s a default one set before:::\n+\n+    >>> from zope.schema.vocabulary import getVocabularyRegistry\n+    >>> getVocabularyRegistry()\n+    <zope.schema.vocabulary.VocabularyRegistry object ...>\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, z2.STARTUP, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.z2.Startup in ... seconds.\n+\n+After layer setup, the ``zodbDB`` resource is available, pointing to the default ZODB.::\n+\n+    >>> z2.STARTUP[\'zodbDB\']\n+    <ZODB.DB.DB object at ...>\n+\n+    >>> z2.STARTUP[\'zodbDB\'].storage\n+    Startup\n+\n+In addition, the resources ``host`` and ``port`` are set to the default hostname and port that are used for URLs generated from Zope.\n+These are hardcoded, but shadowed by layers that provide actual running Zope instances.::\n+\n+    >>> z2.STARTUP[\'host\']\n+    \'nohost\'\n+    >>> z2.STARTUP[\'port\']\n+    80\n+\n+At this point, it is also possible to get hold of a Zope application root.\n+If you are setting up a layer fixture, you can obtain an application root with the correct database that is properly closed by using the ``zopeApp()`` context manager.::\n+\n+    >>> with z2.zopeApp() as app:\n+    ...     \'acl_users\' in app.objectIds()\n+    True\n+\n+If you want to use a specific database, you can pass that to ``zopeApp()`` as the ``db`` parameter.\n+A new connection will be opened and closed.::\n+\n+    >>> with z2.zopeApp(db=z2.STARTUP[\'zodbDB\']) as app:\n+    ...     \'acl_users\' in app.objectIds()\n+    True\n+\n+If you want to re-use an existing connection, you can pass one to ``zopeApp()`` as the ``connection`` argument.\n+In this case, you will need to close the connection yourself.::\n+\n+    >>> conn = z2.STARTUP[\'zodbDB\'].open()\n+    >>> with z2.zopeApp(connection=conn) as app:\n+    ...     \'acl_users\' in app.objectIds()\n+    True\n+\n+    >>> conn.opened is not None\n+    True\n+\n+    >>> conn.close()\n+\n+If an exception is raised within the ``with`` block, the transaction is aborted, but the connection is still closed (if it was opened by the context manager):::\n+\n+    >>> with z2.zopeApp() as app:\n+    ...     raise Exception("Test error")\n+    Traceback (most recent call last):\n+    ...\n+    Exception: Test error\n+\n+It is common to combine the ``zopeApp()`` context manager with a stacked ``DemoStorage`` to set up a layer-specific fixture.\n+As a sketch:::\n+\n+    from plone.testing import Layer, z2, zodb\n+\n+    class MyLayer(Layer):\n+        defaultBases = (z2.STARTUP,)\n+\n+        def setUp(self):\n+            self[\'zodbDB\'] = zodb.stackDemoStorage(self.get(\'zodbDB\'), name=\'MyLayer\')\n+            with z2.zopeApp() as app:\n+\n+                # Set up a fixture, e.g.:\n+                app.manage_addFolder(\'folder1\')\n+                folder = app[\'folder1\']\n+                folder._addRole(\'role1\')\n+                folder.manage_addUserFolder()\n+\n+                userFolder = folder[\'acl_users\']\n+                ignore = userFolder.userFolderAddUser(\'user1\', \'secret\', [\'role1\'], [])\n+                folder.manage_role(\'role1\', (\'Access contents information\',))\n+\n+        def tearDown(self):\n+            self[\'zodbDB\'].close()\n+            del self[\'zodbDB\']\n+\n+Note that you would normally *not* use the ``z2.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.\n+The ``IntegrationTesting`` and ``FunctionalTesting`` layer classes manage the application object for you, exposing them as the resource ``app`` (see below).\n+\n+After layer setup, the global component registry contains a number of components needed by Zope.::\n+\n+    >>> len(list(getSiteManager().registeredAdapters())) > 1 # in fact, > a lot\n+    True\n+\n+And Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:::\n+\n+    >>> getVocabularyRegistry()\n+    <....Zope2VocabularyRegistry object at ...>\n+\n+To load additional ZCML, you can use the ``configurationContext`` resource:::\n+\n+    >>> z2.STARTUP[\'configurationContext\']\n+    <zope.configuration.config.ConfigurationMachine object ...>\n+\n+See ``zca.rst`` for details about how to use ``zope.configuration`` for this purpose.\n+\n+The ``STARTUP`` layer does not perform any specific test setup or tear-down.\n+That is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING`` layers, or other layers using their layer classes - ``IntegrationTesting`` and ``FunctionalTesting``.::\n+\n+    >>> z2.STARTUP.testSetUp()\n+    >>> z2.STARTUP.testTearDown()\n+\n+Layer tear-down resets the environment.::\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+    >>> import Zope2\n+    >>> Zope2._began_startup\n+    0\n+    >>> Zope2.DB is None\n+    True\n+    >>> Zope2.bobo_application is None\n+    True\n+\n+    >>> list(getSiteManager().registeredAdapters())\n+    []\n+\n+    >>> getVocabularyRegistry()\n+    <zope.schema.vocabulary.VocabularyRegistry object at ...>\n+\n+Integration test\n+~~~~~~~~~~~~~~~~\n+\n+``INTEGRATION_TESTING`` is intended for simple Zope 2 integration testing.\n+It extends ``STARTUP`` to ensure that a transaction is begun before and rolled back after each test.\n+Two resources, ``app`` and ``request``, are available during testing as well.\n+It does not manage any layer state - it implements the test lifecycle methods only.\n+\n+**Note:** You would normally *not* use ``INTEGRATION_TESTING`` as a base layer.\n+Instead, you\'d use the ``IntegrationTesting`` class to create your own layer with the testing lifecycle semantics of ``INTEGRATION_TESTING``.\n+See the ``plone.testing`` ``README`` file for an example.\n+\n+``app`` is the application root.\n+In a test, you should use this instead of the ``zopeApp`` context manager (which remains the weapon of choice for setting up persistent fixtures), because the ``app`` resource is part of the transaction managed by the layer.\n+\n+``request`` is a test request. It is the same as ``app.REQUEST``.::\n+\n+    >>> "%s.%s" % (z2.INTEGRATION_TESTING.__module__, z2.INTEGRATION_TESTING.__name__,)\n+    \'plone.testing.z2.IntegrationTesting\'\n+\n+    >>> z2.INTEGRATION_TESTING.__bases__\n+    (<Layer \'plone.testing.z2.Startup\'>,)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, z2.INTEGRATION_TESTING, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.z2.IntegrationTesting in ... seconds.\n+\n+Let\'s now simulate a test.\n+On test setup, the ``app`` resource is made available.\n+In a test, you should always use this to access the application root.::\n+\n+    >>> z2.STARTUP.testSetUp()\n+    >>> z2.INTEGRATION_TESTING.testSetUp()\n+\n+The test may now inspect and modify the environment.::\n+\n+    >>> app = z2.INTEGRATION_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app.manage_addFolder(\'folder1\')\n+    >>> \'acl_users\' in app.objectIds() and \'folder1\' in app.objectIds()\n+    True\n+\n+The request is also available:::\n+\n+    >>> z2.INTEGRATION_TESTING[\'request\'] # would normally be self.layer[\'request\']\n+    <HTTPRequest, URL=http://nohost>\n+\n+We can create a user and simulate logging in as that user, using the ``z2.login()`` helper:::\n+\n+    >>> app._addRole(\'role1\')\n+    >>> ignore = app[\'acl_users\'].userFolderAddUser(\'user1\', \'secret\', [\'role1\'], [])\n+    >>> z2.login(app[\'acl_users\'], \'user1\')\n+\n+The first argument to ``z2.login()`` is the user folder that contains the relevant user.\n+The second argument is the user\'s name.\n+There is no need to give the password.::\n+\n+    >>> from AccessControl import getSecurityManager\n+    >>> getSecurityManager().getUser()\n+    <User \'user1\'>\n+\n+You can change the roles of a user using the ``z2.setRoles()`` helper:::\n+\n+    >>> sorted(getSecurityManager().getUser().getRolesInContext(app))\n+    [\'Authenticated\', \'role1\']\n+\n+    >>> z2.setRoles(app[\'acl_users\'], \'user1\', [])\n+    >>> getSecurityManager().getUser().getRolesInContext(app)\n+    [\'Authenticated\']\n+\n+To become the anonymous user again, use ``z2.logout()``:::\n+\n+    >>> z2.logout()\n+    >>> getSecurityManager().getUser()\n+    <SpecialUser \'Anonymous User\'>\n+\n+On tear-down, the transaction is rolled back:::\n+\n+    >>> z2.INTEGRATION_TESTING.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+\n+    >>> \'app\' in z2.INTEGRATION_TESTING\n+    False\n+\n+    >>> \'request\' in z2.INTEGRATION_TESTING\n+    False\n+\n+    >>> with z2.zopeApp() as app:\n+    ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n+    True\n+\n+\n+Let\'s tear down the layers:::\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.testing.z2.IntegrationTesting in ... seconds.\n+    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+Functional testing\n+~~~~~~~~~~~~~~~~~~\n+\n+The ``FUNCTIONAL_TESTING`` layer is very similar to ``INTEGRATION_TESTING``, and exposes the same fixture and resources.\n+However, it has different transaction semantics.\n+``INTEGRATION_TESTING`` creates a single database storage, and rolls back the transaction after each test.\n+``FUNCTIONAL_TESTING`` creates a whole new database storage (stacked on top of the basic fixture) for each test.\n+This allows testing of code that performs an explicit commit, which is usually required for end-to-end testing.\n+The downside is that the set-up and tear-down of each test takes longer.\n+\n+**Note:** Again, you would normally *not* use ``FUNCTIONAL_TESTING`` as a base layer.\n+Instead, you\'d use the ``FunctionalTesting`` class to create your own layer with the testing lifecycle semantics of ``FUNCTIONAL_TESTING``.\n+See the ``plone.testing`` ``README`` file for an example.\n+\n+Like ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.::\n+\n+    >>> "%s.%s" % (z2.FUNCTIONAL_TESTING.__module__, z2.FUNCTIONAL_TESTING.__name__,)\n+    \'plone.testing.z2.FunctionalTesting\'\n+\n+    >>> z2.FUNCTIONAL_TESTING.__bases__\n+    (<Layer \'plone.testing.z2.Startup\'>,)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.z2.FunctionalTesting in ... seconds.\n+\n+Let\'s now simulate a test.\n+On test setup, the ``app`` resource is made available.\n+In a test, you should always use this to access the application root.\n+The ``request`` resource can be used to access the test request.::\n+\n+    >>> z2.STARTUP.testSetUp()\n+    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n+\n+The test may now inspect and modify the environment.\n+It may also commit things.::\n+\n+    >>> app = z2.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app.manage_addFolder(\'folder1\')\n+    >>> \'acl_users\' in app.objectIds() and \'folder1\' in app.objectIds()\n+    True\n+\n+    >>> import transaction\n+    >>> transaction.commit()\n+\n+On tear-down, the database is torn down.::\n+\n+    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+\n+    >>> \'app\' in z2.FUNCTIONAL_TESTING\n+    False\n+\n+    >>> \'request\' in z2.FUNCTIONAL_TESTING\n+    False\n+\n+    >>> with z2.zopeApp() as app:\n+    ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n+    True\n+\n+Let\'s tear down the layer:::\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.testing.z2.FunctionalTesting in ... seconds.\n+    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+The test browser\n+~~~~~~~~~~~~~~~~\n+\n+The ``FUNCTIONAL_TESTING`` layer and ``FunctionalTesting`` layer class are the basis for functional testing using ``zope.testbrowser``.\n+This simulates a web browser, allowing an application to be tested "end-to-end" via its user-facing interface.\n+\n+To use the test browser with a ``FunctionalTesting`` layer (such as the default ``FUNCTIONAL_TESTING`` layer instance), we need to use a custom browser client, which ensures that the test browser uses the correct ZODB and is appropriately isolated from the test code.::\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.z2.FunctionalTesting in ... seconds.\n+\n+Let\'s simulate a test:::\n+\n+    >>> z2.STARTUP.testSetUp()\n+    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n+\n+In the test, we can create a test browser client like so:::\n+\n+    >>> app = z2.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> browser = z2.Browser(app)\n+\n+It is usually best to let Zope errors be shown with full tracebacks:::\n+\n+    >>> browser.handleErrors = False\n+\n+We can add to the test fixture in the test.\n+For those changes to be visible to the test browser, however, we need to commit the transaction.::\n+\n+    >>> app.manage_addFolder(\'folder1\')\n+    >>> import transaction; transaction.commit()\n+\n+We can now view this via the test browser:::\n+\n+    >>> browser.open(app.absolute_url() + \'/folder1\')\n+\n+    >>> \'folder1\' in browser.contents\n+    True\n+\n+The test browser integration converts the URL into a request and passes control to Zope\'s publisher.\n+Let\'s check that query strings are available for input processing:::\n+\n+    >>> import urllib\n+    >>> qs = urllib.urlencode({\'foo\': \'boo, bar & baz\'})  # sic: the ampersand.\n+    >>> _ = app[\'folder1\'].addDTMLMethod(\'index_html\', file=\'<dtml-var foo>\')\n+    >>> import transaction; transaction.commit()\n+    >>> browser.open(app.absolute_url() + \'/folder1?\' + qs)\n+    >>> browser.contents\n+    \'boo, bar & baz\'\n+\n+The test browser also works with iterators.\n+Let\'s test that with a simple file implementation that uses an iterator.::\n+\n+    >>> from plone.testing.tests import DummyFile\n+    >>> app._setObject(\'file1\', DummyFile(\'file1\'))\n+    \'file1\'\n+\n+    >>> import transaction; transaction.commit()\n+\n+    >>> browser.open(app.absolute_url() + \'/file1\')\n+    >>> \'The test browser also works with iterators\' in browser.contents\n+    True\n+\n+See the ``zope.testbrowser`` documentation for more information about how to use the browser client.\n+\n+On tear-down, the database is torn down.::\n+\n+    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+\n+    >>> \'app\' in z2.FUNCTIONAL_TESTING\n+    False\n+\n+    >>> \'request\' in z2.FUNCTIONAL_TESTING\n+    False\n+\n+    >>> with z2.zopeApp() as app:\n+    ...     \'acl_users\' in app.objectIds()\\\n+    ...         and \'folder1\' not in app.objectIds()\\\n+    ...         and \'file1\' not in app.objectIds()\n+    True\n+\n+Let\'s tear down the layer:::\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.testing.z2.FunctionalTesting in ... seconds.\n+    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+HTTP server\n+~~~~~~~~~~~\n+\n+The ``ZSERVER_FIXTURE`` layer extends ``STARTUP`` to start a single-threaded Zope server in a separate thread.\n+This makes it possible to connect to the test instance using a web browser or a testing tool like Selenium or Windmill.\n+\n+The ``ZSERVER`` layer provides a ``FunctionalTesting`` layer that has ``ZSERVER_FIXTURE`` as its base.::\n+\n+    >>> "%s.%s" % (z2.ZSERVER_FIXTURE.__module__, z2.ZSERVER_FIXTURE.__name__,)\n+    \'plone.testing.z2.ZServer\'\n+\n+    >>> z2.ZSERVER_FIXTURE.__bases__\n+    (<Layer \'plone.testing.z2.Startup\'>,)\n+\n+\n+    >>> "%s.%s" % (z2.ZSERVER.__module__, z2.ZSERVER.__name__,)\n+    \'plone.testing.z2.ZServer:Functional\'\n+\n+    >>> z2.ZSERVER.__bases__\n+    (<Layer \'plone.testing.z2.ZServer\'>,)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, z2.ZSERVER, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.z2.ZServer in ... seconds.\n+    Set up plone.testing.z2.ZServer:Functional in ... seconds.\n+\n+After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n+\n+    >>> host = z2.ZSERVER[\'host\']\n+    >>> host\n+    \'localhost\'\n+\n+    >>> port = z2.ZSERVER[\'port\']\n+    >>> import os\n+    >>> port == int(os.environ.get(\'ZSERVER_PORT\', 55001))\n+    True\n+\n+Let\'s now simulate a test.\n+Test setup does nothing beyond what the base layers do.::\n+\n+    >>> z2.STARTUP.testSetUp()\n+    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n+    >>> z2.ZSERVER.testSetUp()\n+\n+It is common in a test to use the Python API to change the state of the server (e.g.\n+create some content or change a setting) and then use the HTTP protocol to look at the results.\n+Bear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``z2.login()`` and ``z2.logout()``, for instance, do not affect the server thread.::\n+\n+    >>> app = z2.ZSERVER[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app.manage_addFolder(\'folder1\')\n+\n+Note that we need to commit the transaction before it will show up in the other thread.::\n+\n+    >>> import transaction; transaction.commit()\n+\n+We can now look for this new object through the server.::\n+\n+    >>> app_url = app.absolute_url()\n+    >>> app_url.split(\':\')[:-1]\n+    [\'http\', \'//localhost\']\n+\n+    >>> import urllib2\n+    >>> conn = urllib2.urlopen(app_url + \'/folder1\', timeout=5)\n+    >>> print conn.read()\n+    <Folder at folder1>\n+    >>> conn.close()\n+\n+Test tear-down does nothing beyond what the base layers do.::\n+\n+    >>> z2.ZSERVER.testTearDown()\n+    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+\n+    >>> \'app\' in z2.ZSERVER\n+    False\n+\n+    >>> \'request\' in z2.ZSERVER\n+    False\n+\n+    >>> with z2.zopeApp() as app:\n+    ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n+    True\n+\n+When the server is torn down, the ZServer thread is stopped.::\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.testing.z2.ZServer:Functional in ... seconds.\n+    Tear down plone.testing.z2.ZServer in ... seconds.\n+    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+    >>> conn = urllib2.urlopen(app_url + \'/folder1\', timeout=5)\n+    Traceback (most recent call last):\n+    ...\n+    URLError: <urlopen error [Errno ...] Connection refused>\n+\n+FTP server\n+~~~~~~~~~~\n+\n+The ``FTP_SERVER`` layer is identical similar to ``ZSERVER``, except that it starts an FTP server instead of an HTTP server.\n+The fixture is contained in the ``FTP_SERVER_FIXTURE`` layer.\n+\n+    **Warning:** It is generally not safe to run the ``ZSERVER`` and ``FTP_SERVER`` layers concurrently, because they both start up the same ``asyncore`` loop.\n+    If you need concurrent HTTP and FTP servers in a test, you can create your own layer by subclassing the ``ZServer`` layer class, and overriding the ``setUpServer()`` and ``tearDownServer()`` hooks to set up and close both servers.\n+    See the code for an example.\n+\n+The ``FTP_SERVER_FIXTURE`` layer is based on the ``STARTUP`` layer.::\n+\n+    >>> "%s.%s" % (z2.FTP_SERVER_FIXTURE.__module__, z2.FTP_SERVER_FIXTURE.__name__,)\n+    \'plone.testing.z2.FTPServer\'\n+\n+    >>> z2.FTP_SERVER_FIXTURE.__bases__\n+    (<Layer \'plone.testing.z2.Startup\'>,)\n+\n+The ``FTP_SERVER`` layer is based on ``FTP_SERVER_FIXTURE``, using the ``FunctionalTesting`` layer class.::\n+\n+    >>> "%s.%s" % (z2.FTP_SERVER.__module__, z2.FTP_SERVER.__name__,)\n+    \'plone.testing.z2.FTPServer:Functional\'\n+\n+    >>> z2.FTP_SERVER.__bases__\n+    (<Layer \'plone.testing.z2.FTPServer\'>,)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, z2.FTP_SERVER, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.z2.FTPServer in ... seconds.\n+    Set up plone.testing.z2.FTPServer:Functional in ... seconds.\n+\n+After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n+\n+    >>> host = z2.FTP_SERVER[\'host\']\n+    >>> host\n+    \'localhost\'\n+\n+    >>> port = z2.FTP_SERVER[\'port\']\n+    >>> import os\n+    >>> port == int(os.environ.get(\'FTPSERVER_PORT\', 55002))\n+    True\n+\n+Let\'s now simulate a test.\n+Test setup does nothing beyond what the base layers do.::\n+\n+    >>> z2.STARTUP.testSetUp()\n+    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n+    >>> z2.FTP_SERVER.testSetUp()\n+\n+As with ``ZSERVER``, we will set up some content for the test and then access it over the FTP port.::\n+\n+    >>> app = z2.FTP_SERVER[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app.manage_addFolder(\'folder1\')\n+\n+We\'ll also create a user in the root user folder to make FTP access easier.::\n+\n+    >>> ignore = app[\'acl_users\'].userFolderAddUser(\'admin\', \'secret\', [\'Manager\'], ())\n+\n+Note that we need to commit the transaction before it will show up in the other thread.::\n+\n+    >>> import transaction; transaction.commit()\n+\n+We can now look for this new object through the server.::\n+\n+    >>> app_path = app.absolute_url_path()\n+\n+    >>> import ftplib\n+    >>> ftpClient = ftplib.FTP()\n+    >>> ftpClient.connect(host, port, timeout=5)\n+    \'220 ... FTP server (...) ready.\'\n+\n+    >>> ftpClient.login(\'admin\', \'secret\')\n+    \'230 Login successful.\'\n+\n+    >>> ftpClient.cwd(app_path)\n+    \'250 CWD command successful.\'\n+\n+    >>> ftpClient.retrlines(\'LIST\')\n+    drwxrwx---   1 Zope     Zope            0 ... .\n+    ...--w--w----   1 Zope     Zope            0 ... acl_users\n+    drwxrwx---   1 Zope     Zope            0 ... folder1\n+    \'226 Transfer complete\'\n+\n+    >>> ftpClient.quit()\n+    \'221 Goodbye.\'\n+\n+Test tear-down does nothing beyond what the base layers do.::\n+\n+    >>> z2.FTP_SERVER.testTearDown()\n+    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+\n+    >>> \'app\' in z2.ZSERVER\n+    False\n+\n+    >>> \'request\' in z2.ZSERVER\n+    False\n+\n+    >>> with z2.zopeApp() as app:\n+    ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n+    True\n+\n+When the server is torn down, the FTP thread is stopped.::\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.testing.z2.FTPServer:Functional in ... seconds.\n+    Tear down plone.testing.z2.FTPServer in ... seconds.\n+    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+    >>> ftpClient.connect(host, port, timeout=5)\n+    Traceback (most recent call last):\n+    ...\n+    error: [Errno ...] Connection refused\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Godefroid Chapelle (gotcha) <gotcha@bubblenet.be>
Commit: https://github.com/plone/plone.testing/commit/cc8ce1ad2faed7f011462d740692849e576d9e11

move before fix to keep git history

Files changed:
A src/plone/testing/wsgi.py
A src/plone/testing/wsgi.rst
D src/plone/testing/z2.py
D src/plone/testing/z2.rst

b'diff --git a/src/plone/testing/z2.py b/src/plone/testing/wsgi.py\nsimilarity index 100%\nrename from src/plone/testing/z2.py\nrename to src/plone/testing/wsgi.py\ndiff --git a/src/plone/testing/z2.rst b/src/plone/testing/wsgi.rst\nsimilarity index 100%\nrename from src/plone/testing/z2.rst\nrename to src/plone/testing/wsgi.rst\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Godefroid Chapelle (gotcha) <gotcha@bubblenet.be>
Commit: https://github.com/plone/plone.testing/commit/49a1efda029637dc8464a912210e3f5473ad804e

split z2 layers into wsgi and zserver layers

This implies testing them separately.

TODO:
- remove duplicate code
- bring back z2 for BBB

Files changed:
M setup.py
M src/plone/testing/tests.py
M src/plone/testing/wsgi.py
M src/plone/testing/wsgi.rst
M src/plone/testing/zserver.py
M src/plone/testing/zserver.rst

b'diff --git a/setup.py b/setup.py\nindex 92bc8db..2612a70 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -41,7 +41,8 @@\n         open(os.path.join("src", "plone", "testing", "security.rst")).read(),\n         open(os.path.join("src", "plone", "testing", "publisher.rst")).read(),\n         open(os.path.join("src", "plone", "testing", "zodb.rst")).read(),\n-        open(os.path.join("src", "plone", "testing", "z2.rst")).read()\n+        open(os.path.join("src", "plone", "testing", "wsgi.rst")).read(),\n+        open(os.path.join("src", "plone", "testing", "zserver.rst")).read(),\n     ])),\n     classifiers=[\n         "Environment :: Web Environment",\ndiff --git a/src/plone/testing/tests.py b/src/plone/testing/tests.py\nindex 923bc22..29068e5 100644\n--- a/src/plone/testing/tests.py\n+++ b/src/plone/testing/tests.py\n@@ -48,7 +48,7 @@ class DummyFile(SimpleItem):\n \n     def __call__(self):\n         path = get_distribution(\'plone.testing\').location\n-        path = os.path.join(path, \'plone\', \'testing\', \'z2.rst\')\n+        path = os.path.join(path, \'plone\', \'testing\', \'wsgi.rst\')\n \n         request = self.REQUEST\n         response = request.response\n@@ -74,6 +74,7 @@ def test_suite():\n             \'security.rst\',\n             \'publisher.rst\',\n             \'zodb.rst\',\n+            \'wsgi.rst\',\n             setUp=setUp,\n             tearDown=tearDown,\n             optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,\n@@ -89,7 +90,7 @@ def test_suite():\n     if HAS_ZSERVER:\n         suite.addTests([\n             doctest.DocFileSuite(\n-                \'z2.rst\',\n+                \'zserver.rst\',\n                 setUp=setUp,\n                 tearDown=tearDown,\n                 optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,\ndiff --git a/src/plone/testing/wsgi.py b/src/plone/testing/wsgi.py\nindex 17f7a83..80a65f1 100644\n--- a/src/plone/testing/wsgi.py\n+++ b/src/plone/testing/wsgi.py\n@@ -12,7 +12,6 @@\n from zope.schema.vocabulary import setVocabularyRegistry\n \n import contextlib\n-import os\n import transaction\n \n \n@@ -333,7 +332,7 @@ def setUp(self):\n         self.setUpDebugMode()\n         self.setUpClientCache()\n         self.setUpPatches()\n-        self.setUpThreads()\n+        # self.setUpThreads()\n         self.setUpHostPort()\n         self.setUpDatabase()\n         self.setUpApp()\n@@ -348,7 +347,7 @@ def tearDown(self):\n         self.tearDownApp()\n         self.tearDownDatabase()\n         self.tearDownHostPort()\n-        self.tearDownThreads()\n+        # self.tearDownThreads()\n         self.tearDownPatches()\n         self.tearDownClientCache()\n         self.tearDownDebugMode()\n@@ -628,7 +627,7 @@ def setUpApp(self):\n         # That DB then gets stored as Zope2.DB and becomes the default.\n \n         import Zope2\n-        Zope2.startup()\n+        Zope2.startup_wsgi()\n \n         # At this point, Zope2.DB is set to the test database facade. This is\n         # the database will be used by default when someone does Zope2.app().\n@@ -660,15 +659,8 @@ def tearDownApp(self):\n             App.config.setConfiguration(config)\n             del self._testingHome\n \n-        # Clear out the app reference cached in get_module_info\'s\n-        # \'modules\' parameter default dict. (waaaaa)\n-        import ZPublisher.Publish\n-        defaults = ZPublisher.Publish.get_module_info.func_defaults\n-\n-        if defaults:\n-            d = list(defaults)\n-            d[0] = {}\n-            ZPublisher.Publish.get_module_info.func_defaults = tuple(d)\n+        import ZPublisher.WSGIPublisher\n+        ZPublisher.WSGIPublisher._MODULES.clear()\n \n     def setUpBasicProducts(self):\n         """Install a minimal set of products required for Zope 2.\n@@ -949,188 +941,3 @@ def testTearDown(self):\n         # Close and discard the database\n         self[\'zodbDB\'].close()\n         del self[\'zodbDB\']\n-\n-\n-FUNCTIONAL_TESTING = FunctionalTesting()\n-\n-\n-# More advanced functional testing - running ZServer and FTP server\n-\n-class ZServer(Layer):\n-    """Start a ZServer that accesses the fixture managed by the\n-    ``STARTUP`` layer.\n-\n-    The host and port are available as the resources ``host`` and ``port``,\n-    respectively.\n-\n-    This should *not* be used in parallel with the ``FTP_SERVER`` layer, since\n-    it shares the same async loop.\n-\n-    The ``ZSERVER_FIXTURE`` layer must be used as the base for a layer that\n-    uses the ``FunctionalTesting`` layer class. The ``ZSERVER`` layer is\n-    an example of such a layer.\n-    """\n-\n-    defaultBases = (STARTUP,)\n-\n-    host = os.environ.get(\'ZSERVER_HOST\', \'localhost\')\n-    port = int(os.environ.get(\'ZSERVER_PORT\', 55001))\n-    timeout = 5.0\n-    log = None\n-\n-    def setUp(self):\n-\n-        import time\n-        from threading import Thread\n-\n-        self[\'host\'] = self.host\n-        self[\'port\'] = self.port\n-\n-        self._shutdown = False\n-\n-        self.setUpExceptionHook()\n-        self.setUpServer()\n-\n-        self.thread = Thread(\n-            name=\'{0} server\'.format(self.__name__),\n-            target=self.runner,\n-        )\n-\n-        self.thread.start()\n-        time.sleep(0.5)\n-\n-    def tearDown(self):\n-        import time\n-\n-        self._shutdown = True\n-        self.thread.join(self.timeout)\n-        time.sleep(0.5)\n-\n-        self.tearDownServer()\n-        self.tearDownExceptionHook()\n-\n-        del self[\'host\']\n-        del self[\'port\']\n-\n-    def setUpExceptionHook(self):\n-        from ZServer.ZPublisher.exceptionhook import EXCEPTION_HOOK\n-        import Zope2\n-        Zope2.zpublisher_exception_hook = EXCEPTION_HOOK\n-\n-    def tearDownExceptionHook(self):\n-        import Zope2\n-        Zope2.zpublisher_exception_hook = None\n-\n-    def setUpServer(self):\n-        """Create a ZServer server instance and save it in self.zserver\n-        """\n-\n-        from ZServer import zhttp_server, zhttp_handler, logger\n-        from StringIO import StringIO\n-\n-        log = self.log\n-        if log is None:\n-            log = StringIO()\n-\n-        zopeLog = logger.file_logger(log)\n-\n-        server = zhttp_server(\n-            ip=self.host,\n-            port=self.port,\n-            resolver=None,\n-            logger_object=zopeLog)\n-        zhttpHandler = zhttp_handler(module=\'Zope2\', uri_base=\'\')\n-        server.install_handler(zhttpHandler)\n-\n-        self.zserver = server\n-\n-    def tearDownServer(self):\n-        """Close the ZServer socket\n-        """\n-        self.zserver.close()\n-\n-    # Thread runner\n-\n-    def runner(self):\n-        """Thread runner for the main asyncore loop. This function runs in a\n-        separate thread.\n-        """\n-\n-        import asyncore\n-\n-        # Poll\n-        socket_map = asyncore.socket_map\n-        while socket_map and not self._shutdown:\n-            asyncore.poll(self.timeout, socket_map)\n-\n-\n-# Fixture layer - use as a base layer, but don\'t use directly, as it has no\n-# test lifecycle\n-ZSERVER_FIXTURE = ZServer()\n-\n-# Functional testing layer that uses the ZSERVER_FIXTURE\n-ZSERVER = FunctionalTesting(\n-    bases=(\n-        ZSERVER_FIXTURE,\n-    ),\n-    name=\'ZServer:Functional\')\n-\n-\n-class FTPServer(ZServer):\n-    """FTP variant of the ZServer layer.\n-\n-    This will not play well with the ZServer layer. If you need both\n-    ZServer and FTPServer running together, you can subclass the ZServer\n-    layer class (like this layer class does) and implement setUpServer()\n-    and tearDownServer() to set up and close down two servers on different\n-    ports. They will then share a main loop.\n-\n-    The ``FTP_SERVER_FIXTURE`` layer must be used as the base for a layer that\n-    uses the ``FunctionalTesting`` layer class. The ``FTP_SERVER`` layer is\n-    an example of such a layer.\n-    """\n-\n-    defaultBases = (STARTUP,)\n-\n-    host = os.environ.get(\'FTPSERVER_HOST\', \'localhost\')\n-    port = int(os.environ.get(\'FTPSERVER_PORT\', 55002))\n-    threads = 1\n-    timeout = 5.0\n-    log = None\n-\n-    def setUpServer(self):\n-        """Create an FTP server instance and save it in self.ftpServer\n-        """\n-\n-        from ZServer import logger\n-        from ZServer.FTPServer import FTPServer\n-        from StringIO import StringIO\n-\n-        log = self.log\n-        if log is None:\n-            log = StringIO()\n-\n-        zopeLog = logger.file_logger(log)\n-\n-        self.ftpServer = FTPServer(\n-            \'Zope2\',\n-            ip=self.host,\n-            port=self.port,\n-            logger_object=zopeLog)\n-\n-    def tearDownServer(self):\n-        """Close the FTPServer socket\n-        """\n-        self.ftpServer.close()\n-\n-\n-# Fixture layer - use as a base layer, but don\'t use directly, as it has no\n-# test lifecycle\n-FTP_SERVER_FIXTURE = FTPServer()\n-\n-# Functional testing layer that uses the FTP_SERVER_FIXTURE\n-FTP_SERVER = FunctionalTesting(\n-    bases=(\n-        FTP_SERVER_FIXTURE,\n-    ),\n-    name=\'FTPServer:Functional\')\ndiff --git a/src/plone/testing/wsgi.rst b/src/plone/testing/wsgi.rst\nindex 6479e6a..2ea6241 100644\n--- a/src/plone/testing/wsgi.rst\n+++ b/src/plone/testing/wsgi.rst\n@@ -1,9 +1,9 @@\n-Zope 2 layers\n+Zope WSGI layers\n -------------\n \n-The Zope 2 layers are found in the module ``plone.testing.z2``:::\n+The Zope WSGI layers are found in the module ``plone.testing.wsgi``:::\n \n-    >>> from plone.testing import z2\n+    >>> from plone.testing import wsgi\n \n For testing, we need a testrunner:::\n \n@@ -12,17 +12,17 @@ For testing, we need a testrunner:::\n Startup\n ~~~~~~~\n \n-``STARTUP`` is the base layer for all Zope 2 testing.\n-It sets up a Zope 2 sandbox environment that is suitable for testing.\n+``STARTUP`` is the base layer for all Zope WSGI testing.\n+It sets up a Zope WSGI sandbox environment that is suitable for testing.\n It extends the ``zca.LAYER_CLEANUP`` layer to maximise the chances of having and leaving a pristine environment.\n \n **Note**: You should probably use at least ``INTEGRATION_TESTING`` for any real test, although ``STARTUP`` is a useful base layer if you are setting up your own fixture.\n See the description of ``INTEGRATION_TESTING`` below.::\n \n-    >>> "%s.%s" % (z2.STARTUP.__module__, z2.STARTUP.__name__,)\n-    \'plone.testing.z2.Startup\'\n+    >>> "%s.%s" % (wsgi.STARTUP.__module__, wsgi.STARTUP.__name__,)\n+    \'plone.testing.wsgi.Startup\'\n \n-    >>> z2.STARTUP.__bases__\n+    >>> wsgi.STARTUP.__bases__\n     (<Layer \'plone.testing.zca.LayerCleanup\'>,)\n \n On layer setup, Zope is initialised in a lightweight manner.\n@@ -43,45 +43,45 @@ Five sets a special vocabulary registry upon the layer setup, but there\'s a defa\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.STARTUP, setupLayers)\n+    >>> runner.setup_layer(options, wsgi.STARTUP, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.wsgi.Startup in ... seconds.\n \n After layer setup, the ``zodbDB`` resource is available, pointing to the default ZODB.::\n \n-    >>> z2.STARTUP[\'zodbDB\']\n+    >>> wsgi.STARTUP[\'zodbDB\']\n     <ZODB.DB.DB object at ...>\n \n-    >>> z2.STARTUP[\'zodbDB\'].storage\n+    >>> wsgi.STARTUP[\'zodbDB\'].storage\n     Startup\n \n In addition, the resources ``host`` and ``port`` are set to the default hostname and port that are used for URLs generated from Zope.\n These are hardcoded, but shadowed by layers that provide actual running Zope instances.::\n \n-    >>> z2.STARTUP[\'host\']\n+    >>> wsgi.STARTUP[\'host\']\n     \'nohost\'\n-    >>> z2.STARTUP[\'port\']\n+    >>> wsgi.STARTUP[\'port\']\n     80\n \n At this point, it is also possible to get hold of a Zope application root.\n If you are setting up a layer fixture, you can obtain an application root with the correct database that is properly closed by using the ``zopeApp()`` context manager.::\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with wsgi.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds()\n     True\n \n If you want to use a specific database, you can pass that to ``zopeApp()`` as the ``db`` parameter.\n A new connection will be opened and closed.::\n \n-    >>> with z2.zopeApp(db=z2.STARTUP[\'zodbDB\']) as app:\n+    >>> with wsgi.zopeApp(db=wsgi.STARTUP[\'zodbDB\']) as app:\n     ...     \'acl_users\' in app.objectIds()\n     True\n \n If you want to re-use an existing connection, you can pass one to ``zopeApp()`` as the ``connection`` argument.\n In this case, you will need to close the connection yourself.::\n \n-    >>> conn = z2.STARTUP[\'zodbDB\'].open()\n-    >>> with z2.zopeApp(connection=conn) as app:\n+    >>> conn = wsgi.STARTUP[\'zodbDB\'].open()\n+    >>> with wsgi.zopeApp(connection=conn) as app:\n     ...     \'acl_users\' in app.objectIds()\n     True\n \n@@ -92,7 +92,7 @@ In this case, you will need to close the connection yourself.::\n \n If an exception is raised within the ``with`` block, the transaction is aborted, but the connection is still closed (if it was opened by the context manager):::\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with wsgi.zopeApp() as app:\n     ...     raise Exception("Test error")\n     Traceback (most recent call last):\n     ...\n@@ -101,14 +101,14 @@ If an exception is raised within the ``with`` block, the transaction is aborted,\n It is common to combine the ``zopeApp()`` context manager with a stacked ``DemoStorage`` to set up a layer-specific fixture.\n As a sketch:::\n \n-    from plone.testing import Layer, z2, zodb\n+    from plone.testing import Layer, wsgi, zodb\n \n     class MyLayer(Layer):\n-        defaultBases = (z2.STARTUP,)\n+        defaultBases = (wsgi.STARTUP,)\n \n         def setUp(self):\n             self[\'zodbDB\'] = zodb.stackDemoStorage(self.get(\'zodbDB\'), name=\'MyLayer\')\n-            with z2.zopeApp() as app:\n+            with wsgi.zopeApp() as app:\n \n                 # Set up a fixture, e.g.:\n                 app.manage_addFolder(\'folder1\')\n@@ -124,7 +124,7 @@ As a sketch:::\n             self[\'zodbDB\'].close()\n             del self[\'zodbDB\']\n \n-Note that you would normally *not* use the ``z2.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.\n+Note that you would normally *not* use the ``wsgi.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.\n The ``IntegrationTesting`` and ``FunctionalTesting`` layer classes manage the application object for you, exposing them as the resource ``app`` (see below).\n \n After layer setup, the global component registry contains a number of components needed by Zope.::\n@@ -139,7 +139,7 @@ And Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:::\n \n To load additional ZCML, you can use the ``configurationContext`` resource:::\n \n-    >>> z2.STARTUP[\'configurationContext\']\n+    >>> wsgi.STARTUP[\'configurationContext\']\n     <zope.configuration.config.ConfigurationMachine object ...>\n \n See ``zca.rst`` for details about how to use ``zope.configuration`` for this purpose.\n@@ -147,13 +147,13 @@ See ``zca.rst`` for details about how to use ``zope.configuration`` for this pur\n The ``STARTUP`` layer does not perform any specific test setup or tear-down.\n That is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING`` layers, or other layers using their layer classes - ``IntegrationTesting`` and ``FunctionalTesting``.::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> wsgi.STARTUP.testSetUp()\n+    >>> wsgi.STARTUP.testTearDown()\n \n Layer tear-down resets the environment.::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.wsgi.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n     >>> import Zope2\n@@ -173,7 +173,7 @@ Layer tear-down resets the environment.::\n Integration test\n ~~~~~~~~~~~~~~~~\n \n-``INTEGRATION_TESTING`` is intended for simple Zope 2 integration testing.\n+``INTEGRATION_TESTING`` is intended for simple Zope WSGI integration testing.\n It extends ``STARTUP`` to ensure that a transaction is begun before and rolled back after each test.\n Two resources, ``app`` and ``request``, are available during testing as well.\n It does not manage any layer state - it implements the test lifecycle methods only.\n@@ -187,45 +187,45 @@ In a test, you should use this instead of the ``zopeApp`` context manager (which\n \n ``request`` is a test request. It is the same as ``app.REQUEST``.::\n \n-    >>> "%s.%s" % (z2.INTEGRATION_TESTING.__module__, z2.INTEGRATION_TESTING.__name__,)\n-    \'plone.testing.z2.IntegrationTesting\'\n+    >>> "%s.%s" % (wsgi.INTEGRATION_TESTING.__module__, wsgi.INTEGRATION_TESTING.__name__,)\n+    \'plone.testing.wsgi.IntegrationTesting\'\n \n-    >>> z2.INTEGRATION_TESTING.__bases__\n-    (<Layer \'plone.testing.z2.Startup\'>,)\n+    >>> wsgi.INTEGRATION_TESTING.__bases__\n+    (<Layer \'plone.testing.wsgi.Startup\'>,)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.INTEGRATION_TESTING, setupLayers)\n+    >>> runner.setup_layer(options, wsgi.INTEGRATION_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.IntegrationTesting in ... seconds.\n+    Set up plone.testing.wsgi.Startup in ... seconds.\n+    Set up plone.testing.wsgi.IntegrationTesting in ... seconds.\n \n Let\'s now simulate a test.\n On test setup, the ``app`` resource is made available.\n In a test, you should always use this to access the application root.::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.INTEGRATION_TESTING.testSetUp()\n+    >>> wsgi.STARTUP.testSetUp()\n+    >>> wsgi.INTEGRATION_TESTING.testSetUp()\n \n The test may now inspect and modify the environment.::\n \n-    >>> app = z2.INTEGRATION_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app = wsgi.INTEGRATION_TESTING[\'app\'] # would normally be self.layer[\'app\']\n     >>> app.manage_addFolder(\'folder1\')\n     >>> \'acl_users\' in app.objectIds() and \'folder1\' in app.objectIds()\n     True\n \n The request is also available:::\n \n-    >>> z2.INTEGRATION_TESTING[\'request\'] # would normally be self.layer[\'request\']\n+    >>> wsgi.INTEGRATION_TESTING[\'request\'] # would normally be self.layer[\'request\']\n     <HTTPRequest, URL=http://nohost>\n \n-We can create a user and simulate logging in as that user, using the ``z2.login()`` helper:::\n+We can create a user and simulate logging in as that user, using the ``wsgi.login()`` helper:::\n \n     >>> app._addRole(\'role1\')\n     >>> ignore = app[\'acl_users\'].userFolderAddUser(\'user1\', \'secret\', [\'role1\'], [])\n-    >>> z2.login(app[\'acl_users\'], \'user1\')\n+    >>> wsgi.login(app[\'acl_users\'], \'user1\')\n \n-The first argument to ``z2.login()`` is the user folder that contains the relevant user.\n+The first argument to ``wsgi.login()`` is the user folder that contains the relevant user.\n The second argument is the user\'s name.\n There is no need to give the password.::\n \n@@ -233,33 +233,33 @@ There is no need to give the password.::\n     >>> getSecurityManager().getUser()\n     <User \'user1\'>\n \n-You can change the roles of a user using the ``z2.setRoles()`` helper:::\n+You can change the roles of a user using the ``wsgi.setRoles()`` helper:::\n \n     >>> sorted(getSecurityManager().getUser().getRolesInContext(app))\n     [\'Authenticated\', \'role1\']\n \n-    >>> z2.setRoles(app[\'acl_users\'], \'user1\', [])\n+    >>> wsgi.setRoles(app[\'acl_users\'], \'user1\', [])\n     >>> getSecurityManager().getUser().getRolesInContext(app)\n     [\'Authenticated\']\n \n-To become the anonymous user again, use ``z2.logout()``:::\n+To become the anonymous user again, use ``wsgi.logout()``:::\n \n-    >>> z2.logout()\n+    >>> wsgi.logout()\n     >>> getSecurityManager().getUser()\n     <SpecialUser \'Anonymous User\'>\n \n On tear-down, the transaction is rolled back:::\n \n-    >>> z2.INTEGRATION_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> wsgi.INTEGRATION_TESTING.testTearDown()\n+    >>> wsgi.STARTUP.testTearDown()\n \n-    >>> \'app\' in z2.INTEGRATION_TESTING\n+    >>> \'app\' in wsgi.INTEGRATION_TESTING\n     False\n \n-    >>> \'request\' in z2.INTEGRATION_TESTING\n+    >>> \'request\' in wsgi.INTEGRATION_TESTING\n     False\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with wsgi.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n     True\n \n@@ -267,8 +267,8 @@ On tear-down, the transaction is rolled back:::\n Let\'s tear down the layers:::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.IntegrationTesting in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.wsgi.IntegrationTesting in ... seconds.\n+    Tear down plone.testing.wsgi.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n Functional testing\n@@ -287,31 +287,31 @@ See the ``plone.testing`` ``README`` file for an example.\n \n Like ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.::\n \n-    >>> "%s.%s" % (z2.FUNCTIONAL_TESTING.__module__, z2.FUNCTIONAL_TESTING.__name__,)\n-    \'plone.testing.z2.FunctionalTesting\'\n+    >>> "%s.%s" % (wsgi.FUNCTIONAL_TESTING.__module__, wsgi.FUNCTIONAL_TESTING.__name__,)\n+    \'plone.testing.wsgi.FunctionalTesting\'\n \n-    >>> z2.FUNCTIONAL_TESTING.__bases__\n-    (<Layer \'plone.testing.z2.Startup\'>,)\n+    >>> wsgi.FUNCTIONAL_TESTING.__bases__\n+    (<Layer \'plone.testing.wsgi.Startup\'>,)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)\n+    >>> runner.setup_layer(options, wsgi.FUNCTIONAL_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.FunctionalTesting in ... seconds.\n+    Set up plone.testing.wsgi.Startup in ... seconds.\n+    Set up plone.testing.wsgi.FunctionalTesting in ... seconds.\n \n Let\'s now simulate a test.\n On test setup, the ``app`` resource is made available.\n In a test, you should always use this to access the application root.\n The ``request`` resource can be used to access the test request.::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n+    >>> wsgi.STARTUP.testSetUp()\n+    >>> wsgi.FUNCTIONAL_TESTING.testSetUp()\n \n The test may now inspect and modify the environment.\n It may also commit things.::\n \n-    >>> app = z2.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app = wsgi.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n     >>> app.manage_addFolder(\'folder1\')\n     >>> \'acl_users\' in app.objectIds() and \'folder1\' in app.objectIds()\n     True\n@@ -321,24 +321,24 @@ It may also commit things.::\n \n On tear-down, the database is torn down.::\n \n-    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> wsgi.FUNCTIONAL_TESTING.testTearDown()\n+    >>> wsgi.STARTUP.testTearDown()\n \n-    >>> \'app\' in z2.FUNCTIONAL_TESTING\n+    >>> \'app\' in wsgi.FUNCTIONAL_TESTING\n     False\n \n-    >>> \'request\' in z2.FUNCTIONAL_TESTING\n+    >>> \'request\' in wsgi.FUNCTIONAL_TESTING\n     False\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with wsgi.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n     True\n \n Let\'s tear down the layer:::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.FunctionalTesting in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.wsgi.FunctionalTesting in ... seconds.\n+    Tear down plone.testing.wsgi.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n The test browser\n@@ -351,20 +351,20 @@ To use the test browser with a ``FunctionalTesting`` layer (such as the default\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)\n+    >>> runner.setup_layer(options, wsgi.FUNCTIONAL_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.FunctionalTesting in ... seconds.\n+    Set up plone.testing.wsgi.Startup in ... seconds.\n+    Set up plone.testing.wsgi.FunctionalTesting in ... seconds.\n \n Let\'s simulate a test:::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n+    >>> wsgi.STARTUP.testSetUp()\n+    >>> wsgi.FUNCTIONAL_TESTING.testSetUp()\n \n In the test, we can create a test browser client like so:::\n \n-    >>> app = z2.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n-    >>> browser = z2.Browser(app)\n+    >>> app = wsgi.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> browser = wsgi.Browser(app)\n \n It is usually best to let Zope errors be shown with full tracebacks:::\n \n@@ -411,16 +411,16 @@ See the ``zope.testbrowser`` documentation for more information about how to use\n \n On tear-down, the database is torn down.::\n \n-    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> wsgi.FUNCTIONAL_TESTING.testTearDown()\n+    >>> wsgi.STARTUP.testTearDown()\n \n-    >>> \'app\' in z2.FUNCTIONAL_TESTING\n+    >>> \'app\' in wsgi.FUNCTIONAL_TESTING\n     False\n \n-    >>> \'request\' in z2.FUNCTIONAL_TESTING\n+    >>> \'request\' in wsgi.FUNCTIONAL_TESTING\n     False\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with wsgi.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds()\\\n     ...         and \'folder1\' not in app.objectIds()\\\n     ...         and \'file1\' not in app.objectIds()\n@@ -429,223 +429,7 @@ On tear-down, the database is torn down.::\n Let\'s tear down the layer:::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.FunctionalTesting in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.wsgi.FunctionalTesting in ... seconds.\n+    Tear down plone.testing.wsgi.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n-HTTP server\n-~~~~~~~~~~~\n-\n-The ``ZSERVER_FIXTURE`` layer extends ``STARTUP`` to start a single-threaded Zope server in a separate thread.\n-This makes it possible to connect to the test instance using a web browser or a testing tool like Selenium or Windmill.\n-\n-The ``ZSERVER`` layer provides a ``FunctionalTesting`` layer that has ``ZSERVER_FIXTURE`` as its base.::\n-\n-    >>> "%s.%s" % (z2.ZSERVER_FIXTURE.__module__, z2.ZSERVER_FIXTURE.__name__,)\n-    \'plone.testing.z2.ZServer\'\n-\n-    >>> z2.ZSERVER_FIXTURE.__bases__\n-    (<Layer \'plone.testing.z2.Startup\'>,)\n-\n-\n-    >>> "%s.%s" % (z2.ZSERVER.__module__, z2.ZSERVER.__name__,)\n-    \'plone.testing.z2.ZServer:Functional\'\n-\n-    >>> z2.ZSERVER.__bases__\n-    (<Layer \'plone.testing.z2.ZServer\'>,)\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.ZSERVER, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.ZServer in ... seconds.\n-    Set up plone.testing.z2.ZServer:Functional in ... seconds.\n-\n-After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n-\n-    >>> host = z2.ZSERVER[\'host\']\n-    >>> host\n-    \'localhost\'\n-\n-    >>> port = z2.ZSERVER[\'port\']\n-    >>> import os\n-    >>> port == int(os.environ.get(\'ZSERVER_PORT\', 55001))\n-    True\n-\n-Let\'s now simulate a test.\n-Test setup does nothing beyond what the base layers do.::\n-\n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n-    >>> z2.ZSERVER.testSetUp()\n-\n-It is common in a test to use the Python API to change the state of the server (e.g.\n-create some content or change a setting) and then use the HTTP protocol to look at the results.\n-Bear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``z2.login()`` and ``z2.logout()``, for instance, do not affect the server thread.::\n-\n-    >>> app = z2.ZSERVER[\'app\'] # would normally be self.layer[\'app\']\n-    >>> app.manage_addFolder(\'folder1\')\n-\n-Note that we need to commit the transaction before it will show up in the other thread.::\n-\n-    >>> import transaction; transaction.commit()\n-\n-We can now look for this new object through the server.::\n-\n-    >>> app_url = app.absolute_url()\n-    >>> app_url.split(\':\')[:-1]\n-    [\'http\', \'//localhost\']\n-\n-    >>> import urllib2\n-    >>> conn = urllib2.urlopen(app_url + \'/folder1\', timeout=5)\n-    >>> print conn.read()\n-    <Folder at folder1>\n-    >>> conn.close()\n-\n-Test tear-down does nothing beyond what the base layers do.::\n-\n-    >>> z2.ZSERVER.testTearDown()\n-    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n-\n-    >>> \'app\' in z2.ZSERVER\n-    False\n-\n-    >>> \'request\' in z2.ZSERVER\n-    False\n-\n-    >>> with z2.zopeApp() as app:\n-    ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n-    True\n-\n-When the server is torn down, the ZServer thread is stopped.::\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.ZServer:Functional in ... seconds.\n-    Tear down plone.testing.z2.ZServer in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-    >>> conn = urllib2.urlopen(app_url + \'/folder1\', timeout=5)\n-    Traceback (most recent call last):\n-    ...\n-    URLError: <urlopen error [Errno ...] Connection refused>\n-\n-FTP server\n-~~~~~~~~~~\n-\n-The ``FTP_SERVER`` layer is identical similar to ``ZSERVER``, except that it starts an FTP server instead of an HTTP server.\n-The fixture is contained in the ``FTP_SERVER_FIXTURE`` layer.\n-\n-    **Warning:** It is generally not safe to run the ``ZSERVER`` and ``FTP_SERVER`` layers concurrently, because they both start up the same ``asyncore`` loop.\n-    If you need concurrent HTTP and FTP servers in a test, you can create your own layer by subclassing the ``ZServer`` layer class, and overriding the ``setUpServer()`` and ``tearDownServer()`` hooks to set up and close both servers.\n-    See the code for an example.\n-\n-The ``FTP_SERVER_FIXTURE`` layer is based on the ``STARTUP`` layer.::\n-\n-    >>> "%s.%s" % (z2.FTP_SERVER_FIXTURE.__module__, z2.FTP_SERVER_FIXTURE.__name__,)\n-    \'plone.testing.z2.FTPServer\'\n-\n-    >>> z2.FTP_SERVER_FIXTURE.__bases__\n-    (<Layer \'plone.testing.z2.Startup\'>,)\n-\n-The ``FTP_SERVER`` layer is based on ``FTP_SERVER_FIXTURE``, using the ``FunctionalTesting`` layer class.::\n-\n-    >>> "%s.%s" % (z2.FTP_SERVER.__module__, z2.FTP_SERVER.__name__,)\n-    \'plone.testing.z2.FTPServer:Functional\'\n-\n-    >>> z2.FTP_SERVER.__bases__\n-    (<Layer \'plone.testing.z2.FTPServer\'>,)\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.FTP_SERVER, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.FTPServer in ... seconds.\n-    Set up plone.testing.z2.FTPServer:Functional in ... seconds.\n-\n-After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n-\n-    >>> host = z2.FTP_SERVER[\'host\']\n-    >>> host\n-    \'localhost\'\n-\n-    >>> port = z2.FTP_SERVER[\'port\']\n-    >>> import os\n-    >>> port == int(os.environ.get(\'FTPSERVER_PORT\', 55002))\n-    True\n-\n-Let\'s now simulate a test.\n-Test setup does nothing beyond what the base layers do.::\n-\n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n-    >>> z2.FTP_SERVER.testSetUp()\n-\n-As with ``ZSERVER``, we will set up some content for the test and then access it over the FTP port.::\n-\n-    >>> app = z2.FTP_SERVER[\'app\'] # would normally be self.layer[\'app\']\n-    >>> app.manage_addFolder(\'folder1\')\n-\n-We\'ll also create a user in the root user folder to make FTP access easier.::\n-\n-    >>> ignore = app[\'acl_users\'].userFolderAddUser(\'admin\', \'secret\', [\'Manager\'], ())\n-\n-Note that we need to commit the transaction before it will show up in the other thread.::\n-\n-    >>> import transaction; transaction.commit()\n-\n-We can now look for this new object through the server.::\n-\n-    >>> app_path = app.absolute_url_path()\n-\n-    >>> import ftplib\n-    >>> ftpClient = ftplib.FTP()\n-    >>> ftpClient.connect(host, port, timeout=5)\n-    \'220 ... FTP server (...) ready.\'\n-\n-    >>> ftpClient.login(\'admin\', \'secret\')\n-    \'230 Login successful.\'\n-\n-    >>> ftpClient.cwd(app_path)\n-    \'250 CWD command successful.\'\n-\n-    >>> ftpClient.retrlines(\'LIST\')\n-    drwxrwx---   1 Zope     Zope            0 ... .\n-    ...--w--w----   1 Zope     Zope            0 ... acl_users\n-    drwxrwx---   1 Zope     Zope            0 ... folder1\n-    \'226 Transfer complete\'\n-\n-    >>> ftpClient.quit()\n-    \'221 Goodbye.\'\n-\n-Test tear-down does nothing beyond what the base layers do.::\n-\n-    >>> z2.FTP_SERVER.testTearDown()\n-    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n-\n-    >>> \'app\' in z2.ZSERVER\n-    False\n-\n-    >>> \'request\' in z2.ZSERVER\n-    False\n-\n-    >>> with z2.zopeApp() as app:\n-    ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n-    True\n-\n-When the server is torn down, the FTP thread is stopped.::\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.FTPServer:Functional in ... seconds.\n-    Tear down plone.testing.z2.FTPServer in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-    >>> ftpClient.connect(host, port, timeout=5)\n-    Traceback (most recent call last):\n-    ...\n-    error: [Errno ...] Connection refused\ndiff --git a/src/plone/testing/zserver.py b/src/plone/testing/zserver.py\nindex b97c2ee..4e95e33 100644\n--- a/src/plone/testing/zserver.py\n+++ b/src/plone/testing/zserver.py\n@@ -259,7 +259,7 @@ def zopeApp(db=None, connection=None, environ=None):\n     pass an open connection as ``connection`` (the connection will not be\n     closed).\n     """\n-    import Zope2\n+    from ZServer import Zope2\n \n     closeConn = True\n     if connection is not None:\n@@ -634,9 +634,10 @@ def tearDownApp(self):\n         """\n \n         import Zope2\n+        import ZServer.Zope2\n         Zope2.app()._p_jar.close()\n \n-        Zope2._began_startup = 0\n+        ZServer.Zope2._began_startup = 0\n \n         Zope2.DB = None\n         Zope2.bobo_application = None\ndiff --git a/src/plone/testing/zserver.rst b/src/plone/testing/zserver.rst\nindex 6479e6a..01d46f7 100644\n--- a/src/plone/testing/zserver.rst\n+++ b/src/plone/testing/zserver.rst\n@@ -1,9 +1,9 @@\n Zope 2 layers\n -------------\n \n-The Zope 2 layers are found in the module ``plone.testing.z2``:::\n+The Zope 2 layers are found in the module ``plone.testing.zserver``:::\n \n-    >>> from plone.testing import z2\n+    >>> from plone.testing import zserver\n \n For testing, we need a testrunner:::\n \n@@ -19,10 +19,10 @@ It extends the ``zca.LAYER_CLEANUP`` layer to maximise the chances of having and\n **Note**: You should probably use at least ``INTEGRATION_TESTING`` for any real test, although ``STARTUP`` is a useful base layer if you are setting up your own fixture.\n See the description of ``INTEGRATION_TESTING`` below.::\n \n-    >>> "%s.%s" % (z2.STARTUP.__module__, z2.STARTUP.__name__,)\n-    \'plone.testing.z2.Startup\'\n+    >>> "%s.%s" % (zserver.STARTUP.__module__, zserver.STARTUP.__name__,)\n+    \'plone.testing.zserver.Startup\'\n \n-    >>> z2.STARTUP.__bases__\n+    >>> zserver.STARTUP.__bases__\n     (<Layer \'plone.testing.zca.LayerCleanup\'>,)\n \n On layer setup, Zope is initialised in a lightweight manner.\n@@ -43,45 +43,45 @@ Five sets a special vocabulary registry upon the layer setup, but there\'s a defa\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.STARTUP, setupLayers)\n+    >>> runner.setup_layer(options, zserver.STARTUP, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n \n After layer setup, the ``zodbDB`` resource is available, pointing to the default ZODB.::\n \n-    >>> z2.STARTUP[\'zodbDB\']\n+    >>> zserver.STARTUP[\'zodbDB\']\n     <ZODB.DB.DB object at ...>\n \n-    >>> z2.STARTUP[\'zodbDB\'].storage\n+    >>> zserver.STARTUP[\'zodbDB\'].storage\n     Startup\n \n In addition, the resources ``host`` and ``port`` are set to the default hostname and port that are used for URLs generated from Zope.\n These are hardcoded, but shadowed by layers that provide actual running Zope instances.::\n \n-    >>> z2.STARTUP[\'host\']\n+    >>> zserver.STARTUP[\'host\']\n     \'nohost\'\n-    >>> z2.STARTUP[\'port\']\n+    >>> zserver.STARTUP[\'port\']\n     80\n \n At this point, it is also possible to get hold of a Zope application root.\n If you are setting up a layer fixture, you can obtain an application root with the correct database that is properly closed by using the ``zopeApp()`` context manager.::\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds()\n     True\n \n If you want to use a specific database, you can pass that to ``zopeApp()`` as the ``db`` parameter.\n A new connection will be opened and closed.::\n \n-    >>> with z2.zopeApp(db=z2.STARTUP[\'zodbDB\']) as app:\n+    >>> with zserver.zopeApp(db=zserver.STARTUP[\'zodbDB\']) as app:\n     ...     \'acl_users\' in app.objectIds()\n     True\n \n If you want to re-use an existing connection, you can pass one to ``zopeApp()`` as the ``connection`` argument.\n In this case, you will need to close the connection yourself.::\n \n-    >>> conn = z2.STARTUP[\'zodbDB\'].open()\n-    >>> with z2.zopeApp(connection=conn) as app:\n+    >>> conn = zserver.STARTUP[\'zodbDB\'].open()\n+    >>> with zserver.zopeApp(connection=conn) as app:\n     ...     \'acl_users\' in app.objectIds()\n     True\n \n@@ -92,7 +92,7 @@ In this case, you will need to close the connection yourself.::\n \n If an exception is raised within the ``with`` block, the transaction is aborted, but the connection is still closed (if it was opened by the context manager):::\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     raise Exception("Test error")\n     Traceback (most recent call last):\n     ...\n@@ -101,14 +101,14 @@ If an exception is raised within the ``with`` block, the transaction is aborted,\n It is common to combine the ``zopeApp()`` context manager with a stacked ``DemoStorage`` to set up a layer-specific fixture.\n As a sketch:::\n \n-    from plone.testing import Layer, z2, zodb\n+    from plone.testing import Layer, zserver, zodb\n \n     class MyLayer(Layer):\n-        defaultBases = (z2.STARTUP,)\n+        defaultBases = (zserver.STARTUP,)\n \n         def setUp(self):\n             self[\'zodbDB\'] = zodb.stackDemoStorage(self.get(\'zodbDB\'), name=\'MyLayer\')\n-            with z2.zopeApp() as app:\n+            with zserver.zopeApp() as app:\n \n                 # Set up a fixture, e.g.:\n                 app.manage_addFolder(\'folder1\')\n@@ -124,7 +124,7 @@ As a sketch:::\n             self[\'zodbDB\'].close()\n             del self[\'zodbDB\']\n \n-Note that you would normally *not* use the ``z2.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.\n+Note that you would normally *not* use the ``zserver.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.\n The ``IntegrationTesting`` and ``FunctionalTesting`` layer classes manage the application object for you, exposing them as the resource ``app`` (see below).\n \n After layer setup, the global component registry contains a number of components needed by Zope.::\n@@ -139,7 +139,7 @@ And Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:::\n \n To load additional ZCML, you can use the ``configurationContext`` resource:::\n \n-    >>> z2.STARTUP[\'configurationContext\']\n+    >>> zserver.STARTUP[\'configurationContext\']\n     <zope.configuration.config.ConfigurationMachine object ...>\n \n See ``zca.rst`` for details about how to use ``zope.configuration`` for this purpose.\n@@ -147,18 +147,19 @@ See ``zca.rst`` for details about how to use ``zope.configuration`` for this pur\n The ``STARTUP`` layer does not perform any specific test setup or tear-down.\n That is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING`` layers, or other layers using their layer classes - ``IntegrationTesting`` and ``FunctionalTesting``.::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zserver.STARTUP.testSetUp()\n+    >>> zserver.STARTUP.testTearDown()\n \n Layer tear-down resets the environment.::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n-    >>> import Zope2\n-    >>> Zope2._began_startup\n+    >>> import ZServer.Zope2\n+    >>> ZServer.Zope2._began_startup\n     0\n+    >>> import Zope2\n     >>> Zope2.DB is None\n     True\n     >>> Zope2.bobo_application is None\n@@ -187,45 +188,45 @@ In a test, you should use this instead of the ``zopeApp`` context manager (which\n \n ``request`` is a test request. It is the same as ``app.REQUEST``.::\n \n-    >>> "%s.%s" % (z2.INTEGRATION_TESTING.__module__, z2.INTEGRATION_TESTING.__name__,)\n-    \'plone.testing.z2.IntegrationTesting\'\n+    >>> "%s.%s" % (zserver.INTEGRATION_TESTING.__module__, zserver.INTEGRATION_TESTING.__name__,)\n+    \'plone.testing.zserver.IntegrationTesting\'\n \n-    >>> z2.INTEGRATION_TESTING.__bases__\n-    (<Layer \'plone.testing.z2.Startup\'>,)\n+    >>> zserver.INTEGRATION_TESTING.__bases__\n+    (<Layer \'plone.testing.zserver.Startup\'>,)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.INTEGRATION_TESTING, setupLayers)\n+    >>> runner.setup_layer(options, zserver.INTEGRATION_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.IntegrationTesting in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n+    Set up plone.testing.zserver.IntegrationTesting in ... seconds.\n \n Let\'s now simulate a test.\n On test setup, the ``app`` resource is made available.\n In a test, you should always use this to access the application root.::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.INTEGRATION_TESTING.testSetUp()\n+    >>> zserver.STARTUP.testSetUp()\n+    >>> zserver.INTEGRATION_TESTING.testSetUp()\n \n The test may now inspect and modify the environment.::\n \n-    >>> app = z2.INTEGRATION_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app = zserver.INTEGRATION_TESTING[\'app\'] # would normally be self.layer[\'app\']\n     >>> app.manage_addFolder(\'folder1\')\n     >>> \'acl_users\' in app.objectIds() and \'folder1\' in app.objectIds()\n     True\n \n The request is also available:::\n \n-    >>> z2.INTEGRATION_TESTING[\'request\'] # would normally be self.layer[\'request\']\n+    >>> zserver.INTEGRATION_TESTING[\'request\'] # would normally be self.layer[\'request\']\n     <HTTPRequest, URL=http://nohost>\n \n-We can create a user and simulate logging in as that user, using the ``z2.login()`` helper:::\n+We can create a user and simulate logging in as that user, using the ``zserver.login()`` helper:::\n \n     >>> app._addRole(\'role1\')\n     >>> ignore = app[\'acl_users\'].userFolderAddUser(\'user1\', \'secret\', [\'role1\'], [])\n-    >>> z2.login(app[\'acl_users\'], \'user1\')\n+    >>> zserver.login(app[\'acl_users\'], \'user1\')\n \n-The first argument to ``z2.login()`` is the user folder that contains the relevant user.\n+The first argument to ``zserver.login()`` is the user folder that contains the relevant user.\n The second argument is the user\'s name.\n There is no need to give the password.::\n \n@@ -233,33 +234,33 @@ There is no need to give the password.::\n     >>> getSecurityManager().getUser()\n     <User \'user1\'>\n \n-You can change the roles of a user using the ``z2.setRoles()`` helper:::\n+You can change the roles of a user using the ``zserver.setRoles()`` helper:::\n \n     >>> sorted(getSecurityManager().getUser().getRolesInContext(app))\n     [\'Authenticated\', \'role1\']\n \n-    >>> z2.setRoles(app[\'acl_users\'], \'user1\', [])\n+    >>> zserver.setRoles(app[\'acl_users\'], \'user1\', [])\n     >>> getSecurityManager().getUser().getRolesInContext(app)\n     [\'Authenticated\']\n \n-To become the anonymous user again, use ``z2.logout()``:::\n+To become the anonymous user again, use ``zserver.logout()``:::\n \n-    >>> z2.logout()\n+    >>> zserver.logout()\n     >>> getSecurityManager().getUser()\n     <SpecialUser \'Anonymous User\'>\n \n On tear-down, the transaction is rolled back:::\n \n-    >>> z2.INTEGRATION_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zserver.INTEGRATION_TESTING.testTearDown()\n+    >>> zserver.STARTUP.testTearDown()\n \n-    >>> \'app\' in z2.INTEGRATION_TESTING\n+    >>> \'app\' in zserver.INTEGRATION_TESTING\n     False\n \n-    >>> \'request\' in z2.INTEGRATION_TESTING\n+    >>> \'request\' in zserver.INTEGRATION_TESTING\n     False\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n     True\n \n@@ -267,8 +268,8 @@ On tear-down, the transaction is rolled back:::\n Let\'s tear down the layers:::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.IntegrationTesting in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zserver.IntegrationTesting in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n Functional testing\n@@ -287,31 +288,31 @@ See the ``plone.testing`` ``README`` file for an example.\n \n Like ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.::\n \n-    >>> "%s.%s" % (z2.FUNCTIONAL_TESTING.__module__, z2.FUNCTIONAL_TESTING.__name__,)\n-    \'plone.testing.z2.FunctionalTesting\'\n+    >>> "%s.%s" % (zserver.FUNCTIONAL_TESTING.__module__, zserver.FUNCTIONAL_TESTING.__name__,)\n+    \'plone.testing.zserver.FunctionalTesting\'\n \n-    >>> z2.FUNCTIONAL_TESTING.__bases__\n-    (<Layer \'plone.testing.z2.Startup\'>,)\n+    >>> zserver.FUNCTIONAL_TESTING.__bases__\n+    (<Layer \'plone.testing.zserver.Startup\'>,)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)\n+    >>> runner.setup_layer(options, zserver.FUNCTIONAL_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.FunctionalTesting in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n+    Set up plone.testing.zserver.FunctionalTesting in ... seconds.\n \n Let\'s now simulate a test.\n On test setup, the ``app`` resource is made available.\n In a test, you should always use this to access the application root.\n The ``request`` resource can be used to access the test request.::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n+    >>> zserver.STARTUP.testSetUp()\n+    >>> zserver.FUNCTIONAL_TESTING.testSetUp()\n \n The test may now inspect and modify the environment.\n It may also commit things.::\n \n-    >>> app = z2.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app = zserver.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n     >>> app.manage_addFolder(\'folder1\')\n     >>> \'acl_users\' in app.objectIds() and \'folder1\' in app.objectIds()\n     True\n@@ -321,24 +322,24 @@ It may also commit things.::\n \n On tear-down, the database is torn down.::\n \n-    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zserver.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zserver.STARTUP.testTearDown()\n \n-    >>> \'app\' in z2.FUNCTIONAL_TESTING\n+    >>> \'app\' in zserver.FUNCTIONAL_TESTING\n     False\n \n-    >>> \'request\' in z2.FUNCTIONAL_TESTING\n+    >>> \'request\' in zserver.FUNCTIONAL_TESTING\n     False\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n     True\n \n Let\'s tear down the layer:::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.FunctionalTesting in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zserver.FunctionalTesting in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n The test browser\n@@ -351,20 +352,20 @@ To use the test browser with a ``FunctionalTesting`` layer (such as the default\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)\n+    >>> runner.setup_layer(options, zserver.FUNCTIONAL_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.FunctionalTesting in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n+    Set up plone.testing.zserver.FunctionalTesting in ... seconds.\n \n Let\'s simulate a test:::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n+    >>> zserver.STARTUP.testSetUp()\n+    >>> zserver.FUNCTIONAL_TESTING.testSetUp()\n \n In the test, we can create a test browser client like so:::\n \n-    >>> app = z2.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n-    >>> browser = z2.Browser(app)\n+    >>> app = zserver.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> browser = zserver.Browser(app)\n \n It is usually best to let Zope errors be shown with full tracebacks:::\n \n@@ -411,16 +412,16 @@ See the ``zope.testbrowser`` documentation for more information about how to use\n \n On tear-down, the database is torn down.::\n \n-    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zserver.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zserver.STARTUP.testTearDown()\n \n-    >>> \'app\' in z2.FUNCTIONAL_TESTING\n+    >>> \'app\' in zserver.FUNCTIONAL_TESTING\n     False\n \n-    >>> \'request\' in z2.FUNCTIONAL_TESTING\n+    >>> \'request\' in zserver.FUNCTIONAL_TESTING\n     False\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds()\\\n     ...         and \'folder1\' not in app.objectIds()\\\n     ...         and \'file1\' not in app.objectIds()\n@@ -429,8 +430,8 @@ On tear-down, the database is torn down.::\n Let\'s tear down the layer:::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.FunctionalTesting in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zserver.FunctionalTesting in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n HTTP server\n@@ -441,34 +442,34 @@ This makes it possible to connect to the test instance using a web browser or a\n \n The ``ZSERVER`` layer provides a ``FunctionalTesting`` layer that has ``ZSERVER_FIXTURE`` as its base.::\n \n-    >>> "%s.%s" % (z2.ZSERVER_FIXTURE.__module__, z2.ZSERVER_FIXTURE.__name__,)\n-    \'plone.testing.z2.ZServer\'\n+    >>> "%s.%s" % (zserver.ZSERVER_FIXTURE.__module__, zserver.ZSERVER_FIXTURE.__name__,)\n+    \'plone.testing.zserver.ZServer\'\n \n-    >>> z2.ZSERVER_FIXTURE.__bases__\n-    (<Layer \'plone.testing.z2.Startup\'>,)\n+    >>> zserver.ZSERVER_FIXTURE.__bases__\n+    (<Layer \'plone.testing.zserver.Startup\'>,)\n \n \n-    >>> "%s.%s" % (z2.ZSERVER.__module__, z2.ZSERVER.__name__,)\n-    \'plone.testing.z2.ZServer:Functional\'\n+    >>> "%s.%s" % (zserver.ZSERVER.__module__, zserver.ZSERVER.__name__,)\n+    \'plone.testing.zserver.ZServer:Functional\'\n \n-    >>> z2.ZSERVER.__bases__\n-    (<Layer \'plone.testing.z2.ZServer\'>,)\n+    >>> zserver.ZSERVER.__bases__\n+    (<Layer \'plone.testing.zserver.ZServer\'>,)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.ZSERVER, setupLayers)\n+    >>> runner.setup_layer(options, zserver.ZSERVER, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.ZServer in ... seconds.\n-    Set up plone.testing.z2.ZServer:Functional in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n+    Set up plone.testing.zserver.ZServer in ... seconds.\n+    Set up plone.testing.zserver.ZServer:Functional in ... seconds.\n \n After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n \n-    >>> host = z2.ZSERVER[\'host\']\n+    >>> host = zserver.ZSERVER[\'host\']\n     >>> host\n     \'localhost\'\n \n-    >>> port = z2.ZSERVER[\'port\']\n+    >>> port = zserver.ZSERVER[\'port\']\n     >>> import os\n     >>> port == int(os.environ.get(\'ZSERVER_PORT\', 55001))\n     True\n@@ -476,15 +477,15 @@ After layer setup, the resources ``host`` and ``port`` are available, and indica\n Let\'s now simulate a test.\n Test setup does nothing beyond what the base layers do.::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n-    >>> z2.ZSERVER.testSetUp()\n+    >>> zserver.STARTUP.testSetUp()\n+    >>> zserver.FUNCTIONAL_TESTING.testSetUp()\n+    >>> zserver.ZSERVER.testSetUp()\n \n It is common in a test to use the Python API to change the state of the server (e.g.\n create some content or change a setting) and then use the HTTP protocol to look at the results.\n-Bear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``z2.login()`` and ``z2.logout()``, for instance, do not affect the server thread.::\n+Bear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``zserver.login()`` and ``zserver.logout()``, for instance, do not affect the server thread.::\n \n-    >>> app = z2.ZSERVER[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app = zserver.ZSERVER[\'app\'] # would normally be self.layer[\'app\']\n     >>> app.manage_addFolder(\'folder1\')\n \n Note that we need to commit the transaction before it will show up in the other thread.::\n@@ -505,26 +506,26 @@ We can now look for this new object through the server.::\n \n Test tear-down does nothing beyond what the base layers do.::\n \n-    >>> z2.ZSERVER.testTearDown()\n-    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zserver.ZSERVER.testTearDown()\n+    >>> zserver.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zserver.STARTUP.testTearDown()\n \n-    >>> \'app\' in z2.ZSERVER\n+    >>> \'app\' in zserver.ZSERVER\n     False\n \n-    >>> \'request\' in z2.ZSERVER\n+    >>> \'request\' in zserver.ZSERVER\n     False\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n     True\n \n When the server is torn down, the ZServer thread is stopped.::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.ZServer:Functional in ... seconds.\n-    Tear down plone.testing.z2.ZServer in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zserver.ZServer:Functional in ... seconds.\n+    Tear down plone.testing.zserver.ZServer in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n     >>> conn = urllib2.urlopen(app_url + \'/folder1\', timeout=5)\n@@ -544,35 +545,35 @@ The fixture is contained in the ``FTP_SERVER_FIXTURE`` layer.\n \n The ``FTP_SERVER_FIXTURE`` layer is based on the ``STARTUP`` layer.::\n \n-    >>> "%s.%s" % (z2.FTP_SERVER_FIXTURE.__module__, z2.FTP_SERVER_FIXTURE.__name__,)\n-    \'plone.testing.z2.FTPServer\'\n+    >>> "%s.%s" % (zserver.FTP_SERVER_FIXTURE.__module__, zserver.FTP_SERVER_FIXTURE.__name__,)\n+    \'plone.testing.zserver.FTPServer\'\n \n-    >>> z2.FTP_SERVER_FIXTURE.__bases__\n-    (<Layer \'plone.testing.z2.Startup\'>,)\n+    >>> zserver.FTP_SERVER_FIXTURE.__bases__\n+    (<Layer \'plone.testing.zserver.Startup\'>,)\n \n The ``FTP_SERVER`` layer is based on ``FTP_SERVER_FIXTURE``, using the ``FunctionalTesting`` layer class.::\n \n-    >>> "%s.%s" % (z2.FTP_SERVER.__module__, z2.FTP_SERVER.__name__,)\n-    \'plone.testing.z2.FTPServer:Functional\'\n+    >>> "%s.%s" % (zserver.FTP_SERVER.__module__, zserver.FTP_SERVER.__name__,)\n+    \'plone.testing.zserver.FTPServer:Functional\'\n \n-    >>> z2.FTP_SERVER.__bases__\n-    (<Layer \'plone.testing.z2.FTPServer\'>,)\n+    >>> zserver.FTP_SERVER.__bases__\n+    (<Layer \'plone.testing.zserver.FTPServer\'>,)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.FTP_SERVER, setupLayers)\n+    >>> runner.setup_layer(options, zserver.FTP_SERVER, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.FTPServer in ... seconds.\n-    Set up plone.testing.z2.FTPServer:Functional in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n+    Set up plone.testing.zserver.FTPServer in ... seconds.\n+    Set up plone.testing.zserver.FTPServer:Functional in ... seconds.\n \n After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n \n-    >>> host = z2.FTP_SERVER[\'host\']\n+    >>> host = zserver.FTP_SERVER[\'host\']\n     >>> host\n     \'localhost\'\n \n-    >>> port = z2.FTP_SERVER[\'port\']\n+    >>> port = zserver.FTP_SERVER[\'port\']\n     >>> import os\n     >>> port == int(os.environ.get(\'FTPSERVER_PORT\', 55002))\n     True\n@@ -580,13 +581,13 @@ After layer setup, the resources ``host`` and ``port`` are available, and indica\n Let\'s now simulate a test.\n Test setup does nothing beyond what the base layers do.::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n-    >>> z2.FTP_SERVER.testSetUp()\n+    >>> zserver.STARTUP.testSetUp()\n+    >>> zserver.FUNCTIONAL_TESTING.testSetUp()\n+    >>> zserver.FTP_SERVER.testSetUp()\n \n As with ``ZSERVER``, we will set up some content for the test and then access it over the FTP port.::\n \n-    >>> app = z2.FTP_SERVER[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app = zserver.FTP_SERVER[\'app\'] # would normally be self.layer[\'app\']\n     >>> app.manage_addFolder(\'folder1\')\n \n We\'ll also create a user in the root user folder to make FTP access easier.::\n@@ -623,26 +624,26 @@ We can now look for this new object through the server.::\n \n Test tear-down does nothing beyond what the base layers do.::\n \n-    >>> z2.FTP_SERVER.testTearDown()\n-    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zserver.FTP_SERVER.testTearDown()\n+    >>> zserver.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zserver.STARTUP.testTearDown()\n \n-    >>> \'app\' in z2.ZSERVER\n+    >>> \'app\' in zserver.ZSERVER\n     False\n \n-    >>> \'request\' in z2.ZSERVER\n+    >>> \'request\' in zserver.ZSERVER\n     False\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n     True\n \n When the server is torn down, the FTP thread is stopped.::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.FTPServer:Functional in ... seconds.\n-    Tear down plone.testing.z2.FTPServer in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zserver.FTPServer:Functional in ... seconds.\n+    Tear down plone.testing.zserver.FTPServer in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n     >>> ftpClient.connect(host, port, timeout=5)\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/97da356bee7cc80917ba0c6f976989a92813bbc6

Move entry to correct place.

Files changed:
M CHANGES.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 4355357..46c49ae 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -10,7 +10,7 @@ Breaking changes:\n \n New features:\n \n-- *add item here*\n+- Make it possible to run the tests without having ``ZServer`` installed.\n \n Bug fixes:\n \n@@ -27,8 +27,6 @@ Bug fixes:\n   + Only support ``Zope >= 4``, no longer support ``Zope2``.\n   + Drop support for Python 2.6.\n \n-- Make it possible to run the tests without having ``ZServer`` installed.\n-\n - No longer use deprecated import for getSite/setSite.\n   [jensens]\n \n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/5f3a753b03bb3b6604fbc2eb7587f8f3e148c5de

De-duplicate the code between zserver.py and wsgi.py:

Reusing the code from wsgi.py in zserver.py, so it can be easily deleted when zserver is no longer supported.

Files changed:
M src/plone/testing/wsgi.py
M src/plone/testing/zserver.py

b'diff --git a/src/plone/testing/wsgi.py b/src/plone/testing/wsgi.py\nindex 80a65f1..df35f42 100644\n--- a/src/plone/testing/wsgi.py\n+++ b/src/plone/testing/wsgi.py\n@@ -1,5 +1,5 @@\n # -*- coding: utf-8 -*-\n-"""Zope2-specific helpers and layers\n+"""Zope-specific helpers and layers using WSGI\n """\n from OFS.metaconfigure import get_packages_to_initialize\n from plone.testing import Layer\n@@ -15,13 +15,6 @@\n import transaction\n \n \n-try:\n-    from plone.testing._z2_testbrowser import Browser  # noqa # BBB\n-except ImportError:\n-    # Just in case zope.testbrowser causes an import error, don\'t break\n-    pass\n-\n-\n _INSTALLED_PRODUCTS = {}\n \n \n@@ -332,7 +325,7 @@ def setUp(self):\n         self.setUpDebugMode()\n         self.setUpClientCache()\n         self.setUpPatches()\n-        # self.setUpThreads()\n+        self.setUpThreads()\n         self.setUpHostPort()\n         self.setUpDatabase()\n         self.setUpApp()\n@@ -347,7 +340,7 @@ def tearDown(self):\n         self.tearDownApp()\n         self.tearDownDatabase()\n         self.tearDownHostPort()\n-        # self.tearDownThreads()\n+        self.tearDownThreads()\n         self.tearDownPatches()\n         self.tearDownClientCache()\n         self.tearDownDebugMode()\n@@ -496,23 +489,14 @@ def tearDownPatches(self):\n             del self._App_ProductContext_ProductContext_registerHelp\n \n     def setUpThreads(self):\n-        """Set the thread count for ZServer. This defaults to 1.\n+        """Set the thread count. Only needed in ZServer.\n         """\n-\n-        # We can\'t use setNumberOfThreads() because that function self-\n-        # destructs, literally, when called.\n-\n-        import ZServer.PubCore\n-        self._zserverThreads = ZServer.PubCore._n\n-        ZServer.PubCore._n = self.threads\n+        pass\n \n     def tearDownThreads(self):\n-        """Reset the ZServer thread count.\n+        """Reset the thread count. Only needed in ZServer.\n         """\n-\n-        import ZServer.PubCore\n-        ZServer.PubCore._n = self._zserverThreads\n-        del self._zserverThreads\n+        pass\n \n     def setUpHostPort(self):\n         """Set up the \'host\' and \'port\' resources\n@@ -756,7 +740,7 @@ def tearDownFive(self):\n \n \n # Basic integration and functional test and layers. These are the simplest\n-# Zope 2 layers that are generally useful\n+# Zope layers that are generally useful\n \n class IntegrationTesting(Layer):\n     """This layer extends ``STARTUP`` to add rollback of the transaction\ndiff --git a/src/plone/testing/zserver.py b/src/plone/testing/zserver.py\nindex 4e95e33..56d168c 100644\n--- a/src/plone/testing/zserver.py\n+++ b/src/plone/testing/zserver.py\n@@ -1,249 +1,19 @@\n # -*- coding: utf-8 -*-\n-"""Zope2-specific helpers and layers\n+"""Zope2-specific helpers and layers using ZServer\n """\n-from OFS.metaconfigure import get_packages_to_initialize\n from plone.testing import Layer\n-from plone.testing import zca\n-from plone.testing import zodb\n+from plone.testing.wsgi import addRequestContainer\n+from plone.testing.wsgi import login  # noqa\n+from plone.testing.wsgi import logout  # noqa\n+from plone.testing.wsgi import setRoles  # noqa\n from plone.testing._z2_testbrowser import Browser  # noqa\n-from Testing.ZopeTestCase.ZopeLite import _patched as ZOPETESTCASEALERT\n-from Zope2.App.schema import Zope2VocabularyRegistry\n-from zope.schema.vocabulary import getVocabularyRegistry\n-from zope.schema.vocabulary import setVocabularyRegistry\n+from plone.testing import wsgi\n \n import contextlib\n import os\n import transaction\n \n \n-try:\n-    from plone.testing._z2_testbrowser import Browser  # noqa # BBB\n-except ImportError:\n-    # Just in case zope.testbrowser causes an import error, don\'t break\n-    pass\n-\n-\n-_INSTALLED_PRODUCTS = {}\n-\n-\n-class TestIsolationBroken(BaseException):\n-    pass\n-\n-\n-def installProduct(app, productName, quiet=False, multiinit=False):\n-    """Install the Zope 2 product with the given name, so that it will show\n-    up in the Zope 2 control panel and have its ``initialize()`` hook called.\n-\n-    The ``STARTUP`` layer or an equivalent layer must have been loaded first.\n-\n-    If ``quiet`` is False, an error will be logged if the product cannot be\n-    found. By default, the function is silent.\n-\n-    Note that products\' ZCML is *not* loaded automatically, even if the\n-    product is in the Products namespace.\n-    """\n-    from App.class_init import InitializeClass\n-    from OFS.Application import get_folder_permissions\n-    from OFS.Application import get_products\n-    from OFS.Application import install_package\n-    from OFS.Application import install_product\n-    from OFS.Folder import Folder\n-    import sys\n-\n-    found = False\n-\n-    if productName in _INSTALLED_PRODUCTS:\n-        return\n-\n-    if productName.startswith(\'Products.\'):\n-        for priority, name, index, productDir in get_products():\n-            if (\'Products.\' + name) == productName:\n-\n-                install_product(\n-                    app,\n-                    productDir,\n-                    name,\n-                    [],\n-                    get_folder_permissions(),\n-                    raise_exc=1)\n-                InitializeClass(Folder)\n-\n-                _INSTALLED_PRODUCTS[productName] = (\n-                    priority,\n-                    name,\n-                    index,\n-                    productDir,\n-                )\n-\n-                found = True\n-                break\n-\n-    else:\n-        packages = tuple(get_packages_to_initialize())\n-        for module, init_func in packages:\n-            if module.__name__ == productName:\n-                install_package(app, module, init_func, raise_exc=1)\n-                _INSTALLED_PRODUCTS[productName] = (module, init_func,)\n-\n-                found = True\n-                if not multiinit:\n-                    break\n-\n-    if not found and not quiet:\n-        sys.stderr.write(\n-            \'Could not install product {0}\\n\'.format(productName)\n-        )\n-        sys.stderr.flush()\n-\n-\n-def uninstallProduct(app, productName, quiet=False):\n-    """Uninstall the given Zope 2 product. This is the inverse of\n-    ``installProduct()`` above.\n-    """\n-\n-    import sys\n-\n-    # from OFS.Folder import Folder\n-    # from OFS.Application import get_folder_permissions\n-    # from App.class_init import InitializeClass\n-\n-    from OFS.Application import Application, get_products\n-\n-    global _INSTALLED_PRODUCTS\n-    found = False\n-\n-    if productName not in _INSTALLED_PRODUCTS:\n-        return\n-\n-    if productName.startswith(\'Products.\'):\n-        for priority, name, index, productDir in get_products():\n-            if (\'Products.\' + name) == productName:\n-\n-                if name in Application.misc_.__dict__:\n-                    delattr(Application.misc_, name)\n-\n-                try:\n-                    cp = app[\'Control_Panel\'][\'Products\']\n-                except KeyError:\n-                    # Zope 4\n-                    pass\n-                else:\n-                    if name in cp:\n-                        product = cp[name]\n-\n-                        app._manage_remove_product_meta_type(product)\n-                        app._manage_remove_product_permission(product)\n-\n-                        del cp[name]\n-\n-                # TODO: Also remove permissions from get_folder_permissions?\n-                # Difficult to know if this would stomp on any other\n-                # permissions\n-                # InitializeClass(Folder)\n-\n-                found = True\n-                break\n-    elif productName in _INSTALLED_PRODUCTS:  # must be a package\n-\n-        module, init_func = _INSTALLED_PRODUCTS[productName]\n-        name = module.__name__\n-\n-        try:\n-            cp = app[\'Control_Panel\'][\'Products\']\n-        except KeyError:\n-            # Zope 4\n-            pass\n-        else:\n-            if name in cp:\n-                product = cp[name]\n-\n-                app._manage_remove_product_meta_type(product)\n-                app._manage_remove_product_permission(product)\n-\n-                del cp[name]\n-\n-        packages = get_packages_to_initialize()\n-        packages.append((module, init_func))\n-        found = True\n-\n-    if found:\n-        del _INSTALLED_PRODUCTS[productName]\n-\n-    if not found and not quiet:\n-        sys.stderr.write(\n-            \'Could not install product {0}\\n\'.format(productName)\n-        )\n-        sys.stderr.flush()\n-\n-\n-def login(userFolder, userName):\n-    """Log in as the given user in the given user folder.\n-    """\n-\n-    from AccessControl.SecurityManagement import newSecurityManager\n-\n-    user = userFolder.getUser(userName)\n-    if user is None:\n-        raise ValueError(\'User could not be found\')\n-    if not hasattr(user, \'aq_base\'):\n-        user = user.__of__(userFolder)\n-    newSecurityManager(None, user)\n-\n-\n-def logout():\n-    """Log out, i.e. become anonymous\n-    """\n-\n-    from AccessControl.SecurityManagement import noSecurityManager\n-    noSecurityManager()\n-\n-\n-def setRoles(userFolder, userId, roles):\n-    """Set the given user\'s roles to a tuple of roles.\n-    """\n-\n-    userFolder.userFolderEditUser(userId, None, list(roles), [])\n-\n-    from AccessControl import getSecurityManager\n-    userName = userFolder.getUserById(userId).getUserName()\n-    if userName == getSecurityManager().getUser().getUserName():\n-        login(userFolder, userName)\n-\n-\n-def makeTestRequest(environ=None):\n-    """Return an HTTPRequest object suitable for testing views."""\n-    from sys import stdin, stdout\n-    from zope.publisher.browser import setDefaultSkin\n-    from ZPublisher.HTTPRequest import HTTPRequest\n-    from ZPublisher.HTTPResponse import HTTPResponse\n-\n-    if environ is None:\n-        environ = {}\n-    environ.setdefault(\'SERVER_NAME\', \'foo\')\n-    environ.setdefault(\'SERVER_PORT\', \'80\')\n-    environ.setdefault(\'REQUEST_METHOD\', \'GET\')\n-\n-    resp = HTTPResponse(stdout=stdout)\n-    req = HTTPRequest(stdin, environ, resp)\n-    req._steps = [\'noobject\']  # Fake a published object.\n-    req[\'ACTUAL_URL\'] = req.get(\'URL\')\n-    setDefaultSkin(req)\n-\n-    return req\n-\n-\n-def addRequestContainer(app, environ=None):\n-    """Add the request container with a fake request to the app object\'s\n-    acquisition context and return the wrapped app object. Additional request\n-    environment values can be passed as a dict ``environ``.\n-    """\n-\n-    from ZPublisher.BaseRequest import RequestContainer\n-    req = makeTestRequest(environ)\n-    requestcontainer = RequestContainer(REQUEST=req)\n-    return app.__of__(requestcontainer)\n-\n-\n @contextlib.contextmanager\n def zopeApp(db=None, connection=None, environ=None):\n     """Context manager for working with the Zope2 app::\n@@ -308,7 +78,7 @@ def zopeApp(db=None, connection=None, environ=None):\n \n # Startup layer - you probably don\'t want to use this one directly\n \n-class Startup(Layer):\n+class Startup(wsgi.Startup):\n     """This layer does what ZopeLite and ZopeTestCase\'s base.TestCase did:\n     start up a minimal Zope instance and manages the application and\n     request state.\n@@ -325,176 +95,10 @@ class Startup(Layer):\n       respectively.\n     """\n \n-    defaultBases = (zca.LAYER_CLEANUP,)\n-\n     threads = 1\n \n-    # Layer lifecycle\n-\n-    def setUp(self):\n-        self.setUpDebugMode()\n-        self.setUpClientCache()\n-        self.setUpPatches()\n-        self.setUpThreads()\n-        self.setUpHostPort()\n-        self.setUpDatabase()\n-        self.setUpApp()\n-        self.setUpBasicProducts()\n-        self.setUpZCML()\n-        self.setUpFive()\n-\n-    def tearDown(self):\n-        self.tearDownFive()\n-        self.tearDownZCML()\n-        self.tearDownBasicProducts()\n-        self.tearDownApp()\n-        self.tearDownDatabase()\n-        self.tearDownHostPort()\n-        self.tearDownThreads()\n-        self.tearDownPatches()\n-        self.tearDownClientCache()\n-        self.tearDownDebugMode()\n-\n     # Layer lifecycle helper methods\n \n-    def setUpDebugMode(self):\n-        """Switch off debug mode in the global configuration\n-        """\n-\n-        import App.config\n-        config = App.config.getConfiguration()\n-        self._debugMode = config.debug_mode\n-        config.debug_mode = False\n-        App.config.setConfiguration(config)\n-\n-        # Set Python security mode\n-        from AccessControl.Implementation import setImplementation\n-        setImplementation(\'Python\')\n-\n-        # Set a flag so that other code can know that we are running tests.\n-        # Some of the speed-related patches in Plone use this, for instance.\n-        # The name is a BBB artefact from ZopeTestCase :\n-        import os\n-        os.environ[\'ZOPETESTCASE\'] = \'1\'\n-\n-    def tearDownDebugMode(self):\n-        """Return the debug mode flag to its previous state\n-        """\n-\n-        from AccessControl.Implementation import setImplementation\n-        setImplementation(\'C\')\n-\n-        import App.config\n-        config = App.config.getConfiguration()\n-        config.debug_mode = self._debugMode\n-        App.config.setConfiguration(config)\n-        del self._debugMode\n-\n-    def setUpClientCache(self):\n-        """Make sure we use a temporary client cache by altering the global\n-        configuration\n-        """\n-\n-        # Make sure we use a temporary client cache\n-        import App.config\n-        config = App.config.getConfiguration()\n-        self._zeoClientName = getattr(config, \'zeo_client_name\', None)\n-        config.zeo_client_name = None\n-        App.config.setConfiguration(config)\n-\n-    def tearDownClientCache(self):\n-        """Restore the cache configuration to its previous state\n-        """\n-\n-        # Make sure we use a temporary client cache\n-        import App.config\n-        config = App.config.getConfiguration()\n-        config.zeo_client_name = self._zeoClientName\n-        App.config.setConfiguration(config)\n-        del self._zeoClientName\n-\n-    def setUpPatches(self):\n-        """Apply monkey patches that disable unnecessary parts of Zope.\n-        This speeds up the test runs.\n-        """\n-\n-        import OFS.Application\n-        import App.ProductContext\n-        import Zope2.App.startup\n-\n-        # Avoid expensive product import\n-        def null_import_products():\n-            pass\n-        self._OFS_Application_import_products = OFS.Application.import_products\n-        OFS.Application.import_products = null_import_products\n-\n-        # Avoid expensive product installation\n-        def null_initialize(app):\n-            pass\n-        self._OFS_Application_initialize = OFS.Application.initialize\n-        OFS.Application.initialize = null_initialize\n-\n-        # Avoid expensive help registration\n-        try:\n-            self._App_ProductContext_ProductContext_registerHelpTopic = App.ProductContext.ProductContext.registerHelpTopic  # noqa\n-        except AttributeError:\n-            # Zope 4\n-            pass\n-        else:\n-            def null_register_topic(self, id, topic):\n-                pass\n-            App.ProductContext.ProductContext.registerHelpTopic = null_register_topic  # noqa\n-\n-            self._App_ProductContext_ProductContext_registerHelpTitle = App.ProductContext.ProductContext.registerHelpTitle  # noqa\n-\n-            def null_register_title(self, title):\n-                pass\n-            App.ProductContext.ProductContext.registerHelpTitle = null_register_title  # noqa\n-\n-            self._App_ProductContext_ProductContext_registerHelp = App.ProductContext.ProductContext.registerHelp  # noqa\n-\n-            def null_register_help(\n-                    self,\n-                    directory=\'\',\n-                    clear=1,\n-                    title_re=None):\n-                pass\n-            App.ProductContext.ProductContext.registerHelp = null_register_help\n-\n-        # in Zope 2.13, prevent ZCML from loading during App startup\n-        if hasattr(Zope2.App.startup, \'load_zcml\'):\n-            def null_load_zcml():\n-                pass\n-            self._Zope2_App_startup_load_zcml = Zope2.App.startup.load_zcml\n-            Zope2.App.startup.load_zcml = null_load_zcml\n-\n-    def tearDownPatches(self):\n-        """Revert the monkey patches from setUpPatches()\n-        """\n-\n-        import OFS.Application\n-        import App.ProductContext\n-\n-        OFS.Application.import_products = self._OFS_Application_import_products\n-        del self._OFS_Application_import_products\n-\n-        OFS.Application.initialize = self._OFS_Application_initialize\n-        del self._OFS_Application_initialize\n-\n-        try:\n-            App.ProductContext.ProductContext.registerHelpTopic = self._App_ProductContext_ProductContext_registerHelpTopic  # noqa\n-        except AttributeError:\n-            # Zope 4\n-            pass\n-        else:\n-            del self._App_ProductContext_ProductContext_registerHelpTopic\n-\n-            App.ProductContext.ProductContext.registerHelpTitle = self._App_ProductContext_ProductContext_registerHelpTitle  # noqa\n-            del self._App_ProductContext_ProductContext_registerHelpTitle\n-\n-            App.ProductContext.ProductContext.registerHelp = self._App_ProductContext_ProductContext_registerHelp  # noqa\n-            del self._App_ProductContext_ProductContext_registerHelp\n-\n     def setUpThreads(self):\n         """Set the thread count for ZServer. This defaults to 1.\n         """\n@@ -514,97 +118,6 @@ def tearDownThreads(self):\n         ZServer.PubCore._n = self._zserverThreads\n         del self._zserverThreads\n \n-    def setUpHostPort(self):\n-        """Set up the \'host\' and \'port\' resources\n-        """\n-\n-        self[\'host\'] = \'nohost\'\n-        self[\'port\'] = 80\n-\n-    def tearDownHostPort(self):\n-        """Pop the \'host\' and \'port\' resources\n-        """\n-\n-        del self[\'host\']\n-        del self[\'port\']\n-\n-    def setUpDatabase(self):\n-        """Create a database and stash it in the resource ``zodbDB``. If\n-        that resource exists, create a layered DemoStorage on top of the\n-        base database. Otherwise, create a new resource.\n-\n-        The database is registered in the global configuration so that\n-        Zope 2 app startup will find it. We use a facade object to ensure\n-        that the database that is opened by Zope 2 is in fact the top of\n-        the resource stack.\n-        """\n-        if ZOPETESTCASEALERT:\n-            raise Exception(\'You try to run plone.testing tests together with \'\n-                            \'ZopeTestCase tests. This will result in random \'\n-                            \'failures. Convert the ZopeTestCase Tests or \'\n-                            \'do not run them together\')\n-\n-        import Zope2.Startup.datatypes\n-        import App.config\n-\n-        # Layer a new storage for Zope 2 on top of the one from the base\n-        # layer, if there is one.\n-\n-        self[\'zodbDB\'] = zodb.stackDemoStorage(\n-            self.get(\'zodbDB\'),\n-            name=\'Startup\')\n-\n-        # Create a facade for the database object that will delegate to the\n-        # correct underlying database. This allows resource shadowing to work\n-        # with regular traversal, which relies on a module-level ``DB``\n-        # variable.\n-\n-        class DBFacade(object):\n-\n-            def __init__(self, layer):\n-                self.__layer = layer\n-\n-            @property\n-            def __db(self):\n-                return self.__layer[\'zodbDB\']\n-\n-            def __getattr__(self, name):\n-                return getattr(self.__db, name)\n-\n-        # Create a fake dbtab value in the config so that app startup will\n-        # use this one.\n-\n-        class DBTab(Zope2.Startup.datatypes.DBTab):\n-            """A fake DBTab that causes App.startup() to use our own database.\n-            """\n-\n-            def __init__(self, db):\n-                # value is never used when we have an open db\n-                self.db_factories = {\'testing\': None}\n-                self.mount_paths = {\'/\': \'testing\'}\n-                self.databases = {\'testing\': db}\n-\n-        config = App.config.getConfiguration()\n-        self._dbtab = getattr(config, \'dbtab\', None)\n-        config.dbtab = DBTab(DBFacade(self))\n-        App.config.setConfiguration(config)\n-\n-    def tearDownDatabase(self):\n-        """Close the database and pop the ``zodbDB`` resource. Restore the\n-        global database configuration to its previous state.\n-        """\n-\n-        import App.config\n-        config = App.config.getConfiguration()\n-        config.dbtab = self._dbtab\n-        App.config.setConfiguration(config)\n-        del self._dbtab\n-\n-        # Close and pop the zodbDB resource\n-        transaction.abort()\n-        self[\'zodbDB\'].close()\n-        del self[\'zodbDB\']\n-\n     def setUpApp(self):\n         """Trigger Zope startup and set up the application.\n         """\n@@ -663,95 +176,6 @@ def tearDownApp(self):\n             d[0] = {}\n             ZPublisher.Publish.get_module_info.func_defaults = tuple(d)\n \n-    def setUpBasicProducts(self):\n-        """Install a minimal set of products required for Zope 2.\n-        """\n-\n-        with zopeApp() as app:\n-            installProduct(app, \'Products.PluginIndexes\')\n-            installProduct(app, \'Products.OFSP\')\n-\n-    def tearDownBasicProducts(self):\n-        """Tear down the minimal set of products\n-        """\n-\n-        with zopeApp() as app:\n-            uninstallProduct(app, \'Products.PluginIndexes\')\n-            uninstallProduct(app, \'Products.OFSP\')\n-\n-        # It\'s possible for Five\'s _register_monkies and _meta_type_regs\n-        # global variables to contain duplicates. This causes an unecessary\n-        # error in the LayerCleanup layer\'s tear-down. Guard against that\n-        # here\n-\n-        try:\n-            from OFS import metaconfigure\n-        except ImportError:\n-            # Zope <= 2.12\n-            from Products.Five import fiveconfigure as metaconfigure\n-        metaconfigure._register_monkies = list(\n-            set(metaconfigure._register_monkies))\n-        metaconfigure._meta_type_regs = list(\n-            set(metaconfigure._meta_type_regs))\n-\n-    def setUpZCML(self):\n-        """Load the basic ZCML configuration from Five. Exposes a resource\n-        ``configurationContext`` which can be used to load further ZCML.\n-        """\n-\n-        # Push a new global registry so that we can cleanly tear down all ZCML\n-        from plone.testing import zca\n-        zca.pushGlobalRegistry()\n-\n-        # Load something akin to the default site.zcml without actually auto-\n-        # loading products\n-\n-        self[\'configurationContext\'] = context = zca.stackConfigurationContext(\n-            self.get(\'configurationContext\'))\n-\n-        from zope.configuration import xmlconfig\n-        xmlconfig.string("""\\\n-<configure\n-    xmlns="http://namespaces.zope.org/zope"\n-    xmlns:meta="http://namespaces.zope.org/meta">\n-\n-    <include package="Products.Five" />\n-    <meta:redefinePermission from="zope2.Public" to="zope.Public" />\n-\n-    <securityPolicy component="AccessControl.security.SecurityPolicy" />\n-\n-</configure>\n-""", context=context)\n-\n-    def tearDownZCML(self):\n-        """Tear down the component registry and delete the\n-        ``configurationContext`` resource.\n-        """\n-        # Delete the (possibly stacked) configuration context\n-        del self[\'configurationContext\']\n-\n-        # Zap all globally loaded ZCML\n-        from plone.testing import zca\n-        zca.popGlobalRegistry()\n-\n-    def setUpFive(self):\n-        """Initialize Five without loading the site.zcml file to avoid\n-        loading all Products.* .\n-\n-        This basically pushes a special vocabulary registry that\n-        supports global and local utilities.\n-        """\n-\n-        self._oldVocabularyRegistry = getVocabularyRegistry()\n-        setVocabularyRegistry(Zope2VocabularyRegistry())\n-\n-    def tearDownFive(self):\n-        """Tear down the Five initialization restoring the previous\n-        vocabulary registry.\n-        """\n-\n-        setVocabularyRegistry(self._oldVocabularyRegistry)\n-\n \n STARTUP = Startup()\n \n@@ -759,7 +183,7 @@ def tearDownFive(self):\n # Basic integration and functional test and layers. These are the simplest\n # Zope 2 layers that are generally useful\n \n-class IntegrationTesting(Layer):\n+class IntegrationTesting(wsgi.IntegrationTesting):\n     """This layer extends ``STARTUP`` to add rollback of the transaction\n     after each test. It does not manage a fixture and has no layer lifecyle,\n     only a test lifecycle.\n@@ -785,78 +209,10 @@ class MyFixture(Layer):\n \n     defaultBases = (STARTUP,)\n \n-    # Test lifecycle\n-\n-    def testSetUp(self):\n-        import Zope2\n-\n-        # Open a new app and save it as the resource ``app``.\n-\n-        environ = {\n-            \'SERVER_NAME\': self[\'host\'],\n-            \'SERVER_PORT\': str(self[\'port\']),\n-        }\n-\n-        app = addRequestContainer(Zope2.app(), environ=environ)\n-        request = app.REQUEST\n-        request[\'PARENTS\'] = [app]\n-\n-        # Make sure we have a zope.globalrequest request\n-        try:\n-            from zope.globalrequest import setRequest\n-            setRequest(request)\n-        except ImportError:\n-            pass\n-\n-        # Start a transaction\n-        transaction.begin()\n-\n-        self._original_commit = transaction.commit\n-\n-        def you_broke_it():\n-            raise TestIsolationBroken("""You are in a Test Layer\n-(IntegrationTesting) that is fast by just aborting transactions between each\n-test.  You just committed something. That breaks the test isolation.  So I stop\n-here and let you fix it.""")\n-\n-        # XXX TODO Restore this.\n-        # Temporarily allow commits in integration tests.\n-        # Plone 5.1 still uses plone.testing 4.1.1, and for Zope 4 integration\n-        # we want master, but without the commit-breaking for now.\n-        # transaction.commit = you_broke_it\n-\n-        # Save resources for tests to access\n-        self[\'app\'] = app\n-        self[\'request\'] = request\n-\n-    def testTearDown(self):\n-\n-        # Abort the transaction\n-        transaction.abort()\n-\n-        transaction.commit = self._original_commit\n-\n-        # Make sure we have a zope.globalrequest request\n-        try:\n-            from zope.globalrequest import setRequest\n-            setRequest(None)\n-        except ImportError:\n-            pass\n-\n-        # Close the database connection and the request\n-        app = self[\'app\']\n-        app.REQUEST.close()\n-        app._p_jar.close()\n-\n-        # Delete the resources\n-        del self[\'request\']\n-        del self[\'app\']\n-\n-\n INTEGRATION_TESTING = IntegrationTesting()\n \n \n-class FunctionalTesting(Layer):\n+class FunctionalTesting(wsgi.FunctionalTesting):\n     """An alternative to ``INTEGRATION_TESTING`` suitable for functional testing.\n     This one pushes and pops a ``DemoStorage`` layer for each test. The\n     net result is that a test may commit safely.\n@@ -882,67 +238,6 @@ class MyFixture(Layer):\n \n     defaultBases = (STARTUP,)\n \n-    # Test lifecycle\n-\n-    def testSetUp(self):\n-        import Zope2\n-\n-        # Override zodbDB from the layer setup. Since it was set up by\n-        # this layer, we can\'t just assign a new shadow. We therefore keep\n-        # track of the original so that we can restore it on tear-down.\n-\n-        self[\'zodbDB\'] = zodb.stackDemoStorage(\n-            self.get(\'zodbDB\'),\n-            name=\'FunctionalTest\')\n-\n-        # Save the app\n-\n-        environ = {\n-            \'SERVER_NAME\': self[\'host\'],\n-            \'SERVER_PORT\': str(self[\'port\']),\n-        }\n-\n-        app = addRequestContainer(Zope2.app(), environ=environ)\n-        request = app.REQUEST\n-        request[\'PARENTS\'] = [app]\n-\n-        # Make sure we have a zope.globalrequest request\n-        try:\n-            from zope.globalrequest import setRequest\n-            setRequest(request)\n-        except ImportError:\n-            pass\n-\n-        # Start a transaction\n-        transaction.begin()\n-\n-        # Save resources for the test\n-        self[\'app\'] = app\n-        self[\'request\'] = request\n-\n-    def testTearDown(self):\n-        # Abort any open transactions\n-        transaction.abort()\n-\n-        # Make sure we have a zope.globalrequest request\n-        try:\n-            from zope.globalrequest import setRequest\n-            setRequest(None)\n-        except ImportError:\n-            pass\n-\n-        # Close the database connection and the request\n-        app = self[\'app\']\n-        app.REQUEST.close()\n-        app._p_jar.close()\n-\n-        del self[\'app\']\n-        del self[\'request\']\n-\n-        # Close and discard the database\n-        self[\'zodbDB\'].close()\n-        del self[\'zodbDB\']\n-\n \n FUNCTIONAL_TESTING = FunctionalTesting()\n \n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/c75680f3c7761a422fe0996dc7a852101b05ff7d

Fix documentation.

Files changed:
M src/plone/testing/wsgi.py
M src/plone/testing/zserver.py

b'diff --git a/src/plone/testing/wsgi.py b/src/plone/testing/wsgi.py\nindex df35f42..735a0fe 100644\n--- a/src/plone/testing/wsgi.py\n+++ b/src/plone/testing/wsgi.py\n@@ -755,15 +755,15 @@ class IntegrationTesting(Layer):\n     create a new layer that has ``STARTUP`` as a base. Then instantiate\n     this layer with your new "fixture" layer as a base, e.g.::\n \n-        from plone.testing import z2\n+        from plone.testing import wsgi\n         from plone.testing import Layer\n \n         class MyFixture(Layer):\n \n             ...\n \n-        MY_FIXTURE = MyFixture(bases=(z2.STARTUP,), name=\'MyFixture\')\n-        MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Integration\')  # noqa\n+        MY_FIXTURE = MyFixture(bases=(wsgi.STARTUP,), name=\'MyFixture\')\n+        MY_INTEGRATION_TESTING = wsgi.IntegrationTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Integration\')  # noqa\n     """\n \n     defaultBases = (STARTUP,)\n@@ -852,15 +852,15 @@ class FunctionalTesting(Layer):\n     create a new layer that has ``STARTUP`` as a base. Then instantiate\n     this layer with your new "fixture" layer as a base, e.g.::\n \n-        from plone.testing import z2\n+        from plone.testing import wsgi\n         from plone.testing import Layer\n \n         class MyFixture(Layer):\n \n             ...\n \n-        MY_FIXTURE = MyFixture(bases=(z2.STARTUP,), name=\'MyFixture\')\n-        MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Functional\')  # noqa\n+        MY_FIXTURE = MyFixture(bases=(wsgi.STARTUP,), name=\'MyFixture\')\n+        MY_FUNCTIONAL_TESTING = wsgi.FunctionalTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Functional\')  # noqa\n     """\n \n     defaultBases = (STARTUP,)\ndiff --git a/src/plone/testing/zserver.py b/src/plone/testing/zserver.py\nindex 56d168c..020f2e0 100644\n--- a/src/plone/testing/zserver.py\n+++ b/src/plone/testing/zserver.py\n@@ -196,15 +196,15 @@ class IntegrationTesting(wsgi.IntegrationTesting):\n     create a new layer that has ``STARTUP`` as a base. Then instantiate\n     this layer with your new "fixture" layer as a base, e.g.::\n \n-        from plone.testing import z2\n+        from plone.testing import zserver\n         from plone.testing import Layer\n \n         class MyFixture(Layer):\n \n             ...\n \n-        MY_FIXTURE = MyFixture(bases=(z2.STARTUP,), name=\'MyFixture\')\n-        MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Integration\')  # noqa\n+        MY_FIXTURE = MyFixture(bases=(zserver.STARTUP,), name=\'MyFixture\')\n+        MY_INTEGRATION_TESTING = zserver.IntegrationTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Integration\')  # noqa\n     """\n \n     defaultBases = (STARTUP,)\n@@ -225,15 +225,15 @@ class FunctionalTesting(wsgi.FunctionalTesting):\n     create a new layer that has ``STARTUP`` as a base. Then instantiate\n     this layer with your new "fixture" layer as a base, e.g.::\n \n-        from plone.testing import z2\n+        from plone.testing import zserver\n         from plone.testing import Layer\n \n         class MyFixture(Layer):\n \n             ...\n \n-        MY_FIXTURE = MyFixture(bases=(z2.STARTUP,), name=\'MyFixture\')\n-        MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Functional\')  # noqa\n+        MY_FIXTURE = MyFixture(bases=(zserver.STARTUP,), name=\'MyFixture\')\n+        MY_FUNCTIONAL_TESTING = zserver.FunctionalTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Functional\')  # noqa\n     """\n \n     defaultBases = (STARTUP,)\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/9c9c43e99fdeeac6435ac153f16601afc03ee4f2

Re-add z2.py containing BBB imports from wsgi.py.

But we use the same names used in zserver.py.
The `WSGIServer` fixture is still to be developed.

Files changed:
A src/plone/testing/z2.py
M CHANGES.rst

b"diff --git a/CHANGES.rst b/CHANGES.rst\nindex 46c49ae..76fee10 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -6,7 +6,12 @@ Changelog\n \n Breaking changes:\n \n-- *add item here*\n+- ``plone.testing.z2`` is now a BBB shim for ``plone.testing.wsgi``, thus\n+  switches the tests to use WSGI. If you absolutely want to keep using ZServer\n+  please import from ``plone.testing.zserver``.\n+\n+- ``plone.testing.z2`` no longer contains the FTP server fixture, import it\n+  from ``plone.testing.zserver``.\n \n New features:\n \ndiff --git a/src/plone/testing/z2.py b/src/plone/testing/z2.py\nnew file mode 100644\nindex 0000000..ec70675\n--- /dev/null\n+++ b/src/plone/testing/z2.py\n@@ -0,0 +1,24 @@\n+from zope.deferredimport import deprecated\n+\n+deprecated(\n+    'Please import from plone.testing.wsgi.',\n+    Browser='plone.testing.wsgi:Browser',\n+    TestIsolationBroken='plone.testing.wsgi:TestIsolationBroken',\n+    installProduct='plone.testing.wsgi:installProduct',\n+    uninstallProduct='plone.testing.wsgi:uninstallProduct',\n+    login='plone.testing.wsgi:login',\n+    logout='plone.testing.wsgi:logout',\n+    setRoles='plone.testing.wsgi:setRoles',\n+    makeTestRequest='plone.testing.wsgi:makeTestRequest',\n+    addRequestContainer='plone.testing.wsgi:addRequestContainer',\n+    zopeApp='plone.testing.wsgi:zopeApp',\n+    Startup='plone.testing.wsgi:Startup',\n+    STARTUP='plone.testing.wsgi:STARTUP',\n+    IntegrationTesting='plone.testing.wsgi:IntegrationTesting',\n+    INTEGRATION_TESTING='plone.testing.wsgi:INTEGRATION_TESTING',\n+    FunctionalTesting='plone.testing.wsgi:FunctionalTesting',\n+    FUNCTIONAL_TESTING='plone.testing.wsgi:FUNCTIONAL_TESTING',\n+    ZServer='plone.testing.wsgi:WSGIServer',\n+    ZSERVER_FIXTURE='plone.testing.wsgi:WSGI_SERVER_FIXTURE',\n+    ZSERVER='plone.testing.wsgi:WSGI_SERVER',\n+)\n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/23748ceddcf95e1cce911be92883ac874fa3ccf1

Fix change log.
[skip ci]

Files changed:
M CHANGES.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 76fee10..33cf5ab 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -15,7 +15,7 @@ Breaking changes:\n \n New features:\n \n-- Make it possible to run the tests without having ``ZServer`` installed.\n+- Make ``ZServer`` an optional dependency.\n \n Bug fixes:\n \n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/7ed54cdecea1ec4ec231fef33a978771ddc47e91

Add WSGI server fixture as replacement for the ZServer fixture.

Files changed:
M src/plone/testing/wsgi.py
M src/plone/testing/wsgi.rst
M tox.ini

b'diff --git a/src/plone/testing/wsgi.py b/src/plone/testing/wsgi.py\nindex 735a0fe..36e2147 100644\n--- a/src/plone/testing/wsgi.py\n+++ b/src/plone/testing/wsgi.py\n@@ -2,17 +2,25 @@\n """Zope-specific helpers and layers using WSGI\n """\n from OFS.metaconfigure import get_packages_to_initialize\n+from Testing.ZopeTestCase.ZopeLite import _patched as ZOPETESTCASEALERT\n+from Zope2.App.schema import Zope2VocabularyRegistry\n from plone.testing import Layer\n from plone.testing import zca\n from plone.testing import zodb\n from plone.testing._z2_testbrowser import Browser  # noqa\n-from Testing.ZopeTestCase.ZopeLite import _patched as ZOPETESTCASEALERT\n-from Zope2.App.schema import Zope2VocabularyRegistry\n from zope.schema.vocabulary import getVocabularyRegistry\n from zope.schema.vocabulary import setVocabularyRegistry\n+import ZPublisher.WSGIPublisher\n+import Zope2.Startup.run\n \n import contextlib\n+import os\n+import pkg_resources\n+import shutil\n+import tempfile\n+import threading\n import transaction\n+import wsgiref.simple_server\n \n \n _INSTALLED_PRODUCTS = {}\n@@ -925,3 +933,109 @@ def testTearDown(self):\n         # Close and discard the database\n         self[\'zodbDB\'].close()\n         del self[\'zodbDB\']\n+\n+\n+FUNCTIONAL_TESTING = FunctionalTesting()\n+\n+WSGI_LOG_REQUEST = \'WSGI_REQUEST_LOGGING\' in os.environ\n+\n+\n+class NoLogWSGIRequestHandler(wsgiref.simple_server.WSGIRequestHandler):\n+    """Less chatty WSGIRequestHandler."""\n+\n+    def log_request(self, *args):\n+        """Print the request only on the console if requested."""\n+        if WSGI_LOG_REQUEST:\n+            wsgiref.simple_server.WSGIRequestHandler.log_request(\n+                self, *args)  # old-style class :-/\n+\n+\n+class WSGIServer(Layer):\n+    """Start a WSGI server that accesses the fixture managed by the\n+    ``STARTUP`` layer.\n+\n+    The host and port are available as the resources ``host`` and ``port``,\n+    respectively.\n+\n+    The ``WSGI_SERVER_FIXTURE`` layer must be used as the base for a layer that\n+    uses the ``FunctionalTesting`` layer class. The ``WSGI_SERVER`` layer is\n+    an example of such a layer.\n+    """\n+\n+    defaultBases = (STARTUP,)\n+\n+    timeout = 5\n+    host = os.environ.get(\'WSGI_SERVER_HOST\',\n+                          os.environ.get(\'ZSERVER_HOST\', \'localhost\'))\n+    port = int(os.environ.get(\'WSGI_SERVER_PORT\',\n+                              os.environ.get(\'ZSERVER_PORT\', 55001)))\n+    pipeline = [\n+        (\'Zope\', \'paste.filter_app_factory\', \'httpexceptions\', {}),\n+    ]\n+\n+    def setUp(self):\n+        self[\'host\'] = self.host\n+        self.setUpServer()\n+        self[\'port\'] = self.port\n+\n+    def tearDown(self):\n+        self.tearDownServer()\n+        del self[\'host\']\n+        del self[\'port\']\n+\n+    def setUpServer(self):\n+        """Create a WSGI server instance and save it in self.server.\n+        """\n+        app = self.make_wsgi_app()\n+        self.server = wsgiref.simple_server.make_server(\n+            self.host, self.port, app, handler_class=NoLogWSGIRequestHandler)\n+        # allow to choose a random port using 0 as port number:\n+        self.port = self.server.server_port\n+\n+        self.thread = threading.Thread(target=self.serve)\n+        self.thread.daemon = True\n+        self.thread.start()\n+\n+    def tearDownServer(self):\n+        """Close the server socket and clean up.\n+        """\n+        self.server.shutdown()\n+        self.server.server_close()\n+        self.thread.join(self.timeout)\n+        if self.thread.isAlive():\n+            raise RuntimeError(\'WSGI server could not be shut down\')\n+\n+        shutil.rmtree(self._wsgi_conf_dir)\n+\n+    def make_wsgi_app(self):\n+        self._wsgi_conf_dir = tempfile.mkdtemp()\n+        global_config = {\'here\': self._wsgi_conf_dir}\n+        zope_conf = self._get_zope_conf(self._wsgi_conf_dir)\n+        Zope2.Startup.run.make_wsgi_app(global_config, zope_conf)\n+        app = ZPublisher.WSGIPublisher.publish_module\n+\n+        for spec, protocol, name, extra in reversed(self.pipeline):\n+            entrypoint = pkg_resources.get_entry_info(spec, protocol, name)\n+            app = entrypoint.load()(app, global_config, **extra)\n+        return app\n+\n+    def serve(self):\n+        self.server.serve_forever()\n+\n+    def _get_zope_conf(self, dir):\n+        fd, path = tempfile.mkstemp(dir=dir)\n+        with os.fdopen(fd, \'w\') as zope_conf:\n+            zope_conf.write(\'instancehome {0}\\n\'.format(os.path.dirname(dir)))\n+        return path\n+\n+\n+# Fixture layer - use as a base layer, but don\'t use directly, as it has no\n+# test lifecycle\n+WSGI_SERVER_FIXTURE = WSGIServer()\n+\n+# Functional testing layer that uses the WSGI_SERVER_FIXTURE\n+WSGI_SERVER = FunctionalTesting(\n+    bases=(\n+        WSGI_SERVER_FIXTURE,\n+    ),\n+    name=\'WSGIServer:Functional\')\ndiff --git a/src/plone/testing/wsgi.rst b/src/plone/testing/wsgi.rst\nindex 2ea6241..d7bbbf1 100644\n--- a/src/plone/testing/wsgi.rst\n+++ b/src/plone/testing/wsgi.rst\n@@ -433,3 +433,101 @@ Let\'s tear down the layer:::\n     Tear down plone.testing.wsgi.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n+HTTP server\n+~~~~~~~~~~~\n+\n+The ``WSGI_SERVER_FIXTURE`` layer extends ``STARTUP`` to start a single-threaded Zope server in a separate thread.\n+This makes it possible to connect to the test instance using a web browser or a testing tool like Selenium or Windmill.\n+\n+The ``WSGI_SERVER`` layer provides a ``FunctionalTesting`` layer that has ``WSGI_SERVER_FIXTURE`` as its base.::\n+\n+    >>> "%s.%s" % (wsgi.WSGI_SERVER_FIXTURE.__module__, wsgi.WSGI_SERVER_FIXTURE.__name__,)\n+    \'plone.testing.wsgi.WSGIServer\'\n+\n+    >>> wsgi.WSGI_SERVER_FIXTURE.__bases__\n+    (<Layer \'plone.testing.wsgi.Startup\'>,)\n+\n+\n+    >>> "%s.%s" % (wsgi.WSGI_SERVER.__module__, wsgi.WSGI_SERVER.__name__,)\n+    \'plone.testing.wsgi.WSGIServer:Functional\'\n+\n+    >>> wsgi.WSGI_SERVER.__bases__\n+    (<Layer \'plone.testing.wsgi.WSGIServer\'>,)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, wsgi.WSGI_SERVER, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.wsgi.Startup in ... seconds.\n+    Set up plone.testing.wsgi.WSGIServer in ... seconds.\n+    Set up plone.testing.wsgi.WSGIServer:Functional in ... seconds.\n+\n+After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n+\n+    >>> host = wsgi.WSGI_SERVER[\'host\']\n+    >>> host\n+    \'localhost\'\n+\n+    >>> port = wsgi.WSGI_SERVER[\'port\']\n+    >>> import os\n+    >>> port == int(os.environ.get(\'WSGI_SERVER_PORT\', 55001))\n+    True\n+\n+Let\'s now simulate a test.\n+Test setup does nothing beyond what the base layers do.::\n+\n+    >>> wsgi.STARTUP.testSetUp()\n+    >>> wsgi.FUNCTIONAL_TESTING.testSetUp()\n+    >>> wsgi.WSGI_SERVER.testSetUp()\n+\n+It is common in a test to use the Python API to change the state of the server (e.g.\n+create some content or change a setting) and then use the HTTP protocol to look at the results.\n+Bear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``wsgi.login()`` and ``wsgi.logout()``, for instance, do not affect the server thread.::\n+\n+    >>> app = wsgi.WSGI_SERVER[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app.manage_addFolder(\'folder1\')\n+\n+Note that we need to commit the transaction before it will show up in the other thread.::\n+\n+    >>> import transaction; transaction.commit()\n+\n+We can now look for this new object through the server.::\n+\n+    >>> app_url = app.absolute_url()\n+    >>> app_url.split(\':\')[:-1]\n+    [\'http\', \'//localhost\']\n+\n+    >>> import urllib2\n+    >>> conn = urllib2.urlopen(app_url + \'/folder1\', timeout=5)\n+    >>> print conn.read()\n+    <Folder at folder1>\n+    >>> conn.close()\n+\n+Test tear-down does nothing beyond what the base layers do.::\n+\n+    >>> wsgi.WSGI_SERVER.testTearDown()\n+    >>> wsgi.FUNCTIONAL_TESTING.testTearDown()\n+    >>> wsgi.STARTUP.testTearDown()\n+\n+    >>> \'app\' in wsgi.WSGI_SERVER\n+    False\n+\n+    >>> \'request\' in wsgi.WSGI_SERVER\n+    False\n+\n+    >>> with wsgi.zopeApp() as app:\n+    ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n+    True\n+\n+When the server is torn down, the WSGIServer thread is stopped.::\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.testing.wsgi.WSGIServer:Functional in ... seconds.\n+    Tear down plone.testing.wsgi.WSGIServer in ... seconds.\n+    Tear down plone.testing.wsgi.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+    >>> conn = urllib2.urlopen(app_url + \'/folder1\', timeout=5)\n+    Traceback (most recent call last):\n+    ...\n+    URLError: <urlopen error [Errno ...] Connection refused>\ndiff --git a/tox.ini b/tox.ini\nindex 126c650..7b626bf 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -14,6 +14,7 @@ deps =\n commands = coverage run {envbindir}/zope-testrunner --path=src --all {posargs:-vc}\n setenv =\n     COVERAGE_FILE=.coverage.{envname}\n+passenv = WSGI_REQUEST_LOGGING\n \n [testenv:py27-zserver]\n deps = .[test,z2]\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/010ae5f46da903284f5568a78ff312e4c5305d2c

Add back a no-op FTPServer layer to possibly make the Plone tests happy.

Files changed:
M CHANGES.rst
M src/plone/testing/z2.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 33cf5ab..ffbbeba 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -6,12 +6,13 @@ Changelog\n \n Breaking changes:\n \n-- ``plone.testing.z2`` is now a BBB shim for ``plone.testing.wsgi``, thus\n+- ``plone.testing.z2`` is now a BBB shim for ``plone.testing.wsgi``, thus it\n   switches the tests to use WSGI. If you absolutely want to keep using ZServer\n   please import from ``plone.testing.zserver``.\n \n-- ``plone.testing.z2`` no longer contains the FTP server fixture, import it\n-  from ``plone.testing.zserver``.\n+- ``plone.testing.z2`` now only contains a no-op FTPServer layer because FTP is\n+  nit supported by WSGI. If you really need it, import it from\n+  ``plone.testing.zserver`` but this will not work on Python 3.\n \n New features:\n \ndiff --git a/src/plone/testing/z2.py b/src/plone/testing/z2.py\nindex ec70675..c056a5b 100644\n--- a/src/plone/testing/z2.py\n+++ b/src/plone/testing/z2.py\n@@ -1,4 +1,7 @@\n from zope.deferredimport import deprecated\n+import plone.testing\n+import plone.testing.wsgi\n+import warnings\n \n deprecated(\n     \'Please import from plone.testing.wsgi.\',\n@@ -22,3 +25,21 @@\n     ZSERVER_FIXTURE=\'plone.testing.wsgi:WSGI_SERVER_FIXTURE\',\n     ZSERVER=\'plone.testing.wsgi:WSGI_SERVER\',\n )\n+\n+\n+class FTPServer(plone.testing.Layer):\n+    """No-op so imports do not break."""\n+\n+    def setUp(self):\n+        warnings.warn(\n+            \'The FTPServer layer is now only a no-op as FTP is not supported\'\n+            \' by WSGI. If you really need the fixture import it from\'\n+            \' plone.testing.zserver.\')\n+\n+FTP_SERVER_FIXTURE = FTPServer()\n+\n+FTP_SERVER = plone.testing.wsgi.FunctionalTesting(\n+    bases=(\n+        FTP_SERVER_FIXTURE,\n+    ),\n+    name=\'No-OpFTPServer:Functional\')\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/30a0b5f81c7f3937894a790356a6bb9b69c2034c

Allow to import `Layer` from z2.
(Some plone tests do this.)

Files changed:
M src/plone/testing/z2.py

b'diff --git a/src/plone/testing/z2.py b/src/plone/testing/z2.py\nindex c056a5b..7f1c1a8 100644\n--- a/src/plone/testing/z2.py\n+++ b/src/plone/testing/z2.py\n@@ -27,6 +27,12 @@\n )\n \n \n+deprecated(\n+    \'Please import from plone.testing.\',\n+    Layer=\'plone.testing:Layer\',\n+)\n+\n+\n class FTPServer(plone.testing.Layer):\n     """No-op so imports do not break."""\n \n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/af938143cd640e969b975b8ff7dcee138447f2df

Silence most of the code smells Jenkins complains about.

Files changed:
M src/plone/testing/tests.py
M src/plone/testing/wsgi.py
M src/plone/testing/z2.py
M src/plone/testing/zserver.py

b'diff --git a/src/plone/testing/tests.py b/src/plone/testing/tests.py\nindex 29068e5..3c49bd1 100644\n--- a/src/plone/testing/tests.py\n+++ b/src/plone/testing/tests.py\n@@ -8,6 +8,7 @@\n import unittest\n import zope.component.testing\n \n+\n try:\n     import ZServer  # noqa\n except ImportError:\ndiff --git a/src/plone/testing/wsgi.py b/src/plone/testing/wsgi.py\nindex 36e2147..78678b3 100644\n--- a/src/plone/testing/wsgi.py\n+++ b/src/plone/testing/wsgi.py\n@@ -2,16 +2,14 @@\n """Zope-specific helpers and layers using WSGI\n """\n from OFS.metaconfigure import get_packages_to_initialize\n-from Testing.ZopeTestCase.ZopeLite import _patched as ZOPETESTCASEALERT\n-from Zope2.App.schema import Zope2VocabularyRegistry\n from plone.testing import Layer\n from plone.testing import zca\n from plone.testing import zodb\n from plone.testing._z2_testbrowser import Browser  # noqa\n+from Testing.ZopeTestCase.ZopeLite import _patched as ZOPETESTCASEALERT\n+from Zope2.App.schema import Zope2VocabularyRegistry\n from zope.schema.vocabulary import getVocabularyRegistry\n from zope.schema.vocabulary import setVocabularyRegistry\n-import ZPublisher.WSGIPublisher\n-import Zope2.Startup.run\n \n import contextlib\n import os\n@@ -21,6 +19,8 @@\n import threading\n import transaction\n import wsgiref.simple_server\n+import Zope2.Startup.run\n+import ZPublisher.WSGIPublisher\n \n \n _INSTALLED_PRODUCTS = {}\ndiff --git a/src/plone/testing/z2.py b/src/plone/testing/z2.py\nindex 7f1c1a8..3423074 100644\n--- a/src/plone/testing/z2.py\n+++ b/src/plone/testing/z2.py\n@@ -1,8 +1,11 @@\n+# -*- coding: utf-8 -*-\n from zope.deferredimport import deprecated\n+\n import plone.testing\n import plone.testing.wsgi\n import warnings\n \n+\n deprecated(\n     \'Please import from plone.testing.wsgi.\',\n     Browser=\'plone.testing.wsgi:Browser\',\n@@ -42,6 +45,7 @@ def setUp(self):\n             \' by WSGI. If you really need the fixture import it from\'\n             \' plone.testing.zserver.\')\n \n+\n FTP_SERVER_FIXTURE = FTPServer()\n \n FTP_SERVER = plone.testing.wsgi.FunctionalTesting(\ndiff --git a/src/plone/testing/zserver.py b/src/plone/testing/zserver.py\nindex 020f2e0..4f493a9 100644\n--- a/src/plone/testing/zserver.py\n+++ b/src/plone/testing/zserver.py\n@@ -2,12 +2,12 @@\n """Zope2-specific helpers and layers using ZServer\n """\n from plone.testing import Layer\n+from plone.testing import wsgi\n+from plone.testing._z2_testbrowser import Browser  # noqa\n from plone.testing.wsgi import addRequestContainer\n from plone.testing.wsgi import login  # noqa\n from plone.testing.wsgi import logout  # noqa\n from plone.testing.wsgi import setRoles  # noqa\n-from plone.testing._z2_testbrowser import Browser  # noqa\n-from plone.testing import wsgi\n \n import contextlib\n import os\n@@ -128,8 +128,11 @@ def setUpApp(self):\n \n         import App.config\n         config = App.config.getConfiguration()\n-        if hasattr(config, \'testinghome\'):\n+        try:\n             self._testingHome = config.testinghome\n+        except AttributeError:\n+            pass\n+        else:\n             del config.testinghome\n             App.config.setConfiguration(config)\n \n@@ -160,7 +163,11 @@ def tearDownApp(self):\n         Zope2.__bobo_before__ = None\n \n         import App.config\n-        if hasattr(self, \'_testingHome\'):\n+        try:\n+            self._testingHome\n+        except AttributeError:\n+            pass\n+        else:\n             config = App.config.getConfiguration()\n             config.testinghome = self._testingHome\n             App.config.setConfiguration(config)\n@@ -209,6 +216,7 @@ class MyFixture(Layer):\n \n     defaultBases = (STARTUP,)\n \n+\n INTEGRATION_TESTING = IntegrationTesting()\n \n \n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Ruda Porto Filgueiras (rudaporto) <rudazz@gmail.com>
Commit: https://github.com/plone/plone.testing/commit/1088931bbccbd230ec603ab4343d8506433fe398

Added missing _compat module.

Files changed:
A src/plone/testing/_compat.py

b'diff --git a/src/plone/testing/_compat.py b/src/plone/testing/_compat.py\nnew file mode 100644\nindex 0000000..55574c4\n--- /dev/null\n+++ b/src/plone/testing/_compat.py\n@@ -0,0 +1,10 @@\n+"""Python 3 compat module"""\n+import sys\n+\n+\n+PY3 = sys.version_info[0] == 3\n+if PY3:\n+    from io import StringIO\n+else:\n+    from cStringIO import StringIO\n+ \n\\ No newline at end of file\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Ruda Porto Filgueiras (rudaporto) <rudazz@gmail.com>
Commit: https://github.com/plone/plone.testing/commit/6eebe0d6d808900ee4c098ad78d40d223fb8efe0

Fix typo.

Files changed:
M src/plone/testing/_compat.py

b'diff --git a/src/plone/testing/_compat.py b/src/plone/testing/_compat.py\nindex 55574c4..65e206e 100644\n--- a/src/plone/testing/_compat.py\n+++ b/src/plone/testing/_compat.py\n@@ -7,4 +7,3 @@\n     from io import StringIO\n else:\n     from cStringIO import StringIO\n- \n\\ No newline at end of file\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.testing/commit/69bd6eb93807218fb0167c9cf5d4ac07570d7e4e

use six instead of _compat

Files changed:
D src/plone/testing/_compat.py

b'diff --git a/src/plone/testing/_compat.py b/src/plone/testing/_compat.py\ndeleted file mode 100644\nindex 65e206e..0000000\n--- a/src/plone/testing/_compat.py\n+++ /dev/null\n@@ -1,9 +0,0 @@\n-"""Python 3 compat module"""\n-import sys\n-\n-\n-PY3 = sys.version_info[0] == 3\n-if PY3:\n-    from io import StringIO\n-else:\n-    from cStringIO import StringIO\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.testing/commit/70d5570d9e28947cfd017b7a563f9a73b7ebdfa5

add changenote

Files changed:
M CHANGES.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex ffbbeba..8bf5447 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -35,6 +35,8 @@ Bug fixes:\n \n - No longer use deprecated import for getSite/setSite.\n   [jensens]\n+- Python 2 / 3 compatible imports.\n+  [rudaporto]\n \n - Update code to follow Plone styleguide.\n   [gforcada]\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.testing/commit/0c5819bb543078a14e732428d0606d5b7e1a6d11

make most doctests run in python3

Files changed:
M src/plone/testing/README.rst
M src/plone/testing/layer.rst
M src/plone/testing/publisher.rst
M src/plone/testing/security.rst
M src/plone/testing/tests.py
M src/plone/testing/zca.rst
M src/plone/testing/zserver.rst

b'diff --git a/src/plone/testing/README.rst b/src/plone/testing/README.rst\nindex 4adaf6b..fd2bfd3 100644\n--- a/src/plone/testing/README.rst\n+++ b/src/plone/testing/README.rst\n@@ -465,16 +465,16 @@ A simple layer may look like this::\n     >>> class SpaceShip(Layer):\n     ...\n     ...     def setUp(self):\n-    ...         print "Assembling space ship"\n+    ...         print("Assembling space ship")\n     ...\n     ...     def tearDown(self):\n-    ...         print "Disasembling space ship"\n+    ...         print("Disasembling space ship")\n     ...\n     ...     def testSetUp(self):\n-    ...         print "Fuelling space ship in preparation for test"\n+    ...         print("Fuelling space ship in preparation for test")\n     ...\n     ...     def testTearDown(self):\n-    ...         print "Emptying the fuel tank"\n+    ...         print("Emptying the fuel tank")\n \n Before this layer can be used, it must be instantiated.\n Layers are normally instantiated exactly once, since by nature they are shared between tests.\n@@ -499,7 +499,7 @@ Here is an example of another layer that depends on it:::\n     ...     defaultBases = (SPACE_SHIP,)\n     ...\n     ...     def setUp(self):\n-    ...         print "Installing main canon"\n+    ...         print("Installing main canon")\n \n     >>> ZIG = ZIGSpaceShip()\n \n@@ -544,10 +544,10 @@ Normally, of course, you would just re-use the layer instance, either directly i\n     >>> class CATSMessage(Layer):\n     ...\n     ...     def setUp(self):\n-    ...         print "All your base are belong to us"\n+    ...         print("All your base are belong to us")\n     ...\n     ...     def tearDown(self):\n-    ...         print "For great justice"\n+    ...         print("For great justice")\n \n     >>> CATS_MESSAGE = CATSMessage()\n \n@@ -596,9 +596,9 @@ The resource storage uses dictionary notation:::\n     ...\n     ...     def start(self, speed):\n     ...         if speed > self.maxSpeed:\n-    ...             print "We need more power!"\n+    ...             print("We need more power!")\n     ...         else:\n-    ...             print "Going to warp at speed", speed\n+    ...             print("Going to warp at speed", speed)\n     ...             self.running = True\n     ...\n     ...     def stop(self):\ndiff --git a/src/plone/testing/layer.rst b/src/plone/testing/layer.rst\nindex 26cb28a..73649cf 100644\n--- a/src/plone/testing/layer.rst\n+++ b/src/plone/testing/layer.rst\n@@ -55,7 +55,7 @@ The ``name`` argument is required when using ``Layer`` directly (but not when us\n     >>> class NullLayer(Layer):\n     ...     pass\n     >>> NullLayer()\n-    <Layer \'__builtin__.NullLayer\'>\n+    <Layer \'builtins.NullLayer\'>\n \n Using ``Layer`` as a base class\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -66,10 +66,10 @@ This can then override the lifecycle methods as appropriate, as well as set a de\n     >>> class BaseLayer(Layer):\n     ...\n     ...     def setUp(self):\n-    ...         print "Setting up base layer"\n+    ...         print("Setting up base layer")\n     ...\n     ...     def tearDown(self):\n-    ...         print "Tearing down base layer"\n+    ...         print("Tearing down base layer")\n \n     >>> BASE_LAYER = BaseLayer()\n \n@@ -80,7 +80,7 @@ The layer name and module are taken from the class.::\n     >>> BASE_LAYER.__name__\n     \'BaseLayer\'\n     >>> BASE_LAYER.__module__\n-    \'__builtin__\'\n+    \'builtins\'\n \n We can now create a new layer that has this one as a base.\n We can do this in the instance constructor, as shown above, but the most common pattern is to set the default bases in the class body, using the variable ``defaultBases``.\n@@ -95,21 +95,21 @@ This is mostly cosmetic, but may be desirable if the class name would be mislead\n     ...         super(ChildLayer, self).__init__(bases, name, module)\n     ...\n     ...     def setUp(self):\n-    ...         print "Setting up child layer"\n+    ...         print("Setting up child layer")\n     ...\n     ...     def tearDown(self):\n-    ...         print "Tearing down child layer"\n+    ...         print("Tearing down child layer")\n \n     >>> CHILD_LAYER = ChildLayer()\n \n Notice how the bases have now been set using the value in ``defaultBases``.::\n \n     >>> CHILD_LAYER.__bases__\n-    (<Layer \'__builtin__.BaseLayer\'>,)\n+    (<Layer \'builtins.BaseLayer\'>,)\n     >>> CHILD_LAYER.__name__\n     \'Child layer\'\n     >>> CHILD_LAYER.__module__\n-    \'__builtin__\'\n+    \'builtins\'\n \n Overriding the default list of bases\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -125,11 +125,11 @@ When creating a second instance of a layer (most layers are global singletons cr\n     >>> NEW_CHILD_LAYER = ChildLayer(bases=(SIMPLE_LAYER, BASE_LAYER,), name=\'New child\')\n \n     >>> NEW_CHILD_LAYER.__bases__\n-    (<Layer \'plone.testing.tests.Simple layer\'>, <Layer \'__builtin__.BaseLayer\'>)\n+    (<Layer \'plone.testing.tests.Simple layer\'>, <Layer \'builtins.BaseLayer\'>)\n     >>> NEW_CHILD_LAYER.__name__\n     \'New child\'\n     >>> NEW_CHILD_LAYER.__module__\n-    \'__builtin__\'\n+    \'builtins\'\n \n Inconsistent bases\n ~~~~~~~~~~~~~~~~~~\n@@ -138,12 +138,12 @@ Layer bases are maintained in an order that is semantically equivalent to the "m\n We can get this from the ``baseResolutionOrder`` attribute:::\n \n     >>> CHILD_LAYER.baseResolutionOrder\n-    (<Layer \'__builtin__.Child layer\'>, <Layer \'__builtin__.BaseLayer\'>)\n+    (<Layer \'builtins.Child layer\'>, <Layer \'builtins.BaseLayer\'>)\n \n     >>> NEW_CHILD_LAYER.baseResolutionOrder\n-    (<Layer \'__builtin__.New child\'>, <Layer \'plone.testing.tests.Simple layer\'>,\n+    (<Layer \'builtins.New child\'>, <Layer \'plone.testing.tests.Simple layer\'>,\n      <Layer \'plone.testing.layer.Null layer\'>,\n-     <Layer \'__builtin__.BaseLayer\'>)\n+     <Layer \'builtins.BaseLayer\'>)\n \n As with Python classes, it is possible to construct an invalid set of bases.\n In this case, layer instantiation will fail.::\n@@ -211,10 +211,10 @@ The layers are ordered in a known "resource resolution order", which is used to\n This is based on the same algorithm as Python\'s method resolution order.::\n \n     >>> LAYER4.baseResolutionOrder\n-    (<Layer \'__builtin__.Layer4\'>,\n-     <Layer \'__builtin__.Layer2\'>,\n-     <Layer \'__builtin__.Layer1\'>,\n-     <Layer \'__builtin__.Layer3\'>)\n+    (<Layer \'builtins.Layer4\'>,\n+     <Layer \'builtins.Layer2\'>,\n+     <Layer \'builtins.Layer1\'>,\n+     <Layer \'builtins.Layer3\'>)\n \n When fetching and item from a layer, it will be obtained according to the resource resolution order.::\n \n@@ -283,7 +283,7 @@ We want to demonstrate having two "branches" of bases that both happen to define\n     ...     def setUp(self):\n     ...         self[\'resource\'] = "Base 1"\n     ...     def testSetUp(self):\n-    ...         print self[\'resource\']\n+    ...         print(self[\'resource\'])\n     ...     def tearDown(self):\n     ...         del self[\'resource\']\n \n@@ -292,7 +292,7 @@ We want to demonstrate having two "branches" of bases that both happen to define\n     >>> class ResourceBaseLayer2(Layer):\n     ...     defaultBases = (RESOURCE_BASE_LAYER1,)\n     ...     def testSetUp(self):\n-    ...         print self[\'resource\']\n+    ...         print(self[\'resource\'])\n \n     >>> RESOURCE_BASE_LAYER2 = ResourceBaseLayer2()\n \n@@ -300,7 +300,7 @@ We want to demonstrate having two "branches" of bases that both happen to define\n     ...     def setUp(self):\n     ...         self[\'resource\'] = "Base 3"\n     ...     def testSetUp(self):\n-    ...         print self[\'resource\']\n+    ...         print(self[\'resource\'])\n     ...     def tearDown(self):\n     ...         del self[\'resource\']\n \n@@ -313,7 +313,7 @@ We\'ll then create the child layer that overrides this resource.::\n     ...     def setUp(self):\n     ...         self[\'resource\'] = "Child"\n     ...     def testSetUp(self):\n-    ...         print self[\'resource\']\n+    ...         print(self[\'resource\'])\n     ...     def tearDown(self):\n     ...         del self[\'resource\']\n \ndiff --git a/src/plone/testing/publisher.rst b/src/plone/testing/publisher.rst\nindex 921ebc9..d96c393 100644\n--- a/src/plone/testing/publisher.rst\n+++ b/src/plone/testing/publisher.rst\n@@ -43,7 +43,7 @@ the ``<permission />`` or ``<browser:view />`` directives without loading the ne\n     Traceback (most recent call last):\n     ...\n     ZopeXMLConfigurationError: File "<string>", line 5.4\n-        ConfigurationError: (\'Unknown directive\', u\'http://namespaces.zope.org/zope\', u\'permission\')\n+        ConfigurationError: (\'Unknown directive\', \'http://namespaces.zope.org/zope\', \'permission\')\n \n Layer setup creates a configuration context we can use to load further configuration.::\n \ndiff --git a/src/plone/testing/security.rst b/src/plone/testing/security.rst\nindex 3423bd3..4a36e92 100644\n--- a/src/plone/testing/security.rst\n+++ b/src/plone/testing/security.rst\n@@ -26,10 +26,11 @@ Before the test, our custom checker is not in the registry.::\n     ...     pass\n \n     >>> from zope.security.interfaces import IChecker\n-    >>> from zope.interface import implements\n-    >>> class FauxChecker(object):\n-    ...     implements(IChecker)\n+    >>> from zope.interface import implementer\n+    >>> @implementer(IChecker)\n+    ... class FauxChecker(object):\n     ...     # we should really implement the interface here, but oh well\n+    ...     pass\n \n     >>> from zope.security.checker import getCheckerForInstancesOf\n     >>> getCheckerForInstancesOf(DummyObject) is None\ndiff --git a/src/plone/testing/tests.py b/src/plone/testing/tests.py\nindex 3c49bd1..d97a55a 100644\n--- a/src/plone/testing/tests.py\n+++ b/src/plone/testing/tests.py\n@@ -2,10 +2,12 @@\n from OFS.SimpleItem import SimpleItem\n from pkg_resources import get_distribution\n from ZPublisher.Iterators import filestream_iterator\n+from zope.testing import renormalizing\n \n import doctest\n import os.path\n import unittest\n+import re\n import zope.component.testing\n \n \n@@ -66,6 +68,23 @@ def tearDown(self):\n     zope.component.testing.tearDown()\n \n \n+checker = renormalizing.RENormalizing([\n+    # normalize py2 output to py3\n+    (re.compile(r\'__buildin__\'), r\'buildins\'),\n+\n+    (re.compile(\n+        r"\'Unknown directive\', u\'http://namespaces.zope.org/zope\', u\'"),\n+     r"\'Unknown directive\', \'http://namespaces.zope.org/zope\', \'"),\n+\n+    # normalize py3 output to py3\n+    (re.compile(\n+        r"zope\\.configuration\\.xmlconfig\\.ZopeXMLConfigurationError"),\n+     r"ZopeXMLConfigurationError"),\n+    (re.compile(r"builtins\\.PopulatedZODB"), r"PopulatedZODB"),\n+    (re.compile(r"builtins\\.ExpandedZODB"), r"ExpandedZODB"),\n+])\n+\n+\n def test_suite():\n     suite = unittest.TestSuite()\n     suite.addTests([\n@@ -76,6 +95,7 @@ def test_suite():\n             \'publisher.rst\',\n             \'zodb.rst\',\n             \'wsgi.rst\',\n+            checker=checker,\n             setUp=setUp,\n             tearDown=tearDown,\n             optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,\ndiff --git a/src/plone/testing/zca.rst b/src/plone/testing/zca.rst\nindex 5a5e7bb..480f6ac 100644\n--- a/src/plone/testing/zca.rst\n+++ b/src/plone/testing/zca.rst\n@@ -231,7 +231,7 @@ Before the test, we cannot use e.g. a ``<utility />`` directive without loading\n     Traceback (most recent call last):\n     ...\n     ZopeXMLConfigurationError: File "<string>", line 2.4\n-        ConfigurationError: (\'Unknown directive\', u\'http://namespaces.zope.org/zope\', u\'utility\')\n+        ConfigurationError: (\'Unknown directive\', \'http://namespaces.zope.org/zope\', \'utility\')\n \n Layer setup creates a configuration context we can use to load further configuration.::\n \n@@ -285,12 +285,12 @@ The second registry is set up and torn down for each test, allowing tests to reg\n \n First, we\'ll create a simple dummy utility to illustrate registrations.::\n \n-    >>> from zope.interface import Interface, implements\n+    >>> from zope.interface import Interface, implementer\n \n     >>> class IDummyUtility(Interface):\n     ...     pass\n-    >>> class DummyUtility(object):\n-    ...     implements(IDummyUtility)\n+    >>> @implementer(IDummyUtility)\n+    ... class DummyUtility(object):\n     ...     def __init__(self, name):\n     ...         self.name = name\n     ...     def __repr__(self):\ndiff --git a/src/plone/testing/zserver.rst b/src/plone/testing/zserver.rst\nindex 01d46f7..42ac5cf 100644\n--- a/src/plone/testing/zserver.rst\n+++ b/src/plone/testing/zserver.rst\n@@ -500,7 +500,7 @@ We can now look for this new object through the server.::\n \n     >>> import urllib2\n     >>> conn = urllib2.urlopen(app_url + \'/folder1\', timeout=5)\n-    >>> print conn.read()\n+    >>> print(conn.read())\n     <Folder at folder1>\n     >>> conn.close()\n \n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.testing/commit/17cdc890943685d9a00e4b44cf4dbef5d33ee609

fix regex

Files changed:
M src/plone/testing/tests.py

b'diff --git a/src/plone/testing/tests.py b/src/plone/testing/tests.py\nindex d97a55a..12d603d 100644\n--- a/src/plone/testing/tests.py\n+++ b/src/plone/testing/tests.py\n@@ -8,6 +8,7 @@\n import os.path\n import unittest\n import re\n+import unittest\n import zope.component.testing\n \n \n@@ -70,8 +71,7 @@ def tearDown(self):\n \n checker = renormalizing.RENormalizing([\n     # normalize py2 output to py3\n-    (re.compile(r\'__buildin__\'), r\'buildins\'),\n-\n+    (re.compile(r\'__builtin__\'), r\'builtins\'),\n     (re.compile(\n         r"\'Unknown directive\', u\'http://namespaces.zope.org/zope\', u\'"),\n      r"\'Unknown directive\', \'http://namespaces.zope.org/zope\', \'"),\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.testing/commit/8bd07fcb08f514ff1ce4dd03a081870c970d8ebc

needs six

Files changed:
M CHANGES.rst
M setup.py

b"diff --git a/CHANGES.rst b/CHANGES.rst\nindex 8bf5447..8d72055 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -35,6 +35,9 @@ Bug fixes:\n \n - No longer use deprecated import for getSite/setSite.\n   [jensens]\n+- Fix most doctests for python 3.\n+  [rudaporto]\n+\n - Python 2 / 3 compatible imports.\n   [rudaporto]\n \ndiff --git a/setup.py b/setup.py\nindex 2612a70..34a14a6 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -8,6 +8,7 @@\n \n install_requires = [\n     'setuptools',\n+    'six',\n     'zope.testing',\n ]\n \n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.testing/commit/bfcc658ea33b0ae319b48fff87ce0f58a9f8a95e

test against 5.2 coredev versions. Add ZSever as dependency until removed

Files changed:
M buildout.cfg

b'diff --git a/buildout.cfg b/buildout.cfg\nindex 5854182..34df24f 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -1,4 +1,6 @@\n [buildout]\n+extends =\n+    https://raw.githubusercontent.com/plone/buildout.coredev/5.2/versions.cfg\n parts = coverage test report report-xml\n develop = .\n prefer-final = false\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/2f9821ddba008e8ff02afdd132ece7df092b59b3

Add support for Python 3.6.

Files changed:
M .travis.yml
M CHANGES.rst
M setup.py
M src/plone/testing/tests.py
M src/plone/testing/wsgi.rst
M tox.ini

b'diff --git a/.travis.yml b/.travis.yml\nindex 5058ba4..3456c2d 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -2,9 +2,14 @@ language: python\n sudo: false\n python:\n     - 2.7\n+    - 3.6\n env:\n     - EXTRA=\n     - EXTRA=-zserver\n+matrix:\n+    exclude:\n+    - python: 3.6\n+      env: EXTRA=-zserver\n install:\n     - pip install tox\n script:\n@@ -14,5 +19,3 @@ after_success:\n     - coveralls\n cache:\n   pip: true\n-  directories:\n-    - eggs/\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex 8d72055..2d0396c 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -1,8 +1,8 @@\n Changelog\n =========\n \n-6.0.1 (unreleased)\n-------------------\n+6.1 (unreleased)\n+----------------\n \n Breaking changes:\n \n@@ -18,6 +18,8 @@ New features:\n \n - Make ``ZServer`` an optional dependency.\n \n+- Add support for Python 3.6.\n+\n Bug fixes:\n \n - Fix most of the code smells Jenkins complains about.\ndiff --git a/setup.py b/setup.py\nindex 34a14a6..edf3fec 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -4,7 +4,7 @@\n import sys\n from setuptools import setup, find_packages\n \n-version = \'6.0.1.dev0\'\n+version = \'6.1.dev0\'\n \n install_requires = [\n     \'setuptools\',\n@@ -46,14 +46,20 @@\n         open(os.path.join("src", "plone", "testing", "zserver.rst")).read(),\n     ])),\n     classifiers=[\n+        "Development Status :: 5 - Production/Stable",\n         "Environment :: Web Environment",\n-        "Framework :: Plone",\n         "Framework :: Plone :: 5.2",\n+        "Framework :: Plone",\n+        "Framework :: Zope :: 4",\n+        "Intended Audience :: Developers",\n+        "License :: OSI Approved :: BSD License",\n         "Operating System :: OS Independent",\n-        "Programming Language :: Python",\n         "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.6",\n+        "Programming Language :: Python :: Implementation :: CPython",\n+        "Programming Language :: Python",\n         "Topic :: Internet :: WWW/HTTP :: Dynamic Content",\n-        "License :: OSI Approved :: BSD License",\n+        "Topic :: Software Development :: Testing",\n     ],\n     keywords=\'plone zope testing\',\n     author=\'Plone Foundation\',\ndiff --git a/src/plone/testing/tests.py b/src/plone/testing/tests.py\nindex 12d603d..f2d0640 100644\n--- a/src/plone/testing/tests.py\n+++ b/src/plone/testing/tests.py\n@@ -76,15 +76,25 @@ def tearDown(self):\n         r"\'Unknown directive\', u\'http://namespaces.zope.org/zope\', u\'"),\n      r"\'Unknown directive\', \'http://namespaces.zope.org/zope\', \'"),\n \n-    # normalize py3 output to py3\n+    # normalize py3 output to py2\n     (re.compile(\n         r"zope\\.configuration\\.xmlconfig\\.ZopeXMLConfigurationError"),\n      r"ZopeXMLConfigurationError"),\n     (re.compile(r"builtins\\.PopulatedZODB"), r"PopulatedZODB"),\n     (re.compile(r"builtins\\.ExpandedZODB"), r"ExpandedZODB"),\n+    (re.compile(r"urllib\\.error\\.URLError"), r"URLError"),\n ])\n \n \n+class TestZ2(unittest.TestCase):\n+    """Testing plone.testing.z2."""\n+\n+    def test_z2(self):\n+        """It can be imported. (It contains only BBB imports.)"""\n+        import plone.testing.z2\n+        self.assertIsNotNone(plone.testing.z2.ZSERVER)\n+\n+\n def test_suite():\n     suite = unittest.TestSuite()\n     suite.addTests([\n@@ -115,5 +125,7 @@ def test_suite():\n                 setUp=setUp,\n                 tearDown=tearDown,\n                 optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,\n-            )])\n+            ),\n+            unittest.TestLoader().loadTestsFromTestCase(TestZ2),\n+        ])\n     return suite\ndiff --git a/src/plone/testing/wsgi.rst b/src/plone/testing/wsgi.rst\nindex d7bbbf1..234788e 100644\n--- a/src/plone/testing/wsgi.rst\n+++ b/src/plone/testing/wsgi.rst\n@@ -373,24 +373,23 @@ It is usually best to let Zope errors be shown with full tracebacks:::\n We can add to the test fixture in the test.\n For those changes to be visible to the test browser, however, we need to commit the transaction.::\n \n-    >>> app.manage_addFolder(\'folder1\')\n+    >>> _ = app.manage_addDTMLDocument(\'dtml-doc-1\')\n     >>> import transaction; transaction.commit()\n \n We can now view this via the test browser:::\n \n-    >>> browser.open(app.absolute_url() + \'/folder1\')\n-\n-    >>> \'folder1\' in browser.contents\n+    >>> browser.open(app.absolute_url() + \'/dtml-doc-1\')\n+    >>> \'This is the dtml-doc-1 Document.\' in browser.contents\n     True\n \n The test browser integration converts the URL into a request and passes control to Zope\'s publisher.\n Let\'s check that query strings are available for input processing:::\n \n-    >>> import urllib\n-    >>> qs = urllib.urlencode({\'foo\': \'boo, bar & baz\'})  # sic: the ampersand.\n-    >>> _ = app[\'folder1\'].addDTMLMethod(\'index_html\', file=\'<dtml-var foo>\')\n+    >>> from six.moves.urllib.parse import urlencode\n+    >>> _ = app.manage_addDTMLDocument(\'dtml-doc-2\', file=\'<dtml-var foo>\')\n     >>> import transaction; transaction.commit()\n-    >>> browser.open(app.absolute_url() + \'/folder1?\' + qs)\n+    >>> qs = urlencode({\'foo\': \'boo, bar & baz\'})  # sic: the ampersand.\n+    >>> browser.open(app.absolute_url() + \'/dtml-doc-2?\' + qs)\n     >>> browser.contents\n     \'boo, bar & baz\'\n \n@@ -485,7 +484,7 @@ create some content or change a setting) and then use the HTTP protocol to look\n Bear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``wsgi.login()`` and ``wsgi.logout()``, for instance, do not affect the server thread.::\n \n     >>> app = wsgi.WSGI_SERVER[\'app\'] # would normally be self.layer[\'app\']\n-    >>> app.manage_addFolder(\'folder1\')\n+    >>> _ = app.manage_addDTMLDocument(\'dtml-doc-3\')\n \n Note that we need to commit the transaction before it will show up in the other thread.::\n \n@@ -497,10 +496,10 @@ We can now look for this new object through the server.::\n     >>> app_url.split(\':\')[:-1]\n     [\'http\', \'//localhost\']\n \n-    >>> import urllib2\n-    >>> conn = urllib2.urlopen(app_url + \'/folder1\', timeout=5)\n-    >>> print conn.read()\n-    <Folder at folder1>\n+    >>> from six.moves.urllib.request import urlopen\n+    >>> conn = urlopen(app_url + \'/dtml-doc-3\', timeout=5)\n+    >>> b\'This is the dtml-doc-3 Document.\' in conn.read()\n+    True\n     >>> conn.close()\n \n Test tear-down does nothing beyond what the base layers do.::\n@@ -527,7 +526,7 @@ When the server is torn down, the WSGIServer thread is stopped.::\n     Tear down plone.testing.wsgi.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n-    >>> conn = urllib2.urlopen(app_url + \'/folder1\', timeout=5)\n+    >>> conn = urlopen(app_url + \'/folder1\', timeout=5)\n     Traceback (most recent call last):\n     ...\n     URLError: <urlopen error [Errno ...] Connection refused>\ndiff --git a/tox.ini b/tox.ini\nindex 7b626bf..1689e08 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -1,6 +1,7 @@\n [tox]\n envlist = py27,\n-          py27-zserver\n+          py27-zserver,\n+          py36,\n           coverage-report\n minversion = 1.9\n \n@@ -31,4 +32,4 @@ commands =\n     coverage combine\n     coverage html -i\n     coverage xml -i\n-    coverage report -i\n+    coverage report -i --fail-under=86\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/14315a0a200be04b9ed9e9bd486aefe805010481

Fix changes.
[skip ci]

Files changed:
M CHANGES.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 2d0396c..e9630e6 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -19,6 +19,7 @@ New features:\n - Make ``ZServer`` an optional dependency.\n \n - Add support for Python 3.6.\n+  [rudaporto, icemac]\n \n Bug fixes:\n \n@@ -37,11 +38,6 @@ Bug fixes:\n \n - No longer use deprecated import for getSite/setSite.\n   [jensens]\n-- Fix most doctests for python 3.\n-  [rudaporto]\n-\n-- Python 2 / 3 compatible imports.\n-  [rudaporto]\n \n - Update code to follow Plone styleguide.\n   [gforcada]\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/87aee702366d1d3e08d3515178aa93c524eb14c1

Rename `plone.testing.wsgi` to `plone.testing.zope`.

This shows more clearly the purpose of the module.

Files changed:
A src/plone/testing/zope.py
A src/plone/testing/zope.rst
M setup.py
M src/plone/testing/_z2_testbrowser.py
M src/plone/testing/publisher.py
M src/plone/testing/security.py
M src/plone/testing/tests.py
M src/plone/testing/z2.py
M src/plone/testing/zca.py
M src/plone/testing/zserver.py
D src/plone/testing/wsgi.py
D src/plone/testing/wsgi.rst

b'diff --git a/setup.py b/setup.py\nindex edf3fec..84a2303 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -42,7 +42,7 @@\n         open(os.path.join("src", "plone", "testing", "security.rst")).read(),\n         open(os.path.join("src", "plone", "testing", "publisher.rst")).read(),\n         open(os.path.join("src", "plone", "testing", "zodb.rst")).read(),\n-        open(os.path.join("src", "plone", "testing", "wsgi.rst")).read(),\n+        open(os.path.join("src", "plone", "testing", "zope.rst")).read(),\n         open(os.path.join("src", "plone", "testing", "zserver.rst")).read(),\n     ])),\n     classifiers=[\ndiff --git a/src/plone/testing/_z2_testbrowser.py b/src/plone/testing/_z2_testbrowser.py\nindex 31aa093..7fa7c9a 100644\n--- a/src/plone/testing/_z2_testbrowser.py\n+++ b/src/plone/testing/_z2_testbrowser.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from __future__ import absolute_import\n from zope.testbrowser import browser\n from ZPublisher.httpexceptions import HTTPExceptionHandler\n from ZPublisher.WSGIPublisher import publish_module\ndiff --git a/src/plone/testing/publisher.py b/src/plone/testing/publisher.py\nindex f3d03c1..eb1ca4d 100644\n--- a/src/plone/testing/publisher.py\n+++ b/src/plone/testing/publisher.py\n@@ -1,6 +1,7 @@\n # -*- coding: utf-8 -*-\n """Helpers for working with common Zope publisher operations\n """\n+from __future__ import absolute_import\n from plone.testing import Layer\n from plone.testing import security\n from plone.testing import zca\ndiff --git a/src/plone/testing/security.py b/src/plone/testing/security.py\nindex a435d41..be95caf 100644\n--- a/src/plone/testing/security.py\n+++ b/src/plone/testing/security.py\n@@ -1,6 +1,7 @@\n # -*- coding: utf-8 -*-\n """Security helpers and layers\n """\n+from __future__ import absolute_import\n from plone.testing import Layer\n \n \ndiff --git a/src/plone/testing/tests.py b/src/plone/testing/tests.py\nindex f2d0640..3f4584f 100644\n--- a/src/plone/testing/tests.py\n+++ b/src/plone/testing/tests.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from __future__ import absolute_import\n from OFS.SimpleItem import SimpleItem\n from pkg_resources import get_distribution\n from ZPublisher.Iterators import filestream_iterator\n@@ -52,7 +53,7 @@ class DummyFile(SimpleItem):\n \n     def __call__(self):\n         path = get_distribution(\'plone.testing\').location\n-        path = os.path.join(path, \'plone\', \'testing\', \'wsgi.rst\')\n+        path = os.path.join(path, \'plone\', \'testing\', \'zope.rst\')\n \n         request = self.REQUEST\n         response = request.response\n@@ -104,7 +105,7 @@ def test_suite():\n             \'security.rst\',\n             \'publisher.rst\',\n             \'zodb.rst\',\n-            \'wsgi.rst\',\n+            \'zope.rst\',\n             checker=checker,\n             setUp=setUp,\n             tearDown=tearDown,\ndiff --git a/src/plone/testing/z2.py b/src/plone/testing/z2.py\nindex 3423074..0cc7c42 100644\n--- a/src/plone/testing/z2.py\n+++ b/src/plone/testing/z2.py\n@@ -1,32 +1,33 @@\n # -*- coding: utf-8 -*-\n+from __future__ import absolute_import\n from zope.deferredimport import deprecated\n \n import plone.testing\n-import plone.testing.wsgi\n+import plone.testing.zope\n import warnings\n \n \n deprecated(\n-    \'Please import from plone.testing.wsgi.\',\n-    Browser=\'plone.testing.wsgi:Browser\',\n-    TestIsolationBroken=\'plone.testing.wsgi:TestIsolationBroken\',\n-    installProduct=\'plone.testing.wsgi:installProduct\',\n-    uninstallProduct=\'plone.testing.wsgi:uninstallProduct\',\n-    login=\'plone.testing.wsgi:login\',\n-    logout=\'plone.testing.wsgi:logout\',\n-    setRoles=\'plone.testing.wsgi:setRoles\',\n-    makeTestRequest=\'plone.testing.wsgi:makeTestRequest\',\n-    addRequestContainer=\'plone.testing.wsgi:addRequestContainer\',\n-    zopeApp=\'plone.testing.wsgi:zopeApp\',\n-    Startup=\'plone.testing.wsgi:Startup\',\n-    STARTUP=\'plone.testing.wsgi:STARTUP\',\n-    IntegrationTesting=\'plone.testing.wsgi:IntegrationTesting\',\n-    INTEGRATION_TESTING=\'plone.testing.wsgi:INTEGRATION_TESTING\',\n-    FunctionalTesting=\'plone.testing.wsgi:FunctionalTesting\',\n-    FUNCTIONAL_TESTING=\'plone.testing.wsgi:FUNCTIONAL_TESTING\',\n-    ZServer=\'plone.testing.wsgi:WSGIServer\',\n-    ZSERVER_FIXTURE=\'plone.testing.wsgi:WSGI_SERVER_FIXTURE\',\n-    ZSERVER=\'plone.testing.wsgi:WSGI_SERVER\',\n+    \'Please import from plone.testing.zope.\',\n+    Browser=\'plone.testing.zope:Browser\',\n+    TestIsolationBroken=\'plone.testing.zope:TestIsolationBroken\',\n+    installProduct=\'plone.testing.zope:installProduct\',\n+    uninstallProduct=\'plone.testing.zope:uninstallProduct\',\n+    login=\'plone.testing.zope:login\',\n+    logout=\'plone.testing.zope:logout\',\n+    setRoles=\'plone.testing.zope:setRoles\',\n+    makeTestRequest=\'plone.testing.zope:makeTestRequest\',\n+    addRequestContainer=\'plone.testing.zope:addRequestContainer\',\n+    zopeApp=\'plone.testing.zope:zopeApp\',\n+    Startup=\'plone.testing.zope:Startup\',\n+    STARTUP=\'plone.testing.zope:STARTUP\',\n+    IntegrationTesting=\'plone.testing.zope:IntegrationTesting\',\n+    INTEGRATION_TESTING=\'plone.testing.zope:INTEGRATION_TESTING\',\n+    FunctionalTesting=\'plone.testing.zope:FunctionalTesting\',\n+    FUNCTIONAL_TESTING=\'plone.testing.zope:FUNCTIONAL_TESTING\',\n+    ZServer=\'plone.testing.zope:WSGIServer\',\n+    ZSERVER_FIXTURE=\'plone.testing.zope:WSGI_SERVER_FIXTURE\',\n+    ZSERVER=\'plone.testing.zope:WSGI_SERVER\',\n )\n \n \n@@ -48,7 +49,7 @@ def setUp(self):\n \n FTP_SERVER_FIXTURE = FTPServer()\n \n-FTP_SERVER = plone.testing.wsgi.FunctionalTesting(\n+FTP_SERVER = plone.testing.zope.FunctionalTesting(\n     bases=(\n         FTP_SERVER_FIXTURE,\n     ),\ndiff --git a/src/plone/testing/zca.py b/src/plone/testing/zca.py\nindex f0ff0c4..8bf10c3 100644\n--- a/src/plone/testing/zca.py\n+++ b/src/plone/testing/zca.py\n@@ -1,6 +1,7 @@\n # -*- coding: utf-8 -*-\n """Core Zope Component Architecture helpers and layers\n """\n+from __future__ import absolute_import\n from plone.testing import Layer\n from zope.configuration.config import ConfigurationMachine\n \ndiff --git a/src/plone/testing/wsgi.py b/src/plone/testing/zope.py\nsimilarity index 99%\nrename from src/plone/testing/wsgi.py\nrename to src/plone/testing/zope.py\nindex 78678b3..0475e67 100644\n--- a/src/plone/testing/wsgi.py\n+++ b/src/plone/testing/zope.py\n@@ -1,6 +1,7 @@\n # -*- coding: utf-8 -*-\n """Zope-specific helpers and layers using WSGI\n """\n+from __future__ import absolute_import\n from OFS.metaconfigure import get_packages_to_initialize\n from plone.testing import Layer\n from plone.testing import zca\ndiff --git a/src/plone/testing/wsgi.rst b/src/plone/testing/zope.rst\nsimilarity index 73%\nrename from src/plone/testing/wsgi.rst\nrename to src/plone/testing/zope.rst\nindex 234788e..15f41b5 100644\n--- a/src/plone/testing/wsgi.rst\n+++ b/src/plone/testing/zope.rst\n@@ -1,9 +1,9 @@\n Zope WSGI layers\n--------------\n+----------------\n \n-The Zope WSGI layers are found in the module ``plone.testing.wsgi``:::\n+The Zope WSGI layers are found in the module ``plone.testing.zope``:::\n \n-    >>> from plone.testing import wsgi\n+    >>> from plone.testing import zope\n \n For testing, we need a testrunner:::\n \n@@ -19,10 +19,10 @@ It extends the ``zca.LAYER_CLEANUP`` layer to maximise the chances of having and\n **Note**: You should probably use at least ``INTEGRATION_TESTING`` for any real test, although ``STARTUP`` is a useful base layer if you are setting up your own fixture.\n See the description of ``INTEGRATION_TESTING`` below.::\n \n-    >>> "%s.%s" % (wsgi.STARTUP.__module__, wsgi.STARTUP.__name__,)\n-    \'plone.testing.wsgi.Startup\'\n+    >>> "%s.%s" % (zope.STARTUP.__module__, zope.STARTUP.__name__,)\n+    \'plone.testing.zope.Startup\'\n \n-    >>> wsgi.STARTUP.__bases__\n+    >>> zope.STARTUP.__bases__\n     (<Layer \'plone.testing.zca.LayerCleanup\'>,)\n \n On layer setup, Zope is initialised in a lightweight manner.\n@@ -43,45 +43,45 @@ Five sets a special vocabulary registry upon the layer setup, but there\'s a defa\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, wsgi.STARTUP, setupLayers)\n+    >>> runner.setup_layer(options, zope.STARTUP, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.wsgi.Startup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n \n After layer setup, the ``zodbDB`` resource is available, pointing to the default ZODB.::\n \n-    >>> wsgi.STARTUP[\'zodbDB\']\n+    >>> zope.STARTUP[\'zodbDB\']\n     <ZODB.DB.DB object at ...>\n \n-    >>> wsgi.STARTUP[\'zodbDB\'].storage\n+    >>> zope.STARTUP[\'zodbDB\'].storage\n     Startup\n \n In addition, the resources ``host`` and ``port`` are set to the default hostname and port that are used for URLs generated from Zope.\n These are hardcoded, but shadowed by layers that provide actual running Zope instances.::\n \n-    >>> wsgi.STARTUP[\'host\']\n+    >>> zope.STARTUP[\'host\']\n     \'nohost\'\n-    >>> wsgi.STARTUP[\'port\']\n+    >>> zope.STARTUP[\'port\']\n     80\n \n At this point, it is also possible to get hold of a Zope application root.\n If you are setting up a layer fixture, you can obtain an application root with the correct database that is properly closed by using the ``zopeApp()`` context manager.::\n \n-    >>> with wsgi.zopeApp() as app:\n+    >>> with zope.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds()\n     True\n \n If you want to use a specific database, you can pass that to ``zopeApp()`` as the ``db`` parameter.\n A new connection will be opened and closed.::\n \n-    >>> with wsgi.zopeApp(db=wsgi.STARTUP[\'zodbDB\']) as app:\n+    >>> with zope.zopeApp(db=zope.STARTUP[\'zodbDB\']) as app:\n     ...     \'acl_users\' in app.objectIds()\n     True\n \n If you want to re-use an existing connection, you can pass one to ``zopeApp()`` as the ``connection`` argument.\n In this case, you will need to close the connection yourself.::\n \n-    >>> conn = wsgi.STARTUP[\'zodbDB\'].open()\n-    >>> with wsgi.zopeApp(connection=conn) as app:\n+    >>> conn = zope.STARTUP[\'zodbDB\'].open()\n+    >>> with zope.zopeApp(connection=conn) as app:\n     ...     \'acl_users\' in app.objectIds()\n     True\n \n@@ -92,7 +92,7 @@ In this case, you will need to close the connection yourself.::\n \n If an exception is raised within the ``with`` block, the transaction is aborted, but the connection is still closed (if it was opened by the context manager):::\n \n-    >>> with wsgi.zopeApp() as app:\n+    >>> with zope.zopeApp() as app:\n     ...     raise Exception("Test error")\n     Traceback (most recent call last):\n     ...\n@@ -101,14 +101,14 @@ If an exception is raised within the ``with`` block, the transaction is aborted,\n It is common to combine the ``zopeApp()`` context manager with a stacked ``DemoStorage`` to set up a layer-specific fixture.\n As a sketch:::\n \n-    from plone.testing import Layer, wsgi, zodb\n+    from plone.testing import Layer, zope, zodb\n \n     class MyLayer(Layer):\n-        defaultBases = (wsgi.STARTUP,)\n+        defaultBases = (zope.STARTUP,)\n \n         def setUp(self):\n             self[\'zodbDB\'] = zodb.stackDemoStorage(self.get(\'zodbDB\'), name=\'MyLayer\')\n-            with wsgi.zopeApp() as app:\n+            with zope.zopeApp() as app:\n \n                 # Set up a fixture, e.g.:\n                 app.manage_addFolder(\'folder1\')\n@@ -124,7 +124,7 @@ As a sketch:::\n             self[\'zodbDB\'].close()\n             del self[\'zodbDB\']\n \n-Note that you would normally *not* use the ``wsgi.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.\n+Note that you would normally *not* use the ``zope.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.\n The ``IntegrationTesting`` and ``FunctionalTesting`` layer classes manage the application object for you, exposing them as the resource ``app`` (see below).\n \n After layer setup, the global component registry contains a number of components needed by Zope.::\n@@ -139,7 +139,7 @@ And Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:::\n \n To load additional ZCML, you can use the ``configurationContext`` resource:::\n \n-    >>> wsgi.STARTUP[\'configurationContext\']\n+    >>> zope.STARTUP[\'configurationContext\']\n     <zope.configuration.config.ConfigurationMachine object ...>\n \n See ``zca.rst`` for details about how to use ``zope.configuration`` for this purpose.\n@@ -147,13 +147,13 @@ See ``zca.rst`` for details about how to use ``zope.configuration`` for this pur\n The ``STARTUP`` layer does not perform any specific test setup or tear-down.\n That is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING`` layers, or other layers using their layer classes - ``IntegrationTesting`` and ``FunctionalTesting``.::\n \n-    >>> wsgi.STARTUP.testSetUp()\n-    >>> wsgi.STARTUP.testTearDown()\n+    >>> zope.STARTUP.testSetUp()\n+    >>> zope.STARTUP.testTearDown()\n \n Layer tear-down resets the environment.::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.wsgi.Startup in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n     >>> import Zope2\n@@ -187,45 +187,45 @@ In a test, you should use this instead of the ``zopeApp`` context manager (which\n \n ``request`` is a test request. It is the same as ``app.REQUEST``.::\n \n-    >>> "%s.%s" % (wsgi.INTEGRATION_TESTING.__module__, wsgi.INTEGRATION_TESTING.__name__,)\n-    \'plone.testing.wsgi.IntegrationTesting\'\n+    >>> "%s.%s" % (zope.INTEGRATION_TESTING.__module__, zope.INTEGRATION_TESTING.__name__,)\n+    \'plone.testing.zope.IntegrationTesting\'\n \n-    >>> wsgi.INTEGRATION_TESTING.__bases__\n-    (<Layer \'plone.testing.wsgi.Startup\'>,)\n+    >>> zope.INTEGRATION_TESTING.__bases__\n+    (<Layer \'plone.testing.zope.Startup\'>,)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, wsgi.INTEGRATION_TESTING, setupLayers)\n+    >>> runner.setup_layer(options, zope.INTEGRATION_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.wsgi.Startup in ... seconds.\n-    Set up plone.testing.wsgi.IntegrationTesting in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n+    Set up plone.testing.zope.IntegrationTesting in ... seconds.\n \n Let\'s now simulate a test.\n On test setup, the ``app`` resource is made available.\n In a test, you should always use this to access the application root.::\n \n-    >>> wsgi.STARTUP.testSetUp()\n-    >>> wsgi.INTEGRATION_TESTING.testSetUp()\n+    >>> zope.STARTUP.testSetUp()\n+    >>> zope.INTEGRATION_TESTING.testSetUp()\n \n The test may now inspect and modify the environment.::\n \n-    >>> app = wsgi.INTEGRATION_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app = zope.INTEGRATION_TESTING[\'app\'] # would normally be self.layer[\'app\']\n     >>> app.manage_addFolder(\'folder1\')\n     >>> \'acl_users\' in app.objectIds() and \'folder1\' in app.objectIds()\n     True\n \n The request is also available:::\n \n-    >>> wsgi.INTEGRATION_TESTING[\'request\'] # would normally be self.layer[\'request\']\n+    >>> zope.INTEGRATION_TESTING[\'request\'] # would normally be self.layer[\'request\']\n     <HTTPRequest, URL=http://nohost>\n \n-We can create a user and simulate logging in as that user, using the ``wsgi.login()`` helper:::\n+We can create a user and simulate logging in as that user, using the ``zope.login()`` helper:::\n \n     >>> app._addRole(\'role1\')\n     >>> ignore = app[\'acl_users\'].userFolderAddUser(\'user1\', \'secret\', [\'role1\'], [])\n-    >>> wsgi.login(app[\'acl_users\'], \'user1\')\n+    >>> zope.login(app[\'acl_users\'], \'user1\')\n \n-The first argument to ``wsgi.login()`` is the user folder that contains the relevant user.\n+The first argument to ``zope.login()`` is the user folder that contains the relevant user.\n The second argument is the user\'s name.\n There is no need to give the password.::\n \n@@ -233,33 +233,33 @@ There is no need to give the password.::\n     >>> getSecurityManager().getUser()\n     <User \'user1\'>\n \n-You can change the roles of a user using the ``wsgi.setRoles()`` helper:::\n+You can change the roles of a user using the ``zope.setRoles()`` helper:::\n \n     >>> sorted(getSecurityManager().getUser().getRolesInContext(app))\n     [\'Authenticated\', \'role1\']\n \n-    >>> wsgi.setRoles(app[\'acl_users\'], \'user1\', [])\n+    >>> zope.setRoles(app[\'acl_users\'], \'user1\', [])\n     >>> getSecurityManager().getUser().getRolesInContext(app)\n     [\'Authenticated\']\n \n-To become the anonymous user again, use ``wsgi.logout()``:::\n+To become the anonymous user again, use ``zope.logout()``:::\n \n-    >>> wsgi.logout()\n+    >>> zope.logout()\n     >>> getSecurityManager().getUser()\n     <SpecialUser \'Anonymous User\'>\n \n On tear-down, the transaction is rolled back:::\n \n-    >>> wsgi.INTEGRATION_TESTING.testTearDown()\n-    >>> wsgi.STARTUP.testTearDown()\n+    >>> zope.INTEGRATION_TESTING.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n \n-    >>> \'app\' in wsgi.INTEGRATION_TESTING\n+    >>> \'app\' in zope.INTEGRATION_TESTING\n     False\n \n-    >>> \'request\' in wsgi.INTEGRATION_TESTING\n+    >>> \'request\' in zope.INTEGRATION_TESTING\n     False\n \n-    >>> with wsgi.zopeApp() as app:\n+    >>> with zope.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n     True\n \n@@ -267,8 +267,8 @@ On tear-down, the transaction is rolled back:::\n Let\'s tear down the layers:::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.wsgi.IntegrationTesting in ... seconds.\n-    Tear down plone.testing.wsgi.Startup in ... seconds.\n+    Tear down plone.testing.zope.IntegrationTesting in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n Functional testing\n@@ -287,31 +287,31 @@ See the ``plone.testing`` ``README`` file for an example.\n \n Like ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.::\n \n-    >>> "%s.%s" % (wsgi.FUNCTIONAL_TESTING.__module__, wsgi.FUNCTIONAL_TESTING.__name__,)\n-    \'plone.testing.wsgi.FunctionalTesting\'\n+    >>> "%s.%s" % (zope.FUNCTIONAL_TESTING.__module__, zope.FUNCTIONAL_TESTING.__name__,)\n+    \'plone.testing.zope.FunctionalTesting\'\n \n-    >>> wsgi.FUNCTIONAL_TESTING.__bases__\n-    (<Layer \'plone.testing.wsgi.Startup\'>,)\n+    >>> zope.FUNCTIONAL_TESTING.__bases__\n+    (<Layer \'plone.testing.zope.Startup\'>,)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, wsgi.FUNCTIONAL_TESTING, setupLayers)\n+    >>> runner.setup_layer(options, zope.FUNCTIONAL_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.wsgi.Startup in ... seconds.\n-    Set up plone.testing.wsgi.FunctionalTesting in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n+    Set up plone.testing.zope.FunctionalTesting in ... seconds.\n \n Let\'s now simulate a test.\n On test setup, the ``app`` resource is made available.\n In a test, you should always use this to access the application root.\n The ``request`` resource can be used to access the test request.::\n \n-    >>> wsgi.STARTUP.testSetUp()\n-    >>> wsgi.FUNCTIONAL_TESTING.testSetUp()\n+    >>> zope.STARTUP.testSetUp()\n+    >>> zope.FUNCTIONAL_TESTING.testSetUp()\n \n The test may now inspect and modify the environment.\n It may also commit things.::\n \n-    >>> app = wsgi.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app = zope.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n     >>> app.manage_addFolder(\'folder1\')\n     >>> \'acl_users\' in app.objectIds() and \'folder1\' in app.objectIds()\n     True\n@@ -321,24 +321,24 @@ It may also commit things.::\n \n On tear-down, the database is torn down.::\n \n-    >>> wsgi.FUNCTIONAL_TESTING.testTearDown()\n-    >>> wsgi.STARTUP.testTearDown()\n+    >>> zope.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n \n-    >>> \'app\' in wsgi.FUNCTIONAL_TESTING\n+    >>> \'app\' in zope.FUNCTIONAL_TESTING\n     False\n \n-    >>> \'request\' in wsgi.FUNCTIONAL_TESTING\n+    >>> \'request\' in zope.FUNCTIONAL_TESTING\n     False\n \n-    >>> with wsgi.zopeApp() as app:\n+    >>> with zope.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n     True\n \n Let\'s tear down the layer:::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.wsgi.FunctionalTesting in ... seconds.\n-    Tear down plone.testing.wsgi.Startup in ... seconds.\n+    Tear down plone.testing.zope.FunctionalTesting in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n The test browser\n@@ -351,20 +351,20 @@ To use the test browser with a ``FunctionalTesting`` layer (such as the default\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, wsgi.FUNCTIONAL_TESTING, setupLayers)\n+    >>> runner.setup_layer(options, zope.FUNCTIONAL_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.wsgi.Startup in ... seconds.\n-    Set up plone.testing.wsgi.FunctionalTesting in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n+    Set up plone.testing.zope.FunctionalTesting in ... seconds.\n \n Let\'s simulate a test:::\n \n-    >>> wsgi.STARTUP.testSetUp()\n-    >>> wsgi.FUNCTIONAL_TESTING.testSetUp()\n+    >>> zope.STARTUP.testSetUp()\n+    >>> zope.FUNCTIONAL_TESTING.testSetUp()\n \n In the test, we can create a test browser client like so:::\n \n-    >>> app = wsgi.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n-    >>> browser = wsgi.Browser(app)\n+    >>> app = zope.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> browser = zope.Browser(app)\n \n It is usually best to let Zope errors be shown with full tracebacks:::\n \n@@ -410,16 +410,16 @@ See the ``zope.testbrowser`` documentation for more information about how to use\n \n On tear-down, the database is torn down.::\n \n-    >>> wsgi.FUNCTIONAL_TESTING.testTearDown()\n-    >>> wsgi.STARTUP.testTearDown()\n+    >>> zope.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n \n-    >>> \'app\' in wsgi.FUNCTIONAL_TESTING\n+    >>> \'app\' in zope.FUNCTIONAL_TESTING\n     False\n \n-    >>> \'request\' in wsgi.FUNCTIONAL_TESTING\n+    >>> \'request\' in zope.FUNCTIONAL_TESTING\n     False\n \n-    >>> with wsgi.zopeApp() as app:\n+    >>> with zope.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds()\\\n     ...         and \'folder1\' not in app.objectIds()\\\n     ...         and \'file1\' not in app.objectIds()\n@@ -428,8 +428,8 @@ On tear-down, the database is torn down.::\n Let\'s tear down the layer:::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.wsgi.FunctionalTesting in ... seconds.\n-    Tear down plone.testing.wsgi.Startup in ... seconds.\n+    Tear down plone.testing.zope.FunctionalTesting in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n HTTP server\n@@ -440,34 +440,34 @@ This makes it possible to connect to the test instance using a web browser or a\n \n The ``WSGI_SERVER`` layer provides a ``FunctionalTesting`` layer that has ``WSGI_SERVER_FIXTURE`` as its base.::\n \n-    >>> "%s.%s" % (wsgi.WSGI_SERVER_FIXTURE.__module__, wsgi.WSGI_SERVER_FIXTURE.__name__,)\n-    \'plone.testing.wsgi.WSGIServer\'\n+    >>> "%s.%s" % (zope.WSGI_SERVER_FIXTURE.__module__, zope.WSGI_SERVER_FIXTURE.__name__,)\n+    \'plone.testing.zope.WSGIServer\'\n \n-    >>> wsgi.WSGI_SERVER_FIXTURE.__bases__\n-    (<Layer \'plone.testing.wsgi.Startup\'>,)\n+    >>> zope.WSGI_SERVER_FIXTURE.__bases__\n+    (<Layer \'plone.testing.zope.Startup\'>,)\n \n \n-    >>> "%s.%s" % (wsgi.WSGI_SERVER.__module__, wsgi.WSGI_SERVER.__name__,)\n-    \'plone.testing.wsgi.WSGIServer:Functional\'\n+    >>> "%s.%s" % (zope.WSGI_SERVER.__module__, zope.WSGI_SERVER.__name__,)\n+    \'plone.testing.zope.WSGIServer:Functional\'\n \n-    >>> wsgi.WSGI_SERVER.__bases__\n-    (<Layer \'plone.testing.wsgi.WSGIServer\'>,)\n+    >>> zope.WSGI_SERVER.__bases__\n+    (<Layer \'plone.testing.zope.WSGIServer\'>,)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, wsgi.WSGI_SERVER, setupLayers)\n+    >>> runner.setup_layer(options, zope.WSGI_SERVER, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.wsgi.Startup in ... seconds.\n-    Set up plone.testing.wsgi.WSGIServer in ... seconds.\n-    Set up plone.testing.wsgi.WSGIServer:Functional in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n+    Set up plone.testing.zope.WSGIServer in ... seconds.\n+    Set up plone.testing.zope.WSGIServer:Functional in ... seconds.\n \n After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n \n-    >>> host = wsgi.WSGI_SERVER[\'host\']\n+    >>> host = zope.WSGI_SERVER[\'host\']\n     >>> host\n     \'localhost\'\n \n-    >>> port = wsgi.WSGI_SERVER[\'port\']\n+    >>> port = zope.WSGI_SERVER[\'port\']\n     >>> import os\n     >>> port == int(os.environ.get(\'WSGI_SERVER_PORT\', 55001))\n     True\n@@ -475,15 +475,15 @@ After layer setup, the resources ``host`` and ``port`` are available, and indica\n Let\'s now simulate a test.\n Test setup does nothing beyond what the base layers do.::\n \n-    >>> wsgi.STARTUP.testSetUp()\n-    >>> wsgi.FUNCTIONAL_TESTING.testSetUp()\n-    >>> wsgi.WSGI_SERVER.testSetUp()\n+    >>> zope.STARTUP.testSetUp()\n+    >>> zope.FUNCTIONAL_TESTING.testSetUp()\n+    >>> zope.WSGI_SERVER.testSetUp()\n \n It is common in a test to use the Python API to change the state of the server (e.g.\n create some content or change a setting) and then use the HTTP protocol to look at the results.\n-Bear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``wsgi.login()`` and ``wsgi.logout()``, for instance, do not affect the server thread.::\n+Bear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``zope.login()`` and ``zope.logout()``, for instance, do not affect the server thread.::\n \n-    >>> app = wsgi.WSGI_SERVER[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app = zope.WSGI_SERVER[\'app\'] # would normally be self.layer[\'app\']\n     >>> _ = app.manage_addDTMLDocument(\'dtml-doc-3\')\n \n Note that we need to commit the transaction before it will show up in the other thread.::\n@@ -504,26 +504,26 @@ We can now look for this new object through the server.::\n \n Test tear-down does nothing beyond what the base layers do.::\n \n-    >>> wsgi.WSGI_SERVER.testTearDown()\n-    >>> wsgi.FUNCTIONAL_TESTING.testTearDown()\n-    >>> wsgi.STARTUP.testTearDown()\n+    >>> zope.WSGI_SERVER.testTearDown()\n+    >>> zope.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n \n-    >>> \'app\' in wsgi.WSGI_SERVER\n+    >>> \'app\' in zope.WSGI_SERVER\n     False\n \n-    >>> \'request\' in wsgi.WSGI_SERVER\n+    >>> \'request\' in zope.WSGI_SERVER\n     False\n \n-    >>> with wsgi.zopeApp() as app:\n+    >>> with zope.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n     True\n \n When the server is torn down, the WSGIServer thread is stopped.::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.wsgi.WSGIServer:Functional in ... seconds.\n-    Tear down plone.testing.wsgi.WSGIServer in ... seconds.\n-    Tear down plone.testing.wsgi.Startup in ... seconds.\n+    Tear down plone.testing.zope.WSGIServer:Functional in ... seconds.\n+    Tear down plone.testing.zope.WSGIServer in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n     >>> conn = urlopen(app_url + \'/folder1\', timeout=5)\ndiff --git a/src/plone/testing/zserver.py b/src/plone/testing/zserver.py\nindex 4f493a9..55efb62 100644\n--- a/src/plone/testing/zserver.py\n+++ b/src/plone/testing/zserver.py\n@@ -1,13 +1,14 @@\n # -*- coding: utf-8 -*-\n """Zope2-specific helpers and layers using ZServer\n """\n+from __future__ import absolute_import\n from plone.testing import Layer\n-from plone.testing import wsgi\n+from plone.testing.zope import addRequestContainer\n+from plone.testing.zope import login  # noqa\n+from plone.testing.zope import logout  # noqa\n+from plone.testing.zope import setRoles  # noqa\n from plone.testing._z2_testbrowser import Browser  # noqa\n-from plone.testing.wsgi import addRequestContainer\n-from plone.testing.wsgi import login  # noqa\n-from plone.testing.wsgi import logout  # noqa\n-from plone.testing.wsgi import setRoles  # noqa\n+from plone.testing import zope\n \n import contextlib\n import os\n@@ -78,7 +79,7 @@ def zopeApp(db=None, connection=None, environ=None):\n \n # Startup layer - you probably don\'t want to use this one directly\n \n-class Startup(wsgi.Startup):\n+class Startup(zope.Startup):\n     """This layer does what ZopeLite and ZopeTestCase\'s base.TestCase did:\n     start up a minimal Zope instance and manages the application and\n     request state.\n@@ -190,7 +191,7 @@ def tearDownApp(self):\n # Basic integration and functional test and layers. These are the simplest\n # Zope 2 layers that are generally useful\n \n-class IntegrationTesting(wsgi.IntegrationTesting):\n+class IntegrationTesting(zope.IntegrationTesting):\n     """This layer extends ``STARTUP`` to add rollback of the transaction\n     after each test. It does not manage a fixture and has no layer lifecyle,\n     only a test lifecycle.\n@@ -220,7 +221,7 @@ class MyFixture(Layer):\n INTEGRATION_TESTING = IntegrationTesting()\n \n \n-class FunctionalTesting(wsgi.FunctionalTesting):\n+class FunctionalTesting(zope.FunctionalTesting):\n     """An alternative to ``INTEGRATION_TESTING`` suitable for functional testing.\n     This one pushes and pops a ``DemoStorage`` layer for each test. The\n     net result is that a test may commit safely.\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/f34e9d1c0c6b4fe49674ffabd49979832dcedcc2

No longer depend on ZServer for Zope.

Files changed:
M setup.py
M tox.ini

b"diff --git a/setup.py b/setup.py\nindex 84a2303..997e87d 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -28,6 +28,14 @@\n     'Zope',\n ]\n \n+zope_requires = [\n+    'Zope',\n+    'zope.component',\n+    'zope.testbrowser',\n+    'zope.publisher',\n+],\n+\n+\n setup(\n     name='plone.testing',\n     version=version,\n@@ -92,12 +100,10 @@\n             'zope.browserresource',\n             'zope.publisher',\n         ],\n-        'z2': [\n-            'Zope',\n+        'z2': zope_requires,  # BBB\n+        'zope': zope_requires,\n+        'zserver': [\n             'ZServer',\n-            'zope.component',\n-            'zope.testbrowser',\n-            'zope.publisher',\n         ],\n     },\n )\ndiff --git a/tox.ini b/tox.ini\nindex 1689e08..c5870df 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -18,7 +18,7 @@ setenv =\n passenv = WSGI_REQUEST_LOGGING\n \n [testenv:py27-zserver]\n-deps = .[test,z2]\n+deps = .[test,z2,zserver]\n        {[testenv]deps}\n \n [testenv:coverage-report]\n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/daad053bc48b8ec25d2084d0f8597a5b02e0b8be

There is no reason to still depend on ZODB3.

Files changed:
M setup.py

b"diff --git a/setup.py b/setup.py\nindex 997e87d..68ec5ac 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -13,7 +13,7 @@\n ]\n \n tests_require = [\n-    'ZODB3',\n+    'ZODB',\n     'zope.browsermenu',\n     'zope.browserpage',\n     'zope.browserresource',\n@@ -83,7 +83,7 @@\n     tests_require=tests_require,\n     extras_require={\n         'test': tests_require,\n-        'zodb': ['ZODB3'],\n+        'zodb': ['ZODB'],\n         'zca': [\n             'zope.component',\n             'zope.event',\n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/c63ae9b599823c1385aa1156f1303db1505b67e6

Update the documentation.

Files changed:
M CHANGES.rst
M setup.py
M src/plone/testing/README.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex e9630e6..ec06dd2 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -1,18 +1,17 @@\n Changelog\n =========\n \n-6.1 (unreleased)\n+7.0 (unreleased)\n ----------------\n \n Breaking changes:\n \n-- ``plone.testing.z2`` is now a BBB shim for ``plone.testing.wsgi``, thus it\n-  switches the tests to use WSGI. If you absolutely want to keep using ZServer\n-  please import from ``plone.testing.zserver``.\n+- ``plone.testing.z2`` is now a BBB shim for ``plone.testing.zope``,\n+  thus it switches the tests to use WSGI.\n+  If you absolutely want to keep using ZServer please import from ``plone.testing.zserver``.\n \n-- ``plone.testing.z2`` now only contains a no-op FTPServer layer because FTP is\n-  nit supported by WSGI. If you really need it, import it from\n-  ``plone.testing.zserver`` but this will not work on Python 3.\n+- ``plone.testing.z2`` now only contains a no-op FTPServer layer because FTP is not supported by WSGI.\n+  If you really need it, import it from ``plone.testing.zserver`` but this will not work on Python 3.\n \n New features:\n \ndiff --git a/setup.py b/setup.py\nindex 68ec5ac..8410cb9 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,19 +1,19 @@\n # -*- coding: utf-8 -*-\n import os\n import os.path\n-import sys\n from setuptools import setup, find_packages\n \n-version = \'6.1.dev0\'\n+version = \'7.0.dev0\'\n \n install_requires = [\n     \'setuptools\',\n     \'six\',\n-    \'zope.testing\',\n+    \'zope.testing >= 3.8\',\n ]\n \n tests_require = [\n     \'ZODB\',\n+    \'Zope\',\n     \'zope.browsermenu\',\n     \'zope.browserpage\',\n     \'zope.browserresource\',\n@@ -25,14 +25,13 @@\n     \'zope.security\',\n     \'zope.testbrowser\',\n     \'zope.testrunner\',\n-    \'Zope\',\n ]\n \n zope_requires = [\n     \'Zope\',\n     \'zope.component\',\n-    \'zope.testbrowser\',\n     \'zope.publisher\',\n+    \'zope.testbrowser\',\n ],\n \n \n@@ -86,19 +85,19 @@\n         \'zodb\': [\'ZODB\'],\n         \'zca\': [\n             \'zope.component\',\n-            \'zope.event\',\n             \'zope.configuration\',\n+            \'zope.event\',\n         ],\n         \'security\': [\n             \'zope.security\',\n         ],\n         \'publisher\': [\n-            \'zope.configuration\',\n-            \'zope.security\',\n             \'zope.browsermenu\',\n             \'zope.browserpage\',\n             \'zope.browserresource\',\n+            \'zope.configuration\',\n             \'zope.publisher\',\n+            \'zope.security\',\n         ],\n         \'z2\': zope_requires,  # BBB\n         \'zope\': zope_requires,\ndiff --git a/src/plone/testing/README.rst b/src/plone/testing/README.rst\nindex fd2bfd3..565b875 100644\n--- a/src/plone/testing/README.rst\n+++ b/src/plone/testing/README.rst\n@@ -4,7 +4,7 @@ Introduction\n .. contents:: Table of contents\n \n ``plone.testing`` provides tools for writing unit and integration tests in a Zope and Plone environment.\n-It is not tied to Plone, and it does not depend on Zope 2 (although it has some optional Zope 2-only features).\n+It is not tied to Plone, and it does not depend on Zope (although it has some optional Zope-only features).\n \n ``plone.testing`` builds on `zope.testing`_, in particular its layers concept.\n This package also aims to promote some "good practice" for writing tests of various types.\n@@ -26,7 +26,7 @@ The core concepts should be consistent, however.\n Compatibility\n -------------\n \n-``plone.testing`` 6.x has only been tested with Python 2.7.\n+``plone.testing`` 7.x has been tested with Python 2.7 and 3.6.\n If you\'re using the optional Zope layers, you must use Zope version 4 or later.\n Look at older ``plone.testing`` versions for supporting older Zope versions.\n \n@@ -146,7 +146,7 @@ In this example, have listed a single package to test, called ``my.package``, an\n This will install any regular dependencies (listed in the ``install_requires`` option in ``setup.py``), as well as those in the list associated with the ``test`` key in the ``extras_require`` option.\n \n Note that it becomes important to properly list your dependencies here, because the test runner will only be aware of the packages explicitly listed, and their dependencies.\n-For example, if your package depends on Zope 2, you need to list ``Zope2`` in the ``install_requires`` list in ``setup.py``;\n+For example, if your package depends on Zope, you need to list ``Zope`` in the ``install_requires`` list in ``setup.py``;\n ditto for ``Plone``, or indeed any other package you import from.\n \n Once you have re-run buildout, the test runner will be installed as ``bin/test`` (the executable name is taken from the name of the buildout part).\n@@ -208,7 +208,7 @@ The coverage script would otherwise generate coverage information for all execut\n Running the ``bin/report`` script will generate a human readable HTML representation of the run in the `htmlcov` directory.\n Open the contained `index.html` in a browser to see the result.\n \n-If you want to generate an XML representation suitable for the `Cobertura`_ plugin of `Hudson`_, you can add another part::\n+If you want to generate an XML representation suitable for the `Cobertura`_ plugin of `Jenkins`_, you can add another part::\n \n     [buildout]\n     parts =\n@@ -247,7 +247,7 @@ The available extras are:\n \n ``zodb``\n     ZODB testing.\n-    Depends on ``ZODB3``.\n+    Depends on ``ZODB``.\n     The relevant layers and helpers are in the module ``plone.testing.zodb``.\n \n ``zca``\n@@ -265,10 +265,17 @@ The available extras are:\n     Depends on ``zope.publisher``, ``zope.browsermenu``, ``zope.browserpage``, ``zope.browserresource`` and ``zope.security`` and sets up ZCML directives.\n     The relevant layers and helpers are in the module ``plone.testing.publisher``.\n \n-``z2``\n-    Zope 2 testing.\n-    Depends on the ``Zope2`` egg, which includes all the dependencies of the Zope 2 application server.\n-    The relevant layers and helpers are in the module ``plone.testing.z2``\n+``zope`` (For backwards compatibility there is also ``z2``.)\n+\n+    Zope testing.\n+    Depends on the ``Zope`` egg, which includes all the dependencies of the Zope application server.\n+    The relevant layers and helpers are in the module ``plone.testing.zope``.\n+\n+``zserver``\n+\n+    Tests against the ``ZServer``. (Python 2 only!) Requires additionally to use the ``zope`` extra.\n+    The relevant layers and helpers are in the module ``plone.testing.zserver``\n+\n \n Adding a test buildout to your package\n --------------------------------------\n@@ -772,36 +779,11 @@ A few things to note:\n Test suites\n ~~~~~~~~~~~\n \n-If you are using version 3.8.0 or later of `zope.testing`_, a class like the one above is all you need: any class deriving from ``TestCase`` in a module with a name starting with ``test`` will be examined for test methods.\n+A class like the one above is all you need: any class deriving from ``TestCase`` in a module with a name starting with ``test`` will be examined for test methods.\n Those tests are then collected into a test suite and executed.\n \n-With older versions of `zope.testing`_, you need to add a ``test_suite()`` function in each module that returns the tests in the test suite.\n-The `unittest`_ module contains several tools to construct suites, but one of the simplest is to use the default test loader to load all tests in the current module:::\n-\n-    >>> def test_suite():\n-    ...     return unittest.defaultTestLoader.loadTestsFromName(__name__)\n-\n-If you need to load tests explicitly, you can use the ``TestSuite`` API from the `unittest`_ module.\n-For example:::\n-\n-    >>> def test_suite():\n-    ...     suite = unittest.TestSuite()\n-    ...     suite.addTests([\n-    ...         unittest.makeSuite(TestFasterThanLightTravel)\n-    ...     ])\n-    ...     return suite\n-\n-The ``makeSuite()`` function creates a test suite from the test methods in the given class (which must derive from ``TestCase``).\n-This suite is then appended to an overall suite, which is returned from the ``test_suite()`` method.\n-Note that ``addTests()`` takes a list of suites (which are coalesced into a single suite).\n-We\'ll add additional suites later.\n-\n See the `unittest`_ documentation for other options.\n \n-.. note::\n-\n-   Adding a ``test_suite()`` method to a module disables automatic test discovery, even when using a recent version of ``zope.testing``.\n-\n Doctests\n --------\n \n@@ -1161,31 +1143,31 @@ Here, we have loaded two files: ``meta.zcml`` and ``configure.zcml``.\n The first call to ``xmlconfig.file()`` creates and returns a configuration context.\n We re-use that for the subsequent invocation, so that the directives configured are available.\n \n-Installing a Zope 2 product\n----------------------------\n+Installing a Zope product\n+-------------------------\n \n-Some packages (including all those in the ``Products.*`` namespace) have the special status of being Zope 2 "products".\n+Some packages (including all those in the ``Products.*`` namespace) have the special status of being Zope "products".\n These are recorded in a special registry, and may have an ``initialize()`` hook in their top-level ``__init__.py`` that needs to be called for the package to be fully configured.\n \n Zope 2 will find and execute any products during startup.\n For testing, we need to explicitly list the products to install.\n-Provided you are using ``plone.testing`` with Zope 2, you can use the following:::\n+Provided you are using ``plone.testing`` with Zope, you can use the following:::\n \n-    from plone.testing import z2\n+    from plone.testing import zope\n \n-    with z2.zopeApp() as app:\n-        z2.installProduct(app, \'Products.ZCatalog\')\n+    with zope.zopeApp() as app:\n+        zope.installProduct(app, \'Products.ZCatalog\')\n \n This would normally be used during layer ``setUp()``.\n-Note that the basic Zope 2 application context must have been set up before doing this.\n-The usual way to ensure this, is to use a layer that is based on ``z2.STARTUP`` - see below.\n+Note that the basic Zope application context must have been set up before doing this.\n+The usual way to ensure this, is to use a layer that is based on ``zope.STARTUP`` - see below.\n \n To tear down such a layer, you should do:::\n \n-    from plone.testing import z2\n+    from plone.testing import zope\n \n-    with z2.zopeApp() as app:\n-        z2.uninstallProduct(app, \'Products.ZCatalog\')\n+    with zope.zopeApp() as app:\n+        zope.uninstallProduct(app, \'Products.ZCatalog\')\n \n Note:\n \n@@ -1204,20 +1186,20 @@ For functional tests that aim to simulate the browser, you can use `zope.testbro\n     >>> from zope.testbrowser.browser import Browser\n     >>> browser = Browser()\n \n-This provides a simple API to simulate browser input, without actually running a web server thread or scripting a live browser (as tools such as Windmill and Selenium do).\n+This provides a simple API to simulate browser input, without actually running a web server thread or scripting a live browser (as tools such as Selenium_ do).\n The downside is that it is not possible to test JavaScript- dependent behaviour.\n \n-If you are testing a Zope 2 application, you need to change the import location slightly, and pass the application root to the method:::\n+If you are testing a Zope application, you need to change the import location slightly, and pass the application root to the method:::\n \n-    from plone.testing.z2 import Browser\n+    from plone.testing.zope import Browser\n     browser = Browser(app)\n \n-You can get the application root from the ``app`` resource in any of the Zope 2 layers in this package.\n+You can get the application root from the ``app`` resource in any of the Zope layers in this package.\n \n Beyond that, the `zope.testbrowser`_ documentation should cover how to use the test browser.\n \n     **Hint:** The test browser will usually commit at the end of a request.\n-    To avoid test fixture contamination, you should use a layer that fully isolates each test, such as the ``z2.INTEGRATION_TESTING`` layer described below.\n+    To avoid test fixture contamination, you should use a layer that fully isolates each test, such as the ``zope.INTEGRATION_TESTING`` layer described below.\n \n Layer reference\n ===============\n@@ -1550,22 +1532,22 @@ This will shadow the ``zodbDB`` resource with an isolated ``DemoStorage``, creat\n All existing data continues to be available, but new changes are written to the stacked storage.\n On tear-down, the stacked database is closed and the resource removed, leaving the original data.\n \n-Zope 2\n-------\n+Zope\n+----\n \n-The Zope 2 layers provide test fixtures suitable for testing Zope 2 applications.\n-They set up a Zope 2 application root, install core Zope 2 products, and manage security.\n+The Zope layers provide test fixtures suitable for testing Zope applications.\n+They set up a Zope application root, install core Zope products, and manage security.\n \n-Zope 2 layers can be found in the module ``plone.testing.z2``.\n-If you depend on this, you can use the ``[z2]`` extra when depending on ``plone.testing``.\n+Zope layers can be found in the module ``plone.testing.zope``.\n+If you depend on this, you can use the ``[zope]`` extra when depending on ``plone.testing``.\n \n Startup\n ~~~~~~~\n \n +------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.STARTUP``                     |\n+| Layer:     | ``plone.testing.zope.STARTUP``                   |\n +------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.Startup``                     |\n+| Class:     | ``plone.testing.zope.Startup``                   |\n +------------+--------------------------------------------------+\n | Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |\n +------------+--------------------------------------------------+\n@@ -1578,8 +1560,8 @@ Startup\n |            | ``port``                                         |\n +------------+--------------------------------------------------+\n \n-This layer sets up a Zope 2 environment, and is a required base for all other Zope 2 layers.\n-You cannot run two instances of this layer in parallel, since Zope 2 depends on some module-global state to run, which is managed by this layer.\n+This layer sets up a Zope environment, and is a required base for all other Zope layers.\n+You cannot run two instances of this layer in parallel, since Zope depends on some module-global state to run, which is managed by this layer.\n \n On set-up, the layer will configure a Zope environment with:\n \n@@ -1592,9 +1574,9 @@ On set-up, the layer will configure a Zope environment with:\n \n * ZEO client cache disabled.\n \n-* Some patches installed, which speed up Zope startup by disabling the help system and some other superfluous aspects of Zope.\n+* Some patches installed, which speed up Zope startup by disabling some superfluous aspects of Zope.\n \n-* One thread (this only really affects the ``ZSERVER`` and ``FTP_SERVER`` layers).\n+* One thread (this only really affects the ``WSGI_SERVER``, ``ZSERVER`` and ``FTP_SERVER`` layers).\n \n * A pristine database using ``DemoStorage``, exposed as the resource ``zodbDB``.\n   Zope is configured to use this database in a way that will also work if the ``zodbDB`` resource is shadowed using the pattern shown above in the description of the ``zodb.EMPTY_ZODB`` layer.\n@@ -1614,11 +1596,11 @@ Integration test\n ~~~~~~~~~~~~~~~~\n \n +------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.INTEGRATION_TESTING``         |\n+| Layer:     | ``plone.testing.zope.INTEGRATION_TESTING``       |\n +------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.IntegrationTesting``          |\n+| Class:     | ``plone.testing.zope.IntegrationTesting``        |\n +------------+--------------------------------------------------+\n-| Bases:     | ``plone.testing.z2.STARTUP``                     |\n+| Bases:     | ``plone.testing.zope.STARTUP``                   |\n +------------+--------------------------------------------------+\n | Resources: | ``app``                                          |\n |            +--------------------------------------------------+\n@@ -1633,12 +1615,12 @@ This is wrapped in the request container, so you can do ``app.REQUEST`` to acqui\n \n A new transaction is begun for each test and rolled back on test tear-down, meaning that so long as the code under test does not explicitly commit any changes, the test may modify the ZODB.\n \n-    *Hint:* If you want to set up a persistent test fixture in a layer based on this one (or ``z2.FUNCTIONAL_TESTING``), you can stack a new ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern described above for the ``zodb.EMPTY_ZODB`` layer.\n+    *Hint:* If you want to set up a persistent test fixture in a layer based on this one (or ``zope.FUNCTIONAL_TESTING``), you can stack a new ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern described above for the ``zodb.EMPTY_ZODB`` layer.\n \n     Once you\'ve shadowed the ``zodbDB`` resource, you can do (e.g. in your layer\'s ``setUp()`` method)::\n \n         ...\n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n             # modify the Zope application root\n \n     The ``zopeApp()`` context manager will open a new connection to the Zope application root, accessible here as ``app``.\n@@ -1648,11 +1630,11 @@ Functional testing\n ~~~~~~~~~~~~~~~~~~\n \n +------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.FUNCTIONAL_TESTING``          |\n+| Layer:     | ``plone.testing.zope.FUNCTIONAL_TESTING``        |\n +------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.FunctionalTesting``           |\n+| Class:     | ``plone.testing.zope.FunctionalTesting``         |\n +------------+--------------------------------------------------+\n-| Bases:     | ``plone.testing.z2.STARTUP``                     |\n+| Bases:     | ``plone.testing.zope.STARTUP``                   |\n +------------+--------------------------------------------------+\n | Resources: | ``app``                                          |\n |            +--------------------------------------------------+\n@@ -1675,9 +1657,9 @@ Integration and functional testing with custom fixtures\n \n If you want to extend the ``STARTUP`` fixture for use with integration or functional testing, you should use the following pattern:\n \n-* Create a layer class and a "fixture" base layer instance that has ``z2.STARTUP`` (or some intermediary layer, such as ``z2.ZSERVER_FIXTURE`` or ``z2.FTP_SERVER_FIXTURE``, shown below) as a base.\n+* Create a layer class and a "fixture" base layer instance that has ``zope.STARTUP`` (or some intermediary layer, such as ``zope.WSGI_SERVER_FIXTURE``, shown below) as a base.\n \n-* Create "end user" layers by instantiating the ``z2.IntegrationTesting`` and/or ``FunctionalTesting`` classes with this new "fixture" layer as a base.\n+* Create "end user" layers by instantiating the ``zope.IntegrationTesting`` and/or ``FunctionalTesting`` classes with this new "fixture" layer as a base.\n \n This allows the same fixture to be used regardless of the "style" of testing, minimising the amount of set-up and tear-down.\n The "fixture" layers manage the fixture as part of the *layer* lifecycle.\n@@ -1685,10 +1667,10 @@ The layer class (``IntegrationTesting`` or ``FunctionalTesting``), manages the *\n \n For example::\n \n-    from plone.testing import Layer, z2, zodb\n+    from plone.testing import Layer, zope, zodb\n \n     class MyLayer(Layer):\n-        defaultBases = (z2.STARTUP,)\n+        defaultBases = (zope.STARTUP,)\n \n         def setUp(self):\n             # Set up the fixture here\n@@ -1700,8 +1682,8 @@ For example::\n \n     MY_FIXTURE = MyLayer()\n \n-    MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name="MyFixture:Integration")\n-    MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name="MyFixture:Functional")\n+    MY_INTEGRATION_TESTING = zope.IntegrationTesting(bases=(MY_FIXTURE,), name="MyFixture:Integration")\n+    MY_FUNCTIONAL_TESTING = zope.FunctionalTesting(bases=(MY_FIXTURE,), name="MyFixture:Functional")\n \n (Note that we need to give an explicit, unique name to the two layers that re-use the ``IntegrationTesting`` and ``FunctionalTesting`` classes.)\n \n@@ -1717,109 +1699,57 @@ However, even if both these two layers were used, the fixture in ``MY_FIXTURE``\n It may be preferable, therefore, to have your own "test lifecycle" layer classes that subclass ``IntegrationTesting`` and/or ``FunctionalTesting`` and call base class methods as appropriate.\n ``plone.app.testing`` takes this approach, for example.\n \n-HTTP ZServer thread (fixture only)\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+HTTP WSGI server thread (fixture only)\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n +------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.ZSERVER_FIXTURE``             |\n+| Layer:     | ``plone.testing.zope.WSGI_SERVER_FIXTURE``       |\n +------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.ZServer``                     |\n+| Class:     | ``plone.testing.zope.WSGIServer``                |\n +------------+--------------------------------------------------+\n-| Bases:     | ``plone.testing.z2.STARTUP``                     |\n+| Bases:     | ``plone.testing.zope.STARTUP``                   |\n +------------+--------------------------------------------------+\n | Resources: | ``host``                                         |\n |            +--------------------------------------------------+\n |            | ``port``                                         |\n +------------+--------------------------------------------------+\n \n-This layer extends the ``z2.STARTUP`` layer to start the Zope HTTP server in a separate thread.\n-This means the test site can be accessed through a web browser, and can thus be used with tools like `Windmill`_ or `Selenium`_.\n+This layer extends the ``zope.STARTUP`` layer to start the Zope HTTP WSGI server in a separate thread.\n+This means the test site can be accessed through a web browser, and can thus be used with tools like `Selenium`_.\n \n .. note::\n \n     This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\n-    Use the ``ZSERVER`` layer if you want to execute functional tests against this fixture.\n+    Use the ``WSGI_SERVER`` layer if you want to execute functional tests against this fixture.\n \n-The ZServer\'s hostname (normally ``localhost``) is available through the resource ``host``, whilst the port it is running on is available through the resource ``port``.\n+The WSGI server\'s hostname (normally ``localhost``) is available through the resource ``host``, whilst the port it is running on is available through the resource ``port``.\n \n   *Hint:* Whilst the layer is set up, you can actually access the test Zope site through a web browser.\n   The default URL will be ``http://localhost:55001``.\n \n-HTTP ZServer functional testing\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-+------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.ZSERVER``                     |\n-+------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.FunctionalTesting``           |\n-+------------+--------------------------------------------------+\n-| Bases:     | ``plone.testing.z2.ZSERVER_FIXTURE``             |\n-+------------+--------------------------------------------------+\n-| Resources: |                                                  |\n-+------------+--------------------------------------------------+\n-\n-This layer provides the functional testing lifecycle against the fixture set up by the ``z2.ZSERVER_FIXTURE`` layer.\n-\n-You can use this to run "live" functional tests against a basic Zope site.\n-You should **not** use it as a base.\n-Instead, create your own "fixture" layer that extends ``z2.ZSERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.\n-\n-FTP server thread (fixture only)\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-+------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.FTP_SERVER_FIXTURE``          |\n-+------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.FTPServer``                   |\n-+------------+--------------------------------------------------+\n-| Bases:     | ``plone.testing.z2.STARTUP``                     |\n-+------------+--------------------------------------------------+\n-| Resources: | ``host``                                         |\n-|            +--------------------------------------------------+\n-|            | ``port``                                         |\n-+------------+--------------------------------------------------+\n-\n-This layer is the FTP server equivalent of the ``ZSERVER_FIXTURE`` layer.\n-It can be used to functionally test Zope servers.\n-\n-.. note::\n-\n-    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\n-    Use the ``FTP_SERVER`` layer if you want to execute functional tests against this fixture.\n-\n-    *Hint:* Whilst the layer is set up, you can actually access the test Zope site through an FTP client.\n-    The default URL will be ``ftp://localhost:55002``.\n-\n-.. warning::\n-\n-    Do not run the ``FTP_SERVER`` and ``ZSERVER`` layers concurrently in the same process.\n-\n-If you need both ZServer and FTPServer running together, you can subclass the ``ZServer`` layer class (like the ``FTPServer`` layer class does) and implement the ``setUpServer()`` and ``tearDownServer()`` methods to set up and close down two servers on different ports.\n-They will then share a main loop.\n-\n-FTP server functional testing\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+HTTP WSGI server functional testing\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n +------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.FTP_SERVER``                  |\n+| Layer:     | ``plone.testing.zope.WSGI_SERVER``               |\n +------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.FunctionalTesting``           |\n+| Class:     | ``plone.testing.zope.FunctionalTesting``         |\n +------------+--------------------------------------------------+\n-| Bases:     | ``plone.testing.z2.FTP_SERVER_FIXTURE``          |\n+| Bases:     | ``plone.testing.zope.WSGI_SERVER_FIXTURE``       |\n +------------+--------------------------------------------------+\n | Resources: |                                                  |\n +------------+--------------------------------------------------+\n \n-This layer provides the functional testing lifecycle against the fixture set up by the ``z2.FTP_SERVER_FIXTURE`` layer.\n+This layer provides the functional testing lifecycle against the fixture set up by the ``zope.WSGI_SERVER_FIXTURE`` layer.\n \n You can use this to run "live" functional tests against a basic Zope site.\n You should **not** use it as a base.\n-Instead, create your own "fixture" layer that extends ``z2.FTP_SERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.\n+Instead, create your own "fixture" layer that extends ``zope.WSGI_SERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.\n \n Helper functions\n ~~~~~~~~~~~~~~~~\n \n-Several helper functions are available in the ``plone.testing.z2`` module.\n+Several helper functions are available in the ``plone.testing.zope`` module.\n \n ``zopeApp(db=None, conn=Non, environ=None)``\n \n@@ -1827,7 +1757,7 @@ Several helper functions are available in the ``plone.testing.z2`` module.\n     By using it in a ``with`` block, the database will be opened, and the application root will be obtained and request-wrapped.\n     When exiting the ``with`` block, the transaction will be committed and the database properly closed, unless an exception was raised::\n \n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n             # do something with app\n \n     If you want to use a specific database or database connection, pass either the ``db`` or ``conn`` arguments.\n@@ -1878,17 +1808,17 @@ Several helper functions are available in the ``plone.testing.z2`` module.\n \n        This method is rarely used, because both the ``zopeApp()``\n        context manager and the layer set-up/tear-down for\n-       ``z2.INTEGRATION_TESTING`` and ``z2.FUNCTIONAL_TESTING`` will wrap the\n+       ``zope.INTEGRATION_TESTING`` and ``zope.FUNCTIONAL_TESTING`` will wrap the\n        ``app`` object before exposing it.\n \n ``Browser(app)``\n \n     Obtain a test browser client, for use with `zope.testbrowser`_.\n-    You should use this in conjunction with the ``z2.FUNCTIONAL_TESTING`` layer or a derivative.\n+    You should use this in conjunction with the ``zope.FUNCTIONAL_TESTING`` layer or a derivative.\n     You must pass the app root, usually obtained from the ``app`` resource of the layer, e.g.::\n \n         app = self.layer[\'app\']\n-        browser = z2.Browser(app)\n+        browser = zope.Browser(app)\n \n     You can then use ``browser`` as described in the `zope.testbrowser`_ documentation.\n \n@@ -1899,16 +1829,273 @@ Several helper functions are available in the ``plone.testing.z2`` module.\n         import transaction\n         transaction.commit()\n \n-.. _zope.testing: http://pypi.python.org/pypi/zope.testing\n-.. _zope.testbrowser: http://pypi.python.org/pypi/zope.testbrowser\n-.. _zope.component: http://pypi.python.org/pypi/zope.component\n-.. _zope.publisher: http://pypi.python.org/pypi/zope.publisher\n-.. _plone.app.testing: http://pypi.python.org/pypi/plone.app.testing\n-.. _zc.recipe.testrunner: http://pypi.python.org/pypi/zc.recipe.testrunner\n-.. _coverage: http://pypi.python.org/pypi/coverage\n-.. _Cobertura: http://wiki.hudson-ci.org/display/HUDSON/Cobertura+Plugin\n-.. _Hudson: http://www.hudson-labs.org/\n+\n+ZServer\n+-------\n+\n+The ZServer layers provide test fixtures suitable for testing Zope applications while using ZServer instead of a WSGI server.\n+They set up a Zope application root, install core Zope products, and manage security.\n+\n+ZServer layers can be found in the module ``plone.testing.zserver``.\n+If you depend on this, you can use the ``[zope,zserver]`` extra when depending on ``plone.testing``.\n+\n+Startup\n+~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.STARTUP``                |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.Startup``                |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |\n++------------+--------------------------------------------------+\n+| Resources: | ``zodbDB``                                       |\n+|            +--------------------------------------------------+\n+|            | ``configurationContext``                         |\n+|            +--------------------------------------------------+\n+|            | ``host``                                         |\n+|            +--------------------------------------------------+\n+|            | ``port``                                         |\n++------------+--------------------------------------------------+\n+\n+This layer sets up a Zope environment for ZServer, and is a required base for all other ZServer layers.\n+You cannot run two instances of this layer in parallel, since Zope depends on some module-global state to run, which is managed by this layer.\n+\n+On set-up, the layer will configure a Zope environment with the same options as ``zope.Startup``, see there.\n+\n+Integration test\n+~~~~~~~~~~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.INTEGRATION_TESTING``    |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.IntegrationTesting``     |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zserver.STARTUP``                |\n++------------+--------------------------------------------------+\n+| Resources: | ``app``                                          |\n+|            +--------------------------------------------------+\n+|            | ``request``                                      |\n++------------+--------------------------------------------------+\n+\n+This layer is intended for integration testing against the simple ``STARTUP`` fixture.\n+If you want to create your own layer with a more advanced, shared fixture, see "Integration and functional testing with custom fixtures" below.\n+\n+For each test, it exposes the Zope application root as the resource ``app``.\n+This is wrapped in the request container, so you can do ``app.REQUEST`` to acquire a fake request, but the request is also available as the resource ``request``.\n+\n+A new transaction is begun for each test and rolled back on test tear-down, meaning that so long as the code under test does not explicitly commit any changes, the test may modify the ZODB.\n+\n+    *Hint:* If you want to set up a persistent test fixture in a layer based on this one (or ``zserver.FUNCTIONAL_TESTING``), you can stack a new ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern described above for the ``zodb.EMPTY_ZODB`` layer.\n+\n+    Once you\'ve shadowed the ``zodbDB`` resource, you can do (e.g. in your layer\'s ``setUp()`` method)::\n+\n+        ...\n+        with zserver.zopeApp() as app:\n+            # modify the Zope application root\n+\n+    The ``zserver.zopeApp()`` context manager will open a new connection to the Zope application root, accessible here as ``app``.\n+    Provided the code within the ``with`` block does not raise an exception, the transaction will be committed and the database closed properly upon exiting the block.\n+\n+Functional testing\n+~~~~~~~~~~~~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.FUNCTIONAL_TESTING``     |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.FunctionalTesting``      |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zserver.STARTUP``                |\n++------------+--------------------------------------------------+\n+| Resources: | ``app``                                          |\n+|            +--------------------------------------------------+\n+|            | ``request``                                      |\n++------------+--------------------------------------------------+\n+\n+It behaves the same as ``zope.FunctionalTesting``, see there.\n+\n+\n+Integration and functional testing with custom fixtures\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+If you want to extend the ``STARTUP`` fixture for use with integration or functional testing, you should use the following pattern:\n+\n+* Create a layer class and a "fixture" base layer instance that has ``zserver.STARTUP`` (or some intermediary layer, such as ``zserver.ZSERVER_FIXTURE`` or ``zserver.FTP_SERVER_FIXTURE``, shown below) as a base.\n+\n+* Create "end user" layers by instantiating the ``zserver.IntegrationTesting`` and/or ``FunctionalTesting`` classes with this new "fixture" layer as a base.\n+\n+This allows the same fixture to be used regardless of the "style" of testing, minimising the amount of set-up and tear-down.\n+The "fixture" layers manage the fixture as part of the *layer* lifecycle.\n+The layer class (``IntegrationTesting`` or ``FunctionalTesting``), manages the *test* lifecycle, and the test lifecycle only.\n+\n+For example::\n+\n+    from plone.testing import Layer, zserver, zodb\n+\n+    class MyLayer(Layer):\n+        defaultBases = (zserver.STARTUP,)\n+\n+        def setUp(self):\n+            # Set up the fixture here\n+            ...\n+\n+        def tearDown(self):\n+            # Tear down the fixture here\n+            ...\n+\n+    MY_FIXTURE = MyLayer()\n+\n+    MY_INTEGRATION_TESTING = zserver.IntegrationTesting(bases=(MY_FIXTURE,), name="MyFixture:Integration")\n+    MY_FUNCTIONAL_TESTING = zserver.FunctionalTesting(bases=(MY_FIXTURE,), name="MyFixture:Functional")\n+\n+(Note that we need to give an explicit, unique name to the two layers that re-use the ``IntegrationTesting`` and ``FunctionalTesting`` classes.)\n+\n+In this example, other layers could extend the "MyLayer" fixture by using ``MY_FIXTURE`` as a base.\n+Tests would use either ``MY_INTEGRATION_TESTING`` or ``MY_FUNCTIONAL_TESTING`` as appropriate.\n+However, even if both these two layers were used, the fixture in ``MY_FIXTURE`` would only be set up once.\n+\n+.. note::\n+\n+    If you implement the ``testSetUp()`` and ``testTearDown()`` test lifecycle methods in your "fixture" layer (e.g. in the the ``MyLayer`` class above), they will execute before the corresponding methods from ``IntegrationTesting`` and ``FunctionalTesting``.\n+    Hence, they cannot use those layers\' resources (``app`` and ``request``).\n+\n+It may be preferable, therefore, to have your own "test lifecycle" layer classes that subclass ``IntegrationTesting`` and/or ``FunctionalTesting`` and call base class methods as appropriate.\n+``plone.app.testing`` takes this approach, for example.\n+\n+\n+HTTP ZServer thread (fixture only)\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.ZSERVER_FIXTURE``        |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.ZServer``                |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zserver.STARTUP``                |\n++------------+--------------------------------------------------+\n+| Resources: | ``host``                                         |\n+|            +--------------------------------------------------+\n+|            | ``port``                                         |\n++------------+--------------------------------------------------+\n+\n+This layer extends the ``zserver.STARTUP`` layer to start the Zope HTTP server (ZServer) in a separate thread.\n+This means the test site can be accessed through a web browser, and can thus be used with tools like `Selenium`_.\n+\n+.. note::\n+\n+    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\n+    Use the ``ZSERVER`` layer if you want to execute functional tests against this fixture.\n+\n+The ZServer\'s hostname (normally ``localhost``) is available through the resource ``host``, whilst the port it is running on is available through the resource ``port``.\n+\n+  *Hint:* Whilst the layer is set up, you can actually access the test Zope site through a web browser.\n+  The default URL will be ``http://localhost:55001``.\n+\n+HTTP ZServer functional testing\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.ZSERVER``                |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.FunctionalTesting``      |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zserver.ZSERVER_FIXTURE``        |\n++------------+--------------------------------------------------+\n+| Resources: |                                                  |\n++------------+--------------------------------------------------+\n+\n+This layer provides the functional testing lifecycle against the fixture set up by the ``zserver.ZSERVER_FIXTURE`` layer.\n+\n+You can use this to run "live" functional tests against a basic Zope site.\n+You should **not** use it as a base.\n+Instead, create your own "fixture" layer that extends ``zserver.ZSERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.\n+\n+\n+FTP server thread (fixture only)\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.FTP_SERVER_FIXTURE``     |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.FTPServer``              |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zserver.STARTUP``                |\n++------------+--------------------------------------------------+\n+| Resources: | ``host``                                         |\n+|            +--------------------------------------------------+\n+|            | ``port``                                         |\n++------------+--------------------------------------------------+\n+\n+This layer is the FTP server equivalent of the ``zserver.ZSERVER_FIXTURE`` layer.\n+It can be used to functionally test Zope FTP servers.\n+\n+.. note::\n+\n+    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\n+    Use the ``FTP_SERVER`` layer if you want to execute functional tests against this fixture.\n+\n+    *Hint:* Whilst the layer is set up, you can actually access the test Zope site through an FTP client.\n+    The default URL will be ``ftp://localhost:55002``.\n+\n+.. warning::\n+\n+    Do not run the ``FTP_SERVER`` and ``ZSERVER`` layers concurrently in the same process.\n+\n+If you need both ZServer and FTPServer running together, you can subclass the ``ZServer`` layer class (like the ``FTPServer`` layer class does) and implement the ``setUpServer()`` and ``tearDownServer()`` methods to set up and close down two servers on different ports.\n+They will then share a main loop.\n+\n+FTP server functional testing\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.FTP_SERVER``                |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.FunctionalTesting``         |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zserver.FTP_SERVER_FIXTURE``        |\n++------------+--------------------------------------------------+\n+| Resources: |                                                  |\n++------------+--------------------------------------------------+\n+\n+This layer provides the functional testing lifecycle against the fixture set up by the ``zserver.FTP_SERVER_FIXTURE`` layer.\n+\n+You can use this to run "live" functional tests against a basic Zope site.\n+You should **not** use it as a base.\n+Instead, create your own "fixture" layer that extends ``zserver.FTP_SERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.\n+\n+Helper functions\n+~~~~~~~~~~~~~~~~\n+\n+Several helper functions are available in the ``plone.testing.zserver`` module.\n+\n+``zopeApp(db=None, conn=Non, environ=None)``\n+\n+    This function can be used as a context manager for any code that requires access to the Zope application root.\n+    By using it in a ``with`` block, the database will be opened, and the application root will be obtained and request-wrapped.\n+    When exiting the ``with`` block, the transaction will be committed and the database properly closed, unless an exception was raised::\n+\n+        with zserver.zopeApp() as app:\n+            # do something with app\n+\n+    If you want to use a specific database or database connection, pass either the ``db`` or ``conn`` arguments.\n+    If the context manager opened a new connection, it will close it, but it will not close a connection passed with ``conn``.\n+\n+    To set keys in the (fake) request environment, pass a dictionary of environment values as ``environ``.\n+\n+    Note that ``zopeApp()`` should *not* normally be used in tests or test set-up/tear-down, because the ``INTEGRATOIN_TEST`` and ``FUNCTIONAL_TESTING`` layers both manage the application root (as the ``app`` resource) and close it for you.\n+    It is very useful in layer setup, however.\n+\n+The other helper functions defined in ``plone.testing.zope`` can also be used in a ZServer context but together with the ZServer layers.\n+\n+.. _zope.testing: https://pypi.org/project/zope.testing/\n+.. _zope.testbrowser: https://pypi.org/project/zope.testbrowser\n+.. _zope.component: https://pypi.org/project/zope.component\n+.. _zope.publisher: https://pypi.org/project/zope.publisher\n+.. _plone.app.testing: https://pypi.org/project/plone.app.testing\n+.. _zc.recipe.testrunner: https://pypi.org/project/zc.recipe.testrunner\n+.. _coverage: https://pypi.org/project/coverage\n+.. _Cobertura: https://wiki.jenkins.io/display/JENKINS/Cobertura+Plugin\n+.. _Jenkins: https://jenkins.io\n .. _unittest: http://doc.python.org/library/unittest.html\n .. _doctest: http://docs.python.org/dev/library/doctest.html\n-.. _Windmill: http://getwindmill.com/\n .. _Selenium: http://seleniumhq.org/\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/2b45db15f988066390abe68afcf8bba231c94b78

Fix most code smells Jenkins complains about.

Files changed:
M src/plone/testing/tests.py
M src/plone/testing/zserver.py

b'diff --git a/src/plone/testing/tests.py b/src/plone/testing/tests.py\nindex 3f4584f..1a4e27c 100644\n--- a/src/plone/testing/tests.py\n+++ b/src/plone/testing/tests.py\n@@ -2,12 +2,11 @@\n from __future__ import absolute_import\n from OFS.SimpleItem import SimpleItem\n from pkg_resources import get_distribution\n-from ZPublisher.Iterators import filestream_iterator\n from zope.testing import renormalizing\n+from ZPublisher.Iterators import filestream_iterator\n \n import doctest\n import os.path\n-import unittest\n import re\n import unittest\n import zope.component.testing\n@@ -79,11 +78,11 @@ def tearDown(self):\n \n     # normalize py3 output to py2\n     (re.compile(\n-        r"zope\\.configuration\\.xmlconfig\\.ZopeXMLConfigurationError"),\n-     r"ZopeXMLConfigurationError"),\n-    (re.compile(r"builtins\\.PopulatedZODB"), r"PopulatedZODB"),\n-    (re.compile(r"builtins\\.ExpandedZODB"), r"ExpandedZODB"),\n-    (re.compile(r"urllib\\.error\\.URLError"), r"URLError"),\n+        r\'zope\\.configuration\\.xmlconfig\\.ZopeXMLConfigurationError\'),\n+     r\'ZopeXMLConfigurationError\'),\n+    (re.compile(r\'builtins\\.PopulatedZODB\'), r\'PopulatedZODB\'),\n+    (re.compile(r\'builtins\\.ExpandedZODB\'), r\'ExpandedZODB\'),\n+    (re.compile(r\'urllib\\.error\\.URLError\'), r\'URLError\'),\n ])\n \n \ndiff --git a/src/plone/testing/zserver.py b/src/plone/testing/zserver.py\nindex 55efb62..46fbe70 100644\n--- a/src/plone/testing/zserver.py\n+++ b/src/plone/testing/zserver.py\n@@ -3,12 +3,12 @@\n """\n from __future__ import absolute_import\n from plone.testing import Layer\n+from plone.testing import zope\n+from plone.testing._z2_testbrowser import Browser  # noqa\n from plone.testing.zope import addRequestContainer\n from plone.testing.zope import login  # noqa\n from plone.testing.zope import logout  # noqa\n from plone.testing.zope import setRoles  # noqa\n-from plone.testing._z2_testbrowser import Browser  # noqa\n-from plone.testing import zope\n \n import contextlib\n import os\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/040c1ec1c1f88d5f7b720f356fcf46821eb04962

BBB code drops coverage.

Files changed:
M tox.ini

b'diff --git a/tox.ini b/tox.ini\nindex c5870df..fc6e457 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -32,4 +32,4 @@ commands =\n     coverage combine\n     coverage html -i\n     coverage xml -i\n-    coverage report -i --fail-under=86\n+    coverage report -i --fail-under=85\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/ae09150dcb24e3226d5910261bc6ecdd80c90017

Remove Zope 2.13 BBB code no longer needed in Zope 4.

Files changed:
M src/plone/testing/zope.py

b'diff --git a/src/plone/testing/zope.py b/src/plone/testing/zope.py\nindex 0475e67..d0c5291 100644\n--- a/src/plone/testing/zope.py\n+++ b/src/plone/testing/zope.py\n@@ -122,20 +122,6 @@ def uninstallProduct(app, productName, quiet=False):\n                 if name in Application.misc_.__dict__:\n                     delattr(Application.misc_, name)\n \n-                try:\n-                    cp = app[\'Control_Panel\'][\'Products\']\n-                except KeyError:\n-                    # Zope 4\n-                    pass\n-                else:\n-                    if name in cp:\n-                        product = cp[name]\n-\n-                        app._manage_remove_product_meta_type(product)\n-                        app._manage_remove_product_permission(product)\n-\n-                        del cp[name]\n-\n                 # TODO: Also remove permissions from get_folder_permissions?\n                 # Difficult to know if this would stomp on any other\n                 # permissions\n@@ -148,20 +134,6 @@ def uninstallProduct(app, productName, quiet=False):\n         module, init_func = _INSTALLED_PRODUCTS[productName]\n         name = module.__name__\n \n-        try:\n-            cp = app[\'Control_Panel\'][\'Products\']\n-        except KeyError:\n-            # Zope 4\n-            pass\n-        else:\n-            if name in cp:\n-                product = cp[name]\n-\n-                app._manage_remove_product_meta_type(product)\n-                app._manage_remove_product_permission(product)\n-\n-                del cp[name]\n-\n         packages = get_packages_to_initialize()\n         packages.append((module, init_func))\n         found = True\n@@ -418,7 +390,6 @@ def setUpPatches(self):\n         """\n \n         import OFS.Application\n-        import App.ProductContext\n         import Zope2.App.startup\n \n         # Avoid expensive product import\n@@ -433,49 +404,19 @@ def null_initialize(app):\n         self._OFS_Application_initialize = OFS.Application.initialize\n         OFS.Application.initialize = null_initialize\n \n-        # Avoid expensive help registration\n-        try:\n-            self._App_ProductContext_ProductContext_registerHelpTopic = App.ProductContext.ProductContext.registerHelpTopic  # noqa\n-        except AttributeError:\n-            # Zope 4\n-            pass\n-        else:\n-            def null_register_topic(self, id, topic):\n-                pass\n-            App.ProductContext.ProductContext.registerHelpTopic = null_register_topic  # noqa\n-\n-            self._App_ProductContext_ProductContext_registerHelpTitle = App.ProductContext.ProductContext.registerHelpTitle  # noqa\n+        # Prevent ZCML from loading during App startup:\n+        self._Zope2_App_startup_load_zcml = Zope2.App.startup.load_zcml\n \n-            def null_register_title(self, title):\n-                pass\n-            App.ProductContext.ProductContext.registerHelpTitle = null_register_title  # noqa\n-\n-            self._App_ProductContext_ProductContext_registerHelp = App.ProductContext.ProductContext.registerHelp  # noqa\n-\n-            def null_register_help(\n-                    self,\n-                    directory=\'\',\n-                    clear=1,\n-                    title_re=None):\n-                pass\n-            App.ProductContext.ProductContext.registerHelp = null_register_help\n-\n-        try:\n-            self._Zope2_App_startup_load_zcml = Zope2.App.startup.load_zcml\n-        except AttributeError:\n+        def null_load_zcml():\n             pass\n-        else:\n-            # in Zope 2.13, prevent ZCML from loading during App startup\n-            def null_load_zcml():\n-                pass\n-            Zope2.App.startup.load_zcml = null_load_zcml\n+\n+        Zope2.App.startup.load_zcml = null_load_zcml\n \n     def tearDownPatches(self):\n         """Revert the monkey patches from setUpPatches()\n         """\n \n         import OFS.Application\n-        import App.ProductContext\n \n         OFS.Application.import_products = self._OFS_Application_import_products\n         del self._OFS_Application_import_products\n@@ -483,19 +424,7 @@ def tearDownPatches(self):\n         OFS.Application.initialize = self._OFS_Application_initialize\n         del self._OFS_Application_initialize\n \n-        try:\n-            App.ProductContext.ProductContext.registerHelpTopic = self._App_ProductContext_ProductContext_registerHelpTopic  # noqa\n-        except AttributeError:\n-            # Zope 4\n-            pass\n-        else:\n-            del self._App_ProductContext_ProductContext_registerHelpTopic\n-\n-            App.ProductContext.ProductContext.registerHelpTitle = self._App_ProductContext_ProductContext_registerHelpTitle  # noqa\n-            del self._App_ProductContext_ProductContext_registerHelpTitle\n-\n-            App.ProductContext.ProductContext.registerHelp = self._App_ProductContext_ProductContext_registerHelp  # noqa\n-            del self._App_ProductContext_ProductContext_registerHelp\n+        Zope2.App.startup.load_zcml = self._Zope2_App_startup_load_zcml\n \n     def setUpThreads(self):\n         """Set the thread count. Only needed in ZServer.\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.testing/commit/88f7715b7138a9180d416abec9c83fd005a02345

update configs and tox

Files changed:
M .travis.yml
M setup.cfg
M tox.ini
D .isort.cfg

b'diff --git a/.isort.cfg b/.isort.cfg\ndeleted file mode 100644\nindex dd9f25d..0000000\n--- a/.isort.cfg\n+++ /dev/null\n@@ -1,6 +0,0 @@\n-[settings]\n-force_alphabetical_sort = True\n-force_single_line = True\n-lines_after_imports = 2\n-line_length = 200\n-not_skip = __init__.py\ndiff --git a/.travis.yml b/.travis.yml\nindex 3456c2d..9f1b446 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -1,21 +1,50 @@\n language: python\n sudo: false\n-python:\n-    - 2.7\n-    - 3.6\n-env:\n-    - EXTRA=\n-    - EXTRA=-zserver\n+\n matrix:\n-    exclude:\n-    - python: 3.6\n-      env: EXTRA=-zserver\n+    include:\n+        - python: "2.7"\n+          env: TOXENV=lint-py27\n+        - python: "3.6"\n+          env: TOXENV=lint-py36\n+        - python: "2.7"\n+          env: TOXENV=py27\n+        - python: "2.7"\n+          env: TOXENV=py27-zserver\n+        - python: "3.4"\n+          env: TOXENV=py34\n+        - python: "3.5"\n+          env: TOXENV=py35\n+        - python: "3.6"\n+          env: TOXENV=py36\n+        - python: "3.6"\n+          env: TOXENV=py36-zserver\n+        - python: "3.7-dev"\n+          env: TOXENV=py37\n+        - python: "pypy"\n+          env: TOXENV=pypy\n+        - python: "pypy3"\n+          env: TOXENV=pypy\n+    allow_failures:\n+        - python: "3.7-dev"\n+          env: TOXENV=py37\n+        - python: "pypy"\n+          env: TOXENV=pypy\n+        - python: "pypy3"\n+          env: TOXENV=pypy\n+\n install:\n-    - pip install tox\n+    - travis_retry pip install -U pip setuptools\n+    - travis_retry pip install -U -c constraints.txt tox coveralls coverage\n+\n script:\n-    - tox -e py${TRAVIS_PYTHON_VERSION//.}$EXTRA\n+    - travis_retry tox\n+\n after_success:\n     - coverage combine\n     - coveralls\n+\n+notifications:\n+    email: false\n cache:\n   pip: true\ndiff --git a/setup.cfg b/setup.cfg\nindex c2c94bb..5b3ab5b 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,5 +1,10 @@\n-[bdist_wheel]\n-universal = 1\n+[build_sphinx]\n+source-dir = docs/source\n+build-dir  = _build/docs\n+all_files  = 1\n+\n+[upload_sphinx]\n+upload-dir = _build/docs/html\n \n [check-manifest]\n ignore =\n@@ -9,14 +14,46 @@ ignore =\n \n [coverage:run]\n branch = True\n-source = plone.testing\n+\n+source =\n+    src\n+\n+omit =\n \n [coverage:report]\n precision = 2\n \n+[coverage:html]\n+directory = reports/coverage\n+\n+\n+[isort]\n+# for details see\n+# http://docs.plone.org/develop/styleguide/python.html#grouping-and-sorting\n+force_alphabetical_sort = True\n+force_single_line = True\n+lines_after_imports = 2\n+line_length = 200\n+not_skip = __init__.py\n+\n+[flake8]\n+exclude =\n+    bootstrap-buildout.py,\n+    src/*\n+\n+include =\n+    src/ploneorg.releasesecurityinfo\n+\n+ignore =\n+    N801,\n+    N802,\n+    N803,\n+    N805,\n+    N806,\n+    N812,\n+\n [zest.releaser]\n create-wheel = yes\n \n-# When Python 2-3 compatible:\n-# [bdist_wheel]\n-# universal = 1\n+[bdist_wheel]\n+universal = 1\ndiff --git a/tox.ini b/tox.ini\nindex fc6e457..414bec9 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -1,35 +1,160 @@\n [tox]\n-envlist = py27,\n-          py27-zserver,\n-          py36,\n-          coverage-report\n+envlist =\n+    py27,\n+    py27-zserver,\n+    py36,\n+    coverage-report,\n+#    docs,\n+    lint-py27,\n+    lint-py36,\n+\n minversion = 1.9\n \n [testenv]\n usedevelop = True\n+\n pip_pre = True\n+\n+extras =\n+    test\n+\n deps =\n-     .[test]\n+     .\n      zope.testrunner\n      coverage\n+\n commands = coverage run {envbindir}/zope-testrunner --path=src --all {posargs:-vc}\n+\n setenv =\n     COVERAGE_FILE=.coverage.{envname}\n+\n passenv = WSGI_REQUEST_LOGGING\n \n [testenv:py27-zserver]\n-deps = .[test,z2,zserver]\n-       {[testenv]deps}\n+deps =\n+    .[test,z2,zserver]\n+    {[testenv]deps}\n \n [testenv:coverage-report]\n+skip_install = true\n basepython = python2.7\n+\n deps = coverage\n+\n setenv =\n     COVERAGE_FILE=.coverage\n-skip_install = true\n+\n commands =\n     coverage erase\n     coverage combine\n     coverage html -i\n     coverage xml -i\n     coverage report -i --fail-under=85\n+\n+\n+[lint]\n+skip_install = true\n+\n+deps =\n+    isort\n+    flake8\n+    # helper to generate HTML reports:\n+    flake8-html\n+    # Useful flake8 plugins that are Python and Plone specific:\n+    flake8-coding\n+    flake8-debugger\n+    flake8-deprecated\n+    flake8-print\n+    flake8-pytest\n+    flake8-todo\n+    flake8-isort\n+    mccabe\n+    # Potential flake8 plugins that should be used:  # TBD\n+    #flake8-blind-except\n+    #flake8-commas\n+    #flake8-docstrings\n+    #flake8-mypy\n+    #flake8-pep3101\n+    #flake8-plone-hasattr\n+    #flake8-string-format\n+    #flake8_strict\n+    #flake8-quotes\n+    #flake8-polyfill\n+\n+commands =\n+    mkdir -p {toxinidir}/reports/flake8\n+    - flake8 --format=html --htmldir={toxinidir}/reports/flake8 --doctests src setup.py\n+    flake8 --doctests src tests setup.py\n+    isort --check-only --recursive {toxinidir}/src\n+\n+whitelist_externals =\n+    mkdir\n+\n+[testenv:isort-apply]\n+skip_install = true\n+\n+deps =\n+    isort\n+\n+commands =\n+    isort --apply --recursive {toxinidir}/src\n+\n+[testenv:lint-py27]\n+basepython = python2.7\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:lint-py34]\n+basepython = python3.4\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:lint-py35]\n+basepython = python3.5\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:lint-py36]\n+basepython = python3.6\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:docs]\n+skip_install = true\n+\n+deps =\n+    Sphinx\n+\n+commands =\n+    sphinx-build -b html -d _build/docs/doctrees docs _build/docs/html\n+    sphinx-build -b doctest docs _build/docs/doctrees\n+\n+[testenv:update_translation]\n+skip_install = true\n+\n+deps =\n+    i18ndude\n+\n+commands =\n+    i18ndude find-untranslated\n+    i18ndude rebuild-pot\n+    i18ndude merge\n+    i18ndude sync\n+    i18ndude list\n+\n+[testenv:release]\n+skip_install = true\n+\n+deps =\n+    zest.releaser[recommended]\n+\n+commands =\n+    fullrelease --no-input -v\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.testing/commit/6470c9cb094e734496fd1544fcacf3c262ac51ea

linting

Files changed:
M setup.py

b"diff --git a/setup.py b/setup.py\nindex 8410cb9..d05e276 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,7 +1,10 @@\n # -*- coding: utf-8 -*-\n+from setuptools import find_packages\n+from setuptools import setup\n+\n import os\n import os.path\n-from setuptools import setup, find_packages\n+\n \n version = '7.0.dev0'\n \n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.testing/commit/9a992f5c70a9a1eca0cd1aef5cdfb25657079428

config

Files changed:
A .editorconfig
M .gitignore
M setup.cfg

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..512361c\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,36 @@\n+# EditorConfig Configurtaion file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.gitignore b/.gitignore\nindex fcfa901..8293885 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -2,6 +2,7 @@\n *.pyc\n *.tox\n .Python\n+.pytest_cache\n .coverage\n .installed.cfg\n bin\n@@ -13,3 +14,4 @@ include/\n lib/\n parts/\n pip-selfcheck.json\n+_build/\ndiff --git a/setup.cfg b/setup.cfg\nindex 5b3ab5b..a5f18a8 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -24,7 +24,7 @@ omit =\n precision = 2\n \n [coverage:html]\n-directory = reports/coverage\n+directory = _build/reports/coverage\n \n \n [isort]\n@@ -38,11 +38,10 @@ not_skip = __init__.py\n \n [flake8]\n exclude =\n-    bootstrap-buildout.py,\n-    src/*\n+    bootstrap.py,\n \n include =\n-    src/ploneorg.releasesecurityinfo\n+    src\n \n ignore =\n     N801,\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.testing/commit/ff172839062be771ca6a8b58798e17a5aec5562f

flake8 ignore TODO and assert

Files changed:
M setup.cfg

b'diff --git a/setup.cfg b/setup.cfg\nindex a5f18a8..2bce1d9 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -50,6 +50,8 @@ ignore =\n     N805,\n     N806,\n     N812,\n+    T000,\n+    T003,\n \n [zest.releaser]\n create-wheel = yes\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.testing/commit/3749ca35b9af837340dc2901482add9bd32016c0

change path for reports

Files changed:
M tox.ini

b'diff --git a/tox.ini b/tox.ini\nindex 414bec9..55d1155 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -83,7 +83,7 @@ deps =\n \n commands =\n     mkdir -p {toxinidir}/reports/flake8\n-    - flake8 --format=html --htmldir={toxinidir}/reports/flake8 --doctests src setup.py\n+    - flake8 --format=html --htmldir={toxinidir}/_build/reports/flake8 --doctests src setup.py\n     flake8 --doctests src tests setup.py\n     isort --check-only --recursive {toxinidir}/src\n \n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.testing/commit/af80452cb55f43038d550ecd37938a37d8a83315

no constraints.txt

Files changed:
M .travis.yml

b'diff --git a/.travis.yml b/.travis.yml\nindex 9f1b446..396114f 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -35,7 +35,7 @@ matrix:\n \n install:\n     - travis_retry pip install -U pip setuptools\n-    - travis_retry pip install -U -c constraints.txt tox coveralls coverage\n+    - travis_retry pip install -U tox coveralls coverage\n \n script:\n     - travis_retry tox\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.testing/commit/4d7298b9a180c7d687f55b6d32bd52528fd7f6c5

fixing indention on rst

Files changed:
M .travis.yml
M CHANGES.rst

b"diff --git a/.travis.yml b/.travis.yml\nindex 396114f..63ffff2 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -47,4 +47,4 @@ after_success:\n notifications:\n     email: false\n cache:\n-  pip: true\n+    pip: true\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex ec06dd2..81f0c4d 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -7,6 +7,7 @@ Changelog\n Breaking changes:\n \n - ``plone.testing.z2`` is now a BBB shim for ``plone.testing.zope``,\n+- ``plone.testing.z2`` is now a BBB shim for ``plone.testing.wsgi``,\n   thus it switches the tests to use WSGI.\n   If you absolutely want to keep using ZServer please import from ``plone.testing.zserver``.\n \n@@ -45,8 +46,7 @@ Bug fixes:\n 5.1.1 (2017-04-19)\n ------------------\n \n-- Do not break on import of ``plone.testing.z2`` when using\n-  `zope.testbrowser` >= 5.0 which no longer depends on `mechanize`.\n+- Do not break on import of ``plone.testing.z2`` when using `zope.testbrowser` >= 5.0 which no longer depends on `mechanize`.\n \n \n 5.1 (2017-04-13)\n@@ -102,8 +102,7 @@ Fixes:\n - PEP 8.\n   [thet]\n \n-- Depend on zope.testrunner, which was moved out from\n-  zope.testing.testrunner.\n+- Depend on zope.testrunner, which was moved out from zope.testing.testrunner.\n   [thet]\n \n - Add support for Zope 4.\n@@ -113,7 +112,7 @@ Fixes:\n 4.0.15 (2015-08-14)\n -------------------\n \n-- Prevent exception masking in finally clause of zopeApp context\n+- Prevent exception masking in finally clause of zopeApp context.\n   [do3cc]\n \n \n@@ -123,8 +122,7 @@ Fixes:\n - Rerelease for clarity due to double release of 4.0.13.\n   [maurits]\n \n-- Added ``multiinit``-parameter to z2.installProduct\n-  to allow multiple initialize methods for a package\n+- Added ``multiinit``-parameter to z2.installProduct to allow multiple initialize methods for a package\n   [tomgross]\n \n \n@@ -141,11 +139,11 @@ Fixes:\n 4.0.12 (2014-09-07)\n -------------------\n \n-- Fixed AttributeError when importing ``plone.testing.z2`` if\n-  ``zope.testbrowser`` 4.x is used but not ``zope.app.testing``. [icemac]\n+- Fixed AttributeError when importing ``plone.testing.z2`` if ``zope.testbrowser`` 4.x is used but not ``zope.app.testing``.\n+  [icemac]\n \n-- Broke dependency on `unittest2` for Python 2.7+ as all features of\n-  `unittest2` are integrated in `unittest` there. [icemac]\n+- Broke dependency on `unittest2` for Python 2.7+ as all features of `unittest2` are integrated in `unittest` there.\n+  [icemac]\n \n \n 4.0.11 (2014-02-22)\n@@ -158,8 +156,8 @@ Fixes:\n 4.0.10 (2014-02-11)\n -------------------\n \n-- Read 'FTPSERVER_HOST' and 'FTPSERVER_PORT' from the environment variables if\n-  possible. This allows us to run tests in parallel on CI servers.\n+- Read 'FTPSERVER_HOST' and 'FTPSERVER_PORT' from the environment variables if possible.\n+  This allows us to run tests in parallel on CI servers.\n   [timo]\n \n \n@@ -194,18 +192,17 @@ Fixes:\n 4.0.5 (2012-10-15)\n ------------------\n \n-- Fixed an issue where a query string would be unquoted twice; once\n-  while setting up the HTTP request and once in the handler (the\n-  publisher).\n+- Fixed an issue where a query string would be unquoted twice;\n+  once while setting up the HTTP request and once in the handler (the publisher).\n   [malthe]\n \n \n 4.0.4 (2012-08-04)\n ------------------\n \n-- Fixed the cache reset code. In some situations the function does not\n-  have any defaults, so we shouldn't try to clear out the app\n-  reference.\n+- Fixed the cache reset code.\n+  In some situations the function does not have any defaults,\n+  so we shouldn't try to clear out the app reference.\n   [malthe]\n \n \n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.testing/commit/d58da2517c0ded8faf5e95f731271a8bf97bb7b4

fix test setup, no py36-zserver

Files changed:
M .travis.yml
M tox.ini

b'diff --git a/.travis.yml b/.travis.yml\nindex 63ffff2..d505198 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -26,6 +26,8 @@ matrix:\n         - python: "pypy3"\n           env: TOXENV=pypy\n     allow_failures:\n+        - python: "3.6"\n+          env: TOXENV=py36-zserver\n         - python: "3.7-dev"\n           env: TOXENV=py37\n         - python: "pypy"\ndiff --git a/tox.ini b/tox.ini\nindex 55d1155..f57e552 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -23,7 +23,9 @@ deps =\n      zope.testrunner\n      coverage\n \n-commands = coverage run {envbindir}/zope-testrunner --path=src --all {posargs:-vc}\n+commands =\n+    python -V\n+    coverage run {envbindir}/zope-testrunner --path=src --all {posargs:-vc}\n \n setenv =\n     COVERAGE_FILE=.coverage.{envname}\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.testing/commit/3b21ce88d0d49b6173689f5045375919109091d7

fix test setup, no py36-zserver

Files changed:
M .travis.yml
M buildout.cfg

b'diff --git a/.travis.yml b/.travis.yml\nindex d505198..76db166 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -21,19 +21,11 @@ matrix:\n           env: TOXENV=py36-zserver\n         - python: "3.7-dev"\n           env: TOXENV=py37\n-        - python: "pypy"\n-          env: TOXENV=pypy\n-        - python: "pypy3"\n-          env: TOXENV=pypy\n     allow_failures:\n         - python: "3.6"\n           env: TOXENV=py36-zserver\n         - python: "3.7-dev"\n           env: TOXENV=py37\n-        - python: "pypy"\n-          env: TOXENV=pypy\n-        - python: "pypy3"\n-          env: TOXENV=pypy\n \n install:\n     - travis_retry pip install -U pip setuptools\ndiff --git a/buildout.cfg b/buildout.cfg\nindex 34df24f..5e195ed 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -1,7 +1,12 @@\n [buildout]\n extends =\n     https://raw.githubusercontent.com/plone/buildout.coredev/5.2/versions.cfg\n-parts = coverage test report report-xml\n+parts =\n+    coverage\n+    test\n+    report\n+    report-xml\n+\n develop = .\n prefer-final = false\n \n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.testing/commit/45a9a80984672ffd33c7ed86fc8f9e32a46ce879

cleanup tox.ini to do tests right

Files changed:
M tox.ini

b'diff --git a/tox.ini b/tox.ini\nindex f57e552..ca3890f 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -3,6 +3,7 @@ envlist =\n     py27,\n     py27-zserver,\n     py36,\n+#    py36-zserver,\n     coverage-report,\n #    docs,\n     lint-py27,\n@@ -17,10 +18,9 @@ pip_pre = True\n \n extras =\n     test\n+    zserver: z2,zserver\n \n deps =\n-     .\n-     zope.testrunner\n      coverage\n \n commands =\n@@ -30,12 +30,8 @@ commands =\n setenv =\n     COVERAGE_FILE=.coverage.{envname}\n \n-passenv = WSGI_REQUEST_LOGGING\n-\n-[testenv:py27-zserver]\n-deps =\n-    .[test,z2,zserver]\n-    {[testenv]deps}\n+passenv =\n+    WSGI_REQUEST_LOGGING\n \n [testenv:coverage-report]\n skip_install = true\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.testing/commit/20a10a7eab35743d09b5e3bb449e143a2afbec96

cleanup

Files changed:
M src/plone/testing/__init__.py
M tox.ini

b'diff --git a/src/plone/testing/__init__.py b/src/plone/testing/__init__.py\nindex 5312af9..0772d96 100644\n--- a/src/plone/testing/__init__.py\n+++ b/src/plone/testing/__init__.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+# flake8: NOQA: F401\n # Convenience imports\n-from plone.testing.layer import Layer  # noqa\n-from plone.testing.layer import layered  # noqa\n+from plone.testing.layer import Layer\n+from plone.testing.layer import layered\ndiff --git a/tox.ini b/tox.ini\nindex ca3890f..4a57ee9 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -80,7 +80,7 @@ deps =\n     #flake8-polyfill\n \n commands =\n-    mkdir -p {toxinidir}/reports/flake8\n+    mkdir -p {toxinidir}/_build/reports/flake8\n     - flake8 --format=html --htmldir={toxinidir}/_build/reports/flake8 --doctests src setup.py\n     flake8 --doctests src tests setup.py\n     isort --check-only --recursive {toxinidir}/src\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.testing/commit/5a20e2598033efc56d06e9a394323f2c476e2712

lint layer

Files changed:
M src/plone/testing/layer.py

b'diff --git a/src/plone/testing/layer.py b/src/plone/testing/layer.py\nindex 8ac9600..a95b8c6 100644\n--- a/src/plone/testing/layer.py\n+++ b/src/plone/testing/layer.py\n@@ -125,7 +125,8 @@ def _resourceResolutionOrder(self, instance):\n         return self._mergeResourceManagers(\n             [[instance]] +\n             list(map(self._resourceResolutionOrder, instance.__bases__)) +\n-            [list(instance.__bases__)])\n+            [list(instance.__bases__)]\n+        )\n \n \n class Layer(ResourceManager):\n@@ -155,10 +156,10 @@ def __init__(self, bases=None, name=None, module=None):\n         """\n \n         if self.__class__ is Layer and name is None:\n-            raise ValueError(\'The `name` argument is required when instantiating `Layer` directly\')  # noqa\n+            raise ValueError(\'The `name` argument is required when instantiating `Layer` directly\')  # NOQA: E501\n \n         if name is None and bases is not None:\n-            raise ValueError(\'The `name`` argument is required when overriding bases with the `bases` argument\')  # noqa\n+            raise ValueError(\'The `name`` argument is required when overriding bases with the `bases` argument\')  # NOQA: E501\n \n         super(Layer, self).__init__()\n \n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: David Glick (davisagli) <david@glicksoftware.com>
Commit: https://github.com/plone/plone.testing/commit/89f2a407cfe0bbee7778912af0fcf412c1f76c80

encode auth header using ZPublisher.utils.basic_auth_encode

Files changed:
M src/plone/testing/_z2_testbrowser.py

b"diff --git a/src/plone/testing/_z2_testbrowser.py b/src/plone/testing/_z2_testbrowser.py\nindex 7fa7c9a..c0021ad 100644\n--- a/src/plone/testing/_z2_testbrowser.py\n+++ b/src/plone/testing/_z2_testbrowser.py\n@@ -2,12 +2,10 @@\n from __future__ import absolute_import\n from zope.testbrowser import browser\n from ZPublisher.httpexceptions import HTTPExceptionHandler\n+from ZPublisher.utils import basic_auth_encode\n from ZPublisher.WSGIPublisher import publish_module\n-\n-import base64\n import re\n \n-\n BASIC_RE = re.compile('Basic (.+)?:(.+)?$')\n \n \n@@ -19,8 +17,7 @@ def authHeader(header):\n             u = ''\n         if p is None:\n             p = ''\n-        auth = base64.encodestring('{0}:{1}'.format(u, p))\n-        return 'Basic {0}'.format(auth[:-1])\n+        return basic_auth_encode(u, p)\n     return header\n \n \n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.testing/commit/10d443c6545546a767eed42316ca415c2c3f7229

fix flake8 / isort error

Files changed:
M src/plone/testing/_z2_testbrowser.py

b"diff --git a/src/plone/testing/_z2_testbrowser.py b/src/plone/testing/_z2_testbrowser.py\nindex c0021ad..7eba318 100644\n--- a/src/plone/testing/_z2_testbrowser.py\n+++ b/src/plone/testing/_z2_testbrowser.py\n@@ -4,8 +4,10 @@\n from ZPublisher.httpexceptions import HTTPExceptionHandler\n from ZPublisher.utils import basic_auth_encode\n from ZPublisher.WSGIPublisher import publish_module\n+\n import re\n \n+\n BASIC_RE = re.compile('Basic (.+)?:(.+)?$')\n \n \n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.testing/commit/d43e0d49b8392877cce085ffafa48f0d9295a8ad

Improve isolation between Zope and ZServer layers.

Without these changes the ZServer layer implicitly uses the Zope app in some
places. This breaks tests later on which run on the Zope layer with the
following traceback:

    Traceback (most recent call last):
      ...
      File ".../plone/testing/zope.py", line 244, in zopeApp
        app = addRequestContainer(Zope2.app(connection), environ=environ)
      File ".../Zope2/__init__.py", line 55, in app
        return bobo_application(*args, **kw)
    TypeError: 'NoneType' object is not callable

Files changed:
M src/plone/testing/zope.py
M src/plone/testing/zserver.py

b'diff --git a/src/plone/testing/zope.py b/src/plone/testing/zope.py\nindex d0c5291..63e02a4 100644\n--- a/src/plone/testing/zope.py\n+++ b/src/plone/testing/zope.py\n@@ -239,6 +239,8 @@ def zopeApp(db=None, connection=None, environ=None):\n     if connection is None and db is not None:\n         connection = db.open()\n \n+    assert Zope2._began_startup, \\\n+        "Zope2 WSGI is not started, maybe mixing Zope and ZServer layers."\n     app = addRequestContainer(Zope2.app(connection), environ=environ)\n \n     if connection is None:\ndiff --git a/src/plone/testing/zserver.py b/src/plone/testing/zserver.py\nindex 46fbe70..8f0a725 100644\n--- a/src/plone/testing/zserver.py\n+++ b/src/plone/testing/zserver.py\n@@ -3,12 +3,16 @@\n """\n from __future__ import absolute_import\n from plone.testing import Layer\n+from plone.testing import zodb\n from plone.testing import zope\n from plone.testing._z2_testbrowser import Browser  # noqa\n from plone.testing.zope import addRequestContainer\n+from plone.testing.zope import installProduct\n from plone.testing.zope import login  # noqa\n from plone.testing.zope import logout  # noqa\n from plone.testing.zope import setRoles  # noqa\n+from plone.testing.zope import TestIsolationBroken\n+from plone.testing.zope import uninstallProduct\n \n import contextlib\n import os\n@@ -140,7 +144,7 @@ def setUpApp(self):\n         # This uses the DB from the dbtab, as configured in setUpDatabase().\n         # That DB then gets stored as Zope2.DB and becomes the default.\n \n-        import Zope2\n+        from ZServer import Zope2\n         Zope2.startup()\n \n         # At this point, Zope2.DB is set to the test database facade. This is\n@@ -152,7 +156,7 @@ def tearDownApp(self):\n \n         import Zope2\n         import ZServer.Zope2\n-        Zope2.app()._p_jar.close()\n+        ZServer.Zope2.app()._p_jar.close()\n \n         ZServer.Zope2._began_startup = 0\n \n@@ -184,6 +188,37 @@ def tearDownApp(self):\n             d[0] = {}\n             ZPublisher.Publish.get_module_info.func_defaults = tuple(d)\n \n+    def setUpBasicProducts(self):\n+        """Install a minimal set of products required for Zope 2.\n+        """\n+\n+        with zopeApp() as app:\n+            installProduct(app, \'Products.PluginIndexes\')\n+            installProduct(app, \'Products.OFSP\')\n+\n+    def tearDownBasicProducts(self):\n+        """Tear down the minimal set of products\n+        """\n+\n+        with zopeApp() as app:\n+            uninstallProduct(app, \'Products.PluginIndexes\')\n+            uninstallProduct(app, \'Products.OFSP\')\n+\n+        # It\'s possible for Five\'s _register_monkies and _meta_type_regs\n+        # global variables to contain duplicates. This causes an unecessary\n+        # error in the LayerCleanup layer\'s tear-down. Guard against that\n+        # here\n+\n+        try:\n+            from OFS import metaconfigure\n+        except ImportError:\n+            # Zope <= 2.12\n+            from Products.Five import fiveconfigure as metaconfigure\n+        metaconfigure._register_monkies = list(\n+            set(metaconfigure._register_monkies))\n+        metaconfigure._meta_type_regs = list(\n+            set(metaconfigure._meta_type_regs))\n+\n \n STARTUP = Startup()\n \n@@ -217,6 +252,48 @@ class MyFixture(Layer):\n \n     defaultBases = (STARTUP,)\n \n+    def testSetUp(self):\n+        from ZServer import Zope2\n+\n+        # Open a new app and save it as the resource ``app``.\n+\n+        environ = {\n+            \'SERVER_NAME\': self[\'host\'],\n+            \'SERVER_PORT\': str(self[\'port\']),\n+        }\n+\n+        app = addRequestContainer(Zope2.app(), environ=environ)\n+        request = app.REQUEST\n+        request[\'PARENTS\'] = [app]\n+\n+        # Make sure we have a zope.globalrequest request\n+        try:\n+            from zope.globalrequest import setRequest\n+            setRequest(request)\n+        except ImportError:\n+            pass\n+\n+        # Start a transaction\n+        transaction.begin()\n+\n+        self._original_commit = transaction.commit\n+\n+        def you_broke_it():\n+            raise TestIsolationBroken("""You are in a Test Layer\n+(IntegrationTesting) that is fast by just aborting transactions between each\n+test.  You just committed something. That breaks the test isolation.  So I stop\n+here and let you fix it.""")\n+\n+        # XXX TODO Restore this.\n+        # Temporarily allow commits in integration tests.\n+        # Plone 5.1 still uses plone.testing 4.1.1, and for Zope 4 integration\n+        # we want master, but without the commit-breaking for now.\n+        # transaction.commit = you_broke_it\n+\n+        # Save resources for tests to access\n+        self[\'app\'] = app\n+        self[\'request\'] = request\n+\n \n INTEGRATION_TESTING = IntegrationTesting()\n \n@@ -247,6 +324,42 @@ class MyFixture(Layer):\n \n     defaultBases = (STARTUP,)\n \n+    def testSetUp(self):\n+        from ZServer import Zope2\n+\n+        # Override zodbDB from the layer setup. Since it was set up by\n+        # this layer, we can\'t just assign a new shadow. We therefore keep\n+        # track of the original so that we can restore it on tear-down.\n+\n+        self[\'zodbDB\'] = zodb.stackDemoStorage(\n+            self.get(\'zodbDB\'),\n+            name=\'FunctionalTest\')\n+\n+        # Save the app\n+\n+        environ = {\n+            \'SERVER_NAME\': self[\'host\'],\n+            \'SERVER_PORT\': str(self[\'port\']),\n+        }\n+\n+        app = addRequestContainer(Zope2.app(), environ=environ)\n+        request = app.REQUEST\n+        request[\'PARENTS\'] = [app]\n+\n+        # Make sure we have a zope.globalrequest request\n+        try:\n+            from zope.globalrequest import setRequest\n+            setRequest(request)\n+        except ImportError:\n+            pass\n+\n+        # Start a transaction\n+        transaction.begin()\n+\n+        # Save resources for the test\n+        self[\'app\'] = app\n+        self[\'request\'] = request\n+\n \n FUNCTIONAL_TESTING = FunctionalTesting()\n \n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.testing/commit/4e473d91fada6151990f1f482bee7d1044490b5b

Disallow commits in integration test

Files changed:
M src/plone/testing/zope.py

b'diff --git a/src/plone/testing/zope.py b/src/plone/testing/zope.py\nindex 63e02a4..787e333 100644\n--- a/src/plone/testing/zope.py\n+++ b/src/plone/testing/zope.py\n@@ -742,11 +742,8 @@ def you_broke_it():\n test.  You just committed something. That breaks the test isolation.  So I stop\n here and let you fix it.""")\n \n-        # XXX TODO Restore this.\n-        # Temporarily allow commits in integration tests.\n-        # Plone 5.1 still uses plone.testing 4.1.1, and for Zope 4 integration\n-        # we want master, but without the commit-breaking for now.\n-        # transaction.commit = you_broke_it\n+        # Prevent commits in integration tests which breaks test isolation.\n+        transaction.commit = you_broke_it\n \n         # Save resources for tests to access\n         self[\'app\'] = app\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T14:30:22+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.testing/commit/04e94d7d886998bf379eaf3d2ecf89df7b3ce790

InitializeClass was moved to from AccessControl.class_init

Files changed:
M src/plone/testing/zope.py

b'diff --git a/src/plone/testing/zope.py b/src/plone/testing/zope.py\nindex 787e333..7e72504 100644\n--- a/src/plone/testing/zope.py\n+++ b/src/plone/testing/zope.py\n@@ -43,7 +43,7 @@ def installProduct(app, productName, quiet=False, multiinit=False):\n     Note that products\' ZCML is *not* loaded automatically, even if the\n     product is in the Products namespace.\n     """\n-    from App.class_init import InitializeClass\n+    from AccessControl.class_init import InitializeClass\n     from OFS.Application import get_folder_permissions\n     from OFS.Application import get_products\n     from OFS.Application import install_package\n@@ -105,7 +105,7 @@ def uninstallProduct(app, productName, quiet=False):\n \n     # from OFS.Folder import Folder\n     # from OFS.Application import get_folder_permissions\n-    # from App.class_init import InitializeClass\n+    # from AccessControl.class_init import InitializeClass\n \n     from OFS.Application import Application, get_products\n \n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-07-03T15:39:33+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.testing/commit/40d4a34981d0ef23cbcc9958893a621c62c2a3b8

remove zserver support tests on py3.6

Files changed:
M .travis.yml
M tox.ini

b'diff --git a/.travis.yml b/.travis.yml\nindex 76db166..34eabb1 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -17,13 +17,9 @@ matrix:\n           env: TOXENV=py35\n         - python: "3.6"\n           env: TOXENV=py36\n-        - python: "3.6"\n-          env: TOXENV=py36-zserver\n         - python: "3.7-dev"\n           env: TOXENV=py37\n     allow_failures:\n-        - python: "3.6"\n-          env: TOXENV=py36-zserver\n         - python: "3.7-dev"\n           env: TOXENV=py37\n \ndiff --git a/tox.ini b/tox.ini\nindex 4a57ee9..4cf753d 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -3,7 +3,6 @@ envlist =\n     py27,\n     py27-zserver,\n     py36,\n-#    py36-zserver,\n     coverage-report,\n #    docs,\n     lint-py27,\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-09-26T11:09:46+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.testing/commit/e828ed4ca347406c1ef6766acfeee68ee2a1f05f

also disallow commits in zserver.Integrationtesting

Files changed:
M src/plone/testing/zserver.py

b'diff --git a/src/plone/testing/zserver.py b/src/plone/testing/zserver.py\nindex 8f0a725..56d81c4 100644\n--- a/src/plone/testing/zserver.py\n+++ b/src/plone/testing/zserver.py\n@@ -284,11 +284,8 @@ def you_broke_it():\n test.  You just committed something. That breaks the test isolation.  So I stop\n here and let you fix it.""")\n \n-        # XXX TODO Restore this.\n-        # Temporarily allow commits in integration tests.\n-        # Plone 5.1 still uses plone.testing 4.1.1, and for Zope 4 integration\n-        # we want master, but without the commit-breaking for now.\n-        # transaction.commit = you_broke_it\n+        # Prevent commits in integration tests which breaks test isolation.\n+        transaction.commit = you_broke_it\n \n         # Save resources for tests to access\n         self[\'app\'] = app\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-09-30T11:56:04-04:00
Author: David Glick (davisagli) <david@glicksoftware.com>
Commit: https://github.com/plone/plone.testing/commit/05c173e7b2462f032b448fdfbfe5e14d93cca658

Fix check for port

Files changed:
M src/plone/testing/zope.rst

b"diff --git a/src/plone/testing/zope.rst b/src/plone/testing/zope.rst\nindex 15f41b5..e4c05cd 100644\n--- a/src/plone/testing/zope.rst\n+++ b/src/plone/testing/zope.rst\n@@ -469,7 +469,7 @@ After layer setup, the resources ``host`` and ``port`` are available, and indica\n \n     >>> port = zope.WSGI_SERVER['port']\n     >>> import os\n-    >>> port == int(os.environ.get('WSGI_SERVER_PORT', 55001))\n+    >>> port == int(os.environ.get('WSGI_SERVER_PORT', os.environ.get('ZSERVER_PORT', 55001)))\n     True\n \n Let's now simulate a test.\n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-10-02T22:09:29-04:00
Author: David Glick (davisagli) <david@glicksoftware.com>
Commit: https://github.com/plone/plone.testing/commit/58f98c3c90fd82f88284c6fd02635bfe62eb5919

Fix teardown of the security.Checkers layer.

This was a fun one.
The zope.security.checker module has a module-global _checkers dict.
This layer tries to manage it as a stack, where pushing to the stack
copies the current dict and popping from the stack sets
zope.security.checker._checkers back to the copy that was stored.

But, it turns out that _checkers is imported from a C extension module,
and that module keeps a pointer to the original dict that is not
affected by the plone.testing stack pop. So subsequent lookups continue
to use the old dict.

To fix this I changed the stack pop operation to clear and update the
dict instead of replacing it, so that the pointer in the C module
is still valid.

There was a similar but different problem with the pure-Python implementation:
it sets _getChecker = _checkers.get initially and _getChecker was not updated
by the stack pop. My workaround should also deal with this case.

Files changed:
M CHANGES.rst
M src/plone/testing/security.py

b"diff --git a/CHANGES.rst b/CHANGES.rst\nindex 81f0c4d..a57cf13 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -27,6 +27,9 @@ Bug fixes:\n \n - Fix the Zope exception hook when using the ZServer layer.\n \n+- Fix teardown of the ``plone.testing.security.Checkers`` layer.\n+  It was not properly restoring zope.security's ``_checkers`` dict.\n+\n \n 6.0.0 (2018-02-05)\n ------------------\ndiff --git a/src/plone/testing/security.py b/src/plone/testing/security.py\nindex be95caf..b4ba7e3 100644\n--- a/src/plone/testing/security.py\n+++ b/src/plone/testing/security.py\n@@ -31,7 +31,8 @@ def popCheckers():\n \n     from zope.security import checker\n \n-    checker._checkers = _checkersStack.pop()\n+    checker._checkers.clear()\n+    checker._checkers.update(_checkersStack.pop())\n \n \n class Checkers(Layer):\n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-10-03T14:28:06+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.testing/commit/9eb1cc1878fae5ba938b2e5c02fa65fad27ffdb9

complex merge conflict resolving

Files changed:
M CHANGES.rst
M buildout.cfg
M src/plone/testing/publisher.rst
M src/plone/testing/zca.rst
M src/plone/testing/zope.py
M src/plone/testing/zope.rst
M src/plone/testing/zserver.py
M src/plone/testing/zserver.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex a57cf13..9877e6b 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -13,6 +13,9 @@ Breaking changes:\n \n - ``plone.testing.z2`` now only contains a no-op FTPServer layer because FTP is not supported by WSGI.\n   If you really need it, import it from ``plone.testing.zserver`` but this will not work on Python 3.\n+- Default to picking a dynamical port for ZServer layers instead of a static\n+  default port.\n+  [Rotonen]\n \n New features:\n \n@@ -23,6 +26,12 @@ New features:\n \n Bug fixes:\n \n+- Pinned ZODB to < 5.4.0 for testing to avoid flaky doctest layer teardowns.\n+  [Rotonen]\n+\n+- Loosened doctest assertions to keep up with Zope-side changes.\n+  [Rotonen]\n+\n - Fix most of the code smells Jenkins complains about.\n \n - Fix the Zope exception hook when using the ZServer layer.\ndiff --git a/buildout.cfg b/buildout.cfg\nindex 5e195ed..9fad19d 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -14,6 +14,9 @@ prefer-final = false\n setuptools =\n zc.buildout =\n plone.testing =\n+# From 2018-10-02\n+# Please remove this pinning after we get on top of the ZODB issues!\n+ZODB = < 5.4.0\n \n [test]\n recipe = collective.xmltestreport\ndiff --git a/src/plone/testing/publisher.rst b/src/plone/testing/publisher.rst\nindex d96c393..f39daa0 100644\n--- a/src/plone/testing/publisher.rst\n+++ b/src/plone/testing/publisher.rst\n@@ -27,23 +27,24 @@ Before the test, we cannot use e.g.\n the ``<permission />`` or ``<browser:view />`` directives without loading the necessary ``meta.zcml`` files.::\n \n     >>> from zope.configuration import xmlconfig\n-    >>> xmlconfig.string("""\\\n-    ... <configure package="plone.testing"\n-    ...     xmlns="http://namespaces.zope.org/zope"\n-    ...     xmlns:browser="http://namespaces.zope.org/browser"\n-    ...     i18n_domain="plone.testing.tests">\n-    ...     <permission id="plone.testing.Test" title="plone.testing: Test" />\n-    ...     <browser:view\n-    ...         for="*"\n-    ...         name="plone.testing-test"\n-    ...         class="plone.testing.tests.DummyView"\n-    ...         permission="zope.Public"\n-    ...         />\n-    ... </configure>""")\n-    Traceback (most recent call last):\n-    ...\n-    ZopeXMLConfigurationError: File "<string>", line 5.4\n-        ConfigurationError: (\'Unknown directive\', \'http://namespaces.zope.org/zope\', \'permission\')\n+    >>> from zope.configuration.exceptions import ConfigurationError\n+    >>> try:\n+    ...     xmlconfig.string("""\\\n+    ...     <configure package="plone.testing"\n+    ...         xmlns="http://namespaces.zope.org/zope"\n+    ...         xmlns:browser="http://namespaces.zope.org/browser"\n+    ...         i18n_domain="plone.testing.tests">\n+    ...         <permission id="plone.testing.Test" title="plone.testing: Test" />\n+    ...         <browser:view\n+    ...             for="*"\n+    ...             name="plone.testing-test"\n+    ...             class="plone.testing.tests.DummyView"\n+    ...             permission="zope.Public"\n+    ...             />\n+    ...     </configure>""")\n+    ... except ConfigurationError as e:\n+    ...     True\n+    True\n \n Layer setup creates a configuration context we can use to load further configuration.::\n \ndiff --git a/src/plone/testing/zca.rst b/src/plone/testing/zca.rst\nindex 480f6ac..5c1f5ee 100644\n--- a/src/plone/testing/zca.rst\n+++ b/src/plone/testing/zca.rst\n@@ -224,14 +224,15 @@ It extends the ``LAYER_CLEANUP`` layer.::\n Before the test, we cannot use e.g. a ``<utility />`` directive without loading the necessary ``meta.zcml`` files.::\n \n     >>> from zope.configuration import xmlconfig\n-    >>> xmlconfig.string("""\\\n-    ... <configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">\n-    ...     <utility factory=".tests.DummyUtility" provides="zope.interface.Interface" name="test-dummy" />\n-    ... </configure>""")\n-    Traceback (most recent call last):\n-    ...\n-    ZopeXMLConfigurationError: File "<string>", line 2.4\n-        ConfigurationError: (\'Unknown directive\', \'http://namespaces.zope.org/zope\', \'utility\')\n+    >>> from zope.configuration.exceptions import ConfigurationError\n+    >>> try:\n+    ...     xmlconfig.string("""\\\n+    ...     <configure package="plone.testing" xmlns="http://namespaces.zope.org/zope">\n+    ...         <utility factory=".tests.DummyUtility" provides="zope.interface.Interface" name="test-dummy" />\n+    ...     </configure>""")\n+    ... except ConfigurationError as e:\n+    ...     True\n+    True\n \n Layer setup creates a configuration context we can use to load further configuration.::\n \ndiff --git a/src/plone/testing/zope.py b/src/plone/testing/zope.py\nindex 7e72504..aeec4f1 100644\n--- a/src/plone/testing/zope.py\n+++ b/src/plone/testing/zope.py\n@@ -895,9 +895,9 @@ class WSGIServer(Layer):\n \n     timeout = 5\n     host = os.environ.get(\'WSGI_SERVER_HOST\',\n-                          os.environ.get(\'ZSERVER_HOST\', \'localhost\'))\n+                          os.environ.get(\'ZSERVER_HOST\', \'\'))\n     port = int(os.environ.get(\'WSGI_SERVER_PORT\',\n-                              os.environ.get(\'ZSERVER_PORT\', 55001)))\n+                              os.environ.get(\'ZSERVER_PORT\', 0)))\n     pipeline = [\n         (\'Zope\', \'paste.filter_app_factory\', \'httpexceptions\', {}),\n     ]\n@@ -918,8 +918,13 @@ def setUpServer(self):\n         app = self.make_wsgi_app()\n         self.server = wsgiref.simple_server.make_server(\n             self.host, self.port, app, handler_class=NoLogWSGIRequestHandler)\n-        # allow to choose a random port using 0 as port number:\n-        self.port = self.server.server_port\n+        # If we dynamically set the host/port, we want to reset it to localhost\n+        # Otherwise this will depend on, for example, the local network setup\n+        if self.host in (\'\', \'0.0.0.0\', \'127.0.0.1\', ):\n+            self.server.server_name = \'localhost\'\n+        # Refresh the hostname and port in case we dynamically picked them\n+        self[\'host\'] = self.host = self.server.server_name\n+        self[\'port\'] = self.port = self.server.server_port\n \n         self.thread = threading.Thread(target=self.serve)\n         self.thread.daemon = True\ndiff --git a/src/plone/testing/zope.rst b/src/plone/testing/zope.rst\nindex e4c05cd..61cdb79 100644\n--- a/src/plone/testing/zope.rst\n+++ b/src/plone/testing/zope.rst\n@@ -468,9 +468,6 @@ After layer setup, the resources ``host`` and ``port`` are available, and indica\n     \'localhost\'\n \n     >>> port = zope.WSGI_SERVER[\'port\']\n-    >>> import os\n-    >>> port == int(os.environ.get(\'WSGI_SERVER_PORT\', os.environ.get(\'ZSERVER_PORT\', 55001)))\n-    True\n \n Let\'s now simulate a test.\n Test setup does nothing beyond what the base layers do.::\ndiff --git a/src/plone/testing/zserver.py b/src/plone/testing/zserver.py\nindex 56d81c4..e719ddb 100644\n--- a/src/plone/testing/zserver.py\n+++ b/src/plone/testing/zserver.py\n@@ -380,8 +380,8 @@ class ZServer(Layer):\n \n     defaultBases = (STARTUP,)\n \n-    host = os.environ.get(\'ZSERVER_HOST\', \'localhost\')\n-    port = int(os.environ.get(\'ZSERVER_PORT\', 55001))\n+    host = os.environ.get(\'ZSERVER_HOST\', \'\')\n+    port = int(os.environ.get(\'ZSERVER_PORT\', 0))\n     timeout = 5.0\n     log = None\n \n@@ -420,7 +420,6 @@ def tearDown(self):\n     def setUpServer(self):\n         """Create a ZServer server instance and save it in self.zserver\n         """\n-\n         from ZServer import zhttp_server, zhttp_handler, logger\n         from StringIO import StringIO\n \n@@ -434,7 +433,17 @@ def setUpServer(self):\n             ip=self.host,\n             port=self.port,\n             resolver=None,\n-            logger_object=zopeLog)\n+            logger_object=zopeLog,\n+        )\n+\n+        # If we dynamically set the host/port, we want to reset it to localhost\n+        # Otherwise this will depend on, for example, the local network setup\n+        if self.host in (\'\', \'0.0.0.0\', \'127.0.0.1\', ):\n+            server.server_name = \'localhost\'\n+        # Refresh the hostname and port in case we dynamically picked them\n+        self[\'host\'] = self.host = server.server_name\n+        self[\'port\'] = self.port = server.server_port\n+\n         zhttpHandler = zhttp_handler(module=\'Zope2\', uri_base=\'\')\n         server.install_handler(zhttpHandler)\n \n@@ -488,8 +497,8 @@ class FTPServer(ZServer):\n \n     defaultBases = (STARTUP,)\n \n-    host = os.environ.get(\'FTPSERVER_HOST\', \'localhost\')\n-    port = int(os.environ.get(\'FTPSERVER_PORT\', 55002))\n+    host = os.environ.get(\'FTPSERVER_HOST\', \'\')\n+    port = int(os.environ.get(\'FTPSERVER_PORT\', 0))\n     threads = 1\n     timeout = 5.0\n     log = None\n@@ -512,7 +521,18 @@ def setUpServer(self):\n             \'Zope2\',\n             ip=self.host,\n             port=self.port,\n-            logger_object=zopeLog)\n+            logger_object=zopeLog,\n+        )\n+        # Refresh the hostname and port in case we dynamically picked them\n+        self.host, self.port = self.ftpServer.socket.getsockname()\n+        # If we dynamically set the host/port, we want to reset it to localhost\n+        # Otherwise this will depend on, for example, the local network setup\n+        if self.host in (\'\', \'0.0.0.0\', \'127.0.0.1\', ):\n+            self.host = \'localhost\'\n+            self.ftpServer.hostname = \'localhost\'\n+            self.ftpServer.ip = \'127.0.0.1\'\n+        self[\'host\'] = self.host\n+        self[\'port\'] = self.port\n \n     def tearDownServer(self):\n         """Close the FTPServer socket\ndiff --git a/src/plone/testing/zserver.rst b/src/plone/testing/zserver.rst\nindex 42ac5cf..df94d1c 100644\n--- a/src/plone/testing/zserver.rst\n+++ b/src/plone/testing/zserver.rst\n@@ -381,8 +381,10 @@ We can now view this via the test browser:::\n \n     >>> browser.open(app.absolute_url() + \'/folder1\')\n \n-    >>> \'folder1\' in browser.contents\n-    True\n+    >>> browser.contents.replace(\'"\', \'\').replace("\'", "")\n+    \'<Folder ...\'\n+\n+The __repr__ of Zope objects is not stable anymore.\n \n The test browser integration converts the URL into a request and passes control to Zope\'s publisher.\n Let\'s check that query strings are available for input processing:::\n@@ -466,13 +468,7 @@ The ``ZSERVER`` layer provides a ``FunctionalTesting`` layer that has ``ZSERVER_\n After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n \n     >>> host = zserver.ZSERVER[\'host\']\n-    >>> host\n-    \'localhost\'\n-\n     >>> port = zserver.ZSERVER[\'port\']\n-    >>> import os\n-    >>> port == int(os.environ.get(\'ZSERVER_PORT\', 55001))\n-    True\n \n Let\'s now simulate a test.\n Test setup does nothing beyond what the base layers do.::\n@@ -500,10 +496,12 @@ We can now look for this new object through the server.::\n \n     >>> import urllib2\n     >>> conn = urllib2.urlopen(app_url + \'/folder1\', timeout=5)\n-    >>> print(conn.read())\n-    <Folder at folder1>\n+    >>> conn.read().replace(\'"\', \'\').replace("\'", "")\n+    \'<Folder ...\'\n     >>> conn.close()\n \n+The __repr__ of Zope objects is not stable anymore.\n+\n Test tear-down does nothing beyond what the base layers do.::\n \n     >>> zserver.ZSERVER.testTearDown()\n@@ -570,13 +568,7 @@ The ``FTP_SERVER`` layer is based on ``FTP_SERVER_FIXTURE``, using the ``Functio\n After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n \n     >>> host = zserver.FTP_SERVER[\'host\']\n-    >>> host\n-    \'localhost\'\n-\n     >>> port = zserver.FTP_SERVER[\'port\']\n-    >>> import os\n-    >>> port == int(os.environ.get(\'FTPSERVER_PORT\', 55002))\n-    True\n \n Let\'s now simulate a test.\n Test setup does nothing beyond what the base layers do.::\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-10-03T20:00:14-04:00
Author: David Glick (davisagli) <david@glicksoftware.com>
Commit: https://github.com/plone/plone.testing/commit/c6734626140d71f766058dbc8806893d904e90a6

Add what the default host is on my laptop

Files changed:
M src/plone/testing/zope.py

b"diff --git a/src/plone/testing/zope.py b/src/plone/testing/zope.py\nindex aeec4f1..c8d0ee9 100644\n--- a/src/plone/testing/zope.py\n+++ b/src/plone/testing/zope.py\n@@ -920,7 +920,7 @@ def setUpServer(self):\n             self.host, self.port, app, handler_class=NoLogWSGIRequestHandler)\n         # If we dynamically set the host/port, we want to reset it to localhost\n         # Otherwise this will depend on, for example, the local network setup\n-        if self.host in ('', '0.0.0.0', '127.0.0.1', ):\n+        if self.host in ('', '0.0.0.0', '127.0.0.1', '1.0.0.127.in-addr.arpa'):\n             self.server.server_name = 'localhost'\n         # Refresh the hostname and port in case we dynamically picked them\n         self['host'] = self.host = self.server.server_name\n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-10-03T20:09:50-04:00
Author: David Glick (davisagli) <david@glicksoftware.com>
Commit: https://github.com/plone/plone.testing/commit/6be1638fa5f625b5bf232f338b1914fecaaf2e31

fix

Files changed:
M src/plone/testing/zope.py

b"diff --git a/src/plone/testing/zope.py b/src/plone/testing/zope.py\nindex c8d0ee9..37ad25d 100644\n--- a/src/plone/testing/zope.py\n+++ b/src/plone/testing/zope.py\n@@ -920,7 +920,7 @@ def setUpServer(self):\n             self.host, self.port, app, handler_class=NoLogWSGIRequestHandler)\n         # If we dynamically set the host/port, we want to reset it to localhost\n         # Otherwise this will depend on, for example, the local network setup\n-        if self.host in ('', '0.0.0.0', '127.0.0.1', '1.0.0.127.in-addr.arpa'):\n+        if self.host in ('', '0.0.0.0', '127.0.0.1', 'localhost'):\n             self.server.server_name = 'localhost'\n         # Refresh the hostname and port in case we dynamically picked them\n         self['host'] = self.host = self.server.server_name\n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-10-04T00:32:41-04:00
Author: David Glick (davisagli) <david@glicksoftware.com>
Commit: https://github.com/plone/plone.testing/commit/c7c080b2bec2469700c60f83e61dafe876fe1803

Try to clean up after ZopeLite

Files changed:
M src/plone/testing/zope.py

b'diff --git a/src/plone/testing/zope.py b/src/plone/testing/zope.py\nindex 37ad25d..3e921af 100644\n--- a/src/plone/testing/zope.py\n+++ b/src/plone/testing/zope.py\n@@ -547,10 +547,23 @@ def setUpApp(self):\n             del config.testinghome\n             App.config.setConfiguration(config)\n \n+        # Clean up after ZopeLite layer\n+        import ZPublisher.WSGIPublisher\n+        ZPublisher.WSGIPublisher._MODULES.clear()\n+        self._publisher_globals = {\n+            \'load_app\': ZPublisher.WSGIPublisher.load_app\n+        }\n+        if hasattr(ZPublisher.WSGIPublisher, \'__old_load_app__\'):\n+            old_load_app = ZPublisher.WSGIPublisher.__old_load_app__\n+            ZPublisher.WSGIPublisher.load_app = old_load_app\n+            self._publisher_globals[\'__old_load_app__\'] = old_load_app\n+            del ZPublisher.WSGIPublisher.__old_load_app__\n+\n         # This uses the DB from the dbtab, as configured in setUpDatabase().\n         # That DB then gets stored as Zope2.DB and becomes the default.\n \n         import Zope2\n+        Zope2._began_startup = 0\n         Zope2.startup_wsgi()\n \n         # At this point, Zope2.DB is set to the test database facade. This is\n@@ -585,6 +598,8 @@ def tearDownApp(self):\n \n         import ZPublisher.WSGIPublisher\n         ZPublisher.WSGIPublisher._MODULES.clear()\n+        for k, v in self._publisher_globals.items():\n+            setattr(ZPublisher.WSGIPublisher, k, v)\n \n     def setUpBasicProducts(self):\n         """Install a minimal set of products required for Zope 2.\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-10-07T10:48:41-04:00
Author: David Glick (davisagli) <david@glicksoftware.com>
Commit: https://github.com/plone/plone.testing/commit/be3741b0d715dcf0db36b5f2e55b58ea80c0f715

Try using StopableWebServer (WebTest's wrapper of waitress)

Files changed:
M setup.py
M src/plone/testing/zope.py

b'diff --git a/setup.py b/setup.py\nindex d05e276..b2728ec 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -15,6 +15,7 @@\n ]\n \n tests_require = [\n+    \'WebTest\',\n     \'ZODB\',\n     \'Zope\',\n     \'zope.browsermenu\',\n@@ -31,6 +32,7 @@\n ]\n \n zope_requires = [\n+    \'WebTest\',\n     \'Zope\',\n     \'zope.component\',\n     \'zope.publisher\',\ndiff --git a/src/plone/testing/zope.py b/src/plone/testing/zope.py\nindex 3e921af..8657598 100644\n--- a/src/plone/testing/zope.py\n+++ b/src/plone/testing/zope.py\n@@ -8,6 +8,7 @@\n from plone.testing import zodb\n from plone.testing._z2_testbrowser import Browser  # noqa\n from Testing.ZopeTestCase.ZopeLite import _patched as ZOPETESTCASEALERT\n+from webtest.http import StopableWSGIServer\n from Zope2.App.schema import Zope2VocabularyRegistry\n from zope.schema.vocabulary import getVocabularyRegistry\n from zope.schema.vocabulary import setVocabularyRegistry\n@@ -17,9 +18,7 @@\n import pkg_resources\n import shutil\n import tempfile\n-import threading\n import transaction\n-import wsgiref.simple_server\n import Zope2.Startup.run\n import ZPublisher.WSGIPublisher\n \n@@ -884,16 +883,6 @@ def testTearDown(self):\n WSGI_LOG_REQUEST = \'WSGI_REQUEST_LOGGING\' in os.environ\n \n \n-class NoLogWSGIRequestHandler(wsgiref.simple_server.WSGIRequestHandler):\n-    """Less chatty WSGIRequestHandler."""\n-\n-    def log_request(self, *args):\n-        """Print the request only on the console if requested."""\n-        if WSGI_LOG_REQUEST:\n-            wsgiref.simple_server.WSGIRequestHandler.log_request(\n-                self, *args)  # old-style class :-/\n-\n-\n class WSGIServer(Layer):\n     """Start a WSGI server that accesses the fixture managed by the\n     ``STARTUP`` layer.\n@@ -910,9 +899,9 @@ class WSGIServer(Layer):\n \n     timeout = 5\n     host = os.environ.get(\'WSGI_SERVER_HOST\',\n-                          os.environ.get(\'ZSERVER_HOST\', \'\'))\n-    port = int(os.environ.get(\'WSGI_SERVER_PORT\',\n-                              os.environ.get(\'ZSERVER_PORT\', 0)))\n+                          os.environ.get(\'ZSERVER_HOST\'))\n+    port = os.environ.get(\'WSGI_SERVER_PORT\',\n+                          os.environ.get(\'ZSERVER_PORT\'))\n     pipeline = [\n         (\'Zope\', \'paste.filter_app_factory\', \'httpexceptions\', {}),\n     ]\n@@ -931,29 +920,24 @@ def setUpServer(self):\n         """Create a WSGI server instance and save it in self.server.\n         """\n         app = self.make_wsgi_app()\n-        self.server = wsgiref.simple_server.make_server(\n-            self.host, self.port, app, handler_class=NoLogWSGIRequestHandler)\n+        kwargs = {}\n+        if self.host is not None:\n+            kwargs[\'host\'] = self.host\n+        if self.port is not None:\n+            kwargs[\'port\'] = int(self.port)\n+        self.server = StopableWSGIServer.create(app, **kwargs)\n         # If we dynamically set the host/port, we want to reset it to localhost\n         # Otherwise this will depend on, for example, the local network setup\n-        if self.host in (\'\', \'0.0.0.0\', \'127.0.0.1\', \'localhost\'):\n-            self.server.server_name = \'localhost\'\n+        if self.host in (None, \'0.0.0.0\', \'127.0.0.1\', \'localhost\'):\n+            self.server.effective_host = \'localhost\'\n         # Refresh the hostname and port in case we dynamically picked them\n-        self[\'host\'] = self.host = self.server.server_name\n-        self[\'port\'] = self.port = self.server.server_port\n-\n-        self.thread = threading.Thread(target=self.serve)\n-        self.thread.daemon = True\n-        self.thread.start()\n+        self[\'host\'] = self.host = self.server.effective_host\n+        self[\'port\'] = self.port = int(self.server.effective_port)\n \n     def tearDownServer(self):\n         """Close the server socket and clean up.\n         """\n         self.server.shutdown()\n-        self.server.server_close()\n-        self.thread.join(self.timeout)\n-        if self.thread.isAlive():\n-            raise RuntimeError(\'WSGI server could not be shut down\')\n-\n         shutil.rmtree(self._wsgi_conf_dir)\n \n     def make_wsgi_app(self):\n@@ -968,9 +952,6 @@ def make_wsgi_app(self):\n             app = entrypoint.load()(app, global_config, **extra)\n         return app\n \n-    def serve(self):\n-        self.server.serve_forever()\n-\n     def _get_zope_conf(self, dir):\n         fd, path = tempfile.mkstemp(dir=dir)\n         with os.fdopen(fd, \'w\') as zope_conf:\n'

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-10-17T11:03:34+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.testing/commit/d634cb66a1f96076fde071e1dae5f1c4f3fda0c9

merge master

Files changed:
M CHANGES.rst
M buildout.cfg
M setup.py

b"diff --git a/CHANGES.rst b/CHANGES.rst\nindex 9877e6b..2a4d898 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -26,6 +26,21 @@ New features:\n \n Bug fixes:\n \n+- Explicitly depend on ZServer on the z2 extra.\n+  [Rotonen]\n+\n+\n+6.1.0 (2018-10-05)\n+------------------\n+\n+Breaking changes:\n+\n+- Default to picking a dynamical port for ZServer layers instead of a static\n+  default port.\n+  [Rotonen]\n+\n+Bug fixes:\n+\n - Pinned ZODB to < 5.4.0 for testing to avoid flaky doctest layer teardowns.\n   [Rotonen]\n \ndiff --git a/buildout.cfg b/buildout.cfg\nindex 9fad19d..b5e35ab 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -17,6 +17,12 @@ plone.testing =\n # From 2018-10-02\n # Please remove this pinning after we get on top of the ZODB issues!\n ZODB = < 5.4.0\n+# From 2018-10-06\n+# Please remove this pinning once the Zope 4.0 stack allows for it!\n+ZServer = < 4.0b3\n+# From 2018-10-06\n+# Please remove this pinning once collective.xmltestreport cuts a release!\n+zope.testrunner = < 4.9.0\n \n [test]\n recipe = collective.xmltestreport\ndiff --git a/setup.py b/setup.py\nindex b2728ec..97caeb8 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -5,7 +5,6 @@\n import os\n import os.path\n \n-\n version = '7.0.dev0'\n \n install_requires = [\n"

Repository: plone.testing


Branch: refs/heads/master
Date: 2018-10-17T11:04:48+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.testing/commit/c7de92448022ca97764e26a96a3af7482db68bfd

Merge pull request #50 from plone/py3_disallow_commits

Python 3.6 new

Files changed:
A .editorconfig
A src/plone/testing/zope.py
A src/plone/testing/zope.rst
A src/plone/testing/zserver.py
A src/plone/testing/zserver.rst
M .gitignore
M .travis.yml
M CHANGES.rst
M buildout.cfg
M setup.cfg
M setup.py
M src/plone/testing/README.rst
M src/plone/testing/__init__.py
M src/plone/testing/_z2_testbrowser.py
M src/plone/testing/layer.py
M src/plone/testing/layer.rst
M src/plone/testing/publisher.py
M src/plone/testing/security.py
M src/plone/testing/security.rst
M src/plone/testing/tests.py
M src/plone/testing/z2.py
M src/plone/testing/zca.py
M src/plone/testing/zca.rst
M tox.ini
D .isort.cfg
D src/plone/testing/z2.rst

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..512361c\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,36 @@\n+# EditorConfig Configurtaion file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.gitignore b/.gitignore\nindex fcfa901..8293885 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -2,6 +2,7 @@\n *.pyc\n *.tox\n .Python\n+.pytest_cache\n .coverage\n .installed.cfg\n bin\n@@ -13,3 +14,4 @@ include/\n lib/\n parts/\n pip-selfcheck.json\n+_build/\ndiff --git a/.isort.cfg b/.isort.cfg\ndeleted file mode 100644\nindex dd9f25d..0000000\n--- a/.isort.cfg\n+++ /dev/null\n@@ -1,6 +0,0 @@\n-[settings]\n-force_alphabetical_sort = True\n-force_single_line = True\n-lines_after_imports = 2\n-line_length = 200\n-not_skip = __init__.py\ndiff --git a/.travis.yml b/.travis.yml\nindex eb3bc5b..34eabb1 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -1,18 +1,40 @@\n language: python\n sudo: false\n-python:\n-    - 2.7\n+\n+matrix:\n+    include:\n+        - python: "2.7"\n+          env: TOXENV=lint-py27\n+        - python: "3.6"\n+          env: TOXENV=lint-py36\n+        - python: "2.7"\n+          env: TOXENV=py27\n+        - python: "2.7"\n+          env: TOXENV=py27-zserver\n+        - python: "3.4"\n+          env: TOXENV=py34\n+        - python: "3.5"\n+          env: TOXENV=py35\n+        - python: "3.6"\n+          env: TOXENV=py36\n+        - python: "3.7-dev"\n+          env: TOXENV=py37\n+    allow_failures:\n+        - python: "3.7-dev"\n+          env: TOXENV=py37\n+\n install:\n-    - pip install setuptools zc.buildout\n-    - pip install coveralls coverage\n-    - buildout bootstrap\n-    - buildout\n+    - travis_retry pip install -U pip setuptools\n+    - travis_retry pip install -U tox coveralls coverage\n+\n script:\n-    - coverage run bin/test -v1\n+    - travis_retry tox\n+\n after_success:\n     - coverage combine\n     - coveralls\n+\n+notifications:\n+    email: false\n cache:\n-  pip: true\n-  directories:\n-    - eggs/\n+    pip: true\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex 7869ed7..2a4d898 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -1,16 +1,28 @@\n Changelog\n =========\n \n-6.1.1 (unreleased)\n-------------------\n+7.0 (unreleased)\n+----------------\n \n Breaking changes:\n \n-- *add item here*\n+- ``plone.testing.z2`` is now a BBB shim for ``plone.testing.zope``,\n+- ``plone.testing.z2`` is now a BBB shim for ``plone.testing.wsgi``,\n+  thus it switches the tests to use WSGI.\n+  If you absolutely want to keep using ZServer please import from ``plone.testing.zserver``.\n+\n+- ``plone.testing.z2`` now only contains a no-op FTPServer layer because FTP is not supported by WSGI.\n+  If you really need it, import it from ``plone.testing.zserver`` but this will not work on Python 3.\n+- Default to picking a dynamical port for ZServer layers instead of a static\n+  default port.\n+  [Rotonen]\n \n New features:\n \n-- *add item here*\n+- Make ``ZServer`` an optional dependency.\n+\n+- Add support for Python 3.6.\n+  [rudaporto, icemac]\n \n Bug fixes:\n \n@@ -39,6 +51,9 @@ Bug fixes:\n \n - Fix the Zope exception hook when using the ZServer layer.\n \n+- Fix teardown of the ``plone.testing.security.Checkers`` layer.\n+  It was not properly restoring zope.security\'s ``_checkers`` dict.\n+\n \n 6.0.0 (2018-02-05)\n ------------------\n@@ -58,8 +73,7 @@ Bug fixes:\n 5.1.1 (2017-04-19)\n ------------------\n \n-- Do not break on import of ``plone.testing.z2`` when using\n-  `zope.testbrowser` >= 5.0 which no longer depends on `mechanize`.\n+- Do not break on import of ``plone.testing.z2`` when using `zope.testbrowser` >= 5.0 which no longer depends on `mechanize`.\n \n \n 5.1 (2017-04-13)\n@@ -115,8 +129,7 @@ Fixes:\n - PEP 8.\n   [thet]\n \n-- Depend on zope.testrunner, which was moved out from\n-  zope.testing.testrunner.\n+- Depend on zope.testrunner, which was moved out from zope.testing.testrunner.\n   [thet]\n \n - Add support for Zope 4.\n@@ -126,7 +139,7 @@ Fixes:\n 4.0.15 (2015-08-14)\n -------------------\n \n-- Prevent exception masking in finally clause of zopeApp context\n+- Prevent exception masking in finally clause of zopeApp context.\n   [do3cc]\n \n \n@@ -136,8 +149,7 @@ Fixes:\n - Rerelease for clarity due to double release of 4.0.13.\n   [maurits]\n \n-- Added ``multiinit``-parameter to z2.installProduct\n-  to allow multiple initialize methods for a package\n+- Added ``multiinit``-parameter to z2.installProduct to allow multiple initialize methods for a package\n   [tomgross]\n \n \n@@ -154,11 +166,11 @@ Fixes:\n 4.0.12 (2014-09-07)\n -------------------\n \n-- Fixed AttributeError when importing ``plone.testing.z2`` if\n-  ``zope.testbrowser`` 4.x is used but not ``zope.app.testing``. [icemac]\n+- Fixed AttributeError when importing ``plone.testing.z2`` if ``zope.testbrowser`` 4.x is used but not ``zope.app.testing``.\n+  [icemac]\n \n-- Broke dependency on `unittest2` for Python 2.7+ as all features of\n-  `unittest2` are integrated in `unittest` there. [icemac]\n+- Broke dependency on `unittest2` for Python 2.7+ as all features of `unittest2` are integrated in `unittest` there.\n+  [icemac]\n \n \n 4.0.11 (2014-02-22)\n@@ -171,8 +183,8 @@ Fixes:\n 4.0.10 (2014-02-11)\n -------------------\n \n-- Read \'FTPSERVER_HOST\' and \'FTPSERVER_PORT\' from the environment variables if\n-  possible. This allows us to run tests in parallel on CI servers.\n+- Read \'FTPSERVER_HOST\' and \'FTPSERVER_PORT\' from the environment variables if possible.\n+  This allows us to run tests in parallel on CI servers.\n   [timo]\n \n \n@@ -207,18 +219,17 @@ Fixes:\n 4.0.5 (2012-10-15)\n ------------------\n \n-- Fixed an issue where a query string would be unquoted twice; once\n-  while setting up the HTTP request and once in the handler (the\n-  publisher).\n+- Fixed an issue where a query string would be unquoted twice;\n+  once while setting up the HTTP request and once in the handler (the publisher).\n   [malthe]\n \n \n 4.0.4 (2012-08-04)\n ------------------\n \n-- Fixed the cache reset code. In some situations the function does not\n-  have any defaults, so we shouldn\'t try to clear out the app\n-  reference.\n+- Fixed the cache reset code.\n+  In some situations the function does not have any defaults,\n+  so we shouldn\'t try to clear out the app reference.\n   [malthe]\n \n \ndiff --git a/buildout.cfg b/buildout.cfg\nindex b0cf46f..b5e35ab 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -1,5 +1,12 @@\n [buildout]\n-parts = coverage test report report-xml\n+extends =\n+    https://raw.githubusercontent.com/plone/buildout.coredev/5.2/versions.cfg\n+parts =\n+    coverage\n+    test\n+    report\n+    report-xml\n+\n develop = .\n prefer-final = false\n \ndiff --git a/setup.cfg b/setup.cfg\nindex c2c94bb..2bce1d9 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,5 +1,10 @@\n-[bdist_wheel]\n-universal = 1\n+[build_sphinx]\n+source-dir = docs/source\n+build-dir  = _build/docs\n+all_files  = 1\n+\n+[upload_sphinx]\n+upload-dir = _build/docs/html\n \n [check-manifest]\n ignore =\n@@ -9,14 +14,47 @@ ignore =\n \n [coverage:run]\n branch = True\n-source = plone.testing\n+\n+source =\n+    src\n+\n+omit =\n \n [coverage:report]\n precision = 2\n \n+[coverage:html]\n+directory = _build/reports/coverage\n+\n+\n+[isort]\n+# for details see\n+# http://docs.plone.org/develop/styleguide/python.html#grouping-and-sorting\n+force_alphabetical_sort = True\n+force_single_line = True\n+lines_after_imports = 2\n+line_length = 200\n+not_skip = __init__.py\n+\n+[flake8]\n+exclude =\n+    bootstrap.py,\n+\n+include =\n+    src\n+\n+ignore =\n+    N801,\n+    N802,\n+    N803,\n+    N805,\n+    N806,\n+    N812,\n+    T000,\n+    T003,\n+\n [zest.releaser]\n create-wheel = yes\n \n-# When Python 2-3 compatible:\n-# [bdist_wheel]\n-# universal = 1\n+[bdist_wheel]\n+universal = 1\ndiff --git a/setup.py b/setup.py\nindex 801633a..97caeb8 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,18 +1,22 @@\n # -*- coding: utf-8 -*-\n+from setuptools import find_packages\n+from setuptools import setup\n+\n import os\n import os.path\n-import sys\n-from setuptools import setup, find_packages\n \n-version = \'6.1.1.dev0\'\n+version = \'7.0.dev0\'\n \n install_requires = [\n     \'setuptools\',\n-    \'zope.testing\',\n+    \'six\',\n+    \'zope.testing >= 3.8\',\n ]\n \n tests_require = [\n-    \'ZODB3\',\n+    \'WebTest\',\n+    \'ZODB\',\n+    \'Zope\',\n     \'zope.browsermenu\',\n     \'zope.browserpage\',\n     \'zope.browserresource\',\n@@ -24,10 +28,17 @@\n     \'zope.security\',\n     \'zope.testbrowser\',\n     \'zope.testrunner\',\n-    \'Zope\',\n-    \'ZServer\',\n ]\n \n+zope_requires = [\n+    \'WebTest\',\n+    \'Zope\',\n+    \'zope.component\',\n+    \'zope.publisher\',\n+    \'zope.testbrowser\',\n+],\n+\n+\n setup(\n     name=\'plone.testing\',\n     version=version,\n@@ -42,17 +53,24 @@\n         open(os.path.join("src", "plone", "testing", "security.rst")).read(),\n         open(os.path.join("src", "plone", "testing", "publisher.rst")).read(),\n         open(os.path.join("src", "plone", "testing", "zodb.rst")).read(),\n-        open(os.path.join("src", "plone", "testing", "z2.rst")).read()\n+        open(os.path.join("src", "plone", "testing", "zope.rst")).read(),\n+        open(os.path.join("src", "plone", "testing", "zserver.rst")).read(),\n     ])),\n     classifiers=[\n+        "Development Status :: 5 - Production/Stable",\n         "Environment :: Web Environment",\n-        "Framework :: Plone",\n         "Framework :: Plone :: 5.2",\n+        "Framework :: Plone",\n+        "Framework :: Zope :: 4",\n+        "Intended Audience :: Developers",\n+        "License :: OSI Approved :: BSD License",\n         "Operating System :: OS Independent",\n-        "Programming Language :: Python",\n         "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.6",\n+        "Programming Language :: Python :: Implementation :: CPython",\n+        "Programming Language :: Python",\n         "Topic :: Internet :: WWW/HTTP :: Dynamic Content",\n-        "License :: OSI Approved :: BSD License",\n+        "Topic :: Software Development :: Testing",\n     ],\n     keywords=\'plone zope testing\',\n     author=\'Plone Foundation\',\n@@ -68,29 +86,27 @@\n     tests_require=tests_require,\n     extras_require={\n         \'test\': tests_require,\n-        \'zodb\': [\'ZODB3\'],\n+        \'zodb\': [\'ZODB\'],\n         \'zca\': [\n             \'zope.component\',\n-            \'zope.event\',\n             \'zope.configuration\',\n+            \'zope.event\',\n         ],\n         \'security\': [\n             \'zope.security\',\n         ],\n         \'publisher\': [\n-            \'zope.configuration\',\n-            \'zope.security\',\n             \'zope.browsermenu\',\n             \'zope.browserpage\',\n             \'zope.browserresource\',\n+            \'zope.configuration\',\n             \'zope.publisher\',\n+            \'zope.security\',\n         ],\n-        \'z2\': [\n-            \'Zope\',\n+        \'z2\': zope_requires,  # BBB\n+        \'zope\': zope_requires,\n+        \'zserver\': [\n             \'ZServer\',\n-            \'zope.component\',\n-            \'zope.testbrowser\',\n-            \'zope.publisher\',\n         ],\n     },\n )\ndiff --git a/src/plone/testing/README.rst b/src/plone/testing/README.rst\nindex 4adaf6b..565b875 100644\n--- a/src/plone/testing/README.rst\n+++ b/src/plone/testing/README.rst\n@@ -4,7 +4,7 @@ Introduction\n .. contents:: Table of contents\n \n ``plone.testing`` provides tools for writing unit and integration tests in a Zope and Plone environment.\n-It is not tied to Plone, and it does not depend on Zope 2 (although it has some optional Zope 2-only features).\n+It is not tied to Plone, and it does not depend on Zope (although it has some optional Zope-only features).\n \n ``plone.testing`` builds on `zope.testing`_, in particular its layers concept.\n This package also aims to promote some "good practice" for writing tests of various types.\n@@ -26,7 +26,7 @@ The core concepts should be consistent, however.\n Compatibility\n -------------\n \n-``plone.testing`` 6.x has only been tested with Python 2.7.\n+``plone.testing`` 7.x has been tested with Python 2.7 and 3.6.\n If you\'re using the optional Zope layers, you must use Zope version 4 or later.\n Look at older ``plone.testing`` versions for supporting older Zope versions.\n \n@@ -146,7 +146,7 @@ In this example, have listed a single package to test, called ``my.package``, an\n This will install any regular dependencies (listed in the ``install_requires`` option in ``setup.py``), as well as those in the list associated with the ``test`` key in the ``extras_require`` option.\n \n Note that it becomes important to properly list your dependencies here, because the test runner will only be aware of the packages explicitly listed, and their dependencies.\n-For example, if your package depends on Zope 2, you need to list ``Zope2`` in the ``install_requires`` list in ``setup.py``;\n+For example, if your package depends on Zope, you need to list ``Zope`` in the ``install_requires`` list in ``setup.py``;\n ditto for ``Plone``, or indeed any other package you import from.\n \n Once you have re-run buildout, the test runner will be installed as ``bin/test`` (the executable name is taken from the name of the buildout part).\n@@ -208,7 +208,7 @@ The coverage script would otherwise generate coverage information for all execut\n Running the ``bin/report`` script will generate a human readable HTML representation of the run in the `htmlcov` directory.\n Open the contained `index.html` in a browser to see the result.\n \n-If you want to generate an XML representation suitable for the `Cobertura`_ plugin of `Hudson`_, you can add another part::\n+If you want to generate an XML representation suitable for the `Cobertura`_ plugin of `Jenkins`_, you can add another part::\n \n     [buildout]\n     parts =\n@@ -247,7 +247,7 @@ The available extras are:\n \n ``zodb``\n     ZODB testing.\n-    Depends on ``ZODB3``.\n+    Depends on ``ZODB``.\n     The relevant layers and helpers are in the module ``plone.testing.zodb``.\n \n ``zca``\n@@ -265,10 +265,17 @@ The available extras are:\n     Depends on ``zope.publisher``, ``zope.browsermenu``, ``zope.browserpage``, ``zope.browserresource`` and ``zope.security`` and sets up ZCML directives.\n     The relevant layers and helpers are in the module ``plone.testing.publisher``.\n \n-``z2``\n-    Zope 2 testing.\n-    Depends on the ``Zope2`` egg, which includes all the dependencies of the Zope 2 application server.\n-    The relevant layers and helpers are in the module ``plone.testing.z2``\n+``zope`` (For backwards compatibility there is also ``z2``.)\n+\n+    Zope testing.\n+    Depends on the ``Zope`` egg, which includes all the dependencies of the Zope application server.\n+    The relevant layers and helpers are in the module ``plone.testing.zope``.\n+\n+``zserver``\n+\n+    Tests against the ``ZServer``. (Python 2 only!) Requires additionally to use the ``zope`` extra.\n+    The relevant layers and helpers are in the module ``plone.testing.zserver``\n+\n \n Adding a test buildout to your package\n --------------------------------------\n@@ -465,16 +472,16 @@ A simple layer may look like this::\n     >>> class SpaceShip(Layer):\n     ...\n     ...     def setUp(self):\n-    ...         print "Assembling space ship"\n+    ...         print("Assembling space ship")\n     ...\n     ...     def tearDown(self):\n-    ...         print "Disasembling space ship"\n+    ...         print("Disasembling space ship")\n     ...\n     ...     def testSetUp(self):\n-    ...         print "Fuelling space ship in preparation for test"\n+    ...         print("Fuelling space ship in preparation for test")\n     ...\n     ...     def testTearDown(self):\n-    ...         print "Emptying the fuel tank"\n+    ...         print("Emptying the fuel tank")\n \n Before this layer can be used, it must be instantiated.\n Layers are normally instantiated exactly once, since by nature they are shared between tests.\n@@ -499,7 +506,7 @@ Here is an example of another layer that depends on it:::\n     ...     defaultBases = (SPACE_SHIP,)\n     ...\n     ...     def setUp(self):\n-    ...         print "Installing main canon"\n+    ...         print("Installing main canon")\n \n     >>> ZIG = ZIGSpaceShip()\n \n@@ -544,10 +551,10 @@ Normally, of course, you would just re-use the layer instance, either directly i\n     >>> class CATSMessage(Layer):\n     ...\n     ...     def setUp(self):\n-    ...         print "All your base are belong to us"\n+    ...         print("All your base are belong to us")\n     ...\n     ...     def tearDown(self):\n-    ...         print "For great justice"\n+    ...         print("For great justice")\n \n     >>> CATS_MESSAGE = CATSMessage()\n \n@@ -596,9 +603,9 @@ The resource storage uses dictionary notation:::\n     ...\n     ...     def start(self, speed):\n     ...         if speed > self.maxSpeed:\n-    ...             print "We need more power!"\n+    ...             print("We need more power!")\n     ...         else:\n-    ...             print "Going to warp at speed", speed\n+    ...             print("Going to warp at speed", speed)\n     ...             self.running = True\n     ...\n     ...     def stop(self):\n@@ -772,36 +779,11 @@ A few things to note:\n Test suites\n ~~~~~~~~~~~\n \n-If you are using version 3.8.0 or later of `zope.testing`_, a class like the one above is all you need: any class deriving from ``TestCase`` in a module with a name starting with ``test`` will be examined for test methods.\n+A class like the one above is all you need: any class deriving from ``TestCase`` in a module with a name starting with ``test`` will be examined for test methods.\n Those tests are then collected into a test suite and executed.\n \n-With older versions of `zope.testing`_, you need to add a ``test_suite()`` function in each module that returns the tests in the test suite.\n-The `unittest`_ module contains several tools to construct suites, but one of the simplest is to use the default test loader to load all tests in the current module:::\n-\n-    >>> def test_suite():\n-    ...     return unittest.defaultTestLoader.loadTestsFromName(__name__)\n-\n-If you need to load tests explicitly, you can use the ``TestSuite`` API from the `unittest`_ module.\n-For example:::\n-\n-    >>> def test_suite():\n-    ...     suite = unittest.TestSuite()\n-    ...     suite.addTests([\n-    ...         unittest.makeSuite(TestFasterThanLightTravel)\n-    ...     ])\n-    ...     return suite\n-\n-The ``makeSuite()`` function creates a test suite from the test methods in the given class (which must derive from ``TestCase``).\n-This suite is then appended to an overall suite, which is returned from the ``test_suite()`` method.\n-Note that ``addTests()`` takes a list of suites (which are coalesced into a single suite).\n-We\'ll add additional suites later.\n-\n See the `unittest`_ documentation for other options.\n \n-.. note::\n-\n-   Adding a ``test_suite()`` method to a module disables automatic test discovery, even when using a recent version of ``zope.testing``.\n-\n Doctests\n --------\n \n@@ -1161,31 +1143,31 @@ Here, we have loaded two files: ``meta.zcml`` and ``configure.zcml``.\n The first call to ``xmlconfig.file()`` creates and returns a configuration context.\n We re-use that for the subsequent invocation, so that the directives configured are available.\n \n-Installing a Zope 2 product\n----------------------------\n+Installing a Zope product\n+-------------------------\n \n-Some packages (including all those in the ``Products.*`` namespace) have the special status of being Zope 2 "products".\n+Some packages (including all those in the ``Products.*`` namespace) have the special status of being Zope "products".\n These are recorded in a special registry, and may have an ``initialize()`` hook in their top-level ``__init__.py`` that needs to be called for the package to be fully configured.\n \n Zope 2 will find and execute any products during startup.\n For testing, we need to explicitly list the products to install.\n-Provided you are using ``plone.testing`` with Zope 2, you can use the following:::\n+Provided you are using ``plone.testing`` with Zope, you can use the following:::\n \n-    from plone.testing import z2\n+    from plone.testing import zope\n \n-    with z2.zopeApp() as app:\n-        z2.installProduct(app, \'Products.ZCatalog\')\n+    with zope.zopeApp() as app:\n+        zope.installProduct(app, \'Products.ZCatalog\')\n \n This would normally be used during layer ``setUp()``.\n-Note that the basic Zope 2 application context must have been set up before doing this.\n-The usual way to ensure this, is to use a layer that is based on ``z2.STARTUP`` - see below.\n+Note that the basic Zope application context must have been set up before doing this.\n+The usual way to ensure this, is to use a layer that is based on ``zope.STARTUP`` - see below.\n \n To tear down such a layer, you should do:::\n \n-    from plone.testing import z2\n+    from plone.testing import zope\n \n-    with z2.zopeApp() as app:\n-        z2.uninstallProduct(app, \'Products.ZCatalog\')\n+    with zope.zopeApp() as app:\n+        zope.uninstallProduct(app, \'Products.ZCatalog\')\n \n Note:\n \n@@ -1204,20 +1186,20 @@ For functional tests that aim to simulate the browser, you can use `zope.testbro\n     >>> from zope.testbrowser.browser import Browser\n     >>> browser = Browser()\n \n-This provides a simple API to simulate browser input, without actually running a web server thread or scripting a live browser (as tools such as Windmill and Selenium do).\n+This provides a simple API to simulate browser input, without actually running a web server thread or scripting a live browser (as tools such as Selenium_ do).\n The downside is that it is not possible to test JavaScript- dependent behaviour.\n \n-If you are testing a Zope 2 application, you need to change the import location slightly, and pass the application root to the method:::\n+If you are testing a Zope application, you need to change the import location slightly, and pass the application root to the method:::\n \n-    from plone.testing.z2 import Browser\n+    from plone.testing.zope import Browser\n     browser = Browser(app)\n \n-You can get the application root from the ``app`` resource in any of the Zope 2 layers in this package.\n+You can get the application root from the ``app`` resource in any of the Zope layers in this package.\n \n Beyond that, the `zope.testbrowser`_ documentation should cover how to use the test browser.\n \n     **Hint:** The test browser will usually commit at the end of a request.\n-    To avoid test fixture contamination, you should use a layer that fully isolates each test, such as the ``z2.INTEGRATION_TESTING`` layer described below.\n+    To avoid test fixture contamination, you should use a layer that fully isolates each test, such as the ``zope.INTEGRATION_TESTING`` layer described below.\n \n Layer reference\n ===============\n@@ -1550,22 +1532,22 @@ This will shadow the ``zodbDB`` resource with an isolated ``DemoStorage``, creat\n All existing data continues to be available, but new changes are written to the stacked storage.\n On tear-down, the stacked database is closed and the resource removed, leaving the original data.\n \n-Zope 2\n-------\n+Zope\n+----\n \n-The Zope 2 layers provide test fixtures suitable for testing Zope 2 applications.\n-They set up a Zope 2 application root, install core Zope 2 products, and manage security.\n+The Zope layers provide test fixtures suitable for testing Zope applications.\n+They set up a Zope application root, install core Zope products, and manage security.\n \n-Zope 2 layers can be found in the module ``plone.testing.z2``.\n-If you depend on this, you can use the ``[z2]`` extra when depending on ``plone.testing``.\n+Zope layers can be found in the module ``plone.testing.zope``.\n+If you depend on this, you can use the ``[zope]`` extra when depending on ``plone.testing``.\n \n Startup\n ~~~~~~~\n \n +------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.STARTUP``                     |\n+| Layer:     | ``plone.testing.zope.STARTUP``                   |\n +------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.Startup``                     |\n+| Class:     | ``plone.testing.zope.Startup``                   |\n +------------+--------------------------------------------------+\n | Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |\n +------------+--------------------------------------------------+\n@@ -1578,8 +1560,8 @@ Startup\n |            | ``port``                                         |\n +------------+--------------------------------------------------+\n \n-This layer sets up a Zope 2 environment, and is a required base for all other Zope 2 layers.\n-You cannot run two instances of this layer in parallel, since Zope 2 depends on some module-global state to run, which is managed by this layer.\n+This layer sets up a Zope environment, and is a required base for all other Zope layers.\n+You cannot run two instances of this layer in parallel, since Zope depends on some module-global state to run, which is managed by this layer.\n \n On set-up, the layer will configure a Zope environment with:\n \n@@ -1592,9 +1574,9 @@ On set-up, the layer will configure a Zope environment with:\n \n * ZEO client cache disabled.\n \n-* Some patches installed, which speed up Zope startup by disabling the help system and some other superfluous aspects of Zope.\n+* Some patches installed, which speed up Zope startup by disabling some superfluous aspects of Zope.\n \n-* One thread (this only really affects the ``ZSERVER`` and ``FTP_SERVER`` layers).\n+* One thread (this only really affects the ``WSGI_SERVER``, ``ZSERVER`` and ``FTP_SERVER`` layers).\n \n * A pristine database using ``DemoStorage``, exposed as the resource ``zodbDB``.\n   Zope is configured to use this database in a way that will also work if the ``zodbDB`` resource is shadowed using the pattern shown above in the description of the ``zodb.EMPTY_ZODB`` layer.\n@@ -1614,11 +1596,11 @@ Integration test\n ~~~~~~~~~~~~~~~~\n \n +------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.INTEGRATION_TESTING``         |\n+| Layer:     | ``plone.testing.zope.INTEGRATION_TESTING``       |\n +------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.IntegrationTesting``          |\n+| Class:     | ``plone.testing.zope.IntegrationTesting``        |\n +------------+--------------------------------------------------+\n-| Bases:     | ``plone.testing.z2.STARTUP``                     |\n+| Bases:     | ``plone.testing.zope.STARTUP``                   |\n +------------+--------------------------------------------------+\n | Resources: | ``app``                                          |\n |            +--------------------------------------------------+\n@@ -1633,12 +1615,12 @@ This is wrapped in the request container, so you can do ``app.REQUEST`` to acqui\n \n A new transaction is begun for each test and rolled back on test tear-down, meaning that so long as the code under test does not explicitly commit any changes, the test may modify the ZODB.\n \n-    *Hint:* If you want to set up a persistent test fixture in a layer based on this one (or ``z2.FUNCTIONAL_TESTING``), you can stack a new ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern described above for the ``zodb.EMPTY_ZODB`` layer.\n+    *Hint:* If you want to set up a persistent test fixture in a layer based on this one (or ``zope.FUNCTIONAL_TESTING``), you can stack a new ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern described above for the ``zodb.EMPTY_ZODB`` layer.\n \n     Once you\'ve shadowed the ``zodbDB`` resource, you can do (e.g. in your layer\'s ``setUp()`` method)::\n \n         ...\n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n             # modify the Zope application root\n \n     The ``zopeApp()`` context manager will open a new connection to the Zope application root, accessible here as ``app``.\n@@ -1648,11 +1630,11 @@ Functional testing\n ~~~~~~~~~~~~~~~~~~\n \n +------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.FUNCTIONAL_TESTING``          |\n+| Layer:     | ``plone.testing.zope.FUNCTIONAL_TESTING``        |\n +------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.FunctionalTesting``           |\n+| Class:     | ``plone.testing.zope.FunctionalTesting``         |\n +------------+--------------------------------------------------+\n-| Bases:     | ``plone.testing.z2.STARTUP``                     |\n+| Bases:     | ``plone.testing.zope.STARTUP``                   |\n +------------+--------------------------------------------------+\n | Resources: | ``app``                                          |\n |            +--------------------------------------------------+\n@@ -1675,9 +1657,9 @@ Integration and functional testing with custom fixtures\n \n If you want to extend the ``STARTUP`` fixture for use with integration or functional testing, you should use the following pattern:\n \n-* Create a layer class and a "fixture" base layer instance that has ``z2.STARTUP`` (or some intermediary layer, such as ``z2.ZSERVER_FIXTURE`` or ``z2.FTP_SERVER_FIXTURE``, shown below) as a base.\n+* Create a layer class and a "fixture" base layer instance that has ``zope.STARTUP`` (or some intermediary layer, such as ``zope.WSGI_SERVER_FIXTURE``, shown below) as a base.\n \n-* Create "end user" layers by instantiating the ``z2.IntegrationTesting`` and/or ``FunctionalTesting`` classes with this new "fixture" layer as a base.\n+* Create "end user" layers by instantiating the ``zope.IntegrationTesting`` and/or ``FunctionalTesting`` classes with this new "fixture" layer as a base.\n \n This allows the same fixture to be used regardless of the "style" of testing, minimising the amount of set-up and tear-down.\n The "fixture" layers manage the fixture as part of the *layer* lifecycle.\n@@ -1685,10 +1667,10 @@ The layer class (``IntegrationTesting`` or ``FunctionalTesting``), manages the *\n \n For example::\n \n-    from plone.testing import Layer, z2, zodb\n+    from plone.testing import Layer, zope, zodb\n \n     class MyLayer(Layer):\n-        defaultBases = (z2.STARTUP,)\n+        defaultBases = (zope.STARTUP,)\n \n         def setUp(self):\n             # Set up the fixture here\n@@ -1700,8 +1682,8 @@ For example::\n \n     MY_FIXTURE = MyLayer()\n \n-    MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name="MyFixture:Integration")\n-    MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name="MyFixture:Functional")\n+    MY_INTEGRATION_TESTING = zope.IntegrationTesting(bases=(MY_FIXTURE,), name="MyFixture:Integration")\n+    MY_FUNCTIONAL_TESTING = zope.FunctionalTesting(bases=(MY_FIXTURE,), name="MyFixture:Functional")\n \n (Note that we need to give an explicit, unique name to the two layers that re-use the ``IntegrationTesting`` and ``FunctionalTesting`` classes.)\n \n@@ -1717,109 +1699,57 @@ However, even if both these two layers were used, the fixture in ``MY_FIXTURE``\n It may be preferable, therefore, to have your own "test lifecycle" layer classes that subclass ``IntegrationTesting`` and/or ``FunctionalTesting`` and call base class methods as appropriate.\n ``plone.app.testing`` takes this approach, for example.\n \n-HTTP ZServer thread (fixture only)\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+HTTP WSGI server thread (fixture only)\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n +------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.ZSERVER_FIXTURE``             |\n+| Layer:     | ``plone.testing.zope.WSGI_SERVER_FIXTURE``       |\n +------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.ZServer``                     |\n+| Class:     | ``plone.testing.zope.WSGIServer``                |\n +------------+--------------------------------------------------+\n-| Bases:     | ``plone.testing.z2.STARTUP``                     |\n+| Bases:     | ``plone.testing.zope.STARTUP``                   |\n +------------+--------------------------------------------------+\n | Resources: | ``host``                                         |\n |            +--------------------------------------------------+\n |            | ``port``                                         |\n +------------+--------------------------------------------------+\n \n-This layer extends the ``z2.STARTUP`` layer to start the Zope HTTP server in a separate thread.\n-This means the test site can be accessed through a web browser, and can thus be used with tools like `Windmill`_ or `Selenium`_.\n+This layer extends the ``zope.STARTUP`` layer to start the Zope HTTP WSGI server in a separate thread.\n+This means the test site can be accessed through a web browser, and can thus be used with tools like `Selenium`_.\n \n .. note::\n \n     This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\n-    Use the ``ZSERVER`` layer if you want to execute functional tests against this fixture.\n+    Use the ``WSGI_SERVER`` layer if you want to execute functional tests against this fixture.\n \n-The ZServer\'s hostname (normally ``localhost``) is available through the resource ``host``, whilst the port it is running on is available through the resource ``port``.\n+The WSGI server\'s hostname (normally ``localhost``) is available through the resource ``host``, whilst the port it is running on is available through the resource ``port``.\n \n   *Hint:* Whilst the layer is set up, you can actually access the test Zope site through a web browser.\n   The default URL will be ``http://localhost:55001``.\n \n-HTTP ZServer functional testing\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-+------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.ZSERVER``                     |\n-+------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.FunctionalTesting``           |\n-+------------+--------------------------------------------------+\n-| Bases:     | ``plone.testing.z2.ZSERVER_FIXTURE``             |\n-+------------+--------------------------------------------------+\n-| Resources: |                                                  |\n-+------------+--------------------------------------------------+\n-\n-This layer provides the functional testing lifecycle against the fixture set up by the ``z2.ZSERVER_FIXTURE`` layer.\n-\n-You can use this to run "live" functional tests against a basic Zope site.\n-You should **not** use it as a base.\n-Instead, create your own "fixture" layer that extends ``z2.ZSERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.\n-\n-FTP server thread (fixture only)\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-+------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.FTP_SERVER_FIXTURE``          |\n-+------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.FTPServer``                   |\n-+------------+--------------------------------------------------+\n-| Bases:     | ``plone.testing.z2.STARTUP``                     |\n-+------------+--------------------------------------------------+\n-| Resources: | ``host``                                         |\n-|            +--------------------------------------------------+\n-|            | ``port``                                         |\n-+------------+--------------------------------------------------+\n-\n-This layer is the FTP server equivalent of the ``ZSERVER_FIXTURE`` layer.\n-It can be used to functionally test Zope servers.\n-\n-.. note::\n-\n-    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\n-    Use the ``FTP_SERVER`` layer if you want to execute functional tests against this fixture.\n-\n-    *Hint:* Whilst the layer is set up, you can actually access the test Zope site through an FTP client.\n-    The default URL will be ``ftp://localhost:55002``.\n-\n-.. warning::\n-\n-    Do not run the ``FTP_SERVER`` and ``ZSERVER`` layers concurrently in the same process.\n-\n-If you need both ZServer and FTPServer running together, you can subclass the ``ZServer`` layer class (like the ``FTPServer`` layer class does) and implement the ``setUpServer()`` and ``tearDownServer()`` methods to set up and close down two servers on different ports.\n-They will then share a main loop.\n-\n-FTP server functional testing\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+HTTP WSGI server functional testing\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n +------------+--------------------------------------------------+\n-| Layer:     | ``plone.testing.z2.FTP_SERVER``                  |\n+| Layer:     | ``plone.testing.zope.WSGI_SERVER``               |\n +------------+--------------------------------------------------+\n-| Class:     | ``plone.testing.z2.FunctionalTesting``           |\n+| Class:     | ``plone.testing.zope.FunctionalTesting``         |\n +------------+--------------------------------------------------+\n-| Bases:     | ``plone.testing.z2.FTP_SERVER_FIXTURE``          |\n+| Bases:     | ``plone.testing.zope.WSGI_SERVER_FIXTURE``       |\n +------------+--------------------------------------------------+\n | Resources: |                                                  |\n +------------+--------------------------------------------------+\n \n-This layer provides the functional testing lifecycle against the fixture set up by the ``z2.FTP_SERVER_FIXTURE`` layer.\n+This layer provides the functional testing lifecycle against the fixture set up by the ``zope.WSGI_SERVER_FIXTURE`` layer.\n \n You can use this to run "live" functional tests against a basic Zope site.\n You should **not** use it as a base.\n-Instead, create your own "fixture" layer that extends ``z2.FTP_SERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.\n+Instead, create your own "fixture" layer that extends ``zope.WSGI_SERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.\n \n Helper functions\n ~~~~~~~~~~~~~~~~\n \n-Several helper functions are available in the ``plone.testing.z2`` module.\n+Several helper functions are available in the ``plone.testing.zope`` module.\n \n ``zopeApp(db=None, conn=Non, environ=None)``\n \n@@ -1827,7 +1757,7 @@ Several helper functions are available in the ``plone.testing.z2`` module.\n     By using it in a ``with`` block, the database will be opened, and the application root will be obtained and request-wrapped.\n     When exiting the ``with`` block, the transaction will be committed and the database properly closed, unless an exception was raised::\n \n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n             # do something with app\n \n     If you want to use a specific database or database connection, pass either the ``db`` or ``conn`` arguments.\n@@ -1878,17 +1808,17 @@ Several helper functions are available in the ``plone.testing.z2`` module.\n \n        This method is rarely used, because both the ``zopeApp()``\n        context manager and the layer set-up/tear-down for\n-       ``z2.INTEGRATION_TESTING`` and ``z2.FUNCTIONAL_TESTING`` will wrap the\n+       ``zope.INTEGRATION_TESTING`` and ``zope.FUNCTIONAL_TESTING`` will wrap the\n        ``app`` object before exposing it.\n \n ``Browser(app)``\n \n     Obtain a test browser client, for use with `zope.testbrowser`_.\n-    You should use this in conjunction with the ``z2.FUNCTIONAL_TESTING`` layer or a derivative.\n+    You should use this in conjunction with the ``zope.FUNCTIONAL_TESTING`` layer or a derivative.\n     You must pass the app root, usually obtained from the ``app`` resource of the layer, e.g.::\n \n         app = self.layer[\'app\']\n-        browser = z2.Browser(app)\n+        browser = zope.Browser(app)\n \n     You can then use ``browser`` as described in the `zope.testbrowser`_ documentation.\n \n@@ -1899,16 +1829,273 @@ Several helper functions are available in the ``plone.testing.z2`` module.\n         import transaction\n         transaction.commit()\n \n-.. _zope.testing: http://pypi.python.org/pypi/zope.testing\n-.. _zope.testbrowser: http://pypi.python.org/pypi/zope.testbrowser\n-.. _zope.component: http://pypi.python.org/pypi/zope.component\n-.. _zope.publisher: http://pypi.python.org/pypi/zope.publisher\n-.. _plone.app.testing: http://pypi.python.org/pypi/plone.app.testing\n-.. _zc.recipe.testrunner: http://pypi.python.org/pypi/zc.recipe.testrunner\n-.. _coverage: http://pypi.python.org/pypi/coverage\n-.. _Cobertura: http://wiki.hudson-ci.org/display/HUDSON/Cobertura+Plugin\n-.. _Hudson: http://www.hudson-labs.org/\n+\n+ZServer\n+-------\n+\n+The ZServer layers provide test fixtures suitable for testing Zope applications while using ZServer instead of a WSGI server.\n+They set up a Zope application root, install core Zope products, and manage security.\n+\n+ZServer layers can be found in the module ``plone.testing.zserver``.\n+If you depend on this, you can use the ``[zope,zserver]`` extra when depending on ``plone.testing``.\n+\n+Startup\n+~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.STARTUP``                |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.Startup``                |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |\n++------------+--------------------------------------------------+\n+| Resources: | ``zodbDB``                                       |\n+|            +--------------------------------------------------+\n+|            | ``configurationContext``                         |\n+|            +--------------------------------------------------+\n+|            | ``host``                                         |\n+|            +--------------------------------------------------+\n+|            | ``port``                                         |\n++------------+--------------------------------------------------+\n+\n+This layer sets up a Zope environment for ZServer, and is a required base for all other ZServer layers.\n+You cannot run two instances of this layer in parallel, since Zope depends on some module-global state to run, which is managed by this layer.\n+\n+On set-up, the layer will configure a Zope environment with the same options as ``zope.Startup``, see there.\n+\n+Integration test\n+~~~~~~~~~~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.INTEGRATION_TESTING``    |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.IntegrationTesting``     |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zserver.STARTUP``                |\n++------------+--------------------------------------------------+\n+| Resources: | ``app``                                          |\n+|            +--------------------------------------------------+\n+|            | ``request``                                      |\n++------------+--------------------------------------------------+\n+\n+This layer is intended for integration testing against the simple ``STARTUP`` fixture.\n+If you want to create your own layer with a more advanced, shared fixture, see "Integration and functional testing with custom fixtures" below.\n+\n+For each test, it exposes the Zope application root as the resource ``app``.\n+This is wrapped in the request container, so you can do ``app.REQUEST`` to acquire a fake request, but the request is also available as the resource ``request``.\n+\n+A new transaction is begun for each test and rolled back on test tear-down, meaning that so long as the code under test does not explicitly commit any changes, the test may modify the ZODB.\n+\n+    *Hint:* If you want to set up a persistent test fixture in a layer based on this one (or ``zserver.FUNCTIONAL_TESTING``), you can stack a new ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern described above for the ``zodb.EMPTY_ZODB`` layer.\n+\n+    Once you\'ve shadowed the ``zodbDB`` resource, you can do (e.g. in your layer\'s ``setUp()`` method)::\n+\n+        ...\n+        with zserver.zopeApp() as app:\n+            # modify the Zope application root\n+\n+    The ``zserver.zopeApp()`` context manager will open a new connection to the Zope application root, accessible here as ``app``.\n+    Provided the code within the ``with`` block does not raise an exception, the transaction will be committed and the database closed properly upon exiting the block.\n+\n+Functional testing\n+~~~~~~~~~~~~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.FUNCTIONAL_TESTING``     |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.FunctionalTesting``      |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zserver.STARTUP``                |\n++------------+--------------------------------------------------+\n+| Resources: | ``app``                                          |\n+|            +--------------------------------------------------+\n+|            | ``request``                                      |\n++------------+--------------------------------------------------+\n+\n+It behaves the same as ``zope.FunctionalTesting``, see there.\n+\n+\n+Integration and functional testing with custom fixtures\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+If you want to extend the ``STARTUP`` fixture for use with integration or functional testing, you should use the following pattern:\n+\n+* Create a layer class and a "fixture" base layer instance that has ``zserver.STARTUP`` (or some intermediary layer, such as ``zserver.ZSERVER_FIXTURE`` or ``zserver.FTP_SERVER_FIXTURE``, shown below) as a base.\n+\n+* Create "end user" layers by instantiating the ``zserver.IntegrationTesting`` and/or ``FunctionalTesting`` classes with this new "fixture" layer as a base.\n+\n+This allows the same fixture to be used regardless of the "style" of testing, minimising the amount of set-up and tear-down.\n+The "fixture" layers manage the fixture as part of the *layer* lifecycle.\n+The layer class (``IntegrationTesting`` or ``FunctionalTesting``), manages the *test* lifecycle, and the test lifecycle only.\n+\n+For example::\n+\n+    from plone.testing import Layer, zserver, zodb\n+\n+    class MyLayer(Layer):\n+        defaultBases = (zserver.STARTUP,)\n+\n+        def setUp(self):\n+            # Set up the fixture here\n+            ...\n+\n+        def tearDown(self):\n+            # Tear down the fixture here\n+            ...\n+\n+    MY_FIXTURE = MyLayer()\n+\n+    MY_INTEGRATION_TESTING = zserver.IntegrationTesting(bases=(MY_FIXTURE,), name="MyFixture:Integration")\n+    MY_FUNCTIONAL_TESTING = zserver.FunctionalTesting(bases=(MY_FIXTURE,), name="MyFixture:Functional")\n+\n+(Note that we need to give an explicit, unique name to the two layers that re-use the ``IntegrationTesting`` and ``FunctionalTesting`` classes.)\n+\n+In this example, other layers could extend the "MyLayer" fixture by using ``MY_FIXTURE`` as a base.\n+Tests would use either ``MY_INTEGRATION_TESTING`` or ``MY_FUNCTIONAL_TESTING`` as appropriate.\n+However, even if both these two layers were used, the fixture in ``MY_FIXTURE`` would only be set up once.\n+\n+.. note::\n+\n+    If you implement the ``testSetUp()`` and ``testTearDown()`` test lifecycle methods in your "fixture" layer (e.g. in the the ``MyLayer`` class above), they will execute before the corresponding methods from ``IntegrationTesting`` and ``FunctionalTesting``.\n+    Hence, they cannot use those layers\' resources (``app`` and ``request``).\n+\n+It may be preferable, therefore, to have your own "test lifecycle" layer classes that subclass ``IntegrationTesting`` and/or ``FunctionalTesting`` and call base class methods as appropriate.\n+``plone.app.testing`` takes this approach, for example.\n+\n+\n+HTTP ZServer thread (fixture only)\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.ZSERVER_FIXTURE``        |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.ZServer``                |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zserver.STARTUP``                |\n++------------+--------------------------------------------------+\n+| Resources: | ``host``                                         |\n+|            +--------------------------------------------------+\n+|            | ``port``                                         |\n++------------+--------------------------------------------------+\n+\n+This layer extends the ``zserver.STARTUP`` layer to start the Zope HTTP server (ZServer) in a separate thread.\n+This means the test site can be accessed through a web browser, and can thus be used with tools like `Selenium`_.\n+\n+.. note::\n+\n+    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\n+    Use the ``ZSERVER`` layer if you want to execute functional tests against this fixture.\n+\n+The ZServer\'s hostname (normally ``localhost``) is available through the resource ``host``, whilst the port it is running on is available through the resource ``port``.\n+\n+  *Hint:* Whilst the layer is set up, you can actually access the test Zope site through a web browser.\n+  The default URL will be ``http://localhost:55001``.\n+\n+HTTP ZServer functional testing\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.ZSERVER``                |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.FunctionalTesting``      |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zserver.ZSERVER_FIXTURE``        |\n++------------+--------------------------------------------------+\n+| Resources: |                                                  |\n++------------+--------------------------------------------------+\n+\n+This layer provides the functional testing lifecycle against the fixture set up by the ``zserver.ZSERVER_FIXTURE`` layer.\n+\n+You can use this to run "live" functional tests against a basic Zope site.\n+You should **not** use it as a base.\n+Instead, create your own "fixture" layer that extends ``zserver.ZSERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.\n+\n+\n+FTP server thread (fixture only)\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.FTP_SERVER_FIXTURE``     |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.FTPServer``              |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zserver.STARTUP``                |\n++------------+--------------------------------------------------+\n+| Resources: | ``host``                                         |\n+|            +--------------------------------------------------+\n+|            | ``port``                                         |\n++------------+--------------------------------------------------+\n+\n+This layer is the FTP server equivalent of the ``zserver.ZSERVER_FIXTURE`` layer.\n+It can be used to functionally test Zope FTP servers.\n+\n+.. note::\n+\n+    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\n+    Use the ``FTP_SERVER`` layer if you want to execute functional tests against this fixture.\n+\n+    *Hint:* Whilst the layer is set up, you can actually access the test Zope site through an FTP client.\n+    The default URL will be ``ftp://localhost:55002``.\n+\n+.. warning::\n+\n+    Do not run the ``FTP_SERVER`` and ``ZSERVER`` layers concurrently in the same process.\n+\n+If you need both ZServer and FTPServer running together, you can subclass the ``ZServer`` layer class (like the ``FTPServer`` layer class does) and implement the ``setUpServer()`` and ``tearDownServer()`` methods to set up and close down two servers on different ports.\n+They will then share a main loop.\n+\n+FTP server functional testing\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n++------------+--------------------------------------------------+\n+| Layer:     | ``plone.testing.zserver.FTP_SERVER``                |\n++------------+--------------------------------------------------+\n+| Class:     | ``plone.testing.zserver.FunctionalTesting``         |\n++------------+--------------------------------------------------+\n+| Bases:     | ``plone.testing.zserver.FTP_SERVER_FIXTURE``        |\n++------------+--------------------------------------------------+\n+| Resources: |                                                  |\n++------------+--------------------------------------------------+\n+\n+This layer provides the functional testing lifecycle against the fixture set up by the ``zserver.FTP_SERVER_FIXTURE`` layer.\n+\n+You can use this to run "live" functional tests against a basic Zope site.\n+You should **not** use it as a base.\n+Instead, create your own "fixture" layer that extends ``zserver.FTP_SERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.\n+\n+Helper functions\n+~~~~~~~~~~~~~~~~\n+\n+Several helper functions are available in the ``plone.testing.zserver`` module.\n+\n+``zopeApp(db=None, conn=Non, environ=None)``\n+\n+    This function can be used as a context manager for any code that requires access to the Zope application root.\n+    By using it in a ``with`` block, the database will be opened, and the application root will be obtained and request-wrapped.\n+    When exiting the ``with`` block, the transaction will be committed and the database properly closed, unless an exception was raised::\n+\n+        with zserver.zopeApp() as app:\n+            # do something with app\n+\n+    If you want to use a specific database or database connection, pass either the ``db`` or ``conn`` arguments.\n+    If the context manager opened a new connection, it will close it, but it will not close a connection passed with ``conn``.\n+\n+    To set keys in the (fake) request environment, pass a dictionary of environment values as ``environ``.\n+\n+    Note that ``zopeApp()`` should *not* normally be used in tests or test set-up/tear-down, because the ``INTEGRATOIN_TEST`` and ``FUNCTIONAL_TESTING`` layers both manage the application root (as the ``app`` resource) and close it for you.\n+    It is very useful in layer setup, however.\n+\n+The other helper functions defined in ``plone.testing.zope`` can also be used in a ZServer context but together with the ZServer layers.\n+\n+.. _zope.testing: https://pypi.org/project/zope.testing/\n+.. _zope.testbrowser: https://pypi.org/project/zope.testbrowser\n+.. _zope.component: https://pypi.org/project/zope.component\n+.. _zope.publisher: https://pypi.org/project/zope.publisher\n+.. _plone.app.testing: https://pypi.org/project/plone.app.testing\n+.. _zc.recipe.testrunner: https://pypi.org/project/zc.recipe.testrunner\n+.. _coverage: https://pypi.org/project/coverage\n+.. _Cobertura: https://wiki.jenkins.io/display/JENKINS/Cobertura+Plugin\n+.. _Jenkins: https://jenkins.io\n .. _unittest: http://doc.python.org/library/unittest.html\n .. _doctest: http://docs.python.org/dev/library/doctest.html\n-.. _Windmill: http://getwindmill.com/\n .. _Selenium: http://seleniumhq.org/\ndiff --git a/src/plone/testing/__init__.py b/src/plone/testing/__init__.py\nindex 5312af9..0772d96 100644\n--- a/src/plone/testing/__init__.py\n+++ b/src/plone/testing/__init__.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+# flake8: NOQA: F401\n # Convenience imports\n-from plone.testing.layer import Layer  # noqa\n-from plone.testing.layer import layered  # noqa\n+from plone.testing.layer import Layer\n+from plone.testing.layer import layered\ndiff --git a/src/plone/testing/_z2_testbrowser.py b/src/plone/testing/_z2_testbrowser.py\nindex 31aa093..7eba318 100644\n--- a/src/plone/testing/_z2_testbrowser.py\n+++ b/src/plone/testing/_z2_testbrowser.py\n@@ -1,9 +1,10 @@\n # -*- coding: utf-8 -*-\n+from __future__ import absolute_import\n from zope.testbrowser import browser\n from ZPublisher.httpexceptions import HTTPExceptionHandler\n+from ZPublisher.utils import basic_auth_encode\n from ZPublisher.WSGIPublisher import publish_module\n \n-import base64\n import re\n \n \n@@ -18,8 +19,7 @@ def authHeader(header):\n             u = \'\'\n         if p is None:\n             p = \'\'\n-        auth = base64.encodestring(\'{0}:{1}\'.format(u, p))\n-        return \'Basic {0}\'.format(auth[:-1])\n+        return basic_auth_encode(u, p)\n     return header\n \n \ndiff --git a/src/plone/testing/layer.py b/src/plone/testing/layer.py\nindex 8ac9600..a95b8c6 100644\n--- a/src/plone/testing/layer.py\n+++ b/src/plone/testing/layer.py\n@@ -125,7 +125,8 @@ def _resourceResolutionOrder(self, instance):\n         return self._mergeResourceManagers(\n             [[instance]] +\n             list(map(self._resourceResolutionOrder, instance.__bases__)) +\n-            [list(instance.__bases__)])\n+            [list(instance.__bases__)]\n+        )\n \n \n class Layer(ResourceManager):\n@@ -155,10 +156,10 @@ def __init__(self, bases=None, name=None, module=None):\n         """\n \n         if self.__class__ is Layer and name is None:\n-            raise ValueError(\'The `name` argument is required when instantiating `Layer` directly\')  # noqa\n+            raise ValueError(\'The `name` argument is required when instantiating `Layer` directly\')  # NOQA: E501\n \n         if name is None and bases is not None:\n-            raise ValueError(\'The `name`` argument is required when overriding bases with the `bases` argument\')  # noqa\n+            raise ValueError(\'The `name`` argument is required when overriding bases with the `bases` argument\')  # NOQA: E501\n \n         super(Layer, self).__init__()\n \ndiff --git a/src/plone/testing/layer.rst b/src/plone/testing/layer.rst\nindex 26cb28a..73649cf 100644\n--- a/src/plone/testing/layer.rst\n+++ b/src/plone/testing/layer.rst\n@@ -55,7 +55,7 @@ The ``name`` argument is required when using ``Layer`` directly (but not when us\n     >>> class NullLayer(Layer):\n     ...     pass\n     >>> NullLayer()\n-    <Layer \'__builtin__.NullLayer\'>\n+    <Layer \'builtins.NullLayer\'>\n \n Using ``Layer`` as a base class\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -66,10 +66,10 @@ This can then override the lifecycle methods as appropriate, as well as set a de\n     >>> class BaseLayer(Layer):\n     ...\n     ...     def setUp(self):\n-    ...         print "Setting up base layer"\n+    ...         print("Setting up base layer")\n     ...\n     ...     def tearDown(self):\n-    ...         print "Tearing down base layer"\n+    ...         print("Tearing down base layer")\n \n     >>> BASE_LAYER = BaseLayer()\n \n@@ -80,7 +80,7 @@ The layer name and module are taken from the class.::\n     >>> BASE_LAYER.__name__\n     \'BaseLayer\'\n     >>> BASE_LAYER.__module__\n-    \'__builtin__\'\n+    \'builtins\'\n \n We can now create a new layer that has this one as a base.\n We can do this in the instance constructor, as shown above, but the most common pattern is to set the default bases in the class body, using the variable ``defaultBases``.\n@@ -95,21 +95,21 @@ This is mostly cosmetic, but may be desirable if the class name would be mislead\n     ...         super(ChildLayer, self).__init__(bases, name, module)\n     ...\n     ...     def setUp(self):\n-    ...         print "Setting up child layer"\n+    ...         print("Setting up child layer")\n     ...\n     ...     def tearDown(self):\n-    ...         print "Tearing down child layer"\n+    ...         print("Tearing down child layer")\n \n     >>> CHILD_LAYER = ChildLayer()\n \n Notice how the bases have now been set using the value in ``defaultBases``.::\n \n     >>> CHILD_LAYER.__bases__\n-    (<Layer \'__builtin__.BaseLayer\'>,)\n+    (<Layer \'builtins.BaseLayer\'>,)\n     >>> CHILD_LAYER.__name__\n     \'Child layer\'\n     >>> CHILD_LAYER.__module__\n-    \'__builtin__\'\n+    \'builtins\'\n \n Overriding the default list of bases\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -125,11 +125,11 @@ When creating a second instance of a layer (most layers are global singletons cr\n     >>> NEW_CHILD_LAYER = ChildLayer(bases=(SIMPLE_LAYER, BASE_LAYER,), name=\'New child\')\n \n     >>> NEW_CHILD_LAYER.__bases__\n-    (<Layer \'plone.testing.tests.Simple layer\'>, <Layer \'__builtin__.BaseLayer\'>)\n+    (<Layer \'plone.testing.tests.Simple layer\'>, <Layer \'builtins.BaseLayer\'>)\n     >>> NEW_CHILD_LAYER.__name__\n     \'New child\'\n     >>> NEW_CHILD_LAYER.__module__\n-    \'__builtin__\'\n+    \'builtins\'\n \n Inconsistent bases\n ~~~~~~~~~~~~~~~~~~\n@@ -138,12 +138,12 @@ Layer bases are maintained in an order that is semantically equivalent to the "m\n We can get this from the ``baseResolutionOrder`` attribute:::\n \n     >>> CHILD_LAYER.baseResolutionOrder\n-    (<Layer \'__builtin__.Child layer\'>, <Layer \'__builtin__.BaseLayer\'>)\n+    (<Layer \'builtins.Child layer\'>, <Layer \'builtins.BaseLayer\'>)\n \n     >>> NEW_CHILD_LAYER.baseResolutionOrder\n-    (<Layer \'__builtin__.New child\'>, <Layer \'plone.testing.tests.Simple layer\'>,\n+    (<Layer \'builtins.New child\'>, <Layer \'plone.testing.tests.Simple layer\'>,\n      <Layer \'plone.testing.layer.Null layer\'>,\n-     <Layer \'__builtin__.BaseLayer\'>)\n+     <Layer \'builtins.BaseLayer\'>)\n \n As with Python classes, it is possible to construct an invalid set of bases.\n In this case, layer instantiation will fail.::\n@@ -211,10 +211,10 @@ The layers are ordered in a known "resource resolution order", which is used to\n This is based on the same algorithm as Python\'s method resolution order.::\n \n     >>> LAYER4.baseResolutionOrder\n-    (<Layer \'__builtin__.Layer4\'>,\n-     <Layer \'__builtin__.Layer2\'>,\n-     <Layer \'__builtin__.Layer1\'>,\n-     <Layer \'__builtin__.Layer3\'>)\n+    (<Layer \'builtins.Layer4\'>,\n+     <Layer \'builtins.Layer2\'>,\n+     <Layer \'builtins.Layer1\'>,\n+     <Layer \'builtins.Layer3\'>)\n \n When fetching and item from a layer, it will be obtained according to the resource resolution order.::\n \n@@ -283,7 +283,7 @@ We want to demonstrate having two "branches" of bases that both happen to define\n     ...     def setUp(self):\n     ...         self[\'resource\'] = "Base 1"\n     ...     def testSetUp(self):\n-    ...         print self[\'resource\']\n+    ...         print(self[\'resource\'])\n     ...     def tearDown(self):\n     ...         del self[\'resource\']\n \n@@ -292,7 +292,7 @@ We want to demonstrate having two "branches" of bases that both happen to define\n     >>> class ResourceBaseLayer2(Layer):\n     ...     defaultBases = (RESOURCE_BASE_LAYER1,)\n     ...     def testSetUp(self):\n-    ...         print self[\'resource\']\n+    ...         print(self[\'resource\'])\n \n     >>> RESOURCE_BASE_LAYER2 = ResourceBaseLayer2()\n \n@@ -300,7 +300,7 @@ We want to demonstrate having two "branches" of bases that both happen to define\n     ...     def setUp(self):\n     ...         self[\'resource\'] = "Base 3"\n     ...     def testSetUp(self):\n-    ...         print self[\'resource\']\n+    ...         print(self[\'resource\'])\n     ...     def tearDown(self):\n     ...         del self[\'resource\']\n \n@@ -313,7 +313,7 @@ We\'ll then create the child layer that overrides this resource.::\n     ...     def setUp(self):\n     ...         self[\'resource\'] = "Child"\n     ...     def testSetUp(self):\n-    ...         print self[\'resource\']\n+    ...         print(self[\'resource\'])\n     ...     def tearDown(self):\n     ...         del self[\'resource\']\n \ndiff --git a/src/plone/testing/publisher.py b/src/plone/testing/publisher.py\nindex f3d03c1..eb1ca4d 100644\n--- a/src/plone/testing/publisher.py\n+++ b/src/plone/testing/publisher.py\n@@ -1,6 +1,7 @@\n # -*- coding: utf-8 -*-\n """Helpers for working with common Zope publisher operations\n """\n+from __future__ import absolute_import\n from plone.testing import Layer\n from plone.testing import security\n from plone.testing import zca\ndiff --git a/src/plone/testing/security.py b/src/plone/testing/security.py\nindex a435d41..b4ba7e3 100644\n--- a/src/plone/testing/security.py\n+++ b/src/plone/testing/security.py\n@@ -1,6 +1,7 @@\n # -*- coding: utf-8 -*-\n """Security helpers and layers\n """\n+from __future__ import absolute_import\n from plone.testing import Layer\n \n \n@@ -30,7 +31,8 @@ def popCheckers():\n \n     from zope.security import checker\n \n-    checker._checkers = _checkersStack.pop()\n+    checker._checkers.clear()\n+    checker._checkers.update(_checkersStack.pop())\n \n \n class Checkers(Layer):\ndiff --git a/src/plone/testing/security.rst b/src/plone/testing/security.rst\nindex 3423bd3..4a36e92 100644\n--- a/src/plone/testing/security.rst\n+++ b/src/plone/testing/security.rst\n@@ -26,10 +26,11 @@ Before the test, our custom checker is not in the registry.::\n     ...     pass\n \n     >>> from zope.security.interfaces import IChecker\n-    >>> from zope.interface import implements\n-    >>> class FauxChecker(object):\n-    ...     implements(IChecker)\n+    >>> from zope.interface import implementer\n+    >>> @implementer(IChecker)\n+    ... class FauxChecker(object):\n     ...     # we should really implement the interface here, but oh well\n+    ...     pass\n \n     >>> from zope.security.checker import getCheckerForInstancesOf\n     >>> getCheckerForInstancesOf(DummyObject) is None\ndiff --git a/src/plone/testing/tests.py b/src/plone/testing/tests.py\nindex 16766db..1a4e27c 100644\n--- a/src/plone/testing/tests.py\n+++ b/src/plone/testing/tests.py\n@@ -1,14 +1,24 @@\n # -*- coding: utf-8 -*-\n+from __future__ import absolute_import\n from OFS.SimpleItem import SimpleItem\n from pkg_resources import get_distribution\n+from zope.testing import renormalizing\n from ZPublisher.Iterators import filestream_iterator\n \n import doctest\n import os.path\n+import re\n import unittest\n import zope.component.testing\n \n \n+try:\n+    import ZServer  # noqa\n+except ImportError:\n+    HAS_ZSERVER = False\n+else:\n+    HAS_ZSERVER = True\n+\n # This is somewhat retarted. We execute README.rst as a doctest, mainly just\n # to test that the code samples import cleanly and are valid Python. However,\n # in there we also have a code sample of a doctest, which gets executed by the\n@@ -42,7 +52,7 @@ class DummyFile(SimpleItem):\n \n     def __call__(self):\n         path = get_distribution(\'plone.testing\').location\n-        path = os.path.join(path, \'plone\', \'testing\', \'z2.rst\')\n+        path = os.path.join(path, \'plone\', \'testing\', \'zope.rst\')\n \n         request = self.REQUEST\n         response = request.response\n@@ -59,6 +69,32 @@ def tearDown(self):\n     zope.component.testing.tearDown()\n \n \n+checker = renormalizing.RENormalizing([\n+    # normalize py2 output to py3\n+    (re.compile(r\'__builtin__\'), r\'builtins\'),\n+    (re.compile(\n+        r"\'Unknown directive\', u\'http://namespaces.zope.org/zope\', u\'"),\n+     r"\'Unknown directive\', \'http://namespaces.zope.org/zope\', \'"),\n+\n+    # normalize py3 output to py2\n+    (re.compile(\n+        r\'zope\\.configuration\\.xmlconfig\\.ZopeXMLConfigurationError\'),\n+     r\'ZopeXMLConfigurationError\'),\n+    (re.compile(r\'builtins\\.PopulatedZODB\'), r\'PopulatedZODB\'),\n+    (re.compile(r\'builtins\\.ExpandedZODB\'), r\'ExpandedZODB\'),\n+    (re.compile(r\'urllib\\.error\\.URLError\'), r\'URLError\'),\n+])\n+\n+\n+class TestZ2(unittest.TestCase):\n+    """Testing plone.testing.z2."""\n+\n+    def test_z2(self):\n+        """It can be imported. (It contains only BBB imports.)"""\n+        import plone.testing.z2\n+        self.assertIsNotNone(plone.testing.z2.ZSERVER)\n+\n+\n def test_suite():\n     suite = unittest.TestSuite()\n     suite.addTests([\n@@ -68,7 +104,8 @@ def test_suite():\n             \'security.rst\',\n             \'publisher.rst\',\n             \'zodb.rst\',\n-            \'z2.rst\',\n+            \'zope.rst\',\n+            checker=checker,\n             setUp=setUp,\n             tearDown=tearDown,\n             optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,\n@@ -81,4 +118,14 @@ def test_suite():\n             optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,\n         ),\n     ])\n+    if HAS_ZSERVER:\n+        suite.addTests([\n+            doctest.DocFileSuite(\n+                \'zserver.rst\',\n+                setUp=setUp,\n+                tearDown=tearDown,\n+                optionflags=doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE,\n+            ),\n+            unittest.TestLoader().loadTestsFromTestCase(TestZ2),\n+        ])\n     return suite\ndiff --git a/src/plone/testing/z2.py b/src/plone/testing/z2.py\nindex b83dd91..0cc7c42 100644\n--- a/src/plone/testing/z2.py\n+++ b/src/plone/testing/z2.py\n@@ -1,1165 +1,56 @@\n # -*- coding: utf-8 -*-\n-"""Zope2-specific helpers and layers\n-"""\n-from OFS.metaconfigure import get_packages_to_initialize\n-from plone.testing import Layer\n-from plone.testing import zca\n-from plone.testing import zodb\n-from plone.testing._z2_testbrowser import Browser  # noqa\n-from Testing.ZopeTestCase.ZopeLite import _patched as ZOPETESTCASEALERT\n-from Zope2.App.schema import Zope2VocabularyRegistry\n-from zope.schema.vocabulary import getVocabularyRegistry\n-from zope.schema.vocabulary import setVocabularyRegistry\n-\n-import contextlib\n-import os\n-import transaction\n-\n-\n-try:\n-    from plone.testing._z2_testbrowser import Browser  # noqa # BBB\n-except ImportError:\n-    # Just in case zope.testbrowser causes an import error, don\'t break\n-    pass\n-\n-\n-_INSTALLED_PRODUCTS = {}\n-\n-\n-class TestIsolationBroken(BaseException):\n-    pass\n-\n-\n-def installProduct(app, productName, quiet=False, multiinit=False):\n-    """Install the Zope 2 product with the given name, so that it will show\n-    up in the Zope 2 control panel and have its ``initialize()`` hook called.\n-\n-    The ``STARTUP`` layer or an equivalent layer must have been loaded first.\n-\n-    If ``quiet`` is False, an error will be logged if the product cannot be\n-    found. By default, the function is silent.\n-\n-    Note that products\' ZCML is *not* loaded automatically, even if the\n-    product is in the Products namespace.\n-    """\n-    from App.class_init import InitializeClass\n-    from OFS.Application import get_folder_permissions\n-    from OFS.Application import get_products\n-    from OFS.Application import install_package\n-    from OFS.Application import install_product\n-    from OFS.Folder import Folder\n-    import sys\n-\n-    found = False\n-\n-    if productName in _INSTALLED_PRODUCTS:\n-        return\n-\n-    if productName.startswith(\'Products.\'):\n-        for priority, name, index, productDir in get_products():\n-            if (\'Products.\' + name) == productName:\n-\n-                install_product(\n-                    app,\n-                    productDir,\n-                    name,\n-                    [],\n-                    get_folder_permissions(),\n-                    raise_exc=1)\n-                InitializeClass(Folder)\n-\n-                _INSTALLED_PRODUCTS[productName] = (\n-                    priority,\n-                    name,\n-                    index,\n-                    productDir,\n-                )\n-\n-                found = True\n-                break\n-\n-    else:\n-        packages = tuple(get_packages_to_initialize())\n-        for module, init_func in packages:\n-            if module.__name__ == productName:\n-                install_package(app, module, init_func, raise_exc=1)\n-                _INSTALLED_PRODUCTS[productName] = (module, init_func,)\n-\n-                found = True\n-                if not multiinit:\n-                    break\n-\n-    if not found and not quiet:\n-        sys.stderr.write(\n-            \'Could not install product {0}\\n\'.format(productName))\n-        sys.stderr.flush()\n-\n-\n-def uninstallProduct(app, productName, quiet=False):\n-    """Uninstall the given Zope 2 product. This is the inverse of\n-    ``installProduct()`` above.\n-    """\n-\n-    import sys\n-\n-    # from OFS.Folder import Folder\n-    # from OFS.Application import get_folder_permissions\n-    # from App.class_init import InitializeClass\n-\n-    from OFS.Application import Application, get_products\n-\n-    global _INSTALLED_PRODUCTS\n-    found = False\n-\n-    if productName not in _INSTALLED_PRODUCTS:\n-        return\n-\n-    if productName.startswith(\'Products.\'):\n-        for priority, name, index, productDir in get_products():\n-            if (\'Products.\' + name) == productName:\n-\n-                if name in Application.misc_.__dict__:\n-                    delattr(Application.misc_, name)\n-\n-                try:\n-                    cp = app[\'Control_Panel\'][\'Products\']\n-                except KeyError:\n-                    # Zope 4\n-                    pass\n-                else:\n-                    if name in cp:\n-                        product = cp[name]\n-\n-                        app._manage_remove_product_meta_type(product)\n-                        app._manage_remove_product_permission(product)\n-\n-                        del cp[name]\n-\n-                # TODO: Also remove permissions from get_folder_permissions?\n-                # Difficult to know if this would stomp on any other\n-                # permissions\n-                # InitializeClass(Folder)\n-\n-                found = True\n-                break\n-    elif productName in _INSTALLED_PRODUCTS:  # must be a package\n-\n-        module, init_func = _INSTALLED_PRODUCTS[productName]\n-        name = module.__name__\n-\n-        try:\n-            cp = app[\'Control_Panel\'][\'Products\']\n-        except KeyError:\n-            # Zope 4\n-            pass\n-        else:\n-            if name in cp:\n-                product = cp[name]\n-\n-                app._manage_remove_product_meta_type(product)\n-                app._manage_remove_product_permission(product)\n-\n-                del cp[name]\n-\n-        packages = get_packages_to_initialize()\n-        packages.append((module, init_func))\n-        found = True\n-\n-    if found:\n-        del _INSTALLED_PRODUCTS[productName]\n-\n-    if not found and not quiet:\n-        sys.stderr.write(\n-            \'Could not install product {0}\\n\'.format(productName))\n-        sys.stderr.flush()\n-\n-\n-def login(userFolder, userName):\n-    """Log in as the given user in the given user folder.\n-    """\n-\n-    from AccessControl.SecurityManagement import newSecurityManager\n-\n-    user = userFolder.getUser(userName)\n-    if user is None:\n-        raise ValueError(\'User could not be found\')\n-    if getattr(user, \'aq_base\', None) is None:\n-        user = user.__of__(userFolder)\n-    newSecurityManager(None, user)\n-\n-\n-def logout():\n-    """Log out, i.e. become anonymous\n-    """\n-\n-    from AccessControl.SecurityManagement import noSecurityManager\n-    noSecurityManager()\n-\n-\n-def setRoles(userFolder, userId, roles):\n-    """Set the given user\'s roles to a tuple of roles.\n-    """\n-\n-    userFolder.userFolderEditUser(userId, None, list(roles), [])\n-\n-    from AccessControl import getSecurityManager\n-    userName = userFolder.getUserById(userId).getUserName()\n-    if userName == getSecurityManager().getUser().getUserName():\n-        login(userFolder, userName)\n-\n-\n-def makeTestRequest(environ=None):\n-    """Return an HTTPRequest object suitable for testing views."""\n-    from sys import stdin, stdout\n-    from zope.publisher.browser import setDefaultSkin\n-    from ZPublisher.HTTPRequest import HTTPRequest\n-    from ZPublisher.HTTPResponse import HTTPResponse\n-\n-    if environ is None:\n-        environ = {}\n-    environ.setdefault(\'SERVER_NAME\', \'foo\')\n-    environ.setdefault(\'SERVER_PORT\', \'80\')\n-    environ.setdefault(\'REQUEST_METHOD\', \'GET\')\n-\n-    resp = HTTPResponse(stdout=stdout)\n-    req = HTTPRequest(stdin, environ, resp)\n-    req._steps = [\'noobject\']  # Fake a published object.\n-    req[\'ACTUAL_URL\'] = req.get(\'URL\')\n-    setDefaultSkin(req)\n-\n-    return req\n-\n-\n-def addRequestContainer(app, environ=None):\n-    """Add the request container with a fake request to the app object\'s\n-    acquisition context and return the wrapped app object. Additional request\n-    environment values can be passed as a dict ``environ``.\n-    """\n-\n-    from ZPublisher.BaseRequest import RequestContainer\n-    req = makeTestRequest(environ)\n-    requestcontainer = RequestContainer(REQUEST=req)\n-    return app.__of__(requestcontainer)\n-\n-\n-@contextlib.contextmanager\n-def zopeApp(db=None, connection=None, environ=None):\n-    """Context manager for working with the Zope2 app::\n-\n-        with zopeApp() as app:\n-            ...\n-\n-    The ``app`` object has a request container and a simple ``REQUEST``.\n-    To set the request environment, pass a dict ``environ``. See\n-    ``addRequestContainer()`` for details.\n-\n-    Pass a ZODB handle as ``db`` to use a specificdatabase. Alternatively,\n-    pass an open connection as ``connection`` (the connection will not be\n-    closed).\n-    """\n-    import Zope2\n-\n-    closeConn = True\n-    if connection is not None:\n-        closeConn = False\n-\n-    if connection is None and db is not None:\n-        connection = db.open()\n-\n-    app = addRequestContainer(Zope2.app(connection), environ=environ)\n-\n-    if connection is None:\n-        connection = app._p_jar\n-\n-    # exceptions in finally clauses can mask exceptions\n-    # in the preceeding code block. So we catch\n-    # every exception and throw it instead of the exception\n-    # in the finally clause\n-    inner_exception = None\n-    try:\n-        yield app\n-    except Exception as e:\n-        inner_exception = e\n-        try:\n-            transaction.abort()\n-        except Exception as e:\n-            inner_exception = e\n-            raise\n-        raise\n-    else:\n-        try:\n-            transaction.commit()\n-        except Exception as e:\n-            inner_exception = e\n-    finally:\n-        try:\n-            app.REQUEST.close()\n-            if closeConn:\n-                transaction.abort()\n-                connection.close()\n-        except Exception:\n-            if inner_exception:\n-                raise inner_exception\n-            else:\n-                raise\n-\n-\n-# Startup layer - you probably don\'t want to use this one directly\n-\n-class Startup(Layer):\n-    """This layer does what ZopeLite and ZopeTestCase\'s base.TestCase did:\n-    start up a minimal Zope instance and manages the application and\n-    request state.\n-\n-    You probably don\'t want to use this layer directly. Instead, you should\n-    use one of the layers that has it as a base.\n-\n-    The following resources are exposed:\n-\n-    * ``zodbDB`` is the ZODB with the test fixture\n-    * ``configurationContext`` is the ``zope.configuration`` context for\n-      ZCML loading.\n-    * ``host`` and ``port`` are the fake hostname and port number,\n-      respectively.\n-    """\n-\n-    defaultBases = (zca.LAYER_CLEANUP,)\n-\n-    threads = 1\n-\n-    # Layer lifecycle\n+from __future__ import absolute_import\n+from zope.deferredimport import deprecated\n+\n+import plone.testing\n+import plone.testing.zope\n+import warnings\n+\n+\n+deprecated(\n+    \'Please import from plone.testing.zope.\',\n+    Browser=\'plone.testing.zope:Browser\',\n+    TestIsolationBroken=\'plone.testing.zope:TestIsolationBroken\',\n+    installProduct=\'plone.testing.zope:installProduct\',\n+    uninstallProduct=\'plone.testing.zope:uninstallProduct\',\n+    login=\'plone.testing.zope:login\',\n+    logout=\'plone.testing.zope:logout\',\n+    setRoles=\'plone.testing.zope:setRoles\',\n+    makeTestRequest=\'plone.testing.zope:makeTestRequest\',\n+    addRequestContainer=\'plone.testing.zope:addRequestContainer\',\n+    zopeApp=\'plone.testing.zope:zopeApp\',\n+    Startup=\'plone.testing.zope:Startup\',\n+    STARTUP=\'plone.testing.zope:STARTUP\',\n+    IntegrationTesting=\'plone.testing.zope:IntegrationTesting\',\n+    INTEGRATION_TESTING=\'plone.testing.zope:INTEGRATION_TESTING\',\n+    FunctionalTesting=\'plone.testing.zope:FunctionalTesting\',\n+    FUNCTIONAL_TESTING=\'plone.testing.zope:FUNCTIONAL_TESTING\',\n+    ZServer=\'plone.testing.zope:WSGIServer\',\n+    ZSERVER_FIXTURE=\'plone.testing.zope:WSGI_SERVER_FIXTURE\',\n+    ZSERVER=\'plone.testing.zope:WSGI_SERVER\',\n+)\n+\n+\n+deprecated(\n+    \'Please import from plone.testing.\',\n+    Layer=\'plone.testing:Layer\',\n+)\n+\n+\n+class FTPServer(plone.testing.Layer):\n+    """No-op so imports do not break."""\n \n     def setUp(self):\n-        self.setUpDebugMode()\n-        self.setUpClientCache()\n-        self.setUpPatches()\n-        self.setUpThreads()\n-        self.setUpHostPort()\n-        self.setUpDatabase()\n-        self.setUpApp()\n-        self.setUpBasicProducts()\n-        self.setUpZCML()\n-        self.setUpFive()\n-\n-    def tearDown(self):\n-        self.tearDownFive()\n-        self.tearDownZCML()\n-        self.tearDownBasicProducts()\n-        self.tearDownApp()\n-        self.tearDownDatabase()\n-        self.tearDownHostPort()\n-        self.tearDownThreads()\n-        self.tearDownPatches()\n-        self.tearDownClientCache()\n-        self.tearDownDebugMode()\n-\n-    # Layer lifecycle helper methods\n-\n-    def setUpDebugMode(self):\n-        """Switch off debug mode in the global configuration\n-        """\n-\n-        import App.config\n-        config = App.config.getConfiguration()\n-        self._debugMode = config.debug_mode\n-        config.debug_mode = False\n-        App.config.setConfiguration(config)\n-\n-        # Set Python security mode\n-        from AccessControl.Implementation import setImplementation\n-        setImplementation(\'Python\')\n-\n-        # Set a flag so that other code can know that we are running tests.\n-        # Some of the speed-related patches in Plone use this, for instance.\n-        # The name is a BBB artefact from ZopeTestCase :\n-        import os\n-        os.environ[\'ZOPETESTCASE\'] = \'1\'\n-\n-    def tearDownDebugMode(self):\n-        """Return the debug mode flag to its previous state\n-        """\n-\n-        from AccessControl.Implementation import setImplementation\n-        setImplementation(\'C\')\n-\n-        import App.config\n-        config = App.config.getConfiguration()\n-        config.debug_mode = self._debugMode\n-        App.config.setConfiguration(config)\n-        del self._debugMode\n-\n-    def setUpClientCache(self):\n-        """Make sure we use a temporary client cache by altering the global\n-        configuration\n-        """\n-\n-        # Make sure we use a temporary client cache\n-        import App.config\n-        config = App.config.getConfiguration()\n-        self._zeoClientName = getattr(config, \'zeo_client_name\', None)\n-        config.zeo_client_name = None\n-        App.config.setConfiguration(config)\n-\n-    def tearDownClientCache(self):\n-        """Restore the cache configuration to its previous state\n-        """\n-\n-        # Make sure we use a temporary client cache\n-        import App.config\n-        config = App.config.getConfiguration()\n-        config.zeo_client_name = self._zeoClientName\n-        App.config.setConfiguration(config)\n-        del self._zeoClientName\n-\n-    def setUpPatches(self):\n-        """Apply monkey patches that disable unnecessary parts of Zope.\n-        This speeds up the test runs.\n-        """\n-\n-        import OFS.Application\n-        import App.ProductContext\n-        import Zope2.App.startup\n-\n-        # Avoid expensive product import\n-        def null_import_products():\n-            pass\n-        self._OFS_Application_import_products = OFS.Application.import_products\n-        OFS.Application.import_products = null_import_products\n-\n-        # Avoid expensive product installation\n-        def null_initialize(app):\n-            pass\n-        self._OFS_Application_initialize = OFS.Application.initialize\n-        OFS.Application.initialize = null_initialize\n-\n-        # Avoid expensive help registration\n-        try:\n-            self._App_ProductContext_ProductContext_registerHelpTopic = App.ProductContext.ProductContext.registerHelpTopic  # noqa\n-        except AttributeError:\n-            # Zope 4\n-            pass\n-        else:\n-            def null_register_topic(self, id, topic):\n-                pass\n-            App.ProductContext.ProductContext.registerHelpTopic = null_register_topic  # noqa\n-\n-            self._App_ProductContext_ProductContext_registerHelpTitle = App.ProductContext.ProductContext.registerHelpTitle  # noqa\n-\n-            def null_register_title(self, title):\n-                pass\n-            App.ProductContext.ProductContext.registerHelpTitle = null_register_title  # noqa\n-\n-            self._App_ProductContext_ProductContext_registerHelp = App.ProductContext.ProductContext.registerHelp  # noqa\n-\n-            def null_register_help(\n-                    self,\n-                    directory=\'\',\n-                    clear=1,\n-                    title_re=None):\n-                pass\n-            App.ProductContext.ProductContext.registerHelp = null_register_help\n-\n-        try:\n-            self._Zope2_App_startup_load_zcml = Zope2.App.startup.load_zcml\n-        except AttributeError:\n-            pass\n-        else:\n-            # in Zope 2.13, prevent ZCML from loading during App startup\n-            def null_load_zcml():\n-                pass\n-            Zope2.App.startup.load_zcml = null_load_zcml\n-\n-    def tearDownPatches(self):\n-        """Revert the monkey patches from setUpPatches()\n-        """\n-\n-        import OFS.Application\n-        import App.ProductContext\n-\n-        OFS.Application.import_products = self._OFS_Application_import_products\n-        del self._OFS_Application_import_products\n-\n-        OFS.Application.initialize = self._OFS_Application_initialize\n-        del self._OFS_Application_initialize\n-\n-        try:\n-            App.ProductContext.ProductContext.registerHelpTopic = self._App_ProductContext_ProductContext_registerHelpTopic  # noqa\n-        except AttributeError:\n-            # Zope 4\n-            pass\n-        else:\n-            del self._App_ProductContext_ProductContext_registerHelpTopic\n-\n-            App.ProductContext.ProductContext.registerHelpTitle = self._App_ProductContext_ProductContext_registerHelpTitle  # noqa\n-            del self._App_ProductContext_ProductContext_registerHelpTitle\n-\n-            App.ProductContext.ProductContext.registerHelp = self._App_ProductContext_ProductContext_registerHelp  # noqa\n-            del self._App_ProductContext_ProductContext_registerHelp\n-\n-    def setUpThreads(self):\n-        """Set the thread count for ZServer. This defaults to 1.\n-        """\n-\n-        # We can\'t use setNumberOfThreads() because that function self-\n-        # destructs, literally, when called.\n-\n-        import ZServer.PubCore\n-        self._zserverThreads = ZServer.PubCore._n\n-        ZServer.PubCore._n = self.threads\n-\n-    def tearDownThreads(self):\n-        """Reset the ZServer thread count.\n-        """\n-\n-        import ZServer.PubCore\n-        ZServer.PubCore._n = self._zserverThreads\n-        del self._zserverThreads\n-\n-    def setUpHostPort(self):\n-        """Set up the \'host\' and \'port\' resources\n-        """\n-\n-        self[\'host\'] = \'nohost\'\n-        self[\'port\'] = 80\n-\n-    def tearDownHostPort(self):\n-        """Pop the \'host\' and \'port\' resources\n-        """\n-\n-        del self[\'host\']\n-        del self[\'port\']\n-\n-    def setUpDatabase(self):\n-        """Create a database and stash it in the resource ``zodbDB``. If\n-        that resource exists, create a layered DemoStorage on top of the\n-        base database. Otherwise, create a new resource.\n-\n-        The database is registered in the global configuration so that\n-        Zope 2 app startup will find it. We use a facade object to ensure\n-        that the database that is opened by Zope 2 is in fact the top of\n-        the resource stack.\n-        """\n-        if ZOPETESTCASEALERT:\n-            raise Exception(\'You try to run plone.testing tests together with \'\n-                            \'ZopeTestCase tests. This will result in random \'\n-                            \'failures. Convert the ZopeTestCase Tests or \'\n-                            \'do not run them together\')\n-\n-        import Zope2.Startup.datatypes\n-        import App.config\n-\n-        # Layer a new storage for Zope 2 on top of the one from the base\n-        # layer, if there is one.\n-\n-        self[\'zodbDB\'] = zodb.stackDemoStorage(\n-            self.get(\'zodbDB\'),\n-            name=\'Startup\')\n-\n-        # Create a facade for the database object that will delegate to the\n-        # correct underlying database. This allows resource shadowing to work\n-        # with regular traversal, which relies on a module-level ``DB``\n-        # variable.\n-\n-        class DBFacade(object):\n-\n-            def __init__(self, layer):\n-                self.__layer = layer\n-\n-            @property\n-            def __db(self):\n-                return self.__layer[\'zodbDB\']\n-\n-            def __getattr__(self, name):\n-                return getattr(self.__db, name)\n-\n-        # Create a fake dbtab value in the config so that app startup will\n-        # use this one.\n-\n-        class DBTab(Zope2.Startup.datatypes.DBTab):\n-            """A fake DBTab that causes App.startup() to use our own database.\n-            """\n-\n-            def __init__(self, db):\n-                # value is never used when we have an open db\n-                self.db_factories = {\'testing\': None}\n-                self.mount_paths = {\'/\': \'testing\'}\n-                self.databases = {\'testing\': db}\n-\n-        config = App.config.getConfiguration()\n-        self._dbtab = getattr(config, \'dbtab\', None)\n-        config.dbtab = DBTab(DBFacade(self))\n-        App.config.setConfiguration(config)\n-\n-    def tearDownDatabase(self):\n-        """Close the database and pop the ``zodbDB`` resource. Restore the\n-        global database configuration to its previous state.\n-        """\n-\n-        import App.config\n-        config = App.config.getConfiguration()\n-        config.dbtab = self._dbtab\n-        App.config.setConfiguration(config)\n-        del self._dbtab\n-\n-        # Close and pop the zodbDB resource\n-        transaction.abort()\n-        self[\'zodbDB\'].close()\n-        del self[\'zodbDB\']\n-\n-    def setUpApp(self):\n-        """Trigger Zope startup and set up the application.\n-        """\n-\n-        # If the Testing module has been imported, the testinghome\n-        # variable is set and changes the way Zope2.startup() works.\n-        # We want the standard behavior so we remove it.\n-\n-        import App.config\n-        config = App.config.getConfiguration()\n-        try:\n-            self._testingHome = config.testinghome\n-        except AttributeError:\n-            pass\n-        else:\n-            del config.testinghome\n-            App.config.setConfiguration(config)\n-\n-        # This uses the DB from the dbtab, as configured in setUpDatabase().\n-        # That DB then gets stored as Zope2.DB and becomes the default.\n-\n-        import Zope2\n-        Zope2.startup()\n-\n-        # At this point, Zope2.DB is set to the test database facade. This is\n-        # the database will be used by default when someone does Zope2.app().\n-\n-    def tearDownApp(self):\n-        """Undo Zope 2 startup by unsetting the global state it creates.\n-        """\n-\n-        import Zope2\n-        Zope2.app()._p_jar.close()\n-\n-        Zope2._began_startup = 0\n-\n-        Zope2.DB = None\n-        Zope2.bobo_application = None\n-        Zope2.zpublisher_transactions_manager = None\n-        Zope2.zpublisher_validated_hook = None\n-        Zope2.zpublisher_exception_hook = None\n-        Zope2.__bobo_before__ = None\n-\n-        import App.config\n-        try:\n-            self._testingHome\n-        except AttributeError:\n-            pass\n-        else:\n-            config = App.config.getConfiguration()\n-            config.testinghome = self._testingHome\n-            App.config.setConfiguration(config)\n-            del self._testingHome\n-\n-        # Clear out the app reference cached in get_module_info\'s\n-        # \'modules\' parameter default dict. (waaaaa)\n-        import ZPublisher.Publish\n-        defaults = ZPublisher.Publish.get_module_info.func_defaults\n-\n-        if defaults:\n-            d = list(defaults)\n-            d[0] = {}\n-            ZPublisher.Publish.get_module_info.func_defaults = tuple(d)\n-\n-    def setUpBasicProducts(self):\n-        """Install a minimal set of products required for Zope 2.\n-        """\n-\n-        with zopeApp() as app:\n-            installProduct(app, \'Products.PluginIndexes\')\n-            installProduct(app, \'Products.OFSP\')\n-\n-    def tearDownBasicProducts(self):\n-        """Tear down the minimal set of products\n-        """\n-\n-        with zopeApp() as app:\n-            uninstallProduct(app, \'Products.PluginIndexes\')\n-            uninstallProduct(app, \'Products.OFSP\')\n-\n-        # It\'s possible for Five\'s _register_monkies and _meta_type_regs\n-        # global variables to contain duplicates. This causes an unecessary\n-        # error in the LayerCleanup layer\'s tear-down. Guard against that\n-        # here\n-\n-        try:\n-            from OFS import metaconfigure\n-        except ImportError:\n-            # Zope <= 2.12\n-            from Products.Five import fiveconfigure as metaconfigure\n-        metaconfigure._register_monkies = list(\n-            set(metaconfigure._register_monkies))\n-        metaconfigure._meta_type_regs = list(\n-            set(metaconfigure._meta_type_regs))\n-\n-    def setUpZCML(self):\n-        """Load the basic ZCML configuration from Five. Exposes a resource\n-        ``configurationContext`` which can be used to load further ZCML.\n-        """\n-\n-        # Push a new global registry so that we can cleanly tear down all ZCML\n-        from plone.testing import zca\n-        zca.pushGlobalRegistry()\n-\n-        # Load something akin to the default site.zcml without actually auto-\n-        # loading products\n-\n-        self[\'configurationContext\'] = context = zca.stackConfigurationContext(\n-            self.get(\'configurationContext\'))\n-\n-        from zope.configuration import xmlconfig\n-        xmlconfig.string("""\\\n-<configure\n-    xmlns="http://namespaces.zope.org/zope"\n-    xmlns:meta="http://namespaces.zope.org/meta">\n-\n-    <include package="Products.Five" />\n-    <meta:redefinePermission from="zope2.Public" to="zope.Public" />\n-\n-    <securityPolicy component="AccessControl.security.SecurityPolicy" />\n-\n-</configure>\n-""", context=context)\n-\n-    def tearDownZCML(self):\n-        """Tear down the component registry and delete the\n-        ``configurationContext`` resource.\n-        """\n-        # Delete the (possibly stacked) configuration context\n-        del self[\'configurationContext\']\n-\n-        # Zap all globally loaded ZCML\n-        from plone.testing import zca\n-        zca.popGlobalRegistry()\n-\n-    def setUpFive(self):\n-        """Initialize Five without loading the site.zcml file to avoid\n-        loading all Products.* .\n-\n-        This basically pushes a special vocabulary registry that\n-        supports global and local utilities.\n-        """\n-\n-        self._oldVocabularyRegistry = getVocabularyRegistry()\n-        setVocabularyRegistry(Zope2VocabularyRegistry())\n-\n-    def tearDownFive(self):\n-        """Tear down the Five initialization restoring the previous\n-        vocabulary registry.\n-        """\n-\n-        setVocabularyRegistry(self._oldVocabularyRegistry)\n-\n-\n-STARTUP = Startup()\n-\n-\n-# Basic integration and functional test and layers. These are the simplest\n-# Zope 2 layers that are generally useful\n-\n-class IntegrationTesting(Layer):\n-    """This layer extends ``STARTUP`` to add rollback of the transaction\n-    after each test. It does not manage a fixture and has no layer lifecyle,\n-    only a test lifecycle.\n-\n-    The application root is available as the resource ``app`` and the request\n-    is available as the resource ``request``, set up and torn down for each\n-    test.\n-\n-    Hint: If you want to create your own fixture on top of ``STARTUP``,\n-    create a new layer that has ``STARTUP`` as a base. Then instantiate\n-    this layer with your new "fixture" layer as a base, e.g.::\n-\n-        from plone.testing import z2\n-        from plone.testing import Layer\n-\n-        class MyFixture(Layer):\n-\n-            ...\n-\n-        MY_FIXTURE = MyFixture(bases=(z2.STARTUP,), name=\'MyFixture\')\n-        MY_INTEGRATION_TESTING = z2.IntegrationTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Integration\')  # noqa\n-    """\n-\n-    defaultBases = (STARTUP,)\n-\n-    # Test lifecycle\n-\n-    def testSetUp(self):\n-        import Zope2\n-\n-        # Open a new app and save it as the resource ``app``.\n-\n-        environ = {\n-            \'SERVER_NAME\': self[\'host\'],\n-            \'SERVER_PORT\': str(self[\'port\']),\n-        }\n-\n-        app = addRequestContainer(Zope2.app(), environ=environ)\n-        request = app.REQUEST\n-        request[\'PARENTS\'] = [app]\n-\n-        # Make sure we have a zope.globalrequest request\n-        try:\n-            from zope.globalrequest import setRequest\n-            setRequest(request)\n-        except ImportError:\n-            pass\n-\n-        # Start a transaction\n-        transaction.begin()\n-\n-        self._original_commit = transaction.commit\n-\n-        def you_broke_it():\n-            raise TestIsolationBroken("""You are in a Test Layer\n-(IntegrationTesting) that is fast by just aborting transactions between each\n-test.  You just committed something. That breaks the test isolation.  So I stop\n-here and let you fix it.""")\n-\n-        # XXX TODO Restore this.\n-        # Temporarily allow commits in integration tests.\n-        # Plone 5.1 still uses plone.testing 4.1.1, and for Zope 4 integration\n-        # we want master, but without the commit-breaking for now.\n-        # transaction.commit = you_broke_it\n-\n-        # Save resources for tests to access\n-        self[\'app\'] = app\n-        self[\'request\'] = request\n-\n-    def testTearDown(self):\n-\n-        # Abort the transaction\n-        transaction.abort()\n-\n-        transaction.commit = self._original_commit\n-\n-        # Make sure we have a zope.globalrequest request\n-        try:\n-            from zope.globalrequest import setRequest\n-            setRequest(None)\n-        except ImportError:\n-            pass\n-\n-        # Close the database connection and the request\n-        app = self[\'app\']\n-        app.REQUEST.close()\n-        app._p_jar.close()\n-\n-        # Delete the resources\n-        del self[\'request\']\n-        del self[\'app\']\n-\n-\n-INTEGRATION_TESTING = IntegrationTesting()\n-\n-\n-class FunctionalTesting(Layer):\n-    """An alternative to ``INTEGRATION_TESTING`` suitable for functional testing.\n-    This one pushes and pops a ``DemoStorage`` layer for each test. The\n-    net result is that a test may commit safely.\n-\n-    As with ``INTEGRATION_TESTING``, the application root is available as the\n-    resource ``app`` and the request is available as the resource ``request``,\n-    set up and torn down for each test.\n-\n-    Hint: If you want to create your own fixture on top of ``STARTUP``,\n-    create a new layer that has ``STARTUP`` as a base. Then instantiate\n-    this layer with your new "fixture" layer as a base, e.g.::\n-\n-        from plone.testing import z2\n-        from plone.testing import Layer\n-\n-        class MyFixture(Layer):\n-\n-            ...\n-\n-        MY_FIXTURE = MyFixture(bases=(z2.STARTUP,), name=\'MyFixture\')\n-        MY_FUNCTIONAL_TESTING = z2.FunctionalTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Functional\')  # noqa\n-    """\n-\n-    defaultBases = (STARTUP,)\n-\n-    # Test lifecycle\n-\n-    def testSetUp(self):\n-        import Zope2\n-\n-        # Override zodbDB from the layer setup. Since it was set up by\n-        # this layer, we can\'t just assign a new shadow. We therefore keep\n-        # track of the original so that we can restore it on tear-down.\n-\n-        self[\'zodbDB\'] = zodb.stackDemoStorage(\n-            self.get(\'zodbDB\'),\n-            name=\'FunctionalTest\')\n-\n-        # Save the app\n-\n-        environ = {\n-            \'SERVER_NAME\': self[\'host\'],\n-            \'SERVER_PORT\': str(self[\'port\']),\n-        }\n-\n-        app = addRequestContainer(Zope2.app(), environ=environ)\n-        request = app.REQUEST\n-        request[\'PARENTS\'] = [app]\n-\n-        # Make sure we have a zope.globalrequest request\n-        try:\n-            from zope.globalrequest import setRequest\n-            setRequest(request)\n-        except ImportError:\n-            pass\n-\n-        # Start a transaction\n-        transaction.begin()\n-\n-        # Save resources for the test\n-        self[\'app\'] = app\n-        self[\'request\'] = request\n-\n-    def testTearDown(self):\n-        # Abort any open transactions\n-        transaction.abort()\n-\n-        # Make sure we have a zope.globalrequest request\n-        try:\n-            from zope.globalrequest import setRequest\n-            setRequest(None)\n-        except ImportError:\n-            pass\n-\n-        # Close the database connection and the request\n-        app = self[\'app\']\n-        app.REQUEST.close()\n-        app._p_jar.close()\n-\n-        del self[\'app\']\n-        del self[\'request\']\n-\n-        # Close and discard the database\n-        self[\'zodbDB\'].close()\n-        del self[\'zodbDB\']\n-\n-\n-FUNCTIONAL_TESTING = FunctionalTesting()\n-\n-\n-# More advanced functional testing - running ZServer and FTP server\n-\n-class ZServer(Layer):\n-    """Start a ZServer that accesses the fixture managed by the\n-    ``STARTUP`` layer.\n-\n-    The host and port are available as the resources ``host`` and ``port``,\n-    respectively.\n-\n-    This should *not* be used in parallel with the ``FTP_SERVER`` layer, since\n-    it shares the same async loop.\n-\n-    The ``ZSERVER_FIXTURE`` layer must be used as the base for a layer that\n-    uses the ``FunctionalTesting`` layer class. The ``ZSERVER`` layer is\n-    an example of such a layer.\n-    """\n-\n-    defaultBases = (STARTUP,)\n-\n-    # Default to \'bindall\' (marked by an empty string) from os.socket\n-    host = os.environ.get(\'ZSERVER_HOST\', \'\')\n-    # Default to letting the OS allocate us a free port (marked by 0)\n-    port = int(os.environ.get(\'ZSERVER_PORT\', 0))\n-    timeout = 5.0\n-    log = None\n-\n-    def setUp(self):\n-\n-        import time\n-        from threading import Thread\n-\n-        self[\'host\'] = self.host\n-        self[\'port\'] = self.port\n-\n-        self._shutdown = False\n-\n-        self.setUpExceptionHook()\n-        self.setUpServer()\n-\n-        self.thread = Thread(\n-            name=\'{0} server\'.format(self.__name__),\n-            target=self.runner,\n-        )\n-\n-        self.thread.start()\n-        time.sleep(0.5)\n-\n-    def tearDown(self):\n-        import time\n-\n-        self._shutdown = True\n-        self.thread.join(self.timeout)\n-        time.sleep(0.5)\n-\n-        self.tearDownServer()\n-        self.tearDownExceptionHook()\n-\n-        del self[\'host\']\n-        del self[\'port\']\n-\n-    def setUpExceptionHook(self):\n-        from ZServer.ZPublisher.exceptionhook import EXCEPTION_HOOK\n-        import Zope2\n-        Zope2.zpublisher_exception_hook = EXCEPTION_HOOK\n-\n-    def tearDownExceptionHook(self):\n-        import Zope2\n-        Zope2.zpublisher_exception_hook = None\n-\n-    def setUpServer(self):\n-        """Create a ZServer server instance and save it in self.zserver\n-        """\n-\n-        from ZServer import zhttp_server, zhttp_handler, logger\n-        from StringIO import StringIO\n-\n-        log = self.log\n-        if log is None:\n-            log = StringIO()\n-\n-        zopeLog = logger.file_logger(log)\n-\n-        server = zhttp_server(\n-            ip=self.host,\n-            port=self.port,\n-            resolver=None,\n-            logger_object=zopeLog)\n-        zhttpHandler = zhttp_handler(module=\'Zope2\', uri_base=\'\')\n-        server.install_handler(zhttpHandler)\n-\n-        self.zserver = server\n-\n-        # If we dynamically set the host/port, we want to reset it to localhost\n-        # Otherwise this will depend on, for example, the local network setup\n-        if self.host in (\'\', \'0.0.0.0\', \'127.0.0.1\', ):\n-            self.zserver.server_name = \'localhost\'\n-\n-        # Refresh the hostname and port in case we dynamically picked them\n-        self.host = self.zserver.server_name\n-        self[\'host\'] = self.host\n-        self.port = self.zserver.server_port\n-        self[\'port\'] = self.port\n-\n-    def tearDownServer(self):\n-        """Close the ZServer socket\n-        """\n-        self.zserver.close()\n-\n-    # Thread runner\n-\n-    def runner(self):\n-        """Thread runner for the main asyncore loop. This function runs in a\n-        separate thread.\n-        """\n-\n-        import asyncore\n-\n-        # Poll\n-        socket_map = asyncore.socket_map\n-        while socket_map and not self._shutdown:\n-            asyncore.poll(self.timeout, socket_map)\n-\n-\n-# Fixture layer - use as a base layer, but don\'t use directly, as it has no\n-# test lifecycle\n-ZSERVER_FIXTURE = ZServer()\n-\n-# Functional testing layer that uses the ZSERVER_FIXTURE\n-ZSERVER = FunctionalTesting(\n-    bases=(\n-        ZSERVER_FIXTURE,\n-    ),\n-    name=\'ZServer:Functional\')\n-\n-\n-class FTPServer(ZServer):\n-    """FTP variant of the ZServer layer.\n-\n-    This will not play well with the ZServer layer. If you need both\n-    ZServer and FTPServer running together, you can subclass the ZServer\n-    layer class (like this layer class does) and implement setUpServer()\n-    and tearDownServer() to set up and close down two servers on different\n-    ports. They will then share a main loop.\n-\n-    The ``FTP_SERVER_FIXTURE`` layer must be used as the base for a layer that\n-    uses the ``FunctionalTesting`` layer class. The ``FTP_SERVER`` layer is\n-    an example of such a layer.\n-    """\n-\n-    defaultBases = (STARTUP,)\n-\n-    # Default to \'bindall\' (marked by an empty string) from os.socket\n-    host = os.environ.get(\'FTPSERVER_HOST\', \'\')\n-    # Default to letting the OS allocate us a free port (marked by 0)\n-    port = int(os.environ.get(\'FTPSERVER_PORT\', 0))\n-    threads = 1\n-    timeout = 5.0\n-    log = None\n-\n-    def setUpServer(self):\n-        """Create an FTP server instance and save it in self.ftpServer\n-        """\n-\n-        from ZServer import logger\n-        from ZServer.FTPServer import FTPServer\n-        from StringIO import StringIO\n-\n-        log = self.log\n-        if log is None:\n-            log = StringIO()\n-\n-        zopeLog = logger.file_logger(log)\n-\n-        self.ftpServer = FTPServer(\n-            \'Zope2\',\n-            ip=self.host,\n-            port=self.port,\n-            logger_object=zopeLog)\n-\n-\n-        # Refresh the hostname and port in case we dynamically picked them\n-        self.host, self.port = self.ftpServer.socket.getsockname()\n-\n-        # If we dynamically set the host/port, we want to reset it to localhost\n-        # Otherwise this will depend on, for example, the local network setup\n-        if self.host in (\'\', \'0.0.0.0\', \'127.0.0.1\', ):\n-            self.host = \'localhost\'\n-            self.ftpServer.hostname = \'localhost\'\n-            self.ftpServer.ip = \'127.0.0.1\'\n-\n-        self[\'host\'] = self.host\n-        self[\'port\'] = self.port\n-\n-    def tearDownServer(self):\n-        """Close the FTPServer socket\n-        """\n-        self.ftpServer.close()\n+        warnings.warn(\n+            \'The FTPServer layer is now only a no-op as FTP is not supported\'\n+            \' by WSGI. If you really need the fixture import it from\'\n+            \' plone.testing.zserver.\')\n \n \n-# Fixture layer - use as a base layer, but don\'t use directly, as it has no\n-# test lifecycle\n FTP_SERVER_FIXTURE = FTPServer()\n \n-# Functional testing layer that uses the FTP_SERVER_FIXTURE\n-FTP_SERVER = FunctionalTesting(\n+FTP_SERVER = plone.testing.zope.FunctionalTesting(\n     bases=(\n         FTP_SERVER_FIXTURE,\n     ),\n-    name=\'FTPServer:Functional\')\n+    name=\'No-OpFTPServer:Functional\')\ndiff --git a/src/plone/testing/zca.py b/src/plone/testing/zca.py\nindex f0ff0c4..8bf10c3 100644\n--- a/src/plone/testing/zca.py\n+++ b/src/plone/testing/zca.py\n@@ -1,6 +1,7 @@\n # -*- coding: utf-8 -*-\n """Core Zope Component Architecture helpers and layers\n """\n+from __future__ import absolute_import\n from plone.testing import Layer\n from zope.configuration.config import ConfigurationMachine\n \ndiff --git a/src/plone/testing/zca.rst b/src/plone/testing/zca.rst\nindex ce9eb0e..5c1f5ee 100644\n--- a/src/plone/testing/zca.rst\n+++ b/src/plone/testing/zca.rst\n@@ -286,12 +286,12 @@ The second registry is set up and torn down for each test, allowing tests to reg\n \n First, we\'ll create a simple dummy utility to illustrate registrations.::\n \n-    >>> from zope.interface import Interface, implements\n+    >>> from zope.interface import Interface, implementer\n \n     >>> class IDummyUtility(Interface):\n     ...     pass\n-    >>> class DummyUtility(object):\n-    ...     implements(IDummyUtility)\n+    >>> @implementer(IDummyUtility)\n+    ... class DummyUtility(object):\n     ...     def __init__(self, name):\n     ...         self.name = name\n     ...     def __repr__(self):\ndiff --git a/src/plone/testing/zope.py b/src/plone/testing/zope.py\nnew file mode 100644\nindex 0000000..8657598\n--- /dev/null\n+++ b/src/plone/testing/zope.py\n@@ -0,0 +1,971 @@\n+# -*- coding: utf-8 -*-\n+"""Zope-specific helpers and layers using WSGI\n+"""\n+from __future__ import absolute_import\n+from OFS.metaconfigure import get_packages_to_initialize\n+from plone.testing import Layer\n+from plone.testing import zca\n+from plone.testing import zodb\n+from plone.testing._z2_testbrowser import Browser  # noqa\n+from Testing.ZopeTestCase.ZopeLite import _patched as ZOPETESTCASEALERT\n+from webtest.http import StopableWSGIServer\n+from Zope2.App.schema import Zope2VocabularyRegistry\n+from zope.schema.vocabulary import getVocabularyRegistry\n+from zope.schema.vocabulary import setVocabularyRegistry\n+\n+import contextlib\n+import os\n+import pkg_resources\n+import shutil\n+import tempfile\n+import transaction\n+import Zope2.Startup.run\n+import ZPublisher.WSGIPublisher\n+\n+\n+_INSTALLED_PRODUCTS = {}\n+\n+\n+class TestIsolationBroken(BaseException):\n+    pass\n+\n+\n+def installProduct(app, productName, quiet=False, multiinit=False):\n+    """Install the Zope 2 product with the given name, so that it will show\n+    up in the Zope 2 control panel and have its ``initialize()`` hook called.\n+\n+    The ``STARTUP`` layer or an equivalent layer must have been loaded first.\n+\n+    If ``quiet`` is False, an error will be logged if the product cannot be\n+    found. By default, the function is silent.\n+\n+    Note that products\' ZCML is *not* loaded automatically, even if the\n+    product is in the Products namespace.\n+    """\n+    from AccessControl.class_init import InitializeClass\n+    from OFS.Application import get_folder_permissions\n+    from OFS.Application import get_products\n+    from OFS.Application import install_package\n+    from OFS.Application import install_product\n+    from OFS.Folder import Folder\n+    import sys\n+\n+    found = False\n+\n+    if productName in _INSTALLED_PRODUCTS:\n+        return\n+\n+    if productName.startswith(\'Products.\'):\n+        for priority, name, index, productDir in get_products():\n+            if (\'Products.\' + name) == productName:\n+\n+                install_product(\n+                    app,\n+                    productDir,\n+                    name,\n+                    [],\n+                    get_folder_permissions(),\n+                    raise_exc=1)\n+                InitializeClass(Folder)\n+\n+                _INSTALLED_PRODUCTS[productName] = (\n+                    priority,\n+                    name,\n+                    index,\n+                    productDir,\n+                )\n+\n+                found = True\n+                break\n+\n+    else:\n+        packages = tuple(get_packages_to_initialize())\n+        for module, init_func in packages:\n+            if module.__name__ == productName:\n+                install_package(app, module, init_func, raise_exc=1)\n+                _INSTALLED_PRODUCTS[productName] = (module, init_func,)\n+\n+                found = True\n+                if not multiinit:\n+                    break\n+\n+    if not found and not quiet:\n+        sys.stderr.write(\n+            \'Could not install product {0}\\n\'.format(productName))\n+        sys.stderr.flush()\n+\n+\n+def uninstallProduct(app, productName, quiet=False):\n+    """Uninstall the given Zope 2 product. This is the inverse of\n+    ``installProduct()`` above.\n+    """\n+\n+    import sys\n+\n+    # from OFS.Folder import Folder\n+    # from OFS.Application import get_folder_permissions\n+    # from AccessControl.class_init import InitializeClass\n+\n+    from OFS.Application import Application, get_products\n+\n+    global _INSTALLED_PRODUCTS\n+    found = False\n+\n+    if productName not in _INSTALLED_PRODUCTS:\n+        return\n+\n+    if productName.startswith(\'Products.\'):\n+        for priority, name, index, productDir in get_products():\n+            if (\'Products.\' + name) == productName:\n+\n+                if name in Application.misc_.__dict__:\n+                    delattr(Application.misc_, name)\n+\n+                # TODO: Also remove permissions from get_folder_permissions?\n+                # Difficult to know if this would stomp on any other\n+                # permissions\n+                # InitializeClass(Folder)\n+\n+                found = True\n+                break\n+    elif productName in _INSTALLED_PRODUCTS:  # must be a package\n+\n+        module, init_func = _INSTALLED_PRODUCTS[productName]\n+        name = module.__name__\n+\n+        packages = get_packages_to_initialize()\n+        packages.append((module, init_func))\n+        found = True\n+\n+    if found:\n+        del _INSTALLED_PRODUCTS[productName]\n+\n+    if not found and not quiet:\n+        sys.stderr.write(\n+            \'Could not install product {0}\\n\'.format(productName))\n+        sys.stderr.flush()\n+\n+\n+def login(userFolder, userName):\n+    """Log in as the given user in the given user folder.\n+    """\n+\n+    from AccessControl.SecurityManagement import newSecurityManager\n+\n+    user = userFolder.getUser(userName)\n+    if user is None:\n+        raise ValueError(\'User could not be found\')\n+    if getattr(user, \'aq_base\', None) is None:\n+        user = user.__of__(userFolder)\n+    newSecurityManager(None, user)\n+\n+\n+def logout():\n+    """Log out, i.e. become anonymous\n+    """\n+\n+    from AccessControl.SecurityManagement import noSecurityManager\n+    noSecurityManager()\n+\n+\n+def setRoles(userFolder, userId, roles):\n+    """Set the given user\'s roles to a tuple of roles.\n+    """\n+\n+    userFolder.userFolderEditUser(userId, None, list(roles), [])\n+\n+    from AccessControl import getSecurityManager\n+    userName = userFolder.getUserById(userId).getUserName()\n+    if userName == getSecurityManager().getUser().getUserName():\n+        login(userFolder, userName)\n+\n+\n+def makeTestRequest(environ=None):\n+    """Return an HTTPRequest object suitable for testing views."""\n+    from sys import stdin, stdout\n+    from zope.publisher.browser import setDefaultSkin\n+    from ZPublisher.HTTPRequest import HTTPRequest\n+    from ZPublisher.HTTPResponse import HTTPResponse\n+\n+    if environ is None:\n+        environ = {}\n+    environ.setdefault(\'SERVER_NAME\', \'foo\')\n+    environ.setdefault(\'SERVER_PORT\', \'80\')\n+    environ.setdefault(\'REQUEST_METHOD\', \'GET\')\n+\n+    resp = HTTPResponse(stdout=stdout)\n+    req = HTTPRequest(stdin, environ, resp)\n+    req._steps = [\'noobject\']  # Fake a published object.\n+    req[\'ACTUAL_URL\'] = req.get(\'URL\')\n+    setDefaultSkin(req)\n+\n+    return req\n+\n+\n+def addRequestContainer(app, environ=None):\n+    """Add the request container with a fake request to the app object\'s\n+    acquisition context and return the wrapped app object. Additional request\n+    environment values can be passed as a dict ``environ``.\n+    """\n+\n+    from ZPublisher.BaseRequest import RequestContainer\n+    req = makeTestRequest(environ)\n+    requestcontainer = RequestContainer(REQUEST=req)\n+    return app.__of__(requestcontainer)\n+\n+\n+@contextlib.contextmanager\n+def zopeApp(db=None, connection=None, environ=None):\n+    """Context manager for working with the Zope2 app::\n+\n+        with zopeApp() as app:\n+            ...\n+\n+    The ``app`` object has a request container and a simple ``REQUEST``.\n+    To set the request environment, pass a dict ``environ``. See\n+    ``addRequestContainer()`` for details.\n+\n+    Pass a ZODB handle as ``db`` to use a specificdatabase. Alternatively,\n+    pass an open connection as ``connection`` (the connection will not be\n+    closed).\n+    """\n+    import Zope2\n+\n+    closeConn = True\n+    if connection is not None:\n+        closeConn = False\n+\n+    if connection is None and db is not None:\n+        connection = db.open()\n+\n+    assert Zope2._began_startup, \\\n+        "Zope2 WSGI is not started, maybe mixing Zope and ZServer layers."\n+    app = addRequestContainer(Zope2.app(connection), environ=environ)\n+\n+    if connection is None:\n+        connection = app._p_jar\n+\n+    # exceptions in finally clauses can mask exceptions\n+    # in the preceeding code block. So we catch\n+    # every exception and throw it instead of the exception\n+    # in the finally clause\n+    inner_exception = None\n+    try:\n+        yield app\n+    except Exception as e:\n+        inner_exception = e\n+        try:\n+            transaction.abort()\n+        except Exception as e:\n+            inner_exception = e\n+            raise\n+        raise\n+    else:\n+        try:\n+            transaction.commit()\n+        except Exception as e:\n+            inner_exception = e\n+    finally:\n+        try:\n+            app.REQUEST.close()\n+            if closeConn:\n+                transaction.abort()\n+                connection.close()\n+        except Exception:\n+            if inner_exception:\n+                raise inner_exception\n+            else:\n+                raise\n+\n+\n+# Startup layer - you probably don\'t want to use this one directly\n+\n+class Startup(Layer):\n+    """This layer does what ZopeLite and ZopeTestCase\'s base.TestCase did:\n+    start up a minimal Zope instance and manages the application and\n+    request state.\n+\n+    You probably don\'t want to use this layer directly. Instead, you should\n+    use one of the layers that has it as a base.\n+\n+    The following resources are exposed:\n+\n+    * ``zodbDB`` is the ZODB with the test fixture\n+    * ``configurationContext`` is the ``zope.configuration`` context for\n+      ZCML loading.\n+    * ``host`` and ``port`` are the fake hostname and port number,\n+      respectively.\n+    """\n+\n+    defaultBases = (zca.LAYER_CLEANUP,)\n+\n+    threads = 1\n+\n+    # Layer lifecycle\n+\n+    def setUp(self):\n+        self.setUpDebugMode()\n+        self.setUpClientCache()\n+        self.setUpPatches()\n+        self.setUpThreads()\n+        self.setUpHostPort()\n+        self.setUpDatabase()\n+        self.setUpApp()\n+        self.setUpBasicProducts()\n+        self.setUpZCML()\n+        self.setUpFive()\n+\n+    def tearDown(self):\n+        self.tearDownFive()\n+        self.tearDownZCML()\n+        self.tearDownBasicProducts()\n+        self.tearDownApp()\n+        self.tearDownDatabase()\n+        self.tearDownHostPort()\n+        self.tearDownThreads()\n+        self.tearDownPatches()\n+        self.tearDownClientCache()\n+        self.tearDownDebugMode()\n+\n+    # Layer lifecycle helper methods\n+\n+    def setUpDebugMode(self):\n+        """Switch off debug mode in the global configuration\n+        """\n+\n+        import App.config\n+        config = App.config.getConfiguration()\n+        self._debugMode = config.debug_mode\n+        config.debug_mode = False\n+        App.config.setConfiguration(config)\n+\n+        # Set Python security mode\n+        from AccessControl.Implementation import setImplementation\n+        setImplementation(\'Python\')\n+\n+        # Set a flag so that other code can know that we are running tests.\n+        # Some of the speed-related patches in Plone use this, for instance.\n+        # The name is a BBB artefact from ZopeTestCase :\n+        import os\n+        os.environ[\'ZOPETESTCASE\'] = \'1\'\n+\n+    def tearDownDebugMode(self):\n+        """Return the debug mode flag to its previous state\n+        """\n+\n+        from AccessControl.Implementation import setImplementation\n+        setImplementation(\'C\')\n+\n+        import App.config\n+        config = App.config.getConfiguration()\n+        config.debug_mode = self._debugMode\n+        App.config.setConfiguration(config)\n+        del self._debugMode\n+\n+    def setUpClientCache(self):\n+        """Make sure we use a temporary client cache by altering the global\n+        configuration\n+        """\n+\n+        # Make sure we use a temporary client cache\n+        import App.config\n+        config = App.config.getConfiguration()\n+        self._zeoClientName = getattr(config, \'zeo_client_name\', None)\n+        config.zeo_client_name = None\n+        App.config.setConfiguration(config)\n+\n+    def tearDownClientCache(self):\n+        """Restore the cache configuration to its previous state\n+        """\n+\n+        # Make sure we use a temporary client cache\n+        import App.config\n+        config = App.config.getConfiguration()\n+        config.zeo_client_name = self._zeoClientName\n+        App.config.setConfiguration(config)\n+        del self._zeoClientName\n+\n+    def setUpPatches(self):\n+        """Apply monkey patches that disable unnecessary parts of Zope.\n+        This speeds up the test runs.\n+        """\n+\n+        import OFS.Application\n+        import Zope2.App.startup\n+\n+        # Avoid expensive product import\n+        def null_import_products():\n+            pass\n+        self._OFS_Application_import_products = OFS.Application.import_products\n+        OFS.Application.import_products = null_import_products\n+\n+        # Avoid expensive product installation\n+        def null_initialize(app):\n+            pass\n+        self._OFS_Application_initialize = OFS.Application.initialize\n+        OFS.Application.initialize = null_initialize\n+\n+        # Prevent ZCML from loading during App startup:\n+        self._Zope2_App_startup_load_zcml = Zope2.App.startup.load_zcml\n+\n+        def null_load_zcml():\n+            pass\n+\n+        Zope2.App.startup.load_zcml = null_load_zcml\n+\n+    def tearDownPatches(self):\n+        """Revert the monkey patches from setUpPatches()\n+        """\n+\n+        import OFS.Application\n+\n+        OFS.Application.import_products = self._OFS_Application_import_products\n+        del self._OFS_Application_import_products\n+\n+        OFS.Application.initialize = self._OFS_Application_initialize\n+        del self._OFS_Application_initialize\n+\n+        Zope2.App.startup.load_zcml = self._Zope2_App_startup_load_zcml\n+\n+    def setUpThreads(self):\n+        """Set the thread count. Only needed in ZServer.\n+        """\n+        pass\n+\n+    def tearDownThreads(self):\n+        """Reset the thread count. Only needed in ZServer.\n+        """\n+        pass\n+\n+    def setUpHostPort(self):\n+        """Set up the \'host\' and \'port\' resources\n+        """\n+\n+        self[\'host\'] = \'nohost\'\n+        self[\'port\'] = 80\n+\n+    def tearDownHostPort(self):\n+        """Pop the \'host\' and \'port\' resources\n+        """\n+\n+        del self[\'host\']\n+        del self[\'port\']\n+\n+    def setUpDatabase(self):\n+        """Create a database and stash it in the resource ``zodbDB``. If\n+        that resource exists, create a layered DemoStorage on top of the\n+        base database. Otherwise, create a new resource.\n+\n+        The database is registered in the global configuration so that\n+        Zope 2 app startup will find it. We use a facade object to ensure\n+        that the database that is opened by Zope 2 is in fact the top of\n+        the resource stack.\n+        """\n+        if ZOPETESTCASEALERT:\n+            raise Exception(\'You try to run plone.testing tests together with \'\n+                            \'ZopeTestCase tests. This will result in random \'\n+                            \'failures. Convert the ZopeTestCase Tests or \'\n+                            \'do not run them together\')\n+\n+        import Zope2.Startup.datatypes\n+        import App.config\n+\n+        # Layer a new storage for Zope 2 on top of the one from the base\n+        # layer, if there is one.\n+\n+        self[\'zodbDB\'] = zodb.stackDemoStorage(\n+            self.get(\'zodbDB\'),\n+            name=\'Startup\')\n+\n+        # Create a facade for the database object that will delegate to the\n+        # correct underlying database. This allows resource shadowing to work\n+        # with regular traversal, which relies on a module-level ``DB``\n+        # variable.\n+\n+        class DBFacade(object):\n+\n+            def __init__(self, layer):\n+                self.__layer = layer\n+\n+            @property\n+            def __db(self):\n+                return self.__layer[\'zodbDB\']\n+\n+            def __getattr__(self, name):\n+                return getattr(self.__db, name)\n+\n+        # Create a fake dbtab value in the config so that app startup will\n+        # use this one.\n+\n+        class DBTab(Zope2.Startup.datatypes.DBTab):\n+            """A fake DBTab that causes App.startup() to use our own database.\n+            """\n+\n+            def __init__(self, db):\n+                # value is never used when we have an open db\n+                self.db_factories = {\'testing\': None}\n+                self.mount_paths = {\'/\': \'testing\'}\n+                self.databases = {\'testing\': db}\n+\n+        config = App.config.getConfiguration()\n+        self._dbtab = getattr(config, \'dbtab\', None)\n+        config.dbtab = DBTab(DBFacade(self))\n+        App.config.setConfiguration(config)\n+\n+    def tearDownDatabase(self):\n+        """Close the database and pop the ``zodbDB`` resource. Restore the\n+        global database configuration to its previous state.\n+        """\n+\n+        import App.config\n+        config = App.config.getConfiguration()\n+        config.dbtab = self._dbtab\n+        App.config.setConfiguration(config)\n+        del self._dbtab\n+\n+        # Close and pop the zodbDB resource\n+        transaction.abort()\n+        self[\'zodbDB\'].close()\n+        del self[\'zodbDB\']\n+\n+    def setUpApp(self):\n+        """Trigger Zope startup and set up the application.\n+        """\n+\n+        # If the Testing module has been imported, the testinghome\n+        # variable is set and changes the way Zope2.startup() works.\n+        # We want the standard behavior so we remove it.\n+\n+        import App.config\n+        config = App.config.getConfiguration()\n+        try:\n+            self._testingHome = config.testinghome\n+        except AttributeError:\n+            pass\n+        else:\n+            del config.testinghome\n+            App.config.setConfiguration(config)\n+\n+        # Clean up after ZopeLite layer\n+        import ZPublisher.WSGIPublisher\n+        ZPublisher.WSGIPublisher._MODULES.clear()\n+        self._publisher_globals = {\n+            \'load_app\': ZPublisher.WSGIPublisher.load_app\n+        }\n+        if hasattr(ZPublisher.WSGIPublisher, \'__old_load_app__\'):\n+            old_load_app = ZPublisher.WSGIPublisher.__old_load_app__\n+            ZPublisher.WSGIPublisher.load_app = old_load_app\n+            self._publisher_globals[\'__old_load_app__\'] = old_load_app\n+            del ZPublisher.WSGIPublisher.__old_load_app__\n+\n+        # This uses the DB from the dbtab, as configured in setUpDatabase().\n+        # That DB then gets stored as Zope2.DB and becomes the default.\n+\n+        import Zope2\n+        Zope2._began_startup = 0\n+        Zope2.startup_wsgi()\n+\n+        # At this point, Zope2.DB is set to the test database facade. This is\n+        # the database will be used by default when someone does Zope2.app().\n+\n+    def tearDownApp(self):\n+        """Undo Zope 2 startup by unsetting the global state it creates.\n+        """\n+\n+        import Zope2\n+        Zope2.app()._p_jar.close()\n+\n+        Zope2._began_startup = 0\n+\n+        Zope2.DB = None\n+        Zope2.bobo_application = None\n+        Zope2.zpublisher_transactions_manager = None\n+        Zope2.zpublisher_validated_hook = None\n+        Zope2.zpublisher_exception_hook = None\n+        Zope2.__bobo_before__ = None\n+\n+        import App.config\n+        try:\n+            self._testingHome\n+        except AttributeError:\n+            pass\n+        else:\n+            config = App.config.getConfiguration()\n+            config.testinghome = self._testingHome\n+            App.config.setConfiguration(config)\n+            del self._testingHome\n+\n+        import ZPublisher.WSGIPublisher\n+        ZPublisher.WSGIPublisher._MODULES.clear()\n+        for k, v in self._publisher_globals.items():\n+            setattr(ZPublisher.WSGIPublisher, k, v)\n+\n+    def setUpBasicProducts(self):\n+        """Install a minimal set of products required for Zope 2.\n+        """\n+\n+        with zopeApp() as app:\n+            installProduct(app, \'Products.PluginIndexes\')\n+            installProduct(app, \'Products.OFSP\')\n+\n+    def tearDownBasicProducts(self):\n+        """Tear down the minimal set of products\n+        """\n+\n+        with zopeApp() as app:\n+            uninstallProduct(app, \'Products.PluginIndexes\')\n+            uninstallProduct(app, \'Products.OFSP\')\n+\n+        # It\'s possible for Five\'s _register_monkies and _meta_type_regs\n+        # global variables to contain duplicates. This causes an unecessary\n+        # error in the LayerCleanup layer\'s tear-down. Guard against that\n+        # here\n+\n+        try:\n+            from OFS import metaconfigure\n+        except ImportError:\n+            # Zope <= 2.12\n+            from Products.Five import fiveconfigure as metaconfigure\n+        metaconfigure._register_monkies = list(\n+            set(metaconfigure._register_monkies))\n+        metaconfigure._meta_type_regs = list(\n+            set(metaconfigure._meta_type_regs))\n+\n+    def setUpZCML(self):\n+        """Load the basic ZCML configuration from Five. Exposes a resource\n+        ``configurationContext`` which can be used to load further ZCML.\n+        """\n+\n+        # Push a new global registry so that we can cleanly tear down all ZCML\n+        from plone.testing import zca\n+        zca.pushGlobalRegistry()\n+\n+        # Load something akin to the default site.zcml without actually auto-\n+        # loading products\n+\n+        self[\'configurationContext\'] = context = zca.stackConfigurationContext(\n+            self.get(\'configurationContext\'))\n+\n+        from zope.configuration import xmlconfig\n+        xmlconfig.string("""\\\n+<configure\n+    xmlns="http://namespaces.zope.org/zope"\n+    xmlns:meta="http://namespaces.zope.org/meta">\n+\n+    <include package="Products.Five" />\n+    <meta:redefinePermission from="zope2.Public" to="zope.Public" />\n+\n+    <securityPolicy component="AccessControl.security.SecurityPolicy" />\n+\n+</configure>\n+""", context=context)\n+\n+    def tearDownZCML(self):\n+        """Tear down the component registry and delete the\n+        ``configurationContext`` resource.\n+        """\n+        # Delete the (possibly stacked) configuration context\n+        del self[\'configurationContext\']\n+\n+        # Zap all globally loaded ZCML\n+        from plone.testing import zca\n+        zca.popGlobalRegistry()\n+\n+    def setUpFive(self):\n+        """Initialize Five without loading the site.zcml file to avoid\n+        loading all Products.* .\n+\n+        This basically pushes a special vocabulary registry that\n+        supports global and local utilities.\n+        """\n+\n+        self._oldVocabularyRegistry = getVocabularyRegistry()\n+        setVocabularyRegistry(Zope2VocabularyRegistry())\n+\n+    def tearDownFive(self):\n+        """Tear down the Five initialization restoring the previous\n+        vocabulary registry.\n+        """\n+\n+        setVocabularyRegistry(self._oldVocabularyRegistry)\n+\n+\n+STARTUP = Startup()\n+\n+\n+# Basic integration and functional test and layers. These are the simplest\n+# Zope layers that are generally useful\n+\n+class IntegrationTesting(Layer):\n+    """This layer extends ``STARTUP`` to add rollback of the transaction\n+    after each test. It does not manage a fixture and has no layer lifecyle,\n+    only a test lifecycle.\n+\n+    The application root is available as the resource ``app`` and the request\n+    is available as the resource ``request``, set up and torn down for each\n+    test.\n+\n+    Hint: If you want to create your own fixture on top of ``STARTUP``,\n+    create a new layer that has ``STARTUP`` as a base. Then instantiate\n+    this layer with your new "fixture" layer as a base, e.g.::\n+\n+        from plone.testing import wsgi\n+        from plone.testing import Layer\n+\n+        class MyFixture(Layer):\n+\n+            ...\n+\n+        MY_FIXTURE = MyFixture(bases=(wsgi.STARTUP,), name=\'MyFixture\')\n+        MY_INTEGRATION_TESTING = wsgi.IntegrationTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Integration\')  # noqa\n+    """\n+\n+    defaultBases = (STARTUP,)\n+\n+    # Test lifecycle\n+\n+    def testSetUp(self):\n+        import Zope2\n+\n+        # Open a new app and save it as the resource ``app``.\n+\n+        environ = {\n+            \'SERVER_NAME\': self[\'host\'],\n+            \'SERVER_PORT\': str(self[\'port\']),\n+        }\n+\n+        app = addRequestContainer(Zope2.app(), environ=environ)\n+        request = app.REQUEST\n+        request[\'PARENTS\'] = [app]\n+\n+        # Make sure we have a zope.globalrequest request\n+        try:\n+            from zope.globalrequest import setRequest\n+            setRequest(request)\n+        except ImportError:\n+            pass\n+\n+        # Start a transaction\n+        transaction.begin()\n+\n+        self._original_commit = transaction.commit\n+\n+        def you_broke_it():\n+            raise TestIsolationBroken("""You are in a Test Layer\n+(IntegrationTesting) that is fast by just aborting transactions between each\n+test.  You just committed something. That breaks the test isolation.  So I stop\n+here and let you fix it.""")\n+\n+        # Prevent commits in integration tests which breaks test isolation.\n+        transaction.commit = you_broke_it\n+\n+        # Save resources for tests to access\n+        self[\'app\'] = app\n+        self[\'request\'] = request\n+\n+    def testTearDown(self):\n+\n+        # Abort the transaction\n+        transaction.abort()\n+\n+        transaction.commit = self._original_commit\n+\n+        # Make sure we have a zope.globalrequest request\n+        try:\n+            from zope.globalrequest import setRequest\n+            setRequest(None)\n+        except ImportError:\n+            pass\n+\n+        # Close the database connection and the request\n+        app = self[\'app\']\n+        app.REQUEST.close()\n+        app._p_jar.close()\n+\n+        # Delete the resources\n+        del self[\'request\']\n+        del self[\'app\']\n+\n+\n+INTEGRATION_TESTING = IntegrationTesting()\n+\n+\n+class FunctionalTesting(Layer):\n+    """An alternative to ``INTEGRATION_TESTING`` suitable for functional testing.\n+    This one pushes and pops a ``DemoStorage`` layer for each test. The\n+    net result is that a test may commit safely.\n+\n+    As with ``INTEGRATION_TESTING``, the application root is available as the\n+    resource ``app`` and the request is available as the resource ``request``,\n+    set up and torn down for each test.\n+\n+    Hint: If you want to create your own fixture on top of ``STARTUP``,\n+    create a new layer that has ``STARTUP`` as a base. Then instantiate\n+    this layer with your new "fixture" layer as a base, e.g.::\n+\n+        from plone.testing import wsgi\n+        from plone.testing import Layer\n+\n+        class MyFixture(Layer):\n+\n+            ...\n+\n+        MY_FIXTURE = MyFixture(bases=(wsgi.STARTUP,), name=\'MyFixture\')\n+        MY_FUNCTIONAL_TESTING = wsgi.FunctionalTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Functional\')  # noqa\n+    """\n+\n+    defaultBases = (STARTUP,)\n+\n+    # Test lifecycle\n+\n+    def testSetUp(self):\n+        import Zope2\n+\n+        # Override zodbDB from the layer setup. Since it was set up by\n+        # this layer, we can\'t just assign a new shadow. We therefore keep\n+        # track of the original so that we can restore it on tear-down.\n+\n+        self[\'zodbDB\'] = zodb.stackDemoStorage(\n+            self.get(\'zodbDB\'),\n+            name=\'FunctionalTest\')\n+\n+        # Save the app\n+\n+        environ = {\n+            \'SERVER_NAME\': self[\'host\'],\n+            \'SERVER_PORT\': str(self[\'port\']),\n+        }\n+\n+        app = addRequestContainer(Zope2.app(), environ=environ)\n+        request = app.REQUEST\n+        request[\'PARENTS\'] = [app]\n+\n+        # Make sure we have a zope.globalrequest request\n+        try:\n+            from zope.globalrequest import setRequest\n+            setRequest(request)\n+        except ImportError:\n+            pass\n+\n+        # Start a transaction\n+        transaction.begin()\n+\n+        # Save resources for the test\n+        self[\'app\'] = app\n+        self[\'request\'] = request\n+\n+    def testTearDown(self):\n+        # Abort any open transactions\n+        transaction.abort()\n+\n+        # Make sure we have a zope.globalrequest request\n+        try:\n+            from zope.globalrequest import setRequest\n+            setRequest(None)\n+        except ImportError:\n+            pass\n+\n+        # Close the database connection and the request\n+        app = self[\'app\']\n+        app.REQUEST.close()\n+        app._p_jar.close()\n+\n+        del self[\'app\']\n+        del self[\'request\']\n+\n+        # Close and discard the database\n+        self[\'zodbDB\'].close()\n+        del self[\'zodbDB\']\n+\n+\n+FUNCTIONAL_TESTING = FunctionalTesting()\n+\n+WSGI_LOG_REQUEST = \'WSGI_REQUEST_LOGGING\' in os.environ\n+\n+\n+class WSGIServer(Layer):\n+    """Start a WSGI server that accesses the fixture managed by the\n+    ``STARTUP`` layer.\n+\n+    The host and port are available as the resources ``host`` and ``port``,\n+    respectively.\n+\n+    The ``WSGI_SERVER_FIXTURE`` layer must be used as the base for a layer that\n+    uses the ``FunctionalTesting`` layer class. The ``WSGI_SERVER`` layer is\n+    an example of such a layer.\n+    """\n+\n+    defaultBases = (STARTUP,)\n+\n+    timeout = 5\n+    host = os.environ.get(\'WSGI_SERVER_HOST\',\n+                          os.environ.get(\'ZSERVER_HOST\'))\n+    port = os.environ.get(\'WSGI_SERVER_PORT\',\n+                          os.environ.get(\'ZSERVER_PORT\'))\n+    pipeline = [\n+        (\'Zope\', \'paste.filter_app_factory\', \'httpexceptions\', {}),\n+    ]\n+\n+    def setUp(self):\n+        self[\'host\'] = self.host\n+        self.setUpServer()\n+        self[\'port\'] = self.port\n+\n+    def tearDown(self):\n+        self.tearDownServer()\n+        del self[\'host\']\n+        del self[\'port\']\n+\n+    def setUpServer(self):\n+        """Create a WSGI server instance and save it in self.server.\n+        """\n+        app = self.make_wsgi_app()\n+        kwargs = {}\n+        if self.host is not None:\n+            kwargs[\'host\'] = self.host\n+        if self.port is not None:\n+            kwargs[\'port\'] = int(self.port)\n+        self.server = StopableWSGIServer.create(app, **kwargs)\n+        # If we dynamically set the host/port, we want to reset it to localhost\n+        # Otherwise this will depend on, for example, the local network setup\n+        if self.host in (None, \'0.0.0.0\', \'127.0.0.1\', \'localhost\'):\n+            self.server.effective_host = \'localhost\'\n+        # Refresh the hostname and port in case we dynamically picked them\n+        self[\'host\'] = self.host = self.server.effective_host\n+        self[\'port\'] = self.port = int(self.server.effective_port)\n+\n+    def tearDownServer(self):\n+        """Close the server socket and clean up.\n+        """\n+        self.server.shutdown()\n+        shutil.rmtree(self._wsgi_conf_dir)\n+\n+    def make_wsgi_app(self):\n+        self._wsgi_conf_dir = tempfile.mkdtemp()\n+        global_config = {\'here\': self._wsgi_conf_dir}\n+        zope_conf = self._get_zope_conf(self._wsgi_conf_dir)\n+        Zope2.Startup.run.make_wsgi_app(global_config, zope_conf)\n+        app = ZPublisher.WSGIPublisher.publish_module\n+\n+        for spec, protocol, name, extra in reversed(self.pipeline):\n+            entrypoint = pkg_resources.get_entry_info(spec, protocol, name)\n+            app = entrypoint.load()(app, global_config, **extra)\n+        return app\n+\n+    def _get_zope_conf(self, dir):\n+        fd, path = tempfile.mkstemp(dir=dir)\n+        with os.fdopen(fd, \'w\') as zope_conf:\n+            zope_conf.write(\'instancehome {0}\\n\'.format(os.path.dirname(dir)))\n+        return path\n+\n+\n+# Fixture layer - use as a base layer, but don\'t use directly, as it has no\n+# test lifecycle\n+WSGI_SERVER_FIXTURE = WSGIServer()\n+\n+# Functional testing layer that uses the WSGI_SERVER_FIXTURE\n+WSGI_SERVER = FunctionalTesting(\n+    bases=(\n+        WSGI_SERVER_FIXTURE,\n+    ),\n+    name=\'WSGIServer:Functional\')\ndiff --git a/src/plone/testing/zope.rst b/src/plone/testing/zope.rst\nnew file mode 100644\nindex 0000000..61cdb79\n--- /dev/null\n+++ b/src/plone/testing/zope.rst\n@@ -0,0 +1,529 @@\n+Zope WSGI layers\n+----------------\n+\n+The Zope WSGI layers are found in the module ``plone.testing.zope``:::\n+\n+    >>> from plone.testing import zope\n+\n+For testing, we need a testrunner:::\n+\n+    >>> from zope.testrunner import runner\n+\n+Startup\n+~~~~~~~\n+\n+``STARTUP`` is the base layer for all Zope WSGI testing.\n+It sets up a Zope WSGI sandbox environment that is suitable for testing.\n+It extends the ``zca.LAYER_CLEANUP`` layer to maximise the chances of having and leaving a pristine environment.\n+\n+**Note**: You should probably use at least ``INTEGRATION_TESTING`` for any real test, although ``STARTUP`` is a useful base layer if you are setting up your own fixture.\n+See the description of ``INTEGRATION_TESTING`` below.::\n+\n+    >>> "%s.%s" % (zope.STARTUP.__module__, zope.STARTUP.__name__,)\n+    \'plone.testing.zope.Startup\'\n+\n+    >>> zope.STARTUP.__bases__\n+    (<Layer \'plone.testing.zca.LayerCleanup\'>,)\n+\n+On layer setup, Zope is initialised in a lightweight manner.\n+This involves certain patches to global modules that Zope manages, to reduce setup time, a database based on ``DemoStorage``, and a minimal set of products that must be installed for Zope 2 to work.\n+A minimal set of ZCML is loaded, but packages in the ``Products`` namespace are not automatically configured.\n+\n+Let\'s just verify that we have an empty component registry before the test:::\n+\n+    >>> from zope.component import getSiteManager\n+    >>> list(getSiteManager().registeredAdapters())\n+    []\n+\n+Five sets a special vocabulary registry upon the layer setup, but there\'s a default one set before:::\n+\n+    >>> from zope.schema.vocabulary import getVocabularyRegistry\n+    >>> getVocabularyRegistry()\n+    <zope.schema.vocabulary.VocabularyRegistry object ...>\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, zope.STARTUP, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n+\n+After layer setup, the ``zodbDB`` resource is available, pointing to the default ZODB.::\n+\n+    >>> zope.STARTUP[\'zodbDB\']\n+    <ZODB.DB.DB object at ...>\n+\n+    >>> zope.STARTUP[\'zodbDB\'].storage\n+    Startup\n+\n+In addition, the resources ``host`` and ``port`` are set to the default hostname and port that are used for URLs generated from Zope.\n+These are hardcoded, but shadowed by layers that provide actual running Zope instances.::\n+\n+    >>> zope.STARTUP[\'host\']\n+    \'nohost\'\n+    >>> zope.STARTUP[\'port\']\n+    80\n+\n+At this point, it is also possible to get hold of a Zope application root.\n+If you are setting up a layer fixture, you can obtain an application root with the correct database that is properly closed by using the ``zopeApp()`` context manager.::\n+\n+    >>> with zope.zopeApp() as app:\n+    ...     \'acl_users\' in app.objectIds()\n+    True\n+\n+If you want to use a specific database, you can pass that to ``zopeApp()`` as the ``db`` parameter.\n+A new connection will be opened and closed.::\n+\n+    >>> with zope.zopeApp(db=zope.STARTUP[\'zodbDB\']) as app:\n+    ...     \'acl_users\' in app.objectIds()\n+    True\n+\n+If you want to re-use an existing connection, you can pass one to ``zopeApp()`` as the ``connection`` argument.\n+In this case, you will need to close the connection yourself.::\n+\n+    >>> conn = zope.STARTUP[\'zodbDB\'].open()\n+    >>> with zope.zopeApp(connection=conn) as app:\n+    ...     \'acl_users\' in app.objectIds()\n+    True\n+\n+    >>> conn.opened is not None\n+    True\n+\n+    >>> conn.close()\n+\n+If an exception is raised within the ``with`` block, the transaction is aborted, but the connection is still closed (if it was opened by the context manager):::\n+\n+    >>> with zope.zopeApp() as app:\n+    ...     raise Exception("Test error")\n+    Traceback (most recent call last):\n+    ...\n+    Exception: Test error\n+\n+It is common to combine the ``zopeApp()`` context manager with a stacked ``DemoStorage`` to set up a layer-specific fixture.\n+As a sketch:::\n+\n+    from plone.testing import Layer, zope, zodb\n+\n+    class MyLayer(Layer):\n+        defaultBases = (zope.STARTUP,)\n+\n+        def setUp(self):\n+            self[\'zodbDB\'] = zodb.stackDemoStorage(self.get(\'zodbDB\'), name=\'MyLayer\')\n+            with zope.zopeApp() as app:\n+\n+                # Set up a fixture, e.g.:\n+                app.manage_addFolder(\'folder1\')\n+                folder = app[\'folder1\']\n+                folder._addRole(\'role1\')\n+                folder.manage_addUserFolder()\n+\n+                userFolder = folder[\'acl_users\']\n+                ignore = userFolder.userFolderAddUser(\'user1\', \'secret\', [\'role1\'], [])\n+                folder.manage_role(\'role1\', (\'Access contents information\',))\n+\n+        def tearDown(self):\n+            self[\'zodbDB\'].close()\n+            del self[\'zodbDB\']\n+\n+Note that you would normally *not* use the ``zope.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.\n+The ``IntegrationTesting`` and ``FunctionalTesting`` layer classes manage the application object for you, exposing them as the resource ``app`` (see below).\n+\n+After layer setup, the global component registry contains a number of components needed by Zope.::\n+\n+    >>> len(list(getSiteManager().registeredAdapters())) > 1 # in fact, > a lot\n+    True\n+\n+And Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:::\n+\n+    >>> getVocabularyRegistry()\n+    <....Zope2VocabularyRegistry object at ...>\n+\n+To load additional ZCML, you can use the ``configurationContext`` resource:::\n+\n+    >>> zope.STARTUP[\'configurationContext\']\n+    <zope.configuration.config.ConfigurationMachine object ...>\n+\n+See ``zca.rst`` for details about how to use ``zope.configuration`` for this purpose.\n+\n+The ``STARTUP`` layer does not perform any specific test setup or tear-down.\n+That is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING`` layers, or other layers using their layer classes - ``IntegrationTesting`` and ``FunctionalTesting``.::\n+\n+    >>> zope.STARTUP.testSetUp()\n+    >>> zope.STARTUP.testTearDown()\n+\n+Layer tear-down resets the environment.::\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.testing.zope.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+    >>> import Zope2\n+    >>> Zope2._began_startup\n+    0\n+    >>> Zope2.DB is None\n+    True\n+    >>> Zope2.bobo_application is None\n+    True\n+\n+    >>> list(getSiteManager().registeredAdapters())\n+    []\n+\n+    >>> getVocabularyRegistry()\n+    <zope.schema.vocabulary.VocabularyRegistry object at ...>\n+\n+Integration test\n+~~~~~~~~~~~~~~~~\n+\n+``INTEGRATION_TESTING`` is intended for simple Zope WSGI integration testing.\n+It extends ``STARTUP`` to ensure that a transaction is begun before and rolled back after each test.\n+Two resources, ``app`` and ``request``, are available during testing as well.\n+It does not manage any layer state - it implements the test lifecycle methods only.\n+\n+**Note:** You would normally *not* use ``INTEGRATION_TESTING`` as a base layer.\n+Instead, you\'d use the ``IntegrationTesting`` class to create your own layer with the testing lifecycle semantics of ``INTEGRATION_TESTING``.\n+See the ``plone.testing`` ``README`` file for an example.\n+\n+``app`` is the application root.\n+In a test, you should use this instead of the ``zopeApp`` context manager (which remains the weapon of choice for setting up persistent fixtures), because the ``app`` resource is part of the transaction managed by the layer.\n+\n+``request`` is a test request. It is the same as ``app.REQUEST``.::\n+\n+    >>> "%s.%s" % (zope.INTEGRATION_TESTING.__module__, zope.INTEGRATION_TESTING.__name__,)\n+    \'plone.testing.zope.IntegrationTesting\'\n+\n+    >>> zope.INTEGRATION_TESTING.__bases__\n+    (<Layer \'plone.testing.zope.Startup\'>,)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, zope.INTEGRATION_TESTING, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n+    Set up plone.testing.zope.IntegrationTesting in ... seconds.\n+\n+Let\'s now simulate a test.\n+On test setup, the ``app`` resource is made available.\n+In a test, you should always use this to access the application root.::\n+\n+    >>> zope.STARTUP.testSetUp()\n+    >>> zope.INTEGRATION_TESTING.testSetUp()\n+\n+The test may now inspect and modify the environment.::\n+\n+    >>> app = zope.INTEGRATION_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app.manage_addFolder(\'folder1\')\n+    >>> \'acl_users\' in app.objectIds() and \'folder1\' in app.objectIds()\n+    True\n+\n+The request is also available:::\n+\n+    >>> zope.INTEGRATION_TESTING[\'request\'] # would normally be self.layer[\'request\']\n+    <HTTPRequest, URL=http://nohost>\n+\n+We can create a user and simulate logging in as that user, using the ``zope.login()`` helper:::\n+\n+    >>> app._addRole(\'role1\')\n+    >>> ignore = app[\'acl_users\'].userFolderAddUser(\'user1\', \'secret\', [\'role1\'], [])\n+    >>> zope.login(app[\'acl_users\'], \'user1\')\n+\n+The first argument to ``zope.login()`` is the user folder that contains the relevant user.\n+The second argument is the user\'s name.\n+There is no need to give the password.::\n+\n+    >>> from AccessControl import getSecurityManager\n+    >>> getSecurityManager().getUser()\n+    <User \'user1\'>\n+\n+You can change the roles of a user using the ``zope.setRoles()`` helper:::\n+\n+    >>> sorted(getSecurityManager().getUser().getRolesInContext(app))\n+    [\'Authenticated\', \'role1\']\n+\n+    >>> zope.setRoles(app[\'acl_users\'], \'user1\', [])\n+    >>> getSecurityManager().getUser().getRolesInContext(app)\n+    [\'Authenticated\']\n+\n+To become the anonymous user again, use ``zope.logout()``:::\n+\n+    >>> zope.logout()\n+    >>> getSecurityManager().getUser()\n+    <SpecialUser \'Anonymous User\'>\n+\n+On tear-down, the transaction is rolled back:::\n+\n+    >>> zope.INTEGRATION_TESTING.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n+\n+    >>> \'app\' in zope.INTEGRATION_TESTING\n+    False\n+\n+    >>> \'request\' in zope.INTEGRATION_TESTING\n+    False\n+\n+    >>> with zope.zopeApp() as app:\n+    ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n+    True\n+\n+\n+Let\'s tear down the layers:::\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.testing.zope.IntegrationTesting in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+Functional testing\n+~~~~~~~~~~~~~~~~~~\n+\n+The ``FUNCTIONAL_TESTING`` layer is very similar to ``INTEGRATION_TESTING``, and exposes the same fixture and resources.\n+However, it has different transaction semantics.\n+``INTEGRATION_TESTING`` creates a single database storage, and rolls back the transaction after each test.\n+``FUNCTIONAL_TESTING`` creates a whole new database storage (stacked on top of the basic fixture) for each test.\n+This allows testing of code that performs an explicit commit, which is usually required for end-to-end testing.\n+The downside is that the set-up and tear-down of each test takes longer.\n+\n+**Note:** Again, you would normally *not* use ``FUNCTIONAL_TESTING`` as a base layer.\n+Instead, you\'d use the ``FunctionalTesting`` class to create your own layer with the testing lifecycle semantics of ``FUNCTIONAL_TESTING``.\n+See the ``plone.testing`` ``README`` file for an example.\n+\n+Like ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.::\n+\n+    >>> "%s.%s" % (zope.FUNCTIONAL_TESTING.__module__, zope.FUNCTIONAL_TESTING.__name__,)\n+    \'plone.testing.zope.FunctionalTesting\'\n+\n+    >>> zope.FUNCTIONAL_TESTING.__bases__\n+    (<Layer \'plone.testing.zope.Startup\'>,)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, zope.FUNCTIONAL_TESTING, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n+    Set up plone.testing.zope.FunctionalTesting in ... seconds.\n+\n+Let\'s now simulate a test.\n+On test setup, the ``app`` resource is made available.\n+In a test, you should always use this to access the application root.\n+The ``request`` resource can be used to access the test request.::\n+\n+    >>> zope.STARTUP.testSetUp()\n+    >>> zope.FUNCTIONAL_TESTING.testSetUp()\n+\n+The test may now inspect and modify the environment.\n+It may also commit things.::\n+\n+    >>> app = zope.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app.manage_addFolder(\'folder1\')\n+    >>> \'acl_users\' in app.objectIds() and \'folder1\' in app.objectIds()\n+    True\n+\n+    >>> import transaction\n+    >>> transaction.commit()\n+\n+On tear-down, the database is torn down.::\n+\n+    >>> zope.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n+\n+    >>> \'app\' in zope.FUNCTIONAL_TESTING\n+    False\n+\n+    >>> \'request\' in zope.FUNCTIONAL_TESTING\n+    False\n+\n+    >>> with zope.zopeApp() as app:\n+    ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n+    True\n+\n+Let\'s tear down the layer:::\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.testing.zope.FunctionalTesting in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+The test browser\n+~~~~~~~~~~~~~~~~\n+\n+The ``FUNCTIONAL_TESTING`` layer and ``FunctionalTesting`` layer class are the basis for functional testing using ``zope.testbrowser``.\n+This simulates a web browser, allowing an application to be tested "end-to-end" via its user-facing interface.\n+\n+To use the test browser with a ``FunctionalTesting`` layer (such as the default ``FUNCTIONAL_TESTING`` layer instance), we need to use a custom browser client, which ensures that the test browser uses the correct ZODB and is appropriately isolated from the test code.::\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, zope.FUNCTIONAL_TESTING, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n+    Set up plone.testing.zope.FunctionalTesting in ... seconds.\n+\n+Let\'s simulate a test:::\n+\n+    >>> zope.STARTUP.testSetUp()\n+    >>> zope.FUNCTIONAL_TESTING.testSetUp()\n+\n+In the test, we can create a test browser client like so:::\n+\n+    >>> app = zope.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> browser = zope.Browser(app)\n+\n+It is usually best to let Zope errors be shown with full tracebacks:::\n+\n+    >>> browser.handleErrors = False\n+\n+We can add to the test fixture in the test.\n+For those changes to be visible to the test browser, however, we need to commit the transaction.::\n+\n+    >>> _ = app.manage_addDTMLDocument(\'dtml-doc-1\')\n+    >>> import transaction; transaction.commit()\n+\n+We can now view this via the test browser:::\n+\n+    >>> browser.open(app.absolute_url() + \'/dtml-doc-1\')\n+    >>> \'This is the dtml-doc-1 Document.\' in browser.contents\n+    True\n+\n+The test browser integration converts the URL into a request and passes control to Zope\'s publisher.\n+Let\'s check that query strings are available for input processing:::\n+\n+    >>> from six.moves.urllib.parse import urlencode\n+    >>> _ = app.manage_addDTMLDocument(\'dtml-doc-2\', file=\'<dtml-var foo>\')\n+    >>> import transaction; transaction.commit()\n+    >>> qs = urlencode({\'foo\': \'boo, bar & baz\'})  # sic: the ampersand.\n+    >>> browser.open(app.absolute_url() + \'/dtml-doc-2?\' + qs)\n+    >>> browser.contents\n+    \'boo, bar & baz\'\n+\n+The test browser also works with iterators.\n+Let\'s test that with a simple file implementation that uses an iterator.::\n+\n+    >>> from plone.testing.tests import DummyFile\n+    >>> app._setObject(\'file1\', DummyFile(\'file1\'))\n+    \'file1\'\n+\n+    >>> import transaction; transaction.commit()\n+\n+    >>> browser.open(app.absolute_url() + \'/file1\')\n+    >>> \'The test browser also works with iterators\' in browser.contents\n+    True\n+\n+See the ``zope.testbrowser`` documentation for more information about how to use the browser client.\n+\n+On tear-down, the database is torn down.::\n+\n+    >>> zope.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n+\n+    >>> \'app\' in zope.FUNCTIONAL_TESTING\n+    False\n+\n+    >>> \'request\' in zope.FUNCTIONAL_TESTING\n+    False\n+\n+    >>> with zope.zopeApp() as app:\n+    ...     \'acl_users\' in app.objectIds()\\\n+    ...         and \'folder1\' not in app.objectIds()\\\n+    ...         and \'file1\' not in app.objectIds()\n+    True\n+\n+Let\'s tear down the layer:::\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.testing.zope.FunctionalTesting in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+HTTP server\n+~~~~~~~~~~~\n+\n+The ``WSGI_SERVER_FIXTURE`` layer extends ``STARTUP`` to start a single-threaded Zope server in a separate thread.\n+This makes it possible to connect to the test instance using a web browser or a testing tool like Selenium or Windmill.\n+\n+The ``WSGI_SERVER`` layer provides a ``FunctionalTesting`` layer that has ``WSGI_SERVER_FIXTURE`` as its base.::\n+\n+    >>> "%s.%s" % (zope.WSGI_SERVER_FIXTURE.__module__, zope.WSGI_SERVER_FIXTURE.__name__,)\n+    \'plone.testing.zope.WSGIServer\'\n+\n+    >>> zope.WSGI_SERVER_FIXTURE.__bases__\n+    (<Layer \'plone.testing.zope.Startup\'>,)\n+\n+\n+    >>> "%s.%s" % (zope.WSGI_SERVER.__module__, zope.WSGI_SERVER.__name__,)\n+    \'plone.testing.zope.WSGIServer:Functional\'\n+\n+    >>> zope.WSGI_SERVER.__bases__\n+    (<Layer \'plone.testing.zope.WSGIServer\'>,)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, zope.WSGI_SERVER, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n+    Set up plone.testing.zope.WSGIServer in ... seconds.\n+    Set up plone.testing.zope.WSGIServer:Functional in ... seconds.\n+\n+After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n+\n+    >>> host = zope.WSGI_SERVER[\'host\']\n+    >>> host\n+    \'localhost\'\n+\n+    >>> port = zope.WSGI_SERVER[\'port\']\n+\n+Let\'s now simulate a test.\n+Test setup does nothing beyond what the base layers do.::\n+\n+    >>> zope.STARTUP.testSetUp()\n+    >>> zope.FUNCTIONAL_TESTING.testSetUp()\n+    >>> zope.WSGI_SERVER.testSetUp()\n+\n+It is common in a test to use the Python API to change the state of the server (e.g.\n+create some content or change a setting) and then use the HTTP protocol to look at the results.\n+Bear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``zope.login()`` and ``zope.logout()``, for instance, do not affect the server thread.::\n+\n+    >>> app = zope.WSGI_SERVER[\'app\'] # would normally be self.layer[\'app\']\n+    >>> _ = app.manage_addDTMLDocument(\'dtml-doc-3\')\n+\n+Note that we need to commit the transaction before it will show up in the other thread.::\n+\n+    >>> import transaction; transaction.commit()\n+\n+We can now look for this new object through the server.::\n+\n+    >>> app_url = app.absolute_url()\n+    >>> app_url.split(\':\')[:-1]\n+    [\'http\', \'//localhost\']\n+\n+    >>> from six.moves.urllib.request import urlopen\n+    >>> conn = urlopen(app_url + \'/dtml-doc-3\', timeout=5)\n+    >>> b\'This is the dtml-doc-3 Document.\' in conn.read()\n+    True\n+    >>> conn.close()\n+\n+Test tear-down does nothing beyond what the base layers do.::\n+\n+    >>> zope.WSGI_SERVER.testTearDown()\n+    >>> zope.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n+\n+    >>> \'app\' in zope.WSGI_SERVER\n+    False\n+\n+    >>> \'request\' in zope.WSGI_SERVER\n+    False\n+\n+    >>> with zope.zopeApp() as app:\n+    ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n+    True\n+\n+When the server is torn down, the WSGIServer thread is stopped.::\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.testing.zope.WSGIServer:Functional in ... seconds.\n+    Tear down plone.testing.zope.WSGIServer in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+    >>> conn = urlopen(app_url + \'/folder1\', timeout=5)\n+    Traceback (most recent call last):\n+    ...\n+    URLError: <urlopen error [Errno ...] Connection refused>\ndiff --git a/src/plone/testing/zserver.py b/src/plone/testing/zserver.py\nnew file mode 100644\nindex 0000000..e719ddb\n--- /dev/null\n+++ b/src/plone/testing/zserver.py\n@@ -0,0 +1,552 @@\n+# -*- coding: utf-8 -*-\n+"""Zope2-specific helpers and layers using ZServer\n+"""\n+from __future__ import absolute_import\n+from plone.testing import Layer\n+from plone.testing import zodb\n+from plone.testing import zope\n+from plone.testing._z2_testbrowser import Browser  # noqa\n+from plone.testing.zope import addRequestContainer\n+from plone.testing.zope import installProduct\n+from plone.testing.zope import login  # noqa\n+from plone.testing.zope import logout  # noqa\n+from plone.testing.zope import setRoles  # noqa\n+from plone.testing.zope import TestIsolationBroken\n+from plone.testing.zope import uninstallProduct\n+\n+import contextlib\n+import os\n+import transaction\n+\n+\n+@contextlib.contextmanager\n+def zopeApp(db=None, connection=None, environ=None):\n+    """Context manager for working with the Zope2 app::\n+\n+        with zopeApp() as app:\n+            ...\n+\n+    The ``app`` object has a request container and a simple ``REQUEST``.\n+    To set the request environment, pass a dict ``environ``. See\n+    ``addRequestContainer()`` for details.\n+\n+    Pass a ZODB handle as ``db`` to use a specificdatabase. Alternatively,\n+    pass an open connection as ``connection`` (the connection will not be\n+    closed).\n+    """\n+    from ZServer import Zope2\n+\n+    closeConn = True\n+    if connection is not None:\n+        closeConn = False\n+\n+    if connection is None and db is not None:\n+        connection = db.open()\n+\n+    app = addRequestContainer(Zope2.app(connection), environ=environ)\n+\n+    if connection is None:\n+        connection = app._p_jar\n+\n+    # exceptions in finally clauses can mask exceptions\n+    # in the preceeding code block. So we catch\n+    # every exception and throw it instead of the exception\n+    # in the finally clause\n+    inner_exception = None\n+    try:\n+        yield app\n+    except Exception as e:\n+        inner_exception = e\n+        try:\n+            transaction.abort()\n+        except Exception as e:\n+            inner_exception = e\n+            raise\n+        raise\n+    else:\n+        try:\n+            transaction.commit()\n+        except Exception as e:\n+            inner_exception = e\n+    finally:\n+        try:\n+            app.REQUEST.close()\n+            if closeConn:\n+                transaction.abort()\n+                connection.close()\n+        except Exception:\n+            if inner_exception:\n+                raise inner_exception\n+            else:\n+                raise\n+\n+\n+# Startup layer - you probably don\'t want to use this one directly\n+\n+class Startup(zope.Startup):\n+    """This layer does what ZopeLite and ZopeTestCase\'s base.TestCase did:\n+    start up a minimal Zope instance and manages the application and\n+    request state.\n+\n+    You probably don\'t want to use this layer directly. Instead, you should\n+    use one of the layers that has it as a base.\n+\n+    The following resources are exposed:\n+\n+    * ``zodbDB`` is the ZODB with the test fixture\n+    * ``configurationContext`` is the ``zope.configuration`` context for\n+      ZCML loading.\n+    * ``host`` and ``port`` are the fake hostname and port number,\n+      respectively.\n+    """\n+\n+    threads = 1\n+\n+    # Layer lifecycle helper methods\n+\n+    def setUpThreads(self):\n+        """Set the thread count for ZServer. This defaults to 1.\n+        """\n+\n+        # We can\'t use setNumberOfThreads() because that function self-\n+        # destructs, literally, when called.\n+\n+        import ZServer.PubCore\n+        self._zserverThreads = ZServer.PubCore._n\n+        ZServer.PubCore._n = self.threads\n+\n+    def tearDownThreads(self):\n+        """Reset the ZServer thread count.\n+        """\n+\n+        import ZServer.PubCore\n+        ZServer.PubCore._n = self._zserverThreads\n+        del self._zserverThreads\n+\n+    def setUpApp(self):\n+        """Trigger Zope startup and set up the application.\n+        """\n+\n+        # If the Testing module has been imported, the testinghome\n+        # variable is set and changes the way Zope2.startup() works.\n+        # We want the standard behavior so we remove it.\n+\n+        import App.config\n+        config = App.config.getConfiguration()\n+        try:\n+            self._testingHome = config.testinghome\n+        except AttributeError:\n+            pass\n+        else:\n+            del config.testinghome\n+            App.config.setConfiguration(config)\n+\n+        # This uses the DB from the dbtab, as configured in setUpDatabase().\n+        # That DB then gets stored as Zope2.DB and becomes the default.\n+\n+        from ZServer import Zope2\n+        Zope2.startup()\n+\n+        # At this point, Zope2.DB is set to the test database facade. This is\n+        # the database will be used by default when someone does Zope2.app().\n+\n+    def tearDownApp(self):\n+        """Undo Zope 2 startup by unsetting the global state it creates.\n+        """\n+\n+        import Zope2\n+        import ZServer.Zope2\n+        ZServer.Zope2.app()._p_jar.close()\n+\n+        ZServer.Zope2._began_startup = 0\n+\n+        Zope2.DB = None\n+        Zope2.bobo_application = None\n+        Zope2.zpublisher_transactions_manager = None\n+        Zope2.zpublisher_validated_hook = None\n+        Zope2.zpublisher_exception_hook = None\n+        Zope2.__bobo_before__ = None\n+\n+        import App.config\n+        try:\n+            self._testingHome\n+        except AttributeError:\n+            pass\n+        else:\n+            config = App.config.getConfiguration()\n+            config.testinghome = self._testingHome\n+            App.config.setConfiguration(config)\n+            del self._testingHome\n+\n+        # Clear out the app reference cached in get_module_info\'s\n+        # \'modules\' parameter default dict. (waaaaa)\n+        import ZPublisher.Publish\n+        defaults = ZPublisher.Publish.get_module_info.func_defaults\n+\n+        if defaults:\n+            d = list(defaults)\n+            d[0] = {}\n+            ZPublisher.Publish.get_module_info.func_defaults = tuple(d)\n+\n+    def setUpBasicProducts(self):\n+        """Install a minimal set of products required for Zope 2.\n+        """\n+\n+        with zopeApp() as app:\n+            installProduct(app, \'Products.PluginIndexes\')\n+            installProduct(app, \'Products.OFSP\')\n+\n+    def tearDownBasicProducts(self):\n+        """Tear down the minimal set of products\n+        """\n+\n+        with zopeApp() as app:\n+            uninstallProduct(app, \'Products.PluginIndexes\')\n+            uninstallProduct(app, \'Products.OFSP\')\n+\n+        # It\'s possible for Five\'s _register_monkies and _meta_type_regs\n+        # global variables to contain duplicates. This causes an unecessary\n+        # error in the LayerCleanup layer\'s tear-down. Guard against that\n+        # here\n+\n+        try:\n+            from OFS import metaconfigure\n+        except ImportError:\n+            # Zope <= 2.12\n+            from Products.Five import fiveconfigure as metaconfigure\n+        metaconfigure._register_monkies = list(\n+            set(metaconfigure._register_monkies))\n+        metaconfigure._meta_type_regs = list(\n+            set(metaconfigure._meta_type_regs))\n+\n+\n+STARTUP = Startup()\n+\n+\n+# Basic integration and functional test and layers. These are the simplest\n+# Zope 2 layers that are generally useful\n+\n+class IntegrationTesting(zope.IntegrationTesting):\n+    """This layer extends ``STARTUP`` to add rollback of the transaction\n+    after each test. It does not manage a fixture and has no layer lifecyle,\n+    only a test lifecycle.\n+\n+    The application root is available as the resource ``app`` and the request\n+    is available as the resource ``request``, set up and torn down for each\n+    test.\n+\n+    Hint: If you want to create your own fixture on top of ``STARTUP``,\n+    create a new layer that has ``STARTUP`` as a base. Then instantiate\n+    this layer with your new "fixture" layer as a base, e.g.::\n+\n+        from plone.testing import zserver\n+        from plone.testing import Layer\n+\n+        class MyFixture(Layer):\n+\n+            ...\n+\n+        MY_FIXTURE = MyFixture(bases=(zserver.STARTUP,), name=\'MyFixture\')\n+        MY_INTEGRATION_TESTING = zserver.IntegrationTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Integration\')  # noqa\n+    """\n+\n+    defaultBases = (STARTUP,)\n+\n+    def testSetUp(self):\n+        from ZServer import Zope2\n+\n+        # Open a new app and save it as the resource ``app``.\n+\n+        environ = {\n+            \'SERVER_NAME\': self[\'host\'],\n+            \'SERVER_PORT\': str(self[\'port\']),\n+        }\n+\n+        app = addRequestContainer(Zope2.app(), environ=environ)\n+        request = app.REQUEST\n+        request[\'PARENTS\'] = [app]\n+\n+        # Make sure we have a zope.globalrequest request\n+        try:\n+            from zope.globalrequest import setRequest\n+            setRequest(request)\n+        except ImportError:\n+            pass\n+\n+        # Start a transaction\n+        transaction.begin()\n+\n+        self._original_commit = transaction.commit\n+\n+        def you_broke_it():\n+            raise TestIsolationBroken("""You are in a Test Layer\n+(IntegrationTesting) that is fast by just aborting transactions between each\n+test.  You just committed something. That breaks the test isolation.  So I stop\n+here and let you fix it.""")\n+\n+        # Prevent commits in integration tests which breaks test isolation.\n+        transaction.commit = you_broke_it\n+\n+        # Save resources for tests to access\n+        self[\'app\'] = app\n+        self[\'request\'] = request\n+\n+\n+INTEGRATION_TESTING = IntegrationTesting()\n+\n+\n+class FunctionalTesting(zope.FunctionalTesting):\n+    """An alternative to ``INTEGRATION_TESTING`` suitable for functional testing.\n+    This one pushes and pops a ``DemoStorage`` layer for each test. The\n+    net result is that a test may commit safely.\n+\n+    As with ``INTEGRATION_TESTING``, the application root is available as the\n+    resource ``app`` and the request is available as the resource ``request``,\n+    set up and torn down for each test.\n+\n+    Hint: If you want to create your own fixture on top of ``STARTUP``,\n+    create a new layer that has ``STARTUP`` as a base. Then instantiate\n+    this layer with your new "fixture" layer as a base, e.g.::\n+\n+        from plone.testing import zserver\n+        from plone.testing import Layer\n+\n+        class MyFixture(Layer):\n+\n+            ...\n+\n+        MY_FIXTURE = MyFixture(bases=(zserver.STARTUP,), name=\'MyFixture\')\n+        MY_FUNCTIONAL_TESTING = zserver.FunctionalTesting(bases=(MY_FIXTURE,), name=\'MyFixture:Functional\')  # noqa\n+    """\n+\n+    defaultBases = (STARTUP,)\n+\n+    def testSetUp(self):\n+        from ZServer import Zope2\n+\n+        # Override zodbDB from the layer setup. Since it was set up by\n+        # this layer, we can\'t just assign a new shadow. We therefore keep\n+        # track of the original so that we can restore it on tear-down.\n+\n+        self[\'zodbDB\'] = zodb.stackDemoStorage(\n+            self.get(\'zodbDB\'),\n+            name=\'FunctionalTest\')\n+\n+        # Save the app\n+\n+        environ = {\n+            \'SERVER_NAME\': self[\'host\'],\n+            \'SERVER_PORT\': str(self[\'port\']),\n+        }\n+\n+        app = addRequestContainer(Zope2.app(), environ=environ)\n+        request = app.REQUEST\n+        request[\'PARENTS\'] = [app]\n+\n+        # Make sure we have a zope.globalrequest request\n+        try:\n+            from zope.globalrequest import setRequest\n+            setRequest(request)\n+        except ImportError:\n+            pass\n+\n+        # Start a transaction\n+        transaction.begin()\n+\n+        # Save resources for the test\n+        self[\'app\'] = app\n+        self[\'request\'] = request\n+\n+\n+FUNCTIONAL_TESTING = FunctionalTesting()\n+\n+\n+# More advanced functional testing - running ZServer and FTP server\n+\n+class ZServer(Layer):\n+    """Start a ZServer that accesses the fixture managed by the\n+    ``STARTUP`` layer.\n+\n+    The host and port are available as the resources ``host`` and ``port``,\n+    respectively.\n+\n+    This should *not* be used in parallel with the ``FTP_SERVER`` layer, since\n+    it shares the same async loop.\n+\n+    The ``ZSERVER_FIXTURE`` layer must be used as the base for a layer that\n+    uses the ``FunctionalTesting`` layer class. The ``ZSERVER`` layer is\n+    an example of such a layer.\n+    """\n+\n+    defaultBases = (STARTUP,)\n+\n+    host = os.environ.get(\'ZSERVER_HOST\', \'\')\n+    port = int(os.environ.get(\'ZSERVER_PORT\', 0))\n+    timeout = 5.0\n+    log = None\n+\n+    def setUp(self):\n+\n+        import time\n+        from threading import Thread\n+\n+        self[\'host\'] = self.host\n+        self[\'port\'] = self.port\n+\n+        self._shutdown = False\n+\n+        self.setUpServer()\n+\n+        self.thread = Thread(\n+            name=\'{0} server\'.format(self.__name__),\n+            target=self.runner,\n+        )\n+\n+        self.thread.start()\n+        time.sleep(0.5)\n+\n+    def tearDown(self):\n+        import time\n+\n+        self._shutdown = True\n+        self.thread.join(self.timeout)\n+        time.sleep(0.5)\n+\n+        self.tearDownServer()\n+\n+        del self[\'host\']\n+        del self[\'port\']\n+\n+    def setUpServer(self):\n+        """Create a ZServer server instance and save it in self.zserver\n+        """\n+        from ZServer import zhttp_server, zhttp_handler, logger\n+        from StringIO import StringIO\n+\n+        log = self.log\n+        if log is None:\n+            log = StringIO()\n+\n+        zopeLog = logger.file_logger(log)\n+\n+        server = zhttp_server(\n+            ip=self.host,\n+            port=self.port,\n+            resolver=None,\n+            logger_object=zopeLog,\n+        )\n+\n+        # If we dynamically set the host/port, we want to reset it to localhost\n+        # Otherwise this will depend on, for example, the local network setup\n+        if self.host in (\'\', \'0.0.0.0\', \'127.0.0.1\', ):\n+            server.server_name = \'localhost\'\n+        # Refresh the hostname and port in case we dynamically picked them\n+        self[\'host\'] = self.host = server.server_name\n+        self[\'port\'] = self.port = server.server_port\n+\n+        zhttpHandler = zhttp_handler(module=\'Zope2\', uri_base=\'\')\n+        server.install_handler(zhttpHandler)\n+\n+        self.zserver = server\n+\n+    def tearDownServer(self):\n+        """Close the ZServer socket\n+        """\n+        self.zserver.close()\n+\n+    # Thread runner\n+\n+    def runner(self):\n+        """Thread runner for the main asyncore loop. This function runs in a\n+        separate thread.\n+        """\n+\n+        import asyncore\n+\n+        # Poll\n+        socket_map = asyncore.socket_map\n+        while socket_map and not self._shutdown:\n+            asyncore.poll(self.timeout, socket_map)\n+\n+\n+# Fixture layer - use as a base layer, but don\'t use directly, as it has no\n+# test lifecycle\n+ZSERVER_FIXTURE = ZServer()\n+\n+# Functional testing layer that uses the ZSERVER_FIXTURE\n+ZSERVER = FunctionalTesting(\n+    bases=(\n+        ZSERVER_FIXTURE,\n+    ),\n+    name=\'ZServer:Functional\')\n+\n+\n+class FTPServer(ZServer):\n+    """FTP variant of the ZServer layer.\n+\n+    This will not play well with the ZServer layer. If you need both\n+    ZServer and FTPServer running together, you can subclass the ZServer\n+    layer class (like this layer class does) and implement setUpServer()\n+    and tearDownServer() to set up and close down two servers on different\n+    ports. They will then share a main loop.\n+\n+    The ``FTP_SERVER_FIXTURE`` layer must be used as the base for a layer that\n+    uses the ``FunctionalTesting`` layer class. The ``FTP_SERVER`` layer is\n+    an example of such a layer.\n+    """\n+\n+    defaultBases = (STARTUP,)\n+\n+    host = os.environ.get(\'FTPSERVER_HOST\', \'\')\n+    port = int(os.environ.get(\'FTPSERVER_PORT\', 0))\n+    threads = 1\n+    timeout = 5.0\n+    log = None\n+\n+    def setUpServer(self):\n+        """Create an FTP server instance and save it in self.ftpServer\n+        """\n+\n+        from ZServer import logger\n+        from ZServer.FTPServer import FTPServer\n+        from StringIO import StringIO\n+\n+        log = self.log\n+        if log is None:\n+            log = StringIO()\n+\n+        zopeLog = logger.file_logger(log)\n+\n+        self.ftpServer = FTPServer(\n+            \'Zope2\',\n+            ip=self.host,\n+            port=self.port,\n+            logger_object=zopeLog,\n+        )\n+        # Refresh the hostname and port in case we dynamically picked them\n+        self.host, self.port = self.ftpServer.socket.getsockname()\n+        # If we dynamically set the host/port, we want to reset it to localhost\n+        # Otherwise this will depend on, for example, the local network setup\n+        if self.host in (\'\', \'0.0.0.0\', \'127.0.0.1\', ):\n+            self.host = \'localhost\'\n+            self.ftpServer.hostname = \'localhost\'\n+            self.ftpServer.ip = \'127.0.0.1\'\n+        self[\'host\'] = self.host\n+        self[\'port\'] = self.port\n+\n+    def tearDownServer(self):\n+        """Close the FTPServer socket\n+        """\n+        self.ftpServer.close()\n+\n+\n+# Fixture layer - use as a base layer, but don\'t use directly, as it has no\n+# test lifecycle\n+FTP_SERVER_FIXTURE = FTPServer()\n+\n+# Functional testing layer that uses the FTP_SERVER_FIXTURE\n+FTP_SERVER = FunctionalTesting(\n+    bases=(\n+        FTP_SERVER_FIXTURE,\n+    ),\n+    name=\'FTPServer:Functional\')\ndiff --git a/src/plone/testing/z2.rst b/src/plone/testing/zserver.rst\nsimilarity index 70%\nrename from src/plone/testing/z2.rst\nrename to src/plone/testing/zserver.rst\nindex 8b922ba..df94d1c 100644\n--- a/src/plone/testing/z2.rst\n+++ b/src/plone/testing/zserver.rst\n@@ -1,9 +1,9 @@\n Zope 2 layers\n -------------\n \n-The Zope 2 layers are found in the module ``plone.testing.z2``:::\n+The Zope 2 layers are found in the module ``plone.testing.zserver``:::\n \n-    >>> from plone.testing import z2\n+    >>> from plone.testing import zserver\n \n For testing, we need a testrunner:::\n \n@@ -19,10 +19,10 @@ It extends the ``zca.LAYER_CLEANUP`` layer to maximise the chances of having and\n **Note**: You should probably use at least ``INTEGRATION_TESTING`` for any real test, although ``STARTUP`` is a useful base layer if you are setting up your own fixture.\n See the description of ``INTEGRATION_TESTING`` below.::\n \n-    >>> "%s.%s" % (z2.STARTUP.__module__, z2.STARTUP.__name__,)\n-    \'plone.testing.z2.Startup\'\n+    >>> "%s.%s" % (zserver.STARTUP.__module__, zserver.STARTUP.__name__,)\n+    \'plone.testing.zserver.Startup\'\n \n-    >>> z2.STARTUP.__bases__\n+    >>> zserver.STARTUP.__bases__\n     (<Layer \'plone.testing.zca.LayerCleanup\'>,)\n \n On layer setup, Zope is initialised in a lightweight manner.\n@@ -43,45 +43,45 @@ Five sets a special vocabulary registry upon the layer setup, but there\'s a defa\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.STARTUP, setupLayers)\n+    >>> runner.setup_layer(options, zserver.STARTUP, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n \n After layer setup, the ``zodbDB`` resource is available, pointing to the default ZODB.::\n \n-    >>> z2.STARTUP[\'zodbDB\']\n+    >>> zserver.STARTUP[\'zodbDB\']\n     <ZODB.DB.DB object at ...>\n \n-    >>> z2.STARTUP[\'zodbDB\'].storage\n+    >>> zserver.STARTUP[\'zodbDB\'].storage\n     Startup\n \n In addition, the resources ``host`` and ``port`` are set to the default hostname and port that are used for URLs generated from Zope.\n These are hardcoded, but shadowed by layers that provide actual running Zope instances.::\n \n-    >>> z2.STARTUP[\'host\']\n+    >>> zserver.STARTUP[\'host\']\n     \'nohost\'\n-    >>> z2.STARTUP[\'port\']\n+    >>> zserver.STARTUP[\'port\']\n     80\n \n At this point, it is also possible to get hold of a Zope application root.\n If you are setting up a layer fixture, you can obtain an application root with the correct database that is properly closed by using the ``zopeApp()`` context manager.::\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds()\n     True\n \n If you want to use a specific database, you can pass that to ``zopeApp()`` as the ``db`` parameter.\n A new connection will be opened and closed.::\n \n-    >>> with z2.zopeApp(db=z2.STARTUP[\'zodbDB\']) as app:\n+    >>> with zserver.zopeApp(db=zserver.STARTUP[\'zodbDB\']) as app:\n     ...     \'acl_users\' in app.objectIds()\n     True\n \n If you want to re-use an existing connection, you can pass one to ``zopeApp()`` as the ``connection`` argument.\n In this case, you will need to close the connection yourself.::\n \n-    >>> conn = z2.STARTUP[\'zodbDB\'].open()\n-    >>> with z2.zopeApp(connection=conn) as app:\n+    >>> conn = zserver.STARTUP[\'zodbDB\'].open()\n+    >>> with zserver.zopeApp(connection=conn) as app:\n     ...     \'acl_users\' in app.objectIds()\n     True\n \n@@ -92,7 +92,7 @@ In this case, you will need to close the connection yourself.::\n \n If an exception is raised within the ``with`` block, the transaction is aborted, but the connection is still closed (if it was opened by the context manager):::\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     raise Exception("Test error")\n     Traceback (most recent call last):\n     ...\n@@ -101,14 +101,14 @@ If an exception is raised within the ``with`` block, the transaction is aborted,\n It is common to combine the ``zopeApp()`` context manager with a stacked ``DemoStorage`` to set up a layer-specific fixture.\n As a sketch:::\n \n-    from plone.testing import Layer, z2, zodb\n+    from plone.testing import Layer, zserver, zodb\n \n     class MyLayer(Layer):\n-        defaultBases = (z2.STARTUP,)\n+        defaultBases = (zserver.STARTUP,)\n \n         def setUp(self):\n             self[\'zodbDB\'] = zodb.stackDemoStorage(self.get(\'zodbDB\'), name=\'MyLayer\')\n-            with z2.zopeApp() as app:\n+            with zserver.zopeApp() as app:\n \n                 # Set up a fixture, e.g.:\n                 app.manage_addFolder(\'folder1\')\n@@ -124,7 +124,7 @@ As a sketch:::\n             self[\'zodbDB\'].close()\n             del self[\'zodbDB\']\n \n-Note that you would normally *not* use the ``z2.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.\n+Note that you would normally *not* use the ``zserver.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.\n The ``IntegrationTesting`` and ``FunctionalTesting`` layer classes manage the application object for you, exposing them as the resource ``app`` (see below).\n \n After layer setup, the global component registry contains a number of components needed by Zope.::\n@@ -139,7 +139,7 @@ And Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:::\n \n To load additional ZCML, you can use the ``configurationContext`` resource:::\n \n-    >>> z2.STARTUP[\'configurationContext\']\n+    >>> zserver.STARTUP[\'configurationContext\']\n     <zope.configuration.config.ConfigurationMachine object ...>\n \n See ``zca.rst`` for details about how to use ``zope.configuration`` for this purpose.\n@@ -147,18 +147,19 @@ See ``zca.rst`` for details about how to use ``zope.configuration`` for this pur\n The ``STARTUP`` layer does not perform any specific test setup or tear-down.\n That is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING`` layers, or other layers using their layer classes - ``IntegrationTesting`` and ``FunctionalTesting``.::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zserver.STARTUP.testSetUp()\n+    >>> zserver.STARTUP.testTearDown()\n \n Layer tear-down resets the environment.::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n-    >>> import Zope2\n-    >>> Zope2._began_startup\n+    >>> import ZServer.Zope2\n+    >>> ZServer.Zope2._began_startup\n     0\n+    >>> import Zope2\n     >>> Zope2.DB is None\n     True\n     >>> Zope2.bobo_application is None\n@@ -187,45 +188,45 @@ In a test, you should use this instead of the ``zopeApp`` context manager (which\n \n ``request`` is a test request. It is the same as ``app.REQUEST``.::\n \n-    >>> "%s.%s" % (z2.INTEGRATION_TESTING.__module__, z2.INTEGRATION_TESTING.__name__,)\n-    \'plone.testing.z2.IntegrationTesting\'\n+    >>> "%s.%s" % (zserver.INTEGRATION_TESTING.__module__, zserver.INTEGRATION_TESTING.__name__,)\n+    \'plone.testing.zserver.IntegrationTesting\'\n \n-    >>> z2.INTEGRATION_TESTING.__bases__\n-    (<Layer \'plone.testing.z2.Startup\'>,)\n+    >>> zserver.INTEGRATION_TESTING.__bases__\n+    (<Layer \'plone.testing.zserver.Startup\'>,)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.INTEGRATION_TESTING, setupLayers)\n+    >>> runner.setup_layer(options, zserver.INTEGRATION_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.IntegrationTesting in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n+    Set up plone.testing.zserver.IntegrationTesting in ... seconds.\n \n Let\'s now simulate a test.\n On test setup, the ``app`` resource is made available.\n In a test, you should always use this to access the application root.::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.INTEGRATION_TESTING.testSetUp()\n+    >>> zserver.STARTUP.testSetUp()\n+    >>> zserver.INTEGRATION_TESTING.testSetUp()\n \n The test may now inspect and modify the environment.::\n \n-    >>> app = z2.INTEGRATION_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app = zserver.INTEGRATION_TESTING[\'app\'] # would normally be self.layer[\'app\']\n     >>> app.manage_addFolder(\'folder1\')\n     >>> \'acl_users\' in app.objectIds() and \'folder1\' in app.objectIds()\n     True\n \n The request is also available:::\n \n-    >>> z2.INTEGRATION_TESTING[\'request\'] # would normally be self.layer[\'request\']\n+    >>> zserver.INTEGRATION_TESTING[\'request\'] # would normally be self.layer[\'request\']\n     <HTTPRequest, URL=http://nohost>\n \n-We can create a user and simulate logging in as that user, using the ``z2.login()`` helper:::\n+We can create a user and simulate logging in as that user, using the ``zserver.login()`` helper:::\n \n     >>> app._addRole(\'role1\')\n     >>> ignore = app[\'acl_users\'].userFolderAddUser(\'user1\', \'secret\', [\'role1\'], [])\n-    >>> z2.login(app[\'acl_users\'], \'user1\')\n+    >>> zserver.login(app[\'acl_users\'], \'user1\')\n \n-The first argument to ``z2.login()`` is the user folder that contains the relevant user.\n+The first argument to ``zserver.login()`` is the user folder that contains the relevant user.\n The second argument is the user\'s name.\n There is no need to give the password.::\n \n@@ -233,33 +234,33 @@ There is no need to give the password.::\n     >>> getSecurityManager().getUser()\n     <User \'user1\'>\n \n-You can change the roles of a user using the ``z2.setRoles()`` helper:::\n+You can change the roles of a user using the ``zserver.setRoles()`` helper:::\n \n     >>> sorted(getSecurityManager().getUser().getRolesInContext(app))\n     [\'Authenticated\', \'role1\']\n \n-    >>> z2.setRoles(app[\'acl_users\'], \'user1\', [])\n+    >>> zserver.setRoles(app[\'acl_users\'], \'user1\', [])\n     >>> getSecurityManager().getUser().getRolesInContext(app)\n     [\'Authenticated\']\n \n-To become the anonymous user again, use ``z2.logout()``:::\n+To become the anonymous user again, use ``zserver.logout()``:::\n \n-    >>> z2.logout()\n+    >>> zserver.logout()\n     >>> getSecurityManager().getUser()\n     <SpecialUser \'Anonymous User\'>\n \n On tear-down, the transaction is rolled back:::\n \n-    >>> z2.INTEGRATION_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zserver.INTEGRATION_TESTING.testTearDown()\n+    >>> zserver.STARTUP.testTearDown()\n \n-    >>> \'app\' in z2.INTEGRATION_TESTING\n+    >>> \'app\' in zserver.INTEGRATION_TESTING\n     False\n \n-    >>> \'request\' in z2.INTEGRATION_TESTING\n+    >>> \'request\' in zserver.INTEGRATION_TESTING\n     False\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n     True\n \n@@ -267,8 +268,8 @@ On tear-down, the transaction is rolled back:::\n Let\'s tear down the layers:::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.IntegrationTesting in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zserver.IntegrationTesting in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n Functional testing\n@@ -287,31 +288,31 @@ See the ``plone.testing`` ``README`` file for an example.\n \n Like ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.::\n \n-    >>> "%s.%s" % (z2.FUNCTIONAL_TESTING.__module__, z2.FUNCTIONAL_TESTING.__name__,)\n-    \'plone.testing.z2.FunctionalTesting\'\n+    >>> "%s.%s" % (zserver.FUNCTIONAL_TESTING.__module__, zserver.FUNCTIONAL_TESTING.__name__,)\n+    \'plone.testing.zserver.FunctionalTesting\'\n \n-    >>> z2.FUNCTIONAL_TESTING.__bases__\n-    (<Layer \'plone.testing.z2.Startup\'>,)\n+    >>> zserver.FUNCTIONAL_TESTING.__bases__\n+    (<Layer \'plone.testing.zserver.Startup\'>,)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)\n+    >>> runner.setup_layer(options, zserver.FUNCTIONAL_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.FunctionalTesting in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n+    Set up plone.testing.zserver.FunctionalTesting in ... seconds.\n \n Let\'s now simulate a test.\n On test setup, the ``app`` resource is made available.\n In a test, you should always use this to access the application root.\n The ``request`` resource can be used to access the test request.::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n+    >>> zserver.STARTUP.testSetUp()\n+    >>> zserver.FUNCTIONAL_TESTING.testSetUp()\n \n The test may now inspect and modify the environment.\n It may also commit things.::\n \n-    >>> app = z2.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app = zserver.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n     >>> app.manage_addFolder(\'folder1\')\n     >>> \'acl_users\' in app.objectIds() and \'folder1\' in app.objectIds()\n     True\n@@ -321,24 +322,24 @@ It may also commit things.::\n \n On tear-down, the database is torn down.::\n \n-    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zserver.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zserver.STARTUP.testTearDown()\n \n-    >>> \'app\' in z2.FUNCTIONAL_TESTING\n+    >>> \'app\' in zserver.FUNCTIONAL_TESTING\n     False\n \n-    >>> \'request\' in z2.FUNCTIONAL_TESTING\n+    >>> \'request\' in zserver.FUNCTIONAL_TESTING\n     False\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n     True\n \n Let\'s tear down the layer:::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.FunctionalTesting in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zserver.FunctionalTesting in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n The test browser\n@@ -351,20 +352,20 @@ To use the test browser with a ``FunctionalTesting`` layer (such as the default\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.FUNCTIONAL_TESTING, setupLayers)\n+    >>> runner.setup_layer(options, zserver.FUNCTIONAL_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.FunctionalTesting in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n+    Set up plone.testing.zserver.FunctionalTesting in ... seconds.\n \n Let\'s simulate a test:::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n+    >>> zserver.STARTUP.testSetUp()\n+    >>> zserver.FUNCTIONAL_TESTING.testSetUp()\n \n In the test, we can create a test browser client like so:::\n \n-    >>> app = z2.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n-    >>> browser = z2.Browser(app)\n+    >>> app = zserver.FUNCTIONAL_TESTING[\'app\'] # would normally be self.layer[\'app\']\n+    >>> browser = zserver.Browser(app)\n \n It is usually best to let Zope errors be shown with full tracebacks:::\n \n@@ -413,16 +414,16 @@ See the ``zope.testbrowser`` documentation for more information about how to use\n \n On tear-down, the database is torn down.::\n \n-    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zserver.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zserver.STARTUP.testTearDown()\n \n-    >>> \'app\' in z2.FUNCTIONAL_TESTING\n+    >>> \'app\' in zserver.FUNCTIONAL_TESTING\n     False\n \n-    >>> \'request\' in z2.FUNCTIONAL_TESTING\n+    >>> \'request\' in zserver.FUNCTIONAL_TESTING\n     False\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds()\\\n     ...         and \'folder1\' not in app.objectIds()\\\n     ...         and \'file1\' not in app.objectIds()\n@@ -431,8 +432,8 @@ On tear-down, the database is torn down.::\n Let\'s tear down the layer:::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.FunctionalTesting in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zserver.FunctionalTesting in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n HTTP server\n@@ -443,44 +444,44 @@ This makes it possible to connect to the test instance using a web browser or a\n \n The ``ZSERVER`` layer provides a ``FunctionalTesting`` layer that has ``ZSERVER_FIXTURE`` as its base.::\n \n-    >>> "%s.%s" % (z2.ZSERVER_FIXTURE.__module__, z2.ZSERVER_FIXTURE.__name__,)\n-    \'plone.testing.z2.ZServer\'\n+    >>> "%s.%s" % (zserver.ZSERVER_FIXTURE.__module__, zserver.ZSERVER_FIXTURE.__name__,)\n+    \'plone.testing.zserver.ZServer\'\n \n-    >>> z2.ZSERVER_FIXTURE.__bases__\n-    (<Layer \'plone.testing.z2.Startup\'>,)\n+    >>> zserver.ZSERVER_FIXTURE.__bases__\n+    (<Layer \'plone.testing.zserver.Startup\'>,)\n \n \n-    >>> "%s.%s" % (z2.ZSERVER.__module__, z2.ZSERVER.__name__,)\n-    \'plone.testing.z2.ZServer:Functional\'\n+    >>> "%s.%s" % (zserver.ZSERVER.__module__, zserver.ZSERVER.__name__,)\n+    \'plone.testing.zserver.ZServer:Functional\'\n \n-    >>> z2.ZSERVER.__bases__\n-    (<Layer \'plone.testing.z2.ZServer\'>,)\n+    >>> zserver.ZSERVER.__bases__\n+    (<Layer \'plone.testing.zserver.ZServer\'>,)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.ZSERVER, setupLayers)\n+    >>> runner.setup_layer(options, zserver.ZSERVER, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.ZServer in ... seconds.\n-    Set up plone.testing.z2.ZServer:Functional in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n+    Set up plone.testing.zserver.ZServer in ... seconds.\n+    Set up plone.testing.zserver.ZServer:Functional in ... seconds.\n \n After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n \n-    >>> host = z2.ZSERVER[\'host\']\n-    >>> port = z2.ZSERVER[\'port\']\n+    >>> host = zserver.ZSERVER[\'host\']\n+    >>> port = zserver.ZSERVER[\'port\']\n \n Let\'s now simulate a test.\n Test setup does nothing beyond what the base layers do.::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n-    >>> z2.ZSERVER.testSetUp()\n+    >>> zserver.STARTUP.testSetUp()\n+    >>> zserver.FUNCTIONAL_TESTING.testSetUp()\n+    >>> zserver.ZSERVER.testSetUp()\n \n It is common in a test to use the Python API to change the state of the server (e.g.\n create some content or change a setting) and then use the HTTP protocol to look at the results.\n-Bear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``z2.login()`` and ``z2.logout()``, for instance, do not affect the server thread.::\n+Bear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``zserver.login()`` and ``zserver.logout()``, for instance, do not affect the server thread.::\n \n-    >>> app = z2.ZSERVER[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app = zserver.ZSERVER[\'app\'] # would normally be self.layer[\'app\']\n     >>> app.manage_addFolder(\'folder1\')\n \n Note that we need to commit the transaction before it will show up in the other thread.::\n@@ -503,26 +504,26 @@ The __repr__ of Zope objects is not stable anymore.\n \n Test tear-down does nothing beyond what the base layers do.::\n \n-    >>> z2.ZSERVER.testTearDown()\n-    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zserver.ZSERVER.testTearDown()\n+    >>> zserver.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zserver.STARTUP.testTearDown()\n \n-    >>> \'app\' in z2.ZSERVER\n+    >>> \'app\' in zserver.ZSERVER\n     False\n \n-    >>> \'request\' in z2.ZSERVER\n+    >>> \'request\' in zserver.ZSERVER\n     False\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n     True\n \n When the server is torn down, the ZServer thread is stopped.::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.ZServer:Functional in ... seconds.\n-    Tear down plone.testing.z2.ZServer in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zserver.ZServer:Functional in ... seconds.\n+    Tear down plone.testing.zserver.ZServer in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n     >>> conn = urllib2.urlopen(app_url + \'/folder1\', timeout=5)\n@@ -542,43 +543,43 @@ The fixture is contained in the ``FTP_SERVER_FIXTURE`` layer.\n \n The ``FTP_SERVER_FIXTURE`` layer is based on the ``STARTUP`` layer.::\n \n-    >>> "%s.%s" % (z2.FTP_SERVER_FIXTURE.__module__, z2.FTP_SERVER_FIXTURE.__name__,)\n-    \'plone.testing.z2.FTPServer\'\n+    >>> "%s.%s" % (zserver.FTP_SERVER_FIXTURE.__module__, zserver.FTP_SERVER_FIXTURE.__name__,)\n+    \'plone.testing.zserver.FTPServer\'\n \n-    >>> z2.FTP_SERVER_FIXTURE.__bases__\n-    (<Layer \'plone.testing.z2.Startup\'>,)\n+    >>> zserver.FTP_SERVER_FIXTURE.__bases__\n+    (<Layer \'plone.testing.zserver.Startup\'>,)\n \n The ``FTP_SERVER`` layer is based on ``FTP_SERVER_FIXTURE``, using the ``FunctionalTesting`` layer class.::\n \n-    >>> "%s.%s" % (z2.FTP_SERVER.__module__, z2.FTP_SERVER.__name__,)\n-    \'plone.testing.z2.FTPServer:Functional\'\n+    >>> "%s.%s" % (zserver.FTP_SERVER.__module__, zserver.FTP_SERVER.__name__,)\n+    \'plone.testing.zserver.FTPServer:Functional\'\n \n-    >>> z2.FTP_SERVER.__bases__\n-    (<Layer \'plone.testing.z2.FTPServer\'>,)\n+    >>> zserver.FTP_SERVER.__bases__\n+    (<Layer \'plone.testing.zserver.FTPServer\'>,)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, z2.FTP_SERVER, setupLayers)\n+    >>> runner.setup_layer(options, zserver.FTP_SERVER, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.FTPServer in ... seconds.\n-    Set up plone.testing.z2.FTPServer:Functional in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n+    Set up plone.testing.zserver.FTPServer in ... seconds.\n+    Set up plone.testing.zserver.FTPServer:Functional in ... seconds.\n \n After layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n \n-    >>> host = z2.FTP_SERVER[\'host\']\n-    >>> port = z2.FTP_SERVER[\'port\']\n+    >>> host = zserver.FTP_SERVER[\'host\']\n+    >>> port = zserver.FTP_SERVER[\'port\']\n \n Let\'s now simulate a test.\n Test setup does nothing beyond what the base layers do.::\n \n-    >>> z2.STARTUP.testSetUp()\n-    >>> z2.FUNCTIONAL_TESTING.testSetUp()\n-    >>> z2.FTP_SERVER.testSetUp()\n+    >>> zserver.STARTUP.testSetUp()\n+    >>> zserver.FUNCTIONAL_TESTING.testSetUp()\n+    >>> zserver.FTP_SERVER.testSetUp()\n \n As with ``ZSERVER``, we will set up some content for the test and then access it over the FTP port.::\n \n-    >>> app = z2.FTP_SERVER[\'app\'] # would normally be self.layer[\'app\']\n+    >>> app = zserver.FTP_SERVER[\'app\'] # would normally be self.layer[\'app\']\n     >>> app.manage_addFolder(\'folder1\')\n \n We\'ll also create a user in the root user folder to make FTP access easier.::\n@@ -615,26 +616,26 @@ We can now look for this new object through the server.::\n \n Test tear-down does nothing beyond what the base layers do.::\n \n-    >>> z2.FTP_SERVER.testTearDown()\n-    >>> z2.FUNCTIONAL_TESTING.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zserver.FTP_SERVER.testTearDown()\n+    >>> zserver.FUNCTIONAL_TESTING.testTearDown()\n+    >>> zserver.STARTUP.testTearDown()\n \n-    >>> \'app\' in z2.ZSERVER\n+    >>> \'app\' in zserver.ZSERVER\n     False\n \n-    >>> \'request\' in z2.ZSERVER\n+    >>> \'request\' in zserver.ZSERVER\n     False\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zserver.zopeApp() as app:\n     ...     \'acl_users\' in app.objectIds() and \'folder1\' not in app.objectIds()\n     True\n \n When the server is torn down, the FTP thread is stopped.::\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.testing.z2.FTPServer:Functional in ... seconds.\n-    Tear down plone.testing.z2.FTPServer in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zserver.FTPServer:Functional in ... seconds.\n+    Tear down plone.testing.zserver.FTPServer in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n     >>> ftpClient.connect(host, port, timeout=5)\ndiff --git a/tox.ini b/tox.ini\nindex 4045a1e..4cf753d 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -1,28 +1,157 @@\n [tox]\n-envlist = py27,\n-          coverage-report\n+envlist =\n+    py27,\n+    py27-zserver,\n+    py36,\n+    coverage-report,\n+#    docs,\n+    lint-py27,\n+    lint-py36,\n+\n minversion = 1.9\n \n [testenv]\n usedevelop = True\n+\n pip_pre = True\n+\n+extras =\n+    test\n+    zserver: z2,zserver\n+\n deps =\n-     .[test]\n-     zope.testrunner\n      coverage\n-commands = coverage run {envbindir}/zope-testrunner --path=src --all {posargs:-vc}\n+\n+commands =\n+    python -V\n+    coverage run {envbindir}/zope-testrunner --path=src --all {posargs:-vc}\n+\n setenv =\n     COVERAGE_FILE=.coverage.{envname}\n \n+passenv =\n+    WSGI_REQUEST_LOGGING\n+\n [testenv:coverage-report]\n+skip_install = true\n basepython = python2.7\n+\n deps = coverage\n+\n setenv =\n     COVERAGE_FILE=.coverage\n-skip_install = true\n+\n commands =\n     coverage erase\n     coverage combine\n     coverage html -i\n     coverage xml -i\n-    coverage report -i\n+    coverage report -i --fail-under=85\n+\n+\n+[lint]\n+skip_install = true\n+\n+deps =\n+    isort\n+    flake8\n+    # helper to generate HTML reports:\n+    flake8-html\n+    # Useful flake8 plugins that are Python and Plone specific:\n+    flake8-coding\n+    flake8-debugger\n+    flake8-deprecated\n+    flake8-print\n+    flake8-pytest\n+    flake8-todo\n+    flake8-isort\n+    mccabe\n+    # Potential flake8 plugins that should be used:  # TBD\n+    #flake8-blind-except\n+    #flake8-commas\n+    #flake8-docstrings\n+    #flake8-mypy\n+    #flake8-pep3101\n+    #flake8-plone-hasattr\n+    #flake8-string-format\n+    #flake8_strict\n+    #flake8-quotes\n+    #flake8-polyfill\n+\n+commands =\n+    mkdir -p {toxinidir}/_build/reports/flake8\n+    - flake8 --format=html --htmldir={toxinidir}/_build/reports/flake8 --doctests src setup.py\n+    flake8 --doctests src tests setup.py\n+    isort --check-only --recursive {toxinidir}/src\n+\n+whitelist_externals =\n+    mkdir\n+\n+[testenv:isort-apply]\n+skip_install = true\n+\n+deps =\n+    isort\n+\n+commands =\n+    isort --apply --recursive {toxinidir}/src\n+\n+[testenv:lint-py27]\n+basepython = python2.7\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:lint-py34]\n+basepython = python3.4\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:lint-py35]\n+basepython = python3.5\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:lint-py36]\n+basepython = python3.6\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:docs]\n+skip_install = true\n+\n+deps =\n+    Sphinx\n+\n+commands =\n+    sphinx-build -b html -d _build/docs/doctrees docs _build/docs/html\n+    sphinx-build -b doctest docs _build/docs/doctrees\n+\n+[testenv:update_translation]\n+skip_install = true\n+\n+deps =\n+    i18ndude\n+\n+commands =\n+    i18ndude find-untranslated\n+    i18ndude rebuild-pot\n+    i18ndude merge\n+    i18ndude sync\n+    i18ndude list\n+\n+[testenv:release]\n+skip_install = true\n+\n+deps =\n+    zest.releaser[recommended]\n+\n+commands =\n+    fullrelease --no-input -v\n'

