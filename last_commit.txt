Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2018-10-08T23:05:47+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.cachepurging/commit/239844d2ede9f7a768296b189739de8938a6e24e

Try to avoid port collisions

On our CI environment it seems that every now and then these tests fail
because the port it tries to bind to is already in use,
see https://github.com/plone/plone.cachepurging/issues/16

Files changed:
M plone/cachepurging/tests/test_purger.py

b'diff --git a/plone/cachepurging/tests/test_purger.py b/plone/cachepurging/tests/test_purger.py\nindex cff450a..9d2cc01 100644\n--- a/plone/cachepurging/tests/test_purger.py\n+++ b/plone/cachepurging/tests/test_purger.py\n@@ -14,11 +14,6 @@\n import unittest\n \n \n-# Define a test HTTP server that returns canned responses\n-\n-SERVER_PORT = int(os.environ.get("ZSERVER_PORT", 8765))\n-\n-\n class TestHandler(BaseHTTPRequestHandler):\n     def do_PURGE(self):\n         # Get the pre-defined response from the server\'s queue.\n@@ -75,7 +70,7 @@ def queue_response(self, **kw):\n class TestCase(unittest.TestCase):\n     def setUp(self):\n         self.purger = DefaultPurger()\n-        self.httpd, self.httpt = self.startServer()\n+        self.httpd, self.httpt, self.port = self.startServer()\n \n     def tearDown(self):\n         try:\n@@ -101,16 +96,18 @@ def tearDown(self):\n                 self.purger = None\n                 self.httpd, self.httpt = None, None\n \n-    def startServer(self, port=SERVER_PORT, start=True):\n+    def startServer(self, start=True):\n         """Start a TestHTTPServer in a separate thread, returning a tuple\n         (server, thread). If start is true, the thread is started.\n         """\n-        server_address = ("localhost", port)\n+        environment_port = int(os.environ.get("ZSERVER_PORT", 0))\n+        server_address = ("localhost", environment_port)\n         httpd = TestHTTPServer(server_address, TestHandler)\n+        _, actual_port = httpd.socket.getsockname()\n         t = threading.Thread(target=httpd.serve_forever)\n         if start:\n             t.start()\n-        return httpd, t\n+        return httpd, t, actual_port\n \n \n class TestSync(TestCase):\n@@ -121,8 +118,8 @@ def setUp(self):\n     def tearDown(self):\n         super(TestSync, self).tearDown()\n \n-    def dispatchURL(self, path, method="PURGE", port=SERVER_PORT):\n-        url = "http://localhost:%s%s" % (port, path)\n+    def dispatchURL(self, path, method="PURGE"):\n+        url = "http://localhost:%s%s" % (self.port, path)\n         return self.purger.purgeSync(url, method)\n \n     def testSimpleSync(self):\n@@ -145,8 +142,8 @@ def testError(self):\n \n \n class TestAsync(TestCase):\n-    def dispatchURL(self, path, method="PURGE", port=SERVER_PORT):\n-        url = "http://localhost:%s%s" % (port, path)\n+    def dispatchURL(self, path, method="PURGE"):\n+        url = "http://localhost:%s%s" % (self.port, path)\n         self.purger.purgeAsync(url, method)\n \n         # Item should now be in the queue!\n@@ -197,10 +194,10 @@ class TestAsyncConnectionFailure(TestCase):\n     def setUp(self):\n         # Override setup to not start the server immediately\n         self.purger = DefaultPurger()\n-        self.httpd, self.httpt = self.startServer(start=False)\n+        self.httpd, self.httpt, self.port = self.startServer(start=False)\n \n-    def dispatchURL(self, path, method="PURGE", port=SERVER_PORT):\n-        url = "http://localhost:%s%s" % (port, path)\n+    def dispatchURL(self, path, method="PURGE"):\n+        url = "http://localhost:%s%s" % (self.port, path)\n         self.purger.purgeAsync(url, method)\n \n         # Item should now be in the queue!\n'

Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2018-10-08T23:05:47+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.cachepurging/commit/f6b4419616559f00c121d6a8b47bb9155edc053e

Update CHANGES.rst

Files changed:
M CHANGES.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 694c5d6..d26b37a 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -14,7 +14,8 @@ Breaking changes:\n \n New features:\n \n-- *add item here*\n+- Try to avoid port collisions when running tests.\n+  [gforcada]\n \n Bug fixes:\n \n'

Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2018-10-09T12:03:02+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.cachepurging/commit/5c3787c45df44e22994633100fd0c523eaf46504

Merge pull request #17 from plone/gforcada-patch-1

Try to avoid port collisions

Files changed:
M CHANGES.rst
M plone/cachepurging/tests/test_purger.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 694c5d6..d26b37a 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -14,7 +14,8 @@ Breaking changes:\n \n New features:\n \n-- *add item here*\n+- Try to avoid port collisions when running tests.\n+  [gforcada]\n \n Bug fixes:\n \ndiff --git a/plone/cachepurging/tests/test_purger.py b/plone/cachepurging/tests/test_purger.py\nindex cff450a..9d2cc01 100644\n--- a/plone/cachepurging/tests/test_purger.py\n+++ b/plone/cachepurging/tests/test_purger.py\n@@ -14,11 +14,6 @@\n import unittest\n \n \n-# Define a test HTTP server that returns canned responses\n-\n-SERVER_PORT = int(os.environ.get("ZSERVER_PORT", 8765))\n-\n-\n class TestHandler(BaseHTTPRequestHandler):\n     def do_PURGE(self):\n         # Get the pre-defined response from the server\'s queue.\n@@ -75,7 +70,7 @@ def queue_response(self, **kw):\n class TestCase(unittest.TestCase):\n     def setUp(self):\n         self.purger = DefaultPurger()\n-        self.httpd, self.httpt = self.startServer()\n+        self.httpd, self.httpt, self.port = self.startServer()\n \n     def tearDown(self):\n         try:\n@@ -101,16 +96,18 @@ def tearDown(self):\n                 self.purger = None\n                 self.httpd, self.httpt = None, None\n \n-    def startServer(self, port=SERVER_PORT, start=True):\n+    def startServer(self, start=True):\n         """Start a TestHTTPServer in a separate thread, returning a tuple\n         (server, thread). If start is true, the thread is started.\n         """\n-        server_address = ("localhost", port)\n+        environment_port = int(os.environ.get("ZSERVER_PORT", 0))\n+        server_address = ("localhost", environment_port)\n         httpd = TestHTTPServer(server_address, TestHandler)\n+        _, actual_port = httpd.socket.getsockname()\n         t = threading.Thread(target=httpd.serve_forever)\n         if start:\n             t.start()\n-        return httpd, t\n+        return httpd, t, actual_port\n \n \n class TestSync(TestCase):\n@@ -121,8 +118,8 @@ def setUp(self):\n     def tearDown(self):\n         super(TestSync, self).tearDown()\n \n-    def dispatchURL(self, path, method="PURGE", port=SERVER_PORT):\n-        url = "http://localhost:%s%s" % (port, path)\n+    def dispatchURL(self, path, method="PURGE"):\n+        url = "http://localhost:%s%s" % (self.port, path)\n         return self.purger.purgeSync(url, method)\n \n     def testSimpleSync(self):\n@@ -145,8 +142,8 @@ def testError(self):\n \n \n class TestAsync(TestCase):\n-    def dispatchURL(self, path, method="PURGE", port=SERVER_PORT):\n-        url = "http://localhost:%s%s" % (port, path)\n+    def dispatchURL(self, path, method="PURGE"):\n+        url = "http://localhost:%s%s" % (self.port, path)\n         self.purger.purgeAsync(url, method)\n \n         # Item should now be in the queue!\n@@ -197,10 +194,10 @@ class TestAsyncConnectionFailure(TestCase):\n     def setUp(self):\n         # Override setup to not start the server immediately\n         self.purger = DefaultPurger()\n-        self.httpd, self.httpt = self.startServer(start=False)\n+        self.httpd, self.httpt, self.port = self.startServer(start=False)\n \n-    def dispatchURL(self, path, method="PURGE", port=SERVER_PORT):\n-        url = "http://localhost:%s%s" % (port, path)\n+    def dispatchURL(self, path, method="PURGE"):\n+        url = "http://localhost:%s%s" % (self.port, path)\n         self.purger.purgeAsync(url, method)\n \n         # Item should now be in the queue!\n'

