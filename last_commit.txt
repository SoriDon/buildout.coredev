Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T21:41:22+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/afe86cbdb4981f6abf43ba0b6e05bd7f80976e3a

Turn browser.txt doctest into test_browser.py unittest.

Files changed:
A news/1486.bugfix
A plone/app/redirector/tests/test_browser.py
D plone/app/redirector/tests/browser.txt
D plone/app/redirector/tests/test_doctests.py

b'diff --git a/news/1486.bugfix b/news/1486.bugfix\nnew file mode 100644\nindex 0000000..247bfaa\n--- /dev/null\n+++ b/news/1486.bugfix\n@@ -0,0 +1,2 @@\n+Turn browser.txt doctest into test_browser.py unittest.\n+[maurits]\ndiff --git a/plone/app/redirector/tests/browser.txt b/plone/app/redirector/tests/browser.txt\ndeleted file mode 100644\nindex c080395..0000000\n--- a/plone/app/redirector/tests/browser.txt\n+++ /dev/null\n@@ -1,48 +0,0 @@\n-Test setup::\n-\n-    >>> app = layer[\'app\']\n-    >>> from plone.testing.z2 import Browser\n-    >>> browser = Browser(app)\n-    >>> browser.handleErrors = False\n-    >>> browser.addHeader(\'Authorization\', \'Basic admin:secret\')\n-    >>> portal = layer[\'portal\']\n-    >>> portal_url = \'http://nohost/plone\'\n-\n-This test checks https://dev.plone.org/plone/ticket/8260, i.e. it makes sure\n-no redirection entries are created when a content object gets instantiated:\n-\n-  >>> from zope.component import getUtility\n-  >>> from plone.app.redirector.interfaces import IRedirectionStorage\n-  >>> storage = getUtility(IRedirectionStorage)\n-\n-Initially the redirection storage should be empty:\n-\n-  >>> list(storage)\n-  []\n-\n-Let\'s create an object and check again:\n-\n-  >>> browser.open(\'http://nohost/plone/\')\n-  >>> browser.getLink(url=\'++add++Document\').click()\n-  >>> browser.getControl(name=\'form.widgets.IDublinCore.title\').value = \'Foo\'\n-  >>> browser.getControl(\'Save\').click()\n-  >>> browser.contents\n-  \'...Info...Item created...\n-   ...documentFirstHeading...Foo...\n-\n-  >>> list(storage)\n-  []\n-\n-However, if this object is renamed in a normal manner, an entry should be\n-created, of course:\n-\n-  >>> browser.open(\'http://nohost/plone/foo\')\n-  >>> browser.getLink(\'Rename\').click()\n-  >>> browser.getControl(\'New Short Name\').value = \'bar\'\n-  >>> browser.getControl(\'New Title\').value = \'Bar\'\n-  >>> browser.getControl(\'Rename\').click()\n-\n-  >>> list(storage)\n-  [\'/plone/foo\']\n-  >>> storage.get(\'/plone/foo\')\n-  \'/plone/bar\'\ndiff --git a/plone/app/redirector/tests/test_browser.py b/plone/app/redirector/tests/test_browser.py\nnew file mode 100644\nindex 0000000..e62ec31\n--- /dev/null\n+++ b/plone/app/redirector/tests/test_browser.py\n@@ -0,0 +1,65 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.redirector.interfaces import IRedirectionStorage\n+from plone.app.redirector.testing import (\n+    PLONE_APP_REDIRECTOR_FUNCTIONAL_TESTING,\n+)\n+from plone.app.testing import SITE_OWNER_NAME\n+from plone.app.testing import SITE_OWNER_PASSWORD\n+from plone.testing.z2 import Browser\n+from zope.component import getUtility\n+\n+import unittest\n+\n+\n+class TestBrowser(unittest.TestCase):\n+    """Test no redirection entries when instantiating object.\n+\n+    This test checks https://dev.plone.org/plone/ticket/8260,\n+    i.e. it makes sure no redirection entries are created when\n+    a content object gets instantiated:\n+\n+    This used to be in browser.txt.\n+    """\n+\n+    layer = PLONE_APP_REDIRECTOR_FUNCTIONAL_TESTING\n+\n+    def setUp(self):\n+        app = self.layer[\'app\']\n+        self.browser = Browser(app)\n+        self.browser.handleErrors = False\n+        self.browser.addHeader(\n+            \'Authorization\',\n+            \'Basic {0}:{1}\'.format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),\n+        )\n+        portal = self.layer[\'portal\']\n+        self.portal_url = portal.absolute_url()\n+\n+    def test_no_redirect_on_creation(self):\n+        storage = getUtility(IRedirectionStorage)\n+        # Initially the redirection storage should be empty:\n+        self.assertListEqual(list(storage), [])\n+\n+        # Let\'s create an object and check again:\n+        self.browser.open(self.portal_url)\n+        self.browser.getLink(url=\'++add++Document\').click()\n+        self.browser.getControl(\n+            name=\'form.widgets.IDublinCore.title\'\n+        ).value = \'Foo\'\n+        self.browser.getControl(\'Save\').click()\n+        self.assertIn(\'Item created\', self.browser.contents)\n+        self.assertListEqual(list(storage), [])\n+\n+        # However, if this object is renamed in a normal manner,\n+        # an entry should be created, of course:\n+        self.browser.getLink(\'Rename\').click()\n+        self.browser.getControl(\'New Short Name\').value = \'bar\'\n+        self.browser.getControl(\'New Title\').value = \'Bar\'\n+        self.browser.getControl(\'Rename\').click()\n+        self.assertListEqual(list(storage), [\'/plone/foo\'])\n+        self.assertEqual(storage.get(\'/plone/foo\'), \'/plone/bar\')\n+\n+\n+def test_suite():\n+    suite = unittest.TestSuite()\n+    suite.addTest(unittest.makeSuite(TestBrowser))\n+    return suite\ndiff --git a/plone/app/redirector/tests/test_doctests.py b/plone/app/redirector/tests/test_doctests.py\ndeleted file mode 100644\nindex c3c2946..0000000\n--- a/plone/app/redirector/tests/test_doctests.py\n+++ /dev/null\n@@ -1,32 +0,0 @@\n-# -*- coding: utf-8 -*-\n-import doctest\n-\n-import unittest\n-import pprint\n-\n-from plone.testing import layered\n-\n-from plone.app.redirector.testing import \\\n-    PLONE_APP_REDIRECTOR_FUNCTIONAL_TESTING\n-\n-\n-optionflags = (\n-    doctest.ELLIPSIS |\n-    doctest.NORMALIZE_WHITESPACE |\n-    doctest.REPORT_ONLY_FIRST_FAILURE)\n-normal_testfiles = [\n-    \'browser.txt\',\n-]\n-\n-\n-def test_suite():\n-    suite = unittest.TestSuite()\n-    suite.addTests([\n-        layered(doctest.DocFileSuite(test,\n-                                     optionflags=optionflags,\n-                                     globs={\'pprint\': pprint.pprint,\n-                                            }\n-                                     ),\n-                layer=PLONE_APP_REDIRECTOR_FUNCTIONAL_TESTING)\n-        for test in normal_testfiles])\n-    return suite\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T21:41:27+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/a7414bc2694814cd26e3e3bbf3f6cc2951fe7ce8

Turned storage.py doctest into unittests.

Files changed:
M news/1486.bugfix
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_storage.py

b'diff --git a/news/1486.bugfix b/news/1486.bugfix\nindex 247bfaa..0db1414 100644\n--- a/news/1486.bugfix\n+++ b/news/1486.bugfix\n@@ -1,2 +1,2 @@\n-Turn browser.txt doctest into test_browser.py unittest.\n+Turned doctests into unittests.\n [maurits]\ndiff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex 47738f4..d48cac9 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -18,193 +18,7 @@ class RedirectionStorage(Persistent):\n     can be pointed to by multiple different "old paths" (several objects\n     that used to be distinct are now consolidated into one).\n \n-    The following tests (see test_storage.py) demonstrate its usage.\n-\n-        >>> p = RedirectionStorage()\n-\n-    Add one redirect\n-\n-        >>> p.has_path(\'/foo\')\n-        False\n-        >>> p.add(\'/foo\', \'/bar\')\n-        >>> p.has_path(\'/foo\')\n-        True\n-        >>> p.get(\'/foo\')\n-        \'/bar\'\n-        >>> p.has_path(\'/bar\')\n-        False\n-        >>> p.redirects(\'/bar\')\n-        [\'/foo\']\n-\n-    Note that trailing slashes are ignored:\n-\n-        >>> p.has_path(\'/foo/\')\n-        True\n-        >>> p.get(\'/foo/\')\n-        \'/bar\'\n-        >>> p.redirects(\'/bar/\')\n-        [\'/foo\']\n-\n-    Circular references are ignored\n-\n-        >>> p.add(\'/circle\', \'/circle\')\n-        >>> p.has_path(\'/circle\')\n-        False\n-        >>> p.get(\'/circle\', \'_marker_\')\n-        \'_marker_\'\n-        >>> p.redirects(\'/circle\')\n-        []\n-\n-    Add another redirect\n-\n-        >>> p.has_path(\'/baz\')\n-        False\n-        >>> p.add(\'/baz\', \'/bar\')\n-        >>> p.has_path(\'/baz\')\n-        True\n-        >>> p.get(\'/baz\')\n-        \'/bar\'\n-        >>> sorted(p.redirects(\'/bar\'))\n-        [\'/baz\', \'/foo\']\n-\n-    Update a redirect\n-\n-        >>> p.add(\'/foo\', \'/quux\')\n-        >>> p.has_path(\'/foo\')\n-        True\n-        >>> p.get(\'/foo\')\n-        \'/quux\'\n-        >>> p.redirects(\'/bar\')\n-        [\'/baz\']\n-        >>> p.redirects(\'/quux\')\n-        [\'/foo\']\n-\n-    Remove a redirect\n-\n-        >>> p.remove(\'/foo\')\n-        >>> p.has_path(\'/foo\')\n-        False\n-        >>> p.get(\'/foo\', default=\'_notfound_\')\n-        \'_notfound_\'\n-        >>> p.redirects(\'/quux\')\n-        []\n-\n-    Update a redirect in a chain\n-\n-        >>> p.add(\'/fred\', \'/foo\')\n-        >>> p.get(\'/fred\')\n-        \'/foo\'\n-        >>> sorted(p.redirects(\'/foo\'))\n-        [\'/fred\']\n-\n-        >>> p.add(\'/fred\', \'/barney\')\n-        >>> p.get(\'/fred\')\n-        \'/barney\'\n-        >>> sorted(p.redirects(\'/foo\'))\n-        []\n-        >>> sorted(p.redirects(\'/barney\'))\n-        [\'/fred\']\n-\n-        >>> p.add(\'/barney\', \'/wilma\')\n-        >>> p.get(\'/fred\')\n-        \'/wilma\'\n-        >>> p.get(\'/barney\')\n-        \'/wilma\'\n-        >>> sorted(p.redirects(\'/wilma\'))\n-        [\'/barney\', \'/fred\']\n-        >>> sorted(p.redirects(\'/barney\'))\n-        []\n-\n-    Destroy the target of a redirect\n-\n-        >>> p.destroy(\'/wilma\')\n-        >>> p.has_path(\'/barney\')\n-        False\n-        >>> p.has_path(\'/fred\')\n-        False\n-        >>> p.redirects(\'/wilma\')\n-        []\n-\n-    What about three step circular rename ?\n-\n-    Add first redirect.\n-\n-        >>> p.add(\'first\', \'second\')\n-\n-    There is only one redirect.\n-\n-        >>> p.get(\'first\')\n-        \'second\'\n-        >>> p.get(\'second\')\n-        >>> p.get(\'third\')\n-\n-    There is one back reference.\n-\n-        >>> p.redirects(\'first\')\n-        []\n-        >>> p.redirects(\'second\')\n-        [\'first\']\n-        >>> p.redirects(\'third\')\n-        []\n-\n-    Add second redirect.\n-\n-        >>> p.add(\'second\', \'third\')\n-\n-    There are now two.\n-\n-        >>> p.get(\'first\')\n-        \'third\'\n-        >>> p.get(\'second\')\n-        \'third\'\n-        >>> p.get(\'third\')\n-\n-    There are two back references as well.\n-\n-        >>> p.redirects(\'first\')\n-        []\n-        >>> p.redirects(\'second\')\n-        []\n-        >>> p.redirects(\'third\')\n-        [\'first\', \'second\']\n-\n-    Add third redirect, CIRCULAR.\n-\n-        >>> p.add(\'third\', \'first\')\n-\n-    There are still only two redirects.\n-\n-        >>> p.get(\'first\')\n-        >>> p.get(\'second\')\n-        \'first\'\n-        >>> p.get(\'third\')\n-        \'first\'\n-\n-    And same for the back references.\n-\n-        >>> p.redirects(\'first\')\n-        [\'second\', \'third\']\n-        >>> p.redirects(\'second\')\n-        []\n-        >>> p.redirects(\'third\')\n-        []\n-\n-    Cleanup after circular\n-\n-        >>> p.remove(\'second\')\n-        >>> p.remove(\'third\')\n-\n-    We can get an iterator over all existing paths\n-\n-        >>> sorted(iter(p))\n-        [\'/baz\']\n-\n-    Now add some more\n-\n-        >>> p.add(\'/foo\', \'/bar\')\n-        >>> p.add(\'/barney\', \'/wilma\')\n-        >>> sorted(p)\n-        [\'/barney\', \'/baz\', \'/foo\']\n+    See test_storage.py for demonstrations of its usage.\n     """\n \n     def __init__(self):\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 5a5bc8d..4cd5aa8 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -1,13 +1,137 @@\n # -*- coding: utf-8 -*-\n+from plone.app.redirector.storage import RedirectionStorage\n+\n import unittest\n-import doctest\n \n-from plone.app.redirector import storage\n \n-optionflags = doctest.REPORT_ONLY_FIRST_FAILURE | doctest.ELLIPSIS\n+class TestStorage(unittest.TestCase):\n+    """Test the RedirectionStorage class.\n+\n+    This used to be in a doctest inside storage.py itself.\n+    """\n+\n+    def test_storage_basics(self):\n+        p = RedirectionStorage()\n+\n+        # Add one redirect\n+        self.assertFalse(p.has_path(\'/foo\'))\n+        p.add(\'/foo\', \'/bar\')\n+        self.assertTrue(p.has_path(\'/foo\'))\n+        self.assertEqual(p.get(\'/foo\'), \'/bar\')\n+        self.assertFalse(p.has_path(\'/bar\'))\n+        self.assertListEqual(p.redirects(\'/bar\'), [\'/foo\'])\n+\n+        # Note that trailing slashes are ignored:\n+        self.assertTrue(p.has_path(\'/foo/\'))\n+        self.assertEqual(p.get(\'/foo/\'), \'/bar\')\n+        self.assertListEqual(p.redirects(\'/bar/\'), [\'/foo\'])\n+\n+        # Circular references are ignored\n+        p.add(\'/circle\', \'/circle\')\n+        self.assertFalse(p.has_path(\'/circle\'))\n+        self.assertEqual(p.get(\'/circle\', \'_marker_\'), \'_marker_\')\n+        self.assertListEqual(p.redirects(\'/circle\'), [])\n+\n+        # Add another redirect\n+        self.assertFalse(p.has_path(\'/baz\'))\n+        p.add(\'/baz\', \'/bar\')\n+        self.assertTrue(p.has_path(\'/baz\'))\n+        self.assertEqual(p.get(\'/baz\'), \'/bar\')\n+        self.assertListEqual(sorted(p.redirects(\'/bar\')), [\'/baz\', \'/foo\'])\n+\n+        # Update a redirect\n+        p.add(\'/foo\', \'/quux\')\n+        self.assertTrue(p.has_path(\'/foo\'))\n+        self.assertEqual(p.get(\'/foo\'), \'/quux\')\n+        self.assertListEqual(p.redirects(\'/bar\'), [\'/baz\'])\n+        self.assertListEqual(p.redirects(\'/quux\'), [\'/foo\'])\n+\n+        # Remove a redirect\n+        p.remove(\'/foo\')\n+        self.assertFalse(p.has_path(\'/foo\'))\n+        self.assertEqual(p.get(\'/foo\', default=\'_notfound_\'), \'_notfound_\')\n+        self.assertListEqual(p.redirects(\'/quux\'), [])\n+\n+        # Update a redirect in a chain\n+        p.add(\'/fred\', \'/foo\')\n+        self.assertEqual(p.get(\'/fred\'), \'/foo\')\n+        self.assertListEqual(sorted(p.redirects(\'/foo\')), [\'/fred\'])\n+\n+        p.add(\'/fred\', \'/barney\')\n+        self.assertEqual(p.get(\'/fred\'), \'/barney\')\n+        self.assertListEqual(sorted(p.redirects(\'/foo\')), [])\n+        self.assertListEqual(sorted(p.redirects(\'/barney\')), [\'/fred\'])\n+\n+        p.add(\'/barney\', \'/wilma\')\n+        self.assertEqual(p.get(\'/fred\'), \'/wilma\')\n+        self.assertEqual(p.get(\'/barney\'), \'/wilma\')\n+        self.assertListEqual(\n+            sorted(p.redirects(\'/wilma\')), [\'/barney\', \'/fred\']\n+        )\n+        self.assertListEqual(sorted(p.redirects(\'/barney\')), [])\n+\n+        # Destroy the target of a redirect\n+        p.destroy(\'/wilma\')\n+        self.assertFalse(p.has_path(\'/barney\'))\n+        self.assertFalse(p.has_path(\'/fred\'))\n+        self.assertListEqual(p.redirects(\'/wilma\'), [])\n+\n+        # We can get an iterator over all existing paths\n+        self.assertListEqual(sorted(iter(p)), [\'/baz\'])\n+\n+        # Now add some more\n+        p.add(\'/foo\', \'/bar\')\n+        p.add(\'/barney\', \'/wilma\')\n+        self.assertListEqual(sorted(p), [\'/barney\', \'/baz\', \'/foo\'])\n+\n+    def test_storage_three_step_circular_rename(self):\n+        # What about three step circular rename ?\n+        p = RedirectionStorage()\n+\n+        # Add first redirect.\n+        p.add(\'first\', \'second\')\n+\n+        # There is only one redirect.\n+\n+        self.assertEqual(p.get(\'first\'), \'second\')\n+        self.assertIsNone(p.get(\'second\'))\n+        self.assertIsNone(p.get(\'third\'))\n+\n+        # There is one back reference.\n+\n+        self.assertListEqual(p.redirects(\'first\'), [])\n+        self.assertListEqual(p.redirects(\'second\'), [\'first\'])\n+        self.assertListEqual(p.redirects(\'third\'), [])\n+\n+        # Add second redirect.\n+        p.add(\'second\', \'third\')\n+\n+        # There are now two.\n+\n+        self.assertEqual(p.get(\'first\'), \'third\')\n+        self.assertEqual(p.get(\'second\'), \'third\')\n+        self.assertIsNone(p.get(\'third\'))\n+\n+        # There are two back references as well.\n+        self.assertListEqual(p.redirects(\'first\'), [])\n+        self.assertListEqual(p.redirects(\'second\'), [])\n+        self.assertListEqual(p.redirects(\'third\'), [\'first\', \'second\'])\n+\n+        # Add third redirect, CIRCULAR.\n+        p.add(\'third\', \'first\')\n+\n+        # There are still only two redirects.\n+        self.assertIsNone(p.get(\'first\'))\n+        self.assertEqual(p.get(\'second\'), \'first\')\n+        self.assertEqual(p.get(\'third\'), \'first\')\n+\n+        # And same for the back references.\n+        self.assertListEqual(p.redirects(\'first\'), [\'second\', \'third\'])\n+        self.assertListEqual(p.redirects(\'second\'), [])\n+        self.assertListEqual(p.redirects(\'third\'), [])\n \n \n def test_suite():\n     suite = unittest.TestSuite()\n-    suite.addTest(doctest.DocTestSuite(storage, optionflags=optionflags))\n+    suite.addTest(unittest.makeSuite(TestStorage))\n     return suite\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T21:41:27+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/34b33004969cc97cbb9088252f6f750188e7b8ae

Split test_storage into multiple tests that test one thing each.

Files changed:
M plone/app/redirector/tests/test_storage.py

b'diff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 4cd5aa8..560263f 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -10,10 +10,9 @@ class TestStorage(unittest.TestCase):\n     This used to be in a doctest inside storage.py itself.\n     """\n \n-    def test_storage_basics(self):\n-        p = RedirectionStorage()\n-\n+    def test_storage_one_redirect(self):\n         # Add one redirect\n+        p = RedirectionStorage()\n         self.assertFalse(p.has_path(\'/foo\'))\n         p.add(\'/foo\', \'/bar\')\n         self.assertTrue(p.has_path(\'/foo\'))\n@@ -21,38 +20,54 @@ def test_storage_basics(self):\n         self.assertFalse(p.has_path(\'/bar\'))\n         self.assertListEqual(p.redirects(\'/bar\'), [\'/foo\'])\n \n-        # Note that trailing slashes are ignored:\n+    def test_storage_trailing_slash(self):\n+        # trailing slashes are ignored\n+        p = RedirectionStorage()\n+        self.assertFalse(p.has_path(\'/foo/\'))\n+        p.add(\'/foo\', \'/bar\')\n         self.assertTrue(p.has_path(\'/foo/\'))\n         self.assertEqual(p.get(\'/foo/\'), \'/bar\')\n         self.assertListEqual(p.redirects(\'/bar/\'), [\'/foo\'])\n \n-        # Circular references are ignored\n-        p.add(\'/circle\', \'/circle\')\n-        self.assertFalse(p.has_path(\'/circle\'))\n-        self.assertEqual(p.get(\'/circle\', \'_marker_\'), \'_marker_\')\n-        self.assertListEqual(p.redirects(\'/circle\'), [])\n+        # This goes the other way around too\n+        self.assertFalse(p.has_path(\'/quux\'))\n+        p.add(\'/quux/\', \'/baaz/\')\n+        self.assertTrue(p.has_path(\'/quux\'))\n+        self.assertEqual(p.get(\'/quux\'), \'/baaz\')\n+        self.assertListEqual(p.redirects(\'/baaz\'), [\'/quux\'])\n \n-        # Add another redirect\n-        self.assertFalse(p.has_path(\'/baz\'))\n+    def test_storage_two_redirects(self):\n+        # Add multiple redirects.\n+        p = RedirectionStorage()\n+        p.add(\'/foo\', \'/bar\')\n         p.add(\'/baz\', \'/bar\')\n         self.assertTrue(p.has_path(\'/baz\'))\n         self.assertEqual(p.get(\'/baz\'), \'/bar\')\n         self.assertListEqual(sorted(p.redirects(\'/bar\')), [\'/baz\', \'/foo\'])\n \n+    def test_storage_update_redirect(self):\n         # Update a redirect\n+        p = RedirectionStorage()\n+        p.add(\'/foo\', \'/bar\')\n+        p.add(\'/baz\', \'/bar\')\n         p.add(\'/foo\', \'/quux\')\n         self.assertTrue(p.has_path(\'/foo\'))\n         self.assertEqual(p.get(\'/foo\'), \'/quux\')\n         self.assertListEqual(p.redirects(\'/bar\'), [\'/baz\'])\n         self.assertListEqual(p.redirects(\'/quux\'), [\'/foo\'])\n \n+    def test_storage_remove_redirect(self):\n         # Remove a redirect\n+        p = RedirectionStorage()\n+        p.add(\'/foo\', \'/bar\')\n         p.remove(\'/foo\')\n         self.assertFalse(p.has_path(\'/foo\'))\n         self.assertEqual(p.get(\'/foo\', default=\'_notfound_\'), \'_notfound_\')\n-        self.assertListEqual(p.redirects(\'/quux\'), [])\n+        self.assertListEqual(p.redirects(\'/bar\'), [])\n \n+    def test_storage_chain(self):\n         # Update a redirect in a chain\n+        p = RedirectionStorage()\n         p.add(\'/fred\', \'/foo\')\n         self.assertEqual(p.get(\'/fred\'), \'/foo\')\n         self.assertListEqual(sorted(p.redirects(\'/foo\')), [\'/fred\'])\n@@ -70,13 +85,23 @@ def test_storage_basics(self):\n         )\n         self.assertListEqual(sorted(p.redirects(\'/barney\')), [])\n \n+    def test_storage_destroy_target(self):\n         # Destroy the target of a redirect\n+        p = RedirectionStorage()\n+        p.add(\'/fred\', \'/barney\')\n+        p.add(\'/barney\', \'/wilma\')\n         p.destroy(\'/wilma\')\n         self.assertFalse(p.has_path(\'/barney\'))\n         self.assertFalse(p.has_path(\'/fred\'))\n         self.assertListEqual(p.redirects(\'/wilma\'), [])\n \n+    def test_storage_iterator(self):\n         # We can get an iterator over all existing paths\n+        p = RedirectionStorage()\n+        self.assertListEqual(sorted(iter(p)), [])\n+\n+        # Add one\n+        p.add(\'/baz\', \'/bar\')\n         self.assertListEqual(sorted(iter(p)), [\'/baz\'])\n \n         # Now add some more\n@@ -84,6 +109,14 @@ def test_storage_basics(self):\n         p.add(\'/barney\', \'/wilma\')\n         self.assertListEqual(sorted(p), [\'/barney\', \'/baz\', \'/foo\'])\n \n+    def test_storage_no_circular(self):\n+        # Circular references are ignored\n+        p = RedirectionStorage()\n+        p.add(\'/circle\', \'/circle\')\n+        self.assertFalse(p.has_path(\'/circle\'))\n+        self.assertEqual(p.get(\'/circle\', \'_marker_\'), \'_marker_\')\n+        self.assertListEqual(p.redirects(\'/circle\'), [])\n+\n     def test_storage_three_step_circular_rename(self):\n         # What about three step circular rename ?\n         p = RedirectionStorage()\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T21:41:27+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/c9360e9a5f7fdea997daec3720d79af6468a03c6

Extra tests for storage without any slash and with nested paths.

Files changed:
M plone/app/redirector/tests/test_storage.py

b"diff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 560263f..7f22ebe 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -20,6 +20,29 @@ def test_storage_one_redirect(self):\n         self.assertFalse(p.has_path('/bar'))\n         self.assertListEqual(p.redirects('/bar'), ['/foo'])\n \n+    def test_storage_no_slash(self):\n+        # Standard Plone will created redirects with key\n+        # /plone-site-id/some/path.\n+        # But a slash at the beginning is not mandatory.\n+        p = RedirectionStorage()\n+        self.assertFalse(p.has_path('foo'))\n+        p.add('foo', 'bar')\n+        self.assertTrue(p.has_path('foo'))\n+        self.assertEqual(p.get('foo'), 'bar')\n+        self.assertFalse(p.has_path('bar'))\n+        self.assertListEqual(p.redirects('bar'), ['foo'])\n+\n+    def test_storage_nested(self):\n+        # Since Plone will created redirects with key\n+        # /plone-site-id/some/path, testing with multiple slashes seems wise.\n+        p = RedirectionStorage()\n+        self.assertFalse(p.has_path('/plone/some/path'))\n+        p.add('/plone/some/path', '/plone/a/different/path')\n+        self.assertTrue(p.has_path('/plone/some/path'))\n+        self.assertEqual(p.get('/plone/some/path'), '/plone/a/different/path')\n+        self.assertFalse(p.has_path('/plone/a/different/path'))\n+        self.assertListEqual(p.redirects('/plone/a/different/path'), ['/plone/some/path'])\n+\n     def test_storage_trailing_slash(self):\n         # trailing slashes are ignored\n         p = RedirectionStorage()\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T21:41:27+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/0c98367ae7e9725e2aa326dd20e835c898ca3d8d

test_storage: renamed 'p' to 'st'.

'p' is reserved when you are in a pdb.

Files changed:
M plone/app/redirector/tests/test_storage.py

b"diff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 7f22ebe..01413bd 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -12,179 +12,179 @@ class TestStorage(unittest.TestCase):\n \n     def test_storage_one_redirect(self):\n         # Add one redirect\n-        p = RedirectionStorage()\n-        self.assertFalse(p.has_path('/foo'))\n-        p.add('/foo', '/bar')\n-        self.assertTrue(p.has_path('/foo'))\n-        self.assertEqual(p.get('/foo'), '/bar')\n-        self.assertFalse(p.has_path('/bar'))\n-        self.assertListEqual(p.redirects('/bar'), ['/foo'])\n+        st = RedirectionStorage()\n+        self.assertFalse(st.has_path('/foo'))\n+        st.add('/foo', '/bar')\n+        self.assertTrue(st.has_path('/foo'))\n+        self.assertEqual(st.get('/foo'), '/bar')\n+        self.assertFalse(st.has_path('/bar'))\n+        self.assertListEqual(st.redirects('/bar'), ['/foo'])\n \n     def test_storage_no_slash(self):\n         # Standard Plone will created redirects with key\n         # /plone-site-id/some/path.\n         # But a slash at the beginning is not mandatory.\n-        p = RedirectionStorage()\n-        self.assertFalse(p.has_path('foo'))\n-        p.add('foo', 'bar')\n-        self.assertTrue(p.has_path('foo'))\n-        self.assertEqual(p.get('foo'), 'bar')\n-        self.assertFalse(p.has_path('bar'))\n-        self.assertListEqual(p.redirects('bar'), ['foo'])\n+        st = RedirectionStorage()\n+        self.assertFalse(st.has_path('foo'))\n+        st.add('foo', 'bar')\n+        self.assertTrue(st.has_path('foo'))\n+        self.assertEqual(st.get('foo'), 'bar')\n+        self.assertFalse(st.has_path('bar'))\n+        self.assertListEqual(st.redirects('bar'), ['foo'])\n \n     def test_storage_nested(self):\n         # Since Plone will created redirects with key\n         # /plone-site-id/some/path, testing with multiple slashes seems wise.\n-        p = RedirectionStorage()\n-        self.assertFalse(p.has_path('/plone/some/path'))\n-        p.add('/plone/some/path', '/plone/a/different/path')\n-        self.assertTrue(p.has_path('/plone/some/path'))\n-        self.assertEqual(p.get('/plone/some/path'), '/plone/a/different/path')\n-        self.assertFalse(p.has_path('/plone/a/different/path'))\n-        self.assertListEqual(p.redirects('/plone/a/different/path'), ['/plone/some/path'])\n+        st = RedirectionStorage()\n+        self.assertFalse(st.has_path('/plone/some/path'))\n+        st.add('/plone/some/path', '/plone/a/different/path')\n+        self.assertTrue(st.has_path('/plone/some/path'))\n+        self.assertEqual(st.get('/plone/some/path'), '/plone/a/different/path')\n+        self.assertFalse(st.has_path('/plone/a/different/path'))\n+        self.assertListEqual(st.redirects('/plone/a/different/path'), ['/plone/some/path'])\n \n     def test_storage_trailing_slash(self):\n         # trailing slashes are ignored\n-        p = RedirectionStorage()\n-        self.assertFalse(p.has_path('/foo/'))\n-        p.add('/foo', '/bar')\n-        self.assertTrue(p.has_path('/foo/'))\n-        self.assertEqual(p.get('/foo/'), '/bar')\n-        self.assertListEqual(p.redirects('/bar/'), ['/foo'])\n+        st = RedirectionStorage()\n+        self.assertFalse(st.has_path('/foo/'))\n+        st.add('/foo', '/bar')\n+        self.assertTrue(st.has_path('/foo/'))\n+        self.assertEqual(st.get('/foo/'), '/bar')\n+        self.assertListEqual(st.redirects('/bar/'), ['/foo'])\n \n         # This goes the other way around too\n-        self.assertFalse(p.has_path('/quux'))\n-        p.add('/quux/', '/baaz/')\n-        self.assertTrue(p.has_path('/quux'))\n-        self.assertEqual(p.get('/quux'), '/baaz')\n-        self.assertListEqual(p.redirects('/baaz'), ['/quux'])\n+        self.assertFalse(st.has_path('/quux'))\n+        st.add('/quux/', '/baaz/')\n+        self.assertTrue(st.has_path('/quux'))\n+        self.assertEqual(st.get('/quux'), '/baaz')\n+        self.assertListEqual(st.redirects('/baaz'), ['/quux'])\n \n     def test_storage_two_redirects(self):\n         # Add multiple redirects.\n-        p = RedirectionStorage()\n-        p.add('/foo', '/bar')\n-        p.add('/baz', '/bar')\n-        self.assertTrue(p.has_path('/baz'))\n-        self.assertEqual(p.get('/baz'), '/bar')\n-        self.assertListEqual(sorted(p.redirects('/bar')), ['/baz', '/foo'])\n+        st = RedirectionStorage()\n+        st.add('/foo', '/bar')\n+        st.add('/baz', '/bar')\n+        self.assertTrue(st.has_path('/baz'))\n+        self.assertEqual(st.get('/baz'), '/bar')\n+        self.assertListEqual(sorted(st.redirects('/bar')), ['/baz', '/foo'])\n \n     def test_storage_update_redirect(self):\n         # Update a redirect\n-        p = RedirectionStorage()\n-        p.add('/foo', '/bar')\n-        p.add('/baz', '/bar')\n-        p.add('/foo', '/quux')\n-        self.assertTrue(p.has_path('/foo'))\n-        self.assertEqual(p.get('/foo'), '/quux')\n-        self.assertListEqual(p.redirects('/bar'), ['/baz'])\n-        self.assertListEqual(p.redirects('/quux'), ['/foo'])\n+        st = RedirectionStorage()\n+        st.add('/foo', '/bar')\n+        st.add('/baz', '/bar')\n+        st.add('/foo', '/quux')\n+        self.assertTrue(st.has_path('/foo'))\n+        self.assertEqual(st.get('/foo'), '/quux')\n+        self.assertListEqual(st.redirects('/bar'), ['/baz'])\n+        self.assertListEqual(st.redirects('/quux'), ['/foo'])\n \n     def test_storage_remove_redirect(self):\n         # Remove a redirect\n-        p = RedirectionStorage()\n-        p.add('/foo', '/bar')\n-        p.remove('/foo')\n-        self.assertFalse(p.has_path('/foo'))\n-        self.assertEqual(p.get('/foo', default='_notfound_'), '_notfound_')\n-        self.assertListEqual(p.redirects('/bar'), [])\n+        st = RedirectionStorage()\n+        st.add('/foo', '/bar')\n+        st.remove('/foo')\n+        self.assertFalse(st.has_path('/foo'))\n+        self.assertEqual(st.get('/foo', default='_notfound_'), '_notfound_')\n+        self.assertListEqual(st.redirects('/bar'), [])\n \n     def test_storage_chain(self):\n         # Update a redirect in a chain\n-        p = RedirectionStorage()\n-        p.add('/fred', '/foo')\n-        self.assertEqual(p.get('/fred'), '/foo')\n-        self.assertListEqual(sorted(p.redirects('/foo')), ['/fred'])\n-\n-        p.add('/fred', '/barney')\n-        self.assertEqual(p.get('/fred'), '/barney')\n-        self.assertListEqual(sorted(p.redirects('/foo')), [])\n-        self.assertListEqual(sorted(p.redirects('/barney')), ['/fred'])\n-\n-        p.add('/barney', '/wilma')\n-        self.assertEqual(p.get('/fred'), '/wilma')\n-        self.assertEqual(p.get('/barney'), '/wilma')\n+        st = RedirectionStorage()\n+        st.add('/fred', '/foo')\n+        self.assertEqual(st.get('/fred'), '/foo')\n+        self.assertListEqual(sorted(st.redirects('/foo')), ['/fred'])\n+\n+        st.add('/fred', '/barney')\n+        self.assertEqual(st.get('/fred'), '/barney')\n+        self.assertListEqual(sorted(st.redirects('/foo')), [])\n+        self.assertListEqual(sorted(st.redirects('/barney')), ['/fred'])\n+\n+        st.add('/barney', '/wilma')\n+        self.assertEqual(st.get('/fred'), '/wilma')\n+        self.assertEqual(st.get('/barney'), '/wilma')\n         self.assertListEqual(\n-            sorted(p.redirects('/wilma')), ['/barney', '/fred']\n+            sorted(st.redirects('/wilma')), ['/barney', '/fred']\n         )\n-        self.assertListEqual(sorted(p.redirects('/barney')), [])\n+        self.assertListEqual(sorted(st.redirects('/barney')), [])\n \n     def test_storage_destroy_target(self):\n         # Destroy the target of a redirect\n-        p = RedirectionStorage()\n-        p.add('/fred', '/barney')\n-        p.add('/barney', '/wilma')\n-        p.destroy('/wilma')\n-        self.assertFalse(p.has_path('/barney'))\n-        self.assertFalse(p.has_path('/fred'))\n-        self.assertListEqual(p.redirects('/wilma'), [])\n+        st = RedirectionStorage()\n+        st.add('/fred', '/barney')\n+        st.add('/barney', '/wilma')\n+        st.destroy('/wilma')\n+        self.assertFalse(st.has_path('/barney'))\n+        self.assertFalse(st.has_path('/fred'))\n+        self.assertListEqual(st.redirects('/wilma'), [])\n \n     def test_storage_iterator(self):\n         # We can get an iterator over all existing paths\n-        p = RedirectionStorage()\n-        self.assertListEqual(sorted(iter(p)), [])\n+        st = RedirectionStorage()\n+        self.assertListEqual(sorted(iter(st)), [])\n \n         # Add one\n-        p.add('/baz', '/bar')\n-        self.assertListEqual(sorted(iter(p)), ['/baz'])\n+        st.add('/baz', '/bar')\n+        self.assertListEqual(sorted(iter(st)), ['/baz'])\n \n         # Now add some more\n-        p.add('/foo', '/bar')\n-        p.add('/barney', '/wilma')\n-        self.assertListEqual(sorted(p), ['/barney', '/baz', '/foo'])\n+        st.add('/foo', '/bar')\n+        st.add('/barney', '/wilma')\n+        self.assertListEqual(sorted(st), ['/barney', '/baz', '/foo'])\n \n     def test_storage_no_circular(self):\n         # Circular references are ignored\n-        p = RedirectionStorage()\n-        p.add('/circle', '/circle')\n-        self.assertFalse(p.has_path('/circle'))\n-        self.assertEqual(p.get('/circle', '_marker_'), '_marker_')\n-        self.assertListEqual(p.redirects('/circle'), [])\n+        st = RedirectionStorage()\n+        st.add('/circle', '/circle')\n+        self.assertFalse(st.has_path('/circle'))\n+        self.assertEqual(st.get('/circle', '_marker_'), '_marker_')\n+        self.assertListEqual(st.redirects('/circle'), [])\n \n     def test_storage_three_step_circular_rename(self):\n         # What about three step circular rename ?\n-        p = RedirectionStorage()\n+        st = RedirectionStorage()\n \n         # Add first redirect.\n-        p.add('first', 'second')\n+        st.add('first', 'second')\n \n         # There is only one redirect.\n \n-        self.assertEqual(p.get('first'), 'second')\n-        self.assertIsNone(p.get('second'))\n-        self.assertIsNone(p.get('third'))\n+        self.assertEqual(st.get('first'), 'second')\n+        self.assertIsNone(st.get('second'))\n+        self.assertIsNone(st.get('third'))\n \n         # There is one back reference.\n \n-        self.assertListEqual(p.redirects('first'), [])\n-        self.assertListEqual(p.redirects('second'), ['first'])\n-        self.assertListEqual(p.redirects('third'), [])\n+        self.assertListEqual(st.redirects('first'), [])\n+        self.assertListEqual(st.redirects('second'), ['first'])\n+        self.assertListEqual(st.redirects('third'), [])\n \n         # Add second redirect.\n-        p.add('second', 'third')\n+        st.add('second', 'third')\n \n         # There are now two.\n \n-        self.assertEqual(p.get('first'), 'third')\n-        self.assertEqual(p.get('second'), 'third')\n-        self.assertIsNone(p.get('third'))\n+        self.assertEqual(st.get('first'), 'third')\n+        self.assertEqual(st.get('second'), 'third')\n+        self.assertIsNone(st.get('third'))\n \n         # There are two back references as well.\n-        self.assertListEqual(p.redirects('first'), [])\n-        self.assertListEqual(p.redirects('second'), [])\n-        self.assertListEqual(p.redirects('third'), ['first', 'second'])\n+        self.assertListEqual(st.redirects('first'), [])\n+        self.assertListEqual(st.redirects('second'), [])\n+        self.assertListEqual(st.redirects('third'), ['first', 'second'])\n \n         # Add third redirect, CIRCULAR.\n-        p.add('third', 'first')\n+        st.add('third', 'first')\n \n         # There are still only two redirects.\n-        self.assertIsNone(p.get('first'))\n-        self.assertEqual(p.get('second'), 'first')\n-        self.assertEqual(p.get('third'), 'first')\n+        self.assertIsNone(st.get('first'))\n+        self.assertEqual(st.get('second'), 'first')\n+        self.assertEqual(st.get('third'), 'first')\n \n         # And same for the back references.\n-        self.assertListEqual(p.redirects('first'), ['second', 'third'])\n-        self.assertListEqual(p.redirects('second'), [])\n-        self.assertListEqual(p.redirects('third'), [])\n+        self.assertListEqual(st.redirects('first'), ['second', 'third'])\n+        self.assertListEqual(st.redirects('second'), [])\n+        self.assertListEqual(st.redirects('third'), [])\n \n \n def test_suite():\n"

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-13T21:41:27+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.redirector/commit/2d893174ed466bc0900022f08d80826e00012d11

Renamed news snippet.

Files changed:
A news/12.bugfix
D news/1486.bugfix

b'diff --git a/news/1486.bugfix b/news/12.bugfix\nsimilarity index 100%\nrename from news/1486.bugfix\nrename to news/12.bugfix\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2019-02-14T10:16:37+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.redirector/commit/b0a99f3d05bc42f55b3e394b555c6099f933840d

Merge pull request #14 from plone/maurits-improve-tests

Move from doctests to unittests and split them up

Files changed:
A news/12.bugfix
A plone/app/redirector/tests/test_browser.py
M plone/app/redirector/storage.py
M plone/app/redirector/tests/test_storage.py
D plone/app/redirector/tests/browser.txt
D plone/app/redirector/tests/test_doctests.py

b'diff --git a/news/12.bugfix b/news/12.bugfix\nnew file mode 100644\nindex 0000000..0db1414\n--- /dev/null\n+++ b/news/12.bugfix\n@@ -0,0 +1,2 @@\n+Turned doctests into unittests.\n+[maurits]\ndiff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex 47738f4..d48cac9 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -18,193 +18,7 @@ class RedirectionStorage(Persistent):\n     can be pointed to by multiple different "old paths" (several objects\n     that used to be distinct are now consolidated into one).\n \n-    The following tests (see test_storage.py) demonstrate its usage.\n-\n-        >>> p = RedirectionStorage()\n-\n-    Add one redirect\n-\n-        >>> p.has_path(\'/foo\')\n-        False\n-        >>> p.add(\'/foo\', \'/bar\')\n-        >>> p.has_path(\'/foo\')\n-        True\n-        >>> p.get(\'/foo\')\n-        \'/bar\'\n-        >>> p.has_path(\'/bar\')\n-        False\n-        >>> p.redirects(\'/bar\')\n-        [\'/foo\']\n-\n-    Note that trailing slashes are ignored:\n-\n-        >>> p.has_path(\'/foo/\')\n-        True\n-        >>> p.get(\'/foo/\')\n-        \'/bar\'\n-        >>> p.redirects(\'/bar/\')\n-        [\'/foo\']\n-\n-    Circular references are ignored\n-\n-        >>> p.add(\'/circle\', \'/circle\')\n-        >>> p.has_path(\'/circle\')\n-        False\n-        >>> p.get(\'/circle\', \'_marker_\')\n-        \'_marker_\'\n-        >>> p.redirects(\'/circle\')\n-        []\n-\n-    Add another redirect\n-\n-        >>> p.has_path(\'/baz\')\n-        False\n-        >>> p.add(\'/baz\', \'/bar\')\n-        >>> p.has_path(\'/baz\')\n-        True\n-        >>> p.get(\'/baz\')\n-        \'/bar\'\n-        >>> sorted(p.redirects(\'/bar\'))\n-        [\'/baz\', \'/foo\']\n-\n-    Update a redirect\n-\n-        >>> p.add(\'/foo\', \'/quux\')\n-        >>> p.has_path(\'/foo\')\n-        True\n-        >>> p.get(\'/foo\')\n-        \'/quux\'\n-        >>> p.redirects(\'/bar\')\n-        [\'/baz\']\n-        >>> p.redirects(\'/quux\')\n-        [\'/foo\']\n-\n-    Remove a redirect\n-\n-        >>> p.remove(\'/foo\')\n-        >>> p.has_path(\'/foo\')\n-        False\n-        >>> p.get(\'/foo\', default=\'_notfound_\')\n-        \'_notfound_\'\n-        >>> p.redirects(\'/quux\')\n-        []\n-\n-    Update a redirect in a chain\n-\n-        >>> p.add(\'/fred\', \'/foo\')\n-        >>> p.get(\'/fred\')\n-        \'/foo\'\n-        >>> sorted(p.redirects(\'/foo\'))\n-        [\'/fred\']\n-\n-        >>> p.add(\'/fred\', \'/barney\')\n-        >>> p.get(\'/fred\')\n-        \'/barney\'\n-        >>> sorted(p.redirects(\'/foo\'))\n-        []\n-        >>> sorted(p.redirects(\'/barney\'))\n-        [\'/fred\']\n-\n-        >>> p.add(\'/barney\', \'/wilma\')\n-        >>> p.get(\'/fred\')\n-        \'/wilma\'\n-        >>> p.get(\'/barney\')\n-        \'/wilma\'\n-        >>> sorted(p.redirects(\'/wilma\'))\n-        [\'/barney\', \'/fred\']\n-        >>> sorted(p.redirects(\'/barney\'))\n-        []\n-\n-    Destroy the target of a redirect\n-\n-        >>> p.destroy(\'/wilma\')\n-        >>> p.has_path(\'/barney\')\n-        False\n-        >>> p.has_path(\'/fred\')\n-        False\n-        >>> p.redirects(\'/wilma\')\n-        []\n-\n-    What about three step circular rename ?\n-\n-    Add first redirect.\n-\n-        >>> p.add(\'first\', \'second\')\n-\n-    There is only one redirect.\n-\n-        >>> p.get(\'first\')\n-        \'second\'\n-        >>> p.get(\'second\')\n-        >>> p.get(\'third\')\n-\n-    There is one back reference.\n-\n-        >>> p.redirects(\'first\')\n-        []\n-        >>> p.redirects(\'second\')\n-        [\'first\']\n-        >>> p.redirects(\'third\')\n-        []\n-\n-    Add second redirect.\n-\n-        >>> p.add(\'second\', \'third\')\n-\n-    There are now two.\n-\n-        >>> p.get(\'first\')\n-        \'third\'\n-        >>> p.get(\'second\')\n-        \'third\'\n-        >>> p.get(\'third\')\n-\n-    There are two back references as well.\n-\n-        >>> p.redirects(\'first\')\n-        []\n-        >>> p.redirects(\'second\')\n-        []\n-        >>> p.redirects(\'third\')\n-        [\'first\', \'second\']\n-\n-    Add third redirect, CIRCULAR.\n-\n-        >>> p.add(\'third\', \'first\')\n-\n-    There are still only two redirects.\n-\n-        >>> p.get(\'first\')\n-        >>> p.get(\'second\')\n-        \'first\'\n-        >>> p.get(\'third\')\n-        \'first\'\n-\n-    And same for the back references.\n-\n-        >>> p.redirects(\'first\')\n-        [\'second\', \'third\']\n-        >>> p.redirects(\'second\')\n-        []\n-        >>> p.redirects(\'third\')\n-        []\n-\n-    Cleanup after circular\n-\n-        >>> p.remove(\'second\')\n-        >>> p.remove(\'third\')\n-\n-    We can get an iterator over all existing paths\n-\n-        >>> sorted(iter(p))\n-        [\'/baz\']\n-\n-    Now add some more\n-\n-        >>> p.add(\'/foo\', \'/bar\')\n-        >>> p.add(\'/barney\', \'/wilma\')\n-        >>> sorted(p)\n-        [\'/barney\', \'/baz\', \'/foo\']\n+    See test_storage.py for demonstrations of its usage.\n     """\n \n     def __init__(self):\ndiff --git a/plone/app/redirector/tests/browser.txt b/plone/app/redirector/tests/browser.txt\ndeleted file mode 100644\nindex c080395..0000000\n--- a/plone/app/redirector/tests/browser.txt\n+++ /dev/null\n@@ -1,48 +0,0 @@\n-Test setup::\n-\n-    >>> app = layer[\'app\']\n-    >>> from plone.testing.z2 import Browser\n-    >>> browser = Browser(app)\n-    >>> browser.handleErrors = False\n-    >>> browser.addHeader(\'Authorization\', \'Basic admin:secret\')\n-    >>> portal = layer[\'portal\']\n-    >>> portal_url = \'http://nohost/plone\'\n-\n-This test checks https://dev.plone.org/plone/ticket/8260, i.e. it makes sure\n-no redirection entries are created when a content object gets instantiated:\n-\n-  >>> from zope.component import getUtility\n-  >>> from plone.app.redirector.interfaces import IRedirectionStorage\n-  >>> storage = getUtility(IRedirectionStorage)\n-\n-Initially the redirection storage should be empty:\n-\n-  >>> list(storage)\n-  []\n-\n-Let\'s create an object and check again:\n-\n-  >>> browser.open(\'http://nohost/plone/\')\n-  >>> browser.getLink(url=\'++add++Document\').click()\n-  >>> browser.getControl(name=\'form.widgets.IDublinCore.title\').value = \'Foo\'\n-  >>> browser.getControl(\'Save\').click()\n-  >>> browser.contents\n-  \'...Info...Item created...\n-   ...documentFirstHeading...Foo...\n-\n-  >>> list(storage)\n-  []\n-\n-However, if this object is renamed in a normal manner, an entry should be\n-created, of course:\n-\n-  >>> browser.open(\'http://nohost/plone/foo\')\n-  >>> browser.getLink(\'Rename\').click()\n-  >>> browser.getControl(\'New Short Name\').value = \'bar\'\n-  >>> browser.getControl(\'New Title\').value = \'Bar\'\n-  >>> browser.getControl(\'Rename\').click()\n-\n-  >>> list(storage)\n-  [\'/plone/foo\']\n-  >>> storage.get(\'/plone/foo\')\n-  \'/plone/bar\'\ndiff --git a/plone/app/redirector/tests/test_browser.py b/plone/app/redirector/tests/test_browser.py\nnew file mode 100644\nindex 0000000..e62ec31\n--- /dev/null\n+++ b/plone/app/redirector/tests/test_browser.py\n@@ -0,0 +1,65 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.redirector.interfaces import IRedirectionStorage\n+from plone.app.redirector.testing import (\n+    PLONE_APP_REDIRECTOR_FUNCTIONAL_TESTING,\n+)\n+from plone.app.testing import SITE_OWNER_NAME\n+from plone.app.testing import SITE_OWNER_PASSWORD\n+from plone.testing.z2 import Browser\n+from zope.component import getUtility\n+\n+import unittest\n+\n+\n+class TestBrowser(unittest.TestCase):\n+    """Test no redirection entries when instantiating object.\n+\n+    This test checks https://dev.plone.org/plone/ticket/8260,\n+    i.e. it makes sure no redirection entries are created when\n+    a content object gets instantiated:\n+\n+    This used to be in browser.txt.\n+    """\n+\n+    layer = PLONE_APP_REDIRECTOR_FUNCTIONAL_TESTING\n+\n+    def setUp(self):\n+        app = self.layer[\'app\']\n+        self.browser = Browser(app)\n+        self.browser.handleErrors = False\n+        self.browser.addHeader(\n+            \'Authorization\',\n+            \'Basic {0}:{1}\'.format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),\n+        )\n+        portal = self.layer[\'portal\']\n+        self.portal_url = portal.absolute_url()\n+\n+    def test_no_redirect_on_creation(self):\n+        storage = getUtility(IRedirectionStorage)\n+        # Initially the redirection storage should be empty:\n+        self.assertListEqual(list(storage), [])\n+\n+        # Let\'s create an object and check again:\n+        self.browser.open(self.portal_url)\n+        self.browser.getLink(url=\'++add++Document\').click()\n+        self.browser.getControl(\n+            name=\'form.widgets.IDublinCore.title\'\n+        ).value = \'Foo\'\n+        self.browser.getControl(\'Save\').click()\n+        self.assertIn(\'Item created\', self.browser.contents)\n+        self.assertListEqual(list(storage), [])\n+\n+        # However, if this object is renamed in a normal manner,\n+        # an entry should be created, of course:\n+        self.browser.getLink(\'Rename\').click()\n+        self.browser.getControl(\'New Short Name\').value = \'bar\'\n+        self.browser.getControl(\'New Title\').value = \'Bar\'\n+        self.browser.getControl(\'Rename\').click()\n+        self.assertListEqual(list(storage), [\'/plone/foo\'])\n+        self.assertEqual(storage.get(\'/plone/foo\'), \'/plone/bar\')\n+\n+\n+def test_suite():\n+    suite = unittest.TestSuite()\n+    suite.addTest(unittest.makeSuite(TestBrowser))\n+    return suite\ndiff --git a/plone/app/redirector/tests/test_doctests.py b/plone/app/redirector/tests/test_doctests.py\ndeleted file mode 100644\nindex c3c2946..0000000\n--- a/plone/app/redirector/tests/test_doctests.py\n+++ /dev/null\n@@ -1,32 +0,0 @@\n-# -*- coding: utf-8 -*-\n-import doctest\n-\n-import unittest\n-import pprint\n-\n-from plone.testing import layered\n-\n-from plone.app.redirector.testing import \\\n-    PLONE_APP_REDIRECTOR_FUNCTIONAL_TESTING\n-\n-\n-optionflags = (\n-    doctest.ELLIPSIS |\n-    doctest.NORMALIZE_WHITESPACE |\n-    doctest.REPORT_ONLY_FIRST_FAILURE)\n-normal_testfiles = [\n-    \'browser.txt\',\n-]\n-\n-\n-def test_suite():\n-    suite = unittest.TestSuite()\n-    suite.addTests([\n-        layered(doctest.DocFileSuite(test,\n-                                     optionflags=optionflags,\n-                                     globs={\'pprint\': pprint.pprint,\n-                                            }\n-                                     ),\n-                layer=PLONE_APP_REDIRECTOR_FUNCTIONAL_TESTING)\n-        for test in normal_testfiles])\n-    return suite\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 5a5bc8d..01413bd 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -1,13 +1,193 @@\n # -*- coding: utf-8 -*-\n+from plone.app.redirector.storage import RedirectionStorage\n+\n import unittest\n-import doctest\n \n-from plone.app.redirector import storage\n \n-optionflags = doctest.REPORT_ONLY_FIRST_FAILURE | doctest.ELLIPSIS\n+class TestStorage(unittest.TestCase):\n+    """Test the RedirectionStorage class.\n+\n+    This used to be in a doctest inside storage.py itself.\n+    """\n+\n+    def test_storage_one_redirect(self):\n+        # Add one redirect\n+        st = RedirectionStorage()\n+        self.assertFalse(st.has_path(\'/foo\'))\n+        st.add(\'/foo\', \'/bar\')\n+        self.assertTrue(st.has_path(\'/foo\'))\n+        self.assertEqual(st.get(\'/foo\'), \'/bar\')\n+        self.assertFalse(st.has_path(\'/bar\'))\n+        self.assertListEqual(st.redirects(\'/bar\'), [\'/foo\'])\n+\n+    def test_storage_no_slash(self):\n+        # Standard Plone will created redirects with key\n+        # /plone-site-id/some/path.\n+        # But a slash at the beginning is not mandatory.\n+        st = RedirectionStorage()\n+        self.assertFalse(st.has_path(\'foo\'))\n+        st.add(\'foo\', \'bar\')\n+        self.assertTrue(st.has_path(\'foo\'))\n+        self.assertEqual(st.get(\'foo\'), \'bar\')\n+        self.assertFalse(st.has_path(\'bar\'))\n+        self.assertListEqual(st.redirects(\'bar\'), [\'foo\'])\n+\n+    def test_storage_nested(self):\n+        # Since Plone will created redirects with key\n+        # /plone-site-id/some/path, testing with multiple slashes seems wise.\n+        st = RedirectionStorage()\n+        self.assertFalse(st.has_path(\'/plone/some/path\'))\n+        st.add(\'/plone/some/path\', \'/plone/a/different/path\')\n+        self.assertTrue(st.has_path(\'/plone/some/path\'))\n+        self.assertEqual(st.get(\'/plone/some/path\'), \'/plone/a/different/path\')\n+        self.assertFalse(st.has_path(\'/plone/a/different/path\'))\n+        self.assertListEqual(st.redirects(\'/plone/a/different/path\'), [\'/plone/some/path\'])\n+\n+    def test_storage_trailing_slash(self):\n+        # trailing slashes are ignored\n+        st = RedirectionStorage()\n+        self.assertFalse(st.has_path(\'/foo/\'))\n+        st.add(\'/foo\', \'/bar\')\n+        self.assertTrue(st.has_path(\'/foo/\'))\n+        self.assertEqual(st.get(\'/foo/\'), \'/bar\')\n+        self.assertListEqual(st.redirects(\'/bar/\'), [\'/foo\'])\n+\n+        # This goes the other way around too\n+        self.assertFalse(st.has_path(\'/quux\'))\n+        st.add(\'/quux/\', \'/baaz/\')\n+        self.assertTrue(st.has_path(\'/quux\'))\n+        self.assertEqual(st.get(\'/quux\'), \'/baaz\')\n+        self.assertListEqual(st.redirects(\'/baaz\'), [\'/quux\'])\n+\n+    def test_storage_two_redirects(self):\n+        # Add multiple redirects.\n+        st = RedirectionStorage()\n+        st.add(\'/foo\', \'/bar\')\n+        st.add(\'/baz\', \'/bar\')\n+        self.assertTrue(st.has_path(\'/baz\'))\n+        self.assertEqual(st.get(\'/baz\'), \'/bar\')\n+        self.assertListEqual(sorted(st.redirects(\'/bar\')), [\'/baz\', \'/foo\'])\n+\n+    def test_storage_update_redirect(self):\n+        # Update a redirect\n+        st = RedirectionStorage()\n+        st.add(\'/foo\', \'/bar\')\n+        st.add(\'/baz\', \'/bar\')\n+        st.add(\'/foo\', \'/quux\')\n+        self.assertTrue(st.has_path(\'/foo\'))\n+        self.assertEqual(st.get(\'/foo\'), \'/quux\')\n+        self.assertListEqual(st.redirects(\'/bar\'), [\'/baz\'])\n+        self.assertListEqual(st.redirects(\'/quux\'), [\'/foo\'])\n+\n+    def test_storage_remove_redirect(self):\n+        # Remove a redirect\n+        st = RedirectionStorage()\n+        st.add(\'/foo\', \'/bar\')\n+        st.remove(\'/foo\')\n+        self.assertFalse(st.has_path(\'/foo\'))\n+        self.assertEqual(st.get(\'/foo\', default=\'_notfound_\'), \'_notfound_\')\n+        self.assertListEqual(st.redirects(\'/bar\'), [])\n+\n+    def test_storage_chain(self):\n+        # Update a redirect in a chain\n+        st = RedirectionStorage()\n+        st.add(\'/fred\', \'/foo\')\n+        self.assertEqual(st.get(\'/fred\'), \'/foo\')\n+        self.assertListEqual(sorted(st.redirects(\'/foo\')), [\'/fred\'])\n+\n+        st.add(\'/fred\', \'/barney\')\n+        self.assertEqual(st.get(\'/fred\'), \'/barney\')\n+        self.assertListEqual(sorted(st.redirects(\'/foo\')), [])\n+        self.assertListEqual(sorted(st.redirects(\'/barney\')), [\'/fred\'])\n+\n+        st.add(\'/barney\', \'/wilma\')\n+        self.assertEqual(st.get(\'/fred\'), \'/wilma\')\n+        self.assertEqual(st.get(\'/barney\'), \'/wilma\')\n+        self.assertListEqual(\n+            sorted(st.redirects(\'/wilma\')), [\'/barney\', \'/fred\']\n+        )\n+        self.assertListEqual(sorted(st.redirects(\'/barney\')), [])\n+\n+    def test_storage_destroy_target(self):\n+        # Destroy the target of a redirect\n+        st = RedirectionStorage()\n+        st.add(\'/fred\', \'/barney\')\n+        st.add(\'/barney\', \'/wilma\')\n+        st.destroy(\'/wilma\')\n+        self.assertFalse(st.has_path(\'/barney\'))\n+        self.assertFalse(st.has_path(\'/fred\'))\n+        self.assertListEqual(st.redirects(\'/wilma\'), [])\n+\n+    def test_storage_iterator(self):\n+        # We can get an iterator over all existing paths\n+        st = RedirectionStorage()\n+        self.assertListEqual(sorted(iter(st)), [])\n+\n+        # Add one\n+        st.add(\'/baz\', \'/bar\')\n+        self.assertListEqual(sorted(iter(st)), [\'/baz\'])\n+\n+        # Now add some more\n+        st.add(\'/foo\', \'/bar\')\n+        st.add(\'/barney\', \'/wilma\')\n+        self.assertListEqual(sorted(st), [\'/barney\', \'/baz\', \'/foo\'])\n+\n+    def test_storage_no_circular(self):\n+        # Circular references are ignored\n+        st = RedirectionStorage()\n+        st.add(\'/circle\', \'/circle\')\n+        self.assertFalse(st.has_path(\'/circle\'))\n+        self.assertEqual(st.get(\'/circle\', \'_marker_\'), \'_marker_\')\n+        self.assertListEqual(st.redirects(\'/circle\'), [])\n+\n+    def test_storage_three_step_circular_rename(self):\n+        # What about three step circular rename ?\n+        st = RedirectionStorage()\n+\n+        # Add first redirect.\n+        st.add(\'first\', \'second\')\n+\n+        # There is only one redirect.\n+\n+        self.assertEqual(st.get(\'first\'), \'second\')\n+        self.assertIsNone(st.get(\'second\'))\n+        self.assertIsNone(st.get(\'third\'))\n+\n+        # There is one back reference.\n+\n+        self.assertListEqual(st.redirects(\'first\'), [])\n+        self.assertListEqual(st.redirects(\'second\'), [\'first\'])\n+        self.assertListEqual(st.redirects(\'third\'), [])\n+\n+        # Add second redirect.\n+        st.add(\'second\', \'third\')\n+\n+        # There are now two.\n+\n+        self.assertEqual(st.get(\'first\'), \'third\')\n+        self.assertEqual(st.get(\'second\'), \'third\')\n+        self.assertIsNone(st.get(\'third\'))\n+\n+        # There are two back references as well.\n+        self.assertListEqual(st.redirects(\'first\'), [])\n+        self.assertListEqual(st.redirects(\'second\'), [])\n+        self.assertListEqual(st.redirects(\'third\'), [\'first\', \'second\'])\n+\n+        # Add third redirect, CIRCULAR.\n+        st.add(\'third\', \'first\')\n+\n+        # There are still only two redirects.\n+        self.assertIsNone(st.get(\'first\'))\n+        self.assertEqual(st.get(\'second\'), \'first\')\n+        self.assertEqual(st.get(\'third\'), \'first\')\n+\n+        # And same for the back references.\n+        self.assertListEqual(st.redirects(\'first\'), [\'second\', \'third\'])\n+        self.assertListEqual(st.redirects(\'second\'), [])\n+        self.assertListEqual(st.redirects(\'third\'), [])\n \n \n def test_suite():\n     suite = unittest.TestSuite()\n-    suite.addTest(doctest.DocTestSuite(storage, optionflags=optionflags))\n+    suite.addTest(unittest.makeSuite(TestStorage))\n     return suite\n'

