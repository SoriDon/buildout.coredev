Repository: plone.restapi


Branch: refs/heads/master
Date: 2019-09-27T11:14:51+02:00
Author: Lukas Graf (lukasgraf) <lukas.graf@4teamwork.ch>
Commit: https://github.com/plone/plone.restapi/commit/f5e7c0193b9f7d7248a3861b884e88c3de73eaa2

Add @sources and @querysources endpoints (#791)

* Add @sources endpoint:

This endpoint will enumerate terms for iterable sources.

* Add @querysources endpoint:

This endpoint allows to query IQuerySources, and
will return the matching terms.

* Add links to new @sources and @querysources endpoints in @types response.

* Docs: Fix formatting for vocabularies.rst and types.rst to conform

to Plone core documentation guidelines (one sentence per line,
don't wrap lines).

Files changed:
A news/790.feature
A src/plone/restapi/services/querysources/__init__.py
A src/plone/restapi/services/querysources/configure.zcml
A src/plone/restapi/services/querysources/get.py
A src/plone/restapi/services/sources/__init__.py
A src/plone/restapi/services/sources/configure.zcml
A src/plone/restapi/services/sources/get.py
A src/plone/restapi/tests/http-examples/querysources_get.req
A src/plone/restapi/tests/http-examples/querysources_get.resp
A src/plone/restapi/tests/http-examples/sources_get.req
A src/plone/restapi/tests/http-examples/sources_get.resp
A src/plone/restapi/tests/test_services_querysources.py
A src/plone/restapi/tests/test_services_sources.py
M docs/source/types.rst
M docs/source/vocabularies.rst
M src/plone/restapi/serializer/configure.zcml
M src/plone/restapi/serializer/vocabularies.py
M src/plone/restapi/services/configure.zcml
M src/plone/restapi/tests/dxtypes.py
M src/plone/restapi/tests/http-examples/translated_messages_types_folder.resp
M src/plone/restapi/tests/http-examples/types_document.resp
M src/plone/restapi/tests/test_documentation.py
M src/plone/restapi/tests/test_services_vocabularies.py
M src/plone/restapi/tests/test_types.py
M src/plone/restapi/types/adapters.py
M src/plone/restapi/types/utils.py

b'diff --git a/docs/source/types.rst b/docs/source/types.rst\nindex 6cec37ae..0bb6c983 100644\n--- a/docs/source/types.rst\n+++ b/docs/source/types.rst\n@@ -25,6 +25,15 @@ To get the schema of a content type, access the ``/@types`` endpoint  with the n\n \n The content type schema uses the `JSON Schema <http://json-schema.org/>`_ format.\n The tagged values for the widgets are also exposed in the the "properties" attribute of the schema.\n-If a \'vocabulary\' is defined, it will be the name of the vocabulary which should be used via the `@vocabularies` endpoint on the actual resource.\n+\n+For ``Choice`` fields, their vocabulary or source will be linked to in a ``vocabulary`` or ``querysource`` property (one or the other, never both):\n+\n+\n+- If a ``querysource`` property is included, that field is backed by an ``IQuerysource``.\n+  In that case, the source\'s terms can\'t be enumerated, and the terms need to be **queried** by issuing a request to the linked endpoint and including the user\'s search terms in the ``?query=`` parameter.\n+- If a ``vocabulary`` property is included, the field is backed by a vocabulary or another kind of iterable source.\n+  The terms can then be **enumerated** by issuing a request to the linked endpoint.\n+\n+See :ref:`vocabularies` for details on these endpoints.\n \n See :ref:`types-schema` for a detailed documentation about the available field types.\ndiff --git a/docs/source/vocabularies.rst b/docs/source/vocabularies.rst\nindex 35bd7eca..37a79e39 100644\n--- a/docs/source/vocabularies.rst\n+++ b/docs/source/vocabularies.rst\n@@ -1,42 +1,84 @@\n-Vocabularies\n-============\n+.. _vocabularies:\n \n-Vocabularies are utilities containing a list of values grouped by interest or different Plone features.\n-For example, ``plone.app.vocabularies.ReallyUserFriendlyTypes`` will return all the content types registered in Plone.\n-The vocabularies return a list of objects with the items ``title`` and ``token``.\n+Vocabularies and Sources\n+========================\n+\n+Vocabularies are a set of allowed choices that back a particular field.\n+They contain so called *terms* which represent those allowed choices.\n+Sources are a similar, but are a more generic and dynamic concept.\n+\n+Concepts\n+--------\n+\n+**Vocabularies** contain a list of terms.\n+These terms are usually tokenized, meaning that in addition to a term\'s value, it also has a ``token`` which is a machine-friendly identifier for the term (7bit ASCII).\n \n .. note::\n-\tThese docs are generated by code tests, therefore you will see some \'test\' contenttypes appear here.\n+    Since the underlying value of a term might not necessarily be serializable (it could be an arbitrary Python object), ``plone.restapi`` only exposes and accepts tokens, and will transparently convert between tokens and values during serialization / deseralization.\n+    For this reason, the following endpoints only support *tokenized* vocabularies / sources, and they do not expose the terms\' values.\n+\n+Terms can also have a ``title``, which is intended to be the user-facing label for the term.\n+For vocabularies or sources whose terms are only tokenized, but not titled, ``plone.restapi`` will fall back to using the token as the term title.\n+\n+**Sources** are similar to vocabularies, but they tend to be more dynamic in nature, and are often used for larger sets of terms.\n+They are also not registered with a global name like vocabularies, but are instead addressed via the field they are assigned to.\n+\n+**Query Sources** are sources that are capable of being queried / searched.\n+The source will then return only the subset of terms that match the query.\n+\n+The use of such a source is usually a strong indication that no attempt should be made to enumerate the full set of terms, but instead the source should only be queried, by presenting the user with an autocomplete widget for example.\n+\n+Both vocabularies and sources can be context-sensitive, meaning that they take the context into account and their contents may therefore change depending on the context they\'re invoked on.\n+\n+This section can only provide a basic overview of vocabularies and related concepts.\n+For a more in-depth explanation please refer to the `Plone documentation <https://docs.plone.org/develop/plone/forms/vocabularies.html>`_.\n+\n+Endpoints overview\n+------------------\n+\n+In ``plone.restapi`` these three concepts are exposed through three separate endpoints (described in more detail below):\n+\n+- **@vocabularies**/(vocab_name)\n+- **@sources**/(field_name)\n+- **@querysources**/(field_name) **?query=** (search_query)\n \n-Get all vocabularies\n---------------------\n+While the ``@vocabularies`` and ``@sources`` endpoints allow to *enumerate* terms (and optionally have terms filtered server-side), the ``@querysources`` endpoint **only** allows for searching the respective source.\n \n-To retrieve a list of all the available vocabularies, send a GET request to the @vocabularies endpoint:\n+\n+List all vocabularies\n+---------------------\n+\n+.. http:get:: (context)/@vocabularies\n+\n+To retrieve a list of all the available vocabularies, send a ``GET`` request to the ``@vocabularies`` endpoint:\n \n ..  http:example:: curl httpie python-requests\n     :request: ../../src/plone/restapi/tests/http-examples/vocabularies.req\n \n-The response will include a list with the URL (``@id``) the dotted names (``title``) of all the available vocabularies in Plone:\n+The response will include a list with the URL (``@id``) and the names (``title``) of all the available vocabularies in Plone:\n \n .. literalinclude:: ../../src/plone/restapi/tests/http-examples/vocabularies.resp\n    :language: http\n \n+\n Get a vocabulary\n ----------------\n \n-To get a particular vocabulary, use the ``@vocabularies`` endpoint with the name of the vocabulary, e.g. ``/plone/@vocabularies/plone.app.vocabularies.ReallyUserFriendlyTypes``.\n+.. http:get:: (context)/@vocabularies/(vocab_name)\n+\n+To enumerate the terms of a particular vocabulary, use the ``@vocabularies`` endpoint with the name of the vocabulary, e.g. ``/plone/@vocabularies/plone.app.vocabularies.ReallyUserFriendlyTypes``.\n The endpoint can be used with the site root and content objects.\n \n ..  http:example:: curl httpie python-requests\n     :request: ../../src/plone/restapi/tests/http-examples/vocabularies_get.req\n \n-The server will respond with a list of terms. The title is purely for display purposes.\n-The token is what should be sent to the server to retrieve the value of the term.\n+The server will respond with a list of terms.\n+The title is purely for display purposes.\n+The token is what should be sent to the server to address that term.\n \n .. note::\n-    Vocabulary terms will be **batched** if the size of the\n-    resultset exceeds the batch size. See :doc:`/batching` for more\n-    details on how to work with batched results.\n+    Vocabulary terms will be **batched** if the size of the resultset exceeds the batch size.\n+    See :doc:`/batching` for more details on how to work with batched results.\n \n .. literalinclude:: ../../src/plone/restapi/tests/http-examples/vocabularies_get.resp\n    :language: http\n@@ -44,6 +86,9 @@ The token is what should be sent to the server to retrieve the value of the term\n Filter Vocabularies\n ^^^^^^^^^^^^^^^^^^^\n \n+.. http:get:: (context)/@vocabularies/(vocab_name)?title=(filter_query)\n+.. http:get:: (context)/@vocabularies/(vocab_name)?token=(filter_query)\n+\n Vocabulary terms can be filtered using the ``title`` or ``token`` parameter.\n \n Use the ``title`` paramenter to filter vocabulary terms by title.\n@@ -68,3 +113,59 @@ E.g. search the term ``doc`` in the token:\n .. note::\n     You must not filter by title and token at the same time.\n     The API returns a 400 response code if you do so.\n+\n+\n+Get a source\n+------------\n+\n+.. http:get:: (context)/@sources/(field_name)\n+\n+To enumerate the terms of a field\'s source, use the ``@sources`` endpoint on a specific context, and pass the field name as a path parameter, e.g. ``/plone/doc/@sources/some_field``.\n+\n+Because sources are inherently tied to a specific field, this endpoint can only be invoked on content objects, and the source is addressed via the field name its used for, instead of a global name (which sources don\'t have).\n+\n+Otherwise the endpoint behaves the same as the ``@vocabularies`` endpoint.\n+\n+Example:\n+\n+..  http:example:: curl httpie python-requests\n+    :request: ../../src/plone/restapi/tests/http-examples/sources_get.req\n+\n+The server will respond with a list of terms.\n+The title is purely for display purposes.\n+The token is what should be sent to the server to address that term.\n+\n+.. literalinclude:: ../../src/plone/restapi/tests/http-examples/sources_get.resp\n+   :language: http\n+\n+.. note::\n+    Technically there can be sources that are not iterable (ones that only implement ``ISource``, but not ``IIterableSource``).\n+    These cannot be enumerated using the ``@sources`` endpoint, and it will respond with a corresponding error.\n+\n+\n+Querying a query source\n+-----------------------\n+\n+.. http:get:: (context)/@querysources/(field_name)?query=(search_query)\n+\n+Query sources (sources implementing `IQuerySource`) can be queried using this endpoint, by passing the search term in the ``query`` parameter.\n+This search term will be passed to the query source\'s ``search()`` method, and the source\'s results are returned.\n+\n+Example:\n+\n+..  http:example:: curl httpie python-requests\n+    :request: ../../src/plone/restapi/tests/http-examples/querysources_get.req\n+\n+The server will respond with a list of terms.\n+The title is purely for display purposes.\n+The token is what should be sent to the server to address that term.\n+\n+.. literalinclude:: ../../src/plone/restapi/tests/http-examples/querysources_get.resp\n+   :language: http\n+\n+.. note::\n+    Even though technically sources that implement ``IQuerySource`` are required to implement ``__iter__`` as well (when strictly following the interface interitance hierarchy), they usually are used in Plone in situations where their full contents shouldn\'t or can\'t be enumerated (imagine a source of all users, backed by a large LDAP, for example).\n+\n+    For this reason, ``plone.restapi`` takes the stance that the ``IQuerySource`` interface is a strong indication that this source should **only** be queried, and therefore doesn\'t support enumeration of terms via the ``@querysources`` endpoint.\n+\n+    *(If the source does actually implement IIterableSource in addition to IQuerySource, it can still be enumerated via the @sources endpoint)*\ndiff --git a/news/790.feature b/news/790.feature\nnew file mode 100644\nindex 00000000..3329103f\n--- /dev/null\n+++ b/news/790.feature\n@@ -0,0 +1,2 @@\n+Add @sources and @querysources endpoints, and link to them from JSON schema in @types response.\n+[lgraf]\ndiff --git a/src/plone/restapi/serializer/configure.zcml b/src/plone/restapi/serializer/configure.zcml\nindex f3d33ffc..bc9dcbc7 100644\n--- a/src/plone/restapi/serializer/configure.zcml\n+++ b/src/plone/restapi/serializer/configure.zcml\n@@ -71,6 +71,7 @@\n              />\n \n     <adapter factory=".vocabularies.SerializeVocabularyToJson" />\n+    <adapter factory=".vocabularies.SerializeSourceToJson" />\n     <adapter factory=".vocabularies.SerializeTermToJson" />\n \n     <adapter factory=".registry.SerializeRegistryToJson" />\ndiff --git a/src/plone/restapi/serializer/vocabularies.py b/src/plone/restapi/serializer/vocabularies.py\nindex 9eedb31a..f6ad6b8a 100644\n--- a/src/plone/restapi/serializer/vocabularies.py\n+++ b/src/plone/restapi/serializer/vocabularies.py\n@@ -6,6 +6,7 @@\n from zope.i18n import translate\n from zope.interface import implementer\n from zope.interface import Interface\n+from zope.schema.interfaces import IIterableSource\n from zope.schema.interfaces import ITitledTokenizedTerm\n from zope.schema.interfaces import ITokenizedTerm\n from zope.schema.interfaces import IVocabulary\n@@ -14,8 +15,11 @@\n \n \n @implementer(ISerializeToJson)\n-@adapter(IVocabulary, Interface)\n-class SerializeVocabularyToJson(object):\n+class SerializeVocabLikeToJson(object):\n+    """Base implementation to serialize vocabularies and sources to JSON.\n+\n+    Implements server-side filtering as well as batching.\n+    """\n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n@@ -66,6 +70,18 @@ def __call__(self, vocabulary_id):\n         return result\n \n \n+@adapter(IVocabulary, Interface)\n+class SerializeVocabularyToJson(SerializeVocabLikeToJson):\n+    """Serializes IVocabulary to JSON.\n+    """\n+\n+\n+@adapter(IIterableSource, Interface)\n+class SerializeSourceToJson(SerializeVocabLikeToJson):\n+    """Serializes IIterableSource to JSON.\n+    """\n+\n+\n @implementer(ISerializeToJson)\n @adapter(ITokenizedTerm, Interface)\n class SerializeTermToJson(object):\ndiff --git a/src/plone/restapi/services/configure.zcml b/src/plone/restapi/services/configure.zcml\nindex 83955132..5ba9cc26 100644\n--- a/src/plone/restapi/services/configure.zcml\n+++ b/src/plone/restapi/services/configure.zcml\n@@ -19,11 +19,13 @@\n   <include package=".history"/>\n   <include package=".locking" />\n   <include package=".principals"/>\n+  <include package=".querysources"/>\n   <include package=".querystring"/>\n   <include package=".querystringsearch"/>\n   <include package=".registry"/>\n   <include package=".roles"/>\n   <include package=".search"/>\n+  <include package=".sources"/>\n   <include package=".types"/>\n   <include package=".users"/>\n   <include package=".vocabularies"/>\ndiff --git a/src/plone/restapi/services/querysources/__init__.py b/src/plone/restapi/services/querysources/__init__.py\nnew file mode 100644\nindex 00000000..e69de29b\ndiff --git a/src/plone/restapi/services/querysources/configure.zcml b/src/plone/restapi/services/querysources/configure.zcml\nnew file mode 100644\nindex 00000000..3cea0d0b\n--- /dev/null\n+++ b/src/plone/restapi/services/querysources/configure.zcml\n@@ -0,0 +1,23 @@\n+<configure\n+    xmlns="http://namespaces.zope.org/zope"\n+    xmlns:plone="http://namespaces.plone.org/plone">\n+\n+  <plone:service\n+    method="GET"\n+    accept="application/json"\n+    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+    factory=".get.QuerySourcesGet"\n+    name="@querysources"\n+    permission="plone.restapi.vocabularies"\n+    />\n+\n+  <plone:service\n+    method="GET"\n+    accept="application/json"\n+    for="Products.CMFCore.interfaces.IContentish"\n+    factory=".get.QuerySourcesGet"\n+    name="@querysources"\n+    permission="plone.restapi.vocabularies"\n+    />\n+\n+</configure>\ndiff --git a/src/plone/restapi/services/querysources/get.py b/src/plone/restapi/services/querysources/get.py\nnew file mode 100644\nindex 00000000..ac2b76ae\n--- /dev/null\n+++ b/src/plone/restapi/services/querysources/get.py\n@@ -0,0 +1,70 @@\n+# -*- coding: utf-8 -*-\n+from plone.restapi.batching import HypermediaBatch\n+from plone.restapi.interfaces import ISerializeToJson\n+from plone.restapi.services.sources.get import get_field_by_name\n+from plone.restapi.services.sources.get import SourcesGet\n+from z3c.formwidget.query.interfaces import IQuerySource\n+from zope.component import getMultiAdapter\n+from zope.interface import implementer\n+from zope.publisher.interfaces import IPublishTraverse\n+\n+\n+@implementer(IPublishTraverse)\n+class QuerySourcesGet(SourcesGet):\n+\n+    def reply(self):\n+        if len(self.params) != 1:\n+            return self._error(\n+                400, "Bad Request",\n+                "Must supply exactly one path parameter (fieldname)"\n+            )\n+        fieldname = self.params[0]\n+\n+        field = get_field_by_name(fieldname, self.context)\n+        if field is None:\n+            return self._error(\n+                404, "Not Found",\n+                "No such field: %r" % fieldname\n+            )\n+        bound_field = field.bind(self.context)\n+\n+        source = bound_field.source\n+        if not IQuerySource.providedBy(source):\n+            return self._error(\n+                404, "Not Found",\n+                "Field %r does not have an IQuerySource" % fieldname\n+            )\n+\n+        if \'query\' not in self.request.form:\n+            return self._error(\n+                400, "Bad Request",\n+                u\'Enumerating querysources is not supported. Please search \'\n+                u\'the source using the ?query= QS parameter\'\n+            )\n+\n+        query = self.request.form[\'query\']\n+\n+        result = source.search(query)\n+\n+        terms = []\n+        for term in result:\n+            terms.append(term)\n+\n+        batch = HypermediaBatch(self.request, terms)\n+\n+        serialized_terms = []\n+        for term in batch:\n+            serializer = getMultiAdapter(\n+                (term, self.request), interface=ISerializeToJson\n+            )\n+            serialized_terms.append(serializer())\n+\n+        result = {\n+            "@id": batch.canonical_url,\n+            "items": serialized_terms,\n+            "items_total": batch.items_total,\n+        }\n+        links = batch.links\n+        if links:\n+            result["batching"] = links\n+        return result\ndiff --git a/src/plone/restapi/services/sources/__init__.py b/src/plone/restapi/services/sources/__init__.py\nnew file mode 100644\nindex 00000000..e69de29b\ndiff --git a/src/plone/restapi/services/sources/configure.zcml b/src/plone/restapi/services/sources/configure.zcml\nnew file mode 100644\nindex 00000000..429dbfd9\n--- /dev/null\n+++ b/src/plone/restapi/services/sources/configure.zcml\n@@ -0,0 +1,14 @@\n+<configure\n+    xmlns="http://namespaces.zope.org/zope"\n+    xmlns:plone="http://namespaces.plone.org/plone">\n+\n+  <plone:service\n+    method="GET"\n+    accept="application/json"\n+    for="Products.CMFCore.interfaces.IContentish"\n+    factory=".get.SourcesGet"\n+    name="@sources"\n+    permission="plone.restapi.vocabularies"\n+    />\n+\n+</configure>\ndiff --git a/src/plone/restapi/services/sources/get.py b/src/plone/restapi/services/sources/get.py\nnew file mode 100644\nindex 00000000..9653d1f4\n--- /dev/null\n+++ b/src/plone/restapi/services/sources/get.py\n@@ -0,0 +1,71 @@\n+# -*- coding: utf-8 -*-\n+from plone.dexterity.utils import iterSchemata\n+from plone.restapi.interfaces import ISerializeToJson\n+from plone.restapi.services import Service\n+from zope.component import getMultiAdapter\n+from zope.interface import implementer\n+from zope.publisher.interfaces import IPublishTraverse\n+from zope.schema import getFieldsInOrder\n+from zope.schema.interfaces import IIterableSource\n+from zope.schema.interfaces import ISource\n+\n+\n+@implementer(IPublishTraverse)\n+class SourcesGet(Service):\n+    def __init__(self, context, request):\n+        super(SourcesGet, self).__init__(context, request)\n+        self.params = []\n+\n+    def publishTraverse(self, request, name):\n+        # Treat any path segments after /@sources as parameters\n+        self.params.append(name)\n+        return self\n+\n+    def _error(self, status, type, message):\n+        self.request.response.setStatus(status)\n+        return {"error": {"type": type, "message": message}}\n+\n+    def reply(self):\n+        if len(self.params) != 1:\n+            return self._error(\n+                400, "Bad Request",\n+                "Must supply exactly one path parameter (fieldname)"\n+            )\n+        fieldname = self.params[0]\n+\n+        field = get_field_by_name(fieldname, self.context)\n+        if field is None:\n+            return self._error(\n+                404, "Not Found",\n+                "No such field: %r" % fieldname\n+            )\n+        bound_field = field.bind(self.context)\n+\n+        source = bound_field.source\n+        if not ISource.providedBy(source):\n+            return self._error(\n+                404, "Not Found",\n+                "Field %r does not have a source" % fieldname\n+            )\n+\n+        if not IIterableSource.providedBy(source):\n+            return self._error(\n+                400, "Bad Request",\n+                "Source for field %r is not iterable. " % fieldname\n+            )\n+\n+        serializer = getMultiAdapter(\n+            (source, self.request), interface=ISerializeToJson\n+        )\n+        return serializer(\n+            "{}/@sources/{}".format(self.context.absolute_url(), fieldname)\n+        )\n+\n+\n+def get_field_by_name(fieldname, context):\n+    schemata = iterSchemata(context)\n+    for schema in schemata:\n+        fields = getFieldsInOrder(schema)\n+        for fn, field in fields:\n+            if fn == fieldname:\n+                return field\ndiff --git a/src/plone/restapi/tests/dxtypes.py b/src/plone/restapi/tests/dxtypes.py\nindex 34c2a026..688bdbe2 100644\n--- a/src/plone/restapi/tests/dxtypes.py\n+++ b/src/plone/restapi/tests/dxtypes.py\n@@ -12,13 +12,19 @@\n from plone.supermodel import model\n from Products.CMFCore.utils import getToolByName\n from pytz import timezone\n+from z3c.formwidget.query.interfaces import IQuerySource\n from z3c.relationfield.schema import RelationChoice\n from z3c.relationfield.schema import RelationList\n from zope import schema\n+from zope.interface import directlyProvides\n+from zope.interface import implementer\n from zope.interface import Invalid\n from zope.interface import invariant\n from zope.interface import provider\n from zope.schema.interfaces import IContextAwareDefaultFactory\n+from zope.schema.interfaces import IContextSourceBinder\n+from zope.schema.interfaces import IIterableSource\n+from zope.schema.interfaces import ISource\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n@@ -30,6 +36,101 @@\n )\n \n \n+@implementer(ISource)\n+class MyNonIterableSource(object):\n+    divisor = 2\n+\n+    def __contains__(self, value):\n+        return bool(value % self.divisor)\n+\n+\n+@implementer(IIterableSource)\n+class MyIterableSource(object):\n+    values = [1, 2, 3]\n+\n+    def __contains__(self, value):\n+        return value in self.values\n+\n+    def __iter__(self):\n+        terms = [SimpleTerm(value=v, token=\'token%s\' % v, title=\'Title %s\' % v)\n+                 for v in self.values]\n+        return iter(terms)\n+\n+\n+@implementer(IQuerySource)\n+class MyIterableQuerySource(object):\n+    values = [1, 2, 3]\n+\n+    def __contains__(self, value):\n+        return value in self.values\n+\n+    def search(self, query):\n+        terms = [SimpleTerm(value=v, token=\'token%s\' % v, title=\'Title %s\' % v)\n+                 for v in self.values]\n+        return [t for t in terms if query in str(t.token)]\n+\n+    def __iter__(self):\n+        # The @querysources endpoint should never attempt to enumerate terms\n+        raise NotImplementedError\n+\n+\n+@implementer(IIterableSource)\n+class MyIterableContextSource(object):\n+\n+    def __init__(self, context):\n+        self.context = context\n+\n+        title_words = self.context.title.split()\n+        self.terms = [SimpleTerm(value=w.lower(), token=w.lower(), title=w)\n+                      for w in title_words]\n+\n+    def __contains__(self, value):\n+        return value in [t.value for t in self.terms]\n+\n+    def __iter__(self):\n+        return iter(self.terms)\n+\n+\n+@implementer(IQuerySource)\n+class MyContextQuerySource(object):\n+\n+    def __init__(self, context):\n+        self.context = context\n+\n+        title_words = self.context.title.split()\n+        self.terms = [SimpleTerm(value=w.lower(), token=w.lower(), title=w)\n+                      for w in title_words]\n+\n+    def __contains__(self, value):\n+        return value in [t.value for t in self.terms]\n+\n+    def __iter__(self):\n+        # The @querysources endpoint should never attempt to enumerate terms\n+        raise NotImplementedError\n+\n+    def search(self, query):\n+        return [t for t in iter(self.terms) if query in str(t.token)]\n+\n+\n+my_iterable_source = MyIterableSource()\n+my_non_iterable_source = MyNonIterableSource()\n+my_querysource = MyIterableQuerySource()\n+\n+\n+def my_context_source_binder(context):\n+    return MyIterableContextSource(context)\n+\n+\n+directlyProvides(my_context_source_binder, IContextSourceBinder)\n+\n+\n+def my_context_querysource_binder(context):\n+    return MyContextQuerySource(context)\n+\n+\n+directlyProvides(my_context_querysource_binder, IContextSourceBinder)\n+\n+\n def vocabularyRequireingContextFactory(context):\n     catalog = getToolByName(context, "portal_catalog")\n     return SimpleVocabulary([SimpleTerm(catalog.id, catalog.id, catalog.id)])\n@@ -53,6 +154,18 @@ class IDXTestDocumentSchema(model.Schema):\n         ),\n         required=False,\n     )\n+\n+    test_choice_with_non_iterable_source = schema.Choice(\n+        required=False, source=my_non_iterable_source)\n+    test_choice_with_source = schema.Choice(\n+        required=False, source=my_iterable_source)\n+    test_choice_with_context_source = schema.Choice(\n+        required=False, source=my_context_source_binder)\n+    test_choice_with_querysource = schema.Choice(\n+        required=False, source=my_querysource)\n+    test_choice_with_context_querysource = schema.Choice(\n+        required=False, source=my_context_querysource_binder)\n+\n     test_date_field = schema.Date(required=False)\n     test_datetime_field = schema.Datetime(required=False)\n     test_datetime_tz_field = schema.Datetime(\ndiff --git a/src/plone/restapi/tests/http-examples/querysources_get.req b/src/plone/restapi/tests/http-examples/querysources_get.req\nnew file mode 100644\nindex 00000000..b6df1c88\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/querysources_get.req\n@@ -0,0 +1,3 @@\n+GET /plone/doc/@querysources/test_choice_with_querysource?query=2 HTTP/1.1\n+Accept: application/json\n+Authorization: Basic YWRtaW46c2VjcmV0\ndiff --git a/src/plone/restapi/tests/http-examples/querysources_get.resp b/src/plone/restapi/tests/http-examples/querysources_get.resp\nnew file mode 100644\nindex 00000000..cd47e5c2\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/querysources_get.resp\n@@ -0,0 +1,13 @@\n+HTTP/1.1 200 OK\n+Content-Type: application/json\n+\n+{\n+  "@id": "http://localhost:55001/plone/doc/@querysources/test_choice_with_querysource?query=2", \n+  "items": [\n+    {\n+      "title": "Title 2", \n+      "token": "token2"\n+    }\n+  ], \n+  "items_total": 1\n+}\n\\ No newline at end of file\ndiff --git a/src/plone/restapi/tests/http-examples/sources_get.req b/src/plone/restapi/tests/http-examples/sources_get.req\nnew file mode 100644\nindex 00000000..34cc4cb6\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/sources_get.req\n@@ -0,0 +1,3 @@\n+GET /plone/doc/@sources/test_choice_with_source HTTP/1.1\n+Accept: application/json\n+Authorization: Basic YWRtaW46c2VjcmV0\ndiff --git a/src/plone/restapi/tests/http-examples/sources_get.resp b/src/plone/restapi/tests/http-examples/sources_get.resp\nnew file mode 100644\nindex 00000000..958c96a2\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/sources_get.resp\n@@ -0,0 +1,21 @@\n+HTTP/1.1 200 OK\n+Content-Type: application/json\n+\n+{\n+  "@id": "http://localhost:55001/plone/doc/@sources/test_choice_with_source", \n+  "items": [\n+    {\n+      "title": "Title 1", \n+      "token": "token1"\n+    }, \n+    {\n+      "title": "Title 2", \n+      "token": "token2"\n+    }, \n+    {\n+      "title": "Title 3", \n+      "token": "token3"\n+    }\n+  ], \n+  "items_total": 3\n+}\n\\ No newline at end of file\ndiff --git a/src/plone/restapi/tests/http-examples/translated_messages_types_folder.resp b/src/plone/restapi/tests/http-examples/translated_messages_types_folder.resp\nindex 977df0c5..ff4d90d5 100644\n--- a/src/plone/restapi/tests/http-examples/translated_messages_types_folder.resp\n+++ b/src/plone/restapi/tests/http-examples/translated_messages_types_folder.resp\n@@ -78,7 +78,10 @@ Content-Type: application/json+schema\n         "No"\n       ], \n       "title": "Permitir comentarios", \n-      "type": "string"\n+      "type": "string", \n+      "vocabulary": {\n+        "@id": "http://localhost:55001/plone/@sources/allow_discussion"\n+      }\n     }, \n     "contributors": {\n       "additionalItems": true, \ndiff --git a/src/plone/restapi/tests/http-examples/types_document.resp b/src/plone/restapi/tests/http-examples/types_document.resp\nindex 3d58d183..88eceb3d 100644\n--- a/src/plone/restapi/tests/http-examples/types_document.resp\n+++ b/src/plone/restapi/tests/http-examples/types_document.resp\n@@ -76,7 +76,10 @@ Content-Type: application/json+schema\n         "No"\n       ], \n       "title": "Allow discussion", \n-      "type": "string"\n+      "type": "string", \n+      "vocabulary": {\n+        "@id": "http://localhost:55001/plone/@sources/allow_discussion"\n+      }\n     }, \n     "changeNote": {\n       "description": "Enter a comment that describes the changes you made.", \ndiff --git a/src/plone/restapi/tests/test_documentation.py b/src/plone/restapi/tests/test_documentation.py\nindex 586c2ff5..c7b4a6a2 100644\n--- a/src/plone/restapi/tests/test_documentation.py\n+++ b/src/plone/restapi/tests/test_documentation.py\n@@ -1048,6 +1048,16 @@ def test_documentation_vocabularies_get_filtered_by_token(self):\n             "vocabularies_get_filtered_by_token", response\n         )\n \n+    def test_documentation_sources_get(self):\n+        api.content.create(\n+            container=self.portal, id="doc", type="DXTestDocument", title=u"DX Document"\n+        )\n+        transaction.commit()\n+        response = self.api_session.get(\n+            "/doc/@sources/test_choice_with_source"\n+        )\n+        save_request_and_response_for_docs("sources_get", response)\n+\n     def test_documentation_sharing_folder_get(self):\n         self.portal.invokeFactory("Folder", id="folder")\n         transaction.commit()\ndiff --git a/src/plone/restapi/tests/test_services_querysources.py b/src/plone/restapi/tests/test_services_querysources.py\nnew file mode 100644\nindex 00000000..e8054a96\n--- /dev/null\n+++ b/src/plone/restapi/tests/test_services_querysources.py\n@@ -0,0 +1,130 @@\n+# -*- coding: utf-8 -*-\n+from plone import api\n+from plone.app.testing import setRoles\n+from plone.app.testing import SITE_OWNER_NAME\n+from plone.app.testing import SITE_OWNER_PASSWORD\n+from plone.app.testing import TEST_USER_ID\n+from plone.restapi.testing import PLONE_RESTAPI_DX_FUNCTIONAL_TESTING\n+from plone.restapi.testing import RelativeSession\n+\n+import transaction\n+import unittest\n+\n+\n+class TestQuerysourcesEndpoint(unittest.TestCase):\n+\n+    layer = PLONE_RESTAPI_DX_FUNCTIONAL_TESTING\n+\n+    maxDiff = None\n+\n+    def setUp(self):\n+        self.app = self.layer["app"]\n+        self.portal = self.layer["portal"]\n+        self.portal_url = self.portal.absolute_url()\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+\n+        self.api_session = RelativeSession(self.portal_url)\n+        self.api_session.headers.update({"Accept": "application/json"})\n+        self.api_session.auth = (SITE_OWNER_NAME, SITE_OWNER_PASSWORD)\n+\n+        self.doc = api.content.create(\n+            container=self.portal, id="testdoc", type="DXTestDocument", title=u"Document 1"\n+        )\n+        transaction.commit()\n+\n+    def test_get_querysource_xxx(self):\n+        response = self.api_session.get(\n+            "%s/@querysources/test_choice_with_querysource?query=2" % self.doc.absolute_url()\n+        )\n+\n+        self.assertEqual(200, response.status_code)\n+        response = response.json()\n+        self.assertEqual(\n+            response,\n+            {\n+                u"@id": self.doc.absolute_url() + u"/@querysources/test_choice_with_querysource?query=2",  # noqa\n+                u"items": [\n+                    {u"title": u"Title 2", u"token": u"token2"},\n+                ],\n+                u"items_total": 1,\n+            },\n+        )\n+\n+    def test_get_querysource_batched(self):\n+        response = self.api_session.get(\n+            "%s/@querysources/test_choice_with_querysource?query=token&b_size=1" % self.doc.absolute_url()\n+        )\n+\n+        self.assertEqual(200, response.status_code)\n+        response = response.json()\n+        self.assertEqual(\n+            response,\n+            {\n+                u"@id": self.doc.absolute_url() + u"/@querysources/test_choice_with_querysource?query=token",  # noqa\n+                u"batching": {\n+                    u"@id": self.doc.absolute_url()\n+                    + u"/@querysources/test_choice_with_querysource?query=token&b_size=1",  # noqa\n+                    u"first": self.doc.absolute_url()\n+                    + u"/@querysources/test_choice_with_querysource?b_start=0&query=token&b_size=1",  # noqa\n+                    u"last": self.doc.absolute_url()\n+                    + u"/@querysources/test_choice_with_querysource?b_start=2&query=token&b_size=1",  # noqa\n+                    u"next": self.doc.absolute_url()\n+                    + u"/@querysources/test_choice_with_querysource?b_start=1&query=token&b_size=1",  # noqa\n+                },\n+                u"items": [\n+                    {u"title": u"Title 1", u"token": u"token1"},\n+                ],\n+                u"items_total": 3,\n+            },\n+        )\n+\n+    def test_querysource_cant_be_enumerated(self):\n+        response = self.api_session.get(\n+            "%s/@querysources/test_choice_with_querysource" % self.doc.absolute_url()\n+        )\n+\n+        self.assertEqual(400, response.status_code)\n+        response = response.json()\n+\n+        self.assertEqual(\n+            response.get("error"),\n+            {\n+                u"type": u"Bad Request",\n+                u"message": u\'Enumerating querysources is not supported. \'\n+                            u\'Please search the source using the ?query= QS parameter\',\n+            },\n+        )\n+\n+    def test_get_querysource_for_unknown_field(self):\n+        response = self.api_session.get("%s/@querysources/unknown_field" % self.doc.absolute_url())\n+\n+        self.assertEqual(404, response.status_code)\n+        response = response.json()\n+        self.assertEqual(response, {\n+            u\'error\': {\n+                u\'type\': u\'Not Found\',\n+                u\'message\': u"No such field: \'unknown_field\'"}})\n+\n+    def test_context_querysource_xxx(self):\n+        self.doc.title = \'Foo Bar Baz\'\n+        transaction.commit()\n+\n+        response = self.api_session.get(\n+            "%s/@querysources/test_choice_with_context_querysource?query=foo" % self.doc.absolute_url()\n+        )\n+\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(\n+            response.json(),\n+            {\n+                u"@id": self.portal_url\n+                + u"/testdoc/@querysources/test_choice_with_context_querysource?query=foo",  # noqa\n+                u"items": [\n+                    {u\'token\': u\'foo\', u\'title\': u\'Foo\'},\n+                ],\n+                u"items_total": 1,\n+            },\n+        )\n+\n+    def tearDown(self):\n+        self.api_session.close()\ndiff --git a/src/plone/restapi/tests/test_services_sources.py b/src/plone/restapi/tests/test_services_sources.py\nnew file mode 100644\nindex 00000000..e724d4e7\n--- /dev/null\n+++ b/src/plone/restapi/tests/test_services_sources.py\n@@ -0,0 +1,202 @@\n+# -*- coding: utf-8 -*-\n+from plone import api\n+from plone.app.testing import setRoles\n+from plone.app.testing import SITE_OWNER_NAME\n+from plone.app.testing import SITE_OWNER_PASSWORD\n+from plone.app.testing import TEST_USER_ID\n+from plone.restapi.testing import PLONE_RESTAPI_DX_FUNCTIONAL_TESTING\n+from plone.restapi.testing import RelativeSession\n+\n+import transaction\n+import unittest\n+\n+\n+class TestSourcesEndpoint(unittest.TestCase):\n+\n+    layer = PLONE_RESTAPI_DX_FUNCTIONAL_TESTING\n+\n+    maxDiff = None\n+\n+    def setUp(self):\n+        self.app = self.layer["app"]\n+        self.portal = self.layer["portal"]\n+        self.portal_url = self.portal.absolute_url()\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+\n+        self.api_session = RelativeSession(self.portal_url)\n+        self.api_session.headers.update({"Accept": "application/json"})\n+        self.api_session.auth = (SITE_OWNER_NAME, SITE_OWNER_PASSWORD)\n+\n+        self.doc = api.content.create(\n+            container=self.portal, id="testdoc", type="DXTestDocument", title=u"Document 1"\n+        )\n+        transaction.commit()\n+\n+    def test_get_source(self):\n+        response = self.api_session.get(\n+            "%s/@sources/test_choice_with_source" % self.doc.absolute_url()\n+        )\n+\n+        self.assertEqual(200, response.status_code)\n+        response = response.json()\n+        self.assertEqual(\n+            response,\n+            {\n+                u"@id": self.doc.absolute_url() + u"/@sources/test_choice_with_source",  # noqa\n+                u"items": [\n+                    {u"title": u"Title 1", u"token": u"token1"},\n+                    {u"title": u"Title 2", u"token": u"token2"},\n+                    {u"title": u"Title 3", u"token": u"token3"},\n+                ],\n+                u"items_total": 3,\n+            },\n+        )\n+\n+    def test_get_source_batched(self):\n+        response = self.api_session.get(\n+            "%s/@sources/test_choice_with_source?b_size=1" % self.doc.absolute_url()\n+        )\n+\n+        self.assertEqual(200, response.status_code)\n+        response = response.json()\n+        self.assertEqual(\n+            response,\n+            {\n+                u"@id": self.doc.absolute_url() + u"/@sources/test_choice_with_source",  # noqa\n+                u"batching": {\n+                    u"@id": self.doc.absolute_url()\n+                    + u"/@sources/test_choice_with_source?b_size=1",  # noqa\n+                    u"first": self.doc.absolute_url()\n+                    + u"/@sources/test_choice_with_source?b_start=0&b_size=1",  # noqa\n+                    u"last": self.doc.absolute_url()\n+                    + u"/@sources/test_choice_with_source?b_start=2&b_size=1",  # noqa\n+                    u"next": self.doc.absolute_url()\n+                    + u"/@sources/test_choice_with_source?b_start=1&b_size=1",  # noqa\n+                },\n+                u"items": [\n+                    {u"title": u"Title 1", u"token": u"token1"},\n+                ],\n+                u"items_total": 3,\n+            },\n+        )\n+\n+    def test_get_source_filtered_by_title(self):\n+        response = self.api_session.get(\n+            "%s/@sources/test_choice_with_source?title=2" % self.doc.absolute_url()\n+        )\n+\n+        self.assertEqual(200, response.status_code)\n+        response = response.json()\n+        self.assertEqual(\n+            response,\n+            {\n+                u"@id": self.doc.absolute_url()\n+                + u"/@sources/test_choice_with_source?title=2",  # noqa\n+                u"items": [{u"title": u"Title 2", u"token": u"token2"}],\n+                u"items_total": 1,\n+            },\n+        )\n+\n+    def test_get_source_filtered_by_token(self):\n+        response = self.api_session.get(\n+            "%s/@sources/test_choice_with_source?token=token1" % self.doc.absolute_url()\n+        )\n+\n+        self.assertEqual(200, response.status_code)\n+        response = response.json()\n+        self.assertEqual(\n+            response,\n+            {\n+                u"@id": self.doc.absolute_url()\n+                + u"/@sources/test_choice_with_source?token=token1",  # noqa\n+                u"items": [{u"title": u"Title 1", u"token": u"token1"}],\n+                u"items_total": 1,\n+            },\n+        )\n+\n+    def test_get_source_filtered_by_token_partial_not_match(self):\n+        response = self.api_session.get(\n+            "%s/@sources/test_choice_with_source?token=token" % self.doc.absolute_url()\n+        )\n+\n+        self.assertEqual(200, response.status_code)\n+        response = response.json()\n+        self.assertEqual(\n+            response,\n+            {\n+                u"@id": self.doc.absolute_url()\n+                + u"/@sources/test_choice_with_source?token=token",  # noqa\n+                u"items": [],\n+                u"items_total": 0,\n+            },\n+        )\n+\n+    def test_get_source_filtered_by_title_and_token_returns_error(self):\n+        response = self.api_session.get(\n+            "%s/@sources/test_choice_with_source?token=token1&title=Title" % self.doc.absolute_url()  # noqa\n+        )\n+\n+        self.assertEqual(400, response.status_code)\n+        response = response.json()\n+        self.assertEqual(\n+            response.get("error"),\n+            {\n+                u"type": u"Invalid parameters",\n+                u"message": u"You can not filter by title and token at the same time.",  # noqa\n+            },\n+        )\n+\n+    def test_get_non_iterable_source_returns_error(self):\n+        response = self.api_session.get(\n+            "%s/@sources/test_choice_with_non_iterable_source" % self.doc.absolute_url()\n+        )\n+\n+        self.assertEqual(400, response.status_code)\n+        response = response.json()\n+        self.assertEqual(\n+            response.get("error"),\n+            {\n+                u"type": u"Bad Request",\n+                u"message": "Source for field \'test_choice_with_non_iterable_source\' is not iterable. ",\n+            },\n+        )\n+\n+    def test_get_source_for_unknown_field(self):\n+        response = self.api_session.get("%s/@sources/unknown_field" % self.doc.absolute_url())\n+\n+        self.assertEqual(404, response.status_code)\n+        response = response.json()\n+\n+        self.assertEqual(\n+            response.get("error"),\n+            {\n+                u"type": u"Not Found",\n+                u"message": u"No such field: \'unknown_field\'",\n+            },\n+        )\n+\n+    def test_context_source(self):\n+        self.doc.title = \'Foo Bar Baz\'\n+        transaction.commit()\n+\n+        response = self.api_session.get(\n+            "%s/@sources/test_choice_with_context_source" % self.doc.absolute_url()\n+        )\n+\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(\n+            response.json(),\n+            {\n+                u"@id": self.portal_url\n+                + u"/testdoc/@sources/test_choice_with_context_source",  # noqa\n+                u"items": [\n+                    {u\'token\': u\'foo\', u\'title\': u\'Foo\'},\n+                    {u\'token\': u\'bar\', u\'title\': u\'Bar\'},\n+                    {u\'token\': u\'baz\', u\'title\': u\'Baz\'},\n+                ],\n+                u"items_total": 3,\n+            },\n+        )\n+\n+    def tearDown(self):\n+        self.api_session.close()\ndiff --git a/src/plone/restapi/tests/test_services_vocabularies.py b/src/plone/restapi/tests/test_services_vocabularies.py\nindex 9208712f..bddfb0d0 100644\n--- a/src/plone/restapi/tests/test_services_vocabularies.py\n+++ b/src/plone/restapi/tests/test_services_vocabularies.py\n@@ -207,7 +207,11 @@ def test_get_unknown_vocabulary(self):\n \n         self.assertEqual(404, response.status_code)\n         response = response.json()\n-        self.assertEqual(response["error"]["type"], u"Not Found")\n+\n+        self.assertEqual(response, {\n+            u\'error\': {\n+                u\'type\': u\'Not Found\',\n+                u\'message\': u"The vocabulary \'unknown.vocabulary\' does not exist"}})\n \n     def test_get_all_vocabularies(self):\n         response = self.api_session.get("/@vocabularies")\ndiff --git a/src/plone/restapi/tests/test_types.py b/src/plone/restapi/tests/test_types.py\nindex ac218028..bf82475a 100644\n--- a/src/plone/restapi/tests/test_types.py\n+++ b/src/plone/restapi/tests/test_types.py\n@@ -357,6 +357,7 @@ def test_int(self):\n \n     def test_choice(self):\n         field = schema.Choice(\n+            __name__="myfield",\n             title=u"My field",\n             description=u"My great field",\n             vocabulary=self.dummy_vocabulary,\n@@ -373,6 +374,7 @@ def test_choice(self):\n                 "enum": ["foo", "bar"],\n                 "enumNames": ["Foo", "Bar"],\n                 "choices": [("foo", "Foo"), ("bar", "Bar")],\n+                \'vocabulary\': {\'@id\': \'http://nohost/plone/@sources/myfield\'},\n             },\n             adapter.get_schema(),\n         )\n@@ -401,6 +403,7 @@ def test_choice_named_vocab(self):\n \n     def test_choice_source_vocab(self):\n         field = schema.Choice(\n+            __name__="myfield",\n             title=u"My field",\n             description=u"My great field",\n             source=self.dummy_source_vocab,\n@@ -417,6 +420,7 @@ def test_choice_source_vocab(self):\n                 "enum": ["foo", "bar"],\n                 "enumNames": ["Foo", "Bar"],\n                 "choices": [("foo", "Foo"), ("bar", "Bar")],\n+                "vocabulary": {\'@id\': \'http://nohost/plone/@sources/myfield\'},\n             },\n             adapter.get_schema(),\n         )\n@@ -493,6 +497,7 @@ def test_collection(self):\n \n         # List of choices\n         field = schema.List(\n+            __name__="myfield",\n             title=u"My field",\n             value_type=schema.Choice(vocabulary=self.dummy_vocabulary),\n         )\n@@ -514,6 +519,7 @@ def test_collection(self):\n                     "enum": ["foo", "bar"],\n                     "enumNames": ["Foo", "Bar"],\n                     "choices": [("foo", "Foo"), ("bar", "Bar")],\n+                    \'vocabulary\': {\'@id\': \'http://nohost/plone/@sources/\'},\n                 },\n             },\n             adapter.get_schema(),\ndiff --git a/src/plone/restapi/types/adapters.py b/src/plone/restapi/types/adapters.py\nindex d715202b..5ec9a837 100644\n--- a/src/plone/restapi/types/adapters.py\n+++ b/src/plone/restapi/types/adapters.py\n@@ -4,9 +4,12 @@\n from plone.restapi.types.interfaces import IJsonSchemaProvider\n from plone.restapi.types.utils import get_fieldsets\n from plone.restapi.types.utils import get_jsonschema_properties\n+from plone.restapi.types.utils import get_querysource_url\n+from plone.restapi.types.utils import get_source_url\n from plone.restapi.types.utils import get_vocabulary_url\n from plone.restapi.types.utils import get_widget_params\n from plone.schema import IJSONField\n+from z3c.formwidget.query.interfaces import IQuerySource\n from zope.component import adapter\n from zope.component import getMultiAdapter\n from zope.i18n import translate\n@@ -248,6 +251,7 @@ def get_type(self):\n         return "string"\n \n     def additional(self):\n+        # Named global vocabulary\n         vocab_name = getattr(self.field, "vocabularyName", None)\n         if vocab_name:\n             return {\n@@ -256,12 +260,33 @@ def additional(self):\n                 }\n             }\n \n-        # Maybe we have an unnamed vocabulary or source.\n-\n+        # Maybe an unnamed vocabulary or source.\n         vocabulary = getattr(self.field, "vocabulary", None)\n         if IContextSourceBinder.providedBy(vocabulary):\n             vocabulary = vocabulary(self.context)\n \n+        # Query source\n+        if IQuerySource.providedBy(vocabulary):\n+            return {\n+                "querysource": {\n+                    "@id": get_querysource_url(self.field, self.context, self.request)\n+                }\n+            }\n+\n+        # Unamed ISource or vocabulary - render link addressing it via field\n+        #\n+        # Even though the URL will point to the @sources endpoint, we also\n+        # list it under the \'vocabulary\' key, because the semantics for an\n+        # API consumer are exactly the same: A GET to that URL will enumerate\n+        # terms, and will support batching and filtering by title/token.\n+        result = {\n+            "vocabulary": {\n+                "@id": get_source_url(self.field, self.context, self.request)\n+            }\n+        }\n+\n+        # Optionally inline choices for unnamed sources\n+        # (this is for BBB, and may eventually be deprecated)\n         if hasattr(vocabulary, "__iter__") and self.should_render_choices:\n             # choices and enumNames are v5 proposals, for now we implement both\n             choices = []\n@@ -274,9 +299,12 @@ def additional(self):\n                 enum.append(term.token)\n                 enum_names.append(title)\n \n-            return {"enum": enum, "enumNames": enum_names, "choices": choices}\n-        else:\n-            return {}\n+            result.update(\n+                {"enum": enum,\n+                 "enumNames": enum_names,\n+                 "choices": choices})\n+\n+        return result\n \n \n @adapter(IObject, Interface, Interface)\ndiff --git a/src/plone/restapi/types/utils.py b/src/plone/restapi/types/utils.py\nindex e46d5388..3dd562d5 100644\n--- a/src/plone/restapi/types/utils.py\n+++ b/src/plone/restapi/types/utils.py\n@@ -199,10 +199,22 @@ def get_jsonschema_for_portal_type(portal_type, context, request, excluded_field\n     )\n \n \n-def get_vocabulary_url(vocab_name, context, request):\n+def get_vocab_like_url(endpoint, locator, context, request):\n     try:\n         context_url = context.absolute_url()\n     except AttributeError:\n         portal = getSite()\n         context_url = portal.absolute_url()\n-    return "{}/@vocabularies/{}".format(context_url, vocab_name)\n+    return \'/\'.join((context_url, endpoint, locator))\n+\n+\n+def get_vocabulary_url(vocab_name, context, request):\n+    return get_vocab_like_url(\'@vocabularies\', vocab_name, context, request)\n+\n+\n+def get_querysource_url(field, context, request):\n+    return get_vocab_like_url(\'@querysources\', field.getName(), context, request)\n+\n+\n+def get_source_url(field, context, request):\n+    return get_vocab_like_url(\'@sources\', field.getName(), context, request)\n'

