Repository: plone.restapi


Branch: refs/heads/master
Date: 2019-04-25T18:14:06+02:00
Author: Thomas Buchberger (buchi) <t.buchberger@4teamwork.ch>
Commit: https://github.com/plone/plone.restapi/commit/dd182995f7ceeef3ac269a003f8c0ae6ac93eb73

Use tokens for serialization and deserialization of vocabulary terms

Fixes #691

Files changed:
A news/691.breaking
M src/plone/restapi/deserializer/configure.zcml
M src/plone/restapi/deserializer/dxfields.py
M src/plone/restapi/serializer/configure.zcml
M src/plone/restapi/serializer/dxfields.py
M src/plone/restapi/tests/dxtypes.py
M src/plone/restapi/tests/test_dxfield_deserializer.py
M src/plone/restapi/tests/test_dxfield_serializer.py

b'diff --git a/news/691.breaking b/news/691.breaking\nnew file mode 100644\nindex 00000000..51b72235\n--- /dev/null\n+++ b/news/691.breaking\n@@ -0,0 +1,4 @@\n+Use tokens for serialization/deserialization of vocabulary terms.\n+This may break clients if the serialization of a term\'s value is not equal to the token.\n+[buchi]\n+\ndiff --git a/src/plone/restapi/deserializer/configure.zcml b/src/plone/restapi/deserializer/configure.zcml\nindex 635e2c5b..9c89af2e 100644\n--- a/src/plone/restapi/deserializer/configure.zcml\n+++ b/src/plone/restapi/deserializer/configure.zcml\n@@ -8,6 +8,7 @@\n   <adapter factory=".dxcontent.DeserializeFromJson" />\n   <adapter factory=".dxfields.DefaultFieldDeserializer" />\n   <adapter factory=".dxfields.DatetimeFieldDeserializer" />\n+  <adapter factory=".dxfields.ChoiceFieldDeserializer" />\n   <adapter factory=".dxfields.CollectionFieldDeserializer" />\n   <adapter factory=".dxfields.DictFieldDeserializer" />\n   <adapter factory=".dxfields.TextLineFieldDeserializer" />\ndiff --git a/src/plone/restapi/deserializer/dxfields.py b/src/plone/restapi/deserializer/dxfields.py\nindex fd1cd046..81897723 100644\n--- a/src/plone/restapi/deserializer/dxfields.py\n+++ b/src/plone/restapi/deserializer/dxfields.py\n@@ -14,6 +14,7 @@\n from zope.component import queryMultiAdapter\n from zope.interface import implementer\n from zope.publisher.interfaces.browser import IBrowserRequest\n+from zope.schema.interfaces import IChoice\n from zope.schema.interfaces import ICollection\n from zope.schema.interfaces import IDatetime\n from zope.schema.interfaces import IDict\n@@ -22,6 +23,7 @@\n from zope.schema.interfaces import ITextLine\n from zope.schema.interfaces import ITime\n from zope.schema.interfaces import ITimedelta\n+from zope.schema.interfaces import IVocabularyTokenized\n \n import codecs\n import dateutil\n@@ -115,6 +117,21 @@ def __call__(self, value):\n         return value\n \n \n+@implementer(IFieldDeserializer)\n+@adapter(IChoice, IDexterityContent, IBrowserRequest)\n+class ChoiceFieldDeserializer(DefaultFieldDeserializer):\n+\n+    def __call__(self, value):\n+        if IVocabularyTokenized.providedBy(self.field.vocabulary):\n+            try:\n+                value = self.field.vocabulary.getTermByToken(value).value\n+            except LookupError:\n+                pass\n+\n+        self.field.validate(value)\n+        return value\n+\n+\n @implementer(IFieldDeserializer)\n @adapter(ICollection, IDexterityContent, IBrowserRequest)\n class CollectionFieldDeserializer(DefaultFieldDeserializer):\ndiff --git a/src/plone/restapi/serializer/configure.zcml b/src/plone/restapi/serializer/configure.zcml\nindex 041400fc..c7500e5d 100644\n--- a/src/plone/restapi/serializer/configure.zcml\n+++ b/src/plone/restapi/serializer/configure.zcml\n@@ -15,6 +15,8 @@\n     <adapter factory=".summary.SiteRootJSONSummarySerializer" />\n \n     <adapter factory=".dxfields.DefaultFieldSerializer" />\n+    <adapter factory=".dxfields.ChoiceFieldSerializer" />\n+    <adapter factory=".dxfields.CollectionFieldSerializer" />\n     <adapter factory=".dxfields.FileFieldSerializer" />\n     <adapter factory=".dxfields.ImageFieldSerializer" />\n     <adapter factory=".dxfields.RichttextFieldSerializer" />\ndiff --git a/src/plone/restapi/serializer/dxfields.py b/src/plone/restapi/serializer/dxfields.py\nindex 41124705..996cb164 100644\n--- a/src/plone/restapi/serializer/dxfields.py\n+++ b/src/plone/restapi/serializer/dxfields.py\n@@ -1,5 +1,6 @@\n # -*- coding: utf-8 -*-\n from plone.app.textfield.interfaces import IRichText\n+from plone.app.vocabularies.catalog import CatalogVocabulary\n from plone.dexterity.interfaces import IDexterityContent\n from plone.namedfile.interfaces import INamedFileField\n from plone.namedfile.interfaces import INamedImageField\n@@ -10,7 +11,10 @@\n from zope.component import adapter\n from zope.interface import implementer\n from zope.interface import Interface\n+from zope.schema.interfaces import IChoice\n+from zope.schema.interfaces import ICollection\n from zope.schema.interfaces import IField\n+from zope.schema.interfaces import IVocabularyTokenized\n \n \n @adapter(IField, IDexterityContent, Interface)\n@@ -31,6 +35,47 @@ def get_value(self, default=None):\n                        default)\n \n \n+@adapter(IChoice, IDexterityContent, Interface)\n+@implementer(IFieldSerializer)\n+class ChoiceFieldSerializer(DefaultFieldSerializer):\n+\n+    def __call__(self):\n+        # Binding is necessary for named vocabularies\n+        if IField.providedBy(self.field):\n+            self.field = self.field.bind(self.context)\n+        value = self.get_value()\n+        if (value is not None\n+                and IVocabularyTokenized.providedBy(self.field.vocabulary)):\n+            try:\n+                term = self.field.vocabulary.getTerm(value)\n+                value = term.token\n+            # Some fields (e.g. language) have a default value that is not in\n+            # vocabulary\n+            except LookupError:\n+                pass\n+        return json_compatible(value)\n+\n+\n+@adapter(ICollection, IDexterityContent, Interface)\n+@implementer(IFieldSerializer)\n+class CollectionFieldSerializer(DefaultFieldSerializer):\n+\n+    def __call__(self):\n+        # Binding is necessary for named vocabularies\n+        if IField.providedBy(self.field):\n+            self.field = self.field.bind(self.context)\n+        value = self.get_value()\n+        value_type = self.field.value_type\n+        if (value is not None and IChoice.providedBy(value_type)\n+                and IVocabularyTokenized.providedBy(value_type.vocabulary)\n+                # CatalogVocabulary provides IVocabularyTokenized but doesn\'t\n+                # implement it\n+                and not isinstance(value_type.vocabulary, CatalogVocabulary)):\n+            value = self.field._type([value_type.vocabulary.getTerm(v).token\n+                                      for v in value])\n+        return json_compatible(value)\n+\n+\n @adapter(INamedImageField, IDexterityContent, Interface)\n class ImageFieldSerializer(DefaultFieldSerializer):\n \ndiff --git a/src/plone/restapi/tests/dxtypes.py b/src/plone/restapi/tests/dxtypes.py\nindex 2284f677..da5b3164 100644\n--- a/src/plone/restapi/tests/dxtypes.py\n+++ b/src/plone/restapi/tests/dxtypes.py\n@@ -46,6 +46,11 @@ class IDXTestDocumentSchema(model.Schema):\n     test_bytes_field = schema.Bytes(required=False)\n     test_bytesline_field = schema.BytesLine(required=False)\n     test_choice_field = schema.Choice(values=[u\'foo\', u\'bar\'], required=False)\n+    test_choice_field_with_vocabulary = schema.Choice(\n+        vocabulary=SimpleVocabulary([\n+            SimpleTerm(u\'value1\', \'token1\', u\'title1\'),\n+            SimpleTerm(u\'value2\', \'token2\', u\'title2\'),\n+        ]),  required=False)\n     test_date_field = schema.Date(required=False)\n     test_datetime_field = schema.Datetime(required=False)\n     test_datetime_tz_field = schema.Datetime(\n@@ -58,6 +63,12 @@ class IDXTestDocumentSchema(model.Schema):\n     test_frozenset_field = schema.FrozenSet(required=False)\n     test_int_field = schema.Int(required=False)\n     test_list_field = schema.List(required=False)\n+    test_list_field_with_choice_with_vocabulary = schema.List(\n+        value_type=schema.Choice(vocabulary=SimpleVocabulary([\n+            SimpleTerm(u\'value1\', \'token1\', u\'title1\'),\n+            SimpleTerm(u\'value2\', \'token2\', u\'title2\'),\n+            SimpleTerm(u\'value3\', \'token3\', u\'title3\'),\n+        ])), required=False)\n     test_set_field = schema.Set(required=False)\n     test_text_field = schema.Text(required=False)\n     test_textline_field = schema.TextLine(required=False)\ndiff --git a/src/plone/restapi/tests/test_dxfield_deserializer.py b/src/plone/restapi/tests/test_dxfield_deserializer.py\nindex 91e3fb3a..8c4c998b 100644\n--- a/src/plone/restapi/tests/test_dxfield_deserializer.py\n+++ b/src/plone/restapi/tests/test_dxfield_deserializer.py\n@@ -91,6 +91,18 @@ def test_choice_deserialization_returns_vocabulary_item(self):\n         self.assertTrue(isinstance(value, six.text_type), \'Not an <unicode>\')\n         self.assertEqual(u\'bar\', value)\n \n+    def test_choice_deserialization_from_token_returns_vocabulary_value(self):\n+        value = self.deserialize(\'test_choice_field_with_vocabulary\',\n+                                 u\'token1\')\n+        self.assertTrue(isinstance(value, six.text_type), \'Not an <unicode>\')\n+        self.assertEqual(u\'value1\', value)\n+\n+    def test_choice_deserialization_from_value_returns_vocabulary_value(self):\n+        value = self.deserialize(\'test_choice_field_with_vocabulary\',\n+                                 u\'value1\')\n+        self.assertTrue(isinstance(value, six.text_type), \'Not an <unicode>\')\n+        self.assertEqual(u\'value1\', value)\n+\n     def test_date_deserialization_returns_date(self):\n         value = self.deserialize(\'test_date_field\', u\'2015-12-20\')\n         self.assertTrue(isinstance(value, date))\n@@ -173,6 +185,18 @@ def test_list_deserialization_returns_list(self):\n         self.assertTrue(isinstance(value, list), \'Not a <list>\')\n         self.assertEqual([1, 2, 3], value)\n \n+    def test_list_deserialization_from_tokens_returns_list_of_values(self):\n+        value = self.deserialize(\'test_list_field_with_choice_with_vocabulary\',\n+                                 [u\'token1\', u\'token3\'])\n+        self.assertTrue(isinstance(value, list), \'Not a <list>\')\n+        self.assertEqual([u\'value1\', u\'value3\'], value)\n+\n+    def test_list_deserialization_from_values_returns_list_of_values(self):\n+        value = self.deserialize(\'test_list_field_with_choice_with_vocabulary\',\n+                                 [u\'value1\', u\'value3\'])\n+        self.assertTrue(isinstance(value, list), \'Not a <list>\')\n+        self.assertEqual([u\'value1\', u\'value3\'], value)\n+\n     def test_set_deserialization_returns_set(self):\n         value = self.deserialize(\'test_set_field\', [1, 2, 3])\n         self.assertTrue(isinstance(value, set), \'Not a <set>\')\ndiff --git a/src/plone/restapi/tests/test_dxfield_serializer.py b/src/plone/restapi/tests/test_dxfield_serializer.py\nindex 99fc6f32..2e6c57c5 100644\n--- a/src/plone/restapi/tests/test_dxfield_serializer.py\n+++ b/src/plone/restapi/tests/test_dxfield_serializer.py\n@@ -95,6 +95,11 @@ def test_choice_field_serialization_returns_vocabulary_item(self):\n         self.assertTrue(isinstance(value, six.text_type), \'Not an <unicode>\')\n         self.assertEqual(u\'foo\', value)\n \n+    def test_choice_field_serialization_returns_vocabulary_token(self):\n+        value = self.serialize(\'test_choice_field_with_vocabulary\', u\'value1\')\n+        self.assertTrue(isinstance(value, six.text_type), \'Not an <unicode>\')\n+        self.assertEqual(u\'token1\', value)\n+\n     def test_date_field_serialization_returns_unicode(self):\n         value = self.serialize(\'test_date_field\', date(2015, 7, 15))\n         self.assertTrue(isinstance(value, six.text_type), \'Not an <unicode>\')\n@@ -137,6 +142,13 @@ def test_list_field_serialization_returns_list(self):\n         self.assertTrue(isinstance(value, list), \'Not a <list>\')\n         self.assertEqual([1, u\'two\', 3], value)\n \n+    def test_list_field_with_vocabulary_choice_serialization_returns_tokens(\n+            self):\n+        value = self.serialize(\'test_list_field_with_choice_with_vocabulary\',\n+                               [u\'value1\', u\'value3\'])\n+        self.assertTrue(isinstance(value, list), \'Not a <list>\')\n+        self.assertEqual([u\'token1\', u\'token3\'], value)\n+\n     def test_set_field_serialization_returns_list(self):\n         value = self.serialize(\'test_set_field\', set([\'a\', \'b\', \'c\']))\n         self.assertTrue(isinstance(value, list), \'Not a <list>\')\n'

Repository: plone.restapi


Branch: refs/heads/master
Date: 2019-04-25T18:14:06+02:00
Author: Thomas Buchberger (buchi) <t.buchberger@4teamwork.ch>
Commit: https://github.com/plone/plone.restapi/commit/482ab122d4d0b9ff19247aaed995b49332430ca1

Use default serializer for relations

Files changed:
M src/plone/restapi/serializer/configure.zcml
M src/plone/restapi/serializer/dxfields.py
M src/plone/restapi/serializer/relationfield.py

b'diff --git a/src/plone/restapi/serializer/configure.zcml b/src/plone/restapi/serializer/configure.zcml\nindex c7500e5d..350ef417 100644\n--- a/src/plone/restapi/serializer/configure.zcml\n+++ b/src/plone/restapi/serializer/configure.zcml\n@@ -54,6 +54,8 @@\n     <adapter factory=".converters.zope_DateTime_converter" />\n \n     <configure zcml:condition="installed z3c.relationfield">\n+        <adapter factory=".relationfield.RelationChoiceFieldSerializer" />\n+        <adapter factory=".relationfield.RelationListFieldSerializer" />\n         <adapter factory=".relationfield.relationvalue_converter" />\n     </configure>\n \ndiff --git a/src/plone/restapi/serializer/dxfields.py b/src/plone/restapi/serializer/dxfields.py\nindex 996cb164..33954ab1 100644\n--- a/src/plone/restapi/serializer/dxfields.py\n+++ b/src/plone/restapi/serializer/dxfields.py\n@@ -1,6 +1,5 @@\n # -*- coding: utf-8 -*-\n from plone.app.textfield.interfaces import IRichText\n-from plone.app.vocabularies.catalog import CatalogVocabulary\n from plone.dexterity.interfaces import IDexterityContent\n from plone.namedfile.interfaces import INamedFileField\n from plone.namedfile.interfaces import INamedImageField\n@@ -67,10 +66,7 @@ def __call__(self):\n         value = self.get_value()\n         value_type = self.field.value_type\n         if (value is not None and IChoice.providedBy(value_type)\n-                and IVocabularyTokenized.providedBy(value_type.vocabulary)\n-                # CatalogVocabulary provides IVocabularyTokenized but doesn\'t\n-                # implement it\n-                and not isinstance(value_type.vocabulary, CatalogVocabulary)):\n+                and IVocabularyTokenized.providedBy(value_type.vocabulary)):\n             value = self.field._type([value_type.vocabulary.getTerm(v).token\n                                       for v in value])\n         return json_compatible(value)\ndiff --git a/src/plone/restapi/serializer/relationfield.py b/src/plone/restapi/serializer/relationfield.py\nindex faa51a04..f229b60f 100644\n--- a/src/plone/restapi/serializer/relationfield.py\n+++ b/src/plone/restapi/serializer/relationfield.py\n@@ -1,12 +1,18 @@\n # -*- coding: utf-8 -*-\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.restapi.interfaces import IFieldSerializer\n from plone.restapi.interfaces import IJsonCompatible\n from plone.restapi.interfaces import ISerializeToJsonSummary\n from plone.restapi.serializer.converters import json_compatible\n+from plone.restapi.serializer.dxfields import DefaultFieldSerializer\n+from z3c.relationfield.interfaces import IRelationChoice\n+from z3c.relationfield.interfaces import IRelationList\n from z3c.relationfield.interfaces import IRelationValue\n from zope.component import adapter\n from zope.component import getMultiAdapter\n from zope.globalrequest import getRequest\n from zope.interface import implementer\n+from zope.interface import Interface\n \n \n @adapter(IRelationValue)\n@@ -16,3 +22,15 @@ def relationvalue_converter(value):\n         summary = getMultiAdapter(\n             (value.to_object, getRequest()), ISerializeToJsonSummary)()\n         return json_compatible(summary)\n+\n+\n+@adapter(IRelationChoice, IDexterityContent, Interface)\n+@implementer(IFieldSerializer)\n+class RelationChoiceFieldSerializer(DefaultFieldSerializer):\n+    pass\n+\n+\n+@adapter(IRelationList, IDexterityContent, Interface)\n+@implementer(IFieldSerializer)\n+class RelationListFieldSerializer(DefaultFieldSerializer):\n+    pass\n'

Repository: plone.restapi


Branch: refs/heads/master
Date: 2019-04-25T18:14:06+02:00
Author: Thomas Buchberger (buchi) <t.buchberger@4teamwork.ch>
Commit: https://github.com/plone/plone.restapi/commit/a16a18f957d6fe4655800473c91cf3a929019275

Use DX field serializers in controlpanel serializer

Ensures that the serialization of vocabulary terms returns the token.

Files changed:
M src/plone/restapi/serializer/controlpanels.py

b"diff --git a/src/plone/restapi/serializer/controlpanels.py b/src/plone/restapi/serializer/controlpanels.py\nindex f90e8534..22ba4ea8 100644\n--- a/src/plone/restapi/serializer/controlpanels.py\n+++ b/src/plone/restapi/serializer/controlpanels.py\n@@ -1,13 +1,16 @@\n # -*- coding: utf-8 -*-\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.registry.interfaces import IRegistry\n from plone.restapi.controlpanels import IControlpanel\n+from plone.restapi.interfaces import IFieldSerializer\n from plone.restapi.interfaces import ISerializeToJson\n from plone.restapi.interfaces import ISerializeToJsonSummary\n-from plone.restapi.interfaces import IFieldSerializer\n from plone.restapi.serializer.converters import json_compatible\n from plone.restapi.types import utils\n-from plone.registry.interfaces import IRegistry\n-from zope.interface import implementer\n from zope.component import adapter, queryMultiAdapter, getUtility\n+from zope.interface import alsoProvides\n+from zope.interface import implementer\n+from zope.interface import noLongerProvides\n \n import zope.schema\n \n@@ -86,6 +89,10 @@ def __call__(self):\n             self.schema, prefix=self.schema_prefix\n         )\n \n+        # Temporarily provide IDexterityContent, so we can use DX field\n+        # serializers\n+        alsoProvides(proxy, IDexterityContent)\n+\n         json_data = {}\n         for name, field in zope.schema.getFields(self.schema).items():\n             serializer = queryMultiAdapter(\n@@ -98,6 +105,8 @@ def __call__(self):\n                 value = getattr(proxy, name, None)\n             json_data[json_compatible(name)] = value\n \n+        noLongerProvides(proxy, IDexterityContent)\n+\n         # JSON schema\n         return {\n             '@id': '{}/{}/{}'.format(\n"

Repository: plone.restapi


Branch: refs/heads/master
Date: 2019-04-25T18:51:02+02:00
Author: Thomas Buchberger (buchi) <t.buchberger@4teamwork.ch>
Commit: https://github.com/plone/plone.restapi/commit/25fb7600e4e7ed29c388171e984e2da00fc3eca1

Add upgrade guide for serialization/deserialization of vocabulary terms

Files changed:
M docs/source/upgrade-guide.rst

b'diff --git a/docs/source/upgrade-guide.rst b/docs/source/upgrade-guide.rst\nindex 70724dc6..4d3973b1 100644\n--- a/docs/source/upgrade-guide.rst\n+++ b/docs/source/upgrade-guide.rst\n@@ -7,6 +7,47 @@ This upgrade guide lists all breaking changes in plone.restapi and explains the\n Upgrading to plone.restapi 4.x\n ------------------------------\n \n+Serialization and Deserialization of fields with vocabularies\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+The serialization of fields with vocabularies (e.g. ``Choice``) now returns the\n+token of the vocabulary term instead of the stored value. For text values this\n+should not make much a difference as the token and the value are usually the\n+same. However if the term\'s value is not equal to it\'s token it may be neccessary\n+to adopt the client implementation.\n+\n+Example:\n+\n+The date and time controlpanel previously returned a number for the\n+``first_weekday`` property::\n+\n+  {\n+    "@id": "http://localhost:55001/plone/@controlpanels/date-and-time",\n+    "data": {\n+        ...\n+        "first_weekday": 0,\n+        ...\n+    }\n+    ...\n+  }\n+\n+Now it returns a string::\n+\n+  {\n+    "@id": "http://localhost:55001/plone/@controlpanels/date-and-time",\n+    "data": {\n+        ...\n+        "first_weekday": "0",\n+        ...\n+    }\n+    ...\n+  }\n+\n+Deserialization now also expects the token, but still works using the value.\n+However it\'s highly recommended to always use the token as vocabulary terms\n+may contain values that are not JSON serializable.\n+\n+\n Vocabularies\n ^^^^^^^^^^^^\n \n'

Repository: plone.restapi


Branch: refs/heads/master
Date: 2019-04-26T10:39:42+02:00
Author: Timo Stollenwerk (tisto) <tisto@users.noreply.github.com>
Commit: https://github.com/plone/plone.restapi/commit/b04c0181f607e4e2b5019a0fc080e70d13c34abd

Merge pull request #692 from plone/serialization-and-deserialization-with-tokens

Use tokens for serialization and deserialization of vocabulary terms

Files changed:
A news/691.breaking
M docs/source/upgrade-guide.rst
M src/plone/restapi/deserializer/configure.zcml
M src/plone/restapi/deserializer/dxfields.py
M src/plone/restapi/serializer/configure.zcml
M src/plone/restapi/serializer/controlpanels.py
M src/plone/restapi/serializer/dxfields.py
M src/plone/restapi/serializer/relationfield.py
M src/plone/restapi/tests/dxtypes.py
M src/plone/restapi/tests/test_dxfield_deserializer.py
M src/plone/restapi/tests/test_dxfield_serializer.py

b'diff --git a/docs/source/upgrade-guide.rst b/docs/source/upgrade-guide.rst\nindex 70724dc6..4d3973b1 100644\n--- a/docs/source/upgrade-guide.rst\n+++ b/docs/source/upgrade-guide.rst\n@@ -7,6 +7,47 @@ This upgrade guide lists all breaking changes in plone.restapi and explains the\n Upgrading to plone.restapi 4.x\n ------------------------------\n \n+Serialization and Deserialization of fields with vocabularies\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+The serialization of fields with vocabularies (e.g. ``Choice``) now returns the\n+token of the vocabulary term instead of the stored value. For text values this\n+should not make much a difference as the token and the value are usually the\n+same. However if the term\'s value is not equal to it\'s token it may be neccessary\n+to adopt the client implementation.\n+\n+Example:\n+\n+The date and time controlpanel previously returned a number for the\n+``first_weekday`` property::\n+\n+  {\n+    "@id": "http://localhost:55001/plone/@controlpanels/date-and-time",\n+    "data": {\n+        ...\n+        "first_weekday": 0,\n+        ...\n+    }\n+    ...\n+  }\n+\n+Now it returns a string::\n+\n+  {\n+    "@id": "http://localhost:55001/plone/@controlpanels/date-and-time",\n+    "data": {\n+        ...\n+        "first_weekday": "0",\n+        ...\n+    }\n+    ...\n+  }\n+\n+Deserialization now also expects the token, but still works using the value.\n+However it\'s highly recommended to always use the token as vocabulary terms\n+may contain values that are not JSON serializable.\n+\n+\n Vocabularies\n ^^^^^^^^^^^^\n \ndiff --git a/news/691.breaking b/news/691.breaking\nnew file mode 100644\nindex 00000000..51b72235\n--- /dev/null\n+++ b/news/691.breaking\n@@ -0,0 +1,4 @@\n+Use tokens for serialization/deserialization of vocabulary terms.\n+This may break clients if the serialization of a term\'s value is not equal to the token.\n+[buchi]\n+\ndiff --git a/src/plone/restapi/deserializer/configure.zcml b/src/plone/restapi/deserializer/configure.zcml\nindex 635e2c5b..9c89af2e 100644\n--- a/src/plone/restapi/deserializer/configure.zcml\n+++ b/src/plone/restapi/deserializer/configure.zcml\n@@ -8,6 +8,7 @@\n   <adapter factory=".dxcontent.DeserializeFromJson" />\n   <adapter factory=".dxfields.DefaultFieldDeserializer" />\n   <adapter factory=".dxfields.DatetimeFieldDeserializer" />\n+  <adapter factory=".dxfields.ChoiceFieldDeserializer" />\n   <adapter factory=".dxfields.CollectionFieldDeserializer" />\n   <adapter factory=".dxfields.DictFieldDeserializer" />\n   <adapter factory=".dxfields.TextLineFieldDeserializer" />\ndiff --git a/src/plone/restapi/deserializer/dxfields.py b/src/plone/restapi/deserializer/dxfields.py\nindex fd1cd046..81897723 100644\n--- a/src/plone/restapi/deserializer/dxfields.py\n+++ b/src/plone/restapi/deserializer/dxfields.py\n@@ -14,6 +14,7 @@\n from zope.component import queryMultiAdapter\n from zope.interface import implementer\n from zope.publisher.interfaces.browser import IBrowserRequest\n+from zope.schema.interfaces import IChoice\n from zope.schema.interfaces import ICollection\n from zope.schema.interfaces import IDatetime\n from zope.schema.interfaces import IDict\n@@ -22,6 +23,7 @@\n from zope.schema.interfaces import ITextLine\n from zope.schema.interfaces import ITime\n from zope.schema.interfaces import ITimedelta\n+from zope.schema.interfaces import IVocabularyTokenized\n \n import codecs\n import dateutil\n@@ -115,6 +117,21 @@ def __call__(self, value):\n         return value\n \n \n+@implementer(IFieldDeserializer)\n+@adapter(IChoice, IDexterityContent, IBrowserRequest)\n+class ChoiceFieldDeserializer(DefaultFieldDeserializer):\n+\n+    def __call__(self, value):\n+        if IVocabularyTokenized.providedBy(self.field.vocabulary):\n+            try:\n+                value = self.field.vocabulary.getTermByToken(value).value\n+            except LookupError:\n+                pass\n+\n+        self.field.validate(value)\n+        return value\n+\n+\n @implementer(IFieldDeserializer)\n @adapter(ICollection, IDexterityContent, IBrowserRequest)\n class CollectionFieldDeserializer(DefaultFieldDeserializer):\ndiff --git a/src/plone/restapi/serializer/configure.zcml b/src/plone/restapi/serializer/configure.zcml\nindex 041400fc..350ef417 100644\n--- a/src/plone/restapi/serializer/configure.zcml\n+++ b/src/plone/restapi/serializer/configure.zcml\n@@ -15,6 +15,8 @@\n     <adapter factory=".summary.SiteRootJSONSummarySerializer" />\n \n     <adapter factory=".dxfields.DefaultFieldSerializer" />\n+    <adapter factory=".dxfields.ChoiceFieldSerializer" />\n+    <adapter factory=".dxfields.CollectionFieldSerializer" />\n     <adapter factory=".dxfields.FileFieldSerializer" />\n     <adapter factory=".dxfields.ImageFieldSerializer" />\n     <adapter factory=".dxfields.RichttextFieldSerializer" />\n@@ -52,6 +54,8 @@\n     <adapter factory=".converters.zope_DateTime_converter" />\n \n     <configure zcml:condition="installed z3c.relationfield">\n+        <adapter factory=".relationfield.RelationChoiceFieldSerializer" />\n+        <adapter factory=".relationfield.RelationListFieldSerializer" />\n         <adapter factory=".relationfield.relationvalue_converter" />\n     </configure>\n \ndiff --git a/src/plone/restapi/serializer/controlpanels.py b/src/plone/restapi/serializer/controlpanels.py\nindex f90e8534..22ba4ea8 100644\n--- a/src/plone/restapi/serializer/controlpanels.py\n+++ b/src/plone/restapi/serializer/controlpanels.py\n@@ -1,13 +1,16 @@\n # -*- coding: utf-8 -*-\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.registry.interfaces import IRegistry\n from plone.restapi.controlpanels import IControlpanel\n+from plone.restapi.interfaces import IFieldSerializer\n from plone.restapi.interfaces import ISerializeToJson\n from plone.restapi.interfaces import ISerializeToJsonSummary\n-from plone.restapi.interfaces import IFieldSerializer\n from plone.restapi.serializer.converters import json_compatible\n from plone.restapi.types import utils\n-from plone.registry.interfaces import IRegistry\n-from zope.interface import implementer\n from zope.component import adapter, queryMultiAdapter, getUtility\n+from zope.interface import alsoProvides\n+from zope.interface import implementer\n+from zope.interface import noLongerProvides\n \n import zope.schema\n \n@@ -86,6 +89,10 @@ def __call__(self):\n             self.schema, prefix=self.schema_prefix\n         )\n \n+        # Temporarily provide IDexterityContent, so we can use DX field\n+        # serializers\n+        alsoProvides(proxy, IDexterityContent)\n+\n         json_data = {}\n         for name, field in zope.schema.getFields(self.schema).items():\n             serializer = queryMultiAdapter(\n@@ -98,6 +105,8 @@ def __call__(self):\n                 value = getattr(proxy, name, None)\n             json_data[json_compatible(name)] = value\n \n+        noLongerProvides(proxy, IDexterityContent)\n+\n         # JSON schema\n         return {\n             \'@id\': \'{}/{}/{}\'.format(\ndiff --git a/src/plone/restapi/serializer/dxfields.py b/src/plone/restapi/serializer/dxfields.py\nindex 41124705..33954ab1 100644\n--- a/src/plone/restapi/serializer/dxfields.py\n+++ b/src/plone/restapi/serializer/dxfields.py\n@@ -10,7 +10,10 @@\n from zope.component import adapter\n from zope.interface import implementer\n from zope.interface import Interface\n+from zope.schema.interfaces import IChoice\n+from zope.schema.interfaces import ICollection\n from zope.schema.interfaces import IField\n+from zope.schema.interfaces import IVocabularyTokenized\n \n \n @adapter(IField, IDexterityContent, Interface)\n@@ -31,6 +34,44 @@ def get_value(self, default=None):\n                        default)\n \n \n+@adapter(IChoice, IDexterityContent, Interface)\n+@implementer(IFieldSerializer)\n+class ChoiceFieldSerializer(DefaultFieldSerializer):\n+\n+    def __call__(self):\n+        # Binding is necessary for named vocabularies\n+        if IField.providedBy(self.field):\n+            self.field = self.field.bind(self.context)\n+        value = self.get_value()\n+        if (value is not None\n+                and IVocabularyTokenized.providedBy(self.field.vocabulary)):\n+            try:\n+                term = self.field.vocabulary.getTerm(value)\n+                value = term.token\n+            # Some fields (e.g. language) have a default value that is not in\n+            # vocabulary\n+            except LookupError:\n+                pass\n+        return json_compatible(value)\n+\n+\n+@adapter(ICollection, IDexterityContent, Interface)\n+@implementer(IFieldSerializer)\n+class CollectionFieldSerializer(DefaultFieldSerializer):\n+\n+    def __call__(self):\n+        # Binding is necessary for named vocabularies\n+        if IField.providedBy(self.field):\n+            self.field = self.field.bind(self.context)\n+        value = self.get_value()\n+        value_type = self.field.value_type\n+        if (value is not None and IChoice.providedBy(value_type)\n+                and IVocabularyTokenized.providedBy(value_type.vocabulary)):\n+            value = self.field._type([value_type.vocabulary.getTerm(v).token\n+                                      for v in value])\n+        return json_compatible(value)\n+\n+\n @adapter(INamedImageField, IDexterityContent, Interface)\n class ImageFieldSerializer(DefaultFieldSerializer):\n \ndiff --git a/src/plone/restapi/serializer/relationfield.py b/src/plone/restapi/serializer/relationfield.py\nindex faa51a04..f229b60f 100644\n--- a/src/plone/restapi/serializer/relationfield.py\n+++ b/src/plone/restapi/serializer/relationfield.py\n@@ -1,12 +1,18 @@\n # -*- coding: utf-8 -*-\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.restapi.interfaces import IFieldSerializer\n from plone.restapi.interfaces import IJsonCompatible\n from plone.restapi.interfaces import ISerializeToJsonSummary\n from plone.restapi.serializer.converters import json_compatible\n+from plone.restapi.serializer.dxfields import DefaultFieldSerializer\n+from z3c.relationfield.interfaces import IRelationChoice\n+from z3c.relationfield.interfaces import IRelationList\n from z3c.relationfield.interfaces import IRelationValue\n from zope.component import adapter\n from zope.component import getMultiAdapter\n from zope.globalrequest import getRequest\n from zope.interface import implementer\n+from zope.interface import Interface\n \n \n @adapter(IRelationValue)\n@@ -16,3 +22,15 @@ def relationvalue_converter(value):\n         summary = getMultiAdapter(\n             (value.to_object, getRequest()), ISerializeToJsonSummary)()\n         return json_compatible(summary)\n+\n+\n+@adapter(IRelationChoice, IDexterityContent, Interface)\n+@implementer(IFieldSerializer)\n+class RelationChoiceFieldSerializer(DefaultFieldSerializer):\n+    pass\n+\n+\n+@adapter(IRelationList, IDexterityContent, Interface)\n+@implementer(IFieldSerializer)\n+class RelationListFieldSerializer(DefaultFieldSerializer):\n+    pass\ndiff --git a/src/plone/restapi/tests/dxtypes.py b/src/plone/restapi/tests/dxtypes.py\nindex 2284f677..da5b3164 100644\n--- a/src/plone/restapi/tests/dxtypes.py\n+++ b/src/plone/restapi/tests/dxtypes.py\n@@ -46,6 +46,11 @@ class IDXTestDocumentSchema(model.Schema):\n     test_bytes_field = schema.Bytes(required=False)\n     test_bytesline_field = schema.BytesLine(required=False)\n     test_choice_field = schema.Choice(values=[u\'foo\', u\'bar\'], required=False)\n+    test_choice_field_with_vocabulary = schema.Choice(\n+        vocabulary=SimpleVocabulary([\n+            SimpleTerm(u\'value1\', \'token1\', u\'title1\'),\n+            SimpleTerm(u\'value2\', \'token2\', u\'title2\'),\n+        ]),  required=False)\n     test_date_field = schema.Date(required=False)\n     test_datetime_field = schema.Datetime(required=False)\n     test_datetime_tz_field = schema.Datetime(\n@@ -58,6 +63,12 @@ class IDXTestDocumentSchema(model.Schema):\n     test_frozenset_field = schema.FrozenSet(required=False)\n     test_int_field = schema.Int(required=False)\n     test_list_field = schema.List(required=False)\n+    test_list_field_with_choice_with_vocabulary = schema.List(\n+        value_type=schema.Choice(vocabulary=SimpleVocabulary([\n+            SimpleTerm(u\'value1\', \'token1\', u\'title1\'),\n+            SimpleTerm(u\'value2\', \'token2\', u\'title2\'),\n+            SimpleTerm(u\'value3\', \'token3\', u\'title3\'),\n+        ])), required=False)\n     test_set_field = schema.Set(required=False)\n     test_text_field = schema.Text(required=False)\n     test_textline_field = schema.TextLine(required=False)\ndiff --git a/src/plone/restapi/tests/test_dxfield_deserializer.py b/src/plone/restapi/tests/test_dxfield_deserializer.py\nindex 91e3fb3a..8c4c998b 100644\n--- a/src/plone/restapi/tests/test_dxfield_deserializer.py\n+++ b/src/plone/restapi/tests/test_dxfield_deserializer.py\n@@ -91,6 +91,18 @@ def test_choice_deserialization_returns_vocabulary_item(self):\n         self.assertTrue(isinstance(value, six.text_type), \'Not an <unicode>\')\n         self.assertEqual(u\'bar\', value)\n \n+    def test_choice_deserialization_from_token_returns_vocabulary_value(self):\n+        value = self.deserialize(\'test_choice_field_with_vocabulary\',\n+                                 u\'token1\')\n+        self.assertTrue(isinstance(value, six.text_type), \'Not an <unicode>\')\n+        self.assertEqual(u\'value1\', value)\n+\n+    def test_choice_deserialization_from_value_returns_vocabulary_value(self):\n+        value = self.deserialize(\'test_choice_field_with_vocabulary\',\n+                                 u\'value1\')\n+        self.assertTrue(isinstance(value, six.text_type), \'Not an <unicode>\')\n+        self.assertEqual(u\'value1\', value)\n+\n     def test_date_deserialization_returns_date(self):\n         value = self.deserialize(\'test_date_field\', u\'2015-12-20\')\n         self.assertTrue(isinstance(value, date))\n@@ -173,6 +185,18 @@ def test_list_deserialization_returns_list(self):\n         self.assertTrue(isinstance(value, list), \'Not a <list>\')\n         self.assertEqual([1, 2, 3], value)\n \n+    def test_list_deserialization_from_tokens_returns_list_of_values(self):\n+        value = self.deserialize(\'test_list_field_with_choice_with_vocabulary\',\n+                                 [u\'token1\', u\'token3\'])\n+        self.assertTrue(isinstance(value, list), \'Not a <list>\')\n+        self.assertEqual([u\'value1\', u\'value3\'], value)\n+\n+    def test_list_deserialization_from_values_returns_list_of_values(self):\n+        value = self.deserialize(\'test_list_field_with_choice_with_vocabulary\',\n+                                 [u\'value1\', u\'value3\'])\n+        self.assertTrue(isinstance(value, list), \'Not a <list>\')\n+        self.assertEqual([u\'value1\', u\'value3\'], value)\n+\n     def test_set_deserialization_returns_set(self):\n         value = self.deserialize(\'test_set_field\', [1, 2, 3])\n         self.assertTrue(isinstance(value, set), \'Not a <set>\')\ndiff --git a/src/plone/restapi/tests/test_dxfield_serializer.py b/src/plone/restapi/tests/test_dxfield_serializer.py\nindex 99fc6f32..2e6c57c5 100644\n--- a/src/plone/restapi/tests/test_dxfield_serializer.py\n+++ b/src/plone/restapi/tests/test_dxfield_serializer.py\n@@ -95,6 +95,11 @@ def test_choice_field_serialization_returns_vocabulary_item(self):\n         self.assertTrue(isinstance(value, six.text_type), \'Not an <unicode>\')\n         self.assertEqual(u\'foo\', value)\n \n+    def test_choice_field_serialization_returns_vocabulary_token(self):\n+        value = self.serialize(\'test_choice_field_with_vocabulary\', u\'value1\')\n+        self.assertTrue(isinstance(value, six.text_type), \'Not an <unicode>\')\n+        self.assertEqual(u\'token1\', value)\n+\n     def test_date_field_serialization_returns_unicode(self):\n         value = self.serialize(\'test_date_field\', date(2015, 7, 15))\n         self.assertTrue(isinstance(value, six.text_type), \'Not an <unicode>\')\n@@ -137,6 +142,13 @@ def test_list_field_serialization_returns_list(self):\n         self.assertTrue(isinstance(value, list), \'Not a <list>\')\n         self.assertEqual([1, u\'two\', 3], value)\n \n+    def test_list_field_with_vocabulary_choice_serialization_returns_tokens(\n+            self):\n+        value = self.serialize(\'test_list_field_with_choice_with_vocabulary\',\n+                               [u\'value1\', u\'value3\'])\n+        self.assertTrue(isinstance(value, list), \'Not a <list>\')\n+        self.assertEqual([u\'token1\', u\'token3\'], value)\n+\n     def test_set_field_serialization_returns_list(self):\n         value = self.serialize(\'test_set_field\', set([\'a\', \'b\', \'c\']))\n         self.assertTrue(isinstance(value, list), \'Not a <list>\')\n'

