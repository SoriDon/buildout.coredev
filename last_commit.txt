Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2022-06-29T02:58:47+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/0de3c3c81e763c890d98d379bbbeb4a7e3602a1c

Removed earlypatches/expressions.py.

This was a patch to avoid some too strict checks by Zope / Products.PageTemplates.
But in Plone 6 it should be fine to be stricter.

Files changed:
A news/3567.breaking
M Products/CMFPlone/earlypatches/__init__.py
M Products/CMFPlone/tests/test_expressions.py
D Products/CMFPlone/earlypatches/expressions.py
D Products/CMFPlone/tests/accesscontrol_sm2.pt

b'diff --git a/Products/CMFPlone/earlypatches/__init__.py b/Products/CMFPlone/earlypatches/__init__.py\nindex 8010715709..c25923d78d 100644\n--- a/Products/CMFPlone/earlypatches/__init__.py\n+++ b/Products/CMFPlone/earlypatches/__init__.py\n@@ -1,3 +1,2 @@\n # misc security fixes\n from Products.CMFPlone.earlypatches import security  # noqa\n-from Products.CMFPlone.earlypatches import expressions  # noqa\ndiff --git a/Products/CMFPlone/earlypatches/expressions.py b/Products/CMFPlone/earlypatches/expressions.py\ndeleted file mode 100644\nindex 59eb58d1ad..0000000000\n--- a/Products/CMFPlone/earlypatches/expressions.py\n+++ /dev/null\n@@ -1,214 +0,0 @@\n-from AccessControl.SecurityManagement import getSecurityManager\n-from AccessControl.ZopeGuards import guarded_getattr\n-from AccessControl.ZopeGuards import guarded_import\n-from OFS.interfaces import ITraversable\n-from Products.PageTemplates import Expressions\n-from zExceptions import NotFound\n-from zExceptions import Unauthorized\n-from zope.traversing.adapters import traversePathElement\n-\n-import os\n-import string\n-import sys\n-import types\n-import warnings\n-\n-\n-# In the \'bobo aware\' Zope traverse methods and functions, various security checks are done.\n-# For example for content items, permission checks are done.\n-# But for non-content, for example a Python module or a dictionary, the checks were originally very lax.\n-# This could be abused.  Now we know that, we want to be as strict as possible.\n-#\n-# But being stricter breaks existing code which worked fine so far,\n-# not knowing that it tried to access code which should have been disallowed.\n-# One thing that goes wrong, is that any skin template that calls context/main_template/macros/master fails,\n-# for example when viewing a revision from CMFEditions.\n-#\n-# So with this hotfix, by necessity we are still lax/forgiving, but you can change this behavior\n-# with an environment variable: STRICT_TRAVERSE_CHECK.\n-# - STRICT_TRAVERSE_CHECK=0 mostly uses the original lax/sloppy checks.\n-#   This sadly needs to be the default.\n-# - STRICT_TRAVERSE_CHECK=1 uses the strict logic.\n-#   When you know what you are doing, you can try this.\n-# - STRICT_TRAVERSE_CHECK=2 first tries the strict logic.\n-#   If this fails, log a warning and then fallback to the original lax checks.\n-#   The idea would be to use this in development or production for a while, to see which code needs a fix.\n-try:\n-    STRICT_TRAVERSE_CHECK = int(os.getenv("STRICT_TRAVERSE_CHECK", 0))\n-except (ValueError, TypeError, AttributeError):\n-    STRICT_TRAVERSE_CHECK = 0\n-# Set of names that start with an underscore but that we want to allow anyway.\n-ALLOWED_UNDERSCORE_NAMES = set([\n-    # dunder name is used in plone.app.caching, and maybe other places\n-    "__name__",\n-    # Zope allows a single underscore to avoid a test failure\n-    "_",\n-    # Special case for plone.protect.\n-    # Fixes a NotFound error when submitting a PloneFormGen form:\n-    # https://github.com/smcmahon/Products.PloneFormGen/pull/229\n-    "_authenticator",\n-])\n-# Some objects we really do not trust, even when you have found a workaround to reach them.\n-DISALLOWED_OBJECTS = [\n-    os,\n-    sys,\n-    # string.Formatter sounds innocent, but can be abused.\n-    string.Formatter,\n-]\n-_orig_boboAwareZopeTraverse = Expressions.boboAwareZopeTraverse\n-\n-\n-def guarded_import_module(base, path_items):\n-    name = path_items[0]\n-    try:\n-        guarded_import(base.__name__, fromlist=path_items)\n-        # guarded_import will do most security checking\n-        # but will not return the imported item itself,\n-        # so we need to call getattr ourselves.\n-        # Actually, not all security checks are done, so we call guarded_getattr.\n-        for name in path_items:\n-            base = guarded_getattr(base, name)\n-    except Unauthorized:\n-        # special case for OFS/zpt/main.zpt which uses\n-        # modules/AccessControl/SecurityManagement/getSecurityManager\n-        # which should have been modules/AccessControl/getSecurityManager\n-        # Fixed in Zope 4.6.1 and 5.2.1.\n-        if name == "SecurityManagement" and path_items[-1] == "getSecurityManager":\n-            return getSecurityManager\n-        # Convert Unauthorized to prevent information disclosures\n-        raise NotFound(name)\n-    except TypeError:\n-        # During testing with security-policy-implementation python\n-        # and verbose-security on, I got this error when an Unauthorized was raised\n-        # for string.Formatter.get_field:\n-        # TypeError: descriptor \'__repr__\' of \'object\' object needs an argument\n-        # This was in the item_repr function of AccessControl.ImplPython.\n-        raise NotFound(name)\n-    if base in DISALLOWED_OBJECTS:\n-        raise NotFound(name)\n-    return base\n-\n-\n-def shared_traverse(base, path_items, request, traverse_method="restrictedTraverse"):\n-    """Shared traverse method for bobo aware zope traverse function and class method.\n-\n-    They are almost exactly the same, and it is irritating and error prone\n-    to change similar code in two places.\n-    """\n-    validate = getSecurityManager().validate\n-    path_items = list(path_items)\n-    path_items.reverse()\n-\n-    while path_items:\n-        name = path_items.pop()\n-\n-        if ITraversable.providedBy(base):\n-            base = getattr(base, traverse_method)(name)\n-        elif isinstance(base, types.ModuleType):\n-            # We should be able to handle the name and all remaining path items at once.\n-            # Use the correct order again.\n-            path_items.append(name)\n-            path_items.reverse()\n-            return guarded_import_module(base, path_items)\n-        else:\n-            found = traversePathElement(base, name, path_items,\n-                                        request=request)\n-\n-            # If traverse_method is something other than\n-            # ``restrictedTraverse`` then traversal is assumed to be\n-            # unrestricted. This emulates ``unrestrictedTraverse``\n-            if traverse_method != \'restrictedTraverse\':\n-                base = found\n-                continue\n-\n-            # Special backwards compatibility exception for the name ``_``,\n-            # which was often used for translation message factories.\n-            # Allow and continue traversal.\n-            if name == \'_\':\n-                warnings.warn(\'Traversing to the name `_` is deprecated \'\n-                              \'and will be removed in Zope 6.\',\n-                              DeprecationWarning)\n-                base = found\n-                continue\n-\n-            if name.startswith(\'_\'):\n-                if name in ALLOWED_UNDERSCORE_NAMES:\n-                    base = found\n-                    continue\n-                # All other names starting with ``_`` are disallowed.\n-                # This emulates what restrictedTraverse does.\n-                raise NotFound(name)\n-\n-            if found in DISALLOWED_OBJECTS:\n-                raise NotFound(name)\n-\n-            if STRICT_TRAVERSE_CHECK:\n-                # traversePathElement doesn\'t apply any Zope security policy,\n-                # so we validate access explicitly here.\n-                try:\n-                    validate(base, base, name, found)\n-                except Unauthorized:\n-                    if STRICT_TRAVERSE_CHECK == 2:\n-                        # only warn\n-                        warnings.warn(\n-                            \'Traversing from {0} to {1} is only allowed because STRICT_TRAVERSE_CHECK=2. \'\n-                            \'Possible security problem.\'.format(object, name))\n-                    else:\n-                        # Convert Unauthorized to prevent information disclosures\n-                        raise NotFound(name)\n-\n-            base = found\n-\n-    return base\n-\n-\n-def boboAwareZopeTraverse(object, path_items, econtext):\n-    """Traverses a sequence of names, first trying attributes then items.\n-\n-    This uses zope.traversing path traversal where possible and interacts\n-    correctly with objects providing OFS.interface.ITraversable when\n-    necessary (bobo-awareness).\n-    """\n-    request = getattr(econtext, \'request\', None)\n-    result = shared_traverse(object, path_items, request)\n-    return result\n-\n-\n-Expressions.boboAwareZopeTraverse = boboAwareZopeTraverse\n-Expressions.ZopePathExpr._TRAVERSER = staticmethod(boboAwareZopeTraverse)\n-\n-# But wait, there is also a BoboAwareZopeTraverse class.\n-from Products.PageTemplates.expression import BoboAwareZopeTraverse\n-from Products.PageTemplates.expression import TrustedBoboAwareZopeTraverse\n-\n-# We do not want to change the trusted version.  It inherits the traverse method\n-# from the untrusted class.  It may be better to give it its own method.\n-# The @classmethod makes this tricky to get right.\n-# But the following line essentially makes a copy of the traverse method\n-# without needing inheritance anymore.\n-TrustedBoboAwareZopeTraverse.traverse = TrustedBoboAwareZopeTraverse.traverse\n-\n-BoboAwareZopeTraverse._orig_traverse = BoboAwareZopeTraverse.traverse\n-\n-def traverse(cls, base, request, path_items):\n-    """See ``zope.app.pagetemplate.engine``."""\n-    # When our patching is done correctly, this only gets called for the\n-    # BoboAwareZopeTraverse class, so cls.traverse_method is always restrictedTraverse.\n-    # But let\'s be careful and just pass the attribute on.\n-    result = shared_traverse(base, path_items, request, traverse_method=cls.traverse_method)\n-    return result\n-\n-BoboAwareZopeTraverse.traverse = classmethod(traverse)\n-\n-# The TrustedBoboAwareZopeTraverse and (untrusted) BoboAwareZopeTraverse class have a problem:\n-# They have a "traverse_method" attribute, but the "traverse" method\n-# calls "cls.traverseMethod" instead, so this fails.\n-# This may mean these classes do not get called anymore, except in test_expressions.py.\n-name1 = "traverse_method"\n-name2 = "traverseMethod"\n-# First do the trusted class, because it inherits from the untrusted class.\n-# Otherwise the trusted class would have traverse_method=unrestrictedTraverse\n-# and it would inherit traverseMethod=restrictedTraverse.\n-for klass in (TrustedBoboAwareZopeTraverse, BoboAwareZopeTraverse):\n-    if hasattr(klass, name1) and not hasattr(klass, name2):\n-        setattr(klass, name2, getattr(klass, name1))\ndiff --git a/Products/CMFPlone/tests/accesscontrol_sm2.pt b/Products/CMFPlone/tests/accesscontrol_sm2.pt\ndeleted file mode 100644\nindex 6be7a66cdd..0000000000\n--- a/Products/CMFPlone/tests/accesscontrol_sm2.pt\n+++ /dev/null\n@@ -1 +0,0 @@\n-<span tal:condition="nocall:modules/AccessControl/SecurityManagement/getSecurityManager">getSecurityManager is still allowed</span>\ndiff --git a/Products/CMFPlone/tests/test_expressions.py b/Products/CMFPlone/tests/test_expressions.py\nindex 44304311b1..9d950fae46 100644\n--- a/Products/CMFPlone/tests/test_expressions.py\n+++ b/Products/CMFPlone/tests/test_expressions.py\n@@ -86,18 +86,6 @@ def test_template_bad3(self):\n         with self.assertRaises(NotFound):\n             template()\n \n-    def test_template_name(self):\n-        # Allow accessing __name__ in a skin template or TTW template.\n-        template = self._makeOne("options_view_name.pt")\n-        # Pass view in the options.\n-        self.assertIn("dummy-view", template(view=DummyView()))\n-\n-    def test_template_authenticator(self):\n-        # Allow accessing _authenticator in a skin template or TTW template.\n-        template = self._makeOne("options_authenticator.pt")\n-        # Pass view in the options.\n-        self.assertIn("secret", template(view=DummyView()))\n-\n     def test_template_single_underscore(self):\n         # Allow accessing \'_\' in a skin template or TTW template.\n         # In the merge of the hotfix, Zope allows this, to avoid a test failure.\n@@ -117,13 +105,6 @@ def test_template_accesscontrol_sm(self):\n         template = self._makeOne("accesscontrol_sm.pt")\n         self.assertIn("getSecurityManager is allowed", template())\n \n-    def test_template_accesscontrol_sm2(self):\n-        # Zope main.zpt uses modules/AccessControl/SecurityManagement/getSecurityManager\n-        # which should have been modules/AccessControl/getSecurityManager.\n-        # So we need a special case for it, otherwise the ZMI is totally inaccessible.\n-        template = self._makeOne("accesscontrol_sm2.pt")\n-        self.assertIn("getSecurityManager is still allowed", template())\n-\n     def test_template_accesscontrol_direct(self):\n         # Via AccessControl you can access too much.\n         template = self._makeOne("accesscontrol_direct.pt")\n@@ -184,18 +165,6 @@ def test_traverse_function_hacked_names(self):\n         result = trusted_traverse_function(view, ("Formatter_hack",), None)\n         self.assertEqual(result, string.Formatter)\n \n-    def test_traverse_function_name(self):\n-        # We allow access to __name__ always as a special case.\n-        view = DummyView()\n-        self.assertEqual(traverse_function(view, ("__name__",), None), "dummy-view")\n-        self.assertEqual(trusted_traverse_function(view, ("__name__",), None), "dummy-view")\n-\n-    def test_traverse_function_authenticator(self):\n-        # We allow access to _authenticator always as a special case.\n-        view = DummyView()\n-        self.assertEqual(traverse_function(view, ("_authenticator",), None), "secret")\n-        self.assertEqual(trusted_traverse_function(view, ("_authenticator",), None), "secret")\n-\n     def test_traverse_function_single_underscore(self):\n         # We allow access to \'_\' always as a special case.\n         view = DummyView()\n@@ -219,13 +188,6 @@ def test_traverse_function_accesscontrol_getSecurityManager(self):\n         self.assertEqual(traverse_function(AccessControl, ("getSecurityManager",), None), AccessControl.getSecurityManager)\n         self.assertEqual(trusted_traverse_function(AccessControl, ("getSecurityManager",), None), AccessControl.getSecurityManager)\n \n-    def test_traverse_function_accesscontrol_getSecurityManager2(self):\n-        # Zope main.zpt uses modules/AccessControl/SecurityManagement/getSecurityManager\n-        # which should have been modules/AccessControl/getSecurityManager.\n-        # So we need a special case for it, otherwise the ZMI is totally inaccessible.\n-        self.assertEqual(traverse_function(AccessControl, ("SecurityManagement", "getSecurityManager"), None), AccessControl.getSecurityManager)\n-        self.assertEqual(trusted_traverse_function(AccessControl, ("SecurityManagement", "getSecurityManager",), None), AccessControl.getSecurityManager)\n-\n     def test_traverse_function_accesscontrol_direct(self):\n         with self.assertRaises(NotFound):\n             traverse_function(AccessControl, ("SecurityManagement",), None)\n@@ -271,12 +233,6 @@ def test_traverse_class_formatter_get_field(self):\n         result = TrustedTraverseClass.traverse(string, None, ("Formatter", "get_field"))\n         self.assertEqual(result, string.Formatter.get_field)\n \n-    def test_traverse_class_name(self):\n-        # We allow access to __name__ always as a special case.\n-        view = DummyView()\n-        self.assertEqual(TraverseClass.traverse(view, None, ("__name__",)), "dummy-view")\n-        self.assertEqual(TrustedTraverseClass.traverse(view, None, ("__name__",)), "dummy-view")\n-\n     def test_traverse_class_content(self):\n         content = DummyContent("dummy")\n         self.assertEqual(TraverseClass.traverse(content, None, ("public",))(), "I am public")\n@@ -294,10 +250,6 @@ def test_traverse_class_accesscontrol_getSecurityManager(self):\n         self.assertEqual(TraverseClass.traverse(AccessControl, None, ("getSecurityManager",)), AccessControl.getSecurityManager)\n         self.assertEqual(TrustedTraverseClass.traverse(AccessControl, None, ("getSecurityManager",)), AccessControl.getSecurityManager)\n \n-    def test_traverse_class_accesscontrol_getSecurityManager2(self):\n-        self.assertEqual(TraverseClass.traverse(AccessControl, None, ("SecurityManagement", "getSecurityManager",)), AccessControl.getSecurityManager)\n-        self.assertEqual(TrustedTraverseClass.traverse(AccessControl, None, ("SecurityManagement", "getSecurityManager",)), AccessControl.getSecurityManager)\n-\n     def test_traverse_class_accesscontrol_direct(self):\n         with self.assertRaises(NotFound):\n             TraverseClass.traverse(AccessControl, None, ("SecurityManagement",))\ndiff --git a/news/3567.breaking b/news/3567.breaking\nnew file mode 100644\nindex 0000000000..31c60aba7b\n--- /dev/null\n+++ b/news/3567.breaking\n@@ -0,0 +1,5 @@\n+Removed our expressings patch.\n+This was a patch to avoid some too strict checks by Zope / Products.PageTemplates.\n+But in Plone 6 it should be fine to be stricter.\n+The ``STRICT_TRAVERSE_CHECK`` environment variable is no longer read.\n+[maurits]\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2022-06-29T19:02:29+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/0510dbd5afbf6be4a6c2881557293214939eda27

Update news/3567.breaking

Co-authored-by: David Glick &lt;david@glicksoftware.com&gt;

Files changed:
M news/3567.breaking

b'diff --git a/news/3567.breaking b/news/3567.breaking\nindex 31c60aba7b..ac55a10c75 100644\n--- a/news/3567.breaking\n+++ b/news/3567.breaking\n@@ -1,4 +1,4 @@\n-Removed our expressings patch.\n+Removed our expressions patch.\n This was a patch to avoid some too strict checks by Zope / Products.PageTemplates.\n But in Plone 6 it should be fine to be stricter.\n The ``STRICT_TRAVERSE_CHECK`` environment variable is no longer read.\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2022-06-30T00:29:08+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFPlone/commit/e6e825b1e7b014df39d7677c3bb4b3303ee29a0e

Merge pull request #3567 from plone/maurits-remove-earlypatches-expressions

Removed earlypatches/expressions.py.

Files changed:
A news/3567.breaking
M Products/CMFPlone/earlypatches/__init__.py
M Products/CMFPlone/tests/test_expressions.py
D Products/CMFPlone/earlypatches/expressions.py
D Products/CMFPlone/tests/accesscontrol_sm2.pt

b'diff --git a/Products/CMFPlone/earlypatches/__init__.py b/Products/CMFPlone/earlypatches/__init__.py\nindex 8010715709..c25923d78d 100644\n--- a/Products/CMFPlone/earlypatches/__init__.py\n+++ b/Products/CMFPlone/earlypatches/__init__.py\n@@ -1,3 +1,2 @@\n # misc security fixes\n from Products.CMFPlone.earlypatches import security  # noqa\n-from Products.CMFPlone.earlypatches import expressions  # noqa\ndiff --git a/Products/CMFPlone/earlypatches/expressions.py b/Products/CMFPlone/earlypatches/expressions.py\ndeleted file mode 100644\nindex 59eb58d1ad..0000000000\n--- a/Products/CMFPlone/earlypatches/expressions.py\n+++ /dev/null\n@@ -1,214 +0,0 @@\n-from AccessControl.SecurityManagement import getSecurityManager\n-from AccessControl.ZopeGuards import guarded_getattr\n-from AccessControl.ZopeGuards import guarded_import\n-from OFS.interfaces import ITraversable\n-from Products.PageTemplates import Expressions\n-from zExceptions import NotFound\n-from zExceptions import Unauthorized\n-from zope.traversing.adapters import traversePathElement\n-\n-import os\n-import string\n-import sys\n-import types\n-import warnings\n-\n-\n-# In the \'bobo aware\' Zope traverse methods and functions, various security checks are done.\n-# For example for content items, permission checks are done.\n-# But for non-content, for example a Python module or a dictionary, the checks were originally very lax.\n-# This could be abused.  Now we know that, we want to be as strict as possible.\n-#\n-# But being stricter breaks existing code which worked fine so far,\n-# not knowing that it tried to access code which should have been disallowed.\n-# One thing that goes wrong, is that any skin template that calls context/main_template/macros/master fails,\n-# for example when viewing a revision from CMFEditions.\n-#\n-# So with this hotfix, by necessity we are still lax/forgiving, but you can change this behavior\n-# with an environment variable: STRICT_TRAVERSE_CHECK.\n-# - STRICT_TRAVERSE_CHECK=0 mostly uses the original lax/sloppy checks.\n-#   This sadly needs to be the default.\n-# - STRICT_TRAVERSE_CHECK=1 uses the strict logic.\n-#   When you know what you are doing, you can try this.\n-# - STRICT_TRAVERSE_CHECK=2 first tries the strict logic.\n-#   If this fails, log a warning and then fallback to the original lax checks.\n-#   The idea would be to use this in development or production for a while, to see which code needs a fix.\n-try:\n-    STRICT_TRAVERSE_CHECK = int(os.getenv("STRICT_TRAVERSE_CHECK", 0))\n-except (ValueError, TypeError, AttributeError):\n-    STRICT_TRAVERSE_CHECK = 0\n-# Set of names that start with an underscore but that we want to allow anyway.\n-ALLOWED_UNDERSCORE_NAMES = set([\n-    # dunder name is used in plone.app.caching, and maybe other places\n-    "__name__",\n-    # Zope allows a single underscore to avoid a test failure\n-    "_",\n-    # Special case for plone.protect.\n-    # Fixes a NotFound error when submitting a PloneFormGen form:\n-    # https://github.com/smcmahon/Products.PloneFormGen/pull/229\n-    "_authenticator",\n-])\n-# Some objects we really do not trust, even when you have found a workaround to reach them.\n-DISALLOWED_OBJECTS = [\n-    os,\n-    sys,\n-    # string.Formatter sounds innocent, but can be abused.\n-    string.Formatter,\n-]\n-_orig_boboAwareZopeTraverse = Expressions.boboAwareZopeTraverse\n-\n-\n-def guarded_import_module(base, path_items):\n-    name = path_items[0]\n-    try:\n-        guarded_import(base.__name__, fromlist=path_items)\n-        # guarded_import will do most security checking\n-        # but will not return the imported item itself,\n-        # so we need to call getattr ourselves.\n-        # Actually, not all security checks are done, so we call guarded_getattr.\n-        for name in path_items:\n-            base = guarded_getattr(base, name)\n-    except Unauthorized:\n-        # special case for OFS/zpt/main.zpt which uses\n-        # modules/AccessControl/SecurityManagement/getSecurityManager\n-        # which should have been modules/AccessControl/getSecurityManager\n-        # Fixed in Zope 4.6.1 and 5.2.1.\n-        if name == "SecurityManagement" and path_items[-1] == "getSecurityManager":\n-            return getSecurityManager\n-        # Convert Unauthorized to prevent information disclosures\n-        raise NotFound(name)\n-    except TypeError:\n-        # During testing with security-policy-implementation python\n-        # and verbose-security on, I got this error when an Unauthorized was raised\n-        # for string.Formatter.get_field:\n-        # TypeError: descriptor \'__repr__\' of \'object\' object needs an argument\n-        # This was in the item_repr function of AccessControl.ImplPython.\n-        raise NotFound(name)\n-    if base in DISALLOWED_OBJECTS:\n-        raise NotFound(name)\n-    return base\n-\n-\n-def shared_traverse(base, path_items, request, traverse_method="restrictedTraverse"):\n-    """Shared traverse method for bobo aware zope traverse function and class method.\n-\n-    They are almost exactly the same, and it is irritating and error prone\n-    to change similar code in two places.\n-    """\n-    validate = getSecurityManager().validate\n-    path_items = list(path_items)\n-    path_items.reverse()\n-\n-    while path_items:\n-        name = path_items.pop()\n-\n-        if ITraversable.providedBy(base):\n-            base = getattr(base, traverse_method)(name)\n-        elif isinstance(base, types.ModuleType):\n-            # We should be able to handle the name and all remaining path items at once.\n-            # Use the correct order again.\n-            path_items.append(name)\n-            path_items.reverse()\n-            return guarded_import_module(base, path_items)\n-        else:\n-            found = traversePathElement(base, name, path_items,\n-                                        request=request)\n-\n-            # If traverse_method is something other than\n-            # ``restrictedTraverse`` then traversal is assumed to be\n-            # unrestricted. This emulates ``unrestrictedTraverse``\n-            if traverse_method != \'restrictedTraverse\':\n-                base = found\n-                continue\n-\n-            # Special backwards compatibility exception for the name ``_``,\n-            # which was often used for translation message factories.\n-            # Allow and continue traversal.\n-            if name == \'_\':\n-                warnings.warn(\'Traversing to the name `_` is deprecated \'\n-                              \'and will be removed in Zope 6.\',\n-                              DeprecationWarning)\n-                base = found\n-                continue\n-\n-            if name.startswith(\'_\'):\n-                if name in ALLOWED_UNDERSCORE_NAMES:\n-                    base = found\n-                    continue\n-                # All other names starting with ``_`` are disallowed.\n-                # This emulates what restrictedTraverse does.\n-                raise NotFound(name)\n-\n-            if found in DISALLOWED_OBJECTS:\n-                raise NotFound(name)\n-\n-            if STRICT_TRAVERSE_CHECK:\n-                # traversePathElement doesn\'t apply any Zope security policy,\n-                # so we validate access explicitly here.\n-                try:\n-                    validate(base, base, name, found)\n-                except Unauthorized:\n-                    if STRICT_TRAVERSE_CHECK == 2:\n-                        # only warn\n-                        warnings.warn(\n-                            \'Traversing from {0} to {1} is only allowed because STRICT_TRAVERSE_CHECK=2. \'\n-                            \'Possible security problem.\'.format(object, name))\n-                    else:\n-                        # Convert Unauthorized to prevent information disclosures\n-                        raise NotFound(name)\n-\n-            base = found\n-\n-    return base\n-\n-\n-def boboAwareZopeTraverse(object, path_items, econtext):\n-    """Traverses a sequence of names, first trying attributes then items.\n-\n-    This uses zope.traversing path traversal where possible and interacts\n-    correctly with objects providing OFS.interface.ITraversable when\n-    necessary (bobo-awareness).\n-    """\n-    request = getattr(econtext, \'request\', None)\n-    result = shared_traverse(object, path_items, request)\n-    return result\n-\n-\n-Expressions.boboAwareZopeTraverse = boboAwareZopeTraverse\n-Expressions.ZopePathExpr._TRAVERSER = staticmethod(boboAwareZopeTraverse)\n-\n-# But wait, there is also a BoboAwareZopeTraverse class.\n-from Products.PageTemplates.expression import BoboAwareZopeTraverse\n-from Products.PageTemplates.expression import TrustedBoboAwareZopeTraverse\n-\n-# We do not want to change the trusted version.  It inherits the traverse method\n-# from the untrusted class.  It may be better to give it its own method.\n-# The @classmethod makes this tricky to get right.\n-# But the following line essentially makes a copy of the traverse method\n-# without needing inheritance anymore.\n-TrustedBoboAwareZopeTraverse.traverse = TrustedBoboAwareZopeTraverse.traverse\n-\n-BoboAwareZopeTraverse._orig_traverse = BoboAwareZopeTraverse.traverse\n-\n-def traverse(cls, base, request, path_items):\n-    """See ``zope.app.pagetemplate.engine``."""\n-    # When our patching is done correctly, this only gets called for the\n-    # BoboAwareZopeTraverse class, so cls.traverse_method is always restrictedTraverse.\n-    # But let\'s be careful and just pass the attribute on.\n-    result = shared_traverse(base, path_items, request, traverse_method=cls.traverse_method)\n-    return result\n-\n-BoboAwareZopeTraverse.traverse = classmethod(traverse)\n-\n-# The TrustedBoboAwareZopeTraverse and (untrusted) BoboAwareZopeTraverse class have a problem:\n-# They have a "traverse_method" attribute, but the "traverse" method\n-# calls "cls.traverseMethod" instead, so this fails.\n-# This may mean these classes do not get called anymore, except in test_expressions.py.\n-name1 = "traverse_method"\n-name2 = "traverseMethod"\n-# First do the trusted class, because it inherits from the untrusted class.\n-# Otherwise the trusted class would have traverse_method=unrestrictedTraverse\n-# and it would inherit traverseMethod=restrictedTraverse.\n-for klass in (TrustedBoboAwareZopeTraverse, BoboAwareZopeTraverse):\n-    if hasattr(klass, name1) and not hasattr(klass, name2):\n-        setattr(klass, name2, getattr(klass, name1))\ndiff --git a/Products/CMFPlone/tests/accesscontrol_sm2.pt b/Products/CMFPlone/tests/accesscontrol_sm2.pt\ndeleted file mode 100644\nindex 6be7a66cdd..0000000000\n--- a/Products/CMFPlone/tests/accesscontrol_sm2.pt\n+++ /dev/null\n@@ -1 +0,0 @@\n-<span tal:condition="nocall:modules/AccessControl/SecurityManagement/getSecurityManager">getSecurityManager is still allowed</span>\ndiff --git a/Products/CMFPlone/tests/test_expressions.py b/Products/CMFPlone/tests/test_expressions.py\nindex 44304311b1..9d950fae46 100644\n--- a/Products/CMFPlone/tests/test_expressions.py\n+++ b/Products/CMFPlone/tests/test_expressions.py\n@@ -86,18 +86,6 @@ def test_template_bad3(self):\n         with self.assertRaises(NotFound):\n             template()\n \n-    def test_template_name(self):\n-        # Allow accessing __name__ in a skin template or TTW template.\n-        template = self._makeOne("options_view_name.pt")\n-        # Pass view in the options.\n-        self.assertIn("dummy-view", template(view=DummyView()))\n-\n-    def test_template_authenticator(self):\n-        # Allow accessing _authenticator in a skin template or TTW template.\n-        template = self._makeOne("options_authenticator.pt")\n-        # Pass view in the options.\n-        self.assertIn("secret", template(view=DummyView()))\n-\n     def test_template_single_underscore(self):\n         # Allow accessing \'_\' in a skin template or TTW template.\n         # In the merge of the hotfix, Zope allows this, to avoid a test failure.\n@@ -117,13 +105,6 @@ def test_template_accesscontrol_sm(self):\n         template = self._makeOne("accesscontrol_sm.pt")\n         self.assertIn("getSecurityManager is allowed", template())\n \n-    def test_template_accesscontrol_sm2(self):\n-        # Zope main.zpt uses modules/AccessControl/SecurityManagement/getSecurityManager\n-        # which should have been modules/AccessControl/getSecurityManager.\n-        # So we need a special case for it, otherwise the ZMI is totally inaccessible.\n-        template = self._makeOne("accesscontrol_sm2.pt")\n-        self.assertIn("getSecurityManager is still allowed", template())\n-\n     def test_template_accesscontrol_direct(self):\n         # Via AccessControl you can access too much.\n         template = self._makeOne("accesscontrol_direct.pt")\n@@ -184,18 +165,6 @@ def test_traverse_function_hacked_names(self):\n         result = trusted_traverse_function(view, ("Formatter_hack",), None)\n         self.assertEqual(result, string.Formatter)\n \n-    def test_traverse_function_name(self):\n-        # We allow access to __name__ always as a special case.\n-        view = DummyView()\n-        self.assertEqual(traverse_function(view, ("__name__",), None), "dummy-view")\n-        self.assertEqual(trusted_traverse_function(view, ("__name__",), None), "dummy-view")\n-\n-    def test_traverse_function_authenticator(self):\n-        # We allow access to _authenticator always as a special case.\n-        view = DummyView()\n-        self.assertEqual(traverse_function(view, ("_authenticator",), None), "secret")\n-        self.assertEqual(trusted_traverse_function(view, ("_authenticator",), None), "secret")\n-\n     def test_traverse_function_single_underscore(self):\n         # We allow access to \'_\' always as a special case.\n         view = DummyView()\n@@ -219,13 +188,6 @@ def test_traverse_function_accesscontrol_getSecurityManager(self):\n         self.assertEqual(traverse_function(AccessControl, ("getSecurityManager",), None), AccessControl.getSecurityManager)\n         self.assertEqual(trusted_traverse_function(AccessControl, ("getSecurityManager",), None), AccessControl.getSecurityManager)\n \n-    def test_traverse_function_accesscontrol_getSecurityManager2(self):\n-        # Zope main.zpt uses modules/AccessControl/SecurityManagement/getSecurityManager\n-        # which should have been modules/AccessControl/getSecurityManager.\n-        # So we need a special case for it, otherwise the ZMI is totally inaccessible.\n-        self.assertEqual(traverse_function(AccessControl, ("SecurityManagement", "getSecurityManager"), None), AccessControl.getSecurityManager)\n-        self.assertEqual(trusted_traverse_function(AccessControl, ("SecurityManagement", "getSecurityManager",), None), AccessControl.getSecurityManager)\n-\n     def test_traverse_function_accesscontrol_direct(self):\n         with self.assertRaises(NotFound):\n             traverse_function(AccessControl, ("SecurityManagement",), None)\n@@ -271,12 +233,6 @@ def test_traverse_class_formatter_get_field(self):\n         result = TrustedTraverseClass.traverse(string, None, ("Formatter", "get_field"))\n         self.assertEqual(result, string.Formatter.get_field)\n \n-    def test_traverse_class_name(self):\n-        # We allow access to __name__ always as a special case.\n-        view = DummyView()\n-        self.assertEqual(TraverseClass.traverse(view, None, ("__name__",)), "dummy-view")\n-        self.assertEqual(TrustedTraverseClass.traverse(view, None, ("__name__",)), "dummy-view")\n-\n     def test_traverse_class_content(self):\n         content = DummyContent("dummy")\n         self.assertEqual(TraverseClass.traverse(content, None, ("public",))(), "I am public")\n@@ -294,10 +250,6 @@ def test_traverse_class_accesscontrol_getSecurityManager(self):\n         self.assertEqual(TraverseClass.traverse(AccessControl, None, ("getSecurityManager",)), AccessControl.getSecurityManager)\n         self.assertEqual(TrustedTraverseClass.traverse(AccessControl, None, ("getSecurityManager",)), AccessControl.getSecurityManager)\n \n-    def test_traverse_class_accesscontrol_getSecurityManager2(self):\n-        self.assertEqual(TraverseClass.traverse(AccessControl, None, ("SecurityManagement", "getSecurityManager",)), AccessControl.getSecurityManager)\n-        self.assertEqual(TrustedTraverseClass.traverse(AccessControl, None, ("SecurityManagement", "getSecurityManager",)), AccessControl.getSecurityManager)\n-\n     def test_traverse_class_accesscontrol_direct(self):\n         with self.assertRaises(NotFound):\n             TraverseClass.traverse(AccessControl, None, ("SecurityManagement",))\ndiff --git a/news/3567.breaking b/news/3567.breaking\nnew file mode 100644\nindex 0000000000..ac55a10c75\n--- /dev/null\n+++ b/news/3567.breaking\n@@ -0,0 +1,5 @@\n+Removed our expressions patch.\n+This was a patch to avoid some too strict checks by Zope / Products.PageTemplates.\n+But in Plone 6 it should be fine to be stricter.\n+The ``STRICT_TRAVERSE_CHECK`` environment variable is no longer read.\n+[maurits]\n'

