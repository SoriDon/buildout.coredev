Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2023-02-25T01:57:49+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.iterate/commit/f501923899e6a7efbe062d606b2e62a3ae6ef2ae

Drop support for Plone 5.2.

Removed `archetypes` extra.
Use `plone.base` more.

Files changed:
M plone/app/iterate/util.py
M setup.py

b'diff --git a/plone/app/iterate/util.py b/plone/app/iterate/util.py\nindex 6826071..542b9aa 100644\n--- a/plone/app/iterate/util.py\n+++ b/plone/app/iterate/util.py\n@@ -23,7 +23,7 @@\n \n from .interfaces import annotation_key\n from persistent.dict import PersistentDict\n-from Products.CMFPlone.utils import get_installer\n+from plone.base.utils import get_installer\n from zope.annotation import IAnnotations\n \n \ndiff --git a/setup.py b/setup.py\nindex d8f6247..89ee27e 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -7,15 +7,13 @@\n \n setup(\n     name="plone.app.iterate",\n-    version="4.0.4.dev0",\n+    version="5.0.0.dev0",\n     description="check-out/check-in staging for Plone",\n     long_description=LONG_DESCRIPTION,\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Environment :: Web Environment",\n         "Framework :: Plone",\n-        "Framework :: Plone :: 5.1",\n-        "Framework :: Plone :: 5.2",\n         "Framework :: Plone :: 6.0",\n         "Framework :: Plone :: Core",\n         "Framework :: Zope2",\n@@ -23,9 +21,6 @@\n         "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n         "Operating System :: OS Independent",\n         "Programming Language :: Python",\n-        "Programming Language :: Python :: 2.7",\n-        "Programming Language :: Python :: 3.6",\n-        "Programming Language :: Python :: 3.7",\n         "Programming Language :: Python :: 3.8",\n         "Programming Language :: Python :: 3.9",\n         "Programming Language :: Python :: 3.10",\n@@ -40,7 +35,7 @@\n     namespace_packages=["plone", "plone.app"],\n     include_package_data=True,\n     zip_safe=False,\n-    python_requires=">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,!=3.5.*",\n+    python_requires=">=3.8",\n     install_requires=[\n         "Acquisition",\n         "DateTime",\n@@ -63,9 +58,6 @@\n         "zope.viewlet",\n     ],\n     extras_require={\n-        "archetypes": [\n-            "Products.Archetypes",\n-        ],\n         "test": [\n             "plone.app.testing",\n             "plone.app.contenttypes",\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2023-02-25T02:22:58+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.iterate/commit/da57b29b804b7da42f37284377544b49fe2e6569

Drop Archetypes related code.

Files changed:
M plone/app/iterate/configure.zcml
M plone/app/iterate/interfaces.py
M plone/app/iterate/testing.py
M plone/app/iterate/tests/dexterity.rst
M plone/app/iterate/tests/test_doctests.py
D plone/app/iterate/at.zcml
D plone/app/iterate/copier.py
D plone/app/iterate/policy.py
D plone/app/iterate/relation.py
D plone/app/iterate/tests/browser.rst
D plone/app/iterate/tests/content.py
D plone/app/iterate/tests/test_iterate_at.py

b'diff --git a/plone/app/iterate/at.zcml b/plone/app/iterate/at.zcml\ndeleted file mode 100644\nindex e6b938f..0000000\n--- a/plone/app/iterate/at.zcml\n+++ /dev/null\n@@ -1,15 +0,0 @@\n-<configure\n-    xmlns="http://namespaces.zope.org/zope"\n-    xmlns:five="http://namespaces.zope.org/five"\n-    xmlns:zcml="http://namespaces.zope.org/zcml"\n-    i18n_domain="plone">\n-\n-  <class class="Products.Archetypes.BaseObject.BaseObject">\n-      <implements interface=".interfaces.IIterateAware" />\n-  </class>\n-\n-  <adapter factory=".relation.CheckinCheckoutReferenceAdapter"/>\n-  <adapter factory=".policy.CheckinCheckoutPolicyAdapter" />\n-  <adapter factory=".copier.ContentCopier" />\n-\n-</configure>\n\\ No newline at end of file\ndiff --git a/plone/app/iterate/configure.zcml b/plone/app/iterate/configure.zcml\nindex 6b64a41..a788755 100644\n--- a/plone/app/iterate/configure.zcml\n+++ b/plone/app/iterate/configure.zcml\n@@ -117,6 +117,5 @@\n     />\n \n   <include package=".dexterity" zcml:condition="installed plone.app.relationfield" />\n-  <include file="at.zcml" zcml:condition="installed Products.Archetypes.BaseObject" />\n \n </configure>\ndiff --git a/plone/app/iterate/copier.py b/plone/app/iterate/copier.py\ndeleted file mode 100644\nindex 3fec074..0000000\n--- a/plone/app/iterate/copier.py\n+++ /dev/null\n@@ -1,232 +0,0 @@\n-# -*- coding: utf-8 -*-\n-##################################################################\n-#\n-# (C) Copyright 2006-2007 ObjectRealms, LLC\n-# All Rights Reserved\n-#\n-# This file is part of iterate.\n-#\n-# iterate is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2 of the License, or\n-# (at your option) any later version.\n-#\n-# iterate is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with CMFDeployment; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-##################################################################\n-\n-"""\n-Archtypes specific copier, dexterity folder has its own!\n-"""\n-\n-from Acquisition import aq_base\n-from Acquisition import aq_inner\n-from Acquisition import aq_parent\n-from plone.app.iterate import interfaces\n-from plone.app.iterate.base import BaseContentCopier\n-from plone.app.iterate.interfaces import CheckinException\n-from Products.Archetypes.Referenceable import Referenceable\n-from Products.CMFCore.utils import getToolByName\n-from Products.DCWorkflow.DCWorkflow import DCWorkflowDefinition\n-from .relation import WorkingCopyRelation\n-from ZODB.PersistentMapping import PersistentMapping\n-from zope import component\n-from zope import interface\n-from zope.annotation.interfaces import IAnnotations\n-from zope.event import notify\n-from zope.lifecycleevent import ObjectMovedEvent\n-\n-\n-@interface.implementer(interfaces.IObjectCopier)\n-@component.adapter(interfaces.IIterateAware)\n-class ContentCopier(BaseContentCopier):\n-    """ Content copier for Archetypes """\n-\n-    def copyTo(self, container):\n-        wc = self._copyBaseline(container)\n-        wc_ref = wc.addReference(\n-            self.context,\n-            relationship=WorkingCopyRelation.relationship,\n-            referenceClass=WorkingCopyRelation,\n-        )\n-        self._handleReferences(self.context, wc, "checkout", wc_ref)\n-        return wc, wc_ref\n-\n-    def merge(self):\n-        baseline = self._getBaseline()\n-\n-        # delete the working copy reference to the baseline\n-        wc_ref = self._deleteWorkingCopyRelation()\n-\n-        # reassemble references on the new baseline\n-        self._handleReferences(baseline, self.context, "checkin", wc_ref)\n-\n-        # move the working copy to the baseline container, deleting\n-        # the baseline\n-        new_baseline = self._replaceBaseline(baseline)\n-\n-        # patch the working copy with baseline info not preserved\n-        # during checkout\n-        self._reassembleWorkingCopy(new_baseline, baseline)\n-\n-        return new_baseline\n-\n-    def _getBaseline(self):\n-        # follow the working copy\'s reference back to the baseline\n-        refs = self.context.getRefs(WorkingCopyRelation.relationship)\n-\n-        if not len(refs) == 1:\n-            raise CheckinException("Baseline count mismatch")\n-\n-        if not refs or refs[0] is None:\n-            raise CheckinException("Baseline has disappeared")\n-\n-        baseline = refs[0]\n-        return baseline\n-\n-    def _replaceBaseline(self, baseline):\n-        # move the working copy object to the baseline, returns the\n-        # new baseline\n-        baseline_id = baseline.getId()\n-\n-        # delete the baseline from the folder to make room for the\n-        # committed working copy\n-        baseline_container = aq_parent(aq_inner(baseline))\n-        # Check if we are a default_page, because this property of the\n-        # container might get lost.\n-        is_default_page = (\n-            baseline_container.getProperty("default_page", "") == baseline_id\n-        )\n-        baseline_pos = baseline_container.getObjectPosition(baseline_id)\n-        baseline_container._delOb(baseline_id)\n-\n-        # uninedxing the deleted baseline object from portal_catalog\n-        portal_catalog = getToolByName(self.context, "portal_catalog")\n-        portal_catalog.unindexObject(baseline)\n-\n-        # delete the working copy from the its container\n-        wc_container = aq_parent(aq_inner(self.context))\n-\n-        # trick out the at machinery to not delete references\n-        self.context._v_cp_refs = 1\n-        self.context._v_is_cp = 0\n-\n-        wc_id = self.context.getId()\n-        wc_container.manage_delObjects([wc_id])\n-\n-        # move the working copy back to the baseline container\n-        working_copy = aq_base(self.context)\n-        working_copy.setId(baseline_id)\n-        baseline_container._setOb(baseline_id, working_copy)\n-        baseline_container.moveObjectToPosition(baseline_id, baseline_pos)\n-\n-        new_baseline = baseline_container._getOb(baseline_id)\n-        if is_default_page:\n-            # Restore default_page to container.  Note that the property might\n-            # have been removed by an event handler in the mean time.\n-            if baseline_container.hasProperty("default_page"):\n-                baseline_container._updateProperty("default_page", baseline_id)\n-            else:\n-                baseline_container._setProperty("default_page", baseline_id)\n-\n-        # reregister our references with the reference machinery after moving\n-        Referenceable.manage_afterAdd(new_baseline, new_baseline, baseline_container)\n-\n-        notify(\n-            ObjectMovedEvent(\n-                new_baseline, wc_container, wc_id, baseline_container, baseline_id\n-            )\n-        )\n-\n-        return new_baseline\n-\n-    def _reassembleWorkingCopy(self, new_baseline, baseline):\n-        # reattach the source\'s workflow history, try avoid a dangling ref\n-        try:\n-            new_baseline.workflow_history = PersistentMapping(\n-                baseline.workflow_history.items()\n-            )\n-        except AttributeError:\n-            # No workflow apparently.  Oh well.\n-            pass\n-\n-        # reset wf state security directly\n-        workflow_tool = getToolByName(self.context, "portal_workflow")\n-        wfs = workflow_tool.getWorkflowsFor(self.context)\n-        for wf in wfs:\n-            if not isinstance(wf, DCWorkflowDefinition):\n-                continue\n-            wf.updateRoleMappingsFor(new_baseline)\n-\n-        # Reattach the source\'s uid, this will update wc refs to point\n-        # back to the new baseline.  This may introduce duplicate\n-        # references, so we check that and fix them.\n-        self._recursivelyReattachUIDs(baseline, new_baseline)\n-\n-        # reattach the source\'s history id, to get the previous\n-        # version ancestry\n-        histid_handler = getToolByName(self.context, "portal_historyidhandler")\n-        huid = histid_handler.getUid(baseline)\n-        histid_handler.setUid(new_baseline, huid, check_uniqueness=False)\n-\n-        return new_baseline\n-\n-    def _deleteWorkingCopyRelation(self):\n-        # delete the wc reference keeping a reference to it for its annotations\n-        refs = self.context.getReferenceImpl(WorkingCopyRelation.relationship)\n-        wc_ref = refs[0]\n-        self.context.deleteReferences(WorkingCopyRelation.relationship)\n-        return wc_ref\n-\n-    #################################\n-    # Checkout Support Methods\n-\n-    def _handleReferences(self, baseline, wc, mode, wc_ref):\n-\n-        annotations = IAnnotations(wc_ref)\n-\n-        baseline_adapter = interfaces.ICheckinCheckoutReference(baseline)\n-\n-        # handle forward references\n-        for relationship in baseline.getRelationships():\n-            if relationship is None:\n-                adapter = None\n-            else:\n-                # look for a named relation adapter first\n-                adapter = component.queryAdapter(\n-                    baseline, interfaces.ICheckinCheckoutReference, relationship\n-                )\n-\n-            if adapter is None:  # default\n-                adapter = baseline_adapter\n-\n-            references = baseline.getReferenceImpl(relationship)\n-\n-            mode_method = getattr(adapter, mode)\n-            mode_method(baseline, wc, references, annotations)\n-\n-        mode = mode + "BackReferences"\n-\n-        # handle backward references\n-        for relationship in baseline.getBRelationships():\n-            if relationship is None:\n-                adapter = None\n-            else:\n-                # look for a named relation adapter first\n-                adapter = component.queryAdapter(\n-                    baseline, interfaces.ICheckinCheckoutReference, relationship\n-                )\n-\n-            if adapter is None:\n-                adapter = baseline_adapter\n-\n-            references = baseline.getBackReferenceImpl(relationship)\n-\n-            mode_method = getattr(adapter, mode)\n-            mode_method(baseline, wc, references, annotations)\ndiff --git a/plone/app/iterate/interfaces.py b/plone/app/iterate/interfaces.py\nindex d63b42a..120fee7 100644\n--- a/plone/app/iterate/interfaces.py\n+++ b/plone/app/iterate/interfaces.py\n@@ -35,16 +35,8 @@\n import pkg_resources\n \n \n-try:\n-    pkg_resources.get_distribution("Products.Archetypes")\n-except pkg_resources.DistributionNotFound:\n-\n-    class IReference(Interface):\n-        pass\n-\n-\n-else:\n-    from Products.Archetypes.interfaces import IReference\n+class IReference(Interface):\n+    pass\n \n \n ################################\n@@ -103,7 +95,7 @@ class ICheckinEvent(IObjectEvent):\n     """\n \n     baseline = Attribute("The Working Copy\'s baseline")\n-    relation = Attribute("The Working Copy Archetypes Relation Object")\n+    relation = Attribute("The Working Copy Relation Object")\n     checkin_message = Attribute("checkin message")\n \n \n@@ -121,7 +113,7 @@ class ICheckoutEvent(IObjectEvent):\n     """ an object is being checked out, event.object is the baseline """\n \n     working_copy = Attribute("The object\'s working copy")\n-    relation = Attribute("The Working Copy Archetypes Relation Object")\n+    relation = Attribute("The Working Copy Relation Object")\n \n \n class ICancelCheckoutEvent(IObjectEvent):\n@@ -139,7 +131,7 @@ class IWorkingCopyDeletedEvent(IObjectEvent):\n     """\n \n     baseline = Attribute("The working copy baseline")\n-    relation = Attribute("The Working Copy Archetypes Relation Object")\n+    relation = Attribute("The Working Copy Relation Object")\n \n \n #################################\ndiff --git a/plone/app/iterate/policy.py b/plone/app/iterate/policy.py\ndeleted file mode 100644\nindex e2f536d..0000000\n--- a/plone/app/iterate/policy.py\n+++ /dev/null\n@@ -1,103 +0,0 @@\n-# -*- coding: utf-8 -*-\n-##################################################################\n-#\n-# (C) Copyright 2006-2007 ObjectRealms, LLC\n-# All Rights Reserved\n-#\n-# This file is part of iterate.\n-#\n-# iterate is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2 of the License, or\n-# (at your option) any later version.\n-#\n-# iterate is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with CMFDeployment; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-##################################################################\n-"""\n-Archetypes Checkin Checkout Policy For Content\n-\n-"""\n-from plone.app.iterate.base import CheckinCheckoutBasePolicyAdapter\n-from plone.app.iterate.event import AfterCheckinEvent\n-from plone.app.iterate.event import CheckinEvent\n-from plone.app.iterate.interfaces import CheckinException\n-from plone.app.iterate.interfaces import IIterateAware\n-from plone.app.iterate.interfaces import IObjectCopier\n-from plone.app.iterate.relation import WorkingCopyRelation\n-from plone.app.iterate.util import get_storage\n-from Products.Archetypes.interfaces import IReferenceable\n-from zope.component import adapter\n-from zope.component import queryAdapter\n-from zope.event import notify\n-\n-\n-@adapter(IIterateAware)\n-class CheckinCheckoutPolicyAdapter(CheckinCheckoutBasePolicyAdapter):\n-    """Checkin Checkout Policy For Archetypes Content\n-\n-    - on checkout context is the baseline\n-    - on checkin context is the working copy.\n-    """\n-\n-    def checkin(self, checkin_message):\n-        # see interface\n-\n-        # get the baseline for this working copy, raise if not found\n-        baseline = self._getBaseline()\n-\n-        # get a hold of the relation object\n-        wc_ref = self.context.getReferenceImpl(WorkingCopyRelation.relationship)[0]\n-\n-        # publish the event for subscribers, early because contexts are about\n-        # to be manipulated\n-        notify(CheckinEvent(self.context, baseline, wc_ref, checkin_message))\n-\n-        # merge the object back to the baseline with a copier\n-\n-        # XXX by gotcha\n-        # bug we should or use a getAdapter call or test if copier is None\n-        copier = queryAdapter(self.context, IObjectCopier)\n-        new_baseline = copier.merge()\n-\n-        # don\'t need to unlock the lock disappears with old baseline deletion\n-        notify(AfterCheckinEvent(new_baseline, checkin_message))\n-\n-        return new_baseline\n-\n-    #################################\n-    #  Checkin Support Methods\n-\n-    def _getBaseline(self):\n-        # follow the working copy\'s reference back to the baseline\n-        refs = self.context.getReferences(WorkingCopyRelation.relationship)\n-\n-        if not len(refs) == 1:\n-            raise CheckinException("Baseline count mismatch")\n-\n-        if not refs or refs[0] is None:\n-            raise CheckinException("Baseline has disappeared")\n-\n-        baseline = refs[0]\n-        return baseline\n-\n-    def getBaseline(self):\n-        if IReferenceable.providedBy(self.context):\n-            refs = self.context.getReferences(WorkingCopyRelation.relationship)\n-            if refs:\n-                return refs[0]\n-\n-    def getWorkingCopy(self):\n-        if IReferenceable.providedBy(self.context):\n-            refs = self.context.getBRefs(WorkingCopyRelation.relationship)\n-            if refs:\n-                return refs[0]\n-\n-    def getProperties(self, obj, default=None):\n-        return get_storage(obj, default=default)\ndiff --git a/plone/app/iterate/relation.py b/plone/app/iterate/relation.py\ndeleted file mode 100644\nindex dd3ada7..0000000\n--- a/plone/app/iterate/relation.py\n+++ /dev/null\n@@ -1,138 +0,0 @@\n-# -*- coding: utf-8 -*-\n-##################################################################\n-#\n-# (C) Copyright 2006 ObjectRealms, LLC\n-# All Rights Reserved\n-#\n-# This file is part of iterate.\n-#\n-# iterate is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2 of the License, or\n-# (at your option) any later version.\n-#\n-# iterate is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with CMFDeployment; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-##################################################################\n-"""\n-Archetypes speicifc implementation for relation handling\n-"""\n-\n-from .interfaces import ICheckinCheckoutReference\n-from .interfaces import IIterateAware\n-from .interfaces import IWorkingCopyRelation\n-from Products.Archetypes import config as atconf\n-from Products.Archetypes.exceptions import ReferenceException\n-from Products.Archetypes.ReferenceEngine import Reference\n-from zope.annotation.interfaces import IAttributeAnnotatable\n-from zope.component import adapter\n-from zope.interface import implementer\n-\n-import logging\n-\n-\n-logger = logging.getLogger("plone.app.iterate")\n-\n-\n-@implementer(IWorkingCopyRelation, IAttributeAnnotatable)\n-class WorkingCopyRelation(Reference):\n-    """\n-    Source Object is Working Copy\n-\n-    Target Object is Baseline Version\n-    """\n-\n-    relationship = "Working Copy Relation"\n-\n-\n-@implementer(ICheckinCheckoutReference)\n-@adapter(IIterateAware)\n-class CheckinCheckoutReferenceAdapter(object):\n-    """\n-    default adapter for references.\n-\n-    on checkout\n-\n-    forward refs on baseline are copied to wc\n-    backward refs on baseline are ignored on wc\n-\n-    on checkin\n-\n-    forward refs on wc are kept\n-    backwards refs on wc are kept\n-\n-    forward refs on baseline get removed\n-    backward refs on baseline are kept by virtue of UID transferance\n-\n-    """\n-\n-    storage_key = "coci.references"\n-\n-    def __init__(self, context):\n-        self.context = context\n-\n-    def checkout(self, baseline, wc, refs, storage):\n-        for ref in refs:\n-            try:\n-                wc.addReference(\n-                    ref.targetUID, ref.relationship, referenceClass=ref.__class__\n-                )\n-            except ReferenceException:\n-                logger.warn(\n-                    "Reference exception when adding relation %r "\n-                    "from new working copy %s to uid %s. Ignoring relation.",\n-                    ref.relationship,\n-                    "/".join(wc.getPhysicalPath()),\n-                    ref.targetUID,\n-                )\n-\n-    def checkin(self, *args):\n-        pass\n-\n-    checkoutBackReferences = checkinBackReferences = checkin\n-\n-\n-@implementer(ICheckinCheckoutReference)\n-class NoCopyReferenceAdapter(object):\n-    """\n-    an adapter for references that does not copy them to the wc on checkout.\n-\n-    additionally custom reference state is kept when the wc is checked in.\n-    """\n-\n-    def __init__(self, context):\n-        self.context = context\n-\n-    def checkin(self, baseline, wc, refs, storage):\n-        # move the references from the baseline to the wc\n-\n-        # one note, on checkin the wc uid is not yet changed to match that of\n-        # the baseline\n-        ref_ids = [r.getId() for r in refs]\n-\n-        baseline_ref_container = getattr(baseline, atconf.REFERENCE_ANNOTATION)\n-        clipboard = baseline_ref_container.manage_cutObjects(ref_ids)\n-\n-        wc_ref_container = getattr(wc, atconf.REFERENCE_ANNOTATION)\n-\n-        # references aren\'t globally addable w/ associated perm which default\n-        # copysupport wants to check, temporarily monkey around the issue.\n-        def _verifyObjectPaste(*args, **kw):\n-            pass\n-\n-        wc_ref_container._verifyObjectPaste = _verifyObjectPaste\n-        try:\n-            wc_ref_container.manage_pasteObjects(clipboard)\n-        finally:\n-            del wc_ref_container._verifyObjectPaste\n-\n-    def checkout(self, *args):\n-        pass\n-\n-    checkoutBackReferences = checkinBackReferences = checkout\ndiff --git a/plone/app/iterate/testing.py b/plone/app/iterate/testing.py\nindex 73c27fb..1a40805 100644\n--- a/plone/app/iterate/testing.py\n+++ b/plone/app/iterate/testing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """Testing setup for integration and functional tests."""\n from plone.app.contenttypes.testing import PloneAppContenttypes\n from plone.app.testing import applyProfile\n@@ -6,17 +5,6 @@\n from plone.app.testing import PloneSandboxLayer\n from plone.app.testing.layers import FunctionalTesting\n from plone.app.testing.layers import IntegrationTesting\n-from plone.testing import z2\n-\n-import pkg_resources\n-\n-\n-try:\n-    pkg_resources.get_distribution("Products.Archetypes")\n-except pkg_resources.DistributionNotFound:\n-    HAS_AT = False\n-else:\n-    HAS_AT = True\n \n \n ADMIN = {\n@@ -45,91 +33,6 @@\n )\n \n \n-class PloneAppIterateLayer(PloneSandboxLayer):\n-    """Plone Sandbox Layer for plone.app.iterate."""\n-\n-    defaultBases = (PLONE_FIXTURE,)\n-\n-    def setUpZope(self, app, configurationContext):\n-        """Setup Zope with Addons."""\n-        if not HAS_AT:\n-            return\n-\n-        import Products.ATContentTypes\n-\n-        self.loadZCML(package=Products.ATContentTypes)\n-        z2.installProduct(app, "Products.ATContentTypes")\n-\n-        z2.installProduct(app, "Products.Archetypes")\n-        z2.installProduct(app, "Products.ATContentTypes")\n-        z2.installProduct(app, "plone.app.blob")\n-        z2.installProduct(app, "plone.app.collection")\n-\n-        import plone.app.iterate\n-\n-        self.loadZCML(package=plone.app.iterate)\n-\n-    def setUpPloneSite(self, portal):\n-        """Setup Plone Site with Addons."""\n-        if not HAS_AT:\n-            return\n-\n-        # restore default workflow\n-        applyProfile(portal, "Products.CMFPlone:testfixture")\n-\n-        # add default content\n-        applyProfile(portal, "Products.ATContentTypes:content")\n-        applyProfile(portal, "plone.app.iterate:default")\n-        applyProfile(portal, "plone.app.iterate:test")\n-\n-        for user in USERS_TO_BE_ADDED:\n-            portal.portal_membership.addMember(\n-                user["id"],\n-                user["password"],\n-                user["roles"],\n-                [],\n-            )\n-\n-        for user in USERS_WITH_MEMBER_FOLDER:\n-            mtool = portal.portal_membership\n-            if not mtool.getMemberareaCreationFlag():\n-                mtool.setMemberareaCreationFlag()\n-                mtool.createMemberArea(user["id"])\n-\n-            if mtool.getMemberareaCreationFlag():\n-                mtool.setMemberareaCreationFlag()\n-\n-        portal.portal_workflow.setChainForPortalTypes(\n-            ("Document",),\n-            "plone_workflow",\n-        )\n-\n-        # Turn on versioning for folders\n-        portal_repository = portal.portal_repository\n-        portal_repository.addPolicyForContentType(\n-            "Folder",\n-            u"at_edit_autoversion",\n-        )\n-        portal_repository.addPolicyForContentType(\n-            "Folder",\n-            u"version_on_revert",\n-        )\n-        versionable_types = portal_repository.getVersionableContentTypes()\n-        versionable_types.append("Folder")\n-        portal_repository.setVersionableContentTypes(versionable_types)\n-\n-\n-PLONEAPPITERATE_FIXTURE = PloneAppIterateLayer()\n-\n-PLONEAPPITERATE_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(PLONEAPPITERATE_FIXTURE,), name="PloneAppIterateLayer:Integration"\n-)\n-\n-PLONEAPPITERATE_FUNCTIONAL_TESTING = FunctionalTesting(\n-    bases=(PLONEAPPITERATE_FIXTURE,), name="PloneAppIterateLayer:Functional"\n-)\n-\n-\n class DexPloneAppIterateLayer(PloneAppContenttypes):\n     """Dexterity based Plone Sandbox Layer for plone.app.iterate."""\n \ndiff --git a/plone/app/iterate/tests/browser.rst b/plone/app/iterate/tests/browser.rst\ndeleted file mode 100644\nindex 95098c5..0000000\n--- a/plone/app/iterate/tests/browser.rst\n+++ /dev/null\n@@ -1,324 +0,0 @@\n-Setup\n------\n-\n-    >>> from plone.testing import z2\n-    >>> from plone.app.testing import login\n-    >>> from plone.app.testing import SITE_OWNER_NAME\n-    >>> from plone.app.testing import SITE_OWNER_PASSWORD\n-\n-    >>> portal = layer[\'portal\']\n-    >>> app = layer[\'app\']\n-    >>> portal_url = portal.absolute_url()\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.handleErrors = False\n-    >>> browser.addHeader(\'Authorization\',\n-    ...                   \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD))\n-\n-Create a document\n------------------\n-\n-Go to our folder and create a document::\n-\n-    >>> browser.open(portal.absolute_url())\n-    >>> browser.getLink(\'Add new\').click()\n-    >>> \'Add new item\' in browser.contents\n-    True\n-    >>> browser.getControl(\'Page\').click()\n-    >>> browser.getControl(\'Add\').click()\n-    >>> browser.getControl(\'Title\').value = \'Hello, World!\'\n-    >>> browser.getControl(name=\'text\').value = \'Hello, World!\'\n-    >>> browser.getControl(\'Save\').click()\n-    >>> \'Changes saved.\' in browser.contents\n-    True\n-\n-Check it out\n-------------\n-\n-Let\'s check out the document.  For this, we\'ll go to the *Check out*\n-form directly.  From there, we\'ll check out to the parent folder::\n-\n-    >>> browser.getLink(\'Check out\').click()\n-    >>> \'form.button.Checkout\' in browser.contents\n-    True\n-    >>> browser.getControl(name=\'form.button.Checkout\').click()\n-    >>> \'This is a working copy\' in browser.contents\n-    True\n-    >>> browser.url\n-    \'http://nohost/plone/copy_of_hello-world\'\n-\n-When viewing the original document, we should see a note that\n-someone\'s working on a working copy::\n-\n-    >>> browser.open(\'http://nohost/plone/hello-world\')\n-    >>> \'This item is being edited\' in browser.contents\n-    True\n-\n-We\'ll now edit the working copy and save it::\n-\n-    >>> browser.open(\'http://nohost/plone/copy_of_hello-world\')\n-    >>> browser.getLink(\'Edit\').click()\n-    >>> browser.getControl(\'Title\').value = \'Hello, World! version 2.0\'\n-    >>> browser.getControl(\'Save\').click()\n-    >>> \'Changes saved.\' in browser.contents\n-    True\n-    >>> \'http://nohost/plone/copy_of_hello-world\' in browser.url\n-    True\n-\n-Check it in\n------------\n-\n-Now that we\'ve made our changes we\'ll check the working copy in::\n-\n-    >>> browser.getLink(\'Check in\').click()\n-    >>> browser.getControl(\'Check in\').click()\n-    >>> \'Checked in\' in browser.contents\n-    True\n-    >>> browser.url\n-    \'http://nohost/plone/hello-world\'\n-    >>> \'Hello, World! version 2.0\' in browser.contents\n-    True\n-\n-Permissions\n------------\n-\n-For the community workflow, we expect Editors and Contributors to be able to\n-check out published pages::\n-\n-    >>> portal.portal_workflow.setDefaultChain(\'plone_workflow\')\n-    >>> ignore = portal.portal_workflow.updateRoleMappings()\n-    >>> browser.getLink("Publish").click()\n-    >>> "Item state changed" in browser.contents\n-    True\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\', \'Basic editor:secret\')\n-\n-    >>> browser.open(portal.absolute_url() + \'/hello-world\')\n-    >>> browser.getLink("Check out").click()\n-    >>> \'form.button.Checkout\' in browser.contents\n-    True\n-    >>> browser.getControl(name=\'form.button.Checkout\').click()\n-    >>> "Check-out created" in browser.contents\n-    True\n-\n-They should not, however, be able to check in their working copy\n-again.  That\'s because the item is in the ``published`` state and\n-therefore our Editor lacks permissions to modify the original::\n-\n-    >>> browser.getLink("Cancel check-out")\n-    <Link ...>\n-    >>> browser.getLink("Check in")\n-    Traceback (most recent call last):\n-    ...\n-    LinkNotFoundError\n-\n-The Editor could, however, ask someone to retract the original so he\n-gains permissions again and check in (and then possibly request for\n-review)::\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\',\n-    ...                   \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD))\n-    >>> browser.open(portal.absolute_url() + \'/hello-world\')\n-    >>> browser.getLink("Published").click()\n-    >>> browser.getControl("Retract").click()\n-    >>> browser.getControl("Save").click()\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\', \'Basic editor:secret\')\n-    >>> browser.open(portal.absolute_url() + \'/hello-world\')\n-    >>> browser.getLink("working copy").click()\n-    >>> browser.getLink("Check in").click()\n-    >>> browser.getControl("Check in").click()\n-    >>> "Checked in" in browser.contents\n-    True\n-\n-Folders\n--------\n-\n-Turn on versioning for folders::\n-\n-    >>> from Products.CMFCore.utils import getToolByName\n-    >>> tool = getToolByName(portal, \'portal_repository\')\n-    >>> tool.addPolicyForContentType(\'Folder\', u\'at_edit_autoversion\')\n-    >>> tool.addPolicyForContentType(\'Folder\', u\'version_on_revert\')\n-    >>> versionable_types = tool.getVersionableContentTypes()\n-    >>> versionable_types.append(\'Folder\')\n-    >>> tool.setVersionableContentTypes(versionable_types)\n-\n-Go to our folder and create a folder::\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.handleErrors = False\n-    >>> browser.addHeader(\'Authorization\',\n-    ...                   \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD))\n-    >>> browser.open(portal.absolute_url())\n-    >>> browser.getLink(\'Folder\').click()\n-    >>> browser.getControl(\'Title\').value = \'Foo Folder\'\n-    >>> browser.getControl(\'Save\').click()\n-    >>> \'Changes saved.\' in browser.contents\n-    True\n-\n-Add an item to the folder::\n-\n-    >>> browser.getLink(\'Foo Folder\').click()\n-    >>> browser.getLink(\'Page\').click()\n-    >>> browser.getControl(\'Title\').value = \'Bar Page\'\n-    >>> browser.getControl(\'Save\').click()\n-    >>> \'Changes saved.\' in browser.contents\n-    True\n-\n-Check out the folder::\n-\n-    >>> browser.getLink(\'Foo Folder\').click()\n-    >>> browser.getLink(\'Check out\').click()\n-    >>> \'form.button.Checkout\' in browser.contents\n-    True\n-    >>> browser.getControl(name=\'form.button.Checkout\').click()\n-    >>> \'This is a working copy\' in browser.contents\n-    True\n-    >>> wc_url = browser.url\n-    >>> wc_url\n-    \'http://nohost/plone/copy_of_foo-folder\'\n-\n-Add another item to the checked out copy::\n-\n-    >>> browser.getLink(url=\'Document\').click()\n-    >>> browser.getControl(\'Title\').value = \'Qux Page\'\n-    >>> browser.getControl(\'Save\').click()\n-    >>> \'Changes saved.\' in browser.contents\n-    True\n-\n-Now that we\'ve added another item, check the working copy in::\n-\n-    >>> browser.open(wc_url)\n-    >>> browser.open(browser.url + \'/@@content-checkin\')\n-    >>> browser.getControl(\'Check in\').click()\n-    >>> \'Checked in\' in browser.contents\n-    True\n-    >>> browser.url\n-    \'http://nohost/plone/foo-folder\'\n-    >>> browser.getLink(\'Qux Page\')\n-    <Link text=\'Qux Page\' url=\'http://nohost/plone/foo-folder/qux-page\'>\n-\n-Bugs\n-----\n-\n-The "Cancel check-out" action should not be present on items that are\n-not checked out (#8735)::\n-\n-    >>> browser.getLink("Cancel check-out")\n-    Traceback (most recent call last):\n-    ...\n-    LinkNotFoundError\n-\n-Some items, like the Plone site root, don\'t do references.  This broke\n-the condition for the "Cancel check-out" action on these items\n-(#8737)::\n-\n-    >>> z2.login(layer[\'app\'][\'acl_users\'], SITE_OWNER_NAME)\n-    >>> if \'front-page\' in portal:\n-    ...     portal.manage_delObjects([\'front-page\'])\n-    >>> browser.open(portal.absolute_url())\n-\n-Working copy workflows\n-----------------------\n-\n-It\'s possible to assign a different workflow to working copies in combination\n-with Products.CMFPlacefulWorkflow.  This usually makes sense: you should be\n-checking in a working copy rather than publishing it.\n-\n-We have a working copy workflow defined in our textfixture profile.  To enable\n-you need to set a couple of registry-entries::\n-\n-    >>> browser.addHeader(\'Authorization\',\n-    ...                   \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD))\n-    >>> browser.open("http://nohost/plone/portal_registry/edit/plone.app.iterate.interfaces.IIterateSettings.checkout_workflow_policy")\n-    >>> browser.getControl(name="form.widgets.value").value\n-    \'checkout_workflow_policy\'\n-    >>> browser.getControl(name="form.widgets.value").value = \'working-copy\'\n-    >>> browser.getControl(name="form.buttons.save").click()\n-    >>> browser.open("http://nohost/plone/portal_registry/edit/plone.app.iterate.interfaces.IIterateSettings.enable_checkout_workflow")\n-    >>> browser.getControl(name="form.widgets.value:list").value\n-    []\n-    >>> browser.getControl(name="form.widgets.value:list").controls[0].selected = True\n-    >>> browser.getControl(name="form.buttons.save").click()\n-\n-Create a new page to test workflows with::\n-\n-    >>> browser.open(portal.absolute_url())\n-    >>> browser.getLink(\'Add new\').click()\n-    >>> \'Add new item\' in browser.contents\n-    True\n-    >>> browser.getControl(\'Page\').click()\n-    >>> browser.getControl(\'Add\').click()\n-    >>> browser.getControl(\'Title\').value = \'My workflow test\'\n-    >>> browser.getControl(name=\'text\').value = \'My workflow test\'\n-    >>> browser.getControl(\'Save\').click()\n-    >>> \'Changes saved.\' in browser.contents\n-    True\n-    >>> workflow_test_url = browser.url\n-\n-Checkout::\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\', \'Basic contributor:secret\')\n-    >>> browser.open(workflow_test_url)\n-    >>> browser.getLink(id=\'plone-contentmenu-actions-iterate_checkout\').click()\n-    >>> browser.contents\n-    \'...Check out...My workflow test...\'\n-    >>> checkout_form = browser.getForm(name=\'checkout\')\n-    >>> checkout_form.getControl(\'Parent folder\').selected = True\n-    >>> checkout_form.getControl(\'Check out\').click()\n-    >>> browser.contents\n-    \'...This is a working copy of...My workflow test..., made by...contributor...\'\n-    >>> browser.contents\n-    \'...state-draft-copy...\'\n-    >>> workflow_checkout_url = browser.url\n-\n-Check get info message on original::\n-\n-    >>> browser.open(workflow_test_url)\n-    >>> browser.contents\n-    \'...This item is being edited by...contributor...a working copy...\'\n-\n-We\'re going to manually give the contributor user the CheckoutPermission\n-to check it\'s used when displaying the info messages.  In our workflow\n-once the checked out item is submitted the contributor no longer has\n-permission to modify it but we still want them to see the info messages::\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\',\n-    ...                   \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD))\n-\n-    >>> from plone.app.iterate.permissions import CheckoutPermission\n-    >>> browser.open(\'{0}/manage_permissionForm?permission_to_manage={1}\'.format(portal.absolute_url(), CheckoutPermission))\n-    >>> browser.getControl(name=\'roles:list\').value = browser.getControl(name=\'roles:list\').value + [\'Contributor\']\n-    >>> browser.getControl(\'Save Changes\').click()\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\', \'Basic contributor:secret\')\n-    >>> browser.open(workflow_checkout_url)\n-    >>> browser.getLink(id=\'workflow-transition-submit-copy-for-publication\')\\\n-    ...     .click()\n-    >>> browser.contents\n-    \'...state-pending-copy...\'\n-    >>> browser.contents\n-    \'...This is a working copy of...My workflow test..., made by...contributor...\'\n-    >>> browser.open(workflow_test_url)\n-    >>> browser.contents\n-    \'...This item is being edited by...contributor...a working copy...\'\n-\n-Check security permisions on workflow have been applied.  We remove copy or\n-move permissions in our workflow so this should not appear in the action menu.\n-http://code.google.com/p/dexterity/issues/detail?id=258 ::\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\', \'Basic editor:secret\')\n-    >>> browser.open(workflow_checkout_url)\n-    >>> browser.getLink(id=\'plone-contentmenu-actions-copy\')\n-    Traceback (most recent call last):\n-    ...\n-    LinkNotFoundError\n-    >>> browser.getLink(id=\'plone-contentmenu-actions-delete\')\n-    <Link text=\'Delete\' ...>\ndiff --git a/plone/app/iterate/tests/content.py b/plone/app/iterate/tests/content.py\ndeleted file mode 100644\nindex fcdeb44..0000000\n--- a/plone/app/iterate/tests/content.py\n+++ /dev/null\n@@ -1,36 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.folder.folder import ATFolder\n-from plone.app.folder.folder import ATFolderSchema\n-from Products.Archetypes import atapi\n-from Products.ATContentTypes.content.base import registerATCT\n-\n-\n-RichFolderSchema = ATFolderSchema.copy() + atapi.Schema(\n-    (\n-        atapi.TextField(\n-            "text",\n-            default_output_type="text/x-html-safe",\n-            widget=atapi.RichWidget(),\n-        ),\n-    )\n-)\n-\n-\n-class RichFolder(ATFolder):\n-    """ sample content type for testing purposes """\n-\n-    schema = RichFolderSchema\n-    portal_type = "RichFolder"\n-\n-\n-registerATCT(RichFolder, "plone.app.iterate")\n-\n-\n-def addRichFolder(container, id, **kwargs):\n-    """ at-constructor copied from ClassGen.py """\n-    obj = RichFolder(id)\n-    container._setObject(id, obj, suppress_events=True)\n-    obj = container._getOb(id)\n-    obj.manage_afterAdd(obj, container)\n-    obj.initializeArchetype(**kwargs)\n-    return obj.getId()\ndiff --git a/plone/app/iterate/tests/dexterity.rst b/plone/app/iterate/tests/dexterity.rst\nindex 2082ea0..2ef8281 100644\n--- a/plone/app/iterate/tests/dexterity.rst\n+++ b/plone/app/iterate/tests/dexterity.rst\n@@ -5,7 +5,7 @@ Tests for bugs that would distract from usage examples in stagingbehavior.txt\n \n If we access the site as an admin TTW::\n \n-    >>> from plone.testing.z2 import Browser\n+    >>> from plone.testing.zope import Browser\n     >>> browser = Browser(layer["app"])\n     >>> browser.handleErrors = False\n     >>> portal = layer["portal"]\ndiff --git a/plone/app/iterate/tests/test_doctests.py b/plone/app/iterate/tests/test_doctests.py\nindex cc6e435..e1308d7 100644\n--- a/plone/app/iterate/tests/test_doctests.py\n+++ b/plone/app/iterate/tests/test_doctests.py\n@@ -1,32 +1,13 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.iterate.testing import PLONEAPPITERATE_FUNCTIONAL_TESTING\n from plone.app.iterate.testing import PLONEAPPITERATEDEX_FUNCTIONAL_TESTING\n from plone.testing import layered\n from unittest import TestSuite\n-import doctest\n \n-try:\n-    import Products.ATContentTypes  # noqa\n-except ImportError:\n-    HAS_AT = False\n-else:\n-    HAS_AT = True\n+import doctest\n \n \n def test_suite():\n     suite = TestSuite()\n     OPTIONFLAGS = doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE\n-    if HAS_AT:\n-        suite.addTest(\n-            layered(\n-                doctest.DocFileSuite(\n-                    "browser.rst",\n-                    optionflags=OPTIONFLAGS,\n-                    package="plone.app.iterate.tests",\n-                ),\n-                layer=PLONEAPPITERATE_FUNCTIONAL_TESTING,\n-            )\n-        )\n     suite.addTest(\n         layered(\n             doctest.DocFileSuite(\ndiff --git a/plone/app/iterate/tests/test_iterate_at.py b/plone/app/iterate/tests/test_iterate_at.py\ndeleted file mode 100644\nindex f7cd5de..0000000\n--- a/plone/app/iterate/tests/test_iterate_at.py\n+++ /dev/null\n@@ -1,354 +0,0 @@\n-# -*- coding: utf-8 -*-\n-##################################################################\n-#\n-# (C) Copyright 2006 ObjectRealms, LLC\n-# All Rights Reserved\n-#\n-# This file is part of iterate.\n-#\n-# iterate is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2 of the License, or\n-# (at your option) any later version.\n-#\n-# iterate is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with iterate; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-##################################################################\n-\n-from AccessControl import getSecurityManager\n-from plone.app.iterate.browser.control import Control\n-from plone.app.iterate.interfaces import ICheckinCheckoutPolicy\n-from plone.app.iterate.testing import PLONEAPPITERATE_INTEGRATION_TESTING\n-from plone.app.testing import login\n-from plone.app.testing import setRoles\n-from plone.app.testing import TEST_USER_ID\n-from plone.app.testing import TEST_USER_NAME\n-from Products.CMFCore.utils import getToolByName\n-\n-import unittest\n-\n-try:\n-    from Products.Archetypes.ReferenceEngine import Reference\n-except ImportError:\n-    HAS_AT = False\n-else:\n-    HAS_AT = True\n-\n-    class CustomReference(Reference):\n-        pass\n-\n-\n-class TestIterations(unittest.TestCase):\n-\n-    layer = PLONEAPPITERATE_INTEGRATION_TESTING\n-\n-    def setUp(self):\n-        if not HAS_AT:\n-            raise unittest.SkipTest("Testing Archetypes support requires Archetypes")\n-\n-        self.portal = self.layer["portal"]\n-        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n-        login(self.portal, TEST_USER_NAME)\n-\n-        self.wf = self.portal.portal_workflow\n-        self.wf.setChainForPortalTypes(("Document",), "plone_workflow")\n-\n-        # add a folder with two documents in it\n-        self.portal.invokeFactory("Folder", "docs")\n-        self.portal.docs.invokeFactory("Document", "doc1")\n-        self.portal.docs.invokeFactory("Document", "doc2")\n-\n-        # add a working copy folder\n-        self.portal.invokeFactory("Folder", "workarea")\n-\n-        self.repo = self.portal.portal_repository\n-\n-    def test_workflowState(self):\n-        # ensure baseline workflow state is retained on checkin, including\n-        # security\n-\n-        doc = self.portal.docs.doc1\n-\n-        # sanity check that owner can edit visible docs\n-        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n-        self.assertTrue(\n-            getSecurityManager().checkPermission(\n-                "Modify portal content", self.portal.docs.doc1\n-            )\n-        )\n-\n-        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n-        self.wf.doActionFor(doc, "publish")\n-        state = self.wf.getInfoFor(doc, "review_state")\n-\n-        self.repo.save(doc)\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        wc_state = self.wf.getInfoFor(wc, "review_state")\n-\n-        self.assertNotEqual(state, wc_state)\n-\n-        ICheckinCheckoutPolicy(wc).checkin("modified")\n-        bstate = self.wf.getInfoFor(wc, "review_state")\n-        self.assertEqual(state, bstate)\n-        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n-\n-    def test_baselineVersionCreated(self):\n-        # if a baseline has no version ensure that one is created on checkout\n-\n-        doc = self.portal.docs.doc1\n-        self.assertTrue(self.repo.isVersionable(doc))\n-\n-        history = self.repo.getHistory(doc)\n-        self.assertEqual(len(history), 0)\n-\n-        ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-\n-        history = self.repo.getHistory(doc)\n-        self.assertEqual(len(history), 1)\n-\n-        doc2 = self.portal.docs.doc2\n-        self.repo.save(doc2)\n-\n-        ICheckinCheckoutPolicy(doc2).checkout(self.portal.workarea)\n-\n-        history = self.repo.getHistory(doc2)\n-        self.assertEqual(len(history), 1)\n-\n-    def test_wcNewForwardReferencesCopied(self):\n-        # ensure that new wc references are copied back to the baseline on\n-        # checkin\n-        doc = self.portal.docs.doc1\n-        doc.addReference(self.portal.docs)\n-        self.assertEqual(len(doc.getReferences("zebra")), 0)\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        wc.addReference(self.portal.docs.doc2, "zebra")\n-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-        self.assertEqual(len(doc.getReferences("zebra")), 1)\n-\n-    def test_wcNewBackwardReferencesCopied(self):\n-        # ensure that new wc back references are copied back to the baseline on\n-        # checkin\n-\n-        doc = self.portal.docs.doc1\n-        self.assertEqual(len(doc.getBackReferences("zebra")), 0)\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        self.portal.docs.doc2.addReference(wc, "zebra")\n-        self.assertEqual(len(wc.getBackReferences("zebra")), 1)\n-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-        self.assertEqual(len(doc.getBackReferences("zebra")), 1)\n-\n-    def test_baselineReferencesMaintained(self):\n-        # ensure that baseline references are maintained when the object is\n-        # checked in copies forward, bkw are not copied, but are maintained.\n-\n-        doc = self.portal.docs.doc1\n-        doc.addReference(self.portal.docs, "elephant")\n-        self.portal.docs.doc2.addReference(doc)\n-\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-\n-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-\n-        # TODO: This fails in Plone 4.1. The new optimized catalog lookups\n-        # in the reference catalog no longer filter out non-existing reference\n-        # objects. In both Plone 4.0 and 4.1 there\'s two references, one of\n-        # them is a stale catalog entry in the reference catalog. The real fix\n-        # is to figure out how the stale catalog entry gets in there\n-        self.assertEqual(len(doc.getReferences()), 1)\n-        self.assertEqual(len(doc.getBackReferences()), 1)\n-\n-    def test_baselineBrokenReferencesRemoved(self):\n-        # When the baseline has a reference to a deleted object, a\n-        # checkout should not fail with a ReferenceException.\n-\n-        doc = self.portal.docs.doc1\n-        doc.addReference(self.portal.docs.doc2, "pony")\n-        self.portal.docs._delOb("doc2")\n-        # _delOb is low level enough that the reference does not get cleaned\n-        # up.\n-        self.assertEqual(len(doc.getReferences()), 1)\n-\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        # The working copy has one reference: its original.\n-        self.assertEqual(len(wc.getReferences()), 1)\n-        self.assertEqual(wc.getReferences()[0].id, "doc1")\n-\n-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-        # The checkin removes the broken reference.\n-        self.assertEqual(len(doc.getReferences()), 0)\n-\n-    def test_baselineNoCopyReferences(self):\n-        # ensure that custom state is maintained with the no copy adapter\n-\n-        # setup the named ref adapter\n-        from zope import component\n-        from Products.Archetypes.interfaces import IBaseObject\n-        from plone.app.iterate import relation, interfaces\n-\n-        component.provideAdapter(\n-            adapts=(IBaseObject,),\n-            provides=interfaces.ICheckinCheckoutReference,\n-            factory=relation.NoCopyReferenceAdapter,\n-            name="zebra",\n-        )\n-\n-        doc = self.portal.docs.doc1\n-        ref = doc.addReference(\n-            self.portal.docs, "zebra", referenceClass=CustomReference\n-        )\n-        ref.custom_state = "hello world"\n-\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-\n-        self.assertEqual(len(wc.getReferences("zebra")), 0)\n-\n-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-\n-        self.assertEqual(len(doc.getReferences("zebra")), 1)\n-\n-        ref = doc.getReferenceImpl("zebra")[0]\n-\n-        self.assertTrue(hasattr(ref, "custom_state"))\n-        self.assertEqual(ref.custom_state, "hello world")\n-\n-    def test_folderOrder(self):\n-        """When an item is checked out and then back in, the original\n-        folder order is preserved."""\n-        container = self.portal.docs\n-        doc = container.doc1\n-        original_position = container.getObjectPosition(doc.getId())\n-\n-        # check that there is another document which could interact with\n-        # position of document the test work on\n-        doc2_position = container.getObjectPosition("doc2")\n-        self.assertTrue(doc2_position > original_position)\n-\n-        self.repo.save(doc)\n-        wc = ICheckinCheckoutPolicy(doc).checkout(container)\n-        wc.update(text="new document text")\n-\n-        # check that the copy is put after the second document\n-        copy_position = container.getObjectPosition(wc.getId())\n-        self.assertTrue(copy_position > doc2_position)\n-\n-        new_doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-        new_position = container.getObjectPosition(new_doc.getId())\n-        self.assertEqual(new_position, original_position)\n-\n-    def test_folderContents(self):\n-        """When an folder is checked out, and item is added, and then\n-        the folder is checked back in, the added item is in the new\n-        version of the folder.  UIDs of contained content are also\n-        preserved."""\n-        container = self.portal.docs\n-        folder = container[container.invokeFactory(type_name="Folder", id="foo-folder")]\n-        existing_doc = folder[\n-            folder.invokeFactory(type_name="Document", id="existing-folder-item")\n-        ]\n-        existing_doc_uid = existing_doc.UID()\n-\n-        self.repo.save(folder)\n-        wc = ICheckinCheckoutPolicy(folder).checkout(container)\n-        new_doc = wc[\n-            wc.invokeFactory(\n-                type_name="Document", id="new-folder-item", text="new folder item text"\n-            )\n-        ]\n-        new_doc_uid = new_doc.UID()\n-        new_folder = ICheckinCheckoutPolicy(wc).checkin("updated")\n-\n-        catalog = getToolByName(self.portal, "portal_catalog")\n-\n-        self.assertTrue("existing-folder-item" in new_folder)\n-        self.assertEqual(new_folder["existing-folder-item"].UID(), existing_doc_uid)\n-        self.assertTrue("new-folder-item" in new_folder)\n-        self.assertEqual(new_folder["new-folder-item"].UID(), new_doc_uid)\n-        brains = catalog(path="/".join(new_folder["new-folder-item"].getPhysicalPath()))\n-        self.assertTrue(brains)\n-        self.assertTrue(\n-            "new folder item text" in new_folder["new-folder-item"].getText()\n-        )\n-\n-    def test_checkinObjectLinkedInParentsRichTextField(self):\n-        """Checnking-in an object that is linked in it\'s\n-        parent\'s rich text field. See: https://dev.plone.org/ticket/13462\n-        """\n-        # create a folderish object with a rich text field\n-        from content import addRichFolder\n-\n-        addRichFolder(self.portal, "rich_text_folder")\n-        rich_text_folder = self.portal.rich_text_folder\n-\n-        # create the subobject\n-        rich_text_folder.invokeFactory("Document", "subobject")\n-        subobject = rich_text_folder.subobject\n-        subobject_uid = subobject.UID()\n-\n-        # link (by uid) the subobject in it\'s parent\'s rich text field\n-        link_html = (\n-            \'<a class="internal-link" href="resolveuid/{0}">\' "Link to subobject</a>"\n-        )\n-        rich_text_folder.setText(link_html.format(subobject_uid))\n-\n-        # try to checkout and checkin the subobject\n-        wc = ICheckinCheckoutPolicy(subobject).checkout(rich_text_folder)\n-        ICheckinCheckoutPolicy(wc).checkin("updated")\n-\n-        # everything went right and the working copy is checked in\n-        self.assertEqual(subobject_uid, wc.UID())\n-\n-    def test_default_page_is_kept_in_folder(self):\n-        # Ensure that a default page that is checked out and back in is still\n-        # the default page.\n-        folder = self.portal.docs\n-        doc = folder.doc1\n-        from Products.CMFDynamicViewFTI.interfaces import (\n-            ISelectableBrowserDefault,\n-        )  # noqa: C901\n-\n-        ISelectableBrowserDefault(folder).setDefaultPage("doc1")\n-        self.assertEqual(folder.getProperty("default_page", ""), "doc1")\n-        self.assertEqual(folder.getDefaultPage(), "doc1")\n-        # Note: when checking out to self.portal.workarea it surprisingly works\n-        # without changes.  But the default behavior in Plone is to check a\n-        # document out in its original folder, so that is what we check here.\n-        wc = ICheckinCheckoutPolicy(doc).checkout(folder)\n-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-        self.assertEqual(folder.getProperty("default_page", ""), "doc1")\n-        self.assertEqual(folder.getDefaultPage(), "doc1")\n-\n-    def test_control_checkin_allowed_with_no_policy(self):\n-        control = Control(self.portal, self.layer["request"])\n-        self.assertFalse(control.checkin_allowed())\n-\n-    def test_control_checkout_allowed_with_no_policy(self):\n-        control = Control(self.portal, self.layer["request"])\n-        self.assertFalse(control.checkout_allowed())\n-\n-    def test_control_cancel_allowed_with_no_policy(self):\n-        control = Control(self.portal, self.layer["request"])\n-        self.assertFalse(control.cancel_allowed())\n-\n-    def test_control_cancel_on_original_does_not_delete_original(self):\n-        # checkout document\n-        doc = self.portal.docs.doc1\n-        policy = ICheckinCheckoutPolicy(self.portal.docs.doc1, None)\n-        policy.checkout(self.portal.workarea)\n-\n-        # get cancel browser view\n-        from plone.app.iterate.browser.cancel import Cancel\n-\n-        cancel = Cancel(doc, self.layer["request"])\n-        self.layer["request"].form["form.button.Cancel"] = True\n-\n-        # check if cancel on original raises the correct exception\n-        from plone.app.iterate.interfaces import CheckoutException\n-\n-        with self.assertRaises(CheckoutException):\n-            cancel()\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2023-02-25T02:22:59+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.iterate/commit/9b39f51a41dc1f1e2363167669512d1ff0441bfd

Removed check and warning for plone.app.stagingbehavior.

Files changed:
M plone/app/iterate/__init__.py

b'diff --git a/plone/app/iterate/__init__.py b/plone/app/iterate/__init__.py\nindex 68c569b..100d0af 100644\n--- a/plone/app/iterate/__init__.py\n+++ b/plone/app/iterate/__init__.py\n@@ -40,15 +40,3 @@\n         "Dexterity support for iterate is not available. "\n         "You must install plone.app.relationfield"\n     )\n-\n-\n-try:\n-    import plone.app.stagingbehavior  # noqa\n-\n-    logger.error(\n-        "plone.app.stagingbehavior should NOT be installed with this version "\n-        "of plone.app.iterate. You may experience problems running this "\n-        "configuration. plone.app.iterate now has dexterity suport built-in."\n-    )\n-except ImportError:\n-    pass\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2023-02-25T02:24:35+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.iterate/commit/dad6f22def0cefd622c7ee16a783fde42440465e

Add news snippet.

Files changed:
A news/1.breaking

b'diff --git a/news/1.breaking b/news/1.breaking\nnew file mode 100644\nindex 0000000..2d0124d\n--- /dev/null\n+++ b/news/1.breaking\n@@ -0,0 +1,4 @@\n+Drop support for Plone 5.2, Python 2, Archetypes.\n+Removed check and warning for plone.app.stagingbehavior.\n+Version 5 is for Plone 6 only.\n+[maurits]\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2023-02-25T02:27:37+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.iterate/commit/e2f651e999dce3dee1fceca2b9987c108a2ec313

Nuke trailing white space.

Files changed:
M CHANGES.rst
M plone/app/iterate/browser/checkout.pt

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex de1f8da..6e1077e 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -98,7 +98,7 @@ Bug fixes:\n Bug fixes:\n \n \n-- Add missing i18n:translate calls \n+- Add missing i18n:translate calls\n   [erral] (#73)\n \n \ndiff --git a/plone/app/iterate/browser/checkout.pt b/plone/app/iterate/browser/checkout.pt\nindex b6abebd..2092a55 100644\n--- a/plone/app/iterate/browser/checkout.pt\n+++ b/plone/app/iterate/browser/checkout.pt\n@@ -7,7 +7,7 @@\n     i18n:domain="plone">\n <body>\n \n-<div id="content" metal:fill-slot="body" \n+<div id="content" metal:fill-slot="body"\n      tal:define="containers python:list(view.containers())">\n \n     <form action="#"\n@@ -26,8 +26,8 @@\n     </p>\n \n     <tal:one_container tal:condition="python:len(containers)==1">\n-    <input \n-        type="hidden" \n+    <input\n+        type="hidden"\n         name="checkout_location"\n         tal:define = "item python:containers[0]"\n         tal:attributes="id string:checkout_location_${item/name};\n@@ -36,7 +36,7 @@\n     </tal:one_container>\n \n     <fieldset tal:condition="python:len(containers)!=1">\n-        \n+\n         <legend i18n:translate="legend_details">Details</legend>\n \n             <div class="field">\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2023-02-25T09:50:21+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.iterate/commit/ac4f353d8798d2599e0d674e8d70403c7b630c6c

Merge pull request #104 from plone/maurits-drop-52

Drop support for Plone 5.2, Python 2, Archetypes.

Files changed:
A news/1.breaking
M CHANGES.rst
M plone/app/iterate/__init__.py
M plone/app/iterate/browser/checkout.pt
M plone/app/iterate/configure.zcml
M plone/app/iterate/interfaces.py
M plone/app/iterate/testing.py
M plone/app/iterate/tests/dexterity.rst
M plone/app/iterate/tests/test_doctests.py
M plone/app/iterate/util.py
M setup.py
D plone/app/iterate/at.zcml
D plone/app/iterate/copier.py
D plone/app/iterate/policy.py
D plone/app/iterate/relation.py
D plone/app/iterate/tests/browser.rst
D plone/app/iterate/tests/content.py
D plone/app/iterate/tests/test_iterate_at.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex de1f8da..6e1077e 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -98,7 +98,7 @@ Bug fixes:\n Bug fixes:\n \n \n-- Add missing i18n:translate calls \n+- Add missing i18n:translate calls\n   [erral] (#73)\n \n \ndiff --git a/news/1.breaking b/news/1.breaking\nnew file mode 100644\nindex 0000000..2d0124d\n--- /dev/null\n+++ b/news/1.breaking\n@@ -0,0 +1,4 @@\n+Drop support for Plone 5.2, Python 2, Archetypes.\n+Removed check and warning for plone.app.stagingbehavior.\n+Version 5 is for Plone 6 only.\n+[maurits]\ndiff --git a/plone/app/iterate/__init__.py b/plone/app/iterate/__init__.py\nindex 68c569b..100d0af 100644\n--- a/plone/app/iterate/__init__.py\n+++ b/plone/app/iterate/__init__.py\n@@ -40,15 +40,3 @@\n         "Dexterity support for iterate is not available. "\n         "You must install plone.app.relationfield"\n     )\n-\n-\n-try:\n-    import plone.app.stagingbehavior  # noqa\n-\n-    logger.error(\n-        "plone.app.stagingbehavior should NOT be installed with this version "\n-        "of plone.app.iterate. You may experience problems running this "\n-        "configuration. plone.app.iterate now has dexterity suport built-in."\n-    )\n-except ImportError:\n-    pass\ndiff --git a/plone/app/iterate/at.zcml b/plone/app/iterate/at.zcml\ndeleted file mode 100644\nindex e6b938f..0000000\n--- a/plone/app/iterate/at.zcml\n+++ /dev/null\n@@ -1,15 +0,0 @@\n-<configure\n-    xmlns="http://namespaces.zope.org/zope"\n-    xmlns:five="http://namespaces.zope.org/five"\n-    xmlns:zcml="http://namespaces.zope.org/zcml"\n-    i18n_domain="plone">\n-\n-  <class class="Products.Archetypes.BaseObject.BaseObject">\n-      <implements interface=".interfaces.IIterateAware" />\n-  </class>\n-\n-  <adapter factory=".relation.CheckinCheckoutReferenceAdapter"/>\n-  <adapter factory=".policy.CheckinCheckoutPolicyAdapter" />\n-  <adapter factory=".copier.ContentCopier" />\n-\n-</configure>\n\\ No newline at end of file\ndiff --git a/plone/app/iterate/browser/checkout.pt b/plone/app/iterate/browser/checkout.pt\nindex b6abebd..2092a55 100644\n--- a/plone/app/iterate/browser/checkout.pt\n+++ b/plone/app/iterate/browser/checkout.pt\n@@ -7,7 +7,7 @@\n     i18n:domain="plone">\n <body>\n \n-<div id="content" metal:fill-slot="body" \n+<div id="content" metal:fill-slot="body"\n      tal:define="containers python:list(view.containers())">\n \n     <form action="#"\n@@ -26,8 +26,8 @@\n     </p>\n \n     <tal:one_container tal:condition="python:len(containers)==1">\n-    <input \n-        type="hidden" \n+    <input\n+        type="hidden"\n         name="checkout_location"\n         tal:define = "item python:containers[0]"\n         tal:attributes="id string:checkout_location_${item/name};\n@@ -36,7 +36,7 @@\n     </tal:one_container>\n \n     <fieldset tal:condition="python:len(containers)!=1">\n-        \n+\n         <legend i18n:translate="legend_details">Details</legend>\n \n             <div class="field">\ndiff --git a/plone/app/iterate/configure.zcml b/plone/app/iterate/configure.zcml\nindex 6b64a41..a788755 100644\n--- a/plone/app/iterate/configure.zcml\n+++ b/plone/app/iterate/configure.zcml\n@@ -117,6 +117,5 @@\n     />\n \n   <include package=".dexterity" zcml:condition="installed plone.app.relationfield" />\n-  <include file="at.zcml" zcml:condition="installed Products.Archetypes.BaseObject" />\n \n </configure>\ndiff --git a/plone/app/iterate/copier.py b/plone/app/iterate/copier.py\ndeleted file mode 100644\nindex 3fec074..0000000\n--- a/plone/app/iterate/copier.py\n+++ /dev/null\n@@ -1,232 +0,0 @@\n-# -*- coding: utf-8 -*-\n-##################################################################\n-#\n-# (C) Copyright 2006-2007 ObjectRealms, LLC\n-# All Rights Reserved\n-#\n-# This file is part of iterate.\n-#\n-# iterate is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2 of the License, or\n-# (at your option) any later version.\n-#\n-# iterate is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with CMFDeployment; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-##################################################################\n-\n-"""\n-Archtypes specific copier, dexterity folder has its own!\n-"""\n-\n-from Acquisition import aq_base\n-from Acquisition import aq_inner\n-from Acquisition import aq_parent\n-from plone.app.iterate import interfaces\n-from plone.app.iterate.base import BaseContentCopier\n-from plone.app.iterate.interfaces import CheckinException\n-from Products.Archetypes.Referenceable import Referenceable\n-from Products.CMFCore.utils import getToolByName\n-from Products.DCWorkflow.DCWorkflow import DCWorkflowDefinition\n-from .relation import WorkingCopyRelation\n-from ZODB.PersistentMapping import PersistentMapping\n-from zope import component\n-from zope import interface\n-from zope.annotation.interfaces import IAnnotations\n-from zope.event import notify\n-from zope.lifecycleevent import ObjectMovedEvent\n-\n-\n-@interface.implementer(interfaces.IObjectCopier)\n-@component.adapter(interfaces.IIterateAware)\n-class ContentCopier(BaseContentCopier):\n-    """ Content copier for Archetypes """\n-\n-    def copyTo(self, container):\n-        wc = self._copyBaseline(container)\n-        wc_ref = wc.addReference(\n-            self.context,\n-            relationship=WorkingCopyRelation.relationship,\n-            referenceClass=WorkingCopyRelation,\n-        )\n-        self._handleReferences(self.context, wc, "checkout", wc_ref)\n-        return wc, wc_ref\n-\n-    def merge(self):\n-        baseline = self._getBaseline()\n-\n-        # delete the working copy reference to the baseline\n-        wc_ref = self._deleteWorkingCopyRelation()\n-\n-        # reassemble references on the new baseline\n-        self._handleReferences(baseline, self.context, "checkin", wc_ref)\n-\n-        # move the working copy to the baseline container, deleting\n-        # the baseline\n-        new_baseline = self._replaceBaseline(baseline)\n-\n-        # patch the working copy with baseline info not preserved\n-        # during checkout\n-        self._reassembleWorkingCopy(new_baseline, baseline)\n-\n-        return new_baseline\n-\n-    def _getBaseline(self):\n-        # follow the working copy\'s reference back to the baseline\n-        refs = self.context.getRefs(WorkingCopyRelation.relationship)\n-\n-        if not len(refs) == 1:\n-            raise CheckinException("Baseline count mismatch")\n-\n-        if not refs or refs[0] is None:\n-            raise CheckinException("Baseline has disappeared")\n-\n-        baseline = refs[0]\n-        return baseline\n-\n-    def _replaceBaseline(self, baseline):\n-        # move the working copy object to the baseline, returns the\n-        # new baseline\n-        baseline_id = baseline.getId()\n-\n-        # delete the baseline from the folder to make room for the\n-        # committed working copy\n-        baseline_container = aq_parent(aq_inner(baseline))\n-        # Check if we are a default_page, because this property of the\n-        # container might get lost.\n-        is_default_page = (\n-            baseline_container.getProperty("default_page", "") == baseline_id\n-        )\n-        baseline_pos = baseline_container.getObjectPosition(baseline_id)\n-        baseline_container._delOb(baseline_id)\n-\n-        # uninedxing the deleted baseline object from portal_catalog\n-        portal_catalog = getToolByName(self.context, "portal_catalog")\n-        portal_catalog.unindexObject(baseline)\n-\n-        # delete the working copy from the its container\n-        wc_container = aq_parent(aq_inner(self.context))\n-\n-        # trick out the at machinery to not delete references\n-        self.context._v_cp_refs = 1\n-        self.context._v_is_cp = 0\n-\n-        wc_id = self.context.getId()\n-        wc_container.manage_delObjects([wc_id])\n-\n-        # move the working copy back to the baseline container\n-        working_copy = aq_base(self.context)\n-        working_copy.setId(baseline_id)\n-        baseline_container._setOb(baseline_id, working_copy)\n-        baseline_container.moveObjectToPosition(baseline_id, baseline_pos)\n-\n-        new_baseline = baseline_container._getOb(baseline_id)\n-        if is_default_page:\n-            # Restore default_page to container.  Note that the property might\n-            # have been removed by an event handler in the mean time.\n-            if baseline_container.hasProperty("default_page"):\n-                baseline_container._updateProperty("default_page", baseline_id)\n-            else:\n-                baseline_container._setProperty("default_page", baseline_id)\n-\n-        # reregister our references with the reference machinery after moving\n-        Referenceable.manage_afterAdd(new_baseline, new_baseline, baseline_container)\n-\n-        notify(\n-            ObjectMovedEvent(\n-                new_baseline, wc_container, wc_id, baseline_container, baseline_id\n-            )\n-        )\n-\n-        return new_baseline\n-\n-    def _reassembleWorkingCopy(self, new_baseline, baseline):\n-        # reattach the source\'s workflow history, try avoid a dangling ref\n-        try:\n-            new_baseline.workflow_history = PersistentMapping(\n-                baseline.workflow_history.items()\n-            )\n-        except AttributeError:\n-            # No workflow apparently.  Oh well.\n-            pass\n-\n-        # reset wf state security directly\n-        workflow_tool = getToolByName(self.context, "portal_workflow")\n-        wfs = workflow_tool.getWorkflowsFor(self.context)\n-        for wf in wfs:\n-            if not isinstance(wf, DCWorkflowDefinition):\n-                continue\n-            wf.updateRoleMappingsFor(new_baseline)\n-\n-        # Reattach the source\'s uid, this will update wc refs to point\n-        # back to the new baseline.  This may introduce duplicate\n-        # references, so we check that and fix them.\n-        self._recursivelyReattachUIDs(baseline, new_baseline)\n-\n-        # reattach the source\'s history id, to get the previous\n-        # version ancestry\n-        histid_handler = getToolByName(self.context, "portal_historyidhandler")\n-        huid = histid_handler.getUid(baseline)\n-        histid_handler.setUid(new_baseline, huid, check_uniqueness=False)\n-\n-        return new_baseline\n-\n-    def _deleteWorkingCopyRelation(self):\n-        # delete the wc reference keeping a reference to it for its annotations\n-        refs = self.context.getReferenceImpl(WorkingCopyRelation.relationship)\n-        wc_ref = refs[0]\n-        self.context.deleteReferences(WorkingCopyRelation.relationship)\n-        return wc_ref\n-\n-    #################################\n-    # Checkout Support Methods\n-\n-    def _handleReferences(self, baseline, wc, mode, wc_ref):\n-\n-        annotations = IAnnotations(wc_ref)\n-\n-        baseline_adapter = interfaces.ICheckinCheckoutReference(baseline)\n-\n-        # handle forward references\n-        for relationship in baseline.getRelationships():\n-            if relationship is None:\n-                adapter = None\n-            else:\n-                # look for a named relation adapter first\n-                adapter = component.queryAdapter(\n-                    baseline, interfaces.ICheckinCheckoutReference, relationship\n-                )\n-\n-            if adapter is None:  # default\n-                adapter = baseline_adapter\n-\n-            references = baseline.getReferenceImpl(relationship)\n-\n-            mode_method = getattr(adapter, mode)\n-            mode_method(baseline, wc, references, annotations)\n-\n-        mode = mode + "BackReferences"\n-\n-        # handle backward references\n-        for relationship in baseline.getBRelationships():\n-            if relationship is None:\n-                adapter = None\n-            else:\n-                # look for a named relation adapter first\n-                adapter = component.queryAdapter(\n-                    baseline, interfaces.ICheckinCheckoutReference, relationship\n-                )\n-\n-            if adapter is None:\n-                adapter = baseline_adapter\n-\n-            references = baseline.getBackReferenceImpl(relationship)\n-\n-            mode_method = getattr(adapter, mode)\n-            mode_method(baseline, wc, references, annotations)\ndiff --git a/plone/app/iterate/interfaces.py b/plone/app/iterate/interfaces.py\nindex d63b42a..120fee7 100644\n--- a/plone/app/iterate/interfaces.py\n+++ b/plone/app/iterate/interfaces.py\n@@ -35,16 +35,8 @@\n import pkg_resources\n \n \n-try:\n-    pkg_resources.get_distribution("Products.Archetypes")\n-except pkg_resources.DistributionNotFound:\n-\n-    class IReference(Interface):\n-        pass\n-\n-\n-else:\n-    from Products.Archetypes.interfaces import IReference\n+class IReference(Interface):\n+    pass\n \n \n ################################\n@@ -103,7 +95,7 @@ class ICheckinEvent(IObjectEvent):\n     """\n \n     baseline = Attribute("The Working Copy\'s baseline")\n-    relation = Attribute("The Working Copy Archetypes Relation Object")\n+    relation = Attribute("The Working Copy Relation Object")\n     checkin_message = Attribute("checkin message")\n \n \n@@ -121,7 +113,7 @@ class ICheckoutEvent(IObjectEvent):\n     """ an object is being checked out, event.object is the baseline """\n \n     working_copy = Attribute("The object\'s working copy")\n-    relation = Attribute("The Working Copy Archetypes Relation Object")\n+    relation = Attribute("The Working Copy Relation Object")\n \n \n class ICancelCheckoutEvent(IObjectEvent):\n@@ -139,7 +131,7 @@ class IWorkingCopyDeletedEvent(IObjectEvent):\n     """\n \n     baseline = Attribute("The working copy baseline")\n-    relation = Attribute("The Working Copy Archetypes Relation Object")\n+    relation = Attribute("The Working Copy Relation Object")\n \n \n #################################\ndiff --git a/plone/app/iterate/policy.py b/plone/app/iterate/policy.py\ndeleted file mode 100644\nindex e2f536d..0000000\n--- a/plone/app/iterate/policy.py\n+++ /dev/null\n@@ -1,103 +0,0 @@\n-# -*- coding: utf-8 -*-\n-##################################################################\n-#\n-# (C) Copyright 2006-2007 ObjectRealms, LLC\n-# All Rights Reserved\n-#\n-# This file is part of iterate.\n-#\n-# iterate is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2 of the License, or\n-# (at your option) any later version.\n-#\n-# iterate is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with CMFDeployment; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-##################################################################\n-"""\n-Archetypes Checkin Checkout Policy For Content\n-\n-"""\n-from plone.app.iterate.base import CheckinCheckoutBasePolicyAdapter\n-from plone.app.iterate.event import AfterCheckinEvent\n-from plone.app.iterate.event import CheckinEvent\n-from plone.app.iterate.interfaces import CheckinException\n-from plone.app.iterate.interfaces import IIterateAware\n-from plone.app.iterate.interfaces import IObjectCopier\n-from plone.app.iterate.relation import WorkingCopyRelation\n-from plone.app.iterate.util import get_storage\n-from Products.Archetypes.interfaces import IReferenceable\n-from zope.component import adapter\n-from zope.component import queryAdapter\n-from zope.event import notify\n-\n-\n-@adapter(IIterateAware)\n-class CheckinCheckoutPolicyAdapter(CheckinCheckoutBasePolicyAdapter):\n-    """Checkin Checkout Policy For Archetypes Content\n-\n-    - on checkout context is the baseline\n-    - on checkin context is the working copy.\n-    """\n-\n-    def checkin(self, checkin_message):\n-        # see interface\n-\n-        # get the baseline for this working copy, raise if not found\n-        baseline = self._getBaseline()\n-\n-        # get a hold of the relation object\n-        wc_ref = self.context.getReferenceImpl(WorkingCopyRelation.relationship)[0]\n-\n-        # publish the event for subscribers, early because contexts are about\n-        # to be manipulated\n-        notify(CheckinEvent(self.context, baseline, wc_ref, checkin_message))\n-\n-        # merge the object back to the baseline with a copier\n-\n-        # XXX by gotcha\n-        # bug we should or use a getAdapter call or test if copier is None\n-        copier = queryAdapter(self.context, IObjectCopier)\n-        new_baseline = copier.merge()\n-\n-        # don\'t need to unlock the lock disappears with old baseline deletion\n-        notify(AfterCheckinEvent(new_baseline, checkin_message))\n-\n-        return new_baseline\n-\n-    #################################\n-    #  Checkin Support Methods\n-\n-    def _getBaseline(self):\n-        # follow the working copy\'s reference back to the baseline\n-        refs = self.context.getReferences(WorkingCopyRelation.relationship)\n-\n-        if not len(refs) == 1:\n-            raise CheckinException("Baseline count mismatch")\n-\n-        if not refs or refs[0] is None:\n-            raise CheckinException("Baseline has disappeared")\n-\n-        baseline = refs[0]\n-        return baseline\n-\n-    def getBaseline(self):\n-        if IReferenceable.providedBy(self.context):\n-            refs = self.context.getReferences(WorkingCopyRelation.relationship)\n-            if refs:\n-                return refs[0]\n-\n-    def getWorkingCopy(self):\n-        if IReferenceable.providedBy(self.context):\n-            refs = self.context.getBRefs(WorkingCopyRelation.relationship)\n-            if refs:\n-                return refs[0]\n-\n-    def getProperties(self, obj, default=None):\n-        return get_storage(obj, default=default)\ndiff --git a/plone/app/iterate/relation.py b/plone/app/iterate/relation.py\ndeleted file mode 100644\nindex dd3ada7..0000000\n--- a/plone/app/iterate/relation.py\n+++ /dev/null\n@@ -1,138 +0,0 @@\n-# -*- coding: utf-8 -*-\n-##################################################################\n-#\n-# (C) Copyright 2006 ObjectRealms, LLC\n-# All Rights Reserved\n-#\n-# This file is part of iterate.\n-#\n-# iterate is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2 of the License, or\n-# (at your option) any later version.\n-#\n-# iterate is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with CMFDeployment; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-##################################################################\n-"""\n-Archetypes speicifc implementation for relation handling\n-"""\n-\n-from .interfaces import ICheckinCheckoutReference\n-from .interfaces import IIterateAware\n-from .interfaces import IWorkingCopyRelation\n-from Products.Archetypes import config as atconf\n-from Products.Archetypes.exceptions import ReferenceException\n-from Products.Archetypes.ReferenceEngine import Reference\n-from zope.annotation.interfaces import IAttributeAnnotatable\n-from zope.component import adapter\n-from zope.interface import implementer\n-\n-import logging\n-\n-\n-logger = logging.getLogger("plone.app.iterate")\n-\n-\n-@implementer(IWorkingCopyRelation, IAttributeAnnotatable)\n-class WorkingCopyRelation(Reference):\n-    """\n-    Source Object is Working Copy\n-\n-    Target Object is Baseline Version\n-    """\n-\n-    relationship = "Working Copy Relation"\n-\n-\n-@implementer(ICheckinCheckoutReference)\n-@adapter(IIterateAware)\n-class CheckinCheckoutReferenceAdapter(object):\n-    """\n-    default adapter for references.\n-\n-    on checkout\n-\n-    forward refs on baseline are copied to wc\n-    backward refs on baseline are ignored on wc\n-\n-    on checkin\n-\n-    forward refs on wc are kept\n-    backwards refs on wc are kept\n-\n-    forward refs on baseline get removed\n-    backward refs on baseline are kept by virtue of UID transferance\n-\n-    """\n-\n-    storage_key = "coci.references"\n-\n-    def __init__(self, context):\n-        self.context = context\n-\n-    def checkout(self, baseline, wc, refs, storage):\n-        for ref in refs:\n-            try:\n-                wc.addReference(\n-                    ref.targetUID, ref.relationship, referenceClass=ref.__class__\n-                )\n-            except ReferenceException:\n-                logger.warn(\n-                    "Reference exception when adding relation %r "\n-                    "from new working copy %s to uid %s. Ignoring relation.",\n-                    ref.relationship,\n-                    "/".join(wc.getPhysicalPath()),\n-                    ref.targetUID,\n-                )\n-\n-    def checkin(self, *args):\n-        pass\n-\n-    checkoutBackReferences = checkinBackReferences = checkin\n-\n-\n-@implementer(ICheckinCheckoutReference)\n-class NoCopyReferenceAdapter(object):\n-    """\n-    an adapter for references that does not copy them to the wc on checkout.\n-\n-    additionally custom reference state is kept when the wc is checked in.\n-    """\n-\n-    def __init__(self, context):\n-        self.context = context\n-\n-    def checkin(self, baseline, wc, refs, storage):\n-        # move the references from the baseline to the wc\n-\n-        # one note, on checkin the wc uid is not yet changed to match that of\n-        # the baseline\n-        ref_ids = [r.getId() for r in refs]\n-\n-        baseline_ref_container = getattr(baseline, atconf.REFERENCE_ANNOTATION)\n-        clipboard = baseline_ref_container.manage_cutObjects(ref_ids)\n-\n-        wc_ref_container = getattr(wc, atconf.REFERENCE_ANNOTATION)\n-\n-        # references aren\'t globally addable w/ associated perm which default\n-        # copysupport wants to check, temporarily monkey around the issue.\n-        def _verifyObjectPaste(*args, **kw):\n-            pass\n-\n-        wc_ref_container._verifyObjectPaste = _verifyObjectPaste\n-        try:\n-            wc_ref_container.manage_pasteObjects(clipboard)\n-        finally:\n-            del wc_ref_container._verifyObjectPaste\n-\n-    def checkout(self, *args):\n-        pass\n-\n-    checkoutBackReferences = checkinBackReferences = checkout\ndiff --git a/plone/app/iterate/testing.py b/plone/app/iterate/testing.py\nindex 73c27fb..1a40805 100644\n--- a/plone/app/iterate/testing.py\n+++ b/plone/app/iterate/testing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """Testing setup for integration and functional tests."""\n from plone.app.contenttypes.testing import PloneAppContenttypes\n from plone.app.testing import applyProfile\n@@ -6,17 +5,6 @@\n from plone.app.testing import PloneSandboxLayer\n from plone.app.testing.layers import FunctionalTesting\n from plone.app.testing.layers import IntegrationTesting\n-from plone.testing import z2\n-\n-import pkg_resources\n-\n-\n-try:\n-    pkg_resources.get_distribution("Products.Archetypes")\n-except pkg_resources.DistributionNotFound:\n-    HAS_AT = False\n-else:\n-    HAS_AT = True\n \n \n ADMIN = {\n@@ -45,91 +33,6 @@\n )\n \n \n-class PloneAppIterateLayer(PloneSandboxLayer):\n-    """Plone Sandbox Layer for plone.app.iterate."""\n-\n-    defaultBases = (PLONE_FIXTURE,)\n-\n-    def setUpZope(self, app, configurationContext):\n-        """Setup Zope with Addons."""\n-        if not HAS_AT:\n-            return\n-\n-        import Products.ATContentTypes\n-\n-        self.loadZCML(package=Products.ATContentTypes)\n-        z2.installProduct(app, "Products.ATContentTypes")\n-\n-        z2.installProduct(app, "Products.Archetypes")\n-        z2.installProduct(app, "Products.ATContentTypes")\n-        z2.installProduct(app, "plone.app.blob")\n-        z2.installProduct(app, "plone.app.collection")\n-\n-        import plone.app.iterate\n-\n-        self.loadZCML(package=plone.app.iterate)\n-\n-    def setUpPloneSite(self, portal):\n-        """Setup Plone Site with Addons."""\n-        if not HAS_AT:\n-            return\n-\n-        # restore default workflow\n-        applyProfile(portal, "Products.CMFPlone:testfixture")\n-\n-        # add default content\n-        applyProfile(portal, "Products.ATContentTypes:content")\n-        applyProfile(portal, "plone.app.iterate:default")\n-        applyProfile(portal, "plone.app.iterate:test")\n-\n-        for user in USERS_TO_BE_ADDED:\n-            portal.portal_membership.addMember(\n-                user["id"],\n-                user["password"],\n-                user["roles"],\n-                [],\n-            )\n-\n-        for user in USERS_WITH_MEMBER_FOLDER:\n-            mtool = portal.portal_membership\n-            if not mtool.getMemberareaCreationFlag():\n-                mtool.setMemberareaCreationFlag()\n-                mtool.createMemberArea(user["id"])\n-\n-            if mtool.getMemberareaCreationFlag():\n-                mtool.setMemberareaCreationFlag()\n-\n-        portal.portal_workflow.setChainForPortalTypes(\n-            ("Document",),\n-            "plone_workflow",\n-        )\n-\n-        # Turn on versioning for folders\n-        portal_repository = portal.portal_repository\n-        portal_repository.addPolicyForContentType(\n-            "Folder",\n-            u"at_edit_autoversion",\n-        )\n-        portal_repository.addPolicyForContentType(\n-            "Folder",\n-            u"version_on_revert",\n-        )\n-        versionable_types = portal_repository.getVersionableContentTypes()\n-        versionable_types.append("Folder")\n-        portal_repository.setVersionableContentTypes(versionable_types)\n-\n-\n-PLONEAPPITERATE_FIXTURE = PloneAppIterateLayer()\n-\n-PLONEAPPITERATE_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(PLONEAPPITERATE_FIXTURE,), name="PloneAppIterateLayer:Integration"\n-)\n-\n-PLONEAPPITERATE_FUNCTIONAL_TESTING = FunctionalTesting(\n-    bases=(PLONEAPPITERATE_FIXTURE,), name="PloneAppIterateLayer:Functional"\n-)\n-\n-\n class DexPloneAppIterateLayer(PloneAppContenttypes):\n     """Dexterity based Plone Sandbox Layer for plone.app.iterate."""\n \ndiff --git a/plone/app/iterate/tests/browser.rst b/plone/app/iterate/tests/browser.rst\ndeleted file mode 100644\nindex 95098c5..0000000\n--- a/plone/app/iterate/tests/browser.rst\n+++ /dev/null\n@@ -1,324 +0,0 @@\n-Setup\n------\n-\n-    >>> from plone.testing import z2\n-    >>> from plone.app.testing import login\n-    >>> from plone.app.testing import SITE_OWNER_NAME\n-    >>> from plone.app.testing import SITE_OWNER_PASSWORD\n-\n-    >>> portal = layer[\'portal\']\n-    >>> app = layer[\'app\']\n-    >>> portal_url = portal.absolute_url()\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.handleErrors = False\n-    >>> browser.addHeader(\'Authorization\',\n-    ...                   \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD))\n-\n-Create a document\n------------------\n-\n-Go to our folder and create a document::\n-\n-    >>> browser.open(portal.absolute_url())\n-    >>> browser.getLink(\'Add new\').click()\n-    >>> \'Add new item\' in browser.contents\n-    True\n-    >>> browser.getControl(\'Page\').click()\n-    >>> browser.getControl(\'Add\').click()\n-    >>> browser.getControl(\'Title\').value = \'Hello, World!\'\n-    >>> browser.getControl(name=\'text\').value = \'Hello, World!\'\n-    >>> browser.getControl(\'Save\').click()\n-    >>> \'Changes saved.\' in browser.contents\n-    True\n-\n-Check it out\n-------------\n-\n-Let\'s check out the document.  For this, we\'ll go to the *Check out*\n-form directly.  From there, we\'ll check out to the parent folder::\n-\n-    >>> browser.getLink(\'Check out\').click()\n-    >>> \'form.button.Checkout\' in browser.contents\n-    True\n-    >>> browser.getControl(name=\'form.button.Checkout\').click()\n-    >>> \'This is a working copy\' in browser.contents\n-    True\n-    >>> browser.url\n-    \'http://nohost/plone/copy_of_hello-world\'\n-\n-When viewing the original document, we should see a note that\n-someone\'s working on a working copy::\n-\n-    >>> browser.open(\'http://nohost/plone/hello-world\')\n-    >>> \'This item is being edited\' in browser.contents\n-    True\n-\n-We\'ll now edit the working copy and save it::\n-\n-    >>> browser.open(\'http://nohost/plone/copy_of_hello-world\')\n-    >>> browser.getLink(\'Edit\').click()\n-    >>> browser.getControl(\'Title\').value = \'Hello, World! version 2.0\'\n-    >>> browser.getControl(\'Save\').click()\n-    >>> \'Changes saved.\' in browser.contents\n-    True\n-    >>> \'http://nohost/plone/copy_of_hello-world\' in browser.url\n-    True\n-\n-Check it in\n------------\n-\n-Now that we\'ve made our changes we\'ll check the working copy in::\n-\n-    >>> browser.getLink(\'Check in\').click()\n-    >>> browser.getControl(\'Check in\').click()\n-    >>> \'Checked in\' in browser.contents\n-    True\n-    >>> browser.url\n-    \'http://nohost/plone/hello-world\'\n-    >>> \'Hello, World! version 2.0\' in browser.contents\n-    True\n-\n-Permissions\n------------\n-\n-For the community workflow, we expect Editors and Contributors to be able to\n-check out published pages::\n-\n-    >>> portal.portal_workflow.setDefaultChain(\'plone_workflow\')\n-    >>> ignore = portal.portal_workflow.updateRoleMappings()\n-    >>> browser.getLink("Publish").click()\n-    >>> "Item state changed" in browser.contents\n-    True\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\', \'Basic editor:secret\')\n-\n-    >>> browser.open(portal.absolute_url() + \'/hello-world\')\n-    >>> browser.getLink("Check out").click()\n-    >>> \'form.button.Checkout\' in browser.contents\n-    True\n-    >>> browser.getControl(name=\'form.button.Checkout\').click()\n-    >>> "Check-out created" in browser.contents\n-    True\n-\n-They should not, however, be able to check in their working copy\n-again.  That\'s because the item is in the ``published`` state and\n-therefore our Editor lacks permissions to modify the original::\n-\n-    >>> browser.getLink("Cancel check-out")\n-    <Link ...>\n-    >>> browser.getLink("Check in")\n-    Traceback (most recent call last):\n-    ...\n-    LinkNotFoundError\n-\n-The Editor could, however, ask someone to retract the original so he\n-gains permissions again and check in (and then possibly request for\n-review)::\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\',\n-    ...                   \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD))\n-    >>> browser.open(portal.absolute_url() + \'/hello-world\')\n-    >>> browser.getLink("Published").click()\n-    >>> browser.getControl("Retract").click()\n-    >>> browser.getControl("Save").click()\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\', \'Basic editor:secret\')\n-    >>> browser.open(portal.absolute_url() + \'/hello-world\')\n-    >>> browser.getLink("working copy").click()\n-    >>> browser.getLink("Check in").click()\n-    >>> browser.getControl("Check in").click()\n-    >>> "Checked in" in browser.contents\n-    True\n-\n-Folders\n--------\n-\n-Turn on versioning for folders::\n-\n-    >>> from Products.CMFCore.utils import getToolByName\n-    >>> tool = getToolByName(portal, \'portal_repository\')\n-    >>> tool.addPolicyForContentType(\'Folder\', u\'at_edit_autoversion\')\n-    >>> tool.addPolicyForContentType(\'Folder\', u\'version_on_revert\')\n-    >>> versionable_types = tool.getVersionableContentTypes()\n-    >>> versionable_types.append(\'Folder\')\n-    >>> tool.setVersionableContentTypes(versionable_types)\n-\n-Go to our folder and create a folder::\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.handleErrors = False\n-    >>> browser.addHeader(\'Authorization\',\n-    ...                   \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD))\n-    >>> browser.open(portal.absolute_url())\n-    >>> browser.getLink(\'Folder\').click()\n-    >>> browser.getControl(\'Title\').value = \'Foo Folder\'\n-    >>> browser.getControl(\'Save\').click()\n-    >>> \'Changes saved.\' in browser.contents\n-    True\n-\n-Add an item to the folder::\n-\n-    >>> browser.getLink(\'Foo Folder\').click()\n-    >>> browser.getLink(\'Page\').click()\n-    >>> browser.getControl(\'Title\').value = \'Bar Page\'\n-    >>> browser.getControl(\'Save\').click()\n-    >>> \'Changes saved.\' in browser.contents\n-    True\n-\n-Check out the folder::\n-\n-    >>> browser.getLink(\'Foo Folder\').click()\n-    >>> browser.getLink(\'Check out\').click()\n-    >>> \'form.button.Checkout\' in browser.contents\n-    True\n-    >>> browser.getControl(name=\'form.button.Checkout\').click()\n-    >>> \'This is a working copy\' in browser.contents\n-    True\n-    >>> wc_url = browser.url\n-    >>> wc_url\n-    \'http://nohost/plone/copy_of_foo-folder\'\n-\n-Add another item to the checked out copy::\n-\n-    >>> browser.getLink(url=\'Document\').click()\n-    >>> browser.getControl(\'Title\').value = \'Qux Page\'\n-    >>> browser.getControl(\'Save\').click()\n-    >>> \'Changes saved.\' in browser.contents\n-    True\n-\n-Now that we\'ve added another item, check the working copy in::\n-\n-    >>> browser.open(wc_url)\n-    >>> browser.open(browser.url + \'/@@content-checkin\')\n-    >>> browser.getControl(\'Check in\').click()\n-    >>> \'Checked in\' in browser.contents\n-    True\n-    >>> browser.url\n-    \'http://nohost/plone/foo-folder\'\n-    >>> browser.getLink(\'Qux Page\')\n-    <Link text=\'Qux Page\' url=\'http://nohost/plone/foo-folder/qux-page\'>\n-\n-Bugs\n-----\n-\n-The "Cancel check-out" action should not be present on items that are\n-not checked out (#8735)::\n-\n-    >>> browser.getLink("Cancel check-out")\n-    Traceback (most recent call last):\n-    ...\n-    LinkNotFoundError\n-\n-Some items, like the Plone site root, don\'t do references.  This broke\n-the condition for the "Cancel check-out" action on these items\n-(#8737)::\n-\n-    >>> z2.login(layer[\'app\'][\'acl_users\'], SITE_OWNER_NAME)\n-    >>> if \'front-page\' in portal:\n-    ...     portal.manage_delObjects([\'front-page\'])\n-    >>> browser.open(portal.absolute_url())\n-\n-Working copy workflows\n-----------------------\n-\n-It\'s possible to assign a different workflow to working copies in combination\n-with Products.CMFPlacefulWorkflow.  This usually makes sense: you should be\n-checking in a working copy rather than publishing it.\n-\n-We have a working copy workflow defined in our textfixture profile.  To enable\n-you need to set a couple of registry-entries::\n-\n-    >>> browser.addHeader(\'Authorization\',\n-    ...                   \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD))\n-    >>> browser.open("http://nohost/plone/portal_registry/edit/plone.app.iterate.interfaces.IIterateSettings.checkout_workflow_policy")\n-    >>> browser.getControl(name="form.widgets.value").value\n-    \'checkout_workflow_policy\'\n-    >>> browser.getControl(name="form.widgets.value").value = \'working-copy\'\n-    >>> browser.getControl(name="form.buttons.save").click()\n-    >>> browser.open("http://nohost/plone/portal_registry/edit/plone.app.iterate.interfaces.IIterateSettings.enable_checkout_workflow")\n-    >>> browser.getControl(name="form.widgets.value:list").value\n-    []\n-    >>> browser.getControl(name="form.widgets.value:list").controls[0].selected = True\n-    >>> browser.getControl(name="form.buttons.save").click()\n-\n-Create a new page to test workflows with::\n-\n-    >>> browser.open(portal.absolute_url())\n-    >>> browser.getLink(\'Add new\').click()\n-    >>> \'Add new item\' in browser.contents\n-    True\n-    >>> browser.getControl(\'Page\').click()\n-    >>> browser.getControl(\'Add\').click()\n-    >>> browser.getControl(\'Title\').value = \'My workflow test\'\n-    >>> browser.getControl(name=\'text\').value = \'My workflow test\'\n-    >>> browser.getControl(\'Save\').click()\n-    >>> \'Changes saved.\' in browser.contents\n-    True\n-    >>> workflow_test_url = browser.url\n-\n-Checkout::\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\', \'Basic contributor:secret\')\n-    >>> browser.open(workflow_test_url)\n-    >>> browser.getLink(id=\'plone-contentmenu-actions-iterate_checkout\').click()\n-    >>> browser.contents\n-    \'...Check out...My workflow test...\'\n-    >>> checkout_form = browser.getForm(name=\'checkout\')\n-    >>> checkout_form.getControl(\'Parent folder\').selected = True\n-    >>> checkout_form.getControl(\'Check out\').click()\n-    >>> browser.contents\n-    \'...This is a working copy of...My workflow test..., made by...contributor...\'\n-    >>> browser.contents\n-    \'...state-draft-copy...\'\n-    >>> workflow_checkout_url = browser.url\n-\n-Check get info message on original::\n-\n-    >>> browser.open(workflow_test_url)\n-    >>> browser.contents\n-    \'...This item is being edited by...contributor...a working copy...\'\n-\n-We\'re going to manually give the contributor user the CheckoutPermission\n-to check it\'s used when displaying the info messages.  In our workflow\n-once the checked out item is submitted the contributor no longer has\n-permission to modify it but we still want them to see the info messages::\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\',\n-    ...                   \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD))\n-\n-    >>> from plone.app.iterate.permissions import CheckoutPermission\n-    >>> browser.open(\'{0}/manage_permissionForm?permission_to_manage={1}\'.format(portal.absolute_url(), CheckoutPermission))\n-    >>> browser.getControl(name=\'roles:list\').value = browser.getControl(name=\'roles:list\').value + [\'Contributor\']\n-    >>> browser.getControl(\'Save Changes\').click()\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\', \'Basic contributor:secret\')\n-    >>> browser.open(workflow_checkout_url)\n-    >>> browser.getLink(id=\'workflow-transition-submit-copy-for-publication\')\\\n-    ...     .click()\n-    >>> browser.contents\n-    \'...state-pending-copy...\'\n-    >>> browser.contents\n-    \'...This is a working copy of...My workflow test..., made by...contributor...\'\n-    >>> browser.open(workflow_test_url)\n-    >>> browser.contents\n-    \'...This item is being edited by...contributor...a working copy...\'\n-\n-Check security permisions on workflow have been applied.  We remove copy or\n-move permissions in our workflow so this should not appear in the action menu.\n-http://code.google.com/p/dexterity/issues/detail?id=258 ::\n-\n-    >>> browser = z2.Browser(app)\n-    >>> browser.addHeader(\'Authorization\', \'Basic editor:secret\')\n-    >>> browser.open(workflow_checkout_url)\n-    >>> browser.getLink(id=\'plone-contentmenu-actions-copy\')\n-    Traceback (most recent call last):\n-    ...\n-    LinkNotFoundError\n-    >>> browser.getLink(id=\'plone-contentmenu-actions-delete\')\n-    <Link text=\'Delete\' ...>\ndiff --git a/plone/app/iterate/tests/content.py b/plone/app/iterate/tests/content.py\ndeleted file mode 100644\nindex fcdeb44..0000000\n--- a/plone/app/iterate/tests/content.py\n+++ /dev/null\n@@ -1,36 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.folder.folder import ATFolder\n-from plone.app.folder.folder import ATFolderSchema\n-from Products.Archetypes import atapi\n-from Products.ATContentTypes.content.base import registerATCT\n-\n-\n-RichFolderSchema = ATFolderSchema.copy() + atapi.Schema(\n-    (\n-        atapi.TextField(\n-            "text",\n-            default_output_type="text/x-html-safe",\n-            widget=atapi.RichWidget(),\n-        ),\n-    )\n-)\n-\n-\n-class RichFolder(ATFolder):\n-    """ sample content type for testing purposes """\n-\n-    schema = RichFolderSchema\n-    portal_type = "RichFolder"\n-\n-\n-registerATCT(RichFolder, "plone.app.iterate")\n-\n-\n-def addRichFolder(container, id, **kwargs):\n-    """ at-constructor copied from ClassGen.py """\n-    obj = RichFolder(id)\n-    container._setObject(id, obj, suppress_events=True)\n-    obj = container._getOb(id)\n-    obj.manage_afterAdd(obj, container)\n-    obj.initializeArchetype(**kwargs)\n-    return obj.getId()\ndiff --git a/plone/app/iterate/tests/dexterity.rst b/plone/app/iterate/tests/dexterity.rst\nindex 2082ea0..2ef8281 100644\n--- a/plone/app/iterate/tests/dexterity.rst\n+++ b/plone/app/iterate/tests/dexterity.rst\n@@ -5,7 +5,7 @@ Tests for bugs that would distract from usage examples in stagingbehavior.txt\n \n If we access the site as an admin TTW::\n \n-    >>> from plone.testing.z2 import Browser\n+    >>> from plone.testing.zope import Browser\n     >>> browser = Browser(layer["app"])\n     >>> browser.handleErrors = False\n     >>> portal = layer["portal"]\ndiff --git a/plone/app/iterate/tests/test_doctests.py b/plone/app/iterate/tests/test_doctests.py\nindex cc6e435..e1308d7 100644\n--- a/plone/app/iterate/tests/test_doctests.py\n+++ b/plone/app/iterate/tests/test_doctests.py\n@@ -1,32 +1,13 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.iterate.testing import PLONEAPPITERATE_FUNCTIONAL_TESTING\n from plone.app.iterate.testing import PLONEAPPITERATEDEX_FUNCTIONAL_TESTING\n from plone.testing import layered\n from unittest import TestSuite\n-import doctest\n \n-try:\n-    import Products.ATContentTypes  # noqa\n-except ImportError:\n-    HAS_AT = False\n-else:\n-    HAS_AT = True\n+import doctest\n \n \n def test_suite():\n     suite = TestSuite()\n     OPTIONFLAGS = doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE\n-    if HAS_AT:\n-        suite.addTest(\n-            layered(\n-                doctest.DocFileSuite(\n-                    "browser.rst",\n-                    optionflags=OPTIONFLAGS,\n-                    package="plone.app.iterate.tests",\n-                ),\n-                layer=PLONEAPPITERATE_FUNCTIONAL_TESTING,\n-            )\n-        )\n     suite.addTest(\n         layered(\n             doctest.DocFileSuite(\ndiff --git a/plone/app/iterate/tests/test_iterate_at.py b/plone/app/iterate/tests/test_iterate_at.py\ndeleted file mode 100644\nindex f7cd5de..0000000\n--- a/plone/app/iterate/tests/test_iterate_at.py\n+++ /dev/null\n@@ -1,354 +0,0 @@\n-# -*- coding: utf-8 -*-\n-##################################################################\n-#\n-# (C) Copyright 2006 ObjectRealms, LLC\n-# All Rights Reserved\n-#\n-# This file is part of iterate.\n-#\n-# iterate is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2 of the License, or\n-# (at your option) any later version.\n-#\n-# iterate is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with iterate; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-##################################################################\n-\n-from AccessControl import getSecurityManager\n-from plone.app.iterate.browser.control import Control\n-from plone.app.iterate.interfaces import ICheckinCheckoutPolicy\n-from plone.app.iterate.testing import PLONEAPPITERATE_INTEGRATION_TESTING\n-from plone.app.testing import login\n-from plone.app.testing import setRoles\n-from plone.app.testing import TEST_USER_ID\n-from plone.app.testing import TEST_USER_NAME\n-from Products.CMFCore.utils import getToolByName\n-\n-import unittest\n-\n-try:\n-    from Products.Archetypes.ReferenceEngine import Reference\n-except ImportError:\n-    HAS_AT = False\n-else:\n-    HAS_AT = True\n-\n-    class CustomReference(Reference):\n-        pass\n-\n-\n-class TestIterations(unittest.TestCase):\n-\n-    layer = PLONEAPPITERATE_INTEGRATION_TESTING\n-\n-    def setUp(self):\n-        if not HAS_AT:\n-            raise unittest.SkipTest("Testing Archetypes support requires Archetypes")\n-\n-        self.portal = self.layer["portal"]\n-        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n-        login(self.portal, TEST_USER_NAME)\n-\n-        self.wf = self.portal.portal_workflow\n-        self.wf.setChainForPortalTypes(("Document",), "plone_workflow")\n-\n-        # add a folder with two documents in it\n-        self.portal.invokeFactory("Folder", "docs")\n-        self.portal.docs.invokeFactory("Document", "doc1")\n-        self.portal.docs.invokeFactory("Document", "doc2")\n-\n-        # add a working copy folder\n-        self.portal.invokeFactory("Folder", "workarea")\n-\n-        self.repo = self.portal.portal_repository\n-\n-    def test_workflowState(self):\n-        # ensure baseline workflow state is retained on checkin, including\n-        # security\n-\n-        doc = self.portal.docs.doc1\n-\n-        # sanity check that owner can edit visible docs\n-        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n-        self.assertTrue(\n-            getSecurityManager().checkPermission(\n-                "Modify portal content", self.portal.docs.doc1\n-            )\n-        )\n-\n-        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n-        self.wf.doActionFor(doc, "publish")\n-        state = self.wf.getInfoFor(doc, "review_state")\n-\n-        self.repo.save(doc)\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        wc_state = self.wf.getInfoFor(wc, "review_state")\n-\n-        self.assertNotEqual(state, wc_state)\n-\n-        ICheckinCheckoutPolicy(wc).checkin("modified")\n-        bstate = self.wf.getInfoFor(wc, "review_state")\n-        self.assertEqual(state, bstate)\n-        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n-\n-    def test_baselineVersionCreated(self):\n-        # if a baseline has no version ensure that one is created on checkout\n-\n-        doc = self.portal.docs.doc1\n-        self.assertTrue(self.repo.isVersionable(doc))\n-\n-        history = self.repo.getHistory(doc)\n-        self.assertEqual(len(history), 0)\n-\n-        ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-\n-        history = self.repo.getHistory(doc)\n-        self.assertEqual(len(history), 1)\n-\n-        doc2 = self.portal.docs.doc2\n-        self.repo.save(doc2)\n-\n-        ICheckinCheckoutPolicy(doc2).checkout(self.portal.workarea)\n-\n-        history = self.repo.getHistory(doc2)\n-        self.assertEqual(len(history), 1)\n-\n-    def test_wcNewForwardReferencesCopied(self):\n-        # ensure that new wc references are copied back to the baseline on\n-        # checkin\n-        doc = self.portal.docs.doc1\n-        doc.addReference(self.portal.docs)\n-        self.assertEqual(len(doc.getReferences("zebra")), 0)\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        wc.addReference(self.portal.docs.doc2, "zebra")\n-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-        self.assertEqual(len(doc.getReferences("zebra")), 1)\n-\n-    def test_wcNewBackwardReferencesCopied(self):\n-        # ensure that new wc back references are copied back to the baseline on\n-        # checkin\n-\n-        doc = self.portal.docs.doc1\n-        self.assertEqual(len(doc.getBackReferences("zebra")), 0)\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        self.portal.docs.doc2.addReference(wc, "zebra")\n-        self.assertEqual(len(wc.getBackReferences("zebra")), 1)\n-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-        self.assertEqual(len(doc.getBackReferences("zebra")), 1)\n-\n-    def test_baselineReferencesMaintained(self):\n-        # ensure that baseline references are maintained when the object is\n-        # checked in copies forward, bkw are not copied, but are maintained.\n-\n-        doc = self.portal.docs.doc1\n-        doc.addReference(self.portal.docs, "elephant")\n-        self.portal.docs.doc2.addReference(doc)\n-\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-\n-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-\n-        # TODO: This fails in Plone 4.1. The new optimized catalog lookups\n-        # in the reference catalog no longer filter out non-existing reference\n-        # objects. In both Plone 4.0 and 4.1 there\'s two references, one of\n-        # them is a stale catalog entry in the reference catalog. The real fix\n-        # is to figure out how the stale catalog entry gets in there\n-        self.assertEqual(len(doc.getReferences()), 1)\n-        self.assertEqual(len(doc.getBackReferences()), 1)\n-\n-    def test_baselineBrokenReferencesRemoved(self):\n-        # When the baseline has a reference to a deleted object, a\n-        # checkout should not fail with a ReferenceException.\n-\n-        doc = self.portal.docs.doc1\n-        doc.addReference(self.portal.docs.doc2, "pony")\n-        self.portal.docs._delOb("doc2")\n-        # _delOb is low level enough that the reference does not get cleaned\n-        # up.\n-        self.assertEqual(len(doc.getReferences()), 1)\n-\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        # The working copy has one reference: its original.\n-        self.assertEqual(len(wc.getReferences()), 1)\n-        self.assertEqual(wc.getReferences()[0].id, "doc1")\n-\n-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-        # The checkin removes the broken reference.\n-        self.assertEqual(len(doc.getReferences()), 0)\n-\n-    def test_baselineNoCopyReferences(self):\n-        # ensure that custom state is maintained with the no copy adapter\n-\n-        # setup the named ref adapter\n-        from zope import component\n-        from Products.Archetypes.interfaces import IBaseObject\n-        from plone.app.iterate import relation, interfaces\n-\n-        component.provideAdapter(\n-            adapts=(IBaseObject,),\n-            provides=interfaces.ICheckinCheckoutReference,\n-            factory=relation.NoCopyReferenceAdapter,\n-            name="zebra",\n-        )\n-\n-        doc = self.portal.docs.doc1\n-        ref = doc.addReference(\n-            self.portal.docs, "zebra", referenceClass=CustomReference\n-        )\n-        ref.custom_state = "hello world"\n-\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-\n-        self.assertEqual(len(wc.getReferences("zebra")), 0)\n-\n-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-\n-        self.assertEqual(len(doc.getReferences("zebra")), 1)\n-\n-        ref = doc.getReferenceImpl("zebra")[0]\n-\n-        self.assertTrue(hasattr(ref, "custom_state"))\n-        self.assertEqual(ref.custom_state, "hello world")\n-\n-    def test_folderOrder(self):\n-        """When an item is checked out and then back in, the original\n-        folder order is preserved."""\n-        container = self.portal.docs\n-        doc = container.doc1\n-        original_position = container.getObjectPosition(doc.getId())\n-\n-        # check that there is another document which could interact with\n-        # position of document the test work on\n-        doc2_position = container.getObjectPosition("doc2")\n-        self.assertTrue(doc2_position > original_position)\n-\n-        self.repo.save(doc)\n-        wc = ICheckinCheckoutPolicy(doc).checkout(container)\n-        wc.update(text="new document text")\n-\n-        # check that the copy is put after the second document\n-        copy_position = container.getObjectPosition(wc.getId())\n-        self.assertTrue(copy_position > doc2_position)\n-\n-        new_doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-        new_position = container.getObjectPosition(new_doc.getId())\n-        self.assertEqual(new_position, original_position)\n-\n-    def test_folderContents(self):\n-        """When an folder is checked out, and item is added, and then\n-        the folder is checked back in, the added item is in the new\n-        version of the folder.  UIDs of contained content are also\n-        preserved."""\n-        container = self.portal.docs\n-        folder = container[container.invokeFactory(type_name="Folder", id="foo-folder")]\n-        existing_doc = folder[\n-            folder.invokeFactory(type_name="Document", id="existing-folder-item")\n-        ]\n-        existing_doc_uid = existing_doc.UID()\n-\n-        self.repo.save(folder)\n-        wc = ICheckinCheckoutPolicy(folder).checkout(container)\n-        new_doc = wc[\n-            wc.invokeFactory(\n-                type_name="Document", id="new-folder-item", text="new folder item text"\n-            )\n-        ]\n-        new_doc_uid = new_doc.UID()\n-        new_folder = ICheckinCheckoutPolicy(wc).checkin("updated")\n-\n-        catalog = getToolByName(self.portal, "portal_catalog")\n-\n-        self.assertTrue("existing-folder-item" in new_folder)\n-        self.assertEqual(new_folder["existing-folder-item"].UID(), existing_doc_uid)\n-        self.assertTrue("new-folder-item" in new_folder)\n-        self.assertEqual(new_folder["new-folder-item"].UID(), new_doc_uid)\n-        brains = catalog(path="/".join(new_folder["new-folder-item"].getPhysicalPath()))\n-        self.assertTrue(brains)\n-        self.assertTrue(\n-            "new folder item text" in new_folder["new-folder-item"].getText()\n-        )\n-\n-    def test_checkinObjectLinkedInParentsRichTextField(self):\n-        """Checnking-in an object that is linked in it\'s\n-        parent\'s rich text field. See: https://dev.plone.org/ticket/13462\n-        """\n-        # create a folderish object with a rich text field\n-        from content import addRichFolder\n-\n-        addRichFolder(self.portal, "rich_text_folder")\n-        rich_text_folder = self.portal.rich_text_folder\n-\n-        # create the subobject\n-        rich_text_folder.invokeFactory("Document", "subobject")\n-        subobject = rich_text_folder.subobject\n-        subobject_uid = subobject.UID()\n-\n-        # link (by uid) the subobject in it\'s parent\'s rich text field\n-        link_html = (\n-            \'<a class="internal-link" href="resolveuid/{0}">\' "Link to subobject</a>"\n-        )\n-        rich_text_folder.setText(link_html.format(subobject_uid))\n-\n-        # try to checkout and checkin the subobject\n-        wc = ICheckinCheckoutPolicy(subobject).checkout(rich_text_folder)\n-        ICheckinCheckoutPolicy(wc).checkin("updated")\n-\n-        # everything went right and the working copy is checked in\n-        self.assertEqual(subobject_uid, wc.UID())\n-\n-    def test_default_page_is_kept_in_folder(self):\n-        # Ensure that a default page that is checked out and back in is still\n-        # the default page.\n-        folder = self.portal.docs\n-        doc = folder.doc1\n-        from Products.CMFDynamicViewFTI.interfaces import (\n-            ISelectableBrowserDefault,\n-        )  # noqa: C901\n-\n-        ISelectableBrowserDefault(folder).setDefaultPage("doc1")\n-        self.assertEqual(folder.getProperty("default_page", ""), "doc1")\n-        self.assertEqual(folder.getDefaultPage(), "doc1")\n-        # Note: when checking out to self.portal.workarea it surprisingly works\n-        # without changes.  But the default behavior in Plone is to check a\n-        # document out in its original folder, so that is what we check here.\n-        wc = ICheckinCheckoutPolicy(doc).checkout(folder)\n-        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n-        self.assertEqual(folder.getProperty("default_page", ""), "doc1")\n-        self.assertEqual(folder.getDefaultPage(), "doc1")\n-\n-    def test_control_checkin_allowed_with_no_policy(self):\n-        control = Control(self.portal, self.layer["request"])\n-        self.assertFalse(control.checkin_allowed())\n-\n-    def test_control_checkout_allowed_with_no_policy(self):\n-        control = Control(self.portal, self.layer["request"])\n-        self.assertFalse(control.checkout_allowed())\n-\n-    def test_control_cancel_allowed_with_no_policy(self):\n-        control = Control(self.portal, self.layer["request"])\n-        self.assertFalse(control.cancel_allowed())\n-\n-    def test_control_cancel_on_original_does_not_delete_original(self):\n-        # checkout document\n-        doc = self.portal.docs.doc1\n-        policy = ICheckinCheckoutPolicy(self.portal.docs.doc1, None)\n-        policy.checkout(self.portal.workarea)\n-\n-        # get cancel browser view\n-        from plone.app.iterate.browser.cancel import Cancel\n-\n-        cancel = Cancel(doc, self.layer["request"])\n-        self.layer["request"].form["form.button.Cancel"] = True\n-\n-        # check if cancel on original raises the correct exception\n-        from plone.app.iterate.interfaces import CheckoutException\n-\n-        with self.assertRaises(CheckoutException):\n-            cancel()\ndiff --git a/plone/app/iterate/util.py b/plone/app/iterate/util.py\nindex 6826071..542b9aa 100644\n--- a/plone/app/iterate/util.py\n+++ b/plone/app/iterate/util.py\n@@ -23,7 +23,7 @@\n \n from .interfaces import annotation_key\n from persistent.dict import PersistentDict\n-from Products.CMFPlone.utils import get_installer\n+from plone.base.utils import get_installer\n from zope.annotation import IAnnotations\n \n \ndiff --git a/setup.py b/setup.py\nindex d8f6247..89ee27e 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -7,15 +7,13 @@\n \n setup(\n     name="plone.app.iterate",\n-    version="4.0.4.dev0",\n+    version="5.0.0.dev0",\n     description="check-out/check-in staging for Plone",\n     long_description=LONG_DESCRIPTION,\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Environment :: Web Environment",\n         "Framework :: Plone",\n-        "Framework :: Plone :: 5.1",\n-        "Framework :: Plone :: 5.2",\n         "Framework :: Plone :: 6.0",\n         "Framework :: Plone :: Core",\n         "Framework :: Zope2",\n@@ -23,9 +21,6 @@\n         "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n         "Operating System :: OS Independent",\n         "Programming Language :: Python",\n-        "Programming Language :: Python :: 2.7",\n-        "Programming Language :: Python :: 3.6",\n-        "Programming Language :: Python :: 3.7",\n         "Programming Language :: Python :: 3.8",\n         "Programming Language :: Python :: 3.9",\n         "Programming Language :: Python :: 3.10",\n@@ -40,7 +35,7 @@\n     namespace_packages=["plone", "plone.app"],\n     include_package_data=True,\n     zip_safe=False,\n-    python_requires=">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,!=3.5.*",\n+    python_requires=">=3.8",\n     install_requires=[\n         "Acquisition",\n         "DateTime",\n@@ -63,9 +58,6 @@\n         "zope.viewlet",\n     ],\n     extras_require={\n-        "archetypes": [\n-            "Products.Archetypes",\n-        ],\n         "test": [\n             "plone.app.testing",\n             "plone.app.contenttypes",\n'

