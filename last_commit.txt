Repository: plone.app.content


Branch: refs/heads/master
Date: 2021-07-09T00:33:37+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.content/commit/50b63c04094c57f1903585c718316a5e826df9f3

Fixed stored XSS in folder contents.

From [PloneHotfix20210518](https://plone.org/security/hotfix/20210518/stored-xss-in-folder-contents).

Files changed:
A news/3274.bugfix
M plone/app/content/browser/contents/__init__.py
M plone/app/content/tests/test_contents.py

b'diff --git a/news/3274.bugfix b/news/3274.bugfix\nnew file mode 100644\nindex 0000000..ca0f1b9\n--- /dev/null\n+++ b/news/3274.bugfix\n@@ -0,0 +1,3 @@\n+Fixed stored XSS in folder contents.\n+From `PloneHotfix20210518 <https://plone.org/security/hotfix/20210518/stored-xss-in-folder-contents>`_.\n+[maurits]\ndiff --git a/plone/app/content/browser/contents/__init__.py b/plone/app/content/browser/contents/__init__.py\nindex 4c2be03..d926be8 100644\n--- a/plone/app/content/browser/contents/__init__.py\n+++ b/plone/app/content/browser/contents/__init__.py\n@@ -15,6 +15,7 @@\n from Products.CMFPlone.interfaces.controlpanel import ISiteSchema\n from Products.CMFPlone.utils import get_top_site_from_url\n from Products.Five import BrowserView\n+from Products.PortalTransforms.transforms.safe_html import SafeHTML\n from zope.browsermenu.interfaces import IBrowserMenu\n from zope.component import getMultiAdapter\n from zope.component import getUtilitiesFor\n@@ -23,8 +24,6 @@\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n \n-from html import escape\n-\n \n class ContentsBaseAction(BrowserView):\n \n@@ -338,12 +337,13 @@ def __call__(self):\n                 })\n \n         context = aq_inner(self.context)\n+        transform = SafeHTML()\n         crumbs = []\n         top_site = get_top_site_from_url(self.context, self.request)\n         while not context == top_site:\n             crumbs.append({\n                 \'id\': context.getId(),\n-                \'title\': escape(utils.pretty_title_or_id(context, context))\n+                \'title\': transform.scrub_html(utils.pretty_title_or_id(context, context))\n             })\n             context = utils.parent(context)\n \n@@ -367,8 +367,8 @@ def __call__(self):\n                     val = val()\n                 if key == \'path\':\n                     val = val[len(base_path):]\n-                if key == \'Title\':\n-                    val = escape(val)\n+                if isinstance(val, (bytes, str)):\n+                    val = transform.scrub_html(val)\n                 item[key] = val\n \n         self.request.response.setHeader(\ndiff --git a/plone/app/content/tests/test_contents.py b/plone/app/content/tests/test_contents.py\nindex 440aa0e..7f4457b 100644\n--- a/plone/app/content/tests/test_contents.py\n+++ b/plone/app/content/tests/test_contents.py\n@@ -528,22 +528,31 @@ def test_fc_properties__changes__with_recurse(self):\n         self.assertEqual(self.portal.main1.sub2.exclude_from_nav, False)\n \n \n-# Text for testing that the title is escaped.\n-ESCAPED = "&lt;script&gt;"\n-HACKED = \'<script>alert("hacked")</script>\'\n+# We want to avoid hackers getting script tags inserted.\n+# But for example an ampersand is okay as long as it is escaped,\n+# although it should not be doubly escaped, because that looks wrong.\n+NORMAL_TEXT = "Smith & Jones"\n+ESCAPED_TEXT = "Smith &amp; Jones"\n+DOUBLY_ESCAPED_TEXT = "Smith &amp;amp; Jones"\n+# For script tags, safest is to filter them using the safe html filter.\n+HACKED = \'The <script>alert("hacker")</script> was here.\'\n \n \n-class TestTitleEscape(unittest.TestCase):\n-    """Test that the title in the folder contents is escaped.\n+class TestSafeHtmlInFolderContents(unittest.TestCase):\n+    """Test that the title in the folder contents is safe.\n \n     From PloneHotfix20200121, see\n     https://plone.org/security/hotfix/20200121/xss-in-the-title-field-on-plone-5-0-and-higher\n+\n+    Same for other fields, from PloneHotfix20210518, see\n+    https://plone.org/security/hotfix/20210518/stored-xss-in-folder-contents\n     """\n     layer = PLONE_APP_CONTENT_DX_FUNCTIONAL_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer["portal"]\n-        self.app = self.layer["app"]\n+        self.portal = self.layer[\'portal\']\n+        login(self.portal, TEST_USER_NAME)\n+        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n \n     def get_browser(self):\n         browser = Browser(self.layer["app"])\n@@ -554,61 +563,100 @@ def get_browser(self):\n         )\n         return browser\n \n-    def assert_not_hacked(self, browser):\n-        body = browser.contents\n-        hacked = HACKED\n-        if not browser.isHtml:\n-            # Assume json.\n-            hacked = json.dumps(HACKED)\n-\n-        # This gives a too verbose error message, showing the entire body:\n-        # self.assertNotIn(HACKED, body)\n-        # So we roll our own less verbose version.\n-        if hacked in body:\n-            index = body.index(hacked)\n-            start = max(0, index - 50)\n-            end = min(index + len(hacked) + 50, len(body))\n-            assert False, "Hacked script found in body: ... {} ...".format(\n-                body[start:end]\n-            )\n-\n-        # The escaped version of the HACKED text should be in the response text.\n-        self.assertIn(ESCAPED, body)\n-\n-    def test_normal_title(self):\n-        # Create a folder and page with normal title.\n-        normal = "\'Normal title"\n-        setRoles(self.portal, TEST_USER_ID, ["Manager", "Member"])\n-        self.portal.invokeFactory("Folder", id="folder1", title=normal)\n+    def test_ampersand(self):\n+        self.portal.invokeFactory(\n+            "Folder",\n+            id="folder1",\n+            title=NORMAL_TEXT,\n+            description=NORMAL_TEXT,\n+            creators=(NORMAL_TEXT,),\n+            contributors=(NORMAL_TEXT,),\n+        )\n         folder1 = self.portal.folder1\n-        self.assertEqual(folder1.Title(), normal)\n-        folder1.invokeFactory("Document", id="page1", title=normal)\n+        self.assertEqual(folder1.Title(), NORMAL_TEXT)\n+        self.assertEqual(folder1.Description(), NORMAL_TEXT)\n+        folder1.invokeFactory(\n+            "Document",\n+            id="page1",\n+            title=NORMAL_TEXT,\n+            description=NORMAL_TEXT,\n+            creators=(NORMAL_TEXT,),\n+            contributors=(NORMAL_TEXT,),\n+        )\n         page1 = folder1.page1\n-        self.assertEqual(page1.Title(), normal)\n+        self.assertEqual(page1.Title(), NORMAL_TEXT)\n+        self.assertEqual(page1.Description(), NORMAL_TEXT)\n         transaction.commit()\n \n-        # Check the output of the normal case for comparison.\n+        # Check the output.\n         browser = self.get_browser()\n+        browser.open(folder1.absolute_url())\n+        self.assert_only_escaped_text(browser)\n+        browser.open(page1.absolute_url())\n+        self.assert_only_escaped_text(browser)\n+        browser.open(folder1.absolute_url() + "/folder_contents")\n+        self.assert_only_escaped_text(browser)\n+\n         browser.open(folder1.absolute_url() + "/@@fc-contextInfo")\n-        self.assertNotIn(ESCAPED, browser.contents)\n-\n-    def test_xss_from_title(self):\n-        # Does a script tag as title show up anywhere in the html?\n-        # It might end up in the main menu.\n-\n-        # Create a folder and page with a hacked title.\n-        setRoles(self.portal, TEST_USER_ID, ["Manager", "Member"])\n-        self.portal.invokeFactory("Folder", id="folder2", title=HACKED)\n-        folder2 = self.portal.folder2\n-        self.assertEqual(folder2.Title(), HACKED)\n-        folder2.invokeFactory("Document", id="page2", title=HACKED)\n-        page2 = folder2.page2\n-        self.assertEqual(page2.Title(), HACKED)\n+        self.assert_only_escaped_text(browser)\n+\n+    def test_xss(self):\n+        self.portal.invokeFactory(\n+            "Folder",\n+            id="folder1",\n+            title=HACKED,\n+            description=HACKED,\n+            creators=(HACKED,),\n+            contributors=(HACKED,),\n+        )\n+        folder1 = self.portal.folder1\n+        self.assertEqual(folder1.Title(), HACKED)\n+        # With good old Archetypes the description gets cleaned up to\n+        # \'The  alert("hacker")  was here.\'\n+        # self.assertEqual(folder1.Description(), HACKED)\n+        folder1.invokeFactory(\n+            "Document",\n+            id="page1",\n+            title=HACKED,\n+            description=HACKED,\n+            creators=(HACKED,),\n+            contributors=(HACKED,),\n+        )\n+        page1 = folder1.page1\n+        self.assertEqual(page1.Title(), HACKED)\n+        # self.assertEqual(page1.Description(), HACKED)\n         transaction.commit()\n \n-        # Check the output of this hacked case.\n+        # Check the output.\n         browser = self.get_browser()\n-        # Note: the content of the normal page, or /folder_contents\n-        # is checked in the plone.app.layout tests.\n-        browser.open(folder2.absolute_url() + "/@@fc-contextInfo")\n-        self.assert_not_hacked(browser)\n+        browser.open(folder1.absolute_url())\n+        self.assert_not_in(HACKED, browser.contents)\n+        browser.open(page1.absolute_url())\n+        self.assert_not_in(HACKED, browser.contents)\n+        browser.open(folder1.absolute_url() + "/folder_contents")\n+        self.assert_not_in(HACKED, browser.contents)\n+\n+        browser.open(folder1.absolute_url() + "/@@fc-contextInfo")\n+        self.assert_not_in(HACKED, browser.contents)\n+\n+    def assert_only_escaped_text(self, browser):\n+        body = browser.contents\n+        # The escaped version of the text text should be in the response text.\n+        self.assertIn(ESCAPED_TEXT, body)\n+        # The normal version should not.\n+        self.assert_not_in(NORMAL_TEXT, body)\n+        # We should avoid escaping twice.\n+        self.assert_not_in(DOUBLY_ESCAPED_TEXT, body)\n+\n+    def assert_not_in(self, target, body):\n+        # This gives a too verbose error message, showing the entire body:\n+        # self.assertNotIn("x", body)\n+        # So we roll our own less verbose version.\n+        if target not in body:\n+            return\n+        index = body.index(target)\n+        start = max(0, index - 50)\n+        end = min(index + len(target) + 50, len(body))\n+        assert False, "Text \'{0}\' unexpectedly found in body: ... {1} ...".format(\n+            target, body[start:end]\n+        )\n'

Repository: plone.app.content


Branch: refs/heads/master
Date: 2021-07-09T02:02:48+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.content/commit/0213e118997d07e238e6fadb88ee638ad378178c

Fixed stored XSS from user fullname.

And possibly other places where getVocabulary is called.
This is an alternative to the `plone.app.users` workaround from [PloneHotfix20210518](https://plone.org/security/hotfix/20210518/stored-xss-from-user-fullname).

Files changed:
A news/3274.bugfix.1
A news/3274.bugfix.2
M plone/app/content/browser/vocabulary.py
M plone/app/content/tests/test_widgets.py
D news/3274.bugfix

b'diff --git a/news/3274.bugfix b/news/3274.bugfix.1\nsimilarity index 100%\nrename from news/3274.bugfix\nrename to news/3274.bugfix.1\ndiff --git a/news/3274.bugfix.2 b/news/3274.bugfix.2\nnew file mode 100644\nindex 0000000..82778eb\n--- /dev/null\n+++ b/news/3274.bugfix.2\n@@ -0,0 +1,4 @@\n+Fixed stored XSS from user fullname and possibly other places where ``getVocabulary`` is called.\n+This is an alternative to the ``plone.app.users`` workaround from `PloneHotfix20210518 <https://plone.org/security/hotfix/20210518/stored-xss-from-user-fullname>`_.\n+It looks like Plone 6 is not vulnerable, but this change makes sure.\n+[maurits]\ndiff --git a/plone/app/content/browser/vocabulary.py b/plone/app/content/browser/vocabulary.py\nindex 07f447f..1ec75b1 100644\n--- a/plone/app/content/browser/vocabulary.py\n+++ b/plone/app/content/browser/vocabulary.py\n@@ -16,6 +16,7 @@\n from Products.Five import BrowserView\n from Products.MimetypesRegistry.MimeTypeItem import guess_icon_path\n from Products.MimetypesRegistry.MimeTypeItem import PREFIX\n+from Products.PortalTransforms.transforms.safe_html import SafeHTML\n from types import FunctionType\n from z3c.form.interfaces import IAddForm\n from z3c.form.interfaces import ISubForm\n@@ -209,6 +210,7 @@ def __call__(self):\n             attributes = attributes.split(\',\')\n \n         translate_ignored = self.get_translated_ignored()\n+        transform = SafeHTML()\n         if attributes:\n             base_path = self.get_base_path(context)\n             sm = getSecurityManager()\n@@ -238,12 +240,13 @@ def __call__(self):\n                         key not in translate_ignored and\n                         isinstance(val, str)\n                     ):\n-                        item[key] = translate(\n+                        val = translate(\n                             _(safe_unicode(val)),\n                             context=self.request\n                         )\n-                    else:\n-                        item[key] = val\n+                    if isinstance(val, (bytes, str)):\n+                        val = transform.scrub_html(val)\n+                    item[key] = val\n                     if key == \'getMimeIcon\':\n                         item[key] = None\n                         # get mime type icon url from mimetype registry\'\n@@ -265,8 +268,8 @@ def __call__(self):\n                                 )\n                 items.append(item)\n         else:\n-            items = [{\'id\': item.value,\n-                      \'text\': item.title} for item in results]\n+            items = [{\'id\': transform.scrub_html(item.value),\n+                      \'text\': transform.scrub_html(item.title) if item.title else ""} for item in results]\n \n         if total == 0:\n             total = len(items)\ndiff --git a/plone/app/content/tests/test_widgets.py b/plone/app/content/tests/test_widgets.py\nindex 5f80cfd..7b134c2 100644\n--- a/plone/app/content/tests/test_widgets.py\n+++ b/plone/app/content/tests/test_widgets.py\n@@ -25,6 +25,7 @@\n from zope.publisher.browser import TestRequest\n \n import json\n+import operator\n import os\n import transaction\n import unittest\n@@ -350,18 +351,30 @@ def testVocabularyUsers(self):\n         acl_users = self.portal.acl_users\n         membership = self.portal.portal_membership\n         amount = 10\n+        # Let\'s test that safe html is used on the fullname,\n+        # as alternative to the workaround in PloneHotfix20210518.\n         for i in range(amount):\n             id = \'user\' + str(i)\n             acl_users.userFolderAddUser(id, \'secret\', [\'Member\'], [])\n             member = membership.getMemberById(id)\n-            member.setMemberProperties(mapping={"fullname": id})\n+            # Make user0 the hacker.\n+            if i == 0:\n+                fullname = "user <script>alert(\'tag\')</script> hacker"\n+            else:\n+                fullname = id\n+            member.setMemberProperties(mapping={"fullname": fullname})\n         view = VocabularyView(self.portal, self.request)\n         self.request.form.update({\n             \'name\': \'plone.app.vocabularies.Users\',\n             \'query\': \'user\'\n         })\n         data = json.loads(view())\n+\n         self.assertEqual(len(data[\'results\']), amount)\n+        # Let\'s sort, just to be sure.\n+        results = sorted(data[\'results\'], key=operator.itemgetter("id"))\n+        # The first one is the hacker.  The hack should have failed.\n+        self.assertDictEqual(results[0], {\'id\': \'user0\', \'text\': \'user  hacker\'})\n \n     def testSource(self):\n         from z3c.form.browser.text import TextWidget\n'

Repository: plone.app.content


Branch: refs/heads/master
Date: 2021-07-26T20:55:24+02:00
Author: Maurits van Rees (mauritsvanrees) <m.van.rees@zestsoftware.nl>
Commit: https://github.com/plone/plone.app.content/commit/d0c708ca3faeb7aa6fb948fb38b563dcc3d64758

Merge pull request #230 from plone/hotfix-20210518-master

Fixed stored XSS in folder contents and user fullname. [master]

Files changed:
A news/3274.bugfix.1
A news/3274.bugfix.2
M plone/app/content/browser/contents/__init__.py
M plone/app/content/browser/vocabulary.py
M plone/app/content/tests/test_contents.py
M plone/app/content/tests/test_widgets.py

b'diff --git a/news/3274.bugfix.1 b/news/3274.bugfix.1\nnew file mode 100644\nindex 0000000..ca0f1b9\n--- /dev/null\n+++ b/news/3274.bugfix.1\n@@ -0,0 +1,3 @@\n+Fixed stored XSS in folder contents.\n+From `PloneHotfix20210518 <https://plone.org/security/hotfix/20210518/stored-xss-in-folder-contents>`_.\n+[maurits]\ndiff --git a/news/3274.bugfix.2 b/news/3274.bugfix.2\nnew file mode 100644\nindex 0000000..82778eb\n--- /dev/null\n+++ b/news/3274.bugfix.2\n@@ -0,0 +1,4 @@\n+Fixed stored XSS from user fullname and possibly other places where ``getVocabulary`` is called.\n+This is an alternative to the ``plone.app.users`` workaround from `PloneHotfix20210518 <https://plone.org/security/hotfix/20210518/stored-xss-from-user-fullname>`_.\n+It looks like Plone 6 is not vulnerable, but this change makes sure.\n+[maurits]\ndiff --git a/plone/app/content/browser/contents/__init__.py b/plone/app/content/browser/contents/__init__.py\nindex 4c2be03..d926be8 100644\n--- a/plone/app/content/browser/contents/__init__.py\n+++ b/plone/app/content/browser/contents/__init__.py\n@@ -15,6 +15,7 @@\n from Products.CMFPlone.interfaces.controlpanel import ISiteSchema\n from Products.CMFPlone.utils import get_top_site_from_url\n from Products.Five import BrowserView\n+from Products.PortalTransforms.transforms.safe_html import SafeHTML\n from zope.browsermenu.interfaces import IBrowserMenu\n from zope.component import getMultiAdapter\n from zope.component import getUtilitiesFor\n@@ -23,8 +24,6 @@\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n \n-from html import escape\n-\n \n class ContentsBaseAction(BrowserView):\n \n@@ -338,12 +337,13 @@ def __call__(self):\n                 })\n \n         context = aq_inner(self.context)\n+        transform = SafeHTML()\n         crumbs = []\n         top_site = get_top_site_from_url(self.context, self.request)\n         while not context == top_site:\n             crumbs.append({\n                 \'id\': context.getId(),\n-                \'title\': escape(utils.pretty_title_or_id(context, context))\n+                \'title\': transform.scrub_html(utils.pretty_title_or_id(context, context))\n             })\n             context = utils.parent(context)\n \n@@ -367,8 +367,8 @@ def __call__(self):\n                     val = val()\n                 if key == \'path\':\n                     val = val[len(base_path):]\n-                if key == \'Title\':\n-                    val = escape(val)\n+                if isinstance(val, (bytes, str)):\n+                    val = transform.scrub_html(val)\n                 item[key] = val\n \n         self.request.response.setHeader(\ndiff --git a/plone/app/content/browser/vocabulary.py b/plone/app/content/browser/vocabulary.py\nindex 07f447f..1ec75b1 100644\n--- a/plone/app/content/browser/vocabulary.py\n+++ b/plone/app/content/browser/vocabulary.py\n@@ -16,6 +16,7 @@\n from Products.Five import BrowserView\n from Products.MimetypesRegistry.MimeTypeItem import guess_icon_path\n from Products.MimetypesRegistry.MimeTypeItem import PREFIX\n+from Products.PortalTransforms.transforms.safe_html import SafeHTML\n from types import FunctionType\n from z3c.form.interfaces import IAddForm\n from z3c.form.interfaces import ISubForm\n@@ -209,6 +210,7 @@ def __call__(self):\n             attributes = attributes.split(\',\')\n \n         translate_ignored = self.get_translated_ignored()\n+        transform = SafeHTML()\n         if attributes:\n             base_path = self.get_base_path(context)\n             sm = getSecurityManager()\n@@ -238,12 +240,13 @@ def __call__(self):\n                         key not in translate_ignored and\n                         isinstance(val, str)\n                     ):\n-                        item[key] = translate(\n+                        val = translate(\n                             _(safe_unicode(val)),\n                             context=self.request\n                         )\n-                    else:\n-                        item[key] = val\n+                    if isinstance(val, (bytes, str)):\n+                        val = transform.scrub_html(val)\n+                    item[key] = val\n                     if key == \'getMimeIcon\':\n                         item[key] = None\n                         # get mime type icon url from mimetype registry\'\n@@ -265,8 +268,8 @@ def __call__(self):\n                                 )\n                 items.append(item)\n         else:\n-            items = [{\'id\': item.value,\n-                      \'text\': item.title} for item in results]\n+            items = [{\'id\': transform.scrub_html(item.value),\n+                      \'text\': transform.scrub_html(item.title) if item.title else ""} for item in results]\n \n         if total == 0:\n             total = len(items)\ndiff --git a/plone/app/content/tests/test_contents.py b/plone/app/content/tests/test_contents.py\nindex 440aa0e..7f4457b 100644\n--- a/plone/app/content/tests/test_contents.py\n+++ b/plone/app/content/tests/test_contents.py\n@@ -528,22 +528,31 @@ def test_fc_properties__changes__with_recurse(self):\n         self.assertEqual(self.portal.main1.sub2.exclude_from_nav, False)\n \n \n-# Text for testing that the title is escaped.\n-ESCAPED = "&lt;script&gt;"\n-HACKED = \'<script>alert("hacked")</script>\'\n+# We want to avoid hackers getting script tags inserted.\n+# But for example an ampersand is okay as long as it is escaped,\n+# although it should not be doubly escaped, because that looks wrong.\n+NORMAL_TEXT = "Smith & Jones"\n+ESCAPED_TEXT = "Smith &amp; Jones"\n+DOUBLY_ESCAPED_TEXT = "Smith &amp;amp; Jones"\n+# For script tags, safest is to filter them using the safe html filter.\n+HACKED = \'The <script>alert("hacker")</script> was here.\'\n \n \n-class TestTitleEscape(unittest.TestCase):\n-    """Test that the title in the folder contents is escaped.\n+class TestSafeHtmlInFolderContents(unittest.TestCase):\n+    """Test that the title in the folder contents is safe.\n \n     From PloneHotfix20200121, see\n     https://plone.org/security/hotfix/20200121/xss-in-the-title-field-on-plone-5-0-and-higher\n+\n+    Same for other fields, from PloneHotfix20210518, see\n+    https://plone.org/security/hotfix/20210518/stored-xss-in-folder-contents\n     """\n     layer = PLONE_APP_CONTENT_DX_FUNCTIONAL_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer["portal"]\n-        self.app = self.layer["app"]\n+        self.portal = self.layer[\'portal\']\n+        login(self.portal, TEST_USER_NAME)\n+        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n \n     def get_browser(self):\n         browser = Browser(self.layer["app"])\n@@ -554,61 +563,100 @@ def get_browser(self):\n         )\n         return browser\n \n-    def assert_not_hacked(self, browser):\n-        body = browser.contents\n-        hacked = HACKED\n-        if not browser.isHtml:\n-            # Assume json.\n-            hacked = json.dumps(HACKED)\n-\n-        # This gives a too verbose error message, showing the entire body:\n-        # self.assertNotIn(HACKED, body)\n-        # So we roll our own less verbose version.\n-        if hacked in body:\n-            index = body.index(hacked)\n-            start = max(0, index - 50)\n-            end = min(index + len(hacked) + 50, len(body))\n-            assert False, "Hacked script found in body: ... {} ...".format(\n-                body[start:end]\n-            )\n-\n-        # The escaped version of the HACKED text should be in the response text.\n-        self.assertIn(ESCAPED, body)\n-\n-    def test_normal_title(self):\n-        # Create a folder and page with normal title.\n-        normal = "\'Normal title"\n-        setRoles(self.portal, TEST_USER_ID, ["Manager", "Member"])\n-        self.portal.invokeFactory("Folder", id="folder1", title=normal)\n+    def test_ampersand(self):\n+        self.portal.invokeFactory(\n+            "Folder",\n+            id="folder1",\n+            title=NORMAL_TEXT,\n+            description=NORMAL_TEXT,\n+            creators=(NORMAL_TEXT,),\n+            contributors=(NORMAL_TEXT,),\n+        )\n         folder1 = self.portal.folder1\n-        self.assertEqual(folder1.Title(), normal)\n-        folder1.invokeFactory("Document", id="page1", title=normal)\n+        self.assertEqual(folder1.Title(), NORMAL_TEXT)\n+        self.assertEqual(folder1.Description(), NORMAL_TEXT)\n+        folder1.invokeFactory(\n+            "Document",\n+            id="page1",\n+            title=NORMAL_TEXT,\n+            description=NORMAL_TEXT,\n+            creators=(NORMAL_TEXT,),\n+            contributors=(NORMAL_TEXT,),\n+        )\n         page1 = folder1.page1\n-        self.assertEqual(page1.Title(), normal)\n+        self.assertEqual(page1.Title(), NORMAL_TEXT)\n+        self.assertEqual(page1.Description(), NORMAL_TEXT)\n         transaction.commit()\n \n-        # Check the output of the normal case for comparison.\n+        # Check the output.\n         browser = self.get_browser()\n+        browser.open(folder1.absolute_url())\n+        self.assert_only_escaped_text(browser)\n+        browser.open(page1.absolute_url())\n+        self.assert_only_escaped_text(browser)\n+        browser.open(folder1.absolute_url() + "/folder_contents")\n+        self.assert_only_escaped_text(browser)\n+\n         browser.open(folder1.absolute_url() + "/@@fc-contextInfo")\n-        self.assertNotIn(ESCAPED, browser.contents)\n-\n-    def test_xss_from_title(self):\n-        # Does a script tag as title show up anywhere in the html?\n-        # It might end up in the main menu.\n-\n-        # Create a folder and page with a hacked title.\n-        setRoles(self.portal, TEST_USER_ID, ["Manager", "Member"])\n-        self.portal.invokeFactory("Folder", id="folder2", title=HACKED)\n-        folder2 = self.portal.folder2\n-        self.assertEqual(folder2.Title(), HACKED)\n-        folder2.invokeFactory("Document", id="page2", title=HACKED)\n-        page2 = folder2.page2\n-        self.assertEqual(page2.Title(), HACKED)\n+        self.assert_only_escaped_text(browser)\n+\n+    def test_xss(self):\n+        self.portal.invokeFactory(\n+            "Folder",\n+            id="folder1",\n+            title=HACKED,\n+            description=HACKED,\n+            creators=(HACKED,),\n+            contributors=(HACKED,),\n+        )\n+        folder1 = self.portal.folder1\n+        self.assertEqual(folder1.Title(), HACKED)\n+        # With good old Archetypes the description gets cleaned up to\n+        # \'The  alert("hacker")  was here.\'\n+        # self.assertEqual(folder1.Description(), HACKED)\n+        folder1.invokeFactory(\n+            "Document",\n+            id="page1",\n+            title=HACKED,\n+            description=HACKED,\n+            creators=(HACKED,),\n+            contributors=(HACKED,),\n+        )\n+        page1 = folder1.page1\n+        self.assertEqual(page1.Title(), HACKED)\n+        # self.assertEqual(page1.Description(), HACKED)\n         transaction.commit()\n \n-        # Check the output of this hacked case.\n+        # Check the output.\n         browser = self.get_browser()\n-        # Note: the content of the normal page, or /folder_contents\n-        # is checked in the plone.app.layout tests.\n-        browser.open(folder2.absolute_url() + "/@@fc-contextInfo")\n-        self.assert_not_hacked(browser)\n+        browser.open(folder1.absolute_url())\n+        self.assert_not_in(HACKED, browser.contents)\n+        browser.open(page1.absolute_url())\n+        self.assert_not_in(HACKED, browser.contents)\n+        browser.open(folder1.absolute_url() + "/folder_contents")\n+        self.assert_not_in(HACKED, browser.contents)\n+\n+        browser.open(folder1.absolute_url() + "/@@fc-contextInfo")\n+        self.assert_not_in(HACKED, browser.contents)\n+\n+    def assert_only_escaped_text(self, browser):\n+        body = browser.contents\n+        # The escaped version of the text text should be in the response text.\n+        self.assertIn(ESCAPED_TEXT, body)\n+        # The normal version should not.\n+        self.assert_not_in(NORMAL_TEXT, body)\n+        # We should avoid escaping twice.\n+        self.assert_not_in(DOUBLY_ESCAPED_TEXT, body)\n+\n+    def assert_not_in(self, target, body):\n+        # This gives a too verbose error message, showing the entire body:\n+        # self.assertNotIn("x", body)\n+        # So we roll our own less verbose version.\n+        if target not in body:\n+            return\n+        index = body.index(target)\n+        start = max(0, index - 50)\n+        end = min(index + len(target) + 50, len(body))\n+        assert False, "Text \'{0}\' unexpectedly found in body: ... {1} ...".format(\n+            target, body[start:end]\n+        )\ndiff --git a/plone/app/content/tests/test_widgets.py b/plone/app/content/tests/test_widgets.py\nindex 5f80cfd..7b134c2 100644\n--- a/plone/app/content/tests/test_widgets.py\n+++ b/plone/app/content/tests/test_widgets.py\n@@ -25,6 +25,7 @@\n from zope.publisher.browser import TestRequest\n \n import json\n+import operator\n import os\n import transaction\n import unittest\n@@ -350,18 +351,30 @@ def testVocabularyUsers(self):\n         acl_users = self.portal.acl_users\n         membership = self.portal.portal_membership\n         amount = 10\n+        # Let\'s test that safe html is used on the fullname,\n+        # as alternative to the workaround in PloneHotfix20210518.\n         for i in range(amount):\n             id = \'user\' + str(i)\n             acl_users.userFolderAddUser(id, \'secret\', [\'Member\'], [])\n             member = membership.getMemberById(id)\n-            member.setMemberProperties(mapping={"fullname": id})\n+            # Make user0 the hacker.\n+            if i == 0:\n+                fullname = "user <script>alert(\'tag\')</script> hacker"\n+            else:\n+                fullname = id\n+            member.setMemberProperties(mapping={"fullname": fullname})\n         view = VocabularyView(self.portal, self.request)\n         self.request.form.update({\n             \'name\': \'plone.app.vocabularies.Users\',\n             \'query\': \'user\'\n         })\n         data = json.loads(view())\n+\n         self.assertEqual(len(data[\'results\']), amount)\n+        # Let\'s sort, just to be sure.\n+        results = sorted(data[\'results\'], key=operator.itemgetter("id"))\n+        # The first one is the hacker.  The hack should have failed.\n+        self.assertDictEqual(results[0], {\'id\': \'user0\', \'text\': \'user  hacker\'})\n \n     def testSource(self):\n         from z3c.form.browser.text import TextWidget\n'

