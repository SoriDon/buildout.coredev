Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/a1859f10bb4f9c5ca4611bdd679313ec06a70ca7

Include a controlpanel for relations.

Transfer of views from collective.relationhelpers.
make a comon structure and do it as one controlpanel with two tabs.

Files changed:
A Products/CMFPlone/controlpanel/browser/relations.py
A Products/CMFPlone/controlpanel/browser/relations_inspect.pt
A Products/CMFPlone/controlpanel/browser/relations_rebuild.pt
M Products/CMFPlone/controlpanel/browser/configure.zcml
M Products/CMFPlone/controlpanel/permissions.zcml

b'diff --git a/Products/CMFPlone/controlpanel/browser/configure.zcml b/Products/CMFPlone/controlpanel/browser/configure.zcml\nindex 8e2cafd0b6..c87fa46c2c 100644\n--- a/Products/CMFPlone/controlpanel/browser/configure.zcml\n+++ b/Products/CMFPlone/controlpanel/browser/configure.zcml\n@@ -321,4 +321,19 @@\n       allowed_attributes="redirects view_url"\n       />\n \n+  <!-- Relations -->\n+\n+  <permission\n+      id="Products.CMFPlone.ManageRelations"\n+      title="Manage Relations"\n+      />\n+\n+  <browser:page\n+      name="Inspect relations"\n+      for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+      class=".relations.RelationsInspectControlPanel"\n+      template="relations_inspect.pt"\n+      permission="Products.CMFPlone.ManageRelations"\n+      />\n+\n </configure>\ndiff --git a/Products/CMFPlone/controlpanel/browser/relations.py b/Products/CMFPlone/controlpanel/browser/relations.py\nnew file mode 100644\nindex 0000000000..72d384c11e\n--- /dev/null\n+++ b/Products/CMFPlone/controlpanel/browser/relations.py\n@@ -0,0 +1,612 @@\n+# -*- coding: UTF-8 -*-\n+from AccessControl.SecurityManagement import getSecurityManager\n+from collections import Counter\n+from collections import defaultdict\n+from five.intid.intid import addIntIdSubscriber\n+from plone import api\n+from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n+from plone.app.iterate.dexterity.relation import StagingRelationValue\n+from plone.app.linkintegrity.handlers import modifiedContent\n+from plone.app.linkintegrity.utils import referencedRelationship\n+from plone.app.relationfield.event import update_behavior_relations\n+from plone.app.uuid.utils import uuidToObject\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.dexterity.interfaces import IDexterityFTI\n+from plone.dexterity.utils import iterSchemataForType\n+from Products.CMFCore.interfaces import IContentish\n+from Products.Five.browser import BrowserView\n+from z3c.relationfield import event\n+from z3c.relationfield import RelationValue\n+from z3c.relationfield.event import updateRelations\n+from z3c.relationfield.schema import Relation\n+from z3c.relationfield.schema import RelationChoice\n+from z3c.relationfield.schema import RelationList\n+from zc.relation.interfaces import ICatalog\n+from zope.annotation.interfaces import IAnnotations\n+from zope.component import getUtility\n+from zope.component import queryUtility\n+from zope.intid.interfaces import IIntIds\n+from zope.lifecycleevent import modified\n+\n+import json\n+import logging\n+\n+logger = logging.getLogger(__name__)\n+\n+RELATIONS_KEY = \'ALL_REFERENCES\'\n+\n+\n+class RelationsRebuildControlpanel(BrowserView):\n+\n+    def __call__(self, rebuild=False, flush_and_rebuild_intids=False):\n+        self.done = False\n+        if rebuild:\n+            rebuild_relations(flush_and_rebuild_intids=flush_and_rebuild_intids)\n+            self.done = True\n+            api.portal.show_message(u\'Finished! See log for details.\', self.request)\n+\n+        self.relations_stats = get_relations_stats()\n+        return self.index()\n+\n+\n+class RelationsInspectControlpanel(BrowserView):\n+\n+    def __call__(self, relation=None, inspect_backrelation=False):\n+        self.relation = relation or self.request.get(\'relation\')\n+        self.inspect_backrelation = inspect_backrelation or self.request.get(\'inspect_backrelation\')\n+\n+        self.relations = []\n+        self.relations_stats = get_relations_stats()\n+        view_action = api.portal.get_registry_record(\'plone.types_use_view_action_in_listings\')\n+\n+        if not self.relation:\n+            api.portal.show_message(u\'Please select a relation\', self.request)\n+            return self.index()\n+\n+        intids = queryUtility(IIntIds)\n+        relation_catalog = getUtility(ICatalog)\n+        query = {\'from_attribute\': self.relation}\n+        info = defaultdict(list)\n+\n+        # relations: column_1 = source, column_2 = target(s)\n+        # backrelation: column_1 = target, column_2 source(s)\n+        for rel in relation_catalog.findRelations(query):\n+            if self.inspect_backrelation:\n+                info[rel.to_id].append(rel.from_id)\n+            else:\n+                info[rel.from_id].append(rel.to_id)\n+\n+        for column_1_intid in info:\n+            obj = intids.getObject(column_1_intid)\n+            use_view_action = obj.portal_type in view_action\n+            url = obj.absolute_url() + \'/view\' if use_view_action else obj.absolute_url()\n+            item = {}\n+            item[\'column_1\'] = {\n+                \'title\': obj.title,\n+                \'url\': url,\n+                \'portal_type\': obj.portal_type,\n+            }\n+            item[\'column_2\'] = []\n+            for column_2_intid in info[column_1_intid]:\n+                obj = intids.getObject(column_2_intid)\n+                use_view_action = obj.portal_type in view_action\n+                url = obj.absolute_url() + \'/view\' if use_view_action else obj.absolute_url()\n+                item[\'column_2\'].append({\n+                    \'title\': obj.title,\n+                    \'url\': url,\n+                    \'portal_type\': obj.portal_type,\n+                    })\n+            self.relations.append(item)\n+\n+        return self.index()\n+\n+\n+def rebuild_relations(context=None, flush_and_rebuild_intids=False):\n+    store_relations()\n+    purge_relations()\n+    if flush_and_rebuild_intids:\n+        flush_intids()\n+        rebuild_intids()\n+    else:\n+        cleanup_intids()\n+    restore_relations()\n+\n+\n+def get_relations_stats():\n+    info = defaultdict(int)\n+    relation_catalog = getUtility(ICatalog)\n+    for rel in relation_catalog.findRelations():\n+        if rel.isBroken():\n+            info[rel.from_attribute + \' (broken)\'] += 1\n+        else:\n+            info[rel.from_attribute] += 1\n+    return info\n+\n+\n+def get_all_relations():\n+    """Get all data from zc.relation catalog.\n+    Logs some useful statistics.\n+    """\n+    results = []\n+    info = defaultdict(int)\n+\n+    relation_catalog = getUtility(ICatalog)\n+    for rel in relation_catalog.findRelations():\n+        if rel.from_object and rel.to_object:\n+            try:\n+                results.append({\n+                    \'from_uuid\': rel.from_object.UID(),\n+                    \'to_uuid\': rel.to_object.UID(),\n+                    \'from_attribute\': rel.from_attribute,\n+                })\n+                info[rel.from_attribute] += 1\n+            except AttributeError as ex:\n+                logger.info(u\'Something went wrong while storing {0}: \\n {1}\'.format(rel, ex))\n+        else:\n+            logger.info(u\'Dropping relation {} from {} to {}\'.format(rel.from_attribute, rel.from_object, rel.to_object))\n+    msg = \'\'\n+    for k, v in info.items():\n+        msg += u\'{}: {}\\n\'.format(k, v)\n+    logger.info(u\'\\nFound the following relations:\\n{}\'.format(msg))\n+    return results\n+\n+\n+def store_relations(context=None):\n+    """Store all relations in a annotation on the portal.\n+    """\n+    all_relations = get_all_relations()\n+    portal = api.portal.get()\n+    IAnnotations(portal)[RELATIONS_KEY] = all_relations\n+    logger.info(\'Stored {0} relations on the portal\'.format(\n+        len(all_relations))\n+    )\n+\n+\n+def export_relations(context=None):\n+    """Store all relations in a annotation on the portal.\n+    """\n+    all_relations = get_all_relations()\n+    with open(\'all_relations.json\', \'w\') as f:\n+        json.dump(all_relations, f)\n+        logger.info(\'Stored {0} relations as all_relations.json\'.format(\n+            len(all_relations))\n+        )\n+\n+\n+def purge_relations(context=None):\n+    """Removes all entries form zc.relation catalog.\n+    RelationValues that were set as attribute on content are still there!\n+    These are removed/overwritten when restoring the relations.\n+    """\n+    rel_catalog = getUtility(ICatalog)\n+    rel_catalog.clear()\n+    logger.info(\'Purged zc.relation catalog\')\n+\n+\n+def restore_relations(context=None, all_relations=None):\n+    """Restore relations from a annotation on the portal.\n+    """\n+\n+    portal = api.portal.get()\n+    if all_relations is None:\n+        all_relations = IAnnotations(portal)[RELATIONS_KEY]\n+    logger.info(\'Loaded {0} relations to restore\'.format(\n+        len(all_relations))\n+    )\n+    update_linkintegrity = set()\n+    modified_items = set()\n+    modified_relation_lists = defaultdict(list)\n+\n+    # remove duplicates but keep original order\n+    unique_relations = []\n+    seen = set()\n+    seen_add = seen.add\n+    for i in all_relations:\n+        hashable = tuple(i.items())\n+        if hashable not in seen:\n+            unique_relations.append(i)\n+            seen_add(hashable)\n+        else:\n+            logger.info(u\'Dropping duplicate: {}\'.format(hashable))\n+\n+    if len(unique_relations) < len(all_relations):\n+        logger.info(\'Dropping {0} duplicates\'.format(\n+            len(all_relations) - len(unique_relations)))\n+        all_relations = unique_relations\n+\n+    intids = getUtility(IIntIds)\n+    for index, item in enumerate(all_relations, start=1):\n+        if not index % 500:\n+            logger.info(u\'Restored {} of {} relations...\'.format(index, len(all_relations)))\n+        source_obj = uuidToObject(item[\'from_uuid\'])\n+        target_obj = uuidToObject(item[\'to_uuid\'])\n+\n+        if not source_obj:\n+            logger.info(u\'{} is missing\'.format(item[\'from_uuid\']))\n+            continue\n+\n+        if not target_obj:\n+            logger.info(u\'{} is missing\'.format(item[\'to_uuid\']))\n+            continue\n+\n+        if not IDexterityContent.providedBy(source_obj):\n+            logger.info(u\'{} is no dexterity content\'.format(source_obj.portal_type))\n+            continue\n+\n+        if not IDexterityContent.providedBy(target_obj):\n+            logger.info(u\'{} is no dexterity content\'.format(target_obj.portal_type))\n+            continue\n+\n+        from_attribute = item[\'from_attribute\']\n+        to_id = intids.getId(target_obj)\n+\n+        if from_attribute == referencedRelationship:\n+            # Ignore linkintegrity for now. We\'ll rebuilt it at the end!\n+            update_linkintegrity.add(item[\'from_uuid\'])\n+            continue\n+\n+        if from_attribute == ITERATE_RELATION_NAME:\n+            # Iterate relations are not set as values of fields\n+            relation = StagingRelationValue(to_id)\n+            event._setRelation(source_obj, ITERATE_RELATION_NAME, relation)\n+            continue\n+\n+        fti = getUtility(IDexterityFTI, name=source_obj.portal_type)\n+        field_and_schema = get_field_and_schema_for_fieldname(from_attribute, fti)\n+        if field_and_schema is None:\n+            # the from_attribute is no field\n+            # we could either create a fresh relation or log the case\n+            logger.info(u\'No field. Setting relation: {}\'.format(item))\n+            event._setRelation(source_obj, from_attribute, RelationValue(to_id))\n+            continue\n+\n+        field, schema = field_and_schema\n+        relation = RelationValue(to_id)\n+\n+        if isinstance(field, RelationList):\n+            logger.info(\'Add relation to relationslist {} from {} to {}\'.format(\n+                from_attribute, source_obj.absolute_url(), target_obj.absolute_url()))\n+            if item[\'from_uuid\'] in modified_relation_lists.get(from_attribute, []):\n+                # Do not purge relations\n+                existing_relations = getattr(source_obj, from_attribute, [])\n+            else:\n+                # First touch. Make sure we purge!\n+                existing_relations = []\n+            existing_relations.append(relation)\n+            setattr(source_obj, from_attribute, existing_relations)\n+            modified_items.add(item[\'from_uuid\'])\n+            modified_relation_lists[from_attribute].append(item[\'from_uuid\'])\n+            continue\n+\n+        elif isinstance(field, (Relation, RelationChoice)):\n+            logger.info(\'Add relation {} from {} to {}\'.format(\n+                from_attribute, source_obj.absolute_url(), target_obj.absolute_url()))\n+            setattr(source_obj, from_attribute, relation)\n+            modified_items.add(item[\'from_uuid\'])\n+            continue\n+\n+        else:\n+            # we should never end up here!\n+            logger.info(\'Warning: Unexpected relation {} from {} to {}\'.format(\n+                from_attribute, source_obj.absolute_url(), target_obj.absolute_url()))\n+\n+    update_linkintegrity = set(update_linkintegrity)\n+    logger.info(\'Updating linkintegrity for {} items\'.format(len(update_linkintegrity)))\n+    for uuid in sorted(update_linkintegrity):\n+        modifiedContent(uuidToObject(uuid), None)\n+    logger.info(\'Updating relations for {} items\'.format(len(modified_items)))\n+    for uuid in sorted(modified_items):\n+        obj = uuidToObject(uuid)\n+        # updateRelations from z3c.relationfield does not properly update relations in behaviors\n+        # that are registered with a marker-interface.\n+        # update_behavior_relations (from plone.app.relationfield) does that but does not update\n+        # those in the main schema. Duh!\n+        updateRelations(obj, None)\n+        update_behavior_relations(obj, None)\n+\n+    # purge annotation from portal if they exist\n+    if RELATIONS_KEY in IAnnotations(portal):\n+        del IAnnotations(portal)[RELATIONS_KEY]\n+    logger.info(\'Done!\')\n+\n+\n+def link_objects(source, target, relationship):\n+    """Create a relation from source to target using zc.relation\n+\n+    For RelationChoice or RelationList it will add the relation as attribute.\n+    Other relations they will only be added to the relation-catalog.\n+    """\n+    if not IDexterityContent.providedBy(source):\n+        logger.info(u\'{} is no dexterity content\'.format(source.portal_type))\n+        return\n+\n+    if not IDexterityContent.providedBy(target):\n+        logger.info(u\'{} is no dexterity content\'.format(target.portal_type))\n+        return\n+\n+    relation_catalog = getUtility(ICatalog)\n+    intids = getUtility(IIntIds)\n+    to_id = intids.getId(target)\n+    from_id = intids.getId(source)\n+    from_attribute = relationship\n+\n+    # Check if there is exactly this relation.\n+    # If so remove it and create a fresh one.\n+    query = {\n+        \'from_attribute\': from_attribute,\n+        \'from_id\': from_id,\n+        \'to_id\': to_id,\n+    }\n+    for rel in relation_catalog.findRelations(query):\n+        relation_catalog.unindex(rel)\n+\n+    if from_attribute == referencedRelationship:\n+        # Don\'t mess with linkintegrity-relations!\n+        # Refresh them by triggering this subscriber.\n+        modifiedContent(source, None)\n+        return\n+\n+    if from_attribute == ITERATE_RELATION_NAME:\n+        # Iterate relations use a subclass of RelationValue\n+        relation = StagingRelationValue(to_id)\n+        event._setRelation(source, ITERATE_RELATION_NAME, relation)\n+        return\n+\n+    fti = queryUtility(IDexterityFTI, name=source.portal_type)\n+    if not fti:\n+        logger.info(u\'{} is no dexterity content\'.format(source.portal_type))\n+        return\n+    field_and_schema = get_field_and_schema_for_fieldname(from_attribute, fti)\n+\n+    if field_and_schema is None:\n+        # The relationship is not the name of a field. Only create a relation.\n+        logger.info(u\'No field. Setting relation {} from {} to {}\'.format(\n+            source.absolute_url(), target.absolute_url(), relationship))\n+        event._setRelation(source, from_attribute, RelationValue(to_id))\n+        return\n+\n+    field, schema = field_and_schema\n+\n+    if isinstance(field, RelationList):\n+        logger.info(\'Add relation to relationlist {} from {} to {}\'.format(\n+            from_attribute, source.absolute_url(), target.absolute_url()))\n+        existing_relations = getattr(source, from_attribute, [])\n+        existing_relations.append(RelationValue(to_id))\n+        setattr(source, from_attribute, existing_relations)\n+        modified(source)\n+        return\n+\n+    elif isinstance(field, (Relation, RelationChoice)):\n+        logger.info(\'Add relation {} from {} to {}\'.format(\n+            from_attribute, source.absolute_url(), target.absolute_url()))\n+        setattr(source, from_attribute, RelationValue(to_id))\n+        modified(source)\n+        return\n+\n+    # We should never end up here!\n+    logger.info(\'Warning: Unexpected relation {} from {} to {}\'.format(\n+        from_attribute, source.absolute_url(), target.absolute_url()))\n+\n+\n+# Main API method\n+\n+def get_relations(obj, attribute=None, backrels=False, restricted=True, as_dict=False):\n+    """Get specific relations or backrelations for a content object\n+    """\n+    if not IDexterityContent.providedBy(obj):\n+        logger.info(u\'{} is no dexterity content\'.format(obj))\n+        return\n+\n+    results = []\n+    if as_dict:\n+        results = defaultdict(list)\n+    int_id = get_intid(obj)\n+    if not int_id:\n+        return results\n+\n+    relation_catalog = getUtility(ICatalog)\n+    if not relation_catalog:\n+        return results\n+\n+    query = {}\n+    if backrels:\n+        query[\'to_id\'] = int_id\n+    else:\n+        query[\'from_id\'] = int_id\n+\n+    if restricted:\n+        checkPermission = getSecurityManager().checkPermission\n+\n+    if attribute and isinstance(attribute, (list, tuple)):\n+        # The relation-catalog does not support queries for multiple from_attributes\n+        # We make multiple queries to support this use-case.\n+        relations = []\n+        for from_attribute in attribute:\n+            query[\'from_attribute\'] = from_attribute\n+            relations.extend(relation_catalog.findRelations(query))\n+    elif attribute:\n+        # query with one attribute\n+        query[\'from_attribute\'] = attribute\n+        relations = relation_catalog.findRelations(query)\n+    else:\n+        # query without constraint on a attribute\n+        relations = relation_catalog.findRelations(query)\n+\n+    for relation in relations:\n+        if relation.isBroken():\n+            continue\n+\n+        if backrels:\n+            obj = relation.from_object\n+        else:\n+            obj = relation.to_object\n+\n+        if as_dict:\n+            if restricted:\n+                if checkPermission(\'View\', obj):\n+                    results[relation.from_attribute].append(obj)\n+                else:\n+                    results[relation.from_attribute].append(None)\n+            else:\n+                results[relation.from_attribute].append(obj)\n+        else:\n+            if restricted:\n+                if checkPermission(\'View\', obj):\n+                    results.append(obj)\n+            else:\n+                results.append(obj)\n+    return results\n+\n+\n+# Convenience API\n+\n+def relations(obj, attribute=None, as_dict=False):\n+    """Get related objects"""\n+    return get_relations(obj, attribute=attribute, restricted=True, as_dict=as_dict)\n+\n+\n+def unrestricted_relations(obj, attribute=None, as_dict=False):\n+    """Get related objects without permission check"""\n+    return get_relations(obj, attribute=attribute, restricted=False, as_dict=as_dict)\n+\n+\n+def backrelations(obj, attribute=None, as_dict=False):\n+    """Get objects with a relation to this object."""\n+    return get_relations(obj, attribute=attribute, backrels=True, restricted=True, as_dict=as_dict)\n+\n+\n+def unrestricted_backrelations(obj, attribute=None, as_dict=False):\n+    """Get objects with a relation to this object without permission check"""\n+    return get_relations(obj, attribute=attribute, backrels=True, restricted=False, as_dict=as_dict)\n+\n+\n+# Convenience api to deal with relationchoice\n+\n+def relation(obj, attribute, restricted=True):\n+    """Get related object.\n+    Only valid if the attribute is the name of a relationChoice field on the object.\n+    """\n+    if not attribute:\n+        raise RuntimeError(u\'Missing parameter "attribute"\')\n+\n+    check_for_relationchoice(obj, attribute)\n+    items = get_relations(obj, attribute=attribute, restricted=restricted)\n+    if items:\n+        return items[0]\n+\n+\n+def unrestricted_relation(obj, attribute):\n+    """Get related object without permission checks.\n+    Only valid if the attribute is the name of a relationChoice field on the object.\n+    """\n+    return relation(obj, attribute=attribute, restricted=False)\n+\n+\n+def backrelation(obj, attribute, restricted=True):\n+    """Get relating object.\n+    This makes sense when only one item has a relation of this type to obj.\n+    One example is parent -> child where only one parent can exist.\n+    """\n+    if not attribute:\n+        raise RuntimeError(u\'Missing parameter "attribute"\')\n+\n+    items = get_relations(obj, attribute=attribute, backrels=True, restricted=restricted)\n+    if len(items) > 1:\n+        raise RuntimeError(u\'Multiple incoming relations of type {}.\'.format(attribute))\n+\n+    if items:\n+        source_obj = items[0]\n+        check_for_relationchoice(source_obj, attribute)\n+        return source_obj\n+\n+\n+def unrestricted_backrelation(obj, attribute):\n+    """Get relating object without permission checks.\n+    This makes sense when only one item has a relation of this type to obj.\n+    One example is parent -> child where only one parent can exist.\n+    """\n+    return backrelation(obj, attribute, restricted=False)\n+\n+\n+def check_for_relationchoice(obj, attribute):\n+    """Raise a exception if the attribute is no RelationChoice field for the object.\n+    """\n+    fti = getUtility(IDexterityFTI, name=obj.portal_type)\n+    field_and_schema = get_field_and_schema_for_fieldname(attribute, fti)\n+    if field_and_schema is None:\n+        # No field found\n+        raise RuntimeError(u\'{} is no field on {}.\'.format(\n+            attribute, obj.portal_type))\n+    field, schema = field_and_schema\n+    if not isinstance(field, (Relation, RelationChoice)):\n+        # No RelationChoice field found\n+        raise RuntimeError(u\'{} is no RelationChoice field for {}.\'.format(\n+            attribute, obj.portal_type))\n+\n+\n+def get_intid(obj):\n+    """Intid from intid-catalog"""\n+    intids = queryUtility(IIntIds)\n+    if intids is None:\n+        return\n+    # check that the object has an intid, otherwise there\'s nothing to be done\n+    try:\n+        return intids.getId(obj)\n+    except KeyError:  # noqa\n+        # The object has not been added to the ZODB yet\n+        return\n+\n+\n+def get_field_and_schema_for_fieldname(field_id, fti):\n+    """Get field and its schema from a fti.\n+    """\n+    # Turn form.widgets.IDublinCore.title into title\n+    field_id = field_id.split(\'.\')[-1]\n+    for schema in iterSchemataForType(fti):\n+        field = schema.get(field_id, None)\n+        if field is not None:\n+            return (field, schema)\n+\n+\n+def cleanup_intids(context=None):\n+    intids = getUtility(IIntIds)\n+    all_refs = [\'{}.{}\'.format(i.object.__class__.__module__, i.object.__class__.__name__)\n+                for i in intids.refs.values()]\n+    logger.info(Counter(all_refs))\n+\n+    count = 0\n+    refs = [i for i in intids.refs.values() if isinstance(i.object, RelationValue)]\n+    for ref in refs:\n+        intids.unregister(ref)\n+        count += 1\n+    logger.info(\'Removed all {} RelationValues from IntId-tool\'.format(count))\n+\n+    count = 0\n+    for ref in intids.refs.values():\n+        if \'broken\' in repr(ref.object):\n+            intids.unregister(ref)\n+    logger.info(\'Removed {} broken refs from IntId-tool\'.format(count))\n+    all_refs = [\'{}.{}\'.format(i.object.__class__.__module__, i.object.__class__.__name__)\n+                for i in intids.refs.values()]\n+    logger.info(Counter(all_refs))\n+\n+\n+def flush_intids():\n+    """ Flush all intids\n+    """\n+    intids = getUtility(IIntIds)\n+    intids.ids = intids.family.OI.BTree()\n+    intids.refs = intids.family.IO.BTree()\n+\n+\n+def rebuild_intids():\n+    """ Create new intids\n+    """\n+    def add_to_intids(obj, path):\n+        if IContentish.providedBy(obj):\n+            logger.info(\'Added {0} at {1} to intid\'.format(obj, path))\n+            addIntIdSubscriber(obj, None)\n+    portal = api.portal.get()\n+    portal.ZopeFindAndApply(portal,\n+                            search_sub=True,\n+                            apply_func=add_to_intids)\ndiff --git a/Products/CMFPlone/controlpanel/browser/relations_inspect.pt b/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\nnew file mode 100644\nindex 0000000000..54d6e24552\n--- /dev/null\n+++ b/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\n@@ -0,0 +1,115 @@\n+<html xmlns="http://www.w3.org/1999/xhtml"\n+      xml:lang="en"\n+      xmlns:tal="http://xml.zope.org/namespaces/tal"\n+      xmlns:metal="http://xml.zope.org/namespaces/metal"\n+      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n+      lang="en"\n+      metal:use-macro="context/main_template/macros/master"\n+      i18n:domain="plone">\n+\n+<body>\n+\n+  <metal:content-core fill-slot="main"\n+                      tal:define="inspect_backrelation python: view.inspect_backrelation;\n+                                  relation python: view.relation;">\n+\n+    <header>\n+      <h1 class="documentFirstHeading"\n+          tal:condition="python: not inspect_backrelation">\n+        Inspect relation <strong tal:content="python: relation">relation</strong>\n+      </h1>\n+\n+      <h1 class="documentFirstHeading"\n+          tal:condition="python: inspect_backrelation">\n+        Inspect backrelation <strong tal:content="python: relation">backrelation</strong>\n+      </h1>\n+\n+    </header>\n+\n+    <div id="content-core"\n+         tal:define="relations_stats python: view.relations_stats">\n+\n+      <form id="relationinfo" method="post" action="@@relationinfo" enctype="multipart/form-data">\n+\n+        <div class="mb-3 field">\n+          <select class="form-select" aria-label="Default select example" name="relation" id="relation">\n+            <option value="">Select a relation</option>\n+            <tal:rels tal:repeat="from_attribute python: relations_stats">\n+              <option tal:attributes="value python: from_attribute;\n+                                      selected python: relation == from_attribute"\n+                      tal:content="python:\'{} ({})\'.format(from_attribute, relations_stats[from_attribute])">\n+                  relationname (amount)\n+              </option>\n+            </tal:rels>\n+          </select>\n+        </div>\n+\n+        <div class="mb-3 field">\n+          <div class="form-check" id="inspect_backrelation">\n+            <input id="inspect-backrelation"\n+                   name="inspect_backrelation"\n+                   class="form-check-input single-checkbox-bool-widget bool-field"\n+                   value="selected"\n+                   type="checkbox"\n+                   checked="checked"\n+                   tal:attributes="checked python: \'checked\' if inspect_backrelation else \'\'">\n+            <label for="inspect-backrelation" class="form-check-label">\n+              Show backrelations\n+            </label>\n+            <div class="form-text">Display relations grouped by their target.</div>\n+          </div>\n+        </div>\n+\n+        <button class="context btn btn-primary" type="submit" name="submit" value="submit" i18n:translate="">Go!</button>\n+      </form>\n+\n+      <table class="listing table table-striped"\n+             tal:condition="python:view.relations">\n+        <thead>\n+          <tr tal:condition="python: not inspect_backrelation">\n+            <th>Source</th>\n+            <th>&rarr;</th>\n+            <th>Target(s)</th>\n+          </tr>\n+\n+          <tr tal:condition="python: inspect_backrelation">\n+            <th>Target</th>\n+            <th>&larr;</th>\n+            <th>Source(s)</th>\n+          </tr>\n+        </thead>\n+        <tbody>\n+          <tr tal:repeat="item python:view.relations">\n+            <td>\n+              <a tal:attributes="href python:item[\'column_1\'][\'url\'];\n+                                 title python:item[\'column_1\'][\'portal_type\'];"\n+                 tal:content="python:item[\'column_1\'][\'title\']">\n+                Object\n+              </a>\n+            </td>\n+\n+            <td tal:condition="python: not inspect_backrelation">&rarr;</td>\n+            <td tal:condition="python: inspect_backrelation">&larr;</td>\n+            <td>\n+              <ul>\n+                <li tal:repeat="target python:item[\'column_2\']">\n+                  <a href=""\n+                     tal:attributes="href python:target[\'url\'];\n+                                     title python:target[\'portal_type\']; "\n+                     tal:content="python:target[\'title\']">\n+                    Target\n+                  </a>\n+                </li>\n+              </ul>\n+            </td>\n+          </tr>\n+        </tbody>\n+      </table>\n+\n+    </div>\n+\n+  </metal:content-core>\n+\n+</body>\n+\n+</html>\ndiff --git a/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt b/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt\nnew file mode 100644\nindex 0000000000..0bc52cdd98\n--- /dev/null\n+++ b/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt\n@@ -0,0 +1,99 @@\n+<html xmlns="http://www.w3.org/1999/xhtml"\n+      xml:lang="en"\n+      xmlns:tal="http://xml.zope.org/namespaces/tal"\n+      xmlns:metal="http://xml.zope.org/namespaces/metal"\n+      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n+      lang="en"\n+      metal:use-macro="context/main_template/macros/master"\n+      i18n:domain="plone">\n+\n+<body>\n+\n+  <metal:content-core fill-slot="main">\n+\n+    <header>\n+      <h1 class="documentFirstHeading">Rebuild zc.relation catalog</h1>\n+    </header>\n+\n+    <div id="content-core">\n+\n+      <h3>\n+        <span tal:condition="python:view.done">Success!</span>\n+        Current number of relations in the zc.relation catalog\n+      </h3>\n+\n+      <table class="listing table table-striped"\n+            tal:define="relations_stats python: getattr(view, \'relations_stats\', None)"\n+            tal:condition="python: relations_stats">\n+        <thead>\n+          <tr>\n+            <th>Relation</th>\n+            <th>Amount</th>\n+          </tr>\n+        </thead>\n+        <tbody>\n+          <tr tal:repeat="item python:relations_stats">\n+            <td>\n+              <a href=""\n+                 target="_blank"\n+                 tal:attributes="href python:\'@@relationinfo?relation={}\'.format(item)"\n+                 tal:content="python:item"\n+                 title="Inspect relations">\n+               Type\n+              </a>\n+            </td>\n+            <td tal:content="python:relations_stats[item]">Amount</td>\n+          </tr>\n+        </tbody>\n+      </table>\n+\n+      <h3>Common relations:</h3>\n+      <dl>\n+        <dt>relatedItems</dt>\n+        <dd>Relations between content using the default "Related items" field</dd>\n+\n+        <dt>isReferencing</dt>\n+        <dd>Linkintegrity relations (source has a html-link to target)</dd>\n+\n+        <dt>iterate-working-copy</dt>\n+        <dd>Relation from content to a working copy (using plone.app.iterate)</dd>\n+\n+        <dt>staging-working-copy</dt>\n+        <dd>Outdated relation from content to a working copy (using plone.app.stagingbehavior)</dd>\n+\n+        <dt>(broken)</dt>\n+        <dd>Either source or target no longer exist</dd>\n+\n+        <dt><i>all other</i></dt>\n+        <dd>Custom attribute/fieldname used to describe the relation</dd>\n+      </dl>\n+\n+      <form id="rebuild_relations" method="post" action="@@rebuild_relations" enctype="multipart/form-data">\n+        <h3>Purge and rebuild relation-catalog</h3>\n+        <p>Clicking here will do the following:</p>\n+        <ul>\n+          <li>Get all relations from zc.relation catalog and store them in a annotation on the portal.</li>\n+          <li>Remove all entries form zc.relation catalog.</li>\n+          <li>Clean up or flush and rebuild intids - this depends on your selection below</li>\n+          <li>Restore relations from the annotation on the portal.</li>\n+        </ul>\n+\n+        <div class="form-check">\n+          <input class="form-check-input" type="checkbox" name="flush_and_rebuild_intids" id="flush_intids">\n+          <label class="form-check-label" for="flush_intids" >Flush and rebuild intids</label>\n+          <p>\n+             This will delete all intids and create new one.<br/>\n+             Warning: If you have a lot of relations this can take some time. Check the log for details!<br/>\n+             If you have relations on tiles, flushing and rebuilding intids will destroy them b/c intids changed.\n+          </p>\n+        </div>\n+        <button class="context btn btn-danger" type="submit" name="rebuild" value="rebuild" i18n:translate="">Rebuild</button>\n+\n+      </form>\n+    </div>\n+\n+  </metal:content-core>\n+\n+</body>\n+\n+</html>\ndiff --git a/Products/CMFPlone/controlpanel/permissions.zcml b/Products/CMFPlone/controlpanel/permissions.zcml\nindex 7c128c1307..848dd46351 100644\n--- a/Products/CMFPlone/controlpanel/permissions.zcml\n+++ b/Products/CMFPlone/controlpanel/permissions.zcml\n@@ -79,4 +79,10 @@\n     <role name="Site Administrator"/>\n   </permission>\n \n+  <permission id="plone.app.controlpanel.Relations"\n+              title="Plone Site Setup: Relations">\n+    <role name="Manager"/>\n+    <role name="Site Administrator"/>\n+  </permission>\n+\n </configure>\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/1e0cfb572e4b6f8b073df86289def26fe45b3d35

changelog entry

Files changed:
A news/3231.feature

b'diff --git a/news/3231.feature b/news/3231.feature\nnew file mode 100644\nindex 0000000000..7d1d9a81ae\n--- /dev/null\n+++ b/news/3231.feature\n@@ -0,0 +1,2 @@\n+Include a controlpanel for relations.\n+[loechel]\n\\ No newline at end of file\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/f242fbf2a426798243ec0cb5c6a8feff7c5f04fb

remove obsolete methods that will be moved to plone.api

Files changed:
M Products/CMFPlone/controlpanel/browser/relations.py

b'diff --git a/Products/CMFPlone/controlpanel/browser/relations.py b/Products/CMFPlone/controlpanel/browser/relations.py\nindex 72d384c11e..ad72381614 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations.py\n+++ b/Products/CMFPlone/controlpanel/browser/relations.py\n@@ -1,5 +1,4 @@\n # -*- coding: UTF-8 -*-\n-from AccessControl.SecurityManagement import getSecurityManager\n from collections import Counter\n from collections import defaultdict\n from five.intid.intid import addIntIdSubscriber\n@@ -26,7 +25,6 @@\n from zope.component import getUtility\n from zope.component import queryUtility\n from zope.intid.interfaces import IIntIds\n-from zope.lifecycleevent import modified\n \n import json\n import logging\n@@ -310,240 +308,6 @@ def restore_relations(context=None, all_relations=None):\n     logger.info(\'Done!\')\n \n \n-def link_objects(source, target, relationship):\n-    """Create a relation from source to target using zc.relation\n-\n-    For RelationChoice or RelationList it will add the relation as attribute.\n-    Other relations they will only be added to the relation-catalog.\n-    """\n-    if not IDexterityContent.providedBy(source):\n-        logger.info(u\'{} is no dexterity content\'.format(source.portal_type))\n-        return\n-\n-    if not IDexterityContent.providedBy(target):\n-        logger.info(u\'{} is no dexterity content\'.format(target.portal_type))\n-        return\n-\n-    relation_catalog = getUtility(ICatalog)\n-    intids = getUtility(IIntIds)\n-    to_id = intids.getId(target)\n-    from_id = intids.getId(source)\n-    from_attribute = relationship\n-\n-    # Check if there is exactly this relation.\n-    # If so remove it and create a fresh one.\n-    query = {\n-        \'from_attribute\': from_attribute,\n-        \'from_id\': from_id,\n-        \'to_id\': to_id,\n-    }\n-    for rel in relation_catalog.findRelations(query):\n-        relation_catalog.unindex(rel)\n-\n-    if from_attribute == referencedRelationship:\n-        # Don\'t mess with linkintegrity-relations!\n-        # Refresh them by triggering this subscriber.\n-        modifiedContent(source, None)\n-        return\n-\n-    if from_attribute == ITERATE_RELATION_NAME:\n-        # Iterate relations use a subclass of RelationValue\n-        relation = StagingRelationValue(to_id)\n-        event._setRelation(source, ITERATE_RELATION_NAME, relation)\n-        return\n-\n-    fti = queryUtility(IDexterityFTI, name=source.portal_type)\n-    if not fti:\n-        logger.info(u\'{} is no dexterity content\'.format(source.portal_type))\n-        return\n-    field_and_schema = get_field_and_schema_for_fieldname(from_attribute, fti)\n-\n-    if field_and_schema is None:\n-        # The relationship is not the name of a field. Only create a relation.\n-        logger.info(u\'No field. Setting relation {} from {} to {}\'.format(\n-            source.absolute_url(), target.absolute_url(), relationship))\n-        event._setRelation(source, from_attribute, RelationValue(to_id))\n-        return\n-\n-    field, schema = field_and_schema\n-\n-    if isinstance(field, RelationList):\n-        logger.info(\'Add relation to relationlist {} from {} to {}\'.format(\n-            from_attribute, source.absolute_url(), target.absolute_url()))\n-        existing_relations = getattr(source, from_attribute, [])\n-        existing_relations.append(RelationValue(to_id))\n-        setattr(source, from_attribute, existing_relations)\n-        modified(source)\n-        return\n-\n-    elif isinstance(field, (Relation, RelationChoice)):\n-        logger.info(\'Add relation {} from {} to {}\'.format(\n-            from_attribute, source.absolute_url(), target.absolute_url()))\n-        setattr(source, from_attribute, RelationValue(to_id))\n-        modified(source)\n-        return\n-\n-    # We should never end up here!\n-    logger.info(\'Warning: Unexpected relation {} from {} to {}\'.format(\n-        from_attribute, source.absolute_url(), target.absolute_url()))\n-\n-\n-# Main API method\n-\n-def get_relations(obj, attribute=None, backrels=False, restricted=True, as_dict=False):\n-    """Get specific relations or backrelations for a content object\n-    """\n-    if not IDexterityContent.providedBy(obj):\n-        logger.info(u\'{} is no dexterity content\'.format(obj))\n-        return\n-\n-    results = []\n-    if as_dict:\n-        results = defaultdict(list)\n-    int_id = get_intid(obj)\n-    if not int_id:\n-        return results\n-\n-    relation_catalog = getUtility(ICatalog)\n-    if not relation_catalog:\n-        return results\n-\n-    query = {}\n-    if backrels:\n-        query[\'to_id\'] = int_id\n-    else:\n-        query[\'from_id\'] = int_id\n-\n-    if restricted:\n-        checkPermission = getSecurityManager().checkPermission\n-\n-    if attribute and isinstance(attribute, (list, tuple)):\n-        # The relation-catalog does not support queries for multiple from_attributes\n-        # We make multiple queries to support this use-case.\n-        relations = []\n-        for from_attribute in attribute:\n-            query[\'from_attribute\'] = from_attribute\n-            relations.extend(relation_catalog.findRelations(query))\n-    elif attribute:\n-        # query with one attribute\n-        query[\'from_attribute\'] = attribute\n-        relations = relation_catalog.findRelations(query)\n-    else:\n-        # query without constraint on a attribute\n-        relations = relation_catalog.findRelations(query)\n-\n-    for relation in relations:\n-        if relation.isBroken():\n-            continue\n-\n-        if backrels:\n-            obj = relation.from_object\n-        else:\n-            obj = relation.to_object\n-\n-        if as_dict:\n-            if restricted:\n-                if checkPermission(\'View\', obj):\n-                    results[relation.from_attribute].append(obj)\n-                else:\n-                    results[relation.from_attribute].append(None)\n-            else:\n-                results[relation.from_attribute].append(obj)\n-        else:\n-            if restricted:\n-                if checkPermission(\'View\', obj):\n-                    results.append(obj)\n-            else:\n-                results.append(obj)\n-    return results\n-\n-\n-# Convenience API\n-\n-def relations(obj, attribute=None, as_dict=False):\n-    """Get related objects"""\n-    return get_relations(obj, attribute=attribute, restricted=True, as_dict=as_dict)\n-\n-\n-def unrestricted_relations(obj, attribute=None, as_dict=False):\n-    """Get related objects without permission check"""\n-    return get_relations(obj, attribute=attribute, restricted=False, as_dict=as_dict)\n-\n-\n-def backrelations(obj, attribute=None, as_dict=False):\n-    """Get objects with a relation to this object."""\n-    return get_relations(obj, attribute=attribute, backrels=True, restricted=True, as_dict=as_dict)\n-\n-\n-def unrestricted_backrelations(obj, attribute=None, as_dict=False):\n-    """Get objects with a relation to this object without permission check"""\n-    return get_relations(obj, attribute=attribute, backrels=True, restricted=False, as_dict=as_dict)\n-\n-\n-# Convenience api to deal with relationchoice\n-\n-def relation(obj, attribute, restricted=True):\n-    """Get related object.\n-    Only valid if the attribute is the name of a relationChoice field on the object.\n-    """\n-    if not attribute:\n-        raise RuntimeError(u\'Missing parameter "attribute"\')\n-\n-    check_for_relationchoice(obj, attribute)\n-    items = get_relations(obj, attribute=attribute, restricted=restricted)\n-    if items:\n-        return items[0]\n-\n-\n-def unrestricted_relation(obj, attribute):\n-    """Get related object without permission checks.\n-    Only valid if the attribute is the name of a relationChoice field on the object.\n-    """\n-    return relation(obj, attribute=attribute, restricted=False)\n-\n-\n-def backrelation(obj, attribute, restricted=True):\n-    """Get relating object.\n-    This makes sense when only one item has a relation of this type to obj.\n-    One example is parent -> child where only one parent can exist.\n-    """\n-    if not attribute:\n-        raise RuntimeError(u\'Missing parameter "attribute"\')\n-\n-    items = get_relations(obj, attribute=attribute, backrels=True, restricted=restricted)\n-    if len(items) > 1:\n-        raise RuntimeError(u\'Multiple incoming relations of type {}.\'.format(attribute))\n-\n-    if items:\n-        source_obj = items[0]\n-        check_for_relationchoice(source_obj, attribute)\n-        return source_obj\n-\n-\n-def unrestricted_backrelation(obj, attribute):\n-    """Get relating object without permission checks.\n-    This makes sense when only one item has a relation of this type to obj.\n-    One example is parent -> child where only one parent can exist.\n-    """\n-    return backrelation(obj, attribute, restricted=False)\n-\n-\n-def check_for_relationchoice(obj, attribute):\n-    """Raise a exception if the attribute is no RelationChoice field for the object.\n-    """\n-    fti = getUtility(IDexterityFTI, name=obj.portal_type)\n-    field_and_schema = get_field_and_schema_for_fieldname(attribute, fti)\n-    if field_and_schema is None:\n-        # No field found\n-        raise RuntimeError(u\'{} is no field on {}.\'.format(\n-            attribute, obj.portal_type))\n-    field, schema = field_and_schema\n-    if not isinstance(field, (Relation, RelationChoice)):\n-        # No RelationChoice field found\n-        raise RuntimeError(u\'{} is no RelationChoice field for {}.\'.format(\n-            attribute, obj.portal_type))\n-\n-\n def get_intid(obj):\n     """Intid from intid-catalog"""\n     intids = queryUtility(IIntIds)\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/c443f05414e491ad800ece651132c13f15a81da5

Fix zcml and form-actions. Register controlpanel. python3.

Files changed:
M Products/CMFPlone/controlpanel/browser/configure.zcml
M Products/CMFPlone/controlpanel/browser/relations.py
M Products/CMFPlone/controlpanel/browser/relations_inspect.pt
M Products/CMFPlone/controlpanel/browser/relations_rebuild.pt
M Products/CMFPlone/profiles/default/controlpanel.xml

b'diff --git a/Products/CMFPlone/controlpanel/browser/configure.zcml b/Products/CMFPlone/controlpanel/browser/configure.zcml\nindex c87fa46c2c..dfde40f1af 100644\n--- a/Products/CMFPlone/controlpanel/browser/configure.zcml\n+++ b/Products/CMFPlone/controlpanel/browser/configure.zcml\n@@ -329,11 +329,19 @@\n       />\n \n   <browser:page\n-      name="Inspect relations"\n+      name="inspect-relations"\n       for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-      class=".relations.RelationsInspectControlPanel"\n+      class=".relations.RelationsInspectControlpanel"\n       template="relations_inspect.pt"\n       permission="Products.CMFPlone.ManageRelations"\n       />\n \n+  <browser:page\n+      name="rebuild-relations"\n+      for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+      class=".relations.RelationsRebuildControlpanel"\n+      template="relations_rebuild.pt"\n+      permission="cmf.ManagePortal"\n+      />\n+\n </configure>\ndiff --git a/Products/CMFPlone/controlpanel/browser/relations.py b/Products/CMFPlone/controlpanel/browser/relations.py\nindex ad72381614..8c43b7f00f 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations.py\n+++ b/Products/CMFPlone/controlpanel/browser/relations.py\n@@ -1,4 +1,3 @@\n-# -*- coding: UTF-8 -*-\n from collections import Counter\n from collections import defaultdict\n from five.intid.intid import addIntIdSubscriber\n@@ -41,7 +40,7 @@ def __call__(self, rebuild=False, flush_and_rebuild_intids=False):\n         if rebuild:\n             rebuild_relations(flush_and_rebuild_intids=flush_and_rebuild_intids)\n             self.done = True\n-            api.portal.show_message(u\'Finished! See log for details.\', self.request)\n+            api.portal.show_message(\'Finished! See log for details.\', self.request)\n \n         self.relations_stats = get_relations_stats()\n         return self.index()\n@@ -58,7 +57,7 @@ def __call__(self, relation=None, inspect_backrelation=False):\n         view_action = api.portal.get_registry_record(\'plone.types_use_view_action_in_listings\')\n \n         if not self.relation:\n-            api.portal.show_message(u\'Please select a relation\', self.request)\n+            api.portal.show_message(\'Please select a relation\', self.request)\n             return self.index()\n \n         intids = queryUtility(IIntIds)\n@@ -139,13 +138,13 @@ def get_all_relations():\n                 })\n                 info[rel.from_attribute] += 1\n             except AttributeError as ex:\n-                logger.info(u\'Something went wrong while storing {0}: \\n {1}\'.format(rel, ex))\n+                logger.info(\'Something went wrong while storing {0}: \\n {1}\'.format(rel, ex))\n         else:\n-            logger.info(u\'Dropping relation {} from {} to {}\'.format(rel.from_attribute, rel.from_object, rel.to_object))\n+            logger.info(\'Dropping relation {} from {} to {}\'.format(rel.from_attribute, rel.from_object, rel.to_object))\n     msg = \'\'\n     for k, v in info.items():\n-        msg += u\'{}: {}\\n\'.format(k, v)\n-    logger.info(u\'\\nFound the following relations:\\n{}\'.format(msg))\n+        msg += \'{}: {}\\n\'.format(k, v)\n+    logger.info(\'\\nFound the following relations:\\n{}\'.format(msg))\n     return results\n \n \n@@ -205,7 +204,7 @@ def restore_relations(context=None, all_relations=None):\n             unique_relations.append(i)\n             seen_add(hashable)\n         else:\n-            logger.info(u\'Dropping duplicate: {}\'.format(hashable))\n+            logger.info(\'Dropping duplicate: {}\'.format(hashable))\n \n     if len(unique_relations) < len(all_relations):\n         logger.info(\'Dropping {0} duplicates\'.format(\n@@ -215,24 +214,24 @@ def restore_relations(context=None, all_relations=None):\n     intids = getUtility(IIntIds)\n     for index, item in enumerate(all_relations, start=1):\n         if not index % 500:\n-            logger.info(u\'Restored {} of {} relations...\'.format(index, len(all_relations)))\n+            logger.info(\'Restored {} of {} relations...\'.format(index, len(all_relations)))\n         source_obj = uuidToObject(item[\'from_uuid\'])\n         target_obj = uuidToObject(item[\'to_uuid\'])\n \n         if not source_obj:\n-            logger.info(u\'{} is missing\'.format(item[\'from_uuid\']))\n+            logger.info(\'{} is missing\'.format(item[\'from_uuid\']))\n             continue\n \n         if not target_obj:\n-            logger.info(u\'{} is missing\'.format(item[\'to_uuid\']))\n+            logger.info(\'{} is missing\'.format(item[\'to_uuid\']))\n             continue\n \n         if not IDexterityContent.providedBy(source_obj):\n-            logger.info(u\'{} is no dexterity content\'.format(source_obj.portal_type))\n+            logger.info(\'{} is no dexterity content\'.format(source_obj.portal_type))\n             continue\n \n         if not IDexterityContent.providedBy(target_obj):\n-            logger.info(u\'{} is no dexterity content\'.format(target_obj.portal_type))\n+            logger.info(\'{} is no dexterity content\'.format(target_obj.portal_type))\n             continue\n \n         from_attribute = item[\'from_attribute\']\n@@ -254,7 +253,7 @@ def restore_relations(context=None, all_relations=None):\n         if field_and_schema is None:\n             # the from_attribute is no field\n             # we could either create a fresh relation or log the case\n-            logger.info(u\'No field. Setting relation: {}\'.format(item))\n+            logger.info(\'No field. Setting relation: {}\'.format(item))\n             event._setRelation(source_obj, from_attribute, RelationValue(to_id))\n             continue\n \ndiff --git a/Products/CMFPlone/controlpanel/browser/relations_inspect.pt b/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\nindex 54d6e24552..2fef528f4f 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\n+++ b/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\n@@ -29,7 +29,7 @@\n     <div id="content-core"\n          tal:define="relations_stats python: view.relations_stats">\n \n-      <form id="relationinfo" method="post" action="@@relationinfo" enctype="multipart/form-data">\n+      <form id="relationinfo" method="post" action="@@inspect-relations" enctype="multipart/form-data">\n \n         <div class="mb-3 field">\n           <select class="form-select" aria-label="Default select example" name="relation" id="relation">\ndiff --git a/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt b/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt\nindex 0bc52cdd98..7d5c01f97f 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt\n+++ b/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt\n@@ -36,7 +36,7 @@\n             <td>\n               <a href=""\n                  target="_blank"\n-                 tal:attributes="href python:\'@@relationinfo?relation={}\'.format(item)"\n+                 tal:attributes="href python:\'@@inspect-relations?relation={}\'.format(item)"\n                  tal:content="python:item"\n                  title="Inspect relations">\n                Type\n@@ -68,7 +68,7 @@\n         <dd>Custom attribute/fieldname used to describe the relation</dd>\n       </dl>\n \n-      <form id="rebuild_relations" method="post" action="@@rebuild_relations" enctype="multipart/form-data">\n+      <form id="rebuild_relations" method="post" action="@@rebuild-relations" enctype="multipart/form-data">\n         <h3>Purge and rebuild relation-catalog</h3>\n         <p>Clicking here will do the following:</p>\n         <ul>\ndiff --git a/Products/CMFPlone/profiles/default/controlpanel.xml b/Products/CMFPlone/profiles/default/controlpanel.xml\nindex 6507e38c31..217f055364 100644\n--- a/Products/CMFPlone/profiles/default/controlpanel.xml\n+++ b/Products/CMFPlone/profiles/default/controlpanel.xml\n@@ -213,4 +213,13 @@\n     i18n:attributes="title">\n   <permission>Manage Portal Aliases</permission>\n  </configlet>\n+ <configlet title="Relations" action_id="inspectrelations"\n+    icon_expr="string:$portal_url/action_icon.png"\n+    appId="Plone" category="plone-content"\n+    condition_expr=""\n+    url_expr="string:${portal_url}/@@inspect-relations"\n+    visible="True"\n+    i18n:attributes="title">\n+  <permission>Manage Relations</permission>\n+ </configlet>\n </object>\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/19cc3e3e37d97e17958f71f59afd2f7aa509f919

fix some issues from code-review

Files changed:
M Products/CMFPlone/controlpanel/browser/configure.zcml
M Products/CMFPlone/controlpanel/browser/relations.py
M Products/CMFPlone/controlpanel/permissions.zcml

b'diff --git a/Products/CMFPlone/controlpanel/browser/configure.zcml b/Products/CMFPlone/controlpanel/browser/configure.zcml\nindex dfde40f1af..48dc844325 100644\n--- a/Products/CMFPlone/controlpanel/browser/configure.zcml\n+++ b/Products/CMFPlone/controlpanel/browser/configure.zcml\n@@ -323,17 +323,12 @@\n \n   <!-- Relations -->\n \n-  <permission\n-      id="Products.CMFPlone.ManageRelations"\n-      title="Manage Relations"\n-      />\n-\n   <browser:page\n       name="inspect-relations"\n       for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n       class=".relations.RelationsInspectControlpanel"\n       template="relations_inspect.pt"\n-      permission="Products.CMFPlone.ManageRelations"\n+      permission="Products.CMFPlone.InspectRelations"\n       />\n \n   <browser:page\ndiff --git a/Products/CMFPlone/controlpanel/browser/relations.py b/Products/CMFPlone/controlpanel/browser/relations.py\nindex 8c43b7f00f..6422b51627 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations.py\n+++ b/Products/CMFPlone/controlpanel/browser/relations.py\n@@ -9,7 +9,6 @@\n from plone.app.relationfield.event import update_behavior_relations\n from plone.app.uuid.utils import uuidToObject\n from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.interfaces import IDexterityFTI\n from plone.dexterity.utils import iterSchemataForType\n from Products.CMFCore.interfaces import IContentish\n from Products.Five.browser import BrowserView\n@@ -138,13 +137,13 @@ def get_all_relations():\n                 })\n                 info[rel.from_attribute] += 1\n             except AttributeError as ex:\n-                logger.info(\'Something went wrong while storing {0}: \\n {1}\'.format(rel, ex))\n+                logger.info(f\'Something went wrong while storing {rel}: \\n {ex}\')\n         else:\n-            logger.info(\'Dropping relation {} from {} to {}\'.format(rel.from_attribute, rel.from_object, rel.to_object))\n+            logger.info(f\'Dropping relation {rel.from_attribute} from {rel.from_object} to {rel.to_object}\')\n     msg = \'\'\n     for k, v in info.items():\n-        msg += \'{}: {}\\n\'.format(k, v)\n-    logger.info(\'\\nFound the following relations:\\n{}\'.format(msg))\n+        msg += f\'{k}: {v}\\n\'\n+    logger.info(f\'\\nFound the following relations:\\n{msg}\')\n     return results\n \n \n@@ -154,20 +153,7 @@ def store_relations(context=None):\n     all_relations = get_all_relations()\n     portal = api.portal.get()\n     IAnnotations(portal)[RELATIONS_KEY] = all_relations\n-    logger.info(\'Stored {0} relations on the portal\'.format(\n-        len(all_relations))\n-    )\n-\n-\n-def export_relations(context=None):\n-    """Store all relations in a annotation on the portal.\n-    """\n-    all_relations = get_all_relations()\n-    with open(\'all_relations.json\', \'w\') as f:\n-        json.dump(all_relations, f)\n-        logger.info(\'Stored {0} relations as all_relations.json\'.format(\n-            len(all_relations))\n-        )\n+    logger.info(f\'Stored {len(all_relations)} relations on the portal\')\n \n \n def purge_relations(context=None):\n@@ -187,9 +173,7 @@ def restore_relations(context=None, all_relations=None):\n     portal = api.portal.get()\n     if all_relations is None:\n         all_relations = IAnnotations(portal)[RELATIONS_KEY]\n-    logger.info(\'Loaded {0} relations to restore\'.format(\n-        len(all_relations))\n-    )\n+    logger.info(f\'Loaded {len(all_relations)} relations to restore\')\n     update_linkintegrity = set()\n     modified_items = set()\n     modified_relation_lists = defaultdict(list)\n@@ -198,40 +182,39 @@ def restore_relations(context=None, all_relations=None):\n     unique_relations = []\n     seen = set()\n     seen_add = seen.add\n-    for i in all_relations:\n-        hashable = tuple(i.items())\n+    for rel in all_relations:\n+        hashable = tuple(rel.items())\n         if hashable not in seen:\n-            unique_relations.append(i)\n+            unique_relations.append(rel)\n             seen_add(hashable)\n         else:\n-            logger.info(\'Dropping duplicate: {}\'.format(hashable))\n+            logger.info(f\'Dropping duplicate: {hashable}\')\n \n     if len(unique_relations) < len(all_relations):\n-        logger.info(\'Dropping {0} duplicates\'.format(\n-            len(all_relations) - len(unique_relations)))\n+        logger.info(f\'Dropping {len(all_relations) - len(unique_relations)} duplicates\')\n         all_relations = unique_relations\n \n     intids = getUtility(IIntIds)\n     for index, item in enumerate(all_relations, start=1):\n         if not index % 500:\n-            logger.info(\'Restored {} of {} relations...\'.format(index, len(all_relations)))\n+            logger.info(f\'Restored {index} of {len(all_relations)} relations...\')\n         source_obj = uuidToObject(item[\'from_uuid\'])\n         target_obj = uuidToObject(item[\'to_uuid\'])\n \n         if not source_obj:\n-            logger.info(\'{} is missing\'.format(item[\'from_uuid\']))\n+            logger.info(f\'{item["from_uuid"]} is missing\')\n             continue\n \n         if not target_obj:\n-            logger.info(\'{} is missing\'.format(item[\'to_uuid\']))\n+            logger.info(f\'{item["to_uuid"]} is missing\')\n             continue\n \n         if not IDexterityContent.providedBy(source_obj):\n-            logger.info(\'{} is no dexterity content\'.format(source_obj.portal_type))\n+            logger.info(f\'{source_obj} is no dexterity content\')\n             continue\n \n         if not IDexterityContent.providedBy(target_obj):\n-            logger.info(\'{} is no dexterity content\'.format(target_obj.portal_type))\n+            logger.info(f\'{target_obj} is no dexterity content\')\n             continue\n \n         from_attribute = item[\'from_attribute\']\n@@ -248,12 +231,10 @@ def restore_relations(context=None, all_relations=None):\n             event._setRelation(source_obj, ITERATE_RELATION_NAME, relation)\n             continue\n \n-        fti = getUtility(IDexterityFTI, name=source_obj.portal_type)\n-        field_and_schema = get_field_and_schema_for_fieldname(from_attribute, fti)\n+        field_and_schema = get_field_and_schema_for_fieldname(from_attribute, source_obj.portal_type)\n         if field_and_schema is None:\n             # the from_attribute is no field\n-            # we could either create a fresh relation or log the case\n-            logger.info(\'No field. Setting relation: {}\'.format(item))\n+            logger.info(f\'No field. Setting relation: {item}\')\n             event._setRelation(source_obj, from_attribute, RelationValue(to_id))\n             continue\n \n@@ -261,8 +242,7 @@ def restore_relations(context=None, all_relations=None):\n         relation = RelationValue(to_id)\n \n         if isinstance(field, RelationList):\n-            logger.info(\'Add relation to relationslist {} from {} to {}\'.format(\n-                from_attribute, source_obj.absolute_url(), target_obj.absolute_url()))\n+            logger.info(f\'Add relation to relationslist {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}\')\n             if item[\'from_uuid\'] in modified_relation_lists.get(from_attribute, []):\n                 # Do not purge relations\n                 existing_relations = getattr(source_obj, from_attribute, [])\n@@ -276,22 +256,20 @@ def restore_relations(context=None, all_relations=None):\n             continue\n \n         elif isinstance(field, (Relation, RelationChoice)):\n-            logger.info(\'Add relation {} from {} to {}\'.format(\n-                from_attribute, source_obj.absolute_url(), target_obj.absolute_url()))\n+            logger.info(f\'Add relation {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}\')\n             setattr(source_obj, from_attribute, relation)\n             modified_items.add(item[\'from_uuid\'])\n             continue\n \n         else:\n             # we should never end up here!\n-            logger.info(\'Warning: Unexpected relation {} from {} to {}\'.format(\n-                from_attribute, source_obj.absolute_url(), target_obj.absolute_url()))\n+            logger.warn(f\'Unexpected relation {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}\')\n \n     update_linkintegrity = set(update_linkintegrity)\n-    logger.info(\'Updating linkintegrity for {} items\'.format(len(update_linkintegrity)))\n+    logger.info(f\'Updating linkintegrity for {len(update_linkintegrity)} items\')\n     for uuid in sorted(update_linkintegrity):\n         modifiedContent(uuidToObject(uuid), None)\n-    logger.info(\'Updating relations for {} items\'.format(len(modified_items)))\n+    logger.info(f\'Updating relations for {len(modified_items)} items\')\n     for uuid in sorted(modified_items):\n         obj = uuidToObject(uuid)\n         # updateRelations from z3c.relationfield does not properly update relations in behaviors\n@@ -320,12 +298,12 @@ def get_intid(obj):\n         return\n \n \n-def get_field_and_schema_for_fieldname(field_id, fti):\n-    """Get field and its schema from a fti.\n+def get_field_and_schema_for_fieldname(field_id, portal_type):\n+    """Get field and its schema from a portal_type.\n     """\n     # Turn form.widgets.IDublinCore.title into title\n     field_id = field_id.split(\'.\')[-1]\n-    for schema in iterSchemataForType(fti):\n+    for schema in iterSchemataForType(portal_type):\n         field = schema.get(field_id, None)\n         if field is not None:\n             return (field, schema)\n@@ -333,7 +311,7 @@ def get_field_and_schema_for_fieldname(field_id, fti):\n \n def cleanup_intids(context=None):\n     intids = getUtility(IIntIds)\n-    all_refs = [\'{}.{}\'.format(i.object.__class__.__module__, i.object.__class__.__name__)\n+    all_refs = [f\'{i.object.__class__.__module__}.{i.object.__class__.__name__}\'\n                 for i in intids.refs.values()]\n     logger.info(Counter(all_refs))\n \n@@ -342,14 +320,14 @@ def cleanup_intids(context=None):\n     for ref in refs:\n         intids.unregister(ref)\n         count += 1\n-    logger.info(\'Removed all {} RelationValues from IntId-tool\'.format(count))\n+    logger.info(f\'Removed all {count} RelationValues from IntId-tool\')\n \n     count = 0\n     for ref in intids.refs.values():\n         if \'broken\' in repr(ref.object):\n             intids.unregister(ref)\n-    logger.info(\'Removed {} broken refs from IntId-tool\'.format(count))\n-    all_refs = [\'{}.{}\'.format(i.object.__class__.__module__, i.object.__class__.__name__)\n+    logger.info(f\'Removed {count} broken refs from IntId-tool\')\n+    all_refs = [\'{i.object.__class__.__module__}.{i.object.__class__.__name__}\'\n                 for i in intids.refs.values()]\n     logger.info(Counter(all_refs))\n \n@@ -367,7 +345,7 @@ def rebuild_intids():\n     """\n     def add_to_intids(obj, path):\n         if IContentish.providedBy(obj):\n-            logger.info(\'Added {0} at {1} to intid\'.format(obj, path))\n+            logger.info(f\'Added {obj} at {path} to intid\')\n             addIntIdSubscriber(obj, None)\n     portal = api.portal.get()\n     portal.ZopeFindAndApply(portal,\ndiff --git a/Products/CMFPlone/controlpanel/permissions.zcml b/Products/CMFPlone/controlpanel/permissions.zcml\nindex 848dd46351..249aeb6c71 100644\n--- a/Products/CMFPlone/controlpanel/permissions.zcml\n+++ b/Products/CMFPlone/controlpanel/permissions.zcml\n@@ -79,8 +79,8 @@\n     <role name="Site Administrator"/>\n   </permission>\n \n-  <permission id="plone.app.controlpanel.Relations"\n-              title="Plone Site Setup: Relations">\n+  <permission id="Products.CMFPlone.InspectRelations"\n+              title="Inspect Relations">\n     <role name="Manager"/>\n     <role name="Site Administrator"/>\n   </permission>\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/64889895399bf0ef071b5207a78d19c6c934f399

display warning if you have broken relations

Files changed:
M Products/CMFPlone/controlpanel/browser/relations.py
M Products/CMFPlone/controlpanel/browser/relations_inspect.pt

b'diff --git a/Products/CMFPlone/controlpanel/browser/relations.py b/Products/CMFPlone/controlpanel/browser/relations.py\nindex 6422b51627..6ac1edf8cf 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations.py\n+++ b/Products/CMFPlone/controlpanel/browser/relations.py\n@@ -41,7 +41,7 @@ def __call__(self, rebuild=False, flush_and_rebuild_intids=False):\n             self.done = True\n             api.portal.show_message(\'Finished! See log for details.\', self.request)\n \n-        self.relations_stats = get_relations_stats()\n+        self.relations_stats, self.broken = get_relations_stats()\n         return self.index()\n \n \n@@ -52,7 +52,7 @@ def __call__(self, relation=None, inspect_backrelation=False):\n         self.inspect_backrelation = inspect_backrelation or self.request.get(\'inspect_backrelation\')\n \n         self.relations = []\n-        self.relations_stats = get_relations_stats()\n+        self.relations_stats, self.broken = get_relations_stats()\n         view_action = api.portal.get_registry_record(\'plone.types_use_view_action_in_listings\')\n \n         if not self.relation:\n@@ -67,6 +67,8 @@ def __call__(self, relation=None, inspect_backrelation=False):\n         # relations: column_1 = source, column_2 = target(s)\n         # backrelation: column_1 = target, column_2 source(s)\n         for rel in relation_catalog.findRelations(query):\n+            if rel.isBroken():\n+                continue\n             if self.inspect_backrelation:\n                 info[rel.to_id].append(rel.from_id)\n             else:\n@@ -110,13 +112,14 @@ def rebuild_relations(context=None, flush_and_rebuild_intids=False):\n \n def get_relations_stats():\n     info = defaultdict(int)\n+    broken = defaultdict(int)\n     relation_catalog = getUtility(ICatalog)\n     for rel in relation_catalog.findRelations():\n         if rel.isBroken():\n-            info[rel.from_attribute + \' (broken)\'] += 1\n+            broken[rel.from_attribute] += 1\n         else:\n             info[rel.from_attribute] += 1\n-    return info\n+    return info, broken\n \n \n def get_all_relations():\ndiff --git a/Products/CMFPlone/controlpanel/browser/relations_inspect.pt b/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\nindex 2fef528f4f..d62844e4d8 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\n+++ b/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\n@@ -29,6 +29,12 @@\n     <div id="content-core"\n          tal:define="relations_stats python: view.relations_stats">\n \n+      <div tal:condition="python: view.broken"\n+           class="portalMessage warning alert alert-warning" role="alert">\n+             <strong>Warning!</strong> You have broken relations!\n+             You can <a href="@@rebuild_relations">inspect and rebuild all relations</a>.\n+      </div>\n+\n       <form id="relationinfo" method="post" action="@@inspect-relations" enctype="multipart/form-data">\n \n         <div class="mb-3 field">\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/7669b5334bb4d1fb5aeeceb9806eca366e14cf00

test relation controlpanels

Files changed:
A Products/CMFPlone/controlpanel/tests/test_controlpanel_relations.py

b"diff --git a/Products/CMFPlone/controlpanel/tests/test_controlpanel_relations.py b/Products/CMFPlone/controlpanel/tests/test_controlpanel_relations.py\nnew file mode 100644\nindex 0000000000..eb5bde6286\n--- /dev/null\n+++ b/Products/CMFPlone/controlpanel/tests/test_controlpanel_relations.py\n@@ -0,0 +1,198 @@\n+from persistent.list import PersistentList\n+from plone import api\n+from plone.app.testing import TEST_USER_ID, setRoles\n+from Products.CMFPlone.controlpanel.browser.relations import get_relations_stats\n+from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_INTEGRATION_TESTING\n+from z3c.relationfield import RelationValue\n+from zope.component import getUtility\n+from zope.intid.interfaces import IIntIds\n+from zope.lifecycleevent import modified\n+\n+import unittest\n+\n+\n+class TestRelationsControlpanel(unittest.TestCase):\n+\n+    layer = PRODUCTS_CMFPLONE_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer['portal']\n+        self.request = self.layer['request']\n+        setRoles(self.portal, TEST_USER_ID, ('Manager',))\n+\n+    def test_relations_stats(self):\n+        doc1 = api.content.create(\n+            container=self.portal,\n+            type='Document',\n+            title='doc1',\n+            id='doc1',\n+            )\n+        doc2 = api.content.create(\n+            container=self.portal,\n+            type='Document',\n+            title='doc2',\n+            id='doc2',\n+            )\n+        intids = getUtility(IIntIds)\n+        doc1.relatedItems = PersistentList()\n+        doc1.relatedItems.append(RelationValue(intids.getId(doc2)))\n+        modified(doc1)\n+        # TODO: simplify when relation-support is merged into plone.api\n+        # api.relation.create(doc1, doc2, 'relatedItems')\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {'relatedItems': 1})\n+        self.assertEqual(dict(broken), {})\n+        view = api.content.get_view('inspect-relations', self.portal, self.request)\n+        self.assertTrue(view())\n+        self.assertTrue(view(relation='relatedItems'))\n+\n+    def test_relations_stats_broken(self):\n+        doc1 = api.content.create(\n+            container=self.portal,\n+            type='Document',\n+            title='doc1',\n+            id='doc1',\n+            )\n+        doc2 = api.content.create(\n+            container=self.portal,\n+            type='Document',\n+            title='doc2',\n+            id='doc2',\n+            )\n+        doc3 = api.content.create(\n+            container=self.portal,\n+            type='Document',\n+            title='doc3',\n+            id='doc3',\n+            )\n+        intids = getUtility(IIntIds)\n+        doc1.relatedItems = PersistentList()\n+        doc1.relatedItems.append(RelationValue(intids.getId(doc2)))\n+        doc1.relatedItems.append(RelationValue(intids.getId(doc3)))\n+        modified(doc1)\n+        # api.relation.create(doc1, doc2, 'relatedItems')\n+        # api.relation.create(doc1, doc3, 'relatedItems')\n+\n+        self.portal._delObject('doc2')\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {'relatedItems': 1})\n+        self.assertEqual(dict(broken), {'relatedItems': 1})\n+        view = api.content.get_view('inspect-relations', self.portal, self.request)\n+        self.assertTrue(view())\n+        self.assertTrue(view(relation='relatedItems'))\n+\n+    def test_rebuild_relations(self):\n+        doc1 = api.content.create(\n+            container=self.portal,\n+            type='Document',\n+            title='doc1',\n+            id='doc1',\n+            )\n+        doc2 = api.content.create(\n+            container=self.portal,\n+            type='Document',\n+            title='doc2',\n+            id='doc2',\n+            )\n+        doc3 = api.content.create(\n+            container=self.portal,\n+            type='Document',\n+            title='doc3',\n+            id='doc3',\n+            )\n+        intids = getUtility(IIntIds)\n+        doc1_intid = intids.getId(doc1)\n+        doc2_intid = intids.getId(doc2)\n+        doc3_intid = intids.getId(doc3)\n+\n+        doc1.relatedItems = PersistentList()\n+        doc1.relatedItems.append(RelationValue(doc2_intid))\n+        doc1.relatedItems.append(RelationValue(doc3_intid))\n+        modified(doc1)\n+        # api.relation.create(doc1, doc2, 'relatedItems')\n+        # api.relation.create(doc1, doc3, 'relatedItems')\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {'relatedItems': 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        view = api.content.get_view('rebuild-relations', self.portal, self.request)\n+        results = view(rebuild=True)\n+\n+        # relations are the same after a rebuild\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {'relatedItems': 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        # intids are not changed\n+        doc1_intid_after = intids.getId(doc1)\n+        doc2_intid_after = intids.getId(doc2)\n+        doc3_intid_after = intids.getId(doc3)\n+        self.assertEqual(doc1_intid, doc1_intid_after)\n+        self.assertEqual(doc2_intid, doc2_intid_after)\n+        self.assertEqual(doc3_intid, doc3_intid_after)\n+\n+        # break a relation\n+        self.portal._delObject('doc2')\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {'relatedItems': 1})\n+        self.assertEqual(dict(broken), {'relatedItems': 1})\n+\n+        # broken relations are gone after rebuilding\n+        view = api.content.get_view('rebuild-relations', self.portal, self.request)\n+        results = view(rebuild=True)\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {'relatedItems': 1})\n+        self.assertEqual(dict(broken), {})\n+\n+    def test_rebuild_relations_with_intid(self):\n+        doc1 = api.content.create(\n+            container=self.portal,\n+            type='Document',\n+            title='doc1',\n+            id='doc1',\n+            )\n+        doc2 = api.content.create(\n+            container=self.portal,\n+            type='Document',\n+            title='doc2',\n+            id='doc2',\n+            )\n+        doc3 = api.content.create(\n+            container=self.portal,\n+            type='Document',\n+            title='doc3',\n+            id='doc3',\n+            )\n+        intids = getUtility(IIntIds)\n+        doc1_intid = intids.getId(doc1)\n+        doc2_intid = intids.getId(doc2)\n+        doc3_intid = intids.getId(doc3)\n+        doc1.relatedItems = PersistentList()\n+        doc1.relatedItems.append(RelationValue(doc2_intid))\n+        doc1.relatedItems.append(RelationValue(doc3_intid))\n+        modified(doc1)\n+        # api.relation.create(doc1, doc2, 'relatedItems')\n+        # api.relation.create(doc1, doc3, 'relatedItems')\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {'relatedItems': 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        view = api.content.get_view('rebuild-relations', self.portal, self.request)\n+        results = view(rebuild=True, flush_and_rebuild_intids=True)\n+\n+        # relations are the same after a rebuild\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {'relatedItems': 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        # intids are now changed\n+        doc1_intid_after = intids.getId(doc1)\n+        doc2_intid_after = intids.getId(doc2)\n+        doc3_intid_after = intids.getId(doc3)\n+        self.assertNotEqual(doc1_intid, doc1_intid_after)\n+        self.assertNotEqual(doc2_intid, doc2_intid_after)\n+        self.assertNotEqual(doc3_intid, doc3_intid_after)\n"

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/68cc3ddd4a97dc64b52c31efccc9dd4ecbe85262

sort relations

Files changed:
M Products/CMFPlone/controlpanel/browser/relations_inspect.pt
M Products/CMFPlone/controlpanel/browser/relations_rebuild.pt

b'diff --git a/Products/CMFPlone/controlpanel/browser/relations_inspect.pt b/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\nindex d62844e4d8..6b891660d8 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\n+++ b/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\n@@ -40,7 +40,7 @@\n         <div class="mb-3 field">\n           <select class="form-select" aria-label="Default select example" name="relation" id="relation">\n             <option value="">Select a relation</option>\n-            <tal:rels tal:repeat="from_attribute python: relations_stats">\n+            <tal:rels tal:repeat="from_attribute python: sorted(relations_stats)">\n               <option tal:attributes="value python: from_attribute;\n                                       selected python: relation == from_attribute"\n                       tal:content="python:\'{} ({})\'.format(from_attribute, relations_stats[from_attribute])">\ndiff --git a/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt b/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt\nindex 7d5c01f97f..9911f3ef83 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt\n+++ b/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt\n@@ -32,7 +32,7 @@\n           </tr>\n         </thead>\n         <tbody>\n-          <tr tal:repeat="item python:relations_stats">\n+          <tr tal:repeat="item python: sorted(relations_stats)">\n             <td>\n               <a href=""\n                  target="_blank"\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/363942a6b5f9d5fb9d5d80d603c24f80411a4bd1

replace plone.api calls

Files changed:
M Products/CMFPlone/controlpanel/browser/relations.py

b'diff --git a/Products/CMFPlone/controlpanel/browser/relations.py b/Products/CMFPlone/controlpanel/browser/relations.py\nindex 6ac1edf8cf..4fc593d23b 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations.py\n+++ b/Products/CMFPlone/controlpanel/browser/relations.py\n@@ -1,7 +1,6 @@\n from collections import Counter\n from collections import defaultdict\n from five.intid.intid import addIntIdSubscriber\n-from plone import api\n from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n from plone.app.iterate.dexterity.relation import StagingRelationValue\n from plone.app.linkintegrity.handlers import modifiedContent\n@@ -10,8 +9,11 @@\n from plone.app.uuid.utils import uuidToObject\n from plone.dexterity.interfaces import IDexterityContent\n from plone.dexterity.utils import iterSchemataForType\n+from plone.registry.interfaces import IRegistry\n from Products.CMFCore.interfaces import IContentish\n+from Products.CMFPlone import PloneMessageFactory as _\n from Products.Five.browser import BrowserView\n+from Products.statusmessages.interfaces import IStatusMessage\n from z3c.relationfield import event\n from z3c.relationfield import RelationValue\n from z3c.relationfield.event import updateRelations\n@@ -22,6 +24,7 @@\n from zope.annotation.interfaces import IAnnotations\n from zope.component import getUtility\n from zope.component import queryUtility\n+from zope.component.hooks import getSite\n from zope.intid.interfaces import IIntIds\n \n import json\n@@ -39,7 +42,8 @@ def __call__(self, rebuild=False, flush_and_rebuild_intids=False):\n         if rebuild:\n             rebuild_relations(flush_and_rebuild_intids=flush_and_rebuild_intids)\n             self.done = True\n-            api.portal.show_message(\'Finished! See log for details.\', self.request)\n+            IStatusMessage(self.request).addStatusMessage(\n+                _(\'Finished! See log for details.\'), \'info\')\n \n         self.relations_stats, self.broken = get_relations_stats()\n         return self.index()\n@@ -53,10 +57,12 @@ def __call__(self, relation=None, inspect_backrelation=False):\n \n         self.relations = []\n         self.relations_stats, self.broken = get_relations_stats()\n-        view_action = api.portal.get_registry_record(\'plone.types_use_view_action_in_listings\')\n+        registry = getUtility(IRegistry)\n+        view_action = registry[\'plone.types_use_view_action_in_listings\']\n \n         if not self.relation:\n-            api.portal.show_message(\'Please select a relation\', self.request)\n+            IStatusMessage(self.request).addStatusMessage(\n+                _(\'Please select a relation\'), \'info\')\n             return self.index()\n \n         intids = queryUtility(IIntIds)\n@@ -144,8 +150,8 @@ def get_all_relations():\n         else:\n             logger.info(f\'Dropping relation {rel.from_attribute} from {rel.from_object} to {rel.to_object}\')\n     msg = \'\'\n-    for k, v in info.items():\n-        msg += f\'{k}: {v}\\n\'\n+    for key, value in info.items():\n+        msg += f\'{key}: {value}\\n\'\n     logger.info(f\'\\nFound the following relations:\\n{msg}\')\n     return results\n \n@@ -154,7 +160,7 @@ def store_relations(context=None):\n     """Store all relations in a annotation on the portal.\n     """\n     all_relations = get_all_relations()\n-    portal = api.portal.get()\n+    portal = getSite()\n     IAnnotations(portal)[RELATIONS_KEY] = all_relations\n     logger.info(f\'Stored {len(all_relations)} relations on the portal\')\n \n@@ -173,7 +179,7 @@ def restore_relations(context=None, all_relations=None):\n     """Restore relations from a annotation on the portal.\n     """\n \n-    portal = api.portal.get()\n+    portal = getSite()\n     if all_relations is None:\n         all_relations = IAnnotations(portal)[RELATIONS_KEY]\n     logger.info(f\'Loaded {len(all_relations)} relations to restore\')\n@@ -350,7 +356,7 @@ def add_to_intids(obj, path):\n         if IContentish.providedBy(obj):\n             logger.info(f\'Added {obj} at {path} to intid\')\n             addIntIdSubscriber(obj, None)\n-    portal = api.portal.get()\n+    portal = getSite()\n     portal.ZopeFindAndApply(portal,\n                             search_sub=True,\n                             apply_func=add_to_intids)\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/b7fa8d909dca48b00809ac5a202f487065c8026e

handle case when brain exists but no object

Files changed:
M Products/CMFPlone/controlpanel/browser/relations.py

b'diff --git a/Products/CMFPlone/controlpanel/browser/relations.py b/Products/CMFPlone/controlpanel/browser/relations.py\nindex 4fc593d23b..851feac59d 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations.py\n+++ b/Products/CMFPlone/controlpanel/browser/relations.py\n@@ -207,8 +207,17 @@ def restore_relations(context=None, all_relations=None):\n     for index, item in enumerate(all_relations, start=1):\n         if not index % 500:\n             logger.info(f\'Restored {index} of {len(all_relations)} relations...\')\n-        source_obj = uuidToObject(item[\'from_uuid\'])\n-        target_obj = uuidToObject(item[\'to_uuid\'])\n+\n+        try:\n+            source_obj = uuidToObject(item[\'from_uuid\'])\n+        except KeyError:\n+            # brain exists but no object\n+            source_obj = None\n+        try:\n+            target_obj = uuidToObject(item[\'to_uuid\'])\n+        except KeyError:\n+            # brain exists but no object\n+            target_obj = None\n \n         if not source_obj:\n             logger.info(f\'{item["from_uuid"]} is missing\')\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/5cda58e241abcc45b8782e71e09654e103d5d860

render as controlpanels and add link to rebuild-relations

Files changed:
M Products/CMFPlone/controlpanel/browser/relations_inspect.pt
M Products/CMFPlone/controlpanel/browser/relations_rebuild.pt

b'diff --git a/Products/CMFPlone/controlpanel/browser/relations_inspect.pt b/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\nindex 6b891660d8..d5771e0a50 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\n+++ b/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\n@@ -4,24 +4,32 @@\n       xmlns:metal="http://xml.zope.org/namespaces/metal"\n       xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n       lang="en"\n-      metal:use-macro="context/main_template/macros/master"\n+      metal:use-macro="context/prefs_main_template/macros/master"\n       i18n:domain="plone">\n \n <body>\n \n-  <metal:content-core fill-slot="main"\n-                      tal:define="inspect_backrelation python: view.inspect_backrelation;\n-                                  relation python: view.relation;">\n+  <metal:main metal:fill-slot="prefs_configlet_main" i18n:domain="plone"\n+      tal:define="inspect_backrelation python: view.inspect_backrelation;\n+                  relation python: view.relation;">\n+\n+      <a id="setup-link" class="link-parent"\n+         tal:attributes="href string:$portal_url/@@overview-controlpanel"\n+         i18n:translate="">\n+          Site Setup\n+      </a>\n \n     <header>\n       <h1 class="documentFirstHeading"\n           tal:condition="python: not inspect_backrelation">\n-        Inspect relation <strong tal:content="python: relation">relation</strong>\n+        <span i18n:translate="">Inspect relations</span>\n+        <strong tal:content="python: relation">relation</strong>\n       </h1>\n \n       <h1 class="documentFirstHeading"\n           tal:condition="python: inspect_backrelation">\n-        Inspect backrelation <strong tal:content="python: relation">backrelation</strong>\n+        <span i18n:translate="">Inspect backrelations</span>\n+        <strong tal:content="python: relation">backrelation</strong>\n       </h1>\n \n     </header>\n@@ -30,7 +38,8 @@\n          tal:define="relations_stats python: view.relations_stats">\n \n       <div tal:condition="python: view.broken"\n-           class="portalMessage warning alert alert-warning" role="alert">\n+           class="portalMessage warning alert alert-warning" role="alert"\n+           i18n:translate="">\n              <strong>Warning!</strong> You have broken relations!\n              You can <a href="@@rebuild_relations">inspect and rebuild all relations</a>.\n       </div>\n@@ -39,7 +48,7 @@\n \n         <div class="mb-3 field">\n           <select class="form-select" aria-label="Default select example" name="relation" id="relation">\n-            <option value="">Select a relation</option>\n+            <option value="" i18n:translate="">Select a relation</option>\n             <tal:rels tal:repeat="from_attribute python: sorted(relations_stats)">\n               <option tal:attributes="value python: from_attribute;\n                                       selected python: relation == from_attribute"\n@@ -59,29 +68,31 @@\n                    type="checkbox"\n                    checked="checked"\n                    tal:attributes="checked python: \'checked\' if inspect_backrelation else \'\'">\n-            <label for="inspect-backrelation" class="form-check-label">\n+            <label for="inspect-backrelation"\n+                   class="form-check-label"\n+                   i18n:translate="">\n               Show backrelations\n             </label>\n-            <div class="form-text">Display relations grouped by their target.</div>\n+            <div class="form-text" i18n:translate="">Display relations grouped by their target.</div>\n           </div>\n         </div>\n \n-        <button class="context btn btn-primary" type="submit" name="submit" value="submit" i18n:translate="">Go!</button>\n+        <button class="context btn btn-primary" type="submit" name="submit" value="submit" i18n:translate="">Inspect</button>\n       </form>\n \n       <table class="listing table table-striped"\n              tal:condition="python:view.relations">\n         <thead>\n           <tr tal:condition="python: not inspect_backrelation">\n-            <th>Source</th>\n+            <th i18n:translate="">Source</th>\n             <th>&rarr;</th>\n-            <th>Target(s)</th>\n+            <th i18n:translate="">Target(s)</th>\n           </tr>\n \n           <tr tal:condition="python: inspect_backrelation">\n-            <th>Target</th>\n+            <th i18n:translate="">Target</th>\n             <th>&larr;</th>\n-            <th>Source(s)</th>\n+            <th i18n:translate="">Source(s)</th>\n           </tr>\n         </thead>\n         <tbody>\n@@ -112,9 +123,11 @@\n         </tbody>\n       </table>\n \n+      <p><a href="@@rebuild-relations" i18n:translate="">Inspect and rebuild all relations</a>.</p>\n+\n     </div>\n \n-  </metal:content-core>\n+  </metal:main>\n \n </body>\n \ndiff --git a/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt b/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt\nindex 9911f3ef83..5007082020 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt\n+++ b/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt\n@@ -4,22 +4,28 @@\n       xmlns:metal="http://xml.zope.org/namespaces/metal"\n       xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n       lang="en"\n-      metal:use-macro="context/main_template/macros/master"\n+      metal:use-macro="context/prefs_main_template/macros/master"\n       i18n:domain="plone">\n \n <body>\n \n-  <metal:content-core fill-slot="main">\n+  <metal:main metal:fill-slot="prefs_configlet_main">\n+\n+      <a id="setup-link" class="link-parent"\n+         tal:attributes="href string:$portal_url/@@overview-controlpanel"\n+         i18n:translate="">\n+          Site Setup\n+      </a>\n \n     <header>\n-      <h1 class="documentFirstHeading">Rebuild zc.relation catalog</h1>\n+      <h1 class="documentFirstHeading" i18n:translate="">Rebuild relations</h1>\n     </header>\n \n     <div id="content-core">\n \n-      <h3>\n-        <span tal:condition="python:view.done">Success!</span>\n-        Current number of relations in the zc.relation catalog\n+      <span tal:condition="python:view.done" i18n:translate="">Success!</span>\n+      <h3 i18n:translate="">\n+         Current relations in the relation catalog\n       </h3>\n \n       <table class="listing table table-striped"\n@@ -27,8 +33,8 @@\n             tal:condition="python: relations_stats">\n         <thead>\n           <tr>\n-            <th>Relation</th>\n-            <th>Amount</th>\n+            <th i18n:translate="">Relation</th>\n+            <th i18n:translate="">Amount</th>\n           </tr>\n         </thead>\n         <tbody>\n@@ -47,41 +53,41 @@\n         </tbody>\n       </table>\n \n-      <h3>Common relations:</h3>\n+      <h3 i18n:translate="">Common relations:</h3>\n       <dl>\n         <dt>relatedItems</dt>\n-        <dd>Relations between content using the default "Related items" field</dd>\n+        <dd i18n:translate="">Relations between content using the default "Related items" field</dd>\n \n         <dt>isReferencing</dt>\n-        <dd>Linkintegrity relations (source has a html-link to target)</dd>\n+        <dd i18n:translate="">Linkintegrity relations (source has a html-link to target)</dd>\n \n         <dt>iterate-working-copy</dt>\n-        <dd>Relation from content to a working copy (using plone.app.iterate)</dd>\n+        <dd i18n:translate="">Relation from content to a working copy (using plone.app.iterate)</dd>\n \n         <dt>staging-working-copy</dt>\n-        <dd>Outdated relation from content to a working copy (using plone.app.stagingbehavior)</dd>\n+        <dd i18n:translate="">Outdated relation from content to a working copy (using plone.app.stagingbehavior)</dd>\n \n         <dt>(broken)</dt>\n-        <dd>Either source or target no longer exist</dd>\n+        <dd i18n:translate="">Either source or target no longer exist</dd>\n \n         <dt><i>all other</i></dt>\n-        <dd>Custom attribute/fieldname used to describe the relation</dd>\n+        <dd i18n:translate="">Custom attribute/fieldname used to describe the relation</dd>\n       </dl>\n \n       <form id="rebuild_relations" method="post" action="@@rebuild-relations" enctype="multipart/form-data">\n-        <h3>Purge and rebuild relation-catalog</h3>\n-        <p>Clicking here will do the following:</p>\n+        <h3 i18n:translate="">Purge and rebuild relation-catalog</h3>\n+        <p i18n:translate="">Clicking here will do the following:</p>\n         <ul>\n-          <li>Get all relations from zc.relation catalog and store them in a annotation on the portal.</li>\n-          <li>Remove all entries form zc.relation catalog.</li>\n-          <li>Clean up or flush and rebuild intids - this depends on your selection below</li>\n-          <li>Restore relations from the annotation on the portal.</li>\n+          <li i18n:translate="">Get all relations from zc.relation catalog and store them in a annotation on the portal.</li>\n+          <li i18n:translate="">Remove all entries form zc.relation catalog.</li>\n+          <li i18n:translate="">Clean up or flush and rebuild intids - this depends on your selection below</li>\n+          <li i18n:translate="">Restore relations from the annotation on the portal.</li>\n         </ul>\n \n         <div class="form-check">\n           <input class="form-check-input" type="checkbox" name="flush_and_rebuild_intids" id="flush_intids">\n-          <label class="form-check-label" for="flush_intids" >Flush and rebuild intids</label>\n-          <p>\n+          <label class="form-check-label" for="flush_intids" i18n:translate="">Flush and rebuild intids</label>\n+          <p i18n:translate="">\n              This will delete all intids and create new one.<br/>\n              Warning: If you have a lot of relations this can take some time. Check the log for details!<br/>\n              If you have relations on tiles, flushing and rebuilding intids will destroy them b/c intids changed.\n@@ -92,7 +98,7 @@\n       </form>\n     </div>\n \n-  </metal:content-core>\n+  </metal:main>\n \n </body>\n \n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/84bd222951ac54aa2b16a602eace2a53dbbf226e

set icon for controlpanel

Files changed:
M Products/CMFPlone/profiles/default/controlpanel.xml

b'diff --git a/Products/CMFPlone/profiles/default/controlpanel.xml b/Products/CMFPlone/profiles/default/controlpanel.xml\nindex 217f055364..dab561a5f9 100644\n--- a/Products/CMFPlone/profiles/default/controlpanel.xml\n+++ b/Products/CMFPlone/profiles/default/controlpanel.xml\n@@ -214,7 +214,7 @@\n   <permission>Manage Portal Aliases</permission>\n  </configlet>\n  <configlet title="Relations" action_id="inspectrelations"\n-    icon_expr="string:$portal_url/action_icon.png"\n+    icon_expr="string:share-fill"\n     appId="Plone" category="plone-content"\n     condition_expr=""\n     url_expr="string:${portal_url}/@@inspect-relations"\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/37d1c5950694f4fb2e11914c586b190d2753bcef

move helpers in to relationhelper.py

Files changed:
A Products/CMFPlone/relationhelper.py
M Products/CMFPlone/controlpanel/browser/relations.py

b'diff --git a/Products/CMFPlone/controlpanel/browser/relations.py b/Products/CMFPlone/controlpanel/browser/relations.py\nindex 851feac59d..db53c312fd 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations.py\n+++ b/Products/CMFPlone/controlpanel/browser/relations.py\n@@ -1,39 +1,20 @@\n-from collections import Counter\n from collections import defaultdict\n-from five.intid.intid import addIntIdSubscriber\n-from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n-from plone.app.iterate.dexterity.relation import StagingRelationValue\n-from plone.app.linkintegrity.handlers import modifiedContent\n-from plone.app.linkintegrity.utils import referencedRelationship\n-from plone.app.relationfield.event import update_behavior_relations\n-from plone.app.uuid.utils import uuidToObject\n-from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.utils import iterSchemataForType\n from plone.registry.interfaces import IRegistry\n-from Products.CMFCore.interfaces import IContentish\n from Products.CMFPlone import PloneMessageFactory as _\n+from Products.CMFPlone.relationhelper import get_relations_stats\n+from Products.CMFPlone.relationhelper import rebuild_relations\n from Products.Five.browser import BrowserView\n from Products.statusmessages.interfaces import IStatusMessage\n-from z3c.relationfield import event\n-from z3c.relationfield import RelationValue\n-from z3c.relationfield.event import updateRelations\n-from z3c.relationfield.schema import Relation\n-from z3c.relationfield.schema import RelationChoice\n-from z3c.relationfield.schema import RelationList\n from zc.relation.interfaces import ICatalog\n from zope.annotation.interfaces import IAnnotations\n from zope.component import getUtility\n from zope.component import queryUtility\n-from zope.component.hooks import getSite\n from zope.intid.interfaces import IIntIds\n \n-import json\n import logging\n \n logger = logging.getLogger(__name__)\n \n-RELATIONS_KEY = \'ALL_REFERENCES\'\n-\n \n class RelationsRebuildControlpanel(BrowserView):\n \n@@ -103,269 +84,3 @@ def __call__(self, relation=None, inspect_backrelation=False):\n             self.relations.append(item)\n \n         return self.index()\n-\n-\n-def rebuild_relations(context=None, flush_and_rebuild_intids=False):\n-    store_relations()\n-    purge_relations()\n-    if flush_and_rebuild_intids:\n-        flush_intids()\n-        rebuild_intids()\n-    else:\n-        cleanup_intids()\n-    restore_relations()\n-\n-\n-def get_relations_stats():\n-    info = defaultdict(int)\n-    broken = defaultdict(int)\n-    relation_catalog = getUtility(ICatalog)\n-    for rel in relation_catalog.findRelations():\n-        if rel.isBroken():\n-            broken[rel.from_attribute] += 1\n-        else:\n-            info[rel.from_attribute] += 1\n-    return info, broken\n-\n-\n-def get_all_relations():\n-    """Get all data from zc.relation catalog.\n-    Logs some useful statistics.\n-    """\n-    results = []\n-    info = defaultdict(int)\n-\n-    relation_catalog = getUtility(ICatalog)\n-    for rel in relation_catalog.findRelations():\n-        if rel.from_object and rel.to_object:\n-            try:\n-                results.append({\n-                    \'from_uuid\': rel.from_object.UID(),\n-                    \'to_uuid\': rel.to_object.UID(),\n-                    \'from_attribute\': rel.from_attribute,\n-                })\n-                info[rel.from_attribute] += 1\n-            except AttributeError as ex:\n-                logger.info(f\'Something went wrong while storing {rel}: \\n {ex}\')\n-        else:\n-            logger.info(f\'Dropping relation {rel.from_attribute} from {rel.from_object} to {rel.to_object}\')\n-    msg = \'\'\n-    for key, value in info.items():\n-        msg += f\'{key}: {value}\\n\'\n-    logger.info(f\'\\nFound the following relations:\\n{msg}\')\n-    return results\n-\n-\n-def store_relations(context=None):\n-    """Store all relations in a annotation on the portal.\n-    """\n-    all_relations = get_all_relations()\n-    portal = getSite()\n-    IAnnotations(portal)[RELATIONS_KEY] = all_relations\n-    logger.info(f\'Stored {len(all_relations)} relations on the portal\')\n-\n-\n-def purge_relations(context=None):\n-    """Removes all entries form zc.relation catalog.\n-    RelationValues that were set as attribute on content are still there!\n-    These are removed/overwritten when restoring the relations.\n-    """\n-    rel_catalog = getUtility(ICatalog)\n-    rel_catalog.clear()\n-    logger.info(\'Purged zc.relation catalog\')\n-\n-\n-def restore_relations(context=None, all_relations=None):\n-    """Restore relations from a annotation on the portal.\n-    """\n-\n-    portal = getSite()\n-    if all_relations is None:\n-        all_relations = IAnnotations(portal)[RELATIONS_KEY]\n-    logger.info(f\'Loaded {len(all_relations)} relations to restore\')\n-    update_linkintegrity = set()\n-    modified_items = set()\n-    modified_relation_lists = defaultdict(list)\n-\n-    # remove duplicates but keep original order\n-    unique_relations = []\n-    seen = set()\n-    seen_add = seen.add\n-    for rel in all_relations:\n-        hashable = tuple(rel.items())\n-        if hashable not in seen:\n-            unique_relations.append(rel)\n-            seen_add(hashable)\n-        else:\n-            logger.info(f\'Dropping duplicate: {hashable}\')\n-\n-    if len(unique_relations) < len(all_relations):\n-        logger.info(f\'Dropping {len(all_relations) - len(unique_relations)} duplicates\')\n-        all_relations = unique_relations\n-\n-    intids = getUtility(IIntIds)\n-    for index, item in enumerate(all_relations, start=1):\n-        if not index % 500:\n-            logger.info(f\'Restored {index} of {len(all_relations)} relations...\')\n-\n-        try:\n-            source_obj = uuidToObject(item[\'from_uuid\'])\n-        except KeyError:\n-            # brain exists but no object\n-            source_obj = None\n-        try:\n-            target_obj = uuidToObject(item[\'to_uuid\'])\n-        except KeyError:\n-            # brain exists but no object\n-            target_obj = None\n-\n-        if not source_obj:\n-            logger.info(f\'{item["from_uuid"]} is missing\')\n-            continue\n-\n-        if not target_obj:\n-            logger.info(f\'{item["to_uuid"]} is missing\')\n-            continue\n-\n-        if not IDexterityContent.providedBy(source_obj):\n-            logger.info(f\'{source_obj} is no dexterity content\')\n-            continue\n-\n-        if not IDexterityContent.providedBy(target_obj):\n-            logger.info(f\'{target_obj} is no dexterity content\')\n-            continue\n-\n-        from_attribute = item[\'from_attribute\']\n-        to_id = intids.getId(target_obj)\n-\n-        if from_attribute == referencedRelationship:\n-            # Ignore linkintegrity for now. We\'ll rebuilt it at the end!\n-            update_linkintegrity.add(item[\'from_uuid\'])\n-            continue\n-\n-        if from_attribute == ITERATE_RELATION_NAME:\n-            # Iterate relations are not set as values of fields\n-            relation = StagingRelationValue(to_id)\n-            event._setRelation(source_obj, ITERATE_RELATION_NAME, relation)\n-            continue\n-\n-        field_and_schema = get_field_and_schema_for_fieldname(from_attribute, source_obj.portal_type)\n-        if field_and_schema is None:\n-            # the from_attribute is no field\n-            logger.info(f\'No field. Setting relation: {item}\')\n-            event._setRelation(source_obj, from_attribute, RelationValue(to_id))\n-            continue\n-\n-        field, schema = field_and_schema\n-        relation = RelationValue(to_id)\n-\n-        if isinstance(field, RelationList):\n-            logger.info(f\'Add relation to relationslist {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}\')\n-            if item[\'from_uuid\'] in modified_relation_lists.get(from_attribute, []):\n-                # Do not purge relations\n-                existing_relations = getattr(source_obj, from_attribute, [])\n-            else:\n-                # First touch. Make sure we purge!\n-                existing_relations = []\n-            existing_relations.append(relation)\n-            setattr(source_obj, from_attribute, existing_relations)\n-            modified_items.add(item[\'from_uuid\'])\n-            modified_relation_lists[from_attribute].append(item[\'from_uuid\'])\n-            continue\n-\n-        elif isinstance(field, (Relation, RelationChoice)):\n-            logger.info(f\'Add relation {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}\')\n-            setattr(source_obj, from_attribute, relation)\n-            modified_items.add(item[\'from_uuid\'])\n-            continue\n-\n-        else:\n-            # we should never end up here!\n-            logger.warn(f\'Unexpected relation {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}\')\n-\n-    update_linkintegrity = set(update_linkintegrity)\n-    logger.info(f\'Updating linkintegrity for {len(update_linkintegrity)} items\')\n-    for uuid in sorted(update_linkintegrity):\n-        modifiedContent(uuidToObject(uuid), None)\n-    logger.info(f\'Updating relations for {len(modified_items)} items\')\n-    for uuid in sorted(modified_items):\n-        obj = uuidToObject(uuid)\n-        # updateRelations from z3c.relationfield does not properly update relations in behaviors\n-        # that are registered with a marker-interface.\n-        # update_behavior_relations (from plone.app.relationfield) does that but does not update\n-        # those in the main schema. Duh!\n-        updateRelations(obj, None)\n-        update_behavior_relations(obj, None)\n-\n-    # purge annotation from portal if they exist\n-    if RELATIONS_KEY in IAnnotations(portal):\n-        del IAnnotations(portal)[RELATIONS_KEY]\n-    logger.info(\'Done!\')\n-\n-\n-def get_intid(obj):\n-    """Intid from intid-catalog"""\n-    intids = queryUtility(IIntIds)\n-    if intids is None:\n-        return\n-    # check that the object has an intid, otherwise there\'s nothing to be done\n-    try:\n-        return intids.getId(obj)\n-    except KeyError:  # noqa\n-        # The object has not been added to the ZODB yet\n-        return\n-\n-\n-def get_field_and_schema_for_fieldname(field_id, portal_type):\n-    """Get field and its schema from a portal_type.\n-    """\n-    # Turn form.widgets.IDublinCore.title into title\n-    field_id = field_id.split(\'.\')[-1]\n-    for schema in iterSchemataForType(portal_type):\n-        field = schema.get(field_id, None)\n-        if field is not None:\n-            return (field, schema)\n-\n-\n-def cleanup_intids(context=None):\n-    intids = getUtility(IIntIds)\n-    all_refs = [f\'{i.object.__class__.__module__}.{i.object.__class__.__name__}\'\n-                for i in intids.refs.values()]\n-    logger.info(Counter(all_refs))\n-\n-    count = 0\n-    refs = [i for i in intids.refs.values() if isinstance(i.object, RelationValue)]\n-    for ref in refs:\n-        intids.unregister(ref)\n-        count += 1\n-    logger.info(f\'Removed all {count} RelationValues from IntId-tool\')\n-\n-    count = 0\n-    for ref in intids.refs.values():\n-        if \'broken\' in repr(ref.object):\n-            intids.unregister(ref)\n-    logger.info(f\'Removed {count} broken refs from IntId-tool\')\n-    all_refs = [\'{i.object.__class__.__module__}.{i.object.__class__.__name__}\'\n-                for i in intids.refs.values()]\n-    logger.info(Counter(all_refs))\n-\n-\n-def flush_intids():\n-    """ Flush all intids\n-    """\n-    intids = getUtility(IIntIds)\n-    intids.ids = intids.family.OI.BTree()\n-    intids.refs = intids.family.IO.BTree()\n-\n-\n-def rebuild_intids():\n-    """ Create new intids\n-    """\n-    def add_to_intids(obj, path):\n-        if IContentish.providedBy(obj):\n-            logger.info(f\'Added {obj} at {path} to intid\')\n-            addIntIdSubscriber(obj, None)\n-    portal = getSite()\n-    portal.ZopeFindAndApply(portal,\n-                            search_sub=True,\n-                            apply_func=add_to_intids)\ndiff --git a/Products/CMFPlone/relationhelper.py b/Products/CMFPlone/relationhelper.py\nnew file mode 100644\nindex 0000000000..5275e18253\n--- /dev/null\n+++ b/Products/CMFPlone/relationhelper.py\n@@ -0,0 +1,297 @@\n+from collections import Counter\n+from collections import defaultdict\n+from five.intid.intid import addIntIdSubscriber\n+from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n+from plone.app.iterate.dexterity.relation import StagingRelationValue\n+from plone.app.linkintegrity.handlers import modifiedContent\n+from plone.app.linkintegrity.utils import referencedRelationship\n+from plone.app.relationfield.event import update_behavior_relations\n+from plone.app.uuid.utils import uuidToObject\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.dexterity.utils import iterSchemataForType\n+from Products.CMFCore.interfaces import IContentish\n+from Products.CMFPlone import PloneMessageFactory as _\n+from z3c.relationfield import event\n+from z3c.relationfield import RelationValue\n+from z3c.relationfield.event import updateRelations\n+from z3c.relationfield.schema import Relation\n+from z3c.relationfield.schema import RelationChoice\n+from z3c.relationfield.schema import RelationList\n+from zc.relation.interfaces import ICatalog\n+from zope.annotation.interfaces import IAnnotations\n+from zope.component import getUtility\n+from zope.component import queryUtility\n+from zope.component.hooks import getSite\n+from zope.intid.interfaces import IIntIds\n+\n+import logging\n+\n+logger = logging.getLogger(__name__)\n+\n+RELATIONS_KEY = \'ALL_REFERENCES\'\n+\n+\n+def rebuild_relations(context=None, flush_and_rebuild_intids=False):\n+    store_relations()\n+    purge_relations()\n+    if flush_and_rebuild_intids:\n+        flush_intids()\n+        rebuild_intids()\n+    else:\n+        cleanup_intids()\n+    restore_relations()\n+\n+\n+def get_relations_stats():\n+    info = defaultdict(int)\n+    broken = defaultdict(int)\n+    relation_catalog = getUtility(ICatalog)\n+    for rel in relation_catalog.findRelations():\n+        if rel.isBroken():\n+            broken[rel.from_attribute] += 1\n+        else:\n+            info[rel.from_attribute] += 1\n+    return info, broken\n+\n+\n+def get_all_relations():\n+    """Get all data from zc.relation catalog.\n+    Logs some useful statistics.\n+    """\n+    results = []\n+    info = defaultdict(int)\n+\n+    relation_catalog = getUtility(ICatalog)\n+    for rel in relation_catalog.findRelations():\n+        if rel.from_object and rel.to_object:\n+            try:\n+                results.append({\n+                    \'from_uuid\': rel.from_object.UID(),\n+                    \'to_uuid\': rel.to_object.UID(),\n+                    \'from_attribute\': rel.from_attribute,\n+                })\n+                info[rel.from_attribute] += 1\n+            except AttributeError as ex:\n+                logger.info(f\'Something went wrong while storing {rel}: \\n {ex}\')\n+        else:\n+            logger.info(f\'Dropping relation {rel.from_attribute} from {rel.from_object} to {rel.to_object}\')\n+    msg = \'\'\n+    for key, value in info.items():\n+        msg += f\'{key}: {value}\\n\'\n+    logger.info(f\'\\nFound the following relations:\\n{msg}\')\n+    return results\n+\n+\n+def store_relations(context=None):\n+    """Store all relations in a annotation on the portal.\n+    """\n+    all_relations = get_all_relations()\n+    portal = getSite()\n+    IAnnotations(portal)[RELATIONS_KEY] = all_relations\n+    logger.info(f\'Stored {len(all_relations)} relations on the portal\')\n+\n+\n+def purge_relations(context=None):\n+    """Removes all entries form zc.relation catalog.\n+    RelationValues that were set as attribute on content are still there!\n+    These are removed/overwritten when restoring the relations.\n+    """\n+    rel_catalog = getUtility(ICatalog)\n+    rel_catalog.clear()\n+    logger.info(\'Purged zc.relation catalog\')\n+\n+\n+def restore_relations(context=None, all_relations=None):\n+    """Restore relations from a annotation on the portal.\n+    """\n+\n+    portal = getSite()\n+    if all_relations is None:\n+        all_relations = IAnnotations(portal)[RELATIONS_KEY]\n+    logger.info(f\'Loaded {len(all_relations)} relations to restore\')\n+    update_linkintegrity = set()\n+    modified_items = set()\n+    modified_relation_lists = defaultdict(list)\n+\n+    # remove duplicates but keep original order\n+    unique_relations = []\n+    seen = set()\n+    seen_add = seen.add\n+    for rel in all_relations:\n+        hashable = tuple(rel.items())\n+        if hashable not in seen:\n+            unique_relations.append(rel)\n+            seen_add(hashable)\n+        else:\n+            logger.info(f\'Dropping duplicate: {hashable}\')\n+\n+    if len(unique_relations) < len(all_relations):\n+        logger.info(f\'Dropping {len(all_relations) - len(unique_relations)} duplicates\')\n+        all_relations = unique_relations\n+\n+    intids = getUtility(IIntIds)\n+    for index, item in enumerate(all_relations, start=1):\n+        if not index % 500:\n+            logger.info(f\'Restored {index} of {len(all_relations)} relations...\')\n+\n+        try:\n+            source_obj = uuidToObject(item[\'from_uuid\'])\n+        except KeyError:\n+            # brain exists but no object\n+            source_obj = None\n+        try:\n+            target_obj = uuidToObject(item[\'to_uuid\'])\n+        except KeyError:\n+            # brain exists but no object\n+            target_obj = None\n+\n+        if not source_obj:\n+            logger.info(f\'{item["from_uuid"]} is missing\')\n+            continue\n+\n+        if not target_obj:\n+            logger.info(f\'{item["to_uuid"]} is missing\')\n+            continue\n+\n+        if not IDexterityContent.providedBy(source_obj):\n+            logger.info(f\'{source_obj} is no dexterity content\')\n+            continue\n+\n+        if not IDexterityContent.providedBy(target_obj):\n+            logger.info(f\'{target_obj} is no dexterity content\')\n+            continue\n+\n+        from_attribute = item[\'from_attribute\']\n+        to_id = intids.getId(target_obj)\n+\n+        if from_attribute == referencedRelationship:\n+            # Ignore linkintegrity for now. We\'ll rebuilt it at the end!\n+            update_linkintegrity.add(item[\'from_uuid\'])\n+            continue\n+\n+        if from_attribute == ITERATE_RELATION_NAME:\n+            # Iterate relations are not set as values of fields\n+            relation = StagingRelationValue(to_id)\n+            event._setRelation(source_obj, ITERATE_RELATION_NAME, relation)\n+            continue\n+\n+        field_and_schema = get_field_and_schema_for_fieldname(from_attribute, source_obj.portal_type)\n+        if field_and_schema is None:\n+            # the from_attribute is no field\n+            logger.info(f\'No field. Setting relation: {item}\')\n+            event._setRelation(source_obj, from_attribute, RelationValue(to_id))\n+            continue\n+\n+        field, schema = field_and_schema\n+        relation = RelationValue(to_id)\n+\n+        if isinstance(field, RelationList):\n+            logger.info(f\'Add relation to relationslist {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}\')\n+            if item[\'from_uuid\'] in modified_relation_lists.get(from_attribute, []):\n+                # Do not purge relations\n+                existing_relations = getattr(source_obj, from_attribute, [])\n+            else:\n+                # First touch. Make sure we purge!\n+                existing_relations = []\n+            existing_relations.append(relation)\n+            setattr(source_obj, from_attribute, existing_relations)\n+            modified_items.add(item[\'from_uuid\'])\n+            modified_relation_lists[from_attribute].append(item[\'from_uuid\'])\n+            continue\n+\n+        elif isinstance(field, (Relation, RelationChoice)):\n+            logger.info(f\'Add relation {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}\')\n+            setattr(source_obj, from_attribute, relation)\n+            modified_items.add(item[\'from_uuid\'])\n+            continue\n+\n+        else:\n+            # we should never end up here!\n+            logger.warn(f\'Unexpected relation {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}\')\n+\n+    update_linkintegrity = set(update_linkintegrity)\n+    logger.info(f\'Updating linkintegrity for {len(update_linkintegrity)} items\')\n+    for uuid in sorted(update_linkintegrity):\n+        modifiedContent(uuidToObject(uuid), None)\n+    logger.info(f\'Updating relations for {len(modified_items)} items\')\n+    for uuid in sorted(modified_items):\n+        obj = uuidToObject(uuid)\n+        # updateRelations from z3c.relationfield does not properly update relations in behaviors\n+        # that are registered with a marker-interface.\n+        # update_behavior_relations (from plone.app.relationfield) does that but does not update\n+        # those in the main schema. Duh!\n+        updateRelations(obj, None)\n+        update_behavior_relations(obj, None)\n+\n+    # purge annotation from portal if they exist\n+    if RELATIONS_KEY in IAnnotations(portal):\n+        del IAnnotations(portal)[RELATIONS_KEY]\n+    logger.info(\'Done!\')\n+\n+\n+def get_intid(obj):\n+    """Intid from intid-catalog"""\n+    intids = queryUtility(IIntIds)\n+    if intids is None:\n+        return\n+    # check that the object has an intid, otherwise there\'s nothing to be done\n+    try:\n+        return intids.getId(obj)\n+    except KeyError:  # noqa\n+        # The object has not been added to the ZODB yet\n+        return\n+\n+\n+def get_field_and_schema_for_fieldname(field_id, portal_type):\n+    """Get field and its schema from a portal_type.\n+    """\n+    # Turn form.widgets.IDublinCore.title into title\n+    field_id = field_id.split(\'.\')[-1]\n+    for schema in iterSchemataForType(portal_type):\n+        field = schema.get(field_id, None)\n+        if field is not None:\n+            return (field, schema)\n+\n+\n+def cleanup_intids(context=None):\n+    intids = getUtility(IIntIds)\n+    all_refs = [f\'{i.object.__class__.__module__}.{i.object.__class__.__name__}\'\n+                for i in intids.refs.values()]\n+    logger.info(Counter(all_refs))\n+\n+    count = 0\n+    refs = [i for i in intids.refs.values() if isinstance(i.object, RelationValue)]\n+    for ref in refs:\n+        intids.unregister(ref)\n+        count += 1\n+    logger.info(f\'Removed all {count} RelationValues from IntId-tool\')\n+\n+    count = 0\n+    for ref in intids.refs.values():\n+        if \'broken\' in repr(ref.object):\n+            intids.unregister(ref)\n+    logger.info(f\'Removed {count} broken refs from IntId-tool\')\n+    all_refs = [\'{i.object.__class__.__module__}.{i.object.__class__.__name__}\'\n+                for i in intids.refs.values()]\n+    logger.info(Counter(all_refs))\n+\n+\n+def flush_intids():\n+    """ Flush all intids\n+    """\n+    intids = getUtility(IIntIds)\n+    intids.ids = intids.family.OI.BTree()\n+    intids.refs = intids.family.IO.BTree()\n+\n+\n+def rebuild_intids():\n+    """ Create new intids\n+    """\n+    def add_to_intids(obj, path):\n+        if IContentish.providedBy(obj):\n+            logger.info(f\'Added {obj} at {path} to intid\')\n+            addIntIdSubscriber(obj, None)\n+    portal = getSite()\n+    portal.ZopeFindAndApply(portal,\n+                            search_sub=True,\n+                            apply_func=add_to_intids)\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:16:52+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/c959537701aa0bdfbe6f461b1e12b1b891a6e268

sort by title of items in left column. handle missing titles.

Files changed:
M Products/CMFPlone/controlpanel/browser/relations.py

b"diff --git a/Products/CMFPlone/controlpanel/browser/relations.py b/Products/CMFPlone/controlpanel/browser/relations.py\nindex db53c312fd..3ecd0a5455 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations.py\n+++ b/Products/CMFPlone/controlpanel/browser/relations.py\n@@ -1,4 +1,5 @@\n from collections import defaultdict\n+from operator import itemgetter\n from plone.registry.interfaces import IRegistry\n from Products.CMFPlone import PloneMessageFactory as _\n from Products.CMFPlone.relationhelper import get_relations_stats\n@@ -67,7 +68,7 @@ def __call__(self, relation=None, inspect_backrelation=False):\n             url = obj.absolute_url() + '/view' if use_view_action else obj.absolute_url()\n             item = {}\n             item['column_1'] = {\n-                'title': obj.title,\n+                'title': obj.title_or_id(),\n                 'url': url,\n                 'portal_type': obj.portal_type,\n             }\n@@ -77,10 +78,10 @@ def __call__(self, relation=None, inspect_backrelation=False):\n                 use_view_action = obj.portal_type in view_action\n                 url = obj.absolute_url() + '/view' if use_view_action else obj.absolute_url()\n                 item['column_2'].append({\n-                    'title': obj.title,\n+                    'title': obj.title_or_id(),\n                     'url': url,\n                     'portal_type': obj.portal_type,\n                     })\n             self.relations.append(item)\n-\n+        self.relations.sort(key=lambda x: x['column_1']['title'])\n         return self.index()\n"

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T18:45:53+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/3fbd93b7c360a8bbcee561026175bea5a172936f

replace plone.api calls

Files changed:
M Products/CMFPlone/controlpanel/tests/test_controlpanel_relations.py

b"diff --git a/Products/CMFPlone/controlpanel/tests/test_controlpanel_relations.py b/Products/CMFPlone/controlpanel/tests/test_controlpanel_relations.py\nindex eb5bde6286..07c0d232ec 100644\n--- a/Products/CMFPlone/controlpanel/tests/test_controlpanel_relations.py\n+++ b/Products/CMFPlone/controlpanel/tests/test_controlpanel_relations.py\n@@ -1,9 +1,9 @@\n from persistent.list import PersistentList\n-from plone import api\n from plone.app.testing import TEST_USER_ID, setRoles\n from Products.CMFPlone.controlpanel.browser.relations import get_relations_stats\n from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_INTEGRATION_TESTING\n from z3c.relationfield import RelationValue\n+from zope.component import getMultiAdapter\n from zope.component import getUtility\n from zope.intid.interfaces import IIntIds\n from zope.lifecycleevent import modified\n@@ -21,18 +21,10 @@ def setUp(self):\n         setRoles(self.portal, TEST_USER_ID, ('Manager',))\n \n     def test_relations_stats(self):\n-        doc1 = api.content.create(\n-            container=self.portal,\n-            type='Document',\n-            title='doc1',\n-            id='doc1',\n-            )\n-        doc2 = api.content.create(\n-            container=self.portal,\n-            type='Document',\n-            title='doc2',\n-            id='doc2',\n-            )\n+        self.portal.invokeFactory('Document', id='doc1', title='doc1')\n+        doc1 = self.portal['doc1']\n+        self.portal.invokeFactory('Document', id='doc2', title='doc2')\n+        doc2 = self.portal['doc2']\n         intids = getUtility(IIntIds)\n         doc1.relatedItems = PersistentList()\n         doc1.relatedItems.append(RelationValue(intids.getId(doc2)))\n@@ -43,29 +35,18 @@ def test_relations_stats(self):\n         stats, broken = get_relations_stats()\n         self.assertEqual(dict(stats), {'relatedItems': 1})\n         self.assertEqual(dict(broken), {})\n-        view = api.content.get_view('inspect-relations', self.portal, self.request)\n+        view = getMultiAdapter((self.portal, self.request), name='inspect-relations')\n         self.assertTrue(view())\n         self.assertTrue(view(relation='relatedItems'))\n \n     def test_relations_stats_broken(self):\n-        doc1 = api.content.create(\n-            container=self.portal,\n-            type='Document',\n-            title='doc1',\n-            id='doc1',\n-            )\n-        doc2 = api.content.create(\n-            container=self.portal,\n-            type='Document',\n-            title='doc2',\n-            id='doc2',\n-            )\n-        doc3 = api.content.create(\n-            container=self.portal,\n-            type='Document',\n-            title='doc3',\n-            id='doc3',\n-            )\n+        self.portal.invokeFactory('Document', id='doc1', title='doc1')\n+        doc1 = self.portal['doc1']\n+        self.portal.invokeFactory('Document', id='doc2', title='doc2')\n+        doc2 = self.portal['doc2']\n+        self.portal.invokeFactory('Document', id='doc3', title='doc3')\n+        doc3 = self.portal['doc3']\n+\n         intids = getUtility(IIntIds)\n         doc1.relatedItems = PersistentList()\n         doc1.relatedItems.append(RelationValue(intids.getId(doc2)))\n@@ -78,29 +59,17 @@ def test_relations_stats_broken(self):\n         stats, broken = get_relations_stats()\n         self.assertEqual(dict(stats), {'relatedItems': 1})\n         self.assertEqual(dict(broken), {'relatedItems': 1})\n-        view = api.content.get_view('inspect-relations', self.portal, self.request)\n+        view = getMultiAdapter((self.portal, self.request), name='inspect-relations')\n         self.assertTrue(view())\n         self.assertTrue(view(relation='relatedItems'))\n \n     def test_rebuild_relations(self):\n-        doc1 = api.content.create(\n-            container=self.portal,\n-            type='Document',\n-            title='doc1',\n-            id='doc1',\n-            )\n-        doc2 = api.content.create(\n-            container=self.portal,\n-            type='Document',\n-            title='doc2',\n-            id='doc2',\n-            )\n-        doc3 = api.content.create(\n-            container=self.portal,\n-            type='Document',\n-            title='doc3',\n-            id='doc3',\n-            )\n+        self.portal.invokeFactory('Document', id='doc1', title='doc1')\n+        doc1 = self.portal['doc1']\n+        self.portal.invokeFactory('Document', id='doc2', title='doc2')\n+        doc2 = self.portal['doc2']\n+        self.portal.invokeFactory('Document', id='doc3', title='doc3')\n+        doc3 = self.portal['doc3']\n         intids = getUtility(IIntIds)\n         doc1_intid = intids.getId(doc1)\n         doc2_intid = intids.getId(doc2)\n@@ -117,7 +86,7 @@ def test_rebuild_relations(self):\n         self.assertEqual(dict(stats), {'relatedItems': 2})\n         self.assertEqual(dict(broken), {})\n \n-        view = api.content.get_view('rebuild-relations', self.portal, self.request)\n+        view = getMultiAdapter((self.portal, self.request), name='rebuild-relations')\n         results = view(rebuild=True)\n \n         # relations are the same after a rebuild\n@@ -141,31 +110,19 @@ def test_rebuild_relations(self):\n         self.assertEqual(dict(broken), {'relatedItems': 1})\n \n         # broken relations are gone after rebuilding\n-        view = api.content.get_view('rebuild-relations', self.portal, self.request)\n+        view = getMultiAdapter((self.portal, self.request), name='rebuild-relations')\n         results = view(rebuild=True)\n         stats, broken = get_relations_stats()\n         self.assertEqual(dict(stats), {'relatedItems': 1})\n         self.assertEqual(dict(broken), {})\n \n     def test_rebuild_relations_with_intid(self):\n-        doc1 = api.content.create(\n-            container=self.portal,\n-            type='Document',\n-            title='doc1',\n-            id='doc1',\n-            )\n-        doc2 = api.content.create(\n-            container=self.portal,\n-            type='Document',\n-            title='doc2',\n-            id='doc2',\n-            )\n-        doc3 = api.content.create(\n-            container=self.portal,\n-            type='Document',\n-            title='doc3',\n-            id='doc3',\n-            )\n+        self.portal.invokeFactory('Document', id='doc1', title='doc1')\n+        doc1 = self.portal['doc1']\n+        self.portal.invokeFactory('Document', id='doc2', title='doc2')\n+        doc2 = self.portal['doc2']\n+        self.portal.invokeFactory('Document', id='doc3', title='doc3')\n+        doc3 = self.portal['doc3']\n         intids = getUtility(IIntIds)\n         doc1_intid = intids.getId(doc1)\n         doc2_intid = intids.getId(doc2)\n@@ -181,7 +138,7 @@ def test_rebuild_relations_with_intid(self):\n         self.assertEqual(dict(stats), {'relatedItems': 2})\n         self.assertEqual(dict(broken), {})\n \n-        view = api.content.get_view('rebuild-relations', self.portal, self.request)\n+        view = getMultiAdapter((self.portal, self.request), name='rebuild-relations')\n         results = view(rebuild=True, flush_and_rebuild_intids=True)\n \n         # relations are the same after a rebuild\n"

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-11T19:47:33+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/980ce011be4b2c301f5c50f97e6b8580e9c2c460

fix permission

Files changed:
M Products/CMFPlone/profiles/default/controlpanel.xml

b'diff --git a/Products/CMFPlone/profiles/default/controlpanel.xml b/Products/CMFPlone/profiles/default/controlpanel.xml\nindex dab561a5f9..8593740f2a 100644\n--- a/Products/CMFPlone/profiles/default/controlpanel.xml\n+++ b/Products/CMFPlone/profiles/default/controlpanel.xml\n@@ -220,6 +220,6 @@\n     url_expr="string:${portal_url}/@@inspect-relations"\n     visible="True"\n     i18n:attributes="title">\n-  <permission>Manage Relations</permission>\n+  <permission>Inspect Relations</permission>\n  </configlet>\n </object>\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-12T08:39:49+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/4c30d61df666e0e3c7c11386e02c4542e2e0c54a

Backport from collective.relationhelpers: Handle IntIdMissingError and ObjectMissingError when inspecting relations.

Files changed:
M Products/CMFPlone/controlpanel/browser/relations.py
M Products/CMFPlone/relationhelper.py

b"diff --git a/Products/CMFPlone/controlpanel/browser/relations.py b/Products/CMFPlone/controlpanel/browser/relations.py\nindex 3ecd0a5455..3503eac539 100644\n--- a/Products/CMFPlone/controlpanel/browser/relations.py\n+++ b/Products/CMFPlone/controlpanel/browser/relations.py\n@@ -57,6 +57,11 @@ def __call__(self, relation=None, inspect_backrelation=False):\n         for rel in relation_catalog.findRelations(query):\n             if rel.isBroken():\n                 continue\n+            try:\n+                hasattr(rel, 'from_id')\n+                hasattr(rel, 'to_id')\n+            except IntIdMissingError:\n+                continue\n             if self.inspect_backrelation:\n                 info[rel.to_id].append(rel.from_id)\n             else:\ndiff --git a/Products/CMFPlone/relationhelper.py b/Products/CMFPlone/relationhelper.py\nindex 5275e18253..d0ff347abd 100644\n--- a/Products/CMFPlone/relationhelper.py\n+++ b/Products/CMFPlone/relationhelper.py\n@@ -23,6 +23,7 @@\n from zope.component import queryUtility\n from zope.component.hooks import getSite\n from zope.intid.interfaces import IIntIds\n+from zope.intid.interfaces import ObjectMissingError\n \n import logging\n \n@@ -46,7 +47,14 @@ def get_relations_stats():\n     info = defaultdict(int)\n     broken = defaultdict(int)\n     relation_catalog = getUtility(ICatalog)\n-    for rel in relation_catalog.findRelations():\n+    for token in relation_catalog.findRelationTokens():\n+        try:\n+            rel = relation_catalog.resolveRelationToken(token)\n+        except ObjectMissingError:\n+            broken['Object is missing'] += 1\n+            logger.info('Token {} has no object.'.format(token))\n+            continue\n+\n         if rel.isBroken():\n             broken[rel.from_attribute] += 1\n         else:\n@@ -62,7 +70,13 @@ def get_all_relations():\n     info = defaultdict(int)\n \n     relation_catalog = getUtility(ICatalog)\n-    for rel in relation_catalog.findRelations():\n+    for token in relation_catalog.findRelationTokens():\n+        try:\n+            rel = relation_catalog.resolveRelationToken(token)\n+        except ObjectMissingError:\n+            logger.info('Token {} has no object.'.format(token))\n+            continue\n+\n         if rel.from_object and rel.to_object:\n             try:\n                 results.append({\n"

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-12T12:48:03+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/a7c5c20162fbfb8cb2130d7ec796a6dba906d021

fix appId and changenote

Files changed:
M Products/CMFPlone/profiles/default/controlpanel.xml
M news/3231.feature

b'diff --git a/Products/CMFPlone/profiles/default/controlpanel.xml b/Products/CMFPlone/profiles/default/controlpanel.xml\nindex 8593740f2a..05f46d25ed 100644\n--- a/Products/CMFPlone/profiles/default/controlpanel.xml\n+++ b/Products/CMFPlone/profiles/default/controlpanel.xml\n@@ -215,7 +215,7 @@\n  </configlet>\n  <configlet title="Relations" action_id="inspectrelations"\n     icon_expr="string:share-fill"\n-    appId="Plone" category="plone-content"\n+    appId="Relations" category="plone-content"\n     condition_expr=""\n     url_expr="string:${portal_url}/@@inspect-relations"\n     visible="True"\ndiff --git a/news/3231.feature b/news/3231.feature\nindex 7d1d9a81ae..e7254a3b72 100644\n--- a/news/3231.feature\n+++ b/news/3231.feature\n@@ -1,2 +1,2 @@\n-Include a controlpanel for relations.\n-[loechel]\n\\ No newline at end of file\n+Include a controlpanel to inspect and rebuild relations.\n+[pbauer]\n\\ No newline at end of file\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-16T09:44:56+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/d84f3df64ce58897d521c21260beed3184c50ee3

Merge branch 'master' into plip3231-controlpanel-for-relations

Files changed:
A news/3299.bugfix
M Products/CMFPlone/controlpanel/tests/test_controlpanel_browser_usergroups_siteadmin_role.py
M Products/CMFPlone/tests/dummy.py
M Products/CMFPlone/tests/test_expressions.py

b'diff --git a/Products/CMFPlone/controlpanel/tests/test_controlpanel_browser_usergroups_siteadmin_role.py b/Products/CMFPlone/controlpanel/tests/test_controlpanel_browser_usergroups_siteadmin_role.py\nindex cf4edb6e30..5b5dea724e 100644\n--- a/Products/CMFPlone/controlpanel/tests/test_controlpanel_browser_usergroups_siteadmin_role.py\n+++ b/Products/CMFPlone/controlpanel/tests/test_controlpanel_browser_usergroups_siteadmin_role.py\n@@ -7,7 +7,6 @@\n from plone.testing.zope import Browser\n from Products.CMFCore.utils import getToolByName\n from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING\n-from io import StringIO\n from urllib.parse import urlencode\n \n import re\ndiff --git a/Products/CMFPlone/tests/dummy.py b/Products/CMFPlone/tests/dummy.py\nindex c89a7b3852..5ff3e8db1b 100644\n--- a/Products/CMFPlone/tests/dummy.py\n+++ b/Products/CMFPlone/tests/dummy.py\n@@ -6,7 +6,6 @@\n from OFS.SimpleItem import SimpleItem\n from Products.CMFPlone.interfaces import INonStructuralFolder\n from Products.CMFPlone.interfaces import IWorkflowChain\n-from io import StringIO\n from io import BytesIO\n from zope.interface import implementer\n from zope.interface import Interface\ndiff --git a/Products/CMFPlone/tests/test_expressions.py b/Products/CMFPlone/tests/test_expressions.py\nindex 7815889b8b..44304311b1 100644\n--- a/Products/CMFPlone/tests/test_expressions.py\n+++ b/Products/CMFPlone/tests/test_expressions.py\n@@ -13,7 +13,6 @@\n from Products.PageTemplates.Expressions import boboAwareZopeTraverse as traverse_function\n from Products.PageTemplates.Expressions import trustedBoboAwareZopeTraverse as trusted_traverse_function\n from Products.PageTemplates.PageTemplateFile import PageTemplateFile\n-from random import _os\n from zExceptions import NotFound\n from zExceptions import Unauthorized\n \ndiff --git a/news/3299.bugfix b/news/3299.bugfix\nnew file mode 100644\nindex 0000000000..49fabfc5bc\n--- /dev/null\n+++ b/news/3299.bugfix\n@@ -0,0 +1 @@\n+Remove unused imports. [jensens]\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2021-08-16T10:40:10+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFPlone/commit/2b2981d4cbe90f37fe69930cead801c3692b9316

Merge pull request #3232 from plone/plip3231-controlpanel-for-relations

PLIP: Include a controlpanel for relations.

Files changed:
A Products/CMFPlone/controlpanel/browser/relations.py
A Products/CMFPlone/controlpanel/browser/relations_inspect.pt
A Products/CMFPlone/controlpanel/browser/relations_rebuild.pt
A Products/CMFPlone/controlpanel/tests/test_controlpanel_relations.py
A Products/CMFPlone/relationhelper.py
A news/3231.feature
M Products/CMFPlone/controlpanel/browser/configure.zcml
M Products/CMFPlone/controlpanel/permissions.zcml
M Products/CMFPlone/profiles/default/controlpanel.xml

b'diff --git a/Products/CMFPlone/controlpanel/browser/configure.zcml b/Products/CMFPlone/controlpanel/browser/configure.zcml\nindex 8e2cafd0b6..48dc844325 100644\n--- a/Products/CMFPlone/controlpanel/browser/configure.zcml\n+++ b/Products/CMFPlone/controlpanel/browser/configure.zcml\n@@ -321,4 +321,22 @@\n       allowed_attributes="redirects view_url"\n       />\n \n+  <!-- Relations -->\n+\n+  <browser:page\n+      name="inspect-relations"\n+      for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+      class=".relations.RelationsInspectControlpanel"\n+      template="relations_inspect.pt"\n+      permission="Products.CMFPlone.InspectRelations"\n+      />\n+\n+  <browser:page\n+      name="rebuild-relations"\n+      for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+      class=".relations.RelationsRebuildControlpanel"\n+      template="relations_rebuild.pt"\n+      permission="cmf.ManagePortal"\n+      />\n+\n </configure>\ndiff --git a/Products/CMFPlone/controlpanel/browser/relations.py b/Products/CMFPlone/controlpanel/browser/relations.py\nnew file mode 100644\nindex 0000000000..3503eac539\n--- /dev/null\n+++ b/Products/CMFPlone/controlpanel/browser/relations.py\n@@ -0,0 +1,92 @@\n+from collections import defaultdict\n+from operator import itemgetter\n+from plone.registry.interfaces import IRegistry\n+from Products.CMFPlone import PloneMessageFactory as _\n+from Products.CMFPlone.relationhelper import get_relations_stats\n+from Products.CMFPlone.relationhelper import rebuild_relations\n+from Products.Five.browser import BrowserView\n+from Products.statusmessages.interfaces import IStatusMessage\n+from zc.relation.interfaces import ICatalog\n+from zope.annotation.interfaces import IAnnotations\n+from zope.component import getUtility\n+from zope.component import queryUtility\n+from zope.intid.interfaces import IIntIds\n+\n+import logging\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class RelationsRebuildControlpanel(BrowserView):\n+\n+    def __call__(self, rebuild=False, flush_and_rebuild_intids=False):\n+        self.done = False\n+        if rebuild:\n+            rebuild_relations(flush_and_rebuild_intids=flush_and_rebuild_intids)\n+            self.done = True\n+            IStatusMessage(self.request).addStatusMessage(\n+                _(\'Finished! See log for details.\'), \'info\')\n+\n+        self.relations_stats, self.broken = get_relations_stats()\n+        return self.index()\n+\n+\n+class RelationsInspectControlpanel(BrowserView):\n+\n+    def __call__(self, relation=None, inspect_backrelation=False):\n+        self.relation = relation or self.request.get(\'relation\')\n+        self.inspect_backrelation = inspect_backrelation or self.request.get(\'inspect_backrelation\')\n+\n+        self.relations = []\n+        self.relations_stats, self.broken = get_relations_stats()\n+        registry = getUtility(IRegistry)\n+        view_action = registry[\'plone.types_use_view_action_in_listings\']\n+\n+        if not self.relation:\n+            IStatusMessage(self.request).addStatusMessage(\n+                _(\'Please select a relation\'), \'info\')\n+            return self.index()\n+\n+        intids = queryUtility(IIntIds)\n+        relation_catalog = getUtility(ICatalog)\n+        query = {\'from_attribute\': self.relation}\n+        info = defaultdict(list)\n+\n+        # relations: column_1 = source, column_2 = target(s)\n+        # backrelation: column_1 = target, column_2 source(s)\n+        for rel in relation_catalog.findRelations(query):\n+            if rel.isBroken():\n+                continue\n+            try:\n+                hasattr(rel, \'from_id\')\n+                hasattr(rel, \'to_id\')\n+            except IntIdMissingError:\n+                continue\n+            if self.inspect_backrelation:\n+                info[rel.to_id].append(rel.from_id)\n+            else:\n+                info[rel.from_id].append(rel.to_id)\n+\n+        for column_1_intid in info:\n+            obj = intids.getObject(column_1_intid)\n+            use_view_action = obj.portal_type in view_action\n+            url = obj.absolute_url() + \'/view\' if use_view_action else obj.absolute_url()\n+            item = {}\n+            item[\'column_1\'] = {\n+                \'title\': obj.title_or_id(),\n+                \'url\': url,\n+                \'portal_type\': obj.portal_type,\n+            }\n+            item[\'column_2\'] = []\n+            for column_2_intid in info[column_1_intid]:\n+                obj = intids.getObject(column_2_intid)\n+                use_view_action = obj.portal_type in view_action\n+                url = obj.absolute_url() + \'/view\' if use_view_action else obj.absolute_url()\n+                item[\'column_2\'].append({\n+                    \'title\': obj.title_or_id(),\n+                    \'url\': url,\n+                    \'portal_type\': obj.portal_type,\n+                    })\n+            self.relations.append(item)\n+        self.relations.sort(key=lambda x: x[\'column_1\'][\'title\'])\n+        return self.index()\ndiff --git a/Products/CMFPlone/controlpanel/browser/relations_inspect.pt b/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\nnew file mode 100644\nindex 0000000000..d5771e0a50\n--- /dev/null\n+++ b/Products/CMFPlone/controlpanel/browser/relations_inspect.pt\n@@ -0,0 +1,134 @@\n+<html xmlns="http://www.w3.org/1999/xhtml"\n+      xml:lang="en"\n+      xmlns:tal="http://xml.zope.org/namespaces/tal"\n+      xmlns:metal="http://xml.zope.org/namespaces/metal"\n+      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n+      lang="en"\n+      metal:use-macro="context/prefs_main_template/macros/master"\n+      i18n:domain="plone">\n+\n+<body>\n+\n+  <metal:main metal:fill-slot="prefs_configlet_main" i18n:domain="plone"\n+      tal:define="inspect_backrelation python: view.inspect_backrelation;\n+                  relation python: view.relation;">\n+\n+      <a id="setup-link" class="link-parent"\n+         tal:attributes="href string:$portal_url/@@overview-controlpanel"\n+         i18n:translate="">\n+          Site Setup\n+      </a>\n+\n+    <header>\n+      <h1 class="documentFirstHeading"\n+          tal:condition="python: not inspect_backrelation">\n+        <span i18n:translate="">Inspect relations</span>\n+        <strong tal:content="python: relation">relation</strong>\n+      </h1>\n+\n+      <h1 class="documentFirstHeading"\n+          tal:condition="python: inspect_backrelation">\n+        <span i18n:translate="">Inspect backrelations</span>\n+        <strong tal:content="python: relation">backrelation</strong>\n+      </h1>\n+\n+    </header>\n+\n+    <div id="content-core"\n+         tal:define="relations_stats python: view.relations_stats">\n+\n+      <div tal:condition="python: view.broken"\n+           class="portalMessage warning alert alert-warning" role="alert"\n+           i18n:translate="">\n+             <strong>Warning!</strong> You have broken relations!\n+             You can <a href="@@rebuild_relations">inspect and rebuild all relations</a>.\n+      </div>\n+\n+      <form id="relationinfo" method="post" action="@@inspect-relations" enctype="multipart/form-data">\n+\n+        <div class="mb-3 field">\n+          <select class="form-select" aria-label="Default select example" name="relation" id="relation">\n+            <option value="" i18n:translate="">Select a relation</option>\n+            <tal:rels tal:repeat="from_attribute python: sorted(relations_stats)">\n+              <option tal:attributes="value python: from_attribute;\n+                                      selected python: relation == from_attribute"\n+                      tal:content="python:\'{} ({})\'.format(from_attribute, relations_stats[from_attribute])">\n+                  relationname (amount)\n+              </option>\n+            </tal:rels>\n+          </select>\n+        </div>\n+\n+        <div class="mb-3 field">\n+          <div class="form-check" id="inspect_backrelation">\n+            <input id="inspect-backrelation"\n+                   name="inspect_backrelation"\n+                   class="form-check-input single-checkbox-bool-widget bool-field"\n+                   value="selected"\n+                   type="checkbox"\n+                   checked="checked"\n+                   tal:attributes="checked python: \'checked\' if inspect_backrelation else \'\'">\n+            <label for="inspect-backrelation"\n+                   class="form-check-label"\n+                   i18n:translate="">\n+              Show backrelations\n+            </label>\n+            <div class="form-text" i18n:translate="">Display relations grouped by their target.</div>\n+          </div>\n+        </div>\n+\n+        <button class="context btn btn-primary" type="submit" name="submit" value="submit" i18n:translate="">Inspect</button>\n+      </form>\n+\n+      <table class="listing table table-striped"\n+             tal:condition="python:view.relations">\n+        <thead>\n+          <tr tal:condition="python: not inspect_backrelation">\n+            <th i18n:translate="">Source</th>\n+            <th>&rarr;</th>\n+            <th i18n:translate="">Target(s)</th>\n+          </tr>\n+\n+          <tr tal:condition="python: inspect_backrelation">\n+            <th i18n:translate="">Target</th>\n+            <th>&larr;</th>\n+            <th i18n:translate="">Source(s)</th>\n+          </tr>\n+        </thead>\n+        <tbody>\n+          <tr tal:repeat="item python:view.relations">\n+            <td>\n+              <a tal:attributes="href python:item[\'column_1\'][\'url\'];\n+                                 title python:item[\'column_1\'][\'portal_type\'];"\n+                 tal:content="python:item[\'column_1\'][\'title\']">\n+                Object\n+              </a>\n+            </td>\n+\n+            <td tal:condition="python: not inspect_backrelation">&rarr;</td>\n+            <td tal:condition="python: inspect_backrelation">&larr;</td>\n+            <td>\n+              <ul>\n+                <li tal:repeat="target python:item[\'column_2\']">\n+                  <a href=""\n+                     tal:attributes="href python:target[\'url\'];\n+                                     title python:target[\'portal_type\']; "\n+                     tal:content="python:target[\'title\']">\n+                    Target\n+                  </a>\n+                </li>\n+              </ul>\n+            </td>\n+          </tr>\n+        </tbody>\n+      </table>\n+\n+      <p><a href="@@rebuild-relations" i18n:translate="">Inspect and rebuild all relations</a>.</p>\n+\n+    </div>\n+\n+  </metal:main>\n+\n+</body>\n+\n+</html>\ndiff --git a/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt b/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt\nnew file mode 100644\nindex 0000000000..5007082020\n--- /dev/null\n+++ b/Products/CMFPlone/controlpanel/browser/relations_rebuild.pt\n@@ -0,0 +1,105 @@\n+<html xmlns="http://www.w3.org/1999/xhtml"\n+      xml:lang="en"\n+      xmlns:tal="http://xml.zope.org/namespaces/tal"\n+      xmlns:metal="http://xml.zope.org/namespaces/metal"\n+      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n+      lang="en"\n+      metal:use-macro="context/prefs_main_template/macros/master"\n+      i18n:domain="plone">\n+\n+<body>\n+\n+  <metal:main metal:fill-slot="prefs_configlet_main">\n+\n+      <a id="setup-link" class="link-parent"\n+         tal:attributes="href string:$portal_url/@@overview-controlpanel"\n+         i18n:translate="">\n+          Site Setup\n+      </a>\n+\n+    <header>\n+      <h1 class="documentFirstHeading" i18n:translate="">Rebuild relations</h1>\n+    </header>\n+\n+    <div id="content-core">\n+\n+      <span tal:condition="python:view.done" i18n:translate="">Success!</span>\n+      <h3 i18n:translate="">\n+         Current relations in the relation catalog\n+      </h3>\n+\n+      <table class="listing table table-striped"\n+            tal:define="relations_stats python: getattr(view, \'relations_stats\', None)"\n+            tal:condition="python: relations_stats">\n+        <thead>\n+          <tr>\n+            <th i18n:translate="">Relation</th>\n+            <th i18n:translate="">Amount</th>\n+          </tr>\n+        </thead>\n+        <tbody>\n+          <tr tal:repeat="item python: sorted(relations_stats)">\n+            <td>\n+              <a href=""\n+                 target="_blank"\n+                 tal:attributes="href python:\'@@inspect-relations?relation={}\'.format(item)"\n+                 tal:content="python:item"\n+                 title="Inspect relations">\n+               Type\n+              </a>\n+            </td>\n+            <td tal:content="python:relations_stats[item]">Amount</td>\n+          </tr>\n+        </tbody>\n+      </table>\n+\n+      <h3 i18n:translate="">Common relations:</h3>\n+      <dl>\n+        <dt>relatedItems</dt>\n+        <dd i18n:translate="">Relations between content using the default "Related items" field</dd>\n+\n+        <dt>isReferencing</dt>\n+        <dd i18n:translate="">Linkintegrity relations (source has a html-link to target)</dd>\n+\n+        <dt>iterate-working-copy</dt>\n+        <dd i18n:translate="">Relation from content to a working copy (using plone.app.iterate)</dd>\n+\n+        <dt>staging-working-copy</dt>\n+        <dd i18n:translate="">Outdated relation from content to a working copy (using plone.app.stagingbehavior)</dd>\n+\n+        <dt>(broken)</dt>\n+        <dd i18n:translate="">Either source or target no longer exist</dd>\n+\n+        <dt><i>all other</i></dt>\n+        <dd i18n:translate="">Custom attribute/fieldname used to describe the relation</dd>\n+      </dl>\n+\n+      <form id="rebuild_relations" method="post" action="@@rebuild-relations" enctype="multipart/form-data">\n+        <h3 i18n:translate="">Purge and rebuild relation-catalog</h3>\n+        <p i18n:translate="">Clicking here will do the following:</p>\n+        <ul>\n+          <li i18n:translate="">Get all relations from zc.relation catalog and store them in a annotation on the portal.</li>\n+          <li i18n:translate="">Remove all entries form zc.relation catalog.</li>\n+          <li i18n:translate="">Clean up or flush and rebuild intids - this depends on your selection below</li>\n+          <li i18n:translate="">Restore relations from the annotation on the portal.</li>\n+        </ul>\n+\n+        <div class="form-check">\n+          <input class="form-check-input" type="checkbox" name="flush_and_rebuild_intids" id="flush_intids">\n+          <label class="form-check-label" for="flush_intids" i18n:translate="">Flush and rebuild intids</label>\n+          <p i18n:translate="">\n+             This will delete all intids and create new one.<br/>\n+             Warning: If you have a lot of relations this can take some time. Check the log for details!<br/>\n+             If you have relations on tiles, flushing and rebuilding intids will destroy them b/c intids changed.\n+          </p>\n+        </div>\n+        <button class="context btn btn-danger" type="submit" name="rebuild" value="rebuild" i18n:translate="">Rebuild</button>\n+\n+      </form>\n+    </div>\n+\n+  </metal:main>\n+\n+</body>\n+\n+</html>\ndiff --git a/Products/CMFPlone/controlpanel/permissions.zcml b/Products/CMFPlone/controlpanel/permissions.zcml\nindex 7c128c1307..249aeb6c71 100644\n--- a/Products/CMFPlone/controlpanel/permissions.zcml\n+++ b/Products/CMFPlone/controlpanel/permissions.zcml\n@@ -79,4 +79,10 @@\n     <role name="Site Administrator"/>\n   </permission>\n \n+  <permission id="Products.CMFPlone.InspectRelations"\n+              title="Inspect Relations">\n+    <role name="Manager"/>\n+    <role name="Site Administrator"/>\n+  </permission>\n+\n </configure>\ndiff --git a/Products/CMFPlone/controlpanel/tests/test_controlpanel_relations.py b/Products/CMFPlone/controlpanel/tests/test_controlpanel_relations.py\nnew file mode 100644\nindex 0000000000..07c0d232ec\n--- /dev/null\n+++ b/Products/CMFPlone/controlpanel/tests/test_controlpanel_relations.py\n@@ -0,0 +1,155 @@\n+from persistent.list import PersistentList\n+from plone.app.testing import TEST_USER_ID, setRoles\n+from Products.CMFPlone.controlpanel.browser.relations import get_relations_stats\n+from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_INTEGRATION_TESTING\n+from z3c.relationfield import RelationValue\n+from zope.component import getMultiAdapter\n+from zope.component import getUtility\n+from zope.intid.interfaces import IIntIds\n+from zope.lifecycleevent import modified\n+\n+import unittest\n+\n+\n+class TestRelationsControlpanel(unittest.TestCase):\n+\n+    layer = PRODUCTS_CMFPLONE_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+        self.request = self.layer[\'request\']\n+        setRoles(self.portal, TEST_USER_ID, (\'Manager\',))\n+\n+    def test_relations_stats(self):\n+        self.portal.invokeFactory(\'Document\', id=\'doc1\', title=\'doc1\')\n+        doc1 = self.portal[\'doc1\']\n+        self.portal.invokeFactory(\'Document\', id=\'doc2\', title=\'doc2\')\n+        doc2 = self.portal[\'doc2\']\n+        intids = getUtility(IIntIds)\n+        doc1.relatedItems = PersistentList()\n+        doc1.relatedItems.append(RelationValue(intids.getId(doc2)))\n+        modified(doc1)\n+        # TODO: simplify when relation-support is merged into plone.api\n+        # api.relation.create(doc1, doc2, \'relatedItems\')\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {\'relatedItems\': 1})\n+        self.assertEqual(dict(broken), {})\n+        view = getMultiAdapter((self.portal, self.request), name=\'inspect-relations\')\n+        self.assertTrue(view())\n+        self.assertTrue(view(relation=\'relatedItems\'))\n+\n+    def test_relations_stats_broken(self):\n+        self.portal.invokeFactory(\'Document\', id=\'doc1\', title=\'doc1\')\n+        doc1 = self.portal[\'doc1\']\n+        self.portal.invokeFactory(\'Document\', id=\'doc2\', title=\'doc2\')\n+        doc2 = self.portal[\'doc2\']\n+        self.portal.invokeFactory(\'Document\', id=\'doc3\', title=\'doc3\')\n+        doc3 = self.portal[\'doc3\']\n+\n+        intids = getUtility(IIntIds)\n+        doc1.relatedItems = PersistentList()\n+        doc1.relatedItems.append(RelationValue(intids.getId(doc2)))\n+        doc1.relatedItems.append(RelationValue(intids.getId(doc3)))\n+        modified(doc1)\n+        # api.relation.create(doc1, doc2, \'relatedItems\')\n+        # api.relation.create(doc1, doc3, \'relatedItems\')\n+\n+        self.portal._delObject(\'doc2\')\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {\'relatedItems\': 1})\n+        self.assertEqual(dict(broken), {\'relatedItems\': 1})\n+        view = getMultiAdapter((self.portal, self.request), name=\'inspect-relations\')\n+        self.assertTrue(view())\n+        self.assertTrue(view(relation=\'relatedItems\'))\n+\n+    def test_rebuild_relations(self):\n+        self.portal.invokeFactory(\'Document\', id=\'doc1\', title=\'doc1\')\n+        doc1 = self.portal[\'doc1\']\n+        self.portal.invokeFactory(\'Document\', id=\'doc2\', title=\'doc2\')\n+        doc2 = self.portal[\'doc2\']\n+        self.portal.invokeFactory(\'Document\', id=\'doc3\', title=\'doc3\')\n+        doc3 = self.portal[\'doc3\']\n+        intids = getUtility(IIntIds)\n+        doc1_intid = intids.getId(doc1)\n+        doc2_intid = intids.getId(doc2)\n+        doc3_intid = intids.getId(doc3)\n+\n+        doc1.relatedItems = PersistentList()\n+        doc1.relatedItems.append(RelationValue(doc2_intid))\n+        doc1.relatedItems.append(RelationValue(doc3_intid))\n+        modified(doc1)\n+        # api.relation.create(doc1, doc2, \'relatedItems\')\n+        # api.relation.create(doc1, doc3, \'relatedItems\')\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {\'relatedItems\': 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        view = getMultiAdapter((self.portal, self.request), name=\'rebuild-relations\')\n+        results = view(rebuild=True)\n+\n+        # relations are the same after a rebuild\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {\'relatedItems\': 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        # intids are not changed\n+        doc1_intid_after = intids.getId(doc1)\n+        doc2_intid_after = intids.getId(doc2)\n+        doc3_intid_after = intids.getId(doc3)\n+        self.assertEqual(doc1_intid, doc1_intid_after)\n+        self.assertEqual(doc2_intid, doc2_intid_after)\n+        self.assertEqual(doc3_intid, doc3_intid_after)\n+\n+        # break a relation\n+        self.portal._delObject(\'doc2\')\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {\'relatedItems\': 1})\n+        self.assertEqual(dict(broken), {\'relatedItems\': 1})\n+\n+        # broken relations are gone after rebuilding\n+        view = getMultiAdapter((self.portal, self.request), name=\'rebuild-relations\')\n+        results = view(rebuild=True)\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {\'relatedItems\': 1})\n+        self.assertEqual(dict(broken), {})\n+\n+    def test_rebuild_relations_with_intid(self):\n+        self.portal.invokeFactory(\'Document\', id=\'doc1\', title=\'doc1\')\n+        doc1 = self.portal[\'doc1\']\n+        self.portal.invokeFactory(\'Document\', id=\'doc2\', title=\'doc2\')\n+        doc2 = self.portal[\'doc2\']\n+        self.portal.invokeFactory(\'Document\', id=\'doc3\', title=\'doc3\')\n+        doc3 = self.portal[\'doc3\']\n+        intids = getUtility(IIntIds)\n+        doc1_intid = intids.getId(doc1)\n+        doc2_intid = intids.getId(doc2)\n+        doc3_intid = intids.getId(doc3)\n+        doc1.relatedItems = PersistentList()\n+        doc1.relatedItems.append(RelationValue(doc2_intid))\n+        doc1.relatedItems.append(RelationValue(doc3_intid))\n+        modified(doc1)\n+        # api.relation.create(doc1, doc2, \'relatedItems\')\n+        # api.relation.create(doc1, doc3, \'relatedItems\')\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {\'relatedItems\': 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        view = getMultiAdapter((self.portal, self.request), name=\'rebuild-relations\')\n+        results = view(rebuild=True, flush_and_rebuild_intids=True)\n+\n+        # relations are the same after a rebuild\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {\'relatedItems\': 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        # intids are now changed\n+        doc1_intid_after = intids.getId(doc1)\n+        doc2_intid_after = intids.getId(doc2)\n+        doc3_intid_after = intids.getId(doc3)\n+        self.assertNotEqual(doc1_intid, doc1_intid_after)\n+        self.assertNotEqual(doc2_intid, doc2_intid_after)\n+        self.assertNotEqual(doc3_intid, doc3_intid_after)\ndiff --git a/Products/CMFPlone/profiles/default/controlpanel.xml b/Products/CMFPlone/profiles/default/controlpanel.xml\nindex 6507e38c31..05f46d25ed 100644\n--- a/Products/CMFPlone/profiles/default/controlpanel.xml\n+++ b/Products/CMFPlone/profiles/default/controlpanel.xml\n@@ -213,4 +213,13 @@\n     i18n:attributes="title">\n   <permission>Manage Portal Aliases</permission>\n  </configlet>\n+ <configlet title="Relations" action_id="inspectrelations"\n+    icon_expr="string:share-fill"\n+    appId="Relations" category="plone-content"\n+    condition_expr=""\n+    url_expr="string:${portal_url}/@@inspect-relations"\n+    visible="True"\n+    i18n:attributes="title">\n+  <permission>Inspect Relations</permission>\n+ </configlet>\n </object>\ndiff --git a/Products/CMFPlone/relationhelper.py b/Products/CMFPlone/relationhelper.py\nnew file mode 100644\nindex 0000000000..d0ff347abd\n--- /dev/null\n+++ b/Products/CMFPlone/relationhelper.py\n@@ -0,0 +1,311 @@\n+from collections import Counter\n+from collections import defaultdict\n+from five.intid.intid import addIntIdSubscriber\n+from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n+from plone.app.iterate.dexterity.relation import StagingRelationValue\n+from plone.app.linkintegrity.handlers import modifiedContent\n+from plone.app.linkintegrity.utils import referencedRelationship\n+from plone.app.relationfield.event import update_behavior_relations\n+from plone.app.uuid.utils import uuidToObject\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.dexterity.utils import iterSchemataForType\n+from Products.CMFCore.interfaces import IContentish\n+from Products.CMFPlone import PloneMessageFactory as _\n+from z3c.relationfield import event\n+from z3c.relationfield import RelationValue\n+from z3c.relationfield.event import updateRelations\n+from z3c.relationfield.schema import Relation\n+from z3c.relationfield.schema import RelationChoice\n+from z3c.relationfield.schema import RelationList\n+from zc.relation.interfaces import ICatalog\n+from zope.annotation.interfaces import IAnnotations\n+from zope.component import getUtility\n+from zope.component import queryUtility\n+from zope.component.hooks import getSite\n+from zope.intid.interfaces import IIntIds\n+from zope.intid.interfaces import ObjectMissingError\n+\n+import logging\n+\n+logger = logging.getLogger(__name__)\n+\n+RELATIONS_KEY = \'ALL_REFERENCES\'\n+\n+\n+def rebuild_relations(context=None, flush_and_rebuild_intids=False):\n+    store_relations()\n+    purge_relations()\n+    if flush_and_rebuild_intids:\n+        flush_intids()\n+        rebuild_intids()\n+    else:\n+        cleanup_intids()\n+    restore_relations()\n+\n+\n+def get_relations_stats():\n+    info = defaultdict(int)\n+    broken = defaultdict(int)\n+    relation_catalog = getUtility(ICatalog)\n+    for token in relation_catalog.findRelationTokens():\n+        try:\n+            rel = relation_catalog.resolveRelationToken(token)\n+        except ObjectMissingError:\n+            broken[\'Object is missing\'] += 1\n+            logger.info(\'Token {} has no object.\'.format(token))\n+            continue\n+\n+        if rel.isBroken():\n+            broken[rel.from_attribute] += 1\n+        else:\n+            info[rel.from_attribute] += 1\n+    return info, broken\n+\n+\n+def get_all_relations():\n+    """Get all data from zc.relation catalog.\n+    Logs some useful statistics.\n+    """\n+    results = []\n+    info = defaultdict(int)\n+\n+    relation_catalog = getUtility(ICatalog)\n+    for token in relation_catalog.findRelationTokens():\n+        try:\n+            rel = relation_catalog.resolveRelationToken(token)\n+        except ObjectMissingError:\n+            logger.info(\'Token {} has no object.\'.format(token))\n+            continue\n+\n+        if rel.from_object and rel.to_object:\n+            try:\n+                results.append({\n+                    \'from_uuid\': rel.from_object.UID(),\n+                    \'to_uuid\': rel.to_object.UID(),\n+                    \'from_attribute\': rel.from_attribute,\n+                })\n+                info[rel.from_attribute] += 1\n+            except AttributeError as ex:\n+                logger.info(f\'Something went wrong while storing {rel}: \\n {ex}\')\n+        else:\n+            logger.info(f\'Dropping relation {rel.from_attribute} from {rel.from_object} to {rel.to_object}\')\n+    msg = \'\'\n+    for key, value in info.items():\n+        msg += f\'{key}: {value}\\n\'\n+    logger.info(f\'\\nFound the following relations:\\n{msg}\')\n+    return results\n+\n+\n+def store_relations(context=None):\n+    """Store all relations in a annotation on the portal.\n+    """\n+    all_relations = get_all_relations()\n+    portal = getSite()\n+    IAnnotations(portal)[RELATIONS_KEY] = all_relations\n+    logger.info(f\'Stored {len(all_relations)} relations on the portal\')\n+\n+\n+def purge_relations(context=None):\n+    """Removes all entries form zc.relation catalog.\n+    RelationValues that were set as attribute on content are still there!\n+    These are removed/overwritten when restoring the relations.\n+    """\n+    rel_catalog = getUtility(ICatalog)\n+    rel_catalog.clear()\n+    logger.info(\'Purged zc.relation catalog\')\n+\n+\n+def restore_relations(context=None, all_relations=None):\n+    """Restore relations from a annotation on the portal.\n+    """\n+\n+    portal = getSite()\n+    if all_relations is None:\n+        all_relations = IAnnotations(portal)[RELATIONS_KEY]\n+    logger.info(f\'Loaded {len(all_relations)} relations to restore\')\n+    update_linkintegrity = set()\n+    modified_items = set()\n+    modified_relation_lists = defaultdict(list)\n+\n+    # remove duplicates but keep original order\n+    unique_relations = []\n+    seen = set()\n+    seen_add = seen.add\n+    for rel in all_relations:\n+        hashable = tuple(rel.items())\n+        if hashable not in seen:\n+            unique_relations.append(rel)\n+            seen_add(hashable)\n+        else:\n+            logger.info(f\'Dropping duplicate: {hashable}\')\n+\n+    if len(unique_relations) < len(all_relations):\n+        logger.info(f\'Dropping {len(all_relations) - len(unique_relations)} duplicates\')\n+        all_relations = unique_relations\n+\n+    intids = getUtility(IIntIds)\n+    for index, item in enumerate(all_relations, start=1):\n+        if not index % 500:\n+            logger.info(f\'Restored {index} of {len(all_relations)} relations...\')\n+\n+        try:\n+            source_obj = uuidToObject(item[\'from_uuid\'])\n+        except KeyError:\n+            # brain exists but no object\n+            source_obj = None\n+        try:\n+            target_obj = uuidToObject(item[\'to_uuid\'])\n+        except KeyError:\n+            # brain exists but no object\n+            target_obj = None\n+\n+        if not source_obj:\n+            logger.info(f\'{item["from_uuid"]} is missing\')\n+            continue\n+\n+        if not target_obj:\n+            logger.info(f\'{item["to_uuid"]} is missing\')\n+            continue\n+\n+        if not IDexterityContent.providedBy(source_obj):\n+            logger.info(f\'{source_obj} is no dexterity content\')\n+            continue\n+\n+        if not IDexterityContent.providedBy(target_obj):\n+            logger.info(f\'{target_obj} is no dexterity content\')\n+            continue\n+\n+        from_attribute = item[\'from_attribute\']\n+        to_id = intids.getId(target_obj)\n+\n+        if from_attribute == referencedRelationship:\n+            # Ignore linkintegrity for now. We\'ll rebuilt it at the end!\n+            update_linkintegrity.add(item[\'from_uuid\'])\n+            continue\n+\n+        if from_attribute == ITERATE_RELATION_NAME:\n+            # Iterate relations are not set as values of fields\n+            relation = StagingRelationValue(to_id)\n+            event._setRelation(source_obj, ITERATE_RELATION_NAME, relation)\n+            continue\n+\n+        field_and_schema = get_field_and_schema_for_fieldname(from_attribute, source_obj.portal_type)\n+        if field_and_schema is None:\n+            # the from_attribute is no field\n+            logger.info(f\'No field. Setting relation: {item}\')\n+            event._setRelation(source_obj, from_attribute, RelationValue(to_id))\n+            continue\n+\n+        field, schema = field_and_schema\n+        relation = RelationValue(to_id)\n+\n+        if isinstance(field, RelationList):\n+            logger.info(f\'Add relation to relationslist {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}\')\n+            if item[\'from_uuid\'] in modified_relation_lists.get(from_attribute, []):\n+                # Do not purge relations\n+                existing_relations = getattr(source_obj, from_attribute, [])\n+            else:\n+                # First touch. Make sure we purge!\n+                existing_relations = []\n+            existing_relations.append(relation)\n+            setattr(source_obj, from_attribute, existing_relations)\n+            modified_items.add(item[\'from_uuid\'])\n+            modified_relation_lists[from_attribute].append(item[\'from_uuid\'])\n+            continue\n+\n+        elif isinstance(field, (Relation, RelationChoice)):\n+            logger.info(f\'Add relation {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}\')\n+            setattr(source_obj, from_attribute, relation)\n+            modified_items.add(item[\'from_uuid\'])\n+            continue\n+\n+        else:\n+            # we should never end up here!\n+            logger.warn(f\'Unexpected relation {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}\')\n+\n+    update_linkintegrity = set(update_linkintegrity)\n+    logger.info(f\'Updating linkintegrity for {len(update_linkintegrity)} items\')\n+    for uuid in sorted(update_linkintegrity):\n+        modifiedContent(uuidToObject(uuid), None)\n+    logger.info(f\'Updating relations for {len(modified_items)} items\')\n+    for uuid in sorted(modified_items):\n+        obj = uuidToObject(uuid)\n+        # updateRelations from z3c.relationfield does not properly update relations in behaviors\n+        # that are registered with a marker-interface.\n+        # update_behavior_relations (from plone.app.relationfield) does that but does not update\n+        # those in the main schema. Duh!\n+        updateRelations(obj, None)\n+        update_behavior_relations(obj, None)\n+\n+    # purge annotation from portal if they exist\n+    if RELATIONS_KEY in IAnnotations(portal):\n+        del IAnnotations(portal)[RELATIONS_KEY]\n+    logger.info(\'Done!\')\n+\n+\n+def get_intid(obj):\n+    """Intid from intid-catalog"""\n+    intids = queryUtility(IIntIds)\n+    if intids is None:\n+        return\n+    # check that the object has an intid, otherwise there\'s nothing to be done\n+    try:\n+        return intids.getId(obj)\n+    except KeyError:  # noqa\n+        # The object has not been added to the ZODB yet\n+        return\n+\n+\n+def get_field_and_schema_for_fieldname(field_id, portal_type):\n+    """Get field and its schema from a portal_type.\n+    """\n+    # Turn form.widgets.IDublinCore.title into title\n+    field_id = field_id.split(\'.\')[-1]\n+    for schema in iterSchemataForType(portal_type):\n+        field = schema.get(field_id, None)\n+        if field is not None:\n+            return (field, schema)\n+\n+\n+def cleanup_intids(context=None):\n+    intids = getUtility(IIntIds)\n+    all_refs = [f\'{i.object.__class__.__module__}.{i.object.__class__.__name__}\'\n+                for i in intids.refs.values()]\n+    logger.info(Counter(all_refs))\n+\n+    count = 0\n+    refs = [i for i in intids.refs.values() if isinstance(i.object, RelationValue)]\n+    for ref in refs:\n+        intids.unregister(ref)\n+        count += 1\n+    logger.info(f\'Removed all {count} RelationValues from IntId-tool\')\n+\n+    count = 0\n+    for ref in intids.refs.values():\n+        if \'broken\' in repr(ref.object):\n+            intids.unregister(ref)\n+    logger.info(f\'Removed {count} broken refs from IntId-tool\')\n+    all_refs = [\'{i.object.__class__.__module__}.{i.object.__class__.__name__}\'\n+                for i in intids.refs.values()]\n+    logger.info(Counter(all_refs))\n+\n+\n+def flush_intids():\n+    """ Flush all intids\n+    """\n+    intids = getUtility(IIntIds)\n+    intids.ids = intids.family.OI.BTree()\n+    intids.refs = intids.family.IO.BTree()\n+\n+\n+def rebuild_intids():\n+    """ Create new intids\n+    """\n+    def add_to_intids(obj, path):\n+        if IContentish.providedBy(obj):\n+            logger.info(f\'Added {obj} at {path} to intid\')\n+            addIntIdSubscriber(obj, None)\n+    portal = getSite()\n+    portal.ZopeFindAndApply(portal,\n+                            search_sub=True,\n+                            apply_func=add_to_intids)\ndiff --git a/news/3231.feature b/news/3231.feature\nnew file mode 100644\nindex 0000000000..e7254a3b72\n--- /dev/null\n+++ b/news/3231.feature\n@@ -0,0 +1,2 @@\n+Include a controlpanel to inspect and rebuild relations.\n+[pbauer]\n\\ No newline at end of file\n'

