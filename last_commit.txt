Repository: plone.app.folder


Branch: refs/heads/master
Date: 2018-10-03T16:37:14+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.app.folder/commit/35039120d3a8709c408a512623566f2d0734a050

fix testisolation problems and cleanup code

Files changed:
M src/plone/app/folder/tests/test_integration.py
M src/plone/app/folder/tests/test_migration.py
M src/plone/app/folder/tests/test_nextprevious.py
M src/plone/app/folder/tests/test_partialordering_integration.py

b'diff --git a/src/plone/app/folder/tests/test_integration.py b/src/plone/app/folder/tests/test_integration.py\nindex ee74f27..912ca22 100644\n--- a/src/plone/app/folder/tests/test_integration.py\n+++ b/src/plone/app/folder/tests/test_integration.py\n@@ -13,7 +13,7 @@ def afterSetUp(self):\n \n     def testCreateFolder(self):\n         self.folder.invokeFactory(\'Folder\', \'foo\')\n-        self.failUnless(self.folder[\'foo\'])\n+        self.assertTrue(self.folder[\'foo\'])\n         self.assertEqual(self.folder[\'foo\'].getPortalTypeName(), \'Folder\')\n         from plone.app.folder.base import BaseBTreeFolder\n-        self.failUnless(isinstance(self.folder[\'foo\'], BaseBTreeFolder))\n+        self.assertTrue(isinstance(self.folder[\'foo\'], BaseBTreeFolder))\ndiff --git a/src/plone/app/folder/tests/test_migration.py b/src/plone/app/folder/tests/test_migration.py\nindex 325808b..dee1e5b 100644\n--- a/src/plone/app/folder/tests/test_migration.py\n+++ b/src/plone/app/folder/tests/test_migration.py\n@@ -16,7 +16,9 @@\n from zope.component import getMultiAdapter\n from zope.interface import classImplements\n from zope.publisher.browser import TestRequest\n+\n import re\n+import transaction\n \n \n def reverseMigrate(folder):\n@@ -84,10 +86,10 @@ def testReverseMigrate(self):\n         create(\'Event\', folder, \'event1\')\n         reverseMigrate(folder)\n         btree = aq_base(self.portal.folder)\n-        self.failUnless(isinstance(btree, BTreeFolder))\n-        self.failUnless(\'_objects\' in btree.__dict__)\n-        self.failUnless(hasattr(btree, \'_tree\'))\n-        self.failIf(\'_tree\' in btree.__dict__)\n+        self.assertTrue(isinstance(btree, BTreeFolder))\n+        self.assertTrue(\'_objects\' in btree.__dict__)\n+        self.assertTrue(hasattr(btree, \'_tree\'))\n+        self.assertFalse(\'_tree\' in btree.__dict__)\n         self.assertEqual(btree._tree, None)\n         self.assertEqual(\n             btree._objects,\n@@ -104,33 +106,33 @@ def testNestedReverseMigrate(self):\n         create(\'Folder\', folder, \'bar\')\n         reverseMigrate(folder)\n         foo = aq_base(self.portal.foo)\n-        self.failUnless(isinstance(foo, BTreeFolder))\n-        self.failUnless(\'_objects\' in foo.__dict__)\n-        self.failUnless(hasattr(foo, \'_tree\'))\n-        self.failIf(\'_tree\' in foo.__dict__)\n+        self.assertTrue(isinstance(foo, BTreeFolder))\n+        self.assertTrue(\'_objects\' in foo.__dict__)\n+        self.assertTrue(hasattr(foo, \'_tree\'))\n+        self.assertFalse(\'_tree\' in foo.__dict__)\n         self.assertEqual(foo._tree, None)\n         self.assertEqual(\n             foo._objects,\n             (dict(id=\'bar\', meta_type=\'NonBTreeFolder\'), )\n         )\n         bar = aq_base(getattr(foo, \'bar\'))\n-        self.failUnless(isinstance(bar, BTreeFolder))\n-        self.failIf(\'_objects\' in bar.__dict__)   # no sub-objects\n+        self.assertTrue(isinstance(bar, BTreeFolder))\n+        self.assertFalse(\'_objects\' in bar.__dict__)   # no sub-objects\n         self.assertEqual(bar._objects, ())\n-        self.failUnless(hasattr(bar, \'_tree\'))\n-        self.failIf(\'_tree\' in bar.__dict__)\n+        self.assertTrue(hasattr(bar, \'_tree\'))\n+        self.assertFalse(\'_tree\' in bar.__dict__)\n         self.assertEqual(bar._tree, None)\n         self.assertEqual(bar._objects, ())\n \n     def testIsSaneBTreeFolder(self):\n         # positive case\n         _createObjectByType(\'Folder\', self.portal, \'btree\')\n-        self.failUnless(isSaneBTreeFolder(self.portal.btree))\n+        self.assertTrue(isSaneBTreeFolder(self.portal.btree))\n         # negative case\n         create(\'Folder\', self.portal, \'folder\')\n-        self.failIf(isSaneBTreeFolder(self.portal.folder))\n+        self.assertFalse(isSaneBTreeFolder(self.portal.folder))\n         reverseMigrate(self.portal.folder)\n-        self.failIf(isSaneBTreeFolder(self.portal.folder))\n+        self.assertFalse(isSaneBTreeFolder(self.portal.folder))\n \n \n class TestBTreeMigration(IntegrationTestCase):\n@@ -141,32 +143,37 @@ class TestBTreeMigration(IntegrationTestCase):\n \n     def afterSetUp(self):\n         classImplements(ATDocument, IOrderable)\n+        # have to delete previously created content manually\n+        # because of test isolation problems\n+        if \'test\' in self.portal:\n+            del self.portal[\'test\']\n+            transaction.commit()\n \n     def makeUnmigratedFolder(self, context, name, **kw):\n         """ create a folder in an unmigrated state """\n         folder = create(\'Folder\', context, name, **kw)\n         reverseMigrate(folder)\n-        self.failIf(isSaneBTreeFolder(folder))\n+        self.assertFalse(isSaneBTreeFolder(folder))\n         return context[name]\n \n     def testBTreeMigration(self):\n         # create (unmigrated) btree folder\n         folder = self.makeUnmigratedFolder(self.portal, \'test\', title=\'Foo\')\n         view = BTreeMigrationView(self.portal, self.app.REQUEST)\n-        self.failUnless(view.migrate(folder))\n+        self.assertTrue(view.migrate(folder))\n         folder = self.portal.test       # get the object again...\n-        self.failUnless(isSaneBTreeFolder(folder))\n+        self.assertTrue(isSaneBTreeFolder(folder))\n         self.assertEqual(folder.getId(), \'test\')\n         self.assertEqual(folder.Title(), \'Foo\')\n         # a second migration should be skipped\n-        self.failIf(view.migrate(folder))\n+        self.assertFalse(view.migrate(folder))\n \n     def getNumber(self, output):\n-        self.failUnless(len(output) >= 3)\n-        self.failUnless(\'migrating btree-based folders\' in output[0])\n-        self.failUnless(\'intermediate commit\' in output[-2])\n+        self.assertTrue(len(output) >= 3)\n+        self.assertTrue(\'migrating btree-based folders\' in output[0])\n+        self.assertTrue(\'intermediate commit\' in output[-2])\n         last = output[-1]\n-        self.failUnless(\'processed\' in last)\n+        self.assertTrue(\'processed\' in last)\n         matches = re.match(r\'.*processed (.*) object.*\', last).groups()\n         return int(matches[0])\n \n@@ -177,7 +184,7 @@ def testMigrationView(self):\n         num = self.getNumber(output)\n         self.assertEqual(num, 1)\n         folder = self.portal.test               # get the object again...\n-        self.failUnless(isSaneBTreeFolder(folder))\n+        self.assertTrue(isSaneBTreeFolder(folder))\n         self.assertEqual(folder.getId(), \'test\')\n         self.assertEqual(folder.Title(), \'Foo\')\n \n@@ -188,14 +195,14 @@ def testMigrationViewWithSubobjects(self):\n         create(\'Event\', folder, \'event1\')\n         reverseMigrate(folder)\n         folder = self.portal.test               # get the object again...\n-        self.failIf(isSaneBTreeFolder(folder))\n+        self.assertFalse(isSaneBTreeFolder(folder))\n         # now test its migration...\n         view, headers, output, request = getView(self.portal, \'migrate-btrees\')\n         view()      # call the view, triggering the migration\n         num = self.getNumber(output)\n         self.assertEqual(num, 1)\n         folder = self.portal.test               # get the object again...\n-        self.failUnless(isSaneBTreeFolder(folder))\n+        self.assertTrue(isSaneBTreeFolder(folder))\n         self.assertEqual(folder.getId(), \'test\')\n         self.assertEqual(folder.Title(), \'Foo\')\n         self.assertEqual(len(folder.objectValues()), 2)\n@@ -209,8 +216,8 @@ def testMigrationViewForMultipleFolders(self):\n         view()      # call the view, triggering the migration\n         num = self.getNumber(output)\n         self.assertEqual(num, 2)\n-        self.failUnless(isSaneBTreeFolder(self.portal.folder1))\n-        self.failUnless(isSaneBTreeFolder(self.portal.folder2))\n+        self.assertTrue(isSaneBTreeFolder(self.portal.folder1))\n+        self.assertTrue(isSaneBTreeFolder(self.portal.folder2))\n \n     def testMigrationViewForNestedFolders(self):\n         # nested folders have to be "unmigrated" in bottom-up...\n@@ -218,13 +225,13 @@ def testMigrationViewForNestedFolders(self):\n         create(\'Folder\', self.portal.test, \'foo\')\n         create(\'Folder\', self.portal.test, \'bar\')\n         reverseMigrate(folder)\n-        self.failIf(isSaneBTreeFolder(folder))\n+        self.assertFalse(isSaneBTreeFolder(folder))\n         # start the migration\n         view, headers, output, request = getView(self.portal, \'migrate-btrees\')\n         view()      # call the view, triggering the migration\n         num = self.getNumber(output)\n         self.assertEqual(num, 3)\n-        self.failUnless(isSaneBTreeFolder(self.portal.test))\n-        self.failUnless(isSaneBTreeFolder(self.portal.test.foo))\n-        self.failUnless(isSaneBTreeFolder(self.portal.test.bar))\n+        self.assertTrue(isSaneBTreeFolder(self.portal.test))\n+        self.assertTrue(isSaneBTreeFolder(self.portal.test.foo))\n+        self.assertTrue(isSaneBTreeFolder(self.portal.test.bar))\n \ndiff --git a/src/plone/app/folder/tests/test_nextprevious.py b/src/plone/app/folder/tests/test_nextprevious.py\nindex ec3ec10..fa8bea0 100644\n--- a/src/plone/app/folder/tests/test_nextprevious.py\n+++ b/src/plone/app/folder/tests/test_nextprevious.py\n@@ -36,33 +36,33 @@ def afterSetUp(self):\n \n     def testIfFolderImplementsPreviousNext(self):\n         self.folder.invokeFactory(\'Folder\', \'case\')\n-        self.failUnless(INextPreviousProvider(self.folder.case, None))\n+        self.assertTrue(INextPreviousProvider(self.folder.case, None))\n \n     def testNextPreviousEnablingOnCreation(self):\n         self.folder.invokeFactory(\'Folder\', \'case\')\n         # first ensure the field on the atfolder is there\n-        self.failIf(self.folder.case.getNextPreviousEnabled())\n+        self.assertFalse(self.folder.case.getNextPreviousEnabled())\n         # then check if the adapter provides the attribute\n-        self.failIf(INextPreviousProvider(self.folder.case).enabled)\n+        self.assertFalse(INextPreviousProvider(self.folder.case).enabled)\n \n     def testNextPreviousViewDisabled(self):\n         doc = self.portal.folder1.doc11\n         view = doc.restrictedTraverse(\'@@plone_nextprevious_view\')\n-        self.failIf(view is None)\n-        self.failIf(view.enabled())\n+        self.assertFalse(view is None)\n+        self.assertFalse(view.enabled())\n \n     def testNextPreviousViewEnabled(self):\n         self.portal.folder1.setNextPreviousEnabled(True)\n         doc = self.portal.folder1.doc11\n         view = doc.restrictedTraverse(\'@@plone_nextprevious_view\')\n-        self.failIf(view is None)\n-        self.failUnless(view.enabled())\n+        self.assertFalse(view is None)\n+        self.assertTrue(view.enabled())\n \n     def testAdapterOnPortal(self):\n         doc = self.portal.doc1\n         view = doc.restrictedTraverse(\'@@plone_nextprevious_view\')\n-        self.failUnless(view)\n-        self.failIf(view.enabled())\n+        self.assertTrue(view)\n+        self.assertFalse(view.enabled())\n         self.assertEqual(None, view.next())\n         self.assertEqual(None, view.previous())\n \ndiff --git a/src/plone/app/folder/tests/test_partialordering_integration.py b/src/plone/app/folder/tests/test_partialordering_integration.py\nindex c46014b..6df2c0b 100644\n--- a/src/plone/app/folder/tests/test_partialordering_integration.py\n+++ b/src/plone/app/folder/tests/test_partialordering_integration.py\n@@ -22,7 +22,7 @@ def testGetObjectPositionForNonOrderableContent(self):\n         oid = self.folder.invokeFactory(\'Event\', id=\'foo\')\n         obj = self.folder._getOb(oid)\n         # a non-orderable object should return "no position"\n-        self.failIf(IOrderable.providedBy(obj), \'orderable events?\')\n+        self.assertFalse(IOrderable.providedBy(obj), \'orderable events?\')\n         self.assertEqual(self.folder.getObjectPosition(oid), None)\n         # a non-existant object should raise an error, though\n         self.assertRaises(ValueError, self.folder.getObjectPosition, \'bar\')\n@@ -31,14 +31,14 @@ def testRemoveNonOrderableContent(self):\n         self.setRoles([\'Manager\'])\n         self.folder.invokeFactory(\'Event\', id=\'foo\')\n         self.folder.manage_delObjects(\'foo\')\n-        self.failIf(self.folder.hasObject(\'foo\'), \'foo?\')\n+        self.assertFalse(self.folder.hasObject(\'foo\'), \'foo?\')\n \n     def testCreateOrderableContent(self):\n         self.setRoles([\'Manager\'])\n         # create orderable content\n         oid = self.folder.invokeFactory(\'Document\', id=\'foo\')\n         self.assertEqual(oid, \'foo\')\n-        self.failUnless(self.folder.hasObject(\'foo\'), \'foo?\')\n+        self.assertTrue(self.folder.hasObject(\'foo\'), \'foo?\')\n         self.assertEqual(self.folder.getObjectPosition(oid), 0)\n         # and some more...\n         self.folder.invokeFactory(\'Document\', id=\'bar\')\n'

Repository: plone.app.folder


Branch: refs/heads/master
Date: 2018-10-03T16:38:07+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.app.folder/commit/10789fe8888944dac8492f468caa474d1809af25

add changenote

Files changed:
M CHANGES.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex cbf85a7..8905846 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -15,6 +15,9 @@ New features:\n \n Bug fixes:\n \n+- fix testisolation problems\n+  [petschki]\n+  \n - Switch to new TestCase using AT after PloneTestcase is now DX.\n   [pbauer]\n \n'

Repository: plone.app.folder


Branch: refs/heads/master
Date: 2018-10-03T18:43:23+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.folder/commit/d4db64be5ba65641416db91f6ced1266d01c3af7

Merge pull request #21 from plone/testisolation-fix

fix testisolation problems and cleanup code

Files changed:
M CHANGES.rst
M src/plone/app/folder/tests/test_integration.py
M src/plone/app/folder/tests/test_migration.py
M src/plone/app/folder/tests/test_nextprevious.py
M src/plone/app/folder/tests/test_partialordering_integration.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex cbf85a7..8905846 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -15,6 +15,9 @@ New features:\n \n Bug fixes:\n \n+- fix testisolation problems\n+  [petschki]\n+  \n - Switch to new TestCase using AT after PloneTestcase is now DX.\n   [pbauer]\n \ndiff --git a/src/plone/app/folder/tests/test_integration.py b/src/plone/app/folder/tests/test_integration.py\nindex ee74f27..912ca22 100644\n--- a/src/plone/app/folder/tests/test_integration.py\n+++ b/src/plone/app/folder/tests/test_integration.py\n@@ -13,7 +13,7 @@ def afterSetUp(self):\n \n     def testCreateFolder(self):\n         self.folder.invokeFactory(\'Folder\', \'foo\')\n-        self.failUnless(self.folder[\'foo\'])\n+        self.assertTrue(self.folder[\'foo\'])\n         self.assertEqual(self.folder[\'foo\'].getPortalTypeName(), \'Folder\')\n         from plone.app.folder.base import BaseBTreeFolder\n-        self.failUnless(isinstance(self.folder[\'foo\'], BaseBTreeFolder))\n+        self.assertTrue(isinstance(self.folder[\'foo\'], BaseBTreeFolder))\ndiff --git a/src/plone/app/folder/tests/test_migration.py b/src/plone/app/folder/tests/test_migration.py\nindex 325808b..dee1e5b 100644\n--- a/src/plone/app/folder/tests/test_migration.py\n+++ b/src/plone/app/folder/tests/test_migration.py\n@@ -16,7 +16,9 @@\n from zope.component import getMultiAdapter\n from zope.interface import classImplements\n from zope.publisher.browser import TestRequest\n+\n import re\n+import transaction\n \n \n def reverseMigrate(folder):\n@@ -84,10 +86,10 @@ def testReverseMigrate(self):\n         create(\'Event\', folder, \'event1\')\n         reverseMigrate(folder)\n         btree = aq_base(self.portal.folder)\n-        self.failUnless(isinstance(btree, BTreeFolder))\n-        self.failUnless(\'_objects\' in btree.__dict__)\n-        self.failUnless(hasattr(btree, \'_tree\'))\n-        self.failIf(\'_tree\' in btree.__dict__)\n+        self.assertTrue(isinstance(btree, BTreeFolder))\n+        self.assertTrue(\'_objects\' in btree.__dict__)\n+        self.assertTrue(hasattr(btree, \'_tree\'))\n+        self.assertFalse(\'_tree\' in btree.__dict__)\n         self.assertEqual(btree._tree, None)\n         self.assertEqual(\n             btree._objects,\n@@ -104,33 +106,33 @@ def testNestedReverseMigrate(self):\n         create(\'Folder\', folder, \'bar\')\n         reverseMigrate(folder)\n         foo = aq_base(self.portal.foo)\n-        self.failUnless(isinstance(foo, BTreeFolder))\n-        self.failUnless(\'_objects\' in foo.__dict__)\n-        self.failUnless(hasattr(foo, \'_tree\'))\n-        self.failIf(\'_tree\' in foo.__dict__)\n+        self.assertTrue(isinstance(foo, BTreeFolder))\n+        self.assertTrue(\'_objects\' in foo.__dict__)\n+        self.assertTrue(hasattr(foo, \'_tree\'))\n+        self.assertFalse(\'_tree\' in foo.__dict__)\n         self.assertEqual(foo._tree, None)\n         self.assertEqual(\n             foo._objects,\n             (dict(id=\'bar\', meta_type=\'NonBTreeFolder\'), )\n         )\n         bar = aq_base(getattr(foo, \'bar\'))\n-        self.failUnless(isinstance(bar, BTreeFolder))\n-        self.failIf(\'_objects\' in bar.__dict__)   # no sub-objects\n+        self.assertTrue(isinstance(bar, BTreeFolder))\n+        self.assertFalse(\'_objects\' in bar.__dict__)   # no sub-objects\n         self.assertEqual(bar._objects, ())\n-        self.failUnless(hasattr(bar, \'_tree\'))\n-        self.failIf(\'_tree\' in bar.__dict__)\n+        self.assertTrue(hasattr(bar, \'_tree\'))\n+        self.assertFalse(\'_tree\' in bar.__dict__)\n         self.assertEqual(bar._tree, None)\n         self.assertEqual(bar._objects, ())\n \n     def testIsSaneBTreeFolder(self):\n         # positive case\n         _createObjectByType(\'Folder\', self.portal, \'btree\')\n-        self.failUnless(isSaneBTreeFolder(self.portal.btree))\n+        self.assertTrue(isSaneBTreeFolder(self.portal.btree))\n         # negative case\n         create(\'Folder\', self.portal, \'folder\')\n-        self.failIf(isSaneBTreeFolder(self.portal.folder))\n+        self.assertFalse(isSaneBTreeFolder(self.portal.folder))\n         reverseMigrate(self.portal.folder)\n-        self.failIf(isSaneBTreeFolder(self.portal.folder))\n+        self.assertFalse(isSaneBTreeFolder(self.portal.folder))\n \n \n class TestBTreeMigration(IntegrationTestCase):\n@@ -141,32 +143,37 @@ class TestBTreeMigration(IntegrationTestCase):\n \n     def afterSetUp(self):\n         classImplements(ATDocument, IOrderable)\n+        # have to delete previously created content manually\n+        # because of test isolation problems\n+        if \'test\' in self.portal:\n+            del self.portal[\'test\']\n+            transaction.commit()\n \n     def makeUnmigratedFolder(self, context, name, **kw):\n         """ create a folder in an unmigrated state """\n         folder = create(\'Folder\', context, name, **kw)\n         reverseMigrate(folder)\n-        self.failIf(isSaneBTreeFolder(folder))\n+        self.assertFalse(isSaneBTreeFolder(folder))\n         return context[name]\n \n     def testBTreeMigration(self):\n         # create (unmigrated) btree folder\n         folder = self.makeUnmigratedFolder(self.portal, \'test\', title=\'Foo\')\n         view = BTreeMigrationView(self.portal, self.app.REQUEST)\n-        self.failUnless(view.migrate(folder))\n+        self.assertTrue(view.migrate(folder))\n         folder = self.portal.test       # get the object again...\n-        self.failUnless(isSaneBTreeFolder(folder))\n+        self.assertTrue(isSaneBTreeFolder(folder))\n         self.assertEqual(folder.getId(), \'test\')\n         self.assertEqual(folder.Title(), \'Foo\')\n         # a second migration should be skipped\n-        self.failIf(view.migrate(folder))\n+        self.assertFalse(view.migrate(folder))\n \n     def getNumber(self, output):\n-        self.failUnless(len(output) >= 3)\n-        self.failUnless(\'migrating btree-based folders\' in output[0])\n-        self.failUnless(\'intermediate commit\' in output[-2])\n+        self.assertTrue(len(output) >= 3)\n+        self.assertTrue(\'migrating btree-based folders\' in output[0])\n+        self.assertTrue(\'intermediate commit\' in output[-2])\n         last = output[-1]\n-        self.failUnless(\'processed\' in last)\n+        self.assertTrue(\'processed\' in last)\n         matches = re.match(r\'.*processed (.*) object.*\', last).groups()\n         return int(matches[0])\n \n@@ -177,7 +184,7 @@ def testMigrationView(self):\n         num = self.getNumber(output)\n         self.assertEqual(num, 1)\n         folder = self.portal.test               # get the object again...\n-        self.failUnless(isSaneBTreeFolder(folder))\n+        self.assertTrue(isSaneBTreeFolder(folder))\n         self.assertEqual(folder.getId(), \'test\')\n         self.assertEqual(folder.Title(), \'Foo\')\n \n@@ -188,14 +195,14 @@ def testMigrationViewWithSubobjects(self):\n         create(\'Event\', folder, \'event1\')\n         reverseMigrate(folder)\n         folder = self.portal.test               # get the object again...\n-        self.failIf(isSaneBTreeFolder(folder))\n+        self.assertFalse(isSaneBTreeFolder(folder))\n         # now test its migration...\n         view, headers, output, request = getView(self.portal, \'migrate-btrees\')\n         view()      # call the view, triggering the migration\n         num = self.getNumber(output)\n         self.assertEqual(num, 1)\n         folder = self.portal.test               # get the object again...\n-        self.failUnless(isSaneBTreeFolder(folder))\n+        self.assertTrue(isSaneBTreeFolder(folder))\n         self.assertEqual(folder.getId(), \'test\')\n         self.assertEqual(folder.Title(), \'Foo\')\n         self.assertEqual(len(folder.objectValues()), 2)\n@@ -209,8 +216,8 @@ def testMigrationViewForMultipleFolders(self):\n         view()      # call the view, triggering the migration\n         num = self.getNumber(output)\n         self.assertEqual(num, 2)\n-        self.failUnless(isSaneBTreeFolder(self.portal.folder1))\n-        self.failUnless(isSaneBTreeFolder(self.portal.folder2))\n+        self.assertTrue(isSaneBTreeFolder(self.portal.folder1))\n+        self.assertTrue(isSaneBTreeFolder(self.portal.folder2))\n \n     def testMigrationViewForNestedFolders(self):\n         # nested folders have to be "unmigrated" in bottom-up...\n@@ -218,13 +225,13 @@ def testMigrationViewForNestedFolders(self):\n         create(\'Folder\', self.portal.test, \'foo\')\n         create(\'Folder\', self.portal.test, \'bar\')\n         reverseMigrate(folder)\n-        self.failIf(isSaneBTreeFolder(folder))\n+        self.assertFalse(isSaneBTreeFolder(folder))\n         # start the migration\n         view, headers, output, request = getView(self.portal, \'migrate-btrees\')\n         view()      # call the view, triggering the migration\n         num = self.getNumber(output)\n         self.assertEqual(num, 3)\n-        self.failUnless(isSaneBTreeFolder(self.portal.test))\n-        self.failUnless(isSaneBTreeFolder(self.portal.test.foo))\n-        self.failUnless(isSaneBTreeFolder(self.portal.test.bar))\n+        self.assertTrue(isSaneBTreeFolder(self.portal.test))\n+        self.assertTrue(isSaneBTreeFolder(self.portal.test.foo))\n+        self.assertTrue(isSaneBTreeFolder(self.portal.test.bar))\n \ndiff --git a/src/plone/app/folder/tests/test_nextprevious.py b/src/plone/app/folder/tests/test_nextprevious.py\nindex ec3ec10..fa8bea0 100644\n--- a/src/plone/app/folder/tests/test_nextprevious.py\n+++ b/src/plone/app/folder/tests/test_nextprevious.py\n@@ -36,33 +36,33 @@ def afterSetUp(self):\n \n     def testIfFolderImplementsPreviousNext(self):\n         self.folder.invokeFactory(\'Folder\', \'case\')\n-        self.failUnless(INextPreviousProvider(self.folder.case, None))\n+        self.assertTrue(INextPreviousProvider(self.folder.case, None))\n \n     def testNextPreviousEnablingOnCreation(self):\n         self.folder.invokeFactory(\'Folder\', \'case\')\n         # first ensure the field on the atfolder is there\n-        self.failIf(self.folder.case.getNextPreviousEnabled())\n+        self.assertFalse(self.folder.case.getNextPreviousEnabled())\n         # then check if the adapter provides the attribute\n-        self.failIf(INextPreviousProvider(self.folder.case).enabled)\n+        self.assertFalse(INextPreviousProvider(self.folder.case).enabled)\n \n     def testNextPreviousViewDisabled(self):\n         doc = self.portal.folder1.doc11\n         view = doc.restrictedTraverse(\'@@plone_nextprevious_view\')\n-        self.failIf(view is None)\n-        self.failIf(view.enabled())\n+        self.assertFalse(view is None)\n+        self.assertFalse(view.enabled())\n \n     def testNextPreviousViewEnabled(self):\n         self.portal.folder1.setNextPreviousEnabled(True)\n         doc = self.portal.folder1.doc11\n         view = doc.restrictedTraverse(\'@@plone_nextprevious_view\')\n-        self.failIf(view is None)\n-        self.failUnless(view.enabled())\n+        self.assertFalse(view is None)\n+        self.assertTrue(view.enabled())\n \n     def testAdapterOnPortal(self):\n         doc = self.portal.doc1\n         view = doc.restrictedTraverse(\'@@plone_nextprevious_view\')\n-        self.failUnless(view)\n-        self.failIf(view.enabled())\n+        self.assertTrue(view)\n+        self.assertFalse(view.enabled())\n         self.assertEqual(None, view.next())\n         self.assertEqual(None, view.previous())\n \ndiff --git a/src/plone/app/folder/tests/test_partialordering_integration.py b/src/plone/app/folder/tests/test_partialordering_integration.py\nindex c46014b..6df2c0b 100644\n--- a/src/plone/app/folder/tests/test_partialordering_integration.py\n+++ b/src/plone/app/folder/tests/test_partialordering_integration.py\n@@ -22,7 +22,7 @@ def testGetObjectPositionForNonOrderableContent(self):\n         oid = self.folder.invokeFactory(\'Event\', id=\'foo\')\n         obj = self.folder._getOb(oid)\n         # a non-orderable object should return "no position"\n-        self.failIf(IOrderable.providedBy(obj), \'orderable events?\')\n+        self.assertFalse(IOrderable.providedBy(obj), \'orderable events?\')\n         self.assertEqual(self.folder.getObjectPosition(oid), None)\n         # a non-existant object should raise an error, though\n         self.assertRaises(ValueError, self.folder.getObjectPosition, \'bar\')\n@@ -31,14 +31,14 @@ def testRemoveNonOrderableContent(self):\n         self.setRoles([\'Manager\'])\n         self.folder.invokeFactory(\'Event\', id=\'foo\')\n         self.folder.manage_delObjects(\'foo\')\n-        self.failIf(self.folder.hasObject(\'foo\'), \'foo?\')\n+        self.assertFalse(self.folder.hasObject(\'foo\'), \'foo?\')\n \n     def testCreateOrderableContent(self):\n         self.setRoles([\'Manager\'])\n         # create orderable content\n         oid = self.folder.invokeFactory(\'Document\', id=\'foo\')\n         self.assertEqual(oid, \'foo\')\n-        self.failUnless(self.folder.hasObject(\'foo\'), \'foo?\')\n+        self.assertTrue(self.folder.hasObject(\'foo\'), \'foo?\')\n         self.assertEqual(self.folder.getObjectPosition(oid), 0)\n         # and some more...\n         self.folder.invokeFactory(\'Document\', id=\'bar\')\n'

