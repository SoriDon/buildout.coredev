Repository: plone.rfc822


Branch: refs/heads/master
Date: 2018-06-30T15:04:02+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.rfc822/commit/59d17aa55d7b9b2a1173ceea790dae4257d796b6

overhaul of the rfc822 crazyness.

Files changed:
M CHANGES.rst
M README.rst
M plone/rfc822/_utils.py
M plone/rfc822/configure.zcml
M plone/rfc822/defaultfields.py
M plone/rfc822/fields.rst
M plone/rfc822/interfaces.py
M plone/rfc822/message.rst
M plone/rfc822/supermodel.py
M plone/rfc822/tests.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex fdee7a0..6173fab 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -1,16 +1,27 @@\n Changelog\n =========\n \n-1.1.5 (unreleased)\n-------------------\n+2.0.0b1 (unreleased)\n+--------------------\n \n Breaking changes:\n \n-- *add item here*\n+- Drop support of Python 2.6\n+  [jensens]\n+\n+- Deprecate ``renderMessage(message)``,\n+  use stdlibs ``message.as_string()`` from ``email.message.Message`` class instead.\n+  [jensens]\n+\n+- Newline handling in MIME-headers are now escaped explicit.\n+  This follows RFC2822 section 3.2.2.\n+  [jensens]\n \n New features:\n \n-- *add item here*\n+- Support for Python 3.\n+  Also big code overhaul included.\n+  [jensens]\n \n Bug fixes:\n \ndiff --git a/README.rst b/README.rst\nindex a7198af..a8dbfa4 100644\n--- a/README.rst\n+++ b/README.rst\n@@ -1,68 +1,64 @@\n Introduction\n ============\n \n-This package provides primitives for turning content objects described by\n-``zope.schema`` fields into RFC (2)822 style messages, as managed by the\n-Python standard library\'s ``email`` module.\n+This package provides primitives for turning content objects described by ``zope.schema`` fields into RFC (2)822 style messages.\n+It utilizes the Python standard library\'s ``email`` module.\n \n It consists of:\n \n-* A marker interface ``IPrimaryField`` which can be used to indicate the\n-  primary field of a schema. The primary field will be used as the message\n-  body.\n-* An interface ``IFieldMarshaler`` which describes marshalers that convert\n-  to and from strings suitable for encoding into an RFC 2822 style message.\n-  These are adapters on ``(context, field)``, where ``context`` is the content\n-  object and ``field`` is the schema field instance.\n-* Default implementations of ``IFieldMarshaler`` for the standard fields in\n-  the ``zope.schema`` package.\n-* Helper methods to construct messages from one or more schemata or a list of\n-  fields, and to parse a message and update a context object accordingly.\n-\n-The helper methods are described by ``plone.rfc822.interfaces.IMessageAPI``,\n-and are importable directly from the ``plone.rfc822`` package::\n+* A marker interface ``IPrimaryField`` which can be used to indicate the primary field of a schema.\n+  The primary field will be used as the message body.\n+  If there are more than one field marked as primary, the body is turned in a MIME multipart message.\n+* An interface ``IFieldMarshaler`` which describes marshalers that convert to and from strings suitable for encoding into an RFC 2822 style message.\n+  These are multi-adapters on ``(context, field)``.\n+  ``context`` is the content object and ``field`` is the schema field instance.\n+* Default implementations of ``IFieldMarshaler`` for the standard fields in the ``zope.schema`` package.\n+* Helper methods to construct messages from one or more schemata or a list of fields, and to parse a message and update a context object accordingly.\n+\n+The helper methods are described by ``plone.rfc822.interfaces.IMessageAPI``.\n+They are importable directly from the ``plone.rfc822`` package::\n \n     def constructMessageFromSchema(context, schema, charset=\'utf-8\'):\n         """Convenience method which calls ``constructMessage()`` with all the\n         fields, in order, of the given schema interface\n         """\n-    \n+\n     def constructMessageFromSchemata(context, schemata, charset=\'utf-8\'):\n         """Convenience method which calls ``constructMessage()`` with all the\n         fields, in order, of all the given schemata (a sequence of schema\n         interfaces).\n         """\n-    \n+\n     def constructMessage(context, fields, charset=\'utf-8\'):\n         """Helper method to construct a message.\n-    \n+\n         ``context`` is a content object.\n-    \n+\n         ``fields`` is a sequence of (name, field) pairs for the fields which make\n         up the message. This can be obtained from zope.schema.getFieldsInOrder,\n         for example.\n-    \n+\n         ``charset`` is the message charset.\n-    \n+\n         The message body will be constructed from the primary field, i.e. the\n         field which is marked with ``IPrimaryField``. If no such field exists,\n         the message will have no body. If multiple fields exist, the message will\n         be a multipart message. Otherwise, it will contain a scalar string\n         payload.\n-    \n+\n         A field will be ignored if ``(context, field)`` cannot be multi-adapted\n         to ``IFieldMarshaler``, or if the ``marshal()`` method returns None.\n         """\n-    \n+\n     def renderMessage(message, mangleFromHeader=False):\n         """Render a message to a string\n         """\n-        \n+\n     def initializeObjectFromSchema(context, schema, message, defaultCharset=\'utf-8\'):\n         """Convenience method which calls ``initializeObject()`` with all the\n         fields, in order, of the given schema interface\n         """\n-    \n+\n     def initializeObjectFromSchemata(context, schemata, message, defaultCharset=\'utf-8\'):\n         """Convenience method which calls ``initializeObject()`` with all the\n         fields in order, of all the given schemata (a sequence of schema\n@@ -71,55 +67,46 @@ and are importable directly from the ``plone.rfc822`` package::\n \n     def initializeObject(context, fields, message, defaultCharset=\'utf-8\'):\n         """Initialise an object from a message.\n-    \n+\n         ``context`` is the content object to initialise.\n-    \n+\n         ``fields`` is a sequence of (name, field) pairs for the fields which make\n         up the message. This can be obtained from zope.schema.getFieldsInOrder,\n         for example.\n-    \n+\n         ``message`` is a ``Message`` object.\n-    \n+\n         ``defaultCharset`` is the default character set to use.\n-    \n+\n         If the message is a multipart message, the primary fields will be read\n         in order.\n         """\n \n The message format used adheres to the following rules:\n \n-* All non-primary fields are represented as headers. The header name is taken\n-  from the field name, and the value is an encoded string as returned by the\n-  ``marshal()`` method of the appropriate ``IFieldMarshal`` multi-adapter.\n+* All non-primary fields are represented as headers.\n+  The header name is taken from the field name.\n+  The value is an encoded string as returned by the ``marshal()`` method of the appropriate ``IFieldMarshal`` multi-adapter.\n * If no ``IFieldMarshaler`` adapter can be found, the header is ignored.\n-* Similarly, if no fields are found for a given header when parsing a message,\n-  the header is ignored.\n-* If there is a single primary field, the message has a string payload, which\n-  is the marshalled value of the primary field. In this case, the\n-  ``Content-Type`` header of the message will be obtained from the primary\n-  field\'s marshaler.\n-* If there are multiple primary fields, each is encoded into its own message,\n-  each with its own ``Content-Type`` header. The outer message will have a\n-  content type of ``multipart/mixed`` and headers for other fields.\n-* A ``ValueError`` error is raised if a message is being parsed which has\n-  more or fewer parts than there are primary fields.\n+* Similarly, if no fields are found for a given header when parsing a message, the header is ignored.\n+* If there is a single primary field, the message has a string payload, which is the marshalled value of the primary field.\n+  In this case, the ``Content-Type`` header of the message will be obtained from the primary field\'s marshaler.\n+* If there are multiple primary fields, each is encoded into its own message, each with its own ``Content-Type`` header.\n+  The outer message will have a content type of ``multipart/mixed`` and headers for other fields.\n+* A ``ValueError`` error is raised if a message is being parsed which has more or fewer parts than there are primary fields.\n * Duplicate field names are allowed, and will be encoded as duplicate headers.\n-  When parsing a message, there needs to be one field per header. That is, if\n-  a message contains two headers with the name \'foo\', the list of field name/\n-  instance pairs passed to the ``initializeObject()`` method should contain\n-  two pairs with the name \'foo\'. The first field will be used for the first\n-  header value, the second field will be used for the second header value.\n+  When parsing a message, there needs to be one field per header.\n+  That is, if a message contains two headers with the name \'foo\',\n+  the list of field name/ instance pairs passed to the ``initializeObject()`` method should contain two pairs with the name \'foo\'.\n+  The first field will be used for the first header value, the second field will be used for the second header value.\n   If a third \'foo\' header appears, it will be ignored.\n-* Since message headers are always lowercase, field names will be matched\n-  case-insensitively when parsing a message.\n+* Since message headers are always lowercase, field names will be matched case-insensitively when parsing a message.\n \n Supermodel handler\n ------------------\n \n-If ``plone.supermodel`` is installed, this package will register a namespace\n-handler for the ``marshal`` namespace, with the URI\n-``http://namespaces.plone.org/supermodel/marshal``. This can be used to mark\n-a field as the primary field::\n+If ``plone.supermodel`` is installed, this package  will register a namespace handler for the ``marshal`` namespace, with the URI ``http://namespaces.plone.org/supermodel/marshal``.\n+This can be used to mark a field as the primary field::\n \n     <model xmlns="http://namespaces.plone.org/supermodel/schema"\n            xmlns:marshal="http://namespaces.plone.org/supermodel/marshal">\n@@ -131,11 +118,32 @@ a field as the primary field::\n     </model>\n \n ``plone.supermodel`` may be installed as a dependency using the extra\n-``[supermodel]``, but this is probably only useful for running the tests. If\n-the package is not installed, the handler will not be ignored.\n+``[supermodel]``, but this is probably only useful for running the tests.\n+If the package is not installed, the handler will not be ignored.\n \n License note\n ------------\n \n-This package is released under the BSD license. Contributors, please do not\n-add dependencies on GPL code.\n+This package is released under the BSD license.\n+Contributors, please do not add dependencies on GPL code.\n+\n+Issue tracker\n+-------------\n+\n+Please report issues via the `Plone issue tracker`_.\n+\n+.. _`Plone issue tracker`: https://github.com/plone/plone.rfc822/issues\n+\n+Support\n+-------\n+\n+Dexterity use questions may be answered via `Plone\'s support channels`_.\n+\n+.. _`Plone\'s support channels`: http://plone.org/support\n+\n+Contributing\n+------------\n+\n+Sources are at the `Plone code repository hosted at Github <https://github.com/plone/plone.rfc822>`_.\n+\n+Contributors please read the document `Process for Plone core\'s development <http://docs.plone.org/develop/plone-coredev/index.html>`_\ndiff --git a/plone/rfc822/_utils.py b/plone/rfc822/_utils.py\nindex b38bef1..beded86 100644\n--- a/plone/rfc822/_utils.py\n+++ b/plone/rfc822/_utils.py\n@@ -5,159 +5,138 @@\n \n See interfaces.py for details.\n """\n-\n-from email.generator import Generator\n+from __future__ import unicode_literals\n from email.header import decode_header\n from email.header import Header\n from email.message import Message\n-from io import BytesIO\n from plone.rfc822.interfaces import IFieldMarshaler\n from plone.rfc822.interfaces import IPrimaryField\n from zope.component import queryMultiAdapter\n+from zope.deprecation import deprecate\n from zope.schema import getFieldsInOrder\n \n import logging\n import six\n \n \n-LOG = logging.getLogger(\'plone.rfc822\')\n+logger = logging.getLogger("plone.rfc822")\n \n \n-def constructMessageFromSchema(context, schema, charset=\'utf-8\'):\n+def constructMessageFromSchema(context, schema, charset="utf-8"):\n     return constructMessage(context, getFieldsInOrder(schema), charset)\n \n \n-def constructMessageFromSchemata(context, schemata, charset=\'utf-8\'):\n+def constructMessageFromSchemata(context, schemata, charset="utf-8"):\n     fields = []\n     for schema in schemata:\n         fields.extend(getFieldsInOrder(schema))\n     return constructMessage(context, fields, charset)\n \n \n-def constructMessage(context, fields, charset=\'utf-8\'):\n-    msg = Message()\n+def _add_payload_to_message(context, msg, primary, charset):\n+    """If there\'s a single primary field, we have a non-multipart message with\n+    a string payload. Otherwise, we return a multipart message\n+    """\n+    if not primary:\n+        return\n+    is_multipart = len(primary) > 1\n+    if is_multipart:\n+        msg.set_type("multipart/mixed")\n \n-    primary = []\n+    for name, field in primary:\n+        if is_multipart:\n+            payload = Message()\n+        else:\n+            payload = msg\n+        marshaler = queryMultiAdapter((context, field), IFieldMarshaler)\n+        if marshaler is None:\n+            continue\n+\n+        contentType = marshaler.getContentType()\n+        payloadCharset = marshaler.getCharset(charset)\n+\n+        if contentType is not None:\n+            payload.set_type(contentType)\n+        if payloadCharset is not None:\n+            # using set_charset() would also add transfer encoding,\n+            # which we don\'t want to do always\n+            payload.set_param("charset", payloadCharset)\n+\n+        value = marshaler.marshal(charset, primary=True)\n+\n+        if value is None:\n+            continue\n+        payload.set_payload(value)\n+        marshaler.postProcessMessage(payload)\n+        if is_multipart:\n+            msg.attach(payload)\n+\n+\n+def constructMessage(context, fields, charset="utf-8"):\n+    msg = Message()\n+    primaries = []\n \n     # First get all headers, storing primary fields for later\n     for name, field in fields:\n-\n         if IPrimaryField.providedBy(field):\n-            primary.append((name, field,))\n+            primaries.append((name, field))\n             continue\n-\n-        marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n+        marshaler = queryMultiAdapter((context, field), IFieldMarshaler)\n         if marshaler is None:\n-            LOG.debug("No marshaler found for field %s of %s" %\n-                      (name, repr(context)))\n+            logger.debug(\n+                "No marshaler found for field {0} of {1}".format(\n+                    name, repr(context)\n+                )\n+            )\n             continue\n-\n         try:\n             value = marshaler.marshal(charset, primary=False)\n         except ValueError as e:\n-            LOG.debug("Marshaling of %s for %s failed: %s" %\n-                      (name, repr(context), str(e)))\n+            logger.debug(\n+                "Marshaling of {0} for {1} failed: {2}".format(\n+                    name, repr(context), str(e)\n+                )\n+            )\n             continue\n-\n         if value is None:\n-            value = b\'\'\n-        elif not isinstance(value, six.binary_type):\n-            raise ValueError(\n-                "Marshaler for field %s did not return bytes" % name)\n-\n-        if marshaler.ascii and b\'\\n\' not in value:\n+            value = ""\n+        if not isinstance(value, six.text_type):\n+            # py3: email.message.Message headers are expecting text\n+            value = value.decode("utf-8")\n+        # if field.__name__ == \'description\':\n+        #     import pdb; pdb.set_trace()\n+        if marshaler.ascii and "\\n" not in value:\n             msg[name] = value\n         else:\n+            if "\\n" in value:\n+                # see https://tools.ietf.org/html/rfc2822#section-3.2.2\n+                value = value.replace(u"\\n", r"\\n")\n             msg[name] = Header(value, charset)\n \n     # Then deal with the primary field\n-\n-    # If there\'s a single primary field, we have a non-multipart message with\n-    # a string payload\n-\n-    if len(primary) == 1:\n-        name, field = primary[0]\n-\n-        marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n-        if marshaler is not None:\n-            contentType = marshaler.getContentType()\n-            payloadCharset = marshaler.getCharset(charset)\n-\n-            if contentType is not None:\n-                msg.set_type(contentType)\n-\n-            if payloadCharset is not None:\n-                # using set_charset() would also add transfer encoding,\n-                # which we don\'t want to do always\n-                msg.set_param(\'charset\', payloadCharset)\n-\n-            value = marshaler.marshal(charset, primary=True)\n-            if value is not None:\n-                msg.set_payload(value)\n-\n-            marshaler.postProcessMessage(msg)\n-\n-    # Otherwise, we return a multipart message\n-\n-    elif len(primary) > 1:\n-        msg.set_type(\'multipart/mixed\')\n-\n-        for name, field in primary:\n-\n-            marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n-            if marshaler is None:\n-                continue\n-\n-            payload = Message()\n-            attach = False\n-\n-            contentType = marshaler.getContentType()\n-            payloadCharset = marshaler.getCharset(charset)\n-\n-            if contentType is not None:\n-                payload.set_type(contentType)\n-                attach = True\n-            if payloadCharset is not None:\n-                # using set_charset() would also add transfer encoding,\n-                # which we don\'t want to do always\n-                payload.set_param(\'charset\', payloadCharset)\n-                attach = True\n-\n-            value = marshaler.marshal(charset, primary=True)\n-\n-            if value is not None:\n-                payload.set_payload(value)\n-                attach = True\n-\n-            if attach:\n-                marshaler.postProcessMessage(payload)\n-                msg.attach(payload)\n+    _add_payload_to_message(context, msg, primaries, charset)\n \n     return msg\n \n \n+@deprecate(\n+    "Use \'message.as_string()\' from \'email.message.Message\' class instead."\n+)\n def renderMessage(message, mangleFromHeader=False):\n-    out = BytesIO()\n-    generator = Generator(out, mangle_from_=mangleFromHeader)\n-    generator.flatten(message)\n-    return out.getvalue()\n+    # to be removed in a 3.x series\n+    return message.as_string(mangleFromHeader)\n \n \n def initializeObjectFromSchema(\n-    context,\n-    schema,\n-    message,\n-    defaultCharset=\'utf-8\'\n+    context, schema, message, defaultCharset="utf-8"\n ):\n-    initializeObject(context, getFieldsInOrder(\n-        schema), message, defaultCharset)\n+    initializeObject(\n+        context, getFieldsInOrder(schema), message, defaultCharset\n+    )\n \n \n def initializeObjectFromSchemata(\n-    context,\n-    schemata,\n-    message,\n-    defaultCharset=\'utf-8\'\n+    context, schemata, message, defaultCharset="utf-8"\n ):\n     """Convenience method which calls ``initializeObject()`` with all the\n     fields in order, of all the given schemata (a sequence of schema\n@@ -170,152 +149,128 @@ def initializeObjectFromSchemata(\n     return initializeObject(context, fields, message, defaultCharset)\n \n \n-def initializeObject(context, fields, message, defaultCharset=\'utf-8\'):\n-    contentType = message.get_content_type()\n+def initializeObject(context, fields, message, defaultCharset="utf-8"):\n+    content_type = message.get_content_type()\n \n     charset = message.get_charset()\n     if charset is None:\n-        charset = message.get_param(\'charset\')\n+        charset = message.get_param("charset")\n     if charset is not None:\n         charset = str(charset)\n     else:\n         charset = defaultCharset\n \n-    headerFields = {}\n+    header_fields = {}\n     primary = []\n-\n     for name, field in fields:\n         if IPrimaryField.providedBy(field):\n             primary.append((name, field))\n-        else:\n-            headerFields.setdefault(name.lower(), []).append(field)\n+            continue\n+        header_fields.setdefault(name.lower(), []).append(field)\n \n     # Demarshal each header\n-\n     for name, value in message.items():\n-\n         name = name.lower()\n-        fieldset = headerFields.get(name, None)\n+        fieldset = header_fields.get(name, None)\n         if fieldset is None or len(fieldset) == 0:\n-            LOG.debug("No matching field found for header %s" % name)\n+            logger.debug("No matching field found for header {0}".format(name))\n             continue\n-\n         field = fieldset.pop(0)\n-\n-        marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n+        marshaler = queryMultiAdapter((context, field), IFieldMarshaler)\n         if marshaler is None:\n-            LOG.debug("No marshaler found for field %s of %s" %\n-                      (name, repr(context)))\n+            logger.debug(\n+                "No marshaler found for field {0} of {1}".format(\n+                    name, repr(context)\n+                )\n+            )\n             continue\n-\n-        headerValue, headerCharset = decode_header(value)[0]\n-        if headerCharset is None:\n-            headerCharset = charset\n-\n-        # MIME messages always use CRLF. For headers, we\'re probably safer with\n-        # \\n\n-        headerValue = headerValue.replace(\'\\r\\n\', \'\\n\')\n-\n+        header_value, header_charset = decode_header(value)[0]\n+        if header_charset is None:\n+            header_charset = charset\n+\n+        # MIME messages always use CRLF.\n+        # For headers, we\'re probably safer with \\n\n+        #\n+        # Also, replace escaped Newlines, for details see\n+        # https://tools.ietf.org/html/rfc2822#section-3.2.2\n+        if isinstance(header_value, six.binary_type):\n+            header_value = header_value.replace(b"\\r\\n", b"\\n")\n+            header_value = header_value.replace(b"\\\\n", b"\\n")\n+        else:\n+            header_value = header_value.replace("\\r\\n", "\\n")\n+            header_value = header_value.replace(r"\\\\n", "\\n")\n         try:\n             marshaler.demarshal(\n-                headerValue,\n+                header_value,\n                 message=message,\n-                charset=headerCharset,\n-                contentType=contentType,\n-                primary=False\n+                charset=header_charset,\n+                contentType=content_type,\n+                primary=False,\n             )\n         except ValueError as e:\n             # interface allows demarshal() to raise ValueError to indicate\n             # marshalling failed\n-            LOG.debug("Demarshalling of %s for %s failed: %s" %\n-                      (name, repr(context), str(e)))\n+            logger.debug(\n+                "Demarshalling of {0} for {1} failed: {2}".format(\n+                    name, repr(context), str(e)\n+                )\n+            )\n             continue\n \n-    # Then demarshal the primary field\n-\n-    payload = message.get_payload()\n+    # Then demarshal the primary field(s)\n+    payloads = message.get_payload()\n \n     # do nothing if we don\'t have a payload\n-    if not payload:\n+    if not payloads:\n         return\n \n-    # A single string payload\n-    if isinstance(payload, str):\n+    # A single payload is a string, multiparts are lists\n+    if isinstance(payloads, str):\n         if len(primary) != 1:\n             raise ValueError(\n-                \'Got a single string payload for message, but no primary \'\n-                \'fields found for %s\' % repr(context))\n+                "Got a single string payload for message, but no primary "\n+                "fields found for %s" % repr(context)\n+            )\n+        payloads = [message]\n+\n+    if len(payloads) != len(primary):\n+        raise ValueError(\n+            "Got %d payloads for message, but %s primary fields "\n+            "found for %s" % (len(payloads), len(primary), repr(context))\n+        )\n+    for idx, payload in enumerate(payloads):\n+        name, field = primary[idx]\n+        payload_content_type = payload.get_content_type()\n+        charset = message.get_charset()\n+        if charset is not None:\n+            charset = str(charset)\n         else:\n-            name, field = primary[0]\n-\n-            marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n-            if marshaler is None:\n-                LOG.debug("No marshaler found for primary field %s of %s" %\n-                          (name, repr(context),))\n-            else:\n-                payloadValue = message.get_payload(decode=True)\n-                payloadCharset = message.get_content_charset(charset)\n-                try:\n-                    marshaler.demarshal(\n-                        payloadValue,\n-                        message=message,\n-                        charset=payloadCharset,\n-                        contentType=contentType,\n-                        primary=True\n-                    )\n-                except ValueError as e:\n-                    # interface allows demarshal() to raise ValueError to\n-                    # indicate marshalling failed\n-                    LOG.debug("Demarshalling of %s for %s failed: %s" %\n-                              (name, repr(context), str(e)))\n-\n-    # Multiple payloads\n-    elif isinstance(payload, (list, tuple,)):\n-        if len(payload) != len(primary):\n-            raise ValueError(\n-                \'Got %d payloads for message, but %s primary fields \'\n-                \'found for %s\' % (\n-                    len(payload),\n-                    len(primary),\n-                    repr(context),\n+            charset = "utf-8"\n+\n+        marshaler = queryMultiAdapter((context, field), IFieldMarshaler)\n+        if marshaler is None:\n+            logger.debug(\n+                "No marshaler found for primary field {0} of {0}".format(\n+                    name, repr(context)\n                 )\n             )\n-        else:\n-            for idx, msg in enumerate(payload):\n-                name, field = primary[idx]\n-\n-                contentType = msg.get_content_type()\n-\n-                charset = message.get_charset()\n-                if charset is not None:\n-                    charset = str(charset)\n-                else:\n-                    charset = \'utf-8\'\n-\n-                marshaler = queryMultiAdapter(\n-                    (context, field,), IFieldMarshaler)\n-                if marshaler is None:\n-                    LOG.debug(\n-                        \'No marshaler found for primary field %s of %s\' % (\n-                            name,\n-                            repr(context),\n-                        )\n-                    )\n-                    continue\n-\n-                payloadValue = msg.get_payload(decode=True)\n-                payloadCharset = msg.get_content_charset(charset)\n-                try:\n-                    marshaler.demarshal(\n-                        payloadValue,\n-                        message=msg,\n-                        charset=payloadCharset,\n-                        contentType=contentType,\n-                        primary=True\n-                    )\n-                except ValueError as e:\n-                    # interface allows demarshal() to raise ValueError to\n-                    # indicate marshalling failed\n-                    LOG.debug("Demarshalling of %s for %s failed: %s" %\n-                              (name, repr(context), str(e)))\n-                    continue\n+            continue\n+        payload_value = payload.get_payload(decode=True)\n+        payload_charset = payload.get_content_charset(charset)\n+        try:\n+            marshaler.demarshal(\n+                payload_value,\n+                message=payload,\n+                charset=payload_charset,\n+                contentType=payload_content_type,\n+                primary=True,\n+            )\n+        except ValueError as e:\n+            # interface allows demarshal() to raise ValueError to\n+            # indicate marshalling failed\n+            logger.debug(\n+                "Demarshalling of {0} for {1} failed: {2}".format(\n+                    name, repr(context), str(e)\n+                )\n+            )\n+            continue\ndiff --git a/plone/rfc822/configure.zcml b/plone/rfc822/configure.zcml\nindex 15f502c..ba44227 100644\n--- a/plone/rfc822/configure.zcml\n+++ b/plone/rfc822/configure.zcml\n@@ -3,15 +3,24 @@\n     xmlns:five="http://namespaces.zope.org/five"\n     xmlns:zcml="http://namespaces.zope.org/zcml"\n     i18n_domain="plone.rfc822">\n-    \n+\n     <!-- Standard IFromUnicode marshaler -->\n     <adapter factory=".defaultfields.UnicodeFieldMarshaler" />\n-    \n+\n     <!-- Text, TextLine, Password, SourceText may be ASCII safe -->\n     <adapter\n-        for="* zope.schema.interfaces.IText"\n+        for="* zope.schema.interfaces.INativeString"\n         factory=".defaultfields.UnicodeValueFieldMarshaler"\n         />\n+    <!-- ASCII Field marshaller -->\n+    <adapter\n+        for="* zope.schema.interfaces.IASCII"\n+        factory=".defaultfields.ASCIISafeFieldMarshaler"\n+        />\n+    <adapter\n+        for="* zope.schema.interfaces.IASCIILine"\n+        factory=".defaultfields.ASCIISafeFieldMarshaler"\n+        />\n \n     <!-- Bool and Choice omit to declare that they supports IFromUnicode in zope.schema 3.3 -->\n     <adapter\n@@ -22,7 +31,7 @@\n         for="* zope.schema.interfaces.IChoice"\n         factory=".defaultfields.UnicodeValueFieldMarshaler"\n         />\n-    \n+\n     <!-- Int, Float, and Decimal are ASCII safe -->\n     <adapter\n         for="* zope.schema.interfaces.IInt"\n@@ -36,7 +45,7 @@\n         for="* zope.schema.interfaces.IDecimal"\n         factory=".defaultfields.ASCIISafeFieldMarshaler"\n         />\n-        \n+\n     <!-- Somehow this is necessary because these are in _bootstrapfields -->\n     <adapter\n         for="* zope.schema.Text"\n@@ -54,13 +63,13 @@\n         for="* zope.schema.Int"\n         factory=".defaultfields.ASCIISafeFieldMarshaler"\n         />\n-        \n+\n     <adapter factory=".defaultfields.BytesFieldMarshaler" />\n     <adapter factory=".defaultfields.DatetimeMarshaler" />\n     <adapter factory=".defaultfields.DateMarshaler" />\n     <adapter factory=".defaultfields.TimedeltaMarshaler" />\n     <adapter factory=".defaultfields.CollectionMarshaler" />\n-    \n+\n     <!-- Configure plone.supermodel handler if available -->\n     <utility zcml:condition="installed plone.supermodel"\n         factory=".supermodel.PrimaryFieldMetadataHandler"\ndiff --git a/plone/rfc822/defaultfields.py b/plone/rfc822/defaultfields.py\nindex 7792899..690bd20 100644\n--- a/plone/rfc822/defaultfields.py\n+++ b/plone/rfc822/defaultfields.py\n@@ -31,9 +31,9 @@\n * InterfaceField - stores Interface\n * Dict - stores a dict\n """\n-\n+from __future__ import unicode_literals\n from plone.rfc822.interfaces import IFieldMarshaler\n-from zope.component import adapts\n+from zope.component import adapter\n from zope.component import queryMultiAdapter\n from zope.interface import implementer\n from zope.interface import Interface\n@@ -62,15 +62,15 @@ class BaseFieldMarshaler(object):\n     def __init__(self, context, field):\n         self.context = context\n         self.field = field.bind(context)\n-\n         self.instance = context\n         if field.interface is not None:\n             self.instance = field.interface(context, context)\n \n     def marshal(self, charset=\'utf-8\', primary=False):\n         value = self._query(_marker)\n-        return None if value is _marker else \\\n-            self.encode(value, charset, primary)\n+        return (\n+            None if value is _marker else self.encode(value, charset, primary)\n+        )\n \n     def demarshal(\n         self,\n@@ -78,12 +78,15 @@ def demarshal(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n-        fieldValue = self.field.missing_value\n+\n         if value:\n             fieldValue = self.decode(\n-                value, message, charset, contentType, primary)\n+                value, message, charset, contentType, primary\n+            )\n+        else:\n+            fieldValue = self.field.missing_value\n         self._set(fieldValue)\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -95,10 +98,11 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n-        raise ValueError("Demarshalling not implemented for %s" %\n-                         repr(self.field))\n+        raise ValueError(\n+            \'Demarshalling not implemented for %s\' % repr(self.field)\n+        )\n \n     def getContentType(self):\n         return None\n@@ -115,18 +119,21 @@ def _query(self, default=None):\n         return self.field.query(self.instance, default)\n \n     def _set(self, value):\n+        if getattr(self.instance, \'marker\', False):\n+            print(self.field.__name__)\n+            print(value)\n+            print(\'-\' * 5)\n         try:\n             self.field.set(self.instance, value)\n         except TypeError as e:\n             raise ValueError(e)\n \n \n+@adapter(Interface, IFromUnicode)\n class UnicodeFieldMarshaler(BaseFieldMarshaler):\n     """Default marshaler for fields that support IFromUnicode\n     """\n \n-    adapts(Interface, IFromUnicode)\n-\n     def encode(self, value, charset=\'utf-8\', primary=False):\n         if value is None:\n             return\n@@ -141,9 +148,12 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n-        unicodeValue = value.decode(charset)\n+        if isinstance(value, six.binary_type):\n+            unicodeValue = value.decode(charset)\n+        else:\n+            unicodeValue = value\n         try:\n             return self.field.fromUnicode(unicodeValue)\n         except Exception as e:\n@@ -160,7 +170,8 @@ class UnicodeValueFieldMarshaler(UnicodeFieldMarshaler):\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n         encoded = super(UnicodeValueFieldMarshaler, self).encode(\n-            value, charset, primary)\n+            value, charset, primary\n+        )\n         if not encoded or max(six.iterbytes(encoded)) < 128:\n             self.ascii = True\n         else:\n@@ -179,13 +190,12 @@ def getCharset(self, default=\'utf-8\'):\n         return None\n \n \n+@adapter(Interface, IBytes)\n class BytesFieldMarshaler(BaseFieldMarshaler):\n     """Default marshaler for IBytes fields and children. These store str\n     objects, so we will attempt to encode them directly.\n     """\n \n-    adapts(Interface, IBytes)\n-\n     ascii = True\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -197,17 +207,16 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         return value\n \n \n+@adapter(Interface, IDatetime)\n class DatetimeMarshaler(BaseFieldMarshaler):\n     """Marshaler for Python datetime values\n     """\n \n-    adapts(Interface, IDatetime)\n-\n     ascii = True\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -221,7 +230,7 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         unicodeValue = value.decode(charset)\n         try:\n@@ -230,6 +239,7 @@ def decode(\n             raise ValueError(e)\n \n \n+@adapter(Interface, IDate)\n class DateMarshaler(BaseFieldMarshaler):\n     """Marshaler for Python date values.\n \n@@ -238,8 +248,6 @@ class DateMarshaler(BaseFieldMarshaler):\n     information.\n     """\n \n-    adapts(Interface, IDate)\n-\n     ascii = True\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -253,7 +261,7 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         unicodeValue = value.decode(charset)\n         try:\n@@ -262,6 +270,7 @@ def decode(\n             raise ValueError(e)\n \n \n+@adapter(Interface, ITimedelta)\n class TimedeltaMarshaler(BaseFieldMarshaler):\n     """Marshaler for Python timedelta values\n \n@@ -270,8 +279,6 @@ class TimedeltaMarshaler(BaseFieldMarshaler):\n     information.\n     """\n \n-    adapts(Interface, ITimedelta)\n-\n     ascii = True\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -285,7 +292,7 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         try:\n             days, seconds, microseconds = [int(v) for v in value.split(":")]\n@@ -294,17 +301,17 @@ def decode(\n             raise ValueError(e)\n \n \n+@adapter(Interface, ICollection)\n class CollectionMarshaler(BaseFieldMarshaler):\n     """Marshaler for collection values\n     """\n \n-    adapts(Interface, ICollection)\n-\n     ascii = False\n \n     def getCharset(self, default=\'utf-8\'):\n         valueTypeMarshaler = queryMultiAdapter(\n-            (self.context, self.field.value_type,), IFieldMarshaler)\n+            (self.context, self.field.value_type), IFieldMarshaler\n+        )\n         if valueTypeMarshaler is None:\n             return None\n         return valueTypeMarshaler.getCharset(default)\n@@ -314,7 +321,8 @@ def encode(self, value, charset=\'utf-8\', primary=False):\n             return None\n \n         valueTypeMarshaler = queryMultiAdapter(\n-            (self.context, self.field.value_type,), IFieldMarshaler)\n+            (self.context, self.field.value_type), IFieldMarshaler\n+        )\n         if valueTypeMarshaler is None:\n             return None\n \n@@ -322,7 +330,8 @@ def encode(self, value, charset=\'utf-8\', primary=False):\n         value_lines = []\n         for item in value:\n             marshaledValue = valueTypeMarshaler.encode(\n-                item, charset=charset, primary=primary)\n+                item, charset=charset, primary=primary\n+            )\n             if marshaledValue is None:\n                 marshaledValue = \'\'\n             value_lines.append(marshaledValue)\n@@ -330,8 +339,10 @@ def encode(self, value, charset=\'utf-8\', primary=False):\n                 ascii = False\n \n         self.ascii = ascii\n-\n-        return \'||\'.join(value_lines)\n+        if value_lines and isinstance(value_lines[0], six.binary_type):\n+            return b\'||\'.join(value_lines)\n+        else:\n+            return \'||\'.join(value_lines)\n \n     def decode(\n         self,\n@@ -339,22 +350,30 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         valueTypeMarshaler = queryMultiAdapter(\n-            (self.context, self.field.value_type,), IFieldMarshaler)\n+            (self.context, self.field.value_type), IFieldMarshaler\n+        )\n         if valueTypeMarshaler is None:\n-            raise ValueError("Cannot demarshal value type %s" %\n-                             repr(self.field.value_type))\n+            raise ValueError(\n+                \'Cannot demarshal value type %s\' % repr(self.field.value_type)\n+            )\n \n         listValue = []\n-\n-        for line in value.split(\'||\'):\n-            listValue.append(valueTypeMarshaler.decode(\n-                line, message, charset, contentType, primary))\n+        if isinstance(value, six.binary_type):\n+            lines = value.split(b\'||\')\n+        else:\n+            lines = value.split(\'||\')\n+        for line in lines:\n+            listValue.append(\n+                valueTypeMarshaler.decode(\n+                    line, message, charset, contentType, primary\n+                )\n+            )\n \n         sequenceType = self.field._type\n-        if isinstance(sequenceType, (list, tuple,)):\n+        if isinstance(sequenceType, (list, tuple)):\n             sequenceType = sequenceType[-1]\n \n         return sequenceType(listValue)\ndiff --git a/plone/rfc822/fields.rst b/plone/rfc822/fields.rst\nindex 2bd430c..bab43d6 100644\n--- a/plone/rfc822/fields.rst\n+++ b/plone/rfc822/fields.rst\n@@ -3,7 +3,7 @@ Field marshaler tests\n \n This test exercises the various standard field marshalers.\n \n-First, we load the package\'s configuration:\n+First, we load the package\'s configuration::\n \n     >>> configuration = b"""\\\n     ... <configure\n@@ -23,7 +23,7 @@ First, we load the package\'s configuration:\n     >>> xmlconfig.xmlconfig(BytesIO(configuration))\n \n Next, we\'ll create an interface which contains an instance of every field\n-we support.\n+we support::\n \n     >>> from zope.interface import Interface\n     >>> from zope import schema\n@@ -58,7 +58,7 @@ we support.\n     ...     _set = schema.Set(value_type=schema.Bool())\n     ...     _frozenset = schema.FrozenSet(value_type=schema.Timedelta())\n \n-This interface is implemented by a the following class:\n+This interface is implemented by a the following class::\n \n     >>> from decimal import Decimal\n     >>> from zope.interface import implementer\n@@ -74,10 +74,10 @@ This interface is implemented by a the following class:\n     ...     _password2 = u"password" # ascii safe\n     ...     _bytes = \'bytes\'\n     ...     _bytesLine = \'bytesline\'\n-    ...     _ascii = \'ascii\'\n-    ...     _asciiLine = \'asciiline\'\n-    ...     _uri = \'http://plone.org\'\n-    ...     _id = \'some.id\'\n+    ...     _ascii = u\'ascii\'\n+    ...     _asciiLine = u\'asciiline\'\n+    ...     _uri = u\'http://plone.org\'\n+    ...     _id = u\'some.id\'\n     ...     _dottedName = \'dotted.name\'\n     ...     _bool = True\n     ...     _int = long(-10) if six.PY2 else -10\n@@ -96,7 +96,7 @@ This interface is implemented by a the following class:\n     >>> t = TestContent()\n \n We can now look up the marshaler for each one and test the marshalling and\n-extraction methods.\n+extraction methods::\n \n     >>> from zope.component import getMultiAdapter\n     >>> from plone.rfc822.interfaces import IFieldMarshaler\n@@ -113,11 +113,13 @@ Notes:\n Text\n ----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_text\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'text\\xc3\\x98\'\n+    \'text\\xc3\\x98\'\n     >>> marshaler.decode(b\'text\\xc3\\x98\')\n-    u\'text\\xd8\'\n+    \'text\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -126,13 +128,13 @@ Text\n     False\n \n Text field types and derivatives will return True for the ``ascii`` property\n-if the field value is within the ascii range.\n+if the field value is within the ascii range::\n \n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_text2\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'text\'\n+    \'text\'\n     >>> marshaler.decode(b\'text\\xc3\\x98\')\n-    u\'text\\xd8\'\n+    \'text\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -143,11 +145,13 @@ if the field value is within the ascii range.\n TextLine\n --------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_textLine\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'textline\\xc3\\x98\'\n+    \'textline\\xc3\\x98\'\n     >>> marshaler.decode(b\'textline\\xc3\\x98\')\n-    u\'textline\\xd8\'\n+    \'textline\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -158,11 +162,13 @@ TextLine\n Text field types and derivatives will return True for the ``ascii`` property\n if the field value is within the ascii range.\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_textLine2\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'textline\'\n+    \'textline\'\n     >>> marshaler.decode(b\'textline\\xc3\\x98\')\n-    u\'textline\\xd8\'\n+    \'textline\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -173,11 +179,13 @@ if the field value is within the ascii range.\n Password\n --------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_password\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'password\\xc3\\x98\'\n+    \'password\\xc3\\x98\'\n     >>> marshaler.decode(b\'password\\xc3\\x98\')\n-    u\'password\\xd8\'\n+    \'password\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -188,11 +196,13 @@ Password\n Text field types and derivatives will return True for the ``ascii`` property\n if the field value is within the ascii range.\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_password2\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'password\'\n+    \'password\'\n     >>> marshaler.decode(b\'password\\xc3\\x98\')\n-    u\'password\\xd8\'\n+    \'password\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -203,11 +213,13 @@ if the field value is within the ascii range.\n Bytes\n -----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_bytes\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'bytes\'\n     >>> marshaler.decode(b\'bytes\')\n-    b\'bytes\'\n+    \'bytes\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\') is None\n@@ -218,11 +230,13 @@ Bytes\n BytesLine\n ---------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_bytesLine\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'bytesline\'\n     >>> marshaler.decode(b\'bytesline\')\n-    b\'bytesline\'\n+    \'bytesline\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\') is None\n@@ -233,9 +247,14 @@ BytesLine\n ASCII\n -----\n \n+This is an ASCII field which is supposed to store text strings.\n+Note: There is a BytesField which stores b\'foo\' binary string.\n+\n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_ascii\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'ascii\'\n+    \'ascii\'\n     >>> marshaler.decode(b\'ascii\')\n     \'ascii\'\n     >>> marshaler.getContentType() is None\n@@ -248,11 +267,13 @@ ASCII\n ASCIILine\n ---------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_asciiLine\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'asciiline\'\n     >>> marshaler.decode(b\'asciiline\')\n-    b\'asciiline\'\n+    \'asciiline\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\') is None\n@@ -263,6 +284,10 @@ ASCIILine\n URI\n ---\n \n+An URI is in Python 2 based on unicode text, in Python 3 on bytes.\n+\n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_uri\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'http://plone.org\'\n@@ -270,7 +295,11 @@ URI\n     \'http://plone.org\'\n     >>> marshaler.getContentType() is None\n     True\n-    >>> marshaler.getCharset(\'utf-8\') is None\n+    >>> if six.PY2:\n+    ...     expected = None  # its IBytes based\n+    ... else:\n+    ...     expected = \'utf-8\'\n+    >>> marshaler.getCharset(\'utf-8\') == expected\n     True\n     >>> marshaler.ascii\n     True\n@@ -278,21 +307,29 @@ URI\n Id\n --\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_id\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'some.id\'\n     >>> marshaler.decode(b\'some.id\')\n     \'some.id\'\n-    >>> marshaler.getCharset(\'utf-8\') is None\n-    True\n     >>> marshaler.getContentType() is None\n     True\n+    >>> if six.PY2:\n+    ...     expected = None  # its IBytes based\n+    ... else:\n+    ...     expected = \'utf-8\'\n+    >>> marshaler.getCharset(\'utf-8\') == expected\n+    True\n     >>> marshaler.ascii\n     True\n \n DottedName\n ----------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_dottedName\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'dotted.name\'\n@@ -300,7 +337,11 @@ DottedName\n     \'dotted.name\'\n     >>> marshaler.getContentType() is None\n     True\n-    >>> marshaler.getCharset(\'utf-8\') is None\n+    >>> if six.PY2:\n+    ...     expected = None  # its IBytes based\n+    ... else:\n+    ...     expected = \'utf-8\'\n+    >>> marshaler.getCharset(\'utf-8\') == expected\n     True\n     >>> marshaler.ascii\n     True\n@@ -308,6 +349,8 @@ DottedName\n Bool\n ----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_bool\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'True\'\n@@ -329,6 +372,8 @@ Bool\n Int\n ---\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_int\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'-10\'\n@@ -344,6 +389,8 @@ Int\n Float\n -----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_float\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'0.3\'\n@@ -359,6 +406,8 @@ Float\n Decimal\n -------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_decimal\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'5.0\'\n@@ -374,11 +423,13 @@ Decimal\n Choice\n ------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_choice1\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'two\'\n     >>> marshaler.decode(b\'one\')\n-    u\'one\'\n+    \'one\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -390,7 +441,7 @@ Choice\n     >>> marshaler.marshal()\n     \'two\'\n     >>> marshaler.decode(b\'three\')\n-    u\'three\'\n+    \'three\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -401,6 +452,8 @@ Choice\n Datetime\n --------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_datetime\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'2009-01-02T15:10:05.000001+01:00\'\n@@ -416,6 +469,8 @@ Datetime\n Date\n ----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_date\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'2008-02-03\'\n@@ -431,10 +486,12 @@ Date\n Timedelta\n ---------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_timedelta\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'3:4:5\'\n-    >>> marshaler.decode(b\'3:4:5\')\n+    >>> marshaler.decode(\'3:4:5\')\n     datetime.timedelta(3, 4, 5)\n     >>> marshaler.getContentType() is None\n     True\n@@ -446,11 +503,13 @@ Timedelta\n Tuple\n -----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_tuple\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'one\\xc3\\x98||two\'\n     >>> marshaler.decode(b\'one\\xc3\\x98||two\')\n-    (u\'one\\xd8\', u\'two\')\n+    (\'one\\xd8\', \'two\')\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -461,6 +520,8 @@ Tuple\n List\n ----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_list\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'three||four\'\n@@ -468,6 +529,8 @@ List\n     [\'three\', \'four\']\n     >>> marshaler.getContentType() is None\n     True\n+\n+    ValueType of the list is ASCIILine!\n     >>> marshaler.getCharset(\'utf-8\') is None\n     True\n     >>> marshaler.ascii\n@@ -476,6 +539,8 @@ List\n Set\n ---\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_set\']), IFieldMarshaler)\n     >>> marshaler.marshal() in (b\'False||True\', b\'True||False\')\n     True\n@@ -491,10 +556,12 @@ Set\n Frozenset\n ---------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_frozenset\']), IFieldMarshaler)\n-    >>> marshaler.marshal() in (b\'3:4:5||5:4:3\', b\'5:4:3||3:4:5\')\n+    >>> marshaler.marshal() in (\'3:4:5||5:4:3\', \'5:4:3||3:4:5\')\n     True\n-    >>> marshaler.decode(b\'3:4:5||5:4:3\') == frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])\n+    >>> marshaler.decode(\'3:4:5||5:4:3\') == frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])\n     True\n     >>> marshaler.getContentType() is None\n     True\ndiff --git a/plone/rfc822/interfaces.py b/plone/rfc822/interfaces.py\nindex a2e3e02..5c0aa99 100644\n--- a/plone/rfc822/interfaces.py\n+++ b/plone/rfc822/interfaces.py\n@@ -63,6 +63,8 @@ def constructMessage(context, fields, charset=\'utf-8\'):\n \n     def renderMessage(message, mangleFromHeader=False):\n         """Render a message to a string\n+\n+        DEPRECATED. Use \'message.as_string()\' instead.\n         """\n \n     def initializeObjectFromSchema(\ndiff --git a/plone/rfc822/message.rst b/plone/rfc822/message.rst\nindex 4ab8e58..5ea994d 100644\n--- a/plone/rfc822/message.rst\n+++ b/plone/rfc822/message.rst\n@@ -1,12 +1,16 @@\n Message construction and parsing\n ================================\n \n+Use Python 3 bytes/string::\n+\n+    >>> from __future__ import unicode_literals\n+\n This package contains helper methods to construct an RFC 2822 style message\n from a list of schema fields, and to parse a message and initialise an object\n based on its headers and body payload.\n \n Before we begin, let\'s load the default field marshalers and configure\n-annotations, which we will use later in this test.\n+annotations, which we will use later in this test::\n \n     >>> configuration = u"""\\\n     ... <configure\n@@ -57,16 +61,16 @@ marshal to a message.\n     >>> from zope.interface import implementer\n     >>> @implementer(ITestContent)\n     ... class TestContent(object):\n-    ...     title = u""\n-    ...     description = u""\n-    ...     body = u""\n+    ...     title = ""\n+    ...     description = ""\n+    ...     body = ""\n     ...     emptyfield = None\n \n     >>> content = TestContent()\n-    >>> content.title = u"Test title"\n-    >>> content.description = u"""Test description\n+    >>> content.title = "Test title"\n+    >>> content.description = """T\xc3\xa4st description\n     ... with a newline"""\n-    >>> content.body = u"<p>Test body</p>"\n+    >>> content.body = "<p>Test body</p>"\n \n We could create a message form this instance and schema like this:\n \n@@ -75,10 +79,9 @@ We could create a message form this instance and schema like this:\n \n The output looks like this:\n \n-    >>> from plone.rfc822 import renderMessage\n-    >>> print(renderMessage(msg))\n+    >>> print(msg.as_string())\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     Content-Type: text/plain; charset="utf-8"\n     <BLANKLINE>\n@@ -101,9 +104,9 @@ encoding.\n If we want to use a different content type, we could set it explicitly:\n \n     >>> msg.set_type(\'text/html\')\n-    >>> print(renderMessage(msg))\n+    >>> print(msg.as_string())\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     MIME-Version: 1.0\n     Content-Type: text/html; charset="utf-8"\n@@ -131,11 +134,10 @@ the ``getContentType()``:\n \n     >>> from plone.rfc822.defaultfields import UnicodeValueFieldMarshaler\n     >>> from zope.schema.interfaces import IText\n-    >>> from zope.component import adapts\n+    >>> from zope.component import adapter\n \n-    >>> class TestBodyMarshaler(UnicodeValueFieldMarshaler):\n-    ...     adapts(ITestContent, IText)\n-    ...\n+    >>> @adapter(ITestContent, IText)\n+    ... class TestBodyMarshaler(UnicodeValueFieldMarshaler):\n     ...     def getContentType(self):\n     ...         return \'text/html\'\n \n@@ -153,9 +155,9 @@ above), or have the marshaler check the field name.\n Let\'s now try again:\n \n     >>> msg = constructMessageFromSchema(content, ITestContent)\n-    >>> print(renderMessage(msg))\n+    >>> print(msg.as_string())\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     MIME-Version: 1.0\n     Content-Type: text/html; charset="utf-8"\n@@ -193,11 +195,13 @@ message.\n     >>> initializeObjectFromSchema(newContent, ITestContent, msg)\n \n     >>> newContent.title\n-    u\'Test title\'\n-    >>> newContent.description\n-    u\'Test description\\nwith a newline\'\n+    \'Test title\'\n+    >>> print(newContent.description)\n+    Test description\n+    with a newline\n+\n     >>> newContent.body\n-    u\'<p>Test body</p>\'\n+    \'<p>Test body</p>\'\n \n We can also consume messages with a transfer encoding and a charset:\n \n@@ -220,16 +224,17 @@ We can also consume messages with a transfer encoding and a charset:\n     >>> initializeObjectFromSchema(newContent, ITestContent, msg)\n \n     >>> newContent.title\n-    u\'Test title\'\n-    >>> newContent.description\n-    u\'Test description\\nwith a newline\'\n+    \'Test title\'\n+    >>> print(newContent.description)\n+    Test description\n+    with a newline\n     >>> newContent.body\n-    u\'<p>Test body</p>\'\n+    \'<p>Test body</p>\'\n \n Note: Empty fields will result in the field\'s ``missing_value`` being used:\n \n     >>> newContent.emptyfield\n-    u\'missing\'\n+    \'missing\'\n \n Handling multiple primary fields and duplicate field names\n ----------------------------------------------------------\n@@ -251,8 +256,8 @@ The annotation storage would look like this:\n \n     >>> from persistent import Persistent\n     >>> @implementer(IPersonalDetails)\n+    ... @adapter(ITestContent)\n     ... class PersonalDetailsAnnotation(Persistent):\n-    ...     adapts(ITestContent)\n     ...\n     ...     def __init__(self):\n     ...         self.description = None\n@@ -293,14 +298,14 @@ Here are the fields it will see:\n \n Let\'s now construct a message. Since we now have two fields called\n ``description``, we will get two headers by that name. Since we have two\n-primary fields, we will get a multipart message with two attachments.\n+primary fields, we will get a multipart message with two attachments::\n \n     >>> from plone.rfc822 import constructMessageFromSchemata\n     >>> msg = constructMessageFromSchemata(content, (ITestContent, IPersonalDetails,))\n-    >>> msgString = renderMessage(msg)\n+    >>> msgString = msg.as_string()\n     >>> print(msgString)\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     description: <p>My description</p>\n     currentAge: 21\n@@ -317,7 +322,9 @@ primary fields, we will get a multipart message with two attachments.\n     Content-Type: text/html; charset="utf-8"\n     <BLANKLINE>\n     <p>My profile</p>\n-    --===============...==--...\n+    --===============...==--\n+    <BLANKLINE>\n+\n \n (Note that we\'ve used ellipses here for the doctest to work with the generated\n boundary string).\n@@ -339,23 +346,24 @@ attachments to the two primary fields:\n     >>> initializeObjectFromSchemata(newContent, [ITestContent, IPersonalDetails], msg)\n \n     >>> newContent.title\n-    u\'Test title\'\n+    \'Test title\'\n \n+    >>> newContent.marker = True\n     >>> newContent.description\n-    u\'Test description\\nwith a newline\'\n+    \'T\\xe4st description\\nwith a newline\'\n \n     >>> newContent.body\n-    u\'<p>Test body</p>\'\n+    \'<p>Test body</p>\'\n \n     >>> newPersonalDetails = IPersonalDetails(newContent)\n     >>> newPersonalDetails.description\n-    u\'<p>My description</p>\'\n+    \'<p>My description</p>\'\n \n     >>> newPersonalDetails.currentAge\n     21\n \n     >>> newPersonalDetails.personalProfile\n-    u\'<p>My profile</p>\'\n+    \'<p>My profile</p>\'\n \n Alternative ways to deal with multiple schemata\n -----------------------------------------------\n@@ -376,14 +384,14 @@ own multipart message. To do that, we would simply use the\n     >>> envelope.attach(mainMessage)\n     >>> envelope.attach(personalDetailsMessage)\n \n-    >>> envelopeString = renderMessage(envelope)\n+    >>> envelopeString = envelope.as_string()\n     >>> print(envelopeString)\n     Content-Type: multipart/mixed; boundary="===============...=="\n     MIME-Version: 1.0\n     <BLANKLINE>\n     --===============...==\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     MIME-Version: 1.0\n     Content-Type: text/html; charset="utf-8"\n@@ -516,7 +524,7 @@ what happens when we attempt to construct a message from this schema.\n \n     >>> from plone.rfc822 import constructMessageFromSchema\n     >>> message = constructMessageFromSchema(fileContent, IFileContent)\n-    >>> print(renderMessage(message))\n+    >>> print(message.as_string())\n     <BLANKLINE>\n     <BLANKLINE>\n \n@@ -528,7 +536,7 @@ field as primary:\n     >>> alsoProvides(IFileContent[\'file1\'], IPrimaryField)\n \n     >>> message = constructMessageFromSchema(fileContent, IFileContent)\n-    >>> messageBody = renderMessage(message)\n+    >>> messageBody = message.as_string()\n     >>> print(messageBody)\n     MIME-Version: 1.0\n     Content-Type: text/plain\n@@ -564,7 +572,7 @@ In this case, we should get a multipart document with two payloads.\n \n     >>> alsoProvides(IFileContent[\'file2\'], IPrimaryField)\n     >>> message = constructMessageFromSchema(fileContent, IFileContent)\n-    >>> messageBody = renderMessage(message)\n+    >>> messageBody = message.as_string()\n     >>> print(messageBody) # doctest: +ELLIPSIS\n     MIME-Version: 1.0\n     Content-Type: multipart/mixed; boundary="===============...=="\n@@ -604,3 +612,27 @@ And again, we can reconstruct the object, this time with both fields:\n     \'text/html\'\n     >>> newFileContent.file2.filename\n     \'dummy2.html\'\n+\n+Specialities between Py2 and Py3\n+--------------------------------\n+\n+Test a special behavior which is different between Python 2 and 3 stdlib:\n+Newline handling in non-utf8 strings.\n+\n+Python 2.7 ``email.header`` keeps a line with an escaped value,\n+while Python 3.6 turns it into RFC2047 encoded headers, see https://tools.ietf.org/html/rfc2047.html\n+Technical both is fine.\n+\n+::\n+\n+    >>> import six\n+    >>> content.description = "Test content\\nwith newline difference"\n+    >>> msg = constructMessageFromSchema(content, ITestContent)\n+    >>> effective_output = msg.as_string()\n+    >>> effective_output_line_2 = effective_output.split(\'\\n\')[1]\n+    >>> if six.PY2:\n+    ...     expected_output_line_2 = r"description: Test content\\nwith newline difference"\n+    ... else:\n+    ...     expected_output_line_2 = r"description: =?utf-8?q?Test_content=5Cnwith_newline_difference?="\n+    >>> effective_output_line_2 == expected_output_line_2\n+    True\ndiff --git a/plone/rfc822/supermodel.py b/plone/rfc822/supermodel.py\nindex 6d24d72..2f38005 100644\n--- a/plone/rfc822/supermodel.py\n+++ b/plone/rfc822/supermodel.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from __future__ import unicode_literals\n try:\n     from plone.supermodel.interfaces import IFieldMetadataHandler\n     HAVE_SUPERMODEL = True\ndiff --git a/plone/rfc822/tests.py b/plone/rfc822/tests.py\nindex 8d7b26d..47912ea 100644\n--- a/plone/rfc822/tests.py\n+++ b/plone/rfc822/tests.py\n@@ -23,9 +23,9 @@\n class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n         if six.PY2:\n-            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n-        else:\n-            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+            got = re.sub("u\'(.*?)\'", "\'\\\\1\'", got)\n+        if six.PY3:\n+            got = re.sub("b\'(.*?)\'", "\'\\\\1\'", got)\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \ndiff --git a/setup.py b/setup.py\nindex e9dce47..d8cc7b0 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -5,7 +5,7 @@\n import os\n \n \n-version = \'1.1.5.dev0\'\n+version = \'2.0.0b1.dev0\'\n \n setup(\n     name=\'plone.rfc822\',\n@@ -19,17 +19,15 @@\n     # https://pypi.python.org/pypi?%3Aaction=list_classifiers\n     classifiers=[\n         "Framework :: Plone",\n-        "Framework :: Plone :: 4.3",\n-        "Framework :: Plone :: 5.0",\n-        "Framework :: Plone :: 5.1",\n+        # "Framework :: Plone :: 5.2",\n         "Programming Language :: Python",\n-        "Programming Language :: Python :: 2.6",\n         "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.6",\n         "Topic :: Software Development :: Libraries :: Python Modules",\n         "License :: OSI Approved :: BSD License",\n     ],\n     keywords=\'zope schema rfc822\',\n-    author=\'Martin Aspeli\',\n+    author=\'Martin Aspeli and contributors\',\n     author_email=\'optilude@gmail.com\',\n     url=\'https://pypi.python.org/pypi/plone.rfc822\',\n     license=\'BSD\',\n@@ -39,14 +37,15 @@\n     zip_safe=False,\n     extras_require={\n         \'supermodel\': [\'plone.supermodel\'],\n-        \'test\': [\'plone.testing\'],\n+        \'test\': [\'plone.testing\', \'plone.supermodel\'],\n     },\n     install_requires=[\n+        \'python-dateutil\',\n         \'setuptools\',\n-        \'zope.schema\',\n         \'zope.component\',\n+        \'zope.deprecation\',\n         \'zope.interface\',\n-        \'python-dateutil\',\n+        \'zope.schema\',\n     ],\n     entry_points="""\n     """,\n'

Repository: plone.rfc822


Branch: refs/heads/master
Date: 2018-06-30T15:04:12+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.rfc822/commit/4fae1dc125d71ac1217b187048bb1538706f3478

overhaul of the rfc822 crazyness.

Files changed:
M CHANGES.rst
M README.rst
M plone/rfc822/_utils.py
M plone/rfc822/configure.zcml
M plone/rfc822/defaultfields.py
M plone/rfc822/fields.rst
M plone/rfc822/interfaces.py
M plone/rfc822/message.rst
M plone/rfc822/supermodel.py
M plone/rfc822/tests.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex fdee7a0..6173fab 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -1,16 +1,27 @@\n Changelog\n =========\n \n-1.1.5 (unreleased)\n-------------------\n+2.0.0b1 (unreleased)\n+--------------------\n \n Breaking changes:\n \n-- *add item here*\n+- Drop support of Python 2.6\n+  [jensens]\n+\n+- Deprecate ``renderMessage(message)``,\n+  use stdlibs ``message.as_string()`` from ``email.message.Message`` class instead.\n+  [jensens]\n+\n+- Newline handling in MIME-headers are now escaped explicit.\n+  This follows RFC2822 section 3.2.2.\n+  [jensens]\n \n New features:\n \n-- *add item here*\n+- Support for Python 3.\n+  Also big code overhaul included.\n+  [jensens]\n \n Bug fixes:\n \ndiff --git a/README.rst b/README.rst\nindex a7198af..a8dbfa4 100644\n--- a/README.rst\n+++ b/README.rst\n@@ -1,68 +1,64 @@\n Introduction\n ============\n \n-This package provides primitives for turning content objects described by\n-``zope.schema`` fields into RFC (2)822 style messages, as managed by the\n-Python standard library\'s ``email`` module.\n+This package provides primitives for turning content objects described by ``zope.schema`` fields into RFC (2)822 style messages.\n+It utilizes the Python standard library\'s ``email`` module.\n \n It consists of:\n \n-* A marker interface ``IPrimaryField`` which can be used to indicate the\n-  primary field of a schema. The primary field will be used as the message\n-  body.\n-* An interface ``IFieldMarshaler`` which describes marshalers that convert\n-  to and from strings suitable for encoding into an RFC 2822 style message.\n-  These are adapters on ``(context, field)``, where ``context`` is the content\n-  object and ``field`` is the schema field instance.\n-* Default implementations of ``IFieldMarshaler`` for the standard fields in\n-  the ``zope.schema`` package.\n-* Helper methods to construct messages from one or more schemata or a list of\n-  fields, and to parse a message and update a context object accordingly.\n-\n-The helper methods are described by ``plone.rfc822.interfaces.IMessageAPI``,\n-and are importable directly from the ``plone.rfc822`` package::\n+* A marker interface ``IPrimaryField`` which can be used to indicate the primary field of a schema.\n+  The primary field will be used as the message body.\n+  If there are more than one field marked as primary, the body is turned in a MIME multipart message.\n+* An interface ``IFieldMarshaler`` which describes marshalers that convert to and from strings suitable for encoding into an RFC 2822 style message.\n+  These are multi-adapters on ``(context, field)``.\n+  ``context`` is the content object and ``field`` is the schema field instance.\n+* Default implementations of ``IFieldMarshaler`` for the standard fields in the ``zope.schema`` package.\n+* Helper methods to construct messages from one or more schemata or a list of fields, and to parse a message and update a context object accordingly.\n+\n+The helper methods are described by ``plone.rfc822.interfaces.IMessageAPI``.\n+They are importable directly from the ``plone.rfc822`` package::\n \n     def constructMessageFromSchema(context, schema, charset=\'utf-8\'):\n         """Convenience method which calls ``constructMessage()`` with all the\n         fields, in order, of the given schema interface\n         """\n-    \n+\n     def constructMessageFromSchemata(context, schemata, charset=\'utf-8\'):\n         """Convenience method which calls ``constructMessage()`` with all the\n         fields, in order, of all the given schemata (a sequence of schema\n         interfaces).\n         """\n-    \n+\n     def constructMessage(context, fields, charset=\'utf-8\'):\n         """Helper method to construct a message.\n-    \n+\n         ``context`` is a content object.\n-    \n+\n         ``fields`` is a sequence of (name, field) pairs for the fields which make\n         up the message. This can be obtained from zope.schema.getFieldsInOrder,\n         for example.\n-    \n+\n         ``charset`` is the message charset.\n-    \n+\n         The message body will be constructed from the primary field, i.e. the\n         field which is marked with ``IPrimaryField``. If no such field exists,\n         the message will have no body. If multiple fields exist, the message will\n         be a multipart message. Otherwise, it will contain a scalar string\n         payload.\n-    \n+\n         A field will be ignored if ``(context, field)`` cannot be multi-adapted\n         to ``IFieldMarshaler``, or if the ``marshal()`` method returns None.\n         """\n-    \n+\n     def renderMessage(message, mangleFromHeader=False):\n         """Render a message to a string\n         """\n-        \n+\n     def initializeObjectFromSchema(context, schema, message, defaultCharset=\'utf-8\'):\n         """Convenience method which calls ``initializeObject()`` with all the\n         fields, in order, of the given schema interface\n         """\n-    \n+\n     def initializeObjectFromSchemata(context, schemata, message, defaultCharset=\'utf-8\'):\n         """Convenience method which calls ``initializeObject()`` with all the\n         fields in order, of all the given schemata (a sequence of schema\n@@ -71,55 +67,46 @@ and are importable directly from the ``plone.rfc822`` package::\n \n     def initializeObject(context, fields, message, defaultCharset=\'utf-8\'):\n         """Initialise an object from a message.\n-    \n+\n         ``context`` is the content object to initialise.\n-    \n+\n         ``fields`` is a sequence of (name, field) pairs for the fields which make\n         up the message. This can be obtained from zope.schema.getFieldsInOrder,\n         for example.\n-    \n+\n         ``message`` is a ``Message`` object.\n-    \n+\n         ``defaultCharset`` is the default character set to use.\n-    \n+\n         If the message is a multipart message, the primary fields will be read\n         in order.\n         """\n \n The message format used adheres to the following rules:\n \n-* All non-primary fields are represented as headers. The header name is taken\n-  from the field name, and the value is an encoded string as returned by the\n-  ``marshal()`` method of the appropriate ``IFieldMarshal`` multi-adapter.\n+* All non-primary fields are represented as headers.\n+  The header name is taken from the field name.\n+  The value is an encoded string as returned by the ``marshal()`` method of the appropriate ``IFieldMarshal`` multi-adapter.\n * If no ``IFieldMarshaler`` adapter can be found, the header is ignored.\n-* Similarly, if no fields are found for a given header when parsing a message,\n-  the header is ignored.\n-* If there is a single primary field, the message has a string payload, which\n-  is the marshalled value of the primary field. In this case, the\n-  ``Content-Type`` header of the message will be obtained from the primary\n-  field\'s marshaler.\n-* If there are multiple primary fields, each is encoded into its own message,\n-  each with its own ``Content-Type`` header. The outer message will have a\n-  content type of ``multipart/mixed`` and headers for other fields.\n-* A ``ValueError`` error is raised if a message is being parsed which has\n-  more or fewer parts than there are primary fields.\n+* Similarly, if no fields are found for a given header when parsing a message, the header is ignored.\n+* If there is a single primary field, the message has a string payload, which is the marshalled value of the primary field.\n+  In this case, the ``Content-Type`` header of the message will be obtained from the primary field\'s marshaler.\n+* If there are multiple primary fields, each is encoded into its own message, each with its own ``Content-Type`` header.\n+  The outer message will have a content type of ``multipart/mixed`` and headers for other fields.\n+* A ``ValueError`` error is raised if a message is being parsed which has more or fewer parts than there are primary fields.\n * Duplicate field names are allowed, and will be encoded as duplicate headers.\n-  When parsing a message, there needs to be one field per header. That is, if\n-  a message contains two headers with the name \'foo\', the list of field name/\n-  instance pairs passed to the ``initializeObject()`` method should contain\n-  two pairs with the name \'foo\'. The first field will be used for the first\n-  header value, the second field will be used for the second header value.\n+  When parsing a message, there needs to be one field per header.\n+  That is, if a message contains two headers with the name \'foo\',\n+  the list of field name/ instance pairs passed to the ``initializeObject()`` method should contain two pairs with the name \'foo\'.\n+  The first field will be used for the first header value, the second field will be used for the second header value.\n   If a third \'foo\' header appears, it will be ignored.\n-* Since message headers are always lowercase, field names will be matched\n-  case-insensitively when parsing a message.\n+* Since message headers are always lowercase, field names will be matched case-insensitively when parsing a message.\n \n Supermodel handler\n ------------------\n \n-If ``plone.supermodel`` is installed, this package will register a namespace\n-handler for the ``marshal`` namespace, with the URI\n-``http://namespaces.plone.org/supermodel/marshal``. This can be used to mark\n-a field as the primary field::\n+If ``plone.supermodel`` is installed, this package  will register a namespace handler for the ``marshal`` namespace, with the URI ``http://namespaces.plone.org/supermodel/marshal``.\n+This can be used to mark a field as the primary field::\n \n     <model xmlns="http://namespaces.plone.org/supermodel/schema"\n            xmlns:marshal="http://namespaces.plone.org/supermodel/marshal">\n@@ -131,11 +118,32 @@ a field as the primary field::\n     </model>\n \n ``plone.supermodel`` may be installed as a dependency using the extra\n-``[supermodel]``, but this is probably only useful for running the tests. If\n-the package is not installed, the handler will not be ignored.\n+``[supermodel]``, but this is probably only useful for running the tests.\n+If the package is not installed, the handler will not be ignored.\n \n License note\n ------------\n \n-This package is released under the BSD license. Contributors, please do not\n-add dependencies on GPL code.\n+This package is released under the BSD license.\n+Contributors, please do not add dependencies on GPL code.\n+\n+Issue tracker\n+-------------\n+\n+Please report issues via the `Plone issue tracker`_.\n+\n+.. _`Plone issue tracker`: https://github.com/plone/plone.rfc822/issues\n+\n+Support\n+-------\n+\n+Dexterity use questions may be answered via `Plone\'s support channels`_.\n+\n+.. _`Plone\'s support channels`: http://plone.org/support\n+\n+Contributing\n+------------\n+\n+Sources are at the `Plone code repository hosted at Github <https://github.com/plone/plone.rfc822>`_.\n+\n+Contributors please read the document `Process for Plone core\'s development <http://docs.plone.org/develop/plone-coredev/index.html>`_\ndiff --git a/plone/rfc822/_utils.py b/plone/rfc822/_utils.py\nindex b38bef1..beded86 100644\n--- a/plone/rfc822/_utils.py\n+++ b/plone/rfc822/_utils.py\n@@ -5,159 +5,138 @@\n \n See interfaces.py for details.\n """\n-\n-from email.generator import Generator\n+from __future__ import unicode_literals\n from email.header import decode_header\n from email.header import Header\n from email.message import Message\n-from io import BytesIO\n from plone.rfc822.interfaces import IFieldMarshaler\n from plone.rfc822.interfaces import IPrimaryField\n from zope.component import queryMultiAdapter\n+from zope.deprecation import deprecate\n from zope.schema import getFieldsInOrder\n \n import logging\n import six\n \n \n-LOG = logging.getLogger(\'plone.rfc822\')\n+logger = logging.getLogger("plone.rfc822")\n \n \n-def constructMessageFromSchema(context, schema, charset=\'utf-8\'):\n+def constructMessageFromSchema(context, schema, charset="utf-8"):\n     return constructMessage(context, getFieldsInOrder(schema), charset)\n \n \n-def constructMessageFromSchemata(context, schemata, charset=\'utf-8\'):\n+def constructMessageFromSchemata(context, schemata, charset="utf-8"):\n     fields = []\n     for schema in schemata:\n         fields.extend(getFieldsInOrder(schema))\n     return constructMessage(context, fields, charset)\n \n \n-def constructMessage(context, fields, charset=\'utf-8\'):\n-    msg = Message()\n+def _add_payload_to_message(context, msg, primary, charset):\n+    """If there\'s a single primary field, we have a non-multipart message with\n+    a string payload. Otherwise, we return a multipart message\n+    """\n+    if not primary:\n+        return\n+    is_multipart = len(primary) > 1\n+    if is_multipart:\n+        msg.set_type("multipart/mixed")\n \n-    primary = []\n+    for name, field in primary:\n+        if is_multipart:\n+            payload = Message()\n+        else:\n+            payload = msg\n+        marshaler = queryMultiAdapter((context, field), IFieldMarshaler)\n+        if marshaler is None:\n+            continue\n+\n+        contentType = marshaler.getContentType()\n+        payloadCharset = marshaler.getCharset(charset)\n+\n+        if contentType is not None:\n+            payload.set_type(contentType)\n+        if payloadCharset is not None:\n+            # using set_charset() would also add transfer encoding,\n+            # which we don\'t want to do always\n+            payload.set_param("charset", payloadCharset)\n+\n+        value = marshaler.marshal(charset, primary=True)\n+\n+        if value is None:\n+            continue\n+        payload.set_payload(value)\n+        marshaler.postProcessMessage(payload)\n+        if is_multipart:\n+            msg.attach(payload)\n+\n+\n+def constructMessage(context, fields, charset="utf-8"):\n+    msg = Message()\n+    primaries = []\n \n     # First get all headers, storing primary fields for later\n     for name, field in fields:\n-\n         if IPrimaryField.providedBy(field):\n-            primary.append((name, field,))\n+            primaries.append((name, field))\n             continue\n-\n-        marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n+        marshaler = queryMultiAdapter((context, field), IFieldMarshaler)\n         if marshaler is None:\n-            LOG.debug("No marshaler found for field %s of %s" %\n-                      (name, repr(context)))\n+            logger.debug(\n+                "No marshaler found for field {0} of {1}".format(\n+                    name, repr(context)\n+                )\n+            )\n             continue\n-\n         try:\n             value = marshaler.marshal(charset, primary=False)\n         except ValueError as e:\n-            LOG.debug("Marshaling of %s for %s failed: %s" %\n-                      (name, repr(context), str(e)))\n+            logger.debug(\n+                "Marshaling of {0} for {1} failed: {2}".format(\n+                    name, repr(context), str(e)\n+                )\n+            )\n             continue\n-\n         if value is None:\n-            value = b\'\'\n-        elif not isinstance(value, six.binary_type):\n-            raise ValueError(\n-                "Marshaler for field %s did not return bytes" % name)\n-\n-        if marshaler.ascii and b\'\\n\' not in value:\n+            value = ""\n+        if not isinstance(value, six.text_type):\n+            # py3: email.message.Message headers are expecting text\n+            value = value.decode("utf-8")\n+        # if field.__name__ == \'description\':\n+        #     import pdb; pdb.set_trace()\n+        if marshaler.ascii and "\\n" not in value:\n             msg[name] = value\n         else:\n+            if "\\n" in value:\n+                # see https://tools.ietf.org/html/rfc2822#section-3.2.2\n+                value = value.replace(u"\\n", r"\\n")\n             msg[name] = Header(value, charset)\n \n     # Then deal with the primary field\n-\n-    # If there\'s a single primary field, we have a non-multipart message with\n-    # a string payload\n-\n-    if len(primary) == 1:\n-        name, field = primary[0]\n-\n-        marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n-        if marshaler is not None:\n-            contentType = marshaler.getContentType()\n-            payloadCharset = marshaler.getCharset(charset)\n-\n-            if contentType is not None:\n-                msg.set_type(contentType)\n-\n-            if payloadCharset is not None:\n-                # using set_charset() would also add transfer encoding,\n-                # which we don\'t want to do always\n-                msg.set_param(\'charset\', payloadCharset)\n-\n-            value = marshaler.marshal(charset, primary=True)\n-            if value is not None:\n-                msg.set_payload(value)\n-\n-            marshaler.postProcessMessage(msg)\n-\n-    # Otherwise, we return a multipart message\n-\n-    elif len(primary) > 1:\n-        msg.set_type(\'multipart/mixed\')\n-\n-        for name, field in primary:\n-\n-            marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n-            if marshaler is None:\n-                continue\n-\n-            payload = Message()\n-            attach = False\n-\n-            contentType = marshaler.getContentType()\n-            payloadCharset = marshaler.getCharset(charset)\n-\n-            if contentType is not None:\n-                payload.set_type(contentType)\n-                attach = True\n-            if payloadCharset is not None:\n-                # using set_charset() would also add transfer encoding,\n-                # which we don\'t want to do always\n-                payload.set_param(\'charset\', payloadCharset)\n-                attach = True\n-\n-            value = marshaler.marshal(charset, primary=True)\n-\n-            if value is not None:\n-                payload.set_payload(value)\n-                attach = True\n-\n-            if attach:\n-                marshaler.postProcessMessage(payload)\n-                msg.attach(payload)\n+    _add_payload_to_message(context, msg, primaries, charset)\n \n     return msg\n \n \n+@deprecate(\n+    "Use \'message.as_string()\' from \'email.message.Message\' class instead."\n+)\n def renderMessage(message, mangleFromHeader=False):\n-    out = BytesIO()\n-    generator = Generator(out, mangle_from_=mangleFromHeader)\n-    generator.flatten(message)\n-    return out.getvalue()\n+    # to be removed in a 3.x series\n+    return message.as_string(mangleFromHeader)\n \n \n def initializeObjectFromSchema(\n-    context,\n-    schema,\n-    message,\n-    defaultCharset=\'utf-8\'\n+    context, schema, message, defaultCharset="utf-8"\n ):\n-    initializeObject(context, getFieldsInOrder(\n-        schema), message, defaultCharset)\n+    initializeObject(\n+        context, getFieldsInOrder(schema), message, defaultCharset\n+    )\n \n \n def initializeObjectFromSchemata(\n-    context,\n-    schemata,\n-    message,\n-    defaultCharset=\'utf-8\'\n+    context, schemata, message, defaultCharset="utf-8"\n ):\n     """Convenience method which calls ``initializeObject()`` with all the\n     fields in order, of all the given schemata (a sequence of schema\n@@ -170,152 +149,128 @@ def initializeObjectFromSchemata(\n     return initializeObject(context, fields, message, defaultCharset)\n \n \n-def initializeObject(context, fields, message, defaultCharset=\'utf-8\'):\n-    contentType = message.get_content_type()\n+def initializeObject(context, fields, message, defaultCharset="utf-8"):\n+    content_type = message.get_content_type()\n \n     charset = message.get_charset()\n     if charset is None:\n-        charset = message.get_param(\'charset\')\n+        charset = message.get_param("charset")\n     if charset is not None:\n         charset = str(charset)\n     else:\n         charset = defaultCharset\n \n-    headerFields = {}\n+    header_fields = {}\n     primary = []\n-\n     for name, field in fields:\n         if IPrimaryField.providedBy(field):\n             primary.append((name, field))\n-        else:\n-            headerFields.setdefault(name.lower(), []).append(field)\n+            continue\n+        header_fields.setdefault(name.lower(), []).append(field)\n \n     # Demarshal each header\n-\n     for name, value in message.items():\n-\n         name = name.lower()\n-        fieldset = headerFields.get(name, None)\n+        fieldset = header_fields.get(name, None)\n         if fieldset is None or len(fieldset) == 0:\n-            LOG.debug("No matching field found for header %s" % name)\n+            logger.debug("No matching field found for header {0}".format(name))\n             continue\n-\n         field = fieldset.pop(0)\n-\n-        marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n+        marshaler = queryMultiAdapter((context, field), IFieldMarshaler)\n         if marshaler is None:\n-            LOG.debug("No marshaler found for field %s of %s" %\n-                      (name, repr(context)))\n+            logger.debug(\n+                "No marshaler found for field {0} of {1}".format(\n+                    name, repr(context)\n+                )\n+            )\n             continue\n-\n-        headerValue, headerCharset = decode_header(value)[0]\n-        if headerCharset is None:\n-            headerCharset = charset\n-\n-        # MIME messages always use CRLF. For headers, we\'re probably safer with\n-        # \\n\n-        headerValue = headerValue.replace(\'\\r\\n\', \'\\n\')\n-\n+        header_value, header_charset = decode_header(value)[0]\n+        if header_charset is None:\n+            header_charset = charset\n+\n+        # MIME messages always use CRLF.\n+        # For headers, we\'re probably safer with \\n\n+        #\n+        # Also, replace escaped Newlines, for details see\n+        # https://tools.ietf.org/html/rfc2822#section-3.2.2\n+        if isinstance(header_value, six.binary_type):\n+            header_value = header_value.replace(b"\\r\\n", b"\\n")\n+            header_value = header_value.replace(b"\\\\n", b"\\n")\n+        else:\n+            header_value = header_value.replace("\\r\\n", "\\n")\n+            header_value = header_value.replace(r"\\\\n", "\\n")\n         try:\n             marshaler.demarshal(\n-                headerValue,\n+                header_value,\n                 message=message,\n-                charset=headerCharset,\n-                contentType=contentType,\n-                primary=False\n+                charset=header_charset,\n+                contentType=content_type,\n+                primary=False,\n             )\n         except ValueError as e:\n             # interface allows demarshal() to raise ValueError to indicate\n             # marshalling failed\n-            LOG.debug("Demarshalling of %s for %s failed: %s" %\n-                      (name, repr(context), str(e)))\n+            logger.debug(\n+                "Demarshalling of {0} for {1} failed: {2}".format(\n+                    name, repr(context), str(e)\n+                )\n+            )\n             continue\n \n-    # Then demarshal the primary field\n-\n-    payload = message.get_payload()\n+    # Then demarshal the primary field(s)\n+    payloads = message.get_payload()\n \n     # do nothing if we don\'t have a payload\n-    if not payload:\n+    if not payloads:\n         return\n \n-    # A single string payload\n-    if isinstance(payload, str):\n+    # A single payload is a string, multiparts are lists\n+    if isinstance(payloads, str):\n         if len(primary) != 1:\n             raise ValueError(\n-                \'Got a single string payload for message, but no primary \'\n-                \'fields found for %s\' % repr(context))\n+                "Got a single string payload for message, but no primary "\n+                "fields found for %s" % repr(context)\n+            )\n+        payloads = [message]\n+\n+    if len(payloads) != len(primary):\n+        raise ValueError(\n+            "Got %d payloads for message, but %s primary fields "\n+            "found for %s" % (len(payloads), len(primary), repr(context))\n+        )\n+    for idx, payload in enumerate(payloads):\n+        name, field = primary[idx]\n+        payload_content_type = payload.get_content_type()\n+        charset = message.get_charset()\n+        if charset is not None:\n+            charset = str(charset)\n         else:\n-            name, field = primary[0]\n-\n-            marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n-            if marshaler is None:\n-                LOG.debug("No marshaler found for primary field %s of %s" %\n-                          (name, repr(context),))\n-            else:\n-                payloadValue = message.get_payload(decode=True)\n-                payloadCharset = message.get_content_charset(charset)\n-                try:\n-                    marshaler.demarshal(\n-                        payloadValue,\n-                        message=message,\n-                        charset=payloadCharset,\n-                        contentType=contentType,\n-                        primary=True\n-                    )\n-                except ValueError as e:\n-                    # interface allows demarshal() to raise ValueError to\n-                    # indicate marshalling failed\n-                    LOG.debug("Demarshalling of %s for %s failed: %s" %\n-                              (name, repr(context), str(e)))\n-\n-    # Multiple payloads\n-    elif isinstance(payload, (list, tuple,)):\n-        if len(payload) != len(primary):\n-            raise ValueError(\n-                \'Got %d payloads for message, but %s primary fields \'\n-                \'found for %s\' % (\n-                    len(payload),\n-                    len(primary),\n-                    repr(context),\n+            charset = "utf-8"\n+\n+        marshaler = queryMultiAdapter((context, field), IFieldMarshaler)\n+        if marshaler is None:\n+            logger.debug(\n+                "No marshaler found for primary field {0} of {0}".format(\n+                    name, repr(context)\n                 )\n             )\n-        else:\n-            for idx, msg in enumerate(payload):\n-                name, field = primary[idx]\n-\n-                contentType = msg.get_content_type()\n-\n-                charset = message.get_charset()\n-                if charset is not None:\n-                    charset = str(charset)\n-                else:\n-                    charset = \'utf-8\'\n-\n-                marshaler = queryMultiAdapter(\n-                    (context, field,), IFieldMarshaler)\n-                if marshaler is None:\n-                    LOG.debug(\n-                        \'No marshaler found for primary field %s of %s\' % (\n-                            name,\n-                            repr(context),\n-                        )\n-                    )\n-                    continue\n-\n-                payloadValue = msg.get_payload(decode=True)\n-                payloadCharset = msg.get_content_charset(charset)\n-                try:\n-                    marshaler.demarshal(\n-                        payloadValue,\n-                        message=msg,\n-                        charset=payloadCharset,\n-                        contentType=contentType,\n-                        primary=True\n-                    )\n-                except ValueError as e:\n-                    # interface allows demarshal() to raise ValueError to\n-                    # indicate marshalling failed\n-                    LOG.debug("Demarshalling of %s for %s failed: %s" %\n-                              (name, repr(context), str(e)))\n-                    continue\n+            continue\n+        payload_value = payload.get_payload(decode=True)\n+        payload_charset = payload.get_content_charset(charset)\n+        try:\n+            marshaler.demarshal(\n+                payload_value,\n+                message=payload,\n+                charset=payload_charset,\n+                contentType=payload_content_type,\n+                primary=True,\n+            )\n+        except ValueError as e:\n+            # interface allows demarshal() to raise ValueError to\n+            # indicate marshalling failed\n+            logger.debug(\n+                "Demarshalling of {0} for {1} failed: {2}".format(\n+                    name, repr(context), str(e)\n+                )\n+            )\n+            continue\ndiff --git a/plone/rfc822/configure.zcml b/plone/rfc822/configure.zcml\nindex 15f502c..ba44227 100644\n--- a/plone/rfc822/configure.zcml\n+++ b/plone/rfc822/configure.zcml\n@@ -3,15 +3,24 @@\n     xmlns:five="http://namespaces.zope.org/five"\n     xmlns:zcml="http://namespaces.zope.org/zcml"\n     i18n_domain="plone.rfc822">\n-    \n+\n     <!-- Standard IFromUnicode marshaler -->\n     <adapter factory=".defaultfields.UnicodeFieldMarshaler" />\n-    \n+\n     <!-- Text, TextLine, Password, SourceText may be ASCII safe -->\n     <adapter\n-        for="* zope.schema.interfaces.IText"\n+        for="* zope.schema.interfaces.INativeString"\n         factory=".defaultfields.UnicodeValueFieldMarshaler"\n         />\n+    <!-- ASCII Field marshaller -->\n+    <adapter\n+        for="* zope.schema.interfaces.IASCII"\n+        factory=".defaultfields.ASCIISafeFieldMarshaler"\n+        />\n+    <adapter\n+        for="* zope.schema.interfaces.IASCIILine"\n+        factory=".defaultfields.ASCIISafeFieldMarshaler"\n+        />\n \n     <!-- Bool and Choice omit to declare that they supports IFromUnicode in zope.schema 3.3 -->\n     <adapter\n@@ -22,7 +31,7 @@\n         for="* zope.schema.interfaces.IChoice"\n         factory=".defaultfields.UnicodeValueFieldMarshaler"\n         />\n-    \n+\n     <!-- Int, Float, and Decimal are ASCII safe -->\n     <adapter\n         for="* zope.schema.interfaces.IInt"\n@@ -36,7 +45,7 @@\n         for="* zope.schema.interfaces.IDecimal"\n         factory=".defaultfields.ASCIISafeFieldMarshaler"\n         />\n-        \n+\n     <!-- Somehow this is necessary because these are in _bootstrapfields -->\n     <adapter\n         for="* zope.schema.Text"\n@@ -54,13 +63,13 @@\n         for="* zope.schema.Int"\n         factory=".defaultfields.ASCIISafeFieldMarshaler"\n         />\n-        \n+\n     <adapter factory=".defaultfields.BytesFieldMarshaler" />\n     <adapter factory=".defaultfields.DatetimeMarshaler" />\n     <adapter factory=".defaultfields.DateMarshaler" />\n     <adapter factory=".defaultfields.TimedeltaMarshaler" />\n     <adapter factory=".defaultfields.CollectionMarshaler" />\n-    \n+\n     <!-- Configure plone.supermodel handler if available -->\n     <utility zcml:condition="installed plone.supermodel"\n         factory=".supermodel.PrimaryFieldMetadataHandler"\ndiff --git a/plone/rfc822/defaultfields.py b/plone/rfc822/defaultfields.py\nindex 7792899..25ec328 100644\n--- a/plone/rfc822/defaultfields.py\n+++ b/plone/rfc822/defaultfields.py\n@@ -31,9 +31,9 @@\n * InterfaceField - stores Interface\n * Dict - stores a dict\n """\n-\n+from __future__ import unicode_literals\n from plone.rfc822.interfaces import IFieldMarshaler\n-from zope.component import adapts\n+from zope.component import adapter\n from zope.component import queryMultiAdapter\n from zope.interface import implementer\n from zope.interface import Interface\n@@ -62,15 +62,15 @@ class BaseFieldMarshaler(object):\n     def __init__(self, context, field):\n         self.context = context\n         self.field = field.bind(context)\n-\n         self.instance = context\n         if field.interface is not None:\n             self.instance = field.interface(context, context)\n \n     def marshal(self, charset=\'utf-8\', primary=False):\n         value = self._query(_marker)\n-        return None if value is _marker else \\\n-            self.encode(value, charset, primary)\n+        return (\n+            None if value is _marker else self.encode(value, charset, primary)\n+        )\n \n     def demarshal(\n         self,\n@@ -78,12 +78,15 @@ def demarshal(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n-        fieldValue = self.field.missing_value\n+\n         if value:\n             fieldValue = self.decode(\n-                value, message, charset, contentType, primary)\n+                value, message, charset, contentType, primary\n+            )\n+        else:\n+            fieldValue = self.field.missing_value\n         self._set(fieldValue)\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -95,10 +98,11 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n-        raise ValueError("Demarshalling not implemented for %s" %\n-                         repr(self.field))\n+        raise ValueError(\n+            \'Demarshalling not implemented for %s\' % repr(self.field)\n+        )\n \n     def getContentType(self):\n         return None\n@@ -121,12 +125,11 @@ def _set(self, value):\n             raise ValueError(e)\n \n \n+@adapter(Interface, IFromUnicode)\n class UnicodeFieldMarshaler(BaseFieldMarshaler):\n     """Default marshaler for fields that support IFromUnicode\n     """\n \n-    adapts(Interface, IFromUnicode)\n-\n     def encode(self, value, charset=\'utf-8\', primary=False):\n         if value is None:\n             return\n@@ -141,9 +144,12 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n-        unicodeValue = value.decode(charset)\n+        if isinstance(value, six.binary_type):\n+            unicodeValue = value.decode(charset)\n+        else:\n+            unicodeValue = value\n         try:\n             return self.field.fromUnicode(unicodeValue)\n         except Exception as e:\n@@ -160,7 +166,8 @@ class UnicodeValueFieldMarshaler(UnicodeFieldMarshaler):\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n         encoded = super(UnicodeValueFieldMarshaler, self).encode(\n-            value, charset, primary)\n+            value, charset, primary\n+        )\n         if not encoded or max(six.iterbytes(encoded)) < 128:\n             self.ascii = True\n         else:\n@@ -179,13 +186,12 @@ def getCharset(self, default=\'utf-8\'):\n         return None\n \n \n+@adapter(Interface, IBytes)\n class BytesFieldMarshaler(BaseFieldMarshaler):\n     """Default marshaler for IBytes fields and children. These store str\n     objects, so we will attempt to encode them directly.\n     """\n \n-    adapts(Interface, IBytes)\n-\n     ascii = True\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -197,17 +203,16 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         return value\n \n \n+@adapter(Interface, IDatetime)\n class DatetimeMarshaler(BaseFieldMarshaler):\n     """Marshaler for Python datetime values\n     """\n \n-    adapts(Interface, IDatetime)\n-\n     ascii = True\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -221,7 +226,7 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         unicodeValue = value.decode(charset)\n         try:\n@@ -230,6 +235,7 @@ def decode(\n             raise ValueError(e)\n \n \n+@adapter(Interface, IDate)\n class DateMarshaler(BaseFieldMarshaler):\n     """Marshaler for Python date values.\n \n@@ -238,8 +244,6 @@ class DateMarshaler(BaseFieldMarshaler):\n     information.\n     """\n \n-    adapts(Interface, IDate)\n-\n     ascii = True\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -253,7 +257,7 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         unicodeValue = value.decode(charset)\n         try:\n@@ -262,6 +266,7 @@ def decode(\n             raise ValueError(e)\n \n \n+@adapter(Interface, ITimedelta)\n class TimedeltaMarshaler(BaseFieldMarshaler):\n     """Marshaler for Python timedelta values\n \n@@ -270,8 +275,6 @@ class TimedeltaMarshaler(BaseFieldMarshaler):\n     information.\n     """\n \n-    adapts(Interface, ITimedelta)\n-\n     ascii = True\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -285,7 +288,7 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         try:\n             days, seconds, microseconds = [int(v) for v in value.split(":")]\n@@ -294,17 +297,17 @@ def decode(\n             raise ValueError(e)\n \n \n+@adapter(Interface, ICollection)\n class CollectionMarshaler(BaseFieldMarshaler):\n     """Marshaler for collection values\n     """\n \n-    adapts(Interface, ICollection)\n-\n     ascii = False\n \n     def getCharset(self, default=\'utf-8\'):\n         valueTypeMarshaler = queryMultiAdapter(\n-            (self.context, self.field.value_type,), IFieldMarshaler)\n+            (self.context, self.field.value_type), IFieldMarshaler\n+        )\n         if valueTypeMarshaler is None:\n             return None\n         return valueTypeMarshaler.getCharset(default)\n@@ -314,7 +317,8 @@ def encode(self, value, charset=\'utf-8\', primary=False):\n             return None\n \n         valueTypeMarshaler = queryMultiAdapter(\n-            (self.context, self.field.value_type,), IFieldMarshaler)\n+            (self.context, self.field.value_type), IFieldMarshaler\n+        )\n         if valueTypeMarshaler is None:\n             return None\n \n@@ -322,7 +326,8 @@ def encode(self, value, charset=\'utf-8\', primary=False):\n         value_lines = []\n         for item in value:\n             marshaledValue = valueTypeMarshaler.encode(\n-                item, charset=charset, primary=primary)\n+                item, charset=charset, primary=primary\n+            )\n             if marshaledValue is None:\n                 marshaledValue = \'\'\n             value_lines.append(marshaledValue)\n@@ -330,8 +335,10 @@ def encode(self, value, charset=\'utf-8\', primary=False):\n                 ascii = False\n \n         self.ascii = ascii\n-\n-        return \'||\'.join(value_lines)\n+        if value_lines and isinstance(value_lines[0], six.binary_type):\n+            return b\'||\'.join(value_lines)\n+        else:\n+            return \'||\'.join(value_lines)\n \n     def decode(\n         self,\n@@ -339,22 +346,30 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         valueTypeMarshaler = queryMultiAdapter(\n-            (self.context, self.field.value_type,), IFieldMarshaler)\n+            (self.context, self.field.value_type), IFieldMarshaler\n+        )\n         if valueTypeMarshaler is None:\n-            raise ValueError("Cannot demarshal value type %s" %\n-                             repr(self.field.value_type))\n+            raise ValueError(\n+                \'Cannot demarshal value type %s\' % repr(self.field.value_type)\n+            )\n \n         listValue = []\n-\n-        for line in value.split(\'||\'):\n-            listValue.append(valueTypeMarshaler.decode(\n-                line, message, charset, contentType, primary))\n+        if isinstance(value, six.binary_type):\n+            lines = value.split(b\'||\')\n+        else:\n+            lines = value.split(\'||\')\n+        for line in lines:\n+            listValue.append(\n+                valueTypeMarshaler.decode(\n+                    line, message, charset, contentType, primary\n+                )\n+            )\n \n         sequenceType = self.field._type\n-        if isinstance(sequenceType, (list, tuple,)):\n+        if isinstance(sequenceType, (list, tuple)):\n             sequenceType = sequenceType[-1]\n \n         return sequenceType(listValue)\ndiff --git a/plone/rfc822/fields.rst b/plone/rfc822/fields.rst\nindex 2bd430c..bab43d6 100644\n--- a/plone/rfc822/fields.rst\n+++ b/plone/rfc822/fields.rst\n@@ -3,7 +3,7 @@ Field marshaler tests\n \n This test exercises the various standard field marshalers.\n \n-First, we load the package\'s configuration:\n+First, we load the package\'s configuration::\n \n     >>> configuration = b"""\\\n     ... <configure\n@@ -23,7 +23,7 @@ First, we load the package\'s configuration:\n     >>> xmlconfig.xmlconfig(BytesIO(configuration))\n \n Next, we\'ll create an interface which contains an instance of every field\n-we support.\n+we support::\n \n     >>> from zope.interface import Interface\n     >>> from zope import schema\n@@ -58,7 +58,7 @@ we support.\n     ...     _set = schema.Set(value_type=schema.Bool())\n     ...     _frozenset = schema.FrozenSet(value_type=schema.Timedelta())\n \n-This interface is implemented by a the following class:\n+This interface is implemented by a the following class::\n \n     >>> from decimal import Decimal\n     >>> from zope.interface import implementer\n@@ -74,10 +74,10 @@ This interface is implemented by a the following class:\n     ...     _password2 = u"password" # ascii safe\n     ...     _bytes = \'bytes\'\n     ...     _bytesLine = \'bytesline\'\n-    ...     _ascii = \'ascii\'\n-    ...     _asciiLine = \'asciiline\'\n-    ...     _uri = \'http://plone.org\'\n-    ...     _id = \'some.id\'\n+    ...     _ascii = u\'ascii\'\n+    ...     _asciiLine = u\'asciiline\'\n+    ...     _uri = u\'http://plone.org\'\n+    ...     _id = u\'some.id\'\n     ...     _dottedName = \'dotted.name\'\n     ...     _bool = True\n     ...     _int = long(-10) if six.PY2 else -10\n@@ -96,7 +96,7 @@ This interface is implemented by a the following class:\n     >>> t = TestContent()\n \n We can now look up the marshaler for each one and test the marshalling and\n-extraction methods.\n+extraction methods::\n \n     >>> from zope.component import getMultiAdapter\n     >>> from plone.rfc822.interfaces import IFieldMarshaler\n@@ -113,11 +113,13 @@ Notes:\n Text\n ----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_text\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'text\\xc3\\x98\'\n+    \'text\\xc3\\x98\'\n     >>> marshaler.decode(b\'text\\xc3\\x98\')\n-    u\'text\\xd8\'\n+    \'text\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -126,13 +128,13 @@ Text\n     False\n \n Text field types and derivatives will return True for the ``ascii`` property\n-if the field value is within the ascii range.\n+if the field value is within the ascii range::\n \n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_text2\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'text\'\n+    \'text\'\n     >>> marshaler.decode(b\'text\\xc3\\x98\')\n-    u\'text\\xd8\'\n+    \'text\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -143,11 +145,13 @@ if the field value is within the ascii range.\n TextLine\n --------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_textLine\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'textline\\xc3\\x98\'\n+    \'textline\\xc3\\x98\'\n     >>> marshaler.decode(b\'textline\\xc3\\x98\')\n-    u\'textline\\xd8\'\n+    \'textline\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -158,11 +162,13 @@ TextLine\n Text field types and derivatives will return True for the ``ascii`` property\n if the field value is within the ascii range.\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_textLine2\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'textline\'\n+    \'textline\'\n     >>> marshaler.decode(b\'textline\\xc3\\x98\')\n-    u\'textline\\xd8\'\n+    \'textline\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -173,11 +179,13 @@ if the field value is within the ascii range.\n Password\n --------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_password\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'password\\xc3\\x98\'\n+    \'password\\xc3\\x98\'\n     >>> marshaler.decode(b\'password\\xc3\\x98\')\n-    u\'password\\xd8\'\n+    \'password\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -188,11 +196,13 @@ Password\n Text field types and derivatives will return True for the ``ascii`` property\n if the field value is within the ascii range.\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_password2\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'password\'\n+    \'password\'\n     >>> marshaler.decode(b\'password\\xc3\\x98\')\n-    u\'password\\xd8\'\n+    \'password\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -203,11 +213,13 @@ if the field value is within the ascii range.\n Bytes\n -----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_bytes\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'bytes\'\n     >>> marshaler.decode(b\'bytes\')\n-    b\'bytes\'\n+    \'bytes\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\') is None\n@@ -218,11 +230,13 @@ Bytes\n BytesLine\n ---------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_bytesLine\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'bytesline\'\n     >>> marshaler.decode(b\'bytesline\')\n-    b\'bytesline\'\n+    \'bytesline\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\') is None\n@@ -233,9 +247,14 @@ BytesLine\n ASCII\n -----\n \n+This is an ASCII field which is supposed to store text strings.\n+Note: There is a BytesField which stores b\'foo\' binary string.\n+\n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_ascii\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'ascii\'\n+    \'ascii\'\n     >>> marshaler.decode(b\'ascii\')\n     \'ascii\'\n     >>> marshaler.getContentType() is None\n@@ -248,11 +267,13 @@ ASCII\n ASCIILine\n ---------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_asciiLine\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'asciiline\'\n     >>> marshaler.decode(b\'asciiline\')\n-    b\'asciiline\'\n+    \'asciiline\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\') is None\n@@ -263,6 +284,10 @@ ASCIILine\n URI\n ---\n \n+An URI is in Python 2 based on unicode text, in Python 3 on bytes.\n+\n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_uri\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'http://plone.org\'\n@@ -270,7 +295,11 @@ URI\n     \'http://plone.org\'\n     >>> marshaler.getContentType() is None\n     True\n-    >>> marshaler.getCharset(\'utf-8\') is None\n+    >>> if six.PY2:\n+    ...     expected = None  # its IBytes based\n+    ... else:\n+    ...     expected = \'utf-8\'\n+    >>> marshaler.getCharset(\'utf-8\') == expected\n     True\n     >>> marshaler.ascii\n     True\n@@ -278,21 +307,29 @@ URI\n Id\n --\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_id\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'some.id\'\n     >>> marshaler.decode(b\'some.id\')\n     \'some.id\'\n-    >>> marshaler.getCharset(\'utf-8\') is None\n-    True\n     >>> marshaler.getContentType() is None\n     True\n+    >>> if six.PY2:\n+    ...     expected = None  # its IBytes based\n+    ... else:\n+    ...     expected = \'utf-8\'\n+    >>> marshaler.getCharset(\'utf-8\') == expected\n+    True\n     >>> marshaler.ascii\n     True\n \n DottedName\n ----------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_dottedName\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'dotted.name\'\n@@ -300,7 +337,11 @@ DottedName\n     \'dotted.name\'\n     >>> marshaler.getContentType() is None\n     True\n-    >>> marshaler.getCharset(\'utf-8\') is None\n+    >>> if six.PY2:\n+    ...     expected = None  # its IBytes based\n+    ... else:\n+    ...     expected = \'utf-8\'\n+    >>> marshaler.getCharset(\'utf-8\') == expected\n     True\n     >>> marshaler.ascii\n     True\n@@ -308,6 +349,8 @@ DottedName\n Bool\n ----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_bool\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'True\'\n@@ -329,6 +372,8 @@ Bool\n Int\n ---\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_int\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'-10\'\n@@ -344,6 +389,8 @@ Int\n Float\n -----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_float\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'0.3\'\n@@ -359,6 +406,8 @@ Float\n Decimal\n -------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_decimal\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'5.0\'\n@@ -374,11 +423,13 @@ Decimal\n Choice\n ------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_choice1\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'two\'\n     >>> marshaler.decode(b\'one\')\n-    u\'one\'\n+    \'one\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -390,7 +441,7 @@ Choice\n     >>> marshaler.marshal()\n     \'two\'\n     >>> marshaler.decode(b\'three\')\n-    u\'three\'\n+    \'three\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -401,6 +452,8 @@ Choice\n Datetime\n --------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_datetime\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'2009-01-02T15:10:05.000001+01:00\'\n@@ -416,6 +469,8 @@ Datetime\n Date\n ----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_date\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'2008-02-03\'\n@@ -431,10 +486,12 @@ Date\n Timedelta\n ---------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_timedelta\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'3:4:5\'\n-    >>> marshaler.decode(b\'3:4:5\')\n+    >>> marshaler.decode(\'3:4:5\')\n     datetime.timedelta(3, 4, 5)\n     >>> marshaler.getContentType() is None\n     True\n@@ -446,11 +503,13 @@ Timedelta\n Tuple\n -----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_tuple\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'one\\xc3\\x98||two\'\n     >>> marshaler.decode(b\'one\\xc3\\x98||two\')\n-    (u\'one\\xd8\', u\'two\')\n+    (\'one\\xd8\', \'two\')\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -461,6 +520,8 @@ Tuple\n List\n ----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_list\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'three||four\'\n@@ -468,6 +529,8 @@ List\n     [\'three\', \'four\']\n     >>> marshaler.getContentType() is None\n     True\n+\n+    ValueType of the list is ASCIILine!\n     >>> marshaler.getCharset(\'utf-8\') is None\n     True\n     >>> marshaler.ascii\n@@ -476,6 +539,8 @@ List\n Set\n ---\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_set\']), IFieldMarshaler)\n     >>> marshaler.marshal() in (b\'False||True\', b\'True||False\')\n     True\n@@ -491,10 +556,12 @@ Set\n Frozenset\n ---------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_frozenset\']), IFieldMarshaler)\n-    >>> marshaler.marshal() in (b\'3:4:5||5:4:3\', b\'5:4:3||3:4:5\')\n+    >>> marshaler.marshal() in (\'3:4:5||5:4:3\', \'5:4:3||3:4:5\')\n     True\n-    >>> marshaler.decode(b\'3:4:5||5:4:3\') == frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])\n+    >>> marshaler.decode(\'3:4:5||5:4:3\') == frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])\n     True\n     >>> marshaler.getContentType() is None\n     True\ndiff --git a/plone/rfc822/interfaces.py b/plone/rfc822/interfaces.py\nindex a2e3e02..5c0aa99 100644\n--- a/plone/rfc822/interfaces.py\n+++ b/plone/rfc822/interfaces.py\n@@ -63,6 +63,8 @@ def constructMessage(context, fields, charset=\'utf-8\'):\n \n     def renderMessage(message, mangleFromHeader=False):\n         """Render a message to a string\n+\n+        DEPRECATED. Use \'message.as_string()\' instead.\n         """\n \n     def initializeObjectFromSchema(\ndiff --git a/plone/rfc822/message.rst b/plone/rfc822/message.rst\nindex 4ab8e58..5ea994d 100644\n--- a/plone/rfc822/message.rst\n+++ b/plone/rfc822/message.rst\n@@ -1,12 +1,16 @@\n Message construction and parsing\n ================================\n \n+Use Python 3 bytes/string::\n+\n+    >>> from __future__ import unicode_literals\n+\n This package contains helper methods to construct an RFC 2822 style message\n from a list of schema fields, and to parse a message and initialise an object\n based on its headers and body payload.\n \n Before we begin, let\'s load the default field marshalers and configure\n-annotations, which we will use later in this test.\n+annotations, which we will use later in this test::\n \n     >>> configuration = u"""\\\n     ... <configure\n@@ -57,16 +61,16 @@ marshal to a message.\n     >>> from zope.interface import implementer\n     >>> @implementer(ITestContent)\n     ... class TestContent(object):\n-    ...     title = u""\n-    ...     description = u""\n-    ...     body = u""\n+    ...     title = ""\n+    ...     description = ""\n+    ...     body = ""\n     ...     emptyfield = None\n \n     >>> content = TestContent()\n-    >>> content.title = u"Test title"\n-    >>> content.description = u"""Test description\n+    >>> content.title = "Test title"\n+    >>> content.description = """T\xc3\xa4st description\n     ... with a newline"""\n-    >>> content.body = u"<p>Test body</p>"\n+    >>> content.body = "<p>Test body</p>"\n \n We could create a message form this instance and schema like this:\n \n@@ -75,10 +79,9 @@ We could create a message form this instance and schema like this:\n \n The output looks like this:\n \n-    >>> from plone.rfc822 import renderMessage\n-    >>> print(renderMessage(msg))\n+    >>> print(msg.as_string())\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     Content-Type: text/plain; charset="utf-8"\n     <BLANKLINE>\n@@ -101,9 +104,9 @@ encoding.\n If we want to use a different content type, we could set it explicitly:\n \n     >>> msg.set_type(\'text/html\')\n-    >>> print(renderMessage(msg))\n+    >>> print(msg.as_string())\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     MIME-Version: 1.0\n     Content-Type: text/html; charset="utf-8"\n@@ -131,11 +134,10 @@ the ``getContentType()``:\n \n     >>> from plone.rfc822.defaultfields import UnicodeValueFieldMarshaler\n     >>> from zope.schema.interfaces import IText\n-    >>> from zope.component import adapts\n+    >>> from zope.component import adapter\n \n-    >>> class TestBodyMarshaler(UnicodeValueFieldMarshaler):\n-    ...     adapts(ITestContent, IText)\n-    ...\n+    >>> @adapter(ITestContent, IText)\n+    ... class TestBodyMarshaler(UnicodeValueFieldMarshaler):\n     ...     def getContentType(self):\n     ...         return \'text/html\'\n \n@@ -153,9 +155,9 @@ above), or have the marshaler check the field name.\n Let\'s now try again:\n \n     >>> msg = constructMessageFromSchema(content, ITestContent)\n-    >>> print(renderMessage(msg))\n+    >>> print(msg.as_string())\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     MIME-Version: 1.0\n     Content-Type: text/html; charset="utf-8"\n@@ -193,11 +195,13 @@ message.\n     >>> initializeObjectFromSchema(newContent, ITestContent, msg)\n \n     >>> newContent.title\n-    u\'Test title\'\n-    >>> newContent.description\n-    u\'Test description\\nwith a newline\'\n+    \'Test title\'\n+    >>> print(newContent.description)\n+    Test description\n+    with a newline\n+\n     >>> newContent.body\n-    u\'<p>Test body</p>\'\n+    \'<p>Test body</p>\'\n \n We can also consume messages with a transfer encoding and a charset:\n \n@@ -220,16 +224,17 @@ We can also consume messages with a transfer encoding and a charset:\n     >>> initializeObjectFromSchema(newContent, ITestContent, msg)\n \n     >>> newContent.title\n-    u\'Test title\'\n-    >>> newContent.description\n-    u\'Test description\\nwith a newline\'\n+    \'Test title\'\n+    >>> print(newContent.description)\n+    Test description\n+    with a newline\n     >>> newContent.body\n-    u\'<p>Test body</p>\'\n+    \'<p>Test body</p>\'\n \n Note: Empty fields will result in the field\'s ``missing_value`` being used:\n \n     >>> newContent.emptyfield\n-    u\'missing\'\n+    \'missing\'\n \n Handling multiple primary fields and duplicate field names\n ----------------------------------------------------------\n@@ -251,8 +256,8 @@ The annotation storage would look like this:\n \n     >>> from persistent import Persistent\n     >>> @implementer(IPersonalDetails)\n+    ... @adapter(ITestContent)\n     ... class PersonalDetailsAnnotation(Persistent):\n-    ...     adapts(ITestContent)\n     ...\n     ...     def __init__(self):\n     ...         self.description = None\n@@ -293,14 +298,14 @@ Here are the fields it will see:\n \n Let\'s now construct a message. Since we now have two fields called\n ``description``, we will get two headers by that name. Since we have two\n-primary fields, we will get a multipart message with two attachments.\n+primary fields, we will get a multipart message with two attachments::\n \n     >>> from plone.rfc822 import constructMessageFromSchemata\n     >>> msg = constructMessageFromSchemata(content, (ITestContent, IPersonalDetails,))\n-    >>> msgString = renderMessage(msg)\n+    >>> msgString = msg.as_string()\n     >>> print(msgString)\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     description: <p>My description</p>\n     currentAge: 21\n@@ -317,7 +322,9 @@ primary fields, we will get a multipart message with two attachments.\n     Content-Type: text/html; charset="utf-8"\n     <BLANKLINE>\n     <p>My profile</p>\n-    --===============...==--...\n+    --===============...==--\n+    <BLANKLINE>\n+\n \n (Note that we\'ve used ellipses here for the doctest to work with the generated\n boundary string).\n@@ -339,23 +346,24 @@ attachments to the two primary fields:\n     >>> initializeObjectFromSchemata(newContent, [ITestContent, IPersonalDetails], msg)\n \n     >>> newContent.title\n-    u\'Test title\'\n+    \'Test title\'\n \n+    >>> newContent.marker = True\n     >>> newContent.description\n-    u\'Test description\\nwith a newline\'\n+    \'T\\xe4st description\\nwith a newline\'\n \n     >>> newContent.body\n-    u\'<p>Test body</p>\'\n+    \'<p>Test body</p>\'\n \n     >>> newPersonalDetails = IPersonalDetails(newContent)\n     >>> newPersonalDetails.description\n-    u\'<p>My description</p>\'\n+    \'<p>My description</p>\'\n \n     >>> newPersonalDetails.currentAge\n     21\n \n     >>> newPersonalDetails.personalProfile\n-    u\'<p>My profile</p>\'\n+    \'<p>My profile</p>\'\n \n Alternative ways to deal with multiple schemata\n -----------------------------------------------\n@@ -376,14 +384,14 @@ own multipart message. To do that, we would simply use the\n     >>> envelope.attach(mainMessage)\n     >>> envelope.attach(personalDetailsMessage)\n \n-    >>> envelopeString = renderMessage(envelope)\n+    >>> envelopeString = envelope.as_string()\n     >>> print(envelopeString)\n     Content-Type: multipart/mixed; boundary="===============...=="\n     MIME-Version: 1.0\n     <BLANKLINE>\n     --===============...==\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     MIME-Version: 1.0\n     Content-Type: text/html; charset="utf-8"\n@@ -516,7 +524,7 @@ what happens when we attempt to construct a message from this schema.\n \n     >>> from plone.rfc822 import constructMessageFromSchema\n     >>> message = constructMessageFromSchema(fileContent, IFileContent)\n-    >>> print(renderMessage(message))\n+    >>> print(message.as_string())\n     <BLANKLINE>\n     <BLANKLINE>\n \n@@ -528,7 +536,7 @@ field as primary:\n     >>> alsoProvides(IFileContent[\'file1\'], IPrimaryField)\n \n     >>> message = constructMessageFromSchema(fileContent, IFileContent)\n-    >>> messageBody = renderMessage(message)\n+    >>> messageBody = message.as_string()\n     >>> print(messageBody)\n     MIME-Version: 1.0\n     Content-Type: text/plain\n@@ -564,7 +572,7 @@ In this case, we should get a multipart document with two payloads.\n \n     >>> alsoProvides(IFileContent[\'file2\'], IPrimaryField)\n     >>> message = constructMessageFromSchema(fileContent, IFileContent)\n-    >>> messageBody = renderMessage(message)\n+    >>> messageBody = message.as_string()\n     >>> print(messageBody) # doctest: +ELLIPSIS\n     MIME-Version: 1.0\n     Content-Type: multipart/mixed; boundary="===============...=="\n@@ -604,3 +612,27 @@ And again, we can reconstruct the object, this time with both fields:\n     \'text/html\'\n     >>> newFileContent.file2.filename\n     \'dummy2.html\'\n+\n+Specialities between Py2 and Py3\n+--------------------------------\n+\n+Test a special behavior which is different between Python 2 and 3 stdlib:\n+Newline handling in non-utf8 strings.\n+\n+Python 2.7 ``email.header`` keeps a line with an escaped value,\n+while Python 3.6 turns it into RFC2047 encoded headers, see https://tools.ietf.org/html/rfc2047.html\n+Technical both is fine.\n+\n+::\n+\n+    >>> import six\n+    >>> content.description = "Test content\\nwith newline difference"\n+    >>> msg = constructMessageFromSchema(content, ITestContent)\n+    >>> effective_output = msg.as_string()\n+    >>> effective_output_line_2 = effective_output.split(\'\\n\')[1]\n+    >>> if six.PY2:\n+    ...     expected_output_line_2 = r"description: Test content\\nwith newline difference"\n+    ... else:\n+    ...     expected_output_line_2 = r"description: =?utf-8?q?Test_content=5Cnwith_newline_difference?="\n+    >>> effective_output_line_2 == expected_output_line_2\n+    True\ndiff --git a/plone/rfc822/supermodel.py b/plone/rfc822/supermodel.py\nindex 6d24d72..2f38005 100644\n--- a/plone/rfc822/supermodel.py\n+++ b/plone/rfc822/supermodel.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from __future__ import unicode_literals\n try:\n     from plone.supermodel.interfaces import IFieldMetadataHandler\n     HAVE_SUPERMODEL = True\ndiff --git a/plone/rfc822/tests.py b/plone/rfc822/tests.py\nindex 8d7b26d..47912ea 100644\n--- a/plone/rfc822/tests.py\n+++ b/plone/rfc822/tests.py\n@@ -23,9 +23,9 @@\n class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n         if six.PY2:\n-            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n-        else:\n-            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+            got = re.sub("u\'(.*?)\'", "\'\\\\1\'", got)\n+        if six.PY3:\n+            got = re.sub("b\'(.*?)\'", "\'\\\\1\'", got)\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \ndiff --git a/setup.py b/setup.py\nindex e9dce47..d8cc7b0 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -5,7 +5,7 @@\n import os\n \n \n-version = \'1.1.5.dev0\'\n+version = \'2.0.0b1.dev0\'\n \n setup(\n     name=\'plone.rfc822\',\n@@ -19,17 +19,15 @@\n     # https://pypi.python.org/pypi?%3Aaction=list_classifiers\n     classifiers=[\n         "Framework :: Plone",\n-        "Framework :: Plone :: 4.3",\n-        "Framework :: Plone :: 5.0",\n-        "Framework :: Plone :: 5.1",\n+        # "Framework :: Plone :: 5.2",\n         "Programming Language :: Python",\n-        "Programming Language :: Python :: 2.6",\n         "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.6",\n         "Topic :: Software Development :: Libraries :: Python Modules",\n         "License :: OSI Approved :: BSD License",\n     ],\n     keywords=\'zope schema rfc822\',\n-    author=\'Martin Aspeli\',\n+    author=\'Martin Aspeli and contributors\',\n     author_email=\'optilude@gmail.com\',\n     url=\'https://pypi.python.org/pypi/plone.rfc822\',\n     license=\'BSD\',\n@@ -39,14 +37,15 @@\n     zip_safe=False,\n     extras_require={\n         \'supermodel\': [\'plone.supermodel\'],\n-        \'test\': [\'plone.testing\'],\n+        \'test\': [\'plone.testing\', \'plone.supermodel\'],\n     },\n     install_requires=[\n+        \'python-dateutil\',\n         \'setuptools\',\n-        \'zope.schema\',\n         \'zope.component\',\n+        \'zope.deprecation\',\n         \'zope.interface\',\n-        \'python-dateutil\',\n+        \'zope.schema\',\n     ],\n     entry_points="""\n     """,\n'

Repository: plone.rfc822


Branch: refs/heads/master
Date: 2018-07-02T11:54:32+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.rfc822/commit/0fc67324527a113f113a3c40b088fbdacd444801

Merge remote-tracking branch 'remotes/origin/jensens-overhaul-py3' into jensens-overhaul-py3

Files changed:
M CHANGES.rst
M plone/rfc822/_utils.py
M plone/rfc822/interfaces.py
M plone/rfc822/message.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 6173fab..2feb024 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -6,20 +6,24 @@ Changelog\n \n Breaking changes:\n \n-- Drop support of Python 2.6\n-  [jensens]\n-\n - Deprecate ``renderMessage(message)``,\n   use stdlibs ``message.as_string()`` from ``email.message.Message`` class instead.\n   [jensens]\n \n-- Newline handling in MIME-headers are now escaped explicit.\n+- Newline handling in MIME-headers: ``\\n`` are now escaped explicit.\n   This follows RFC2822 section 3.2.2.\n   [jensens]\n \n+- Drop support of Python 2.6\n+  [jensens]\n+\n New features:\n \n-- Support for Python 3.\n+- ``constructMessage`` now handles base64 encoding automatically for all marshallers,\n+  where ``marshaler.ascii`` is ``False`` and ``marshaler.getContentType`` is ``None``.\n+  [jensens]\n+\n+- Support for Python 3+\n   Also big code overhaul included.\n   [jensens]\n \ndiff --git a/plone/rfc822/_utils.py b/plone/rfc822/_utils.py\nindex beded86..7cee2a5 100644\n--- a/plone/rfc822/_utils.py\n+++ b/plone/rfc822/_utils.py\n@@ -6,6 +6,7 @@\n See interfaces.py for details.\n """\n from __future__ import unicode_literals\n+from email.encoders import encode_base64\n from email.header import decode_header\n from email.header import Header\n from email.message import Message\n@@ -36,9 +37,8 @@ def constructMessageFromSchemata(context, schemata, charset="utf-8"):\n def _add_payload_to_message(context, msg, primary, charset):\n     """If there\'s a single primary field, we have a non-multipart message with\n     a string payload. Otherwise, we return a multipart message\n+\n     """\n-    if not primary:\n-        return\n     is_multipart = len(primary) > 1\n     if is_multipart:\n         msg.set_type("multipart/mixed")\n@@ -52,21 +52,32 @@ def _add_payload_to_message(context, msg, primary, charset):\n         if marshaler is None:\n             continue\n \n-        contentType = marshaler.getContentType()\n-        payloadCharset = marshaler.getCharset(charset)\n-\n-        if contentType is not None:\n-            payload.set_type(contentType)\n-        if payloadCharset is not None:\n-            # using set_charset() would also add transfer encoding,\n-            # which we don\'t want to do always\n-            payload.set_param("charset", payloadCharset)\n-\n         value = marshaler.marshal(charset, primary=True)\n-\n         if value is None:\n             continue\n-        payload.set_payload(value)\n+\n+        content_type = marshaler.getContentType()\n+        if content_type is not None:\n+            payload.set_type(content_type)\n+\n+        charset = marshaler.getCharset(charset)\n+        if charset is None and not marshaler.ascii:\n+            # we have real binary data such as images, files, etc.\n+            # encode to base64!\n+            payload.set_payload(value)\n+            encode_base64(payload)\n+        elif charset is not None:\n+            # using set_charset() would also add transfer encoding to\n+            # quoted-printable, which we don\'t want here.\n+            # for unicodedata, we keep it as-is, so: binary\n+            # payload[\'Content-Transfer-Encoding\'] = "BINARY"\n+            payload.set_param("charset", charset)\n+            if isinstance(value, six.binary_type):\n+                value = value.decode(charset)\n+            payload.set_payload(value)\n+        else:\n+            payload.set_payload(value)\n+\n         marshaler.postProcessMessage(payload)\n         if is_multipart:\n             msg.attach(payload)\n@@ -103,8 +114,6 @@ def constructMessage(context, fields, charset="utf-8"):\n         if not isinstance(value, six.text_type):\n             # py3: email.message.Message headers are expecting text\n             value = value.decode("utf-8")\n-        # if field.__name__ == \'description\':\n-        #     import pdb; pdb.set_trace()\n         if marshaler.ascii and "\\n" not in value:\n             msg[name] = value\n         else:\ndiff --git a/plone/rfc822/interfaces.py b/plone/rfc822/interfaces.py\nindex 5c0aa99..cdc09e0 100644\n--- a/plone/rfc822/interfaces.py\n+++ b/plone/rfc822/interfaces.py\n@@ -3,8 +3,6 @@\n from zope.interface import Attribute\n from zope.interface import Interface\n \n-import six\n-\n \n class IPrimaryField(Interface):\n     """Marker interface for the primary field in a schema\n@@ -221,4 +219,8 @@ def postProcessMessage(message):\n         """This is a chance to perform any post-processing of the message.\n \n         It is only called for primary fields.\n+\n+        Note: Before version 2 of plone.rfc.822 this was used primary for\n+        Base64 encoding of the body. Base64 encoding is handled now by default\n+        in ``constructMessage``.\n         """\ndiff --git a/plone/rfc822/message.rst b/plone/rfc822/message.rst\nindex 5ea994d..8c12390 100644\n--- a/plone/rfc822/message.rst\n+++ b/plone/rfc822/message.rst\n@@ -1,10 +1,6 @@\n Message construction and parsing\n ================================\n \n-Use Python 3 bytes/string::\n-\n-    >>> from __future__ import unicode_literals\n-\n This package contains helper methods to construct an RFC 2822 style message\n from a list of schema fields, and to parse a message and initialise an object\n based on its headers and body payload.\n@@ -25,6 +21,8 @@ annotations, which we will use later in this test::\n     ... </configure>\n     ... """\n \n+::\n+\n     >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n@@ -35,7 +33,7 @@ The primary field\n The message body is assumed to originate from a "primary" field, which is\n indicated via a marker interface.\n \n-To illustrate the pattern, consider the following schema interface:\n+To illustrate the pattern, consider the following schema interface::\n \n     >>> from zope.interface import Interface, alsoProvides\n     >>> from plone.rfc822.interfaces import IPrimaryField\n@@ -48,7 +46,7 @@ To illustrate the pattern, consider the following schema interface:\n     ...     body = schema.Text(title=u"Body text")\n     ...     emptyfield = schema.TextLine(title=u"Empty field", missing_value=u\'missing\')\n \n-The primary field instance is marked like this:\n+The primary field instance is marked like this::\n \n     >>> alsoProvides(ITestContent[\'body\'], IPrimaryField)\n \n@@ -56,7 +54,7 @@ Constructing a message\n ----------------------\n \n Let\'s now say we have an instance providing this interface, which we want to\n-marshal to a message.\n+marshal to a message::\n \n     >>> from zope.interface import implementer\n     >>> @implementer(ITestContent)\n@@ -72,12 +70,12 @@ marshal to a message.\n     ... with a newline"""\n     >>> content.body = "<p>Test body</p>"\n \n-We could create a message form this instance and schema like this:\n+We could create a message from this instance and schema like this::\n \n     >>> from plone.rfc822 import constructMessageFromSchema\n     >>> msg = constructMessageFromSchema(content, ITestContent)\n \n-The output looks like this:\n+The output looks like this::\n \n     >>> print(msg.as_string())\n     title: Test title\n@@ -87,11 +85,11 @@ The output looks like this:\n     <BLANKLINE>\n     <p>Test body</p>\n \n-Notice how the non-ASCII header values are UTF-8 encoded. The encoding\n-algorithm is clever enough to only encode the value if it is necessary,\n+Notice how the non-ASCII header values are UTF-8 encoded.\n+The encoding algorithm is clever enough to only encode the value if it is necessary,\n leaving more readable field values otherwise.\n \n-The body here is of the default message type:\n+The body here is of the default message type::\n \n     >>> msg.get_default_type()\n     \'text/plain\'\n@@ -101,7 +99,7 @@ This is because none of the default field types manage a content type.\n The body is also utf-8 encoded, because the primary field specified this\n encoding.\n \n-If we want to use a different content type, we could set it explicitly:\n+If we want to use a different content type, we could set it explicitly::\n \n     >>> msg.set_type(\'text/html\')\n     >>> print(msg.as_string())\n@@ -497,8 +495,6 @@ We can register a field marshaler for this field which will do the following:\n     ...             if filename:\n     ...                 # Add a new header storing the filename if we have one\n     ...                 message.add_header(\'Content-Disposition\', \'attachment\', filename=filename)\n-    ...         # Apply base64 encoding\n-    ...         encode_base64(message)\n \n     >>> from zope.component import provideAdapter\n     >>> provideAdapter(FileFieldMarshaler)\n@@ -540,8 +536,8 @@ field as primary:\n     >>> print(messageBody)\n     MIME-Version: 1.0\n     Content-Type: text/plain\n-    Content-Disposition: attachment; filename="dummy1.txt"\n     Content-Transfer-Encoding: base64\n+    Content-Disposition: attachment; filename="dummy1.txt"\n     <BLANKLINE>\n     ZHVtbXkgZmlsZQ==\n \n@@ -580,15 +576,15 @@ In this case, we should get a multipart document with two payloads.\n     --===============...==\n     MIME-Version: 1.0\n     Content-Type: text/plain\n-    Content-Disposition: attachment; filename="dummy1.txt"\n     Content-Transfer-Encoding: base64\n+    Content-Disposition: attachment; filename="dummy1.txt"\n     <BLANKLINE>\n     ZHVtbXkgZmlsZQ==\n     --===============...==\n     MIME-Version: 1.0\n     Content-Type: text/html\n-    Content-Disposition: attachment; filename="dummy2.html"\n     Content-Transfer-Encoding: base64\n+    Content-Disposition: attachment; filename="dummy2.html"\n     <BLANKLINE>\n     PGh0bWw+PGJvZHk+dGVzdDwvYm9keT48L2h0bWw+\n     --===============...==--...\n'

Repository: plone.rfc822


Branch: refs/heads/master
Date: 2018-10-02T11:26:28+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.rfc822/commit/868db8757e2c8dabd4f7db0892a77202c791abd8

Merge remote-tracking branch 'origin/master' into jensens-overhaul-py3

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex d8cc7b0..e298b2d 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -16,10 +16,10 @@\n         open("CHANGES.rst").read() + "\\n" +\n         open(os.path.join("plone", "rfc822", "message.rst")).read()),\n     # Get more strings from\n-    # https://pypi.python.org/pypi?%3Aaction=list_classifiers\n+    # https://pypi.org/classifiers/\n     classifiers=[\n         "Framework :: Plone",\n-        # "Framework :: Plone :: 5.2",\n+        "Framework :: Plone :: 5.2",\n         "Programming Language :: Python",\n         "Programming Language :: Python :: 2.7",\n         "Programming Language :: Python :: 3.6",\n@@ -29,9 +29,9 @@\n     keywords=\'zope schema rfc822\',\n     author=\'Martin Aspeli and contributors\',\n     author_email=\'optilude@gmail.com\',\n-    url=\'https://pypi.python.org/pypi/plone.rfc822\',\n+    url=\'https://pypi.org/project/plone.rfc822\',\n     license=\'BSD\',\n-    packages=find_packages(exclude=[\'ez_setup\']),\n+    packages=find_packages(),\n     namespace_packages=[\'plone\'],\n     include_package_data=True,\n     zip_safe=False,\n'

Repository: plone.rfc822


Branch: refs/heads/master
Date: 2018-10-02T12:55:02+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.rfc822/commit/c974d3d374bb329c5b9dc4c0098f989f0667e358

email messages should always be native strings

Files changed:
M plone/rfc822/_utils.py
M plone/rfc822/configure.zcml
M plone/rfc822/message.rst

b'diff --git a/plone/rfc822/_utils.py b/plone/rfc822/_utils.py\nindex 7cee2a5..bdcb995 100644\n--- a/plone/rfc822/_utils.py\n+++ b/plone/rfc822/_utils.py\n@@ -23,6 +23,14 @@\n logger = logging.getLogger("plone.rfc822")\n \n \n+def enforce_native_string(value, encoding=\'utf8\'):\n+    if six.PY2 and isinstance(value, six.text_type):\n+        return value.encode(encoding)\n+    if isinstance(value, six.binary_type):\n+        return value.decode(encoding)\n+    return value\n+\n+\n def constructMessageFromSchema(context, schema, charset="utf-8"):\n     return constructMessage(context, getFieldsInOrder(schema), charset)\n \n@@ -72,10 +80,10 @@ def _add_payload_to_message(context, msg, primary, charset):\n             # for unicodedata, we keep it as-is, so: binary\n             # payload[\'Content-Transfer-Encoding\'] = "BINARY"\n             payload.set_param("charset", charset)\n-            if isinstance(value, six.binary_type):\n-                value = value.decode(charset)\n+            value = enforce_native_string(value, charset)\n             payload.set_payload(value)\n         else:\n+            value = enforce_native_string(value)\n             payload.set_payload(value)\n \n         marshaler.postProcessMessage(payload)\n@@ -89,6 +97,7 @@ def constructMessage(context, fields, charset="utf-8"):\n \n     # First get all headers, storing primary fields for later\n     for name, field in fields:\n+        value = \'\'\n         if IPrimaryField.providedBy(field):\n             primaries.append((name, field))\n             continue\n@@ -111,15 +120,14 @@ def constructMessage(context, fields, charset="utf-8"):\n             continue\n         if value is None:\n             value = ""\n-        if not isinstance(value, six.text_type):\n-            # py3: email.message.Message headers are expecting text\n-            value = value.decode("utf-8")\n+        # Enforce native strings\n+        value = enforce_native_string(value)\n         if marshaler.ascii and "\\n" not in value:\n             msg[name] = value\n         else:\n             if "\\n" in value:\n                 # see https://tools.ietf.org/html/rfc2822#section-3.2.2\n-                value = value.replace(u"\\n", r"\\n")\n+                value = value.replace("\\n", r"\\n")\n             msg[name] = Header(value, charset)\n \n     # Then deal with the primary field\ndiff --git a/plone/rfc822/configure.zcml b/plone/rfc822/configure.zcml\nindex ba44227..2397069 100644\n--- a/plone/rfc822/configure.zcml\n+++ b/plone/rfc822/configure.zcml\n@@ -27,6 +27,13 @@\n         for="* zope.schema.interfaces.IBool"\n         factory=".defaultfields.ASCIISafeFieldMarshaler"\n         />\n+    <!-- We need this as a workaround for this issue:\n+      https://github.com/zopefoundation/zope.schema/issues/80\n+    -->\n+    <adapter\n+        for="* zope.schema._bootstrapfields.Bool"\n+        factory=".defaultfields.ASCIISafeFieldMarshaler"\n+        />\n     <adapter\n         for="* zope.schema.interfaces.IChoice"\n         factory=".defaultfields.UnicodeValueFieldMarshaler"\ndiff --git a/plone/rfc822/message.rst b/plone/rfc822/message.rst\nindex 8c12390..9f21f95 100644\n--- a/plone/rfc822/message.rst\n+++ b/plone/rfc822/message.rst\n@@ -457,11 +457,11 @@ We can register a field marshaler for this field which will do the following:\n     >>> from plone.rfc822.interfaces import IFieldMarshaler\n     >>> from email.encoders import encode_base64\n \n-    >>> from zope.component import adapts\n+    >>> from zope.component import adapter\n     >>> from plone.rfc822.defaultfields import BaseFieldMarshaler\n \n-    >>> class FileFieldMarshaler(BaseFieldMarshaler):\n-    ...     adapts(Interface, IFileField)\n+    >>> @adapter(Interface, IFileField)\n+    ... class FileFieldMarshaler(BaseFieldMarshaler):\n     ...\n     ...     ascii = False\n     ...\n'

Repository: plone.rfc822


Branch: refs/heads/master
Date: 2018-10-02T15:19:24+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.rfc822/commit/4bee4c921d076ab0a8a86fc53d56721ccd9b2893

Fix native strings everywhere

Files changed:
M plone/rfc822/_utils.py
M plone/rfc822/defaultfields.py
M plone/rfc822/message.rst
M plone/rfc822/supermodel.py
M plone/rfc822/tests.py

b'diff --git a/plone/rfc822/_utils.py b/plone/rfc822/_utils.py\nindex bdcb995..403c8b4 100644\n--- a/plone/rfc822/_utils.py\n+++ b/plone/rfc822/_utils.py\n@@ -5,7 +5,6 @@\n \n See interfaces.py for details.\n """\n-from __future__ import unicode_literals\n from email.encoders import encode_base64\n from email.header import decode_header\n from email.header import Header\n@@ -23,11 +22,16 @@\n logger = logging.getLogger("plone.rfc822")\n \n \n-def enforce_native_string(value, encoding=\'utf8\'):\n-    if six.PY2 and isinstance(value, six.text_type):\n-        return value.encode(encoding)\n-    if isinstance(value, six.binary_type):\n+def safe_native_string(value, encoding=\'utf8\'):\n+    \'\'\' Try to convert value into a native string\n+    \'\'\'\n+    if six.PY2:\n+        if isinstance(value, six.text_type):\n+            return value.encode(encoding)\n+    elif isinstance(value, six.binary_type):\n         return value.decode(encoding)\n+    if not isinstance(value, str):\n+        raise ValueError(\'Cannot convert %r into a native string\' % value)\n     return value\n \n \n@@ -80,10 +84,10 @@ def _add_payload_to_message(context, msg, primary, charset):\n             # for unicodedata, we keep it as-is, so: binary\n             # payload[\'Content-Transfer-Encoding\'] = "BINARY"\n             payload.set_param("charset", charset)\n-            value = enforce_native_string(value, charset)\n+            value = safe_native_string(value, charset)\n             payload.set_payload(value)\n         else:\n-            value = enforce_native_string(value)\n+            value = safe_native_string(value)\n             payload.set_payload(value)\n \n         marshaler.postProcessMessage(payload)\n@@ -121,12 +125,12 @@ def constructMessage(context, fields, charset="utf-8"):\n         if value is None:\n             value = ""\n         # Enforce native strings\n-        value = enforce_native_string(value)\n+        value = safe_native_string(value)\n         if marshaler.ascii and "\\n" not in value:\n             msg[name] = value\n         else:\n-            if "\\n" in value:\n-                # see https://tools.ietf.org/html/rfc2822#section-3.2.2\n+            # see https://tools.ietf.org/html/rfc2822#section-3.2.2\n+            if \'\\n\' in value:\n                 value = value.replace("\\n", r"\\n")\n             msg[name] = Header(value, charset)\n \ndiff --git a/plone/rfc822/defaultfields.py b/plone/rfc822/defaultfields.py\nindex 690bd20..fe155c3 100644\n--- a/plone/rfc822/defaultfields.py\n+++ b/plone/rfc822/defaultfields.py\n@@ -31,7 +31,6 @@\n * InterfaceField - stores Interface\n * Dict - stores a dict\n """\n-from __future__ import unicode_literals\n from plone.rfc822.interfaces import IFieldMarshaler\n from zope.component import adapter\n from zope.component import queryMultiAdapter\ndiff --git a/plone/rfc822/message.rst b/plone/rfc822/message.rst\nindex 9f21f95..d6beaaf 100644\n--- a/plone/rfc822/message.rst\n+++ b/plone/rfc822/message.rst\n@@ -625,10 +625,5 @@ Technical both is fine.\n     >>> content.description = "Test content\\nwith newline difference"\n     >>> msg = constructMessageFromSchema(content, ITestContent)\n     >>> effective_output = msg.as_string()\n-    >>> effective_output_line_2 = effective_output.split(\'\\n\')[1]\n-    >>> if six.PY2:\n-    ...     expected_output_line_2 = r"description: Test content\\nwith newline difference"\n-    ... else:\n-    ...     expected_output_line_2 = r"description: =?utf-8?q?Test_content=5Cnwith_newline_difference?="\n-    >>> effective_output_line_2 == expected_output_line_2\n-    True\n+    >>> effective_output.split(\'\\n\')[1]\n+    \'description: =?utf-8?q?Test_content=5Cnwith_newline_difference?=\'\ndiff --git a/plone/rfc822/supermodel.py b/plone/rfc822/supermodel.py\nindex 2f38005..6d24d72 100644\n--- a/plone/rfc822/supermodel.py\n+++ b/plone/rfc822/supermodel.py\n@@ -1,5 +1,4 @@\n # -*- coding: utf-8 -*-\n-from __future__ import unicode_literals\n try:\n     from plone.supermodel.interfaces import IFieldMetadataHandler\n     HAVE_SUPERMODEL = True\ndiff --git a/plone/rfc822/tests.py b/plone/rfc822/tests.py\nindex 47912ea..a2bb902 100644\n--- a/plone/rfc822/tests.py\n+++ b/plone/rfc822/tests.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from plone.rfc822._utils import safe_native_string\n from plone.testing import layered\n from plone.testing.zca import UNIT_TESTING\n \n@@ -29,6 +30,14 @@ def check_output(self, want, got, optionflags):\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \n+class TestUtils(unittest.TestCase):\n+\n+    def test_safe_native_string(self):\n+        self.assertIsInstance(safe_native_string(b\'\'), str)\n+        self.assertIsInstance(safe_native_string(u\'\'), str)\n+        self.assertRaises(ValueError, safe_native_string, None)\n+\n+\n def test_suite():\n \n     suite = unittest.TestSuite()\n@@ -43,4 +52,5 @@ def test_suite():\n         )\n         for docfile in DOCFILES\n     ])\n+    suite.addTest(TestUtils(\'test_safe_native_string\'))\n     return suite\n'

Repository: plone.rfc822


Branch: refs/heads/master
Date: 2018-10-02T18:37:13+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.rfc822/commit/9d476d61d7ca766998e030991540b8da666b88cb

fix DatetimeMarshaler in py3

Files changed:
M plone/rfc822/defaultfields.py

b'diff --git a/plone/rfc822/defaultfields.py b/plone/rfc822/defaultfields.py\nindex fe155c3..250a6b2 100644\n--- a/plone/rfc822/defaultfields.py\n+++ b/plone/rfc822/defaultfields.py\n@@ -231,9 +231,10 @@ def decode(\n         contentType=None,\n         primary=False,\n     ):\n-        unicodeValue = value.decode(charset)\n+        if isinstance(value, six.binary_type):\n+            value = value.decode(charset)\n         try:\n-            return dateutil.parser.parse(unicodeValue)\n+            return dateutil.parser.parse(value)\n         except Exception as e:\n             raise ValueError(e)\n \n'

Repository: plone.rfc822


Branch: refs/heads/master
Date: 2018-10-03T18:25:15+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.rfc822/commit/524d477a515f5c93e6cfc7dfd0571c963c4bac5a

Python 3.7 compatibility

Files changed:
M plone/rfc822/fields.rst
M setup.py

b'diff --git a/plone/rfc822/fields.rst b/plone/rfc822/fields.rst\nindex bab43d6..e656445 100644\n--- a/plone/rfc822/fields.rst\n+++ b/plone/rfc822/fields.rst\n@@ -491,8 +491,8 @@ Timedelta\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_timedelta\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'3:4:5\'\n-    >>> marshaler.decode(\'3:4:5\')\n-    datetime.timedelta(3, 4, 5)\n+    >>> marshaler.decode(\'3:4:5\') == datetime.timedelta(3, 4, 5)\n+    True\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\') is None\ndiff --git a/setup.py b/setup.py\nindex e298b2d..6073f29 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -23,6 +23,7 @@\n         "Programming Language :: Python",\n         "Programming Language :: Python :: 2.7",\n         "Programming Language :: Python :: 3.6",\n+        "Programming Language :: Python :: 3.7",\n         "Topic :: Software Development :: Libraries :: Python Modules",\n         "License :: OSI Approved :: BSD License",\n     ],\n'

Repository: plone.rfc822


Branch: refs/heads/master
Date: 2018-10-17T11:30:37+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.rfc822/commit/b27b0ca586da29577719714b04517ff3bd974214

Merge pull request #6 from plone/jensens-overhaul-py3

Complete overhaul for Python 2/3 compat

Files changed:
M CHANGES.rst
M README.rst
M plone/rfc822/_utils.py
M plone/rfc822/configure.zcml
M plone/rfc822/defaultfields.py
M plone/rfc822/fields.rst
M plone/rfc822/interfaces.py
M plone/rfc822/message.rst
M plone/rfc822/tests.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex fdee7a0..2feb024 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -1,16 +1,31 @@\n Changelog\n =========\n \n-1.1.5 (unreleased)\n-------------------\n+2.0.0b1 (unreleased)\n+--------------------\n \n Breaking changes:\n \n-- *add item here*\n+- Deprecate ``renderMessage(message)``,\n+  use stdlibs ``message.as_string()`` from ``email.message.Message`` class instead.\n+  [jensens]\n+\n+- Newline handling in MIME-headers: ``\\n`` are now escaped explicit.\n+  This follows RFC2822 section 3.2.2.\n+  [jensens]\n+\n+- Drop support of Python 2.6\n+  [jensens]\n \n New features:\n \n-- *add item here*\n+- ``constructMessage`` now handles base64 encoding automatically for all marshallers,\n+  where ``marshaler.ascii`` is ``False`` and ``marshaler.getContentType`` is ``None``.\n+  [jensens]\n+\n+- Support for Python 3+\n+  Also big code overhaul included.\n+  [jensens]\n \n Bug fixes:\n \ndiff --git a/README.rst b/README.rst\nindex a7198af..a8dbfa4 100644\n--- a/README.rst\n+++ b/README.rst\n@@ -1,68 +1,64 @@\n Introduction\n ============\n \n-This package provides primitives for turning content objects described by\n-``zope.schema`` fields into RFC (2)822 style messages, as managed by the\n-Python standard library\'s ``email`` module.\n+This package provides primitives for turning content objects described by ``zope.schema`` fields into RFC (2)822 style messages.\n+It utilizes the Python standard library\'s ``email`` module.\n \n It consists of:\n \n-* A marker interface ``IPrimaryField`` which can be used to indicate the\n-  primary field of a schema. The primary field will be used as the message\n-  body.\n-* An interface ``IFieldMarshaler`` which describes marshalers that convert\n-  to and from strings suitable for encoding into an RFC 2822 style message.\n-  These are adapters on ``(context, field)``, where ``context`` is the content\n-  object and ``field`` is the schema field instance.\n-* Default implementations of ``IFieldMarshaler`` for the standard fields in\n-  the ``zope.schema`` package.\n-* Helper methods to construct messages from one or more schemata or a list of\n-  fields, and to parse a message and update a context object accordingly.\n-\n-The helper methods are described by ``plone.rfc822.interfaces.IMessageAPI``,\n-and are importable directly from the ``plone.rfc822`` package::\n+* A marker interface ``IPrimaryField`` which can be used to indicate the primary field of a schema.\n+  The primary field will be used as the message body.\n+  If there are more than one field marked as primary, the body is turned in a MIME multipart message.\n+* An interface ``IFieldMarshaler`` which describes marshalers that convert to and from strings suitable for encoding into an RFC 2822 style message.\n+  These are multi-adapters on ``(context, field)``.\n+  ``context`` is the content object and ``field`` is the schema field instance.\n+* Default implementations of ``IFieldMarshaler`` for the standard fields in the ``zope.schema`` package.\n+* Helper methods to construct messages from one or more schemata or a list of fields, and to parse a message and update a context object accordingly.\n+\n+The helper methods are described by ``plone.rfc822.interfaces.IMessageAPI``.\n+They are importable directly from the ``plone.rfc822`` package::\n \n     def constructMessageFromSchema(context, schema, charset=\'utf-8\'):\n         """Convenience method which calls ``constructMessage()`` with all the\n         fields, in order, of the given schema interface\n         """\n-    \n+\n     def constructMessageFromSchemata(context, schemata, charset=\'utf-8\'):\n         """Convenience method which calls ``constructMessage()`` with all the\n         fields, in order, of all the given schemata (a sequence of schema\n         interfaces).\n         """\n-    \n+\n     def constructMessage(context, fields, charset=\'utf-8\'):\n         """Helper method to construct a message.\n-    \n+\n         ``context`` is a content object.\n-    \n+\n         ``fields`` is a sequence of (name, field) pairs for the fields which make\n         up the message. This can be obtained from zope.schema.getFieldsInOrder,\n         for example.\n-    \n+\n         ``charset`` is the message charset.\n-    \n+\n         The message body will be constructed from the primary field, i.e. the\n         field which is marked with ``IPrimaryField``. If no such field exists,\n         the message will have no body. If multiple fields exist, the message will\n         be a multipart message. Otherwise, it will contain a scalar string\n         payload.\n-    \n+\n         A field will be ignored if ``(context, field)`` cannot be multi-adapted\n         to ``IFieldMarshaler``, or if the ``marshal()`` method returns None.\n         """\n-    \n+\n     def renderMessage(message, mangleFromHeader=False):\n         """Render a message to a string\n         """\n-        \n+\n     def initializeObjectFromSchema(context, schema, message, defaultCharset=\'utf-8\'):\n         """Convenience method which calls ``initializeObject()`` with all the\n         fields, in order, of the given schema interface\n         """\n-    \n+\n     def initializeObjectFromSchemata(context, schemata, message, defaultCharset=\'utf-8\'):\n         """Convenience method which calls ``initializeObject()`` with all the\n         fields in order, of all the given schemata (a sequence of schema\n@@ -71,55 +67,46 @@ and are importable directly from the ``plone.rfc822`` package::\n \n     def initializeObject(context, fields, message, defaultCharset=\'utf-8\'):\n         """Initialise an object from a message.\n-    \n+\n         ``context`` is the content object to initialise.\n-    \n+\n         ``fields`` is a sequence of (name, field) pairs for the fields which make\n         up the message. This can be obtained from zope.schema.getFieldsInOrder,\n         for example.\n-    \n+\n         ``message`` is a ``Message`` object.\n-    \n+\n         ``defaultCharset`` is the default character set to use.\n-    \n+\n         If the message is a multipart message, the primary fields will be read\n         in order.\n         """\n \n The message format used adheres to the following rules:\n \n-* All non-primary fields are represented as headers. The header name is taken\n-  from the field name, and the value is an encoded string as returned by the\n-  ``marshal()`` method of the appropriate ``IFieldMarshal`` multi-adapter.\n+* All non-primary fields are represented as headers.\n+  The header name is taken from the field name.\n+  The value is an encoded string as returned by the ``marshal()`` method of the appropriate ``IFieldMarshal`` multi-adapter.\n * If no ``IFieldMarshaler`` adapter can be found, the header is ignored.\n-* Similarly, if no fields are found for a given header when parsing a message,\n-  the header is ignored.\n-* If there is a single primary field, the message has a string payload, which\n-  is the marshalled value of the primary field. In this case, the\n-  ``Content-Type`` header of the message will be obtained from the primary\n-  field\'s marshaler.\n-* If there are multiple primary fields, each is encoded into its own message,\n-  each with its own ``Content-Type`` header. The outer message will have a\n-  content type of ``multipart/mixed`` and headers for other fields.\n-* A ``ValueError`` error is raised if a message is being parsed which has\n-  more or fewer parts than there are primary fields.\n+* Similarly, if no fields are found for a given header when parsing a message, the header is ignored.\n+* If there is a single primary field, the message has a string payload, which is the marshalled value of the primary field.\n+  In this case, the ``Content-Type`` header of the message will be obtained from the primary field\'s marshaler.\n+* If there are multiple primary fields, each is encoded into its own message, each with its own ``Content-Type`` header.\n+  The outer message will have a content type of ``multipart/mixed`` and headers for other fields.\n+* A ``ValueError`` error is raised if a message is being parsed which has more or fewer parts than there are primary fields.\n * Duplicate field names are allowed, and will be encoded as duplicate headers.\n-  When parsing a message, there needs to be one field per header. That is, if\n-  a message contains two headers with the name \'foo\', the list of field name/\n-  instance pairs passed to the ``initializeObject()`` method should contain\n-  two pairs with the name \'foo\'. The first field will be used for the first\n-  header value, the second field will be used for the second header value.\n+  When parsing a message, there needs to be one field per header.\n+  That is, if a message contains two headers with the name \'foo\',\n+  the list of field name/ instance pairs passed to the ``initializeObject()`` method should contain two pairs with the name \'foo\'.\n+  The first field will be used for the first header value, the second field will be used for the second header value.\n   If a third \'foo\' header appears, it will be ignored.\n-* Since message headers are always lowercase, field names will be matched\n-  case-insensitively when parsing a message.\n+* Since message headers are always lowercase, field names will be matched case-insensitively when parsing a message.\n \n Supermodel handler\n ------------------\n \n-If ``plone.supermodel`` is installed, this package will register a namespace\n-handler for the ``marshal`` namespace, with the URI\n-``http://namespaces.plone.org/supermodel/marshal``. This can be used to mark\n-a field as the primary field::\n+If ``plone.supermodel`` is installed, this package  will register a namespace handler for the ``marshal`` namespace, with the URI ``http://namespaces.plone.org/supermodel/marshal``.\n+This can be used to mark a field as the primary field::\n \n     <model xmlns="http://namespaces.plone.org/supermodel/schema"\n            xmlns:marshal="http://namespaces.plone.org/supermodel/marshal">\n@@ -131,11 +118,32 @@ a field as the primary field::\n     </model>\n \n ``plone.supermodel`` may be installed as a dependency using the extra\n-``[supermodel]``, but this is probably only useful for running the tests. If\n-the package is not installed, the handler will not be ignored.\n+``[supermodel]``, but this is probably only useful for running the tests.\n+If the package is not installed, the handler will not be ignored.\n \n License note\n ------------\n \n-This package is released under the BSD license. Contributors, please do not\n-add dependencies on GPL code.\n+This package is released under the BSD license.\n+Contributors, please do not add dependencies on GPL code.\n+\n+Issue tracker\n+-------------\n+\n+Please report issues via the `Plone issue tracker`_.\n+\n+.. _`Plone issue tracker`: https://github.com/plone/plone.rfc822/issues\n+\n+Support\n+-------\n+\n+Dexterity use questions may be answered via `Plone\'s support channels`_.\n+\n+.. _`Plone\'s support channels`: http://plone.org/support\n+\n+Contributing\n+------------\n+\n+Sources are at the `Plone code repository hosted at Github <https://github.com/plone/plone.rfc822>`_.\n+\n+Contributors please read the document `Process for Plone core\'s development <http://docs.plone.org/develop/plone-coredev/index.html>`_\ndiff --git a/plone/rfc822/_utils.py b/plone/rfc822/_utils.py\nindex b38bef1..403c8b4 100644\n--- a/plone/rfc822/_utils.py\n+++ b/plone/rfc822/_utils.py\n@@ -5,159 +5,159 @@\n \n See interfaces.py for details.\n """\n-\n-from email.generator import Generator\n+from email.encoders import encode_base64\n from email.header import decode_header\n from email.header import Header\n from email.message import Message\n-from io import BytesIO\n from plone.rfc822.interfaces import IFieldMarshaler\n from plone.rfc822.interfaces import IPrimaryField\n from zope.component import queryMultiAdapter\n+from zope.deprecation import deprecate\n from zope.schema import getFieldsInOrder\n \n import logging\n import six\n \n \n-LOG = logging.getLogger(\'plone.rfc822\')\n+logger = logging.getLogger("plone.rfc822")\n+\n+\n+def safe_native_string(value, encoding=\'utf8\'):\n+    \'\'\' Try to convert value into a native string\n+    \'\'\'\n+    if six.PY2:\n+        if isinstance(value, six.text_type):\n+            return value.encode(encoding)\n+    elif isinstance(value, six.binary_type):\n+        return value.decode(encoding)\n+    if not isinstance(value, str):\n+        raise ValueError(\'Cannot convert %r into a native string\' % value)\n+    return value\n \n \n-def constructMessageFromSchema(context, schema, charset=\'utf-8\'):\n+def constructMessageFromSchema(context, schema, charset="utf-8"):\n     return constructMessage(context, getFieldsInOrder(schema), charset)\n \n \n-def constructMessageFromSchemata(context, schemata, charset=\'utf-8\'):\n+def constructMessageFromSchemata(context, schemata, charset="utf-8"):\n     fields = []\n     for schema in schemata:\n         fields.extend(getFieldsInOrder(schema))\n     return constructMessage(context, fields, charset)\n \n \n-def constructMessage(context, fields, charset=\'utf-8\'):\n-    msg = Message()\n+def _add_payload_to_message(context, msg, primary, charset):\n+    """If there\'s a single primary field, we have a non-multipart message with\n+    a string payload. Otherwise, we return a multipart message\n \n-    primary = []\n+    """\n+    is_multipart = len(primary) > 1\n+    if is_multipart:\n+        msg.set_type("multipart/mixed")\n+\n+    for name, field in primary:\n+        if is_multipart:\n+            payload = Message()\n+        else:\n+            payload = msg\n+        marshaler = queryMultiAdapter((context, field), IFieldMarshaler)\n+        if marshaler is None:\n+            continue\n+\n+        value = marshaler.marshal(charset, primary=True)\n+        if value is None:\n+            continue\n+\n+        content_type = marshaler.getContentType()\n+        if content_type is not None:\n+            payload.set_type(content_type)\n+\n+        charset = marshaler.getCharset(charset)\n+        if charset is None and not marshaler.ascii:\n+            # we have real binary data such as images, files, etc.\n+            # encode to base64!\n+            payload.set_payload(value)\n+            encode_base64(payload)\n+        elif charset is not None:\n+            # using set_charset() would also add transfer encoding to\n+            # quoted-printable, which we don\'t want here.\n+            # for unicodedata, we keep it as-is, so: binary\n+            # payload[\'Content-Transfer-Encoding\'] = "BINARY"\n+            payload.set_param("charset", charset)\n+            value = safe_native_string(value, charset)\n+            payload.set_payload(value)\n+        else:\n+            value = safe_native_string(value)\n+            payload.set_payload(value)\n+\n+        marshaler.postProcessMessage(payload)\n+        if is_multipart:\n+            msg.attach(payload)\n+\n+\n+def constructMessage(context, fields, charset="utf-8"):\n+    msg = Message()\n+    primaries = []\n \n     # First get all headers, storing primary fields for later\n     for name, field in fields:\n-\n+        value = \'\'\n         if IPrimaryField.providedBy(field):\n-            primary.append((name, field,))\n+            primaries.append((name, field))\n             continue\n-\n-        marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n+        marshaler = queryMultiAdapter((context, field), IFieldMarshaler)\n         if marshaler is None:\n-            LOG.debug("No marshaler found for field %s of %s" %\n-                      (name, repr(context)))\n+            logger.debug(\n+                "No marshaler found for field {0} of {1}".format(\n+                    name, repr(context)\n+                )\n+            )\n             continue\n-\n         try:\n             value = marshaler.marshal(charset, primary=False)\n         except ValueError as e:\n-            LOG.debug("Marshaling of %s for %s failed: %s" %\n-                      (name, repr(context), str(e)))\n+            logger.debug(\n+                "Marshaling of {0} for {1} failed: {2}".format(\n+                    name, repr(context), str(e)\n+                )\n+            )\n             continue\n-\n         if value is None:\n-            value = b\'\'\n-        elif not isinstance(value, six.binary_type):\n-            raise ValueError(\n-                "Marshaler for field %s did not return bytes" % name)\n-\n-        if marshaler.ascii and b\'\\n\' not in value:\n+            value = ""\n+        # Enforce native strings\n+        value = safe_native_string(value)\n+        if marshaler.ascii and "\\n" not in value:\n             msg[name] = value\n         else:\n+            # see https://tools.ietf.org/html/rfc2822#section-3.2.2\n+            if \'\\n\' in value:\n+                value = value.replace("\\n", r"\\n")\n             msg[name] = Header(value, charset)\n \n     # Then deal with the primary field\n-\n-    # If there\'s a single primary field, we have a non-multipart message with\n-    # a string payload\n-\n-    if len(primary) == 1:\n-        name, field = primary[0]\n-\n-        marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n-        if marshaler is not None:\n-            contentType = marshaler.getContentType()\n-            payloadCharset = marshaler.getCharset(charset)\n-\n-            if contentType is not None:\n-                msg.set_type(contentType)\n-\n-            if payloadCharset is not None:\n-                # using set_charset() would also add transfer encoding,\n-                # which we don\'t want to do always\n-                msg.set_param(\'charset\', payloadCharset)\n-\n-            value = marshaler.marshal(charset, primary=True)\n-            if value is not None:\n-                msg.set_payload(value)\n-\n-            marshaler.postProcessMessage(msg)\n-\n-    # Otherwise, we return a multipart message\n-\n-    elif len(primary) > 1:\n-        msg.set_type(\'multipart/mixed\')\n-\n-        for name, field in primary:\n-\n-            marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n-            if marshaler is None:\n-                continue\n-\n-            payload = Message()\n-            attach = False\n-\n-            contentType = marshaler.getContentType()\n-            payloadCharset = marshaler.getCharset(charset)\n-\n-            if contentType is not None:\n-                payload.set_type(contentType)\n-                attach = True\n-            if payloadCharset is not None:\n-                # using set_charset() would also add transfer encoding,\n-                # which we don\'t want to do always\n-                payload.set_param(\'charset\', payloadCharset)\n-                attach = True\n-\n-            value = marshaler.marshal(charset, primary=True)\n-\n-            if value is not None:\n-                payload.set_payload(value)\n-                attach = True\n-\n-            if attach:\n-                marshaler.postProcessMessage(payload)\n-                msg.attach(payload)\n+    _add_payload_to_message(context, msg, primaries, charset)\n \n     return msg\n \n \n+@deprecate(\n+    "Use \'message.as_string()\' from \'email.message.Message\' class instead."\n+)\n def renderMessage(message, mangleFromHeader=False):\n-    out = BytesIO()\n-    generator = Generator(out, mangle_from_=mangleFromHeader)\n-    generator.flatten(message)\n-    return out.getvalue()\n+    # to be removed in a 3.x series\n+    return message.as_string(mangleFromHeader)\n \n \n def initializeObjectFromSchema(\n-    context,\n-    schema,\n-    message,\n-    defaultCharset=\'utf-8\'\n+    context, schema, message, defaultCharset="utf-8"\n ):\n-    initializeObject(context, getFieldsInOrder(\n-        schema), message, defaultCharset)\n+    initializeObject(\n+        context, getFieldsInOrder(schema), message, defaultCharset\n+    )\n \n \n def initializeObjectFromSchemata(\n-    context,\n-    schemata,\n-    message,\n-    defaultCharset=\'utf-8\'\n+    context, schemata, message, defaultCharset="utf-8"\n ):\n     """Convenience method which calls ``initializeObject()`` with all the\n     fields in order, of all the given schemata (a sequence of schema\n@@ -170,152 +170,128 @@ def initializeObjectFromSchemata(\n     return initializeObject(context, fields, message, defaultCharset)\n \n \n-def initializeObject(context, fields, message, defaultCharset=\'utf-8\'):\n-    contentType = message.get_content_type()\n+def initializeObject(context, fields, message, defaultCharset="utf-8"):\n+    content_type = message.get_content_type()\n \n     charset = message.get_charset()\n     if charset is None:\n-        charset = message.get_param(\'charset\')\n+        charset = message.get_param("charset")\n     if charset is not None:\n         charset = str(charset)\n     else:\n         charset = defaultCharset\n \n-    headerFields = {}\n+    header_fields = {}\n     primary = []\n-\n     for name, field in fields:\n         if IPrimaryField.providedBy(field):\n             primary.append((name, field))\n-        else:\n-            headerFields.setdefault(name.lower(), []).append(field)\n+            continue\n+        header_fields.setdefault(name.lower(), []).append(field)\n \n     # Demarshal each header\n-\n     for name, value in message.items():\n-\n         name = name.lower()\n-        fieldset = headerFields.get(name, None)\n+        fieldset = header_fields.get(name, None)\n         if fieldset is None or len(fieldset) == 0:\n-            LOG.debug("No matching field found for header %s" % name)\n+            logger.debug("No matching field found for header {0}".format(name))\n             continue\n-\n         field = fieldset.pop(0)\n-\n-        marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n+        marshaler = queryMultiAdapter((context, field), IFieldMarshaler)\n         if marshaler is None:\n-            LOG.debug("No marshaler found for field %s of %s" %\n-                      (name, repr(context)))\n+            logger.debug(\n+                "No marshaler found for field {0} of {1}".format(\n+                    name, repr(context)\n+                )\n+            )\n             continue\n-\n-        headerValue, headerCharset = decode_header(value)[0]\n-        if headerCharset is None:\n-            headerCharset = charset\n-\n-        # MIME messages always use CRLF. For headers, we\'re probably safer with\n-        # \\n\n-        headerValue = headerValue.replace(\'\\r\\n\', \'\\n\')\n-\n+        header_value, header_charset = decode_header(value)[0]\n+        if header_charset is None:\n+            header_charset = charset\n+\n+        # MIME messages always use CRLF.\n+        # For headers, we\'re probably safer with \\n\n+        #\n+        # Also, replace escaped Newlines, for details see\n+        # https://tools.ietf.org/html/rfc2822#section-3.2.2\n+        if isinstance(header_value, six.binary_type):\n+            header_value = header_value.replace(b"\\r\\n", b"\\n")\n+            header_value = header_value.replace(b"\\\\n", b"\\n")\n+        else:\n+            header_value = header_value.replace("\\r\\n", "\\n")\n+            header_value = header_value.replace(r"\\\\n", "\\n")\n         try:\n             marshaler.demarshal(\n-                headerValue,\n+                header_value,\n                 message=message,\n-                charset=headerCharset,\n-                contentType=contentType,\n-                primary=False\n+                charset=header_charset,\n+                contentType=content_type,\n+                primary=False,\n             )\n         except ValueError as e:\n             # interface allows demarshal() to raise ValueError to indicate\n             # marshalling failed\n-            LOG.debug("Demarshalling of %s for %s failed: %s" %\n-                      (name, repr(context), str(e)))\n+            logger.debug(\n+                "Demarshalling of {0} for {1} failed: {2}".format(\n+                    name, repr(context), str(e)\n+                )\n+            )\n             continue\n \n-    # Then demarshal the primary field\n-\n-    payload = message.get_payload()\n+    # Then demarshal the primary field(s)\n+    payloads = message.get_payload()\n \n     # do nothing if we don\'t have a payload\n-    if not payload:\n+    if not payloads:\n         return\n \n-    # A single string payload\n-    if isinstance(payload, str):\n+    # A single payload is a string, multiparts are lists\n+    if isinstance(payloads, str):\n         if len(primary) != 1:\n             raise ValueError(\n-                \'Got a single string payload for message, but no primary \'\n-                \'fields found for %s\' % repr(context))\n+                "Got a single string payload for message, but no primary "\n+                "fields found for %s" % repr(context)\n+            )\n+        payloads = [message]\n+\n+    if len(payloads) != len(primary):\n+        raise ValueError(\n+            "Got %d payloads for message, but %s primary fields "\n+            "found for %s" % (len(payloads), len(primary), repr(context))\n+        )\n+    for idx, payload in enumerate(payloads):\n+        name, field = primary[idx]\n+        payload_content_type = payload.get_content_type()\n+        charset = message.get_charset()\n+        if charset is not None:\n+            charset = str(charset)\n         else:\n-            name, field = primary[0]\n-\n-            marshaler = queryMultiAdapter((context, field,), IFieldMarshaler)\n-            if marshaler is None:\n-                LOG.debug("No marshaler found for primary field %s of %s" %\n-                          (name, repr(context),))\n-            else:\n-                payloadValue = message.get_payload(decode=True)\n-                payloadCharset = message.get_content_charset(charset)\n-                try:\n-                    marshaler.demarshal(\n-                        payloadValue,\n-                        message=message,\n-                        charset=payloadCharset,\n-                        contentType=contentType,\n-                        primary=True\n-                    )\n-                except ValueError as e:\n-                    # interface allows demarshal() to raise ValueError to\n-                    # indicate marshalling failed\n-                    LOG.debug("Demarshalling of %s for %s failed: %s" %\n-                              (name, repr(context), str(e)))\n-\n-    # Multiple payloads\n-    elif isinstance(payload, (list, tuple,)):\n-        if len(payload) != len(primary):\n-            raise ValueError(\n-                \'Got %d payloads for message, but %s primary fields \'\n-                \'found for %s\' % (\n-                    len(payload),\n-                    len(primary),\n-                    repr(context),\n+            charset = "utf-8"\n+\n+        marshaler = queryMultiAdapter((context, field), IFieldMarshaler)\n+        if marshaler is None:\n+            logger.debug(\n+                "No marshaler found for primary field {0} of {0}".format(\n+                    name, repr(context)\n                 )\n             )\n-        else:\n-            for idx, msg in enumerate(payload):\n-                name, field = primary[idx]\n-\n-                contentType = msg.get_content_type()\n-\n-                charset = message.get_charset()\n-                if charset is not None:\n-                    charset = str(charset)\n-                else:\n-                    charset = \'utf-8\'\n-\n-                marshaler = queryMultiAdapter(\n-                    (context, field,), IFieldMarshaler)\n-                if marshaler is None:\n-                    LOG.debug(\n-                        \'No marshaler found for primary field %s of %s\' % (\n-                            name,\n-                            repr(context),\n-                        )\n-                    )\n-                    continue\n-\n-                payloadValue = msg.get_payload(decode=True)\n-                payloadCharset = msg.get_content_charset(charset)\n-                try:\n-                    marshaler.demarshal(\n-                        payloadValue,\n-                        message=msg,\n-                        charset=payloadCharset,\n-                        contentType=contentType,\n-                        primary=True\n-                    )\n-                except ValueError as e:\n-                    # interface allows demarshal() to raise ValueError to\n-                    # indicate marshalling failed\n-                    LOG.debug("Demarshalling of %s for %s failed: %s" %\n-                              (name, repr(context), str(e)))\n-                    continue\n+            continue\n+        payload_value = payload.get_payload(decode=True)\n+        payload_charset = payload.get_content_charset(charset)\n+        try:\n+            marshaler.demarshal(\n+                payload_value,\n+                message=payload,\n+                charset=payload_charset,\n+                contentType=payload_content_type,\n+                primary=True,\n+            )\n+        except ValueError as e:\n+            # interface allows demarshal() to raise ValueError to\n+            # indicate marshalling failed\n+            logger.debug(\n+                "Demarshalling of {0} for {1} failed: {2}".format(\n+                    name, repr(context), str(e)\n+                )\n+            )\n+            continue\ndiff --git a/plone/rfc822/configure.zcml b/plone/rfc822/configure.zcml\nindex 15f502c..2397069 100644\n--- a/plone/rfc822/configure.zcml\n+++ b/plone/rfc822/configure.zcml\n@@ -3,26 +3,42 @@\n     xmlns:five="http://namespaces.zope.org/five"\n     xmlns:zcml="http://namespaces.zope.org/zcml"\n     i18n_domain="plone.rfc822">\n-    \n+\n     <!-- Standard IFromUnicode marshaler -->\n     <adapter factory=".defaultfields.UnicodeFieldMarshaler" />\n-    \n+\n     <!-- Text, TextLine, Password, SourceText may be ASCII safe -->\n     <adapter\n-        for="* zope.schema.interfaces.IText"\n+        for="* zope.schema.interfaces.INativeString"\n         factory=".defaultfields.UnicodeValueFieldMarshaler"\n         />\n+    <!-- ASCII Field marshaller -->\n+    <adapter\n+        for="* zope.schema.interfaces.IASCII"\n+        factory=".defaultfields.ASCIISafeFieldMarshaler"\n+        />\n+    <adapter\n+        for="* zope.schema.interfaces.IASCIILine"\n+        factory=".defaultfields.ASCIISafeFieldMarshaler"\n+        />\n \n     <!-- Bool and Choice omit to declare that they supports IFromUnicode in zope.schema 3.3 -->\n     <adapter\n         for="* zope.schema.interfaces.IBool"\n         factory=".defaultfields.ASCIISafeFieldMarshaler"\n         />\n+    <!-- We need this as a workaround for this issue:\n+      https://github.com/zopefoundation/zope.schema/issues/80\n+    -->\n+    <adapter\n+        for="* zope.schema._bootstrapfields.Bool"\n+        factory=".defaultfields.ASCIISafeFieldMarshaler"\n+        />\n     <adapter\n         for="* zope.schema.interfaces.IChoice"\n         factory=".defaultfields.UnicodeValueFieldMarshaler"\n         />\n-    \n+\n     <!-- Int, Float, and Decimal are ASCII safe -->\n     <adapter\n         for="* zope.schema.interfaces.IInt"\n@@ -36,7 +52,7 @@\n         for="* zope.schema.interfaces.IDecimal"\n         factory=".defaultfields.ASCIISafeFieldMarshaler"\n         />\n-        \n+\n     <!-- Somehow this is necessary because these are in _bootstrapfields -->\n     <adapter\n         for="* zope.schema.Text"\n@@ -54,13 +70,13 @@\n         for="* zope.schema.Int"\n         factory=".defaultfields.ASCIISafeFieldMarshaler"\n         />\n-        \n+\n     <adapter factory=".defaultfields.BytesFieldMarshaler" />\n     <adapter factory=".defaultfields.DatetimeMarshaler" />\n     <adapter factory=".defaultfields.DateMarshaler" />\n     <adapter factory=".defaultfields.TimedeltaMarshaler" />\n     <adapter factory=".defaultfields.CollectionMarshaler" />\n-    \n+\n     <!-- Configure plone.supermodel handler if available -->\n     <utility zcml:condition="installed plone.supermodel"\n         factory=".supermodel.PrimaryFieldMetadataHandler"\ndiff --git a/plone/rfc822/defaultfields.py b/plone/rfc822/defaultfields.py\nindex 7792899..250a6b2 100644\n--- a/plone/rfc822/defaultfields.py\n+++ b/plone/rfc822/defaultfields.py\n@@ -31,9 +31,8 @@\n * InterfaceField - stores Interface\n * Dict - stores a dict\n """\n-\n from plone.rfc822.interfaces import IFieldMarshaler\n-from zope.component import adapts\n+from zope.component import adapter\n from zope.component import queryMultiAdapter\n from zope.interface import implementer\n from zope.interface import Interface\n@@ -62,15 +61,15 @@ class BaseFieldMarshaler(object):\n     def __init__(self, context, field):\n         self.context = context\n         self.field = field.bind(context)\n-\n         self.instance = context\n         if field.interface is not None:\n             self.instance = field.interface(context, context)\n \n     def marshal(self, charset=\'utf-8\', primary=False):\n         value = self._query(_marker)\n-        return None if value is _marker else \\\n-            self.encode(value, charset, primary)\n+        return (\n+            None if value is _marker else self.encode(value, charset, primary)\n+        )\n \n     def demarshal(\n         self,\n@@ -78,12 +77,15 @@ def demarshal(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n-        fieldValue = self.field.missing_value\n+\n         if value:\n             fieldValue = self.decode(\n-                value, message, charset, contentType, primary)\n+                value, message, charset, contentType, primary\n+            )\n+        else:\n+            fieldValue = self.field.missing_value\n         self._set(fieldValue)\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -95,10 +97,11 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n-        raise ValueError("Demarshalling not implemented for %s" %\n-                         repr(self.field))\n+        raise ValueError(\n+            \'Demarshalling not implemented for %s\' % repr(self.field)\n+        )\n \n     def getContentType(self):\n         return None\n@@ -115,18 +118,21 @@ def _query(self, default=None):\n         return self.field.query(self.instance, default)\n \n     def _set(self, value):\n+        if getattr(self.instance, \'marker\', False):\n+            print(self.field.__name__)\n+            print(value)\n+            print(\'-\' * 5)\n         try:\n             self.field.set(self.instance, value)\n         except TypeError as e:\n             raise ValueError(e)\n \n \n+@adapter(Interface, IFromUnicode)\n class UnicodeFieldMarshaler(BaseFieldMarshaler):\n     """Default marshaler for fields that support IFromUnicode\n     """\n \n-    adapts(Interface, IFromUnicode)\n-\n     def encode(self, value, charset=\'utf-8\', primary=False):\n         if value is None:\n             return\n@@ -141,9 +147,12 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n-        unicodeValue = value.decode(charset)\n+        if isinstance(value, six.binary_type):\n+            unicodeValue = value.decode(charset)\n+        else:\n+            unicodeValue = value\n         try:\n             return self.field.fromUnicode(unicodeValue)\n         except Exception as e:\n@@ -160,7 +169,8 @@ class UnicodeValueFieldMarshaler(UnicodeFieldMarshaler):\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n         encoded = super(UnicodeValueFieldMarshaler, self).encode(\n-            value, charset, primary)\n+            value, charset, primary\n+        )\n         if not encoded or max(six.iterbytes(encoded)) < 128:\n             self.ascii = True\n         else:\n@@ -179,13 +189,12 @@ def getCharset(self, default=\'utf-8\'):\n         return None\n \n \n+@adapter(Interface, IBytes)\n class BytesFieldMarshaler(BaseFieldMarshaler):\n     """Default marshaler for IBytes fields and children. These store str\n     objects, so we will attempt to encode them directly.\n     """\n \n-    adapts(Interface, IBytes)\n-\n     ascii = True\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -197,17 +206,16 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         return value\n \n \n+@adapter(Interface, IDatetime)\n class DatetimeMarshaler(BaseFieldMarshaler):\n     """Marshaler for Python datetime values\n     """\n \n-    adapts(Interface, IDatetime)\n-\n     ascii = True\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -221,15 +229,17 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n-        unicodeValue = value.decode(charset)\n+        if isinstance(value, six.binary_type):\n+            value = value.decode(charset)\n         try:\n-            return dateutil.parser.parse(unicodeValue)\n+            return dateutil.parser.parse(value)\n         except Exception as e:\n             raise ValueError(e)\n \n \n+@adapter(Interface, IDate)\n class DateMarshaler(BaseFieldMarshaler):\n     """Marshaler for Python date values.\n \n@@ -238,8 +248,6 @@ class DateMarshaler(BaseFieldMarshaler):\n     information.\n     """\n \n-    adapts(Interface, IDate)\n-\n     ascii = True\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -253,7 +261,7 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         unicodeValue = value.decode(charset)\n         try:\n@@ -262,6 +270,7 @@ def decode(\n             raise ValueError(e)\n \n \n+@adapter(Interface, ITimedelta)\n class TimedeltaMarshaler(BaseFieldMarshaler):\n     """Marshaler for Python timedelta values\n \n@@ -270,8 +279,6 @@ class TimedeltaMarshaler(BaseFieldMarshaler):\n     information.\n     """\n \n-    adapts(Interface, ITimedelta)\n-\n     ascii = True\n \n     def encode(self, value, charset=\'utf-8\', primary=False):\n@@ -285,7 +292,7 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         try:\n             days, seconds, microseconds = [int(v) for v in value.split(":")]\n@@ -294,17 +301,17 @@ def decode(\n             raise ValueError(e)\n \n \n+@adapter(Interface, ICollection)\n class CollectionMarshaler(BaseFieldMarshaler):\n     """Marshaler for collection values\n     """\n \n-    adapts(Interface, ICollection)\n-\n     ascii = False\n \n     def getCharset(self, default=\'utf-8\'):\n         valueTypeMarshaler = queryMultiAdapter(\n-            (self.context, self.field.value_type,), IFieldMarshaler)\n+            (self.context, self.field.value_type), IFieldMarshaler\n+        )\n         if valueTypeMarshaler is None:\n             return None\n         return valueTypeMarshaler.getCharset(default)\n@@ -314,7 +321,8 @@ def encode(self, value, charset=\'utf-8\', primary=False):\n             return None\n \n         valueTypeMarshaler = queryMultiAdapter(\n-            (self.context, self.field.value_type,), IFieldMarshaler)\n+            (self.context, self.field.value_type), IFieldMarshaler\n+        )\n         if valueTypeMarshaler is None:\n             return None\n \n@@ -322,7 +330,8 @@ def encode(self, value, charset=\'utf-8\', primary=False):\n         value_lines = []\n         for item in value:\n             marshaledValue = valueTypeMarshaler.encode(\n-                item, charset=charset, primary=primary)\n+                item, charset=charset, primary=primary\n+            )\n             if marshaledValue is None:\n                 marshaledValue = \'\'\n             value_lines.append(marshaledValue)\n@@ -330,8 +339,10 @@ def encode(self, value, charset=\'utf-8\', primary=False):\n                 ascii = False\n \n         self.ascii = ascii\n-\n-        return \'||\'.join(value_lines)\n+        if value_lines and isinstance(value_lines[0], six.binary_type):\n+            return b\'||\'.join(value_lines)\n+        else:\n+            return \'||\'.join(value_lines)\n \n     def decode(\n         self,\n@@ -339,22 +350,30 @@ def decode(\n         message=None,\n         charset=\'utf-8\',\n         contentType=None,\n-        primary=False\n+        primary=False,\n     ):\n         valueTypeMarshaler = queryMultiAdapter(\n-            (self.context, self.field.value_type,), IFieldMarshaler)\n+            (self.context, self.field.value_type), IFieldMarshaler\n+        )\n         if valueTypeMarshaler is None:\n-            raise ValueError("Cannot demarshal value type %s" %\n-                             repr(self.field.value_type))\n+            raise ValueError(\n+                \'Cannot demarshal value type %s\' % repr(self.field.value_type)\n+            )\n \n         listValue = []\n-\n-        for line in value.split(\'||\'):\n-            listValue.append(valueTypeMarshaler.decode(\n-                line, message, charset, contentType, primary))\n+        if isinstance(value, six.binary_type):\n+            lines = value.split(b\'||\')\n+        else:\n+            lines = value.split(\'||\')\n+        for line in lines:\n+            listValue.append(\n+                valueTypeMarshaler.decode(\n+                    line, message, charset, contentType, primary\n+                )\n+            )\n \n         sequenceType = self.field._type\n-        if isinstance(sequenceType, (list, tuple,)):\n+        if isinstance(sequenceType, (list, tuple)):\n             sequenceType = sequenceType[-1]\n \n         return sequenceType(listValue)\ndiff --git a/plone/rfc822/fields.rst b/plone/rfc822/fields.rst\nindex 2bd430c..e656445 100644\n--- a/plone/rfc822/fields.rst\n+++ b/plone/rfc822/fields.rst\n@@ -3,7 +3,7 @@ Field marshaler tests\n \n This test exercises the various standard field marshalers.\n \n-First, we load the package\'s configuration:\n+First, we load the package\'s configuration::\n \n     >>> configuration = b"""\\\n     ... <configure\n@@ -23,7 +23,7 @@ First, we load the package\'s configuration:\n     >>> xmlconfig.xmlconfig(BytesIO(configuration))\n \n Next, we\'ll create an interface which contains an instance of every field\n-we support.\n+we support::\n \n     >>> from zope.interface import Interface\n     >>> from zope import schema\n@@ -58,7 +58,7 @@ we support.\n     ...     _set = schema.Set(value_type=schema.Bool())\n     ...     _frozenset = schema.FrozenSet(value_type=schema.Timedelta())\n \n-This interface is implemented by a the following class:\n+This interface is implemented by a the following class::\n \n     >>> from decimal import Decimal\n     >>> from zope.interface import implementer\n@@ -74,10 +74,10 @@ This interface is implemented by a the following class:\n     ...     _password2 = u"password" # ascii safe\n     ...     _bytes = \'bytes\'\n     ...     _bytesLine = \'bytesline\'\n-    ...     _ascii = \'ascii\'\n-    ...     _asciiLine = \'asciiline\'\n-    ...     _uri = \'http://plone.org\'\n-    ...     _id = \'some.id\'\n+    ...     _ascii = u\'ascii\'\n+    ...     _asciiLine = u\'asciiline\'\n+    ...     _uri = u\'http://plone.org\'\n+    ...     _id = u\'some.id\'\n     ...     _dottedName = \'dotted.name\'\n     ...     _bool = True\n     ...     _int = long(-10) if six.PY2 else -10\n@@ -96,7 +96,7 @@ This interface is implemented by a the following class:\n     >>> t = TestContent()\n \n We can now look up the marshaler for each one and test the marshalling and\n-extraction methods.\n+extraction methods::\n \n     >>> from zope.component import getMultiAdapter\n     >>> from plone.rfc822.interfaces import IFieldMarshaler\n@@ -113,11 +113,13 @@ Notes:\n Text\n ----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_text\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'text\\xc3\\x98\'\n+    \'text\\xc3\\x98\'\n     >>> marshaler.decode(b\'text\\xc3\\x98\')\n-    u\'text\\xd8\'\n+    \'text\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -126,13 +128,13 @@ Text\n     False\n \n Text field types and derivatives will return True for the ``ascii`` property\n-if the field value is within the ascii range.\n+if the field value is within the ascii range::\n \n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_text2\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'text\'\n+    \'text\'\n     >>> marshaler.decode(b\'text\\xc3\\x98\')\n-    u\'text\\xd8\'\n+    \'text\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -143,11 +145,13 @@ if the field value is within the ascii range.\n TextLine\n --------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_textLine\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'textline\\xc3\\x98\'\n+    \'textline\\xc3\\x98\'\n     >>> marshaler.decode(b\'textline\\xc3\\x98\')\n-    u\'textline\\xd8\'\n+    \'textline\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -158,11 +162,13 @@ TextLine\n Text field types and derivatives will return True for the ``ascii`` property\n if the field value is within the ascii range.\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_textLine2\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'textline\'\n+    \'textline\'\n     >>> marshaler.decode(b\'textline\\xc3\\x98\')\n-    u\'textline\\xd8\'\n+    \'textline\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -173,11 +179,13 @@ if the field value is within the ascii range.\n Password\n --------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_password\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'password\\xc3\\x98\'\n+    \'password\\xc3\\x98\'\n     >>> marshaler.decode(b\'password\\xc3\\x98\')\n-    u\'password\\xd8\'\n+    \'password\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -188,11 +196,13 @@ Password\n Text field types and derivatives will return True for the ``ascii`` property\n if the field value is within the ascii range.\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_password2\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'password\'\n+    \'password\'\n     >>> marshaler.decode(b\'password\\xc3\\x98\')\n-    u\'password\\xd8\'\n+    \'password\\xd8\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -203,11 +213,13 @@ if the field value is within the ascii range.\n Bytes\n -----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_bytes\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'bytes\'\n     >>> marshaler.decode(b\'bytes\')\n-    b\'bytes\'\n+    \'bytes\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\') is None\n@@ -218,11 +230,13 @@ Bytes\n BytesLine\n ---------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_bytesLine\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'bytesline\'\n     >>> marshaler.decode(b\'bytesline\')\n-    b\'bytesline\'\n+    \'bytesline\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\') is None\n@@ -233,9 +247,14 @@ BytesLine\n ASCII\n -----\n \n+This is an ASCII field which is supposed to store text strings.\n+Note: There is a BytesField which stores b\'foo\' binary string.\n+\n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_ascii\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    b\'ascii\'\n+    \'ascii\'\n     >>> marshaler.decode(b\'ascii\')\n     \'ascii\'\n     >>> marshaler.getContentType() is None\n@@ -248,11 +267,13 @@ ASCII\n ASCIILine\n ---------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_asciiLine\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'asciiline\'\n     >>> marshaler.decode(b\'asciiline\')\n-    b\'asciiline\'\n+    \'asciiline\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\') is None\n@@ -263,6 +284,10 @@ ASCIILine\n URI\n ---\n \n+An URI is in Python 2 based on unicode text, in Python 3 on bytes.\n+\n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_uri\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'http://plone.org\'\n@@ -270,7 +295,11 @@ URI\n     \'http://plone.org\'\n     >>> marshaler.getContentType() is None\n     True\n-    >>> marshaler.getCharset(\'utf-8\') is None\n+    >>> if six.PY2:\n+    ...     expected = None  # its IBytes based\n+    ... else:\n+    ...     expected = \'utf-8\'\n+    >>> marshaler.getCharset(\'utf-8\') == expected\n     True\n     >>> marshaler.ascii\n     True\n@@ -278,21 +307,29 @@ URI\n Id\n --\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_id\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'some.id\'\n     >>> marshaler.decode(b\'some.id\')\n     \'some.id\'\n-    >>> marshaler.getCharset(\'utf-8\') is None\n-    True\n     >>> marshaler.getContentType() is None\n     True\n+    >>> if six.PY2:\n+    ...     expected = None  # its IBytes based\n+    ... else:\n+    ...     expected = \'utf-8\'\n+    >>> marshaler.getCharset(\'utf-8\') == expected\n+    True\n     >>> marshaler.ascii\n     True\n \n DottedName\n ----------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_dottedName\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'dotted.name\'\n@@ -300,7 +337,11 @@ DottedName\n     \'dotted.name\'\n     >>> marshaler.getContentType() is None\n     True\n-    >>> marshaler.getCharset(\'utf-8\') is None\n+    >>> if six.PY2:\n+    ...     expected = None  # its IBytes based\n+    ... else:\n+    ...     expected = \'utf-8\'\n+    >>> marshaler.getCharset(\'utf-8\') == expected\n     True\n     >>> marshaler.ascii\n     True\n@@ -308,6 +349,8 @@ DottedName\n Bool\n ----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_bool\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'True\'\n@@ -329,6 +372,8 @@ Bool\n Int\n ---\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_int\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'-10\'\n@@ -344,6 +389,8 @@ Int\n Float\n -----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_float\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'0.3\'\n@@ -359,6 +406,8 @@ Float\n Decimal\n -------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_decimal\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'5.0\'\n@@ -374,11 +423,13 @@ Decimal\n Choice\n ------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_choice1\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'two\'\n     >>> marshaler.decode(b\'one\')\n-    u\'one\'\n+    \'one\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -390,7 +441,7 @@ Choice\n     >>> marshaler.marshal()\n     \'two\'\n     >>> marshaler.decode(b\'three\')\n-    u\'three\'\n+    \'three\'\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -401,6 +452,8 @@ Choice\n Datetime\n --------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_datetime\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'2009-01-02T15:10:05.000001+01:00\'\n@@ -416,6 +469,8 @@ Datetime\n Date\n ----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_date\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'2008-02-03\'\n@@ -431,11 +486,13 @@ Date\n Timedelta\n ---------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_timedelta\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'3:4:5\'\n-    >>> marshaler.decode(b\'3:4:5\')\n-    datetime.timedelta(3, 4, 5)\n+    >>> marshaler.decode(\'3:4:5\') == datetime.timedelta(3, 4, 5)\n+    True\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\') is None\n@@ -446,11 +503,13 @@ Timedelta\n Tuple\n -----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_tuple\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'one\\xc3\\x98||two\'\n     >>> marshaler.decode(b\'one\\xc3\\x98||two\')\n-    (u\'one\\xd8\', u\'two\')\n+    (\'one\\xd8\', \'two\')\n     >>> marshaler.getContentType() is None\n     True\n     >>> marshaler.getCharset(\'utf-8\')\n@@ -461,6 +520,8 @@ Tuple\n List\n ----\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_list\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     \'three||four\'\n@@ -468,6 +529,8 @@ List\n     [\'three\', \'four\']\n     >>> marshaler.getContentType() is None\n     True\n+\n+    ValueType of the list is ASCIILine!\n     >>> marshaler.getCharset(\'utf-8\') is None\n     True\n     >>> marshaler.ascii\n@@ -476,6 +539,8 @@ List\n Set\n ---\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_set\']), IFieldMarshaler)\n     >>> marshaler.marshal() in (b\'False||True\', b\'True||False\')\n     True\n@@ -491,10 +556,12 @@ Set\n Frozenset\n ---------\n \n+::\n+\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_frozenset\']), IFieldMarshaler)\n-    >>> marshaler.marshal() in (b\'3:4:5||5:4:3\', b\'5:4:3||3:4:5\')\n+    >>> marshaler.marshal() in (\'3:4:5||5:4:3\', \'5:4:3||3:4:5\')\n     True\n-    >>> marshaler.decode(b\'3:4:5||5:4:3\') == frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])\n+    >>> marshaler.decode(\'3:4:5||5:4:3\') == frozenset([datetime.timedelta(3, 4, 5), datetime.timedelta(5, 4, 3)])\n     True\n     >>> marshaler.getContentType() is None\n     True\ndiff --git a/plone/rfc822/interfaces.py b/plone/rfc822/interfaces.py\nindex a2e3e02..cdc09e0 100644\n--- a/plone/rfc822/interfaces.py\n+++ b/plone/rfc822/interfaces.py\n@@ -3,8 +3,6 @@\n from zope.interface import Attribute\n from zope.interface import Interface\n \n-import six\n-\n \n class IPrimaryField(Interface):\n     """Marker interface for the primary field in a schema\n@@ -63,6 +61,8 @@ def constructMessage(context, fields, charset=\'utf-8\'):\n \n     def renderMessage(message, mangleFromHeader=False):\n         """Render a message to a string\n+\n+        DEPRECATED. Use \'message.as_string()\' instead.\n         """\n \n     def initializeObjectFromSchema(\n@@ -219,4 +219,8 @@ def postProcessMessage(message):\n         """This is a chance to perform any post-processing of the message.\n \n         It is only called for primary fields.\n+\n+        Note: Before version 2 of plone.rfc.822 this was used primary for\n+        Base64 encoding of the body. Base64 encoding is handled now by default\n+        in ``constructMessage``.\n         """\ndiff --git a/plone/rfc822/message.rst b/plone/rfc822/message.rst\nindex 4ab8e58..d6beaaf 100644\n--- a/plone/rfc822/message.rst\n+++ b/plone/rfc822/message.rst\n@@ -6,7 +6,7 @@ from a list of schema fields, and to parse a message and initialise an object\n based on its headers and body payload.\n \n Before we begin, let\'s load the default field marshalers and configure\n-annotations, which we will use later in this test.\n+annotations, which we will use later in this test::\n \n     >>> configuration = u"""\\\n     ... <configure\n@@ -21,6 +21,8 @@ annotations, which we will use later in this test.\n     ... </configure>\n     ... """\n \n+::\n+\n     >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n@@ -31,7 +33,7 @@ The primary field\n The message body is assumed to originate from a "primary" field, which is\n indicated via a marker interface.\n \n-To illustrate the pattern, consider the following schema interface:\n+To illustrate the pattern, consider the following schema interface::\n \n     >>> from zope.interface import Interface, alsoProvides\n     >>> from plone.rfc822.interfaces import IPrimaryField\n@@ -44,7 +46,7 @@ To illustrate the pattern, consider the following schema interface:\n     ...     body = schema.Text(title=u"Body text")\n     ...     emptyfield = schema.TextLine(title=u"Empty field", missing_value=u\'missing\')\n \n-The primary field instance is marked like this:\n+The primary field instance is marked like this::\n \n     >>> alsoProvides(ITestContent[\'body\'], IPrimaryField)\n \n@@ -52,43 +54,42 @@ Constructing a message\n ----------------------\n \n Let\'s now say we have an instance providing this interface, which we want to\n-marshal to a message.\n+marshal to a message::\n \n     >>> from zope.interface import implementer\n     >>> @implementer(ITestContent)\n     ... class TestContent(object):\n-    ...     title = u""\n-    ...     description = u""\n-    ...     body = u""\n+    ...     title = ""\n+    ...     description = ""\n+    ...     body = ""\n     ...     emptyfield = None\n \n     >>> content = TestContent()\n-    >>> content.title = u"Test title"\n-    >>> content.description = u"""Test description\n+    >>> content.title = "Test title"\n+    >>> content.description = """T\xc3\xa4st description\n     ... with a newline"""\n-    >>> content.body = u"<p>Test body</p>"\n+    >>> content.body = "<p>Test body</p>"\n \n-We could create a message form this instance and schema like this:\n+We could create a message from this instance and schema like this::\n \n     >>> from plone.rfc822 import constructMessageFromSchema\n     >>> msg = constructMessageFromSchema(content, ITestContent)\n \n-The output looks like this:\n+The output looks like this::\n \n-    >>> from plone.rfc822 import renderMessage\n-    >>> print(renderMessage(msg))\n+    >>> print(msg.as_string())\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     Content-Type: text/plain; charset="utf-8"\n     <BLANKLINE>\n     <p>Test body</p>\n \n-Notice how the non-ASCII header values are UTF-8 encoded. The encoding\n-algorithm is clever enough to only encode the value if it is necessary,\n+Notice how the non-ASCII header values are UTF-8 encoded.\n+The encoding algorithm is clever enough to only encode the value if it is necessary,\n leaving more readable field values otherwise.\n \n-The body here is of the default message type:\n+The body here is of the default message type::\n \n     >>> msg.get_default_type()\n     \'text/plain\'\n@@ -98,12 +99,12 @@ This is because none of the default field types manage a content type.\n The body is also utf-8 encoded, because the primary field specified this\n encoding.\n \n-If we want to use a different content type, we could set it explicitly:\n+If we want to use a different content type, we could set it explicitly::\n \n     >>> msg.set_type(\'text/html\')\n-    >>> print(renderMessage(msg))\n+    >>> print(msg.as_string())\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     MIME-Version: 1.0\n     Content-Type: text/html; charset="utf-8"\n@@ -131,11 +132,10 @@ the ``getContentType()``:\n \n     >>> from plone.rfc822.defaultfields import UnicodeValueFieldMarshaler\n     >>> from zope.schema.interfaces import IText\n-    >>> from zope.component import adapts\n+    >>> from zope.component import adapter\n \n-    >>> class TestBodyMarshaler(UnicodeValueFieldMarshaler):\n-    ...     adapts(ITestContent, IText)\n-    ...\n+    >>> @adapter(ITestContent, IText)\n+    ... class TestBodyMarshaler(UnicodeValueFieldMarshaler):\n     ...     def getContentType(self):\n     ...         return \'text/html\'\n \n@@ -153,9 +153,9 @@ above), or have the marshaler check the field name.\n Let\'s now try again:\n \n     >>> msg = constructMessageFromSchema(content, ITestContent)\n-    >>> print(renderMessage(msg))\n+    >>> print(msg.as_string())\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     MIME-Version: 1.0\n     Content-Type: text/html; charset="utf-8"\n@@ -193,11 +193,13 @@ message.\n     >>> initializeObjectFromSchema(newContent, ITestContent, msg)\n \n     >>> newContent.title\n-    u\'Test title\'\n-    >>> newContent.description\n-    u\'Test description\\nwith a newline\'\n+    \'Test title\'\n+    >>> print(newContent.description)\n+    Test description\n+    with a newline\n+\n     >>> newContent.body\n-    u\'<p>Test body</p>\'\n+    \'<p>Test body</p>\'\n \n We can also consume messages with a transfer encoding and a charset:\n \n@@ -220,16 +222,17 @@ We can also consume messages with a transfer encoding and a charset:\n     >>> initializeObjectFromSchema(newContent, ITestContent, msg)\n \n     >>> newContent.title\n-    u\'Test title\'\n-    >>> newContent.description\n-    u\'Test description\\nwith a newline\'\n+    \'Test title\'\n+    >>> print(newContent.description)\n+    Test description\n+    with a newline\n     >>> newContent.body\n-    u\'<p>Test body</p>\'\n+    \'<p>Test body</p>\'\n \n Note: Empty fields will result in the field\'s ``missing_value`` being used:\n \n     >>> newContent.emptyfield\n-    u\'missing\'\n+    \'missing\'\n \n Handling multiple primary fields and duplicate field names\n ----------------------------------------------------------\n@@ -251,8 +254,8 @@ The annotation storage would look like this:\n \n     >>> from persistent import Persistent\n     >>> @implementer(IPersonalDetails)\n+    ... @adapter(ITestContent)\n     ... class PersonalDetailsAnnotation(Persistent):\n-    ...     adapts(ITestContent)\n     ...\n     ...     def __init__(self):\n     ...         self.description = None\n@@ -293,14 +296,14 @@ Here are the fields it will see:\n \n Let\'s now construct a message. Since we now have two fields called\n ``description``, we will get two headers by that name. Since we have two\n-primary fields, we will get a multipart message with two attachments.\n+primary fields, we will get a multipart message with two attachments::\n \n     >>> from plone.rfc822 import constructMessageFromSchemata\n     >>> msg = constructMessageFromSchemata(content, (ITestContent, IPersonalDetails,))\n-    >>> msgString = renderMessage(msg)\n+    >>> msgString = msg.as_string()\n     >>> print(msgString)\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     description: <p>My description</p>\n     currentAge: 21\n@@ -317,7 +320,9 @@ primary fields, we will get a multipart message with two attachments.\n     Content-Type: text/html; charset="utf-8"\n     <BLANKLINE>\n     <p>My profile</p>\n-    --===============...==--...\n+    --===============...==--\n+    <BLANKLINE>\n+\n \n (Note that we\'ve used ellipses here for the doctest to work with the generated\n boundary string).\n@@ -339,23 +344,24 @@ attachments to the two primary fields:\n     >>> initializeObjectFromSchemata(newContent, [ITestContent, IPersonalDetails], msg)\n \n     >>> newContent.title\n-    u\'Test title\'\n+    \'Test title\'\n \n+    >>> newContent.marker = True\n     >>> newContent.description\n-    u\'Test description\\nwith a newline\'\n+    \'T\\xe4st description\\nwith a newline\'\n \n     >>> newContent.body\n-    u\'<p>Test body</p>\'\n+    \'<p>Test body</p>\'\n \n     >>> newPersonalDetails = IPersonalDetails(newContent)\n     >>> newPersonalDetails.description\n-    u\'<p>My description</p>\'\n+    \'<p>My description</p>\'\n \n     >>> newPersonalDetails.currentAge\n     21\n \n     >>> newPersonalDetails.personalProfile\n-    u\'<p>My profile</p>\'\n+    \'<p>My profile</p>\'\n \n Alternative ways to deal with multiple schemata\n -----------------------------------------------\n@@ -376,14 +382,14 @@ own multipart message. To do that, we would simply use the\n     >>> envelope.attach(mainMessage)\n     >>> envelope.attach(personalDetailsMessage)\n \n-    >>> envelopeString = renderMessage(envelope)\n+    >>> envelopeString = envelope.as_string()\n     >>> print(envelopeString)\n     Content-Type: multipart/mixed; boundary="===============...=="\n     MIME-Version: 1.0\n     <BLANKLINE>\n     --===============...==\n     title: Test title\n-    description: =?utf-8?q?Test_description...with_a_newline?=\n+    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n     emptyfield:\n     MIME-Version: 1.0\n     Content-Type: text/html; charset="utf-8"\n@@ -451,11 +457,11 @@ We can register a field marshaler for this field which will do the following:\n     >>> from plone.rfc822.interfaces import IFieldMarshaler\n     >>> from email.encoders import encode_base64\n \n-    >>> from zope.component import adapts\n+    >>> from zope.component import adapter\n     >>> from plone.rfc822.defaultfields import BaseFieldMarshaler\n \n-    >>> class FileFieldMarshaler(BaseFieldMarshaler):\n-    ...     adapts(Interface, IFileField)\n+    >>> @adapter(Interface, IFileField)\n+    ... class FileFieldMarshaler(BaseFieldMarshaler):\n     ...\n     ...     ascii = False\n     ...\n@@ -489,8 +495,6 @@ We can register a field marshaler for this field which will do the following:\n     ...             if filename:\n     ...                 # Add a new header storing the filename if we have one\n     ...                 message.add_header(\'Content-Disposition\', \'attachment\', filename=filename)\n-    ...         # Apply base64 encoding\n-    ...         encode_base64(message)\n \n     >>> from zope.component import provideAdapter\n     >>> provideAdapter(FileFieldMarshaler)\n@@ -516,7 +520,7 @@ what happens when we attempt to construct a message from this schema.\n \n     >>> from plone.rfc822 import constructMessageFromSchema\n     >>> message = constructMessageFromSchema(fileContent, IFileContent)\n-    >>> print(renderMessage(message))\n+    >>> print(message.as_string())\n     <BLANKLINE>\n     <BLANKLINE>\n \n@@ -528,12 +532,12 @@ field as primary:\n     >>> alsoProvides(IFileContent[\'file1\'], IPrimaryField)\n \n     >>> message = constructMessageFromSchema(fileContent, IFileContent)\n-    >>> messageBody = renderMessage(message)\n+    >>> messageBody = message.as_string()\n     >>> print(messageBody)\n     MIME-Version: 1.0\n     Content-Type: text/plain\n-    Content-Disposition: attachment; filename="dummy1.txt"\n     Content-Transfer-Encoding: base64\n+    Content-Disposition: attachment; filename="dummy1.txt"\n     <BLANKLINE>\n     ZHVtbXkgZmlsZQ==\n \n@@ -564,7 +568,7 @@ In this case, we should get a multipart document with two payloads.\n \n     >>> alsoProvides(IFileContent[\'file2\'], IPrimaryField)\n     >>> message = constructMessageFromSchema(fileContent, IFileContent)\n-    >>> messageBody = renderMessage(message)\n+    >>> messageBody = message.as_string()\n     >>> print(messageBody) # doctest: +ELLIPSIS\n     MIME-Version: 1.0\n     Content-Type: multipart/mixed; boundary="===============...=="\n@@ -572,15 +576,15 @@ In this case, we should get a multipart document with two payloads.\n     --===============...==\n     MIME-Version: 1.0\n     Content-Type: text/plain\n-    Content-Disposition: attachment; filename="dummy1.txt"\n     Content-Transfer-Encoding: base64\n+    Content-Disposition: attachment; filename="dummy1.txt"\n     <BLANKLINE>\n     ZHVtbXkgZmlsZQ==\n     --===============...==\n     MIME-Version: 1.0\n     Content-Type: text/html\n-    Content-Disposition: attachment; filename="dummy2.html"\n     Content-Transfer-Encoding: base64\n+    Content-Disposition: attachment; filename="dummy2.html"\n     <BLANKLINE>\n     PGh0bWw+PGJvZHk+dGVzdDwvYm9keT48L2h0bWw+\n     --===============...==--...\n@@ -604,3 +608,22 @@ And again, we can reconstruct the object, this time with both fields:\n     \'text/html\'\n     >>> newFileContent.file2.filename\n     \'dummy2.html\'\n+\n+Specialities between Py2 and Py3\n+--------------------------------\n+\n+Test a special behavior which is different between Python 2 and 3 stdlib:\n+Newline handling in non-utf8 strings.\n+\n+Python 2.7 ``email.header`` keeps a line with an escaped value,\n+while Python 3.6 turns it into RFC2047 encoded headers, see https://tools.ietf.org/html/rfc2047.html\n+Technical both is fine.\n+\n+::\n+\n+    >>> import six\n+    >>> content.description = "Test content\\nwith newline difference"\n+    >>> msg = constructMessageFromSchema(content, ITestContent)\n+    >>> effective_output = msg.as_string()\n+    >>> effective_output.split(\'\\n\')[1]\n+    \'description: =?utf-8?q?Test_content=5Cnwith_newline_difference?=\'\ndiff --git a/plone/rfc822/tests.py b/plone/rfc822/tests.py\nindex 8d7b26d..a2bb902 100644\n--- a/plone/rfc822/tests.py\n+++ b/plone/rfc822/tests.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from plone.rfc822._utils import safe_native_string\n from plone.testing import layered\n from plone.testing.zca import UNIT_TESTING\n \n@@ -23,12 +24,20 @@\n class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n         if six.PY2:\n-            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n-        else:\n-            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+            got = re.sub("u\'(.*?)\'", "\'\\\\1\'", got)\n+        if six.PY3:\n+            got = re.sub("b\'(.*?)\'", "\'\\\\1\'", got)\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \n+class TestUtils(unittest.TestCase):\n+\n+    def test_safe_native_string(self):\n+        self.assertIsInstance(safe_native_string(b\'\'), str)\n+        self.assertIsInstance(safe_native_string(u\'\'), str)\n+        self.assertRaises(ValueError, safe_native_string, None)\n+\n+\n def test_suite():\n \n     suite = unittest.TestSuite()\n@@ -43,4 +52,5 @@ def test_suite():\n         )\n         for docfile in DOCFILES\n     ])\n+    suite.addTest(TestUtils(\'test_safe_native_string\'))\n     return suite\ndiff --git a/setup.py b/setup.py\nindex 7c1509d..6073f29 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -5,7 +5,7 @@\n import os\n \n \n-version = \'1.1.5.dev0\'\n+version = \'2.0.0b1.dev0\'\n \n setup(\n     name=\'plone.rfc822\',\n@@ -19,18 +19,16 @@\n     # https://pypi.org/classifiers/\n     classifiers=[\n         "Framework :: Plone",\n-        "Framework :: Plone :: 4.3",\n-        "Framework :: Plone :: 5.0",\n-        "Framework :: Plone :: 5.1",\n         "Framework :: Plone :: 5.2",\n         "Programming Language :: Python",\n-        "Programming Language :: Python :: 2.6",\n         "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.6",\n+        "Programming Language :: Python :: 3.7",\n         "Topic :: Software Development :: Libraries :: Python Modules",\n         "License :: OSI Approved :: BSD License",\n     ],\n     keywords=\'zope schema rfc822\',\n-    author=\'Martin Aspeli\',\n+    author=\'Martin Aspeli and contributors\',\n     author_email=\'optilude@gmail.com\',\n     url=\'https://pypi.org/project/plone.rfc822\',\n     license=\'BSD\',\n@@ -40,14 +38,15 @@\n     zip_safe=False,\n     extras_require={\n         \'supermodel\': [\'plone.supermodel\'],\n-        \'test\': [\'plone.testing\'],\n+        \'test\': [\'plone.testing\', \'plone.supermodel\'],\n     },\n     install_requires=[\n+        \'python-dateutil\',\n         \'setuptools\',\n-        \'zope.schema\',\n         \'zope.component\',\n+        \'zope.deprecation\',\n         \'zope.interface\',\n-        \'python-dateutil\',\n+        \'zope.schema\',\n     ],\n     entry_points="""\n     """,\n'

