Repository: plone.scale


Branch: refs/heads/master
Date: 2016-06-03T16:39:22+02:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.scale/commit/9195c7a412d8caca6587bd8cf7481ab455eb7988

Don't scale images up for direction "down" or "thumbnail".

Files changed:
M CHANGES.rst
M plone/scale/scale.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 1c6892a..128485f 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -32,6 +32,9 @@ New:
 
 Fixes:
 
+- Don't scale images up for direction "down" or "thumbnail".
+  [thet]
+
 - Minor housekeeping.
   [jensens]
 
diff --git a/plone/scale/scale.py b/plone/scale/scale.py
index f076477..80dde35 100644
--- a/plone/scale/scale.py
+++ b/plone/scale/scale.py
@@ -115,6 +115,18 @@ def scalePILImage(image, width=None, height=None, direction="down"):
     else:
         scale_width = (float(width) / float(current_size[0]))
 
+    if (scale_height >= 1 or scale_width >= 1)\
+            and direction in ("down", "thumbnail"):
+        # Don't scale up for direction "down" or "thumbnail".
+        # However, for this example scaling calculations after this block fail
+        # badly:
+        # image with size (129, 100)
+        # target boxed size (400, 99999)
+        # we get a scale_width, scale_height (3.10077519379845, scale_height)
+        # and new_width, new_height of (128999, 99999)
+        # that brings down PIL by eating all the available memory.
+        return image
+
     if scale_height == scale_width or direction == "thumbnail":
         # The original already has the right aspect ratio, so we only need
         # to scale.


Repository: plone.scale


Branch: refs/heads/master
Date: 2016-06-03T16:39:22+02:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.scale/commit/8412518a1b55c82cf1f56f87bee8a2dcf02cb230

Preserve GIF format for GIF images instead of converting them to JPEG.

Files changed:
M CHANGES.rst
M plone/scale/scale.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 128485f..ddcc5a3 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -23,6 +23,9 @@ Bug fixes:
 
 New:
 
+- Preserve GIF format for GIF images instead of converting them to JPEG.
+  [thet]
+
 - Use an adapter to lookup the actual factory for scaling.
   Deprecated passing the factory as named parameter along,
   because this had not enough flexibility:
diff --git a/plone/scale/scale.py b/plone/scale/scale.py
index 80dde35..1e9fd75 100644
--- a/plone/scale/scale.py
+++ b/plone/scale/scale.py
@@ -28,6 +28,10 @@ def scaleImage(image, width=None, height=None, direction="down",
 
     The `width`, `height`, `direction` parameters will be passed to
     :meth:`scalePILImage`, which performs the actual scaling.
+
+    The generated image is a JPEG image, unless the original is a PNG or GIF
+    image. This is needed to make sure alpha channel information is
+    not lost, which JPEG does not support.
     """
     if isinstance(image, str):
         image = StringIO(image)
@@ -35,9 +39,10 @@ def scaleImage(image, width=None, height=None, direction="down",
 
     # When we create a new image during scaling we loose the format
     # information, so remember it here.
-    format = image.format
-    if not format == 'PNG':
-        format = 'JPEG'
+    format_ = image.format
+    if format_ not in ('PNG', 'GIF'):
+        # Always generate JPEG, except if format is PNG or GIF.
+        format_ = 'JPEG'
 
     image = scalePILImage(image, width, height, direction)
 
@@ -45,7 +50,7 @@ def scaleImage(image, width=None, height=None, direction="down",
         result = StringIO()
         image.save(
             result,
-            format,
+            format_,
             quality=quality,
             optimize=True,
             progressive=True)
@@ -53,22 +58,18 @@ def scaleImage(image, width=None, height=None, direction="down",
     else:
         image.save(
             result,
-            format,
+            format_,
             quality=quality,
             optimize=True,
             progressive=True)
         result.seek(0)
 
-    return result, format, image.size
+    return result, format_, image.size
 
 
 def scalePILImage(image, width=None, height=None, direction="down"):
     """Scale a PIL image to another size.
 
-    The generated image is a JPEG image, unless the original is a PNG
-    image. This is needed to make sure alpha channel information is
-    not lost, which JPEG does not support.
-
     Three different scaling options are supported:
 
     * `up` scaling scales the smallest dimension up to the required size


Repository: plone.scale


Branch: refs/heads/master
Date: 2016-06-03T16:39:22+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.scale/commit/a789cfb5d1efbd8e38f460a08eef36a0c0ba9a5f

Assume a width of zero is semantically the same as None.

several simplifications and comments and code restructering

Files changed:
A plone/scale/tests/data/logo.tiff
M CHANGES.rst
M plone/scale/scale.py
M plone/scale/tests/test_scale.py

diff --git a/CHANGES.rst b/CHANGES.rst
index ddcc5a3..ef4f57a 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -23,8 +23,12 @@ Bug fixes:
 
 New:
 
-- Preserve GIF format for GIF images instead of converting them to JPEG.
-  [thet]
+- Assume a width or height of zero is semantically the same as None already was:
+  Use the other dimension to scale, calculate the missing one.
+  [jensens, thet]
+
+- Scaled GIFs are converted to RGBA PNG images instead of converting them to JPEG.
+  [thet, jensens]
 
 - Use an adapter to lookup the actual factory for scaling.
   Deprecated passing the factory as named parameter along,
@@ -35,10 +39,10 @@ New:
 
 Fixes:
 
-- Don't scale images up for direction "down" or "thumbnail".
+- Don't scale images up for direction "down".
   [thet]
 
-- Minor housekeeping.
+- Major housekeeping.
   [jensens]
 
 
diff --git a/plone/scale/scale.py b/plone/scale/scale.py
index 1e9fd75..653d304 100644
--- a/plone/scale/scale.py
+++ b/plone/scale/scale.py
@@ -3,6 +3,7 @@
 
 import PIL.Image
 import PIL.ImageFile
+import warnings
 
 
 # Set a larger buffer size. This fixes problems with jpeg decoding.
@@ -11,7 +12,7 @@
 PIL.ImageFile.MAXBLOCK = 1000000
 
 
-def scaleImage(image, width=None, height=None, direction="down",
+def scaleImage(image, width=None, height=None, direction='down',
                quality=88, result=None):
     """Scale the given image data to another size and return the result
     as a string or optionally write in to the file-like `result` object.
@@ -43,58 +44,99 @@ def scaleImage(image, width=None, height=None, direction="down",
     if format_ not in ('PNG', 'GIF'):
         # Always generate JPEG, except if format is PNG or GIF.
         format_ = 'JPEG'
+    elif format_ == 'GIF':
+        # GIF scaled looks better if we have 8-bit alpha and no palette
+        format_ = 'PNG'
 
     image = scalePILImage(image, width, height, direction)
 
+    new_result = False
+
     if result is None:
         result = StringIO()
-        image.save(
-            result,
-            format_,
-            quality=quality,
-            optimize=True,
-            progressive=True)
+        new_result = True
+
+    image.save(
+        result,
+        format_,
+        quality=quality,
+        optimize=True,
+        progressive=True
+    )
+
+    if new_result:
         result = result.getvalue()
     else:
-        image.save(
-            result,
-            format_,
-            quality=quality,
-            optimize=True,
-            progressive=True)
         result.seek(0)
 
     return result, format_, image.size
 
 
-def scalePILImage(image, width=None, height=None, direction="down"):
+def _scale_thumbnail(image, width=None, height=None):
+    """Scale with method "thumbnail".
+
+    Aspect Ratio is kept. Resulting image has to fit in the given box.
+    If target aspect ratio is different, either width or height is smaller
+    than the given target width or height. No cropping!
+    """
+    if width is None and height is None:
+        raise ValueError("Either width or height need to be given.")
+    if width is None:
+        # calculate a width based on a scale:
+        size = image.size
+        width = float(size[0]) / float(size[1]) * height
+    elif height is None:
+        size = image.size
+        height = float(size[1]) / float(size[0]) * width
+    image.thumbnail((width, height), PIL.Image.ANTIALIAS)
+    return image
+
+
+def scalePILImage(image, width=None, height=None, direction='down'):
     """Scale a PIL image to another size.
 
-    Three different scaling options are supported:
+    This is all about scaling for the display in a web browser.
+
+    Either width or height - or both - must be given.
+
+    Three different scaling options are supported via `direction`:
+
+    `up`
+        scaling scales the smallest dimension up to the required size
+        and crops the other dimension if needed.
+
+    `down`
+        scaling starts by scaling the largest dimension to the required
+        size and crops the other dimension if needed.
 
-    * `up` scaling scales the smallest dimension up to the required size
-      and scrops the other dimension if needed.
-    * `down` scaling starts by scaling the largest dimension to the required
-      size and scrops the other dimension if needed.
-    * `thumbnail` scales to the requested dimensions without cropping. The
-      resulting image may have a different size than requested. This option
-      requires both width and height to be specified. `keep` is accepted as
-      an alternative spelling for this option, but its use is deprecated.
+    `thumbnail`
+        scales to the requested dimensions without cropping. Theresulting
+        image may have a different size than requested. This option
+        requires both width and height to be specified.
+
+        `keep` is accepted as an alternative spelling for this option,
+        but its use is deprecated.
 
     The `image` parameter must be an instance of the `PIL.Image` class.
 
     The return value the scaled image in the form of another instance of
     `PIL.Image`.
     """
+    # convert zero to None, same sematics: calculate this scale
+    if width == 0:
+        width = None
+    if height == 0:
+        height = None
+    if width is None and height is None:
+        raise ValueError("Either width or height need to be given")
+
     if direction == "keep":
+        warnings.warn(
+            'direction="keep" is deprecated, use "thumbnail" instead',
+            DeprecationWarning
+        )
         direction = "thumbnail"
 
-    if direction == "thumbnail" and not (width and height):
-        raise ValueError(
-            "Thumbnailing requires both width and height to be specified")
-    elif width is None and height is None:
-        raise ValueError("Either width or height need to be given")
-
     if image.mode == "1":
         # Convert black&white to grayscale
         image = image.convert("L")
@@ -105,75 +147,69 @@ def scalePILImage(image, width=None, height=None, direction="down"):
         # Convert CMYK to RGB, allowing for web previews of print images
         image = image.convert("RGB")
 
-    current_size = image.size
+    # for thumbnail we're done:
+    if direction == 'thumbnail':
+        return _scale_thumbnail(image, width, height)
+
+    # now for up and down scaling
     # Determine scale factor needed to get the right height
-    if height is None:
-        scale_height = None
-    else:
-        scale_height = (float(height) / float(current_size[1]))
-    if width is None:
-        scale_width = None
-    else:
-        scale_width = (float(width) / float(current_size[0]))
+    factor_height = factor_width = None
+    if height is not None:
+        factor_height = (float(height) / float(image.size[1]))
+    if width is not None:
+        factor_width = (float(width) / float(image.size[0]))
 
-    if (scale_height >= 1 or scale_width >= 1)\
-            and direction in ("down", "thumbnail"):
-        # Don't scale up for direction "down" or "thumbnail".
+    if (factor_height >= 1 or factor_width >= 1) and direction == 'down':
         # However, for this example scaling calculations after this block fail
         # badly:
-        # image with size (129, 100)
-        # target boxed size (400, 99999)
-        # we get a scale_width, scale_height (3.10077519379845, scale_height)
-        # and new_width, new_height of (128999, 99999)
-        # that brings down PIL by eating all the available memory.
+        # - image with size (129, 100)
+        # - target boxed size (400, 99999)
+        # - we get a factor_width, factor_height: (3.10077519379845, 249.9975)
+        #   and new_width, new_height of (128999, 99999)
+        #   that brings down PIL by eating all the available memory.
         return image
 
-    if scale_height == scale_width or direction == "thumbnail":
+    if factor_height == factor_width:
         # The original already has the right aspect ratio, so we only need
         # to scale.
-        if direction in ("down", "thumbnail"):
+        if direction == 'down':
             image.thumbnail((width, height), PIL.Image.ANTIALIAS)
+            return image
+        return image.resize((width, height), PIL.Image.ANTIALIAS)
+
+    # figure out which axis to scale. One of the factors can still be None!
+    # calculate for 'down'
+    use_height = factor_width > factor_height
+    if direction == 'up':  # for 'up': invert
+        use_height = not use_height
+
+    new_width = width
+    new_height = height
+
+    # keep aspect ratio, crop later
+    if (height is None or (use_height and width is not None)):
+        new_height = int(round(image.size[1] * factor_width))
+
+    if (width is None or (height is not None and not use_height)):
+        new_width = int(round(image.size[0] * factor_height))
+
+    image.draft(image.mode, (new_width, new_height))
+    image = image.resize((new_width, new_height), PIL.Image.ANTIALIAS)
+
+    # cropping
+    if (
+        (width is not None and new_width > width) or
+        (height is not None and new_height > height)
+    ):
+        if use_height:
+            left = 0
+            right = new_width
+            top = int((new_height - height) / 2.0)
+            bottom = top + height
         else:
-            image = image.resize((width, height), PIL.Image.ANTIALIAS)
-    else:
-        if direction == "down":
-            if scale_height is None or (
-                    scale_width is not None and scale_width > scale_height):
-                # Width is the smallest dimension (relatively), so scale up
-                # to the desired width
-                new_width = width
-                new_height = int(round(current_size[1] * scale_width))
-            else:
-                new_height = height
-                new_width = int(round(current_size[0] * scale_height))
-        else:
-            if scale_height is None or (
-                    scale_width is not None and scale_width < scale_height):
-                # Width is the largest dimension (relatively), so scale up
-                # to the desired width
-                new_width = width
-                new_height = int(round(current_size[1] * scale_width))
-            else:
-                new_height = height
-                new_width = int(round(current_size[0] * scale_height))
-
-        image.draft(image.mode, (new_width, new_height))
-        image = image.resize((new_width, new_height), PIL.Image.ANTIALIAS)
-
-        if (width is not None and new_width > width) or (
-                height is not None and new_height > height):
-            if width is None:
-                left = 0
-                right = new_width
-            else:
-                left = int((new_width - width) / 2.0)
-                right = left + width
-            if height is None:
-                top = 0
-                bottom = new_height
-            else:
-                top = int((new_height - height) / 2.0)
-                bottom = top + height
-            image = image.crop((left, top, right, bottom))
-
+            left = int((new_width - width) / 2.0)
+            right = left + width
+            top = 0
+            bottom = new_height
+        image = image.crop((left, top, right, bottom))
     return image
diff --git a/plone/scale/tests/data/logo.tiff b/plone/scale/tests/data/logo.tiff
new file mode 100644
index 0000000..828995c
Binary files /dev/null and b/plone/scale/tests/data/logo.tiff differ
diff --git a/plone/scale/tests/test_scale.py b/plone/scale/tests/test_scale.py
index 519b6ea..20a9101 100644
--- a/plone/scale/tests/test_scale.py
+++ b/plone/scale/tests/test_scale.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from cStringIO import StringIO
 from plone.scale.scale import scaleImage
 from plone.scale.tests import TEST_DATA_LOCATION
@@ -9,6 +10,7 @@
 
 PNG = open(os.path.join(TEST_DATA_LOCATION, "logo.png")).read()
 GIF = open(os.path.join(TEST_DATA_LOCATION, "logo.gif")).read()
+TIFF = open(os.path.join(TEST_DATA_LOCATION, "logo.tiff")).read()
 CMYK = open(os.path.join(TEST_DATA_LOCATION, "cmyk.jpg")).read()
 
 
@@ -20,8 +22,14 @@ def testNewSizeReturned(self):
         image = PIL.Image.open(input)
         self.assertEqual(image.size, size)
 
+    def testScaledImageKeepPNG(self):
+        self.assertEqual(scaleImage(PNG, 84, 103, "down")[1], "PNG")
+
+    def testScaledImageKeepGIFto(self):
+        self.assertEqual(scaleImage(GIF, 84, 103, "down")[1], "PNG")
+
     def testScaledImageIsJpeg(self):
-        self.assertEqual(scaleImage(GIF, 84, 103, "down")[1], "JPEG")
+        self.assertEqual(scaleImage(TIFF, 84, 103, "down")[1], "JPEG")
 
     def testScaledCMYKIsRGB(self):
         (imagedata, format, size) = scaleImage(CMYK, 42, 51, "down")
@@ -29,9 +37,7 @@ def testScaledCMYKIsRGB(self):
         image = PIL.Image.open(input)
         self.assertEqual(image.mode, "RGB")
 
-    def XtestScaledPngImageIsPng(self):
-        # This test failes because the sample input file has a format of
-        # None according to PIL..
+    def testScaledPngImageIsPng(self):
         self.assertEqual(scaleImage(PNG, 84, 103, "down")[1], "PNG")
 
     def testSameSizeDownScale(self):
@@ -44,14 +50,20 @@ def testScaleWithCropDownScale(self):
         self.assertEqual(scaleImage(PNG, 20, 51, "down")[2], (20, 51))
 
     def testNoStretchingDownScale(self):
-        self.assertEqual(scaleImage(PNG, 200, 103, "down")[2], (200, 103))
+        self.assertEqual(scaleImage(PNG, 200, 103, "down")[2], (84, 103))
 
-    def testRestrictWidthOnlyDownScale(self):
+    def testRestrictWidthOnlyDownScaleNone(self):
         self.assertEqual(scaleImage(PNG, 42, None, "down")[2], (42, 52))
 
-    def testRestrictHeightOnlyDownScale(self):
+    def testRestrictWidthOnlyDownScaleZero(self):
+        self.assertEqual(scaleImage(PNG, 42, 0, "down")[2], (42, 52))
+
+    def testRestrictHeightOnlyDownScaleNone(self):
         self.assertEqual(scaleImage(PNG, None, 51, "down")[2], (42, 51))
 
+    def testRestrictHeightOnlyDownScaleZero(self):
+        self.assertEqual(scaleImage(PNG, 0, 51, "down")[2], (42, 51))
+
     def testSameSizeUpScale(self):
         self.assertEqual(scaleImage(PNG, 84, 103, "up")[2], (84, 103))
 
@@ -64,18 +76,36 @@ def testHalfSizeUpScale(self):
     def testNoStretchingUpScale(self):
         self.assertEqual(scaleImage(PNG, 200, 103, "up")[2], (84, 103))
 
-    def testRestrictWidthOnlyUpScale(self):
+    def testRestrictWidthOnlyUpScaleNone(self):
         self.assertEqual(scaleImage(PNG, 42, None, "up")[2], (42, 52))
 
-    def testRestrictHeightOnlyUpScale(self):
+    def testRestrictWidthOnlyUpScaleZero(self):
+        self.assertEqual(scaleImage(PNG, 42, 0, "up")[2], (42, 52))
+
+    def testRestrictHeightOnlyUpScaleNone(self):
         self.assertEqual(scaleImage(PNG, None, 51, "up")[2], (42, 51))
 
-    def testNoRestrictions(self):
+    def testRestrictHeightOnlyUpScaleZero(self):
+        self.assertEqual(scaleImage(PNG, 0, 51, "up")[2], (42, 51))
+
+    def testNoRestrictionsNone(self):
         self.assertRaises(ValueError, scaleImage, PNG, None, None)
 
+    def testNoRestrictionsZero(self):
+        self.assertRaises(ValueError, scaleImage, PNG, 0, 0)
+
     def testKeepAspectRatio(self):
+        self.assertEqual(scaleImage(PNG, 80, 80, "thumbnail")[2], (65, 80))
+
+    def testKeepAspectRatioBBB(self):
         self.assertEqual(scaleImage(PNG, 80, 80, "keep")[2], (65, 80))
 
+    def testThumbnailHeightNone(self):
+        self.assertEqual(scaleImage(PNG, 42, None, "thumbnail")[2], (42, 51))
+
+    def testThumbnailWidthNone(self):
+        self.assertEqual(scaleImage(PNG, None, 51, "thumbnail")[2], (41, 51))
+
     def testQuality(self):
         img1 = scaleImage(CMYK, 84, 103)[0]
         img2 = scaleImage(CMYK, 84, 103, quality=50)[0]


Repository: plone.scale


Branch: refs/heads/master
Date: 2016-06-03T16:43:56+02:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.scale/commit/ba587bd6e2863ae0acd1630f23d1dbeecb955777

changes justify new major version

Files changed:
M CHANGES.rst
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index ef4f57a..cd3f606 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -2,20 +2,25 @@ Changelog
 =========
 
 
-1.5.1 (unreleased)
+2.0 (unreleased)
 ------------------
 
-Breaking changes:
+New:
 
-- *add item here*
+- Assume a width or height of zero is semantically the same as None already was:
+  Use the other dimension to scale, calculate the missing one.
+  [jensens, thet]
 
-New features:
+- Scaled GIFs are converted to RGBA PNG images instead of converting them to JPEG.
+  [thet, jensens]
 
-- *add item here*
+Fixes:
 
-Bug fixes:
+- Don't scale images up for direction "down".
+  [thet]
 
-- *add item here*
+- Major housekeeping, code refactored in order to reduce complexicty.
+  [jensens]
 
 
 1.5.0 (2016-05-18)
@@ -23,13 +28,6 @@ Bug fixes:
 
 New:
 
-- Assume a width or height of zero is semantically the same as None already was:
-  Use the other dimension to scale, calculate the missing one.
-  [jensens, thet]
-
-- Scaled GIFs are converted to RGBA PNG images instead of converting them to JPEG.
-  [thet, jensens]
-
 - Use an adapter to lookup the actual factory for scaling.
   Deprecated passing the factory as named parameter along,
   because this had not enough flexibility:
@@ -39,10 +37,7 @@ New:
 
 Fixes:
 
-- Don't scale images up for direction "down".
-  [thet]
-
-- Major housekeeping.
+- Minor housekeeping.
   [jensens]
 
 
diff --git a/setup.py b/setup.py
index a6e2fb6..8452f05 100644
--- a/setup.py
+++ b/setup.py
@@ -2,7 +2,7 @@
 from setuptools import find_packages
 from setuptools import setup
 
-version = '1.5.1.dev0'
+version = '2.0.dev0'
 readme = open('README.rst').read().replace(':class:', '').replace(':mod:', '')
 changes = open('CHANGES.rst').read()
 


Repository: plone.scale


Branch: refs/heads/master
Date: 2016-06-06T17:47:33+02:00
Author: agitator (agitator) <hpeter@agitator.com>
Commit: https://github.com/plone/plone.scale/commit/f87153a26581df5db975195bbf275daa340292d2

Merge pull request #11 from plone/thet-avoid-upscaling

Cleanup: don't scale images up for direction "down", GIF handling, zero as flexible width

Files changed:
A plone/scale/tests/data/logo.tiff
M CHANGES.rst
M plone/scale/scale.py
M plone/scale/tests/test_scale.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 1c6892a..cd3f606 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -2,20 +2,25 @@ Changelog
 =========
 
 
-1.5.1 (unreleased)
+2.0 (unreleased)
 ------------------
 
-Breaking changes:
+New:
 
-- *add item here*
+- Assume a width or height of zero is semantically the same as None already was:
+  Use the other dimension to scale, calculate the missing one.
+  [jensens, thet]
 
-New features:
+- Scaled GIFs are converted to RGBA PNG images instead of converting them to JPEG.
+  [thet, jensens]
 
-- *add item here*
+Fixes:
 
-Bug fixes:
+- Don't scale images up for direction "down".
+  [thet]
 
-- *add item here*
+- Major housekeeping, code refactored in order to reduce complexicty.
+  [jensens]
 
 
 1.5.0 (2016-05-18)
diff --git a/plone/scale/scale.py b/plone/scale/scale.py
index f076477..653d304 100644
--- a/plone/scale/scale.py
+++ b/plone/scale/scale.py
@@ -3,6 +3,7 @@
 
 import PIL.Image
 import PIL.ImageFile
+import warnings
 
 
 # Set a larger buffer size. This fixes problems with jpeg decoding.
@@ -11,7 +12,7 @@
 PIL.ImageFile.MAXBLOCK = 1000000
 
 
-def scaleImage(image, width=None, height=None, direction="down",
+def scaleImage(image, width=None, height=None, direction='down',
                quality=88, result=None):
     """Scale the given image data to another size and return the result
     as a string or optionally write in to the file-like `result` object.
@@ -28,6 +29,10 @@ def scaleImage(image, width=None, height=None, direction="down",
 
     The `width`, `height`, `direction` parameters will be passed to
     :meth:`scalePILImage`, which performs the actual scaling.
+
+    The generated image is a JPEG image, unless the original is a PNG or GIF
+    image. This is needed to make sure alpha channel information is
+    not lost, which JPEG does not support.
     """
     if isinstance(image, str):
         image = StringIO(image)
@@ -35,65 +40,103 @@ def scaleImage(image, width=None, height=None, direction="down",
 
     # When we create a new image during scaling we loose the format
     # information, so remember it here.
-    format = image.format
-    if not format == 'PNG':
-        format = 'JPEG'
+    format_ = image.format
+    if format_ not in ('PNG', 'GIF'):
+        # Always generate JPEG, except if format is PNG or GIF.
+        format_ = 'JPEG'
+    elif format_ == 'GIF':
+        # GIF scaled looks better if we have 8-bit alpha and no palette
+        format_ = 'PNG'
 
     image = scalePILImage(image, width, height, direction)
 
+    new_result = False
+
     if result is None:
         result = StringIO()
-        image.save(
-            result,
-            format,
-            quality=quality,
-            optimize=True,
-            progressive=True)
+        new_result = True
+
+    image.save(
+        result,
+        format_,
+        quality=quality,
+        optimize=True,
+        progressive=True
+    )
+
+    if new_result:
         result = result.getvalue()
     else:
-        image.save(
-            result,
-            format,
-            quality=quality,
-            optimize=True,
-            progressive=True)
         result.seek(0)
 
-    return result, format, image.size
+    return result, format_, image.size
 
 
-def scalePILImage(image, width=None, height=None, direction="down"):
+def _scale_thumbnail(image, width=None, height=None):
+    """Scale with method "thumbnail".
+
+    Aspect Ratio is kept. Resulting image has to fit in the given box.
+    If target aspect ratio is different, either width or height is smaller
+    than the given target width or height. No cropping!
+    """
+    if width is None and height is None:
+        raise ValueError("Either width or height need to be given.")
+    if width is None:
+        # calculate a width based on a scale:
+        size = image.size
+        width = float(size[0]) / float(size[1]) * height
+    elif height is None:
+        size = image.size
+        height = float(size[1]) / float(size[0]) * width
+    image.thumbnail((width, height), PIL.Image.ANTIALIAS)
+    return image
+
+
+def scalePILImage(image, width=None, height=None, direction='down'):
     """Scale a PIL image to another size.
 
-    The generated image is a JPEG image, unless the original is a PNG
-    image. This is needed to make sure alpha channel information is
-    not lost, which JPEG does not support.
+    This is all about scaling for the display in a web browser.
+
+    Either width or height - or both - must be given.
 
-    Three different scaling options are supported:
+    Three different scaling options are supported via `direction`:
 
-    * `up` scaling scales the smallest dimension up to the required size
-      and scrops the other dimension if needed.
-    * `down` scaling starts by scaling the largest dimension to the required
-      size and scrops the other dimension if needed.
-    * `thumbnail` scales to the requested dimensions without cropping. The
-      resulting image may have a different size than requested. This option
-      requires both width and height to be specified. `keep` is accepted as
-      an alternative spelling for this option, but its use is deprecated.
+    `up`
+        scaling scales the smallest dimension up to the required size
+        and crops the other dimension if needed.
+
+    `down`
+        scaling starts by scaling the largest dimension to the required
+        size and crops the other dimension if needed.
+
+    `thumbnail`
+        scales to the requested dimensions without cropping. Theresulting
+        image may have a different size than requested. This option
+        requires both width and height to be specified.
+
+        `keep` is accepted as an alternative spelling for this option,
+        but its use is deprecated.
 
     The `image` parameter must be an instance of the `PIL.Image` class.
 
     The return value the scaled image in the form of another instance of
     `PIL.Image`.
     """
+    # convert zero to None, same sematics: calculate this scale
+    if width == 0:
+        width = None
+    if height == 0:
+        height = None
+    if width is None and height is None:
+        raise ValueError("Either width or height need to be given")
+
     if direction == "keep":
+        warnings.warn(
+            'direction="keep" is deprecated, use "thumbnail" instead',
+            DeprecationWarning
+        )
         direction = "thumbnail"
 
-    if direction == "thumbnail" and not (width and height):
-        raise ValueError(
-            "Thumbnailing requires both width and height to be specified")
-    elif width is None and height is None:
-        raise ValueError("Either width or height need to be given")
-
     if image.mode == "1":
         # Convert black&white to grayscale
         image = image.convert("L")
@@ -104,63 +147,69 @@ def scalePILImage(image, width=None, height=None, direction="down"):
         # Convert CMYK to RGB, allowing for web previews of print images
         image = image.convert("RGB")
 
-    current_size = image.size
-    # Determine scale factor needed to get the right height
-    if height is None:
-        scale_height = None
-    else:
-        scale_height = (float(height) / float(current_size[1]))
-    if width is None:
-        scale_width = None
-    else:
-        scale_width = (float(width) / float(current_size[0]))
+    # for thumbnail we're done:
+    if direction == 'thumbnail':
+        return _scale_thumbnail(image, width, height)
 
-    if scale_height == scale_width or direction == "thumbnail":
+    # now for up and down scaling
+    # Determine scale factor needed to get the right height
+    factor_height = factor_width = None
+    if height is not None:
+        factor_height = (float(height) / float(image.size[1]))
+    if width is not None:
+        factor_width = (float(width) / float(image.size[0]))
+
+    if (factor_height >= 1 or factor_width >= 1) and direction == 'down':
+        # However, for this example scaling calculations after this block fail
+        # badly:
+        # - image with size (129, 100)
+        # - target boxed size (400, 99999)
+        # - we get a factor_width, factor_height: (3.10077519379845, 249.9975)
+        #   and new_width, new_height of (128999, 99999)
+        #   that brings down PIL by eating all the available memory.
+        return image
+
+    if factor_height == factor_width:
         # The original already has the right aspect ratio, so we only need
         # to scale.
-        if direction in ("down", "thumbnail"):
+        if direction == 'down':
             image.thumbnail((width, height), PIL.Image.ANTIALIAS)
+            return image
+        return image.resize((width, height), PIL.Image.ANTIALIAS)
+
+    # figure out which axis to scale. One of the factors can still be None!
+    # calculate for 'down'
+    use_height = factor_width > factor_height
+    if direction == 'up':  # for 'up': invert
+        use_height = not use_height
+
+    new_width = width
+    new_height = height
+
+    # keep aspect ratio, crop later
+    if (height is None or (use_height and width is not None)):
+        new_height = int(round(image.size[1] * factor_width))
+
+    if (width is None or (height is not None and not use_height)):
+        new_width = int(round(image.size[0] * factor_height))
+
+    image.draft(image.mode, (new_width, new_height))
+    image = image.resize((new_width, new_height), PIL.Image.ANTIALIAS)
+
+    # cropping
+    if (
+        (width is not None and new_width > width) or
+        (height is not None and new_height > height)
+    ):
+        if use_height:
+            left = 0
+            right = new_width
+            top = int((new_height - height) / 2.0)
+            bottom = top + height
         else:
-            image = image.resize((width, height), PIL.Image.ANTIALIAS)
-    else:
-        if direction == "down":
-            if scale_height is None or (
-                    scale_width is not None and scale_width > scale_height):
-                # Width is the smallest dimension (relatively), so scale up
-                # to the desired width
-                new_width = width
-                new_height = int(round(current_size[1] * scale_width))
-            else:
-                new_height = height
-                new_width = int(round(current_size[0] * scale_height))
-        else:
-            if scale_height is None or (
-                    scale_width is not None and scale_width < scale_height):
-                # Width is the largest dimension (relatively), so scale up
-                # to the desired width
-                new_width = width
-                new_height = int(round(current_size[1] * scale_width))
-            else:
-                new_height = height
-                new_width = int(round(current_size[0] * scale_height))
-
-        image.draft(image.mode, (new_width, new_height))
-        image = image.resize((new_width, new_height), PIL.Image.ANTIALIAS)
-
-        if (width is not None and new_width > width) or (
-                height is not None and new_height > height):
-            if width is None:
-                left = 0
-                right = new_width
-            else:
-                left = int((new_width - width) / 2.0)
-                right = left + width
-            if height is None:
-                top = 0
-                bottom = new_height
-            else:
-                top = int((new_height - height) / 2.0)
-                bottom = top + height
-            image = image.crop((left, top, right, bottom))
-
+            left = int((new_width - width) / 2.0)
+            right = left + width
+            top = 0
+            bottom = new_height
+        image = image.crop((left, top, right, bottom))
     return image
diff --git a/plone/scale/tests/data/logo.tiff b/plone/scale/tests/data/logo.tiff
new file mode 100644
index 0000000..828995c
Binary files /dev/null and b/plone/scale/tests/data/logo.tiff differ
diff --git a/plone/scale/tests/test_scale.py b/plone/scale/tests/test_scale.py
index 519b6ea..20a9101 100644
--- a/plone/scale/tests/test_scale.py
+++ b/plone/scale/tests/test_scale.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from cStringIO import StringIO
 from plone.scale.scale import scaleImage
 from plone.scale.tests import TEST_DATA_LOCATION
@@ -9,6 +10,7 @@
 
 PNG = open(os.path.join(TEST_DATA_LOCATION, "logo.png")).read()
 GIF = open(os.path.join(TEST_DATA_LOCATION, "logo.gif")).read()
+TIFF = open(os.path.join(TEST_DATA_LOCATION, "logo.tiff")).read()
 CMYK = open(os.path.join(TEST_DATA_LOCATION, "cmyk.jpg")).read()
 
 
@@ -20,8 +22,14 @@ def testNewSizeReturned(self):
         image = PIL.Image.open(input)
         self.assertEqual(image.size, size)
 
+    def testScaledImageKeepPNG(self):
+        self.assertEqual(scaleImage(PNG, 84, 103, "down")[1], "PNG")
+
+    def testScaledImageKeepGIFto(self):
+        self.assertEqual(scaleImage(GIF, 84, 103, "down")[1], "PNG")
+
     def testScaledImageIsJpeg(self):
-        self.assertEqual(scaleImage(GIF, 84, 103, "down")[1], "JPEG")
+        self.assertEqual(scaleImage(TIFF, 84, 103, "down")[1], "JPEG")
 
     def testScaledCMYKIsRGB(self):
         (imagedata, format, size) = scaleImage(CMYK, 42, 51, "down")
@@ -29,9 +37,7 @@ def testScaledCMYKIsRGB(self):
         image = PIL.Image.open(input)
         self.assertEqual(image.mode, "RGB")
 
-    def XtestScaledPngImageIsPng(self):
-        # This test failes because the sample input file has a format of
-        # None according to PIL..
+    def testScaledPngImageIsPng(self):
         self.assertEqual(scaleImage(PNG, 84, 103, "down")[1], "PNG")
 
     def testSameSizeDownScale(self):
@@ -44,14 +50,20 @@ def testScaleWithCropDownScale(self):
         self.assertEqual(scaleImage(PNG, 20, 51, "down")[2], (20, 51))
 
     def testNoStretchingDownScale(self):
-        self.assertEqual(scaleImage(PNG, 200, 103, "down")[2], (200, 103))
+        self.assertEqual(scaleImage(PNG, 200, 103, "down")[2], (84, 103))
 
-    def testRestrictWidthOnlyDownScale(self):
+    def testRestrictWidthOnlyDownScaleNone(self):
         self.assertEqual(scaleImage(PNG, 42, None, "down")[2], (42, 52))
 
-    def testRestrictHeightOnlyDownScale(self):
+    def testRestrictWidthOnlyDownScaleZero(self):
+        self.assertEqual(scaleImage(PNG, 42, 0, "down")[2], (42, 52))
+
+    def testRestrictHeightOnlyDownScaleNone(self):
         self.assertEqual(scaleImage(PNG, None, 51, "down")[2], (42, 51))
 
+    def testRestrictHeightOnlyDownScaleZero(self):
+        self.assertEqual(scaleImage(PNG, 0, 51, "down")[2], (42, 51))
+
     def testSameSizeUpScale(self):
         self.assertEqual(scaleImage(PNG, 84, 103, "up")[2], (84, 103))
 
@@ -64,18 +76,36 @@ def testHalfSizeUpScale(self):
     def testNoStretchingUpScale(self):
         self.assertEqual(scaleImage(PNG, 200, 103, "up")[2], (84, 103))
 
-    def testRestrictWidthOnlyUpScale(self):
+    def testRestrictWidthOnlyUpScaleNone(self):
         self.assertEqual(scaleImage(PNG, 42, None, "up")[2], (42, 52))
 
-    def testRestrictHeightOnlyUpScale(self):
+    def testRestrictWidthOnlyUpScaleZero(self):
+        self.assertEqual(scaleImage(PNG, 42, 0, "up")[2], (42, 52))
+
+    def testRestrictHeightOnlyUpScaleNone(self):
         self.assertEqual(scaleImage(PNG, None, 51, "up")[2], (42, 51))
 
-    def testNoRestrictions(self):
+    def testRestrictHeightOnlyUpScaleZero(self):
+        self.assertEqual(scaleImage(PNG, 0, 51, "up")[2], (42, 51))
+
+    def testNoRestrictionsNone(self):
         self.assertRaises(ValueError, scaleImage, PNG, None, None)
 
+    def testNoRestrictionsZero(self):
+        self.assertRaises(ValueError, scaleImage, PNG, 0, 0)
+
     def testKeepAspectRatio(self):
+        self.assertEqual(scaleImage(PNG, 80, 80, "thumbnail")[2], (65, 80))
+
+    def testKeepAspectRatioBBB(self):
         self.assertEqual(scaleImage(PNG, 80, 80, "keep")[2], (65, 80))
 
+    def testThumbnailHeightNone(self):
+        self.assertEqual(scaleImage(PNG, 42, None, "thumbnail")[2], (42, 51))
+
+    def testThumbnailWidthNone(self):
+        self.assertEqual(scaleImage(PNG, None, 51, "thumbnail")[2], (41, 51))
+
     def testQuality(self):
         img1 = scaleImage(CMYK, 84, 103)[0]
         img2 = scaleImage(CMYK, 84, 103, quality=50)[0]
diff --git a/setup.py b/setup.py
index a6e2fb6..8452f05 100644
--- a/setup.py
+++ b/setup.py
@@ -2,7 +2,7 @@
 from setuptools import find_packages
 from setuptools import setup
 
-version = '1.5.1.dev0'
+version = '2.0.dev0'
 readme = open('README.rst').read().replace(':class:', '').replace(':mod:', '')
 changes = open('CHANGES.rst').read()
 


