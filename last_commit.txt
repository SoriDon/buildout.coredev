Repository: plone.restapi


Branch: refs/heads/master
Date: 2018-09-05T23:43:14+02:00
Author: Sune Broendum Woeller (sunew) <sune@woeller.dk>
Commit: https://github.com/plone/plone.restapi/commit/22d610e486aa4cd85ba87c85263cd3e68aea59cc

Fix AttributeError: 'list' object has no attribute 'lstrip' in a virtual hosting setting when restricting search to multiple paths (path.query is a list).

Files changed:
A src/plone/restapi/tests/http-examples/search_multiple_paths.req
A src/plone/restapi/tests/http-examples/search_multiple_paths.resp
M CHANGES.rst
M docs/source/searching.rst
M src/plone/restapi/search/handler.py
M src/plone/restapi/tests/test_documentation.py
M src/plone/restapi/tests/test_search.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 024d82b4..b90ac783 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -4,7 +4,10 @@ Changelog\n 3.4.5 (unreleased)\n ------------------\n \n-- Nothing changed yet.\n+Bugfixes:\n+\n+- Make search work with a path query containing a list of paths in a virtual hosting setting.\n+  [sunew]\n \n \n 3.4.4 (2018-08-31)\ndiff --git a/docs/source/searching.rst b/docs/source/searching.rst\nindex bc88a42a..491ba8b5 100644\n--- a/docs/source/searching.rst\n+++ b/docs/source/searching.rst\n@@ -70,6 +70,24 @@ This dictionary will need to be flattened in dotted notation in order to pass it\n Again, this is very similar to how `Record Arguments <http://docs.zope.org/zope2/zdgbook/ObjectPublishing.html?highlight=record#record-arguments>`_ are parsed by ZPublisher, except that you can omit the ``:record`` suffix.\n \n \n+Restricting search to multiple paths\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+To restrict search to multiple paths, the original query as a Python dictionary would look like this (with an optional depth and sort_on)::\n+\n+    query = {\'path\': {\'query\': (\'/folder\', \'/folder2\'),\n+                      \'depth\': 2},\n+             \'sort_on\': \'path\'}\n+\n+This dictionary will need to be flattened in dotted notation in order to pass it in a query string. In order to specify multiple paths, simply repeat the query string parameter (the ``requests`` module will do this automatically for you if you pass it a list of values for a query string parameter).\n+\n+..  http:example:: curl httpie python-requests\n+    :request: ../../src/plone/restapi/tests/http-examples/search_multiple_paths.req\n+\n+.. literalinclude:: ../../src/plone/restapi/tests/http-examples/search_multiple_paths.resp\n+   :language: http\n+\n+\n Data types in queries\n ^^^^^^^^^^^^^^^^^^^^^\n \ndiff --git a/src/plone/restapi/search/handler.py b/src/plone/restapi/search/handler.py\nindex 2f65f530..a2b3f955 100644\n--- a/src/plone/restapi/search/handler.py\n+++ b/src/plone/restapi/search/handler.py\n@@ -33,7 +33,10 @@ def _constrain_query_by_path(self, query):\n         if \'path\' not in query:\n             query[\'path\'] = {}\n \n-        if isinstance(query[\'path\'], str):\n+        if (\n+            isinstance(query[\'path\'], str)\n+            or isinstance(query[\'path\'], list)\n+        ):\n             query[\'path\'] = {\'query\': query[\'path\']}\n \n         # If this is accessed through a VHM the client does not know\n@@ -43,9 +46,17 @@ def _constrain_query_by_path(self, query):\n         if vhm_physical_path:\n             path = query[\'path\'].get(\'query\')\n             if path:\n-                path = path.lstrip(\'/\')\n-                full_path = \'/\'.join(vhm_physical_path + (path,))\n-                query[\'path\'][\'query\'] = full_path\n+                if isinstance(path, str):\n+                    path = path.lstrip(\'/\')\n+                    full_path = \'/\'.join(vhm_physical_path + (path,))\n+                    query[\'path\'][\'query\'] = full_path\n+                if isinstance(path, list):\n+                    full_paths = []\n+                    for p in path:\n+                        p = p.lstrip(\'/\')\n+                        full_path = \'/\'.join(vhm_physical_path + (p,))\n+                        full_paths.append(full_path)\n+                    query[\'path\'][\'query\'] = full_paths\n \n         if isinstance(query[\'path\'], dict) and \'query\' not in query[\'path\']:\n             # We either had no \'path\' parameter at all, or an incomplete\ndiff --git a/src/plone/restapi/tests/http-examples/search_multiple_paths.req b/src/plone/restapi/tests/http-examples/search_multiple_paths.req\nnew file mode 100644\nindex 00000000..0067c1de\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/search_multiple_paths.req\n@@ -0,0 +1,3 @@\n+GET /plone/@search?path.query=%2Fplone%2Ffolder1&path.query=%2Fplone%2Ffolder2&sort_on=path&path.depth=2 HTTP/1.1\n+Accept: application/json\n+Authorization: Basic YWRtaW46c2VjcmV0\ndiff --git a/src/plone/restapi/tests/http-examples/search_multiple_paths.resp b/src/plone/restapi/tests/http-examples/search_multiple_paths.resp\nnew file mode 100644\nindex 00000000..1aacaf15\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/search_multiple_paths.resp\n@@ -0,0 +1,37 @@\n+HTTP/1.1 200 OK\n+Content-Type: application/json\n+\n+{\n+  "@id": "http://localhost:55001/plone/@search?path.query=%2Fplone%2Ffolder1&path.query=%2Fplone%2Ffolder2&path.depth=2", \n+  "items": [\n+    {\n+      "@id": "http://localhost:55001/plone/folder1", \n+      "@type": "Folder", \n+      "description": "", \n+      "review_state": "private", \n+      "title": "Folder 1"\n+    }, \n+    {\n+      "@id": "http://localhost:55001/plone/folder1/doc1", \n+      "@type": "Document", \n+      "description": "", \n+      "review_state": "private", \n+      "title": "Lorem Ipsum"\n+    }, \n+    {\n+      "@id": "http://localhost:55001/plone/folder2", \n+      "@type": "Folder", \n+      "description": "", \n+      "review_state": "private", \n+      "title": "Folder 2"\n+    }, \n+    {\n+      "@id": "http://localhost:55001/plone/folder2/doc2", \n+      "@type": "Document", \n+      "description": "", \n+      "review_state": "private", \n+      "title": "Lorem Ipsum"\n+    }\n+  ], \n+  "items_total": 4\n+}\n\\ No newline at end of file\ndiff --git a/src/plone/restapi/tests/test_documentation.py b/src/plone/restapi/tests/test_documentation.py\nindex bc58bb6b..4e2ba04f 100644\n--- a/src/plone/restapi/tests/test_documentation.py\n+++ b/src/plone/restapi/tests/test_documentation.py\n@@ -424,6 +424,35 @@ def test_documentation_search_options(self):\n         response = self.api_session.get(\'/@search\', params=query)\n         save_request_and_response_for_docs(\'search_options\', response)\n \n+    def test_documentation_search_multiple_paths(self):\n+        self.portal.invokeFactory(\n+            \'Folder\',\n+            id=\'folder1\',\n+            title=\'Folder 1\'\n+        )\n+        self.portal.folder1.invokeFactory(\n+            \'Document\',\n+            id=\'doc1\',\n+            title=\'Lorem Ipsum\'\n+        )\n+        self.portal.invokeFactory(\n+            \'Folder\',\n+            id=\'folder2\',\n+            title=\'Folder 2\'\n+        )\n+        self.portal.folder2.invokeFactory(\n+            \'Document\',\n+            id=\'doc2\',\n+            title=\'Lorem Ipsum\'\n+        )\n+        import transaction\n+        transaction.commit()\n+        query = {\'sort_on\': \'path\',\n+                 \'path.query\': [\'/plone/folder1\', \'/plone/folder2\'],\n+                 \'path.depth\': \'2\'}\n+        response = self.api_session.get(\'/@search\', params=query)\n+        save_request_and_response_for_docs(\'search_multiple_paths\', response)\n+\n     def test_documentation_search_metadata_fields(self):\n         self.portal.invokeFactory(\n             \'Document\',\ndiff --git a/src/plone/restapi/tests/test_search.py b/src/plone/restapi/tests/test_search.py\nindex ec4fd645..ca9619c6 100644\n--- a/src/plone/restapi/tests/test_search.py\n+++ b/src/plone/restapi/tests/test_search.py\n@@ -74,6 +74,23 @@ def setUp(self):\n             test_bool_field=False,\n         )\n \n+        # /plone/folder2\n+        self.folder2 = createContentInContainer(\n+            self.portal, u\'Folder\',\n+            id=u\'folder2\',\n+            title=u\'Another Folder\')\n+\n+        # /plone/folder2/doc\n+        createContentInContainer(\n+            self.folder2, u\'DXTestDocument\',\n+            id=\'doc\',\n+            title=u\'Document in second folder\',\n+            start=DateTime(1975, 1, 1, 0, 0),\n+            effective=DateTime(2015, 1, 1, 0, 0),\n+            expires=DateTime(2020, 1, 1, 0, 0),\n+            test_bool_field=False,\n+        )\n+\n         # /plone/doc-outside-folder\n         createContentInContainer(\n             self.portal, u\'DXTestDocument\',\n@@ -133,10 +150,61 @@ def test_search_in_vhm(self):\n              u\'/folder/other-document\'},\n             set(result_paths(response.json())))\n \n+    def test_search_in_vhm_multiple_paths(self):\n+        # Install a Virtual Host Monster\n+        if \'virtual_hosting\' not in self.app.objectIds():\n+            # If ZopeLite was imported, we have no default virtual\n+            # host monster\n+            from Products.SiteAccess.VirtualHostMonster \\\n+                import manage_addVirtualHostMonster\n+            manage_addVirtualHostMonster(self.app, \'virtual_hosting\')\n+        transaction.commit()\n+\n+        # path as a list\n+        query = {\'path\': [\n+            \'/folder\',\n+            \'/folder2\']\n+        }\n+\n+        # If we go through the VHM we will get results for multiple paths\n+        # if we only use the part of the path inside the VHM\n+        vhm_url = (\n+            \'%s/VirtualHostBase/http/plone.org/plone/VirtualHostRoot/%s\' %\n+            (self.app.absolute_url(), \'@search\'))\n+        response = self.api_session.get(vhm_url, params=query)\n+        self.assertSetEqual(\n+            {u\'/folder\',\n+             u\'/folder/doc\',\n+             u\'/folder/other-document\',\n+             u\'/folder2\',\n+             u\'/folder2/doc\'},\n+            set(result_paths(response.json())))\n+\n+        # path as a dict with a query list\n+        query = {\'path.query\': [\n+            \'/folder\',\n+            \'/folder2\']\n+        }\n+\n+        # If we go through the VHM we will get results for multiple paths\n+        # if we only use the part of the path inside the VHM\n+        vhm_url = (\n+            \'%s/VirtualHostBase/http/plone.org/plone/VirtualHostRoot/%s\' %\n+            (self.app.absolute_url(), \'@search\'))\n+        response = self.api_session.get(vhm_url, params=query)\n+        self.assertSetEqual(\n+            {u\'/folder\',\n+             u\'/folder/doc\',\n+             u\'/folder/other-document\',\n+             u\'/folder2\',\n+             u\'/folder2/doc\'},\n+            set(result_paths(response.json())))\n+\n     def test_path_gets_prefilled_if_missing_from_path_query_dict(self):\n         response = self.api_session.get(\'/@search?path.depth=1\')\n         self.assertSetEqual(\n             {u\'/plone/folder\',\n+             u\'/plone/folder2\',\n              u\'/plone/doc-outside-folder\'},\n             set(result_paths(response.json())))\n \n@@ -361,6 +429,39 @@ def test_extended_path_index_query(self):\n             result_paths(response.json())\n         )\n \n+    def test_extended_path_index_query_multiple(self):\n+        # path as a list\n+        query = {\'path\': [\n+                \'/\'.join(self.folder.getPhysicalPath()),\n+                \'/\'.join(self.folder2.getPhysicalPath())]\n+        }\n+        response = self.api_session.get(\'/@search\', params=query)\n+\n+        self.assertEqual(\n+            [u\'/plone/folder\',\n+             u\'/plone/folder/doc\',\n+             u\'/plone/folder/other-document\',\n+             u\'/plone/folder2\',\n+             u\'/plone/folder2/doc\'],\n+            result_paths(response.json())\n+        )\n+\n+        # path as a dict with a query list\n+        query = {\'path.query\': [\n+                \'/\'.join(self.folder.getPhysicalPath()),\n+                \'/\'.join(self.folder2.getPhysicalPath())]\n+        }\n+        response = self.api_session.get(\'/@search\', params=query)\n+\n+        self.assertEqual(\n+            [u\'/plone/folder\',\n+             u\'/plone/folder/doc\',\n+             u\'/plone/folder/other-document\',\n+             u\'/plone/folder2\',\n+             u\'/plone/folder2/doc\'],\n+            result_paths(response.json())\n+        )\n+\n     def test_extended_path_index_depth_limiting(self):\n         lvl1 = createContentInContainer(self.portal, u\'Folder\', id=u\'lvl1\')\n         lvl2 = createContentInContainer(lvl1, u\'Folder\', id=u\'lvl2\')\n'

Repository: plone.restapi


Branch: refs/heads/master
Date: 2018-09-06T09:32:27+02:00
Author: Sune Broendum Woeller (sunew) <sune@woeller.dk>
Commit: https://github.com/plone/plone.restapi/commit/d347f4114f147860f0f571197f1db7567ecd9726

Merge pull request #615 from plone/search-multiple-paths

Fix AttributeError in a virtual hosting setting when restricting search to multiple paths

Files changed:
A src/plone/restapi/tests/http-examples/search_multiple_paths.req
A src/plone/restapi/tests/http-examples/search_multiple_paths.resp
M CHANGES.rst
M docs/source/searching.rst
M src/plone/restapi/search/handler.py
M src/plone/restapi/tests/test_documentation.py
M src/plone/restapi/tests/test_search.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 024d82b4..b90ac783 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -4,7 +4,10 @@ Changelog\n 3.4.5 (unreleased)\n ------------------\n \n-- Nothing changed yet.\n+Bugfixes:\n+\n+- Make search work with a path query containing a list of paths in a virtual hosting setting.\n+  [sunew]\n \n \n 3.4.4 (2018-08-31)\ndiff --git a/docs/source/searching.rst b/docs/source/searching.rst\nindex bc88a42a..491ba8b5 100644\n--- a/docs/source/searching.rst\n+++ b/docs/source/searching.rst\n@@ -70,6 +70,24 @@ This dictionary will need to be flattened in dotted notation in order to pass it\n Again, this is very similar to how `Record Arguments <http://docs.zope.org/zope2/zdgbook/ObjectPublishing.html?highlight=record#record-arguments>`_ are parsed by ZPublisher, except that you can omit the ``:record`` suffix.\n \n \n+Restricting search to multiple paths\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+To restrict search to multiple paths, the original query as a Python dictionary would look like this (with an optional depth and sort_on)::\n+\n+    query = {\'path\': {\'query\': (\'/folder\', \'/folder2\'),\n+                      \'depth\': 2},\n+             \'sort_on\': \'path\'}\n+\n+This dictionary will need to be flattened in dotted notation in order to pass it in a query string. In order to specify multiple paths, simply repeat the query string parameter (the ``requests`` module will do this automatically for you if you pass it a list of values for a query string parameter).\n+\n+..  http:example:: curl httpie python-requests\n+    :request: ../../src/plone/restapi/tests/http-examples/search_multiple_paths.req\n+\n+.. literalinclude:: ../../src/plone/restapi/tests/http-examples/search_multiple_paths.resp\n+   :language: http\n+\n+\n Data types in queries\n ^^^^^^^^^^^^^^^^^^^^^\n \ndiff --git a/src/plone/restapi/search/handler.py b/src/plone/restapi/search/handler.py\nindex 2f65f530..a2b3f955 100644\n--- a/src/plone/restapi/search/handler.py\n+++ b/src/plone/restapi/search/handler.py\n@@ -33,7 +33,10 @@ def _constrain_query_by_path(self, query):\n         if \'path\' not in query:\n             query[\'path\'] = {}\n \n-        if isinstance(query[\'path\'], str):\n+        if (\n+            isinstance(query[\'path\'], str)\n+            or isinstance(query[\'path\'], list)\n+        ):\n             query[\'path\'] = {\'query\': query[\'path\']}\n \n         # If this is accessed through a VHM the client does not know\n@@ -43,9 +46,17 @@ def _constrain_query_by_path(self, query):\n         if vhm_physical_path:\n             path = query[\'path\'].get(\'query\')\n             if path:\n-                path = path.lstrip(\'/\')\n-                full_path = \'/\'.join(vhm_physical_path + (path,))\n-                query[\'path\'][\'query\'] = full_path\n+                if isinstance(path, str):\n+                    path = path.lstrip(\'/\')\n+                    full_path = \'/\'.join(vhm_physical_path + (path,))\n+                    query[\'path\'][\'query\'] = full_path\n+                if isinstance(path, list):\n+                    full_paths = []\n+                    for p in path:\n+                        p = p.lstrip(\'/\')\n+                        full_path = \'/\'.join(vhm_physical_path + (p,))\n+                        full_paths.append(full_path)\n+                    query[\'path\'][\'query\'] = full_paths\n \n         if isinstance(query[\'path\'], dict) and \'query\' not in query[\'path\']:\n             # We either had no \'path\' parameter at all, or an incomplete\ndiff --git a/src/plone/restapi/tests/http-examples/search_multiple_paths.req b/src/plone/restapi/tests/http-examples/search_multiple_paths.req\nnew file mode 100644\nindex 00000000..0067c1de\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/search_multiple_paths.req\n@@ -0,0 +1,3 @@\n+GET /plone/@search?path.query=%2Fplone%2Ffolder1&path.query=%2Fplone%2Ffolder2&sort_on=path&path.depth=2 HTTP/1.1\n+Accept: application/json\n+Authorization: Basic YWRtaW46c2VjcmV0\ndiff --git a/src/plone/restapi/tests/http-examples/search_multiple_paths.resp b/src/plone/restapi/tests/http-examples/search_multiple_paths.resp\nnew file mode 100644\nindex 00000000..1aacaf15\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/search_multiple_paths.resp\n@@ -0,0 +1,37 @@\n+HTTP/1.1 200 OK\n+Content-Type: application/json\n+\n+{\n+  "@id": "http://localhost:55001/plone/@search?path.query=%2Fplone%2Ffolder1&path.query=%2Fplone%2Ffolder2&path.depth=2", \n+  "items": [\n+    {\n+      "@id": "http://localhost:55001/plone/folder1", \n+      "@type": "Folder", \n+      "description": "", \n+      "review_state": "private", \n+      "title": "Folder 1"\n+    }, \n+    {\n+      "@id": "http://localhost:55001/plone/folder1/doc1", \n+      "@type": "Document", \n+      "description": "", \n+      "review_state": "private", \n+      "title": "Lorem Ipsum"\n+    }, \n+    {\n+      "@id": "http://localhost:55001/plone/folder2", \n+      "@type": "Folder", \n+      "description": "", \n+      "review_state": "private", \n+      "title": "Folder 2"\n+    }, \n+    {\n+      "@id": "http://localhost:55001/plone/folder2/doc2", \n+      "@type": "Document", \n+      "description": "", \n+      "review_state": "private", \n+      "title": "Lorem Ipsum"\n+    }\n+  ], \n+  "items_total": 4\n+}\n\\ No newline at end of file\ndiff --git a/src/plone/restapi/tests/test_documentation.py b/src/plone/restapi/tests/test_documentation.py\nindex bc58bb6b..4e2ba04f 100644\n--- a/src/plone/restapi/tests/test_documentation.py\n+++ b/src/plone/restapi/tests/test_documentation.py\n@@ -424,6 +424,35 @@ def test_documentation_search_options(self):\n         response = self.api_session.get(\'/@search\', params=query)\n         save_request_and_response_for_docs(\'search_options\', response)\n \n+    def test_documentation_search_multiple_paths(self):\n+        self.portal.invokeFactory(\n+            \'Folder\',\n+            id=\'folder1\',\n+            title=\'Folder 1\'\n+        )\n+        self.portal.folder1.invokeFactory(\n+            \'Document\',\n+            id=\'doc1\',\n+            title=\'Lorem Ipsum\'\n+        )\n+        self.portal.invokeFactory(\n+            \'Folder\',\n+            id=\'folder2\',\n+            title=\'Folder 2\'\n+        )\n+        self.portal.folder2.invokeFactory(\n+            \'Document\',\n+            id=\'doc2\',\n+            title=\'Lorem Ipsum\'\n+        )\n+        import transaction\n+        transaction.commit()\n+        query = {\'sort_on\': \'path\',\n+                 \'path.query\': [\'/plone/folder1\', \'/plone/folder2\'],\n+                 \'path.depth\': \'2\'}\n+        response = self.api_session.get(\'/@search\', params=query)\n+        save_request_and_response_for_docs(\'search_multiple_paths\', response)\n+\n     def test_documentation_search_metadata_fields(self):\n         self.portal.invokeFactory(\n             \'Document\',\ndiff --git a/src/plone/restapi/tests/test_search.py b/src/plone/restapi/tests/test_search.py\nindex ec4fd645..ca9619c6 100644\n--- a/src/plone/restapi/tests/test_search.py\n+++ b/src/plone/restapi/tests/test_search.py\n@@ -74,6 +74,23 @@ def setUp(self):\n             test_bool_field=False,\n         )\n \n+        # /plone/folder2\n+        self.folder2 = createContentInContainer(\n+            self.portal, u\'Folder\',\n+            id=u\'folder2\',\n+            title=u\'Another Folder\')\n+\n+        # /plone/folder2/doc\n+        createContentInContainer(\n+            self.folder2, u\'DXTestDocument\',\n+            id=\'doc\',\n+            title=u\'Document in second folder\',\n+            start=DateTime(1975, 1, 1, 0, 0),\n+            effective=DateTime(2015, 1, 1, 0, 0),\n+            expires=DateTime(2020, 1, 1, 0, 0),\n+            test_bool_field=False,\n+        )\n+\n         # /plone/doc-outside-folder\n         createContentInContainer(\n             self.portal, u\'DXTestDocument\',\n@@ -133,10 +150,61 @@ def test_search_in_vhm(self):\n              u\'/folder/other-document\'},\n             set(result_paths(response.json())))\n \n+    def test_search_in_vhm_multiple_paths(self):\n+        # Install a Virtual Host Monster\n+        if \'virtual_hosting\' not in self.app.objectIds():\n+            # If ZopeLite was imported, we have no default virtual\n+            # host monster\n+            from Products.SiteAccess.VirtualHostMonster \\\n+                import manage_addVirtualHostMonster\n+            manage_addVirtualHostMonster(self.app, \'virtual_hosting\')\n+        transaction.commit()\n+\n+        # path as a list\n+        query = {\'path\': [\n+            \'/folder\',\n+            \'/folder2\']\n+        }\n+\n+        # If we go through the VHM we will get results for multiple paths\n+        # if we only use the part of the path inside the VHM\n+        vhm_url = (\n+            \'%s/VirtualHostBase/http/plone.org/plone/VirtualHostRoot/%s\' %\n+            (self.app.absolute_url(), \'@search\'))\n+        response = self.api_session.get(vhm_url, params=query)\n+        self.assertSetEqual(\n+            {u\'/folder\',\n+             u\'/folder/doc\',\n+             u\'/folder/other-document\',\n+             u\'/folder2\',\n+             u\'/folder2/doc\'},\n+            set(result_paths(response.json())))\n+\n+        # path as a dict with a query list\n+        query = {\'path.query\': [\n+            \'/folder\',\n+            \'/folder2\']\n+        }\n+\n+        # If we go through the VHM we will get results for multiple paths\n+        # if we only use the part of the path inside the VHM\n+        vhm_url = (\n+            \'%s/VirtualHostBase/http/plone.org/plone/VirtualHostRoot/%s\' %\n+            (self.app.absolute_url(), \'@search\'))\n+        response = self.api_session.get(vhm_url, params=query)\n+        self.assertSetEqual(\n+            {u\'/folder\',\n+             u\'/folder/doc\',\n+             u\'/folder/other-document\',\n+             u\'/folder2\',\n+             u\'/folder2/doc\'},\n+            set(result_paths(response.json())))\n+\n     def test_path_gets_prefilled_if_missing_from_path_query_dict(self):\n         response = self.api_session.get(\'/@search?path.depth=1\')\n         self.assertSetEqual(\n             {u\'/plone/folder\',\n+             u\'/plone/folder2\',\n              u\'/plone/doc-outside-folder\'},\n             set(result_paths(response.json())))\n \n@@ -361,6 +429,39 @@ def test_extended_path_index_query(self):\n             result_paths(response.json())\n         )\n \n+    def test_extended_path_index_query_multiple(self):\n+        # path as a list\n+        query = {\'path\': [\n+                \'/\'.join(self.folder.getPhysicalPath()),\n+                \'/\'.join(self.folder2.getPhysicalPath())]\n+        }\n+        response = self.api_session.get(\'/@search\', params=query)\n+\n+        self.assertEqual(\n+            [u\'/plone/folder\',\n+             u\'/plone/folder/doc\',\n+             u\'/plone/folder/other-document\',\n+             u\'/plone/folder2\',\n+             u\'/plone/folder2/doc\'],\n+            result_paths(response.json())\n+        )\n+\n+        # path as a dict with a query list\n+        query = {\'path.query\': [\n+                \'/\'.join(self.folder.getPhysicalPath()),\n+                \'/\'.join(self.folder2.getPhysicalPath())]\n+        }\n+        response = self.api_session.get(\'/@search\', params=query)\n+\n+        self.assertEqual(\n+            [u\'/plone/folder\',\n+             u\'/plone/folder/doc\',\n+             u\'/plone/folder/other-document\',\n+             u\'/plone/folder2\',\n+             u\'/plone/folder2/doc\'],\n+            result_paths(response.json())\n+        )\n+\n     def test_extended_path_index_depth_limiting(self):\n         lvl1 = createContentInContainer(self.portal, u\'Folder\', id=u\'lvl1\')\n         lvl2 = createContentInContainer(lvl1, u\'Folder\', id=u\'lvl2\')\n'

