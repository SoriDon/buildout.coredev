Repository: plone.restapi


Branch: refs/heads/master
Date: 2022-10-02T00:00:33+02:00
Author: Andrea Cecchi (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.restapi/commit/5a367e0f6374ccd84c086b5907cfff04c5b23412

Blocks linkintegrity (#953)

* set references also for blocks

* set references also for blocks

* add linkintegrity service

* fix tests

* black

* fix black

* fix zpretty

* add changelog

* move endpoint to POST and add documentation

* Install black version from versions.cfg

* black

* move from POST to GET, change permission and fix tests

* flake8

* fix typo

* Remove bogus .resp from workingcopy

* Linkintegrity docs: minor improvements

* Linkintegrity -&gt; LinkIntegrityGet

Co-authored-by: Timo Stollenwerk &lt;stollenwerk@kitconcept.com&gt;
Co-authored-by: Timo Stollenwerk &lt;tisto@users.noreply.github.com&gt;
Co-authored-by: Victor Fernandez de Alba &lt;sneridagh@gmail.com&gt;

Files changed:
A docs/source/linkintegrity.md
A news/953.feature
A src/plone/restapi/blocks_linkintegrity.py
A src/plone/restapi/services/linkintegrity/__init__.py
A src/plone/restapi/services/linkintegrity/configure.zcml
A src/plone/restapi/services/linkintegrity/get.py
A src/plone/restapi/tests/http-examples/linkintegrity_get.req
A src/plone/restapi/tests/test_blocks_linkintegrity.py
A src/plone/restapi/tests/test_services_linkintegrity.py
M src/plone/restapi/configure.zcml
M src/plone/restapi/interfaces.py
M src/plone/restapi/services/configure.zcml

b'diff --git a/docs/source/linkintegrity.md b/docs/source/linkintegrity.md\nnew file mode 100644\nindex 000000000..2aed82201\n--- /dev/null\n+++ b/docs/source/linkintegrity.md\n@@ -0,0 +1,31 @@\n+---\n+html_meta:\n+  "description": "Returns a list of possible reference breaches for given objects."\n+  "property=og:description": "Returns a list of possible reference breaches for given objects."\n+  "property=og:title": "Link integrity"\n+  "keywords": "Plone, plone.restapi, REST, API, Linkintegrity"\n+---\n+\n+# Link Integrity\n+\n+When you create relations between content objects in Plone (e.g. via relation fields or links in text blocks), these relations are stored in the database.\n+The Plone user interface will use those stored relations to show a warning when you try to delete a content object that is still referenced somewhere.\n+This avoids broken links ("breaches") in the site.\n+\n+This check includes content objects that are located within a content object ("folderish content").\n+\n+The `@linkintegrity` endpoint returns the list of reference breaches. If there are none, it will return an empty list ("[]").\n+\n+You can call the `/@linkintegrity` endpoint on site root with a `GET` request and a list of uids in JSON BODY:\n+\n+..  http:example:: curl httpie python-requests\n+    :request: ../../src/plone/restapi/tests/http-examples/linkintegrity_get.req\n+\n+The server will respond with the results:\n+\n+.. literalinclude:: ../../src/plone/restapi/tests/http-examples/linkintegrity_get.resp\n+   :language: http\n+\n+The endpoint accepts a single parameter:\n+\n+  - ``uids`` (a list of object uids that you want to check)\ndiff --git a/news/953.feature b/news/953.feature\nnew file mode 100644\nindex 000000000..70a418ac1\n--- /dev/null\n+++ b/news/953.feature\n@@ -0,0 +1,2 @@\n+Add link integrity support for blocks\n+[cekk]\ndiff --git a/src/plone/restapi/blocks_linkintegrity.py b/src/plone/restapi/blocks_linkintegrity.py\nnew file mode 100644\nindex 000000000..b64be9e55\n--- /dev/null\n+++ b/src/plone/restapi/blocks_linkintegrity.py\n@@ -0,0 +1,80 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.linkintegrity.interfaces import IRetriever\n+from plone.app.linkintegrity.retriever import DXGeneral\n+from plone.restapi.behaviors import IBlocks\n+from plone.restapi.interfaces import IBlockFieldLinkIntegrityRetriever\n+from zope.component import adapter\n+from zope.component import subscribers\n+from zope.interface import implementer\n+from zope.publisher.interfaces.browser import IBrowserRequest\n+\n+\n+@implementer(IRetriever)\n+@adapter(IBlocks)\n+class BlocksRetriever(DXGeneral):\n+    """General retriever for Blocks enabled contents."""\n+\n+    def retrieveLinks(self):\n+        """Finds all links from the object and return them."""\n+        links = set()\n+        blocks = getattr(self.context, "blocks", {})\n+        for block in blocks.values():\n+            block_type = block.get("@type", None)\n+            handlers = []\n+            for h in subscribers(\n+                (self.context, self.context.REQUEST),\n+                IBlockFieldLinkIntegrityRetriever,\n+            ):\n+                if h.block_type == block_type or h.block_type is None:\n+                    handlers.append(h)\n+            for handler in sorted(handlers, key=lambda h: h.order):\n+                links |= set(handler(block))\n+\n+        return links\n+\n+\n+@adapter(IBlocks, IBrowserRequest)\n+@implementer(IBlockFieldLinkIntegrityRetriever)\n+class TextBlockLinksRetriever(object):\n+    order = 100\n+    block_type = "text"\n+\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n+\n+    def __call__(self, block):\n+        """\n+        Returns a list of internal links\n+        """\n+        links = []\n+        entity_map = block.get("text", {}).get("entityMap", {})\n+        for entity in entity_map.values():\n+            if entity.get("type") == "LINK":\n+                for attr in ["href", "url"]:\n+                    relation = entity.get("data", {}).get(attr, "")\n+                    if relation and "resolveuid" in relation and relation not in links:\n+                        links.append(relation)\n+        return links\n+\n+\n+@adapter(IBlocks, IBrowserRequest)\n+@implementer(IBlockFieldLinkIntegrityRetriever)\n+class GenericBlockLinksRetriever(object):\n+    order = 1\n+    block_type = None\n+\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n+\n+    def __call__(self, block):\n+        """\n+        Returns a list of internal links\n+        """\n+        links = []\n+        for field in ["url", "href"]:\n+            value = block.get(field, "")\n+            if value and "resolveuid" in value:\n+                links.append(value)\n+        return links\ndiff --git a/src/plone/restapi/configure.zcml b/src/plone/restapi/configure.zcml\nindex a18da9013..f31a80c92 100644\n--- a/src/plone/restapi/configure.zcml\n+++ b/src/plone/restapi/configure.zcml\n@@ -122,4 +122,16 @@\n       name="plone.restapi"\n       />\n \n+  <!-- blocks link integrity -->\n+  <adapter factory=".blocks_linkintegrity.BlocksRetriever" />\n+\n+  <subscriber\n+      factory=".blocks_linkintegrity.TextBlockLinksRetriever"\n+      provides="plone.restapi.interfaces.IBlockFieldLinkIntegrityRetriever"\n+      />\n+  <subscriber\n+      factory=".blocks_linkintegrity.GenericBlockLinksRetriever"\n+      provides="plone.restapi.interfaces.IBlockFieldLinkIntegrityRetriever"\n+      />\n+\n </configure>\ndiff --git a/src/plone/restapi/interfaces.py b/src/plone/restapi/interfaces.py\nindex 9137914b8..47427dd9a 100644\n--- a/src/plone/restapi/interfaces.py\n+++ b/src/plone/restapi/interfaces.py\n@@ -210,6 +210,20 @@ def __call__(value):\n         """Extract text from the block value. Returns text"""\n \n \n+class IBlockFieldLinkIntegrityRetriever(Interface):\n+    """Retrieve internal links set in current block."""\n+\n+    block_type = Attribute(\n+        "A string with the type of block, the @type from " "the block value"\n+    )\n+\n+    def __init__(field, context, request):\n+        """Adapts context and the request."""\n+\n+    def __call__(value):\n+        """Return a list of internal links set in this block."""\n+\n+\n class IJSONSummarySerializerMetadata(Interface):\n     """Configure JSONSummary serializer."""\n \ndiff --git a/src/plone/restapi/services/configure.zcml b/src/plone/restapi/services/configure.zcml\nindex 5ae759dcc..ac7a917d5 100644\n--- a/src/plone/restapi/services/configure.zcml\n+++ b/src/plone/restapi/services/configure.zcml\n@@ -23,6 +23,7 @@\n   <include package=".navigation" />\n   <include package=".contextnavigation" />\n   <include package=".history" />\n+  <include package=".linkintegrity" />\n   <include package=".locking" />\n   <include package=".principals" />\n   <include package=".querysources" />\ndiff --git a/src/plone/restapi/services/linkintegrity/__init__.py b/src/plone/restapi/services/linkintegrity/__init__.py\nnew file mode 100644\nindex 000000000..e69de29bb\ndiff --git a/src/plone/restapi/services/linkintegrity/configure.zcml b/src/plone/restapi/services/linkintegrity/configure.zcml\nnew file mode 100644\nindex 000000000..65da4559e\n--- /dev/null\n+++ b/src/plone/restapi/services/linkintegrity/configure.zcml\n@@ -0,0 +1,17 @@\n+<configure\n+    xmlns="http://namespaces.zope.org/zope"\n+    xmlns:plone="http://namespaces.plone.org/plone"\n+    xmlns:zcml="http://namespaces.zope.org/zcml"\n+    >\n+\n+  <include package="Products.CMFEditions" />\n+\n+  <plone:service\n+      method="GET"\n+      factory=".get.LinkIntegrityGet"\n+      for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+      permission="zope2.AccessContentsInformation"\n+      name="@linkintegrity"\n+      />\n+\n+</configure>\ndiff --git a/src/plone/restapi/services/linkintegrity/get.py b/src/plone/restapi/services/linkintegrity/get.py\nnew file mode 100644\nindex 000000000..41edeae4c\n--- /dev/null\n+++ b/src/plone/restapi/services/linkintegrity/get.py\n@@ -0,0 +1,47 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.linkintegrity.utils import linkintegrity_enabled\n+from plone.app.uuid.utils import uuidToObject\n+from plone.restapi.interfaces import ISerializeToJsonSummary\n+from plone.restapi.serializer.converters import json_compatible\n+from plone.restapi.services import Service\n+from zExceptions import BadRequest\n+from zope.component import getMultiAdapter\n+from zope.interface import implementer\n+from zope.publisher.interfaces import IPublishTraverse\n+\n+\n+@implementer(IPublishTraverse)\n+class LinkIntegrityGet(Service):\n+    """\n+    Return a list of breaches from p.a.linkintegrity view\n+    """\n+\n+    def reply(self):\n+        if not linkintegrity_enabled():\n+            return json_compatible([])\n+        query = self.request.form\n+        uids = query.get("uids", [])\n+\n+        if not uids:\n+            raise BadRequest(\'Missing parameter "uids"\')\n+        if not isinstance(uids, list):\n+            uids = [uids]\n+\n+        result = []\n+        for uid in uids:\n+            item = uuidToObject(uid)\n+            links_info = item.restrictedTraverse("@@delete_confirmation_info")\n+            breaches = links_info.get_breaches()\n+            if not breaches:\n+                continue\n+            data = getMultiAdapter((item, self.request), ISerializeToJsonSummary)()\n+            data["breaches"] = []\n+            for breach in breaches:\n+                for source in breach.get("sources", []):\n+                    # remove unwanted data\n+                    source["@id"] = source["url"]\n+                    del source["url"]\n+                    del source["accessible"]\n+                    data["breaches"].append(source)\n+            result.append(data)\n+        return json_compatible(result)\ndiff --git a/src/plone/restapi/tests/http-examples/linkintegrity_get.req b/src/plone/restapi/tests/http-examples/linkintegrity_get.req\nnew file mode 100644\nindex 000000000..cb79c1d52\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/linkintegrity_get.req\n@@ -0,0 +1,3 @@\n+GET /plone/@linkintegrity?uids=SomeUUID000000000000000000000001 HTTP/1.1\n+Accept: application/json\n+Authorization: Basic YWRtaW46c2VjcmV0\ndiff --git a/src/plone/restapi/tests/test_blocks_linkintegrity.py b/src/plone/restapi/tests/test_blocks_linkintegrity.py\nnew file mode 100644\nindex 000000000..1c9217efd\n--- /dev/null\n+++ b/src/plone/restapi/tests/test_blocks_linkintegrity.py\n@@ -0,0 +1,421 @@\n+# -*- coding: utf-8 -*-\n+from Acquisition import aq_inner\n+from plone.app.linkintegrity.interfaces import IRetriever\n+from plone.app.linkintegrity.utils import referencedRelationship\n+from plone.app.testing import setRoles\n+from plone.app.testing import SITE_OWNER_NAME\n+from plone.app.testing import SITE_OWNER_PASSWORD\n+from plone.app.testing import TEST_USER_ID\n+from plone.dexterity.utils import createContentInContainer\n+from plone.restapi.testing import PLONE_RESTAPI_BLOCKS_FUNCTIONAL_TESTING\n+from plone.restapi.testing import PLONE_RESTAPI_BLOCKS_INTEGRATION_TESTING\n+from plone.restapi.testing import RelativeSession\n+from plone.uuid.interfaces import IUUID\n+from unittest import TestCase\n+from zc.relation.interfaces import ICatalog\n+from zope.component import getUtility\n+from zope.intid.interfaces import IIntIds\n+\n+import transaction\n+\n+\n+class TestBlocksLinkintegrity(TestCase):\n+    layer = PLONE_RESTAPI_BLOCKS_INTEGRATION_TESTING\n+    maxDiff = None\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+\n+        self.doc1 = self.portal[\n+            self.portal.invokeFactory(\n+                "Document", id="doc1", title="Document with Blocks"\n+            )\n+        ]\n+        self.doc2 = self.portal[\n+            self.portal.invokeFactory("Document", id="doc2", title="Target Document")\n+        ]\n+\n+    def retrieve_links(self, value):\n+        retriever = IRetriever(self.portal.doc1)\n+        return retriever.retrieveLinks()\n+\n+    def test_links_retriever_return_internal_links_in_text_block(self):\n+        uid = IUUID(self.doc2)\n+        blocks = {\n+            "111": {"@type": "title"},\n+            "222": {\n+                "@type": "text",\n+                "text": {\n+                    "blocks": [{"key": "68rve", "text": "Example text"}],\n+                    "entityMap": {\n+                        "0": {\n+                            "data": {\n+                                "href": "../resolveuid/{}".format(uid),\n+                                "rel": "nofollow",\n+                                "url": "../resolveuid/{}".format(uid),\n+                            },\n+                            "mutability": "MUTABLE",\n+                            "type": "LINK",\n+                        }\n+                    },\n+                },\n+            },\n+        }\n+        self.portal.doc1.blocks = blocks\n+        value = self.retrieve_links(blocks)\n+\n+        self.assertEqual(len(value), 1)\n+        self.assertIn("../resolveuid/{}".format(uid), value)\n+\n+    def test_links_retriever_return_internal_links_in_generic_block(self):\n+        uid = IUUID(self.doc2)\n+        blocks = {"111": {"@type": "foo", "href": "../resolveuid/{}".format(uid)}}\n+        self.portal.doc1.blocks = blocks\n+        value = self.retrieve_links(blocks)\n+\n+        self.assertEqual(len(value), 1)\n+        self.assertIn("../resolveuid/{}".format(uid), value)\n+\n+    def test_links_retriever_return_internal_links_in_text_block_once(self):\n+        uid = IUUID(self.doc2)\n+        blocks = {\n+            "111": {"@type": "title"},\n+            "222": {\n+                "@type": "text",\n+                "text": {\n+                    "blocks": [{"key": "68rve", "text": "Example text"}],\n+                    "entityMap": {\n+                        "0": {\n+                            "data": {\n+                                "href": "../resolveuid/{}".format(uid),\n+                                "rel": "nofollow",\n+                                "url": "../resolveuid/{}".format(uid),\n+                            },\n+                            "mutability": "MUTABLE",\n+                            "type": "LINK",\n+                        }\n+                    },\n+                },\n+            },\n+            "333": {\n+                "@type": "text",\n+                "text": {\n+                    "blocks": [{"key": "68rve", "text": "Another text"}],\n+                    "entityMap": {\n+                        "0": {\n+                            "data": {\n+                                "href": "../resolveuid/{}".format(uid),\n+                                "rel": "nofollow",\n+                                "url": "../resolveuid/{}".format(uid),\n+                            },\n+                            "mutability": "MUTABLE",\n+                            "type": "LINK",\n+                        }\n+                    },\n+                },\n+            },\n+            "444": {"@type": "foo", "href": "../resolveuid/{}".format(uid)},\n+        }\n+        self.portal.doc1.blocks = blocks\n+        value = self.retrieve_links(blocks)\n+\n+        self.assertEqual(len(value), 1)\n+        self.assertIn("../resolveuid/{}".format(uid), value)\n+\n+\n+class TestLinkintegrityForBlocks(TestCase):\n+\n+    layer = PLONE_RESTAPI_BLOCKS_FUNCTIONAL_TESTING\n+\n+    def setUp(self):\n+        self.app = self.layer["app"]\n+        self.portal = self.layer["portal"]\n+        self.portal_url = self.portal.absolute_url()\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+\n+        self.api_session = RelativeSession(self.portal_url)\n+        self.api_session.headers.update({"Accept": "application/json"})\n+        self.api_session.auth = (SITE_OWNER_NAME, SITE_OWNER_PASSWORD)\n+\n+        self.doc1 = createContentInContainer(\n+            self.portal, "Document", id="doc-1", title="First document"\n+        )\n+        self.doc2 = createContentInContainer(\n+            self.portal, "Document", id="doc-2", title="Second document"\n+        )\n+        transaction.commit()\n+\n+    def tearDown(self):\n+        self.api_session.close()\n+\n+    def get_back_references(self, item):\n+        catalog = getUtility(ICatalog)\n+        intids = getUtility(IIntIds)\n+        result = []\n+        for rel in catalog.findRelations(\n+            dict(\n+                to_id=intids.getId(aq_inner(item)),\n+                from_attribute=referencedRelationship,\n+            )\n+        ):\n+            obj = intids.queryObject(rel.from_id)\n+            if obj is not None:\n+                result.append(obj)\n+        return result\n+\n+    def test_reference_correctly_set_for_text_blocks(self):\n+        self.assertEqual([], self.get_back_references(self.doc2))\n+\n+        uid = IUUID(self.doc2)\n+        response = self.api_session.patch(\n+            "/doc-1",\n+            json={\n+                "blocks": {\n+                    "uuid1": {\n+                        "@type": "text",\n+                        "text": {\n+                            "blocks": [{"text": "This is a link to second doc "}],\n+                            "entityMap": {\n+                                "0": {\n+                                    "data": {\n+                                        "href": "../resolveuid/{}".format(uid),\n+                                        "rel": "nofollow",\n+                                        "url": "../resolveuid/{}".format(uid),\n+                                    },\n+                                    "mutability": "MUTABLE",\n+                                    "type": "LINK",\n+                                }\n+                            },\n+                        },\n+                    }\n+                }\n+            },\n+        )\n+        transaction.commit()\n+        self.assertEqual(response.status_code, 204)\n+        back_references = self.get_back_references(self.doc2)\n+        self.assertEqual(len(back_references), 1)\n+        self.assertEqual(back_references[0], self.doc1)\n+\n+    def test_reference_correctly_unset_for_text_blocks(self):\n+        uid = IUUID(self.doc2)\n+        self.api_session.patch(\n+            "/doc-1",\n+            json={\n+                "blocks": {\n+                    "uuid1": {\n+                        "@type": "text",\n+                        "text": {\n+                            "blocks": [{"text": "This is a link to second doc "}],\n+                            "entityMap": {\n+                                "0": {\n+                                    "data": {\n+                                        "href": "../resolveuid/{}".format(uid),\n+                                        "rel": "nofollow",\n+                                        "url": "../resolveuid/{}".format(uid),\n+                                    },\n+                                    "mutability": "MUTABLE",\n+                                    "type": "LINK",\n+                                }\n+                            },\n+                        },\n+                    }\n+                }\n+            },\n+        )\n+        transaction.commit()\n+        back_references = self.get_back_references(self.doc2)\n+        self.assertEqual(len(back_references), 1)\n+\n+        # now unset reference\n+        self.api_session.patch(\n+            "/doc-1",\n+            json={\n+                "blocks": {\n+                    "uuid1": {\n+                        "@type": "text",\n+                        "text": {\n+                            "blocks": [{"text": "This is a link to plone.org "}],\n+                            "entityMap": {\n+                                "0": {\n+                                    "data": {\n+                                        "href": "http://www.plone.org",\n+                                        "rel": "nofollow",\n+                                        "url": "http://www.plone.org",\n+                                    },\n+                                    "mutability": "MUTABLE",\n+                                    "type": "LINK",\n+                                }\n+                            },\n+                        },\n+                    }\n+                }\n+            },\n+        )\n+        transaction.commit()\n+        back_references = self.get_back_references(self.doc2)\n+        self.assertEqual(len(back_references), 0)\n+\n+    def test_reference_correctly_set_for_generic_blocks_with_href(self):\n+        self.assertEqual([], self.get_back_references(self.doc2))\n+\n+        uid = IUUID(self.doc2)\n+        response = self.api_session.patch(\n+            "/doc-1",\n+            json={\n+                "blocks": {\n+                    "uuid1": {\n+                        "@type": "foo",\n+                        "href": "../resolveuid/{}".format(uid),\n+                    }\n+                }\n+            },\n+        )\n+        transaction.commit()\n+        self.assertEqual(response.status_code, 204)\n+        back_references = self.get_back_references(self.doc2)\n+        self.assertEqual(len(back_references), 1)\n+        self.assertEqual(back_references[0], self.doc1)\n+\n+    def test_reference_correctly_unset_for_generic_blocks_with_href(self):\n+        uid = IUUID(self.doc2)\n+        self.api_session.patch(\n+            "/doc-1",\n+            json={\n+                "blocks": {\n+                    "uuid1": {\n+                        "@type": "foo",\n+                        "href": "../resolveuid/{}".format(uid),\n+                    }\n+                }\n+            },\n+        )\n+        transaction.commit()\n+        back_references = self.get_back_references(self.doc2)\n+        self.assertEqual(len(back_references), 1)\n+\n+        # now unset reference\n+        self.api_session.patch(\n+            "/doc-1",\n+            json={\n+                "blocks": {"uuid1": {"@type": "foo", "href": "http://www.plone.org"}}\n+            },\n+        )\n+        transaction.commit()\n+        back_references = self.get_back_references(self.doc2)\n+        self.assertEqual(len(back_references), 0)\n+\n+    def test_reference_correctly_set_for_generic_blocks_with_url(self):\n+        self.assertEqual([], self.get_back_references(self.doc2))\n+\n+        uid = IUUID(self.doc2)\n+        response = self.api_session.patch(\n+            "/doc-1",\n+            json={\n+                "blocks": {\n+                    "uuid1": {\n+                        "@type": "foo",\n+                        "url": "../resolveuid/{}".format(uid),\n+                    }\n+                }\n+            },\n+        )\n+        transaction.commit()\n+        self.assertEqual(response.status_code, 204)\n+        back_references = self.get_back_references(self.doc2)\n+        self.assertEqual(len(back_references), 1)\n+        self.assertEqual(back_references[0], self.doc1)\n+\n+    def test_reference_correctly_unset_for_generic_blocks_with_url(self):\n+        uid = IUUID(self.doc2)\n+        self.api_session.patch(\n+            "/doc-1",\n+            json={\n+                "blocks": {\n+                    "uuid1": {\n+                        "@type": "foo",\n+                        "url": "../resolveuid/{}".format(uid),\n+                    }\n+                }\n+            },\n+        )\n+        transaction.commit()\n+        back_references = self.get_back_references(self.doc2)\n+        self.assertEqual(len(back_references), 1)\n+\n+        # now unset reference\n+        self.api_session.patch(\n+            "/doc-1",\n+            json={\n+                "blocks": {"uuid1": {"@type": "foo", "href": "http://www.plone.org"}}\n+            },\n+        )\n+        transaction.commit()\n+        back_references = self.get_back_references(self.doc2)\n+        self.assertEqual(len(back_references), 0)\n+\n+    def test_delete_confirm_info_return_right_values(self):\n+        uid = IUUID(self.doc2)\n+        self.api_session.patch(\n+            "/doc-1",\n+            json={\n+                "blocks": {\n+                    "uuid1": {\n+                        "@type": "text",\n+                        "text": {\n+                            "blocks": [{"text": "This is a link to second doc "}],\n+                            "entityMap": {\n+                                "0": {\n+                                    "data": {\n+                                        "href": "../resolveuid/{}".format(uid),\n+                                        "rel": "nofollow",\n+                                        "url": "../resolveuid/{}".format(uid),\n+                                    },\n+                                    "mutability": "MUTABLE",\n+                                    "type": "LINK",\n+                                }\n+                            },\n+                        },\n+                    }\n+                }\n+            },\n+        )\n+        transaction.commit()\n+        links_info = self.doc2.restrictedTraverse("@@delete_confirmation_info")\n+        breaches = links_info.get_breaches()\n+\n+        self.assertEqual(len(breaches), 1)\n+        self.assertEqual(len(breaches[0]["sources"]), 1)\n+        self.assertEqual(breaches[0]["sources"][0]["uid"], IUUID(self.doc1))\n+\n+        # now try to unset internal link\n+        self.api_session.patch(\n+            "/doc-1",\n+            json={\n+                "blocks": {\n+                    "uuid1": {\n+                        "@type": "text",\n+                        "text": {\n+                            "blocks": [{"text": "Now we set an external link"}],\n+                            "entityMap": {\n+                                "0": {\n+                                    "data": {\n+                                        "href": "http://www.plone.org",\n+                                        "rel": "nofollow",\n+                                        "url": "http://www.plone.org",\n+                                    },\n+                                    "mutability": "MUTABLE",\n+                                    "type": "LINK",\n+                                }\n+                            },\n+                        },\n+                    }\n+                }\n+            },\n+        )\n+        transaction.commit()\n+        links_info = self.doc2.restrictedTraverse("@@delete_confirmation_info")\n+        breaches = links_info.get_breaches()\n+\n+        self.assertEqual(len(breaches), 0)\ndiff --git a/src/plone/restapi/tests/test_services_linkintegrity.py b/src/plone/restapi/tests/test_services_linkintegrity.py\nnew file mode 100644\nindex 000000000..6de9b1244\n--- /dev/null\n+++ b/src/plone/restapi/tests/test_services_linkintegrity.py\n@@ -0,0 +1,190 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.testing import setRoles\n+from plone.app.testing import SITE_OWNER_NAME\n+from plone.app.testing import SITE_OWNER_PASSWORD\n+from plone.app.testing import TEST_USER_ID\n+from plone.dexterity.utils import createContentInContainer\n+from plone.registry.interfaces import IRegistry\n+from plone.restapi.testing import PLONE_RESTAPI_BLOCKS_FUNCTIONAL_TESTING\n+from plone.restapi.testing import RelativeSession\n+from plone.uuid.interfaces import IUUID\n+from Products.CMFPlone.interfaces import IEditingSchema\n+from z3c.relationfield import RelationValue\n+from zope.component import getUtility\n+from zope.event import notify\n+from zope.intid.interfaces import IIntIds\n+from zope.lifecycleevent import ObjectModifiedEvent\n+\n+import transaction\n+import unittest\n+\n+\n+class TestLinkIntegrity(unittest.TestCase):\n+\n+    layer = PLONE_RESTAPI_BLOCKS_FUNCTIONAL_TESTING\n+\n+    def setUp(self):\n+        self.app = self.layer["app"]\n+        self.portal = self.layer["portal"]\n+        self.portal_url = self.portal.absolute_url()\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+\n+        self.api_session = RelativeSession(self.portal_url)\n+        self.api_session.headers.update({"Accept": "application/json"})\n+        self.api_session.auth = (SITE_OWNER_NAME, SITE_OWNER_PASSWORD)\n+\n+        self.doc1 = createContentInContainer(\n+            self.portal, "Document", id="doc-1", title="First document"\n+        )\n+        self.doc2 = createContentInContainer(\n+            self.portal, "Document", id="doc-2", title="Second document"\n+        )\n+        transaction.commit()\n+\n+    def tearDown(self):\n+        self.api_session.close()\n+\n+    def test_required_uids(self):\n+        response = self.api_session.get("/@linkintegrity")\n+\n+        self.assertEqual(response.status_code, 400)\n+\n+    def test_return_empty_list_for_non_referenced_objects(self):\n+        response = self.api_session.get(\n+            "/@linkintegrity", params={"uids": [self.doc1.UID()]}\n+        )\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response.json(), [])\n+\n+    def test_return_right_breaches_for_reference_field(self):\n+        intids = getUtility(IIntIds)\n+        self.doc1.relatedItems = [RelationValue(intids.getId(self.doc2))]\n+        notify(ObjectModifiedEvent(self.doc1))\n+        transaction.commit()\n+\n+        response = self.api_session.get(\n+            "/@linkintegrity", params={"uids": [self.doc2.UID()]}\n+        )\n+        result = response.json()\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(len(result), 1)\n+        self.assertEqual(result[0]["@id"], self.doc2.absolute_url())\n+\n+        breaches = result[0]["breaches"]\n+        self.assertEqual(len(breaches), 1)\n+        self.assertEqual(breaches[0]["uid"], IUUID(self.doc1))\n+        self.assertEqual(breaches[0]["@id"], self.doc1.absolute_url())\n+\n+    def test_do_not_return_breaches_if_check_is_disabled(self):\n+        registry = getUtility(IRegistry)\n+        settings = registry.forInterface(IEditingSchema, prefix="plone")\n+        settings.enable_link_integrity_checks = False\n+        intids = getUtility(IIntIds)\n+        self.doc1.relatedItems = [RelationValue(intids.getId(self.doc2))]\n+        notify(ObjectModifiedEvent(self.doc1))\n+        transaction.commit()\n+\n+        response = self.api_session.get(\n+            "/@linkintegrity", params={"uids": [self.doc2.UID()]}\n+        )\n+        breaches = response.json()\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(breaches, [])\n+\n+    def test_return_right_breaches_for_blocks(self):\n+        response = self.api_session.get(\n+            "/@linkintegrity", params={"uids": [self.doc2.UID()]}\n+        )\n+        breaches = response.json()\n+        self.assertEqual(breaches, [])\n+\n+        # create a new content with relations\n+        uid = IUUID(self.doc2)\n+        doc_with_rel = createContentInContainer(\n+            self.portal,\n+            "Document",\n+            id="doc-with-rel",\n+            title="Document with relations",\n+            blocks={\n+                "block-uuid1": {\n+                    "@type": "text",\n+                    "text": {\n+                        "blocks": [{"text": "This is a link to second doc "}],\n+                        "entityMap": {\n+                            "0": {\n+                                "data": {\n+                                    "href": "../resolveuid/{}".format(uid),\n+                                    "rel": "nofollow",\n+                                    "url": "../resolveuid/{}".format(uid),\n+                                },\n+                                "mutability": "MUTABLE",\n+                                "type": "LINK",\n+                            }\n+                        },\n+                    },\n+                }\n+            },\n+        )\n+        transaction.commit()\n+\n+        response = self.api_session.get(\n+            "/@linkintegrity", params={"uids": [self.doc2.UID()]}\n+        )\n+\n+        result = response.json()\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(len(result), 1)\n+        self.assertEqual(result[0]["@id"], self.doc2.absolute_url())\n+\n+        breaches = result[0]["breaches"]\n+        self.assertEqual(len(breaches), 1)\n+        self.assertEqual(breaches[0]["uid"], IUUID(doc_with_rel))\n+        self.assertEqual(breaches[0]["@id"], doc_with_rel.absolute_url())\n+\n+    def test_return_breaches_for_contents_in_subfolders(self):\n+        # create a folder structure\n+\n+        createContentInContainer(self.portal, "Folder", id="level1")\n+        createContentInContainer(self.portal["level1"], "Folder", id="level2")\n+\n+        uid = IUUID(self.doc2)\n+        doc_in_folder = createContentInContainer(\n+            self.portal["level1"]["level2"],\n+            "Document",\n+            id="doc-in-folder",\n+            title="Document in folder",\n+            blocks={\n+                "block-uuid1": {\n+                    "@type": "text",\n+                    "text": {\n+                        "blocks": [{"text": "This is a link to second doc "}],\n+                        "entityMap": {\n+                            "0": {\n+                                "data": {\n+                                    "href": "../resolveuid/{}".format(uid),\n+                                    "rel": "nofollow",\n+                                    "url": "../resolveuid/{}".format(uid),\n+                                },\n+                                "mutability": "MUTABLE",\n+                                "type": "LINK",\n+                            }\n+                        },\n+                    },\n+                }\n+            },\n+        )\n+        transaction.commit()\n+\n+        response = self.api_session.get(\n+            "/@linkintegrity", params={"uids": [self.doc2.UID()]}\n+        )\n+\n+        result = response.json()\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(len(result), 1)\n+        self.assertEqual(result[0]["@id"], self.doc2.absolute_url())\n+\n+        breaches = result[0]["breaches"]\n+        self.assertEqual(len(breaches), 1)\n+        self.assertEqual(breaches[0]["uid"], IUUID(doc_in_folder))\n+        self.assertEqual(breaches[0]["@id"], doc_in_folder.absolute_url())\n'

