Repository: plone.dexterity


Branch: refs/heads/master
Date: 2019-10-02T12:37:33+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.dexterity/commit/ea8643c8d49e099911a13669271171612b2cd18e

cache expensive assignable lookup

Files changed:
A news/115.bugfix
M plone/dexterity/content.py

b'diff --git a/news/115.bugfix b/news/115.bugfix\nnew file mode 100644\nindex 0000000..345106e\n--- /dev/null\n+++ b/news/115.bugfix\n@@ -0,0 +1,2 @@\n+Performance enhancement in schema cache and assignable.\n+[jensens]\ndiff --git a/plone/dexterity/content.py b/plone/dexterity/content.py\nindex 72b8a66..75d56c6 100644\n--- a/plone/dexterity/content.py\n+++ b/plone/dexterity/content.py\n@@ -40,6 +40,7 @@\n from zope.annotation import IAttributeAnnotatable\n from zope.component import queryUtility\n from zope.container.contained import Contained\n+from zope.globalrequest import getRequest\n from zope.interface import implementer\n from zope.interface.declarations import getObjectSpecification\n from zope.interface.declarations import implementedBy\n@@ -70,6 +71,8 @@\n     \'translation_service\',\n )\n \n+ASSIGNABLE_CACHE_KEY = \'__plone_dexterity_assignable_cache__\'\n+\n \n def _default_from_schema(context, schema, fieldname):\n     """helper to lookup default value of a field\n@@ -89,6 +92,32 @@ def _default_from_schema(context, schema, fieldname):\n     return deepcopy(field.default)\n \n \n+def get_assignable(context):\n+    """get the BehaviorAssignable for the context.\n+\n+    Read from cache on request if needed (twice as fast as lookup)\n+\n+    returns IBehaviorAssignable providing instance or None\n+    """\n+    request = getRequest()\n+    if not request:\n+        return IBehaviorAssignable(context, None)\n+    cache_key = getattr(context, \'_p_oid\', None)\n+    if not cache_key:\n+        return IBehaviorAssignable(context, None)\n+    assignable_cache = getattr(request, ASSIGNABLE_CACHE_KEY, _marker)\n+    if assignable_cache is _marker:\n+        assignable_cache = dict()\n+        setattr(request, ASSIGNABLE_CACHE_KEY, assignable_cache)\n+    assignable = assignable_cache.get(cache_key, _marker)\n+    if assignable is _marker:\n+        assignable_cache[cache_key] = assignable = IBehaviorAssignable(\n+            context,\n+            None,\n+        )\n+    return assignable\n+\n+\n class FTIAwareSpecification(ObjectSpecificationDescriptor):\n     """A __providedBy__ decorator that returns the interfaces provided by\n     the object, plus the schema interface set in the FTI.\n@@ -148,7 +177,7 @@ def __get__(self, inst, cls=None):\n         # block recursion\n         self.__recursion__ = True\n         try:\n-            assignable = IBehaviorAssignable(inst, None)\n+            assignable = get_assignable(inst)\n             if assignable is not None:\n                 for behavior_registration in assignable.enumerateBehaviors():\n                     if behavior_registration.marker:\n@@ -365,8 +394,8 @@ def __getattr__(self, name):\n         if value is not _marker:\n             return value\n \n-        # do the same for each subtype\n-        assignable = IBehaviorAssignable(self, None)\n+        # do the same for each behavior\n+        assignable = get_assignable(self)\n         if assignable is not None:\n             for behavior_registration in assignable.enumerateBehaviors():\n                 if behavior_registration.interface:\n'

Repository: plone.dexterity


Branch: refs/heads/master
Date: 2019-10-02T14:16:54+02:00
Author: Alessandro Pisa (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.dexterity/commit/e155797ca1f78a584dcf80f28f38e08bdede0d10

Merge pull request #115 from plone/jensens-performance-assignable-cache

Performance: Cache expensive assignable lookup

Files changed:
A news/115.bugfix
M plone/dexterity/content.py

b'diff --git a/news/115.bugfix b/news/115.bugfix\nnew file mode 100644\nindex 0000000..345106e\n--- /dev/null\n+++ b/news/115.bugfix\n@@ -0,0 +1,2 @@\n+Performance enhancement in schema cache and assignable.\n+[jensens]\ndiff --git a/plone/dexterity/content.py b/plone/dexterity/content.py\nindex 72b8a66..75d56c6 100644\n--- a/plone/dexterity/content.py\n+++ b/plone/dexterity/content.py\n@@ -40,6 +40,7 @@\n from zope.annotation import IAttributeAnnotatable\n from zope.component import queryUtility\n from zope.container.contained import Contained\n+from zope.globalrequest import getRequest\n from zope.interface import implementer\n from zope.interface.declarations import getObjectSpecification\n from zope.interface.declarations import implementedBy\n@@ -70,6 +71,8 @@\n     \'translation_service\',\n )\n \n+ASSIGNABLE_CACHE_KEY = \'__plone_dexterity_assignable_cache__\'\n+\n \n def _default_from_schema(context, schema, fieldname):\n     """helper to lookup default value of a field\n@@ -89,6 +92,32 @@ def _default_from_schema(context, schema, fieldname):\n     return deepcopy(field.default)\n \n \n+def get_assignable(context):\n+    """get the BehaviorAssignable for the context.\n+\n+    Read from cache on request if needed (twice as fast as lookup)\n+\n+    returns IBehaviorAssignable providing instance or None\n+    """\n+    request = getRequest()\n+    if not request:\n+        return IBehaviorAssignable(context, None)\n+    cache_key = getattr(context, \'_p_oid\', None)\n+    if not cache_key:\n+        return IBehaviorAssignable(context, None)\n+    assignable_cache = getattr(request, ASSIGNABLE_CACHE_KEY, _marker)\n+    if assignable_cache is _marker:\n+        assignable_cache = dict()\n+        setattr(request, ASSIGNABLE_CACHE_KEY, assignable_cache)\n+    assignable = assignable_cache.get(cache_key, _marker)\n+    if assignable is _marker:\n+        assignable_cache[cache_key] = assignable = IBehaviorAssignable(\n+            context,\n+            None,\n+        )\n+    return assignable\n+\n+\n class FTIAwareSpecification(ObjectSpecificationDescriptor):\n     """A __providedBy__ decorator that returns the interfaces provided by\n     the object, plus the schema interface set in the FTI.\n@@ -148,7 +177,7 @@ def __get__(self, inst, cls=None):\n         # block recursion\n         self.__recursion__ = True\n         try:\n-            assignable = IBehaviorAssignable(inst, None)\n+            assignable = get_assignable(inst)\n             if assignable is not None:\n                 for behavior_registration in assignable.enumerateBehaviors():\n                     if behavior_registration.marker:\n@@ -365,8 +394,8 @@ def __getattr__(self, name):\n         if value is not _marker:\n             return value\n \n-        # do the same for each subtype\n-        assignable = IBehaviorAssignable(self, None)\n+        # do the same for each behavior\n+        assignable = get_assignable(self)\n         if assignable is not None:\n             for behavior_registration in assignable.enumerateBehaviors():\n                 if behavior_registration.interface:\n'

