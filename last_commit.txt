Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2019-07-12T08:35:05+02:00
Author: Manuel Reinhardt (reinhardt) <reinhardt@syslab.com>
Commit: https://github.com/plone/plone.app.vocabularies/commit/a04fa1849b1d82b0e2bcdb118ebdc262a3531d75

Principals vocabularies: Fixed handling of results from multiple PAS plugins (like pasldap and mutable_properties).
Closes #60

Files changed:
A news/60.bugfix
M plone/app/vocabularies/principals.py
M plone/app/vocabularies/tests/test_principals.py

b'diff --git a/news/60.bugfix b/news/60.bugfix\nnew file mode 100644\nindex 0000000..a1731d1\n--- /dev/null\n+++ b/news/60.bugfix\n@@ -0,0 +1 @@\n+Principals vocabularies: Fixed handling of results from multiple PAS plugins (like pasldap and mutable_properties).\ndiff --git a/plone/app/vocabularies/principals.py b/plone/app/vocabularies/principals.py\nindex 1483a48..ece63f3 100644\n--- a/plone/app/vocabularies/principals.py\n+++ b/plone/app/vocabularies/principals.py\n@@ -59,6 +59,22 @@ def token_from_principal_info(info, prefix=False):\n     return \'{0}__{1}\'.format(info[\'principal_type\'], info[\'id\'])\n \n \n+def merge_principal_infos(infos, prefix=False):\n+    info = infos[0]\n+    if len(infos) > 1:\n+        principal_types = set([\n+            info[\'principal_type\'] for info in infos if info[\'principal_type\']]\n+        )\n+        if len(principal_types) > 1:\n+            # Principals with the same ID but different types. Should not\n+            # happen.\n+            raise ValueError(\'Principal ID not unique: {}\'.format(info[\'id\']))\n+        info[\'title\'] = \';\'.join(\n+            [info[\'title\'] for info in infos if info[\'title\']]\n+        )\n+    return info\n+\n+\n def _get_acl_users():\n     return getToolByName(getSite(), \'acl_users\')\n \n@@ -219,14 +235,26 @@ def term_triples():\n                 search = getattr(acl_users, search_cfg[\'search\'])\n                 searchargs = search_cfg[\'searchargs\'].copy()\n                 searchargs[search_cfg[\'searchattr\']] = query\n+                infotree = {}\n                 for info in search(**searchargs):\n-                    value = info[\'id\']\n-                    if cfg[\'prefix\']:\n-                        value = \'{0}:{1}\'.format(info[\'principal_type\'], value)\n-                    token = token_from_principal_info(\n-                        info, prefix=cfg[\'prefix\']\n-                    )\n-                    yield (value, token, info[\'title\'])\n+                    infotree.setdefault(\n+                        info[\'id\'], {}).setdefault(\n+                            info[\'principal_type\'], []).append(\n+                                info)\n+                for principal_id, types_infos in infotree.items():\n+                    if len(types_infos) > 1 and not cfg[\'prefix\']:\n+                        raise ValueError(\'Principal ID not unique: {}\'.format(\n+                            principal_id))\n+                    for principal_type, principal_infos in types_infos.items():\n+                        value = principal_id\n+                        info = merge_principal_infos(principal_infos)\n+                        if cfg[\'prefix\']:\n+                            value = \'{0}:{1}\'.format(\n+                                info[\'principal_type\'], value)\n+                        token = token_from_principal_info(\n+                            info, prefix=cfg[\'prefix\']\n+                        )\n+                        yield (value, token, info[\'title\'])\n \n         vocabulary = PrincipalsVocabulary(\n             [\ndiff --git a/plone/app/vocabularies/tests/test_principals.py b/plone/app/vocabularies/tests/test_principals.py\nindex b60fed3..134a629 100644\n--- a/plone/app/vocabularies/tests/test_principals.py\n+++ b/plone/app/vocabularies/tests/test_principals.py\n@@ -1,6 +1,7 @@\n # -*- coding: utf-8 -*-\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n \n+import mock\n import unittest\n \n \n@@ -387,3 +388,103 @@ def test_factory_principal_query(self):\n         self.assertTrue(\'user:us\xc3\xa9r2\' in vocab)\n         self.assertTrue(\'group:gro\xc3\xbcp0\' in vocab)\n         self.assertTrue(\'group:gro\xc3\xbcp2\' in vocab)\n+\n+    def test_factory_user_duplicate(self):\n+        """ For an LDAP user that has logged in at least once, we get one\n+        result each from pasldap and from mutable_properties. This should be\n+        treated as one user.\n+        """\n+        with mock.patch(\n+            \'plone.app.vocabularies.principals._get_acl_users\',\n+        ) as fake_get_acl_users:\n+            fake_get_acl_users.return_value.searchUsers.return_value = (\n+                    {\'id\': \'ldapus\xc3\xa9r\',\n+                     \'login\': \'ldapus\xc3\xa9r\',\n+                     \'pluginid\': \'pasldap\',\n+                     \'userid\': \'ldapus\xc3\xa9r\',\n+                     \'principal_type\': \'user\',\n+                     \'title\': \'LDAP Us\xc3\xa9r\'},\n+                    {\'id\': \'ldapus\xc3\xa9r\',\n+                     \'login\': \'ldapus\xc3\xa9r\',\n+                     \'title\': \'\',\n+                     \'description\': \'\',\n+                     \'email\': \'\',\n+                     \'pluginid\': \'mutable_properties\',\n+                     \'userid\': \'ldapus\xc3\xa9r\',\n+                     \'principal_type\': \'user\'},\n+            )\n+            from plone.app.vocabularies.principals import UsersFactory\n+\n+            factory = UsersFactory()\n+            vocab = factory(self.portal)\n+            self.assertEqual(vocab.getTerm(\'ldapus\xc3\xa9r\').title, \'LDAP Us\xc3\xa9r\')\n+\n+    def test_factory_user_conflict(self):\n+        """ In a user vocabulary, multiple results for the same principal ID\n+        but with different principal_type values indicate some problem. Raise\n+        an error.\n+        """\n+        with mock.patch(\n+            \'plone.app.vocabularies.principals._get_acl_users\',\n+        ) as fake_get_acl_users:\n+            fake_get_acl_users.return_value.searchUsers.return_value = (\n+                    {\'id\': \'ldapus\xc3\xa9r\',\n+                     \'login\': \'ldapus\xc3\xa9r\',\n+                     \'pluginid\': \'pasldap\',\n+                     \'userid\': \'ldapus\xc3\xa9r\',\n+                     \'principal_type\': \'user\',\n+                     \'title\': \'LDAP Us\xc3\xa9r\'},\n+                    {\'id\': \'ldapus\xc3\xa9r\',\n+                     \'login\': \'ldapus\xc3\xa9r\',\n+                     \'title\': \'\',\n+                     \'description\': \'\',\n+                     \'email\': \'\',\n+                     \'pluginid\': \'mutable_properties\',\n+                     \'userid\': \'ldapus\xc3\xa9r\',\n+                     \'principal_type\': \'unknown\'},\n+            )\n+            from plone.app.vocabularies.principals import UsersFactory\n+\n+            factory = UsersFactory()\n+            self.assertRaises(\n+                ValueError,\n+                factory,\n+                self.portal,\n+            )\n+\n+    def test_factory_principal_conflict(self):\n+        """ In a principal vocabulary, multiple results for the same principal\n+        ID but with different principal_type values can be handled because they\n+        are prefixed.\n+        """\n+        with mock.patch(\n+            \'plone.app.vocabularies.principals._get_acl_users\',\n+        ) as fake_get_acl_users:\n+            fake_get_acl_users.return_value.searchUsers.return_value = (\n+                    {\'id\': \'duplicat\xc3\xa9\',\n+                     \'login\': \'duplicat\xc3\xa9\',\n+                     \'pluginid\': \'pasldap\',\n+                     \'userid\': \'duplicat\xc3\xa9\',\n+                     \'principal_type\': \'user\',\n+                     \'title\': \'Duplicat\xc3\xa9 User\'},\n+                    {\'id\': \'duplicat\xc3\xa9\',\n+                     \'login\': \'duplicat\xc3\xa9\',\n+                     \'title\': \'Duplicat\xc3\xa9 Group\',\n+                     \'description\': \'\',\n+                     \'email\': \'\',\n+                     \'pluginid\': \'source_groups\',\n+                     \'userid\': \'duplicat\xc3\xa9\',\n+                     \'principal_type\': \'group\'},\n+            )\n+            from plone.app.vocabularies.principals import PrincipalsFactory\n+\n+            factory = PrincipalsFactory()\n+            vocab = factory(self.portal)\n+            self.assertEqual(\n+                vocab.getTerm(\'user:duplicat\xc3\xa9\').title,\n+                \'Duplicat\xc3\xa9 User\',\n+            )\n+            self.assertEqual(\n+                vocab.getTerm(\'group:duplicat\xc3\xa9\').title,\n+                \'Duplicat\xc3\xa9 Group\',\n+            )\n'

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2019-07-12T14:22:08+02:00
Author: Manuel Reinhardt (reinhardt) <reinhardt@syslab.com>
Commit: https://github.com/plone/plone.app.vocabularies/commit/be08e5094f81e7e73b2936c1b52fa4563d051061

Principals: don't merge titles.
The first one is the one from the plugin with the highest priority.

Files changed:
M plone/app/vocabularies/principals.py

b"diff --git a/plone/app/vocabularies/principals.py b/plone/app/vocabularies/principals.py\nindex ece63f3..49afebd 100644\n--- a/plone/app/vocabularies/principals.py\n+++ b/plone/app/vocabularies/principals.py\n@@ -69,9 +69,11 @@ def merge_principal_infos(infos, prefix=False):\n             # Principals with the same ID but different types. Should not\n             # happen.\n             raise ValueError('Principal ID not unique: {}'.format(info['id']))\n-        info['title'] = ';'.join(\n-            [info['title'] for info in infos if info['title']]\n-        )\n+        if not info['title']:\n+            for candidate in infos:\n+                if candidate['title']:\n+                    info['title'] = candidate['title']\n+                    break\n     return info\n \n \n"

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2019-07-18T10:52:45+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.vocabularies/commit/739495a455f290684e998c446ff23eb5a75bad71

Merge pull request #61 from plone/60-principals-vocab-ldap

Principals vocabularies: Fixed handling of results from multiple PAS plugins

Files changed:
A news/60.bugfix
M plone/app/vocabularies/principals.py
M plone/app/vocabularies/tests/test_principals.py

b'diff --git a/news/60.bugfix b/news/60.bugfix\nnew file mode 100644\nindex 0000000..a1731d1\n--- /dev/null\n+++ b/news/60.bugfix\n@@ -0,0 +1 @@\n+Principals vocabularies: Fixed handling of results from multiple PAS plugins (like pasldap and mutable_properties).\ndiff --git a/plone/app/vocabularies/principals.py b/plone/app/vocabularies/principals.py\nindex 1483a48..49afebd 100644\n--- a/plone/app/vocabularies/principals.py\n+++ b/plone/app/vocabularies/principals.py\n@@ -59,6 +59,24 @@ def token_from_principal_info(info, prefix=False):\n     return \'{0}__{1}\'.format(info[\'principal_type\'], info[\'id\'])\n \n \n+def merge_principal_infos(infos, prefix=False):\n+    info = infos[0]\n+    if len(infos) > 1:\n+        principal_types = set([\n+            info[\'principal_type\'] for info in infos if info[\'principal_type\']]\n+        )\n+        if len(principal_types) > 1:\n+            # Principals with the same ID but different types. Should not\n+            # happen.\n+            raise ValueError(\'Principal ID not unique: {}\'.format(info[\'id\']))\n+        if not info[\'title\']:\n+            for candidate in infos:\n+                if candidate[\'title\']:\n+                    info[\'title\'] = candidate[\'title\']\n+                    break\n+    return info\n+\n+\n def _get_acl_users():\n     return getToolByName(getSite(), \'acl_users\')\n \n@@ -219,14 +237,26 @@ def term_triples():\n                 search = getattr(acl_users, search_cfg[\'search\'])\n                 searchargs = search_cfg[\'searchargs\'].copy()\n                 searchargs[search_cfg[\'searchattr\']] = query\n+                infotree = {}\n                 for info in search(**searchargs):\n-                    value = info[\'id\']\n-                    if cfg[\'prefix\']:\n-                        value = \'{0}:{1}\'.format(info[\'principal_type\'], value)\n-                    token = token_from_principal_info(\n-                        info, prefix=cfg[\'prefix\']\n-                    )\n-                    yield (value, token, info[\'title\'])\n+                    infotree.setdefault(\n+                        info[\'id\'], {}).setdefault(\n+                            info[\'principal_type\'], []).append(\n+                                info)\n+                for principal_id, types_infos in infotree.items():\n+                    if len(types_infos) > 1 and not cfg[\'prefix\']:\n+                        raise ValueError(\'Principal ID not unique: {}\'.format(\n+                            principal_id))\n+                    for principal_type, principal_infos in types_infos.items():\n+                        value = principal_id\n+                        info = merge_principal_infos(principal_infos)\n+                        if cfg[\'prefix\']:\n+                            value = \'{0}:{1}\'.format(\n+                                info[\'principal_type\'], value)\n+                        token = token_from_principal_info(\n+                            info, prefix=cfg[\'prefix\']\n+                        )\n+                        yield (value, token, info[\'title\'])\n \n         vocabulary = PrincipalsVocabulary(\n             [\ndiff --git a/plone/app/vocabularies/tests/test_principals.py b/plone/app/vocabularies/tests/test_principals.py\nindex b60fed3..134a629 100644\n--- a/plone/app/vocabularies/tests/test_principals.py\n+++ b/plone/app/vocabularies/tests/test_principals.py\n@@ -1,6 +1,7 @@\n # -*- coding: utf-8 -*-\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n \n+import mock\n import unittest\n \n \n@@ -387,3 +388,103 @@ def test_factory_principal_query(self):\n         self.assertTrue(\'user:us\xc3\xa9r2\' in vocab)\n         self.assertTrue(\'group:gro\xc3\xbcp0\' in vocab)\n         self.assertTrue(\'group:gro\xc3\xbcp2\' in vocab)\n+\n+    def test_factory_user_duplicate(self):\n+        """ For an LDAP user that has logged in at least once, we get one\n+        result each from pasldap and from mutable_properties. This should be\n+        treated as one user.\n+        """\n+        with mock.patch(\n+            \'plone.app.vocabularies.principals._get_acl_users\',\n+        ) as fake_get_acl_users:\n+            fake_get_acl_users.return_value.searchUsers.return_value = (\n+                    {\'id\': \'ldapus\xc3\xa9r\',\n+                     \'login\': \'ldapus\xc3\xa9r\',\n+                     \'pluginid\': \'pasldap\',\n+                     \'userid\': \'ldapus\xc3\xa9r\',\n+                     \'principal_type\': \'user\',\n+                     \'title\': \'LDAP Us\xc3\xa9r\'},\n+                    {\'id\': \'ldapus\xc3\xa9r\',\n+                     \'login\': \'ldapus\xc3\xa9r\',\n+                     \'title\': \'\',\n+                     \'description\': \'\',\n+                     \'email\': \'\',\n+                     \'pluginid\': \'mutable_properties\',\n+                     \'userid\': \'ldapus\xc3\xa9r\',\n+                     \'principal_type\': \'user\'},\n+            )\n+            from plone.app.vocabularies.principals import UsersFactory\n+\n+            factory = UsersFactory()\n+            vocab = factory(self.portal)\n+            self.assertEqual(vocab.getTerm(\'ldapus\xc3\xa9r\').title, \'LDAP Us\xc3\xa9r\')\n+\n+    def test_factory_user_conflict(self):\n+        """ In a user vocabulary, multiple results for the same principal ID\n+        but with different principal_type values indicate some problem. Raise\n+        an error.\n+        """\n+        with mock.patch(\n+            \'plone.app.vocabularies.principals._get_acl_users\',\n+        ) as fake_get_acl_users:\n+            fake_get_acl_users.return_value.searchUsers.return_value = (\n+                    {\'id\': \'ldapus\xc3\xa9r\',\n+                     \'login\': \'ldapus\xc3\xa9r\',\n+                     \'pluginid\': \'pasldap\',\n+                     \'userid\': \'ldapus\xc3\xa9r\',\n+                     \'principal_type\': \'user\',\n+                     \'title\': \'LDAP Us\xc3\xa9r\'},\n+                    {\'id\': \'ldapus\xc3\xa9r\',\n+                     \'login\': \'ldapus\xc3\xa9r\',\n+                     \'title\': \'\',\n+                     \'description\': \'\',\n+                     \'email\': \'\',\n+                     \'pluginid\': \'mutable_properties\',\n+                     \'userid\': \'ldapus\xc3\xa9r\',\n+                     \'principal_type\': \'unknown\'},\n+            )\n+            from plone.app.vocabularies.principals import UsersFactory\n+\n+            factory = UsersFactory()\n+            self.assertRaises(\n+                ValueError,\n+                factory,\n+                self.portal,\n+            )\n+\n+    def test_factory_principal_conflict(self):\n+        """ In a principal vocabulary, multiple results for the same principal\n+        ID but with different principal_type values can be handled because they\n+        are prefixed.\n+        """\n+        with mock.patch(\n+            \'plone.app.vocabularies.principals._get_acl_users\',\n+        ) as fake_get_acl_users:\n+            fake_get_acl_users.return_value.searchUsers.return_value = (\n+                    {\'id\': \'duplicat\xc3\xa9\',\n+                     \'login\': \'duplicat\xc3\xa9\',\n+                     \'pluginid\': \'pasldap\',\n+                     \'userid\': \'duplicat\xc3\xa9\',\n+                     \'principal_type\': \'user\',\n+                     \'title\': \'Duplicat\xc3\xa9 User\'},\n+                    {\'id\': \'duplicat\xc3\xa9\',\n+                     \'login\': \'duplicat\xc3\xa9\',\n+                     \'title\': \'Duplicat\xc3\xa9 Group\',\n+                     \'description\': \'\',\n+                     \'email\': \'\',\n+                     \'pluginid\': \'source_groups\',\n+                     \'userid\': \'duplicat\xc3\xa9\',\n+                     \'principal_type\': \'group\'},\n+            )\n+            from plone.app.vocabularies.principals import PrincipalsFactory\n+\n+            factory = PrincipalsFactory()\n+            vocab = factory(self.portal)\n+            self.assertEqual(\n+                vocab.getTerm(\'user:duplicat\xc3\xa9\').title,\n+                \'Duplicat\xc3\xa9 User\',\n+            )\n+            self.assertEqual(\n+                vocab.getTerm(\'group:duplicat\xc3\xa9\').title,\n+                \'Duplicat\xc3\xa9 Group\',\n+            )\n'

