Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2023-04-03T00:29:10+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/fcd8c7c1c8e425e073be0c219b7c12b3807b1f82

Configuring with plone/meta

Files changed:
A .editorconfig
A .meta.toml
A .pre-commit-config.yaml
A news/5623f8b3.internal
A tox.ini
M pyproject.toml
M setup.cfg

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..4f67994\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "5623f8b3"\ndiff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nnew file mode 100644\nindex 0000000..449e951\n--- /dev/null\n+++ b/.pre-commit-config.yaml\n@@ -0,0 +1,42 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+ci:\n+    autofix_prs: false\n+    autoupdate_schedule: monthly\n+\n+repos:\n+-   repo: https://github.com/asottile/pyupgrade\n+    rev: v3.3.1\n+    hooks:\n+    -   id: pyupgrade\n+        args: [--py38-plus]\n+-   repo: https://github.com/pycqa/isort\n+    rev: 5.12.0\n+    hooks:\n+    -   id: isort\n+-   repo: https://github.com/psf/black\n+    rev: 23.1.0\n+    hooks:\n+    -   id: black\n+-   repo: https://github.com/collective/zpretty\n+    rev: 3.0.3\n+    hooks:\n+    -   id: zpretty\n+-   repo: https://github.com/PyCQA/flake8\n+    rev: 6.0.0\n+    hooks:\n+    -   id: flake8\n+-   repo: https://github.com/codespell-project/codespell\n+    rev: v2.2.2\n+    hooks:\n+    -   id: codespell\n+        additional_dependencies:\n+          - tomli\n+-   repo: https://github.com/mgedmin/check-manifest\n+    rev: "0.49"\n+    hooks:\n+    -   id: check-manifest\n+-   repo: https://github.com/regebro/pyroma\n+    rev: "4.2"\n+    hooks:\n+    -   id: pyroma\ndiff --git a/news/5623f8b3.internal b/news/5623f8b3.internal\nnew file mode 100644\nindex 0000000..c08f539\n--- /dev/null\n+++ b/news/5623f8b3.internal\n@@ -0,0 +1,2 @@\n+Update configuration files.\n+[plone devs]\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..9eb73f3 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,43 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "internal"\n+name = "Internal:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "documentation"\n+name = "Documentation:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "tests"\n+name = "Tests"\n+showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\n+\n+[tool.dependencychecker]\n+Zope = [\n+  # Zope own provided namespaces\n+  \'App\', \'OFS\', \'Products.Five\', \'Products.OFSP\', \'Products.PageTemplates\',\n+  \'Products.SiteAccess\', \'Shared\', \'Testing\', \'ZPublisher\', \'ZTUtils\',\n+  \'Zope2\', \'webdav\', \'zmi\',\n+  # Zope dependencies\n+  \'Acquisition\', \'DateTime\', \'transaction\', \'zExceptions\', \'ZODB\', \'zope.component\',\n+  \'zope.configuration\', \'zope.container\', \'zope.deferredimport\', \'zope.event\',\n+  \'zope.exceptions\', \'zope.globalrequest\', \'zope.i18n\', \'zope.i18nmessageid\',\n+  \'zope.interface\', \'zope.lifecycleevent\', \'zope.location\', \'zope.publisher\',\n+  \'zope.schema\', \'zope.security\', \'zope.site\', \'zope.traversing\', \'AccessControl\',\n+]\n+\'plone.base\' = [\n+  \'AccessControl\', \'Products.BTreeFolder2\', \'Products.CMFCore\',\n+  \'Products.CMFDynamicViewFTI\', \'zope.deprecation\',\n+]\n+python-dateutil = [\'dateutil\']\ndiff --git a/setup.cfg b/setup.cfg\nindex c01f844..0da8f8f 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,5 +1,23 @@\n-[zest.releaser]\n-extra-message = [ci skip]\n-\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [bdist_wheel]\n-universal = 1\n+universal = 0\n+\n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n+\n+[check-manifest]\n+ignore =\n+    .editorconfig\n+    .meta.toml\n+    .pre-commit-config.yaml\n+    tox.ini\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..7e161fd\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,54 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[tox]\n+# We need 4.4.0 for constrain_package_deps.\n+min_version = 4.4.0\n+envlist =\n+    format\n+    lint\n+    test\n+\n+[testenv]\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat code\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a pyupgrade\n+    pre-commit run -a isort\n+    pre-commit run -a black\n+    pre-commit run -a zpretty\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a\n+\n+[testenv:dependencies]\n+description = check if the package defines all its dependencies and generate a graph out of them\n+deps =\n+    z3c.dependencychecker==2.11\n+    pipdeptree==2.5.1\n+    graphviz  # optional dependency of pipdeptree\n+commands =\n+    dependencychecker\n+    sh -c \'pipdeptree --exclude setuptools,wheel,pipdeptree,z3c.dependencychecker,zope.interface,zope.component --graph-output svg > dependencies.svg\'\n+\n+[testenv:test]\n+usedevelop = true\n+constrain_package_deps = true\n+set_env = ROBOT_BROWSER=headlesschrome\n+deps =\n+    zope.testrunner\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    zope-testrunner --all --test-path={toxinidir} -s plone.app.linkintegrity {posargs}\n+extras =\n+    test\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2023-04-03T00:30:33+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/211e0a01b93478c869dd828bab4db8ca4847c1e2

chore: pyupgrade

Files changed:
M plone/__init__.py
M plone/app/__init__.py
M plone/app/linkintegrity/__init__.py
M plone/app/linkintegrity/browser/__init__.py
M plone/app/linkintegrity/browser/info.py
M plone/app/linkintegrity/browser/update.py
M plone/app/linkintegrity/exceptions.py
M plone/app/linkintegrity/interfaces.py
M plone/app/linkintegrity/retriever.py
M plone/app/linkintegrity/testing.py
M plone/app/linkintegrity/tests/__init__.py
M plone/app/linkintegrity/tests/test_circular.py
M plone/app/linkintegrity/tests/test_functional.py
M plone/app/linkintegrity/tests/test_handlers.py
M plone/app/linkintegrity/tests/test_imagescales.py
M plone/app/linkintegrity/utils.py
M setup.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..de40ea7 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n __import__(\'pkg_resources\').declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 68c04af..de40ea7 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n __import__(\'pkg_resources\').declare_namespace(__name__)\ndiff --git a/plone/app/linkintegrity/__init__.py b/plone/app/linkintegrity/__init__.py\nindex 40a96af..e69de29 100644\n--- a/plone/app/linkintegrity/__init__.py\n+++ b/plone/app/linkintegrity/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/linkintegrity/browser/__init__.py b/plone/app/linkintegrity/browser/__init__.py\nindex 40a96af..e69de29 100644\n--- a/plone/app/linkintegrity/browser/__init__.py\n+++ b/plone/app/linkintegrity/browser/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py\nindex e93f95c..3590d4f 100644\n--- a/plone/app/linkintegrity/browser/info.py\n+++ b/plone/app/linkintegrity/browser/info.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from OFS.interfaces import IFolder\n from plone.app.linkintegrity.utils import getIncomingLinks\ndiff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py\nindex a31b1ef..cdb0333 100644\n--- a/plone/app/linkintegrity/browser/update.py\n+++ b/plone/app/linkintegrity/browser/update.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from datetime import datetime\n from datetime import timedelta\n@@ -26,20 +25,20 @@ def __call__(self):\n             count = self.update()\n             duration = timedelta(seconds=(datetime.now() - starttime).seconds)\n             msg = _(\n-                u\'linkintegrity_update_info\',\n-                default=u\'Link integrity information updated for ${count} \' +\n-                        u\'items in ${time} seconds.\',\n+                \'linkintegrity_update_info\',\n+                default=\'Link integrity information updated for ${count} \' +\n+                        \'items in ${time} seconds.\',\n                 mapping={\'count\': count, \'time\': str(duration)},\n             )\n             IStatusMessage(request).add(msg, type=\'info\')\n-            msg = \'Updated {0} items in {1} seconds\'.format(\n+            msg = \'Updated {} items in {} seconds\'.format(\n                 count,\n                 str(duration),\n             )\n             logger.info(msg)\n             request.RESPONSE.redirect(getToolByName(context, \'portal_url\')())\n         elif \'cancel\' in request.form:\n-            msg = _(u\'Update cancelled.\')\n+            msg = _(\'Update cancelled.\')\n             IStatusMessage(request).add(msg, type=\'info\')\n             request.RESPONSE.redirect(getToolByName(context, \'portal_url\')())\n         else:\ndiff --git a/plone/app/linkintegrity/exceptions.py b/plone/app/linkintegrity/exceptions.py\nindex a0cf407..c611cb7 100644\n--- a/plone/app/linkintegrity/exceptions.py\n+++ b/plone/app/linkintegrity/exceptions.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from OFS.ObjectManager import BeforeDeleteException\n from zope.interface import implementer\n from zope.interface import Interface\n@@ -18,4 +17,4 @@ def __str__(self):\n         args = self.args\n         if args and isinstance(args, tuple):\n             return repr(args[0])\n-        return super(LinkIntegrityNotificationException, self).__str__()\n+        return super().__str__()\ndiff --git a/plone/app/linkintegrity/interfaces.py b/plone/app/linkintegrity/interfaces.py\nindex e7ee638..76d6228 100644\n--- a/plone/app/linkintegrity/interfaces.py\n+++ b/plone/app/linkintegrity/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Interface\n \n \ndiff --git a/plone/app/linkintegrity/retriever.py b/plone/app/linkintegrity/retriever.py\nindex 993a7a5..40c2fd7 100644\n--- a/plone/app/linkintegrity/retriever.py\n+++ b/plone/app/linkintegrity/retriever.py\n@@ -14,7 +14,7 @@\n \n @implementer(IRetriever)\n @adapter(IDexterityContent)\n-class DXGeneral(object):\n+class DXGeneral:\n     """General retriever for DX that extracts URLs from (rich) text fields.\n     """\n \ndiff --git a/plone/app/linkintegrity/testing.py b/plone/app/linkintegrity/testing.py\nindex 1239036..6634c55 100644\n--- a/plone/app/linkintegrity/testing.py\n+++ b/plone/app/linkintegrity/testing.py\n@@ -50,8 +50,8 @@ def setUpPloneSite(self, portal):\n         # Create sample documents\n         type_data = dict(type_name=\'Document\')\n         for i in range(1, 4):\n-            type_data[\'id\'] = \'doc{0:d}\'.format(i)\n-            type_data[\'title\'] = \'Test Page {0:d}\'.format(i)\n+            type_data[\'id\'] = f\'doc{i:d}\'\n+            type_data[\'title\'] = f\'Test Page {i:d}\'\n             create(portal, **type_data)\n \n         create(portal, \'File\', id=\'file1\', title=\'File 1\', file=GIF)\n@@ -71,7 +71,7 @@ def setUpPloneSite(self, portal):\n         # create a NamedImage\n         portal.invokeFactory(\'Image\', \'image1\')\n         portal[\'image1\'].image = NamedImage(GIF, \'image/gif\',\n-                                            u\'sample.gif\')\n+                                            \'sample.gif\')\n \n \n PLONE_APP_LINKINTEGRITY_FIXTURE = LinkIntegrityLayer()\ndiff --git a/plone/app/linkintegrity/tests/__init__.py b/plone/app/linkintegrity/tests/__init__.py\nindex 336bbe1..087606d 100644\n--- a/plone/app/linkintegrity/tests/__init__.py\n+++ b/plone/app/linkintegrity/tests/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n # tests package\n # to run all tests type \'.../bin/instance test -s plone.app.linkintegrity\'\n \ndiff --git a/plone/app/linkintegrity/tests/test_circular.py b/plone/app/linkintegrity/tests/test_circular.py\nindex b3a3c1f..4db8c78 100644\n--- a/plone/app/linkintegrity/tests/test_circular.py\n+++ b/plone/app/linkintegrity/tests/test_circular.py\n@@ -72,9 +72,9 @@ def test_internal_breaches_are_dropped(self):\n         set_text(doc4, \'<a href="doc5">d5</a><a href="../doc1">d1</a>\')\n         set_text(doc5, \'<a href="../folder1">f1</a>\')\n \n-        doc4_breaches = set([r.to_object for r in getOutgoingLinks(doc4)])\n+        doc4_breaches = {r.to_object for r in getOutgoingLinks(doc4)}\n         # the order of breaches is non-deterministic\n-        self.assertEqual(set([doc1, doc5]), doc4_breaches)\n+        self.assertEqual({doc1, doc5}, doc4_breaches)\n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc5)], [folder1])\n         self.assertEqual(\ndiff --git a/plone/app/linkintegrity/tests/test_functional.py b/plone/app/linkintegrity/tests/test_functional.py\nindex ac5cb83..9ae1b05 100644\n--- a/plone/app/linkintegrity/tests/test_functional.py\n+++ b/plone/app/linkintegrity/tests/test_functional.py\n@@ -34,7 +34,7 @@ def setUp(self):\n         self.browser.addHeader(\'Referer\', self.portal.absolute_url())\n         self.browser.addHeader(\n             \'Authorization\',\n-            \'Basic {0:s}:{1:s}\'.format(TEST_USER_NAME, TEST_USER_PASSWORD))\n+            f\'Basic {TEST_USER_NAME:s}:{TEST_USER_PASSWORD:s}\')\n \n         # Do an initial page load to make sure the bundles get compiled\n         # (which currently commits a transaction)\n@@ -67,9 +67,9 @@ def test_file_reference_linkintegrity_page_is_shown(self):\n         self.browser.handleErrors = True\n         self.browser.addHeader(\n             \'Authorization\',\n-            \'Basic {0:s}:{1:s}\'.format(TEST_USER_NAME, TEST_USER_PASSWORD))\n+            f\'Basic {TEST_USER_NAME:s}:{TEST_USER_PASSWORD:s}\')\n \n-        delete_url = \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+        delete_url = \'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n             file2.absolute_url(), token)\n \n         # Try to remove but cancel\n@@ -126,7 +126,7 @@ def test_renaming_referenced_item(self):\n \n         # Then we use a browser to rename the referenced image:\n         self.browser.handleErrors = True\n-        self.browser.open(\'{0:s}/object_rename?_authenticator={1:s}\'.format(\n+        self.browser.open(\'{:s}/object_rename?_authenticator={:s}\'.format(\n             doc1.absolute_url(), self._get_token(doc1)))\n \n         self.browser.getControl(name=\'form.widgets.new_id\').value = \'nuname\'\n@@ -171,7 +171,7 @@ def test_removal_in_subfolder(self):\n         self.browser.handleErrors = True\n \n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            \'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n                 folder1.absolute_url(), self._get_token(folder1)\n             )\n         )\n@@ -196,7 +196,7 @@ def test_removal_with_cookie_auth(self):\n         browser.handleErrors = True\n         browser.addHeader(\'Referer\', self.portal.absolute_url())\n         browser.open(\n-            \'{0:s}/folder_contents\'.format(self.portal.absolute_url()))\n+            f\'{self.portal.absolute_url():s}/folder_contents\')\n \n         # At this point we shouldn\'t be able to look at the folder\n         # contents (as an anonymous user):\n@@ -212,7 +212,7 @@ def test_removal_with_cookie_auth(self):\n \n         # This should lead us back to the "folder contents" listing,\n         # where we try to delete the referenced document.\n-        browser.open(\'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+        browser.open(\'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n             doc2.absolute_url(), self._get_token(doc2)))\n         self.assertIn(\'Potential link breakage\', browser.contents)\n         self.assertIn(\'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n@@ -235,7 +235,7 @@ def test_linkintegrity_on_off_switch(self):\n         self.browser.handleErrors = True\n \n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            \'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n                 doc2.absolute_url(), self._get_token(doc2)\n             )\n         )\n@@ -275,7 +275,7 @@ def test_update(self):\n         # An update of link integrity information for all content is triggered\n         # by browsing a specific url:\n         transaction.commit()\n-        self.browser.open(\'{0:s}/updateLinkIntegrityInformation\'.format(\n+        self.browser.open(\'{:s}/updateLinkIntegrityInformation\'.format(\n             self.portal.absolute_url()))\n         self.browser.getControl(\'Update\').click()\n         self.assertIn(\'Link integrity information updated for\',\n@@ -318,7 +318,7 @@ def test_references_on_cloned_objects(self):\n         # Now we can continue and "click" the "delete" action. The confirmation\n         # page should list both documents:\n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            \'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n                 doc2.absolute_url(), self._get_token(doc2)\n             )\n         )\n@@ -358,7 +358,7 @@ def test_files_with_spaces_removal(self):\n         self.browser.handleErrors = True\n \n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            \'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n                 spaces1.absolute_url(), self._get_token(spaces1)\n             )\n         )\n@@ -397,7 +397,7 @@ def test_removal_via_zmi(self):\n     def test_warn_about_content(self):\n         folder1 = self.portal.folder1\n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            \'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n                 folder1.absolute_url(), self._get_token(folder1)\n             )\n         )\ndiff --git a/plone/app/linkintegrity/tests/test_handlers.py b/plone/app/linkintegrity/tests/test_handlers.py\nindex acc020f..2f455b2 100644\n--- a/plone/app/linkintegrity/tests/test_handlers.py\n+++ b/plone/app/linkintegrity/tests/test_handlers.py\n@@ -42,7 +42,7 @@ def test_uuid_link(self):\n         create(self.portal, \'Document\', id=\'target\', title=\'Target\')\n         target = self.portal.target\n         target_uid = target.UID()\n-        path = "../resolveuid/{}".format(target_uid)\n+        path = f"../resolveuid/{target_uid}"\n \n         # We logout.  This is to check that findObject also finds objects\n         # that are not visible to the current user, like a private page.\ndiff --git a/plone/app/linkintegrity/tests/test_imagescales.py b/plone/app/linkintegrity/tests/test_imagescales.py\nindex 0ffc9cd..a809603 100644\n--- a/plone/app/linkintegrity/tests/test_imagescales.py\n+++ b/plone/app/linkintegrity/tests/test_imagescales.py\n@@ -57,7 +57,7 @@ def test_image_resolveuid_reference_creation(self):\n         img1 = self.portal.image1\n \n         # Linking via the "resolveuid/UID" method should also work:\n-        set_text(doc1, \'<a href="resolveuid/{0:s}">an image</a>\'.format(\n+        set_text(doc1, \'<a href="resolveuid/{:s}">an image</a>\'.format(\n             IUUID(img1)))\n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\ndiff --git a/plone/app/linkintegrity/utils.py b/plone/app/linkintegrity/utils.py\nindex 629350b..c5e8e3d 100644\n--- a/plone/app/linkintegrity/utils.py\n+++ b/plone/app/linkintegrity/utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.registry.interfaces import IRegistry\n from plone.base.interfaces import IEditingSchema\n from zc.relation.interfaces import ICatalog\ndiff --git a/setup.py b/setup.py\nindex e1ada7a..9615d69 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2023-04-03T00:30:51+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/99641ffbad2a3f2dde599db44d524ad9656ae815

chore: isort

Files changed:
M plone/app/linkintegrity/browser/info.py
M plone/app/linkintegrity/browser/update.py
M plone/app/linkintegrity/handlers.py
M plone/app/linkintegrity/tests/test_functional.py
M plone/app/linkintegrity/tests/test_references.py
M plone/app/linkintegrity/utils.py

b"diff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py\nindex 3590d4f..cc5b67a 100644\n--- a/plone/app/linkintegrity/browser/info.py\n+++ b/plone/app/linkintegrity/browser/info.py\n@@ -2,15 +2,16 @@\n from OFS.interfaces import IFolder\n from plone.app.linkintegrity.utils import getIncomingLinks\n from plone.app.linkintegrity.utils import linkintegrity_enabled\n+from plone.base import PloneMessageFactory as _\n+from plone.base.interfaces import IPloneSiteRoot\n from plone.uuid.interfaces import IUUID\n from Products.CMFCore.permissions import AccessContentsInformation\n from Products.CMFCore.utils import _checkPermission\n from Products.CMFCore.utils import getToolByName\n-from plone.base import PloneMessageFactory as _\n-from plone.base.interfaces import IPloneSiteRoot\n from Products.Five import BrowserView\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n from zope.i18n import translate\n+\n import logging\n \n \ndiff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py\nindex cdb0333..1d9d624 100644\n--- a/plone/app/linkintegrity/browser/update.py\n+++ b/plone/app/linkintegrity/browser/update.py\n@@ -2,14 +2,16 @@\n from datetime import datetime\n from datetime import timedelta\n from plone.app.linkintegrity.handlers import modifiedContent\n-from Products.CMFCore.utils import getToolByName\n from plone.base import PloneMessageFactory as _\n+from Products.CMFCore.utils import getToolByName\n from Products.Five import BrowserView\n from Products.statusmessages.interfaces import IStatusMessage\n from transaction import savepoint\n from zExceptions import NotFound\n \n import logging\n+\n+\n logger = logging.getLogger(__name__)\n \n \ndiff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py\nindex 5bcaaed..8bcc805 100644\n--- a/plone/app/linkintegrity/handlers.py\n+++ b/plone/app/linkintegrity/handlers.py\n@@ -4,11 +4,11 @@\n from plone.app.linkintegrity.utils import ensure_intid\n from plone.app.linkintegrity.utils import referencedRelationship\n from plone.app.uuid.utils import uuidToCatalogBrain\n+from plone.base.interfaces import IEditingSchema\n+from plone.base.interfaces import IPloneSiteRoot\n from plone.dexterity.interfaces import IDexterityContent\n from plone.registry.interfaces import IRegistry\n from Products.CMFCore.utils import getToolByName\n-from plone.base.interfaces import IEditingSchema\n-from plone.base.interfaces import IPloneSiteRoot\n from urllib.parse import unquote\n from urllib.parse import urlsplit\n from z3c.relationfield import RelationValue\ndiff --git a/plone/app/linkintegrity/tests/test_functional.py b/plone/app/linkintegrity/tests/test_functional.py\nindex 9ae1b05..df125ce 100644\n--- a/plone/app/linkintegrity/tests/test_functional.py\n+++ b/plone/app/linkintegrity/tests/test_functional.py\n@@ -7,9 +7,9 @@\n from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n from plone.app.testing import TEST_USER_PASSWORD\n+from plone.base.interfaces import IEditingSchema\n from plone.registry.interfaces import IRegistry\n from plone.testing.zope import Browser\n-from plone.base.interfaces import IEditingSchema\n from zc.relation.interfaces import ICatalog\n from zope.component import getMultiAdapter\n from zope.component import getUtility\ndiff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py\nindex 55b0faf..67a413d 100644\n--- a/plone/app/linkintegrity/tests/test_references.py\n+++ b/plone/app/linkintegrity/tests/test_references.py\n@@ -13,8 +13,8 @@\n from z3c.relationfield.event import _setRelation\n from zc.relation.interfaces import ICatalog\n from zope.component import getUtility\n-from zope.lifecycleevent import modified\n from zope.intid.interfaces import IIntIds\n+from zope.lifecycleevent import modified\n \n import unittest\n \ndiff --git a/plone/app/linkintegrity/utils.py b/plone/app/linkintegrity/utils.py\nindex c5e8e3d..1c97817 100644\n--- a/plone/app/linkintegrity/utils.py\n+++ b/plone/app/linkintegrity/utils.py\n@@ -1,10 +1,11 @@\n-from plone.registry.interfaces import IRegistry\n from plone.base.interfaces import IEditingSchema\n+from plone.registry.interfaces import IRegistry\n from zc.relation.interfaces import ICatalog\n from zope.component import getUtility\n from zope.intid.interfaces import IIntIds\n from zope.keyreference.interfaces import NotYet\n \n+\n referencedRelationship = 'isReferencing'\n \n \n"

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2023-04-03T00:32:47+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/327ea20c3278919e4b072cdab4cd1b37234586eb

chore: black

Files changed:
M plone/__init__.py
M plone/app/__init__.py
M plone/app/linkintegrity/browser/info.py
M plone/app/linkintegrity/browser/update.py
M plone/app/linkintegrity/exceptions.py
M plone/app/linkintegrity/handlers.py
M plone/app/linkintegrity/interfaces.py
M plone/app/linkintegrity/retriever.py
M plone/app/linkintegrity/testing.py
M plone/app/linkintegrity/tests/__init__.py
M plone/app/linkintegrity/tests/test_circular.py
M plone/app/linkintegrity/tests/test_functional.py
M plone/app/linkintegrity/tests/test_handlers.py
M plone/app/linkintegrity/tests/test_imagescales.py
M plone/app/linkintegrity/tests/test_references.py
M plone/app/linkintegrity/utils.py
M setup.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex de40ea7..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1 +1 @@\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex de40ea7..5284146 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1 +1 @@\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py\nindex cc5b67a..f26d27a 100644\n--- a/plone/app/linkintegrity/browser/info.py\n+++ b/plone/app/linkintegrity/browser/info.py\n@@ -19,8 +19,7 @@\n \n \n class DeleteConfirmationInfo(BrowserView):\n-\n-    template = ViewPageTemplateFile(\'delete_confirmation_info.pt\')\n+    template = ViewPageTemplateFile("delete_confirmation_info.pt")\n     breach_count = {}\n \n     def __init__(self, context, request):\n@@ -48,14 +47,14 @@ def get_breaches(self, items=None):\n         """\n         if items is None:\n             items = [self.context]\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n+        catalog = getToolByName(self.context, "portal_catalog")\n         results = []\n         uids_to_ignore = []\n         uids_visited = set()\n         self.breach_count = {}\n         for obj in items:\n-            obj_path = \'/\'.join(obj.getPhysicalPath())\n-            brains_to_delete = catalog(path={\'query\': obj_path})\n+            obj_path = "/".join(obj.getPhysicalPath())\n+            brains_to_delete = catalog(path={"query": obj_path})\n             # add the current items uid and all its childrens uids to the\n             # list of uids that are ignored\n             uids_to_ignore.extend([i.UID for i in brains_to_delete])\n@@ -64,47 +63,40 @@ def get_breaches(self, items=None):\n                     obj_to_delete = brain_to_delete.getObject()  # noqa\n                 except (AttributeError, KeyError):\n                     logger.exception(\n-                        \'No object found for %s! Skipping\', brain_to_delete)\n+                        "No object found for %s! Skipping", brain_to_delete\n+                    )\n                     continue\n                 for breach in self.get_breaches_for_item(obj):\n                     add_breach = False\n-                    for source in breach[\'sources\']:\n+                    for source in breach["sources"]:\n                         # Only add the breach if one the sources is not in the\n                         # list of items that are to be deleted.\n-                        if source[\'uid\'] not in uids_to_ignore and \\\n-                           source[\'uid\'] not in uids_visited:\n+                        if (\n+                            source["uid"] not in uids_to_ignore\n+                            and source["uid"] not in uids_visited\n+                        ):\n                             add_breach = True\n-                            uids_visited.add(source[\'uid\'])\n+                            uids_visited.add(source["uid"])\n                             break\n                     if add_breach:\n                         results.append(breach)\n             if IFolder.providedBy(obj):\n-                count = len(catalog(\n-                    path={\'query\': obj_path}\n-                ))\n-                count_dirs = len(catalog(\n-                    path={\'query\': obj_path},\n-                    is_folderish=True\n-                ))\n-                count_public = len(catalog(\n-                    path={\'query\': obj_path},\n-                    review_state=\'published\'\n-                ))\n+                count = len(catalog(path={"query": obj_path}))\n+                count_dirs = len(catalog(path={"query": obj_path}, is_folderish=True))\n+                count_public = len(\n+                    catalog(path={"query": obj_path}, review_state="published")\n+                )\n                 if count:\n-                    self.breach_count[obj_path] = [\n-                        count,\n-                        count_dirs,\n-                        count_public\n-                    ]\n+                    self.breach_count[obj_path] = [count, count_dirs, count_public]\n \n         # Cleanup: Some breaches where added before it was known\n         # that their source will be deleted too.\n         for result in results:\n-            for source in result[\'sources\']:\n-                if source[\'uid\'] in uids_to_ignore:\n+            for source in result["sources"]:\n+                if source["uid"] in uids_to_ignore:\n                     # Drop sources that are also being deleted\n-                    result[\'sources\'].remove(source)\n-                    if not result[\'sources\']:\n+                    result["sources"].remove(source)\n+                    if not result["sources"]:\n                         # Remove the breach is there are no more sources\n                         # This check is necessary since there can be multiple\n                         # sources for a breach\n@@ -119,15 +111,15 @@ def get_breaches_for_item(self, obj=None):\n         if obj is None:\n             obj = self.context\n         results = []\n-        catalog = getToolByName(obj, \'portal_catalog\')\n-        obj_path = \'/\'.join(obj.getPhysicalPath())\n+        catalog = getToolByName(obj, "portal_catalog")\n+        obj_path = "/".join(obj.getPhysicalPath())\n \n         breaches = self.check_object(obj)\n         if breaches:\n             results.append(breaches)\n \n         if IFolder.providedBy(obj):\n-            brains = catalog(path={\'query\': obj_path})\n+            brains = catalog(path={"query": obj_path})\n             for brain in brains:\n                 try:\n                     child = brain.getObject()\n@@ -157,30 +149,31 @@ def check_object(self, obj, excluded_path=None):\n                 # source is in excluded_path\n                 continue\n             source = direct_link.from_object\n-            if not breaches.get(\'sources\'):\n-                breaches[\'sources\'] = []\n-            breaches[\'sources\'].append({\n-                \'uid\': IUUID(source),\n-                \'title\': source.Title(),\n-                \'url\': source.absolute_url(),\n-                \'accessible\': self.is_accessible(source),\n-            })\n+            if not breaches.get("sources"):\n+                breaches["sources"] = []\n+            breaches["sources"].append(\n+                {\n+                    "uid": IUUID(source),\n+                    "title": source.Title(),\n+                    "url": source.absolute_url(),\n+                    "accessible": self.is_accessible(source),\n+                }\n+            )\n             has_breaches = True\n         if has_breaches:\n-            breaches[\'target\'] = {\n-                \'uid\': IUUID(obj),\n-                \'title\': obj.Title(),\n-                \'url\': obj.absolute_url(),\n-                \'portal_type\': obj.portal_type,\n-                \'type_title\': self.get_portal_type_title(obj),\n+            breaches["target"] = {\n+                "uid": IUUID(obj),\n+                "title": obj.Title(),\n+                "url": obj.absolute_url(),\n+                "portal_type": obj.portal_type,\n+                "type_title": self.get_portal_type_title(obj),\n             }\n             return breaches\n \n     def get_portal_type_title(self, obj):\n-        """Get the portal type title of the object.\n-        """\n+        """Get the portal type title of the object."""\n         context = aq_inner(self.context)\n-        portal_types = getToolByName(context, \'portal_types\')\n+        portal_types = getToolByName(context, "portal_types")\n         fti = portal_types.get(obj.portal_type)\n         if fti is not None:\n             type_title_msgid = fti.Title()\n@@ -193,4 +186,4 @@ def is_accessible(self, obj):\n         return _checkPermission(AccessContentsInformation, obj)\n \n     def objects(self):\n-        return [_(\'Objects in all\'), _(\'Folders\'), _(\'Published objects\')]\n+        return [_("Objects in all"), _("Folders"), _("Published objects")]\ndiff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py\nindex 1d9d624..4f51eb4 100644\n--- a/plone/app/linkintegrity/browser/update.py\n+++ b/plone/app/linkintegrity/browser/update.py\n@@ -16,52 +16,51 @@\n \n \n class UpdateView(BrowserView):\n-    """Iterate over all catalogued items and update linkintegrity-information.\n-    """\n+    """Iterate over all catalogued items and update linkintegrity-information."""\n \n     def __call__(self):\n         context = aq_inner(self.context)\n         request = aq_inner(self.request)\n-        if \'update\' in request.form or \'delete_all\' in request.form:\n+        if "update" in request.form or "delete_all" in request.form:\n             starttime = datetime.now()\n             count = self.update()\n             duration = timedelta(seconds=(datetime.now() - starttime).seconds)\n             msg = _(\n-                \'linkintegrity_update_info\',\n-                default=\'Link integrity information updated for ${count} \' +\n-                        \'items in ${time} seconds.\',\n-                mapping={\'count\': count, \'time\': str(duration)},\n+                "linkintegrity_update_info",\n+                default="Link integrity information updated for ${count} "\n+                + "items in ${time} seconds.",\n+                mapping={"count": count, "time": str(duration)},\n             )\n-            IStatusMessage(request).add(msg, type=\'info\')\n-            msg = \'Updated {} items in {} seconds\'.format(\n+            IStatusMessage(request).add(msg, type="info")\n+            msg = "Updated {} items in {} seconds".format(\n                 count,\n                 str(duration),\n             )\n             logger.info(msg)\n-            request.RESPONSE.redirect(getToolByName(context, \'portal_url\')())\n-        elif \'cancel\' in request.form:\n-            msg = _(\'Update cancelled.\')\n-            IStatusMessage(request).add(msg, type=\'info\')\n-            request.RESPONSE.redirect(getToolByName(context, \'portal_url\')())\n+            request.RESPONSE.redirect(getToolByName(context, "portal_url")())\n+        elif "cancel" in request.form:\n+            msg = _("Update cancelled.")\n+            IStatusMessage(request).add(msg, type="info")\n+            request.RESPONSE.redirect(getToolByName(context, "portal_url")())\n         else:\n             return self.index()\n \n     def update(self):\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n+        catalog = getToolByName(self.context, "portal_catalog")\n         count = 0\n \n         for brain in catalog():\n             try:\n                 obj = brain.getObject()\n             except (AttributeError, NotFound, KeyError):\n-                msg = \'Catalog inconsistency: {0} not found!\'\n+                msg = "Catalog inconsistency: {0} not found!"\n                 logger.error(msg.format(brain.getPath()), exc_info=1)\n                 continue\n             try:\n-                modifiedContent(obj, \'dummy event parameter\')\n+                modifiedContent(obj, "dummy event parameter")\n                 count += 1\n             except Exception:\n-                msg = \'Error updating linkintegrity-info for {0}.\'\n+                msg = "Error updating linkintegrity-info for {0}."\n                 logger.error(msg.format(obj.absolute_url()), exc_info=1)\n             if count % 1000 == 0:\n                 savepoint(optimistic=True)\ndiff --git a/plone/app/linkintegrity/exceptions.py b/plone/app/linkintegrity/exceptions.py\nindex c611cb7..41afee0 100644\n--- a/plone/app/linkintegrity/exceptions.py\n+++ b/plone/app/linkintegrity/exceptions.py\n@@ -4,14 +4,12 @@\n \n \n class ILinkIntegrityNotificationException(Interface):\n-    """An exception indicating a prevented link integrity breach.\n-    """\n+    """An exception indicating a prevented link integrity breach."""\n \n \n @implementer(ILinkIntegrityNotificationException)\n class LinkIntegrityNotificationException(BeforeDeleteException):\n-    """An exception indicating a prevented link integrity breach.\n-    """\n+    """An exception indicating a prevented link integrity breach."""\n \n     def __str__(self):\n         args = self.args\ndiff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py\nindex 8bcc805..07aa710 100644\n--- a/plone/app/linkintegrity/handlers.py\n+++ b/plone/app/linkintegrity/handlers.py\n@@ -28,22 +28,22 @@\n \n \n def findObject(base, path):\n-    """ traverse to given path and find the upmost object """\n-    if path.startswith(\'/\'):\n+    """traverse to given path and find the upmost object"""\n+    if path.startswith("/"):\n         # Make an absolute path relative to the portal root\n-        obj = getToolByName(base, \'portal_url\').getPortalObject()\n-        portal_path = obj.absolute_url_path() + \'/\'\n+        obj = getToolByName(base, "portal_url").getPortalObject()\n+        portal_path = obj.absolute_url_path() + "/"\n         if path.startswith(portal_path):\n-            path = path[len(portal_path):]\n+            path = path[len(portal_path) :]\n     else:\n-        obj = aq_parent(base)   # relative urls start at the parent...\n+        obj = aq_parent(base)  # relative urls start at the parent...\n \n-    components = path.split(\'/\')\n+    components = path.split("/")\n \n     # Support resolveuid/UID paths explicitely, without relying\n     # on a view or skinscript to do this for us.\n-    if \'resolveuid\' in components:\n-        uid = components[components.index(\'resolveuid\') + 1]\n+    if "resolveuid" in components:\n+        uid = components[components.index("resolveuid") + 1]\n         # This may be a link to a page that once was published but not anymore,\n         # or the current editor does not have View permission.\n         # In that case uuidToObject(uid) could fail with Unauthorized.\n@@ -62,23 +62,23 @@ def findObject(base, path):\n             try:\n                 child = obj.unrestrictedTraverse(child_id)\n             except AttributeError:\n-                request = aq_get(obj, \'REQUEST\')\n+                request = aq_get(obj, "REQUEST")\n                 child = request.traverseName(obj, child_id)\n         except ConflictError:\n             raise\n-        except (AttributeError, KeyError,\n-                NotFound, ztkNotFound, UnicodeEncodeError):\n+        except (AttributeError, KeyError, NotFound, ztkNotFound, UnicodeEncodeError):\n             return None, None\n-        if not IDexterityContent.providedBy(child) and \\\n-                not IPloneSiteRoot.providedBy(child):\n+        if not IDexterityContent.providedBy(child) and not IPloneSiteRoot.providedBy(\n+            child\n+        ):\n             break\n         obj = child\n         components.pop(0)\n-    return obj, \'/\'.join(components)\n+    return obj, "/".join(components)\n \n \n def getObjectsFromLinks(base, links):\n-    """ determine actual objects refered to by given links """\n+    """determine actual objects refered to by given links"""\n     intids = getUtility(IIntIds)\n     objects = set()\n     url = base.absolute_url()\n@@ -128,9 +128,12 @@ def updateReferences(obj, refs):\n         return\n     catalog = getUtility(ICatalog)\n     # unpack the rels before deleting\n-    old_rels = [i for i in catalog.findRelations(\n-        {\'from_id\': int_id,\n-         \'from_attribute\': referencedRelationship})]\n+    old_rels = [\n+        i\n+        for i in catalog.findRelations(\n+            {"from_id": int_id, "from_attribute": referencedRelationship}\n+        )\n+    ]\n     for old_rel in old_rels:\n         catalog.unindex(old_rel)\n     for ref in refs:\n@@ -140,12 +143,12 @@ def updateReferences(obj, refs):\n def check_linkintegrity_dependencies(obj):\n     try:\n         reg = getUtility(IRegistry)\n-        editing_settings = reg.forInterface(IEditingSchema, prefix=\'plone\')\n+        editing_settings = reg.forInterface(IEditingSchema, prefix="plone")\n     except (ComponentLookupError, KeyError):\n         return False\n     if not editing_settings.enable_link_integrity_checks:\n         return False\n-    if not getToolByName(obj, \'portal_url\', None):\n+    if not getToolByName(obj, "portal_url", None):\n         # `getObjectFromLinks` is not possible without access\n         # to `portal_url`\n         return False\ndiff --git a/plone/app/linkintegrity/interfaces.py b/plone/app/linkintegrity/interfaces.py\nindex 76d6228..44287b0 100644\n--- a/plone/app/linkintegrity/interfaces.py\n+++ b/plone/app/linkintegrity/interfaces.py\n@@ -2,8 +2,7 @@\n \n \n class IRetriever(Interface):\n-    """A retriever for links in a content type.\n-    """\n+    """A retriever for links in a content type."""\n \n     def retrieveLinks():\n-        """ retrieve links """\n+        """retrieve links"""\ndiff --git a/plone/app/linkintegrity/retriever.py b/plone/app/linkintegrity/retriever.py\nindex 40c2fd7..4e0ff95 100644\n--- a/plone/app/linkintegrity/retriever.py\n+++ b/plone/app/linkintegrity/retriever.py\n@@ -15,26 +15,25 @@\n @implementer(IRetriever)\n @adapter(IDexterityContent)\n class DXGeneral:\n-    """General retriever for DX that extracts URLs from (rich) text fields.\n-    """\n+    """General retriever for DX that extracts URLs from (rich) text fields."""\n \n     def __init__(self, context):\n         self.context = context\n \n     def retrieveLinks(self):\n-        """Finds all links from the object and return them.\n-        """\n+        """Finds all links from the object and return them."""\n         fti = getUtility(IDexterityFTI, name=self.context.portal_type)\n         schema = fti.lookupSchema()\n         additional_schema = getAdditionalSchemata(\n-            context=self.context, portal_type=self.context.portal_type)\n+            context=self.context, portal_type=self.context.portal_type\n+        )\n         schemas = [i for i in additional_schema] + [schema]\n         links = set()\n         for schema in schemas:\n             for name, field in getFieldsInOrder(schema):\n                 if isinstance(field, RichText):\n                     value = getattr(schema(self.context), name)\n-                    if not value or not getattr(value, \'raw\', None):\n+                    if not value or not getattr(value, "raw", None):\n                         continue\n                     links |= set(extractLinks(value.raw))\n         return links\ndiff --git a/plone/app/linkintegrity/testing.py b/plone/app/linkintegrity/testing.py\nindex 6634c55..518541b 100644\n--- a/plone/app/linkintegrity/testing.py\n+++ b/plone/app/linkintegrity/testing.py\n@@ -14,10 +14,10 @@\n import io\n \n \n-B64_DATA = b\'R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=\'\n+B64_DATA = b"R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs="\n GIF = io.BytesIO(decodebytes(B64_DATA))\n-GIF.filename = \'sample.gif\'\n-GIF.contentType = \'image/gif\'\n+GIF.filename = "sample.gif"\n+GIF.contentType = "image/gif"\n GIF._width = 1\n GIF._height = 1\n \n@@ -32,56 +32,59 @@ def create(container, type_name, **kwargs):\n \n \n class LinkIntegrityLayer(PloneSandboxLayer):\n-    """Base Layer for Dexterity testing.\n-    """\n+    """Base Layer for Dexterity testing."""\n \n-    defaultBases = (PLONE_FIXTURE, )\n+    defaultBases = (PLONE_FIXTURE,)\n \n     def setUpZope(self, app, configurationContext):\n         import plone.app.linkintegrity\n \n-        xmlconfig.file(\'configure.zcml\', plone.app.linkintegrity,\n-                       context=configurationContext)\n+        xmlconfig.file(\n+            "configure.zcml", plone.app.linkintegrity, context=configurationContext\n+        )\n \n     def setUpPloneSite(self, portal):\n-        setRoles(portal, TEST_USER_ID, [\'Manager\', ])\n+        setRoles(\n+            portal,\n+            TEST_USER_ID,\n+            [\n+                "Manager",\n+            ],\n+        )\n         login(portal, TEST_USER_NAME)\n \n         # Create sample documents\n-        type_data = dict(type_name=\'Document\')\n+        type_data = dict(type_name="Document")\n         for i in range(1, 4):\n-            type_data[\'id\'] = f\'doc{i:d}\'\n-            type_data[\'title\'] = f\'Test Page {i:d}\'\n+            type_data["id"] = f"doc{i:d}"\n+            type_data["title"] = f"Test Page {i:d}"\n             create(portal, **type_data)\n \n-        create(portal, \'File\', id=\'file1\', title=\'File 1\', file=GIF)\n-        create(portal, \'Folder\', id=\'folder1\', title=\'Folder 1\')\n-        subfolder = portal[\'folder1\']\n-        create(subfolder, \'Document\', id=\'doc4\', title=\'Test Page 4\')\n+        create(portal, "File", id="file1", title="File 1", file=GIF)\n+        create(portal, "Folder", id="folder1", title="Folder 1")\n+        subfolder = portal["folder1"]\n+        create(subfolder, "Document", id="doc4", title="Test Page 4")\n \n         # setup members\n-        pm = getToolByName(portal, \'portal_membership\')\n-        pm.addMember(\'editor\', TEST_USER_PASSWORD, [\'Editor\'], [])\n-        pm.addMember(\'member\', TEST_USER_PASSWORD, [\'Member\'], [])\n-        pm.addMember(\'authenticated\', TEST_USER_PASSWORD, [], [])\n+        pm = getToolByName(portal, "portal_membership")\n+        pm.addMember("editor", TEST_USER_PASSWORD, ["Editor"], [])\n+        pm.addMember("member", TEST_USER_PASSWORD, ["Member"], [])\n+        pm.addMember("authenticated", TEST_USER_PASSWORD, [], [])\n \n         # Create an object that does not provide the behavior to live along\n-        create(portal, \'News Item\', id=\'news1\', title=\'News 1\')\n+        create(portal, "News Item", id="news1", title="News 1")\n \n         # create a NamedImage\n-        portal.invokeFactory(\'Image\', \'image1\')\n-        portal[\'image1\'].image = NamedImage(GIF, \'image/gif\',\n-                                            \'sample.gif\')\n+        portal.invokeFactory("Image", "image1")\n+        portal["image1"].image = NamedImage(GIF, "image/gif", "sample.gif")\n \n \n PLONE_APP_LINKINTEGRITY_FIXTURE = LinkIntegrityLayer()\n \n PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING = layers.IntegrationTesting(\n-    bases=(PLONE_APP_LINKINTEGRITY_FIXTURE, ),\n-    name=\'plone.app.linkintegrity:Integration\'\n+    bases=(PLONE_APP_LINKINTEGRITY_FIXTURE,), name="plone.app.linkintegrity:Integration"\n )\n \n PLONE_APP_LINKINTEGRITY_FUNCTIONAL_TESTING = layers.FunctionalTesting(\n-    bases=(PLONE_APP_LINKINTEGRITY_FIXTURE, ),\n-    name=\'plone.app.linkintegrity:Functional\'\n+    bases=(PLONE_APP_LINKINTEGRITY_FIXTURE,), name="plone.app.linkintegrity:Functional"\n )\ndiff --git a/plone/app/linkintegrity/tests/__init__.py b/plone/app/linkintegrity/tests/__init__.py\nindex 087606d..dcdcd54 100644\n--- a/plone/app/linkintegrity/tests/__init__.py\n+++ b/plone/app/linkintegrity/tests/__init__.py\n@@ -5,4 +5,4 @@\n import warnings\n \n \n-warnings.filterwarnings(\'ignore\', \'.*\', DeprecationWarning)\n+warnings.filterwarnings("ignore", ".*", DeprecationWarning)\ndiff --git a/plone/app/linkintegrity/tests/test_circular.py b/plone/app/linkintegrity/tests/test_circular.py\nindex 4db8c78..807cc67 100644\n--- a/plone/app/linkintegrity/tests/test_circular.py\n+++ b/plone/app/linkintegrity/tests/test_circular.py\n@@ -16,17 +16,17 @@ class CircularReferencesTestCase(unittest.TestCase):\n     layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n \n     def _set_text(self, obj, text):\n         obj.text = RichTextValue(text)\n         modified(obj)\n \n     def test_circular_reference_manages_relations(self):\n-        doc1 = self.portal[\'doc1\']\n-        doc2 = self.portal[\'doc2\']\n-        doc3 = self.portal[\'doc3\']\n+        doc1 = self.portal["doc1"]\n+        doc2 = self.portal["doc2"]\n+        doc3 = self.portal["doc3"]\n         self.assertFalse(hasIncomingLinks(doc1))\n         self.assertFalse(hasIncomingLinks(doc2))\n         self.assertFalse(hasIncomingLinks(doc3))\n@@ -58,13 +58,12 @@ def test_circular_reference_subfolder_deletion(self):\n \n         view = DeleteConfirmationInfo(self.portal, self.request)\n         self.assertEqual(len(view.get_breaches([folder1])), 1)\n-        self.assertEqual(\n-            len(view.get_breaches([doc1, doc2, doc3, folder1])), 0)\n+        self.assertEqual(len(view.get_breaches([doc1, doc2, doc3, folder1])), 0)\n         self.assertEqual(len(view.get_breaches([doc2, folder1])), 2)\n \n     def test_internal_breaches_are_dropped(self):\n         folder1 = self.portal.folder1\n-        create(folder1, \'Document\', id=\'doc5\', title=\'Test Page 5\')\n+        create(folder1, "Document", id="doc5", title="Test Page 5")\n         doc1 = self.portal.doc1\n         doc4 = self.portal.folder1.doc4\n         doc5 = self.portal.folder1.doc5\n@@ -75,10 +74,8 @@ def test_internal_breaches_are_dropped(self):\n         doc4_breaches = {r.to_object for r in getOutgoingLinks(doc4)}\n         # the order of breaches is non-deterministic\n         self.assertEqual({doc1, doc5}, doc4_breaches)\n-        self.assertEqual(\n-            [r.to_object for r in getOutgoingLinks(doc5)], [folder1])\n-        self.assertEqual(\n-            [r.to_object for r in getOutgoingLinks(doc1)], [folder1])\n+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc5)], [folder1])\n+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [folder1])\n         view = DeleteConfirmationInfo(self.portal, self.request)\n         self.assertEqual(len(view.get_breaches([doc4])), 0)\n         self.assertEqual(len(view.get_breaches([doc5])), 1)\n@@ -87,11 +84,11 @@ def test_internal_breaches_are_dropped(self):\n         self.assertEqual(len(view.get_breaches([doc1])), 1)\n         self.assertEqual(len(view.get_breaches([doc1, folder1])), 0)\n \n-        view = folder1.restrictedTraverse(\'delete_confirmation\')\n-        self.assertIn(\'Potential link breakage\', view())\n-        view = folder1.restrictedTraverse(\'delete_confirmation_info\')\n-        self.assertIn(\'Potential link breakage\', view())\n-        view = doc4.restrictedTraverse(\'delete_confirmation\')\n-        self.assertNotIn(\'Potential link breakage\', view())\n-        view = doc4.restrictedTraverse(\'delete_confirmation_info\')\n-        self.assertNotIn(\'Potential link breakage\', view())\n+        view = folder1.restrictedTraverse("delete_confirmation")\n+        self.assertIn("Potential link breakage", view())\n+        view = folder1.restrictedTraverse("delete_confirmation_info")\n+        self.assertIn("Potential link breakage", view())\n+        view = doc4.restrictedTraverse("delete_confirmation")\n+        self.assertNotIn("Potential link breakage", view())\n+        view = doc4.restrictedTraverse("delete_confirmation_info")\n+        self.assertNotIn("Potential link breakage", view())\ndiff --git a/plone/app/linkintegrity/tests/test_functional.py b/plone/app/linkintegrity/tests/test_functional.py\nindex df125ce..e3129db 100644\n--- a/plone/app/linkintegrity/tests/test_functional.py\n+++ b/plone/app/linkintegrity/tests/test_functional.py\n@@ -24,76 +24,83 @@ class FunctionalReferenceTestCase(unittest.TestCase):\n     layer = testing.PLONE_APP_LINKINTEGRITY_FUNCTIONAL_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n         # alsoProvides(self.request, IFormLayer)\n \n         # Get a testbrowser\n-        self.browser = Browser(self.layer[\'app\'])\n+        self.browser = Browser(self.layer["app"])\n         self.browser.handleErrors = False\n-        self.browser.addHeader(\'Referer\', self.portal.absolute_url())\n+        self.browser.addHeader("Referer", self.portal.absolute_url())\n         self.browser.addHeader(\n-            \'Authorization\',\n-            f\'Basic {TEST_USER_NAME:s}:{TEST_USER_PASSWORD:s}\')\n+            "Authorization", f"Basic {TEST_USER_NAME:s}:{TEST_USER_PASSWORD:s}"\n+        )\n \n         # Do an initial page load to make sure the bundles get compiled\n         # (which currently commits a transaction)\n         # before we render exception views\n         self.browser.open(self.portal.absolute_url())\n \n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\', ])\n+        setRoles(\n+            self.portal,\n+            TEST_USER_ID,\n+            [\n+                "Manager",\n+            ],\n+        )\n \n     def _get_token(self, obj):\n-        return getMultiAdapter(\n-            (obj, self.request), name=\'authenticator\').token()\n+        return getMultiAdapter((obj, self.request), name="authenticator").token()\n \n-    @unittest.skip(\'Re-enable after https://github.com/plone/plone.app.content/issues/38\')  # noqa\n+    @unittest.skip(\n+        "Re-enable after https://github.com/plone/plone.app.content/issues/38"\n+    )  # noqa\n     def test_file_reference_linkintegrity_page_is_shown(self):\n         doc1 = self.portal.doc1\n-        file2 = testing.create(self.portal, \'File\',\n-                               id=\'file2\', file=testing.GIF)\n+        file2 = testing.create(self.portal, "File", id="file2", file=testing.GIF)\n \n         self.assertFalse(hasOutgoingLinks(doc1))\n         set_text(doc1, \'<a href="file2">A File</a>\')\n         self.assertTrue(hasOutgoingLinks(doc1))\n-        self.assertIn(\'file2\', self.portal.objectIds())\n+        self.assertIn("file2", self.portal.objectIds())\n \n         token = self._get_token(file2)\n-        self.request[\'_authenticator\'] = token\n+        self.request["_authenticator"] = token\n \n         # Make changes visible to test browser\n         transaction.commit()\n \n         self.browser.handleErrors = True\n         self.browser.addHeader(\n-            \'Authorization\',\n-            f\'Basic {TEST_USER_NAME:s}:{TEST_USER_PASSWORD:s}\')\n+            "Authorization", f"Basic {TEST_USER_NAME:s}:{TEST_USER_PASSWORD:s}"\n+        )\n \n-        delete_url = \'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n-            file2.absolute_url(), token)\n+        delete_url = "{:s}/delete_confirmation?_authenticator={:s}".format(\n+            file2.absolute_url(), token\n+        )\n \n         # Try to remove but cancel\n         self.browser.open(delete_url)\n \n         # Validate text\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-                      self.browser.contents)\n-        self.assertIn(\'Would you like to delete it anyway?\',\n-                      self.browser.contents)\n+        self.assertIn("Potential link breakage", self.browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n+        )\n+        self.assertIn("Would you like to delete it anyway?", self.browser.contents)\n \n         # Click cancel button, item should stay in place\n         # FIXME! This fails in Plone 6 with an internal server error,\n         # but maybe no longer for the original reasons for which we skip this test.\n-        self.browser.getControl(name=\'form.buttons.Cancel\').click()\n-        self.assertEqual(self.browser.url, file2.absolute_url() + \'/view\')\n-        self.assertIn(\'Removal cancelled.\', self.browser.contents)\n-        self.assertIn(\'file2\', self.portal.objectIds())\n+        self.browser.getControl(name="form.buttons.Cancel").click()\n+        self.assertEqual(self.browser.url, file2.absolute_url() + "/view")\n+        self.assertIn("Removal cancelled.", self.browser.contents)\n+        self.assertIn("file2", self.portal.objectIds())\n \n         # Try to remove and confirm\n         self.browser.open(delete_url)\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'file2\', self.portal.objectIds())\n+        self.browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("file2", self.portal.objectIds())\n \n     def test_unreferenced_removal(self):\n         # This tests against #6666 and #7784, simple removal of a not\n@@ -101,14 +108,13 @@ def test_unreferenced_removal(self):\n \n         # We simply use a browser to try to delete a content item.\n         self.browser.open(self.portal.doc1.absolute_url())\n-        self.browser.getLink(\'Delete\').click()\n-        self.assertIn(\n-            \'Do you really want to delete this item?\', self.browser.contents)\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n+        self.browser.getLink("Delete").click()\n+        self.assertIn("Do you really want to delete this item?", self.browser.contents)\n+        self.browser.getControl(name="form.buttons.Delete").click()\n \n         # The resulting page should confirm the removal:\n-        self.assertIn(\'Test Page 1 has been deleted\', self.browser.contents)\n-        self.assertNotIn(\'doc1\', self.portal.objectIds())\n+        self.assertIn("Test Page 1 has been deleted", self.browser.contents)\n+        self.assertNotIn("doc1", self.portal.objectIds())\n \n     def test_renaming_referenced_item(self):\n         doc1 = self.portal.doc1\n@@ -118,38 +124,41 @@ def test_renaming_referenced_item(self):\n         # renamed (see the related bug report in #6608).  First we need\n         # to create the necessary links:\n         set_text(doc1, \'<a href="doc2">doc2</a>\')\n-        self.assertEqual(\n-            [i.from_object for i in getIncomingLinks(doc2)], [doc1])\n+        self.assertEqual([i.from_object for i in getIncomingLinks(doc2)], [doc1])\n \n         # Make changes visible to testbrowseropen\n         transaction.commit()\n \n         # Then we use a browser to rename the referenced image:\n         self.browser.handleErrors = True\n-        self.browser.open(\'{:s}/object_rename?_authenticator={:s}\'.format(\n-            doc1.absolute_url(), self._get_token(doc1)))\n+        self.browser.open(\n+            "{:s}/object_rename?_authenticator={:s}".format(\n+                doc1.absolute_url(), self._get_token(doc1)\n+            )\n+        )\n \n-        self.browser.getControl(name=\'form.widgets.new_id\').value = \'nuname\'\n-        self.browser.getControl(name=\'form.buttons.Rename\').click()\n+        self.browser.getControl(name="form.widgets.new_id").value = "nuname"\n+        self.browser.getControl(name="form.buttons.Rename").click()\n         self.assertIn("Renamed \'doc1\' to \'nuname\'.", self.browser.contents)\n         transaction.commit()\n \n-        self.assertNotIn(\'doc1\', self.portal.objectIds())\n-        self.assertIn(\'nuname\', self.portal.objectIds())\n+        self.assertNotIn("doc1", self.portal.objectIds())\n+        self.assertIn("nuname", self.portal.objectIds())\n         self.assertIn(doc1, [i.from_object for i in getIncomingLinks(doc2)])\n \n         # We simply use a browser to try to delete a content item.\n         self.browser.open(doc2.absolute_url())\n-        self.browser.getLink(\'Delete\').click()\n-        self.assertIn(\n-            \'Do you really want to delete this item?\', self.browser.contents)\n-        self.assertIn(\'nuname\', self.portal.objectIds())\n+        self.browser.getLink("Delete").click()\n+        self.assertIn("Do you really want to delete this item?", self.browser.contents)\n+        self.assertIn("nuname", self.portal.objectIds())\n         # Link breakabe page should be shown\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/nuname">Test Page 1</a>\',\n-                      self.browser.contents)\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'doc2\', self.portal.objectIds())\n+        self.assertIn("Potential link breakage", self.browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/nuname">Test Page 1</a>\',\n+            self.browser.contents,\n+        )\n+        self.browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("doc2", self.portal.objectIds())\n \n     def test_removal_in_subfolder(self):\n         doc1 = self.portal.doc1\n@@ -171,17 +180,19 @@ def test_removal_in_subfolder(self):\n         self.browser.handleErrors = True\n \n         self.browser.open(\n-            \'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 folder1.absolute_url(), self._get_token(folder1)\n             )\n         )\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-                      self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc2">Test Page 2</a>\',\n-                      self.browser.contents)\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'folder1\', self.portal.objectIds())\n+        self.assertIn("Potential link breakage", self.browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n+        )\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc2">Test Page 2</a>\', self.browser.contents\n+        )\n+        self.browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("folder1", self.portal.objectIds())\n \n     def test_removal_with_cookie_auth(self):\n         doc1 = self.portal.doc1\n@@ -192,33 +203,35 @@ def test_removal_with_cookie_auth(self):\n         set_text(doc1, \'<a href="doc2">doc2</a>\')\n         transaction.commit()\n \n-        browser = Browser(self.layer[\'app\'])\n+        browser = Browser(self.layer["app"])\n         browser.handleErrors = True\n-        browser.addHeader(\'Referer\', self.portal.absolute_url())\n-        browser.open(\n-            f\'{self.portal.absolute_url():s}/folder_contents\')\n+        browser.addHeader("Referer", self.portal.absolute_url())\n+        browser.open(f"{self.portal.absolute_url():s}/folder_contents")\n \n         # At this point we shouldn\'t be able to look at the folder\n         # contents (as an anonymous user):\n-        self.assertIn(\'login?came_from\', browser.url)\n+        self.assertIn("login?came_from", browser.url)\n \n         # So we log in via the regular plone login form and additionally check\n         # that there is no \'authorization\' header set afterwards:\n-        browser.getControl(name=\'__ac_name\').value = TEST_USER_NAME\n-        browser.getControl(name=\'__ac_password\').value = TEST_USER_PASSWORD\n-        browser.getControl(\'Log in\').click()\n-        self.assertNotIn(\n-            \'authorization\', [h.lower() for h in browser.headers.keys()])\n+        browser.getControl(name="__ac_name").value = TEST_USER_NAME\n+        browser.getControl(name="__ac_password").value = TEST_USER_PASSWORD\n+        browser.getControl("Log in").click()\n+        self.assertNotIn("authorization", [h.lower() for h in browser.headers.keys()])\n \n         # This should lead us back to the "folder contents" listing,\n         # where we try to delete the referenced document.\n-        browser.open(\'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n-            doc2.absolute_url(), self._get_token(doc2)))\n-        self.assertIn(\'Potential link breakage\', browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-                      browser.contents)\n-        browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'doc2\', self.portal.objectIds())\n+        browser.open(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n+                doc2.absolute_url(), self._get_token(doc2)\n+            )\n+        )\n+        self.assertIn("Potential link breakage", browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', browser.contents\n+        )\n+        browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("doc2", self.portal.objectIds())\n \n     def test_linkintegrity_on_off_switch(self):\n         doc1 = self.portal.doc1\n@@ -235,22 +248,23 @@ def test_linkintegrity_on_off_switch(self):\n         self.browser.handleErrors = True\n \n         self.browser.open(\n-            \'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 doc2.absolute_url(), self._get_token(doc2)\n             )\n         )\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-                      self.browser.contents)\n+        self.assertIn("Potential link breakage", self.browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n+        )\n \n         # Now we turn the switch for link integrity checking off via the site\n         # properties and try again:\n         registry = getUtility(IRegistry)\n-        settings = registry.forInterface(IEditingSchema, prefix=\'plone\')\n+        settings = registry.forInterface(IEditingSchema, prefix="plone")\n         settings.enable_link_integrity_checks = False\n         transaction.commit()\n         self.browser.reload()\n-        self.assertNotIn(\'Potential link breakage\', self.browser.contents)\n+        self.assertNotIn("Potential link breakage", self.browser.contents)\n \n     def test_update(self):\n         doc1 = self.portal.doc1\n@@ -275,21 +289,25 @@ def test_update(self):\n         # An update of link integrity information for all content is triggered\n         # by browsing a specific url:\n         transaction.commit()\n-        self.browser.open(\'{:s}/updateLinkIntegrityInformation\'.format(\n-            self.portal.absolute_url()))\n-        self.browser.getControl(\'Update\').click()\n-        self.assertIn(\'Link integrity information updated for\',\n-                      self.browser.contents)\n+        self.browser.open(\n+            "{:s}/updateLinkIntegrityInformation".format(self.portal.absolute_url())\n+        )\n+        self.browser.getControl("Update").click()\n+        self.assertIn("Link integrity information updated for", self.browser.contents)\n \n         # Now the linking documents should hold the correct link integrity\n         # references:\n         self.assertEqual(\n             [i.to_object for i in getOutgoingLinks(doc1)],\n-            [doc2, ],\n+            [\n+                doc2,\n+            ],\n         )\n         self.assertEqual(\n             [i.to_object for i in getOutgoingLinks(doc2)],\n-            [doc4, ],\n+            [\n+                doc4,\n+            ],\n         )\n \n     def test_references_on_cloned_objects(self):\n@@ -302,12 +320,12 @@ def test_references_on_cloned_objects(self):\n \n         # Next we clone the document:\n         token = self._get_token(doc1)\n-        self.request[\'_authenticator\'] = token\n-        doc1.restrictedTraverse(\'object_copy\')()\n+        self.request["_authenticator"] = token\n+        doc1.restrictedTraverse("object_copy")()\n \n-        self.request[\'_authenticator\'] = token\n-        self.portal.restrictedTraverse(\'object_paste\')()\n-        self.assertIn(\'copy_of_doc1\', self.portal)\n+        self.request["_authenticator"] = token\n+        self.portal.restrictedTraverse("object_paste")()\n+        self.assertIn("copy_of_doc1", self.portal)\n         transaction.commit()\n \n         # Then we try to delete the document linked by the original document\n@@ -318,20 +336,17 @@ def test_references_on_cloned_objects(self):\n         # Now we can continue and "click" the "delete" action. The confirmation\n         # page should list both documents:\n         self.browser.open(\n-            \'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 doc2.absolute_url(), self._get_token(doc2)\n             )\n         )\n+        self.assertIn("is referenced by the following items:", self.browser.contents)\n+        self.assertIn("Potential link breakage", self.browser.contents)\n         self.assertIn(\n-            \'is referenced by the following items:\', self.browser.contents)\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\n-            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-            self.browser.contents\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n         )\n         self.assertIn(\n-            \'<a href="http://nohost/plone/copy_of_doc1"\',\n-            self.browser.contents\n+            \'<a href="http://nohost/plone/copy_of_doc1"\', self.browser.contents\n         )\n \n     def test_files_with_spaces_removal(self):\n@@ -340,16 +355,16 @@ def test_files_with_spaces_removal(self):\n         # This tests the behaviour when removing a referenced file that has\n         # spaces in its id.  First we need to rename the existing file:\n         self.portal.invokeFactory(\n-            \'Document\', id=\'some spaces.doc\', title=\'A spaces doc\')\n+            "Document", id="some spaces.doc", title="A spaces doc"\n+        )\n \n-        self.assertIn(\'some spaces.doc\', self.portal.objectIds())\n-        spaces1 = self.portal[\'some spaces.doc\']\n+        self.assertIn("some spaces.doc", self.portal.objectIds())\n+        spaces1 = self.portal["some spaces.doc"]\n \n         set_text(doc1, \'<a href="some spaces.doc">a document</a>\')\n \n         # The document should now have a reference to the file:\n-        self.assertEqual(\n-            [i.to_object for i in getOutgoingLinks(doc1)], [spaces1])\n+        self.assertEqual([i.to_object for i in getOutgoingLinks(doc1)], [spaces1])\n         transaction.commit()\n \n         # Then we use a browser to try to delete the referenced file.\n@@ -358,17 +373,16 @@ def test_files_with_spaces_removal(self):\n         self.browser.handleErrors = True\n \n         self.browser.open(\n-            \'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 spaces1.absolute_url(), self._get_token(spaces1)\n             )\n         )\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n+        self.assertIn("Potential link breakage", self.browser.contents)\n         self.assertIn(\n-            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-            self.browser.contents\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n         )\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'some spaces.doc\', self.portal.objectIds())\n+        self.browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("some spaces.doc", self.portal.objectIds())\n \n     def test_removal_via_zmi(self):\n         """Delete via ZMI is no longer protedted!"""\n@@ -386,22 +400,22 @@ def test_removal_via_zmi(self):\n         # framework from choking on the exception we intentionally throw.\n         self.browser.handleErrors = True\n \n-        self.browser.open(\'http://nohost/plone/manage_main\')\n-        self.browser\\\n-            .getControl(name=\'ids:list\')\\\n-            .getControl(value=\'doc2\').selected = True\n+        self.browser.open("http://nohost/plone/manage_main")\n+        self.browser.getControl(name="ids:list").getControl(\n+            value="doc2"\n+        ).selected = True\n \n-        self.browser.getControl(\'Delete\').click()\n-        self.assertNotIn(\'doc2\', self.portal.objectIds())\n+        self.browser.getControl("Delete").click()\n+        self.assertNotIn("doc2", self.portal.objectIds())\n \n     def test_warn_about_content(self):\n         folder1 = self.portal.folder1\n         self.browser.open(\n-            \'{:s}/delete_confirmation?_authenticator={:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 folder1.absolute_url(), self._get_token(folder1)\n             )\n         )\n-        self.assertIn(\'Number of selected\', self.browser.contents)\n-        self.assertIn(\'2 Objects in all\', self.browser.contents)\n-        self.assertIn(\'1 Folders\', self.browser.contents)\n-        self.assertIn(\'0 Published objects\', self.browser.contents)\n+        self.assertIn("Number of selected", self.browser.contents)\n+        self.assertIn("2 Objects in all", self.browser.contents)\n+        self.assertIn("1 Folders", self.browser.contents)\n+        self.assertIn("0 Published objects", self.browser.contents)\ndiff --git a/plone/app/linkintegrity/tests/test_handlers.py b/plone/app/linkintegrity/tests/test_handlers.py\nindex 2f455b2..5b094ef 100644\n--- a/plone/app/linkintegrity/tests/test_handlers.py\n+++ b/plone/app/linkintegrity/tests/test_handlers.py\n@@ -7,39 +7,39 @@\n \n \n class ReferenceGenerationTestCase(unittest.TestCase):\n-    """ testing the handlers.findObject function """\n+    """testing the handlers.findObject function"""\n \n     layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def test_relative_to_portal_root_1(self):\n-        obj, components = findObject(self.portal.doc1, \'/plone/doc2\')\n-        self.assertEqual(obj.absolute_url_path(), \'/plone/doc2\')\n-        self.assertEqual(components, \'\')\n+        obj, components = findObject(self.portal.doc1, "/plone/doc2")\n+        self.assertEqual(obj.absolute_url_path(), "/plone/doc2")\n+        self.assertEqual(components, "")\n \n     def test_relative_to_portal_root_2(self):\n         # Prevent regression.\n         # See https://github.com/plone/plone.app.linkintegrity/pull/17\n-        obj, components = findObject(self.portal.doc1, \'/doc2\')\n-        self.assertEqual(obj.absolute_url_path(), \'/plone/doc2\')\n-        self.assertEqual(components, \'\')\n+        obj, components = findObject(self.portal.doc1, "/doc2")\n+        self.assertEqual(obj.absolute_url_path(), "/plone/doc2")\n+        self.assertEqual(components, "")\n \n     def test_webserver_rewrites_portal_name(self):\n         # test the case where a webserver rewrites the portal name,\n         # e.g. for Apache:\n         # RewriteRule ^/wssitename(.*)$ http://localhost:8080/VirtualHostBase/http/my.domain.com:80/plonesitename/VirtualHostRoot/_vh_wssitename$1  # noqa\n-        self.portal.REQUEST.other[\'VirtualRootPhysicalPath\'] = (\'\', \'plone\')\n-        self.portal.REQUEST._script = [\'plone_foo\']\n-        obj, components = findObject(self.portal.doc1, \'/plone_foo/doc2\')\n-        self.assertEqual(obj.absolute_url_path(), \'/plone_foo/doc2\')\n-        self.assertEqual(obj.getPhysicalPath(), (\'\', \'plone\', \'doc2\'))\n-        self.assertEqual(components, \'\')\n+        self.portal.REQUEST.other["VirtualRootPhysicalPath"] = ("", "plone")\n+        self.portal.REQUEST._script = ["plone_foo"]\n+        obj, components = findObject(self.portal.doc1, "/plone_foo/doc2")\n+        self.assertEqual(obj.absolute_url_path(), "/plone_foo/doc2")\n+        self.assertEqual(obj.getPhysicalPath(), ("", "plone", "doc2"))\n+        self.assertEqual(components, "")\n \n     def test_uuid_link(self):\n         # Test that objects can be found from uuid links.\n-        create(self.portal, \'Document\', id=\'target\', title=\'Target\')\n+        create(self.portal, "Document", id="target", title="Target")\n         target = self.portal.target\n         target_uid = target.UID()\n         path = f"../resolveuid/{target_uid}"\n@@ -50,5 +50,5 @@ def test_uuid_link(self):\n         logout()\n \n         obj, components = findObject(self.portal.doc1, path)\n-        self.assertEqual(obj.absolute_url_path(), \'/plone/target\')\n+        self.assertEqual(obj.absolute_url_path(), "/plone/target")\n         self.assertEqual(components, path)\ndiff --git a/plone/app/linkintegrity/tests/test_imagescales.py b/plone/app/linkintegrity/tests/test_imagescales.py\nindex a809603..5e52c21 100644\n--- a/plone/app/linkintegrity/tests/test_imagescales.py\n+++ b/plone/app/linkintegrity/tests/test_imagescales.py\n@@ -13,7 +13,7 @@ class ImageReferenceTestCase(unittest.TestCase):\n     layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def test_image_tag_reference_creation(self):\n         doc1 = self.portal.doc1\n@@ -23,11 +23,13 @@ def test_image_tag_reference_creation(self):\n         # ensuring link integrity. Any archetype-based content object\n         # which refers to other (local) objects by `<img>` or `<a>` tags\n         # should create references between those objects on save.\n-        set_text(doc1, img1.restrictedTraverse(\'@@images\').tag())\n+        set_text(doc1, img1.restrictedTraverse("@@images").tag())\n \n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n-            [img1, ],\n+            [\n+                img1,\n+            ],\n         )\n         self.assertEqual([r.to_object for r in getIncomingLinks(doc1)], [])\n         self.assertEqual([r.to_object for r in getOutgoingLinks(img1)], [])\n@@ -41,15 +43,18 @@ def test_image_scale_reference_creation(self):\n         img1 = self.portal.image1\n \n         # Linking image scales should also work:\n-        set_text(\n-            doc1, \'<a href="image1/@@images/image_thumb">an image</a>\')\n+        set_text(doc1, \'<a href="image1/@@images/image_thumb">an image</a>\')\n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n-            [img1, ],\n+            [\n+                img1,\n+            ],\n         )\n         self.assertEqual(\n             [r.from_object for r in getIncomingLinks(img1)],\n-            [doc1, ],\n+            [\n+                doc1,\n+            ],\n         )\n \n     def test_image_resolveuid_reference_creation(self):\n@@ -57,13 +62,16 @@ def test_image_resolveuid_reference_creation(self):\n         img1 = self.portal.image1\n \n         # Linking via the "resolveuid/UID" method should also work:\n-        set_text(doc1, \'<a href="resolveuid/{:s}">an image</a>\'.format(\n-            IUUID(img1)))\n+        set_text(doc1, \'<a href="resolveuid/{:s}">an image</a>\'.format(IUUID(img1)))\n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n-            [img1, ],\n+            [\n+                img1,\n+            ],\n         )\n         self.assertEqual(\n             [r.from_object for r in getIncomingLinks(img1)],\n-            [doc1, ],\n+            [\n+                doc1,\n+            ],\n         )\ndiff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py\nindex 67a413d..eef0bcf 100644\n--- a/plone/app/linkintegrity/tests/test_references.py\n+++ b/plone/app/linkintegrity/tests/test_references.py\n@@ -25,19 +25,19 @@ class ReferenceGenerationTestCase(unittest.TestCase):\n     layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def _set_related_items(self, obj, items):\n         assert IRelatedItems.providedBy(obj)\n-        setattr(obj, \'relatedItems\', items)\n+        setattr(obj, "relatedItems", items)\n         modified(obj)\n \n     def _get_related_items(self, obj):\n         return obj.relatedItems\n \n     def test_is_linked(self):\n-        img1 = self.portal[\'image1\']\n-        doc1 = self.portal[\'doc1\']\n+        img1 = self.portal["image1"]\n+        doc1 = self.portal["doc1"]\n         set_text(doc1, \'<img src="image1"></img>\')\n         self.assertTrue(hasIncomingLinks(img1))\n \n@@ -52,27 +52,28 @@ def test_referal_to_private_files(self):\n         img = self.portal.image1\n         set_text(doc, \'<a href="image1">Image 1</a>\')\n \n-        roles = (\'Member\', )\n-        self.portal.manage_permission(\'List folder contents\', roles=roles)\n-        self.portal.manage_permission(\'Delete objects\', roles=roles)\n-        doc.manage_permission(\'View\', roles=(\'Manager\',), acquire=0)\n-        doc.manage_permission(\'Access contents information\',\n-                              roles=(\'Manager\', ), acquire=0)\n+        roles = ("Member",)\n+        self.portal.manage_permission("List folder contents", roles=roles)\n+        self.portal.manage_permission("Delete objects", roles=roles)\n+        doc.manage_permission("View", roles=("Manager",), acquire=0)\n+        doc.manage_permission(\n+            "Access contents information", roles=("Manager",), acquire=0\n+        )\n \n         logout()\n-        login(self.portal, \'member\')\n+        login(self.portal, "member")\n         checkPermission = self.portal.portal_membership.checkPermission\n-        self.assertFalse(checkPermission(\'View\', doc))\n-        self.assertFalse(checkPermission(\'Access contents information\', doc))\n-        self.assertTrue(checkPermission(\'View\', img))\n-        self.assertTrue(checkPermission(\'Access contents information\', img))\n+        self.assertFalse(checkPermission("View", doc))\n+        self.assertFalse(checkPermission("Access contents information", doc))\n+        self.assertTrue(checkPermission("View", img))\n+        self.assertTrue(checkPermission("Access contents information", img))\n \n         # The warning is shown.\n         self.assertTrue(hasOutgoingLinks(doc))\n-        view = img.restrictedTraverse(\'delete_confirmation\')\n+        view = img.restrictedTraverse("delete_confirmation")\n         results = view()\n-        self.assertIn(\'Potential link breakage\', results)\n-        self.assertIn(\'The item is not accessible.\', results)\n+        self.assertIn("Potential link breakage", results)\n+        self.assertIn("The item is not accessible.", results)\n \n         # delete linked item and check if the source still has the relation\n \n@@ -97,35 +98,30 @@ def test_referal_to_private_files(self):\n     def test_link_extraction_easy(self):\n         doc1 = self.portal.doc1\n         set_text(doc1, \'<a href="doc2">Doc 2</a>\')\n-        self.assertEqual(\n-            extractLinks(doc1.text.raw),\n-            (\'doc2\', )\n-        )\n+        self.assertEqual(extractLinks(doc1.text.raw), ("doc2",))\n \n     def test_link_extraction_more_complex(self):\n         doc2 = self.portal.doc2\n         set_text(\n             doc2,\n-            \'<a href="doc1">Doc 2</a>\' +\n-            \'<a href="folder1/doc3"><img src="image1" /></a>\',\n+            \'<a href="doc1">Doc 2</a>\'\n+            + \'<a href="folder1/doc3"><img src="image1" /></a>\',\n         )\n         self.assertEqual(\n-            extractLinks(doc2.text.raw),\n-            (\'doc1\',\n-             \'folder1/doc3\',\n-             \'image1\')\n+            extractLinks(doc2.text.raw), ("doc1", "folder1/doc3", "image1")\n         )\n \n     def test_broken_references(self):\n         # create a temporary document to test with\n-        doc1a = testing.create(self.portal, \'Document\', id=\'doc1a\')\n+        doc1a = testing.create(self.portal, "Document", id="doc1a")\n         doc1 = self.portal.doc1\n \n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)\n         set_text(doc1, \'<a href="doc1a">Doc 1a</a>\')\n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 1)\n-        self.assertEqual([link.to_object for link in getOutgoingLinks(doc1)],\n-                         [self.portal.doc1a])\n+        self.assertEqual(\n+            [link.to_object for link in getOutgoingLinks(doc1)], [self.portal.doc1a]\n+        )\n \n         # Now delete the target item, suppress events and test again,\n         # The reference should be a ghost not in any folder anymore.\n@@ -137,17 +133,16 @@ def test_broken_references(self):\n         if obj is not None:\n             # Plone with fixed five.intid\n             # if object is None: all fine as well.\n-            self.assertEqual(obj.portal_type, \'Document\')\n+            self.assertEqual(obj.portal_type, "Document")\n             _marker = dict()\n-            self.assertEqual(getattr(obj, \'aq_parent\', _marker), _marker)\n+            self.assertEqual(getattr(obj, "aq_parent", _marker), _marker)\n \n     def test_relative_upwards_link_generates_matching_reference(self):\n         doc1 = self.portal.doc1\n         doc3 = self.portal.folder1.doc3\n         set_text(doc3, \'<a href="../doc1">go!</a>\')\n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)\n-        self.assertEqual([link.to_object for link in getOutgoingLinks(doc3)],\n-                         [doc1])\n+        self.assertEqual([link.to_object for link in getOutgoingLinks(doc3)], [doc1])\n \n     def test_unicode_links(self):\n         doc1 = self.portal.doc1\n@@ -156,16 +151,14 @@ def test_unicode_links(self):\n         # eventually plays well with transaction machinery.\n         # Add bad link, should not raise exception and there should not\n         # be any references added.\n-        set_text(\n-            doc1,\n-            \'<a href="\xc3\xb6?foo=bar&baz=bam">bug</a>\')\n+        set_text(doc1, \'<a href="\xc3\xb6?foo=bar&baz=bam">bug</a>\')\n \n         self.assertEqual([link for link in getOutgoingLinks(doc1)], [])\n \n     def test_reference_orthogonality(self):\n         doc = self.portal.doc1\n         img = self.portal.image1\n-        tag = img.restrictedTraverse(\'@@images\').tag()\n+        tag = img.restrictedTraverse("@@images").tag()\n \n         # This tests the behavior when other references already exist.\n         self.assertEqual([link for link in getOutgoingLinks(doc)], [])\n@@ -175,8 +168,18 @@ def test_reference_orthogonality(self):\n \n         # Then establish a reference between the document and image as\n         # a related item:\n-        self._set_related_items(doc, [img, ])\n-        self.assertEqual(self._get_related_items(doc), [img, ])\n+        self._set_related_items(\n+            doc,\n+            [\n+                img,\n+            ],\n+        )\n+        self.assertEqual(\n+            self._get_related_items(doc),\n+            [\n+                img,\n+            ],\n+        )\n \n         # Next edit the document body and insert a link to the image,\n         # which should trigger the creation of a link integrity reference:\n@@ -185,37 +188,47 @@ def test_reference_orthogonality(self):\n         self.assertEqual([link.to_object for link in getOutgoingLinks(doc)], [img])\n \n         # And the related item reference remains in place:\n-        self.assertEqual(self._get_related_items(doc), [img, ])\n+        self.assertEqual(\n+            self._get_related_items(doc),\n+            [\n+                img,\n+            ],\n+        )\n \n         # Finally, edit the document body again, this time removing the\n         # link to the image, which should trigger the removal of the\n         # link integrity reference:\n-        set_text(doc, \'where did my link go?\')\n+        set_text(doc, "where did my link go?")\n         self.assertEqual([link.to_object for link in getOutgoingLinks(doc)], [])\n \n         # And again the related item reference remains in place:\n-        self.assertEqual(self._get_related_items(doc), [img, ])\n+        self.assertEqual(\n+            self._get_related_items(doc),\n+            [\n+                img,\n+            ],\n+        )\n \n     def test_delete_confirmation_for_any_reference(self):\n         """Test, if delete confirmation shows also a warning if items are\n         deleted, which are referenced by other items via a reference field.\n         """\n-        img1 = self.portal[\'image1\']\n-        doc1 = self.portal[\'doc1\']\n+        img1 = self.portal["image1"]\n+        doc1 = self.portal["doc1"]\n \n         intids_tool = getUtility(IIntIds)\n         to_id = intids_tool.getId(img1)\n         rel = RelationValue(to_id)\n-        _setRelation(doc1, \'related_image\', rel)\n+        _setRelation(doc1, "related_image", rel)\n \n         # Test, if relation is present in the relation catalog\n         catalog = getUtility(ICatalog)\n-        rels = list(catalog.findRelations({\'to_id\': to_id}))\n+        rels = list(catalog.findRelations({"to_id": to_id}))\n         self.assertEqual(len(rels), 1)\n \n         # Test, if delete_confirmation_info shows also other relations than\n         # ``isReferencing``.\n-        info = img1.restrictedTraverse(\'@@delete_confirmation_info\')\n+        info = img1.restrictedTraverse("@@delete_confirmation_info")\n         breaches = info.get_breaches()\n         self.assertEqual(len(breaches), 1)\n-        self.assertEqual(len(info.get_breaches()[0][\'sources\']), 1)\n+        self.assertEqual(len(info.get_breaches()[0]["sources"]), 1)\ndiff --git a/plone/app/linkintegrity/utils.py b/plone/app/linkintegrity/utils.py\nindex 1c97817..5990bdd 100644\n--- a/plone/app/linkintegrity/utils.py\n+++ b/plone/app/linkintegrity/utils.py\n@@ -6,22 +6,18 @@\n from zope.keyreference.interfaces import NotYet\n \n \n-referencedRelationship = \'isReferencing\'\n+referencedRelationship = "isReferencing"\n \n \n-def getIncomingLinks(\n-    obj=None,\n-    intid=None,\n-    from_attribute=referencedRelationship\n-):\n+def getIncomingLinks(obj=None, intid=None, from_attribute=referencedRelationship):\n     """Return a generator of incoming relations created using\n     plone.app.linkintegrity (Links in Richtext-Fields).\n     """\n     catalog = getUtility(ICatalog)\n     intid = intid if intid is not None else getUtility(IIntIds).getId(obj)\n-    query = {\'to_id\': intid}\n+    query = {"to_id": intid}\n     if from_attribute:\n-        query[\'from_attribute\'] = from_attribute\n+        query["from_attribute"] = from_attribute\n     return catalog.findRelations(query)\n \n \n@@ -36,19 +32,15 @@ def hasIncomingLinks(obj=None, intid=None):\n     return False\n \n \n-def getOutgoingLinks(\n-    obj=None,\n-    intid=None,\n-    from_attribute=referencedRelationship\n-):\n+def getOutgoingLinks(obj=None, intid=None, from_attribute=referencedRelationship):\n     """Return a generator of outgoing relations created using\n     plone.app.linkintegrity (Links in Richtext-Fields).\n     """\n     catalog = getUtility(ICatalog)\n     intid = intid if intid is not None else getUtility(IIntIds).getId(obj)\n-    query = {\'from_id\': intid}\n+    query = {"from_id": intid}\n     if from_attribute:\n-        query[\'from_attribute\'] = from_attribute\n+        query["from_attribute"] = from_attribute\n     return catalog.findRelations(query)\n \n \n@@ -63,7 +55,7 @@ def hasOutgoingLinks(obj=None, intid=None):\n \n def linkintegrity_enabled():\n     reg = getUtility(IRegistry)\n-    editing_settings = reg.forInterface(IEditingSchema, prefix=\'plone\')\n+    editing_settings = reg.forInterface(IEditingSchema, prefix="plone")\n     return editing_settings.enable_link_integrity_checks\n \n \ndiff --git a/setup.py b/setup.py\nindex 9615d69..87bcd6f 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -2,16 +2,18 @@\n from setuptools import setup\n \n \n-version = \'4.0.1.dev0\'\n+version = "4.0.1.dev0"\n \n setup(\n-    name=\'plone.app.linkintegrity\',\n+    name="plone.app.linkintegrity",\n     version=version,\n-    description=\'Manage link integrity in Plone.\',\n-    long_description=\'\\n\\n\'.join([\n-        open("README.rst").read(),\n-        open(\'CHANGES.rst\').read(),\n-    ]),\n+    description="Manage link integrity in Plone.",\n+    long_description="\\n\\n".join(\n+        [\n+            open("README.rst").read(),\n+            open("CHANGES.rst").read(),\n+        ]\n+    ),\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Environment :: Web Environment",\n@@ -30,33 +32,33 @@\n         "Programming Language :: Python :: 3.11",\n         "Topic :: Internet :: WWW/HTTP :: Site Management :: Link Checking",\n     ],\n-    keywords=\'link integrity plone\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://github.com/plone/plone.app.linkintegrity\',\n-    license=\'GPL version 2\',\n+    keywords="link integrity plone",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://github.com/plone/plone.app.linkintegrity",\n+    license="GPL version 2",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\', \'plone.app\'],\n+    namespace_packages=["plone", "plone.app"],\n     include_package_data=True,\n-    python_requires=\'>=3.8\',\n+    python_requires=">=3.8",\n     install_requires=[\n-        \'setuptools\',\n-        \'plone.app.intid\',\n-        \'plone.app.relationfield\',\n-        \'plone.base\',\n-        \'plone.dexterity\',\n+        "setuptools",\n+        "plone.app.intid",\n+        "plone.app.relationfield",\n+        "plone.base",\n+        "plone.dexterity",\n     ],\n     extras_require={\n-        \'test\': [\n-            \'plone.app.testing\',\n-            \'plone.app.contenttypes\',\n-            \'plone.app.dexterity [relations]\',  # related items in dx 2.0\n+        "test": [\n+            "plone.app.testing",\n+            "plone.app.contenttypes",\n+            "plone.app.dexterity [relations]",  # related items in dx 2.0\n         ],\n     },\n-    platforms=\'Any\',\n+    platforms="Any",\n     zip_safe=False,\n-    entry_points=\'\'\'\n+    entry_points="""\n     [z3c.autoinclude.plugin]\n     target = plone\n-    \'\'\',\n+    """,\n )\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2023-04-03T00:33:01+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/2c93040ea6ca2dcc177b6e5b9f7b48edf799c7eb

pyupgrade

Files changed:
M plone/app/linkintegrity/tests/test_functional.py
M plone/app/linkintegrity/tests/test_imagescales.py

b'diff --git a/plone/app/linkintegrity/tests/test_functional.py b/plone/app/linkintegrity/tests/test_functional.py\nindex e3129db..15221b7 100644\n--- a/plone/app/linkintegrity/tests/test_functional.py\n+++ b/plone/app/linkintegrity/tests/test_functional.py\n@@ -290,7 +290,7 @@ def test_update(self):\n         # by browsing a specific url:\n         transaction.commit()\n         self.browser.open(\n-            "{:s}/updateLinkIntegrityInformation".format(self.portal.absolute_url())\n+            f"{self.portal.absolute_url():s}/updateLinkIntegrityInformation"\n         )\n         self.browser.getControl("Update").click()\n         self.assertIn("Link integrity information updated for", self.browser.contents)\ndiff --git a/plone/app/linkintegrity/tests/test_imagescales.py b/plone/app/linkintegrity/tests/test_imagescales.py\nindex 5e52c21..3661478 100644\n--- a/plone/app/linkintegrity/tests/test_imagescales.py\n+++ b/plone/app/linkintegrity/tests/test_imagescales.py\n@@ -62,7 +62,7 @@ def test_image_resolveuid_reference_creation(self):\n         img1 = self.portal.image1\n \n         # Linking via the "resolveuid/UID" method should also work:\n-        set_text(doc1, \'<a href="resolveuid/{:s}">an image</a>\'.format(IUUID(img1)))\n+        set_text(doc1, f\'<a href="resolveuid/{IUUID(img1):s}">an image</a>\')\n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n             [\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2023-04-03T00:33:31+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/48933642f2585afb7bfa1d1ebf66b2946e1b9964

chore: zpretty ZCML/XML

Files changed:
M plone/app/linkintegrity/browser/configure.zcml
M plone/app/linkintegrity/configure.zcml
M plone/app/linkintegrity/profiles/default/metadata.xml

b'diff --git a/plone/app/linkintegrity/browser/configure.zcml b/plone/app/linkintegrity/browser/configure.zcml\nindex ffff903..7931e09 100644\n--- a/plone/app/linkintegrity/browser/configure.zcml\n+++ b/plone/app/linkintegrity/browser/configure.zcml\n@@ -1,20 +1,21 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    xmlns:browser="http://namespaces.zope.org/browser">\n+    xmlns:browser="http://namespaces.zope.org/browser"\n+    >\n \n   <browser:page\n-       for="*"\n-       name="delete_confirmation_info"\n-       class=".info.DeleteConfirmationInfo"\n-       permission="zope2.Public"\n-       />\n+      name="delete_confirmation_info"\n+      for="*"\n+      class=".info.DeleteConfirmationInfo"\n+      permission="zope2.Public"\n+      />\n \n   <browser:page\n-        name="updateLinkIntegrityInformation"\n-        for="plone.base.interfaces.IPloneSiteRoot"\n-        template="update.pt"\n-        class=".update.UpdateView"\n-        permission="cmf.ManagePortal"\n-        />\n+      name="updateLinkIntegrityInformation"\n+      for="plone.base.interfaces.IPloneSiteRoot"\n+      class=".update.UpdateView"\n+      template="update.pt"\n+      permission="cmf.ManagePortal"\n+      />\n \n </configure>\ndiff --git a/plone/app/linkintegrity/configure.zcml b/plone/app/linkintegrity/configure.zcml\nindex ce1cd55..d11d5ef 100644\n--- a/plone/app/linkintegrity/configure.zcml\n+++ b/plone/app/linkintegrity/configure.zcml\n@@ -6,7 +6,10 @@\n \n   <include package="plone.app.intid" />\n   <include package="plone.app.relationfield" />\n-  <include package="Products.CMFCore" file="permissions.zcml" />\n+  <include\n+      package="Products.CMFCore"\n+      file="permissions.zcml"\n+      />\n \n   <include package=".browser" />\n \n@@ -14,25 +17,28 @@\n \n   <subscriber\n       for="plone.app.relationfield.interfaces.IDexterityHasRelations\n-            zope.lifecycleevent.interfaces.IObjectCopiedEvent"\n-      handler=".handlers.modifiedContent" />\n+           zope.lifecycleevent.interfaces.IObjectCopiedEvent"\n+      handler=".handlers.modifiedContent"\n+      />\n \n   <subscriber\n       for="plone.app.relationfield.interfaces.IDexterityHasRelations\n-            zope.lifecycleevent.interfaces.IObjectAddedEvent"\n-      handler=".handlers.modifiedContent" />\n+           zope.lifecycleevent.interfaces.IObjectAddedEvent"\n+      handler=".handlers.modifiedContent"\n+      />\n \n   <subscriber\n       for="plone.app.relationfield.interfaces.IDexterityHasRelations\n-            zope.lifecycleevent.interfaces.IObjectModifiedEvent"\n-      handler=".handlers.modifiedContent" />\n+           zope.lifecycleevent.interfaces.IObjectModifiedEvent"\n+      handler=".handlers.modifiedContent"\n+      />\n \n   <genericsetup:registerProfile\n       name="default"\n       title="plone.app.linkintegrity"\n-      directory="profiles/default"\n       description="Installs the plone.app.linkintegrity add-on."\n       provides="Products.GenericSetup.interfaces.EXTENSION"\n+      directory="profiles/default"\n       />\n \n </configure>\ndiff --git a/plone/app/linkintegrity/profiles/default/metadata.xml b/plone/app/linkintegrity/profiles/default/metadata.xml\nindex 3d93a8e..ffe02eb 100644\n--- a/plone/app/linkintegrity/profiles/default/metadata.xml\n+++ b/plone/app/linkintegrity/profiles/default/metadata.xml\n@@ -1,4 +1,4 @@\n-<?xml version="1.0"?>\n+<?xml version="1.0" encoding="utf-8"?>\n <metadata>\n   <version>1000</version>\n   <dependencies>\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2023-04-04T01:22:47+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/037ffe3db70205c88db0dec7ed9c7e1319d99528

chore: zpretty PT

Files changed:
M plone/app/linkintegrity/browser/delete_confirmation_info.pt
M plone/app/linkintegrity/browser/update.pt

b'diff --git a/plone/app/linkintegrity/browser/delete_confirmation_info.pt b/plone/app/linkintegrity/browser/delete_confirmation_info.pt\nindex d2263f5..0b938c0 100644\n--- a/plone/app/linkintegrity/browser/delete_confirmation_info.pt\n+++ b/plone/app/linkintegrity/browser/delete_confirmation_info.pt\n@@ -1,86 +1,135 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"\n-    xmlns:tal="http://xml.zope.org/namespaces/tal"\n-    xmlns:metal="http://xml.zope.org/namespaces/metal"\n-    xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-    lang="en"\n-    i18n:domain="plone"\n-    tal:omit-tag="">\n-<body tal:omit-tag="" tal:define="breaches python:view.breaches">\n+<html xmlns="http://www.w3.org/1999/xhtml"\n+      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n+      xmlns:metal="http://xml.zope.org/namespaces/metal"\n+      xmlns:tal="http://xml.zope.org/namespaces/tal"\n+      lang="en"\n+      xml:lang="en"\n+      tal:omit-tag=""\n+      i18n:domain="plone"\n+>\n+  <body tal:define="\n+          breaches python:view.breaches;\n+        "\n+        tal:omit-tag=""\n+  >\n \n-  <h2 tal:condition="breaches" i18n:translate="linkintegrity_breaches_title">Potential link breakage</h2>\n+    <h2 tal:condition="breaches"\n+        i18n:translate="linkintegrity_breaches_title"\n+    >Potential link breakage</h2>\n \n-  <div id="content-core">\n+    <div id="content-core">\n \n-    <p tal:condition="breaches" i18n:translate="linkintegrity_instructions">\n+      <p tal:condition="breaches"\n+         i18n:translate="linkintegrity_instructions"\n+      >\n       By deleting this item, you will break links that exist in the items listed\n       below. If this is indeed what you want to do, we recommend that you remove\n       these references first.\n-    </p>\n+      </p>\n \n-    <div tal:define="token context/@@authenticator/token">\n-      <article tal:repeat="breach breaches" class="breach-container">\n+      <div tal:define="\n+             token context/@@authenticator/token;\n+           ">\n+        <article class="breach-container"\n+                 tal:repeat="breach breaches"\n+        >\n \n-        <tal:target  tal:define="target breach/target">\n-          <header><a href="${target/url}" tal:content="target/title" /></header>\n-          <p>\n-            <span i18n:translate="linkintegrity_is_referenced">\n-              This <span i18n:name="portal_type" tal:content="target/type_title" />\n+          <tal:target tal:define="\n+                        target breach/target;\n+                      ">\n+            <header><a href="${target/url}"\n+                 tal:content="target/title"\n+              ></a></header>\n+            <p>\n+              <span i18n:translate="linkintegrity_is_referenced">\n+              This\n+                <span tal:content="target/type_title"\n+                      i18n:name="portal_type"\n+                ></span>\n               is referenced by the following items:\n-            </span>\n-          </p>\n-        </tal:target>\n+              </span>\n+            </p>\n+          </tal:target>\n \n-        <ul>\n-          <li tal:repeat="source python:breach[\'sources\']" class="breach-item">\n-            <tal:visible condition="source/accessible">\n-              <a tal:attributes="href source/url" tal:content="source/title" />\n-              [<a\n-                  tal:attributes="href string:${source/url}/edit?_authenticator=${token}"\n-                  i18n:translate="linkintegrity_edit_in_new_window"\n-                  target="_blank">Edit in new window</a>]\n-            </tal:visible>\n-            <tal:private\n-                condition="not: source/accessible"\n-                i18n:translate="linkintegrity_item_not_accessible">\n+          <ul>\n+            <li class="breach-item"\n+                tal:repeat="source python:breach[\'sources\']"\n+            >\n+              <tal:visible condition="source/accessible">\n+                <a tal:content="source/title"\n+                   tal:attributes="\n+                     href source/url;\n+                   "\n+                ></a>\n+                [<a target="_blank"\n+                   tal:attributes="\n+                     href string:${source/url}/edit?_authenticator=${token};\n+                   "\n+                   i18n:translate="linkintegrity_edit_in_new_window"\n+                >Edit in new window</a>]\n+              </tal:visible>\n+              <tal:private condition="not: source/accessible"\n+                           i18n:translate="linkintegrity_item_not_accessible"\n+              >\n               The item is not accessible.\n-            </tal:private>\n-          </li>\n-        </ul>\n+              </tal:private>\n+            </li>\n+          </ul>\n \n-      </article>\n+        </article>\n \n-      <div tal:define="breach_count view/breach_count" tal:condition="breach_count">\n+        <div tal:define="\n+               breach_count view/breach_count;\n+             "\n+             tal:condition="breach_count"\n+        >\n \n-        <h2 i18n:translate="deleting_overview" >Deleting overview</h2>\n-        <p>\n-          <span tal:define="refs python:len(breach_count)"\n-              i18n:translate="selected_folders_with_content">\n-            Number of selected, non-empty folders: <strong><span tal:replace="refs" i18n:name="refs" /></strong>\n-          </span>\n-        </p>\n-        <ul>\n-          <li tal:repeat="content python:breach_count">\n-            <span i18n:translate="deleting_contents"> Following content within\n-              <strong><span tal:replace="content" i18n:name="content" /></strong>  will also be deleted:\n-            </span><br/>\n-            <ul>\n-              <li tal:define="objects view/objects"\n-                  tal:repeat="item python:range(3) ">\n-                <span tal:replace="python: breach_count[content][item]" /> <span tal:replace="python: objects[item]" />\n-              </li>\n-            </ul>\n-          </li>\n-        </ul>\n+          <h2 i18n:translate="deleting_overview">Deleting overview</h2>\n+          <p>\n+            <span tal:define="\n+                    refs python:len(breach_count);\n+                  "\n+                  i18n:translate="selected_folders_with_content"\n+            >\n+            Number of selected, non-empty folders:\n+              <strong><span tal:replace="refs"\n+                      i18n:name="refs"\n+                ></span></strong>\n+            </span>\n+          </p>\n+          <ul>\n+            <li tal:repeat="content python:breach_count">\n+              <span i18n:translate="deleting_contents">\n+                 Following content within\n+                <strong><span tal:replace="content"\n+                        i18n:name="content"\n+                  ></span></strong>\n+                  will also be deleted:\n+              </span><br />\n+              <ul>\n+                <li tal:define="\n+                      objects view/objects;\n+                    "\n+                    tal:repeat="item python:range(3) "\n+                >\n+                  <span tal:replace="python: breach_count[content][item]"></span>\n+                  <span tal:replace="python: objects[item]"></span>\n+                </li>\n+              </ul>\n+            </li>\n+          </ul>\n \n-      </div>\n+        </div>\n \n-      <p tal:condition="breaches" i18n:translate="linkintegrity_delete_anyway">\n+        <p tal:condition="breaches"\n+           i18n:translate="linkintegrity_delete_anyway"\n+        >\n         Would you like to delete it anyway?\n-      </p>\n+        </p>\n \n-    </div>\n+      </div>\n \n-  </div>\n+    </div>\n \n-</body>\n+  </body>\n </html>\ndiff --git a/plone/app/linkintegrity/browser/update.pt b/plone/app/linkintegrity/browser/update.pt\nindex 1c461b3..f099245 100644\n--- a/plone/app/linkintegrity/browser/update.pt\n+++ b/plone/app/linkintegrity/browser/update.pt\n@@ -1,39 +1,58 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"\n-    xmlns:tal="http://xml.zope.org/namespaces/tal"\n-    xmlns:metal="http://xml.zope.org/namespaces/metal"\n-    xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-    lang="en"\n-    metal:use-macro="here/main_template/macros/master"\n-    i18n:domain="plone"\n-    tal:omit-tag="">\n-\n-<head>\n-  <metal:block\n-      fill-slot="top_slot"\n-      tal:define="dummy python:request.set(\'disable_border\',1)" />\n-</head>\n-\n-<body>\n-<metal:main fill-slot="main">\n-\n-  <h1 class="documentFirstHeading"\n-      i18n:translate="linkintegrity_update_title">Update link integrity information</h1>\n-\n-  <div id="content-core">\n-\n-    <p i18n:translate="linkintegrity_update_instructions">\n+<html xmlns="http://www.w3.org/1999/xhtml"\n+      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n+      xmlns:metal="http://xml.zope.org/namespaces/metal"\n+      xmlns:tal="http://xml.zope.org/namespaces/tal"\n+      lang="en"\n+      metal:use-macro="here/main_template/macros/master"\n+      xml:lang="en"\n+      tal:omit-tag=""\n+      i18n:domain="plone"\n+>\n+\n+  <head>\n+    <metal:block fill-slot="top_slot"\n+                 tal:define="\n+                   dummy python:request.set(\'disable_border\',1);\n+                 "\n+    />\n+  </head>\n+\n+  <body>\n+    <metal:main fill-slot="main">\n+\n+      <h1 class="documentFirstHeading"\n+          i18n:translate="linkintegrity_update_title"\n+      >Update link integrity information</h1>\n+\n+      <div id="content-core">\n+\n+        <p i18n:translate="linkintegrity_update_instructions">\n       Clicking the below button will cause link integrity information to be\n       updated. This might take a while, especially for bigger sites...\n-    </p>\n-\n-    <form method="post" action="updateLinkIntegrityInformation"\n-        tal:attributes="action request/URL">\n-      <input class="destructive" type="submit" name="update" i18n:attributes="value" value="Update" />\n-      <input class="standalone" type="submit" name="cancel" i18n:attributes="value" value="Cancel" />\n-    </form>\n-\n-  </div>\n-\n-</metal:main>\n-</body>\n+        </p>\n+\n+        <form action="updateLinkIntegrityInformation"\n+              method="post"\n+              tal:attributes="\n+                action request/URL;\n+              "\n+        >\n+          <input class="destructive"\n+                 name="update"\n+                 type="submit"\n+                 value="Update"\n+                 i18n:attributes="value"\n+          />\n+          <input class="standalone"\n+                 name="cancel"\n+                 type="submit"\n+                 value="Cancel"\n+                 i18n:attributes="value"\n+          />\n+        </form>\n+\n+      </div>\n+\n+    </metal:main>\n+  </body>\n </html>\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2023-04-04T01:34:46+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/aab3fda5b208501d11136c17c9059de60ae30d8b

feat: codespell

Files changed:
M CHANGES.rst
M README.rst
M plone/app/linkintegrity/browser/info.py
M plone/app/linkintegrity/handlers.py
M plone/app/linkintegrity/tests/test_references.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex f210c91..c9bd11f 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -538,7 +538,7 @@ New:\n   for fields which have been added via schema extension.\n   [malthe]\n \n-- Support resolveuid/UID references explicitely, by parsing and resolving\n+- Support resolveuid/UID references explicitly, by parsing and resolving\n   these ourselves instead of relying on a view or script (which doesn\'t work).\n   This fixes linkintegrity for sites with link-by-uid turned on.\n   This closes https://dev.plone.org/ticket/12104\ndiff --git a/README.rst b/README.rst\nindex 5e7a348..e864749 100644\n--- a/README.rst\n+++ b/README.rst\n@@ -65,7 +65,7 @@ API\n ---\n \n To check if there would be breaches when deleting one or more objects\n-you can use the follwing code:\n+you can use the following code:\n \n .. code-block:: python\n \ndiff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py\nindex f26d27a..d8c0af1 100644\n--- a/plone/app/linkintegrity/browser/info.py\n+++ b/plone/app/linkintegrity/browser/info.py\n@@ -55,7 +55,7 @@ def get_breaches(self, items=None):\n         for obj in items:\n             obj_path = "/".join(obj.getPhysicalPath())\n             brains_to_delete = catalog(path={"query": obj_path})\n-            # add the current items uid and all its childrens uids to the\n+            # add the current items uid and all its children\'s uids to the\n             # list of uids that are ignored\n             uids_to_ignore.extend([i.UID for i in brains_to_delete])\n             for brain_to_delete in brains_to_delete:\ndiff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py\nindex 07aa710..f9423b1 100644\n--- a/plone/app/linkintegrity/handlers.py\n+++ b/plone/app/linkintegrity/handlers.py\n@@ -40,7 +40,7 @@ def findObject(base, path):\n \n     components = path.split("/")\n \n-    # Support resolveuid/UID paths explicitely, without relying\n+    # Support resolveuid/UID paths explicitly, without relying\n     # on a view or skinscript to do this for us.\n     if "resolveuid" in components:\n         uid = components[components.index("resolveuid") + 1]\n@@ -78,7 +78,7 @@ def findObject(base, path):\n \n \n def getObjectsFromLinks(base, links):\n-    """determine actual objects refered to by given links"""\n+    """determine actual objects referred to by given links"""\n     intids = getUtility(IIntIds)\n     objects = set()\n     url = base.absolute_url()\ndiff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py\nindex eef0bcf..41aecdf 100644\n--- a/plone/app/linkintegrity/tests/test_references.py\n+++ b/plone/app/linkintegrity/tests/test_references.py\n@@ -125,7 +125,7 @@ def test_broken_references(self):\n \n         # Now delete the target item, suppress events and test again,\n         # The reference should be a ghost not in any folder anymore.\n-        # check if it has no acquition parent!\n+        # check if it has no acquisition parent!\n         self.portal._delObject(doc1a.id, suppress_events=True)\n         objs = [link.to_object for link in getOutgoingLinks(doc1)]\n         self.assertEqual(len(objs), 1)\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2023-04-04T01:34:46+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/96905e7b57b01d2c25df8b74a52f7931ca52739f

fix: adjust tests to zptlint

Files changed:
M plone/app/linkintegrity/tests/test_functional.py

b'diff --git a/plone/app/linkintegrity/tests/test_functional.py b/plone/app/linkintegrity/tests/test_functional.py\nindex 15221b7..93bedde 100644\n--- a/plone/app/linkintegrity/tests/test_functional.py\n+++ b/plone/app/linkintegrity/tests/test_functional.py\n@@ -14,6 +14,7 @@\n from zope.component import getMultiAdapter\n from zope.component import getUtility\n \n+import re\n import transaction\n import unittest\n \n@@ -416,6 +417,6 @@ def test_warn_about_content(self):\n             )\n         )\n         self.assertIn("Number of selected", self.browser.contents)\n-        self.assertIn("2 Objects in all", self.browser.contents)\n-        self.assertIn("1 Folders", self.browser.contents)\n-        self.assertIn("0 Published objects", self.browser.contents)\n+        self.assertTrue(re.search(r"2\\s+Objects in all", self.browser.contents))\n+        self.assertTrue(re.search(r"1\\s+Folders", self.browser.contents))\n+        self.assertTrue(re.search(r"0\\s+Published objects", self.browser.contents))\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2023-04-04T01:34:46+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/b7f70e3084b727593d52dedd72b592b90f4ee832

feat: declare dependencies

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex 87bcd6f..4cad1a6 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -47,12 +47,22 @@\n         "plone.app.relationfield",\n         "plone.base",\n         "plone.dexterity",\n+        "Products.GenericSetup",\n+        "Products.statusmessages",\n+        "plone.app.textfield",\n+        "plone.app.uuid",\n+        "plone.registry",\n+        "plone.uuid",\n+        "z3c.relationfield",\n+        "zc.relation",\n+        "zope.intid",\n+        "zope.keyreference",\n     ],\n     extras_require={\n         "test": [\n             "plone.app.testing",\n-            "plone.app.contenttypes",\n-            "plone.app.dexterity [relations]",  # related items in dx 2.0\n+            "plone.namedfile",\n+            "plone.testing",\n         ],\n     },\n     platforms="Any",\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2023-04-05T22:05:39+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/b43c69bc8e341917638c104b2235231a4ad34845

Merge pull request #89 from plone/config-with-default-template-56e7ccbd

Config with default template

Files changed:
A .editorconfig
A .meta.toml
A .pre-commit-config.yaml
A news/5623f8b3.internal
A tox.ini
M CHANGES.rst
M README.rst
M plone/__init__.py
M plone/app/__init__.py
M plone/app/linkintegrity/__init__.py
M plone/app/linkintegrity/browser/__init__.py
M plone/app/linkintegrity/browser/configure.zcml
M plone/app/linkintegrity/browser/delete_confirmation_info.pt
M plone/app/linkintegrity/browser/info.py
M plone/app/linkintegrity/browser/update.pt
M plone/app/linkintegrity/browser/update.py
M plone/app/linkintegrity/configure.zcml
M plone/app/linkintegrity/exceptions.py
M plone/app/linkintegrity/handlers.py
M plone/app/linkintegrity/interfaces.py
M plone/app/linkintegrity/profiles/default/metadata.xml
M plone/app/linkintegrity/retriever.py
M plone/app/linkintegrity/testing.py
M plone/app/linkintegrity/tests/__init__.py
M plone/app/linkintegrity/tests/test_circular.py
M plone/app/linkintegrity/tests/test_functional.py
M plone/app/linkintegrity/tests/test_handlers.py
M plone/app/linkintegrity/tests/test_imagescales.py
M plone/app/linkintegrity/tests/test_references.py
M plone/app/linkintegrity/utils.py
M pyproject.toml
M setup.cfg
M setup.py

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..4f67994\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "5623f8b3"\ndiff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nnew file mode 100644\nindex 0000000..449e951\n--- /dev/null\n+++ b/.pre-commit-config.yaml\n@@ -0,0 +1,42 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+ci:\n+    autofix_prs: false\n+    autoupdate_schedule: monthly\n+\n+repos:\n+-   repo: https://github.com/asottile/pyupgrade\n+    rev: v3.3.1\n+    hooks:\n+    -   id: pyupgrade\n+        args: [--py38-plus]\n+-   repo: https://github.com/pycqa/isort\n+    rev: 5.12.0\n+    hooks:\n+    -   id: isort\n+-   repo: https://github.com/psf/black\n+    rev: 23.1.0\n+    hooks:\n+    -   id: black\n+-   repo: https://github.com/collective/zpretty\n+    rev: 3.0.3\n+    hooks:\n+    -   id: zpretty\n+-   repo: https://github.com/PyCQA/flake8\n+    rev: 6.0.0\n+    hooks:\n+    -   id: flake8\n+-   repo: https://github.com/codespell-project/codespell\n+    rev: v2.2.2\n+    hooks:\n+    -   id: codespell\n+        additional_dependencies:\n+          - tomli\n+-   repo: https://github.com/mgedmin/check-manifest\n+    rev: "0.49"\n+    hooks:\n+    -   id: check-manifest\n+-   repo: https://github.com/regebro/pyroma\n+    rev: "4.2"\n+    hooks:\n+    -   id: pyroma\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex f210c91..c9bd11f 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -538,7 +538,7 @@ New:\n   for fields which have been added via schema extension.\n   [malthe]\n \n-- Support resolveuid/UID references explicitely, by parsing and resolving\n+- Support resolveuid/UID references explicitly, by parsing and resolving\n   these ourselves instead of relying on a view or script (which doesn\'t work).\n   This fixes linkintegrity for sites with link-by-uid turned on.\n   This closes https://dev.plone.org/ticket/12104\ndiff --git a/README.rst b/README.rst\nindex 5e7a348..e864749 100644\n--- a/README.rst\n+++ b/README.rst\n@@ -65,7 +65,7 @@ API\n ---\n \n To check if there would be breaches when deleting one or more objects\n-you can use the follwing code:\n+you can use the following code:\n \n .. code-block:: python\n \ndiff --git a/news/5623f8b3.internal b/news/5623f8b3.internal\nnew file mode 100644\nindex 0000000..c08f539\n--- /dev/null\n+++ b/news/5623f8b3.internal\n@@ -0,0 +1,2 @@\n+Update configuration files.\n+[plone devs]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 68c04af..5284146 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/linkintegrity/__init__.py b/plone/app/linkintegrity/__init__.py\nindex 40a96af..e69de29 100644\n--- a/plone/app/linkintegrity/__init__.py\n+++ b/plone/app/linkintegrity/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/linkintegrity/browser/__init__.py b/plone/app/linkintegrity/browser/__init__.py\nindex 40a96af..e69de29 100644\n--- a/plone/app/linkintegrity/browser/__init__.py\n+++ b/plone/app/linkintegrity/browser/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/linkintegrity/browser/configure.zcml b/plone/app/linkintegrity/browser/configure.zcml\nindex ffff903..7931e09 100644\n--- a/plone/app/linkintegrity/browser/configure.zcml\n+++ b/plone/app/linkintegrity/browser/configure.zcml\n@@ -1,20 +1,21 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    xmlns:browser="http://namespaces.zope.org/browser">\n+    xmlns:browser="http://namespaces.zope.org/browser"\n+    >\n \n   <browser:page\n-       for="*"\n-       name="delete_confirmation_info"\n-       class=".info.DeleteConfirmationInfo"\n-       permission="zope2.Public"\n-       />\n+      name="delete_confirmation_info"\n+      for="*"\n+      class=".info.DeleteConfirmationInfo"\n+      permission="zope2.Public"\n+      />\n \n   <browser:page\n-        name="updateLinkIntegrityInformation"\n-        for="plone.base.interfaces.IPloneSiteRoot"\n-        template="update.pt"\n-        class=".update.UpdateView"\n-        permission="cmf.ManagePortal"\n-        />\n+      name="updateLinkIntegrityInformation"\n+      for="plone.base.interfaces.IPloneSiteRoot"\n+      class=".update.UpdateView"\n+      template="update.pt"\n+      permission="cmf.ManagePortal"\n+      />\n \n </configure>\ndiff --git a/plone/app/linkintegrity/browser/delete_confirmation_info.pt b/plone/app/linkintegrity/browser/delete_confirmation_info.pt\nindex d2263f5..0b938c0 100644\n--- a/plone/app/linkintegrity/browser/delete_confirmation_info.pt\n+++ b/plone/app/linkintegrity/browser/delete_confirmation_info.pt\n@@ -1,86 +1,135 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"\n-    xmlns:tal="http://xml.zope.org/namespaces/tal"\n-    xmlns:metal="http://xml.zope.org/namespaces/metal"\n-    xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-    lang="en"\n-    i18n:domain="plone"\n-    tal:omit-tag="">\n-<body tal:omit-tag="" tal:define="breaches python:view.breaches">\n+<html xmlns="http://www.w3.org/1999/xhtml"\n+      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n+      xmlns:metal="http://xml.zope.org/namespaces/metal"\n+      xmlns:tal="http://xml.zope.org/namespaces/tal"\n+      lang="en"\n+      xml:lang="en"\n+      tal:omit-tag=""\n+      i18n:domain="plone"\n+>\n+  <body tal:define="\n+          breaches python:view.breaches;\n+        "\n+        tal:omit-tag=""\n+  >\n \n-  <h2 tal:condition="breaches" i18n:translate="linkintegrity_breaches_title">Potential link breakage</h2>\n+    <h2 tal:condition="breaches"\n+        i18n:translate="linkintegrity_breaches_title"\n+    >Potential link breakage</h2>\n \n-  <div id="content-core">\n+    <div id="content-core">\n \n-    <p tal:condition="breaches" i18n:translate="linkintegrity_instructions">\n+      <p tal:condition="breaches"\n+         i18n:translate="linkintegrity_instructions"\n+      >\n       By deleting this item, you will break links that exist in the items listed\n       below. If this is indeed what you want to do, we recommend that you remove\n       these references first.\n-    </p>\n+      </p>\n \n-    <div tal:define="token context/@@authenticator/token">\n-      <article tal:repeat="breach breaches" class="breach-container">\n+      <div tal:define="\n+             token context/@@authenticator/token;\n+           ">\n+        <article class="breach-container"\n+                 tal:repeat="breach breaches"\n+        >\n \n-        <tal:target  tal:define="target breach/target">\n-          <header><a href="${target/url}" tal:content="target/title" /></header>\n-          <p>\n-            <span i18n:translate="linkintegrity_is_referenced">\n-              This <span i18n:name="portal_type" tal:content="target/type_title" />\n+          <tal:target tal:define="\n+                        target breach/target;\n+                      ">\n+            <header><a href="${target/url}"\n+                 tal:content="target/title"\n+              ></a></header>\n+            <p>\n+              <span i18n:translate="linkintegrity_is_referenced">\n+              This\n+                <span tal:content="target/type_title"\n+                      i18n:name="portal_type"\n+                ></span>\n               is referenced by the following items:\n-            </span>\n-          </p>\n-        </tal:target>\n+              </span>\n+            </p>\n+          </tal:target>\n \n-        <ul>\n-          <li tal:repeat="source python:breach[\'sources\']" class="breach-item">\n-            <tal:visible condition="source/accessible">\n-              <a tal:attributes="href source/url" tal:content="source/title" />\n-              [<a\n-                  tal:attributes="href string:${source/url}/edit?_authenticator=${token}"\n-                  i18n:translate="linkintegrity_edit_in_new_window"\n-                  target="_blank">Edit in new window</a>]\n-            </tal:visible>\n-            <tal:private\n-                condition="not: source/accessible"\n-                i18n:translate="linkintegrity_item_not_accessible">\n+          <ul>\n+            <li class="breach-item"\n+                tal:repeat="source python:breach[\'sources\']"\n+            >\n+              <tal:visible condition="source/accessible">\n+                <a tal:content="source/title"\n+                   tal:attributes="\n+                     href source/url;\n+                   "\n+                ></a>\n+                [<a target="_blank"\n+                   tal:attributes="\n+                     href string:${source/url}/edit?_authenticator=${token};\n+                   "\n+                   i18n:translate="linkintegrity_edit_in_new_window"\n+                >Edit in new window</a>]\n+              </tal:visible>\n+              <tal:private condition="not: source/accessible"\n+                           i18n:translate="linkintegrity_item_not_accessible"\n+              >\n               The item is not accessible.\n-            </tal:private>\n-          </li>\n-        </ul>\n+              </tal:private>\n+            </li>\n+          </ul>\n \n-      </article>\n+        </article>\n \n-      <div tal:define="breach_count view/breach_count" tal:condition="breach_count">\n+        <div tal:define="\n+               breach_count view/breach_count;\n+             "\n+             tal:condition="breach_count"\n+        >\n \n-        <h2 i18n:translate="deleting_overview" >Deleting overview</h2>\n-        <p>\n-          <span tal:define="refs python:len(breach_count)"\n-              i18n:translate="selected_folders_with_content">\n-            Number of selected, non-empty folders: <strong><span tal:replace="refs" i18n:name="refs" /></strong>\n-          </span>\n-        </p>\n-        <ul>\n-          <li tal:repeat="content python:breach_count">\n-            <span i18n:translate="deleting_contents"> Following content within\n-              <strong><span tal:replace="content" i18n:name="content" /></strong>  will also be deleted:\n-            </span><br/>\n-            <ul>\n-              <li tal:define="objects view/objects"\n-                  tal:repeat="item python:range(3) ">\n-                <span tal:replace="python: breach_count[content][item]" /> <span tal:replace="python: objects[item]" />\n-              </li>\n-            </ul>\n-          </li>\n-        </ul>\n+          <h2 i18n:translate="deleting_overview">Deleting overview</h2>\n+          <p>\n+            <span tal:define="\n+                    refs python:len(breach_count);\n+                  "\n+                  i18n:translate="selected_folders_with_content"\n+            >\n+            Number of selected, non-empty folders:\n+              <strong><span tal:replace="refs"\n+                      i18n:name="refs"\n+                ></span></strong>\n+            </span>\n+          </p>\n+          <ul>\n+            <li tal:repeat="content python:breach_count">\n+              <span i18n:translate="deleting_contents">\n+                 Following content within\n+                <strong><span tal:replace="content"\n+                        i18n:name="content"\n+                  ></span></strong>\n+                  will also be deleted:\n+              </span><br />\n+              <ul>\n+                <li tal:define="\n+                      objects view/objects;\n+                    "\n+                    tal:repeat="item python:range(3) "\n+                >\n+                  <span tal:replace="python: breach_count[content][item]"></span>\n+                  <span tal:replace="python: objects[item]"></span>\n+                </li>\n+              </ul>\n+            </li>\n+          </ul>\n \n-      </div>\n+        </div>\n \n-      <p tal:condition="breaches" i18n:translate="linkintegrity_delete_anyway">\n+        <p tal:condition="breaches"\n+           i18n:translate="linkintegrity_delete_anyway"\n+        >\n         Would you like to delete it anyway?\n-      </p>\n+        </p>\n \n-    </div>\n+      </div>\n \n-  </div>\n+    </div>\n \n-</body>\n+  </body>\n </html>\ndiff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py\nindex e93f95c..d8c0af1 100644\n--- a/plone/app/linkintegrity/browser/info.py\n+++ b/plone/app/linkintegrity/browser/info.py\n@@ -1,17 +1,17 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from OFS.interfaces import IFolder\n from plone.app.linkintegrity.utils import getIncomingLinks\n from plone.app.linkintegrity.utils import linkintegrity_enabled\n+from plone.base import PloneMessageFactory as _\n+from plone.base.interfaces import IPloneSiteRoot\n from plone.uuid.interfaces import IUUID\n from Products.CMFCore.permissions import AccessContentsInformation\n from Products.CMFCore.utils import _checkPermission\n from Products.CMFCore.utils import getToolByName\n-from plone.base import PloneMessageFactory as _\n-from plone.base.interfaces import IPloneSiteRoot\n from Products.Five import BrowserView\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n from zope.i18n import translate\n+\n import logging\n \n \n@@ -19,8 +19,7 @@\n \n \n class DeleteConfirmationInfo(BrowserView):\n-\n-    template = ViewPageTemplateFile(\'delete_confirmation_info.pt\')\n+    template = ViewPageTemplateFile("delete_confirmation_info.pt")\n     breach_count = {}\n \n     def __init__(self, context, request):\n@@ -48,15 +47,15 @@ def get_breaches(self, items=None):\n         """\n         if items is None:\n             items = [self.context]\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n+        catalog = getToolByName(self.context, "portal_catalog")\n         results = []\n         uids_to_ignore = []\n         uids_visited = set()\n         self.breach_count = {}\n         for obj in items:\n-            obj_path = \'/\'.join(obj.getPhysicalPath())\n-            brains_to_delete = catalog(path={\'query\': obj_path})\n-            # add the current items uid and all its childrens uids to the\n+            obj_path = "/".join(obj.getPhysicalPath())\n+            brains_to_delete = catalog(path={"query": obj_path})\n+            # add the current items uid and all its children\'s uids to the\n             # list of uids that are ignored\n             uids_to_ignore.extend([i.UID for i in brains_to_delete])\n             for brain_to_delete in brains_to_delete:\n@@ -64,47 +63,40 @@ def get_breaches(self, items=None):\n                     obj_to_delete = brain_to_delete.getObject()  # noqa\n                 except (AttributeError, KeyError):\n                     logger.exception(\n-                        \'No object found for %s! Skipping\', brain_to_delete)\n+                        "No object found for %s! Skipping", brain_to_delete\n+                    )\n                     continue\n                 for breach in self.get_breaches_for_item(obj):\n                     add_breach = False\n-                    for source in breach[\'sources\']:\n+                    for source in breach["sources"]:\n                         # Only add the breach if one the sources is not in the\n                         # list of items that are to be deleted.\n-                        if source[\'uid\'] not in uids_to_ignore and \\\n-                           source[\'uid\'] not in uids_visited:\n+                        if (\n+                            source["uid"] not in uids_to_ignore\n+                            and source["uid"] not in uids_visited\n+                        ):\n                             add_breach = True\n-                            uids_visited.add(source[\'uid\'])\n+                            uids_visited.add(source["uid"])\n                             break\n                     if add_breach:\n                         results.append(breach)\n             if IFolder.providedBy(obj):\n-                count = len(catalog(\n-                    path={\'query\': obj_path}\n-                ))\n-                count_dirs = len(catalog(\n-                    path={\'query\': obj_path},\n-                    is_folderish=True\n-                ))\n-                count_public = len(catalog(\n-                    path={\'query\': obj_path},\n-                    review_state=\'published\'\n-                ))\n+                count = len(catalog(path={"query": obj_path}))\n+                count_dirs = len(catalog(path={"query": obj_path}, is_folderish=True))\n+                count_public = len(\n+                    catalog(path={"query": obj_path}, review_state="published")\n+                )\n                 if count:\n-                    self.breach_count[obj_path] = [\n-                        count,\n-                        count_dirs,\n-                        count_public\n-                    ]\n+                    self.breach_count[obj_path] = [count, count_dirs, count_public]\n \n         # Cleanup: Some breaches where added before it was known\n         # that their source will be deleted too.\n         for result in results:\n-            for source in result[\'sources\']:\n-                if source[\'uid\'] in uids_to_ignore:\n+            for source in result["sources"]:\n+                if source["uid"] in uids_to_ignore:\n                     # Drop sources that are also being deleted\n-                    result[\'sources\'].remove(source)\n-                    if not result[\'sources\']:\n+                    result["sources"].remove(source)\n+                    if not result["sources"]:\n                         # Remove the breach is there are no more sources\n                         # This check is necessary since there can be multiple\n                         # sources for a breach\n@@ -119,15 +111,15 @@ def get_breaches_for_item(self, obj=None):\n         if obj is None:\n             obj = self.context\n         results = []\n-        catalog = getToolByName(obj, \'portal_catalog\')\n-        obj_path = \'/\'.join(obj.getPhysicalPath())\n+        catalog = getToolByName(obj, "portal_catalog")\n+        obj_path = "/".join(obj.getPhysicalPath())\n \n         breaches = self.check_object(obj)\n         if breaches:\n             results.append(breaches)\n \n         if IFolder.providedBy(obj):\n-            brains = catalog(path={\'query\': obj_path})\n+            brains = catalog(path={"query": obj_path})\n             for brain in brains:\n                 try:\n                     child = brain.getObject()\n@@ -157,30 +149,31 @@ def check_object(self, obj, excluded_path=None):\n                 # source is in excluded_path\n                 continue\n             source = direct_link.from_object\n-            if not breaches.get(\'sources\'):\n-                breaches[\'sources\'] = []\n-            breaches[\'sources\'].append({\n-                \'uid\': IUUID(source),\n-                \'title\': source.Title(),\n-                \'url\': source.absolute_url(),\n-                \'accessible\': self.is_accessible(source),\n-            })\n+            if not breaches.get("sources"):\n+                breaches["sources"] = []\n+            breaches["sources"].append(\n+                {\n+                    "uid": IUUID(source),\n+                    "title": source.Title(),\n+                    "url": source.absolute_url(),\n+                    "accessible": self.is_accessible(source),\n+                }\n+            )\n             has_breaches = True\n         if has_breaches:\n-            breaches[\'target\'] = {\n-                \'uid\': IUUID(obj),\n-                \'title\': obj.Title(),\n-                \'url\': obj.absolute_url(),\n-                \'portal_type\': obj.portal_type,\n-                \'type_title\': self.get_portal_type_title(obj),\n+            breaches["target"] = {\n+                "uid": IUUID(obj),\n+                "title": obj.Title(),\n+                "url": obj.absolute_url(),\n+                "portal_type": obj.portal_type,\n+                "type_title": self.get_portal_type_title(obj),\n             }\n             return breaches\n \n     def get_portal_type_title(self, obj):\n-        """Get the portal type title of the object.\n-        """\n+        """Get the portal type title of the object."""\n         context = aq_inner(self.context)\n-        portal_types = getToolByName(context, \'portal_types\')\n+        portal_types = getToolByName(context, "portal_types")\n         fti = portal_types.get(obj.portal_type)\n         if fti is not None:\n             type_title_msgid = fti.Title()\n@@ -193,4 +186,4 @@ def is_accessible(self, obj):\n         return _checkPermission(AccessContentsInformation, obj)\n \n     def objects(self):\n-        return [_(\'Objects in all\'), _(\'Folders\'), _(\'Published objects\')]\n+        return [_("Objects in all"), _("Folders"), _("Published objects")]\ndiff --git a/plone/app/linkintegrity/browser/update.pt b/plone/app/linkintegrity/browser/update.pt\nindex 1c461b3..f099245 100644\n--- a/plone/app/linkintegrity/browser/update.pt\n+++ b/plone/app/linkintegrity/browser/update.pt\n@@ -1,39 +1,58 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"\n-    xmlns:tal="http://xml.zope.org/namespaces/tal"\n-    xmlns:metal="http://xml.zope.org/namespaces/metal"\n-    xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-    lang="en"\n-    metal:use-macro="here/main_template/macros/master"\n-    i18n:domain="plone"\n-    tal:omit-tag="">\n-\n-<head>\n-  <metal:block\n-      fill-slot="top_slot"\n-      tal:define="dummy python:request.set(\'disable_border\',1)" />\n-</head>\n-\n-<body>\n-<metal:main fill-slot="main">\n-\n-  <h1 class="documentFirstHeading"\n-      i18n:translate="linkintegrity_update_title">Update link integrity information</h1>\n-\n-  <div id="content-core">\n-\n-    <p i18n:translate="linkintegrity_update_instructions">\n+<html xmlns="http://www.w3.org/1999/xhtml"\n+      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n+      xmlns:metal="http://xml.zope.org/namespaces/metal"\n+      xmlns:tal="http://xml.zope.org/namespaces/tal"\n+      lang="en"\n+      metal:use-macro="here/main_template/macros/master"\n+      xml:lang="en"\n+      tal:omit-tag=""\n+      i18n:domain="plone"\n+>\n+\n+  <head>\n+    <metal:block fill-slot="top_slot"\n+                 tal:define="\n+                   dummy python:request.set(\'disable_border\',1);\n+                 "\n+    />\n+  </head>\n+\n+  <body>\n+    <metal:main fill-slot="main">\n+\n+      <h1 class="documentFirstHeading"\n+          i18n:translate="linkintegrity_update_title"\n+      >Update link integrity information</h1>\n+\n+      <div id="content-core">\n+\n+        <p i18n:translate="linkintegrity_update_instructions">\n       Clicking the below button will cause link integrity information to be\n       updated. This might take a while, especially for bigger sites...\n-    </p>\n-\n-    <form method="post" action="updateLinkIntegrityInformation"\n-        tal:attributes="action request/URL">\n-      <input class="destructive" type="submit" name="update" i18n:attributes="value" value="Update" />\n-      <input class="standalone" type="submit" name="cancel" i18n:attributes="value" value="Cancel" />\n-    </form>\n-\n-  </div>\n-\n-</metal:main>\n-</body>\n+        </p>\n+\n+        <form action="updateLinkIntegrityInformation"\n+              method="post"\n+              tal:attributes="\n+                action request/URL;\n+              "\n+        >\n+          <input class="destructive"\n+                 name="update"\n+                 type="submit"\n+                 value="Update"\n+                 i18n:attributes="value"\n+          />\n+          <input class="standalone"\n+                 name="cancel"\n+                 type="submit"\n+                 value="Cancel"\n+                 i18n:attributes="value"\n+          />\n+        </form>\n+\n+      </div>\n+\n+    </metal:main>\n+  </body>\n </html>\ndiff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py\nindex a31b1ef..4f51eb4 100644\n--- a/plone/app/linkintegrity/browser/update.py\n+++ b/plone/app/linkintegrity/browser/update.py\n@@ -1,66 +1,66 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from datetime import datetime\n from datetime import timedelta\n from plone.app.linkintegrity.handlers import modifiedContent\n-from Products.CMFCore.utils import getToolByName\n from plone.base import PloneMessageFactory as _\n+from Products.CMFCore.utils import getToolByName\n from Products.Five import BrowserView\n from Products.statusmessages.interfaces import IStatusMessage\n from transaction import savepoint\n from zExceptions import NotFound\n \n import logging\n+\n+\n logger = logging.getLogger(__name__)\n \n \n class UpdateView(BrowserView):\n-    """Iterate over all catalogued items and update linkintegrity-information.\n-    """\n+    """Iterate over all catalogued items and update linkintegrity-information."""\n \n     def __call__(self):\n         context = aq_inner(self.context)\n         request = aq_inner(self.request)\n-        if \'update\' in request.form or \'delete_all\' in request.form:\n+        if "update" in request.form or "delete_all" in request.form:\n             starttime = datetime.now()\n             count = self.update()\n             duration = timedelta(seconds=(datetime.now() - starttime).seconds)\n             msg = _(\n-                u\'linkintegrity_update_info\',\n-                default=u\'Link integrity information updated for ${count} \' +\n-                        u\'items in ${time} seconds.\',\n-                mapping={\'count\': count, \'time\': str(duration)},\n+                "linkintegrity_update_info",\n+                default="Link integrity information updated for ${count} "\n+                + "items in ${time} seconds.",\n+                mapping={"count": count, "time": str(duration)},\n             )\n-            IStatusMessage(request).add(msg, type=\'info\')\n-            msg = \'Updated {0} items in {1} seconds\'.format(\n+            IStatusMessage(request).add(msg, type="info")\n+            msg = "Updated {} items in {} seconds".format(\n                 count,\n                 str(duration),\n             )\n             logger.info(msg)\n-            request.RESPONSE.redirect(getToolByName(context, \'portal_url\')())\n-        elif \'cancel\' in request.form:\n-            msg = _(u\'Update cancelled.\')\n-            IStatusMessage(request).add(msg, type=\'info\')\n-            request.RESPONSE.redirect(getToolByName(context, \'portal_url\')())\n+            request.RESPONSE.redirect(getToolByName(context, "portal_url")())\n+        elif "cancel" in request.form:\n+            msg = _("Update cancelled.")\n+            IStatusMessage(request).add(msg, type="info")\n+            request.RESPONSE.redirect(getToolByName(context, "portal_url")())\n         else:\n             return self.index()\n \n     def update(self):\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n+        catalog = getToolByName(self.context, "portal_catalog")\n         count = 0\n \n         for brain in catalog():\n             try:\n                 obj = brain.getObject()\n             except (AttributeError, NotFound, KeyError):\n-                msg = \'Catalog inconsistency: {0} not found!\'\n+                msg = "Catalog inconsistency: {0} not found!"\n                 logger.error(msg.format(brain.getPath()), exc_info=1)\n                 continue\n             try:\n-                modifiedContent(obj, \'dummy event parameter\')\n+                modifiedContent(obj, "dummy event parameter")\n                 count += 1\n             except Exception:\n-                msg = \'Error updating linkintegrity-info for {0}.\'\n+                msg = "Error updating linkintegrity-info for {0}."\n                 logger.error(msg.format(obj.absolute_url()), exc_info=1)\n             if count % 1000 == 0:\n                 savepoint(optimistic=True)\ndiff --git a/plone/app/linkintegrity/configure.zcml b/plone/app/linkintegrity/configure.zcml\nindex ce1cd55..d11d5ef 100644\n--- a/plone/app/linkintegrity/configure.zcml\n+++ b/plone/app/linkintegrity/configure.zcml\n@@ -6,7 +6,10 @@\n \n   <include package="plone.app.intid" />\n   <include package="plone.app.relationfield" />\n-  <include package="Products.CMFCore" file="permissions.zcml" />\n+  <include\n+      package="Products.CMFCore"\n+      file="permissions.zcml"\n+      />\n \n   <include package=".browser" />\n \n@@ -14,25 +17,28 @@\n \n   <subscriber\n       for="plone.app.relationfield.interfaces.IDexterityHasRelations\n-            zope.lifecycleevent.interfaces.IObjectCopiedEvent"\n-      handler=".handlers.modifiedContent" />\n+           zope.lifecycleevent.interfaces.IObjectCopiedEvent"\n+      handler=".handlers.modifiedContent"\n+      />\n \n   <subscriber\n       for="plone.app.relationfield.interfaces.IDexterityHasRelations\n-            zope.lifecycleevent.interfaces.IObjectAddedEvent"\n-      handler=".handlers.modifiedContent" />\n+           zope.lifecycleevent.interfaces.IObjectAddedEvent"\n+      handler=".handlers.modifiedContent"\n+      />\n \n   <subscriber\n       for="plone.app.relationfield.interfaces.IDexterityHasRelations\n-            zope.lifecycleevent.interfaces.IObjectModifiedEvent"\n-      handler=".handlers.modifiedContent" />\n+           zope.lifecycleevent.interfaces.IObjectModifiedEvent"\n+      handler=".handlers.modifiedContent"\n+      />\n \n   <genericsetup:registerProfile\n       name="default"\n       title="plone.app.linkintegrity"\n-      directory="profiles/default"\n       description="Installs the plone.app.linkintegrity add-on."\n       provides="Products.GenericSetup.interfaces.EXTENSION"\n+      directory="profiles/default"\n       />\n \n </configure>\ndiff --git a/plone/app/linkintegrity/exceptions.py b/plone/app/linkintegrity/exceptions.py\nindex a0cf407..41afee0 100644\n--- a/plone/app/linkintegrity/exceptions.py\n+++ b/plone/app/linkintegrity/exceptions.py\n@@ -1,21 +1,18 @@\n-# -*- coding: utf-8 -*-\n from OFS.ObjectManager import BeforeDeleteException\n from zope.interface import implementer\n from zope.interface import Interface\n \n \n class ILinkIntegrityNotificationException(Interface):\n-    """An exception indicating a prevented link integrity breach.\n-    """\n+    """An exception indicating a prevented link integrity breach."""\n \n \n @implementer(ILinkIntegrityNotificationException)\n class LinkIntegrityNotificationException(BeforeDeleteException):\n-    """An exception indicating a prevented link integrity breach.\n-    """\n+    """An exception indicating a prevented link integrity breach."""\n \n     def __str__(self):\n         args = self.args\n         if args and isinstance(args, tuple):\n             return repr(args[0])\n-        return super(LinkIntegrityNotificationException, self).__str__()\n+        return super().__str__()\ndiff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py\nindex 5bcaaed..f9423b1 100644\n--- a/plone/app/linkintegrity/handlers.py\n+++ b/plone/app/linkintegrity/handlers.py\n@@ -4,11 +4,11 @@\n from plone.app.linkintegrity.utils import ensure_intid\n from plone.app.linkintegrity.utils import referencedRelationship\n from plone.app.uuid.utils import uuidToCatalogBrain\n+from plone.base.interfaces import IEditingSchema\n+from plone.base.interfaces import IPloneSiteRoot\n from plone.dexterity.interfaces import IDexterityContent\n from plone.registry.interfaces import IRegistry\n from Products.CMFCore.utils import getToolByName\n-from plone.base.interfaces import IEditingSchema\n-from plone.base.interfaces import IPloneSiteRoot\n from urllib.parse import unquote\n from urllib.parse import urlsplit\n from z3c.relationfield import RelationValue\n@@ -28,22 +28,22 @@\n \n \n def findObject(base, path):\n-    """ traverse to given path and find the upmost object """\n-    if path.startswith(\'/\'):\n+    """traverse to given path and find the upmost object"""\n+    if path.startswith("/"):\n         # Make an absolute path relative to the portal root\n-        obj = getToolByName(base, \'portal_url\').getPortalObject()\n-        portal_path = obj.absolute_url_path() + \'/\'\n+        obj = getToolByName(base, "portal_url").getPortalObject()\n+        portal_path = obj.absolute_url_path() + "/"\n         if path.startswith(portal_path):\n-            path = path[len(portal_path):]\n+            path = path[len(portal_path) :]\n     else:\n-        obj = aq_parent(base)   # relative urls start at the parent...\n+        obj = aq_parent(base)  # relative urls start at the parent...\n \n-    components = path.split(\'/\')\n+    components = path.split("/")\n \n-    # Support resolveuid/UID paths explicitely, without relying\n+    # Support resolveuid/UID paths explicitly, without relying\n     # on a view or skinscript to do this for us.\n-    if \'resolveuid\' in components:\n-        uid = components[components.index(\'resolveuid\') + 1]\n+    if "resolveuid" in components:\n+        uid = components[components.index("resolveuid") + 1]\n         # This may be a link to a page that once was published but not anymore,\n         # or the current editor does not have View permission.\n         # In that case uuidToObject(uid) could fail with Unauthorized.\n@@ -62,23 +62,23 @@ def findObject(base, path):\n             try:\n                 child = obj.unrestrictedTraverse(child_id)\n             except AttributeError:\n-                request = aq_get(obj, \'REQUEST\')\n+                request = aq_get(obj, "REQUEST")\n                 child = request.traverseName(obj, child_id)\n         except ConflictError:\n             raise\n-        except (AttributeError, KeyError,\n-                NotFound, ztkNotFound, UnicodeEncodeError):\n+        except (AttributeError, KeyError, NotFound, ztkNotFound, UnicodeEncodeError):\n             return None, None\n-        if not IDexterityContent.providedBy(child) and \\\n-                not IPloneSiteRoot.providedBy(child):\n+        if not IDexterityContent.providedBy(child) and not IPloneSiteRoot.providedBy(\n+            child\n+        ):\n             break\n         obj = child\n         components.pop(0)\n-    return obj, \'/\'.join(components)\n+    return obj, "/".join(components)\n \n \n def getObjectsFromLinks(base, links):\n-    """ determine actual objects refered to by given links """\n+    """determine actual objects referred to by given links"""\n     intids = getUtility(IIntIds)\n     objects = set()\n     url = base.absolute_url()\n@@ -128,9 +128,12 @@ def updateReferences(obj, refs):\n         return\n     catalog = getUtility(ICatalog)\n     # unpack the rels before deleting\n-    old_rels = [i for i in catalog.findRelations(\n-        {\'from_id\': int_id,\n-         \'from_attribute\': referencedRelationship})]\n+    old_rels = [\n+        i\n+        for i in catalog.findRelations(\n+            {"from_id": int_id, "from_attribute": referencedRelationship}\n+        )\n+    ]\n     for old_rel in old_rels:\n         catalog.unindex(old_rel)\n     for ref in refs:\n@@ -140,12 +143,12 @@ def updateReferences(obj, refs):\n def check_linkintegrity_dependencies(obj):\n     try:\n         reg = getUtility(IRegistry)\n-        editing_settings = reg.forInterface(IEditingSchema, prefix=\'plone\')\n+        editing_settings = reg.forInterface(IEditingSchema, prefix="plone")\n     except (ComponentLookupError, KeyError):\n         return False\n     if not editing_settings.enable_link_integrity_checks:\n         return False\n-    if not getToolByName(obj, \'portal_url\', None):\n+    if not getToolByName(obj, "portal_url", None):\n         # `getObjectFromLinks` is not possible without access\n         # to `portal_url`\n         return False\ndiff --git a/plone/app/linkintegrity/interfaces.py b/plone/app/linkintegrity/interfaces.py\nindex e7ee638..44287b0 100644\n--- a/plone/app/linkintegrity/interfaces.py\n+++ b/plone/app/linkintegrity/interfaces.py\n@@ -1,10 +1,8 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Interface\n \n \n class IRetriever(Interface):\n-    """A retriever for links in a content type.\n-    """\n+    """A retriever for links in a content type."""\n \n     def retrieveLinks():\n-        """ retrieve links """\n+        """retrieve links"""\ndiff --git a/plone/app/linkintegrity/profiles/default/metadata.xml b/plone/app/linkintegrity/profiles/default/metadata.xml\nindex 3d93a8e..ffe02eb 100644\n--- a/plone/app/linkintegrity/profiles/default/metadata.xml\n+++ b/plone/app/linkintegrity/profiles/default/metadata.xml\n@@ -1,4 +1,4 @@\n-<?xml version="1.0"?>\n+<?xml version="1.0" encoding="utf-8"?>\n <metadata>\n   <version>1000</version>\n   <dependencies>\ndiff --git a/plone/app/linkintegrity/retriever.py b/plone/app/linkintegrity/retriever.py\nindex 993a7a5..4e0ff95 100644\n--- a/plone/app/linkintegrity/retriever.py\n+++ b/plone/app/linkintegrity/retriever.py\n@@ -14,27 +14,26 @@\n \n @implementer(IRetriever)\n @adapter(IDexterityContent)\n-class DXGeneral(object):\n-    """General retriever for DX that extracts URLs from (rich) text fields.\n-    """\n+class DXGeneral:\n+    """General retriever for DX that extracts URLs from (rich) text fields."""\n \n     def __init__(self, context):\n         self.context = context\n \n     def retrieveLinks(self):\n-        """Finds all links from the object and return them.\n-        """\n+        """Finds all links from the object and return them."""\n         fti = getUtility(IDexterityFTI, name=self.context.portal_type)\n         schema = fti.lookupSchema()\n         additional_schema = getAdditionalSchemata(\n-            context=self.context, portal_type=self.context.portal_type)\n+            context=self.context, portal_type=self.context.portal_type\n+        )\n         schemas = [i for i in additional_schema] + [schema]\n         links = set()\n         for schema in schemas:\n             for name, field in getFieldsInOrder(schema):\n                 if isinstance(field, RichText):\n                     value = getattr(schema(self.context), name)\n-                    if not value or not getattr(value, \'raw\', None):\n+                    if not value or not getattr(value, "raw", None):\n                         continue\n                     links |= set(extractLinks(value.raw))\n         return links\ndiff --git a/plone/app/linkintegrity/testing.py b/plone/app/linkintegrity/testing.py\nindex 1239036..518541b 100644\n--- a/plone/app/linkintegrity/testing.py\n+++ b/plone/app/linkintegrity/testing.py\n@@ -14,10 +14,10 @@\n import io\n \n \n-B64_DATA = b\'R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=\'\n+B64_DATA = b"R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs="\n GIF = io.BytesIO(decodebytes(B64_DATA))\n-GIF.filename = \'sample.gif\'\n-GIF.contentType = \'image/gif\'\n+GIF.filename = "sample.gif"\n+GIF.contentType = "image/gif"\n GIF._width = 1\n GIF._height = 1\n \n@@ -32,56 +32,59 @@ def create(container, type_name, **kwargs):\n \n \n class LinkIntegrityLayer(PloneSandboxLayer):\n-    """Base Layer for Dexterity testing.\n-    """\n+    """Base Layer for Dexterity testing."""\n \n-    defaultBases = (PLONE_FIXTURE, )\n+    defaultBases = (PLONE_FIXTURE,)\n \n     def setUpZope(self, app, configurationContext):\n         import plone.app.linkintegrity\n \n-        xmlconfig.file(\'configure.zcml\', plone.app.linkintegrity,\n-                       context=configurationContext)\n+        xmlconfig.file(\n+            "configure.zcml", plone.app.linkintegrity, context=configurationContext\n+        )\n \n     def setUpPloneSite(self, portal):\n-        setRoles(portal, TEST_USER_ID, [\'Manager\', ])\n+        setRoles(\n+            portal,\n+            TEST_USER_ID,\n+            [\n+                "Manager",\n+            ],\n+        )\n         login(portal, TEST_USER_NAME)\n \n         # Create sample documents\n-        type_data = dict(type_name=\'Document\')\n+        type_data = dict(type_name="Document")\n         for i in range(1, 4):\n-            type_data[\'id\'] = \'doc{0:d}\'.format(i)\n-            type_data[\'title\'] = \'Test Page {0:d}\'.format(i)\n+            type_data["id"] = f"doc{i:d}"\n+            type_data["title"] = f"Test Page {i:d}"\n             create(portal, **type_data)\n \n-        create(portal, \'File\', id=\'file1\', title=\'File 1\', file=GIF)\n-        create(portal, \'Folder\', id=\'folder1\', title=\'Folder 1\')\n-        subfolder = portal[\'folder1\']\n-        create(subfolder, \'Document\', id=\'doc4\', title=\'Test Page 4\')\n+        create(portal, "File", id="file1", title="File 1", file=GIF)\n+        create(portal, "Folder", id="folder1", title="Folder 1")\n+        subfolder = portal["folder1"]\n+        create(subfolder, "Document", id="doc4", title="Test Page 4")\n \n         # setup members\n-        pm = getToolByName(portal, \'portal_membership\')\n-        pm.addMember(\'editor\', TEST_USER_PASSWORD, [\'Editor\'], [])\n-        pm.addMember(\'member\', TEST_USER_PASSWORD, [\'Member\'], [])\n-        pm.addMember(\'authenticated\', TEST_USER_PASSWORD, [], [])\n+        pm = getToolByName(portal, "portal_membership")\n+        pm.addMember("editor", TEST_USER_PASSWORD, ["Editor"], [])\n+        pm.addMember("member", TEST_USER_PASSWORD, ["Member"], [])\n+        pm.addMember("authenticated", TEST_USER_PASSWORD, [], [])\n \n         # Create an object that does not provide the behavior to live along\n-        create(portal, \'News Item\', id=\'news1\', title=\'News 1\')\n+        create(portal, "News Item", id="news1", title="News 1")\n \n         # create a NamedImage\n-        portal.invokeFactory(\'Image\', \'image1\')\n-        portal[\'image1\'].image = NamedImage(GIF, \'image/gif\',\n-                                            u\'sample.gif\')\n+        portal.invokeFactory("Image", "image1")\n+        portal["image1"].image = NamedImage(GIF, "image/gif", "sample.gif")\n \n \n PLONE_APP_LINKINTEGRITY_FIXTURE = LinkIntegrityLayer()\n \n PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING = layers.IntegrationTesting(\n-    bases=(PLONE_APP_LINKINTEGRITY_FIXTURE, ),\n-    name=\'plone.app.linkintegrity:Integration\'\n+    bases=(PLONE_APP_LINKINTEGRITY_FIXTURE,), name="plone.app.linkintegrity:Integration"\n )\n \n PLONE_APP_LINKINTEGRITY_FUNCTIONAL_TESTING = layers.FunctionalTesting(\n-    bases=(PLONE_APP_LINKINTEGRITY_FIXTURE, ),\n-    name=\'plone.app.linkintegrity:Functional\'\n+    bases=(PLONE_APP_LINKINTEGRITY_FIXTURE,), name="plone.app.linkintegrity:Functional"\n )\ndiff --git a/plone/app/linkintegrity/tests/__init__.py b/plone/app/linkintegrity/tests/__init__.py\nindex 336bbe1..dcdcd54 100644\n--- a/plone/app/linkintegrity/tests/__init__.py\n+++ b/plone/app/linkintegrity/tests/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n # tests package\n # to run all tests type \'.../bin/instance test -s plone.app.linkintegrity\'\n \n@@ -6,4 +5,4 @@\n import warnings\n \n \n-warnings.filterwarnings(\'ignore\', \'.*\', DeprecationWarning)\n+warnings.filterwarnings("ignore", ".*", DeprecationWarning)\ndiff --git a/plone/app/linkintegrity/tests/test_circular.py b/plone/app/linkintegrity/tests/test_circular.py\nindex b3a3c1f..807cc67 100644\n--- a/plone/app/linkintegrity/tests/test_circular.py\n+++ b/plone/app/linkintegrity/tests/test_circular.py\n@@ -16,17 +16,17 @@ class CircularReferencesTestCase(unittest.TestCase):\n     layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n \n     def _set_text(self, obj, text):\n         obj.text = RichTextValue(text)\n         modified(obj)\n \n     def test_circular_reference_manages_relations(self):\n-        doc1 = self.portal[\'doc1\']\n-        doc2 = self.portal[\'doc2\']\n-        doc3 = self.portal[\'doc3\']\n+        doc1 = self.portal["doc1"]\n+        doc2 = self.portal["doc2"]\n+        doc3 = self.portal["doc3"]\n         self.assertFalse(hasIncomingLinks(doc1))\n         self.assertFalse(hasIncomingLinks(doc2))\n         self.assertFalse(hasIncomingLinks(doc3))\n@@ -58,13 +58,12 @@ def test_circular_reference_subfolder_deletion(self):\n \n         view = DeleteConfirmationInfo(self.portal, self.request)\n         self.assertEqual(len(view.get_breaches([folder1])), 1)\n-        self.assertEqual(\n-            len(view.get_breaches([doc1, doc2, doc3, folder1])), 0)\n+        self.assertEqual(len(view.get_breaches([doc1, doc2, doc3, folder1])), 0)\n         self.assertEqual(len(view.get_breaches([doc2, folder1])), 2)\n \n     def test_internal_breaches_are_dropped(self):\n         folder1 = self.portal.folder1\n-        create(folder1, \'Document\', id=\'doc5\', title=\'Test Page 5\')\n+        create(folder1, "Document", id="doc5", title="Test Page 5")\n         doc1 = self.portal.doc1\n         doc4 = self.portal.folder1.doc4\n         doc5 = self.portal.folder1.doc5\n@@ -72,13 +71,11 @@ def test_internal_breaches_are_dropped(self):\n         set_text(doc4, \'<a href="doc5">d5</a><a href="../doc1">d1</a>\')\n         set_text(doc5, \'<a href="../folder1">f1</a>\')\n \n-        doc4_breaches = set([r.to_object for r in getOutgoingLinks(doc4)])\n+        doc4_breaches = {r.to_object for r in getOutgoingLinks(doc4)}\n         # the order of breaches is non-deterministic\n-        self.assertEqual(set([doc1, doc5]), doc4_breaches)\n-        self.assertEqual(\n-            [r.to_object for r in getOutgoingLinks(doc5)], [folder1])\n-        self.assertEqual(\n-            [r.to_object for r in getOutgoingLinks(doc1)], [folder1])\n+        self.assertEqual({doc1, doc5}, doc4_breaches)\n+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc5)], [folder1])\n+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [folder1])\n         view = DeleteConfirmationInfo(self.portal, self.request)\n         self.assertEqual(len(view.get_breaches([doc4])), 0)\n         self.assertEqual(len(view.get_breaches([doc5])), 1)\n@@ -87,11 +84,11 @@ def test_internal_breaches_are_dropped(self):\n         self.assertEqual(len(view.get_breaches([doc1])), 1)\n         self.assertEqual(len(view.get_breaches([doc1, folder1])), 0)\n \n-        view = folder1.restrictedTraverse(\'delete_confirmation\')\n-        self.assertIn(\'Potential link breakage\', view())\n-        view = folder1.restrictedTraverse(\'delete_confirmation_info\')\n-        self.assertIn(\'Potential link breakage\', view())\n-        view = doc4.restrictedTraverse(\'delete_confirmation\')\n-        self.assertNotIn(\'Potential link breakage\', view())\n-        view = doc4.restrictedTraverse(\'delete_confirmation_info\')\n-        self.assertNotIn(\'Potential link breakage\', view())\n+        view = folder1.restrictedTraverse("delete_confirmation")\n+        self.assertIn("Potential link breakage", view())\n+        view = folder1.restrictedTraverse("delete_confirmation_info")\n+        self.assertIn("Potential link breakage", view())\n+        view = doc4.restrictedTraverse("delete_confirmation")\n+        self.assertNotIn("Potential link breakage", view())\n+        view = doc4.restrictedTraverse("delete_confirmation_info")\n+        self.assertNotIn("Potential link breakage", view())\ndiff --git a/plone/app/linkintegrity/tests/test_functional.py b/plone/app/linkintegrity/tests/test_functional.py\nindex ac5cb83..93bedde 100644\n--- a/plone/app/linkintegrity/tests/test_functional.py\n+++ b/plone/app/linkintegrity/tests/test_functional.py\n@@ -7,13 +7,14 @@\n from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n from plone.app.testing import TEST_USER_PASSWORD\n+from plone.base.interfaces import IEditingSchema\n from plone.registry.interfaces import IRegistry\n from plone.testing.zope import Browser\n-from plone.base.interfaces import IEditingSchema\n from zc.relation.interfaces import ICatalog\n from zope.component import getMultiAdapter\n from zope.component import getUtility\n \n+import re\n import transaction\n import unittest\n \n@@ -24,76 +25,83 @@ class FunctionalReferenceTestCase(unittest.TestCase):\n     layer = testing.PLONE_APP_LINKINTEGRITY_FUNCTIONAL_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n         # alsoProvides(self.request, IFormLayer)\n \n         # Get a testbrowser\n-        self.browser = Browser(self.layer[\'app\'])\n+        self.browser = Browser(self.layer["app"])\n         self.browser.handleErrors = False\n-        self.browser.addHeader(\'Referer\', self.portal.absolute_url())\n+        self.browser.addHeader("Referer", self.portal.absolute_url())\n         self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic {0:s}:{1:s}\'.format(TEST_USER_NAME, TEST_USER_PASSWORD))\n+            "Authorization", f"Basic {TEST_USER_NAME:s}:{TEST_USER_PASSWORD:s}"\n+        )\n \n         # Do an initial page load to make sure the bundles get compiled\n         # (which currently commits a transaction)\n         # before we render exception views\n         self.browser.open(self.portal.absolute_url())\n \n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\', ])\n+        setRoles(\n+            self.portal,\n+            TEST_USER_ID,\n+            [\n+                "Manager",\n+            ],\n+        )\n \n     def _get_token(self, obj):\n-        return getMultiAdapter(\n-            (obj, self.request), name=\'authenticator\').token()\n+        return getMultiAdapter((obj, self.request), name="authenticator").token()\n \n-    @unittest.skip(\'Re-enable after https://github.com/plone/plone.app.content/issues/38\')  # noqa\n+    @unittest.skip(\n+        "Re-enable after https://github.com/plone/plone.app.content/issues/38"\n+    )  # noqa\n     def test_file_reference_linkintegrity_page_is_shown(self):\n         doc1 = self.portal.doc1\n-        file2 = testing.create(self.portal, \'File\',\n-                               id=\'file2\', file=testing.GIF)\n+        file2 = testing.create(self.portal, "File", id="file2", file=testing.GIF)\n \n         self.assertFalse(hasOutgoingLinks(doc1))\n         set_text(doc1, \'<a href="file2">A File</a>\')\n         self.assertTrue(hasOutgoingLinks(doc1))\n-        self.assertIn(\'file2\', self.portal.objectIds())\n+        self.assertIn("file2", self.portal.objectIds())\n \n         token = self._get_token(file2)\n-        self.request[\'_authenticator\'] = token\n+        self.request["_authenticator"] = token\n \n         # Make changes visible to test browser\n         transaction.commit()\n \n         self.browser.handleErrors = True\n         self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic {0:s}:{1:s}\'.format(TEST_USER_NAME, TEST_USER_PASSWORD))\n+            "Authorization", f"Basic {TEST_USER_NAME:s}:{TEST_USER_PASSWORD:s}"\n+        )\n \n-        delete_url = \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n-            file2.absolute_url(), token)\n+        delete_url = "{:s}/delete_confirmation?_authenticator={:s}".format(\n+            file2.absolute_url(), token\n+        )\n \n         # Try to remove but cancel\n         self.browser.open(delete_url)\n \n         # Validate text\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-                      self.browser.contents)\n-        self.assertIn(\'Would you like to delete it anyway?\',\n-                      self.browser.contents)\n+        self.assertIn("Potential link breakage", self.browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n+        )\n+        self.assertIn("Would you like to delete it anyway?", self.browser.contents)\n \n         # Click cancel button, item should stay in place\n         # FIXME! This fails in Plone 6 with an internal server error,\n         # but maybe no longer for the original reasons for which we skip this test.\n-        self.browser.getControl(name=\'form.buttons.Cancel\').click()\n-        self.assertEqual(self.browser.url, file2.absolute_url() + \'/view\')\n-        self.assertIn(\'Removal cancelled.\', self.browser.contents)\n-        self.assertIn(\'file2\', self.portal.objectIds())\n+        self.browser.getControl(name="form.buttons.Cancel").click()\n+        self.assertEqual(self.browser.url, file2.absolute_url() + "/view")\n+        self.assertIn("Removal cancelled.", self.browser.contents)\n+        self.assertIn("file2", self.portal.objectIds())\n \n         # Try to remove and confirm\n         self.browser.open(delete_url)\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'file2\', self.portal.objectIds())\n+        self.browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("file2", self.portal.objectIds())\n \n     def test_unreferenced_removal(self):\n         # This tests against #6666 and #7784, simple removal of a not\n@@ -101,14 +109,13 @@ def test_unreferenced_removal(self):\n \n         # We simply use a browser to try to delete a content item.\n         self.browser.open(self.portal.doc1.absolute_url())\n-        self.browser.getLink(\'Delete\').click()\n-        self.assertIn(\n-            \'Do you really want to delete this item?\', self.browser.contents)\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n+        self.browser.getLink("Delete").click()\n+        self.assertIn("Do you really want to delete this item?", self.browser.contents)\n+        self.browser.getControl(name="form.buttons.Delete").click()\n \n         # The resulting page should confirm the removal:\n-        self.assertIn(\'Test Page 1 has been deleted\', self.browser.contents)\n-        self.assertNotIn(\'doc1\', self.portal.objectIds())\n+        self.assertIn("Test Page 1 has been deleted", self.browser.contents)\n+        self.assertNotIn("doc1", self.portal.objectIds())\n \n     def test_renaming_referenced_item(self):\n         doc1 = self.portal.doc1\n@@ -118,38 +125,41 @@ def test_renaming_referenced_item(self):\n         # renamed (see the related bug report in #6608).  First we need\n         # to create the necessary links:\n         set_text(doc1, \'<a href="doc2">doc2</a>\')\n-        self.assertEqual(\n-            [i.from_object for i in getIncomingLinks(doc2)], [doc1])\n+        self.assertEqual([i.from_object for i in getIncomingLinks(doc2)], [doc1])\n \n         # Make changes visible to testbrowseropen\n         transaction.commit()\n \n         # Then we use a browser to rename the referenced image:\n         self.browser.handleErrors = True\n-        self.browser.open(\'{0:s}/object_rename?_authenticator={1:s}\'.format(\n-            doc1.absolute_url(), self._get_token(doc1)))\n+        self.browser.open(\n+            "{:s}/object_rename?_authenticator={:s}".format(\n+                doc1.absolute_url(), self._get_token(doc1)\n+            )\n+        )\n \n-        self.browser.getControl(name=\'form.widgets.new_id\').value = \'nuname\'\n-        self.browser.getControl(name=\'form.buttons.Rename\').click()\n+        self.browser.getControl(name="form.widgets.new_id").value = "nuname"\n+        self.browser.getControl(name="form.buttons.Rename").click()\n         self.assertIn("Renamed \'doc1\' to \'nuname\'.", self.browser.contents)\n         transaction.commit()\n \n-        self.assertNotIn(\'doc1\', self.portal.objectIds())\n-        self.assertIn(\'nuname\', self.portal.objectIds())\n+        self.assertNotIn("doc1", self.portal.objectIds())\n+        self.assertIn("nuname", self.portal.objectIds())\n         self.assertIn(doc1, [i.from_object for i in getIncomingLinks(doc2)])\n \n         # We simply use a browser to try to delete a content item.\n         self.browser.open(doc2.absolute_url())\n-        self.browser.getLink(\'Delete\').click()\n-        self.assertIn(\n-            \'Do you really want to delete this item?\', self.browser.contents)\n-        self.assertIn(\'nuname\', self.portal.objectIds())\n+        self.browser.getLink("Delete").click()\n+        self.assertIn("Do you really want to delete this item?", self.browser.contents)\n+        self.assertIn("nuname", self.portal.objectIds())\n         # Link breakabe page should be shown\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/nuname">Test Page 1</a>\',\n-                      self.browser.contents)\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'doc2\', self.portal.objectIds())\n+        self.assertIn("Potential link breakage", self.browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/nuname">Test Page 1</a>\',\n+            self.browser.contents,\n+        )\n+        self.browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("doc2", self.portal.objectIds())\n \n     def test_removal_in_subfolder(self):\n         doc1 = self.portal.doc1\n@@ -171,17 +181,19 @@ def test_removal_in_subfolder(self):\n         self.browser.handleErrors = True\n \n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 folder1.absolute_url(), self._get_token(folder1)\n             )\n         )\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-                      self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc2">Test Page 2</a>\',\n-                      self.browser.contents)\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'folder1\', self.portal.objectIds())\n+        self.assertIn("Potential link breakage", self.browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n+        )\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc2">Test Page 2</a>\', self.browser.contents\n+        )\n+        self.browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("folder1", self.portal.objectIds())\n \n     def test_removal_with_cookie_auth(self):\n         doc1 = self.portal.doc1\n@@ -192,33 +204,35 @@ def test_removal_with_cookie_auth(self):\n         set_text(doc1, \'<a href="doc2">doc2</a>\')\n         transaction.commit()\n \n-        browser = Browser(self.layer[\'app\'])\n+        browser = Browser(self.layer["app"])\n         browser.handleErrors = True\n-        browser.addHeader(\'Referer\', self.portal.absolute_url())\n-        browser.open(\n-            \'{0:s}/folder_contents\'.format(self.portal.absolute_url()))\n+        browser.addHeader("Referer", self.portal.absolute_url())\n+        browser.open(f"{self.portal.absolute_url():s}/folder_contents")\n \n         # At this point we shouldn\'t be able to look at the folder\n         # contents (as an anonymous user):\n-        self.assertIn(\'login?came_from\', browser.url)\n+        self.assertIn("login?came_from", browser.url)\n \n         # So we log in via the regular plone login form and additionally check\n         # that there is no \'authorization\' header set afterwards:\n-        browser.getControl(name=\'__ac_name\').value = TEST_USER_NAME\n-        browser.getControl(name=\'__ac_password\').value = TEST_USER_PASSWORD\n-        browser.getControl(\'Log in\').click()\n-        self.assertNotIn(\n-            \'authorization\', [h.lower() for h in browser.headers.keys()])\n+        browser.getControl(name="__ac_name").value = TEST_USER_NAME\n+        browser.getControl(name="__ac_password").value = TEST_USER_PASSWORD\n+        browser.getControl("Log in").click()\n+        self.assertNotIn("authorization", [h.lower() for h in browser.headers.keys()])\n \n         # This should lead us back to the "folder contents" listing,\n         # where we try to delete the referenced document.\n-        browser.open(\'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n-            doc2.absolute_url(), self._get_token(doc2)))\n-        self.assertIn(\'Potential link breakage\', browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-                      browser.contents)\n-        browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'doc2\', self.portal.objectIds())\n+        browser.open(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n+                doc2.absolute_url(), self._get_token(doc2)\n+            )\n+        )\n+        self.assertIn("Potential link breakage", browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', browser.contents\n+        )\n+        browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("doc2", self.portal.objectIds())\n \n     def test_linkintegrity_on_off_switch(self):\n         doc1 = self.portal.doc1\n@@ -235,22 +249,23 @@ def test_linkintegrity_on_off_switch(self):\n         self.browser.handleErrors = True\n \n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 doc2.absolute_url(), self._get_token(doc2)\n             )\n         )\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-                      self.browser.contents)\n+        self.assertIn("Potential link breakage", self.browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n+        )\n \n         # Now we turn the switch for link integrity checking off via the site\n         # properties and try again:\n         registry = getUtility(IRegistry)\n-        settings = registry.forInterface(IEditingSchema, prefix=\'plone\')\n+        settings = registry.forInterface(IEditingSchema, prefix="plone")\n         settings.enable_link_integrity_checks = False\n         transaction.commit()\n         self.browser.reload()\n-        self.assertNotIn(\'Potential link breakage\', self.browser.contents)\n+        self.assertNotIn("Potential link breakage", self.browser.contents)\n \n     def test_update(self):\n         doc1 = self.portal.doc1\n@@ -275,21 +290,25 @@ def test_update(self):\n         # An update of link integrity information for all content is triggered\n         # by browsing a specific url:\n         transaction.commit()\n-        self.browser.open(\'{0:s}/updateLinkIntegrityInformation\'.format(\n-            self.portal.absolute_url()))\n-        self.browser.getControl(\'Update\').click()\n-        self.assertIn(\'Link integrity information updated for\',\n-                      self.browser.contents)\n+        self.browser.open(\n+            f"{self.portal.absolute_url():s}/updateLinkIntegrityInformation"\n+        )\n+        self.browser.getControl("Update").click()\n+        self.assertIn("Link integrity information updated for", self.browser.contents)\n \n         # Now the linking documents should hold the correct link integrity\n         # references:\n         self.assertEqual(\n             [i.to_object for i in getOutgoingLinks(doc1)],\n-            [doc2, ],\n+            [\n+                doc2,\n+            ],\n         )\n         self.assertEqual(\n             [i.to_object for i in getOutgoingLinks(doc2)],\n-            [doc4, ],\n+            [\n+                doc4,\n+            ],\n         )\n \n     def test_references_on_cloned_objects(self):\n@@ -302,12 +321,12 @@ def test_references_on_cloned_objects(self):\n \n         # Next we clone the document:\n         token = self._get_token(doc1)\n-        self.request[\'_authenticator\'] = token\n-        doc1.restrictedTraverse(\'object_copy\')()\n+        self.request["_authenticator"] = token\n+        doc1.restrictedTraverse("object_copy")()\n \n-        self.request[\'_authenticator\'] = token\n-        self.portal.restrictedTraverse(\'object_paste\')()\n-        self.assertIn(\'copy_of_doc1\', self.portal)\n+        self.request["_authenticator"] = token\n+        self.portal.restrictedTraverse("object_paste")()\n+        self.assertIn("copy_of_doc1", self.portal)\n         transaction.commit()\n \n         # Then we try to delete the document linked by the original document\n@@ -318,20 +337,17 @@ def test_references_on_cloned_objects(self):\n         # Now we can continue and "click" the "delete" action. The confirmation\n         # page should list both documents:\n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 doc2.absolute_url(), self._get_token(doc2)\n             )\n         )\n+        self.assertIn("is referenced by the following items:", self.browser.contents)\n+        self.assertIn("Potential link breakage", self.browser.contents)\n         self.assertIn(\n-            \'is referenced by the following items:\', self.browser.contents)\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\n-            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-            self.browser.contents\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n         )\n         self.assertIn(\n-            \'<a href="http://nohost/plone/copy_of_doc1"\',\n-            self.browser.contents\n+            \'<a href="http://nohost/plone/copy_of_doc1"\', self.browser.contents\n         )\n \n     def test_files_with_spaces_removal(self):\n@@ -340,16 +356,16 @@ def test_files_with_spaces_removal(self):\n         # This tests the behaviour when removing a referenced file that has\n         # spaces in its id.  First we need to rename the existing file:\n         self.portal.invokeFactory(\n-            \'Document\', id=\'some spaces.doc\', title=\'A spaces doc\')\n+            "Document", id="some spaces.doc", title="A spaces doc"\n+        )\n \n-        self.assertIn(\'some spaces.doc\', self.portal.objectIds())\n-        spaces1 = self.portal[\'some spaces.doc\']\n+        self.assertIn("some spaces.doc", self.portal.objectIds())\n+        spaces1 = self.portal["some spaces.doc"]\n \n         set_text(doc1, \'<a href="some spaces.doc">a document</a>\')\n \n         # The document should now have a reference to the file:\n-        self.assertEqual(\n-            [i.to_object for i in getOutgoingLinks(doc1)], [spaces1])\n+        self.assertEqual([i.to_object for i in getOutgoingLinks(doc1)], [spaces1])\n         transaction.commit()\n \n         # Then we use a browser to try to delete the referenced file.\n@@ -358,17 +374,16 @@ def test_files_with_spaces_removal(self):\n         self.browser.handleErrors = True\n \n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 spaces1.absolute_url(), self._get_token(spaces1)\n             )\n         )\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n+        self.assertIn("Potential link breakage", self.browser.contents)\n         self.assertIn(\n-            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-            self.browser.contents\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n         )\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'some spaces.doc\', self.portal.objectIds())\n+        self.browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("some spaces.doc", self.portal.objectIds())\n \n     def test_removal_via_zmi(self):\n         """Delete via ZMI is no longer protedted!"""\n@@ -386,22 +401,22 @@ def test_removal_via_zmi(self):\n         # framework from choking on the exception we intentionally throw.\n         self.browser.handleErrors = True\n \n-        self.browser.open(\'http://nohost/plone/manage_main\')\n-        self.browser\\\n-            .getControl(name=\'ids:list\')\\\n-            .getControl(value=\'doc2\').selected = True\n+        self.browser.open("http://nohost/plone/manage_main")\n+        self.browser.getControl(name="ids:list").getControl(\n+            value="doc2"\n+        ).selected = True\n \n-        self.browser.getControl(\'Delete\').click()\n-        self.assertNotIn(\'doc2\', self.portal.objectIds())\n+        self.browser.getControl("Delete").click()\n+        self.assertNotIn("doc2", self.portal.objectIds())\n \n     def test_warn_about_content(self):\n         folder1 = self.portal.folder1\n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 folder1.absolute_url(), self._get_token(folder1)\n             )\n         )\n-        self.assertIn(\'Number of selected\', self.browser.contents)\n-        self.assertIn(\'2 Objects in all\', self.browser.contents)\n-        self.assertIn(\'1 Folders\', self.browser.contents)\n-        self.assertIn(\'0 Published objects\', self.browser.contents)\n+        self.assertIn("Number of selected", self.browser.contents)\n+        self.assertTrue(re.search(r"2\\s+Objects in all", self.browser.contents))\n+        self.assertTrue(re.search(r"1\\s+Folders", self.browser.contents))\n+        self.assertTrue(re.search(r"0\\s+Published objects", self.browser.contents))\ndiff --git a/plone/app/linkintegrity/tests/test_handlers.py b/plone/app/linkintegrity/tests/test_handlers.py\nindex acc020f..5b094ef 100644\n--- a/plone/app/linkintegrity/tests/test_handlers.py\n+++ b/plone/app/linkintegrity/tests/test_handlers.py\n@@ -7,42 +7,42 @@\n \n \n class ReferenceGenerationTestCase(unittest.TestCase):\n-    """ testing the handlers.findObject function """\n+    """testing the handlers.findObject function"""\n \n     layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def test_relative_to_portal_root_1(self):\n-        obj, components = findObject(self.portal.doc1, \'/plone/doc2\')\n-        self.assertEqual(obj.absolute_url_path(), \'/plone/doc2\')\n-        self.assertEqual(components, \'\')\n+        obj, components = findObject(self.portal.doc1, "/plone/doc2")\n+        self.assertEqual(obj.absolute_url_path(), "/plone/doc2")\n+        self.assertEqual(components, "")\n \n     def test_relative_to_portal_root_2(self):\n         # Prevent regression.\n         # See https://github.com/plone/plone.app.linkintegrity/pull/17\n-        obj, components = findObject(self.portal.doc1, \'/doc2\')\n-        self.assertEqual(obj.absolute_url_path(), \'/plone/doc2\')\n-        self.assertEqual(components, \'\')\n+        obj, components = findObject(self.portal.doc1, "/doc2")\n+        self.assertEqual(obj.absolute_url_path(), "/plone/doc2")\n+        self.assertEqual(components, "")\n \n     def test_webserver_rewrites_portal_name(self):\n         # test the case where a webserver rewrites the portal name,\n         # e.g. for Apache:\n         # RewriteRule ^/wssitename(.*)$ http://localhost:8080/VirtualHostBase/http/my.domain.com:80/plonesitename/VirtualHostRoot/_vh_wssitename$1  # noqa\n-        self.portal.REQUEST.other[\'VirtualRootPhysicalPath\'] = (\'\', \'plone\')\n-        self.portal.REQUEST._script = [\'plone_foo\']\n-        obj, components = findObject(self.portal.doc1, \'/plone_foo/doc2\')\n-        self.assertEqual(obj.absolute_url_path(), \'/plone_foo/doc2\')\n-        self.assertEqual(obj.getPhysicalPath(), (\'\', \'plone\', \'doc2\'))\n-        self.assertEqual(components, \'\')\n+        self.portal.REQUEST.other["VirtualRootPhysicalPath"] = ("", "plone")\n+        self.portal.REQUEST._script = ["plone_foo"]\n+        obj, components = findObject(self.portal.doc1, "/plone_foo/doc2")\n+        self.assertEqual(obj.absolute_url_path(), "/plone_foo/doc2")\n+        self.assertEqual(obj.getPhysicalPath(), ("", "plone", "doc2"))\n+        self.assertEqual(components, "")\n \n     def test_uuid_link(self):\n         # Test that objects can be found from uuid links.\n-        create(self.portal, \'Document\', id=\'target\', title=\'Target\')\n+        create(self.portal, "Document", id="target", title="Target")\n         target = self.portal.target\n         target_uid = target.UID()\n-        path = "../resolveuid/{}".format(target_uid)\n+        path = f"../resolveuid/{target_uid}"\n \n         # We logout.  This is to check that findObject also finds objects\n         # that are not visible to the current user, like a private page.\n@@ -50,5 +50,5 @@ def test_uuid_link(self):\n         logout()\n \n         obj, components = findObject(self.portal.doc1, path)\n-        self.assertEqual(obj.absolute_url_path(), \'/plone/target\')\n+        self.assertEqual(obj.absolute_url_path(), "/plone/target")\n         self.assertEqual(components, path)\ndiff --git a/plone/app/linkintegrity/tests/test_imagescales.py b/plone/app/linkintegrity/tests/test_imagescales.py\nindex 0ffc9cd..3661478 100644\n--- a/plone/app/linkintegrity/tests/test_imagescales.py\n+++ b/plone/app/linkintegrity/tests/test_imagescales.py\n@@ -13,7 +13,7 @@ class ImageReferenceTestCase(unittest.TestCase):\n     layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def test_image_tag_reference_creation(self):\n         doc1 = self.portal.doc1\n@@ -23,11 +23,13 @@ def test_image_tag_reference_creation(self):\n         # ensuring link integrity. Any archetype-based content object\n         # which refers to other (local) objects by `<img>` or `<a>` tags\n         # should create references between those objects on save.\n-        set_text(doc1, img1.restrictedTraverse(\'@@images\').tag())\n+        set_text(doc1, img1.restrictedTraverse("@@images").tag())\n \n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n-            [img1, ],\n+            [\n+                img1,\n+            ],\n         )\n         self.assertEqual([r.to_object for r in getIncomingLinks(doc1)], [])\n         self.assertEqual([r.to_object for r in getOutgoingLinks(img1)], [])\n@@ -41,15 +43,18 @@ def test_image_scale_reference_creation(self):\n         img1 = self.portal.image1\n \n         # Linking image scales should also work:\n-        set_text(\n-            doc1, \'<a href="image1/@@images/image_thumb">an image</a>\')\n+        set_text(doc1, \'<a href="image1/@@images/image_thumb">an image</a>\')\n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n-            [img1, ],\n+            [\n+                img1,\n+            ],\n         )\n         self.assertEqual(\n             [r.from_object for r in getIncomingLinks(img1)],\n-            [doc1, ],\n+            [\n+                doc1,\n+            ],\n         )\n \n     def test_image_resolveuid_reference_creation(self):\n@@ -57,13 +62,16 @@ def test_image_resolveuid_reference_creation(self):\n         img1 = self.portal.image1\n \n         # Linking via the "resolveuid/UID" method should also work:\n-        set_text(doc1, \'<a href="resolveuid/{0:s}">an image</a>\'.format(\n-            IUUID(img1)))\n+        set_text(doc1, f\'<a href="resolveuid/{IUUID(img1):s}">an image</a>\')\n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n-            [img1, ],\n+            [\n+                img1,\n+            ],\n         )\n         self.assertEqual(\n             [r.from_object for r in getIncomingLinks(img1)],\n-            [doc1, ],\n+            [\n+                doc1,\n+            ],\n         )\ndiff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py\nindex 55b0faf..41aecdf 100644\n--- a/plone/app/linkintegrity/tests/test_references.py\n+++ b/plone/app/linkintegrity/tests/test_references.py\n@@ -13,8 +13,8 @@\n from z3c.relationfield.event import _setRelation\n from zc.relation.interfaces import ICatalog\n from zope.component import getUtility\n-from zope.lifecycleevent import modified\n from zope.intid.interfaces import IIntIds\n+from zope.lifecycleevent import modified\n \n import unittest\n \n@@ -25,19 +25,19 @@ class ReferenceGenerationTestCase(unittest.TestCase):\n     layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def _set_related_items(self, obj, items):\n         assert IRelatedItems.providedBy(obj)\n-        setattr(obj, \'relatedItems\', items)\n+        setattr(obj, "relatedItems", items)\n         modified(obj)\n \n     def _get_related_items(self, obj):\n         return obj.relatedItems\n \n     def test_is_linked(self):\n-        img1 = self.portal[\'image1\']\n-        doc1 = self.portal[\'doc1\']\n+        img1 = self.portal["image1"]\n+        doc1 = self.portal["doc1"]\n         set_text(doc1, \'<img src="image1"></img>\')\n         self.assertTrue(hasIncomingLinks(img1))\n \n@@ -52,27 +52,28 @@ def test_referal_to_private_files(self):\n         img = self.portal.image1\n         set_text(doc, \'<a href="image1">Image 1</a>\')\n \n-        roles = (\'Member\', )\n-        self.portal.manage_permission(\'List folder contents\', roles=roles)\n-        self.portal.manage_permission(\'Delete objects\', roles=roles)\n-        doc.manage_permission(\'View\', roles=(\'Manager\',), acquire=0)\n-        doc.manage_permission(\'Access contents information\',\n-                              roles=(\'Manager\', ), acquire=0)\n+        roles = ("Member",)\n+        self.portal.manage_permission("List folder contents", roles=roles)\n+        self.portal.manage_permission("Delete objects", roles=roles)\n+        doc.manage_permission("View", roles=("Manager",), acquire=0)\n+        doc.manage_permission(\n+            "Access contents information", roles=("Manager",), acquire=0\n+        )\n \n         logout()\n-        login(self.portal, \'member\')\n+        login(self.portal, "member")\n         checkPermission = self.portal.portal_membership.checkPermission\n-        self.assertFalse(checkPermission(\'View\', doc))\n-        self.assertFalse(checkPermission(\'Access contents information\', doc))\n-        self.assertTrue(checkPermission(\'View\', img))\n-        self.assertTrue(checkPermission(\'Access contents information\', img))\n+        self.assertFalse(checkPermission("View", doc))\n+        self.assertFalse(checkPermission("Access contents information", doc))\n+        self.assertTrue(checkPermission("View", img))\n+        self.assertTrue(checkPermission("Access contents information", img))\n \n         # The warning is shown.\n         self.assertTrue(hasOutgoingLinks(doc))\n-        view = img.restrictedTraverse(\'delete_confirmation\')\n+        view = img.restrictedTraverse("delete_confirmation")\n         results = view()\n-        self.assertIn(\'Potential link breakage\', results)\n-        self.assertIn(\'The item is not accessible.\', results)\n+        self.assertIn("Potential link breakage", results)\n+        self.assertIn("The item is not accessible.", results)\n \n         # delete linked item and check if the source still has the relation\n \n@@ -97,39 +98,34 @@ def test_referal_to_private_files(self):\n     def test_link_extraction_easy(self):\n         doc1 = self.portal.doc1\n         set_text(doc1, \'<a href="doc2">Doc 2</a>\')\n-        self.assertEqual(\n-            extractLinks(doc1.text.raw),\n-            (\'doc2\', )\n-        )\n+        self.assertEqual(extractLinks(doc1.text.raw), ("doc2",))\n \n     def test_link_extraction_more_complex(self):\n         doc2 = self.portal.doc2\n         set_text(\n             doc2,\n-            \'<a href="doc1">Doc 2</a>\' +\n-            \'<a href="folder1/doc3"><img src="image1" /></a>\',\n+            \'<a href="doc1">Doc 2</a>\'\n+            + \'<a href="folder1/doc3"><img src="image1" /></a>\',\n         )\n         self.assertEqual(\n-            extractLinks(doc2.text.raw),\n-            (\'doc1\',\n-             \'folder1/doc3\',\n-             \'image1\')\n+            extractLinks(doc2.text.raw), ("doc1", "folder1/doc3", "image1")\n         )\n \n     def test_broken_references(self):\n         # create a temporary document to test with\n-        doc1a = testing.create(self.portal, \'Document\', id=\'doc1a\')\n+        doc1a = testing.create(self.portal, "Document", id="doc1a")\n         doc1 = self.portal.doc1\n \n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)\n         set_text(doc1, \'<a href="doc1a">Doc 1a</a>\')\n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 1)\n-        self.assertEqual([link.to_object for link in getOutgoingLinks(doc1)],\n-                         [self.portal.doc1a])\n+        self.assertEqual(\n+            [link.to_object for link in getOutgoingLinks(doc1)], [self.portal.doc1a]\n+        )\n \n         # Now delete the target item, suppress events and test again,\n         # The reference should be a ghost not in any folder anymore.\n-        # check if it has no acquition parent!\n+        # check if it has no acquisition parent!\n         self.portal._delObject(doc1a.id, suppress_events=True)\n         objs = [link.to_object for link in getOutgoingLinks(doc1)]\n         self.assertEqual(len(objs), 1)\n@@ -137,17 +133,16 @@ def test_broken_references(self):\n         if obj is not None:\n             # Plone with fixed five.intid\n             # if object is None: all fine as well.\n-            self.assertEqual(obj.portal_type, \'Document\')\n+            self.assertEqual(obj.portal_type, "Document")\n             _marker = dict()\n-            self.assertEqual(getattr(obj, \'aq_parent\', _marker), _marker)\n+            self.assertEqual(getattr(obj, "aq_parent", _marker), _marker)\n \n     def test_relative_upwards_link_generates_matching_reference(self):\n         doc1 = self.portal.doc1\n         doc3 = self.portal.folder1.doc3\n         set_text(doc3, \'<a href="../doc1">go!</a>\')\n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)\n-        self.assertEqual([link.to_object for link in getOutgoingLinks(doc3)],\n-                         [doc1])\n+        self.assertEqual([link.to_object for link in getOutgoingLinks(doc3)], [doc1])\n \n     def test_unicode_links(self):\n         doc1 = self.portal.doc1\n@@ -156,16 +151,14 @@ def test_unicode_links(self):\n         # eventually plays well with transaction machinery.\n         # Add bad link, should not raise exception and there should not\n         # be any references added.\n-        set_text(\n-            doc1,\n-            \'<a href="\xc3\xb6?foo=bar&baz=bam">bug</a>\')\n+        set_text(doc1, \'<a href="\xc3\xb6?foo=bar&baz=bam">bug</a>\')\n \n         self.assertEqual([link for link in getOutgoingLinks(doc1)], [])\n \n     def test_reference_orthogonality(self):\n         doc = self.portal.doc1\n         img = self.portal.image1\n-        tag = img.restrictedTraverse(\'@@images\').tag()\n+        tag = img.restrictedTraverse("@@images").tag()\n \n         # This tests the behavior when other references already exist.\n         self.assertEqual([link for link in getOutgoingLinks(doc)], [])\n@@ -175,8 +168,18 @@ def test_reference_orthogonality(self):\n \n         # Then establish a reference between the document and image as\n         # a related item:\n-        self._set_related_items(doc, [img, ])\n-        self.assertEqual(self._get_related_items(doc), [img, ])\n+        self._set_related_items(\n+            doc,\n+            [\n+                img,\n+            ],\n+        )\n+        self.assertEqual(\n+            self._get_related_items(doc),\n+            [\n+                img,\n+            ],\n+        )\n \n         # Next edit the document body and insert a link to the image,\n         # which should trigger the creation of a link integrity reference:\n@@ -185,37 +188,47 @@ def test_reference_orthogonality(self):\n         self.assertEqual([link.to_object for link in getOutgoingLinks(doc)], [img])\n \n         # And the related item reference remains in place:\n-        self.assertEqual(self._get_related_items(doc), [img, ])\n+        self.assertEqual(\n+            self._get_related_items(doc),\n+            [\n+                img,\n+            ],\n+        )\n \n         # Finally, edit the document body again, this time removing the\n         # link to the image, which should trigger the removal of the\n         # link integrity reference:\n-        set_text(doc, \'where did my link go?\')\n+        set_text(doc, "where did my link go?")\n         self.assertEqual([link.to_object for link in getOutgoingLinks(doc)], [])\n \n         # And again the related item reference remains in place:\n-        self.assertEqual(self._get_related_items(doc), [img, ])\n+        self.assertEqual(\n+            self._get_related_items(doc),\n+            [\n+                img,\n+            ],\n+        )\n \n     def test_delete_confirmation_for_any_reference(self):\n         """Test, if delete confirmation shows also a warning if items are\n         deleted, which are referenced by other items via a reference field.\n         """\n-        img1 = self.portal[\'image1\']\n-        doc1 = self.portal[\'doc1\']\n+        img1 = self.portal["image1"]\n+        doc1 = self.portal["doc1"]\n \n         intids_tool = getUtility(IIntIds)\n         to_id = intids_tool.getId(img1)\n         rel = RelationValue(to_id)\n-        _setRelation(doc1, \'related_image\', rel)\n+        _setRelation(doc1, "related_image", rel)\n \n         # Test, if relation is present in the relation catalog\n         catalog = getUtility(ICatalog)\n-        rels = list(catalog.findRelations({\'to_id\': to_id}))\n+        rels = list(catalog.findRelations({"to_id": to_id}))\n         self.assertEqual(len(rels), 1)\n \n         # Test, if delete_confirmation_info shows also other relations than\n         # ``isReferencing``.\n-        info = img1.restrictedTraverse(\'@@delete_confirmation_info\')\n+        info = img1.restrictedTraverse("@@delete_confirmation_info")\n         breaches = info.get_breaches()\n         self.assertEqual(len(breaches), 1)\n-        self.assertEqual(len(info.get_breaches()[0][\'sources\']), 1)\n+        self.assertEqual(len(info.get_breaches()[0]["sources"]), 1)\ndiff --git a/plone/app/linkintegrity/utils.py b/plone/app/linkintegrity/utils.py\nindex 629350b..5990bdd 100644\n--- a/plone/app/linkintegrity/utils.py\n+++ b/plone/app/linkintegrity/utils.py\n@@ -1,27 +1,23 @@\n-# -*- coding: utf-8 -*-\n-from plone.registry.interfaces import IRegistry\n from plone.base.interfaces import IEditingSchema\n+from plone.registry.interfaces import IRegistry\n from zc.relation.interfaces import ICatalog\n from zope.component import getUtility\n from zope.intid.interfaces import IIntIds\n from zope.keyreference.interfaces import NotYet\n \n-referencedRelationship = \'isReferencing\'\n+\n+referencedRelationship = "isReferencing"\n \n \n-def getIncomingLinks(\n-    obj=None,\n-    intid=None,\n-    from_attribute=referencedRelationship\n-):\n+def getIncomingLinks(obj=None, intid=None, from_attribute=referencedRelationship):\n     """Return a generator of incoming relations created using\n     plone.app.linkintegrity (Links in Richtext-Fields).\n     """\n     catalog = getUtility(ICatalog)\n     intid = intid if intid is not None else getUtility(IIntIds).getId(obj)\n-    query = {\'to_id\': intid}\n+    query = {"to_id": intid}\n     if from_attribute:\n-        query[\'from_attribute\'] = from_attribute\n+        query["from_attribute"] = from_attribute\n     return catalog.findRelations(query)\n \n \n@@ -36,19 +32,15 @@ def hasIncomingLinks(obj=None, intid=None):\n     return False\n \n \n-def getOutgoingLinks(\n-    obj=None,\n-    intid=None,\n-    from_attribute=referencedRelationship\n-):\n+def getOutgoingLinks(obj=None, intid=None, from_attribute=referencedRelationship):\n     """Return a generator of outgoing relations created using\n     plone.app.linkintegrity (Links in Richtext-Fields).\n     """\n     catalog = getUtility(ICatalog)\n     intid = intid if intid is not None else getUtility(IIntIds).getId(obj)\n-    query = {\'from_id\': intid}\n+    query = {"from_id": intid}\n     if from_attribute:\n-        query[\'from_attribute\'] = from_attribute\n+        query["from_attribute"] = from_attribute\n     return catalog.findRelations(query)\n \n \n@@ -63,7 +55,7 @@ def hasOutgoingLinks(obj=None, intid=None):\n \n def linkintegrity_enabled():\n     reg = getUtility(IRegistry)\n-    editing_settings = reg.forInterface(IEditingSchema, prefix=\'plone\')\n+    editing_settings = reg.forInterface(IEditingSchema, prefix="plone")\n     return editing_settings.enable_link_integrity_checks\n \n \ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..9eb73f3 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,43 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "internal"\n+name = "Internal:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "documentation"\n+name = "Documentation:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "tests"\n+name = "Tests"\n+showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\n+\n+[tool.dependencychecker]\n+Zope = [\n+  # Zope own provided namespaces\n+  \'App\', \'OFS\', \'Products.Five\', \'Products.OFSP\', \'Products.PageTemplates\',\n+  \'Products.SiteAccess\', \'Shared\', \'Testing\', \'ZPublisher\', \'ZTUtils\',\n+  \'Zope2\', \'webdav\', \'zmi\',\n+  # Zope dependencies\n+  \'Acquisition\', \'DateTime\', \'transaction\', \'zExceptions\', \'ZODB\', \'zope.component\',\n+  \'zope.configuration\', \'zope.container\', \'zope.deferredimport\', \'zope.event\',\n+  \'zope.exceptions\', \'zope.globalrequest\', \'zope.i18n\', \'zope.i18nmessageid\',\n+  \'zope.interface\', \'zope.lifecycleevent\', \'zope.location\', \'zope.publisher\',\n+  \'zope.schema\', \'zope.security\', \'zope.site\', \'zope.traversing\', \'AccessControl\',\n+]\n+\'plone.base\' = [\n+  \'AccessControl\', \'Products.BTreeFolder2\', \'Products.CMFCore\',\n+  \'Products.CMFDynamicViewFTI\', \'zope.deprecation\',\n+]\n+python-dateutil = [\'dateutil\']\ndiff --git a/setup.cfg b/setup.cfg\nindex c01f844..0da8f8f 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,5 +1,23 @@\n-[zest.releaser]\n-extra-message = [ci skip]\n-\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [bdist_wheel]\n-universal = 1\n+universal = 0\n+\n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n+\n+[check-manifest]\n+ignore =\n+    .editorconfig\n+    .meta.toml\n+    .pre-commit-config.yaml\n+    tox.ini\ndiff --git a/setup.py b/setup.py\nindex e1ada7a..4cad1a6 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,18 +1,19 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n \n-version = \'4.0.1.dev0\'\n+version = "4.0.1.dev0"\n \n setup(\n-    name=\'plone.app.linkintegrity\',\n+    name="plone.app.linkintegrity",\n     version=version,\n-    description=\'Manage link integrity in Plone.\',\n-    long_description=\'\\n\\n\'.join([\n-        open("README.rst").read(),\n-        open(\'CHANGES.rst\').read(),\n-    ]),\n+    description="Manage link integrity in Plone.",\n+    long_description="\\n\\n".join(\n+        [\n+            open("README.rst").read(),\n+            open("CHANGES.rst").read(),\n+        ]\n+    ),\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Environment :: Web Environment",\n@@ -31,33 +32,43 @@\n         "Programming Language :: Python :: 3.11",\n         "Topic :: Internet :: WWW/HTTP :: Site Management :: Link Checking",\n     ],\n-    keywords=\'link integrity plone\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://github.com/plone/plone.app.linkintegrity\',\n-    license=\'GPL version 2\',\n+    keywords="link integrity plone",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://github.com/plone/plone.app.linkintegrity",\n+    license="GPL version 2",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\', \'plone.app\'],\n+    namespace_packages=["plone", "plone.app"],\n     include_package_data=True,\n-    python_requires=\'>=3.8\',\n+    python_requires=">=3.8",\n     install_requires=[\n-        \'setuptools\',\n-        \'plone.app.intid\',\n-        \'plone.app.relationfield\',\n-        \'plone.base\',\n-        \'plone.dexterity\',\n+        "setuptools",\n+        "plone.app.intid",\n+        "plone.app.relationfield",\n+        "plone.base",\n+        "plone.dexterity",\n+        "Products.GenericSetup",\n+        "Products.statusmessages",\n+        "plone.app.textfield",\n+        "plone.app.uuid",\n+        "plone.registry",\n+        "plone.uuid",\n+        "z3c.relationfield",\n+        "zc.relation",\n+        "zope.intid",\n+        "zope.keyreference",\n     ],\n     extras_require={\n-        \'test\': [\n-            \'plone.app.testing\',\n-            \'plone.app.contenttypes\',\n-            \'plone.app.dexterity [relations]\',  # related items in dx 2.0\n+        "test": [\n+            "plone.app.testing",\n+            "plone.namedfile",\n+            "plone.testing",\n         ],\n     },\n-    platforms=\'Any\',\n+    platforms="Any",\n     zip_safe=False,\n-    entry_points=\'\'\'\n+    entry_points="""\n     [z3c.autoinclude.plugin]\n     target = plone\n-    \'\'\',\n+    """,\n )\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..7e161fd\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,54 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[tox]\n+# We need 4.4.0 for constrain_package_deps.\n+min_version = 4.4.0\n+envlist =\n+    format\n+    lint\n+    test\n+\n+[testenv]\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat code\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a pyupgrade\n+    pre-commit run -a isort\n+    pre-commit run -a black\n+    pre-commit run -a zpretty\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a\n+\n+[testenv:dependencies]\n+description = check if the package defines all its dependencies and generate a graph out of them\n+deps =\n+    z3c.dependencychecker==2.11\n+    pipdeptree==2.5.1\n+    graphviz  # optional dependency of pipdeptree\n+commands =\n+    dependencychecker\n+    sh -c \'pipdeptree --exclude setuptools,wheel,pipdeptree,z3c.dependencychecker,zope.interface,zope.component --graph-output svg > dependencies.svg\'\n+\n+[testenv:test]\n+usedevelop = true\n+constrain_package_deps = true\n+set_env = ROBOT_BROWSER=headlesschrome\n+deps =\n+    zope.testrunner\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    zope-testrunner --all --test-path={toxinidir} -s plone.app.linkintegrity {posargs}\n+extras =\n+    test\n'

