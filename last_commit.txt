Repository: plone.app.event


Branch: refs/heads/master
Date: 2022-05-04T22:13:15+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.event/commit/c642ebfd18f8f7c1f321c994882e57ef97639e30

isort

Files changed:
M docs/conf.py
M plone/app/event/__init__.py
M plone/app/event/browser/event_listing.py
M plone/app/event/dx/traverser.py
M plone/app/event/portlets/portlet_calendar.py
M plone/app/event/testing.py
M plone/app/event/tests/INACTIVE_test_robot.py
M plone/app/event/tests/base_setup.py
M plone/app/event/tests/robot/variables.py
M plone/app/event/tests/test_base_module.py
M plone/app/event/tests/test_dx_behaviors.py
M plone/app/event/tests/test_event_listing.py
M plone/app/event/tests/test_event_summary.py
M plone/app/event/tests/test_event_view.py
M plone/app/event/tests/test_ical_import.py
M plone/app/event/tests/test_recurrence.py
M plone/app/event/tests/test_search.py
M plone/app/event/upgrades/upgrades.py
M setup.cfg

b'diff --git a/docs/conf.py b/docs/conf.py\nindex 6d4ab972f..b8e8a666b 100644\n--- a/docs/conf.py\n+++ b/docs/conf.py\n@@ -15,4 +15,6 @@\n language = \'en\'\n \n from pkg_resources import get_distribution\n+\n+\n version = release = get_distribution(project).version\ndiff --git a/plone/app/event/__init__.py b/plone/app/event/__init__.py\nindex aa11903e4..361647926 100644\n--- a/plone/app/event/__init__.py\n+++ b/plone/app/event/__init__.py\n@@ -2,6 +2,7 @@\n from AccessControl.Permission import addPermission\n from zope.i18nmessageid import MessageFactory\n \n+\n packageName = __name__\n _ = MessageFactory(\'plone\')\n \ndiff --git a/plone/app/event/browser/event_listing.py b/plone/app/event/browser/event_listing.py\nindex 5aa1b8265..e50000c76 100644\n--- a/plone/app/event/browser/event_listing.py\n+++ b/plone/app/event/browser/event_listing.py\n@@ -27,10 +27,14 @@\n     from Products.CMFPlone.defaultpage import get_default_page\n except ImportError:\n     # Plone 4\n-    from plone.app.layout.navigation.defaultpage import getDefaultPage as get_default_page  # noqa\n+    from plone.app.layout.navigation.defaultpage import (\n+        getDefaultPage as get_default_page,\n+    )  # noqa\n \n try:\n-    from plone.app.contenttypes.behaviors.collection import ISyndicatableCollection as ICollection  # noqa\n+    from plone.app.contenttypes.behaviors.collection import (\n+        ISyndicatableCollection as ICollection,\n+    )  # noqa\n except ImportError:\n     ICollection = None\n \ndiff --git a/plone/app/event/dx/traverser.py b/plone/app/event/dx/traverser.py\nindex dc08c4d7f..e3134e41a 100644\n--- a/plone/app/event/dx/traverser.py\n+++ b/plone/app/event/dx/traverser.py\n@@ -1,6 +1,6 @@\n # -*- coding: utf-8 -*-\n-from plone.app.event.recurrence import OccurrenceTraverser as DefaultTraverser\n from plone.app.event.dx.interfaces import IDXEventRecurrence\n+from plone.app.event.recurrence import OccurrenceTraverser as DefaultTraverser\n from plone.dexterity.browser.traversal import DexterityPublishTraverse\n from zope.component import adapter\n from zope.publisher.interfaces.browser import IBrowserRequest\ndiff --git a/plone/app/event/portlets/portlet_calendar.py b/plone/app/event/portlets/portlet_calendar.py\nindex fbf9dd600..c8c62e9a0 100644\n--- a/plone/app/event/portlets/portlet_calendar.py\n+++ b/plone/app/event/portlets/portlet_calendar.py\n@@ -31,7 +31,9 @@\n \n \n try:\n-    from plone.app.contenttypes.behaviors.collection import ISyndicatableCollection as ICollection  # noqa\n+    from plone.app.contenttypes.behaviors.collection import (\n+        ISyndicatableCollection as ICollection,\n+    )  # noqa\n     from plone.app.contenttypes.interfaces import IFolder\n     search_base_uid_source = CatalogSource(object_provides={\n         \'query\': [\ndiff --git a/plone/app/event/testing.py b/plone/app/event/testing.py\nindex 4c60b4d47..32e08b599 100644\n--- a/plone/app/event/testing.py\n+++ b/plone/app/event/testing.py\n@@ -11,16 +11,17 @@\n \n import os\n \n+\n try:\n     # plone.testing 7+, Plone 5.2+\n-    from plone.testing.zope import WSGI_SERVER_FIXTURE\n     from plone.testing.zope import installProduct\n     from plone.testing.zope import uninstallProduct\n+    from plone.testing.zope import WSGI_SERVER_FIXTURE\n except ImportError:\n     # plone.testing 6-, Plone 5.1\n-    from plone.testing.z2 import ZSERVER_FIXTURE as WSGI_SERVER_FIXTURE\n     from plone.testing.z2 import installProduct\n     from plone.testing.z2 import uninstallProduct\n+    from plone.testing.z2 import ZSERVER_FIXTURE as WSGI_SERVER_FIXTURE\n \n \n def set_browserlayer(request):\ndiff --git a/plone/app/event/tests/INACTIVE_test_robot.py b/plone/app/event/tests/INACTIVE_test_robot.py\nindex f155d5b2a..8c5293dac 100644\n--- a/plone/app/event/tests/INACTIVE_test_robot.py\n+++ b/plone/app/event/tests/INACTIVE_test_robot.py\n@@ -1,12 +1,12 @@\n # -*- conding: utf-8 -*-\n-import os\n-import robotsuite\n-import unittest\n-\n from plone.app.event.testing import PAEventDX_ROBOT_TESTING\n from plone.app.testing import ROBOT_TEST_LEVEL\n from plone.testing import layered\n \n+import os\n+import robotsuite\n+import unittest\n+\n \n def test_suite():\n     suite = unittest.TestSuite()\ndiff --git a/plone/app/event/tests/base_setup.py b/plone/app/event/tests/base_setup.py\nindex 5958bcb44..c12f7b3e2 100644\n--- a/plone/app/event/tests/base_setup.py\n+++ b/plone/app/event/tests/base_setup.py\n@@ -1,14 +1,14 @@\n # -*- coding: utf-8 -*-\n-from Products.CMFCore.utils import getToolByName\n from datetime import datetime\n from datetime import timedelta\n from plone.app.event.dx import behaviors\n from plone.app.event.testing import set_browserlayer\n from plone.app.event.testing import set_timezone\n-from plone.app.testing import TEST_USER_ID\n from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n from plone.app.textfield.value import RichTextValue\n from plone.dexterity.utils import createContentInContainer\n+from Products.CMFCore.utils import getToolByName\n \n import pytz\n import unittest\ndiff --git a/plone/app/event/tests/robot/variables.py b/plone/app/event/tests/robot/variables.py\nindex 614ef1706..4514b019b 100644\n--- a/plone/app/event/tests/robot/variables.py\n+++ b/plone/app/event/tests/robot/variables.py\n@@ -4,6 +4,7 @@\n \n import locale\n \n+\n # important for MONTHNAME\n locale.setlocale(locale.LC_ALL, "en_US")\n \ndiff --git a/plone/app/event/tests/test_base_module.py b/plone/app/event/tests/test_base_module.py\nindex dd9e5c0ce..dc6adc17d 100644\n--- a/plone/app/event/tests/test_base_module.py\n+++ b/plone/app/event/tests/test_base_module.py\n@@ -183,8 +183,8 @@ def test__dt_end_of_day(self):\n         )\n \n     def test__start_end_from_mode(self):\n-        from plone.app.event.base import start_end_from_mode\n         from plone.app.event.base import dt_end_of_day\n+        from plone.app.event.base import start_end_from_mode\n \n         # ALL\n         #\ndiff --git a/plone/app/event/tests/test_dx_behaviors.py b/plone/app/event/tests/test_dx_behaviors.py\nindex 955347a46..537577edb 100644\n--- a/plone/app/event/tests/test_dx_behaviors.py\n+++ b/plone/app/event/tests/test_dx_behaviors.py\n@@ -38,6 +38,7 @@\n import unittest\n import zope.interface\n \n+\n try:\n     # plone.testing 7+\n     from plone.testing.zope import Browser\ndiff --git a/plone/app/event/tests/test_event_listing.py b/plone/app/event/tests/test_event_listing.py\nindex d0d2ab213..72e7f9ba7 100644\n--- a/plone/app/event/tests/test_event_listing.py\n+++ b/plone/app/event/tests/test_event_listing.py\n@@ -2,8 +2,8 @@\n from plone.app.event.base import localized_today\n from plone.app.event.testing import make_fake_response\n from plone.app.event.testing import PAEventDX_INTEGRATION_TESTING\n-from plone.app.event.tests.base_setup import patched_now as PN\n from plone.app.event.tests.base_setup import AbstractSampleDataEvents\n+from plone.app.event.tests.base_setup import patched_now as PN\n \n import mock\n \ndiff --git a/plone/app/event/tests/test_event_summary.py b/plone/app/event/tests/test_event_summary.py\nindex 3fb71ab2b..eedcb952a 100644\n--- a/plone/app/event/tests/test_event_summary.py\n+++ b/plone/app/event/tests/test_event_summary.py\n@@ -1,8 +1,8 @@\n # -*- coding: utf-8 -*-\n from plone.app.event.dx.traverser import OccurrenceTraverser as OccTravDX\n from plone.app.event.testing import PAEventDX_INTEGRATION_TESTING\n-from plone.app.event.tests.base_setup import patched_now as PN\n from plone.app.event.tests.base_setup import AbstractSampleDataEvents\n+from plone.app.event.tests.base_setup import patched_now as PN\n \n import mock\n \ndiff --git a/plone/app/event/tests/test_event_view.py b/plone/app/event/tests/test_event_view.py\nindex 0a2382f8c..fa977fdc9 100644\n--- a/plone/app/event/tests/test_event_view.py\n+++ b/plone/app/event/tests/test_event_view.py\n@@ -1,8 +1,8 @@\n # -*- coding: utf-8 -*-\n from plone.app.event.dx.traverser import OccurrenceTraverser as OccTravDX\n from plone.app.event.testing import PAEventDX_FUNCTIONAL_TESTING\n-from plone.app.event.tests.base_setup import patched_now as PN\n from plone.app.event.tests.base_setup import AbstractSampleDataEvents\n+from plone.app.event.tests.base_setup import patched_now as PN\n \n import mock\n \ndiff --git a/plone/app/event/tests/test_ical_import.py b/plone/app/event/tests/test_ical_import.py\nindex 16cadaa12..5a92d42c7 100644\n--- a/plone/app/event/tests/test_ical_import.py\n+++ b/plone/app/event/tests/test_ical_import.py\n@@ -1,6 +1,6 @@\n # -*- coding: utf-8 -*-\n-from plone.app.event.interfaces import IICalendarImportEnabled\n from plone.app.event.ical.importer import IcalendarImportSettingsFormView\n+from plone.app.event.interfaces import IICalendarImportEnabled\n from plone.app.event.testing import PAEventDX_FUNCTIONAL_TESTING\n from plone.app.testing import setRoles\n from plone.app.testing import SITE_OWNER_NAME\n@@ -10,6 +10,7 @@\n import transaction\n import unittest\n \n+\n try:\n     # plone.testing 7+\n     from plone.testing.zope import Browser\ndiff --git a/plone/app/event/tests/test_recurrence.py b/plone/app/event/tests/test_recurrence.py\nindex c294a08b6..e514efe6c 100644\n--- a/plone/app/event/tests/test_recurrence.py\n+++ b/plone/app/event/tests/test_recurrence.py\n@@ -34,6 +34,7 @@\n import unittest\n import zope.component\n \n+\n try:\n     # plone.testing 7+\n     from plone.testing.zope import Browser\ndiff --git a/plone/app/event/tests/test_search.py b/plone/app/event/tests/test_search.py\nindex 90fe3c038..6dead4467 100644\n--- a/plone/app/event/tests/test_search.py\n+++ b/plone/app/event/tests/test_search.py\n@@ -1,7 +1,7 @@\n # -*- coding: utf-8 -*-\n from plone.app.event.testing import PAEventDX_FUNCTIONAL_TESTING\n-from plone.app.event.tests.base_setup import patched_now as PN\n from plone.app.event.tests.base_setup import AbstractSampleDataEvents\n+from plone.app.event.tests.base_setup import patched_now as PN\n \n import mock\n \ndiff --git a/plone/app/event/upgrades/upgrades.py b/plone/app/event/upgrades/upgrades.py\nindex d7c866286..c2a5a4d0a 100644\n--- a/plone/app/event/upgrades/upgrades.py\n+++ b/plone/app/event/upgrades/upgrades.py\n@@ -1,18 +1,20 @@\n # -*- coding: utf-8 -*-\n-from Products.CMFCore.utils import getToolByName\n-from plone.app.event.dx.interfaces import IDXEvent\n from plone.app.event.dx.behaviors import IEventAttendees\n from plone.app.event.dx.behaviors import IEventContact\n from plone.app.event.dx.behaviors import IEventLocation\n+from plone.app.event.dx.interfaces import IDXEvent\n from plone.dexterity.interfaces import IDexterityFTI\n+from Products.CMFCore.utils import getToolByName\n from zope.annotation.interfaces import IAnnotatable\n from zope.annotation.interfaces import IAnnotations\n-from zope.event import notify\n from zope.component import queryUtility\n from zope.component.hooks import getSite\n+from zope.event import notify\n from zope.lifecycleevent import ObjectModifiedEvent\n \n import logging\n+\n+\n log = logging.getLogger(__name__)\n \n BEHAVIOR_LIST = [\ndiff --git a/setup.cfg b/setup.cfg\nindex a5841d50b..00f7b1f84 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -3,7 +3,12 @@ ignore =\n     *.cfg\n     *.sh\n \n-\n-\n [bdist_wheel]\n universal = 1\n+\n+[isort]\n+# black compatible Plone isort rules:\n+profile = black\n+force_alphabetical_sort = True\n+force_single_line = True\n+lines_after_imports = 2\n'

Repository: plone.app.event


Branch: refs/heads/master
Date: 2022-05-04T22:13:30+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.event/commit/53e50770a31cae9f9c5f09cd8aef06d4c7ab496b

black

Files changed:
M docs/conf.py
M plone/__init__.py
M plone/app/__init__.py
M plone/app/event/__init__.py
M plone/app/event/base.py
M plone/app/event/browser/event_listing.py
M plone/app/event/browser/event_summary.py
M plone/app/event/browser/event_view.py
M plone/app/event/browser/formatted_date.py
M plone/app/event/browser/leadimage_viewlet.py
M plone/app/event/dx/behaviors.py
M plone/app/event/dx/interfaces.py
M plone/app/event/dx/traverser.py
M plone/app/event/ical/exporter.py
M plone/app/event/ical/importer.py
M plone/app/event/interfaces.py
M plone/app/event/portlets/__init__.py
M plone/app/event/portlets/portlet_calendar.py
M plone/app/event/portlets/portlet_events.py
M plone/app/event/recurrence.py
M plone/app/event/setuphandlers.py
M plone/app/event/testing.py
M plone/app/event/tests/INACTIVE_test_robot.py
M plone/app/event/tests/base_setup.py
M plone/app/event/tests/test_base_module.py
M plone/app/event/tests/test_catalog.py
M plone/app/event/tests/test_dx_behaviors.py
M plone/app/event/tests/test_event_listing.py
M plone/app/event/tests/test_event_summary.py
M plone/app/event/tests/test_event_view.py
M plone/app/event/tests/test_ical_import.py
M plone/app/event/tests/test_icalendar.py
M plone/app/event/tests/test_portlet_calendar.py
M plone/app/event/tests/test_portlet_events.py
M plone/app/event/tests/test_recurrence.py
M plone/app/event/tests/test_search.py
M plone/app/event/upgrades/upgrades.py
M plone/app/event/vocabularies.py
M setup.py

b'diff --git a/docs/conf.py b/docs/conf.py\nindex b8e8a666..bd0a78d7 100644\n--- a/docs/conf.py\n+++ b/docs/conf.py\n@@ -1,18 +1,18 @@\n # sphinx configuration\n \n-project = u\'plone.app.event\'\n-copyright = u\'2012, Plone Foundation\'\n+project = u"plone.app.event"\n+copyright = u"2012, Plone Foundation"\n \n extensions = [\n-    \'sphinx.ext.doctest\',\n-    \'sphinx.ext.coverage\',\n-    \'sphinx.ext.autodoc\',\n-    \'sphinx.ext.viewcode\',\n-    \'sphinx.ext.autosummary\',\n+    "sphinx.ext.doctest",\n+    "sphinx.ext.coverage",\n+    "sphinx.ext.autodoc",\n+    "sphinx.ext.viewcode",\n+    "sphinx.ext.autosummary",\n ]\n-master_doc = \'index\'\n+master_doc = "index"\n \n-language = \'en\'\n+language = "en"\n \n from pkg_resources import get_distribution\n \ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af4..03d08ffd 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1,2 @@\n # -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 68c04af4..03d08ffd 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,2 +1,2 @@\n # -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/event/__init__.py b/plone/app/event/__init__.py\nindex 36164792..301d4775 100644\n--- a/plone/app/event/__init__.py\n+++ b/plone/app/event/__init__.py\n@@ -4,12 +4,16 @@\n \n \n packageName = __name__\n-_ = MessageFactory(\'plone\')\n+_ = MessageFactory("plone")\n \n # BBB Permissions\n-PORTAL_ADD_PERMISSION = \'Add portal events\'  # CMFCalendar/ATCT permissions\n+PORTAL_ADD_PERMISSION = "Add portal events"  # CMFCalendar/ATCT permissions\n \n addPermission(\n     PORTAL_ADD_PERMISSION,\n-    (\'Manager\', \'Site Administrator\', \'Owner\',)\n+    (\n+        "Manager",\n+        "Site Administrator",\n+        "Owner",\n+    ),\n )\ndiff --git a/plone/app/event/base.py b/plone/app/event/base.py\nindex e21e7bc9..b6a4b8d6 100644\n--- a/plone/app/event/base.py\n+++ b/plone/app/event/base.py\n@@ -38,7 +38,7 @@\n \n \n DEFAULT_END_DELTA = 1  # hours\n-FALLBACK_TIMEZONE = \'UTC\'\n+FALLBACK_TIMEZONE = "UTC"\n \n # Sync strategies\n SYNC_NONE = 0\n@@ -58,18 +58,27 @@\n # TODO: do we need this at all or shouldn\'t we just fail with ambiguous\n #       timezones?\n replacement_zones = {\n-    \'CET\': \'Europe/Vienna\',    # Central European Time\n-    \'MET\': \'Europe/Vienna\',    # Middle European Time\n-    \'EET\': \'Europe/Helsinki\',  # East European Time\n-    \'WET\': \'Europe/Lisbon\',    # West European Time\n+    "CET": "Europe/Vienna",  # Central European Time\n+    "MET": "Europe/Vienna",  # Middle European Time\n+    "EET": "Europe/Helsinki",  # East European Time\n+    "WET": "Europe/Lisbon",  # West European Time\n }\n \n \n # RETRIEVE EVENTS\n \n-def get_events(context, start=None, end=None, limit=None,\n-               ret_mode=RET_MODE_BRAINS, expand=False,\n-               sort=\'start\', sort_reverse=False, **kw):\n+\n+def get_events(\n+    context,\n+    start=None,\n+    end=None,\n+    limit=None,\n+    ret_mode=RET_MODE_BRAINS,\n+    expand=False,\n+    sort="start",\n+    sort_reverse=False,\n+    **kw\n+):\n     """Return all events as catalog brains, possibly within a given\n     timeframe.\n \n@@ -115,40 +124,38 @@ def get_events(context, start=None, end=None, limit=None,\n     start, end = _prepare_range(context, start, end)\n \n     query = {}\n-    query[\'object_provides\'] = IEvent.__identifier__\n+    query["object_provides"] = IEvent.__identifier__\n \n     query.update(start_end_query(start, end))\n \n-    if \'path\' not in kw:\n+    if "path" not in kw:\n         # limit to the current navigation root, usually (not always) site\n         portal = getSite()\n         navroot = getNavigationRootObject(context, portal)\n-        query[\'path\'] = \'/\'.join(navroot.getPhysicalPath())\n+        query["path"] = "/".join(navroot.getPhysicalPath())\n     else:\n-        query[\'path\'] = kw[\'path\']\n+        query["path"] = kw["path"]\n \n     # Sorting\n     # In expand mode we sort after calculation of recurrences again. But we\n     # need to leave this sorting here in place, since no sort definition could\n     # lead to arbitrary results when limiting with sort_limit.\n-    query[\'sort_on\'] = sort\n+    query["sort_on"] = sort\n     if sort_reverse:\n-        query[\'sort_order\'] = \'reverse\'\n+        query["sort_order"] = "reverse"\n \n     # cannot limit before resorting or expansion, see below\n \n     query.update(kw)\n \n-    cat = getToolByName(context, \'portal_catalog\')\n+    cat = getToolByName(context, "portal_catalog")\n     result = cat(**query)\n \n     # unfiltered catalog results are already sorted correctly on brain.start\n     # filtering on start/end requires a resort, see docstring below and\n     # p.a.event.tests.test_base_module.TestGetEventsDX.test_get_event_sort\n-    if sort in (\'start\', \'end\'):\n-        result = filter_and_resort(context, result,\n-                                   start, end,\n-                                   sort, sort_reverse)\n+    if sort in ("start", "end"):\n+        result = filter_and_resort(context, result, start, end, sort, sort_reverse)\n \n         # Limiting a start/end-sorted result set is possible here\n         # and provides an important optimization BEFORE costly expansion\n@@ -159,8 +166,7 @@ def get_events(context, start=None, end=None, limit=None,\n         if expand is False:\n             result = [_obj_or_acc(it.getObject(), ret_mode) for it in result]\n         else:\n-            result = expand_events(result, ret_mode, start, end, sort,\n-                                   sort_reverse)\n+            result = expand_events(result, ret_mode, start, end, sort, sort_reverse)\n \n     # Limiting a non-start-sorted result set can only happen here\n     if limit:\n@@ -212,14 +218,14 @@ def filter_and_resort(context, brains, start, end, sort, sort_reverse):\n     """\n     _start = dt2int(start)  # index contains longint sets\n     _end = dt2int(end)\n-    catalog = getToolByName(context, \'portal_catalog\')\n+    catalog = getToolByName(context, "portal_catalog")\n     items = []  # (start:int, occurrence:brain) pairs\n     for brain in brains:\n         # brain.start metadata reflects first occurrence.\n         # instead, get all occurrence start/end from raw index\n         idx = catalog.getIndexDataForRID(brain.getRID())\n-        _allstarts = sorted(idx[\'start\'])\n-        _allends = sorted(idx[\'end\'])\n+        _allstarts = sorted(idx["start"])\n+        _allends = sorted(idx["end"])\n         # assuming (start, end) pairs belong together\n         # assert(len(_allstarts) == len(_allends))\n         _occ = six.moves.zip(_allstarts, _allends)\n@@ -229,10 +235,10 @@ def filter_and_resort(context, brains, start, end, sort, sort_reverse):\n             _occ = [(s, e) for (s, e) in _occ if s <= _end]\n         if not _occ:\n             continue\n-        if sort == \'start\':\n+        if sort == "start":\n             # first start can be before filter window if end is in window\n             _first = min([s for (s, e) in _occ])\n-        elif sort == \'end\':\n+        elif sort == "end":\n             _first = min([e for (s, e) in _occ])\n         items.append((_first, brain))  # key on next start/end\n \n@@ -243,9 +249,7 @@ def filter_and_resort(context, brains, start, end, sort, sort_reverse):\n     return data\n \n \n-def expand_events(events, ret_mode,\n-                  start=None, end=None,\n-                  sort=None, sort_reverse=None):\n+def expand_events(events, ret_mode, start=None, end=None, sort=None, sort_reverse=None):\n     """Expand to the recurrence occurrences of a given set of events.\n \n     :param events: IEvent based objects or IEventAccessor object wrapper.\n@@ -273,11 +277,11 @@ def expand_events(events, ret_mode,\n     :param sort_reverse: Change the order of the sorting.\n     :type sort_reverse: boolean\n     """\n-    assert(ret_mode is not RET_MODE_BRAINS)\n+    assert ret_mode is not RET_MODE_BRAINS\n \n     exp_result = []\n     for it in events:\n-        obj = it.getObject() if getattr(it, \'getObject\', False) else it\n+        obj = it.getObject() if getattr(it, "getObject", False) else it\n         if IEventRecurrence.providedBy(obj):\n \n             occ_list = list(IRecurrenceSupport(obj).occurrences(start, end))\n@@ -304,7 +308,7 @@ def _obj_or_acc(obj, ret_mode):\n     ret_mode. ret_mode 2 returns objects, ret_mode 3 returns IEventAccessor\n     object wrapper. ret_mode 1 is not supported.\n     """\n-    assert(ret_mode is not RET_MODE_BRAINS)\n+    assert ret_mode is not RET_MODE_BRAINS\n     if ret_mode == RET_MODE_OBJECTS:\n         return obj\n     elif ret_mode == RET_MODE_ACCESSORS:\n@@ -412,22 +416,22 @@ def _prepare_range(context, start, end):\n \n \n def start_end_query(start, end):\n-    """Make a catalog query out of start and end dates.\n-    """\n+    """Make a catalog query out of start and end dates."""\n     query = {}\n     if start:\n         # All events from start date ongoing:\n         # The minimum end date of events is the date from which we search.\n-        query[\'end\'] = {\'query\': start, \'range\': \'min\'}\n+        query["end"] = {"query": start, "range": "min"}\n     if end:\n         # All events until end date:\n         # The maximum start date must be the date until we search.\n-        query[\'start\'] = {\'query\': end, \'range\': \'max\'}\n+        query["start"] = {"query": end, "range": "max"}\n     return query\n \n \n # TIMEZONE HANDLING\n \n+\n def default_timezone(context=None, as_tzinfo=False):\n     """Return the timezone from the portal or user.\n \n@@ -445,15 +449,15 @@ def default_timezone(context=None, as_tzinfo=False):\n     if not context:\n         context = getSite()\n \n-    membership = getToolByName(context, \'portal_membership\', None)\n+    membership = getToolByName(context, "portal_membership", None)\n     if membership and not membership.isAnonymousUser():  # user not logged in\n         member = membership.getAuthenticatedMember()\n-        member_timezone = member.getProperty(\'timezone\', None)\n+        member_timezone = member.getProperty("timezone", None)\n         if member_timezone:\n             info = pytz.timezone(member_timezone)\n             return info if as_tzinfo else info.zone\n \n-    reg_key = \'plone.portal_timezone\'\n+    reg_key = "plone.portal_timezone"\n     registry = getUtility(IRegistry)\n     portal_timezone = registry.get(reg_key, None)\n \n@@ -503,6 +507,7 @@ def localized_today(context=None):\n \n # DATETIME HELPERS\n \n+\n def first_weekday():\n     """Returns the number of the first Weekday in a Week, as defined in\n     the registry. 0 is Monday, 6 is Sunday, as expected by Python\'s datetime.\n@@ -513,7 +518,7 @@ def first_weekday():\n     :rtype: integer\n \n     """\n-    reg_key = \'plone.first_weekday\'\n+    reg_key = "plone.first_weekday"\n     registry = getUtility(IRegistry)\n     first_wd = registry.get(reg_key, None)\n \n@@ -582,23 +587,19 @@ def _adjust_DT(DT, exact):\n                 DT.hour(),\n                 DT.minute(),\n                 int(DT.second()),\n-                DT.timezone()\n+                DT.timezone(),\n             )\n         return ret\n \n     tz = default_timezone(getSite())\n     ret = None\n     if is_datetime(dt):\n-        zone_id = getattr(dt.tzinfo, \'zone\', tz)\n+        zone_id = getattr(dt.tzinfo, "zone", tz)\n         tz = validated_timezone(zone_id, tz)\n         second = dt.second\n         if exact:\n             second += dt.microsecond / 1000000.0\n-        ret = DateTime(\n-            dt.year, dt.month, dt.day,\n-            dt.hour, dt.minute, second,\n-            tz\n-        )\n+        ret = DateTime(dt.year, dt.month, dt.day, dt.hour, dt.minute, second, tz)\n     elif is_date(dt):\n         ret = DateTime(dt.year, dt.month, dt.day, 0, 0, 0, tz)\n     elif isinstance(dt, DateTime):\n@@ -699,33 +700,33 @@ def start_end_from_mode(mode, dt=None, context=None):\n     now = localized_now(context)\n     start = end = None\n \n-    if mode == \'all\':\n+    if mode == "all":\n         start = None\n         end = None\n \n-    elif mode == \'past\':\n+    elif mode == "past":\n         start = None\n         end = now\n \n-    elif mode == \'future\':\n+    elif mode == "future":\n         start = now\n         end = None\n \n-    elif mode == \'now\':\n+    elif mode == "now":\n         start = now\n         end = dt_end_of_day(now)\n \n-    elif mode == \'7days\':\n+    elif mode == "7days":\n         start = now\n         end = dt_end_of_day(now + timedelta(days=6))\n \n-    elif mode == \'day\' or mode == \'today\':\n+    elif mode == "day" or mode == "today":\n         if not dt:\n             dt = now  # show today\n         start = dt_start_of_day(dt)\n         end = dt_end_of_day(dt)\n \n-    elif mode == \'week\':\n+    elif mode == "week":\n         if not dt:\n             dt = now  # show this week\n         wkd = dt.weekday()\n@@ -739,7 +740,7 @@ def start_end_from_mode(mode, dt=None, context=None):\n         start = dt_start_of_day(dt - timedelta(days=delta))\n         end = dt_end_of_day(start + timedelta(days=6))\n \n-    elif mode == \'month\':\n+    elif mode == "month":\n         if not dt:\n             dt = now  # show this month\n         year = dt.year\n@@ -753,8 +754,9 @@ def start_end_from_mode(mode, dt=None, context=None):\n \n # DISPLAY HELPERS\n \n+\n def dates_for_display(occurrence):\n-    """ Return a dictionary containing pre-calculated information for building\n+    """Return a dictionary containing pre-calculated information for building\n     <start>-<end> date strings.\n \n     Keys are:\n@@ -828,22 +830,18 @@ def dates_for_display(occurrence):\n     if acc.open_end:\n         end_time = None\n \n-    start_iso = acc.whole_day and acc.start.date().isoformat()\\\n-        or acc.start.isoformat()\n-    end_iso = acc.whole_day and acc.end.date().isoformat()\\\n-        or acc.end.isoformat()\n+    start_iso = acc.whole_day and acc.start.date().isoformat() or acc.start.isoformat()\n+    end_iso = acc.whole_day and acc.end.date().isoformat() or acc.end.isoformat()\n \n     return dict(\n         # Start\n         start_date=start_date,\n         start_time=start_time,\n         start_iso=start_iso,\n-\n         # End\n         end_date=end_date,\n         end_time=end_time,\n         end_iso=end_iso,\n-\n         # Meta\n         same_day=same_day,\n         same_time=same_time,\n@@ -852,61 +850,49 @@ def dates_for_display(occurrence):\n     )\n \n \n-@deprecate(\'date_speller is no longer supported, use spell_date instead.\')\n+@deprecate("date_speller is no longer supported, use spell_date instead.")\n def date_speller(context, dt):\n     return spell_date(dt, context)\n \n \n def spell_date(dt, translation_context=None):\n-    """Return a dictionary with localized and readable formatted date parts.\n-\n-    """\n+    """Return a dictionary with localized and readable formatted date parts."""\n     if not translation_context:\n         translation_context = getSite()\n \n     dt = DT(dt)\n-    util = getToolByName(translation_context, \'translation_service\')\n-    dom = \'plonelocales\'\n+    util = getToolByName(translation_context, "translation_service")\n+    dom = "plonelocales"\n \n     def zero_pad(num):\n-        return \'%02d\' % num\n+        return "%02d" % num\n \n     date_dict = dict(\n         year=dt.year(),\n-\n         month=dt.month(),\n         month2=zero_pad(dt.month()),\n         month_name=util.translate(\n-            util.month_msgid(dt.month()),\n-            domain=dom, context=translation_context\n+            util.month_msgid(dt.month()), domain=dom, context=translation_context\n         ),\n         month_abbr=util.translate(\n-            util.month_msgid(dt.month(), \'a\'),\n-            domain=dom, context=translation_context\n+            util.month_msgid(dt.month(), "a"), domain=dom, context=translation_context\n         ),\n-\n         week=dt.week(),\n         wkday=dt.dow(),\n         wkday_name=util.translate(\n-            util.day_msgid(dt.dow()),\n-            domain=dom, context=translation_context\n+            util.day_msgid(dt.dow()), domain=dom, context=translation_context\n         ),\n         wkday_abbr=util.translate(\n-            util.day_msgid(dt.dow(), \'s\'),\n-            domain=dom, context=translation_context\n+            util.day_msgid(dt.dow(), "s"), domain=dom, context=translation_context\n         ),\n-\n         day=dt.day(),\n         day2=zero_pad(dt.day()),\n-\n         hour=dt.hour(),\n         hour2=zero_pad(dt.hour()),\n-\n         minute=dt.minute(),\n         minute2=zero_pad(dt.minute()),\n-\n         second=dt.second(),\n-        second2=zero_pad(dt.second())\n+        second2=zero_pad(dt.second()),\n     )\n     return date_dict\n \n@@ -935,6 +921,7 @@ def default_end(context=None):\n # General utils\n # TODO: Better fits to CMFPlone. (Taken from CMFPlone\'s new syndication tool)\n \n+\n class AnnotationAdapter(object):\n     """Abstract Base Class for an annotation storage.\n \n@@ -943,6 +930,7 @@ class AnnotationAdapter(object):\n     So, the context doesn\'t get polluted with annotations by accident.\n \n     """\n+\n     ANNOTATION_KEY = None\n \n     def __init__(self, context):\n@@ -951,7 +939,7 @@ def __init__(self, context):\n         self._data = annotations.get(self.ANNOTATION_KEY, None)\n \n     def __setattr__(self, name, value):\n-        if name in (\'context\', \'_data\', \'ANNOTATION_KEY\'):\n+        if name in ("context", "_data", "ANNOTATION_KEY"):\n             self.__dict__[name] = value\n         else:\n             if self._data is None:\n@@ -964,8 +952,7 @@ def __getattr__(self, name):\n         return self._data.get(name, None) if self._data else None\n \n \n-def find_context(context, viewname=None, iface=None,\n-                 as_url=False, append_view=True):\n+def find_context(context, viewname=None, iface=None, as_url=False, append_view=True):\n     """Find the next context with a given view name or interface, up in the\n     content tree, starting from the given context. This might not be the\n     IPloneSiteRoot, but another subsite.\n@@ -984,18 +971,27 @@ def find_context(context, viewname=None, iface=None,\n     """\n     context = aq_inner(context)\n     ret = None\n-    if viewname and context.defaultView() == viewname\\\n-       or iface and iface.providedBy(context)\\\n-       or IPloneSiteRoot.providedBy(context):\n+    if (\n+        viewname\n+        and context.defaultView() == viewname\n+        or iface\n+        and iface.providedBy(context)\n+        or IPloneSiteRoot.providedBy(context)\n+    ):\n         # Search for viewname or interface but stop at IPloneSiteRoot\n         ret = context\n     else:\n-        ret = find_context(aq_parent(context), viewname=viewname, iface=iface,\n-                           as_url=False, append_view=False)\n+        ret = find_context(\n+            aq_parent(context),\n+            viewname=viewname,\n+            iface=iface,\n+            as_url=False,\n+            append_view=False,\n+        )\n     if as_url:\n         url = ret.absolute_url()\n         if viewname and append_view and ret.defaultView() != viewname:\n-            url = \'%s/%s\' % (url, viewname)\n+            url = "%s/%s" % (url, viewname)\n         return url\n     return ret\n \n@@ -1013,8 +1009,9 @@ def find_navroot(context, as_url=False):\n \n \n def find_event_listing(context, as_url=False):\n-    return find_context(context, viewname=\'event_listing\', iface=ISite,\n-                        as_url=as_url, append_view=True)\n+    return find_context(\n+        context, viewname="event_listing", iface=ISite, as_url=as_url, append_view=True\n+    )\n \n \n # Workaround for buggy strftime with timezone handling in DateTime.\ndiff --git a/plone/app/event/browser/event_listing.py b/plone/app/event/browser/event_listing.py\nindex e50000c7..6dcd791c 100644\n--- a/plone/app/event/browser/event_listing.py\n+++ b/plone/app/event/browser/event_listing.py\n@@ -40,7 +40,6 @@\n \n \n class EventListing(BrowserView):\n-\n     def __init__(self, context, request):\n         super(EventListing, self).__init__(context, request)\n \n@@ -57,30 +56,30 @@ def __init__(self, context, request):\n         # Request parameter\n         req = self.request.form\n \n-        b_size  = int(req.get(\'b_size\', 0))\n+        b_size = int(req.get("b_size", 0))\n         if not b_size and self.is_collection:\n             collection_behavior = ICollection(self.default_context)\n-            b_size = getattr(collection_behavior, \'item_count\', 0)\n+            b_size = getattr(collection_behavior, "item_count", 0)\n         self.b_size = b_size or 10\n-        self.b_start = int(req.get(\'b_start\', 0))\n-        self.orphan  = int(req.get(\'orphan\', 1))\n-        self.mode    = req.get(\'mode\', None)\n-        self._date   = req.get(\'date\', None)\n-        self.tags    = req.get(\'tags\', None)\n-        self.searchable_text = req.get(\'SearchableText\', None)\n-        self.path    = req.get(\'path\', None)\n-\n-        day   = int(req.get(\'day\', 0)) or None\n-        month = int(req.get(\'month\', 0)) or None\n-        year  = int(req.get(\'year\', 0)) or None\n+        self.b_start = int(req.get("b_start", 0))\n+        self.orphan = int(req.get("orphan", 1))\n+        self.mode = req.get("mode", None)\n+        self._date = req.get("date", None)\n+        self.tags = req.get("tags", None)\n+        self.searchable_text = req.get("SearchableText", None)\n+        self.path = req.get("path", None)\n+\n+        day = int(req.get("day", 0)) or None\n+        month = int(req.get("month", 0)) or None\n+        year = int(req.get("year", 0)) or None\n \n         if not self._date and day or month or year:\n-            self._date = date(year or now.year,\n-                              month or now.month,\n-                              day or now.day).isoformat()\n+            self._date = date(\n+                year or now.year, month or now.month, day or now.day\n+            ).isoformat()\n \n         if self.mode is None:\n-            self.mode = \'day\' if self._date else \'future\'\n+            self.mode = "day" if self._date else "future"\n \n         self.uid = None  # Used to get all occurrences from a single event. Overrides all other settings  # noqa\n \n@@ -90,7 +89,7 @@ def show_filter(self):\n         if self.is_collection:\n             ctx = self.default_context\n             query = queryparser.parseFormquery(ctx, ctx.query)\n-            if \'start\' in query or \'end\' in query:\n+            if "start" in query or "end" in query:\n                 # Don\'t show the date filter, if a date is given in the\n                 # collection\'s query\n                 ret = False\n@@ -116,32 +115,39 @@ def _get_events(self, ret_mode=RET_MODE_ACCESSORS, expand=True):\n         kw = {}\n         if self.uid:\n             # In this case, restrict search for single event\n-            kw[\'UID\'] = self.uid\n+            kw["UID"] = self.uid\n         else:\n             if self.path:\n-                kw[\'path\'] = self.path\n+                kw["path"] = self.path\n             else:\n                 # Search current and subsequent folders\n-                kw[\'path\'] = \'/\'.join(context.getPhysicalPath())\n+                kw["path"] = "/".join(context.getPhysicalPath())\n \n             if self.tags:\n-                kw[\'Subject\'] = {\'query\': self.tags, \'operator\': \'and\'}\n+                kw["Subject"] = {"query": self.tags, "operator": "and"}\n \n             if self.searchable_text:\n-                kw[\'SearchableText\'] = self.searchable_text\n+                kw["SearchableText"] = self.searchable_text\n \n         # kw[\'b_start\'] = self.b_start\n         # kw[\'b_size\']  = self.b_size\n \n         start, end = self._start_end\n \n-        sort = \'start\'\n+        sort = "start"\n         sort_reverse = False\n-        if self.mode in (\'past\', \'all\'):\n+        if self.mode in ("past", "all"):\n             sort_reverse = True\n-        return get_events(context, start=start, end=end,\n-                          sort=sort, sort_reverse=sort_reverse,\n-                          ret_mode=ret_mode, expand=expand, **kw)\n+        return get_events(\n+            context,\n+            start=start,\n+            end=end,\n+            sort=sort,\n+            sort_reverse=sort_reverse,\n+            ret_mode=ret_mode,\n+            expand=expand,\n+            **kw\n+        )\n \n     @view.memoize\n     def events(self, ret_mode=RET_MODE_ACCESSORS, expand=True, batch=True):\n@@ -149,33 +155,34 @@ def events(self, ret_mode=RET_MODE_ACCESSORS, expand=True, batch=True):\n         if self.is_collection:\n             ctx = self.default_context\n             # Whatever sorting is defined, we\'re overriding it.\n-            sort_on = \'start\'\n+            sort_on = "start"\n             sort_order = None\n-            if self.mode in (\'past\', \'all\'):\n-                sort_order = \'reverse\'\n+            if self.mode in ("past", "all"):\n+                sort_order = "reverse"\n             query = queryparser.parseFormquery(\n                 ctx, ctx.query, sort_on=sort_on, sort_order=sort_order\n             )\n-            custom_query = self.request.get(\'contentFilter\', {})\n-            if \'start\' not in query or \'end\' not in query:\n+            custom_query = self.request.get("contentFilter", {})\n+            if "start" not in query or "end" not in query:\n                 # ... else don\'t show the navigation bar\n                 start, end = self._start_end\n                 start, end = _prepare_range(ctx, start, end)\n                 custom_query.update(start_end_query(start, end))\n-            res = ctx.results(\n-                batch=False, brains=True, custom_query=custom_query\n-            )\n+            res = ctx.results(batch=False, brains=True, custom_query=custom_query)\n             if expand:\n                 # get start and end values from the query to ensure limited\n                 # listing for occurrences\n                 start, end = self._expand_events_start_end(\n-                    query.get(\'start\') or custom_query.get(\'start\'),\n-                    query.get(\'end\') or custom_query.get(\'end\')\n+                    query.get("start") or custom_query.get("start"),\n+                    query.get("end") or custom_query.get("end"),\n                 )\n                 res = expand_events(\n-                    res, ret_mode,\n-                    start=start, end=end,\n-                    sort=sort_on, sort_reverse=True if sort_order else False\n+                    res,\n+                    ret_mode,\n+                    start=start,\n+                    end=end,\n+                    sort=sort_on,\n+                    sort_reverse=True if sort_order else False,\n                 )\n         else:\n             res = self._get_events(ret_mode, expand=expand)\n@@ -190,17 +197,15 @@ def ical(self):\n         # Get as objects.\n         # Don\'t include occurrences to avoid having them along with their\n         # original events and it\'s recurrence definition in icalendar exports.\n-        events = self.events(ret_mode=RET_MODE_OBJECTS, expand=False,\n-                             batch=False)\n+        events = self.events(ret_mode=RET_MODE_OBJECTS, expand=False, batch=False)\n         cal = construct_icalendar(self.context, events)\n-        name = \'%s.ics\' % self.context.getId()\n+        name = "%s.ics" % self.context.getId()\n         contents = cal.to_ical()\n-        self.request.response.setHeader(\'Content-Type\', \'text/calendar\')\n+        self.request.response.setHeader("Content-Type", "text/calendar")\n         self.request.response.setHeader(\n-            \'Content-Disposition\',\n-            \'attachment; filename="%s"\' % name\n+            "Content-Disposition", \'attachment; filename="%s"\' % name\n         )\n-        self.request.response.setHeader(\'Content-Length\', len(contents))\n+        self.request.response.setHeader("Content-Length", len(contents))\n         self.request.response.write(contents)\n \n     @property\n@@ -208,16 +213,18 @@ def ical_url(self):\n         date = self.date\n         mode = self.mode\n \n-        qstr = \'&\'.join([\n-            it for it in [\'mode=%s\' % mode if mode else None,\n-                          \'date=%s\' % date if date else None]\n-            if it\n-        ])\n-        qstr = \'?%s\' % qstr if qstr else \'\'\n-        return \'%s/@@event_listing_ical%s\' % (\n-            self.context.absolute_url(),\n-            qstr\n+        qstr = "&".join(\n+            [\n+                it\n+                for it in [\n+                    "mode=%s" % mode if mode else None,\n+                    "date=%s" % date if date else None,\n+                ]\n+                if it\n+            ]\n         )\n+        qstr = "?%s" % qstr if qstr else ""\n+        return "%s/@@event_listing_ical%s" % (self.context.absolute_url(), qstr)\n \n     # COLLECTION daterange start/end determination\n     def _expand_events_start_end(self, start, end):\n@@ -229,8 +236,8 @@ def _expand_events_start_end(self, start, end):\n         # wants to come up with some edgecases!\n         se = dict(start=None, end=None)\n         if start:\n-            q = start.get(\'query\')\n-            r = start.get(\'range\')\n+            q = start.get("query")\n+            r = start.get("range")\n             if r == "min":\n                 se["start"] = q\n             elif r == "max":\n@@ -240,16 +247,15 @@ def _expand_events_start_end(self, start, end):\n                 se["start"] = q[0]\n                 se["end"] = q[1]\n         if end:\n-            q = end.get(\'query\')\n-            r = end.get(\'range\')\n+            q = end.get("query")\n+            r = end.get("range")\n             if r == "min":\n                 se["start"] = q\n         return se["start"], se["end"]\n \n     def formatted_date(self, occ):\n         provider = getMultiAdapter(\n-            (self.context, self.request, self),\n-            IContentProvider, name=\'formatted_date\'\n+            (self.context, self.request, self), IContentProvider, name="formatted_date"\n         )\n         return provider(occ)\n \n@@ -265,181 +271,188 @@ def header_string(self):\n         mode = self.mode\n         main_msgid = None\n         sub_msgid = None\n-        if mode == \'all\':\n+        if mode == "all":\n             main_msgid = _(u"all_events", default=u"All events")\n \n-        elif mode == \'past\':\n+        elif mode == "past":\n             main_msgid = _(u"past_events", default=u"Past events")\n \n-        elif mode == \'future\':\n+        elif mode == "future":\n             main_msgid = _(u"future_events", default=u"Future events")\n \n-        elif mode == \'now\':\n-            main_msgid = _(u"todays_upcoming_events",\n-                           default=u"Todays upcoming events")\n+        elif mode == "now":\n+            main_msgid = _(u"todays_upcoming_events", default=u"Todays upcoming events")\n \n-        elif mode == \'today\':\n+        elif mode == "today":\n             main_msgid = _(u"todays_events", default=u"Todays events")\n \n-        elif mode == \'7days\':\n+        elif mode == "7days":\n             main_msgid = _(u"7days_events", default=u"Events in next 7 days.")\n             sub_msgid = _(\n                 u"events_from_until",\n                 default=u"${from} until ${until}.",\n                 mapping={\n-                    \'from\': "%s, %s. %s %s" % (\n-                        start_dict[\'wkday_name\'],\n+                    "from": "%s, %s. %s %s"\n+                    % (\n+                        start_dict["wkday_name"],\n                         start.day,\n-                        start_dict[\'month_name\'],\n-                        start.year\n+                        start_dict["month_name"],\n+                        start.year,\n                     ),\n-                    \'until\': "%s, %s. %s %s" % (\n-                        end_dict[\'wkday_name\'],\n+                    "until": "%s, %s. %s %s"\n+                    % (\n+                        end_dict["wkday_name"],\n                         end.day,\n-                        end_dict[\'month_name\'],\n-                        end.year\n+                        end_dict["month_name"],\n+                        end.year,\n                     ),\n-                }\n+                },\n             )\n \n-        elif mode == \'day\':\n+        elif mode == "day":\n             main_msgid = _(\n                 u"events_on_day",\n                 default=u"Events on ${day}",\n                 mapping={\n-                    \'day\': "%s, %s. %s %s" % (\n-                        start_dict[\'wkday_name\'],\n+                    "day": "%s, %s. %s %s"\n+                    % (\n+                        start_dict["wkday_name"],\n                         start.day,\n-                        start_dict[\'month_name\'],\n-                        start.year\n+                        start_dict["month_name"],\n+                        start.year,\n                     ),\n-                }\n+                },\n             )\n \n-        elif mode == \'week\':\n-            main_msgid = _(u"events_in_week",\n-                           default=u"Events in week ${weeknumber}",\n-                           mapping={\'weeknumber\': start.isocalendar()[1]})\n+        elif mode == "week":\n+            main_msgid = _(\n+                u"events_in_week",\n+                default=u"Events in week ${weeknumber}",\n+                mapping={"weeknumber": start.isocalendar()[1]},\n+            )\n             sub_msgid = _(\n                 u"events_from_until",\n                 default=u"${from} until ${until}.",\n                 mapping={\n-                    \'from\': "%s, %s. %s %s" % (\n-                        start_dict[\'wkday_name\'],\n+                    "from": "%s, %s. %s %s"\n+                    % (\n+                        start_dict["wkday_name"],\n                         start.day,\n-                        start_dict[\'month_name\'],\n-                        start.year\n+                        start_dict["month_name"],\n+                        start.year,\n                     ),\n-                    \'until\': "%s, %s. %s %s" % (\n-                        end_dict[\'wkday_name\'],\n+                    "until": "%s, %s. %s %s"\n+                    % (\n+                        end_dict["wkday_name"],\n                         end.day,\n-                        end_dict[\'month_name\'],\n-                        end.year\n+                        end_dict["month_name"],\n+                        end.year,\n                     ),\n-                }\n+                },\n             )\n \n-        elif mode == \'month\':\n+        elif mode == "month":\n             main_msgid = _(\n                 u"events_in_month",\n                 default=u"Events in ${month} ${year}",\n                 mapping={\n-                    \'month\': start_dict[\'month_name\'],\n-                    \'year\': start.year,\n-                }\n+                    "month": start_dict["month_name"],\n+                    "year": start.year,\n+                },\n             )\n \n         trans = self.context.translate\n-        return {\'main\': trans(main_msgid) if main_msgid else \'\',\n-                \'sub\': trans(sub_msgid) if sub_msgid else \'\'}\n+        return {\n+            "main": trans(main_msgid) if main_msgid else "",\n+            "sub": trans(sub_msgid) if sub_msgid else "",\n+        }\n \n     # MODE URLs\n-    def _date_nav_url(self, mode, datestr=\'\'):\n-        return \'%s?mode=%s%s\' % (\n+    def _date_nav_url(self, mode, datestr=""):\n+        return "%s?mode=%s%s" % (\n             self.request.getURL(),\n             mode,\n-            \'&date=%s\' % datestr if datestr else \'\'\n+            "&date=%s" % datestr if datestr else "",\n         )\n \n     @property\n     def mode_all_url(self):\n-        return self._date_nav_url(\'all\')\n+        return self._date_nav_url("all")\n \n     @property\n     def mode_future_url(self):\n-        return self._date_nav_url(\'future\')\n+        return self._date_nav_url("future")\n \n     @property\n     def mode_past_url(self):\n-        return self._date_nav_url(\'past\')\n+        return self._date_nav_url("past")\n \n     @property\n     def mode_day_url(self):\n         now = self.date or self.now\n-        return self._date_nav_url(\'day\', now.date().isoformat())\n+        return self._date_nav_url("day", now.date().isoformat())\n \n     @property\n     def mode_week_url(self):\n         now = self.date or self.now\n-        return self._date_nav_url(\'week\', now.date().isoformat())\n+        return self._date_nav_url("week", now.date().isoformat())\n \n     @property\n     def mode_month_url(self):\n         now = self.date or self.now\n-        return self._date_nav_url(\'month\', now.date().isoformat())\n+        return self._date_nav_url("month", now.date().isoformat())\n \n     # DAY NAV\n     @property\n     def next_day_url(self):\n         now = self.date or self.now\n         datestr = (now + timedelta(days=1)).date().isoformat()\n-        return self._date_nav_url(\'day\', datestr)\n+        return self._date_nav_url("day", datestr)\n \n     @property\n     def today_url(self):\n-        return self._date_nav_url(\'day\')\n+        return self._date_nav_url("day")\n \n     @property\n     def prev_day_url(self):\n         now = self.date or self.now\n         datestr = (now - timedelta(days=1)).date().isoformat()\n-        return self._date_nav_url(\'day\', datestr)\n+        return self._date_nav_url("day", datestr)\n \n     # WEEK NAV\n     @property\n     def next_week_url(self):\n         now = self.date or self.now\n         datestr = (now + timedelta(days=7)).date().isoformat()\n-        return self._date_nav_url(\'week\', datestr)\n+        return self._date_nav_url("week", datestr)\n \n     @property\n     def this_week_url(self):\n-        return self._date_nav_url(\'week\')\n+        return self._date_nav_url("week")\n \n     @property\n     def prev_week_url(self):\n         now = self.date or self.now\n         datestr = (now - timedelta(days=7)).date().isoformat()\n-        return self._date_nav_url(\'week\', datestr)\n+        return self._date_nav_url("week", datestr)\n \n     # MONTH NAV\n     @property\n     def next_month_url(self):\n         now = self.date or self.now\n         last_day = monthrange(now.year, now.month)[1]  # (wkday, days)\n-        datestr = (now.replace(day=last_day) +\n-                   timedelta(days=1)).date().isoformat()\n-        return self._date_nav_url(\'month\', datestr)\n+        datestr = (now.replace(day=last_day) + timedelta(days=1)).date().isoformat()\n+        return self._date_nav_url("month", datestr)\n \n     @property\n     def this_month_url(self):\n-        return self._date_nav_url(\'month\')\n+        return self._date_nav_url("month")\n \n     @property\n     def prev_month_url(self):\n         now = self.date or self.now\n         datestr = (now.replace(day=1) - timedelta(days=1)).date().isoformat()\n-        return self._date_nav_url(\'month\', datestr)\n+        return self._date_nav_url("month", datestr)\n \n \n class EventListingIcal(EventListing):\n@@ -452,6 +465,7 @@ class EventEventListing(EventListing):\n     occurrences batched and navigatable with all the features, the EventListing\n     offers.\n     """\n+\n     def __init__(self, context, request):\n         super(EventEventListing, self).__init__(context, request)\n         self.uid = IUUID(self.context)\ndiff --git a/plone/app/event/browser/event_summary.py b/plone/app/event/browser/event_summary.py\nindex 94735f7a..84b6956d 100644\n--- a/plone/app/event/browser/event_summary.py\n+++ b/plone/app/event/browser/event_summary.py\n@@ -13,13 +13,14 @@\n \n \n class EventSummaryView(BrowserView):\n-\n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n         self.data = IEventAccessor(context)\n         self.max_occurrences = 6\n-        self.excludes = [\'title\', ]\n+        self.excludes = [\n+            "title",\n+        ]\n \n     @property\n     def is_occurrence(self):\n@@ -33,8 +34,7 @@ def event_context(self):\n \n     def formatted_date(self, occ):\n         provider = getMultiAdapter(\n-            (self.context, self.request, self),\n-            IContentProvider, name=\'formatted_date\'\n+            (self.context, self.request, self), IContentProvider, name="formatted_date"\n         )\n         return provider(occ)\n \n@@ -50,8 +50,7 @@ def next_occurrences(self):\n         occurrences = []\n         adapter = IRecurrenceSupport(self.event_context, None)\n         if adapter:\n-            for cnt, occ in enumerate(adapter.occurrences(\n-                    range_start=self.data.start)):\n+            for cnt, occ in enumerate(adapter.occurrences(range_start=self.data.start)):\n                 if cnt == self.max_occurrences:\n                     break\n                 occurrences.append(occ)\n@@ -67,13 +66,13 @@ def num_more_occurrences(self):\n         if not uid:\n             # Might be an occurrence\n             return 0\n-        catalog = getToolByName(self.event_context, \'portal_catalog\')\n+        catalog = getToolByName(self.event_context, "portal_catalog")\n         brains = catalog(UID=uid)\n         if len(brains) == 0:\n             return 0\n         brain = brains[0]  # assuming, that current context is in the catalog\n         idx = catalog.getIndexDataForRID(brain.getRID())\n-        num = len(idx[\'start\']) - len(self.next_occurrences)\n+        num = len(idx["start"]) - len(self.next_occurrences)\n         return num if num > 0 else 0\n \n     @property\n@@ -81,7 +80,7 @@ def more_occurrences_text(self):\n         msgid = _(\n             u"msg_num_more_occurrences",\n             default=u"There are ${results} more occurrences.",\n-            mapping={u"results": self.num_more_occurrences}\n+            mapping={u"results": self.num_more_occurrences},\n         )\n         return self.context.translate(msgid)\n \n@@ -90,4 +89,3 @@ def more_occurrences_text(self):\n     def has_occurrences(self):\n         occs = [o for o in self.next_occurrences if IOccurrence.providedBy(o)]\n         return len(occs)\n-        \n\\ No newline at end of file\ndiff --git a/plone/app/event/browser/event_view.py b/plone/app/event/browser/event_view.py\nindex 15202bd2..ff27002f 100644\n--- a/plone/app/event/browser/event_view.py\n+++ b/plone/app/event/browser/event_view.py\n@@ -5,7 +5,6 @@\n \n \n class EventView(BrowserView):\n-\n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n@@ -15,5 +14,5 @@ def __call__(self):\n         if IOccurrence.providedBy(self.context):\n             # The transient Occurrence objects cannot be edited. disable the\n             # edit border for them.\n-            self.request.set(\'disable_border\', True)\n+            self.request.set("disable_border", True)\n         return self.index()  # render me.\ndiff --git a/plone/app/event/browser/formatted_date.py b/plone/app/event/browser/formatted_date.py\nindex ce133dca..a3af360e 100644\n--- a/plone/app/event/browser/formatted_date.py\n+++ b/plone/app/event/browser/formatted_date.py\n@@ -5,7 +5,7 @@\n \n \n class FormattedDateProvider(Explicit):\n-    template = ViewPageTemplateFile(u\'formatted_date.pt\')\n+    template = ViewPageTemplateFile(u"formatted_date.pt")\n \n     def __init__(self, context, request, view):\n         self.__parent__ = view\n@@ -29,4 +29,4 @@ def __call__(self, occ):\n \n \n class FormattedStartDateProvider(FormattedDateProvider):\n-    template = ViewPageTemplateFile(u\'formatted_start_date.pt\')\n+    template = ViewPageTemplateFile(u"formatted_start_date.pt")\ndiff --git a/plone/app/event/browser/leadimage_viewlet.py b/plone/app/event/browser/leadimage_viewlet.py\nindex 1d923b12..ae88616d 100644\n--- a/plone/app/event/browser/leadimage_viewlet.py\n+++ b/plone/app/event/browser/leadimage_viewlet.py\n@@ -8,7 +8,11 @@ class LeadImageViewlet(ViewletBase):\n     """plone.app.contenttypes LeadImageViewlet for Occurrence contexts, where\n     the image might be defined on the parent object.\n     """\n+\n     def update(self):\n         parent = aq_parent(self.context)\n-        self.available = ILeadImage.providedBy(parent) and\\\n-            True if getattr(parent, \'image\', False) else False\n+        self.available = (\n+            ILeadImage.providedBy(parent) and True\n+            if getattr(parent, "image", False)\n+            else False\n+        )\ndiff --git a/plone/app/event/dx/behaviors.py b/plone/app/event/dx/behaviors.py\nindex f414f080..e57fc902 100644\n--- a/plone/app/event/dx/behaviors.py\n+++ b/plone/app/event/dx/behaviors.py\n@@ -47,64 +47,53 @@ def first_weekday_sun0():\n \n \n class StartBeforeEnd(Invalid):\n-    __doc__ = _("error_invalid_date",\n-                default=u"Invalid start or end date")\n+    __doc__ = _("error_invalid_date", default=u"Invalid start or end date")\n \n \n @provider(IContextAwareDefaultFactory)\n def default_start(context):\n-    """Provide default start for the form.\n-    """\n+    """Provide default start for the form."""\n     return default_start_dt(context)\n \n \n @provider(IContextAwareDefaultFactory)\n def default_end(context):\n-    """Provide default end for the form.\n-    """\n+    """Provide default end for the form."""\n     return default_end_dt(context)\n \n \n class IEventBasic(model.Schema, IDXEvent):\n \n-    """ Basic event schema.\n-    """\n+    """Basic event schema."""\n+\n     start = schema.Datetime(\n-        title=_(\n-            u\'label_event_start\',\n-            default=u\'Event Starts\'\n-        ),\n+        title=_(u"label_event_start", default=u"Event Starts"),\n         description=_(\n-            u\'help_event_start\',\n-            default=u\'Date and Time, when the event begins.\'\n+            u"help_event_start", default=u"Date and Time, when the event begins."\n         ),\n         required=True,\n-        defaultFactory=default_start\n+        defaultFactory=default_start,\n     )\n     directives.widget(\n-        \'start\',\n+        "start",\n         DatetimeFieldWidget,\n         default_timezone=default_timezone,\n-        klass=u\'event_start\'\n+        klass=u"event_start",\n     )\n \n     end = schema.Datetime(\n-        title=_(\n-            u\'label_event_end\',\n-            default=u\'Event Ends\'\n-        ),\n+        title=_(u"label_event_end", default=u"Event Ends"),\n         description=_(\n-            u\'help_event_end\',\n-            default=u\'Date and Time, when the event ends.\'\n+            u"help_event_end", default=u"Date and Time, when the event ends."\n         ),\n         required=True,\n-        defaultFactory=default_end\n+        defaultFactory=default_end,\n     )\n     directives.widget(\n-        \'end\',\n+        "end",\n         DatetimeFieldWidget,\n         default_timezone=default_timezone,\n-        klass=u\'event_end\',\n+        klass=u"event_end",\n         pattern_options={\n             "behavior": "styled",\n             "after": "input.event_end",\n@@ -113,209 +102,134 @@ class IEventBasic(model.Schema, IDXEvent):\n     )\n \n     whole_day = schema.Bool(\n-        title=_(\n-            u\'label_event_whole_day\',\n-            default=u\'Whole Day\'\n-        ),\n-        description=_(\n-            u\'help_event_whole_day\',\n-            default=u\'Event lasts whole day.\'\n-        ),\n+        title=_(u"label_event_whole_day", default=u"Whole Day"),\n+        description=_(u"help_event_whole_day", default=u"Event lasts whole day."),\n         required=False,\n-        default=False\n-    )\n-    directives.widget(\n-        \'whole_day\',\n-        SingleCheckBoxFieldWidget,\n-        klass=u\'event_whole_day\'\n+        default=False,\n     )\n+    directives.widget("whole_day", SingleCheckBoxFieldWidget, klass=u"event_whole_day")\n \n     open_end = schema.Bool(\n-        title=_(\n-            u\'label_event_open_end\',\n-            default=u\'Open End\'\n-        ),\n-        description=_(\n-            u\'help_event_open_end\',\n-            default=u"This event is open ended."\n-        ),\n+        title=_(u"label_event_open_end", default=u"Open End"),\n+        description=_(u"help_event_open_end", default=u"This event is open ended."),\n         required=False,\n-        default=False\n-    )\n-    directives.widget(\n-        \'open_end\',\n-        SingleCheckBoxFieldWidget,\n-        klass=u\'event_open_end\'\n+        default=False,\n     )\n+    directives.widget("open_end", SingleCheckBoxFieldWidget, klass=u"event_open_end")\n \n     # icalendar event uid\n     sync_uid = schema.TextLine(required=False)\n-    directives.mode(sync_uid=\'hidden\')\n+    directives.mode(sync_uid="hidden")\n \n     @invariant\n     def validate_start_end(data):\n-        if (\n-            data.start\n-            and data.end\n-            and data.start > data.end\n-            and not data.open_end\n-        ):\n+        if data.start and data.end and data.start > data.end and not data.open_end:\n             raise StartBeforeEnd(\n-                _("error_end_must_be_after_start_date",\n-                  default=u"End date must be after start date.")\n+                _(\n+                    "error_end_must_be_after_start_date",\n+                    default=u"End date must be after start date.",\n+                )\n             )\n \n \n class IEventRecurrence(model.Schema, IDXEventRecurrence):\n \n-    """ Recurring Event Schema.\n-    """\n+    """Recurring Event Schema."""\n+\n     recurrence = schema.Text(\n-        title=_(\n-            u\'label_event_recurrence\',\n-            default=u\'Recurrence\'\n-        ),\n+        title=_(u"label_event_recurrence", default=u"Recurrence"),\n         description=_(\n-            u\'help_event_recurrence\',\n-            default=u\'Define the event recurrence rule.\'\n+            u"help_event_recurrence", default=u"Define the event recurrence rule."\n         ),\n         required=False,\n-        default=None\n+        default=None,\n     )\n     directives.widget(\n-        \'recurrence\',\n+        "recurrence",\n         RecurrenceFieldWidget,\n-        start_field=u\'IEventBasic.start\',\n+        start_field=u"IEventBasic.start",\n         first_day=first_weekday_sun0,\n         show_repeat_forever=False,\n-        klass=u\'event_recurrence\'\n+        klass=u"event_recurrence",\n     )\n \n \n class IEventLocation(model.Schema):\n \n-    """ Event Location Schema.\n-    """\n+    """Event Location Schema."""\n+\n     location = schema.TextLine(\n-        title=_(\n-            u\'label_event_location\',\n-            default=u\'Location\'\n-        ),\n-        description=_(\n-            u\'help_event_location\',\n-            default=u\'Location of the event.\'\n-        ),\n+        title=_(u"label_event_location", default=u"Location"),\n+        description=_(u"help_event_location", default=u"Location of the event."),\n         required=False,\n-        default=None\n-    )\n-    directives.widget(\n-        \'location\',\n-        TextFieldWidget,\n-        klass=u\'event_location\'\n+        default=None,\n     )\n+    directives.widget("location", TextFieldWidget, klass=u"event_location")\n \n \n class IEventAttendees(model.Schema):\n \n-    """ Event Attendees Schema.\n-    """\n+    """Event Attendees Schema."""\n+\n     attendees = schema.Tuple(\n-        title=_(\n-            u\'label_event_attendees\',\n-            default=u\'Attendees\'\n-        ),\n-        description=_(\n-            u\'help_event_attendees\',\n-            default=u\'List of attendees.\'\n-        ),\n+        title=_(u"label_event_attendees", default=u"Attendees"),\n+        description=_(u"help_event_attendees", default=u"List of attendees."),\n         value_type=schema.TextLine(),\n         required=False,\n         missing_value=(),\n         default=(),\n     )\n-    directives.widget(\n-        \'attendees\',\n-        TextLinesFieldWidget,\n-        klass=u\'event_attendees\'\n-    )\n+    directives.widget("attendees", TextLinesFieldWidget, klass=u"event_attendees")\n \n \n class IEventContact(model.Schema):\n \n-    """ Event Contact Schema.\n-    """\n+    """Event Contact Schema."""\n+\n     contact_name = schema.TextLine(\n-        title=_(\n-            u\'label_event_contact_name\',\n-            default=u\'Contact Name\'\n-        ),\n+        title=_(u"label_event_contact_name", default=u"Contact Name"),\n         description=_(\n-            u\'help_event_contact_name\',\n-            default=u\'Name of a person to contact about this event.\'\n+            u"help_event_contact_name",\n+            default=u"Name of a person to contact about this event.",\n         ),\n         required=False,\n-        default=None\n-    )\n-    directives.widget(\n-        \'contact_name\',\n-        TextFieldWidget,\n-        klass=u\'event_contact_name\'\n+        default=None,\n     )\n+    directives.widget("contact_name", TextFieldWidget, klass=u"event_contact_name")\n \n     contact_email = schema.TextLine(\n-        title=_(\n-            u\'label_event_contact_email\',\n-            default=u\'Contact E-mail\'\n-        ),\n+        title=_(u"label_event_contact_email", default=u"Contact E-mail"),\n         description=_(\n-            u\'help_event_contact_email\',\n-            default=u\'Email address to contact about this event.\'\n+            u"help_event_contact_email",\n+            default=u"Email address to contact about this event.",\n         ),\n         required=False,\n-        default=None\n-    )\n-    directives.widget(\n-        \'contact_email\',\n-        TextFieldWidget,\n-        klass=u\'event_contact_email\'\n+        default=None,\n     )\n+    directives.widget("contact_email", TextFieldWidget, klass=u"event_contact_email")\n \n     contact_phone = schema.TextLine(\n-        title=_(\n-            u\'label_event_contact_phone\',\n-            default=u\'Contact Phone\'\n-        ),\n+        title=_(u"label_event_contact_phone", default=u"Contact Phone"),\n         description=_(\n-            u\'help_event_contact_phone\',\n-            default=u\'Phone number to contact about this event.\'\n+            u"help_event_contact_phone",\n+            default=u"Phone number to contact about this event.",\n         ),\n         required=False,\n-        default=None\n-    )\n-    directives.widget(\n-        \'contact_phone\',\n-        TextFieldWidget,\n-        klass=u\'event_contact_phone\'\n+        default=None,\n     )\n+    directives.widget("contact_phone", TextFieldWidget, klass=u"event_contact_phone")\n \n     event_url = schema.URI(\n-        title=_(\n-            u\'label_event_url\',\n-            default=u\'Event URL\'\n-        ),\n+        title=_(u"label_event_url", default=u"Event URL"),\n         description=_(\n-            u\'help_event_url\',\n-            default=u\'Web address with more info about the event. \'\n-                    u\'Add http:// for external links.\'\n+            u"help_event_url",\n+            default=u"Web address with more info about the event. "\n+            u"Add http:// for external links.",\n         ),\n         required=False,\n-        default=None\n-    )\n-    directives.widget(\n-        \'event_url\',\n-        TextFieldWidget,\n-        klass=u\'event_url\'\n+        default=None,\n     )\n+    directives.widget("event_url", TextFieldWidget, klass=u"event_url")\n \n \n # Mark these interfaces as form field providers\n@@ -327,10 +241,10 @@ class IEventContact(model.Schema):\n \n \n # Language independent fields\n-alsoProvides(IEventBasic[\'start\'], ILanguageIndependentField)\n-alsoProvides(IEventBasic[\'end\'], ILanguageIndependentField)\n-alsoProvides(IEventBasic[\'whole_day\'], ILanguageIndependentField)\n-alsoProvides(IEventBasic[\'open_end\'], ILanguageIndependentField)\n+alsoProvides(IEventBasic["start"], ILanguageIndependentField)\n+alsoProvides(IEventBasic["end"], ILanguageIndependentField)\n+alsoProvides(IEventBasic["whole_day"], ILanguageIndependentField)\n+alsoProvides(IEventBasic["open_end"], ILanguageIndependentField)\n \n \n # Attribute indexer\n@@ -357,7 +271,7 @@ def end_indexer(obj):\n @indexer(IDXEvent)\n def location_indexer(obj):\n     location_adapter = IEventLocation(obj, None)\n-    location = getattr(location_adapter, \'location\', None)\n+    location = getattr(location_adapter, "location", None)\n     if not location:\n         raise AttributeError\n     return location\n@@ -374,16 +288,17 @@ def sync_uid_indexer(obj):\n \n # Object adapters\n \n+\n @adapter(IDXEvent)\n @implementer(IEventAccessor)\n class EventAccessor(object):\n \n     """Generic event accessor adapter implementation for Dexterity content\n-       objects.\n+    objects.\n     """\n \n     def __init__(self, context):\n-        object.__setattr__(self, \'context\', context)\n+        object.__setattr__(self, "context", context)\n \n         bm = dict(\n             start=IEventBasic,\n@@ -400,7 +315,7 @@ def __init__(self, context):\n             event_url=IEventContact,\n             subjects=ICategorization,\n         )\n-        object.__setattr__(self, \'_behavior_map\', bm)\n+        object.__setattr__(self, "_behavior_map", bm)\n \n     def __getattr__(self, name):\n         bm = self._behavior_map\n@@ -461,7 +376,7 @@ def _recurrence_upcoming_event(self):\n \n     @property\n     def start(self):\n-        if getattr(self.context, \'recurrence\', None):\n+        if getattr(self.context, "recurrence", None):\n             start = self._recurrence_upcoming_event().start\n         else:\n             start = IEventBasic(self.context).start\n@@ -473,11 +388,11 @@ def start(self):\n     @start.setter\n     def start(self, value):\n         value = pydt(value)\n-        self._behavior_map[\'start\'](self.context).start = value\n+        self._behavior_map["start"](self.context).start = value\n \n     @property\n     def end(self):\n-        if getattr(self.context, \'recurrence\', None):\n+        if getattr(self.context, "recurrence", None):\n             end = self._recurrence_upcoming_event().end\n         elif self.open_end:\n             end = IEventBasic(self.context).start\n@@ -491,7 +406,7 @@ def end(self):\n     @end.setter\n     def end(self, value):\n         value = pydt(value)\n-        self._behavior_map[\'end\'](self.context).end = value\n+        self._behavior_map["end"](self.context).end = value\n \n     @property\n     def timezone(self):\n@@ -500,10 +415,10 @@ def timezone(self):\n         (START_TIMEZONENAME, END_TIMEZONENAME).\n         """\n         tz_start = tz_end = None\n-        tz = getattr(IEventBasic(self.context).start, \'tzinfo\', None)\n+        tz = getattr(IEventBasic(self.context).start, "tzinfo", None)\n         if tz:\n             tz_start = tz.zone\n-        tz = getattr(IEventBasic(self.context).end, \'tzinfo\', None)\n+        tz = getattr(IEventBasic(self.context).end, "tzinfo", None)\n         if tz:\n             tz_end = tz.zone\n         return tz_start if tz_start == tz_end else (tz_start, tz_end)\n@@ -511,12 +426,12 @@ def timezone(self):\n     @property\n     def sync_uid(self):\n         # Return externally set sync_uid or Plone\'s UUID + @domain.\n-        sync_uid = getattr(self.context, \'sync_uid\', None)\n+        sync_uid = getattr(self.context, "sync_uid", None)\n         if not sync_uid:\n             # Return internal sync_uid\n             request = getRequest() or {}\n-            domain = request.get(\'HTTP_HOST\', None)\n-            domain = \'@\' + domain if domain else \'\'\n+            domain = request.get("HTTP_HOST", None)\n+            domain = "@" + domain if domain else ""\n             sync_uid = self.uid + domain if self.uid else None\n         return sync_uid\n \n@@ -525,7 +440,7 @@ def sync_uid(self):\n \n     @property\n     def title(self):\n-        return safe_unicode(getattr(self.context, \'title\', None))\n+        return safe_unicode(getattr(self.context, "title", None))\n \n     @title.setter\n     def title(self, value):\n@@ -533,7 +448,7 @@ def title(self, value):\n \n     @property\n     def description(self):\n-        return safe_unicode(getattr(self.context, \'description\', None))\n+        return safe_unicode(getattr(self.context, "description", None))\n \n     @description.setter\n     def description(self, value):\n@@ -551,9 +466,9 @@ def last_modified(self, value):\n \n     @property\n     def text(self):\n-        textvalue = getattr(self.context, \'text\', None)\n+        textvalue = getattr(self.context, "text", None)\n         if textvalue is None:\n-            return u\'\'\n+            return u""\n         return safe_unicode(textvalue.output_relative_to(self.context))\n \n     @text.setter\ndiff --git a/plone/app/event/dx/interfaces.py b/plone/app/event/dx/interfaces.py\nindex 5a58804c..d3935448 100644\n--- a/plone/app/event/dx/interfaces.py\n+++ b/plone/app/event/dx/interfaces.py\n@@ -4,10 +4,8 @@\n \n \n class IDXEvent(IEvent):\n-    """ Marker interface for Dexterity events.\n-    """\n+    """Marker interface for Dexterity events."""\n \n \n class IDXEventRecurrence(IEventRecurrence):\n-    """ Marker interface for recurring Dexterity events.\n-    """\n+    """Marker interface for recurring Dexterity events."""\ndiff --git a/plone/app/event/dx/traverser.py b/plone/app/event/dx/traverser.py\nindex e3134e41..828b0458 100644\n--- a/plone/app/event/dx/traverser.py\n+++ b/plone/app/event/dx/traverser.py\n@@ -15,5 +15,6 @@ class OccurrenceTraverser(DefaultTraverser):\n     """\n \n     def fallbackTraverse(self, request, name):\n-        return DexterityPublishTraverse(\n-            self.context, request).publishTraverse(request, name)\n+        return DexterityPublishTraverse(self.context, request).publishTraverse(\n+            request, name\n+        )\ndiff --git a/plone/app/event/ical/exporter.py b/plone/app/event/ical/exporter.py\nindex aab1d33f..af0ff04d 100644\n--- a/plone/app/event/ical/exporter.py\n+++ b/plone/app/event/ical/exporter.py\n@@ -37,19 +37,18 @@ def construct_icalendar(context, events):\n                    calendar.\n     """\n     cal = icalendar.Calendar()\n-    cal.add(\'prodid\', PRODID)\n-    cal.add(\'version\', VERSION)\n+    cal.add("prodid", PRODID)\n+    cal.add("version", VERSION)\n \n     cal_tz = default_timezone(context)\n     if cal_tz:\n-        cal.add(\'x-wr-timezone\', cal_tz)\n+        cal.add("x-wr-timezone", cal_tz)\n \n     tzmap = {}\n-    if not getattr(events, \'__getitem__\', False):\n+    if not getattr(events, "__getitem__", False):\n         events = [events]\n     for event in events:\n-        if ICatalogBrain.providedBy(event) or\\\n-                IContentListingObject.providedBy(event):\n+        if ICatalogBrain.providedBy(event) or IContentListingObject.providedBy(event):\n             event = event.getObject()\n         if not (IEvent.providedBy(event) or IOccurrence.providedBy(event)):\n             # Must be an event.\n@@ -59,7 +58,7 @@ def construct_icalendar(context, events):\n         # TODO: the standard wants each recurrence to have a valid timezone\n         # definition. sounds decent, but not realizable.\n         if not acc.whole_day:  # whole day events are exported as dates without\n-                               # timezone information\n+            # timezone information\n             if isinstance(tz, tuple):\n                 tz_start, tz_end = tz\n             else:\n@@ -70,20 +69,20 @@ def construct_icalendar(context, events):\n \n     for (tzid, transitions) in tzmap.items():\n         cal_tz = icalendar.Timezone()\n-        cal_tz.add(\'tzid\', tzid)\n-        cal_tz.add(\'x-lic-location\', tzid)\n+        cal_tz.add("tzid", tzid)\n+        cal_tz.add("x-lic-location", tzid)\n \n         for (transition, tzinfo) in transitions.items():\n \n-            if tzinfo[\'dst\']:\n+            if tzinfo["dst"]:\n                 cal_tz_sub = icalendar.TimezoneDaylight()\n             else:\n                 cal_tz_sub = icalendar.TimezoneStandard()\n \n-            cal_tz_sub.add(\'tzname\', tzinfo[\'name\'])\n-            cal_tz_sub.add(\'dtstart\', transition)\n-            cal_tz_sub.add(\'tzoffsetfrom\', tzinfo[\'tzoffsetfrom\'])\n-            cal_tz_sub.add(\'tzoffsetto\', tzinfo[\'tzoffsetto\'])\n+            cal_tz_sub.add("tzname", tzinfo["name"])\n+            cal_tz_sub.add("dtstart", transition)\n+            cal_tz_sub.add("tzoffsetfrom", tzinfo["tzoffsetfrom"])\n+            cal_tz_sub.add("tzoffsetto", tzinfo["tzoffsetto"])\n             # TODO: add rrule\n             # tzi.add(\'rrule\',\n             #         {\'freq\': \'yearly\', \'bymonth\': 10, \'byday\': \'-1su\'})\n@@ -111,12 +110,12 @@ def add_to_zones_map(tzmap, tzid, dt):\n     :rtype: dictionary\n     """\n \n-    if tzid.lower() == \'utc\' or not is_datetime(dt):\n+    if tzid.lower() == "utc" or not is_datetime(dt):\n         # no need to define UTC nor timezones for date objects.\n         return tzmap\n     null = datetime(1, 1, 1)\n     tz = pytz.timezone(tzid)\n-    transitions = getattr(tz, \'_utc_transition_times\', None)\n+    transitions = getattr(tz, "_utc_transition_times", None)\n     if not transitions:\n         return tzmap  # we need transition definitions\n     dtzl = tzdel(utc(dt))\n@@ -128,8 +127,7 @@ def add_to_zones_map(tzmap, tzid, dt):\n     #     datetime, which wouldn\'t create a match within the max-function. this\n     #     way we get the maximum transition time which is smaller than the\n     #     given datetime.\n-    transition = max(transitions,\n-                     key=lambda item: item if item <= dtzl else null)\n+    transition = max(transitions, key=lambda item: item if item <= dtzl else null)\n \n     # get previous transition to calculate tzoffsetfrom\n     idx = transitions.index(transition)\n@@ -142,6 +140,7 @@ def localize(tz, dt):\n             # (dt at beginning of all transitions, see above.)\n             return null\n         return pytz.utc.localize(dt).astimezone(tz)  # naive to utc + localize\n+\n     transition = localize(tz, transition)\n     dtstart = tzdel(transition)  # timezone dtstart must be in local time\n     prev_transition = localize(tz, prev_transition)\n@@ -151,10 +150,10 @@ def localize(tz, dt):\n     if dtstart in tzmap[tzid]:\n         return tzmap  # already there\n     tzmap[tzid][dtstart] = {\n-        \'dst\': transition.dst() > timedelta(0),\n-        \'name\': transition.tzname(),\n-        \'tzoffsetfrom\': prev_transition.utcoffset(),\n-        \'tzoffsetto\': transition.utcoffset(),\n+        "dst": transition.dst() > timedelta(0),\n+        "name": transition.tzname(),\n+        "tzoffsetfrom": prev_transition.utcoffset(),\n+        "tzoffsetto": transition.utcoffset(),\n         # TODO: recurrence rule\n     }\n     return tzmap\n@@ -175,9 +174,8 @@ def calendar_from_container(context):\n     Containerish context like a Folder.\n     """\n     context = aq_inner(context)\n-    path = \'/\'.join(context.getPhysicalPath())\n-    result = get_events(context, ret_mode=RET_MODE_BRAINS,\n-                        expand=False, path=path)\n+    path = "/".join(context.getPhysicalPath())\n+    result = get_events(context, ret_mode=RET_MODE_BRAINS, expand=False, path=path)\n     return construct_icalendar(context, result)\n \n \n@@ -189,14 +187,13 @@ def calendar_from_collection(context):\n     context = aq_inner(context)\n     # The keyword argument brains=False was added to plone.app.contenttypes\n     # after 1.0\n-    result = context.results(batch=False, sort_on=\'start\')\n+    result = context.results(batch=False, sort_on="start")\n     return construct_icalendar(context, result)\n \n \n @implementer(IICalendarEventComponent)\n class ICalendarEventComponent(object):\n-    """Returns an icalendar object of the event.\n-    """\n+    """Returns an icalendar object of the event."""\n \n     def __init__(self, context):\n         self.context = context\n@@ -206,33 +203,33 @@ def __init__(self, context):\n     @property\n     def dtstamp(self):\n         # must be in uc\n-        return {\'value\': utc(datetime.now())}\n+        return {"value": utc(datetime.now())}\n \n     @property\n     def created(self):\n         # must be in uc\n-        return {\'value\': utc(self.event.created)}\n+        return {"value": utc(self.event.created)}\n \n     @property\n     def last_modified(self):\n         # must be in uc\n-        return {\'value\': utc(self.event.last_modified)}\n+        return {"value": utc(self.event.last_modified)}\n \n     @property\n     def uid(self):\n-        return {\'value\': self.event.sync_uid}\n+        return {"value": self.event.sync_uid}\n \n     @property\n     def url(self):\n-        return {\'value\': self.event.url}\n+        return {"value": self.event.url}\n \n     @property\n     def summary(self):\n-        return {\'value\': self.event.title}\n+        return {"value": self.event.title}\n \n     @property\n     def description(self):\n-        return {\'value\': self.event.description}\n+        return {"value": self.event.description}\n \n     @property\n     def dtstart(self):\n@@ -242,7 +239,7 @@ def dtstart(self):\n             # specifies a "DTSTART" property with a DATE value type but no\n             # "DTEND" nor "DURATION" property, the event\'s duration is taken to\n             # be one day.\n-            return {\'value\': self.event.start.date()}\n+            return {"value": self.event.start.date()}\n \n         # Normal case + Open End case:\n         # RFC5545, 3.6.1\n@@ -250,7 +247,7 @@ def dtstart(self):\n         # specifies a "DTSTART" property with a DATE-TIME value type but no\n         # "DTEND" property, the event ends on the same calendar date and\n         # time of day specified by the "DTSTART" property.\n-        return {\'value\': self.event.start}\n+        return {"value": self.event.start}\n \n     @property\n     def dtend(self):\n@@ -273,7 +270,7 @@ def dtend(self):\n             # http://stackoverflow.com/questions/1716237/single-day-all-day-appointments-in-ics-files\n             # http://icalevents.com/1778-all-day-events-adding-a-day-or-not/\n             # http://www.innerjoin.org/iCalendar/all-day-events.html\n-            return {\'value\': self.event.end.date() + timedelta(days=1)}\n+            return {"value": self.event.end.date() + timedelta(days=1)}\n \n         elif self.event.open_end:\n             # RFC5545, 3.6.1\n@@ -283,7 +280,7 @@ def dtend(self):\n             # time of day specified by the "DTSTART" property.\n             return None\n \n-        return {\'value\': self.event.end}\n+        return {"value": self.event.end}\n \n     @property\n     def recurrence(self):\n@@ -292,14 +289,13 @@ def recurrence(self):\n \n         ret = []\n         for recdef in self.event.recurrence.split():\n-            prop, val = recdef.split(\':\')\n-            if prop == \'RRULE\':\n-                ret.append({\n-                    \'property\': prop,\n-                    \'value\': icalendar.prop.vRecur.from_ical(val)\n-                })\n-\n-            elif prop in (\'EXDATE\', \'RDATE\'):\n+            prop, val = recdef.split(":")\n+            if prop == "RRULE":\n+                ret.append(\n+                    {"property": prop, "value": icalendar.prop.vRecur.from_ical(val)}\n+                )\n+\n+            elif prop in ("EXDATE", "RDATE"):\n                 factory = icalendar.prop.vDDDLists\n \n                 # localize ex/rdate\n@@ -317,16 +313,13 @@ def recurrence(self):\n                     # TODO: REMOVE this workaround, once this failure is\n                     # fixed in recurrence widget.\n                     continue\n-                ret.append({\n-                    \'property\': prop,\n-                    \'value\': dtlist\n-                })\n+                ret.append({"property": prop, "value": dtlist})\n \n         return ret\n \n     @property\n     def location(self):\n-        return {\'value\': self.event.location}\n+        return {"value": self.event.location}\n \n     @property\n     def attendee(self):\n@@ -334,10 +327,10 @@ def attendee(self):\n         ret = []\n         for attendee in self.event.attendees or []:\n             att = icalendar.prop.vCalAddress(attendee)\n-            att.params[\'cn\'] = icalendar.prop.vText(attendee)\n-            att.params[\'ROLE\'] = icalendar.prop.vText(\'REQ-PARTICIPANT\')\n+            att.params["cn"] = icalendar.prop.vText(attendee)\n+            att.params["ROLE"] = icalendar.prop.vText("REQ-PARTICIPANT")\n             ret.append(att)\n-        return {\'value\': ret}\n+        return {"value": ret}\n \n     @property\n     def contact(self):\n@@ -352,7 +345,7 @@ def contact(self):\n         if event.event_url:\n             cn.append(event.event_url)\n \n-        return {\'value\': u\', \'.join(cn)}\n+        return {"value": u", ".join(cn)}\n \n     @property\n     def categories(self):\n@@ -360,12 +353,11 @@ def categories(self):\n         for cat in self.event.subjects or []:\n             ret.append(cat)\n         if ret:\n-            return {\'value\': ret}\n+            return {"value": ret}\n \n     @property\n     def geo(self):\n-        """Not implemented.\n-        """\n+        """Not implemented."""\n         return\n \n     def ical_add(self, prop, val):\n@@ -376,40 +368,39 @@ def ical_add(self, prop, val):\n             val = [val]\n \n         for _val in val:\n-            assert(isinstance(_val, dict))\n-            value = _val[\'value\']\n+            assert isinstance(_val, dict)\n+            value = _val["value"]\n             if not value:\n                 continue\n-            prop = _val.get(\'property\', prop)\n-            params = _val.get(\'parameters\', None)\n+            prop = _val.get("property", prop)\n+            params = _val.get("parameters", None)\n             self.ical.add(prop, value, params)\n \n     def to_ical(self):\n         # TODO: event.text\n \n         ical_add = self.ical_add\n-        ical_add(\'dtstamp\', self.dtstamp)\n-        ical_add(\'created\', self.created)\n-        ical_add(\'last-modified\', self.last_modified)\n-        ical_add(\'uid\', self.uid)\n-        ical_add(\'url\', self.url)\n-        ical_add(\'summary\', self.summary)\n-        ical_add(\'description\', self.description)\n-        ical_add(\'dtstart\', self.dtstart)\n-        ical_add(\'dtend\', self.dtend)\n+        ical_add("dtstamp", self.dtstamp)\n+        ical_add("created", self.created)\n+        ical_add("last-modified", self.last_modified)\n+        ical_add("uid", self.uid)\n+        ical_add("url", self.url)\n+        ical_add("summary", self.summary)\n+        ical_add("description", self.description)\n+        ical_add("dtstart", self.dtstart)\n+        ical_add("dtend", self.dtend)\n         ical_add(None, self.recurrence)  # property key set via val\n-        ical_add(\'location\', self.location)\n-        ical_add(\'attendee\', self.attendee)\n-        ical_add(\'contact\', self.contact)\n-        ical_add(\'categories\', self.categories)\n-        ical_add(\'geo\', self.geo)\n+        ical_add("location", self.location)\n+        ical_add("attendee", self.attendee)\n+        ical_add("contact", self.contact)\n+        ical_add("categories", self.categories)\n+        ical_add("geo", self.geo)\n \n         return self.ical\n \n \n class EventsICal(BrowserView):\n-    """Returns events in iCal format.\n-    """\n+    """Returns events in iCal format."""\n \n     def get_ical_string(self):\n         cal = IICalendar(self.context)\n@@ -417,11 +408,10 @@ def get_ical_string(self):\n \n     def __call__(self):\n         ical = self.get_ical_string()\n-        name = \'{0}.ics\'.format(self.context.getId())\n-        self.request.response.setHeader(\'Content-Type\', \'text/calendar\')\n+        name = "{0}.ics".format(self.context.getId())\n+        self.request.response.setHeader("Content-Type", "text/calendar")\n         self.request.response.setHeader(\n-            \'Content-Disposition\',\n-            \'attachment; filename="{0}"\'.format(name)\n+            "Content-Disposition", \'attachment; filename="{0}"\'.format(name)\n         )\n-        self.request.response.setHeader(\'Content-Length\', len(ical))\n+        self.request.response.setHeader("Content-Length", len(ical))\n         self.request.response.write(ical)\ndiff --git a/plone/app/event/ical/importer.py b/plone/app/event/ical/importer.py\nindex a6eeb71c..1ce1600f 100644\n--- a/plone/app/event/ical/importer.py\n+++ b/plone/app/event/ical/importer.py\n@@ -37,19 +37,17 @@\n import transaction\n \n \n-def ical_import(container, ics_resource, event_type,\n-                sync_strategy=base.SYNC_KEEP_NEWER):\n+def ical_import(\n+    container, ics_resource, event_type, sync_strategy=base.SYNC_KEEP_NEWER\n+):\n     cal = icalendar.Calendar.from_ical(ics_resource)\n-    events = cal.walk(\'VEVENT\')\n+    events = cal.walk("VEVENT")\n \n-    cat = getToolByName(container, \'portal_catalog\')\n-    container_path = \'/\'.join(container.getPhysicalPath())\n+    cat = getToolByName(container, "portal_catalog")\n+    container_path = "/".join(container.getPhysicalPath())\n \n     def _get_by_sync_uid(uid):\n-        return cat(\n-            sync_uid=uid,\n-            path={\'query\': container_path, \'depth\': 1}\n-        )\n+        return cat(sync_uid=uid, path={"query": container_path, "depth": 1})\n \n     def _get_prop(prop, item, default=None):\n         ret = default\n@@ -73,21 +71,21 @@ def _from_list(ical, prop):\n         # Zip multiple lines into one, since jquery.recurrenceinput.js does\n         # not support multiple lines here\n         # https://github.com/collective/jquery.recurrenceinput.js/issues/15\n-        ret = \'\'\n+        ret = ""\n         for item in val:\n-            ret = \'%s,\' % ret if ret else ret  # insert linebreak\n+            ret = "%s," % ret if ret else ret  # insert linebreak\n             ical_val = item.to_ical()\n             if six.PY3 and isinstance(ical_val, six.binary_type):\n-                ical_val = ical_val.decode(\'utf8\')\n-            ret = \'%s%s\' % (ret, ical_val)\n-        return \'%s:%s\' % (prop, ret) if ret else None\n+                ical_val = ical_val.decode("utf8")\n+            ret = "%s%s" % (ret, ical_val)\n+        return "%s:%s" % (prop, ret) if ret else None\n \n     count = 0\n     for item in events:\n-        start = _get_prop(\'DTSTART\', item)\n-        end = _get_prop(\'DTEND\', item)\n+        start = _get_prop("DTSTART", item)\n+        end = _get_prop("DTEND", item)\n         if not end:\n-            duration = _get_prop(\'DURATION\', item)\n+            duration = _get_prop("DURATION", item)\n             if duration:\n                 end = start + duration\n             # else: whole day or open end\n@@ -112,47 +110,47 @@ def _from_list(ical, prop):\n             # Open end event, see RFC 5545, 3.6.1\n             open_end = True\n             end = base.dt_end_of_day(date_to_datetime(start))\n-        assert(is_datetime(start))\n-        assert(is_datetime(end))\n+        assert is_datetime(start)\n+        assert is_datetime(end)\n \n         # Set timezone, if not already set\n         tz = base.default_timezone(container, as_tzinfo=True)\n-        if not getattr(start, \'tzinfo\', False):\n+        if not getattr(start, "tzinfo", False):\n             start = tz.localize(start)\n-        if not getattr(end, \'tzinfo\', False):\n+        if not getattr(end, "tzinfo", False):\n             end = tz.localize(end)\n \n-        title = _get_prop(\'SUMMARY\', item)\n-        description = _get_prop(\'DESCRIPTION\', item)\n-        location = _get_prop(\'LOCATION\', item)\n+        title = _get_prop("SUMMARY", item)\n+        description = _get_prop("DESCRIPTION", item)\n+        location = _get_prop("LOCATION", item)\n \n-        url = _get_prop(\'URL\', item)\n+        url = _get_prop("URL", item)\n \n-        rrule = _get_prop(\'RRULE\', item)\n-        rrule = rrule.to_ical() if rrule else \'\'\n+        rrule = _get_prop("RRULE", item)\n+        rrule = rrule.to_ical() if rrule else ""\n         if rrule:\n             if six.PY3 and isinstance(rrule, six.binary_type):\n-                rrule = rrule.decode(\'utf8\')\n-            rrule = \'RRULE:%s\' % rrule\n-        rdates = _from_list(item, \'RDATE\')\n-        exdates = _from_list(item, \'EXDATE\')\n-        rrule = \'\\n\'.join([it for it in [rrule, rdates, exdates] if it])\n+                rrule = rrule.decode("utf8")\n+            rrule = "RRULE:%s" % rrule\n+        rdates = _from_list(item, "RDATE")\n+        exdates = _from_list(item, "EXDATE")\n+        rrule = "\\n".join([it for it in [rrule, rdates, exdates] if it])\n \n         # TODO: attendee-lists are not decoded properly and contain only\n         # vCalAddress values\n-        attendees = item.get(\'ATTENDEE\', ())\n+        attendees = item.get("ATTENDEE", ())\n \n-        contact = _get_prop(\'CONTACT\', item)\n-        categories = item.get(\'CATEGORIES\', ())\n-        if getattr(categories, \'__iter__\', False):\n+        contact = _get_prop("CONTACT", item)\n+        categories = item.get("CATEGORIES", ())\n+        if getattr(categories, "__iter__", False):\n             categories = tuple([safe_unicode(it) for it in categories])\n \n-        ext_modified = utc(_get_prop(\'LAST-MODIFIED\', item))\n+        ext_modified = utc(_get_prop("LAST-MODIFIED", item))\n \n         content = None\n         new_content_id = None\n         existing_event = None\n-        sync_uid = _get_prop(\'UID\', item)\n+        sync_uid = _get_prop("UID", item)\n         if sync_uid and sync_strategy is not base.SYNC_NONE:\n             existing_event = _get_by_sync_uid(sync_uid)\n         if existing_event:\n@@ -163,8 +161,9 @@ def _from_list(ical, prop):\n             exist_event = existing_event[0].getObject()\n             acc = IEventAccessor(exist_event)\n \n-            if sync_strategy == base.SYNC_KEEP_NEWER and\\\n-                    (not ext_modified or acc.last_modified > ext_modified):\n+            if sync_strategy == base.SYNC_KEEP_NEWER and (\n+                not ext_modified or acc.last_modified > ext_modified\n+            ):\n                 # Update only if modified date was passed in and it is not\n                 # older than the current modified date.  The client is not\n                 # expected to update the "last-modified" property, it is the\n@@ -178,13 +177,12 @@ def _from_list(ical, prop):\n             content = exist_event\n         else:\n             new_content_id = str(random.randint(0, 99999999))\n-            container.invokeFactory(event_type,\n-                                    id=new_content_id,\n-                                    title=title,\n-                                    description=description)\n+            container.invokeFactory(\n+                event_type, id=new_content_id, title=title, description=description\n+            )\n             content = container[new_content_id]\n \n-        assert(content)  # At this point, a content must be available.\n+        assert content  # At this point, a content must be available.\n \n         event = IEventAccessor(content)\n         event.title = title\n@@ -221,7 +219,7 @@ def _from_list(ical, prop):\n \n         count += 1\n \n-    return {\'count\': count}\n+    return {"count": count}\n \n \n def no_file_protocol_url(value):\n@@ -237,39 +235,39 @@ def no_file_protocol_url(value):\n class IIcalendarImportSettings(Interface):\n \n     event_type = schema.Choice(\n-        title=_(\'ical_import_event_type_title\', default=u\'Event Type\'),\n+        title=_("ical_import_event_type_title", default=u"Event Type"),\n         description=_(\n-            \'ical_import_event_type_desc\',\n+            "ical_import_event_type_desc",\n             default=u"Content type of the event, which is created when "\n-                    u"importing icalendar resources."),\n-        vocabulary=\'plone.app.vocabularies.ReallyUserFriendlyTypes\',\n-        required=True\n+            u"importing icalendar resources.",\n+        ),\n+        vocabulary="plone.app.vocabularies.ReallyUserFriendlyTypes",\n+        required=True,\n     )\n \n     ical_url = schema.URI(\n-        title=_(\'ical_import_url_title\', default=u\'Icalendar URL\'),\n+        title=_("ical_import_url_title", default=u"Icalendar URL"),\n         description=_(\n-            \'ical_import_url_desc\',\n-            default=u"URL to an external icalendar resource file."),\n+            "ical_import_url_desc",\n+            default=u"URL to an external icalendar resource file.",\n+        ),\n         constraint=no_file_protocol_url,\n-        required=False\n+        required=False,\n     )\n \n     ical_file = NamedFile(\n-        title=_(\'ical_import_file_title\', default=u"Icalendar File"),\n+        title=_("ical_import_file_title", default=u"Icalendar File"),\n         description=_(\n-            \'ical_import_file_desc\',\n-            default=u"Icalendar resource file, if no URL is given."),\n-        required=False\n+            "ical_import_file_desc",\n+            default=u"Icalendar resource file, if no URL is given.",\n+        ),\n+        required=False,\n     )\n \n     sync_strategy = schema.Choice(\n-        title=_(\n-            \'ical_import_sync_strategy_title\',\n-            default=u"Synchronization Strategy"\n-        ),\n+        title=_("ical_import_sync_strategy_title", default=u"Synchronization Strategy"),\n         description=_(\n-            \'ical_import_sync_strategy_desc\',\n+            "ical_import_sync_strategy_desc",\n             default=u"""Defines how to synchronize:\n 1) "Keep newer": Import, if the imported event is modified after the existing\n    one.\n@@ -277,18 +275,19 @@ class IIcalendarImportSettings(Interface):\n 3) "Keep theirs": On conflicts, update the existing event with the external\n    one.\n 4) "No Syncing": Don\'t synchronize but import events and create new ones, even\n-    if they already exist. For each one, create a new sync_uid."""),\n-        vocabulary=\'plone.app.event.SynchronizationStrategies\',\n+    if they already exist. For each one, create a new sync_uid.""",\n+        ),\n+        vocabulary="plone.app.event.SynchronizationStrategies",\n         required=True,\n-        default=base.SYNC_KEEP_NEWER\n+        default=base.SYNC_KEEP_NEWER,\n     )\n \n \n @adapter(IFolder)\n @implementer(IIcalendarImportSettings)\n class IcalendarImportSettings(AnnotationAdapter):\n-    """Annotation Adapter for IIcalendarImportSettings.\n-    """\n+    """Annotation Adapter for IIcalendarImportSettings."""\n+\n     ANNOTATION_KEY = "icalendar_import_settings"\n \n \n@@ -299,18 +298,18 @@ class IcalendarImportSettingsForm(form.Form):\n     def getContent(self):\n         data = {}\n         settings = IIcalendarImportSettings(self.context)\n-        data[\'event_type\'] = settings.event_type\n-        data[\'ical_url\'] = settings.ical_url\n-        data[\'sync_strategy\'] = settings.sync_strategy\n+        data["event_type"] = settings.event_type\n+        data["ical_url"] = settings.ical_url\n+        data["sync_strategy"] = settings.sync_strategy\n         return data\n \n     def save_data(self, data):\n         settings = IIcalendarImportSettings(self.context)\n-        settings.ical_url = data[\'ical_url\']\n-        settings.event_type = data[\'event_type\']\n-        settings.sync_strategy = data[\'sync_strategy\']\n+        settings.ical_url = data["ical_url"]\n+        settings.event_type = data["event_type"]\n+        settings.sync_strategy = data["sync_strategy"]\n \n-    @button.buttonAndHandler(u\'Save\')\n+    @button.buttonAndHandler(u"Save")\n     def handleSave(self, action):\n         data, errors = self.extractData()\n         if errors:\n@@ -319,12 +318,12 @@ def handleSave(self, action):\n         self.save_data(data)\n \n         IStatusMessage(self.request).addStatusMessage(\n-            _(\'msg_ical_import_settings_saved\',\n-              default=u"Ical import settings saved."), \'info\'\n+            _("msg_ical_import_settings_saved", default=u"Ical import settings saved."),\n+            "info",\n         )\n         self.request.response.redirect(self.context.absolute_url())\n \n-    @button.buttonAndHandler(u\'Save and Import\')\n+    @button.buttonAndHandler(u"Save and Import")\n     def handleSaveImport(self, action):\n         data, errors = self.extractData()\n         if errors:\n@@ -332,10 +331,10 @@ def handleSaveImport(self, action):\n \n         self.save_data(data)\n \n-        ical_file = data[\'ical_file\']\n-        ical_url = data[\'ical_url\']\n-        event_type = data[\'event_type\']\n-        sync_strategy = data[\'sync_strategy\']\n+        ical_file = data["ical_file"]\n+        ical_url = data["ical_url"]\n+        event_type = data["event_type"]\n+        sync_strategy = data["sync_strategy"]\n \n         if ical_file or ical_url:\n \n@@ -354,29 +353,35 @@ def handleSaveImport(self, action):\n                 sync_strategy=sync_strategy,\n             )\n \n-            count = import_metadata[\'count\']\n+            count = import_metadata["count"]\n \n             IStatusMessage(self.request).addStatusMessage(\n-                _(\'ical_import_imported\',\n-                  default=u"${num} events imported from ${filename}",\n-                  mapping={\'num\': count, \'filename\': ical_import_from}),\n-                \'info\')\n+                _(\n+                    "ical_import_imported",\n+                    default=u"${num} events imported from ${filename}",\n+                    mapping={"num": count, "filename": ical_import_from},\n+                ),\n+                "info",\n+            )\n \n         else:\n             IStatusMessage(self.request).addStatusMessage(\n-                _(\'ical_import_no_ics\',\n-                  default=u"Please provide either a icalendar ics file or a "\n-                          u"URL to a file."), \'error\')\n+                _(\n+                    "ical_import_no_ics",\n+                    default=u"Please provide either a icalendar ics file or a "\n+                    u"URL to a file.",\n+                ),\n+                "error",\n+            )\n \n         self.request.response.redirect(self.context.absolute_url())\n \n-    @button.buttonAndHandler(u\'Cancel\')\n+    @button.buttonAndHandler(u"Cancel")\n     def handleCancel(self, action):\n         self.request.response.redirect(self.context.absolute_url())\n \n \n class IcalendarImportTool(BrowserView):\n-\n     @property\n     def available(self):\n         return IFolder.providedBy(self.context)\n@@ -394,15 +399,13 @@ class IcalendarImportSettingsFormView(FormWrapper):\n     form = IcalendarImportSettingsForm\n \n     def enable(self):\n-        """Enable icalendar import on this context.\n-        """\n+        """Enable icalendar import on this context."""\n         alsoProvides(self.context, IICalendarImportEnabled)\n-        self.context.reindexObject(idxs=(\'object_provides\'))\n+        self.context.reindexObject(idxs=("object_provides"))\n         self.request.response.redirect(self.context.absolute_url())\n \n     def disable(self):\n-        """Disable icalendar import on this context.\n-        """\n+        """Disable icalendar import on this context."""\n         noLongerProvides(self.context, IICalendarImportEnabled)\n-        self.context.reindexObject(idxs=(\'object_provides\'))\n+        self.context.reindexObject(idxs=("object_provides"))\n         self.request.response.redirect(self.context.absolute_url())\ndiff --git a/plone/app/event/interfaces.py b/plone/app/event/interfaces.py\nindex 64a1f5b1..82262b27 100644\n--- a/plone/app/event/interfaces.py\n+++ b/plone/app/event/interfaces.py\n@@ -3,14 +3,12 @@\n from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n \n \n-ISO_DATE_FORMAT = \'%Y-%m-%d\'\n+ISO_DATE_FORMAT = "%Y-%m-%d"\n \n \n class IBrowserLayer(IDefaultBrowserLayer):\n-    """plone.app.event specific browser layer.\n-    """\n+    """plone.app.event specific browser layer."""\n \n \n class IICalendarImportEnabled(Interface):\n-    """Marker interface for contexts, where icalendar import is enabled.\n-    """\n+    """Marker interface for contexts, where icalendar import is enabled."""\ndiff --git a/plone/app/event/portlets/__init__.py b/plone/app/event/portlets/__init__.py\nindex dd39882f..fe916989 100644\n--- a/plone/app/event/portlets/__init__.py\n+++ b/plone/app/event/portlets/__init__.py\n@@ -13,13 +13,13 @@ def get_calendar_url(context, search_base):\n     if search_base:\n         portal = find_ploneroot(context)\n         if six.PY2 and isinstance(search_base, six.text_type):\n-            search_base = search_base.encode(\'utf8\')\n-        search_base = \'/\'.join(search_base.split(\'/\')[2:])\n+            search_base = search_base.encode("utf8")\n+        search_base = "/".join(search_base.split("/")[2:])\n         calendar_url = portal.unrestrictedTraverse(\n-            search_base.lstrip(\'/\')  # start relative, first slash is omitted\n+            search_base.lstrip("/")  # start relative, first slash is omitted\n         ).absolute_url()\n     else:\n         site_url = find_navroot(context, as_url=True)\n-        calendar_url = \'%s/event_listing\' % site_url\n+        calendar_url = "%s/event_listing" % site_url\n \n     return calendar_url\ndiff --git a/plone/app/event/portlets/portlet_calendar.py b/plone/app/event/portlets/portlet_calendar.py\nindex c8c62e9a..d6017a7e 100644\n--- a/plone/app/event/portlets/portlet_calendar.py\n+++ b/plone/app/event/portlets/portlet_calendar.py\n@@ -35,42 +35,40 @@\n         ISyndicatableCollection as ICollection,\n     )  # noqa\n     from plone.app.contenttypes.interfaces import IFolder\n-    search_base_uid_source = CatalogSource(object_provides={\n-        \'query\': [\n-            ICollection.__identifier__,\n-            IFolder.__identifier__\n-        ],\n-        \'operator\': \'or\'\n-    })\n+\n+    search_base_uid_source = CatalogSource(\n+        object_provides={\n+            "query": [ICollection.__identifier__, IFolder.__identifier__],\n+            "operator": "or",\n+        }\n+    )\n except ImportError:\n     search_base_uid_source = CatalogSource(is_folderish=True)\n     ICollection = None\n \n-PLMF = MessageFactory(\'plonelocales\')\n+PLMF = MessageFactory("plonelocales")\n \n \n class ICalendarPortlet(IPortletDataProvider):\n-    """A portlet displaying a calendar\n-    """\n+    """A portlet displaying a calendar"""\n \n     state = schema.Tuple(\n         title=_(u"Workflow state"),\n         description=_(u"Items in which workflow state to show."),\n         default=None,\n         required=False,\n-        value_type=schema.Choice(\n-            vocabulary="plone.app.vocabularies.WorkflowStates")\n+        value_type=schema.Choice(vocabulary="plone.app.vocabularies.WorkflowStates"),\n     )\n \n     search_base_uid = schema.Choice(\n-        title=_(u\'portlet_label_search_base\', default=u\'Search base\'),\n+        title=_(u"portlet_label_search_base", default=u"Search base"),\n         description=_(\n-            u\'portlet_help_search_base\',\n-            default=u\'Select search base Folder or Collection to search for \'\n-                    u\'events. The URL to to this item will also be used to \'\n-                    u\'link to in calendar searches. If empty, the whole site \'\n-                    u\'will be searched and the event listing view will be \'\n-                    u\'called on the site root.\'\n+            u"portlet_help_search_base",\n+            default=u"Select search base Folder or Collection to search for "\n+            u"events. The URL to to this item will also be used to "\n+            u"link to in calendar searches. If empty, the whole site "\n+            u"will be searched and the event listing view will be "\n+            u"called on the site root.",\n         ),\n         required=False,\n         source=search_base_uid_source,\n@@ -79,7 +77,7 @@ class ICalendarPortlet(IPortletDataProvider):\n \n @implementer(ICalendarPortlet)\n class Assignment(base.Assignment):\n-    title = _(u\'Calendar\')\n+    title = _(u"Calendar")\n \n     # reduce upgrade pain\n     state = None\n@@ -94,15 +92,16 @@ def _uid(self):\n         # \'search_base\' attribute that needs to be converted.\n         path = self.search_base\n         try:\n-            search_base = getSite().unrestrictedTraverse(path.lstrip(\'/\'))\n+            search_base = getSite().unrestrictedTraverse(path.lstrip("/"))\n         except (AttributeError, KeyError, TypeError, NotFound):\n             return\n         return search_base.UID()\n+\n     search_base_uid = ComputedAttribute(_uid, 1)\n \n \n class Renderer(base.Renderer):\n-    render = ViewPageTemplateFile(\'portlet_calendar.pt\')\n+    render = ViewPageTemplateFile("portlet_calendar.pt")\n     _search_base = None\n \n     @property\n@@ -113,7 +112,9 @@ def search_base(self):\n \n     @property\n     def search_base_path(self):\n-        return \'/\'.join(self.search_base.getPhysicalPath()) if self.search_base else None  # noqa\n+        return (\n+            "/".join(self.search_base.getPhysicalPath()) if self.search_base else None\n+        )  # noqa\n \n     def update(self):\n         context = aq_inner(self.context)\n@@ -121,39 +122,40 @@ def update(self):\n         self.calendar_url = get_calendar_url(context, self.search_base_path)\n \n         self.year, self.month = year, month = self.year_month_display()\n-        self.prev_year, self.prev_month = prev_year, prev_month = (\n-            self.get_previous_month(year, month))\n-        self.next_year, self.next_month = next_year, next_month = (\n-            self.get_next_month(year, month))\n-        self.prev_query = \'?month=%s&year=%s\' % (prev_month, prev_year)\n-        self.next_query = \'?month=%s&year=%s\' % (next_month, next_year)\n+        self.prev_year, self.prev_month = (\n+            prev_year,\n+            prev_month,\n+        ) = self.get_previous_month(year, month)\n+        self.next_year, self.next_month = next_year, next_month = self.get_next_month(\n+            year, month\n+        )\n+        self.prev_query = "?month=%s&year=%s" % (prev_month, prev_year)\n+        self.next_query = "?month=%s&year=%s" % (next_month, next_year)\n \n         self.cal = calendar.Calendar(first_weekday())\n-        self._ts = getToolByName(context, \'translation_service\')\n+        self._ts = getToolByName(context, "translation_service")\n         self.month_name = PLMF(\n-            self._ts.month_msgid(month),\n-            default=self._ts.month_english(month)\n+            self._ts.month_msgid(month), default=self._ts.month_english(month)\n         )\n \n         # strftime %w interprets 0 as Sunday unlike the calendar.\n-        strftime_wkdays = [\n-            wkday_to_mon1(day) for day in self.cal.iterweekdays()\n-        ]\n+        strftime_wkdays = [wkday_to_mon1(day) for day in self.cal.iterweekdays()]\n         self.weekdays = [\n-            PLMF(self._ts.day_msgid(day, format=\'s\'),\n-                 default=self._ts.weekday_english(day, format=\'a\'))\n+            PLMF(\n+                self._ts.day_msgid(day, format="s"),\n+                default=self._ts.weekday_english(day, format="a"),\n+            )\n             for day in strftime_wkdays\n         ]\n \n     def year_month_display(self):\n-        """ Return the year and month to display in the calendar.\n-        """\n+        """Return the year and month to display in the calendar."""\n         context = aq_inner(self.context)\n         request = self.request\n \n         # Try to get year and month from request\n-        year = request.get(\'year\', None)\n-        month = request.get(\'month\', None)\n+        year = request.get("year", None)\n+        month = request.get("month", None)\n \n         # Or use current date\n         today = localized_today(context)\n@@ -186,12 +188,11 @@ def get_next_month(self, year, month):\n         return (year, month)\n \n     def date_events_url(self, date):\n-        return \'%s?mode=day&date=%s\' % (self.calendar_url, date)\n+        return "%s?mode=day&date=%s" % (self.calendar_url, date)\n \n     @property\n     def cal_data(self):\n-        """Calendar iterator over weeks and days of the month to display.\n-        """\n+        """Calendar iterator over weeks and days of the month to display."""\n         context = aq_inner(self.context)\n         today = localized_today(context)\n         year, month = self.year_month_display()\n@@ -203,22 +204,24 @@ def cal_data(self):\n         data = self.data\n         query = {}\n         if data.state:\n-            query[\'review_state\'] = data.state\n+            query["review_state"] = data.state\n \n         events = []\n-        query.update(self.request.get(\'contentFilter\', {}))\n+        query.update(self.request.get("contentFilter", {}))\n         if ICollection and ICollection.providedBy(self.search_base):\n             # Whatever sorting is defined, we\'re overriding it.\n             query = queryparser.parseFormquery(\n-                self.search_base, self.search_base.query,\n-                sort_on=\'start\', sort_order=None\n+                self.search_base,\n+                self.search_base.query,\n+                sort_on="start",\n+                sort_order=None,\n             )\n \n             # restrict start/end with those from query, if given.\n-            if \'start\' in query and query[\'start\'] > start:\n-                start = query[\'start\']\n-            if \'end\' in query and query[\'end\'] < end:\n-                end = query[\'end\']\n+            if "start" in query and query["start"] > start:\n+                start = query["start"]\n+            if "end" in query and query["end"] < end:\n+                end = query["end"]\n \n             start, end = _prepare_range(self.search_base, start, end)\n             query.update(start_end_query(start, end))\n@@ -226,16 +229,24 @@ def cal_data(self):\n                 batch=False, brains=True, custom_query=query\n             )\n             events = expand_events(\n-                events, ret_mode=RET_MODE_OBJECTS,\n-                start=start, end=end,\n-                sort=\'start\', sort_reverse=False\n+                events,\n+                ret_mode=RET_MODE_OBJECTS,\n+                start=start,\n+                end=end,\n+                sort="start",\n+                sort_reverse=False,\n             )\n         else:\n             if self.search_base_path:\n-                query[\'path\'] = {\'query\': self.search_base_path}\n-            events = get_events(context, start=start, end=end,\n-                                ret_mode=RET_MODE_OBJECTS,\n-                                expand=True, **query)\n+                query["path"] = {"query": self.search_base_path}\n+            events = get_events(\n+                context,\n+                start=start,\n+                end=end,\n+                ret_mode=RET_MODE_OBJECTS,\n+                expand=True,\n+                **query\n+            )\n \n         cal_dict = construct_calendar(events, start=start, end=end)\n \n@@ -255,29 +266,31 @@ def cal_data(self):\n                     accessor = IEventAccessor(occ)\n                     location = accessor.location\n                     whole_day = accessor.whole_day\n-                    time = accessor.start.time().strftime(\'%H:%M\')\n+                    time = accessor.start.time().strftime("%H:%M")\n                     # TODO: make 24/12 hr format configurable\n                     events_string_list.append(\n-                        u\'{0}{1}{2}{3}\'.format(\n+                        u"{0}{1}{2}{3}".format(\n                             accessor.title,\n-                            u\' {0}\'.format(time) if not whole_day else u\'\',\n-                            u\', \' if not whole_day and location else u\'\',\n-                            u\' {0}\'.format(location) if location else u\'\'\n+                            u" {0}".format(time) if not whole_day else u"",\n+                            u", " if not whole_day and location else u"",\n+                            u" {0}".format(location) if location else u"",\n                         )\n                     )\n \n             caldata[-1].append(\n-                {\'date\': dat,\n-                 \'day\': dat.day,\n-                 \'prev_month\': dat.month < month,\n-                 \'next_month\': dat.month > month,\n-                 \'today\':\n-                    dat.year == today.year and\n-                    dat.month == today.month and\n-                    dat.day == today.day,\n-                 \'date_string\': u"%s-%s-%s" % (dat.year, dat.month, dat.day),\n-                 \'events_string\': u\' | \'.join(events_string_list),\n-                 \'events\': date_events})\n+                {\n+                    "date": dat,\n+                    "day": dat.day,\n+                    "prev_month": dat.month < month,\n+                    "next_month": dat.month > month,\n+                    "today": dat.year == today.year\n+                    and dat.month == today.month\n+                    and dat.day == today.day,\n+                    "date_string": u"%s-%s-%s" % (dat.year, dat.month, dat.day),\n+                    "events_string": u" | ".join(events_string_list),\n+                    "events": date_events,\n+                }\n+            )\n         return caldata\n \n     def nav_pattern_options(self, year, month):\n@@ -285,19 +298,19 @@ def nav_pattern_options(self, year, month):\n         if isinstance(val, bytes):\n             val = val.decode("utf-8")\n \n-        return json.dumps({\n-            \'url\': \'%s/@@render-portlet?portlethash=%s&year=%s&month=%s\' % (\n-                getSite().absolute_url(),\n-                val,\n-                year, month),\n-            \'target\': \'#portletwrapper-%s > *\' % val\n-        })\n+        return json.dumps(\n+            {\n+                "url": "%s/@@render-portlet?portlethash=%s&year=%s&month=%s"\n+                % (getSite().absolute_url(), val, year, month),\n+                "target": "#portletwrapper-%s > *" % val,\n+            }\n+        )\n \n     @property\n     def hash(self):\n         return self.request.form.get(\n-            \'portlethash\',\n-            getattr(self, \'__portlet_metadata__\', {}).get(\'hash\', \'\'))\n+            "portlethash", getattr(self, "__portlet_metadata__", {}).get("hash", "")\n+        )\n \n \n class AddForm(base.AddForm):\n@@ -307,8 +320,8 @@ class AddForm(base.AddForm):\n \n     def create(self, data):\n         return Assignment(\n-            state=data.get(\'state\', None),\n-            search_base_uid=data.get(\'search_base_uid\', None)\n+            state=data.get("state", None),\n+            search_base_uid=data.get("search_base_uid", None),\n         )\n \n \ndiff --git a/plone/app/event/portlets/portlet_events.py b/plone/app/event/portlets/portlet_events.py\nindex fe902e3a..6f0dd8b0 100644\n--- a/plone/app/event/portlets/portlet_events.py\n+++ b/plone/app/event/portlets/portlet_events.py\n@@ -31,8 +31,8 @@\n class IEventsPortlet(IPortletDataProvider):\n \n     count = schema.Int(\n-        title=_(u\'Number of items to display\'),\n-        description=_(u\'How many items to list.\'),\n+        title=_(u"Number of items to display"),\n+        description=_(u"How many items to list."),\n         required=True,\n         default=5,\n         min=1,\n@@ -43,20 +43,18 @@ class IEventsPortlet(IPortletDataProvider):\n         description=_(u"Items in which workflow state to show."),\n         default=None,\n         required=False,\n-        value_type=schema.Choice(\n-            vocabulary="plone.app.vocabularies.WorkflowStates"\n-        )\n+        value_type=schema.Choice(vocabulary="plone.app.vocabularies.WorkflowStates"),\n     )\n \n     search_base_uid = schema.Choice(\n-        title=_(u\'portlet_label_search_base\', default=u\'Search base\'),\n+        title=_(u"portlet_label_search_base", default=u"Search base"),\n         description=_(\n-            u\'portlet_help_search_base\',\n-            default=u\'Select search base Folder or Collection to search for \'\n-                    u\'events. The URL to to this item will also be used to \'\n-                    u\'link to in calendar searches. If empty, the whole site \'\n-                    u\'will be searched and the event listing view will be \'\n-                    u\'called on the site root.\'\n+            u"portlet_help_search_base",\n+            default=u"Select search base Folder or Collection to search for "\n+            u"events. The URL to to this item will also be used to "\n+            u"link to in calendar searches. If empty, the whole site "\n+            u"will be searched and the event listing view will be "\n+            u"called on the site root.",\n         ),\n         required=False,\n         source=search_base_uid_source,\n@@ -70,14 +68,15 @@ class IEventsPortlet(IPortletDataProvider):\n             u" Leave empty to use default (see \'Site\' control panel)."\n         ),\n         required=False,\n-        default=u\'\')\n+        default=u"",\n+    )\n \n     no_thumbs = schema.Bool(\n         title=_(u"Suppress thumbs"),\n-        description=_(\n-            u"If enabled, the portlet will not show thumbs."),\n+        description=_(u"If enabled, the portlet will not show thumbs."),\n         required=False,\n-        default=False)\n+        default=False,\n+    )\n \n \n @implementer(IEventsPortlet)\n@@ -87,8 +86,14 @@ class Assignment(base.Assignment):\n     thumb_scale = None\n     no_thumbs = False\n \n-    def __init__(self, count=5, state=None, search_base_uid=None,\n-                 thumb_scale=None, no_thumbs=False):\n+    def __init__(\n+        self,\n+        count=5,\n+        state=None,\n+        search_base_uid=None,\n+        thumb_scale=None,\n+        no_thumbs=False,\n+    ):\n         self.count = count\n         self.state = state\n         self.search_base_uid = search_base_uid\n@@ -105,16 +110,17 @@ def _uid(self):\n         # \'search_base\' attribute that needs to be converted.\n         path = self.search_base\n         try:\n-            search_base = getSite().unrestrictedTraverse(path.lstrip(\'/\'))\n+            search_base = getSite().unrestrictedTraverse(path.lstrip("/"))\n         except (AttributeError, KeyError, TypeError, NotFound):\n             return\n         return search_base.UID()\n+\n     search_base_uid = ComputedAttribute(_uid, 1)\n \n \n class Renderer(base.Renderer):\n \n-    _template = ViewPageTemplateFile(\'portlet_events.pt\')\n+    _template = ViewPageTemplateFile("portlet_events.pt")\n     _search_base = None\n \n     @property\n@@ -125,13 +131,15 @@ def search_base(self):\n \n     @property\n     def search_base_path(self):\n-        return \'/\'.join(self.search_base.getPhysicalPath()) if self.search_base else None  # noqa\n+        return (\n+            "/".join(self.search_base.getPhysicalPath()) if self.search_base else None\n+        )  # noqa\n \n     def update(self):\n         context = aq_inner(self.context)\n         calendar_url = get_calendar_url(context, self.search_base_path)\n-        self.next_url = \'%s?mode=future\' % calendar_url\n-        self.prev_url = \'%s?mode=past\' % calendar_url\n+        self.next_url = "%s?mode=future" % calendar_url\n+        self.prev_url = "%s?mode=past" % calendar_url\n \n     def render(self):\n         return xhtml_compress(self._template())\n@@ -147,54 +155,60 @@ def events(self):\n \n         query = {}\n         if data.state:\n-            query[\'review_state\'] = data.state\n+            query["review_state"] = data.state\n \n         events = []\n-        query.update(self.request.get(\'contentFilter\', {}))\n+        query.update(self.request.get("contentFilter", {}))\n         if ICollection and ICollection.providedBy(self.search_base):\n             # Whatever sorting is defined, we\'re overriding it.\n             query = queryparser.parseFormquery(\n-                self.search_base, self.search_base.query,\n-                sort_on=\'start\', sort_order=None\n+                self.search_base,\n+                self.search_base.query,\n+                sort_on="start",\n+                sort_order=None,\n             )\n \n             start = None\n-            if \'start\' in query:\n-                start = query[\'start\']\n+            if "start" in query:\n+                start = query["start"]\n             else:\n                 start = localized_now(context)\n \n             end = None\n-            if \'end\' in query:\n-                end = query[\'end\']\n+            if "end" in query:\n+                end = query["end"]\n \n             start, end = _prepare_range(self.search_base, start, end)\n             query.update(start_end_query(start, end))\n             events = self.search_base.results(\n-                batch=False, brains=True, custom_query=query,\n-                limit=data.count\n+                batch=False, brains=True, custom_query=query, limit=data.count\n             )\n             events = expand_events(\n-                events, ret_mode=RET_MODE_ACCESSORS,\n-                start=start, end=end,\n-                sort=\'start\', sort_reverse=False\n+                events,\n+                ret_mode=RET_MODE_ACCESSORS,\n+                start=start,\n+                end=end,\n+                sort="start",\n+                sort_reverse=False,\n             )\n-            events = events[:data.count]  # limit expanded\n+            events = events[: data.count]  # limit expanded\n         else:\n             if self.search_base_path:\n-                query[\'path\'] = {\'query\': self.search_base_path}\n+                query["path"] = {"query": self.search_base_path}\n             events = get_events(\n-                context, start=localized_now(context),\n+                context,\n+                start=localized_now(context),\n                 ret_mode=RET_MODE_ACCESSORS,\n-                expand=True, limit=data.count, **query\n+                expand=True,\n+                limit=data.count,\n+                **query\n             )\n \n         return events\n \n     def formatted_date(self, event):\n         provider = getMultiAdapter(\n-            (self.context, self.request, self),\n-            IContentProvider, name=\'formatted_date\'\n+            (self.context, self.request, self), IContentProvider, name="formatted_date"\n         )\n         return provider(event)\n \n@@ -203,15 +217,14 @@ def thumb_scale(self):\n         Image sizes must fit to value in allowed image sizes.\n         None will suppress thumb.\n         """\n-        if getattr(self.data, \'no_thumbs\', False):\n+        if getattr(self.data, "no_thumbs", False):\n             # Individual setting overrides ...\n             return None\n-        thsize = getattr(self.data, \'thumb_scale\', None)\n+        thsize = getattr(self.data, "thumb_scale", None)\n         if thsize:\n             return thsize\n         registry = getUtility(IRegistry)\n-        settings = registry.forInterface(\n-            ISiteSchema, prefix="plone", check=False)\n+        settings = registry.forInterface(ISiteSchema, prefix="plone", check=False)\n         if settings.no_thumbs_portlet:\n             return None\n         thumb_scale_portlet = settings.thumb_scale_portlet\n@@ -224,9 +237,11 @@ class AddForm(base.AddForm):\n     description = _(u"This portlet lists upcoming Events.")\n \n     def create(self, data):\n-        return Assignment(count=data.get(\'count\', 5),\n-                          state=data.get(\'state\', None),\n-                          search_base_uid=data.get(\'search_base_uid\', None))\n+        return Assignment(\n+            count=data.get("count", 5),\n+            state=data.get("state", None),\n+            search_base_uid=data.get("search_base_uid", None),\n+        )\n \n \n class EditForm(base.EditForm):\ndiff --git a/plone/app/event/recurrence.py b/plone/app/event/recurrence.py\nindex 4ca742e5..e5f46dfa 100644\n--- a/plone/app/event/recurrence.py\n+++ b/plone/app/event/recurrence.py\n@@ -30,8 +30,7 @@\n @adapter(IEventRecurrence)\n @implementer(IRecurrenceSupport)\n class RecurrenceSupport(object):\n-    """IRecurrenceSupport Adapter.\n-    """\n+    """IRecurrenceSupport Adapter."""\n \n     def __init__(self, context):\n         self.context = context\n@@ -60,26 +59,28 @@ def occurrences(self, range_start=None, range_end=None):\n         event = IEventAccessor(self.context)\n \n         # We try to get IEventBasic start without including recurrence\n-        event_start = getattr(self.context, \'start\', None)\n+        event_start = getattr(self.context, "start", None)\n         if not event_start:\n             event_start = event.start\n-        elif getattr(event, \'whole_day\', None):\n+        elif getattr(event, "whole_day", None):\n             event_start = dt_start_of_day(event_start)\n \n         # We get event ends by adding a duration to the start. This way, we\n         # prevent that the start and end lists are of different size if an\n         # event starts before range_start but ends afterwards.\n-        if (getattr(event, \'whole_day\', None) or\n-            getattr(event, \'open_end\', None)):\n+        if getattr(event, "whole_day", None) or getattr(event, "open_end", None):\n             duration = datetime.timedelta(hours=23, minutes=59, seconds=59)\n         else:\n-            event_end = getattr(self.context, \'end\', None)\n+            event_end = getattr(self.context, "end", None)\n             duration = event_end - event_start\n \n-        starts = recurrence_sequence_ical(event_start,\n-                                          recrule=event.recurrence,\n-                                          from_=range_start, until=range_end,\n-                                          duration=duration)\n+        starts = recurrence_sequence_ical(\n+            event_start,\n+            recrule=event.recurrence,\n+            from_=range_start,\n+            until=range_end,\n+            duration=duration,\n+        )\n \n         # XXX potentially occurrence won\'t need to be wrapped anymore\n         # but doing it for backwards compatibility as views/templates\n@@ -93,9 +94,8 @@ def get_obj(start):\n                 # remove it for a valid comparison.\n                 return self.context\n             return Occurrence(\n-                id=str(start.date()),\n-                start=start,\n-                end=start + duration).__of__(self.context)\n+                id=str(start.date()), start=start, end=start + duration\n+            ).__of__(self.context)\n \n         for start in starts:\n             yield get_obj(start)\n@@ -137,20 +137,19 @@ def __init__(self, id, start, end):\n         self.id = id\n         self.start = start\n         self.end = end\n-        self.portal_type = \'Occurrence\'\n+        self.portal_type = "Occurrence"\n \n \n @adapter(IOccurrence)\n @implementer(IEventAccessor)\n class EventOccurrenceAccessor(object):\n-    """Generic event accessor adapter implementation for Occurrence objects.\n-    """\n+    """Generic event accessor adapter implementation for Occurrence objects."""\n \n     def __init__(self, context):\n-        object.__setattr__(self, \'context\', context)\n+        object.__setattr__(self, "context", context)\n \n-        own_attr = [\'start\', \'end\', \'url\']\n-        object.__setattr__(self, \'_own_attr\', own_attr)\n+        own_attr = ["start", "end", "url"]\n+        object.__setattr__(self, "_own_attr", own_attr)\n \n     def _get_context(self, name):\n         # TODO: save parent context on self, so it must not be called every\n@@ -183,6 +182,7 @@ class ImageScalingViewFactory(BrowserView):\n     """Factory for ImageScaling view for Occurrences.\n     Delegates to parent @@images view.\n     """\n+\n     def __new__(cls, context, request):\n         parent = aq_parent(context)\n         if IImageScaleTraversable.providedBy(parent):\ndiff --git a/plone/app/event/setuphandlers.py b/plone/app/event/setuphandlers.py\nindex 5d4be5c9..b2028f16 100644\n--- a/plone/app/event/setuphandlers.py\n+++ b/plone/app/event/setuphandlers.py\n@@ -12,7 +12,6 @@\n \n @implementer(INonInstallable)\n class HiddenProfiles(object):\n-\n     def getNonInstallableProfiles(self):\n         """Prevents profiles, which should not be user-installable from showing\n         up in the profile list when creating a Plone site.\n@@ -20,7 +19,9 @@ def getNonInstallableProfiles(self):\n         plone.app.event:testing .. Testing profile, which provides an\n         example type.\n         """\n-        return [u\'plone.app.event:testing\', ]\n+        return [\n+            u"plone.app.event:testing",\n+        ]\n \n \n def setup_catalog(context):\n@@ -34,35 +35,35 @@ def setup_catalog(context):\n         emptying-the-indexes-td2302709.html\n         https://mail.zope.org/pipermail/zope-cmf/2007-March/025664.html\n     """\n-    if context.readDataFile(\'plone.app.event-default.txt\') is None:\n+    if context.readDataFile("plone.app.event-default.txt") is None:\n         return\n     portal = context.getSite()\n-    catalog = getToolByName(portal, \'portal_catalog\')\n-    date_idxs = [\'start\', \'end\']\n-    field_idxs = [\'sync_uid\']\n+    catalog = getToolByName(portal, "portal_catalog")\n+    date_idxs = ["start", "end"]\n+    field_idxs = ["sync_uid"]\n     idxs = date_idxs + field_idxs\n \n     class extra(object):\n-        recurdef = \'recurrence\'\n-        until = \'\'\n+        recurdef = "recurrence"\n+        until = ""\n \n     _catalog = catalog._catalog\n     for name in idxs:\n         if name in catalog.indexes():\n-            if _catalog.getIndex(name).meta_type == \'DateIndex\':\n+            if _catalog.getIndex(name).meta_type == "DateIndex":\n                 # delete old standard DateIndex\n                 catalog.delIndex(name)\n-                logger.info(\'Old catalog DateIndex %s deleted.\' % name)\n+                logger.info("Old catalog DateIndex %s deleted." % name)\n         if name not in catalog.indexes():\n             if name in date_idxs:\n                 # create new DateRecurringIndex\n-                catalog.addIndex(name, \'DateRecurringIndex\', extra=extra())\n-                logger.info(\'Catalog DateRecurringIndex %s created.\' % name)\n+                catalog.addIndex(name, "DateRecurringIndex", extra=extra())\n+                logger.info("Catalog DateRecurringIndex %s created." % name)\n             elif name in field_idxs:\n-                catalog.addIndex(name, \'FieldIndex\')\n-                logger.info(\'Catalog FieldIndex %s created.\' % name)\n+                catalog.addIndex(name, "FieldIndex")\n+                logger.info("Catalog FieldIndex %s created." % name)\n         try:\n             catalog.addColumn(name)\n-            logger.info(\'Catalog metadata column %s created.\' % name)\n+            logger.info("Catalog metadata column %s created." % name)\n         except CatalogError:\n-            logger.info(\'Catalog metadata column %s already exists.\' % name)\n+            logger.info("Catalog metadata column %s already exists." % name)\ndiff --git a/plone/app/event/testing.py b/plone/app/event/testing.py\nindex 32e08b59..02e2364e 100644\n--- a/plone/app/event/testing.py\n+++ b/plone/app/event/testing.py\n@@ -38,22 +38,22 @@ def set_timezone(tz):\n     if tz is None:\n         return None\n     reg = getUtility(IRegistry)\n-    current_tz = reg.get(\'plone.portal_timezone\', None)\n-    reg[\'plone.portal_timezone\'] = tz\n+    current_tz = reg.get("plone.portal_timezone", None)\n+    reg["plone.portal_timezone"] = tz\n     return current_tz\n \n \n def set_env_timezone(tz):\n     if tz is None:\n-        os.environ.pop(\'TZ\')\n+        os.environ.pop("TZ")\n         return None\n-    current_tz = os.environ.get(\'TZ\', None)\n-    os.environ[\'TZ\'] = tz\n+    current_tz = os.environ.get("TZ", None)\n+    os.environ["TZ"] = tz\n     return current_tz\n \n \n def os_zone():\n-    return os.environ[\'TZ\'] if \'TZ\' in os.environ.keys() else None\n+    return os.environ["TZ"] if "TZ" in os.environ.keys() else None\n \n \n def make_fake_response(request):\n@@ -80,31 +80,32 @@ def setUpZope(self, app, configurationContext):\n         self.ostz = os_zone()\n \n         # Install products that use an old-style initialize() function\n-        installProduct(app, \'Products.DateRecurringIndex\')\n+        installProduct(app, "Products.DateRecurringIndex")\n \n         # Load ZCML\n         import plone.app.event\n+\n         self.loadZCML(package=plone.app.event, context=configurationContext)\n \n     def setUpPloneSite(self, portal):\n-        self.applyProfile(portal, \'plone.app.event:default\')\n-        set_timezone(tz=\'UTC\')\n+        self.applyProfile(portal, "plone.app.event:default")\n+        set_timezone(tz="UTC")\n \n     def tearDownZope(self, app):\n         # Uninstall old-style Products\n-        uninstallProduct(app, \'Products.DateRecurringIndex\')\n+        uninstallProduct(app, "Products.DateRecurringIndex")\n \n         # reset OS TZ\n         if self.ostz:\n-            os.environ[\'TZ\'] = self.ostz\n-        elif \'TZ\' in os.environ:\n-            del os.environ[\'TZ\']\n+            os.environ["TZ"] = self.ostz\n+        elif "TZ" in os.environ:\n+            del os.environ["TZ"]\n \n \n PAEvent_FIXTURE = PAEventLayer()\n PAEvent_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(PAEvent_FIXTURE,),\n-    name="PAEvent:Integration")\n+    bases=(PAEvent_FIXTURE,), name="PAEvent:Integration"\n+)\n \n \n class PAEventDXLayer(PloneSandboxLayer):\n@@ -114,26 +115,27 @@ class PAEventDXLayer(PloneSandboxLayer):\n     def setUpZope(self, app, configurationContext):\n         self.ostz = os_zone()\n         import plone.app.event.dx\n-        self.loadZCML(package=plone.app.event.dx,\n-                      context=configurationContext)\n+\n+        self.loadZCML(package=plone.app.event.dx, context=configurationContext)\n \n     def setUpPloneSite(self, portal):\n-        self.applyProfile(portal, \'plone.app.event:testing\')\n-        set_timezone(tz=\'UTC\')\n+        self.applyProfile(portal, "plone.app.event:testing")\n+        set_timezone(tz="UTC")\n \n \n PAEventDX_FIXTURE = PAEventDXLayer()\n PAEventDX_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(PAEventDX_FIXTURE,),\n-    name="PAEventDX:Integration")\n+    bases=(PAEventDX_FIXTURE,), name="PAEventDX:Integration"\n+)\n # Functional testing needed for tests, with explicit transaction commits.\n PAEventDX_FUNCTIONAL_TESTING = FunctionalTesting(\n-    bases=(PAEventDX_FIXTURE,),\n-    name="PAEventDX:Functional")\n+    bases=(PAEventDX_FIXTURE,), name="PAEventDX:Functional"\n+)\n PAEventDX_ROBOT_TESTING = FunctionalTesting(\n     bases=(\n         PAEventDX_FIXTURE,\n         AUTOLOGIN_LIBRARY_FIXTURE,\n         WSGI_SERVER_FIXTURE,\n     ),\n-    name="plone.app.event.dx:Robot")\n+    name="plone.app.event.dx:Robot",\n+)\ndiff --git a/plone/app/event/tests/INACTIVE_test_robot.py b/plone/app/event/tests/INACTIVE_test_robot.py\nindex 8c5293da..83e5c391 100644\n--- a/plone/app/event/tests/INACTIVE_test_robot.py\n+++ b/plone/app/event/tests/INACTIVE_test_robot.py\n@@ -11,22 +11,21 @@\n def test_suite():\n     suite = unittest.TestSuite()\n     current_dir = os.path.abspath(os.path.dirname(__file__))\n-    robot_dir = os.path.join(current_dir, \'robot\')\n+    robot_dir = os.path.join(current_dir, "robot")\n     robot_tests = [\n-        os.path.join(\'robot\', doc) for doc in\n-        os.listdir(robot_dir) if doc.endswith(\'.robot\')\n-        and doc.startswith(\'test_\')\n+        os.path.join("robot", doc)\n+        for doc in os.listdir(robot_dir)\n+        if doc.endswith(".robot") and doc.startswith("test_")\n     ]\n     for robot_test in robot_tests:\n         robottestsuite = robotsuite.RobotTestSuite(\n             robot_test,\n-            noncritical=[\'unstable\'],\n+            noncritical=["unstable"],\n         )\n         robottestsuite.level = ROBOT_TEST_LEVEL\n-        suite.addTests([\n-            layered(\n-                robottestsuite,\n-                layer=PAEventDX_ROBOT_TESTING\n-            ),\n-        ])\n+        suite.addTests(\n+            [\n+                layered(robottestsuite, layer=PAEventDX_ROBOT_TESTING),\n+            ]\n+        )\n     return suite\ndiff --git a/plone/app/event/tests/base_setup.py b/plone/app/event/tests/base_setup.py\nindex c12f7b3e..2cefd2a2 100644\n--- a/plone/app/event/tests/base_setup.py\n+++ b/plone/app/event/tests/base_setup.py\n@@ -14,12 +14,11 @@\n import unittest\n \n \n-TEST_TIMEZONE = \'Europe/Vienna\'\n+TEST_TIMEZONE = "Europe/Vienna"\n \n \n def patched_now(context=None):\n-    """Patch localized_now to allow stable results in tests.\n-    """\n+    """Patch localized_now to allow stable results in tests."""\n     if not context:\n         context = None\n     tzinfo = pytz.timezone(TEST_TIMEZONE)\n@@ -30,7 +29,7 @@ def patched_now(context=None):\n \n # Patch EventAccessor for IDXEvent to set the correct testing portal type.\n # For custom accessor in addons you would rather do that in an adapter.\n-behaviors.EventAccessor.event_type = \'plone.app.event.dx.event\'\n+behaviors.EventAccessor.event_type = "plone.app.event.dx.event"\n \n \n class AbstractSampleDataEvents(unittest.TestCase):\n@@ -38,11 +37,7 @@ class AbstractSampleDataEvents(unittest.TestCase):\n \n     def event_factory(self, container, **kwargs):\n         # Return the IEventAccessor.create event factory.\n-        return createContentInContainer(\n-            container,\n-            \'plone.app.event.dx.event\',\n-            **kwargs\n-        )\n+        return createContentInContainer(container, "plone.app.event.dx.event", **kwargs)\n \n     def make_dates(self):\n         tz = pytz.timezone(TEST_TIMEZONE)\n@@ -72,87 +67,92 @@ def setUp(self):\n         \'Future Event: 2013-05-15T10:00:00+02:00 - 2013-05-15T11:00:00+02:00\'\n \n         """\n-        self.portal = self.layer[\'portal\']\n-        self.app = self.layer[\'app\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.app = self.layer["app"]\n+        self.request = self.layer["request"]\n         set_browserlayer(self.request)\n         set_timezone(TEST_TIMEZONE)\n \n         now, past, future, far, duration = self.make_dates()\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n-        workflow = getToolByName(self.portal, \'portal_workflow\')\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+        workflow = getToolByName(self.portal, "portal_workflow")\n         workflow.setDefaultChain("simple_publication_workflow")\n \n         factory = self.event_factory\n         self.past_event = factory(\n             container=self.portal,\n-            id=\'past\',\n-            title=u\'Past Event\',\n+            id="past",\n+            title=u"Past Event",\n             start=past,\n             end=past + duration,\n             location=u"Vienna",\n             whole_day=True,\n-            recurrence=\'RRULE:FREQ=DAILY;COUNT=3\')\n-        workflow.doActionFor(self.past_event, \'publish\')\n+            recurrence="RRULE:FREQ=DAILY;COUNT=3",\n+        )\n+        workflow.doActionFor(self.past_event, "publish")\n         # adjust start and end according to whole_day and open_end\n         self.past_event.reindexObject()\n \n         self.now_event = factory(\n             container=self.portal,\n-            id=\'now\',\n-            title=u\'Now Event\',\n+            id="now",\n+            title=u"Now Event",\n             start=now,\n             end=now + duration,\n             location=u"Vienna",\n             recurrence="""RRULE:FREQ=DAILY;COUNT=3;INTERVAL=1\n RDATE:20130509T000000\n EXDATE:20130506T000000,20140404T000000""",\n-            contact_name=\'Auto Testdriver\',\n-            contact_email=\'testdriver@plone.org\',\n-            contact_phone=\'+123456789\',\n-            event_url=\'http://plone.org\',\n-            subject=(\'plone\', \'testing\'))  # change to subjects, once this is\n+            contact_name="Auto Testdriver",\n+            contact_email="testdriver@plone.org",\n+            contact_phone="+123456789",\n+            event_url="http://plone.org",\n+            subject=("plone", "testing"),\n+        )  # change to subjects, once this is\n         # fixed:\n         # https://github.com/plone/plone.dexterity/pull/18\n         # https://github.com/plone/plone.app.dexterity/issues/118\n-        workflow.doActionFor(self.now_event, \'publish\')\n+        workflow.doActionFor(self.now_event, "publish")\n         self.now_event.reindexObject()\n \n         self.future_event = factory(\n             container=self.portal,\n-            id=\'future\',\n-            title=u\'Future Event\',\n+            id="future",\n+            title=u"Future Event",\n             text=RichTextValue(\n-                u\'\xc3\x9cberraschung! Du kannst nach mir suchen\',\n-                \'text/plain\',\n-                \'text/html\',\n+                u"\xc3\x9cberraschung! Du kannst nach mir suchen",\n+                "text/plain",\n+                "text/html",\n             ),\n             start=future,\n             end=future + duration,\n-            location=u\'Graz\')\n-        workflow.doActionFor(self.future_event, \'publish\')\n+            location=u"Graz",\n+        )\n+        workflow.doActionFor(self.future_event, "publish")\n         self.future_event.reindexObject()\n \n-        self.portal.invokeFactory(\'Folder\', \'sub\', title=u\'sub\')\n+        self.portal.invokeFactory("Folder", "sub", title=u"sub")\n         self.long_event = factory(\n             container=self.portal.sub,\n-            id=\'long\',\n-            title=u\'Long Event\',\n+            id="long",\n+            title=u"Long Event",\n             start=past,\n             end=far,\n-            location=u\'Schaftal\')\n-        workflow.doActionFor(self.long_event, \'publish\')\n+            location=u"Schaftal",\n+        )\n+        workflow.doActionFor(self.long_event, "publish")\n         self.long_event.reindexObject()\n \n         # plone.app.contenttypes ICollection type\n-        self.portal.invokeFactory(\'Collection\', \'collection\', title=u\'Col\')\n+        self.portal.invokeFactory("Collection", "collection", title=u"Col")\n         collection = self.portal.collection\n-        collection.sort_on = u\'start\'\n+        collection.sort_on = u"start"\n         collection.reverse_sort = True\n         collection.query = [\n-            {\'i\': \'portal_type\',\n-             \'o\': \'plone.app.querystring.operation.selection.any\',\n-             \'v\': [\'Event\', \'plone.app.event.dx.event\']\n-             },\n+            {\n+                "i": "portal_type",\n+                "o": "plone.app.querystring.operation.selection.any",\n+                "v": ["Event", "plone.app.event.dx.event"],\n+            },\n         ]\n         collection.reindexObject()\ndiff --git a/plone/app/event/tests/test_base_module.py b/plone/app/event/tests/test_base_module.py\nindex dc6adc17..e78430b8 100644\n--- a/plone/app/event/tests/test_base_module.py\n+++ b/plone/app/event/tests/test_base_module.py\n@@ -49,18 +49,17 @@ class TestBaseModule(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def assertEqualDatetime(self, date1, date2, msg=None):\n-        """ Compare two datetime instances to a resolution of minutes.\n-        """\n-        format_ = \'%Y-%m-%d %H:%M %Z\'\n+        """Compare two datetime instances to a resolution of minutes."""\n+        format_ = "%Y-%m-%d %H:%M %Z"\n         self.assertEqual(date1.strftime(format_), date2.strftime(format_), msg)\n \n     def test_default_end(self):\n         self.assertEqualDatetime(\n-            default_end() - timedelta(hours=DEFAULT_END_DELTA),\n-            default_start())\n+            default_end() - timedelta(hours=DEFAULT_END_DELTA), default_start()\n+        )\n \n     def test_default_start(self):\n         now = localized_now().replace(minute=0, second=0, microsecond=0)\n@@ -69,87 +68,81 @@ def test_default_start(self):\n     def test_DT(self):\n         # Python datetime with valid zone. Zope converts it to GMT+1...\n         # TODO: DateTime better shouldn\'t do this!\n-        cet = pytz.timezone(\'CET\')\n+        cet = pytz.timezone("CET")\n         self.assertEqual(\n             DT(datetime(2011, 11, 11, 11, 0, 0, tzinfo=cet)),\n-            DateTime(\'2011/11/11 11:00:00 GMT+1\')\n+            DateTime("2011/11/11 11:00:00 GMT+1"),\n         )\n \n         # Python dates get converted to a DateTime with timecomponent including\n         # a timezone\n-        self.assertEqual(\n-            DT(date(2011, 11, 11)),\n-            DateTime(\'2011/11/11 00:00:00 UTC\')\n-        )\n+        self.assertEqual(DT(date(2011, 11, 11)), DateTime("2011/11/11 00:00:00 UTC"))\n \n         # DateTime with valid zone\n         self.assertEqual(\n-            DT(DateTime(2011, 11, 11, 11, 0, 0, \'Europe/Vienna\')),\n-            DateTime(\'2011/11/11 11:00:00 Europe/Vienna\')\n+            DT(DateTime(2011, 11, 11, 11, 0, 0, "Europe/Vienna")),\n+            DateTime("2011/11/11 11:00:00 Europe/Vienna"),\n         )\n \n         # Zope DateTime with valid DateTime zone but invalid pytz is kept as is\n         self.assertEqual(\n-            DT(DateTime(2011, 11, 11, 11, 0, 0, \'GMT+1\')),\n-            DateTime(\'2011/11/11 11:00:00 GMT+1\')\n+            DT(DateTime(2011, 11, 11, 11, 0, 0, "GMT+1")),\n+            DateTime("2011/11/11 11:00:00 GMT+1"),\n         )\n \n         # Invalid datetime zones are converted to the portal timezone\n         # Testing with no timezone\n         self.assertEqual(\n-            DT(datetime(2011, 11, 11, 11, 0, 0)),\n-            DateTime(\'2011/11/11 11:00:00 UTC\')\n+            DT(datetime(2011, 11, 11, 11, 0, 0)), DateTime("2011/11/11 11:00:00 UTC")\n         )\n \n         # Conversion from string\n         self.assertEqual(\n-            DT(\'2011/11/11 11:00:00 Europe/Vienna\'),\n-            DateTime(\'2011/11/11 11:00:00 Europe/Vienna\')\n+            DT("2011/11/11 11:00:00 Europe/Vienna"),\n+            DateTime("2011/11/11 11:00:00 Europe/Vienna"),\n         )\n \n         # TEST WITH/WITHOUT MICROSECONDS\n \n         # From Python datetime\n \n-        tz = pytz.timezone(\'Europe/Vienna\')\n+        tz = pytz.timezone("Europe/Vienna")\n \n         # exact=False\n         self.assertEqual(\n-            DT(datetime(2012, 12, 12, 10, 10, 10, 123456,\n-               tzinfo=tz), exact=False),\n-            DateTime(\'2012/12/12 10:10:10 Europe/Vienna\')\n+            DT(datetime(2012, 12, 12, 10, 10, 10, 123456, tzinfo=tz), exact=False),\n+            DateTime("2012/12/12 10:10:10 Europe/Vienna"),\n         )\n \n         # exact=True\n         self.assertEqual(\n-            DT(datetime(2012, 12, 12, 10, 10, 10, 123456,\n-               tzinfo=tz), exact=True),\n-            DateTime(\'2012/12/12 10:10:10.123456 Europe/Vienna\')\n+            DT(datetime(2012, 12, 12, 10, 10, 10, 123456, tzinfo=tz), exact=True),\n+            DateTime("2012/12/12 10:10:10.123456 Europe/Vienna"),\n         )\n \n         # From Zope DateTime\n \n         # Exact=False\n         self.assertEqual(\n-            DT(DateTime(2012, 12, 12, 10, 10, 10.123456, \'Europe/Vienna\'),\n-               exact=False),\n-            DateTime(\'2012/12/12 10:10:10 Europe/Vienna\')\n+            DT(DateTime(2012, 12, 12, 10, 10, 10.123456, "Europe/Vienna"), exact=False),\n+            DateTime("2012/12/12 10:10:10 Europe/Vienna"),\n         )\n \n         # Exact=True\n         self.assertEqual(\n-            DT(DateTime(2012, 12, 12, 10, 10, 10.123456, \'Europe/Vienna\'),\n-               exact=True),\n-            DateTime(\'2012/12/12 10:10:10.123456 Europe/Vienna\')\n+            DT(DateTime(2012, 12, 12, 10, 10, 10.123456, "Europe/Vienna"), exact=True),\n+            DateTime("2012/12/12 10:10:10.123456 Europe/Vienna"),\n         )\n \n     def test_wkday_to_mon1(self):\n         from plone.app.event.base import wkday_to_mon1\n+\n         li = [wkday_to_mon1(day) for day in range(0, 7)]\n         self.assertEqual(li, [1, 2, 3, 4, 5, 6, 0])\n \n     def test_wkday_to_mon0(self):\n         from plone.app.event.base import wkday_to_mon0\n+\n         li = [wkday_to_mon0(day) for day in range(0, 7)]\n         self.assertEqual(li, [6, 0, 1, 2, 3, 4, 5])\n \n@@ -162,24 +155,24 @@ def test__default_timezone(self):\n \n     def test__dt_start_of_day(self):\n         from plone.app.event.base import dt_start_of_day\n+\n         self.assertEqual(\n             dt_start_of_day(datetime(2013, 2, 1, 18, 35)),\n-            datetime(2013, 2, 1, 0, 0, 0, 0)\n+            datetime(2013, 2, 1, 0, 0, 0, 0),\n         )\n         self.assertEqual(\n-            dt_start_of_day(date(2013, 2, 1)),\n-            datetime(2013, 2, 1, 0, 0, 0, 0)\n+            dt_start_of_day(date(2013, 2, 1)), datetime(2013, 2, 1, 0, 0, 0, 0)\n         )\n \n     def test__dt_end_of_day(self):\n         from plone.app.event.base import dt_end_of_day\n+\n         self.assertEqual(\n             dt_end_of_day(datetime(2013, 2, 1, 18, 35)),\n-            datetime(2013, 2, 1, 23, 59, 59, 0)\n+            datetime(2013, 2, 1, 23, 59, 59, 0),\n         )\n         self.assertEqual(\n-            dt_end_of_day(date(2013, 2, 1)),\n-            datetime(2013, 2, 1, 23, 59, 59, 0)\n+            dt_end_of_day(date(2013, 2, 1)), datetime(2013, 2, 1, 23, 59, 59, 0)\n         )\n \n     def test__start_end_from_mode(self):\n@@ -188,65 +181,79 @@ def test__start_end_from_mode(self):\n \n         # ALL\n         #\n-        start, end = start_end_from_mode(\'all\')\n+        start, end = start_end_from_mode("all")\n         self.assertTrue(start is None and end is None)\n \n         # PAST\n         #\n-        start, end = start_end_from_mode(\'past\')\n+        start, end = start_end_from_mode("past")\n         self.assertTrue(start is None and isinstance(end, datetime))\n \n         # FUTURE\n         #\n-        start, end = start_end_from_mode(\'future\')\n+        start, end = start_end_from_mode("future")\n         self.assertTrue(isinstance(start, datetime) and end is None)\n \n         # NOW\n         #\n-        start, end = start_end_from_mode(\'now\')\n+        start, end = start_end_from_mode("now")\n         self.assertTrue(\n-            isinstance(start, datetime) and\n-            isinstance(end, datetime) and\n-            end.hour == 23 and end.minute == 59 and end.second == 59\n+            isinstance(start, datetime)\n+            and isinstance(end, datetime)\n+            and end.hour == 23\n+            and end.minute == 59\n+            and end.second == 59\n         )\n \n         # 7DAYS\n         #\n-        start, end = start_end_from_mode(\'7days\')\n+        start, end = start_end_from_mode("7days")\n         self.assertTrue(\n-            isinstance(start, datetime) and\n-            isinstance(end, datetime) and\n-            end == dt_end_of_day(start + timedelta(days=6))\n+            isinstance(start, datetime)\n+            and isinstance(end, datetime)\n+            and end == dt_end_of_day(start + timedelta(days=6))\n         )\n \n         # TODAY\n         #\n-        start, end = start_end_from_mode(\'today\')\n+        start, end = start_end_from_mode("today")\n         self.assertTrue(\n-            isinstance(start, datetime) and\n-            isinstance(end, datetime) and\n-            start.hour == 0 and start.minute == 0 and start.second == 0 and\n-            end.hour == 23 and end.minute == 59 and end.second == 59 and\n-            (start, end) == start_end_from_mode(\'day\')\n+            isinstance(start, datetime)\n+            and isinstance(end, datetime)\n+            and start.hour == 0\n+            and start.minute == 0\n+            and start.second == 0\n+            and end.hour == 23\n+            and end.minute == 59\n+            and end.second == 59\n+            and (start, end) == start_end_from_mode("day")\n         )\n \n         # DAY\n         #\n         day = datetime(2013, 2, 1, 18, 22)\n-        start, end = start_end_from_mode(\'day\', day)\n+        start, end = start_end_from_mode("day", day)\n         self.assertTrue(\n-            start.date() == day.date() == end.date() and\n-            start.hour == 0 and start.minute == 0 and start.second == 0 and\n-            end.hour == 23 and end.minute == 59 and end.second == 59\n+            start.date() == day.date() == end.date()\n+            and start.hour == 0\n+            and start.minute == 0\n+            and start.second == 0\n+            and end.hour == 23\n+            and end.minute == 59\n+            and end.second == 59\n         )\n \n         # test with date-only\n         day = datetime(2013, 2, 1)\n-        start, end = start_end_from_mode(\'day\', day)\n+        start, end = start_end_from_mode("day", day)\n         self.assertTrue(\n-            start.date() == day.date() == end.date() and\n-            start.hour == 0 and start.minute == 0 and start.second == 0 and\n-            end.hour == 23 and end.minute == 59 and end.second == 59\n+            start.date() == day.date() == end.date()\n+            and start.hour == 0\n+            and start.minute == 0\n+            and start.second == 0\n+            and end.hour == 23\n+            and end.minute == 59\n+            and end.second == 59\n         )\n \n         # WEEK\n@@ -265,90 +272,98 @@ def ret_6():\n \n         base.first_weekday = ret_0\n         day = datetime(2013, 2, 2)\n-        start, end = start_end_from_mode(\'week\', day)\n+        start, end = start_end_from_mode("week", day)\n         self.assertTrue(\n-            start.isoformat() == \'2013-01-28T00:00:00\' and\n-            end.isoformat() == \'2013-02-03T23:59:59\'\n+            start.isoformat() == "2013-01-28T00:00:00"\n+            and end.isoformat() == "2013-02-03T23:59:59"\n         )\n \n         base.first_weekday = ret_1\n         day = datetime(2013, 2, 2)\n-        start, end = start_end_from_mode(\'week\', day)\n+        start, end = start_end_from_mode("week", day)\n         self.assertTrue(\n-            start.isoformat() == \'2013-01-29T00:00:00\' and\n-            end.isoformat() == \'2013-02-04T23:59:59\'\n+            start.isoformat() == "2013-01-29T00:00:00"\n+            and end.isoformat() == "2013-02-04T23:59:59"\n         )\n \n         base.first_weekday = ret_6\n         day = datetime(2013, 2, 1)\n-        start, end = start_end_from_mode(\'week\', day)\n+        start, end = start_end_from_mode("week", day)\n         self.assertTrue(\n-            start.isoformat() == \'2013-01-27T00:00:00\' and\n-            end.isoformat() == \'2013-02-02T23:59:59\'\n+            start.isoformat() == "2013-01-27T00:00:00"\n+            and end.isoformat() == "2013-02-02T23:59:59"\n         )\n \n         base.first_weekday = orig_first_weekday  # restore orig first_weekday\n \n         # MONTH\n         #\n-        start, end = start_end_from_mode(\'month\')\n+        start, end = start_end_from_mode("month")\n         self.assertTrue(start < end and start.day == 1)\n \n         day = datetime(2013, 2, 7)\n-        start, end = start_end_from_mode(\'month\', day)\n+        start, end = start_end_from_mode("month", day)\n         self.assertTrue(\n-            start.year == 2013 and start.month == 2 and start.day == 1 and\n-            start.hour == 0 and start.minute == 0 and start.second == 0 and\n-            end.year == 2013 and end.month == 2 and end.day == 28 and\n-            end.hour == 23 and end.minute == 59 and end.second == 59\n+            start.year == 2013\n+            and start.month == 2\n+            and start.day == 1\n+            and start.hour == 0\n+            and start.minute == 0\n+            and start.second == 0\n+            and end.year == 2013\n+            and end.month == 2\n+            and end.day == 28\n+            and end.hour == 23\n+            and end.minute == 59\n+            and end.second == 59\n         )\n \n     def test_spell_date(self):\n         DT = DateTime(2015, 6, 6, 1, 2, 3)\n         date_spelled = spell_date(DT, self.portal)\n-        self.assertEqual(date_spelled[\'year\'], 2015)\n-        self.assertEqual(date_spelled[\'month\'], 6)\n-        self.assertEqual(date_spelled[\'month2\'], \'06\')\n-        self.assertEqual(date_spelled[\'day\'], 6)\n-        self.assertEqual(date_spelled[\'day2\'], \'06\')\n-        self.assertEqual(date_spelled[\'hour\'], 1)\n-        self.assertEqual(date_spelled[\'hour2\'], \'01\')\n-        self.assertEqual(date_spelled[\'minute\'], 2)\n-        self.assertEqual(date_spelled[\'minute2\'], \'02\')\n-        self.assertEqual(date_spelled[\'second\'], 3)\n-        self.assertEqual(date_spelled[\'second2\'], \'03\')\n-        self.assertEqual(date_spelled[\'week\'], 23)\n+        self.assertEqual(date_spelled["year"], 2015)\n+        self.assertEqual(date_spelled["month"], 6)\n+        self.assertEqual(date_spelled["month2"], "06")\n+        self.assertEqual(date_spelled["day"], 6)\n+        self.assertEqual(date_spelled["day2"], "06")\n+        self.assertEqual(date_spelled["hour"], 1)\n+        self.assertEqual(date_spelled["hour2"], "01")\n+        self.assertEqual(date_spelled["minute"], 2)\n+        self.assertEqual(date_spelled["minute2"], "02")\n+        self.assertEqual(date_spelled["second"], 3)\n+        self.assertEqual(date_spelled["second2"], "03")\n+        self.assertEqual(date_spelled["week"], 23)\n \n         # locale specific\n         # TODO: test better.\n-        self.assertTrue(isinstance(date_spelled[\'wkday\'], int))\n-        self.assertTrue(isinstance(date_spelled[\'month_name\'], six.string_types))\n-        self.assertTrue(isinstance(date_spelled[\'month_abbr\'], six.string_types))\n-        self.assertTrue(isinstance(date_spelled[\'wkday_name\'], six.string_types))\n-        self.assertTrue(isinstance(date_spelled[\'wkday_abbr\'], six.string_types))\n+        self.assertTrue(isinstance(date_spelled["wkday"], int))\n+        self.assertTrue(isinstance(date_spelled["month_name"], six.string_types))\n+        self.assertTrue(isinstance(date_spelled["month_abbr"], six.string_types))\n+        self.assertTrue(isinstance(date_spelled["wkday_name"], six.string_types))\n+        self.assertTrue(isinstance(date_spelled["wkday_abbr"], six.string_types))\n \n \n class TimezoneTest(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        set_env_timezone(\'UTC\')\n-        set_timezone(\'UTC\')\n+        self.portal = self.layer["portal"]\n+        set_env_timezone("UTC")\n+        set_timezone("UTC")\n \n     def test_default_timezone(self):\n-        self.assertTrue(os_default_timezone() == default_timezone() == \'UTC\')\n+        self.assertTrue(os_default_timezone() == default_timezone() == "UTC")\n \n         registry = getUtility(IRegistry)\n-        registry[\'plone.portal_timezone\'] = "Europe/Vienna"\n-        self.assertTrue(default_timezone() == \'Europe/Vienna\')\n+        registry["plone.portal_timezone"] = "Europe/Vienna"\n+        self.assertTrue(default_timezone() == "Europe/Vienna")\n \n \n class TestAnnotationAdapter(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def test_annotation_adapter(self):\n         # Normally called via adapter lookup from it\'s interface. but for\n@@ -359,7 +374,7 @@ def test_annotation_adapter(self):\n         self.assertEqual(an._data, None)\n \n         # ANNOTATION_KEY set, but no attribute set yet - an._data still None\n-        an.ANNOTATION_KEY = \'testing_annotation\'\n+        an.ANNOTATION_KEY = "testing_annotation"\n         an._data = IAnnotations(self.portal).get(an.ANNOTATION_KEY, None)\n \n         # Test attribute access, an._data still None\n@@ -374,21 +389,21 @@ def test_annotation_adapter(self):\n         self.assertTrue(an._data is not None)\n \n         # Set with something else than None\n-        an.foo = \'123\'\n-        self.assertEqual(an.foo, \'123\')\n+        an.foo = "123"\n+        self.assertEqual(an.foo, "123")\n \n \n class TestFindContext(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = portal = self.layer[\'portal\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = portal = self.layer["portal"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n-        portal.invokeFactory(\'Folder\', \'newsite\')\n-        portal.newsite.invokeFactory(\'Folder\', \'subfolder\')\n-        portal.invokeFactory(\'Folder\', \'subfolder2\')\n-        portal.subfolder2.invokeFactory(\'Folder\', \'subfolder3\')\n+        portal.invokeFactory("Folder", "newsite")\n+        portal.newsite.invokeFactory("Folder", "subfolder")\n+        portal.invokeFactory("Folder", "subfolder2")\n+        portal.subfolder2.invokeFactory("Folder", "subfolder3")\n \n         directlyProvides(portal.newsite, ISite)\n         self.assertTrue(ISite.providedBy(portal.newsite))\n@@ -401,44 +416,42 @@ def test_find_ploneroot(self):\n \n         self.assertEqual(\n             find_ploneroot(self.portal.newsite.subfolder, as_url=True),\n-            \'http://nohost/plone\'\n+            "http://nohost/plone",\n         )\n \n     def test_find_site(self):\n-        self.assertEqual(\n-            find_site(self.portal.newsite.subfolder),\n-            self.portal.newsite\n-        )\n+        self.assertEqual(find_site(self.portal.newsite.subfolder), self.portal.newsite)\n \n         self.assertEqual(\n             find_site(self.portal.newsite.subfolder, as_url=True),\n-            \'http://nohost/plone/newsite\'\n+            "http://nohost/plone/newsite",\n         )\n \n     def test_find_event_listing(self):\n-        self.portal.subfolder2.setLayout(\'event_listing\')\n+        self.portal.subfolder2.setLayout("event_listing")\n         self.assertEqual(\n             find_event_listing(self.portal.subfolder2.subfolder3),\n-            self.portal.subfolder2\n+            self.portal.subfolder2,\n         )\n         self.assertEqual(\n             find_event_listing(self.portal.subfolder2.subfolder3, as_url=True),\n-            \'http://nohost/plone/subfolder2\'\n+            "http://nohost/plone/subfolder2",\n         )\n \n         self.assertEqual(\n             find_context(\n                 self.portal.subfolder2.subfolder3,\n-                viewname=\'foo\',\n+                viewname="foo",\n                 as_url=True,\n-                append_view=True),\n-            \'http://nohost/plone/foo\'\n+                append_view=True,\n+            ),\n+            "http://nohost/plone/foo",\n         )\n \n \n class TestGetEventsDX(AbstractSampleDataEvents):\n-    """Test get_events with DX objects.\n-    """\n+    """Test get_events with DX objects."""\n+\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def test_get_events(self):\n@@ -447,17 +460,13 @@ def test_get_events(self):\n         res = get_events(self.portal)\n         self.assertEqual(len(res), 4)\n \n-        res = get_events(self.portal,\n-                         start=self.past,\n-                         end=self.future)\n+        res = get_events(self.portal, start=self.past, end=self.future)\n         self.assertEqual(len(res), 4)\n \n-        res = get_events(self.portal,\n-                         end=self.future)\n+        res = get_events(self.portal, end=self.future)\n         self.assertEqual(len(res), 4)\n \n-        res = get_events(self.portal,\n-                         start=self.past)\n+        res = get_events(self.portal, start=self.past)\n         self.assertEqual(len(res), 4)\n \n         # Limit\n@@ -475,21 +484,16 @@ def test_get_events(self):\n         self.assertTrue(res[0].start < res[-1].start)\n \n         # Test reversed sorting\n-        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS,\n-                         sort_reverse=True)\n+        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS, sort_reverse=True)\n         self.assertTrue(res[0].start > res[-1].start)\n \n         # Test sort_on\n-        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS,\n-                         sort="start")\n-        self.assertEqual(\n-            [it.title for it in res][2:],\n-            [u\'Now Event\', u\'Future Event\']\n-        )\n+        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS, sort="start")\n+        self.assertEqual([it.title for it in res][2:], [u"Now Event", u"Future Event"])\n         res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS, sort="end")\n         self.assertEqual(\n             [it.title for it in res],\n-            [u\'Past Event\', u\'Now Event\', u\'Future Event\', u\'Long Event\']\n+            [u"Past Event", u"Now Event", u"Future Event", u"Long Event"],\n         )\n \n         # Test expansion\n@@ -501,49 +505,42 @@ def test_get_events(self):\n         # Test sorting\n         self.assertTrue(res[0].start < res[-1].start)\n \n-        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS,\n-                         expand=True, sort_reverse=True)\n+        res = get_events(\n+            self.portal, ret_mode=RET_MODE_ACCESSORS, expand=True, sort_reverse=True\n+        )\n         # Test sorting\n         self.assertTrue(res[0].start > res[-1].start)\n \n         # only on now-date\n-        res = get_events(self.portal,\n-                         start=self.now,\n-                         end=self.now)\n+        res = get_events(self.portal, start=self.now, end=self.now)\n         self.assertEqual(len(res), 2)\n \n         # only on now-date as date\n         # NOTE: converting self.now to python datetime to allow testing also\n         # with dates as Zope DateTime objects.\n-        res = get_events(self.portal,\n-                         start=pydt(self.now).date(),\n-                         end=pydt(self.now).date())\n+        res = get_events(\n+            self.portal, start=pydt(self.now).date(), end=pydt(self.now).date()\n+        )\n         self.assertEqual(len(res), 2)\n \n         # only on past date\n-        res = get_events(self.portal,\n-                         start=self.past,\n-                         end=self.past)\n+        res = get_events(self.portal, start=self.past, end=self.past)\n         self.assertEqual(len(res), 2)\n \n         # one recurrence occurrence in far future\n-        res = get_events(self.portal,\n-                         start=self.far,\n-                         end=self.far)\n+        res = get_events(self.portal, start=self.far, end=self.far)\n         self.assertEqual(len(res), 1)\n \n         # from now on\n-        res = get_events(self.portal,\n-                         start=self.now)\n+        res = get_events(self.portal, start=self.now)\n         self.assertEqual(len(res), 3)\n \n         # until now\n-        res = get_events(self.portal,\n-                         end=self.now)\n+        res = get_events(self.portal, end=self.now)\n         self.assertEqual(len(res), 3)\n \n         # in subfolder\n-        path = \'/\'.join(self.portal.sub.getPhysicalPath())\n+        path = "/".join(self.portal.sub.getPhysicalPath())\n         res = get_events(self.portal, path=path)\n         self.assertEqual(len(res), 1)\n \n@@ -575,18 +572,18 @@ def test_get_event_limit(self):\n         factory = self.event_factory\n         factory(\n             container=self.portal,\n-            content_id=\'past_recur\',\n-            title=u\'Past Event recurring\',\n+            content_id="past_recur",\n+            title=u"Past Event recurring",\n             start=self.past,\n             end=self.past + self.duration,\n             location=u"Dornbirn",\n-            recurrence=\'RRULE:FREQ=WEEKLY;COUNT=4\',\n+            recurrence="RRULE:FREQ=WEEKLY;COUNT=4",\n         )\n \n         tomorrow = factory(\n             container=self.portal,\n-            content_id=\'tomorrow\',\n-            title=u\'Tomorrow event\',\n+            content_id="tomorrow",\n+            title=u"Tomorrow event",\n             start=self.tomorrow,\n             end=self.tomorrow + self.duration,\n             open_end=True,\n@@ -594,10 +591,16 @@ def test_get_event_limit(self):\n         )\n         tomorrow.reindexObject()\n \n-        limit = get_events(self.portal, start=self.now, expand=True,\n-                           ret_mode=RET_MODE_ACCESSORS, limit=3)\n-        all_ = get_events(self.portal, start=self.now, expand=True,\n-                          ret_mode=RET_MODE_ACCESSORS)\n+        limit = get_events(\n+            self.portal,\n+            start=self.now,\n+            expand=True,\n+            ret_mode=RET_MODE_ACCESSORS,\n+            limit=3,\n+        )\n+        all_ = get_events(\n+            self.portal, start=self.now, expand=True, ret_mode=RET_MODE_ACCESSORS\n+        )\n         self.assertEqual([e.url for e in limit], [e.url for e in all_[:3]])\n \n     def test_construct_calendar(self):\n@@ -619,28 +622,20 @@ def _num_events(values):\n \n         # Completly outside range and start, end given as datetime\n         cal = construct_calendar(\n-            res,\n-            start=datetime(2000, 1, 1, 10, 0),\n-            end=datetime(2000, 1, 2, 10, 0)\n+            res, start=datetime(2000, 1, 1, 10, 0), end=datetime(2000, 1, 2, 10, 0)\n         )\n         self.assertEqual(_num_events(cal.values()), 0)\n \n         # Within range\n-        cal = construct_calendar(\n-            res,\n-            start=date(2013, 5, 1),\n-            end=date(2013, 5, 31)\n-        )\n+        cal = construct_calendar(res, start=date(2013, 5, 1), end=date(2013, 5, 31))\n         self.assertEqual(_num_events(cal.values()), 35)\n         # First day must also be set in the calendar\n-        self.assertTrue(\'2013-05-01\' in cal.keys())\n+        self.assertTrue("2013-05-01" in cal.keys())\n \n         # invalid start\n         def _invalid_start():\n             return construct_calendar(\n-                res,\n-                start=\'invalid\',\n-                end=datetime(2000, 1, 2, 10, 0)\n+                res, start="invalid", end=datetime(2000, 1, 2, 10, 0)\n             )\n \n         self.assertRaises(AssertionError, _invalid_start)\n@@ -648,10 +643,9 @@ def _invalid_start():\n         # invalid end\n         def _invalid_end():\n             return construct_calendar(\n-                res,\n-                start=datetime(2000, 1, 1, 10, 0),\n-                end=\'invalid\'\n+                res, start=datetime(2000, 1, 1, 10, 0), end="invalid"\n             )\n+\n         self.assertRaises(AssertionError, _invalid_end)\n \n \n@@ -662,6 +656,7 @@ class TestGetEventsOptimizations(AbstractSampleDataEvents):\n     is actually a manifestation of a deeper sorting bug,\n     that also affects unlimited and unexpanded get_events().\n     """\n+\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n@@ -671,18 +666,18 @@ def setUp(self):\n         factory = self.event_factory\n         factory(\n             container=self.portal,\n-            content_id=\'past_recur\',\n-            title=u\'Past Recur\',\n+            content_id="past_recur",\n+            title=u"Past Recur",\n             start=self.past + self.duration,\n             end=self.past + self.duration + self.duration,\n             location=u"Dornbirn",\n-            recurrence=\'RRULE:FREQ=WEEKLY;COUNT=4\',\n+            recurrence="RRULE:FREQ=WEEKLY;COUNT=4",\n         )\n \n         tomorrow = factory(\n             container=self.portal,\n-            content_id=\'tomorrow\',\n-            title=u\'Tomorrow event\',\n+            content_id="tomorrow",\n+            title=u"Tomorrow event",\n             start=self.tomorrow,\n             end=self.tomorrow + self.duration,\n             open_end=True,\n@@ -691,19 +686,20 @@ def setUp(self):\n         tomorrow.reindexObject()\n \n         self.occ = [\n-            (u\'Past Event\', \'2013-04-25 00:00:00\', \'2013-04-25 23:59:59\'),\n-            (u\'Long Event\', \'2013-04-25 10:00:00\', \'2013-06-04 10:00:00\'),\n-            (u\'Past Recur\', \'2013-04-25 11:00:00\', \'2013-04-25 12:00:00\'),\n-            (u\'Past Event\', \'2013-04-26 00:00:00\', \'2013-04-26 23:59:59\'),\n-            (u\'Past Event\', \'2013-04-27 00:00:00\', \'2013-04-27 23:59:59\'),\n-            (u\'Past Recur\', \'2013-05-02 11:00:00\', \'2013-05-02 12:00:00\'),\n-            (u\'Now Event\', \'2013-05-05 10:00:00\', \'2013-05-05 11:00:00\'),\n-            (u\'Tomorrow event\', \'2013-05-06 10:00:00\', \'2013-05-06 23:59:59\'),\n-            (u\'Now Event\', \'2013-05-07 10:00:00\', \'2013-05-07 11:00:00\'),\n-            (u\'Now Event\', \'2013-05-09 10:00:00\', \'2013-05-09 11:00:00\'),\n-            (u\'Past Recur\', \'2013-05-09 11:00:00\', \'2013-05-09 12:00:00\'),\n-            (u\'Future Event\', \'2013-05-15 10:00:00\', \'2013-05-15 11:00:00\'),\n-            (u\'Past Recur\', \'2013-05-16 11:00:00\', \'2013-05-16 12:00:00\')]\n+            (u"Past Event", "2013-04-25 00:00:00", "2013-04-25 23:59:59"),\n+            (u"Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            (u"Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n+            (u"Past Event", "2013-04-26 00:00:00", "2013-04-26 23:59:59"),\n+            (u"Past Event", "2013-04-27 00:00:00", "2013-04-27 23:59:59"),\n+            (u"Past Recur", "2013-05-02 11:00:00", "2013-05-02 12:00:00"),\n+            (u"Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+            (u"Tomorrow event", "2013-05-06 10:00:00", "2013-05-06 23:59:59"),\n+            (u"Now Event", "2013-05-07 10:00:00", "2013-05-07 11:00:00"),\n+            (u"Now Event", "2013-05-09 10:00:00", "2013-05-09 11:00:00"),\n+            (u"Past Recur", "2013-05-09 11:00:00", "2013-05-09 12:00:00"),\n+            (u"Future Event", "2013-05-15 10:00:00", "2013-05-15 11:00:00"),\n+            (u"Past Recur", "2013-05-16 11:00:00", "2013-05-16 12:00:00"),\n+        ]\n \n     def diff(self, list1, list2):\n         c = set(list1).union(set(list2))\n@@ -711,73 +707,106 @@ def diff(self, list1, list2):\n         return list(c - d)\n \n     def fmt(self, seq):\n-        return [(x.title,\n-                 x.start.strftime(\'%Y-%m-%d %H:%M:%S\'),\n-                 x.end.strftime(\'%Y-%m-%d %H:%M:%S\'))\n-                for x in seq]\n+        return [\n+            (\n+                x.title,\n+                x.start.strftime("%Y-%m-%d %H:%M:%S"),\n+                x.end.strftime("%Y-%m-%d %H:%M:%S"),\n+            )\n+            for x in seq\n+        ]\n \n     # expand=True: events\n \n     def test_expand_all(self):\n         # all occurrences, sorted by start\n-        res = self.fmt(get_events(self.portal, expand=True,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(self.portal, expand=True, ret_mode=RET_MODE_ACCESSORS)\n+        )\n         self.assertEqual(res, self.occ)\n \n     def test_expand_all_limit(self):\n         # limited occurrences\n-        res = self.fmt(get_events(self.portal, expand=True,\n-                                  limit=3,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(self.portal, expand=True, limit=3, ret_mode=RET_MODE_ACCESSORS)\n+        )\n         expect = self.occ[:3]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n     def test_expand_start(self):\n         # now+future occurrences\n-        res = self.fmt(get_events(self.portal, expand=True,\n-                                  start=self.now,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal, expand=True, start=self.now, ret_mode=RET_MODE_ACCESSORS\n+            )\n+        )\n         expect = self.occ[1:2] + self.occ[6:]  # includes ongoing long event\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n     def test_expand_start_limit(self):\n         # limited now+future occurrences\n-        res = self.fmt(get_events(self.portal, expand=True,\n-                                  start=self.now, limit=3,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal,\n+                expand=True,\n+                start=self.now,\n+                limit=3,\n+                ret_mode=RET_MODE_ACCESSORS,\n+            )\n+        )\n         expect = self.occ[1:2] + self.occ[6:8]  # includes ongoing long event\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n     def test_expand_future_event(self):\n-        """make sure expand_events does not remove event objects (that need not be expanded)\n-        """\n+        """make sure expand_events does not remove event objects (that need not be expanded)"""\n         # create event happening next year (today + 365 days)\n         next_year = self.event_factory(\n             container=self.portal,\n-            content_id=\'next-year\',\n-            title=u\'Next year\',\n+            content_id="next-year",\n+            title=u"Next year",\n             start=self.tomorrow + timedelta(365),\n             end=self.tomorrow + timedelta(365) + self.duration,\n             location=u"Dornbirn",\n-            recurrence=\'RRULE:FREQ=DAILY;COUNT=4\',\n+            recurrence="RRULE:FREQ=DAILY;COUNT=4",\n         )\n         next_year.reindexObject()\n \n-\n-        ev = (u\'Next year\', \'2014-05-06 10:00:00\', \'2014-05-06 11:00:00\')  # original event\n-        rec1 = (u\'Next year\', \'2014-05-07 10:00:00\', \'2014-05-07 11:00:00\')  # first recurrence\n-        rec2 = (u\'Next year\', \'2014-05-08 10:00:00\', \'2014-05-08 11:00:00\')  # second recurrence\n-        rec3 = (u\'Next year\', \'2014-05-09 10:00:00\', \'2014-05-09 11:00:00\')  # third recurrence\n-        rec4 = (u\'Next year\', \'2014-05-10 10:00:00\', \'2014-05-10 11:00:00\')  # fourth recurrence\n-\n+        ev = (\n+            u"Next year",\n+            "2014-05-06 10:00:00",\n+            "2014-05-06 11:00:00",\n+        )  # original event\n+        rec1 = (\n+            u"Next year",\n+            "2014-05-07 10:00:00",\n+            "2014-05-07 11:00:00",\n+        )  # first recurrence\n+        rec2 = (\n+            u"Next year",\n+            "2014-05-08 10:00:00",\n+            "2014-05-08 11:00:00",\n+        )  # second recurrence\n+        rec3 = (\n+            u"Next year",\n+            "2014-05-09 10:00:00",\n+            "2014-05-09 11:00:00",\n+        )  # third recurrence\n+        rec4 = (\n+            u"Next year",\n+            "2014-05-10 10:00:00",\n+            "2014-05-10 11:00:00",\n+        )  # fourth recurrence\n \n         # expand_events from today+200 until today+300\n-        res = self.fmt(expand_events(\n-            [next_year],\n-            RET_MODE_ACCESSORS,\n-            start=self.now + timedelta(200),\n-            end=self.now + timedelta(300),\n-            sort="start"))\n+        res = self.fmt(\n+            expand_events(\n+                [next_year],\n+                RET_MODE_ACCESSORS,\n+                start=self.now + timedelta(200),\n+                end=self.now + timedelta(300),\n+                sort="start",\n+            )\n+        )\n \n         # event is included in result even though it starts after the the `end` param of expand_events\n         # this is to make expand_events only use start/end to expand occurrences, not limit events given in the list\n@@ -788,12 +817,15 @@ def test_expand_future_event(self):\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n         # when the event does not happen after the search timespan, expand won\'t add original event\n-        res = self.fmt(get_events(\n-            self.portal,\n-            expand=True,\n-            start=self.now + timedelta(365+2),\n-            end=self.now + timedelta(365+3),\n-            ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal,\n+                expand=True,\n+                start=self.now + timedelta(365 + 2),\n+                end=self.now + timedelta(365 + 3),\n+                ret_mode=RET_MODE_ACCESSORS,\n+            )\n+        )\n         expect = [rec1, rec2]\n         self.assertEqual(res, expect)\n \n@@ -801,80 +833,110 @@ def test_expand_future_event(self):\n \n     def test_noexpand_all(self):\n         # all events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(self.portal, expand=False, ret_mode=RET_MODE_ACCESSORS)\n+        )\n         expect = [\n-            (u\'Past Event\', \'2013-04-25 00:00:00\', \'2013-04-25 23:59:59\'),\n-            (u\'Long Event\', \'2013-04-25 10:00:00\', \'2013-06-04 10:00:00\'),\n-            (u\'Past Recur\', \'2013-04-25 11:00:00\', \'2013-04-25 12:00:00\'),\n-            (u\'Now Event\', \'2013-05-05 10:00:00\', \'2013-05-05 11:00:00\'),\n-            (u\'Tomorrow event\', \'2013-05-06 10:00:00\', \'2013-05-06 23:59:59\'),\n-            (u\'Future Event\', \'2013-05-15 10:00:00\', \'2013-05-15 11:00:00\')]\n+            (u"Past Event", "2013-04-25 00:00:00", "2013-04-25 23:59:59"),\n+            (u"Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            (u"Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n+            (u"Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+            (u"Tomorrow event", "2013-05-06 10:00:00", "2013-05-06 23:59:59"),\n+            (u"Future Event", "2013-05-15 10:00:00", "2013-05-15 11:00:00"),\n+        ]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n         # limited events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  limit=3,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(self.portal, expand=False, limit=3, ret_mode=RET_MODE_ACCESSORS)\n+        )\n         self.assertEqual(res, expect[:3], self.diff(res, expect[:3]))\n \n     def test_noexpand_start(self):\n         # now+future events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  start=self.now,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal, expand=False, start=self.now, ret_mode=RET_MODE_ACCESSORS\n+            )\n+        )\n         expect = [\n-            (u\'Long Event\', \'2013-04-25 10:00:00\', \'2013-06-04 10:00:00\'),\n-            (u\'Now Event\', \'2013-05-05 10:00:00\', \'2013-05-05 11:00:00\'),\n-            (u\'Tomorrow event\', \'2013-05-06 10:00:00\', \'2013-05-06 23:59:59\'),\n+            (u"Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            (u"Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+            (u"Tomorrow event", "2013-05-06 10:00:00", "2013-05-06 23:59:59"),\n             # Past Recur next occurrence: \'2013-05-09 11:00:00\'\n             # Past Recur brain.start: \'2013-04-25 11:00:00\'\n-            (u\'Past Recur\', \'2013-04-25 11:00:00\', \'2013-04-25 12:00:00\'),\n-            (u\'Future Event\', \'2013-05-15 10:00:00\', \'2013-05-15 11:00:00\')]\n+            (u"Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n+            (u"Future Event", "2013-05-15 10:00:00", "2013-05-15 11:00:00"),\n+        ]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n         # limited now+future events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  start=self.now, limit=3,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal,\n+                expand=False,\n+                start=self.now,\n+                limit=3,\n+                ret_mode=RET_MODE_ACCESSORS,\n+            )\n+        )\n         self.assertEqual(res, expect[:3], self.diff(res, expect[:3]))\n \n     def test_noexpand_end(self):\n         # past+now events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  end=self.now,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal, expand=False, end=self.now, ret_mode=RET_MODE_ACCESSORS\n+            )\n+        )\n         expect = [\n-            (u\'Past Event\', \'2013-04-25 00:00:00\', \'2013-04-25 23:59:59\'),\n-            (u\'Long Event\', \'2013-04-25 10:00:00\', \'2013-06-04 10:00:00\'),\n-            (u\'Past Recur\', \'2013-04-25 11:00:00\', \'2013-04-25 12:00:00\'),\n-            (u\'Now Event\', \'2013-05-05 10:00:00\', \'2013-05-05 11:00:00\')]\n+            (u"Past Event", "2013-04-25 00:00:00", "2013-04-25 23:59:59"),\n+            (u"Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            (u"Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n+            (u"Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+        ]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n         # limited past+now events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  end=self.now,\n-                                  limit=3,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal,\n+                expand=False,\n+                end=self.now,\n+                limit=3,\n+                ret_mode=RET_MODE_ACCESSORS,\n+            )\n+        )\n         self.assertEqual(res, expect[:3], self.diff(res, expect[:3]))\n \n     def test_noexpand_start_end(self):\n         # only now events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  start=self.now,\n-                                  end=self.now,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal,\n+                expand=False,\n+                start=self.now,\n+                end=self.now,\n+                ret_mode=RET_MODE_ACCESSORS,\n+            )\n+        )\n         expect = [\n-            (u\'Long Event\', \'2013-04-25 10:00:00\', \'2013-06-04 10:00:00\'),\n-            (u\'Now Event\', \'2013-05-05 10:00:00\', \'2013-05-05 11:00:00\')]\n+            (u"Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            (u"Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+        ]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n         # limited now events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  start=self.now,\n-                                  end=self.now,\n-                                  limit=3,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal,\n+                expand=False,\n+                start=self.now,\n+                end=self.now,\n+                limit=3,\n+                ret_mode=RET_MODE_ACCESSORS,\n+            )\n+        )\n         self.assertEqual(res, expect[:3], self.diff(res, expect[:3]))\n \n \n@@ -882,79 +944,82 @@ class TestDatesForDisplay(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_prep_display_with_time(self):\n         tz = pytz.timezone("Europe/Vienna")\n         event = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n+            "plone.app.event.dx.event",\n             id="event",\n             start=tz.localize(datetime(2000, 10, 12, 6, 0, 0)),\n-            end=tz.localize(datetime(2000, 10, 12, 18, 0, 0))\n+            end=tz.localize(datetime(2000, 10, 12, 18, 0, 0)),\n         )\n         self.assertEqual(\n             dates_for_display(event),\n-            {\'start_date\': u\'Oct 12, 2000\',\n-             \'start_time\': u\'06:00 AM\',\n-             \'start_iso\': \'2000-10-12T06:00:00+02:00\',\n-             \'end_date\': u\'Oct 12, 2000\',\n-             \'end_time\': u\'06:00 PM\',\n-             \'end_iso\': \'2000-10-12T18:00:00+02:00\',\n-             \'same_day\': True,\n-             \'same_time\': False,\n-             \'whole_day\': False,\n-             \'open_end\': False,\n-             }\n+            {\n+                "start_date": u"Oct 12, 2000",\n+                "start_time": u"06:00 AM",\n+                "start_iso": "2000-10-12T06:00:00+02:00",\n+                "end_date": u"Oct 12, 2000",\n+                "end_time": u"06:00 PM",\n+                "end_iso": "2000-10-12T18:00:00+02:00",\n+                "same_day": True,\n+                "same_time": False,\n+                "whole_day": False,\n+                "open_end": False,\n+            },\n         )\n \n     def test_prep_display_wholeday_sameday(self):\n         tz = pytz.timezone("Europe/Vienna")\n         event = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n+            "plone.app.event.dx.event",\n             id="event",\n             start=tz.localize(datetime(2000, 10, 12, 0, 0, 0)),\n             end=tz.localize(datetime(2000, 10, 12, 23, 59, 59)),\n-            whole_day=True\n+            whole_day=True,\n         )\n         self.assertEqual(\n             dates_for_display(event),\n-            {\'start_date\': u\'Oct 12, 2000\',\n-             \'start_time\': None,\n-             \'start_iso\': \'2000-10-12\',\n-             \'end_date\': u\'Oct 12, 2000\',\n-             \'end_time\': None,\n-             \'end_iso\': \'2000-10-12\',\n-             \'same_day\': True,\n-             \'same_time\': False,\n-             \'whole_day\': True,\n-             \'open_end\': False,\n-             }\n+            {\n+                "start_date": u"Oct 12, 2000",\n+                "start_time": None,\n+                "start_iso": "2000-10-12",\n+                "end_date": u"Oct 12, 2000",\n+                "end_time": None,\n+                "end_iso": "2000-10-12",\n+                "same_day": True,\n+                "same_time": False,\n+                "whole_day": True,\n+                "open_end": False,\n+            },\n         )\n \n     def test_prep_display_wholeday_differentdays(self):\n         tz = pytz.timezone("Europe/Vienna")\n         event = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n+            "plone.app.event.dx.event",\n             id="event",\n             start=tz.localize(datetime(2000, 10, 12, 0, 0, 0)),\n             end=tz.localize(datetime(2000, 10, 13, 23, 59, 59)),\n-            whole_day=True\n+            whole_day=True,\n         )\n         self.assertEqual(\n             dates_for_display(event),\n-            {\'start_date\': u\'Oct 12, 2000\',\n-             \'start_time\': None,\n-             \'start_iso\': \'2000-10-12\',\n-             \'end_date\': u\'Oct 13, 2000\',\n-             \'end_time\': None,\n-             \'end_iso\': \'2000-10-13\',\n-             \'same_day\': False,\n-             \'same_time\': False,\n-             \'whole_day\': True,\n-             \'open_end\': False,\n-             }\n+            {\n+                "start_date": u"Oct 12, 2000",\n+                "start_time": None,\n+                "start_iso": "2000-10-12",\n+                "end_date": u"Oct 13, 2000",\n+                "end_time": None,\n+                "end_iso": "2000-10-13",\n+                "same_day": False,\n+                "same_time": False,\n+                "whole_day": True,\n+                "open_end": False,\n+            },\n         )\ndiff --git a/plone/app/event/tests/test_catalog.py b/plone/app/event/tests/test_catalog.py\nindex 6570916c..ceaa009c 100644\n--- a/plone/app/event/tests/test_catalog.py\n+++ b/plone/app/event/tests/test_catalog.py\n@@ -9,15 +9,17 @@ class TextDXIntegration(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n+        self.portal = self.layer["portal"]\n+        self.catalog = getToolByName(self.portal, "portal_catalog")\n \n     def test_end_is_DateRecurringIndex(self):\n         # end should be a DateRecurringIndex\n-        self.assertEqual(self.catalog.Indexes[\'end\'].__class__.__name__,\n-                         \'DateRecurringIndex\')\n+        self.assertEqual(\n+            self.catalog.Indexes["end"].__class__.__name__, "DateRecurringIndex"\n+        )\n \n     def test_start_is_DateRecurringIndex(self):\n         # start should be a DateRecurringIndex\n-        self.assertEqual(self.catalog.Indexes[\'start\'].__class__.__name__,\n-                         \'DateRecurringIndex\')\n+        self.assertEqual(\n+            self.catalog.Indexes["start"].__class__.__name__, "DateRecurringIndex"\n+        )\ndiff --git a/plone/app/event/tests/test_dx_behaviors.py b/plone/app/event/tests/test_dx_behaviors.py\nindex 537577ed..228097cc 100644\n--- a/plone/app/event/tests/test_dx_behaviors.py\n+++ b/plone/app/event/tests/test_dx_behaviors.py\n@@ -51,26 +51,30 @@\n \n \n class MockEvent(SimpleItem):\n-    """ Mock event"""\n+    """Mock event"""\n \n \n class TestDXAddEdit(unittest.TestCase):\n     layer = PAEventDX_FUNCTIONAL_TESTING\n \n     def setUp(self):\n-        app = self.layer[\'app\']\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        app = self.layer["app"]\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n         self.browser = Browser(app)\n         self.browser.handleErrors = False\n         self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD,)\n+            "Authorization",\n+            "Basic %s:%s"\n+            % (\n+                SITE_OWNER_NAME,\n+                SITE_OWNER_PASSWORD,\n+            ),\n         )\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=patched_now)\n+    @mock.patch("plone.app.event.base.localized_now", new=patched_now)\n     def test_defaults(self):\n         """Test, if defaults are set correctly.\n \n@@ -99,27 +103,30 @@ def test_defaults(self):\n         form.add(e1)\n         """\n \n-        self.browser.open(\'{}/{}\'.format(\n-            self.portal.absolute_url(),\n-            \'++add++plone.app.event.dx.event\'\n-        ))\n+        self.browser.open(\n+            "{}/{}".format(\n+                self.portal.absolute_url(), "++add++plone.app.event.dx.event"\n+            )\n+        )\n \n         self.browser.getControl(\n-            name=\'form.widgets.IDublinCore.title\'\n+            name="form.widgets.IDublinCore.title"\n         ).value = "TestEvent"\n \n         # TODO: these values are simply not set in the pat-pickadate pattern.\n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.start\').value = \'2014-03-30\'\n+            name="form.widgets.IEventBasic.start"\n+        ).value = "2014-03-30"\n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.end\').value = \'2014-03-31\'\n+            name="form.widgets.IEventBasic.end"\n+        ).value = "2014-03-31"\n \n-        self.browser.getControl(\'Save\').click()\n+        self.browser.getControl("Save").click()\n \n         # CHECK VALUES\n         #\n         # TODO: fix all defaults\n-        event = self.portal[\'testevent\']\n+        event = self.portal["testevent"]\n         # self.assertEqual(\n         #     event.start,\n         #     patched_now()\n@@ -165,86 +172,91 @@ def test_edit_context(self):\n         # ADD\n         #\n         self.browser.open(self.portal.absolute_url())\n-        self.browser.getLink(\'plone.app.event.dx.event\').click()\n+        self.browser.getLink("plone.app.event.dx.event").click()\n         self.browser.getControl(\n-            name=\'form.widgets.IDublinCore.title\'\n+            name="form.widgets.IDublinCore.title"\n         ).value = "TestEvent"\n \n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.start\').value = "2014-03-30T03:51"\n+            name="form.widgets.IEventBasic.start"\n+        ).value = "2014-03-30T03:51"\n \n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.end\').value = "2014-03-30T04:51"\n+            name="form.widgets.IEventBasic.end"\n+        ).value = "2014-03-30T04:51"\n \n-        self.browser.getControl(\'Save\').click()\n+        self.browser.getControl("Save").click()\n \n         # CHECK VALUES\n         #\n-        self.assertTrue(self.browser.url.endswith(\'testevent/view\'))\n-        self.assertTrue(\'TestEvent\' in self.browser.contents)\n-        self.assertTrue(\'2014-03-30\' in self.browser.contents)\n+        self.assertTrue(self.browser.url.endswith("testevent/view"))\n+        self.assertTrue("TestEvent" in self.browser.contents)\n+        self.assertTrue("2014-03-30" in self.browser.contents)\n \n         #\n         # EDIT\n         #\n         testevent = self.portal.testevent\n-        self.browser.open(\'%s/@@edit\' % testevent.absolute_url())\n+        self.browser.open("%s/@@edit" % testevent.absolute_url())\n \n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.start\').value = "2014-03-31T03:51"\n+            name="form.widgets.IEventBasic.start"\n+        ).value = "2014-03-31T03:51"\n \n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.end\').value = "2014-03-31T04:51"\n+            name="form.widgets.IEventBasic.end"\n+        ).value = "2014-03-31T04:51"\n \n-        self.browser.getControl(\'Save\').click()\n+        self.browser.getControl("Save").click()\n \n         #\n         # EDIT AGAIN\n         #\n         testevent = self.portal.testevent\n-        self.browser.open(\'%s/@@edit\' % testevent.absolute_url())\n+        self.browser.open("%s/@@edit" % testevent.absolute_url())\n \n-        self.browser.getControl(\'Save\').click()\n+        self.browser.getControl("Save").click()\n \n         # CHECK DATES/TIMES, MUST NOT HAVE CHANGED\n         #\n-        self.assertTrue(\'2014-03-31\' in self.browser.contents)\n-        self.assertTrue(\'03:51\' in self.browser.contents)\n-        self.assertTrue(\'04:51\' in self.browser.contents)\n+        self.assertTrue("2014-03-31" in self.browser.contents)\n+        self.assertTrue("03:51" in self.browser.contents)\n+        self.assertTrue("04:51" in self.browser.contents)\n \n         #\n         # EDIT and set whole_day setting\n         #\n         testevent = self.portal.testevent\n-        self.browser.open(\'%s/@@edit\' % testevent.absolute_url())\n+        self.browser.open("%s/@@edit" % testevent.absolute_url())\n \n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.whole_day:list\').value = True\n+            name="form.widgets.IEventBasic.whole_day:list"\n+        ).value = True\n \n-        self.browser.getControl(\'Save\').click()\n+        self.browser.getControl("Save").click()\n \n         # CHECK DATES/TIMES, IF THEY ADAPTED ACCORDING TO WHOLE DAY\n         #\n-        self.assertTrue(\'2014-03-31\' in self.browser.contents)\n-        self.assertTrue(\'0:00\' in self.browser.contents)\n-        self.assertTrue(\'23:59\' in self.browser.contents)\n+        self.assertTrue("2014-03-31" in self.browser.contents)\n+        self.assertTrue("0:00" in self.browser.contents)\n+        self.assertTrue("23:59" in self.browser.contents)\n \n \n class TestEventAccessor(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n         set_browserlayer(self.request)\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_event_accessor(self):\n         tz = pytz.timezone("Europe/Vienna")\n         e1 = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            title=u\'event1\',\n+            "plone.app.event.dx.event",\n+            title=u"event1",\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             end=tz.localize(datetime(2011, 11, 11, 12, 0)),\n         )\n@@ -274,10 +286,10 @@ def test_event_accessor_whole_day__open_end(self):\n \n         e1 = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            title=u\'event1\',\n+            "plone.app.event.dx.event",\n+            title=u"event1",\n             start=start,\n-            end=end\n+            end=end,\n         )\n         acc = IEventAccessor(e1)\n \n@@ -300,42 +312,38 @@ def test_event_accessor_whole_day__open_end(self):\n         self.assertEqual(acc.end, end_end)\n \n     def test_event_accessor__sync_uid(self):\n-        self.request.set(\'HTTP_HOST\', \'nohost\')\n+        self.request.set("HTTP_HOST", "nohost")\n \n         e1 = createContentInContainer(\n-            self.portal,\n-            \'plone.app.event.dx.event\',\n-            title=u\'event1\'\n+            self.portal, "plone.app.event.dx.event", title=u"event1"\n         )\n         acc = IEventAccessor(e1)\n \n         # setting no sync uid will automatically generate one\n-        self.assertTrue(acc.sync_uid, IUUID(e1) + \'@nohost\')\n+        self.assertTrue(acc.sync_uid, IUUID(e1) + "@nohost")\n         # it\'s not stored on the object though\n         self.assertEqual(e1.sync_uid, None)\n         # but it\'s indexed\n-        result = self.portal.portal_catalog(sync_uid=IUUID(e1) + \'@nohost\')\n+        result = self.portal.portal_catalog(sync_uid=IUUID(e1) + "@nohost")\n         self.assertEqual(len(result), 1)\n \n         # Setting the sync_uid\n-        acc.sync_uid = \'okay\'\n+        acc.sync_uid = "okay"\n         e1.reindexObject()\n-        self.assertEqual(acc.sync_uid, \'okay\')\n+        self.assertEqual(acc.sync_uid, "okay")\n         # Now, it\'s also stored on the object itself\n-        self.assertEqual(e1.sync_uid, \'okay\')\n+        self.assertEqual(e1.sync_uid, "okay")\n         # and indexed\n-        result = self.portal.portal_catalog(sync_uid=\'okay\')\n+        result = self.portal.portal_catalog(sync_uid="okay")\n         self.assertEqual(len(result), 1)\n \n     def test_event_accessor__start_end(self):\n         e1 = createContentInContainer(\n-            self.portal,\n-            \'plone.app.event.dx.event\',\n-            title=u\'event1\'\n+            self.portal, "plone.app.event.dx.event", title=u"event1"\n         )\n \n         dt = datetime(2161, 1, 1)  # United Federation of Planets\n-        DT = DateTime(\'2161/01/01 00:00:00 UTC\')\n+        DT = DateTime("2161/01/01 00:00:00 UTC")\n \n         acc = IEventAccessor(e1)\n \n@@ -363,10 +371,10 @@ class TestDXIntegration(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n         set_browserlayer(self.request)\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n         self.tz = pytz.timezone(TEST_TIMEZONE)\n \n     def test_start_defaults(self):\n@@ -390,15 +398,13 @@ def test_start_end_dates_indexed(self):\n         end = tz.localize(datetime(2011, 11, 11, 12, 0))\n         e1 = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            title=u\'event1\',\n+            "plone.app.event.dx.event",\n+            title=u"event1",\n             start=start,\n-            end=end\n+            end=end,\n         )\n \n-        result = self.portal.portal_catalog(\n-            path=\'/\'.join(e1.getPhysicalPath())\n-        )\n+        result = self.portal.portal_catalog(path="/".join(e1.getPhysicalPath()))\n         self.assertEqual(1, len(result))\n \n         # The start and end datetime\'s are indexed as Python datetimes\n@@ -409,15 +415,15 @@ def test_recurrence_indexing(self):\n         tz = pytz.timezone("Europe/Vienna")\n         e1 = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            title=u\'event1\',\n+            "plone.app.event.dx.event",\n+            title=u"event1",\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             end=tz.localize(datetime(2011, 11, 11, 12, 0)),\n         )\n \n         # When editing via behaviors, the attributes should also be available\n         # on the context itself.\n-        IEventRecurrence(e1).recurrence = \'RRULE:FREQ=DAILY;COUNT=4\'\n+        IEventRecurrence(e1).recurrence = "RRULE:FREQ=DAILY;COUNT=4"\n         self.assertTrue(e1.recurrence == IEventRecurrence(e1).recurrence)\n \n         e1.reindexObject()\n@@ -431,7 +437,7 @@ def test_recurrence_indexing(self):\n             self.portal,\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             ret_mode=base.RET_MODE_OBJECTS,\n-            expand=True\n+            expand=True,\n         )\n         self.assertEqual(len(result), 4)\n \n@@ -441,15 +447,15 @@ class TestDXEventRecurrence(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def test_recurrence(self):\n-        tz = pytz.timezone(\'Europe/Vienna\')\n+        tz = pytz.timezone("Europe/Vienna")\n         duration = timedelta(days=4)\n         mock = MockEvent()\n         mock.start = tz.localize(datetime(2011, 11, 11, 11, 0))\n         mock.end = mock.start + duration\n-        mock.recurrence = \'RRULE:FREQ=DAILY;COUNT=4\'\n+        mock.recurrence = "RRULE:FREQ=DAILY;COUNT=4"\n         zope.interface.alsoProvides(\n-            mock, IEvent, IEventBasic, IEventRecurrence,\n-            IDXEvent, IDXEventRecurrence)\n+            mock, IEvent, IEventBasic, IEventRecurrence, IDXEvent, IDXEventRecurrence\n+        )\n         result = IRecurrenceSupport(mock).occurrences()\n         result = list(result)  # cast generator to list\n \n@@ -463,8 +469,7 @@ def test_recurrence(self):\n \n \n class TestDXEventUnittest(unittest.TestCase):\n-    """ Unit test for Dexterity event behaviors.\n-    """\n+    """Unit test for Dexterity event behaviors."""\n \n     def setUp(self):\n         self.orig_tz = set_env_timezone(TEST_TIMEZONE)\n@@ -546,50 +551,51 @@ def test_validate_dont_validate_incomplete(self):\n \n \n class TestDXAnnotationStorageUpdate(unittest.TestCase):\n-    """ Unit tests for the Annotation Storage migration\n-    """\n+    """Unit tests for the Annotation Storage migration"""\n+\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     location = u"K\xc3\xb6ln"\n-    attendees = (u\'Peter\', u\'S\xc3\xb8ren\', u\'Madeleine\')\n-    contact_email = u\'person@email.com\'\n-    contact_name = u\'Peter Parker\'\n-    contact_phone = u\'555 123 456\'\n-    event_url = u\'http://my.event.url\'\n-    text = u\'<p>Cathedral Sprint in K\xc3\xb6ln</p>\'\n+    attendees = (u"Peter", u"S\xc3\xb8ren", u"Madeleine")\n+    contact_email = u"person@email.com"\n+    contact_name = u"Peter Parker"\n+    contact_phone = u"555 123 456"\n+    event_url = u"http://my.event.url"\n+    text = u"<p>Cathedral Sprint in K\xc3\xb6ln</p>"\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n         set_browserlayer(self.request)\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_migrate_fields(self):\n-        tz = pytz.timezone(\'Europe/Berlin\')\n+        tz = pytz.timezone("Europe/Berlin")\n         e1 = createContentInContainer(\n             self.portal,\n-            \'Event\',\n-            title=u\'event1\',\n+            "Event",\n+            title=u"event1",\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             end=tz.localize(datetime(2011, 11, 11, 12, 0)),\n         )\n \n         # Fill the field values into the annotation storage\n         ann = IAnnotations(e1)\n-        ann[\'plone.app.event.dx.behaviors.IEventLocation.location\'] = \\\n-            self.location\n-        ann[\'plone.app.event.dx.behaviors.IEventAttendees.attendees\'] = \\\n-            self.attendees\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.contact_email\'] = \\\n-            self.contact_email\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.contact_name\'] = \\\n-            self.contact_name\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.contact_phone\'] = \\\n-            self.contact_phone\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.event_url\'] = \\\n-            self.event_url\n-        ann[\'plone.app.event.dx.behaviors.IEventSummary.text\'] = \\\n-            RichTextValue(raw=self.text)\n+        ann["plone.app.event.dx.behaviors.IEventLocation.location"] = self.location\n+        ann["plone.app.event.dx.behaviors.IEventAttendees.attendees"] = self.attendees\n+        ann[\n+            "plone.app.event.dx.behaviors.IEventContact.contact_email"\n+        ] = self.contact_email\n+        ann[\n+            "plone.app.event.dx.behaviors.IEventContact.contact_name"\n+        ] = self.contact_name\n+        ann[\n+            "plone.app.event.dx.behaviors.IEventContact.contact_phone"\n+        ] = self.contact_phone\n+        ann["plone.app.event.dx.behaviors.IEventContact.event_url"] = self.event_url\n+        ann["plone.app.event.dx.behaviors.IEventSummary.text"] = RichTextValue(\n+            raw=self.text\n+        )\n \n         # All behavior-related fields are not set yet\n         self.assertEqual(e1.location, None)\n@@ -613,31 +619,38 @@ def test_migrate_fields(self):\n         self.assertEqual(e1.text.raw, self.text)\n \n     def test_no_overwrite(self):\n-        tz = pytz.timezone(\'Europe/Berlin\')\n+        tz = pytz.timezone("Europe/Berlin")\n         e1 = createContentInContainer(\n             self.portal,\n-            \'Event\',\n-            title=u\'event1\',\n+            "Event",\n+            title=u"event1",\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             end=tz.localize(datetime(2011, 11, 11, 12, 0)),\n         )\n \n         # Fill the field values into the annotation storage\n         ann = IAnnotations(e1)\n-        ann[\'plone.app.event.dx.behaviors.IEventLocation.location\'] = \\\n-            self.location + u\'X\'\n-        ann[\'plone.app.event.dx.behaviors.IEventAttendees.attendees\'] = \\\n-            self.attendees + (u\'Paula\',)\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.contact_email\'] = \\\n-            self.contact_email + u\'X\'\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.contact_name\'] = \\\n-            self.contact_name + u\'X\'\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.contact_phone\'] = \\\n-            self.contact_phone + u\'X\'\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.event_url\'] = \\\n-            self.event_url + u\'X\'\n-        ann[\'plone.app.event.dx.behaviors.IEventSummary.text\'] = \\\n-            RichTextValue(raw=self.text + u\'X\')\n+        ann["plone.app.event.dx.behaviors.IEventLocation.location"] = (\n+            self.location + u"X"\n+        )\n+        ann[\n+            "plone.app.event.dx.behaviors.IEventAttendees.attendees"\n+        ] = self.attendees + (u"Paula",)\n+        ann["plone.app.event.dx.behaviors.IEventContact.contact_email"] = (\n+            self.contact_email + u"X"\n+        )\n+        ann["plone.app.event.dx.behaviors.IEventContact.contact_name"] = (\n+            self.contact_name + u"X"\n+        )\n+        ann["plone.app.event.dx.behaviors.IEventContact.contact_phone"] = (\n+            self.contact_phone + u"X"\n+        )\n+        ann["plone.app.event.dx.behaviors.IEventContact.event_url"] = (\n+            self.event_url + u"X"\n+        )\n+        ann["plone.app.event.dx.behaviors.IEventSummary.text"] = RichTextValue(\n+            raw=self.text + u"X"\n+        )\n \n         # Add values into the fields in the new way\n         e1.location = self.location\ndiff --git a/plone/app/event/tests/test_event_listing.py b/plone/app/event/tests/test_event_listing.py\nindex 72e7f9ba..406f03f9 100644\n--- a/plone/app/event/tests/test_event_listing.py\n+++ b/plone/app/event/tests/test_event_listing.py\n@@ -11,55 +11,54 @@\n class TestEventsListingPortal(AbstractSampleDataEvents):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n-    def _listing_view(self, name=\'@@event_listing\'):\n+    def _listing_view(self, name="@@event_listing"):\n         return self.portal.restrictedTraverse(name)\n \n-    @mock.patch(\'plone.app.event.browser.event_listing.localized_now\', new=PN)\n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.browser.event_listing.localized_now", new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_get_events_future(self):\n         # Default mode is to show all events from now on.\n         view = self._listing_view()\n         self.assertEqual(len(view.events(batch=False)), 5)\n \n-    @mock.patch(\'plone.app.event.browser.event_listing.localized_now\', new=PN)\n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.browser.event_listing.localized_now", new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_get_events_past(self):\n-        self.request.form.update({\'mode\': \'past\'})\n+        self.request.form.update({"mode": "past"})\n         view = self._listing_view()\n         self.assertEqual(len(view.events(batch=False)), 5)\n \n-    @mock.patch(\'plone.app.event.browser.event_listing.localized_now\', new=PN)\n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.browser.event_listing.localized_now", new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_get_events_all(self):\n-        self.request.form.update({\'mode\': \'all\'})\n+        self.request.form.update({"mode": "all"})\n         view = self._listing_view()\n         self.assertEqual(len(view.events(batch=False)), 8)\n \n-    @mock.patch(\'plone.app.event.browser.event_listing.localized_now\', new=PN)\n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.browser.event_listing.localized_now", new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_get_events_today(self):\n         today = localized_today().isoformat()\n-        self.request.form.update({\'mode\': \'day\', \'date\': today})\n+        self.request.form.update({"mode": "day", "date": today})\n         view = self._listing_view()\n         self.assertEqual(len(view.events(batch=False)), 2)\n \n-    @mock.patch(\'plone.app.event.browser.event_listing.localized_now\', new=PN)\n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.browser.event_listing.localized_now", new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_events_listing_ical(self):\n         # Default mode is to show all events from now on.\n         headers, output, request = make_fake_response(self.request)\n-        view = self._listing_view(name=\'@@event_listing_ical\')\n+        view = self._listing_view(name="@@event_listing_ical")\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n-        icalstr = b\'\'.join(output)\n-        self.assertTrue(b\'Long Event\' in icalstr)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n+        icalstr = b"".join(output)\n+        self.assertTrue(b"Long Event" in icalstr)\n \n \n class TestEventsListingCollection(TestEventsListingPortal):\n-\n-    def _listing_view(self, name=\'@@event_listing\'):\n+    def _listing_view(self, name="@@event_listing"):\n         return self.portal.collection.restrictedTraverse(name)\n \n     def _collection_batching_base(self):\n@@ -70,39 +69,37 @@ def _collection_batching_base(self):\n         environment with newly calculated results.\n         """\n         # plone.app.contenttypes ICollection type\n-        self.portal.invokeFactory(\'Collection\', \'col_test\', title=u\'Col\')\n+        self.portal.invokeFactory("Collection", "col_test", title=u"Col")\n         collection = self.portal.col_test\n         collection.query = [\n-            {\'i\': \'portal_type\',\n-             \'o\': \'plone.app.querystring.operation.selection.any\',\n-             \'v\': [\'Event\', \'plone.app.event.dx.event\']\n-             },\n+            {\n+                "i": "portal_type",\n+                "o": "plone.app.querystring.operation.selection.any",\n+                "v": ["Event", "plone.app.event.dx.event"],\n+            },\n         ]\n-        self.request.form.update({\'mode\': \'all\'})\n+        self.request.form.update({"mode": "all"})\n         return collection\n \n     def test_collection_batching__all(self):\n-        """Don\'t limit the results.\n-        """\n+        """Don\'t limit the results."""\n         collection = self._collection_batching_base()\n-        view = collection.restrictedTraverse(\'@@event_listing\')\n+        view = collection.restrictedTraverse("@@event_listing")\n         self.assertEqual(len(view.events(batch=True)), 8)\n \n     def test_collection_batching__reduce_by_collection_setting(self):\n-        """Limit the results by setting item_count on the collection.\n-        """\n+        """Limit the results by setting item_count on the collection."""\n         collection = self._collection_batching_base()\n-        view = collection.restrictedTraverse(\'@@event_listing\')\n+        view = collection.restrictedTraverse("@@event_listing")\n         collection.item_count = 4\n-        view = collection.restrictedTraverse(\'@@event_listing\')\n+        view = collection.restrictedTraverse("@@event_listing")\n         self.assertEqual(len(view.events(batch=True)), 4)\n \n     def test_collection_batching__reduce_by_request_parameter(self):\n-        """Limit the results by using a request parameter.\n-        """\n+        """Limit the results by using a request parameter."""\n         collection = self._collection_batching_base()\n-        self.request.form.update({\'b_size\': 2})\n-        view = collection.restrictedTraverse(\'@@event_listing\')\n+        self.request.form.update({"b_size": 2})\n+        view = collection.restrictedTraverse("@@event_listing")\n         self.assertEqual(len(view.events(batch=True)), 2)\n \n     def test_date_filtering(self):\n@@ -111,46 +108,48 @@ def test_date_filtering(self):\n         """\n         # plone.app.contenttypes ICollection type\n         self.portal.invokeFactory(\n-            \'Collection\', \'col_without_date_criterion\', title=u\'Col\')\n+            "Collection", "col_without_date_criterion", title=u"Col"\n+        )\n         collection = self.portal.col_without_date_criterion\n         collection.query = [\n-            {\'i\': \'portal_type\',\n-             \'o\': \'plone.app.querystring.operation.selection.any\',\n-             \'v\': [\'Event\', \'plone.app.event.dx.event\']\n-             },\n+            {\n+                "i": "portal_type",\n+                "o": "plone.app.querystring.operation.selection.any",\n+                "v": ["Event", "plone.app.event.dx.event"],\n+            },\n         ]\n         view = self.portal.col_without_date_criterion.restrictedTraverse(\n-            \'@@event_listing\'\n+            "@@event_listing"\n         )\n         out = view()\n-        self.assertTrue(\'mode_past\' in out)\n+        self.assertTrue("mode_past" in out)\n \n     def test_no_date_filtering(self):\n         """Test if date filters are not available on Collections with start or\n         end search criterias.\n         """\n         # plone.app.contenttypes ICollection type\n-        self.portal.invokeFactory(\n-            \'Collection\', \'col_with_date_criterion\', title=u\'Col\')\n+        self.portal.invokeFactory("Collection", "col_with_date_criterion", title=u"Col")\n         collection = self.portal.col_with_date_criterion\n         collection.query = [\n-            {\'i\': \'portal_type\',\n-             \'o\': \'plone.app.querystring.operation.selection.any\',\n-             \'v\': [\'Event\', \'plone.app.event.dx.event\']\n-             },\n-            {\'i\': \'start\',\n-             \'o\': \'plone.app.querystring.operation.date.afterToday\',\n-             \'v\': \'\'}\n+            {\n+                "i": "portal_type",\n+                "o": "plone.app.querystring.operation.selection.any",\n+                "v": ["Event", "plone.app.event.dx.event"],\n+            },\n+            {\n+                "i": "start",\n+                "o": "plone.app.querystring.operation.date.afterToday",\n+                "v": "",\n+            },\n         ]\n-        view = self.portal.col_with_date_criterion.restrictedTraverse(\n-            \'@@event_listing\'\n-        )\n+        view = self.portal.col_with_date_criterion.restrictedTraverse("@@event_listing")\n         out = view()\n         for _class in [\n-            \'mode_future\',\n-            \'mode_past\',\n-            \'mode_month\',\n-            \'mode_week\',\n-            \'mode_day\',\n+            "mode_future",\n+            "mode_past",\n+            "mode_month",\n+            "mode_week",\n+            "mode_day",\n         ]:\n             self.assertTrue(_class not in out)\ndiff --git a/plone/app/event/tests/test_event_summary.py b/plone/app/event/tests/test_event_summary.py\nindex eedcb952..a353e81c 100644\n--- a/plone/app/event/tests/test_event_summary.py\n+++ b/plone/app/event/tests/test_event_summary.py\n@@ -14,24 +14,22 @@ class TestEventSummaryDX(AbstractSampleDataEvents):\n     def traverser(self):\n         return OccTravDX(self.now_event, self.request)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_summary__non_recurring(self):\n-        """Test if some specific content is included here.\n-        """\n-        view = self.portal.future.restrictedTraverse(\'@@event_summary\')\n+        """Test if some specific content is included here."""\n+        view = self.portal.future.restrictedTraverse("@@event_summary")\n \n         output = view()\n \n-        self.assertTrue(\'2013-05-15\' in output)\n-        self.assertTrue(\'(Europe/Vienna / UTC200)\' in output)\n-        self.assertTrue(\'Graz\' in output)\n-        self.assertTrue(\'All dates\' not in output)\n+        self.assertTrue("2013-05-15" in output)\n+        self.assertTrue("(Europe/Vienna / UTC200)" in output)\n+        self.assertTrue("Graz" in output)\n+        self.assertTrue("All dates" not in output)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_summary__recurring(self):\n-        """Test if some specific content is included here.\n-        """\n-        view = self.portal.now.restrictedTraverse(\'@@event_summary\')\n+        """Test if some specific content is included here."""\n+        view = self.portal.now.restrictedTraverse("@@event_summary")\n \n         self.assertEqual(view.is_occurrence, False)\n         self.assertEqual(len(view.next_occurrences), 3)\n@@ -40,18 +38,17 @@ def test_event_summary__recurring(self):\n         output = view()\n \n         # self.assertTrue(\'Now Event\' not in output)  # Title not shown by def.\n-        self.assertTrue(\'2013-05-05\' in output)\n-        self.assertTrue(\'All dates\' in output)\n-        self.assertTrue(\'2013-05-07\' in output)\n-        self.assertTrue(\'2013-05-09\' in output)\n-        self.assertTrue(\'http://plone.org\' in output)\n+        self.assertTrue("2013-05-05" in output)\n+        self.assertTrue("All dates" in output)\n+        self.assertTrue("2013-05-07" in output)\n+        self.assertTrue("2013-05-09" in output)\n+        self.assertTrue("http://plone.org" in output)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_summary__recurring_occurrence(self):\n-        """Test if some specific content is included here.\n-        """\n-        occ = self.traverser.publishTraverse(self.request, \'2013-05-07\')\n-        view = occ.restrictedTraverse(\'@@event_summary\')\n+        """Test if some specific content is included here."""\n+        occ = self.traverser.publishTraverse(self.request, "2013-05-07")\n+        view = occ.restrictedTraverse("@@event_summary")\n \n         self.assertEqual(view.is_occurrence, True)\n         # Lists only upcoming relative to occurrence\'s date\n@@ -62,14 +59,16 @@ def test_event_summary__recurring_occurrence(self):\n \n         output = view()\n \n-        self.assertTrue(\'Now Event\' not in output)  # Title not shown by def.\n-        self.assertTrue(\'All dates\' in output)\n-        self.assertTrue(\'2013-05-05\' not in output)  # Lists only upcoming relative to occurrence\'s date  # noqa\n-        self.assertTrue(\'2013-05-07\' in output)\n-        self.assertTrue(\'2013-05-09\' in output)\n-        self.assertTrue(\'http://plone.org\' in output)\n+        self.assertTrue("Now Event" not in output)  # Title not shown by def.\n+        self.assertTrue("All dates" in output)\n+        self.assertTrue(\n+            "2013-05-05" not in output\n+        )  # Lists only upcoming relative to occurrence\'s date  # noqa\n+        self.assertTrue("2013-05-07" in output)\n+        self.assertTrue("2013-05-09" in output)\n+        self.assertTrue("http://plone.org" in output)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_summary__recurring_last_occurrence(self):\n         """Test if some specific content is included here.\n \n@@ -77,8 +76,8 @@ def test_event_summary__recurring_last_occurrence(self):\n         the link to the event_listing view, where all occurrences of the event\n         are shown.\n         """\n-        occ = self.traverser.publishTraverse(self.request, \'2013-05-09\')\n-        view = occ.restrictedTraverse(\'@@event_summary\')\n+        occ = self.traverser.publishTraverse(self.request, "2013-05-09")\n+        view = occ.restrictedTraverse("@@event_summary")\n \n         self.assertEqual(view.is_occurrence, True)\n         # Lists only upcoming relative to occurrence\'s date. Here no other,\n@@ -91,29 +90,28 @@ def test_event_summary__recurring_last_occurrence(self):\n \n         output = view()\n \n-        self.assertTrue(\'Now Event\' not in output)  # Title not shown by def.\n-        self.assertTrue(\'All dates\' in output)\n-        self.assertTrue(\'2013-05-05\' not in output)\n-        self.assertTrue(\'2013-05-07\' not in output)\n-        self.assertTrue(\'2013-05-09\' in output)\n-        self.assertTrue(\'http://plone.org\' in output)\n+        self.assertTrue("Now Event" not in output)  # Title not shown by def.\n+        self.assertTrue("All dates" in output)\n+        self.assertTrue("2013-05-05" not in output)\n+        self.assertTrue("2013-05-07" not in output)\n+        self.assertTrue("2013-05-09" in output)\n+        self.assertTrue("http://plone.org" in output)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_summary__recurring_excludes(self):\n-        """Test if some specific content is excluded here.\n-        """\n-        view = self.portal.now.restrictedTraverse(\'@@event_summary\')\n+        """Test if some specific content is excluded here."""\n+        view = self.portal.now.restrictedTraverse("@@event_summary")\n         ex = view.excludes\n-        view.excludes = [\'occurrences\', \'event_url\']\n+        view.excludes = ["occurrences", "event_url"]\n \n         output = view()\n \n-        self.assertTrue(\'Now Event\' not in output)  # Title not shown by def.\n-        self.assertTrue(\'2013-05-05\' in output)\n-        self.assertTrue(\'All dates\' not in output)\n-        self.assertTrue(\'2013-05-07\' not in output)\n-        self.assertTrue(\'2013-05-09\' not in output)\n-        self.assertTrue(\'http://plone.org\' not in output)\n+        self.assertTrue("Now Event" not in output)  # Title not shown by def.\n+        self.assertTrue("2013-05-05" in output)\n+        self.assertTrue("All dates" not in output)\n+        self.assertTrue("2013-05-07" not in output)\n+        self.assertTrue("2013-05-09" not in output)\n+        self.assertTrue("http://plone.org" not in output)\n \n         # Restore default excludes\n         view.excludes = ex\ndiff --git a/plone/app/event/tests/test_event_view.py b/plone/app/event/tests/test_event_view.py\nindex fa977fdc..eef581af 100644\n--- a/plone/app/event/tests/test_event_view.py\n+++ b/plone/app/event/tests/test_event_view.py\n@@ -14,40 +14,42 @@ class FunctionalTestEventViewDX(AbstractSampleDataEvents):\n     def traverser(self):\n         return OccTravDX(self.now_event, self.request)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_view__non_recurring(self):\n-        view = self.portal.future.restrictedTraverse(\'@@event_view\')\n+        view = self.portal.future.restrictedTraverse("@@event_view")\n \n         output = view()\n \n-        self.assertTrue(\'Future Event\' in output)\n-        self.assertTrue(\'2013-05-15\' in output)\n-        self.assertTrue(\'(Europe/Vienna / UTC200)\' in output)\n-        self.assertTrue(\'Graz\' in output)\n-        self.assertTrue(\'All dates\' not in output)\n+        self.assertTrue("Future Event" in output)\n+        self.assertTrue("2013-05-15" in output)\n+        self.assertTrue("(Europe/Vienna / UTC200)" in output)\n+        self.assertTrue("Graz" in output)\n+        self.assertTrue("All dates" not in output)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_view__recurring(self):\n-        view = self.portal.now.restrictedTraverse(\'@@event_view\')\n+        view = self.portal.now.restrictedTraverse("@@event_view")\n \n         output = view()\n \n-        self.assertTrue(\'Now Event\' in output)\n-        self.assertTrue(\'2013-05-05\' in output)\n-        self.assertTrue(\'All dates\' in output)\n-        self.assertTrue(\'2013-05-07\' in output)\n-        self.assertTrue(\'2013-05-09\' in output)\n-        self.assertTrue(\'http://plone.org\' in output)\n+        self.assertTrue("Now Event" in output)\n+        self.assertTrue("2013-05-05" in output)\n+        self.assertTrue("All dates" in output)\n+        self.assertTrue("2013-05-07" in output)\n+        self.assertTrue("2013-05-09" in output)\n+        self.assertTrue("http://plone.org" in output)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_view__recurring_occurrence(self):\n-        occ = self.traverser.publishTraverse(self.request, \'2013-05-07\')\n-        view = occ.restrictedTraverse(\'@@event_view\')\n+        occ = self.traverser.publishTraverse(self.request, "2013-05-07")\n+        view = occ.restrictedTraverse("@@event_view")\n \n         output = view()\n \n-        self.assertTrue(\'Now Event\' in output)\n-        self.assertTrue(\'2013-05-05\' not in output)  # Lists only upcoming relative to occurrence\'s date  # noqa\n-        self.assertTrue(\'2013-05-07\' in output)\n-        self.assertTrue(\'2013-05-09\' in output)\n-        self.assertTrue(\'http://plone.org\' in output)\n+        self.assertTrue("Now Event" in output)\n+        self.assertTrue(\n+            "2013-05-05" not in output\n+        )  # Lists only upcoming relative to occurrence\'s date  # noqa\n+        self.assertTrue("2013-05-07" in output)\n+        self.assertTrue("2013-05-09" in output)\n+        self.assertTrue("http://plone.org" in output)\ndiff --git a/plone/app/event/tests/test_ical_import.py b/plone/app/event/tests/test_ical_import.py\nindex 5a92d42c..3eab0d87 100644\n--- a/plone/app/event/tests/test_ical_import.py\n+++ b/plone/app/event/tests/test_ical_import.py\n@@ -24,23 +24,27 @@ class TestICALImportSettings(unittest.TestCase):\n     layer = PAEventDX_FUNCTIONAL_TESTING\n \n     def setUp(self):\n-        app = self.layer[\'app\']\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        app = self.layer["app"]\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n         self.browser = Browser(app)\n         self.browser.handleErrors = False\n         self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD,)\n+            "Authorization",\n+            "Basic %s:%s"\n+            % (\n+                SITE_OWNER_NAME,\n+                SITE_OWNER_PASSWORD,\n+            ),\n         )\n \n     def test_enable_ical_import(self):\n         """Test that ical import can be enabled/disabled in the browser.\n         Failed in Zope4: https://github.com/zopefoundation/Zope/issues/397\n         """\n-        self.portal.invokeFactory(\'Folder\', \'f1\')\n-        f1 = self.portal[\'f1\']\n+        self.portal.invokeFactory("Folder", "f1")\n+        f1 = self.portal["f1"]\n         self.assertFalse(IICalendarImportEnabled.providedBy(f1))\n \n         # enable/disable with the view\n@@ -51,10 +55,10 @@ def test_enable_ical_import(self):\n         self.assertFalse(IICalendarImportEnabled.providedBy(f1))\n \n         # enable/disable with traversal\n-        enable_method = f1.restrictedTraverse(\'ical_import_settings/enable\')\n+        enable_method = f1.restrictedTraverse("ical_import_settings/enable")\n         enable_method()\n         self.assertTrue(IICalendarImportEnabled.providedBy(f1))\n-        disable_method = f1.restrictedTraverse(\'ical_import_settings/disable\')\n+        disable_method = f1.restrictedTraverse("ical_import_settings/disable")\n         disable_method()\n         self.assertFalse(IICalendarImportEnabled.providedBy(f1))\n \n@@ -62,18 +66,18 @@ def test_enable_ical_import(self):\n         transaction.commit()\n         f1_url = f1.absolute_url()\n         self.assertFalse(IICalendarImportEnabled.providedBy(f1))\n-        self.browser.open(f1_url + \'/ical_import_settings/enable\')\n-        self.browser.getControl(\'Confirm action\').click()\n+        self.browser.open(f1_url + "/ical_import_settings/enable")\n+        self.browser.getControl("Confirm action").click()\n         self.assertTrue(IICalendarImportEnabled.providedBy(f1))\n-        self.browser.open(f1_url + \'/ical_import_settings/disable\')\n-        self.browser.getControl(\'Confirm action\').click()\n+        self.browser.open(f1_url + "/ical_import_settings/disable")\n+        self.browser.getControl("Confirm action").click()\n         self.assertFalse(IICalendarImportEnabled.providedBy(f1))\n \n         # the form can be rendered\n-        self.browser.open(f1_url + \'/ical_import_settings\')\n+        self.browser.open(f1_url + "/ical_import_settings")\n         self.assertIn(\n-            \'URL to an external icalendar resource file\',\n-            self.browser.contents)\n+            "URL to an external icalendar resource file", self.browser.contents\n+        )\n \n     def test_constraint(self):\n         self.portal.invokeFactory("Folder", "f1")\n@@ -87,7 +91,11 @@ def test_constraint(self):\n \n         # Set it to a file url.\n         self.browser.open(f1_url + "/ical_import_settings")\n-        self.assertIn("URL to an external icalendar resource file", self.browser.contents)\n-        self.browser.getControl(name="form.widgets.ical_url").value = "file:///tmp/test.ical"\n+        self.assertIn(\n+            "URL to an external icalendar resource file", self.browser.contents\n+        )\n+        self.browser.getControl(\n+            name="form.widgets.ical_url"\n+        ).value = "file:///tmp/test.ical"\n         self.browser.getControl(name="form.buttons.save").click()\n         self.assertIn("URLs with file: are not allowed.", self.browser.contents)\ndiff --git a/plone/app/event/tests/test_icalendar.py b/plone/app/event/tests/test_icalendar.py\nindex a279ab75..8e7ad5ab 100644\n--- a/plone/app/event/tests/test_icalendar.py\n+++ b/plone/app/event/tests/test_icalendar.py\n@@ -34,55 +34,55 @@ def checkOrder(self, text, *order):\n         for item in order:\n             position = text.find(item)\n             self.assertTrue(\n-                position >= 0,\n-                \'menu item "%s" missing or out of order\' % item\n+                position >= 0, \'menu item "%s" missing or out of order\' % item\n             )\n             text = text[position:]\n \n     def test_event_ical(self):\n         headers, output, request = make_fake_response(self.request)\n-        view = getMultiAdapter((self.now_event, request), name=\'ics_view\')\n+        view = getMultiAdapter((self.now_event, request), name="ics_view")\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n         if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n+            output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n         self.checkOrder(\n             icalstr,\n-            \'BEGIN:VCALENDAR\',\n-            \'VERSION:2.0\',\n-            \'PRODID:-//Plone.org//NONSGML plone.app.event//EN\',\n-            \'X-WR-TIMEZONE:Europe/Vienna\',\n-            \'BEGIN:VEVENT\',\n-            \'SUMMARY:Now Event\',\n-            \'DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T100000\',\n-            \'DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T110000\',\n-            \'DTSTAMP;VALUE=DATE-TIME:\',\n-            \'UID:\',\n-            \'RRULE:FREQ=DAILY;COUNT=3;INTERVAL=1\',\n-            \'RDATE;TZID=Europe/Vienna:20130509T000000\',\n-            \'EXDATE;TZID=Europe/Vienna:20130506T000000,20140404T000000\',\n-            \'CATEGORIES:plone,testing\',\n-            \'CONTACT:Auto Testdriver\\\\, +123456789\\\\, testdriver@plone.org\\\\, http://plone\',  # noqa\n-            \' .org\',  # line longer than max length spec by icalendar\n-            \'CREATED;VALUE=DATE-TIME:\',\n-            \'LAST-MODIFIED;VALUE=DATE-TIME:\',\n-            \'LOCATION:Vienna\',\n-            \'URL:http://nohost/plone/now\',\n-            \'END:VEVENT\',\n-            \'BEGIN:VTIMEZONE\',\n-            \'TZID:Europe/Vienna\',\n-            \'X-LIC-LOCATION:Europe/Vienna\',\n-            \'BEGIN:DAYLIGHT\',\n-            \'DTSTART;VALUE=DATE-TIME:20130331T030000\',\n-            \'TZNAME:CEST\',\n-            \'TZOFFSETFROM:+0100\',\n-            \'TZOFFSETTO:+0200\',\n-            \'END:DAYLIGHT\',\n-            \'END:VTIMEZONE\',\n-            \'END:VCALENDAR\')\n+            "BEGIN:VCALENDAR",\n+            "VERSION:2.0",\n+            "PRODID:-//Plone.org//NONSGML plone.app.event//EN",\n+            "X-WR-TIMEZONE:Europe/Vienna",\n+            "BEGIN:VEVENT",\n+            "SUMMARY:Now Event",\n+            "DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T100000",\n+            "DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T110000",\n+            "DTSTAMP;VALUE=DATE-TIME:",\n+            "UID:",\n+            "RRULE:FREQ=DAILY;COUNT=3;INTERVAL=1",\n+            "RDATE;TZID=Europe/Vienna:20130509T000000",\n+            "EXDATE;TZID=Europe/Vienna:20130506T000000,20140404T000000",\n+            "CATEGORIES:plone,testing",\n+            "CONTACT:Auto Testdriver\\\\, +123456789\\\\, testdriver@plone.org\\\\, http://plone",  # noqa\n+            " .org",  # line longer than max length spec by icalendar\n+            "CREATED;VALUE=DATE-TIME:",\n+            "LAST-MODIFIED;VALUE=DATE-TIME:",\n+            "LOCATION:Vienna",\n+            "URL:http://nohost/plone/now",\n+            "END:VEVENT",\n+            "BEGIN:VTIMEZONE",\n+            "TZID:Europe/Vienna",\n+            "X-LIC-LOCATION:Europe/Vienna",\n+            "BEGIN:DAYLIGHT",\n+            "DTSTART;VALUE=DATE-TIME:20130331T030000",\n+            "TZNAME:CEST",\n+            "TZOFFSETFROM:+0100",\n+            "TZOFFSETTO:+0200",\n+            "END:DAYLIGHT",\n+            "END:VTIMEZONE",\n+            "END:VCALENDAR",\n+        )\n \n     def test_event_occurrence_ical(self):\n         """A event occurrence should not conain recurrence definitions from\n@@ -90,105 +90,102 @@ def test_event_occurrence_ical(self):\n         """\n         headers, output, request = make_fake_response(self.request)\n         occ = self.traverser(self.now_event, request).publishTraverse(\n-            request, \'2013-05-07\'\n+            request, "2013-05-07"\n         )\n-        view = getMultiAdapter((occ, request), name=\'ics_view\')\n+        view = getMultiAdapter((occ, request), name="ics_view")\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n         if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n-        self.assertTrue(\'Now Event\' in icalstr)\n-        self.assertTrue(\'RRULE\' not in icalstr)\n+            output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n+        self.assertTrue("Now Event" in icalstr)\n+        self.assertTrue("RRULE" not in icalstr)\n \n     def test_portal_ical(self):\n         headers, output, request = make_fake_response(self.request)\n-        view = getMultiAdapter((self.portal, request), name=\'ics_view\')\n+        view = getMultiAdapter((self.portal, request), name="ics_view")\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n         if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n+            output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n \n         # No occurrences in export. Otherwise count would be 8.\n-        self.assertEqual(icalstr.count(\'BEGIN:VEVENT\'), 4)\n+        self.assertEqual(icalstr.count("BEGIN:VEVENT"), 4)\n         self.checkOrder(\n             icalstr,\n-            \'BEGIN:VCALENDAR\',\n-            \'VERSION:2.0\',\n-            \'PRODID:-//Plone.org//NONSGML plone.app.event//EN\',\n-            \'X-WR-TIMEZONE:Europe/Vienna\',\n+            "BEGIN:VCALENDAR",\n+            "VERSION:2.0",\n+            "PRODID:-//Plone.org//NONSGML plone.app.event//EN",\n+            "X-WR-TIMEZONE:Europe/Vienna",\n             # whole_day event\n-            \'BEGIN:VEVENT\',\n-            \'SUMMARY:Past Event\',\n-            \'DTSTART;VALUE=DATE:20130425\',\n-            \'DTEND;VALUE=DATE:20130426\',\n-            \'DTSTAMP;VALUE=DATE-TIME:\',\n-            \'UID:\',\n-            \'RRULE:FREQ=DAILY;COUNT=3\',\n-            \'CREATED;VALUE=DATE-TIME:\',\n-            \'LAST-MODIFIED;VALUE=DATE-TIME:\',\n-            \'LOCATION:Vienna\',\n-            \'URL:http://nohost/plone/past\',\n-            \'END:VEVENT\',\n-\n-            \'BEGIN:VEVENT\',\n-            \'SUMMARY:Long Event\',\n-            \'DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130425T100000\',\n-            \'DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130604T100000\',\n-            \'DTSTAMP;VALUE=DATE-TIME:\',\n-            \'UID:\',\n-            \'CREATED;VALUE=DATE-TIME:\',\n-            \'LAST-MODIFIED;VALUE=DATE-TIME:\',\n-            \'LOCATION:Schaftal\',\n-            \'URL:http://nohost/plone/sub/long\',\n-            \'END:VEVENT\',\n-\n-            \'BEGIN:VEVENT\',\n-            \'SUMMARY:Now Event\',\n-            \'DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T100000\',\n-            \'DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T110000\',\n-            \'DTSTAMP;VALUE=DATE-TIME:\',\n-            \'UID:\',\n-            \'RRULE:FREQ=DAILY;COUNT=3;INTERVAL=1\',\n-            \'RDATE;TZID=Europe/Vienna:20130509T000000\',\n-            \'EXDATE;TZID=Europe/Vienna:20130506T000000,20140404T000000\',\n-            \'CATEGORIES:plone,testing\',\n-            \'CONTACT:Auto Testdriver\\\\, +123456789\\\\, testdriver@plone.org\\\\, http://plone\',  # noqa\n-            \' .org\',\n-            \'CREATED;VALUE=DATE-TIME:\',\n-            \'LAST-MODIFIED;VALUE=DATE-TIME:\',\n-            \'LOCATION:Vienna\',\n-            \'URL:http://nohost/plone/now\',\n-            \'END:VEVENT\',\n-\n-            \'BEGIN:VEVENT\',\n-            \'SUMMARY:Future Event\',\n-            \'DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130515T100000\',\n-            \'DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130515T110000\',\n-            \'DTSTAMP;VALUE=DATE-TIME:\',\n-            \'UID:\',\n-            \'CREATED;VALUE=DATE-TIME:\',\n-            \'LAST-MODIFIED;VALUE=DATE-TIME:\',\n-            \'LOCATION:Graz\',\n-            \'URL:http://nohost/plone/future\',\n-            \'END:VEVENT\',\n-\n-            \'BEGIN:VTIMEZONE\',\n-            \'TZID:Europe/Vienna\',\n-            \'X-LIC-LOCATION:Europe/Vienna\',\n-            \'BEGIN:DAYLIGHT\',\n-            \'DTSTART;VALUE=DATE-TIME:20130331T030000\',\n-            \'TZNAME:CEST\',\n-            \'TZOFFSETFROM:+0100\',\n-            \'TZOFFSETTO:+0200\',\n-            \'END:DAYLIGHT\',\n-            \'END:VTIMEZONE\',\n-            \'END:VCALENDAR\')\n+            "BEGIN:VEVENT",\n+            "SUMMARY:Past Event",\n+            "DTSTART;VALUE=DATE:20130425",\n+            "DTEND;VALUE=DATE:20130426",\n+            "DTSTAMP;VALUE=DATE-TIME:",\n+            "UID:",\n+            "RRULE:FREQ=DAILY;COUNT=3",\n+            "CREATED;VALUE=DATE-TIME:",\n+            "LAST-MODIFIED;VALUE=DATE-TIME:",\n+            "LOCATION:Vienna",\n+            "URL:http://nohost/plone/past",\n+            "END:VEVENT",\n+            "BEGIN:VEVENT",\n+            "SUMMARY:Long Event",\n+            "DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130425T100000",\n+            "DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130604T100000",\n+            "DTSTAMP;VALUE=DATE-TIME:",\n+            "UID:",\n+            "CREATED;VALUE=DATE-TIME:",\n+            "LAST-MODIFIED;VALUE=DATE-TIME:",\n+            "LOCATION:Schaftal",\n+            "URL:http://nohost/plone/sub/long",\n+            "END:VEVENT",\n+            "BEGIN:VEVENT",\n+            "SUMMARY:Now Event",\n+            "DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T100000",\n+            "DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T110000",\n+            "DTSTAMP;VALUE=DATE-TIME:",\n+            "UID:",\n+            "RRULE:FREQ=DAILY;COUNT=3;INTERVAL=1",\n+            "RDATE;TZID=Europe/Vienna:20130509T000000",\n+            "EXDATE;TZID=Europe/Vienna:20130506T000000,20140404T000000",\n+            "CATEGORIES:plone,testing",\n+            "CONTACT:Auto Testdriver\\\\, +123456789\\\\, testdriver@plone.org\\\\, http://plone",  # noqa\n+            " .org",\n+            "CREATED;VALUE=DATE-TIME:",\n+            "LAST-MODIFIED;VALUE=DATE-TIME:",\n+            "LOCATION:Vienna",\n+            "URL:http://nohost/plone/now",\n+            "END:VEVENT",\n+            "BEGIN:VEVENT",\n+            "SUMMARY:Future Event",\n+            "DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130515T100000",\n+            "DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130515T110000",\n+            "DTSTAMP;VALUE=DATE-TIME:",\n+            "UID:",\n+            "CREATED;VALUE=DATE-TIME:",\n+            "LAST-MODIFIED;VALUE=DATE-TIME:",\n+            "LOCATION:Graz",\n+            "URL:http://nohost/plone/future",\n+            "END:VEVENT",\n+            "BEGIN:VTIMEZONE",\n+            "TZID:Europe/Vienna",\n+            "X-LIC-LOCATION:Europe/Vienna",\n+            "BEGIN:DAYLIGHT",\n+            "DTSTART;VALUE=DATE-TIME:20130331T030000",\n+            "TZNAME:CEST",\n+            "TZOFFSETFROM:+0100",\n+            "TZOFFSETTO:+0200",\n+            "END:DAYLIGHT",\n+            "END:VTIMEZONE",\n+            "END:VCALENDAR",\n+        )\n \n     def test_event_listing_ical_portal(self):\n         """Test event_listing ical export. It should contain all events from\n@@ -196,19 +193,17 @@ def test_event_listing_ical_portal(self):\n         are exported.\n         """\n         headers, output, request = make_fake_response(self.request)\n-        view = getMultiAdapter(\n-            (self.portal, request), name=\'event_listing_ical\'\n-        )\n-        view.mode = \'all\'\n+        view = getMultiAdapter((self.portal, request), name="event_listing_ical")\n+        view.mode = "all"\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n         if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n+            output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n         # No occurrences in export. Otherwise count would be 8.\n-        self.assertEqual(icalstr.count(\'BEGIN:VEVENT\'), 4)\n+        self.assertEqual(icalstr.count("BEGIN:VEVENT"), 4)\n \n     def test_event_listing_ical_portal__specific_date(self):\n         """Test event_listing ical export for a specific date. The date is when\n@@ -216,38 +211,32 @@ def test_event_listing_ical_portal__specific_date(self):\n         original event and the long lasting event.\n         """\n         headers, output, request = make_fake_response(self.request)\n-        view = getMultiAdapter(\n-            (self.portal, request), name=\'event_listing_ical\'\n-        )\n-        view.mode = \'day\'\n-        view._date = \'2013-04-27\'\n+        view = getMultiAdapter((self.portal, request), name="event_listing_ical")\n+        view.mode = "day"\n+        view._date = "2013-04-27"\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n         if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n-        self.assertEqual(icalstr.count(\'BEGIN:VEVENT\'), 2)\n-        self.assertTrue(\'Past Event\' in icalstr)\n-        self.assertTrue(\'Long Event\' in icalstr)\n+            output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n+        self.assertEqual(icalstr.count("BEGIN:VEVENT"), 2)\n+        self.assertTrue("Past Event" in icalstr)\n+        self.assertTrue("Long Event" in icalstr)\n \n     def test_collection_ical(self):\n-        """Test basic icalendar export from Collections.\n-        """\n+        """Test basic icalendar export from Collections."""\n         headers, output, request = make_fake_response(self.request)\n-        view = getMultiAdapter(\n-            (self.portal.collection, request),\n-            name=\'ics_view\'\n-        )\n+        view = getMultiAdapter((self.portal.collection, request), name="ics_view")\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n         if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n-        self.assertEqual(icalstr.count(\'BEGIN:VEVENT\'), 4)\n+            output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n+        self.assertEqual(icalstr.count("BEGIN:VEVENT"), 4)\n \n     def test_collection_all_ical(self):\n         """Test basic icalendar export from Collections, which returns not only\n@@ -255,48 +244,46 @@ def test_collection_all_ical(self):\n         """\n         headers, output, request = make_fake_response(self.request)\n         self.portal.collection.query = [\n-            {\'i\': \'portal_type\',\n-             \'o\': \'plone.app.querystring.operation.selection.any\',\n-             \'v\': [\'Event\', \'plone.app.event.dx.event\', \'Page\']\n-             },\n+            {\n+                "i": "portal_type",\n+                "o": "plone.app.querystring.operation.selection.any",\n+                "v": ["Event", "plone.app.event.dx.event", "Page"],\n+            },\n         ]\n-        view = getMultiAdapter(\n-            (self.portal.collection, request),\n-            name=\'ics_view\'\n-        )\n+        view = getMultiAdapter((self.portal.collection, request), name="ics_view")\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n         if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n-        self.assertEqual(icalstr.count(\'BEGIN:VEVENT\'), 4)\n+            output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n+        self.assertEqual(icalstr.count("BEGIN:VEVENT"), 4)\n \n \n class TestIcalImportDX(unittest.TestCase):\n     layer = PAEventDX_FUNCTIONAL_TESTING\n-    event_type = \'plone.app.event.dx.event\'\n+    event_type = "plone.app.event.dx.event"\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_import_from_ics(self):\n         # Ical import unit test.\n-        self.portal.invokeFactory(\'Folder\', \'impfolder1\')\n+        self.portal.invokeFactory("Folder", "impfolder1")\n         impfolder = self.portal.impfolder1\n \n         directory = os.path.dirname(__file__)\n-        with open(os.path.join(directory, \'icaltest.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest.ics"), "rb") as icsfile:\n             icsdata = icsfile.read()\n         res = ical_import(impfolder, icsdata, self.event_type)\n \n-        self.assertEqual(res[\'count\'], 5)\n+        self.assertEqual(res["count"], 5)\n         self.assertEqual(len(impfolder.contentIds()), 5)\n \n-        at = pytz.timezone(\'Europe/Vienna\')\n+        at = pytz.timezone("Europe/Vienna")\n         utc = pytz.utc\n \n         # Use pydt to normalize for DST times.\n@@ -304,146 +291,96 @@ def test_import_from_ics(self):\n         # TODO: test for attendees. see note in\n         # plone.app.event.ical.importer.ical_import\n         e1 = IEventAccessor(impfolder.e1)\n-        self.assertEqual(\n-            e1.start,\n-            at.localize(datetime(2013, 7, 19, 12, 0))\n-        )\n-        self.assertEqual(\n-            e1.end,\n-            at.localize(datetime(2013, 7, 20, 13, 0))\n-        )\n-        self.assertEqual(\n-            e1.description,\n-            \'A basic event with many properties.\'\n-        )\n-        self.assertEqual(\n-            e1.whole_day,\n-            False\n-        )\n-        self.assertEqual(\n-            e1.open_end,\n-            False\n-        )\n+        self.assertEqual(e1.start, at.localize(datetime(2013, 7, 19, 12, 0)))\n+        self.assertEqual(e1.end, at.localize(datetime(2013, 7, 20, 13, 0)))\n+        self.assertEqual(e1.description, "A basic event with many properties.")\n+        self.assertEqual(e1.whole_day, False)\n+        self.assertEqual(e1.open_end, False)\n         self.assertEqual(\n             e1.sync_uid,\n-            u\'48f1a7ad64e847568d860cd092344970\',\n+            u"48f1a7ad64e847568d860cd092344970",\n         )\n \n         e2 = IEventAccessor(impfolder.e2)\n-        self.assertEqual(\n-            e2.start,\n-            utc.localize(datetime(1996, 4, 1, 1, 0))\n-        )\n-        self.assertEqual(\n-            e2.end,\n-            utc.localize(datetime(1996, 4, 1, 2, 0))\n-        )\n+        self.assertEqual(e2.start, utc.localize(datetime(1996, 4, 1, 1, 0)))\n+        self.assertEqual(e2.end, utc.localize(datetime(1996, 4, 1, 2, 0)))\n         self.assertEqual(\n             e2.recurrence,\n-            u\'RRULE:FREQ=DAILY;COUNT=100\\nEXDATE:19960402T010000Z,\'\n-            u\'19960403T010000Z,19960404T010000Z\'\n+            u"RRULE:FREQ=DAILY;COUNT=100\\nEXDATE:19960402T010000Z,"\n+            u"19960403T010000Z,19960404T010000Z",\n         )\n \n         e3 = IEventAccessor(impfolder.e3)\n-        self.assertEqual(\n-            e3.start,\n-            at.localize(datetime(2012, 3, 27, 10, 0))\n-        )\n-        self.assertEqual(\n-            e3.end,\n-            at.localize(datetime(2012, 3, 27, 18, 0))\n-        )\n+        self.assertEqual(e3.start, at.localize(datetime(2012, 3, 27, 10, 0)))\n+        self.assertEqual(e3.end, at.localize(datetime(2012, 3, 27, 18, 0)))\n         self.assertEqual(\n             e3.recurrence,\n-            u\'RRULE:FREQ=WEEKLY;UNTIL=20120703T080000Z;BYDAY=TU\\n\'\n-            u\'EXDATE:20120529T100000,20120403T100000,20120410T100000,\'\n-            u\'20120501T100000,20120417T100000\'\n+            u"RRULE:FREQ=WEEKLY;UNTIL=20120703T080000Z;BYDAY=TU\\n"\n+            u"EXDATE:20120529T100000,20120403T100000,20120410T100000,"\n+            u"20120501T100000,20120417T100000",\n         )\n \n         e4 = IEventAccessor(impfolder.e4)\n-        self.assertEqual(\n-            e4.start,\n-            utc.localize(datetime(2013, 4, 4, 0, 0))\n-        )\n-        self.assertEqual(\n-            e4.end,\n-            utc.localize(datetime(2013, 4, 4, 23, 59, 59))\n-        )\n-        self.assertEqual(\n-            e4.whole_day,\n-            True\n-        )\n-        self.assertEqual(\n-            e4.open_end,\n-            False\n-        )\n+        self.assertEqual(e4.start, utc.localize(datetime(2013, 4, 4, 0, 0)))\n+        self.assertEqual(e4.end, utc.localize(datetime(2013, 4, 4, 23, 59, 59)))\n+        self.assertEqual(e4.whole_day, True)\n+        self.assertEqual(e4.open_end, False)\n \n         e5 = IEventAccessor(impfolder.e5)\n-        self.assertEqual(\n-            e5.start,\n-            utc.localize(datetime(2013, 4, 2, 12, 0))\n-        )\n-        self.assertEqual(\n-            e5.end,\n-            utc.localize(datetime(2013, 4, 2, 23, 59, 59))\n-        )\n-        self.assertEqual(\n-            e5.whole_day,\n-            False\n-        )\n-        self.assertEqual(\n-            e5.open_end,\n-            True\n-        )\n+        self.assertEqual(e5.start, utc.localize(datetime(2013, 4, 2, 12, 0)))\n+        self.assertEqual(e5.end, utc.localize(datetime(2013, 4, 2, 23, 59, 59)))\n+        self.assertEqual(e5.whole_day, False)\n+        self.assertEqual(e5.open_end, True)\n \n     def test_import_from_ics__no_sync(self):\n         """SYNC_NONE and importing the same file again should create new event\n         objects and give them each a new sync_uid.\n         """\n-        self.portal.invokeFactory(\'Folder\', \'impfolder2\')\n+        self.portal.invokeFactory("Folder", "impfolder2")\n         impfolder = self.portal.impfolder2\n \n         directory = os.path.dirname(__file__)\n-        with open(os.path.join(directory, \'icaltest.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest.ics"), "rb") as icsfile:\n             icsdata = icsfile.read()\n \n         res = ical_import(impfolder, icsdata, self.event_type)\n \n-        self.assertEqual(res[\'count\'], 5)\n+        self.assertEqual(res["count"], 5)\n \n-        e11 = impfolder[\'e1\']\n+        e11 = impfolder["e1"]\n         suid1 = IEventAccessor(e11).sync_uid\n \n-        res = ical_import(impfolder, icsdata, self.event_type,\n-                          sync_strategy=base.SYNC_NONE)\n-        self.assertEqual(res[\'count\'], 5)\n+        res = ical_import(\n+            impfolder, icsdata, self.event_type, sync_strategy=base.SYNC_NONE\n+        )\n+        self.assertEqual(res["count"], 5)\n \n-        e12 = impfolder[\'e1-1\']\n+        e12 = impfolder["e1-1"]\n         suid2 = IEventAccessor(e12).sync_uid\n \n         self.assertEqual(len(impfolder.contentIds()), 10)\n         self.assertNotEqual(suid1, suid2)\n \n     def test_import_from_ics__sync_keep_mine(self):\n-        """SYNC_KEEP_MINE and importing the same file again should do nothing.\n-        """\n-        self.portal.invokeFactory(\'Folder\', \'impfolder3\')\n+        """SYNC_KEEP_MINE and importing the same file again should do nothing."""\n+        self.portal.invokeFactory("Folder", "impfolder3")\n         impfolder = self.portal.impfolder3\n \n         directory = os.path.dirname(__file__)\n-        with open(os.path.join(directory, \'icaltest.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest.ics"), "rb") as icsfile:\n             icsdata = icsfile.read()\n \n         res = ical_import(impfolder, icsdata, self.event_type)\n-        self.assertEqual(res[\'count\'], 5)\n+        self.assertEqual(res["count"], 5)\n \n         e1a = IEventAccessor(impfolder.e1)\n         mod1 = e1a.last_modified\n         suid1 = e1a.sync_uid\n \n-        res = ical_import(impfolder, icsdata, self.event_type,\n-                          sync_strategy=base.SYNC_KEEP_MINE)\n-        self.assertEqual(res[\'count\'], 0)\n+        res = ical_import(\n+            impfolder, icsdata, self.event_type, sync_strategy=base.SYNC_KEEP_MINE\n+        )\n+        self.assertEqual(res["count"], 0)\n         e1a = IEventAccessor(impfolder.e1)\n         mod2 = e1a.last_modified\n         suid2 = e1a.sync_uid\n@@ -457,18 +394,18 @@ def test_import_from_ics__sync_drop_older(self):\n         """SYNC_KEEP_NEWER and importing the same file again should update only\n         newer and on equal modified date but drop the change when it is older.\n         """\n-        self.portal.invokeFactory(\'Folder\', \'impfolder4\')\n+        self.portal.invokeFactory("Folder", "impfolder4")\n         impfolder = self.portal.impfolder4\n \n         directory = os.path.dirname(__file__)\n-        with open(os.path.join(directory, \'icaltest.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest.ics"), "rb") as icsfile:\n             icsdata1 = icsfile.read()\n \n-        with open(os.path.join(directory, \'icaltest2.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest2.ics"), "rb") as icsfile:\n             icsdata2 = icsfile.read()\n \n         res = ical_import(impfolder, icsdata1, self.event_type)\n-        self.assertEqual(res[\'count\'], 5)\n+        self.assertEqual(res["count"], 5)\n \n         e1a = IEventAccessor(impfolder.e1)\n         mod1 = e1a.last_modified\n@@ -478,9 +415,10 @@ def test_import_from_ics__sync_drop_older(self):\n         start1 = e1a.start\n         end1 = e1a.end\n \n-        res = ical_import(impfolder, icsdata2, self.event_type,\n-                          sync_strategy=base.SYNC_KEEP_NEWER)\n-        self.assertEqual(res[\'count\'], 4)\n+        res = ical_import(\n+            impfolder, icsdata2, self.event_type, sync_strategy=base.SYNC_KEEP_NEWER\n+        )\n+        self.assertEqual(res["count"], 4)\n         e1a = IEventAccessor(impfolder.e1)\n         mod2 = e1a.last_modified\n         suid2 = e1a.sync_uid\n@@ -502,19 +440,19 @@ def test_import_from_ics__sync_keep_theirs(self):\n         """SYNC_KEEP_THEIRS and importing the same file again should update\n         all.\n         """\n-        self.portal.invokeFactory(\'Folder\', \'impfolder5\')\n+        self.portal.invokeFactory("Folder", "impfolder5")\n         impfolder = self.portal.impfolder5\n \n         directory = os.path.dirname(__file__)\n \n-        with open(os.path.join(directory, \'icaltest.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest.ics"), "rb") as icsfile:\n             icsdata1 = icsfile.read()\n \n-        with open(os.path.join(directory, \'icaltest2.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest2.ics"), "rb") as icsfile:\n             icsdata2 = icsfile.read()\n \n         res = ical_import(impfolder, icsdata1, self.event_type)\n-        self.assertEqual(res[\'count\'], 5)\n+        self.assertEqual(res["count"], 5)\n \n         e1a = IEventAccessor(impfolder.e1)\n         mod11 = e1a.last_modified\n@@ -531,9 +469,10 @@ def test_import_from_ics__sync_keep_theirs(self):\n         start21 = e2a.start\n         end21 = e2a.end\n \n-        res = ical_import(impfolder, icsdata2, self.event_type,\n-                          sync_strategy=base.SYNC_KEEP_THEIRS)\n-        self.assertEqual(res[\'count\'], 5)\n+        res = ical_import(\n+            impfolder, icsdata2, self.event_type, sync_strategy=base.SYNC_KEEP_THEIRS\n+        )\n+        self.assertEqual(res["count"], 5)\n \n         e1a = IEventAccessor(impfolder.e1)\n         mod12 = e1a.last_modified\ndiff --git a/plone/app/event/tests/test_portlet_calendar.py b/plone/app/event/tests/test_portlet_calendar.py\nindex 618bb858..6e10d6c8 100644\n--- a/plone/app/event/tests/test_portlet_calendar.py\n+++ b/plone/app/event/tests/test_portlet_calendar.py\n@@ -27,33 +27,35 @@\n import unittest\n \n \n-TZNAME = \'Europe/Vienna\'\n-PTYPE = \'plone.app.event.dx.event\'\n+TZNAME = "Europe/Vienna"\n+PTYPE = "plone.app.event.dx.event"\n \n \n class PortletTest(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        portal = self.layer[\'portal\']\n+        portal = self.layer["portal"]\n         self.portal = portal\n-        self.request = self.layer[\'request\']\n-        setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+        self.request = self.layer["request"]\n+        setRoles(portal, TEST_USER_ID, ["Manager"])\n         setHooks()\n         setSite(portal)\n \n     def testPortletTypeRegistered(self):\n-        portlet = getUtility(IPortletType, name=\'portlets.Calendar\')\n-        self.assertEqual(portlet.addview, \'portlets.Calendar\')\n+        portlet = getUtility(IPortletType, name="portlets.Calendar")\n+        self.assertEqual(portlet.addview, "portlets.Calendar")\n \n     def testRegisteredInterfaces(self):\n-        portlet = getUtility(IPortletType, name=\'portlets.Calendar\')\n+        portlet = getUtility(IPortletType, name="portlets.Calendar")\n         registered_interfaces = [_getDottedName(i) for i in portlet.for_]\n         registered_interfaces.sort()\n-        self.assertEqual([\n-            \'plone.app.portlets.interfaces.IColumn\',\n-            \'plone.app.portlets.interfaces.IDashboard\'],\n-            registered_interfaces\n+        self.assertEqual(\n+            [\n+                "plone.app.portlets.interfaces.IColumn",\n+                "plone.app.portlets.interfaces.IDashboard",\n+            ],\n+            registered_interfaces,\n         )\n \n     def testInterfaces(self):\n@@ -62,13 +64,11 @@ def testInterfaces(self):\n         self.assertTrue(IPortletDataProvider.providedBy(portlet.data))\n \n     def testInvokeAddview(self):\n-        portlet = getUtility(IPortletType, name=\'portlets.Calendar\')\n-        mapping = self.portal.restrictedTraverse(\n-            \'++contextportlets++plone.leftcolumn\'\n-        )\n+        portlet = getUtility(IPortletType, name="portlets.Calendar")\n+        mapping = self.portal.restrictedTraverse("++contextportlets++plone.leftcolumn")\n         for m in mapping.keys():\n             del mapping[m]\n-        addview = mapping.restrictedTraverse(\'+/\' + portlet.addview)\n+        addview = mapping.restrictedTraverse("+/" + portlet.addview)\n \n         addview.createAndAdd(data={})\n \n@@ -79,17 +79,14 @@ def testInvokeAddview(self):\n \n     def testRenderer(self):\n         context = self.portal\n-        view = context.restrictedTraverse(\'@@plone\')\n+        view = context.restrictedTraverse("@@plone")\n         manager = getUtility(\n-            IPortletManager,\n-            name=\'plone.rightcolumn\',\n-            context=self.portal\n+            IPortletManager, name="plone.rightcolumn", context=self.portal\n         )\n         assignment = portlet_calendar.Assignment()\n \n         renderer = getMultiAdapter(\n-            (context, self.request, view, manager, assignment),\n-            IPortletRenderer\n+            (context, self.request, view, manager, assignment), IPortletRenderer\n         )\n         self.assertTrue(isinstance(renderer, portlet_calendar.Renderer))\n \n@@ -98,27 +95,26 @@ class RendererTest(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        portal = self.layer[\'portal\']\n+        portal = self.layer["portal"]\n         self.portal = portal\n-        self.request = self.layer[\'request\']\n-        self.wft = getToolByName(self.portal, \'portal_workflow\')\n+        self.request = self.layer["request"]\n+        self.wft = getToolByName(self.portal, "portal_workflow")\n         self.wft.setDefaultChain("simple_publication_workflow")\n-        setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(portal, TEST_USER_ID, ["Manager"])\n         setHooks()\n         setSite(portal)\n \n         set_env_timezone(TZNAME)\n         set_timezone(TZNAME)\n \n-    def renderer(self, context=None, request=None, view=None, manager=None,\n-                 assignment=None):\n+    def renderer(\n+        self, context=None, request=None, view=None, manager=None, assignment=None\n+    ):\n         context = context or self.portal\n         request = request or self.request\n-        view = view or context.restrictedTraverse(\'@@plone\')\n+        view = view or context.restrictedTraverse("@@plone")\n         manager = manager or getUtility(\n-            IPortletManager,\n-            name=\'plone.rightcolumn\',\n-            context=self.portal\n+            IPortletManager, name="plone.rightcolumn", context=self.portal\n         )\n         assignment = assignment or portlet_calendar.Assignment()\n \n@@ -132,49 +128,58 @@ def test_portlet_config(self):\n         end = start + timedelta(hours=1)\n \n         e1 = createContentInContainer(\n-            self.portal, PTYPE, title=u\'e1\', start=start, end=end)\n-        self.portal.invokeFactory(\'Folder\', \'eventfolder\')\n+            self.portal, PTYPE, title=u"e1", start=start, end=end\n+        )\n+        self.portal.invokeFactory("Folder", "eventfolder")\n         createContentInContainer(\n-            self.portal.eventfolder, PTYPE, title=u\'e2\', start=start, end=end)\n-        self.portal.portal_workflow.doActionFor(e1, \'publish\')\n+            self.portal.eventfolder, PTYPE, title=u"e2", start=start, end=end\n+        )\n+        self.portal.portal_workflow.doActionFor(e1, "publish")\n \n-        r = self.renderer(assignment=portlet_calendar.Assignment(\n-            state=(\'draft\',)))\n+        r = self.renderer(assignment=portlet_calendar.Assignment(state=("draft",)))\n         r.update()\n         rd = r.render()\n-        self.assertTrue(\'e1\' not in rd and \'e2\' not in rd)\n+        self.assertTrue("e1" not in rd and "e2" not in rd)\n \n-        r = self.renderer(assignment=portlet_calendar.Assignment(\n-            state=(\'published\', )))\n+        r = self.renderer(assignment=portlet_calendar.Assignment(state=("published",)))\n         r.update()\n         rd = r.render()\n-        self.assertTrue(\'e1\' in rd and \'e2\' not in rd)\n+        self.assertTrue("e1" in rd and "e2" not in rd)\n \n-        r = self.renderer(assignment=portlet_calendar.Assignment(\n-            state=(\'published\', \'private\',)))\n+        r = self.renderer(\n+            assignment=portlet_calendar.Assignment(\n+                state=(\n+                    "published",\n+                    "private",\n+                )\n+            )\n+        )\n         r.update()\n         rd = r.render()\n-        self.assertTrue(\'e1\' in rd and \'e2\' in rd)\n+        self.assertTrue("e1" in rd and "e2" in rd)\n \n         r = self.renderer(assignment=portlet_calendar.Assignment())\n         r.update()\n         rd = r.render()\n-        self.assertTrue(\'e1\' in rd and \'e2\' in rd)\n+        self.assertTrue("e1" in rd and "e2" in rd)\n \n         # No search base gives calendar urls with event_listing part\n-        self.assertTrue(\'event_listing?mode=day\' in rd)\n+        self.assertTrue("event_listing?mode=day" in rd)\n \n-        r = self.renderer(assignment=portlet_calendar.Assignment(\n-            search_base_uid=self.portal.eventfolder.UID()))\n+        r = self.renderer(\n+            assignment=portlet_calendar.Assignment(\n+                search_base_uid=self.portal.eventfolder.UID()\n+            )\n+        )\n         r.update()\n         rd = r.render()\n-        self.assertTrue(\'e1\' not in rd and \'e2\' in rd)\n+        self.assertTrue("e1" not in rd and "e2" in rd)\n \n         # A given search base gives calendar urls without event_listing part\n-        self.assertTrue(\'event_listing?mode=day\' not in rd)\n+        self.assertTrue("event_listing?mode=day" not in rd)\n \n         # link to calendar view in rendering\n-        self.assertTrue(\'?mode=day&amp;date=\' in rd)\n+        self.assertTrue("?mode=day&amp;date=" in rd)\n \n     def test_long_event(self):\n         tz = pytz.timezone(TZNAME)\n@@ -183,15 +188,14 @@ def test_long_event(self):\n         end = start + timedelta(days=2)\n \n         e1 = createContentInContainer(\n-            self.portal, PTYPE, title=u\'e1\', start=start, end=end)\n-        self.portal.portal_workflow.doActionFor(e1, \'publish\')\n-\n-        r = self.renderer(\n-            assignment=portlet_calendar.Assignment(state=(\'published\', ))\n+            self.portal, PTYPE, title=u"e1", start=start, end=end\n         )\n+        self.portal.portal_workflow.doActionFor(e1, "publish")\n+\n+        r = self.renderer(assignment=portlet_calendar.Assignment(state=("published",)))\n         r.update()\n         rd = r.render()\n-        self.assertEqual(rd.count(\'e1\'), 3)\n+        self.assertEqual(rd.count("e1"), 3)\n \n     def test_event_created_last_day_of_month_invalidate_cache(self):\n         # First render the calendar portlet when there\'s no events\n@@ -207,28 +211,24 @@ def test_event_created_last_day_of_month_invalidate_cache(self):\n         start = tz.localize(datetime(year, month, day, 23, 0, 0))\n         end = tz.localize(datetime(year, month, day, 23, 30, 0))\n         # Event starts at 23:00 and ends at 23:30\n-        createContentInContainer(\n-            self.portal, PTYPE, title=u\'e1\', start=start, end=end\n-        )\n+        createContentInContainer(self.portal, PTYPE, title=u"e1", start=start, end=end)\n \n         # Try to render the calendar portlet again, it must be different Now\n         r = self.renderer(assignment=portlet_calendar.Assignment())\n         r.update()\n-        self.assertNotEqual(\n-            html, r.render(), "Cache key wasn\'t invalidated"\n-        )\n+        self.assertNotEqual(html, r.render(), "Cache key wasn\'t invalidated")\n \n     def test_event_nonascii(self):\n         # test issue with non-ascii event title and location\n-        title = u\'Pl\xc3\xb6n\xe2\x82\xac\xc2\xa2\xc3\xb6nf M\xc3\xbcnchen 2012\'\n+        title = u"Pl\xc3\xb6n\xe2\x82\xac\xc2\xa2\xc3\xb6nf M\xc3\xbcnchen 2012"\n \n         tz = pytz.timezone(TZNAME)\n         start = tz.localize(datetime.now())\n         end = start + timedelta(hours=1)\n         e1 = createContentInContainer(\n-            self.portal, PTYPE, title=title, start=start, end=end,\n-            location=u\'M\xc3\xbcnchen\')\n-        self.wft.doActionFor(e1, \'publish\')\n+            self.portal, PTYPE, title=title, start=start, end=end, location=u"M\xc3\xbcnchen"\n+        )\n+        self.wft.doActionFor(e1, "publish")\n         r = self.renderer(assignment=portlet_calendar.Assignment())\n         r.update()\n         self.assertTrue(title in r.render())\n@@ -238,16 +238,14 @@ def test_prev_next_query(self):\n         r.update()\n \n         year, month = r.year_month_display()\n-        prev_expected = \'?month={1}&year={0}\'.format(\n-            *r.get_previous_month(year, month))\n-        next_expected = \'?month={1}&year={0}\'.format(\n-            *r.get_next_month(year, month))\n+        prev_expected = "?month={1}&year={0}".format(*r.get_previous_month(year, month))\n+        next_expected = "?month={1}&year={0}".format(*r.get_next_month(year, month))\n         self.assertEqual(next_expected, r.next_query)\n         self.assertEqual(prev_expected, r.prev_query)\n \n     def test_invalid_request(self):\n-        self.request.form[\'month\'] = [3, 4]\n-        self.request.form[\'year\'] = [2011]\n+        self.request.form["month"] = [3, 4]\n+        self.request.form["year"] = [2011]\n         r = self.renderer()\n         r.update()\n         today = localized_today(self.portal)\ndiff --git a/plone/app/event/tests/test_portlet_events.py b/plone/app/event/tests/test_portlet_events.py\nindex db3cc01f..db7fbe8d 100644\n--- a/plone/app/event/tests/test_portlet_events.py\n+++ b/plone/app/event/tests/test_portlet_events.py\n@@ -29,34 +29,36 @@\n import unittest\n \n \n-TZNAME = \'Australia/Brisbane\'\n-PTYPE = \'plone.app.event.dx.event\'\n+TZNAME = "Australia/Brisbane"\n+PTYPE = "plone.app.event.dx.event"\n \n \n class PortletTest(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        portal = self.layer[\'portal\']\n+        portal = self.layer["portal"]\n         self.portal = portal\n-        self.request = self.layer[\'request\']\n+        self.request = self.layer["request"]\n         alsoProvides(self.request, IPloneFormLayer)\n-        setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(portal, TEST_USER_ID, ["Manager"])\n         setHooks()\n         setSite(portal)\n \n     def testPortletTypeRegistered(self):\n-        portlet = getUtility(IPortletType, name=\'portlets.Events\')\n-        self.assertEqual(portlet.addview, \'portlets.Events\')\n+        portlet = getUtility(IPortletType, name="portlets.Events")\n+        self.assertEqual(portlet.addview, "portlets.Events")\n \n     def testRegisteredInterfaces(self):\n-        portlet = getUtility(IPortletType, name=\'portlets.Events\')\n+        portlet = getUtility(IPortletType, name="portlets.Events")\n         registered_interfaces = [_getDottedName(i) for i in portlet.for_]\n         registered_interfaces.sort()\n         self.assertEqual(\n-            [\'plone.app.portlets.interfaces.IColumn\',\n-             \'plone.app.portlets.interfaces.IDashboard\'],\n-            registered_interfaces\n+            [\n+                "plone.app.portlets.interfaces.IColumn",\n+                "plone.app.portlets.interfaces.IDashboard",\n+            ],\n+            registered_interfaces,\n         )\n \n     def testInterfaces(self):\n@@ -65,13 +67,11 @@ def testInterfaces(self):\n         self.assertTrue(IPortletDataProvider.providedBy(portlet.data))\n \n     def testInvokeAddview(self):\n-        portlet = getUtility(IPortletType, name=\'portlets.Events\')\n-        mapping = self.portal.restrictedTraverse(\n-            \'++contextportlets++plone.leftcolumn\'\n-        )\n+        portlet = getUtility(IPortletType, name="portlets.Events")\n+        mapping = self.portal.restrictedTraverse("++contextportlets++plone.leftcolumn")\n         for m in mapping.keys():\n             del mapping[m]\n-        addview = mapping.restrictedTraverse(\'+/\' + portlet.addview)\n+        addview = mapping.restrictedTraverse("+/" + portlet.addview)\n \n         addview.createAndAdd(data={})\n \n@@ -83,37 +83,32 @@ def testInvokeAddview(self):\n     def testInvokeEditView(self):\n         mapping = PortletAssignmentMapping()\n \n-        mapping[\'foo\'] = portlet_events.Assignment(count=5)\n-        editview = getMultiAdapter((mapping[\'foo\'], self.request), name=\'edit\')\n+        mapping["foo"] = portlet_events.Assignment(count=5)\n+        editview = getMultiAdapter((mapping["foo"], self.request), name="edit")\n         self.assertTrue(isinstance(editview, portlet_events.EditForm))\n \n     def testRenderer(self):\n         context = self.portal\n-        view = context.restrictedTraverse(\'@@plone\')\n+        view = context.restrictedTraverse("@@plone")\n         manager = getUtility(\n-            IPortletManager, name=\'plone.leftcolumn\', context=self.portal\n+            IPortletManager, name="plone.leftcolumn", context=self.portal\n         )\n         assignment = portlet_events.Assignment(count=5)\n \n         renderer = getMultiAdapter(\n-            (context, self.request, view, manager, assignment),\n-            IPortletRenderer\n+            (context, self.request, view, manager, assignment), IPortletRenderer\n         )\n         self.assertTrue(isinstance(renderer, portlet_events.Renderer))\n \n     def test_disable_dasboard_breaks_event_portlet(self):\n         # Bug #8230: disabling the dashboard breaks the event portlet\n         self.portal.manage_permission(\n-            \'Portlets: Manage own portlets\',\n-            roles=[\'Manager\'],\n-            acquire=0\n+            "Portlets: Manage own portlets", roles=["Manager"], acquire=0\n         )\n \n-        portlet = getUtility(IPortletType, name=\'portlets.Events\')\n-        mapping = self.portal.restrictedTraverse(\n-            \'++contextportlets++plone.leftcolumn\'\n-        )\n-        addview = mapping.restrictedTraverse(\'+/\' + portlet.addview)\n+        portlet = getUtility(IPortletType, name="portlets.Events")\n+        mapping = self.portal.restrictedTraverse("++contextportlets++plone.leftcolumn")\n+        addview = mapping.restrictedTraverse("+/" + portlet.addview)\n \n         try:\n             addview.createAndAdd(data={})\n@@ -125,30 +120,30 @@ class RendererTest(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        portal = self.layer[\'portal\']\n+        portal = self.layer["portal"]\n         self.portal = portal\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n         wftool = getToolByName(self.portal, "portal_workflow")\n         wftool.setDefaultChain("simple_publication_workflow")\n         set_env_timezone(TZNAME)\n         set_timezone(TZNAME)\n \n-    def renderer(self, context=None, request=None, view=None, manager=None,\n-                 assignment=None):\n+    def renderer(\n+        self, context=None, request=None, view=None, manager=None, assignment=None\n+    ):\n         context = context or self.portal\n         request = request or self.request\n-        view = view or context.restrictedTraverse(\'@@plone\')\n+        view = view or context.restrictedTraverse("@@plone")\n         manager = manager or getUtility(\n-            IPortletManager, name=\'plone.leftcolumn\', context=self.portal\n+            IPortletManager, name="plone.leftcolumn", context=self.portal\n         )\n         assignment = assignment or portlet_events.Assignment(\n-            template=\'portlet_recent\', macro=\'portlet\'\n+            template="portlet_recent", macro="portlet"\n         )\n \n         return getMultiAdapter(\n-            (context, request, view, manager, assignment),\n-            IPortletRenderer\n+            (context, request, view, manager, assignment), IPortletRenderer\n         )\n \n     def test_portlet_event_renderer__get_events(self):\n@@ -156,27 +151,36 @@ def test_portlet_event_renderer__get_events(self):\n         end = start + timedelta(hours=1)\n \n         e1 = createContentInContainer(\n-            self.portal, PTYPE,\n-            id=\'e1\', title=u\'e1\', start=start, end=end)\n-        self.portal.portal_workflow.doActionFor(e1, \'publish\')\n+            self.portal, PTYPE, id="e1", title=u"e1", start=start, end=end\n+        )\n+        self.portal.portal_workflow.doActionFor(e1, "publish")\n \n-        self.portal.invokeFactory(\'Folder\', \'eventfolder\')\n+        self.portal.invokeFactory("Folder", "eventfolder")\n         createContentInContainer(\n-            self.portal.eventfolder, PTYPE,\n-            id=\'e2\', title=u\'e2\', start=start, end=end)\n+            self.portal.eventfolder, PTYPE, id="e2", title=u"e2", start=start, end=end\n+        )\n \n-        r = self.renderer(assignment=portlet_events.Assignment(\n-            count=5, state=(\'draft\',)))\n+        r = self.renderer(\n+            assignment=portlet_events.Assignment(count=5, state=("draft",))\n+        )\n         r.update()\n         self.assertEqual(0, len(r.events))\n \n-        r = self.renderer(assignment=portlet_events.Assignment(\n-            count=5, state=(\'published\', )))\n+        r = self.renderer(\n+            assignment=portlet_events.Assignment(count=5, state=("published",))\n+        )\n         r.update()\n         self.assertEqual(1, len(r.events))\n \n-        r = self.renderer(assignment=portlet_events.Assignment(\n-            count=5, state=(\'published\', \'private\',)))\n+        r = self.renderer(\n+            assignment=portlet_events.Assignment(\n+                count=5,\n+                state=(\n+                    "published",\n+                    "private",\n+                ),\n+            )\n+        )\n         r.update()\n         self.assertEqual(2, len(r.events))\n \n@@ -185,35 +189,48 @@ def test_portlet_event_renderer__get_events(self):\n         self.assertEqual(2, len(r.events))\n \n         # No search base gives calendar urls with event_listing part\n-        self.assertTrue(\'event_listing\' in r.render())\n+        self.assertTrue("event_listing" in r.render())\n \n-        r = self.renderer(assignment=portlet_events.Assignment(\n-            count=5, search_base_uid=self.portal.eventfolder.UID()))\n+        r = self.renderer(\n+            assignment=portlet_events.Assignment(\n+                count=5, search_base_uid=self.portal.eventfolder.UID()\n+            )\n+        )\n         r.update()\n         self.assertEqual(1, len(r.events))\n \n         # A given search base gives calendar urls without event_listing part\n-        self.assertTrue(\'event_listing\' not in r.render())\n+        self.assertTrue("event_listing" not in r.render())\n \n     def test_portlet_event_renderer__recurring(self):\n         start = localized_now() + timedelta(days=1)\n \n         e1 = createContentInContainer(\n-            self.portal, PTYPE, id=\'e1\', title=u\'Event 1\', start=start,\n-            recurrence=\'RRULE:FREQ=WEEKLY;COUNT=10\')\n+            self.portal,\n+            PTYPE,\n+            id="e1",\n+            title=u"Event 1",\n+            start=start,\n+            recurrence="RRULE:FREQ=WEEKLY;COUNT=10",\n+        )\n         createContentInContainer(\n-            self.portal, PTYPE, id=\'e1\', title=u\'Event 1\', start=start,\n-            recurrence=\'RRULE:FREQ=DAILY;COUNT=3\')\n+            self.portal,\n+            PTYPE,\n+            id="e1",\n+            title=u"Event 1",\n+            start=start,\n+            recurrence="RRULE:FREQ=DAILY;COUNT=3",\n+        )\n \n-        self.portal.portal_workflow.doActionFor(e1, \'publish\')\n+        self.portal.portal_workflow.doActionFor(e1, "publish")\n \n         r = self.renderer(\n-            assignment=portlet_events.Assignment(count=5,\n-                                                 state=(\'published\',)))\n+            assignment=portlet_events.Assignment(count=5, state=("published",))\n+        )\n         r.update()\n         events = r.events\n         self.assertEqual(5, len(events))\n-        self.assertTrue(\'Event 2\' not in [x.title for x in events])\n+        self.assertTrue("Event 2" not in [x.title for x in events])\n \n         rd = r.render()\n         occ1dt = start + timedelta(days=7)\n@@ -222,13 +239,14 @@ def test_portlet_event_renderer__recurring(self):\n         self.assertTrue(\'http://nohost/plone/e1"\' in rd)\n         # Occurrences should link to the Occurrence.\n         self.assertTrue(\n-            \'http://nohost/plone/e1/%s-%02d-%02d\' %\n-            (occ1dt.year, occ1dt.month, occ1dt.day) in rd\n+            "http://nohost/plone/e1/%s-%02d-%02d"\n+            % (occ1dt.year, occ1dt.month, occ1dt.day)\n+            in rd\n         )\n \n     def test_portlet_event_renderer__listing_link(self):\n         r = self.renderer(assignment=portlet_events.Assignment(count=5))\n         r.update()\n         rd = r.render()\n-        self.assertTrue(\'?mode=future\' in rd)\n-        self.assertTrue(\'?mode=past\' in rd)\n+        self.assertTrue("?mode=future" in rd)\n+        self.assertTrue("?mode=past" in rd)\ndiff --git a/plone/app/event/tests/test_recurrence.py b/plone/app/event/tests/test_recurrence.py\nindex e514efe6..86d2a9e2 100644\n--- a/plone/app/event/tests/test_recurrence.py\n+++ b/plone/app/event/tests/test_recurrence.py\n@@ -47,8 +47,8 @@\n \n \n class TestTraversalDX(AbstractSampleDataEvents):\n-    """Test OccurrenceTraverser with DX objects.\n-    """\n+    """Test OccurrenceTraverser with DX objects."""\n+\n     layer = PAEventDX_FUNCTIONAL_TESTING\n \n     @property\n@@ -57,14 +57,11 @@ def occ_traverser_1(self):\n \n     def test_no_occurrence(self):\n         self.assertRaises(\n-            AttributeError,\n-            self.occ_traverser_1.publishTraverse,\n-            self.request,\n-            \'foo\'\n+            AttributeError, self.occ_traverser_1.publishTraverse, self.request, "foo"\n         )\n \n     def test_default_views(self):\n-        view = self.occ_traverser_1.publishTraverse(self.request, \'event_view\')\n+        view = self.occ_traverser_1.publishTraverse(self.request, "event_view")\n         self.assertTrue(IBrowserView.providedBy(view))\n \n     def test_occurrence(self):\n@@ -75,22 +72,26 @@ def test_occurrence(self):\n         self.assertRaises(\n             AttributeError,\n             self.occ_traverser_1.publishTraverse,\n-            self.request, \'2000-01-01\')\n+            self.request,\n+            "2000-01-01",\n+        )\n \n         # Try to traverse to future occurrence\n         self.assertRaises(\n             AttributeError,\n             self.occ_traverser_1.publishTraverse,\n-            self.request, \'2030-01-01\')\n+            self.request,\n+            "2030-01-01",\n+        )\n \n         # Traverse to existent occurrence\n-        item = self.occ_traverser_1.publishTraverse(self.request, \'2013-05-07\')\n+        item = self.occ_traverser_1.publishTraverse(self.request, "2013-05-07")\n         self.assertTrue(IOccurrence.providedBy(item))\n         self.assertEqual(type(self.now_event), type(item.aq_parent))\n \n         # Test attributes of Occurrence\n-        self.assertEqual(item.portal_type, \'Occurrence\')\n-        self.assertEqual(item.id, \'2013-05-07\')\n+        self.assertEqual(item.portal_type, "Occurrence")\n+        self.assertEqual(item.id, "2013-05-07")\n         delta = datetime.timedelta(days=2)\n         self.assertEqual(item.start, self.now + delta)\n         self.assertEqual(item.end, self.now + delta + self.duration)\n@@ -98,32 +99,30 @@ def test_occurrence(self):\n     def test_occurrence_accessor(self):\n         start = self.now\n         end = self.future\n-        occ = Occurrence(\'ignored\', start, end)\n+        occ = Occurrence("ignored", start, end)\n         occ = occ.__of__(self.now_event)\n         acc_occ = IEventAccessor(occ)\n         acc_ctx = IEventAccessor(self.now_event)\n         self.assertEqual(acc_occ.start, acc_ctx.start)\n-        self.assertEqual(acc_occ.url, \'http://nohost/plone/now/ignored\')\n+        self.assertEqual(acc_occ.url, "http://nohost/plone/now/ignored")\n \n     def test_traverse_occurrence(self):\n         transaction.commit()\n         browser = Browser(self.app)\n         browser.addHeader(\n-            \'Authorization\', \'Basic %s:%s\' % (TEST_USER_ID, TEST_USER_PASSWORD)\n+            "Authorization", "Basic %s:%s" % (TEST_USER_ID, TEST_USER_PASSWORD)\n         )\n-        url = \'/\'.join([self.now_event.absolute_url(), \'2013-05-07\'])\n+        url = "/".join([self.now_event.absolute_url(), "2013-05-07"])\n         browser.open(url)\n         title = self.now_event.title\n         if six.PY2:\n-            title = title.encode(\'ascii\')\n+            title = title.encode("ascii")\n         self.assertTrue(title in browser.contents)\n \n     def test_traverse_occurrence_imagescaling(self):\n         self.now_event.image = Mock()\n-        occurrence = self.occ_traverser_1.publishTraverse(\n-            self.request, \'2013-05-07\'\n-        )\n-        image_view = occurrence.restrictedTraverse(\'@@images\')\n+        occurrence = self.occ_traverser_1.publishTraverse(self.request, "2013-05-07")\n+        image_view = occurrence.restrictedTraverse("@@images")\n         self.assertEqual(image_view.context, self.now_event)\n \n \n@@ -131,8 +130,8 @@ class TestOccurrences(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n \n         set_browserlayer(self.request)\n         set_env_timezone(TZNAME)\n@@ -142,77 +141,79 @@ def setUp(self):\n \n         yesterday = now - datetime.timedelta(days=1)\n \n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n         self.daily = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            id=\'daily\',\n-            title=u\'Daily Event\',\n+            "plone.app.event.dx.event",\n+            id="daily",\n+            title=u"Daily Event",\n             start=now,\n             end=now + datetime.timedelta(hours=1),\n-            location=u\'Vienna\',\n-            recurrence=\'RRULE:FREQ=DAILY;COUNT=4\',\n+            location=u"Vienna",\n+            recurrence="RRULE:FREQ=DAILY;COUNT=4",\n         )\n         self.interval = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            id=\'interval\',\n-            title=u\'Interval Event\',\n+            "plone.app.event.dx.event",\n+            id="interval",\n+            title=u"Interval Event",\n             start=yesterday,\n             end=yesterday + datetime.timedelta(hours=1),\n-            location=u\'Halle\',\n-            recurrence=\'RRULE:FREQ=DAILY;INTERVAL=2;COUNT=5\',\n+            location=u"Halle",\n+            recurrence="RRULE:FREQ=DAILY;INTERVAL=2;COUNT=5",\n         )\n \n         self.now = now\n         self.yesterday = yesterday\n \n     def test_get_occurrences(self):\n-        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS,\n-                         expand=True)\n+        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS, expand=True)\n         self.assertEqual(len(res), 9)\n-        res = get_events(self.portal, start=self.now,\n-                         ret_mode=RET_MODE_ACCESSORS, expand=True)\n+        res = get_events(\n+            self.portal, start=self.now, ret_mode=RET_MODE_ACCESSORS, expand=True\n+        )\n         self.assertEqual(len(res), 8)\n \n-        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS,\n-                         expand=True, limit=5)\n+        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS, expand=True, limit=5)\n         self.assertEqual(len(res), 5)\n         self.assertTrue(IEventAccessor.providedBy(res[0]))\n \n     def test_event_summary_occurrences(self):\n         createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            id=\'many\',\n-            title=u\'Interval Event\',\n-            location=u\'Brisbane\',\n-            recurrence=\'RRULE:FREQ=DAILY;COUNT=1000\'\n+            "plone.app.event.dx.event",\n+            id="many",\n+            title=u"Interval Event",\n+            location=u"Brisbane",\n+            recurrence="RRULE:FREQ=DAILY;COUNT=1000",\n         )\n \n         view = zope.component.getMultiAdapter(\n-            (self.portal[\'interval\'], self.request), name=\'event_summary\')\n+            (self.portal["interval"], self.request), name="event_summary"\n+        )\n         result = view.next_occurrences\n         # altogether 5 occurrences, start occurrence is included\n         self.assertEqual(5, len(result))\n \n         view = zope.component.getMultiAdapter(\n-            (self.portal[\'many\'], self.request), name=\'event_summary\')\n+            (self.portal["many"], self.request), name="event_summary"\n+        )\n \n         # Number of shown occurrences should match max_occurrences setting\n         self.assertEqual(len(view.next_occurrences), view.max_occurrences)\n         # num_more_occurrences should return number of remaining occurrences\n-        self.assertEqual(\n-            view.num_more_occurrences, 1000 - view.max_occurrences)\n+        self.assertEqual(view.num_more_occurrences, 1000 - view.max_occurrences)\n \n     def test_event_summary_occurrences_next_upcoming(self):\n-        event = IEventAccessor(self.portal[\'daily\'])\n+        event = IEventAccessor(self.portal["daily"])\n \n         date = patched_now()\n-        with mock.patch(\'plone.app.event.dx.behaviors.localized_now\',\n-                        return_value=date):\n+        with mock.patch(\n+            "plone.app.event.dx.behaviors.localized_now", return_value=date\n+        ):\n             view = zope.component.getMultiAdapter(\n-                (self.portal[\'daily\'], self.request), name=\'event_summary\')\n+                (self.portal["daily"], self.request), name="event_summary"\n+            )\n             # altogether 4 occurrences, start occurrence is included\n             self.assertEqual(4, len(view.next_occurrences))\n             self.assertEqual(event.start, date)\n@@ -220,10 +221,12 @@ def test_event_summary_occurrences_next_upcoming(self):\n \n         IAnnotations(self.request).clear()  # clear cache\n         next_date = patched_now() + datetime.timedelta(hours=24)\n-        with mock.patch(\'plone.app.event.dx.behaviors.localized_now\',\n-                        return_value=next_date):\n+        with mock.patch(\n+            "plone.app.event.dx.behaviors.localized_now", return_value=next_date\n+        ):\n             view = zope.component.getMultiAdapter(\n-                (self.portal[\'daily\'], self.request), name=\'event_summary\')\n+                (self.portal["daily"], self.request), name="event_summary"\n+            )\n             # 3 occurrences remaining\n             self.assertEqual(3, len(view.next_occurrences))\n             self.assertEqual(event.start, next_date)\n@@ -232,23 +235,27 @@ def test_event_summary_occurrences_next_upcoming(self):\n \n         IAnnotations(self.request).clear()  # clear cache\n         next_date = patched_now() + datetime.timedelta(days=10)\n-        with mock.patch(\'plone.app.event.dx.behaviors.localized_now\',\n-                        return_value=next_date):\n+        with mock.patch(\n+            "plone.app.event.dx.behaviors.localized_now", return_value=next_date\n+        ):\n             view = zope.component.getMultiAdapter(\n-                (self.portal[\'daily\'], self.request), name=\'event_summary\')\n+                (self.portal["daily"], self.request), name="event_summary"\n+            )\n             # no occurrences remaining, show all original 4\n             self.assertEqual(4, len(view.next_occurrences))\n             self.assertEqual(event.start, date)\n             self.assertEqual(event.end, date + datetime.timedelta(hours=1))\n \n     def test_event_summary_occurrences_whole_day(self):\n-        self.portal[\'daily\'].whole_day = True\n+        self.portal["daily"].whole_day = True\n \n         date = patched_now()\n-        with mock.patch(\'plone.app.event.dx.behaviors.localized_now\',\n-                        return_value=date):\n+        with mock.patch(\n+            "plone.app.event.dx.behaviors.localized_now", return_value=date\n+        ):\n             view = zope.component.getMultiAdapter(\n-                (self.portal[\'daily\'], self.request), name=\'event_summary\')\n+                (self.portal["daily"], self.request), name="event_summary"\n+            )\n             # altogether 4 occurrences, start occurrence is included\n             self.assertEqual(4, len(view.next_occurrences))\n             for occurrence in view.next_occurrences:\n@@ -259,10 +266,12 @@ def test_event_summary_occurrences_whole_day(self):\n \n         IAnnotations(self.request).clear()  # clear cache\n         next_date = patched_now() + datetime.timedelta(hours=24)\n-        with mock.patch(\'plone.app.event.dx.behaviors.localized_now\',\n-                        return_value=next_date):\n+        with mock.patch(\n+            "plone.app.event.dx.behaviors.localized_now", return_value=next_date\n+        ):\n             view = zope.component.getMultiAdapter(\n-                (self.portal[\'daily\'], self.request), name=\'event_summary\')\n+                (self.portal["daily"], self.request), name="event_summary"\n+            )\n             # 3 occurrences remaining\n             self.assertEqual(3, len(view.next_occurrences))\n             for occurrence in view.next_occurrences:\n@@ -273,10 +282,12 @@ def test_event_summary_occurrences_whole_day(self):\n \n         IAnnotations(self.request).clear()  # clear cache\n         next_date = patched_now() + datetime.timedelta(days=10)\n-        with mock.patch(\'plone.app.event.dx.behaviors.localized_now\',\n-                        return_value=next_date):\n+        with mock.patch(\n+            "plone.app.event.dx.behaviors.localized_now", return_value=next_date\n+        ):\n             view = zope.component.getMultiAdapter(\n-                (self.portal[\'daily\'], self.request), name=\'event_summary\')\n+                (self.portal["daily"], self.request), name="event_summary"\n+            )\n             # no occurrences remaining, show all original 4\n             self.assertEqual(4, len(view.next_occurrences))\n             for occurrence in view.next_occurrences:\n@@ -295,12 +306,12 @@ class TestRecurrenceSupport(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.tz = tz = pytz.timezone(\'Europe/Vienna\')\n+        self.tz = tz = pytz.timezone("Europe/Vienna")\n         duration = datetime.timedelta(days=4)\n         data = MockEvent()\n         data.start = datetime.datetime(2011, 11, 11, 11, 00, tzinfo=tz)\n         data.end = data.start + duration\n-        data.recurrence = \'RRULE:FREQ=DAILY;COUNT=4\'\n+        data.recurrence = "RRULE:FREQ=DAILY;COUNT=4"\n         alsoProvides(data, IEvent, IEventRecurrence)\n         self.data = data\n \n@@ -345,8 +356,7 @@ def test_recurrence_occurrences_with_range_start_and_end(self):\n         # Test with range\n         rs = datetime.datetime(2011, 11, 11, 11, 0, tzinfo=self.tz)\n         re = datetime.datetime(2011, 11, 12, 11, 0, tzinfo=self.tz)\n-        result = IRecurrenceSupport(self.data).occurrences(range_start=rs,\n-                                                           range_end=re)\n+        result = IRecurrenceSupport(self.data).occurrences(range_start=rs, range_end=re)\n         result = list(result)  # cast generator to list\n \n         self.assertEqual(2, len(result))\ndiff --git a/plone/app/event/tests/test_search.py b/plone/app/event/tests/test_search.py\nindex 6dead446..f2cad31b 100644\n--- a/plone/app/event/tests/test_search.py\n+++ b/plone/app/event/tests/test_search.py\n@@ -9,7 +9,7 @@\n class FunctionalTestSearchEvent(AbstractSampleDataEvents):\n     layer = PAEventDX_FUNCTIONAL_TESTING\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_searchabletext(self):\n-        results = self.portal.portal_catalog(SearchableText=u\'\xc3\x9cberraschung\')\n+        results = self.portal.portal_catalog(SearchableText=u"\xc3\x9cberraschung")\n         self.assertTrue(len(results) == 1)\ndiff --git a/plone/app/event/upgrades/upgrades.py b/plone/app/event/upgrades/upgrades.py\nindex c2a5a4d0..1de64b3a 100644\n--- a/plone/app/event/upgrades/upgrades.py\n+++ b/plone/app/event/upgrades/upgrades.py\n@@ -28,41 +28,47 @@ def enable_richtext_behavior(self):\n     fti = queryUtility(IDexterityFTI, name="Event", default=None)\n     if not fti:\n         return\n-    behaviors = [it for it in fti.behaviors\n-                 if \'plone.app.event.dx.behaviors.IEventSummary\' not in it]\n-    behaviors.extend([\n-        \'plone.app.contenttypes.behaviors.richtext.IRichText\',\n-    ])\n+    behaviors = [\n+        it\n+        for it in fti.behaviors\n+        if "plone.app.event.dx.behaviors.IEventSummary" not in it\n+    ]\n+    behaviors.extend(\n+        [\n+            "plone.app.contenttypes.behaviors.richtext.IRichText",\n+        ]\n+    )\n     behaviors = tuple(set(behaviors))\n-    fti._updateProperty(\'behaviors\', behaviors)\n+    fti._updateProperty("behaviors", behaviors)\n \n \n def upgrade_attribute_storage(context):\n     portal = getSite()\n-    catalog = getToolByName(portal, \'portal_catalog\')\n+    catalog = getToolByName(portal, "portal_catalog")\n     query = {}\n-    query[\'object_provides\'] = IDXEvent.__identifier__\n+    query["object_provides"] = IDXEvent.__identifier__\n     results = catalog(**query)\n-    log.info(\'There are {0} in total, stating migration...\'.format(\n-        len(results)))\n+    log.info("There are {0} in total, stating migration...".format(len(results)))\n     for result in results:\n         try:\n             event = result.getObject()\n         except:\n             log.warning(\n-                \'Not possible to fetch event object from catalog result for \'\n-                \'item: {0}.\'.format(result.getPath()))\n+                "Not possible to fetch event object from catalog result for "\n+                "item: {0}.".format(result.getPath())\n+            )\n             continue\n         if not IAnnotatable.providedBy(event):\n             log.warning(\n-                \'The event at {0} does provide annotation capabilities, \'\n-                \'skipping.\'.format(event.absolute_url()))\n+                "The event at {0} does provide annotation capabilities, "\n+                "skipping.".format(event.absolute_url())\n+            )\n             continue\n         annotations = IAnnotations(event)\n         did_work = False\n         for behavior in BEHAVIOR_LIST:\n             for name in behavior.names():\n-                fullname = \'{0}.{1}\'.format(behavior.__identifier__, name)\n+                fullname = "{0}.{1}".format(behavior.__identifier__, name)\n                 oldvalue = annotations.get(fullname, None)\n                 # Only write the old value if there is no new value yet\n                 if oldvalue and not getattr(event, name, None):\n@@ -71,19 +77,24 @@ def upgrade_attribute_storage(context):\n         # The old IEventSummary behavior is gone, just look for the old name\n         # inside the annotation storage\n         oldvalue = annotations.get(\n-            \'plone.app.event.dx.behaviors.IEventSummary.text\', None)\n-        if oldvalue and not getattr(event, \'text\', None):\n-            setattr(event, \'text\', oldvalue)\n+            "plone.app.event.dx.behaviors.IEventSummary.text", None\n+        )\n+        if oldvalue and not getattr(event, "text", None):\n+            setattr(event, "text", oldvalue)\n             did_work = True\n         if did_work:\n             notify(ObjectModifiedEvent(event))\n-        log.debug(\'Handled event at {0}\'.format(event.absolute_url()))\n+        log.debug("Handled event at {0}".format(event.absolute_url()))\n \n \n def remove_event_listing_settings(context):\n     portal = getSite()\n-    actions = getToolByName(portal, \'portal_actions\')\n-    ob = getattr(actions, \'object\')\n-    if ob and getattr(ob, \'event_listing_settings\', False):\n-        actions.object.manage_delObjects([\'event_listing_settings\', ])\n-        log.debug(\'Removed event_listing_settings from object actions.\')\n+    actions = getToolByName(portal, "portal_actions")\n+    ob = getattr(actions, "object")\n+    if ob and getattr(ob, "event_listing_settings", False):\n+        actions.object.manage_delObjects(\n+            [\n+                "event_listing_settings",\n+            ]\n+        )\n+        log.debug("Removed event_listing_settings from object actions.")\ndiff --git a/plone/app/event/vocabularies.py b/plone/app/event/vocabularies.py\nindex bae395d4..0a1da887 100644\n--- a/plone/app/event/vocabularies.py\n+++ b/plone/app/event/vocabularies.py\n@@ -21,10 +21,10 @@ def SynchronizationStrategies(context):\n                       sync_uid.\n     """\n     items = [\n-        (_(\'sync_keep_newer\', default="Keep newer"), base.SYNC_KEEP_NEWER),\n-        (_(\'sync_keep_mine\', default="Keep mine"), base.SYNC_KEEP_MINE),\n-        (_(\'sync_keep_theirs\', default="Keep theirs"), base.SYNC_KEEP_THEIRS),\n-        (_(\'sync_none\', default="No Syncing"), base.SYNC_NONE),\n+        (_("sync_keep_newer", default="Keep newer"), base.SYNC_KEEP_NEWER),\n+        (_("sync_keep_mine", default="Keep mine"), base.SYNC_KEEP_MINE),\n+        (_("sync_keep_theirs", default="Keep theirs"), base.SYNC_KEEP_THEIRS),\n+        (_("sync_none", default="No Syncing"), base.SYNC_NONE),\n     ]\n     items = [SimpleTerm(title=i[0], value=i[1]) for i in items]\n     return SimpleVocabulary(items)\ndiff --git a/setup.py b/setup.py\nindex 19d55551..0da276f0 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -5,18 +5,20 @@\n import os\n \n \n-version = \'4.0.0a9.dev0\'\n+version = "4.0.0a9.dev0"\n \n \n-long_description = (\'\\n\\n\'.join([\n-    open("README.rst").read(),\n-    open(os.path.join(\'docs\', \'installation.rst\')).read(),\n-    open("CHANGES.rst").read(),\n-]))\n+long_description = "\\n\\n".join(\n+    [\n+        open("README.rst").read(),\n+        open(os.path.join("docs", "installation.rst")).read(),\n+        open("CHANGES.rst").read(),\n+    ]\n+)\n \n \n setup(\n-    name=\'plone.app.event\',\n+    name="plone.app.event",\n     version=version,\n     description="The Plone calendar framework",\n     long_description=long_description,\n@@ -31,87 +33,87 @@\n         "Programming Language :: Python :: 3.8",\n         "Programming Language :: Python :: 3.9",\n     ],\n-    keywords=\'plone event\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://github.com/plone/plone.app.event\',\n-    license=\'GPL version 2\',\n+    keywords="plone event",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://github.com/plone/plone.app.event",\n+    license="GPL version 2",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\', \'plone.app\'],\n+    namespace_packages=["plone", "plone.app"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n+        "setuptools",\n         # -*- Extra requirements: -*-\n-        \'Acquisition\',\n-        \'DateTime\',\n-        \'Products.CMFCore\',\n-        \'Products.CMFPlone\',\n-        \'Products.DateRecurringIndex\',\n-        \'Products.GenericSetup\',\n-        \'Products.ZCatalog\',\n-        \'Products.statusmessages\',\n-        \'Zope2\',\n-        \'icalendar\',  # >4.0.2\n-        \'plone.app.contentlisting\',\n-        \'plone.app.dexterity\',\n-        \'plone.app.layout\',\n-        \'plone.app.multilingual\',\n-        \'plone.app.portlets >= 2.5.1\',\n-        \'plone.app.querystring\',\n-        \'plone.app.registry\',\n-        \'plone.app.textfield\',\n-        \'plone.app.vocabularies >= 2.1.15.dev0\',\n-        \'plone.app.z3cform>=2.0.1.dev0\',\n-        \'plone.autoform>=1.4\',\n-        \'plone.behavior\',\n-        \'plone.browserlayer\',\n-        \'plone.dexterity\',\n-        \'plone.event>=1.0\',\n-        \'plone.folder\',\n-        \'plone.formwidget.recurrence [z3cform] >= 1.2.4\',\n-        \'plone.indexer\',\n-        \'plone.memoize\',\n-        \'plone.namedfile\',\n-        \'plone.portlets\',\n-        \'plone.registry\',\n-        \'plone.supermodel\',\n-        \'plone.uuid\',\n-        \'plone.z3cform\',\n-        \'pytz\',\n-        \'six\',\n-        \'transaction\',\n-        \'z3c.form >= 3.2.1.dev0\',\n-        \'zope.annotation\',\n-        \'zope.component\',\n-        \'zope.container\',\n-        \'zope.contentprovider\',\n-        \'zope.event\',\n-        \'zope.globalrequest\',\n-        \'zope.i18n\',\n-        \'zope.i18nmessageid\',\n-        \'zope.interface\',\n-        \'zope.lifecycleevent\',\n-        \'zope.publisher\',\n-        \'zope.schema\',\n+        "Acquisition",\n+        "DateTime",\n+        "Products.CMFCore",\n+        "Products.CMFPlone",\n+        "Products.DateRecurringIndex",\n+        "Products.GenericSetup",\n+        "Products.ZCatalog",\n+        "Products.statusmessages",\n+        "Zope2",\n+        "icalendar",  # >4.0.2\n+        "plone.app.contentlisting",\n+        "plone.app.dexterity",\n+        "plone.app.layout",\n+        "plone.app.multilingual",\n+        "plone.app.portlets >= 2.5.1",\n+        "plone.app.querystring",\n+        "plone.app.registry",\n+        "plone.app.textfield",\n+        "plone.app.vocabularies >= 2.1.15.dev0",\n+        "plone.app.z3cform>=2.0.1.dev0",\n+        "plone.autoform>=1.4",\n+        "plone.behavior",\n+        "plone.browserlayer",\n+        "plone.dexterity",\n+        "plone.event>=1.0",\n+        "plone.folder",\n+        "plone.formwidget.recurrence [z3cform] >= 1.2.4",\n+        "plone.indexer",\n+        "plone.memoize",\n+        "plone.namedfile",\n+        "plone.portlets",\n+        "plone.registry",\n+        "plone.supermodel",\n+        "plone.uuid",\n+        "plone.z3cform",\n+        "pytz",\n+        "six",\n+        "transaction",\n+        "z3c.form >= 3.2.1.dev0",\n+        "zope.annotation",\n+        "zope.component",\n+        "zope.container",\n+        "zope.contentprovider",\n+        "zope.event",\n+        "zope.globalrequest",\n+        "zope.i18n",\n+        "zope.i18nmessageid",\n+        "zope.interface",\n+        "zope.lifecycleevent",\n+        "zope.publisher",\n+        "zope.schema",\n     ],\n     extras_require={\n-        \'dexterity\': [],  # BBB, remove with next version\n-        \'test\': [\n-            \'icalendar >= 3.10\',  # otherwise minor test failure\n-            \'mock\',\n-            \'plone.app.contenttypes >= 1.2a3\',\n-            \'plone.app.robotframework\',\n-            \'plone.app.testing [robot]\',\n-            \'plone.testing\',\n-            \'robotsuite\',\n-            \'transaction\',\n-            \'zExceptions\',\n-            \'zope.event\',\n+        "dexterity": [],  # BBB, remove with next version\n+        "test": [\n+            "icalendar >= 3.10",  # otherwise minor test failure\n+            "mock",\n+            "plone.app.contenttypes >= 1.2a3",\n+            "plone.app.robotframework",\n+            "plone.app.testing [robot]",\n+            "plone.testing",\n+            "robotsuite",\n+            "transaction",\n+            "zExceptions",\n+            "zope.event",\n         ],\n     },\n     entry_points="""\n     [z3c.autoinclude.plugin]\n     target = plone\n-    """\n+    """,\n )\n'

Repository: plone.app.event


Branch: refs/heads/master
Date: 2022-05-04T22:13:56+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.event/commit/915278bb3b06fcce5a85197e5bbb2fc6f56fd670

find . -name "*.py" -exec pyupgrade  --py3-only --py37-plus {} +

Files changed:
M docs/conf.py
M plone/__init__.py
M plone/app/__init__.py
M plone/app/event/__init__.py
M plone/app/event/base.py
M plone/app/event/browser/__init__.py
M plone/app/event/browser/event_listing.py
M plone/app/event/browser/event_summary.py
M plone/app/event/browser/event_view.py
M plone/app/event/browser/formatted_date.py
M plone/app/event/browser/leadimage_viewlet.py
M plone/app/event/dx/__init__.py
M plone/app/event/dx/behaviors.py
M plone/app/event/dx/interfaces.py
M plone/app/event/dx/traverser.py
M plone/app/event/ical/__init__.py
M plone/app/event/ical/exporter.py
M plone/app/event/ical/importer.py
M plone/app/event/interfaces.py
M plone/app/event/portlets/__init__.py
M plone/app/event/portlets/portlet_calendar.py
M plone/app/event/portlets/portlet_events.py
M plone/app/event/recurrence.py
M plone/app/event/setuphandlers.py
M plone/app/event/testing.py
M plone/app/event/tests/__init__.py
M plone/app/event/tests/base_setup.py
M plone/app/event/tests/test_base_module.py
M plone/app/event/tests/test_catalog.py
M plone/app/event/tests/test_dx_behaviors.py
M plone/app/event/tests/test_event_listing.py
M plone/app/event/tests/test_event_summary.py
M plone/app/event/tests/test_event_view.py
M plone/app/event/tests/test_ical_import.py
M plone/app/event/tests/test_icalendar.py
M plone/app/event/tests/test_portlet_calendar.py
M plone/app/event/tests/test_portlet_events.py
M plone/app/event/tests/test_recurrence.py
M plone/app/event/tests/test_search.py
M plone/app/event/upgrades/upgrades.py
M plone/app/event/vocabularies.py
M setup.py

b'diff --git a/docs/conf.py b/docs/conf.py\nindex bd0a78d7..754e531f 100644\n--- a/docs/conf.py\n+++ b/docs/conf.py\n@@ -1,7 +1,7 @@\n # sphinx configuration\n \n-project = u"plone.app.event"\n-copyright = u"2012, Plone Foundation"\n+project = "plone.app.event"\n+copyright = "2012, Plone Foundation"\n \n extensions = [\n     "sphinx.ext.doctest",\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 03d08ffd..5284146e 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n __import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 03d08ffd..5284146e 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n __import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/event/__init__.py b/plone/app/event/__init__.py\nindex 301d4775..bac87e2c 100644\n--- a/plone/app/event/__init__.py\n+++ b/plone/app/event/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from AccessControl.Permission import addPermission\n from zope.i18nmessageid import MessageFactory\n \ndiff --git a/plone/app/event/base.py b/plone/app/event/base.py\nindex b6a4b8d6..5c317229 100644\n--- a/plone/app/event/base.py\n+++ b/plone/app/event/base.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n from calendar import monthrange\n@@ -77,7 +76,7 @@ def get_events(\n     expand=False,\n     sort="start",\n     sort_reverse=False,\n-    **kw\n+    **kw,\n ):\n     """Return all events as catalog brains, possibly within a given\n     timeframe.\n@@ -237,9 +236,9 @@ def filter_and_resort(context, brains, start, end, sort, sort_reverse):\n             continue\n         if sort == "start":\n             # first start can be before filter window if end is in window\n-            _first = min([s for (s, e) in _occ])\n+            _first = min(s for (s, e) in _occ)\n         elif sort == "end":\n-            _first = min([e for (s, e) in _occ])\n+            _first = min(e for (s, e) in _occ)\n         items.append((_first, brain))  # key on next start/end\n \n     # sort brains by next start, discard sort key\n@@ -922,7 +921,7 @@ def default_end(context=None):\n # TODO: Better fits to CMFPlone. (Taken from CMFPlone\'s new syndication tool)\n \n \n-class AnnotationAdapter(object):\n+class AnnotationAdapter:\n     """Abstract Base Class for an annotation storage.\n \n     If the annotation wasn\'t set, it won\'t be created until the first attempt\n@@ -991,7 +990,7 @@ def find_context(context, viewname=None, iface=None, as_url=False, append_view=T\n     if as_url:\n         url = ret.absolute_url()\n         if viewname and append_view and ret.defaultView() != viewname:\n-            url = "%s/%s" % (url, viewname)\n+            url = f"{url}/{viewname}"\n         return url\n     return ret\n \ndiff --git a/plone/app/event/browser/__init__.py b/plone/app/event/browser/__init__.py\nindex 40a96afc..e69de29b 100644\n--- a/plone/app/event/browser/__init__.py\n+++ b/plone/app/event/browser/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/event/browser/event_listing.py b/plone/app/event/browser/event_listing.py\nindex 6dcd791c..5e4bcbe1 100644\n--- a/plone/app/event/browser/event_listing.py\n+++ b/plone/app/event/browser/event_listing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from calendar import monthrange\n from datetime import date\n from datetime import timedelta\n@@ -41,7 +40,7 @@\n \n class EventListing(BrowserView):\n     def __init__(self, context, request):\n-        super(EventListing, self).__init__(context, request)\n+        super().__init__(context, request)\n \n         self.now = now = localized_now(context)\n \n@@ -146,7 +145,7 @@ def _get_events(self, ret_mode=RET_MODE_ACCESSORS, expand=True):\n             sort_reverse=sort_reverse,\n             ret_mode=ret_mode,\n             expand=expand,\n-            **kw\n+            **kw,\n         )\n \n     @view.memoize\n@@ -224,7 +223,7 @@ def ical_url(self):\n             ]\n         )\n         qstr = "?%s" % qstr if qstr else ""\n-        return "%s/@@event_listing_ical%s" % (self.context.absolute_url(), qstr)\n+        return f"{self.context.absolute_url()}/@@event_listing_ical{qstr}"\n \n     # COLLECTION daterange start/end determination\n     def _expand_events_start_end(self, start, end):\n@@ -272,25 +271,25 @@ def header_string(self):\n         main_msgid = None\n         sub_msgid = None\n         if mode == "all":\n-            main_msgid = _(u"all_events", default=u"All events")\n+            main_msgid = _("all_events", default="All events")\n \n         elif mode == "past":\n-            main_msgid = _(u"past_events", default=u"Past events")\n+            main_msgid = _("past_events", default="Past events")\n \n         elif mode == "future":\n-            main_msgid = _(u"future_events", default=u"Future events")\n+            main_msgid = _("future_events", default="Future events")\n \n         elif mode == "now":\n-            main_msgid = _(u"todays_upcoming_events", default=u"Todays upcoming events")\n+            main_msgid = _("todays_upcoming_events", default="Todays upcoming events")\n \n         elif mode == "today":\n-            main_msgid = _(u"todays_events", default=u"Todays events")\n+            main_msgid = _("todays_events", default="Todays events")\n \n         elif mode == "7days":\n-            main_msgid = _(u"7days_events", default=u"Events in next 7 days.")\n+            main_msgid = _("7days_events", default="Events in next 7 days.")\n             sub_msgid = _(\n-                u"events_from_until",\n-                default=u"${from} until ${until}.",\n+                "events_from_until",\n+                default="${from} until ${until}.",\n                 mapping={\n                     "from": "%s, %s. %s %s"\n                     % (\n@@ -311,8 +310,8 @@ def header_string(self):\n \n         elif mode == "day":\n             main_msgid = _(\n-                u"events_on_day",\n-                default=u"Events on ${day}",\n+                "events_on_day",\n+                default="Events on ${day}",\n                 mapping={\n                     "day": "%s, %s. %s %s"\n                     % (\n@@ -326,13 +325,13 @@ def header_string(self):\n \n         elif mode == "week":\n             main_msgid = _(\n-                u"events_in_week",\n-                default=u"Events in week ${weeknumber}",\n+                "events_in_week",\n+                default="Events in week ${weeknumber}",\n                 mapping={"weeknumber": start.isocalendar()[1]},\n             )\n             sub_msgid = _(\n-                u"events_from_until",\n-                default=u"${from} until ${until}.",\n+                "events_from_until",\n+                default="${from} until ${until}.",\n                 mapping={\n                     "from": "%s, %s. %s %s"\n                     % (\n@@ -353,8 +352,8 @@ def header_string(self):\n \n         elif mode == "month":\n             main_msgid = _(\n-                u"events_in_month",\n-                default=u"Events in ${month} ${year}",\n+                "events_in_month",\n+                default="Events in ${month} ${year}",\n                 mapping={\n                     "month": start_dict["month_name"],\n                     "year": start.year,\n@@ -369,7 +368,7 @@ def header_string(self):\n \n     # MODE URLs\n     def _date_nav_url(self, mode, datestr=""):\n-        return "%s?mode=%s%s" % (\n+        return "{}?mode={}{}".format(\n             self.request.getURL(),\n             mode,\n             "&date=%s" % datestr if datestr else "",\n@@ -467,5 +466,5 @@ class EventEventListing(EventListing):\n     """\n \n     def __init__(self, context, request):\n-        super(EventEventListing, self).__init__(context, request)\n+        super().__init__(context, request)\n         self.uid = IUUID(self.context)\ndiff --git a/plone/app/event/browser/event_summary.py b/plone/app/event/browser/event_summary.py\nindex 84b6956d..de565376 100644\n--- a/plone/app/event/browser/event_summary.py\n+++ b/plone/app/event/browser/event_summary.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_parent\n from plone.app.event import _\n from plone.event.interfaces import IEventAccessor\n@@ -78,9 +77,9 @@ def num_more_occurrences(self):\n     @property\n     def more_occurrences_text(self):\n         msgid = _(\n-            u"msg_num_more_occurrences",\n-            default=u"There are ${results} more occurrences.",\n-            mapping={u"results": self.num_more_occurrences},\n+            "msg_num_more_occurrences",\n+            default="There are ${results} more occurrences.",\n+            mapping={"results": self.num_more_occurrences},\n         )\n         return self.context.translate(msgid)\n \ndiff --git a/plone/app/event/browser/event_view.py b/plone/app/event/browser/event_view.py\nindex ff27002f..32ec01bc 100644\n--- a/plone/app/event/browser/event_view.py\n+++ b/plone/app/event/browser/event_view.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.event.interfaces import IEventAccessor\n from plone.event.interfaces import IOccurrence\n from Products.Five.browser import BrowserView\ndiff --git a/plone/app/event/browser/formatted_date.py b/plone/app/event/browser/formatted_date.py\nindex a3af360e..42a3d5ed 100644\n--- a/plone/app/event/browser/formatted_date.py\n+++ b/plone/app/event/browser/formatted_date.py\n@@ -1,11 +1,10 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import Explicit\n from plone.app.event.base import dates_for_display\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n \n \n class FormattedDateProvider(Explicit):\n-    template = ViewPageTemplateFile(u"formatted_date.pt")\n+    template = ViewPageTemplateFile("formatted_date.pt")\n \n     def __init__(self, context, request, view):\n         self.__parent__ = view\n@@ -24,9 +23,9 @@ def __call__(self, occ):\n         self.date_dict = dates_for_display(occ)\n         if self.date_dict is None:\n             # Don\'t break for potential Events without start/end.\n-            return u""\n+            return ""\n         return self.template(self)\n \n \n class FormattedStartDateProvider(FormattedDateProvider):\n-    template = ViewPageTemplateFile(u"formatted_start_date.pt")\n+    template = ViewPageTemplateFile("formatted_start_date.pt")\ndiff --git a/plone/app/event/browser/leadimage_viewlet.py b/plone/app/event/browser/leadimage_viewlet.py\nindex ae88616d..434071e5 100644\n--- a/plone/app/event/browser/leadimage_viewlet.py\n+++ b/plone/app/event/browser/leadimage_viewlet.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_parent\n from plone.app.contenttypes.behaviors.leadimage import ILeadImage\n from plone.app.layout.viewlets import ViewletBase\ndiff --git a/plone/app/event/dx/__init__.py b/plone/app/event/dx/__init__.py\nindex 40a96afc..e69de29b 100644\n--- a/plone/app/event/dx/__init__.py\n+++ b/plone/app/event/dx/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/event/dx/behaviors.py b/plone/app/event/dx/behaviors.py\nindex e57fc902..04ffa5fe 100644\n--- a/plone/app/event/dx/behaviors.py\n+++ b/plone/app/event/dx/behaviors.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """Behaviors to enable calendarish event extension to dexterity content types.\n """\n from plone.app.dexterity.behaviors.metadata import ICategorization\n@@ -47,7 +46,7 @@ def first_weekday_sun0():\n \n \n class StartBeforeEnd(Invalid):\n-    __doc__ = _("error_invalid_date", default=u"Invalid start or end date")\n+    __doc__ = _("error_invalid_date", default="Invalid start or end date")\n \n \n @provider(IContextAwareDefaultFactory)\n@@ -67,9 +66,9 @@ class IEventBasic(model.Schema, IDXEvent):\n     """Basic event schema."""\n \n     start = schema.Datetime(\n-        title=_(u"label_event_start", default=u"Event Starts"),\n+        title=_("label_event_start", default="Event Starts"),\n         description=_(\n-            u"help_event_start", default=u"Date and Time, when the event begins."\n+            "help_event_start", default="Date and Time, when the event begins."\n         ),\n         required=True,\n         defaultFactory=default_start,\n@@ -78,14 +77,12 @@ class IEventBasic(model.Schema, IDXEvent):\n         "start",\n         DatetimeFieldWidget,\n         default_timezone=default_timezone,\n-        klass=u"event_start",\n+        klass="event_start",\n     )\n \n     end = schema.Datetime(\n-        title=_(u"label_event_end", default=u"Event Ends"),\n-        description=_(\n-            u"help_event_end", default=u"Date and Time, when the event ends."\n-        ),\n+        title=_("label_event_end", default="Event Ends"),\n+        description=_("help_event_end", default="Date and Time, when the event ends."),\n         required=True,\n         defaultFactory=default_end,\n     )\n@@ -93,7 +90,7 @@ class IEventBasic(model.Schema, IDXEvent):\n         "end",\n         DatetimeFieldWidget,\n         default_timezone=default_timezone,\n-        klass=u"event_end",\n+        klass="event_end",\n         pattern_options={\n             "behavior": "styled",\n             "after": "input.event_end",\n@@ -102,20 +99,20 @@ class IEventBasic(model.Schema, IDXEvent):\n     )\n \n     whole_day = schema.Bool(\n-        title=_(u"label_event_whole_day", default=u"Whole Day"),\n-        description=_(u"help_event_whole_day", default=u"Event lasts whole day."),\n+        title=_("label_event_whole_day", default="Whole Day"),\n+        description=_("help_event_whole_day", default="Event lasts whole day."),\n         required=False,\n         default=False,\n     )\n-    directives.widget("whole_day", SingleCheckBoxFieldWidget, klass=u"event_whole_day")\n+    directives.widget("whole_day", SingleCheckBoxFieldWidget, klass="event_whole_day")\n \n     open_end = schema.Bool(\n-        title=_(u"label_event_open_end", default=u"Open End"),\n-        description=_(u"help_event_open_end", default=u"This event is open ended."),\n+        title=_("label_event_open_end", default="Open End"),\n+        description=_("help_event_open_end", default="This event is open ended."),\n         required=False,\n         default=False,\n     )\n-    directives.widget("open_end", SingleCheckBoxFieldWidget, klass=u"event_open_end")\n+    directives.widget("open_end", SingleCheckBoxFieldWidget, klass="event_open_end")\n \n     # icalendar event uid\n     sync_uid = schema.TextLine(required=False)\n@@ -127,7 +124,7 @@ def validate_start_end(data):\n             raise StartBeforeEnd(\n                 _(\n                     "error_end_must_be_after_start_date",\n-                    default=u"End date must be after start date.",\n+                    default="End date must be after start date.",\n                 )\n             )\n \n@@ -137,9 +134,9 @@ class IEventRecurrence(model.Schema, IDXEventRecurrence):\n     """Recurring Event Schema."""\n \n     recurrence = schema.Text(\n-        title=_(u"label_event_recurrence", default=u"Recurrence"),\n+        title=_("label_event_recurrence", default="Recurrence"),\n         description=_(\n-            u"help_event_recurrence", default=u"Define the event recurrence rule."\n+            "help_event_recurrence", default="Define the event recurrence rule."\n         ),\n         required=False,\n         default=None,\n@@ -147,10 +144,10 @@ class IEventRecurrence(model.Schema, IDXEventRecurrence):\n     directives.widget(\n         "recurrence",\n         RecurrenceFieldWidget,\n-        start_field=u"IEventBasic.start",\n+        start_field="IEventBasic.start",\n         first_day=first_weekday_sun0,\n         show_repeat_forever=False,\n-        klass=u"event_recurrence",\n+        klass="event_recurrence",\n     )\n \n \n@@ -159,12 +156,12 @@ class IEventLocation(model.Schema):\n     """Event Location Schema."""\n \n     location = schema.TextLine(\n-        title=_(u"label_event_location", default=u"Location"),\n-        description=_(u"help_event_location", default=u"Location of the event."),\n+        title=_("label_event_location", default="Location"),\n+        description=_("help_event_location", default="Location of the event."),\n         required=False,\n         default=None,\n     )\n-    directives.widget("location", TextFieldWidget, klass=u"event_location")\n+    directives.widget("location", TextFieldWidget, klass="event_location")\n \n \n class IEventAttendees(model.Schema):\n@@ -172,14 +169,14 @@ class IEventAttendees(model.Schema):\n     """Event Attendees Schema."""\n \n     attendees = schema.Tuple(\n-        title=_(u"label_event_attendees", default=u"Attendees"),\n-        description=_(u"help_event_attendees", default=u"List of attendees."),\n+        title=_("label_event_attendees", default="Attendees"),\n+        description=_("help_event_attendees", default="List of attendees."),\n         value_type=schema.TextLine(),\n         required=False,\n         missing_value=(),\n         default=(),\n     )\n-    directives.widget("attendees", TextLinesFieldWidget, klass=u"event_attendees")\n+    directives.widget("attendees", TextLinesFieldWidget, klass="event_attendees")\n \n \n class IEventContact(model.Schema):\n@@ -187,49 +184,49 @@ class IEventContact(model.Schema):\n     """Event Contact Schema."""\n \n     contact_name = schema.TextLine(\n-        title=_(u"label_event_contact_name", default=u"Contact Name"),\n+        title=_("label_event_contact_name", default="Contact Name"),\n         description=_(\n-            u"help_event_contact_name",\n-            default=u"Name of a person to contact about this event.",\n+            "help_event_contact_name",\n+            default="Name of a person to contact about this event.",\n         ),\n         required=False,\n         default=None,\n     )\n-    directives.widget("contact_name", TextFieldWidget, klass=u"event_contact_name")\n+    directives.widget("contact_name", TextFieldWidget, klass="event_contact_name")\n \n     contact_email = schema.TextLine(\n-        title=_(u"label_event_contact_email", default=u"Contact E-mail"),\n+        title=_("label_event_contact_email", default="Contact E-mail"),\n         description=_(\n-            u"help_event_contact_email",\n-            default=u"Email address to contact about this event.",\n+            "help_event_contact_email",\n+            default="Email address to contact about this event.",\n         ),\n         required=False,\n         default=None,\n     )\n-    directives.widget("contact_email", TextFieldWidget, klass=u"event_contact_email")\n+    directives.widget("contact_email", TextFieldWidget, klass="event_contact_email")\n \n     contact_phone = schema.TextLine(\n-        title=_(u"label_event_contact_phone", default=u"Contact Phone"),\n+        title=_("label_event_contact_phone", default="Contact Phone"),\n         description=_(\n-            u"help_event_contact_phone",\n-            default=u"Phone number to contact about this event.",\n+            "help_event_contact_phone",\n+            default="Phone number to contact about this event.",\n         ),\n         required=False,\n         default=None,\n     )\n-    directives.widget("contact_phone", TextFieldWidget, klass=u"event_contact_phone")\n+    directives.widget("contact_phone", TextFieldWidget, klass="event_contact_phone")\n \n     event_url = schema.URI(\n-        title=_(u"label_event_url", default=u"Event URL"),\n+        title=_("label_event_url", default="Event URL"),\n         description=_(\n-            u"help_event_url",\n-            default=u"Web address with more info about the event. "\n-            u"Add http:// for external links.",\n+            "help_event_url",\n+            default="Web address with more info about the event. "\n+            "Add http:// for external links.",\n         ),\n         required=False,\n         default=None,\n     )\n-    directives.widget("event_url", TextFieldWidget, klass=u"event_url")\n+    directives.widget("event_url", TextFieldWidget, klass="event_url")\n \n \n # Mark these interfaces as form field providers\n@@ -291,7 +288,7 @@ def sync_uid_indexer(obj):\n \n @adapter(IDXEvent)\n @implementer(IEventAccessor)\n-class EventAccessor(object):\n+class EventAccessor:\n \n     """Generic event accessor adapter implementation for Dexterity content\n     objects.\n@@ -468,7 +465,7 @@ def last_modified(self, value):\n     def text(self):\n         textvalue = getattr(self.context, "text", None)\n         if textvalue is None:\n-            return u""\n+            return ""\n         return safe_unicode(textvalue.output_relative_to(self.context))\n \n     @text.setter\ndiff --git a/plone/app/event/dx/interfaces.py b/plone/app/event/dx/interfaces.py\nindex d3935448..fe6af56e 100644\n--- a/plone/app/event/dx/interfaces.py\n+++ b/plone/app/event/dx/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.event.interfaces import IEvent\n from plone.event.interfaces import IEventRecurrence\n \ndiff --git a/plone/app/event/dx/traverser.py b/plone/app/event/dx/traverser.py\nindex 828b0458..553f258f 100644\n--- a/plone/app/event/dx/traverser.py\n+++ b/plone/app/event/dx/traverser.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.dx.interfaces import IDXEventRecurrence\n from plone.app.event.recurrence import OccurrenceTraverser as DefaultTraverser\n from plone.dexterity.browser.traversal import DexterityPublishTraverse\ndiff --git a/plone/app/event/ical/__init__.py b/plone/app/event/ical/__init__.py\nindex 5d70fc71..50df7e31 100644\n--- a/plone/app/event/ical/__init__.py\n+++ b/plone/app/event/ical/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.ical.exporter import calendar_from_collection  # nopep8\n from plone.app.event.ical.exporter import calendar_from_container  # nopep8\n from plone.app.event.ical.exporter import calendar_from_event  # nopep8\ndiff --git a/plone/app/event/ical/exporter.py b/plone/app/event/ical/exporter.py\nindex af0ff04d..6d4fb004 100644\n--- a/plone/app/event/ical/exporter.py\n+++ b/plone/app/event/ical/exporter.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from datetime import datetime\n from datetime import timedelta\n@@ -192,7 +191,7 @@ def calendar_from_collection(context):\n \n \n @implementer(IICalendarEventComponent)\n-class ICalendarEventComponent(object):\n+class ICalendarEventComponent:\n     """Returns an icalendar object of the event."""\n \n     def __init__(self, context):\n@@ -345,7 +344,7 @@ def contact(self):\n         if event.event_url:\n             cn.append(event.event_url)\n \n-        return {"value": u", ".join(cn)}\n+        return {"value": ", ".join(cn)}\n \n     @property\n     def categories(self):\n@@ -408,10 +407,10 @@ def get_ical_string(self):\n \n     def __call__(self):\n         ical = self.get_ical_string()\n-        name = "{0}.ics".format(self.context.getId())\n+        name = f"{self.context.getId()}.ics"\n         self.request.response.setHeader("Content-Type", "text/calendar")\n         self.request.response.setHeader(\n-            "Content-Disposition", \'attachment; filename="{0}"\'.format(name)\n+            "Content-Disposition", f\'attachment; filename="{name}"\'\n         )\n         self.request.response.setHeader("Content-Length", len(ical))\n         self.request.response.write(ical)\ndiff --git a/plone/app/event/ical/importer.py b/plone/app/event/ical/importer.py\nindex 1ce1600f..787ca8f3 100644\n--- a/plone/app/event/ical/importer.py\n+++ b/plone/app/event/ical/importer.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event import _\n from plone.app.event import base\n from plone.app.event.base import AnnotationAdapter\n@@ -75,10 +74,10 @@ def _from_list(ical, prop):\n         for item in val:\n             ret = "%s," % ret if ret else ret  # insert linebreak\n             ical_val = item.to_ical()\n-            if six.PY3 and isinstance(ical_val, six.binary_type):\n+            if six.PY3 and isinstance(ical_val, bytes):\n                 ical_val = ical_val.decode("utf8")\n-            ret = "%s%s" % (ret, ical_val)\n-        return "%s:%s" % (prop, ret) if ret else None\n+            ret = f"{ret}{ical_val}"\n+        return f"{prop}:{ret}" if ret else None\n \n     count = 0\n     for item in events:\n@@ -129,7 +128,7 @@ def _from_list(ical, prop):\n         rrule = _get_prop("RRULE", item)\n         rrule = rrule.to_ical() if rrule else ""\n         if rrule:\n-            if six.PY3 and isinstance(rrule, six.binary_type):\n+            if six.PY3 and isinstance(rrule, bytes):\n                 rrule = rrule.decode("utf8")\n             rrule = "RRULE:%s" % rrule\n         rdates = _from_list(item, "RDATE")\n@@ -143,7 +142,7 @@ def _from_list(ical, prop):\n         contact = _get_prop("CONTACT", item)\n         categories = item.get("CATEGORIES", ())\n         if getattr(categories, "__iter__", False):\n-            categories = tuple([safe_unicode(it) for it in categories])\n+            categories = tuple(safe_unicode(it) for it in categories)\n \n         ext_modified = utc(_get_prop("LAST-MODIFIED", item))\n \n@@ -228,47 +227,47 @@ def no_file_protocol_url(value):\n     This opens up security issues.\n     """\n     if value and value.startswith("file:"):\n-        raise Invalid(_(u"URLs with file: are not allowed."))\n+        raise Invalid(_("URLs with file: are not allowed."))\n     return True\n \n \n class IIcalendarImportSettings(Interface):\n \n     event_type = schema.Choice(\n-        title=_("ical_import_event_type_title", default=u"Event Type"),\n+        title=_("ical_import_event_type_title", default="Event Type"),\n         description=_(\n             "ical_import_event_type_desc",\n-            default=u"Content type of the event, which is created when "\n-            u"importing icalendar resources.",\n+            default="Content type of the event, which is created when "\n+            "importing icalendar resources.",\n         ),\n         vocabulary="plone.app.vocabularies.ReallyUserFriendlyTypes",\n         required=True,\n     )\n \n     ical_url = schema.URI(\n-        title=_("ical_import_url_title", default=u"Icalendar URL"),\n+        title=_("ical_import_url_title", default="Icalendar URL"),\n         description=_(\n             "ical_import_url_desc",\n-            default=u"URL to an external icalendar resource file.",\n+            default="URL to an external icalendar resource file.",\n         ),\n         constraint=no_file_protocol_url,\n         required=False,\n     )\n \n     ical_file = NamedFile(\n-        title=_("ical_import_file_title", default=u"Icalendar File"),\n+        title=_("ical_import_file_title", default="Icalendar File"),\n         description=_(\n             "ical_import_file_desc",\n-            default=u"Icalendar resource file, if no URL is given.",\n+            default="Icalendar resource file, if no URL is given.",\n         ),\n         required=False,\n     )\n \n     sync_strategy = schema.Choice(\n-        title=_("ical_import_sync_strategy_title", default=u"Synchronization Strategy"),\n+        title=_("ical_import_sync_strategy_title", default="Synchronization Strategy"),\n         description=_(\n             "ical_import_sync_strategy_desc",\n-            default=u"""Defines how to synchronize:\n+            default="""Defines how to synchronize:\n 1) "Keep newer": Import, if the imported event is modified after the existing\n    one.\n 2) "Keep mine": On conflicts, just do nothing.\n@@ -309,7 +308,7 @@ def save_data(self, data):\n         settings.event_type = data["event_type"]\n         settings.sync_strategy = data["sync_strategy"]\n \n-    @button.buttonAndHandler(u"Save")\n+    @button.buttonAndHandler("Save")\n     def handleSave(self, action):\n         data, errors = self.extractData()\n         if errors:\n@@ -318,12 +317,12 @@ def handleSave(self, action):\n         self.save_data(data)\n \n         IStatusMessage(self.request).addStatusMessage(\n-            _("msg_ical_import_settings_saved", default=u"Ical import settings saved."),\n+            _("msg_ical_import_settings_saved", default="Ical import settings saved."),\n             "info",\n         )\n         self.request.response.redirect(self.context.absolute_url())\n \n-    @button.buttonAndHandler(u"Save and Import")\n+    @button.buttonAndHandler("Save and Import")\n     def handleSaveImport(self, action):\n         data, errors = self.extractData()\n         if errors:\n@@ -358,7 +357,7 @@ def handleSaveImport(self, action):\n             IStatusMessage(self.request).addStatusMessage(\n                 _(\n                     "ical_import_imported",\n-                    default=u"${num} events imported from ${filename}",\n+                    default="${num} events imported from ${filename}",\n                     mapping={"num": count, "filename": ical_import_from},\n                 ),\n                 "info",\n@@ -368,15 +367,15 @@ def handleSaveImport(self, action):\n             IStatusMessage(self.request).addStatusMessage(\n                 _(\n                     "ical_import_no_ics",\n-                    default=u"Please provide either a icalendar ics file or a "\n-                    u"URL to a file.",\n+                    default="Please provide either a icalendar ics file or a "\n+                    "URL to a file.",\n                 ),\n                 "error",\n             )\n \n         self.request.response.redirect(self.context.absolute_url())\n \n-    @button.buttonAndHandler(u"Cancel")\n+    @button.buttonAndHandler("Cancel")\n     def handleCancel(self, action):\n         self.request.response.redirect(self.context.absolute_url())\n \ndiff --git a/plone/app/event/interfaces.py b/plone/app/event/interfaces.py\nindex 82262b27..cb9e52af 100644\n--- a/plone/app/event/interfaces.py\n+++ b/plone/app/event/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Interface\n from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n \ndiff --git a/plone/app/event/portlets/__init__.py b/plone/app/event/portlets/__init__.py\nindex fe916989..50212c41 100644\n--- a/plone/app/event/portlets/__init__.py\n+++ b/plone/app/event/portlets/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.base import find_navroot\n from plone.app.event.base import find_ploneroot\n \n@@ -12,7 +11,7 @@ def get_calendar_url(context, search_base):\n     calendar_url = None\n     if search_base:\n         portal = find_ploneroot(context)\n-        if six.PY2 and isinstance(search_base, six.text_type):\n+        if six.PY2 and isinstance(search_base, str):\n             search_base = search_base.encode("utf8")\n         search_base = "/".join(search_base.split("/")[2:])\n         calendar_url = portal.unrestrictedTraverse(\ndiff --git a/plone/app/event/portlets/portlet_calendar.py b/plone/app/event/portlets/portlet_calendar.py\nindex d6017a7e..f6efe6df 100644\n--- a/plone/app/event/portlets/portlet_calendar.py\n+++ b/plone/app/event/portlets/portlet_calendar.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from ComputedAttribute import ComputedAttribute\n from plone.app.event import _\n@@ -53,22 +52,22 @@ class ICalendarPortlet(IPortletDataProvider):\n     """A portlet displaying a calendar"""\n \n     state = schema.Tuple(\n-        title=_(u"Workflow state"),\n-        description=_(u"Items in which workflow state to show."),\n+        title=_("Workflow state"),\n+        description=_("Items in which workflow state to show."),\n         default=None,\n         required=False,\n         value_type=schema.Choice(vocabulary="plone.app.vocabularies.WorkflowStates"),\n     )\n \n     search_base_uid = schema.Choice(\n-        title=_(u"portlet_label_search_base", default=u"Search base"),\n+        title=_("portlet_label_search_base", default="Search base"),\n         description=_(\n-            u"portlet_help_search_base",\n-            default=u"Select search base Folder or Collection to search for "\n-            u"events. The URL to to this item will also be used to "\n-            u"link to in calendar searches. If empty, the whole site "\n-            u"will be searched and the event listing view will be "\n-            u"called on the site root.",\n+            "portlet_help_search_base",\n+            default="Select search base Folder or Collection to search for "\n+            "events. The URL to to this item will also be used to "\n+            "link to in calendar searches. If empty, the whole site "\n+            "will be searched and the event listing view will be "\n+            "called on the site root.",\n         ),\n         required=False,\n         source=search_base_uid_source,\n@@ -77,7 +76,7 @@ class ICalendarPortlet(IPortletDataProvider):\n \n @implementer(ICalendarPortlet)\n class Assignment(base.Assignment):\n-    title = _(u"Calendar")\n+    title = _("Calendar")\n \n     # reduce upgrade pain\n     state = None\n@@ -129,8 +128,8 @@ def update(self):\n         self.next_year, self.next_month = next_year, next_month = self.get_next_month(\n             year, month\n         )\n-        self.prev_query = "?month=%s&year=%s" % (prev_month, prev_year)\n-        self.next_query = "?month=%s&year=%s" % (next_month, next_year)\n+        self.prev_query = f"?month={prev_month}&year={prev_year}"\n+        self.next_query = f"?month={next_month}&year={next_year}"\n \n         self.cal = calendar.Calendar(first_weekday())\n         self._ts = getToolByName(context, "translation_service")\n@@ -188,7 +187,7 @@ def get_next_month(self, year, month):\n         return (year, month)\n \n     def date_events_url(self, date):\n-        return "%s?mode=day&date=%s" % (self.calendar_url, date)\n+        return f"{self.calendar_url}?mode=day&date={date}"\n \n     @property\n     def cal_data(self):\n@@ -245,7 +244,7 @@ def cal_data(self):\n                 end=end,\n                 ret_mode=RET_MODE_OBJECTS,\n                 expand=True,\n-                **query\n+                **query,\n             )\n \n         cal_dict = construct_calendar(events, start=start, end=end)\n@@ -269,11 +268,11 @@ def cal_data(self):\n                     time = accessor.start.time().strftime("%H:%M")\n                     # TODO: make 24/12 hr format configurable\n                     events_string_list.append(\n-                        u"{0}{1}{2}{3}".format(\n+                        "{}{}{}{}".format(\n                             accessor.title,\n-                            u" {0}".format(time) if not whole_day else u"",\n-                            u", " if not whole_day and location else u"",\n-                            u" {0}".format(location) if location else u"",\n+                            f" {time}" if not whole_day else "",\n+                            ", " if not whole_day and location else "",\n+                            f" {location}" if location else "",\n                         )\n                     )\n \n@@ -286,8 +285,8 @@ def cal_data(self):\n                     "today": dat.year == today.year\n                     and dat.month == today.month\n                     and dat.day == today.day,\n-                    "date_string": u"%s-%s-%s" % (dat.year, dat.month, dat.day),\n-                    "events_string": u" | ".join(events_string_list),\n+                    "date_string": f"{dat.year}-{dat.month}-{dat.day}",\n+                    "events_string": " | ".join(events_string_list),\n                     "events": date_events,\n                 }\n             )\n@@ -315,8 +314,8 @@ def hash(self):\n \n class AddForm(base.AddForm):\n     schema = ICalendarPortlet\n-    label = _(u"Add Calendar Portlet")\n-    description = _(u"This portlet displays events in a calendar.")\n+    label = _("Add Calendar Portlet")\n+    description = _("This portlet displays events in a calendar.")\n \n     def create(self, data):\n         return Assignment(\n@@ -327,5 +326,5 @@ def create(self, data):\n \n class EditForm(base.EditForm):\n     schema = ICalendarPortlet\n-    label = _(u"Edit Calendar Portlet")\n-    description = _(u"This portlet displays events in a calendar.")\n+    label = _("Edit Calendar Portlet")\n+    description = _("This portlet displays events in a calendar.")\ndiff --git a/plone/app/event/portlets/portlet_events.py b/plone/app/event/portlets/portlet_events.py\nindex 6f0dd8b0..4c394bb6 100644\n--- a/plone/app/event/portlets/portlet_events.py\n+++ b/plone/app/event/portlets/portlet_events.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from ComputedAttribute import ComputedAttribute\n from plone.app.event import _\n@@ -31,49 +30,49 @@\n class IEventsPortlet(IPortletDataProvider):\n \n     count = schema.Int(\n-        title=_(u"Number of items to display"),\n-        description=_(u"How many items to list."),\n+        title=_("Number of items to display"),\n+        description=_("How many items to list."),\n         required=True,\n         default=5,\n         min=1,\n     )\n \n     state = schema.Tuple(\n-        title=_(u"Workflow state"),\n-        description=_(u"Items in which workflow state to show."),\n+        title=_("Workflow state"),\n+        description=_("Items in which workflow state to show."),\n         default=None,\n         required=False,\n         value_type=schema.Choice(vocabulary="plone.app.vocabularies.WorkflowStates"),\n     )\n \n     search_base_uid = schema.Choice(\n-        title=_(u"portlet_label_search_base", default=u"Search base"),\n+        title=_("portlet_label_search_base", default="Search base"),\n         description=_(\n-            u"portlet_help_search_base",\n-            default=u"Select search base Folder or Collection to search for "\n-            u"events. The URL to to this item will also be used to "\n-            u"link to in calendar searches. If empty, the whole site "\n-            u"will be searched and the event listing view will be "\n-            u"called on the site root.",\n+            "portlet_help_search_base",\n+            default="Select search base Folder or Collection to search for "\n+            "events. The URL to to this item will also be used to "\n+            "link to in calendar searches. If empty, the whole site "\n+            "will be searched and the event listing view will be "\n+            "called on the site root.",\n         ),\n         required=False,\n         source=search_base_uid_source,\n     )\n     thumb_scale = schema.TextLine(\n-        title=_(u"Override thumb scale"),\n+        title=_("Override thumb scale"),\n         description=_(\n-            u"Enter a valid scale name"\n-            u" (see \'Image Handling\' control panel) to override"\n-            u" (e.g. icon, tile, thumb, mini, preview, ... )."\n-            u" Leave empty to use default (see \'Site\' control panel)."\n+            "Enter a valid scale name"\n+            " (see \'Image Handling\' control panel) to override"\n+            " (e.g. icon, tile, thumb, mini, preview, ... )."\n+            " Leave empty to use default (see \'Site\' control panel)."\n         ),\n         required=False,\n-        default=u"",\n+        default="",\n     )\n \n     no_thumbs = schema.Bool(\n-        title=_(u"Suppress thumbs"),\n-        description=_(u"If enabled, the portlet will not show thumbs."),\n+        title=_("Suppress thumbs"),\n+        description=_("If enabled, the portlet will not show thumbs."),\n         required=False,\n         default=False,\n     )\n@@ -102,7 +101,7 @@ def __init__(\n \n     @property\n     def title(self):\n-        return _(u"Events")\n+        return _("Events")\n \n     def _uid(self):\n         # This is only called if the instance doesn\'t have a search_base_uid\n@@ -233,8 +232,8 @@ def thumb_scale(self):\n \n class AddForm(base.AddForm):\n     schema = IEventsPortlet\n-    label = _(u"Add Events Portlet")\n-    description = _(u"This portlet lists upcoming Events.")\n+    label = _("Add Events Portlet")\n+    description = _("This portlet lists upcoming Events.")\n \n     def create(self, data):\n         return Assignment(\n@@ -246,5 +245,5 @@ def create(self, data):\n \n class EditForm(base.EditForm):\n     schema = IEventsPortlet\n-    label = _(u"Edit Events Portlet")\n-    description = _(u"This portlet lists upcoming Events.")\n+    label = _("Edit Events Portlet")\n+    description = _("This portlet lists upcoming Events.")\ndiff --git a/plone/app/event/recurrence.py b/plone/app/event/recurrence.py\nindex e5f46dfa..f27a1260 100644\n--- a/plone/app/event/recurrence.py\n+++ b/plone/app/event/recurrence.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_parent\n from OFS.SimpleItem import SimpleItem\n from plone.app.event.base import dt_start_of_day\n@@ -29,7 +28,7 @@\n \n @adapter(IEventRecurrence)\n @implementer(IRecurrenceSupport)\n-class RecurrenceSupport(object):\n+class RecurrenceSupport:\n     """IRecurrenceSupport Adapter."""\n \n     def __init__(self, context):\n@@ -124,7 +123,7 @@ def publishTraverse(self, request, name):\n         return self.fallbackTraverse(request, name)\n \n     def fallbackTraverse(self, request, name):\n-        return super(OccurrenceTraverser, self).publishTraverse(request, name)\n+        return super().publishTraverse(request, name)\n \n \n @implementer(IOccurrence)\n@@ -142,7 +141,7 @@ def __init__(self, id, start, end):\n \n @adapter(IOccurrence)\n @implementer(IEventAccessor)\n-class EventOccurrenceAccessor(object):\n+class EventOccurrenceAccessor:\n     """Generic event accessor adapter implementation for Occurrence objects."""\n \n     def __init__(self, context):\ndiff --git a/plone/app/event/setuphandlers.py b/plone/app/event/setuphandlers.py\nindex b2028f16..4923bacf 100644\n--- a/plone/app/event/setuphandlers.py\n+++ b/plone/app/event/setuphandlers.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Products.CMFCore.utils import getToolByName\n from Products.CMFPlone.interfaces import INonInstallable\n from Products.ZCatalog.Catalog import CatalogError\n@@ -11,7 +10,7 @@\n \n \n @implementer(INonInstallable)\n-class HiddenProfiles(object):\n+class HiddenProfiles:\n     def getNonInstallableProfiles(self):\n         """Prevents profiles, which should not be user-installable from showing\n         up in the profile list when creating a Plone site.\n@@ -20,7 +19,7 @@ def getNonInstallableProfiles(self):\n         example type.\n         """\n         return [\n-            u"plone.app.event:testing",\n+            "plone.app.event:testing",\n         ]\n \n \n@@ -43,7 +42,7 @@ def setup_catalog(context):\n     field_idxs = ["sync_uid"]\n     idxs = date_idxs + field_idxs\n \n-    class extra(object):\n+    class extra:\n         recurdef = "recurrence"\n         until = ""\n \ndiff --git a/plone/app/event/testing.py b/plone/app/event/testing.py\nindex 02e2364e..171f58c1 100644\n--- a/plone/app/event/testing.py\n+++ b/plone/app/event/testing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.interfaces import IBrowserLayer\n from plone.app.robotframework.testing import AUTOLOGIN_LIBRARY_FIXTURE\n from plone.app.testing import FunctionalTesting\n@@ -61,7 +60,7 @@ def make_fake_response(request):\n     headers = {}\n     output = []\n \n-    class Response(object):\n+    class Response:\n         def setHeader(self, header, value):\n             headers[header] = value\n \ndiff --git a/plone/app/event/tests/__init__.py b/plone/app/event/tests/__init__.py\nindex 40a96afc..e69de29b 100644\n--- a/plone/app/event/tests/__init__.py\n+++ b/plone/app/event/tests/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/event/tests/base_setup.py b/plone/app/event/tests/base_setup.py\nindex 2cefd2a2..c3f70d14 100644\n--- a/plone/app/event/tests/base_setup.py\n+++ b/plone/app/event/tests/base_setup.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import datetime\n from datetime import timedelta\n from plone.app.event.dx import behaviors\n@@ -82,10 +81,10 @@ def setUp(self):\n         self.past_event = factory(\n             container=self.portal,\n             id="past",\n-            title=u"Past Event",\n+            title="Past Event",\n             start=past,\n             end=past + duration,\n-            location=u"Vienna",\n+            location="Vienna",\n             whole_day=True,\n             recurrence="RRULE:FREQ=DAILY;COUNT=3",\n         )\n@@ -96,10 +95,10 @@ def setUp(self):\n         self.now_event = factory(\n             container=self.portal,\n             id="now",\n-            title=u"Now Event",\n+            title="Now Event",\n             start=now,\n             end=now + duration,\n-            location=u"Vienna",\n+            location="Vienna",\n             recurrence="""RRULE:FREQ=DAILY;COUNT=3;INTERVAL=1\n RDATE:20130509T000000\n EXDATE:20130506T000000,20140404T000000""",\n@@ -118,35 +117,35 @@ def setUp(self):\n         self.future_event = factory(\n             container=self.portal,\n             id="future",\n-            title=u"Future Event",\n+            title="Future Event",\n             text=RichTextValue(\n-                u"\xc3\x9cberraschung! Du kannst nach mir suchen",\n+                "\xc3\x9cberraschung! Du kannst nach mir suchen",\n                 "text/plain",\n                 "text/html",\n             ),\n             start=future,\n             end=future + duration,\n-            location=u"Graz",\n+            location="Graz",\n         )\n         workflow.doActionFor(self.future_event, "publish")\n         self.future_event.reindexObject()\n \n-        self.portal.invokeFactory("Folder", "sub", title=u"sub")\n+        self.portal.invokeFactory("Folder", "sub", title="sub")\n         self.long_event = factory(\n             container=self.portal.sub,\n             id="long",\n-            title=u"Long Event",\n+            title="Long Event",\n             start=past,\n             end=far,\n-            location=u"Schaftal",\n+            location="Schaftal",\n         )\n         workflow.doActionFor(self.long_event, "publish")\n         self.long_event.reindexObject()\n \n         # plone.app.contenttypes ICollection type\n-        self.portal.invokeFactory("Collection", "collection", title=u"Col")\n+        self.portal.invokeFactory("Collection", "collection", title="Col")\n         collection = self.portal.collection\n-        collection.sort_on = u"start"\n+        collection.sort_on = "start"\n         collection.reverse_sort = True\n         collection.query = [\n             {\ndiff --git a/plone/app/event/tests/test_base_module.py b/plone/app/event/tests/test_base_module.py\nindex e78430b8..2e07cfd1 100644\n--- a/plone/app/event/tests/test_base_module.py\n+++ b/plone/app/event/tests/test_base_module.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import date\n from datetime import datetime\n from datetime import timedelta\n@@ -337,10 +336,10 @@ def test_spell_date(self):\n         # locale specific\n         # TODO: test better.\n         self.assertTrue(isinstance(date_spelled["wkday"], int))\n-        self.assertTrue(isinstance(date_spelled["month_name"], six.string_types))\n-        self.assertTrue(isinstance(date_spelled["month_abbr"], six.string_types))\n-        self.assertTrue(isinstance(date_spelled["wkday_name"], six.string_types))\n-        self.assertTrue(isinstance(date_spelled["wkday_abbr"], six.string_types))\n+        self.assertTrue(isinstance(date_spelled["month_name"], str))\n+        self.assertTrue(isinstance(date_spelled["month_abbr"], str))\n+        self.assertTrue(isinstance(date_spelled["wkday_name"], str))\n+        self.assertTrue(isinstance(date_spelled["wkday_abbr"], str))\n \n \n class TimezoneTest(unittest.TestCase):\n@@ -489,11 +488,11 @@ def test_get_events(self):\n \n         # Test sort_on\n         res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS, sort="start")\n-        self.assertEqual([it.title for it in res][2:], [u"Now Event", u"Future Event"])\n+        self.assertEqual([it.title for it in res][2:], ["Now Event", "Future Event"])\n         res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS, sort="end")\n         self.assertEqual(\n             [it.title for it in res],\n-            [u"Past Event", u"Now Event", u"Future Event", u"Long Event"],\n+            ["Past Event", "Now Event", "Future Event", "Long Event"],\n         )\n \n         # Test expansion\n@@ -573,21 +572,21 @@ def test_get_event_limit(self):\n         factory(\n             container=self.portal,\n             content_id="past_recur",\n-            title=u"Past Event recurring",\n+            title="Past Event recurring",\n             start=self.past,\n             end=self.past + self.duration,\n-            location=u"Dornbirn",\n+            location="Dornbirn",\n             recurrence="RRULE:FREQ=WEEKLY;COUNT=4",\n         )\n \n         tomorrow = factory(\n             container=self.portal,\n             content_id="tomorrow",\n-            title=u"Tomorrow event",\n+            title="Tomorrow event",\n             start=self.tomorrow,\n             end=self.tomorrow + self.duration,\n             open_end=True,\n-            location=u"Dornbirn",\n+            location="Dornbirn",\n         )\n         tomorrow.reindexObject()\n \n@@ -667,38 +666,38 @@ def setUp(self):\n         factory(\n             container=self.portal,\n             content_id="past_recur",\n-            title=u"Past Recur",\n+            title="Past Recur",\n             start=self.past + self.duration,\n             end=self.past + self.duration + self.duration,\n-            location=u"Dornbirn",\n+            location="Dornbirn",\n             recurrence="RRULE:FREQ=WEEKLY;COUNT=4",\n         )\n \n         tomorrow = factory(\n             container=self.portal,\n             content_id="tomorrow",\n-            title=u"Tomorrow event",\n+            title="Tomorrow event",\n             start=self.tomorrow,\n             end=self.tomorrow + self.duration,\n             open_end=True,\n-            location=u"Dornbirn",\n+            location="Dornbirn",\n         )\n         tomorrow.reindexObject()\n \n         self.occ = [\n-            (u"Past Event", "2013-04-25 00:00:00", "2013-04-25 23:59:59"),\n-            (u"Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n-            (u"Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n-            (u"Past Event", "2013-04-26 00:00:00", "2013-04-26 23:59:59"),\n-            (u"Past Event", "2013-04-27 00:00:00", "2013-04-27 23:59:59"),\n-            (u"Past Recur", "2013-05-02 11:00:00", "2013-05-02 12:00:00"),\n-            (u"Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n-            (u"Tomorrow event", "2013-05-06 10:00:00", "2013-05-06 23:59:59"),\n-            (u"Now Event", "2013-05-07 10:00:00", "2013-05-07 11:00:00"),\n-            (u"Now Event", "2013-05-09 10:00:00", "2013-05-09 11:00:00"),\n-            (u"Past Recur", "2013-05-09 11:00:00", "2013-05-09 12:00:00"),\n-            (u"Future Event", "2013-05-15 10:00:00", "2013-05-15 11:00:00"),\n-            (u"Past Recur", "2013-05-16 11:00:00", "2013-05-16 12:00:00"),\n+            ("Past Event", "2013-04-25 00:00:00", "2013-04-25 23:59:59"),\n+            ("Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            ("Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n+            ("Past Event", "2013-04-26 00:00:00", "2013-04-26 23:59:59"),\n+            ("Past Event", "2013-04-27 00:00:00", "2013-04-27 23:59:59"),\n+            ("Past Recur", "2013-05-02 11:00:00", "2013-05-02 12:00:00"),\n+            ("Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+            ("Tomorrow event", "2013-05-06 10:00:00", "2013-05-06 23:59:59"),\n+            ("Now Event", "2013-05-07 10:00:00", "2013-05-07 11:00:00"),\n+            ("Now Event", "2013-05-09 10:00:00", "2013-05-09 11:00:00"),\n+            ("Past Recur", "2013-05-09 11:00:00", "2013-05-09 12:00:00"),\n+            ("Future Event", "2013-05-15 10:00:00", "2013-05-15 11:00:00"),\n+            ("Past Recur", "2013-05-16 11:00:00", "2013-05-16 12:00:00"),\n         ]\n \n     def diff(self, list1, list2):\n@@ -763,36 +762,36 @@ def test_expand_future_event(self):\n         next_year = self.event_factory(\n             container=self.portal,\n             content_id="next-year",\n-            title=u"Next year",\n+            title="Next year",\n             start=self.tomorrow + timedelta(365),\n             end=self.tomorrow + timedelta(365) + self.duration,\n-            location=u"Dornbirn",\n+            location="Dornbirn",\n             recurrence="RRULE:FREQ=DAILY;COUNT=4",\n         )\n         next_year.reindexObject()\n \n         ev = (\n-            u"Next year",\n+            "Next year",\n             "2014-05-06 10:00:00",\n             "2014-05-06 11:00:00",\n         )  # original event\n         rec1 = (\n-            u"Next year",\n+            "Next year",\n             "2014-05-07 10:00:00",\n             "2014-05-07 11:00:00",\n         )  # first recurrence\n         rec2 = (\n-            u"Next year",\n+            "Next year",\n             "2014-05-08 10:00:00",\n             "2014-05-08 11:00:00",\n         )  # second recurrence\n         rec3 = (\n-            u"Next year",\n+            "Next year",\n             "2014-05-09 10:00:00",\n             "2014-05-09 11:00:00",\n         )  # third recurrence\n         rec4 = (\n-            u"Next year",\n+            "Next year",\n             "2014-05-10 10:00:00",\n             "2014-05-10 11:00:00",\n         )  # fourth recurrence\n@@ -837,12 +836,12 @@ def test_noexpand_all(self):\n             get_events(self.portal, expand=False, ret_mode=RET_MODE_ACCESSORS)\n         )\n         expect = [\n-            (u"Past Event", "2013-04-25 00:00:00", "2013-04-25 23:59:59"),\n-            (u"Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n-            (u"Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n-            (u"Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n-            (u"Tomorrow event", "2013-05-06 10:00:00", "2013-05-06 23:59:59"),\n-            (u"Future Event", "2013-05-15 10:00:00", "2013-05-15 11:00:00"),\n+            ("Past Event", "2013-04-25 00:00:00", "2013-04-25 23:59:59"),\n+            ("Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            ("Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n+            ("Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+            ("Tomorrow event", "2013-05-06 10:00:00", "2013-05-06 23:59:59"),\n+            ("Future Event", "2013-05-15 10:00:00", "2013-05-15 11:00:00"),\n         ]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n@@ -860,13 +859,13 @@ def test_noexpand_start(self):\n             )\n         )\n         expect = [\n-            (u"Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n-            (u"Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n-            (u"Tomorrow event", "2013-05-06 10:00:00", "2013-05-06 23:59:59"),\n+            ("Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            ("Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+            ("Tomorrow event", "2013-05-06 10:00:00", "2013-05-06 23:59:59"),\n             # Past Recur next occurrence: \'2013-05-09 11:00:00\'\n             # Past Recur brain.start: \'2013-04-25 11:00:00\'\n-            (u"Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n-            (u"Future Event", "2013-05-15 10:00:00", "2013-05-15 11:00:00"),\n+            ("Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n+            ("Future Event", "2013-05-15 10:00:00", "2013-05-15 11:00:00"),\n         ]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n@@ -890,10 +889,10 @@ def test_noexpand_end(self):\n             )\n         )\n         expect = [\n-            (u"Past Event", "2013-04-25 00:00:00", "2013-04-25 23:59:59"),\n-            (u"Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n-            (u"Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n-            (u"Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+            ("Past Event", "2013-04-25 00:00:00", "2013-04-25 23:59:59"),\n+            ("Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            ("Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n+            ("Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n         ]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n@@ -921,8 +920,8 @@ def test_noexpand_start_end(self):\n             )\n         )\n         expect = [\n-            (u"Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n-            (u"Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+            ("Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            ("Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n         ]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n@@ -959,11 +958,11 @@ def test_prep_display_with_time(self):\n         self.assertEqual(\n             dates_for_display(event),\n             {\n-                "start_date": u"Oct 12, 2000",\n-                "start_time": u"06:00 AM",\n+                "start_date": "Oct 12, 2000",\n+                "start_time": "06:00 AM",\n                 "start_iso": "2000-10-12T06:00:00+02:00",\n-                "end_date": u"Oct 12, 2000",\n-                "end_time": u"06:00 PM",\n+                "end_date": "Oct 12, 2000",\n+                "end_time": "06:00 PM",\n                 "end_iso": "2000-10-12T18:00:00+02:00",\n                 "same_day": True,\n                 "same_time": False,\n@@ -985,10 +984,10 @@ def test_prep_display_wholeday_sameday(self):\n         self.assertEqual(\n             dates_for_display(event),\n             {\n-                "start_date": u"Oct 12, 2000",\n+                "start_date": "Oct 12, 2000",\n                 "start_time": None,\n                 "start_iso": "2000-10-12",\n-                "end_date": u"Oct 12, 2000",\n+                "end_date": "Oct 12, 2000",\n                 "end_time": None,\n                 "end_iso": "2000-10-12",\n                 "same_day": True,\n@@ -1011,10 +1010,10 @@ def test_prep_display_wholeday_differentdays(self):\n         self.assertEqual(\n             dates_for_display(event),\n             {\n-                "start_date": u"Oct 12, 2000",\n+                "start_date": "Oct 12, 2000",\n                 "start_time": None,\n                 "start_iso": "2000-10-12",\n-                "end_date": u"Oct 13, 2000",\n+                "end_date": "Oct 13, 2000",\n                 "end_time": None,\n                 "end_iso": "2000-10-13",\n                 "same_day": False,\ndiff --git a/plone/app/event/tests/test_catalog.py b/plone/app/event/tests/test_catalog.py\nindex ceaa009c..540dabad 100644\n--- a/plone/app/event/tests/test_catalog.py\n+++ b/plone/app/event/tests/test_catalog.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.testing import PAEvent_INTEGRATION_TESTING\n from Products.CMFCore.utils import getToolByName\n \ndiff --git a/plone/app/event/tests/test_dx_behaviors.py b/plone/app/event/tests/test_dx_behaviors.py\nindex 228097cc..cc09544b 100644\n--- a/plone/app/event/tests/test_dx_behaviors.py\n+++ b/plone/app/event/tests/test_dx_behaviors.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import datetime\n from datetime import timedelta\n from DateTime import DateTime\n@@ -31,9 +30,9 @@\n from plone.event.interfaces import IOccurrence\n from plone.event.interfaces import IRecurrenceSupport\n from plone.uuid.interfaces import IUUID\n+from unittest import mock\n from zope.annotation.interfaces import IAnnotations\n \n-import mock\n import pytz\n import unittest\n import zope.interface\n@@ -256,7 +255,7 @@ def test_event_accessor(self):\n         e1 = createContentInContainer(\n             self.portal,\n             "plone.app.event.dx.event",\n-            title=u"event1",\n+            title="event1",\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             end=tz.localize(datetime(2011, 11, 11, 12, 0)),\n         )\n@@ -287,7 +286,7 @@ def test_event_accessor_whole_day__open_end(self):\n         e1 = createContentInContainer(\n             self.portal,\n             "plone.app.event.dx.event",\n-            title=u"event1",\n+            title="event1",\n             start=start,\n             end=end,\n         )\n@@ -315,7 +314,7 @@ def test_event_accessor__sync_uid(self):\n         self.request.set("HTTP_HOST", "nohost")\n \n         e1 = createContentInContainer(\n-            self.portal, "plone.app.event.dx.event", title=u"event1"\n+            self.portal, "plone.app.event.dx.event", title="event1"\n         )\n         acc = IEventAccessor(e1)\n \n@@ -339,7 +338,7 @@ def test_event_accessor__sync_uid(self):\n \n     def test_event_accessor__start_end(self):\n         e1 = createContentInContainer(\n-            self.portal, "plone.app.event.dx.event", title=u"event1"\n+            self.portal, "plone.app.event.dx.event", title="event1"\n         )\n \n         dt = datetime(2161, 1, 1)  # United Federation of Planets\n@@ -399,7 +398,7 @@ def test_start_end_dates_indexed(self):\n         e1 = createContentInContainer(\n             self.portal,\n             "plone.app.event.dx.event",\n-            title=u"event1",\n+            title="event1",\n             start=start,\n             end=end,\n         )\n@@ -416,7 +415,7 @@ def test_recurrence_indexing(self):\n         e1 = createContentInContainer(\n             self.portal,\n             "plone.app.event.dx.event",\n-            title=u"event1",\n+            title="event1",\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             end=tz.localize(datetime(2011, 11, 11, 12, 0)),\n         )\n@@ -555,13 +554,13 @@ class TestDXAnnotationStorageUpdate(unittest.TestCase):\n \n     layer = PAEventDX_INTEGRATION_TESTING\n \n-    location = u"K\xc3\xb6ln"\n-    attendees = (u"Peter", u"S\xc3\xb8ren", u"Madeleine")\n-    contact_email = u"person@email.com"\n-    contact_name = u"Peter Parker"\n-    contact_phone = u"555 123 456"\n-    event_url = u"http://my.event.url"\n-    text = u"<p>Cathedral Sprint in K\xc3\xb6ln</p>"\n+    location = "K\xc3\xb6ln"\n+    attendees = ("Peter", "S\xc3\xb8ren", "Madeleine")\n+    contact_email = "person@email.com"\n+    contact_name = "Peter Parker"\n+    contact_phone = "555 123 456"\n+    event_url = "http://my.event.url"\n+    text = "<p>Cathedral Sprint in K\xc3\xb6ln</p>"\n \n     def setUp(self):\n         self.portal = self.layer["portal"]\n@@ -574,7 +573,7 @@ def test_migrate_fields(self):\n         e1 = createContentInContainer(\n             self.portal,\n             "Event",\n-            title=u"event1",\n+            title="event1",\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             end=tz.localize(datetime(2011, 11, 11, 12, 0)),\n         )\n@@ -623,7 +622,7 @@ def test_no_overwrite(self):\n         e1 = createContentInContainer(\n             self.portal,\n             "Event",\n-            title=u"event1",\n+            title="event1",\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             end=tz.localize(datetime(2011, 11, 11, 12, 0)),\n         )\n@@ -631,25 +630,25 @@ def test_no_overwrite(self):\n         # Fill the field values into the annotation storage\n         ann = IAnnotations(e1)\n         ann["plone.app.event.dx.behaviors.IEventLocation.location"] = (\n-            self.location + u"X"\n+            self.location + "X"\n         )\n         ann[\n             "plone.app.event.dx.behaviors.IEventAttendees.attendees"\n-        ] = self.attendees + (u"Paula",)\n+        ] = self.attendees + ("Paula",)\n         ann["plone.app.event.dx.behaviors.IEventContact.contact_email"] = (\n-            self.contact_email + u"X"\n+            self.contact_email + "X"\n         )\n         ann["plone.app.event.dx.behaviors.IEventContact.contact_name"] = (\n-            self.contact_name + u"X"\n+            self.contact_name + "X"\n         )\n         ann["plone.app.event.dx.behaviors.IEventContact.contact_phone"] = (\n-            self.contact_phone + u"X"\n+            self.contact_phone + "X"\n         )\n         ann["plone.app.event.dx.behaviors.IEventContact.event_url"] = (\n-            self.event_url + u"X"\n+            self.event_url + "X"\n         )\n         ann["plone.app.event.dx.behaviors.IEventSummary.text"] = RichTextValue(\n-            raw=self.text + u"X"\n+            raw=self.text + "X"\n         )\n \n         # Add values into the fields in the new way\ndiff --git a/plone/app/event/tests/test_event_listing.py b/plone/app/event/tests/test_event_listing.py\nindex 406f03f9..9d024cd7 100644\n--- a/plone/app/event/tests/test_event_listing.py\n+++ b/plone/app/event/tests/test_event_listing.py\n@@ -1,11 +1,9 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.base import localized_today\n from plone.app.event.testing import make_fake_response\n from plone.app.event.testing import PAEventDX_INTEGRATION_TESTING\n from plone.app.event.tests.base_setup import AbstractSampleDataEvents\n from plone.app.event.tests.base_setup import patched_now as PN\n-\n-import mock\n+from unittest import mock\n \n \n class TestEventsListingPortal(AbstractSampleDataEvents):\n@@ -69,7 +67,7 @@ def _collection_batching_base(self):\n         environment with newly calculated results.\n         """\n         # plone.app.contenttypes ICollection type\n-        self.portal.invokeFactory("Collection", "col_test", title=u"Col")\n+        self.portal.invokeFactory("Collection", "col_test", title="Col")\n         collection = self.portal.col_test\n         collection.query = [\n             {\n@@ -108,7 +106,7 @@ def test_date_filtering(self):\n         """\n         # plone.app.contenttypes ICollection type\n         self.portal.invokeFactory(\n-            "Collection", "col_without_date_criterion", title=u"Col"\n+            "Collection", "col_without_date_criterion", title="Col"\n         )\n         collection = self.portal.col_without_date_criterion\n         collection.query = [\n@@ -129,7 +127,7 @@ def test_no_date_filtering(self):\n         end search criterias.\n         """\n         # plone.app.contenttypes ICollection type\n-        self.portal.invokeFactory("Collection", "col_with_date_criterion", title=u"Col")\n+        self.portal.invokeFactory("Collection", "col_with_date_criterion", title="Col")\n         collection = self.portal.col_with_date_criterion\n         collection.query = [\n             {\ndiff --git a/plone/app/event/tests/test_event_summary.py b/plone/app/event/tests/test_event_summary.py\nindex a353e81c..3a3a5587 100644\n--- a/plone/app/event/tests/test_event_summary.py\n+++ b/plone/app/event/tests/test_event_summary.py\n@@ -1,10 +1,8 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.dx.traverser import OccurrenceTraverser as OccTravDX\n from plone.app.event.testing import PAEventDX_INTEGRATION_TESTING\n from plone.app.event.tests.base_setup import AbstractSampleDataEvents\n from plone.app.event.tests.base_setup import patched_now as PN\n-\n-import mock\n+from unittest import mock\n \n \n class TestEventSummaryDX(AbstractSampleDataEvents):\ndiff --git a/plone/app/event/tests/test_event_view.py b/plone/app/event/tests/test_event_view.py\nindex eef581af..7b081cb6 100644\n--- a/plone/app/event/tests/test_event_view.py\n+++ b/plone/app/event/tests/test_event_view.py\n@@ -1,10 +1,8 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.dx.traverser import OccurrenceTraverser as OccTravDX\n from plone.app.event.testing import PAEventDX_FUNCTIONAL_TESTING\n from plone.app.event.tests.base_setup import AbstractSampleDataEvents\n from plone.app.event.tests.base_setup import patched_now as PN\n-\n-import mock\n+from unittest import mock\n \n \n class FunctionalTestEventViewDX(AbstractSampleDataEvents):\ndiff --git a/plone/app/event/tests/test_ical_import.py b/plone/app/event/tests/test_ical_import.py\nindex 3eab0d87..96567016 100644\n--- a/plone/app/event/tests/test_ical_import.py\n+++ b/plone/app/event/tests/test_ical_import.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.ical.importer import IcalendarImportSettingsFormView\n from plone.app.event.interfaces import IICalendarImportEnabled\n from plone.app.event.testing import PAEventDX_FUNCTIONAL_TESTING\ndiff --git a/plone/app/event/tests/test_icalendar.py b/plone/app/event/tests/test_icalendar.py\nindex 8e7ad5ab..ad3dabf6 100644\n--- a/plone/app/event/tests/test_icalendar.py\n+++ b/plone/app/event/tests/test_icalendar.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import datetime\n from plone.app.event import base\n from plone.app.event.dx.traverser import OccurrenceTraverser as OccTravDX\n@@ -45,8 +44,7 @@ def test_event_ical(self):\n         self.assertEqual(len(headers), 3)\n         self.assertEqual(headers["Content-Type"], "text/calendar")\n         self.assertTrue("Content-Length" in headers)\n-        if six.PY3:\n-            output = [i.decode("utf8") for i in output]\n+        output = [i.decode("utf8") for i in output]\n         icalstr = "".join(output)\n         self.checkOrder(\n             icalstr,\n@@ -97,8 +95,7 @@ def test_event_occurrence_ical(self):\n         self.assertEqual(len(headers), 3)\n         self.assertEqual(headers["Content-Type"], "text/calendar")\n         self.assertTrue("Content-Length" in headers)\n-        if six.PY3:\n-            output = [i.decode("utf8") for i in output]\n+        output = [i.decode("utf8") for i in output]\n         icalstr = "".join(output)\n         self.assertTrue("Now Event" in icalstr)\n         self.assertTrue("RRULE" not in icalstr)\n@@ -110,8 +107,7 @@ def test_portal_ical(self):\n         self.assertEqual(len(headers), 3)\n         self.assertEqual(headers["Content-Type"], "text/calendar")\n         self.assertTrue("Content-Length" in headers)\n-        if six.PY3:\n-            output = [i.decode("utf8") for i in output]\n+        output = [i.decode("utf8") for i in output]\n         icalstr = "".join(output)\n \n         # No occurrences in export. Otherwise count would be 8.\n@@ -199,8 +195,7 @@ def test_event_listing_ical_portal(self):\n         self.assertEqual(len(headers), 3)\n         self.assertEqual(headers["Content-Type"], "text/calendar")\n         self.assertTrue("Content-Length" in headers)\n-        if six.PY3:\n-            output = [i.decode("utf8") for i in output]\n+        output = [i.decode("utf8") for i in output]\n         icalstr = "".join(output)\n         # No occurrences in export. Otherwise count would be 8.\n         self.assertEqual(icalstr.count("BEGIN:VEVENT"), 4)\n@@ -218,8 +213,7 @@ def test_event_listing_ical_portal__specific_date(self):\n         self.assertEqual(len(headers), 3)\n         self.assertEqual(headers["Content-Type"], "text/calendar")\n         self.assertTrue("Content-Length" in headers)\n-        if six.PY3:\n-            output = [i.decode("utf8") for i in output]\n+        output = [i.decode("utf8") for i in output]\n         icalstr = "".join(output)\n         self.assertEqual(icalstr.count("BEGIN:VEVENT"), 2)\n         self.assertTrue("Past Event" in icalstr)\n@@ -233,8 +227,7 @@ def test_collection_ical(self):\n         self.assertEqual(len(headers), 3)\n         self.assertEqual(headers["Content-Type"], "text/calendar")\n         self.assertTrue("Content-Length" in headers)\n-        if six.PY3:\n-            output = [i.decode("utf8") for i in output]\n+        output = [i.decode("utf8") for i in output]\n         icalstr = "".join(output)\n         self.assertEqual(icalstr.count("BEGIN:VEVENT"), 4)\n \n@@ -255,8 +248,7 @@ def test_collection_all_ical(self):\n         self.assertEqual(len(headers), 3)\n         self.assertEqual(headers["Content-Type"], "text/calendar")\n         self.assertTrue("Content-Length" in headers)\n-        if six.PY3:\n-            output = [i.decode("utf8") for i in output]\n+        output = [i.decode("utf8") for i in output]\n         icalstr = "".join(output)\n         self.assertEqual(icalstr.count("BEGIN:VEVENT"), 4)\n \n@@ -298,7 +290,7 @@ def test_import_from_ics(self):\n         self.assertEqual(e1.open_end, False)\n         self.assertEqual(\n             e1.sync_uid,\n-            u"48f1a7ad64e847568d860cd092344970",\n+            "48f1a7ad64e847568d860cd092344970",\n         )\n \n         e2 = IEventAccessor(impfolder.e2)\n@@ -306,8 +298,8 @@ def test_import_from_ics(self):\n         self.assertEqual(e2.end, utc.localize(datetime(1996, 4, 1, 2, 0)))\n         self.assertEqual(\n             e2.recurrence,\n-            u"RRULE:FREQ=DAILY;COUNT=100\\nEXDATE:19960402T010000Z,"\n-            u"19960403T010000Z,19960404T010000Z",\n+            "RRULE:FREQ=DAILY;COUNT=100\\nEXDATE:19960402T010000Z,"\n+            "19960403T010000Z,19960404T010000Z",\n         )\n \n         e3 = IEventAccessor(impfolder.e3)\n@@ -315,9 +307,9 @@ def test_import_from_ics(self):\n         self.assertEqual(e3.end, at.localize(datetime(2012, 3, 27, 18, 0)))\n         self.assertEqual(\n             e3.recurrence,\n-            u"RRULE:FREQ=WEEKLY;UNTIL=20120703T080000Z;BYDAY=TU\\n"\n-            u"EXDATE:20120529T100000,20120403T100000,20120410T100000,"\n-            u"20120501T100000,20120417T100000",\n+            "RRULE:FREQ=WEEKLY;UNTIL=20120703T080000Z;BYDAY=TU\\n"\n+            "EXDATE:20120529T100000,20120403T100000,20120410T100000,"\n+            "20120501T100000,20120417T100000",\n         )\n \n         e4 = IEventAccessor(impfolder.e4)\ndiff --git a/plone/app/event/tests/test_portlet_calendar.py b/plone/app/event/tests/test_portlet_calendar.py\nindex 6e10d6c8..a5a8ada1 100644\n--- a/plone/app/event/tests/test_portlet_calendar.py\n+++ b/plone/app/event/tests/test_portlet_calendar.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from calendar import monthrange\n from datetime import datetime\n from datetime import timedelta\n@@ -128,11 +127,11 @@ def test_portlet_config(self):\n         end = start + timedelta(hours=1)\n \n         e1 = createContentInContainer(\n-            self.portal, PTYPE, title=u"e1", start=start, end=end\n+            self.portal, PTYPE, title="e1", start=start, end=end\n         )\n         self.portal.invokeFactory("Folder", "eventfolder")\n         createContentInContainer(\n-            self.portal.eventfolder, PTYPE, title=u"e2", start=start, end=end\n+            self.portal.eventfolder, PTYPE, title="e2", start=start, end=end\n         )\n         self.portal.portal_workflow.doActionFor(e1, "publish")\n \n@@ -188,7 +187,7 @@ def test_long_event(self):\n         end = start + timedelta(days=2)\n \n         e1 = createContentInContainer(\n-            self.portal, PTYPE, title=u"e1", start=start, end=end\n+            self.portal, PTYPE, title="e1", start=start, end=end\n         )\n         self.portal.portal_workflow.doActionFor(e1, "publish")\n \n@@ -211,7 +210,7 @@ def test_event_created_last_day_of_month_invalidate_cache(self):\n         start = tz.localize(datetime(year, month, day, 23, 0, 0))\n         end = tz.localize(datetime(year, month, day, 23, 30, 0))\n         # Event starts at 23:00 and ends at 23:30\n-        createContentInContainer(self.portal, PTYPE, title=u"e1", start=start, end=end)\n+        createContentInContainer(self.portal, PTYPE, title="e1", start=start, end=end)\n \n         # Try to render the calendar portlet again, it must be different Now\n         r = self.renderer(assignment=portlet_calendar.Assignment())\n@@ -220,13 +219,13 @@ def test_event_created_last_day_of_month_invalidate_cache(self):\n \n     def test_event_nonascii(self):\n         # test issue with non-ascii event title and location\n-        title = u"Pl\xc3\xb6n\xe2\x82\xac\xc2\xa2\xc3\xb6nf M\xc3\xbcnchen 2012"\n+        title = "Pl\xc3\xb6n\xe2\x82\xac\xc2\xa2\xc3\xb6nf M\xc3\xbcnchen 2012"\n \n         tz = pytz.timezone(TZNAME)\n         start = tz.localize(datetime.now())\n         end = start + timedelta(hours=1)\n         e1 = createContentInContainer(\n-            self.portal, PTYPE, title=title, start=start, end=end, location=u"M\xc3\xbcnchen"\n+            self.portal, PTYPE, title=title, start=start, end=end, location="M\xc3\xbcnchen"\n         )\n         self.wft.doActionFor(e1, "publish")\n         r = self.renderer(assignment=portlet_calendar.Assignment())\ndiff --git a/plone/app/event/tests/test_portlet_events.py b/plone/app/event/tests/test_portlet_events.py\nindex db7fbe8d..a2e0a8e6 100644\n--- a/plone/app/event/tests/test_portlet_events.py\n+++ b/plone/app/event/tests/test_portlet_events.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import timedelta\n from plone.app.event.base import localized_now\n from plone.app.event.portlets import portlet_events\n@@ -151,13 +150,13 @@ def test_portlet_event_renderer__get_events(self):\n         end = start + timedelta(hours=1)\n \n         e1 = createContentInContainer(\n-            self.portal, PTYPE, id="e1", title=u"e1", start=start, end=end\n+            self.portal, PTYPE, id="e1", title="e1", start=start, end=end\n         )\n         self.portal.portal_workflow.doActionFor(e1, "publish")\n \n         self.portal.invokeFactory("Folder", "eventfolder")\n         createContentInContainer(\n-            self.portal.eventfolder, PTYPE, id="e2", title=u"e2", start=start, end=end\n+            self.portal.eventfolder, PTYPE, id="e2", title="e2", start=start, end=end\n         )\n \n         r = self.renderer(\n@@ -209,7 +208,7 @@ def test_portlet_event_renderer__recurring(self):\n             self.portal,\n             PTYPE,\n             id="e1",\n-            title=u"Event 1",\n+            title="Event 1",\n             start=start,\n             recurrence="RRULE:FREQ=WEEKLY;COUNT=10",\n         )\n@@ -217,7 +216,7 @@ def test_portlet_event_renderer__recurring(self):\n             self.portal,\n             PTYPE,\n             id="e1",\n-            title=u"Event 1",\n+            title="Event 1",\n             start=start,\n             recurrence="RRULE:FREQ=DAILY;COUNT=3",\n         )\ndiff --git a/plone/app/event/tests/test_recurrence.py b/plone/app/event/tests/test_recurrence.py\nindex 86d2a9e2..e5dd875d 100644\n--- a/plone/app/event/tests/test_recurrence.py\n+++ b/plone/app/event/tests/test_recurrence.py\n@@ -1,5 +1,3 @@\n-# -*- coding: utf-8 -*-\n-from mock import Mock\n from OFS.SimpleItem import SimpleItem\n from plone.app.event.base import get_events\n from plone.app.event.base import RET_MODE_ACCESSORS\n@@ -22,12 +20,13 @@\n from plone.event.interfaces import IEventRecurrence\n from plone.event.interfaces import IOccurrence\n from plone.event.interfaces import IRecurrenceSupport\n+from unittest import mock\n+from unittest.mock import Mock\n from zope.annotation.interfaces import IAnnotations\n from zope.interface import alsoProvides\n from zope.publisher.interfaces.browser import IBrowserView\n \n import datetime\n-import mock\n import pytz\n import six\n import transaction\n@@ -109,9 +108,7 @@ def test_occurrence_accessor(self):\n     def test_traverse_occurrence(self):\n         transaction.commit()\n         browser = Browser(self.app)\n-        browser.addHeader(\n-            "Authorization", "Basic %s:%s" % (TEST_USER_ID, TEST_USER_PASSWORD)\n-        )\n+        browser.addHeader("Authorization", f"Basic {TEST_USER_ID}:{TEST_USER_PASSWORD}")\n         url = "/".join([self.now_event.absolute_url(), "2013-05-07"])\n         browser.open(url)\n         title = self.now_event.title\n@@ -146,20 +143,20 @@ def setUp(self):\n             self.portal,\n             "plone.app.event.dx.event",\n             id="daily",\n-            title=u"Daily Event",\n+            title="Daily Event",\n             start=now,\n             end=now + datetime.timedelta(hours=1),\n-            location=u"Vienna",\n+            location="Vienna",\n             recurrence="RRULE:FREQ=DAILY;COUNT=4",\n         )\n         self.interval = createContentInContainer(\n             self.portal,\n             "plone.app.event.dx.event",\n             id="interval",\n-            title=u"Interval Event",\n+            title="Interval Event",\n             start=yesterday,\n             end=yesterday + datetime.timedelta(hours=1),\n-            location=u"Halle",\n+            location="Halle",\n             recurrence="RRULE:FREQ=DAILY;INTERVAL=2;COUNT=5",\n         )\n \n@@ -183,8 +180,8 @@ def test_event_summary_occurrences(self):\n             self.portal,\n             "plone.app.event.dx.event",\n             id="many",\n-            title=u"Interval Event",\n-            location=u"Brisbane",\n+            title="Interval Event",\n+            location="Brisbane",\n             recurrence="RRULE:FREQ=DAILY;COUNT=1000",\n         )\n \ndiff --git a/plone/app/event/tests/test_search.py b/plone/app/event/tests/test_search.py\nindex f2cad31b..7fbf03d5 100644\n--- a/plone/app/event/tests/test_search.py\n+++ b/plone/app/event/tests/test_search.py\n@@ -1,9 +1,7 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.testing import PAEventDX_FUNCTIONAL_TESTING\n from plone.app.event.tests.base_setup import AbstractSampleDataEvents\n from plone.app.event.tests.base_setup import patched_now as PN\n-\n-import mock\n+from unittest import mock\n \n \n class FunctionalTestSearchEvent(AbstractSampleDataEvents):\n@@ -11,5 +9,5 @@ class FunctionalTestSearchEvent(AbstractSampleDataEvents):\n \n     @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_searchabletext(self):\n-        results = self.portal.portal_catalog(SearchableText=u"\xc3\x9cberraschung")\n+        results = self.portal.portal_catalog(SearchableText="\xc3\x9cberraschung")\n         self.assertTrue(len(results) == 1)\ndiff --git a/plone/app/event/upgrades/upgrades.py b/plone/app/event/upgrades/upgrades.py\nindex 1de64b3a..a716af57 100644\n--- a/plone/app/event/upgrades/upgrades.py\n+++ b/plone/app/event/upgrades/upgrades.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.dx.behaviors import IEventAttendees\n from plone.app.event.dx.behaviors import IEventContact\n from plone.app.event.dx.behaviors import IEventLocation\n@@ -48,19 +47,19 @@ def upgrade_attribute_storage(context):\n     query = {}\n     query["object_provides"] = IDXEvent.__identifier__\n     results = catalog(**query)\n-    log.info("There are {0} in total, stating migration...".format(len(results)))\n+    log.info(f"There are {len(results)} in total, stating migration...")\n     for result in results:\n         try:\n             event = result.getObject()\n         except:\n             log.warning(\n                 "Not possible to fetch event object from catalog result for "\n-                "item: {0}.".format(result.getPath())\n+                "item: {}.".format(result.getPath())\n             )\n             continue\n         if not IAnnotatable.providedBy(event):\n             log.warning(\n-                "The event at {0} does provide annotation capabilities, "\n+                "The event at {} does provide annotation capabilities, "\n                 "skipping.".format(event.absolute_url())\n             )\n             continue\n@@ -68,7 +67,7 @@ def upgrade_attribute_storage(context):\n         did_work = False\n         for behavior in BEHAVIOR_LIST:\n             for name in behavior.names():\n-                fullname = "{0}.{1}".format(behavior.__identifier__, name)\n+                fullname = f"{behavior.__identifier__}.{name}"\n                 oldvalue = annotations.get(fullname, None)\n                 # Only write the old value if there is no new value yet\n                 if oldvalue and not getattr(event, name, None):\n@@ -84,7 +83,7 @@ def upgrade_attribute_storage(context):\n             did_work = True\n         if did_work:\n             notify(ObjectModifiedEvent(event))\n-        log.debug("Handled event at {0}".format(event.absolute_url()))\n+        log.debug(f"Handled event at {event.absolute_url()}")\n \n \n def remove_event_listing_settings(context):\ndiff --git a/plone/app/event/vocabularies.py b/plone/app/event/vocabularies.py\nindex 0a1da887..d6975f75 100644\n--- a/plone/app/event/vocabularies.py\n+++ b/plone/app/event/vocabularies.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event import _\n from plone.app.event import base\n from zope.interface import provider\ndiff --git a/setup.py b/setup.py\nindex 0da276f0..c9308400 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n'

Repository: plone.app.event


Branch: refs/heads/master
Date: 2022-05-04T22:20:55+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.event/commit/969c4690eb50ef236846d3d9b31ccd1205fb66ad

remove six

Files changed:
M plone/app/event/base.py
M plone/app/event/ical/importer.py
M plone/app/event/portlets/__init__.py
M plone/app/event/tests/test_base_module.py
M plone/app/event/tests/test_icalendar.py
M plone/app/event/tests/test_recurrence.py
M setup.py

b'diff --git a/plone/app/event/base.py b/plone/app/event/base.py\nindex 5c317229..8e71ef8a 100644\n--- a/plone/app/event/base.py\n+++ b/plone/app/event/base.py\n@@ -33,7 +33,6 @@\n from zope.deprecation import deprecate\n \n import pytz\n-import six\n \n \n DEFAULT_END_DELTA = 1  # hours\n@@ -227,7 +226,7 @@ def filter_and_resort(context, brains, start, end, sort, sort_reverse):\n         _allends = sorted(idx["end"])\n         # assuming (start, end) pairs belong together\n         # assert(len(_allstarts) == len(_allends))\n-        _occ = six.moves.zip(_allstarts, _allends)\n+        _occ = zip(_allstarts, _allends)\n         if start:\n             _occ = [(s, e) for (s, e) in _occ if e >= _start]\n         if end:\ndiff --git a/plone/app/event/ical/importer.py b/plone/app/event/ical/importer.py\nindex 787ca8f3..286794df 100644\n--- a/plone/app/event/ical/importer.py\n+++ b/plone/app/event/ical/importer.py\n@@ -14,7 +14,6 @@\n from Products.CMFPlone.utils import safe_unicode\n from Products.Five.browser import BrowserView\n from Products.statusmessages.interfaces import IStatusMessage\n-from six.moves import urllib\n from z3c.form import button\n from z3c.form import field\n from z3c.form import form\n@@ -32,8 +31,8 @@\n import datetime\n import icalendar\n import random\n-import six\n import transaction\n+import urllib\n \n \n def ical_import(\n@@ -74,7 +73,7 @@ def _from_list(ical, prop):\n         for item in val:\n             ret = "%s," % ret if ret else ret  # insert linebreak\n             ical_val = item.to_ical()\n-            if six.PY3 and isinstance(ical_val, bytes):\n+            if isinstance(ical_val, bytes):\n                 ical_val = ical_val.decode("utf8")\n             ret = f"{ret}{ical_val}"\n         return f"{prop}:{ret}" if ret else None\n@@ -128,7 +127,7 @@ def _from_list(ical, prop):\n         rrule = _get_prop("RRULE", item)\n         rrule = rrule.to_ical() if rrule else ""\n         if rrule:\n-            if six.PY3 and isinstance(rrule, bytes):\n+            if isinstance(rrule, bytes):\n                 rrule = rrule.decode("utf8")\n             rrule = "RRULE:%s" % rrule\n         rdates = _from_list(item, "RDATE")\ndiff --git a/plone/app/event/portlets/__init__.py b/plone/app/event/portlets/__init__.py\nindex 50212c41..8d7e6559 100644\n--- a/plone/app/event/portlets/__init__.py\n+++ b/plone/app/event/portlets/__init__.py\n@@ -1,7 +1,6 @@\n from plone.app.event.base import find_navroot\n from plone.app.event.base import find_ploneroot\n \n-import six\n \n \n def get_calendar_url(context, search_base):\n@@ -11,8 +10,6 @@ def get_calendar_url(context, search_base):\n     calendar_url = None\n     if search_base:\n         portal = find_ploneroot(context)\n-        if six.PY2 and isinstance(search_base, str):\n-            search_base = search_base.encode("utf8")\n         search_base = "/".join(search_base.split("/")[2:])\n         calendar_url = portal.unrestrictedTraverse(\n             search_base.lstrip("/")  # start relative, first slash is omitted\ndiff --git a/plone/app/event/tests/test_base_module.py b/plone/app/event/tests/test_base_module.py\nindex 2e07cfd1..34395d33 100644\n--- a/plone/app/event/tests/test_base_module.py\n+++ b/plone/app/event/tests/test_base_module.py\n@@ -40,7 +40,6 @@\n from zope.interface import directlyProvides\n \n import pytz\n-import six\n import unittest\n \n \ndiff --git a/plone/app/event/tests/test_icalendar.py b/plone/app/event/tests/test_icalendar.py\nindex ad3dabf6..94aa840f 100644\n--- a/plone/app/event/tests/test_icalendar.py\n+++ b/plone/app/event/tests/test_icalendar.py\n@@ -13,7 +13,6 @@\n \n import os\n import pytz\n-import six\n import unittest\n \n \ndiff --git a/plone/app/event/tests/test_recurrence.py b/plone/app/event/tests/test_recurrence.py\nindex e5dd875d..e27befb8 100644\n--- a/plone/app/event/tests/test_recurrence.py\n+++ b/plone/app/event/tests/test_recurrence.py\n@@ -28,7 +28,6 @@\n \n import datetime\n import pytz\n-import six\n import transaction\n import unittest\n import zope.component\n@@ -112,8 +111,6 @@ def test_traverse_occurrence(self):\n         url = "/".join([self.now_event.absolute_url(), "2013-05-07"])\n         browser.open(url)\n         title = self.now_event.title\n-        if six.PY2:\n-            title = title.encode("ascii")\n         self.assertTrue(title in browser.contents)\n \n     def test_traverse_occurrence_imagescaling(self):\ndiff --git a/setup.py b/setup.py\nindex c9308400..6ed0624d 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -80,7 +80,6 @@\n         "plone.uuid",\n         "plone.z3cform",\n         "pytz",\n-        "six",\n         "transaction",\n         "z3c.form >= 3.2.1.dev0",\n         "zope.annotation",\n'

Repository: plone.app.event


Branch: refs/heads/master
Date: 2022-05-04T22:43:13+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.event/commit/7bb174cf56515052e9ce928652356729baa1173e

use plone.base and manual overhaul

Files changed:
M plone/app/event/base.py
M plone/app/event/browser/event_listing.py
M plone/app/event/configure.zcml
M plone/app/event/dx/behaviors.py
M plone/app/event/ical/importer.py
M plone/app/event/portlets/__init__.py
M plone/app/event/portlets/portlet_calendar.py
M plone/app/event/portlets/portlet_events.py
M plone/app/event/recurrence.py
M plone/app/event/setuphandlers.py
M plone/app/event/testing.py
M plone/app/event/tests/test_dx_behaviors.py
M plone/app/event/tests/test_ical_import.py
M plone/app/event/tests/test_recurrence.py
M setup.py

b'diff --git a/plone/app/event/base.py b/plone/app/event/base.py\nindex 8e71ef8a..91fef1be 100644\n--- a/plone/app/event/base.py\n+++ b/plone/app/event/base.py\n@@ -9,6 +9,9 @@\n from plone.app.event.interfaces import ISO_DATE_FORMAT\n from plone.app.layout.navigation.interfaces import INavigationRoot\n from plone.app.layout.navigation.root import getNavigationRootObject\n+from plone.base.i18nl10n import ulocalized_time as orig_ulocalized_time\n+from plone.base.interfaces.siteroot import IPloneSiteRoot\n+from plone.base.utils import safe_callable\n from plone.event.interfaces import IEvent\n from plone.event.interfaces import IEventAccessor\n from plone.event.interfaces import IEventRecurrence\n@@ -23,9 +26,6 @@\n from plone.event.utils import validated_timezone\n from plone.registry.interfaces import IRegistry\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.i18nl10n import ulocalized_time as orig_ulocalized_time\n-from Products.CMFPlone.interfaces.siteroot import IPloneSiteRoot\n-from Products.CMFPlone.utils import safe_callable\n from zope.annotation.interfaces import IAnnotations\n from zope.component import getUtility\n from zope.component.hooks import getSite\ndiff --git a/plone/app/event/browser/event_listing.py b/plone/app/event/browser/event_listing.py\nindex 5e4bcbe1..55c0f2e1 100644\n--- a/plone/app/event/browser/event_listing.py\n+++ b/plone/app/event/browser/event_listing.py\n@@ -1,6 +1,7 @@\n from calendar import monthrange\n from datetime import date\n from datetime import timedelta\n+from plone.app.contenttypes.behaviors.collection import ISyndicatableCollection\n from plone.app.event import _\n from plone.app.event.base import _prepare_range\n from plone.app.event.base import expand_events\n@@ -14,30 +15,15 @@\n from plone.app.event.base import start_end_query\n from plone.app.event.ical.exporter import construct_icalendar\n from plone.app.querystring import queryparser\n+from plone.base.batch import Batch\n+from plone.base.defaultpage import get_default_page\n from plone.memoize import view\n from plone.uuid.interfaces import IUUID\n-from Products.CMFPlone.PloneBatch import Batch\n from Products.Five.browser import BrowserView\n from zope.component import getMultiAdapter\n from zope.contentprovider.interfaces import IContentProvider\n \n \n-try:\n-    from Products.CMFPlone.defaultpage import get_default_page\n-except ImportError:\n-    # Plone 4\n-    from plone.app.layout.navigation.defaultpage import (\n-        getDefaultPage as get_default_page,\n-    )  # noqa\n-\n-try:\n-    from plone.app.contenttypes.behaviors.collection import (\n-        ISyndicatableCollection as ICollection,\n-    )  # noqa\n-except ImportError:\n-    ICollection = None\n-\n-\n class EventListing(BrowserView):\n     def __init__(self, context, request):\n         super().__init__(context, request)\n@@ -49,15 +35,17 @@ def __init__(self, context, request):\n         self.default_context = context[default] if default else context\n \n         self.is_collection = False\n-        if ICollection:\n-            self.is_collection = ICollection.providedBy(self.default_context)\n+        if ISyndicatableCollection:\n+            self.is_collection = ISyndicatableCollection.providedBy(\n+                self.default_context\n+            )\n \n         # Request parameter\n         req = self.request.form\n \n         b_size = int(req.get("b_size", 0))\n         if not b_size and self.is_collection:\n-            collection_behavior = ICollection(self.default_context)\n+            collection_behavior = ISyndicatableCollection(self.default_context)\n             b_size = getattr(collection_behavior, "item_count", 0)\n         self.b_size = b_size or 10\n         self.b_start = int(req.get("b_start", 0))\ndiff --git a/plone/app/event/configure.zcml b/plone/app/event/configure.zcml\nindex 42a0c532..64e995a1 100644\n--- a/plone/app/event/configure.zcml\n+++ b/plone/app/event/configure.zcml\n@@ -34,7 +34,7 @@\n       directory="profiles/default"\n       title="plone.app.event"\n       description="plone.app.event framework registration."\n-      for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+      for="plone.base.interfaces.IPloneSiteRoot"\n       provides="Products.GenericSetup.interfaces.EXTENSION"\n       />\n \n@@ -43,7 +43,7 @@\n       title="plone.app.event testing"\n       directory="profiles/testing"\n       description="Testing profile for plone.app.event"\n-      for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+      for="plone.base.interfaces.IPloneSiteRoot"\n       provides="Products.GenericSetup.interfaces.EXTENSION"\n       />\n \n@@ -58,6 +58,6 @@\n   <utility\n       factory=".setuphandlers.HiddenProfiles"\n       name="plone.app.event"\n-      provides="Products.CMFPlone.interfaces.INonInstallable" />\n+      provides="plone.base.interfaces.INonInstallable" />\n \n </configure>\ndiff --git a/plone/app/event/dx/behaviors.py b/plone/app/event/dx/behaviors.py\nindex 04ffa5fe..871c77ad 100644\n--- a/plone/app/event/dx/behaviors.py\n+++ b/plone/app/event/dx/behaviors.py\n@@ -18,6 +18,7 @@\n from plone.app.z3cform.widget import DatetimeFieldWidget\n from plone.autoform import directives\n from plone.autoform.interfaces import IFormFieldProvider\n+from plone.base.utils import safe_text\n from plone.event.interfaces import IEventAccessor\n from plone.event.interfaces import IRecurrenceSupport\n from plone.event.utils import pydt\n@@ -26,7 +27,6 @@\n from plone.indexer import indexer\n from plone.supermodel import model\n from plone.uuid.interfaces import IUUID\n-from Products.CMFPlone.utils import safe_unicode\n from z3c.form.browser.checkbox import SingleCheckBoxFieldWidget\n from z3c.form.browser.text import TextFieldWidget\n from z3c.form.browser.textlines import TextLinesFieldWidget\n@@ -319,7 +319,7 @@ def __getattr__(self, name):\n         if name in bm:  # adapt object with behavior and return the attribute\n             behavior = bm[name](self.context, None)\n             if behavior:\n-                return safe_unicode(getattr(behavior, name, None))\n+                return safe_text(getattr(behavior, name, None))\n         return None\n \n     def __setattr__(self, name, value):\n@@ -334,7 +334,7 @@ def __setattr__(self, name, value):\n             if name in bm:\n                 behavior = bm[name](self.context, None)\n                 if behavior:\n-                    setattr(behavior, name, safe_unicode(value))\n+                    setattr(behavior, name, safe_text(value))\n \n     def __delattr__(self, name):\n         bm = self._behavior_map\n@@ -351,7 +351,7 @@ def uid(self):\n \n     @property\n     def url(self):\n-        return safe_unicode(self.context.absolute_url())\n+        return safe_text(self.context.absolute_url())\n \n     @property\n     def created(self):\n@@ -437,19 +437,19 @@ def sync_uid(self):\n \n     @property\n     def title(self):\n-        return safe_unicode(getattr(self.context, "title", None))\n+        return safe_text(getattr(self.context, "title", None))\n \n     @title.setter\n     def title(self, value):\n-        self.context.title = safe_unicode(value)\n+        self.context.title = safe_text(value)\n \n     @property\n     def description(self):\n-        return safe_unicode(getattr(self.context, "description", None))\n+        return safe_text(getattr(self.context, "description", None))\n \n     @description.setter\n     def description(self, value):\n-        self.context.description = safe_unicode(value)\n+        self.context.description = safe_text(value)\n \n     @property\n     def last_modified(self):\n@@ -466,8 +466,8 @@ def text(self):\n         textvalue = getattr(self.context, "text", None)\n         if textvalue is None:\n             return ""\n-        return safe_unicode(textvalue.output_relative_to(self.context))\n+        return safe_text(textvalue.output_relative_to(self.context))\n \n     @text.setter\n     def text(self, value):\n-        self.context.text = RichTextValue(raw=safe_unicode(value))\n+        self.context.text = RichTextValue(raw=safe_text(value))\ndiff --git a/plone/app/event/ical/importer.py b/plone/app/event/ical/importer.py\nindex 286794df..022961c8 100644\n--- a/plone/app/event/ical/importer.py\n+++ b/plone/app/event/ical/importer.py\n@@ -2,6 +2,7 @@\n from plone.app.event import base\n from plone.app.event.base import AnnotationAdapter\n from plone.app.event.interfaces import IICalendarImportEnabled\n+from plone.base.utils import safe_text\n from plone.event.interfaces import IEventAccessor\n from plone.event.utils import date_to_datetime\n from plone.event.utils import is_date\n@@ -11,7 +12,6 @@\n from plone.namedfile.field import NamedFile\n from plone.z3cform.layout import FormWrapper\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.utils import safe_unicode\n from Products.Five.browser import BrowserView\n from Products.statusmessages.interfaces import IStatusMessage\n from z3c.form import button\n@@ -50,7 +50,7 @@ def _get_by_sync_uid(uid):\n     def _get_prop(prop, item, default=None):\n         ret = default\n         if prop in item:\n-            ret = safe_unicode(item.decoded(prop))\n+            ret = safe_text(item.decoded(prop))\n         return ret\n \n     def _from_list(ical, prop):\n@@ -141,7 +141,7 @@ def _from_list(ical, prop):\n         contact = _get_prop("CONTACT", item)\n         categories = item.get("CATEGORIES", ())\n         if getattr(categories, "__iter__", False):\n-            categories = tuple(safe_unicode(it) for it in categories)\n+            categories = tuple(safe_text(it) for it in categories)\n \n         ext_modified = utc(_get_prop("LAST-MODIFIED", item))\n \ndiff --git a/plone/app/event/portlets/__init__.py b/plone/app/event/portlets/__init__.py\nindex 8d7e6559..983ba273 100644\n--- a/plone/app/event/portlets/__init__.py\n+++ b/plone/app/event/portlets/__init__.py\n@@ -2,7 +2,6 @@\n from plone.app.event.base import find_ploneroot\n \n \n-\n def get_calendar_url(context, search_base):\n     # search_base is always from the portal_root object. We won\'t include\n     # the path from the portal root object, so we traverse to the calendar\ndiff --git a/plone/app/event/portlets/portlet_calendar.py b/plone/app/event/portlets/portlet_calendar.py\nindex f6efe6df..cfd4d21d 100644\n--- a/plone/app/event/portlets/portlet_calendar.py\n+++ b/plone/app/event/portlets/portlet_calendar.py\n@@ -1,5 +1,7 @@\n from Acquisition import aq_inner\n from ComputedAttribute import ComputedAttribute\n+from plone.app.contenttypes.behaviors.collection import ISyndicatableCollection\n+from plone.app.contenttypes.interfaces import IFolder\n from plone.app.event import _\n from plone.app.event.base import _prepare_range\n from plone.app.event.base import construct_calendar\n@@ -29,21 +31,12 @@\n import json\n \n \n-try:\n-    from plone.app.contenttypes.behaviors.collection import (\n-        ISyndicatableCollection as ICollection,\n-    )  # noqa\n-    from plone.app.contenttypes.interfaces import IFolder\n-\n-    search_base_uid_source = CatalogSource(\n-        object_provides={\n-            "query": [ICollection.__identifier__, IFolder.__identifier__],\n-            "operator": "or",\n-        }\n-    )\n-except ImportError:\n-    search_base_uid_source = CatalogSource(is_folderish=True)\n-    ICollection = None\n+search_base_uid_source = CatalogSource(\n+    object_provides={\n+        "query": [ISyndicatableCollection.__identifier__, IFolder.__identifier__],\n+        "operator": "or",\n+    }\n+)\n \n PLMF = MessageFactory("plonelocales")\n \n@@ -207,7 +200,9 @@ def cal_data(self):\n \n         events = []\n         query.update(self.request.get("contentFilter", {}))\n-        if ICollection and ICollection.providedBy(self.search_base):\n+        if ISyndicatableCollection and ISyndicatableCollection.providedBy(\n+            self.search_base\n+        ):\n             # Whatever sorting is defined, we\'re overriding it.\n             query = queryparser.parseFormquery(\n                 self.search_base,\ndiff --git a/plone/app/event/portlets/portlet_events.py b/plone/app/event/portlets/portlet_events.py\nindex 4c394bb6..ed7f3bf6 100644\n--- a/plone/app/event/portlets/portlet_events.py\n+++ b/plone/app/event/portlets/portlet_events.py\n@@ -8,15 +8,15 @@\n from plone.app.event.base import RET_MODE_ACCESSORS\n from plone.app.event.base import start_end_query\n from plone.app.event.portlets import get_calendar_url\n-from plone.app.event.portlets.portlet_calendar import ICollection\n+from plone.app.event.portlets.portlet_calendar import ISyndicatableCollection\n from plone.app.event.portlets.portlet_calendar import search_base_uid_source\n from plone.app.portlets.portlets import base\n from plone.app.querystring import queryparser\n from plone.app.uuid.utils import uuidToObject\n+from plone.base.interfaces.controlpanel import ISiteSchema\n from plone.memoize.compress import xhtml_compress\n from plone.portlets.interfaces import IPortletDataProvider\n from plone.registry.interfaces import IRegistry\n-from Products.CMFPlone.interfaces.controlpanel import ISiteSchema\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n from zExceptions import NotFound\n from zope import schema\n@@ -158,7 +158,7 @@ def events(self):\n \n         events = []\n         query.update(self.request.get("contentFilter", {}))\n-        if ICollection and ICollection.providedBy(self.search_base):\n+        if ISyndicatableCollection.providedBy(self.search_base):\n             # Whatever sorting is defined, we\'re overriding it.\n             query = queryparser.parseFormquery(\n                 self.search_base,\ndiff --git a/plone/app/event/recurrence.py b/plone/app/event/recurrence.py\nindex f27a1260..d6bfc216 100644\n--- a/plone/app/event/recurrence.py\n+++ b/plone/app/event/recurrence.py\n@@ -2,6 +2,7 @@\n from OFS.SimpleItem import SimpleItem\n from plone.app.event.base import dt_start_of_day\n from plone.app.event.base import guess_date_from\n+from plone.base.utils import safe_text\n from plone.event.interfaces import IEventAccessor\n from plone.event.interfaces import IEventRecurrence\n from plone.event.interfaces import IOccurrence\n@@ -11,21 +12,15 @@\n from plone.event.utils import pydt\n from plone.namedfile.interfaces import IImageScaleTraversable\n from plone.namedfile.scaling import ImageScaling\n-from Products.CMFPlone.utils import safe_unicode\n from Products.Five.browser import BrowserView\n from zope.component import adapter\n from zope.interface import implementer\n from zope.publisher.interfaces.browser import IBrowserRequest\n+from ZPublisher.BaseRequest import DefaultPublishTraverse\n \n import datetime\n \n \n-try:\n-    from repoze.zope2.publishtraverse import DefaultPublishTraverse\n-except ImportError:\n-    from ZPublisher.BaseRequest import DefaultPublishTraverse\n-\n-\n @adapter(IEventRecurrence)\n @implementer(IRecurrenceSupport)\n class RecurrenceSupport:\n@@ -174,7 +169,7 @@ def __delattr__(self, name):\n \n     @property\n     def url(self):\n-        return safe_unicode(self.context.absolute_url())\n+        return safe_text(self.context.absolute_url())\n \n \n class ImageScalingViewFactory(BrowserView):\ndiff --git a/plone/app/event/setuphandlers.py b/plone/app/event/setuphandlers.py\nindex 4923bacf..fffa1468 100644\n--- a/plone/app/event/setuphandlers.py\n+++ b/plone/app/event/setuphandlers.py\n@@ -1,5 +1,5 @@\n+from plone.base.interfaces import INonInstallable\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.interfaces import INonInstallable\n from Products.ZCatalog.Catalog import CatalogError\n from zope.interface import implementer\n \ndiff --git a/plone/app/event/testing.py b/plone/app/event/testing.py\nindex 171f58c1..a0a1e438 100644\n--- a/plone/app/event/testing.py\n+++ b/plone/app/event/testing.py\n@@ -5,24 +5,15 @@\n from plone.app.testing import PLONE_FIXTURE\n from plone.app.testing import PloneSandboxLayer\n from plone.registry.interfaces import IRegistry\n+from plone.testing.zope import installProduct\n+from plone.testing.zope import uninstallProduct\n+from plone.testing.zope import WSGI_SERVER_FIXTURE\n from zope.component import getUtility\n from zope.interface import alsoProvides\n \n import os\n \n \n-try:\n-    # plone.testing 7+, Plone 5.2+\n-    from plone.testing.zope import installProduct\n-    from plone.testing.zope import uninstallProduct\n-    from plone.testing.zope import WSGI_SERVER_FIXTURE\n-except ImportError:\n-    # plone.testing 6-, Plone 5.1\n-    from plone.testing.z2 import installProduct\n-    from plone.testing.z2 import uninstallProduct\n-    from plone.testing.z2 import ZSERVER_FIXTURE as WSGI_SERVER_FIXTURE\n-\n-\n def set_browserlayer(request):\n     """Set the BrowserLayer for the request.\n \ndiff --git a/plone/app/event/tests/test_dx_behaviors.py b/plone/app/event/tests/test_dx_behaviors.py\nindex cc09544b..9e0fcaf4 100644\n--- a/plone/app/event/tests/test_dx_behaviors.py\n+++ b/plone/app/event/tests/test_dx_behaviors.py\n@@ -29,6 +29,7 @@\n from plone.event.interfaces import IEventAccessor\n from plone.event.interfaces import IOccurrence\n from plone.event.interfaces import IRecurrenceSupport\n+from plone.testing.zope import Browser\n from plone.uuid.interfaces import IUUID\n from unittest import mock\n from zope.annotation.interfaces import IAnnotations\n@@ -38,14 +39,6 @@\n import zope.interface\n \n \n-try:\n-    # plone.testing 7+\n-    from plone.testing.zope import Browser\n-except ImportError:\n-    # plone.testing 6-\n-    from plone.testing.z2 import Browser\n-\n-\n TEST_TIMEZONE = "Europe/Vienna"\n \n \ndiff --git a/plone/app/event/tests/test_ical_import.py b/plone/app/event/tests/test_ical_import.py\nindex 96567016..05e0beb8 100644\n--- a/plone/app/event/tests/test_ical_import.py\n+++ b/plone/app/event/tests/test_ical_import.py\n@@ -5,19 +5,12 @@\n from plone.app.testing import SITE_OWNER_NAME\n from plone.app.testing import SITE_OWNER_PASSWORD\n from plone.app.testing import TEST_USER_ID\n+from plone.testing.zope import Browser\n \n import transaction\n import unittest\n \n \n-try:\n-    # plone.testing 7+\n-    from plone.testing.zope import Browser\n-except ImportError:\n-    # plone.testing 6-\n-    from plone.testing.z2 import Browser\n-\n-\n class TestICALImportSettings(unittest.TestCase):\n \n     layer = PAEventDX_FUNCTIONAL_TESTING\ndiff --git a/plone/app/event/tests/test_recurrence.py b/plone/app/event/tests/test_recurrence.py\nindex e27befb8..eedc5a88 100644\n--- a/plone/app/event/tests/test_recurrence.py\n+++ b/plone/app/event/tests/test_recurrence.py\n@@ -20,6 +20,7 @@\n from plone.event.interfaces import IEventRecurrence\n from plone.event.interfaces import IOccurrence\n from plone.event.interfaces import IRecurrenceSupport\n+from plone.testing.zope import Browser\n from unittest import mock\n from unittest.mock import Mock\n from zope.annotation.interfaces import IAnnotations\n@@ -33,14 +34,6 @@\n import zope.component\n \n \n-try:\n-    # plone.testing 7+\n-    from plone.testing.zope import Browser\n-except ImportError:\n-    # plone.testing 6-\n-    from plone.testing.z2 import Browser\n-\n-\n TZNAME = "Europe/Vienna"\n \n \ndiff --git a/setup.py b/setup.py\nindex 6ed0624d..afdeb8af 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -43,16 +43,9 @@\n     zip_safe=False,\n     install_requires=[\n         "setuptools",\n-        # -*- Extra requirements: -*-\n-        "Acquisition",\n-        "DateTime",\n-        "Products.CMFCore",\n-        "Products.CMFPlone",\n+        "plone.base",\n         "Products.DateRecurringIndex",\n-        "Products.GenericSetup",\n-        "Products.ZCatalog",\n         "Products.statusmessages",\n-        "Zope2",\n         "icalendar",  # >4.0.2\n         "plone.app.contentlisting",\n         "plone.app.dexterity",\n@@ -80,34 +73,14 @@\n         "plone.uuid",\n         "plone.z3cform",\n         "pytz",\n-        "transaction",\n         "z3c.form >= 3.2.1.dev0",\n-        "zope.annotation",\n-        "zope.component",\n-        "zope.container",\n-        "zope.contentprovider",\n-        "zope.event",\n         "zope.globalrequest",\n-        "zope.i18n",\n-        "zope.i18nmessageid",\n-        "zope.interface",\n-        "zope.lifecycleevent",\n-        "zope.publisher",\n-        "zope.schema",\n     ],\n     extras_require={\n-        "dexterity": [],  # BBB, remove with next version\n         "test": [\n-            "icalendar >= 3.10",  # otherwise minor test failure\n-            "mock",\n-            "plone.app.contenttypes >= 1.2a3",\n             "plone.app.robotframework",\n             "plone.app.testing [robot]",\n-            "plone.testing",\n             "robotsuite",\n-            "transaction",\n-            "zExceptions",\n-            "zope.event",\n         ],\n     },\n     entry_points="""\n'

Repository: plone.app.event


Branch: refs/heads/master
Date: 2022-05-04T22:50:07+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.event/commit/d7c049ae108a49fd198b12aacb9a8cc0eea53e60

reduce deprecation messages

Files changed:
M plone/app/event/tests/test_event_listing.py

b'diff --git a/plone/app/event/tests/test_event_listing.py b/plone/app/event/tests/test_event_listing.py\nindex 9d024cd7..b40a5bb2 100644\n--- a/plone/app/event/tests/test_event_listing.py\n+++ b/plone/app/event/tests/test_event_listing.py\n@@ -83,7 +83,7 @@ def test_collection_batching__all(self):\n         """Don\'t limit the results."""\n         collection = self._collection_batching_base()\n         view = collection.restrictedTraverse("@@event_listing")\n-        self.assertEqual(len(view.events(batch=True)), 8)\n+        self.assertEqual(view.events(batch=True).length, 8)\n \n     def test_collection_batching__reduce_by_collection_setting(self):\n         """Limit the results by setting item_count on the collection."""\n@@ -91,14 +91,14 @@ def test_collection_batching__reduce_by_collection_setting(self):\n         view = collection.restrictedTraverse("@@event_listing")\n         collection.item_count = 4\n         view = collection.restrictedTraverse("@@event_listing")\n-        self.assertEqual(len(view.events(batch=True)), 4)\n+        self.assertEqual(view.events(batch=True).length, 4)\n \n     def test_collection_batching__reduce_by_request_parameter(self):\n         """Limit the results by using a request parameter."""\n         collection = self._collection_batching_base()\n         self.request.form.update({"b_size": 2})\n         view = collection.restrictedTraverse("@@event_listing")\n-        self.assertEqual(len(view.events(batch=True)), 2)\n+        self.assertEqual(view.events(batch=True).length, 2)\n \n     def test_date_filtering(self):\n         """Test if date filters are available on Collections without start or\n'

Repository: plone.app.event


Branch: refs/heads/master
Date: 2022-05-04T22:52:49+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.event/commit/d275b41f59a6d646e7927a2661ab3fc57aca6f36

add newsfile

Files changed:
A news/356.breaking

b'diff --git a/news/356.breaking b/news/356.breaking\nnew file mode 100644\nindex 00000000..7336636d\n--- /dev/null\n+++ b/news/356.breaking\n@@ -0,0 +1,2 @@\n+Code Style, pyupgrade, remove six, use plone.base, some overhaul.\n+[jensens] \n'

Repository: plone.app.event


Branch: refs/heads/master
Date: 2022-05-15T09:27:13+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.event/commit/4b634dadd6518d19773910b86c6f5b14bbdd9cf8

Merge branch 'plone.base-overhaul'

Files changed:
A news/356.breaking
M docs/conf.py
M plone/__init__.py
M plone/app/__init__.py
M plone/app/event/__init__.py
M plone/app/event/base.py
M plone/app/event/browser/__init__.py
M plone/app/event/browser/event_listing.py
M plone/app/event/browser/event_summary.py
M plone/app/event/browser/event_view.py
M plone/app/event/browser/formatted_date.py
M plone/app/event/browser/leadimage_viewlet.py
M plone/app/event/configure.zcml
M plone/app/event/dx/__init__.py
M plone/app/event/dx/behaviors.py
M plone/app/event/dx/interfaces.py
M plone/app/event/dx/traverser.py
M plone/app/event/ical/__init__.py
M plone/app/event/ical/exporter.py
M plone/app/event/ical/importer.py
M plone/app/event/interfaces.py
M plone/app/event/portlets/__init__.py
M plone/app/event/portlets/portlet_calendar.py
M plone/app/event/portlets/portlet_events.py
M plone/app/event/recurrence.py
M plone/app/event/setuphandlers.py
M plone/app/event/testing.py
M plone/app/event/tests/INACTIVE_test_robot.py
M plone/app/event/tests/__init__.py
M plone/app/event/tests/base_setup.py
M plone/app/event/tests/robot/variables.py
M plone/app/event/tests/test_base_module.py
M plone/app/event/tests/test_catalog.py
M plone/app/event/tests/test_dx_behaviors.py
M plone/app/event/tests/test_event_listing.py
M plone/app/event/tests/test_event_summary.py
M plone/app/event/tests/test_event_view.py
M plone/app/event/tests/test_ical_import.py
M plone/app/event/tests/test_icalendar.py
M plone/app/event/tests/test_portlet_calendar.py
M plone/app/event/tests/test_portlet_events.py
M plone/app/event/tests/test_recurrence.py
M plone/app/event/tests/test_search.py
M plone/app/event/upgrades/upgrades.py
M plone/app/event/vocabularies.py
M setup.cfg
M setup.py

b'diff --git a/docs/conf.py b/docs/conf.py\nindex 6d4ab972f..754e531f5 100644\n--- a/docs/conf.py\n+++ b/docs/conf.py\n@@ -1,18 +1,20 @@\n # sphinx configuration\n \n-project = u\'plone.app.event\'\n-copyright = u\'2012, Plone Foundation\'\n+project = "plone.app.event"\n+copyright = "2012, Plone Foundation"\n \n extensions = [\n-    \'sphinx.ext.doctest\',\n-    \'sphinx.ext.coverage\',\n-    \'sphinx.ext.autodoc\',\n-    \'sphinx.ext.viewcode\',\n-    \'sphinx.ext.autosummary\',\n+    "sphinx.ext.doctest",\n+    "sphinx.ext.coverage",\n+    "sphinx.ext.autodoc",\n+    "sphinx.ext.viewcode",\n+    "sphinx.ext.autosummary",\n ]\n-master_doc = \'index\'\n+master_doc = "index"\n \n-language = \'en\'\n+language = "en"\n \n from pkg_resources import get_distribution\n+\n+\n version = release = get_distribution(project).version\ndiff --git a/news/356.breaking b/news/356.breaking\nnew file mode 100644\nindex 000000000..7336636d2\n--- /dev/null\n+++ b/news/356.breaking\n@@ -0,0 +1,2 @@\n+Code Style, pyupgrade, remove six, use plone.base, some overhaul.\n+[jensens] \ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af45..5284146eb 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 68c04af45..5284146eb 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/event/__init__.py b/plone/app/event/__init__.py\nindex aa11903e4..bac87e2cf 100644\n--- a/plone/app/event/__init__.py\n+++ b/plone/app/event/__init__.py\n@@ -1,14 +1,18 @@\n-# -*- coding: utf-8 -*-\n from AccessControl.Permission import addPermission\n from zope.i18nmessageid import MessageFactory\n \n+\n packageName = __name__\n-_ = MessageFactory(\'plone\')\n+_ = MessageFactory("plone")\n \n # BBB Permissions\n-PORTAL_ADD_PERMISSION = \'Add portal events\'  # CMFCalendar/ATCT permissions\n+PORTAL_ADD_PERMISSION = "Add portal events"  # CMFCalendar/ATCT permissions\n \n addPermission(\n     PORTAL_ADD_PERMISSION,\n-    (\'Manager\', \'Site Administrator\', \'Owner\',)\n+    (\n+        "Manager",\n+        "Site Administrator",\n+        "Owner",\n+    ),\n )\ndiff --git a/plone/app/event/base.py b/plone/app/event/base.py\nindex e21e7bc90..91fef1be1 100644\n--- a/plone/app/event/base.py\n+++ b/plone/app/event/base.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n from calendar import monthrange\n@@ -10,6 +9,9 @@\n from plone.app.event.interfaces import ISO_DATE_FORMAT\n from plone.app.layout.navigation.interfaces import INavigationRoot\n from plone.app.layout.navigation.root import getNavigationRootObject\n+from plone.base.i18nl10n import ulocalized_time as orig_ulocalized_time\n+from plone.base.interfaces.siteroot import IPloneSiteRoot\n+from plone.base.utils import safe_callable\n from plone.event.interfaces import IEvent\n from plone.event.interfaces import IEventAccessor\n from plone.event.interfaces import IEventRecurrence\n@@ -24,9 +26,6 @@\n from plone.event.utils import validated_timezone\n from plone.registry.interfaces import IRegistry\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.i18nl10n import ulocalized_time as orig_ulocalized_time\n-from Products.CMFPlone.interfaces.siteroot import IPloneSiteRoot\n-from Products.CMFPlone.utils import safe_callable\n from zope.annotation.interfaces import IAnnotations\n from zope.component import getUtility\n from zope.component.hooks import getSite\n@@ -34,11 +33,10 @@\n from zope.deprecation import deprecate\n \n import pytz\n-import six\n \n \n DEFAULT_END_DELTA = 1  # hours\n-FALLBACK_TIMEZONE = \'UTC\'\n+FALLBACK_TIMEZONE = "UTC"\n \n # Sync strategies\n SYNC_NONE = 0\n@@ -58,18 +56,27 @@\n # TODO: do we need this at all or shouldn\'t we just fail with ambiguous\n #       timezones?\n replacement_zones = {\n-    \'CET\': \'Europe/Vienna\',    # Central European Time\n-    \'MET\': \'Europe/Vienna\',    # Middle European Time\n-    \'EET\': \'Europe/Helsinki\',  # East European Time\n-    \'WET\': \'Europe/Lisbon\',    # West European Time\n+    "CET": "Europe/Vienna",  # Central European Time\n+    "MET": "Europe/Vienna",  # Middle European Time\n+    "EET": "Europe/Helsinki",  # East European Time\n+    "WET": "Europe/Lisbon",  # West European Time\n }\n \n \n # RETRIEVE EVENTS\n \n-def get_events(context, start=None, end=None, limit=None,\n-               ret_mode=RET_MODE_BRAINS, expand=False,\n-               sort=\'start\', sort_reverse=False, **kw):\n+\n+def get_events(\n+    context,\n+    start=None,\n+    end=None,\n+    limit=None,\n+    ret_mode=RET_MODE_BRAINS,\n+    expand=False,\n+    sort="start",\n+    sort_reverse=False,\n+    **kw,\n+):\n     """Return all events as catalog brains, possibly within a given\n     timeframe.\n \n@@ -115,40 +122,38 @@ def get_events(context, start=None, end=None, limit=None,\n     start, end = _prepare_range(context, start, end)\n \n     query = {}\n-    query[\'object_provides\'] = IEvent.__identifier__\n+    query["object_provides"] = IEvent.__identifier__\n \n     query.update(start_end_query(start, end))\n \n-    if \'path\' not in kw:\n+    if "path" not in kw:\n         # limit to the current navigation root, usually (not always) site\n         portal = getSite()\n         navroot = getNavigationRootObject(context, portal)\n-        query[\'path\'] = \'/\'.join(navroot.getPhysicalPath())\n+        query["path"] = "/".join(navroot.getPhysicalPath())\n     else:\n-        query[\'path\'] = kw[\'path\']\n+        query["path"] = kw["path"]\n \n     # Sorting\n     # In expand mode we sort after calculation of recurrences again. But we\n     # need to leave this sorting here in place, since no sort definition could\n     # lead to arbitrary results when limiting with sort_limit.\n-    query[\'sort_on\'] = sort\n+    query["sort_on"] = sort\n     if sort_reverse:\n-        query[\'sort_order\'] = \'reverse\'\n+        query["sort_order"] = "reverse"\n \n     # cannot limit before resorting or expansion, see below\n \n     query.update(kw)\n \n-    cat = getToolByName(context, \'portal_catalog\')\n+    cat = getToolByName(context, "portal_catalog")\n     result = cat(**query)\n \n     # unfiltered catalog results are already sorted correctly on brain.start\n     # filtering on start/end requires a resort, see docstring below and\n     # p.a.event.tests.test_base_module.TestGetEventsDX.test_get_event_sort\n-    if sort in (\'start\', \'end\'):\n-        result = filter_and_resort(context, result,\n-                                   start, end,\n-                                   sort, sort_reverse)\n+    if sort in ("start", "end"):\n+        result = filter_and_resort(context, result, start, end, sort, sort_reverse)\n \n         # Limiting a start/end-sorted result set is possible here\n         # and provides an important optimization BEFORE costly expansion\n@@ -159,8 +164,7 @@ def get_events(context, start=None, end=None, limit=None,\n         if expand is False:\n             result = [_obj_or_acc(it.getObject(), ret_mode) for it in result]\n         else:\n-            result = expand_events(result, ret_mode, start, end, sort,\n-                                   sort_reverse)\n+            result = expand_events(result, ret_mode, start, end, sort, sort_reverse)\n \n     # Limiting a non-start-sorted result set can only happen here\n     if limit:\n@@ -212,28 +216,28 @@ def filter_and_resort(context, brains, start, end, sort, sort_reverse):\n     """\n     _start = dt2int(start)  # index contains longint sets\n     _end = dt2int(end)\n-    catalog = getToolByName(context, \'portal_catalog\')\n+    catalog = getToolByName(context, "portal_catalog")\n     items = []  # (start:int, occurrence:brain) pairs\n     for brain in brains:\n         # brain.start metadata reflects first occurrence.\n         # instead, get all occurrence start/end from raw index\n         idx = catalog.getIndexDataForRID(brain.getRID())\n-        _allstarts = sorted(idx[\'start\'])\n-        _allends = sorted(idx[\'end\'])\n+        _allstarts = sorted(idx["start"])\n+        _allends = sorted(idx["end"])\n         # assuming (start, end) pairs belong together\n         # assert(len(_allstarts) == len(_allends))\n-        _occ = six.moves.zip(_allstarts, _allends)\n+        _occ = zip(_allstarts, _allends)\n         if start:\n             _occ = [(s, e) for (s, e) in _occ if e >= _start]\n         if end:\n             _occ = [(s, e) for (s, e) in _occ if s <= _end]\n         if not _occ:\n             continue\n-        if sort == \'start\':\n+        if sort == "start":\n             # first start can be before filter window if end is in window\n-            _first = min([s for (s, e) in _occ])\n-        elif sort == \'end\':\n-            _first = min([e for (s, e) in _occ])\n+            _first = min(s for (s, e) in _occ)\n+        elif sort == "end":\n+            _first = min(e for (s, e) in _occ)\n         items.append((_first, brain))  # key on next start/end\n \n     # sort brains by next start, discard sort key\n@@ -243,9 +247,7 @@ def filter_and_resort(context, brains, start, end, sort, sort_reverse):\n     return data\n \n \n-def expand_events(events, ret_mode,\n-                  start=None, end=None,\n-                  sort=None, sort_reverse=None):\n+def expand_events(events, ret_mode, start=None, end=None, sort=None, sort_reverse=None):\n     """Expand to the recurrence occurrences of a given set of events.\n \n     :param events: IEvent based objects or IEventAccessor object wrapper.\n@@ -273,11 +275,11 @@ def expand_events(events, ret_mode,\n     :param sort_reverse: Change the order of the sorting.\n     :type sort_reverse: boolean\n     """\n-    assert(ret_mode is not RET_MODE_BRAINS)\n+    assert ret_mode is not RET_MODE_BRAINS\n \n     exp_result = []\n     for it in events:\n-        obj = it.getObject() if getattr(it, \'getObject\', False) else it\n+        obj = it.getObject() if getattr(it, "getObject", False) else it\n         if IEventRecurrence.providedBy(obj):\n \n             occ_list = list(IRecurrenceSupport(obj).occurrences(start, end))\n@@ -304,7 +306,7 @@ def _obj_or_acc(obj, ret_mode):\n     ret_mode. ret_mode 2 returns objects, ret_mode 3 returns IEventAccessor\n     object wrapper. ret_mode 1 is not supported.\n     """\n-    assert(ret_mode is not RET_MODE_BRAINS)\n+    assert ret_mode is not RET_MODE_BRAINS\n     if ret_mode == RET_MODE_OBJECTS:\n         return obj\n     elif ret_mode == RET_MODE_ACCESSORS:\n@@ -412,22 +414,22 @@ def _prepare_range(context, start, end):\n \n \n def start_end_query(start, end):\n-    """Make a catalog query out of start and end dates.\n-    """\n+    """Make a catalog query out of start and end dates."""\n     query = {}\n     if start:\n         # All events from start date ongoing:\n         # The minimum end date of events is the date from which we search.\n-        query[\'end\'] = {\'query\': start, \'range\': \'min\'}\n+        query["end"] = {"query": start, "range": "min"}\n     if end:\n         # All events until end date:\n         # The maximum start date must be the date until we search.\n-        query[\'start\'] = {\'query\': end, \'range\': \'max\'}\n+        query["start"] = {"query": end, "range": "max"}\n     return query\n \n \n # TIMEZONE HANDLING\n \n+\n def default_timezone(context=None, as_tzinfo=False):\n     """Return the timezone from the portal or user.\n \n@@ -445,15 +447,15 @@ def default_timezone(context=None, as_tzinfo=False):\n     if not context:\n         context = getSite()\n \n-    membership = getToolByName(context, \'portal_membership\', None)\n+    membership = getToolByName(context, "portal_membership", None)\n     if membership and not membership.isAnonymousUser():  # user not logged in\n         member = membership.getAuthenticatedMember()\n-        member_timezone = member.getProperty(\'timezone\', None)\n+        member_timezone = member.getProperty("timezone", None)\n         if member_timezone:\n             info = pytz.timezone(member_timezone)\n             return info if as_tzinfo else info.zone\n \n-    reg_key = \'plone.portal_timezone\'\n+    reg_key = "plone.portal_timezone"\n     registry = getUtility(IRegistry)\n     portal_timezone = registry.get(reg_key, None)\n \n@@ -503,6 +505,7 @@ def localized_today(context=None):\n \n # DATETIME HELPERS\n \n+\n def first_weekday():\n     """Returns the number of the first Weekday in a Week, as defined in\n     the registry. 0 is Monday, 6 is Sunday, as expected by Python\'s datetime.\n@@ -513,7 +516,7 @@ def first_weekday():\n     :rtype: integer\n \n     """\n-    reg_key = \'plone.first_weekday\'\n+    reg_key = "plone.first_weekday"\n     registry = getUtility(IRegistry)\n     first_wd = registry.get(reg_key, None)\n \n@@ -582,23 +585,19 @@ def _adjust_DT(DT, exact):\n                 DT.hour(),\n                 DT.minute(),\n                 int(DT.second()),\n-                DT.timezone()\n+                DT.timezone(),\n             )\n         return ret\n \n     tz = default_timezone(getSite())\n     ret = None\n     if is_datetime(dt):\n-        zone_id = getattr(dt.tzinfo, \'zone\', tz)\n+        zone_id = getattr(dt.tzinfo, "zone", tz)\n         tz = validated_timezone(zone_id, tz)\n         second = dt.second\n         if exact:\n             second += dt.microsecond / 1000000.0\n-        ret = DateTime(\n-            dt.year, dt.month, dt.day,\n-            dt.hour, dt.minute, second,\n-            tz\n-        )\n+        ret = DateTime(dt.year, dt.month, dt.day, dt.hour, dt.minute, second, tz)\n     elif is_date(dt):\n         ret = DateTime(dt.year, dt.month, dt.day, 0, 0, 0, tz)\n     elif isinstance(dt, DateTime):\n@@ -699,33 +698,33 @@ def start_end_from_mode(mode, dt=None, context=None):\n     now = localized_now(context)\n     start = end = None\n \n-    if mode == \'all\':\n+    if mode == "all":\n         start = None\n         end = None\n \n-    elif mode == \'past\':\n+    elif mode == "past":\n         start = None\n         end = now\n \n-    elif mode == \'future\':\n+    elif mode == "future":\n         start = now\n         end = None\n \n-    elif mode == \'now\':\n+    elif mode == "now":\n         start = now\n         end = dt_end_of_day(now)\n \n-    elif mode == \'7days\':\n+    elif mode == "7days":\n         start = now\n         end = dt_end_of_day(now + timedelta(days=6))\n \n-    elif mode == \'day\' or mode == \'today\':\n+    elif mode == "day" or mode == "today":\n         if not dt:\n             dt = now  # show today\n         start = dt_start_of_day(dt)\n         end = dt_end_of_day(dt)\n \n-    elif mode == \'week\':\n+    elif mode == "week":\n         if not dt:\n             dt = now  # show this week\n         wkd = dt.weekday()\n@@ -739,7 +738,7 @@ def start_end_from_mode(mode, dt=None, context=None):\n         start = dt_start_of_day(dt - timedelta(days=delta))\n         end = dt_end_of_day(start + timedelta(days=6))\n \n-    elif mode == \'month\':\n+    elif mode == "month":\n         if not dt:\n             dt = now  # show this month\n         year = dt.year\n@@ -753,8 +752,9 @@ def start_end_from_mode(mode, dt=None, context=None):\n \n # DISPLAY HELPERS\n \n+\n def dates_for_display(occurrence):\n-    """ Return a dictionary containing pre-calculated information for building\n+    """Return a dictionary containing pre-calculated information for building\n     <start>-<end> date strings.\n \n     Keys are:\n@@ -828,22 +828,18 @@ def dates_for_display(occurrence):\n     if acc.open_end:\n         end_time = None\n \n-    start_iso = acc.whole_day and acc.start.date().isoformat()\\\n-        or acc.start.isoformat()\n-    end_iso = acc.whole_day and acc.end.date().isoformat()\\\n-        or acc.end.isoformat()\n+    start_iso = acc.whole_day and acc.start.date().isoformat() or acc.start.isoformat()\n+    end_iso = acc.whole_day and acc.end.date().isoformat() or acc.end.isoformat()\n \n     return dict(\n         # Start\n         start_date=start_date,\n         start_time=start_time,\n         start_iso=start_iso,\n-\n         # End\n         end_date=end_date,\n         end_time=end_time,\n         end_iso=end_iso,\n-\n         # Meta\n         same_day=same_day,\n         same_time=same_time,\n@@ -852,61 +848,49 @@ def dates_for_display(occurrence):\n     )\n \n \n-@deprecate(\'date_speller is no longer supported, use spell_date instead.\')\n+@deprecate("date_speller is no longer supported, use spell_date instead.")\n def date_speller(context, dt):\n     return spell_date(dt, context)\n \n \n def spell_date(dt, translation_context=None):\n-    """Return a dictionary with localized and readable formatted date parts.\n-\n-    """\n+    """Return a dictionary with localized and readable formatted date parts."""\n     if not translation_context:\n         translation_context = getSite()\n \n     dt = DT(dt)\n-    util = getToolByName(translation_context, \'translation_service\')\n-    dom = \'plonelocales\'\n+    util = getToolByName(translation_context, "translation_service")\n+    dom = "plonelocales"\n \n     def zero_pad(num):\n-        return \'%02d\' % num\n+        return "%02d" % num\n \n     date_dict = dict(\n         year=dt.year(),\n-\n         month=dt.month(),\n         month2=zero_pad(dt.month()),\n         month_name=util.translate(\n-            util.month_msgid(dt.month()),\n-            domain=dom, context=translation_context\n+            util.month_msgid(dt.month()), domain=dom, context=translation_context\n         ),\n         month_abbr=util.translate(\n-            util.month_msgid(dt.month(), \'a\'),\n-            domain=dom, context=translation_context\n+            util.month_msgid(dt.month(), "a"), domain=dom, context=translation_context\n         ),\n-\n         week=dt.week(),\n         wkday=dt.dow(),\n         wkday_name=util.translate(\n-            util.day_msgid(dt.dow()),\n-            domain=dom, context=translation_context\n+            util.day_msgid(dt.dow()), domain=dom, context=translation_context\n         ),\n         wkday_abbr=util.translate(\n-            util.day_msgid(dt.dow(), \'s\'),\n-            domain=dom, context=translation_context\n+            util.day_msgid(dt.dow(), "s"), domain=dom, context=translation_context\n         ),\n-\n         day=dt.day(),\n         day2=zero_pad(dt.day()),\n-\n         hour=dt.hour(),\n         hour2=zero_pad(dt.hour()),\n-\n         minute=dt.minute(),\n         minute2=zero_pad(dt.minute()),\n-\n         second=dt.second(),\n-        second2=zero_pad(dt.second())\n+        second2=zero_pad(dt.second()),\n     )\n     return date_dict\n \n@@ -935,7 +919,8 @@ def default_end(context=None):\n # General utils\n # TODO: Better fits to CMFPlone. (Taken from CMFPlone\'s new syndication tool)\n \n-class AnnotationAdapter(object):\n+\n+class AnnotationAdapter:\n     """Abstract Base Class for an annotation storage.\n \n     If the annotation wasn\'t set, it won\'t be created until the first attempt\n@@ -943,6 +928,7 @@ class AnnotationAdapter(object):\n     So, the context doesn\'t get polluted with annotations by accident.\n \n     """\n+\n     ANNOTATION_KEY = None\n \n     def __init__(self, context):\n@@ -951,7 +937,7 @@ def __init__(self, context):\n         self._data = annotations.get(self.ANNOTATION_KEY, None)\n \n     def __setattr__(self, name, value):\n-        if name in (\'context\', \'_data\', \'ANNOTATION_KEY\'):\n+        if name in ("context", "_data", "ANNOTATION_KEY"):\n             self.__dict__[name] = value\n         else:\n             if self._data is None:\n@@ -964,8 +950,7 @@ def __getattr__(self, name):\n         return self._data.get(name, None) if self._data else None\n \n \n-def find_context(context, viewname=None, iface=None,\n-                 as_url=False, append_view=True):\n+def find_context(context, viewname=None, iface=None, as_url=False, append_view=True):\n     """Find the next context with a given view name or interface, up in the\n     content tree, starting from the given context. This might not be the\n     IPloneSiteRoot, but another subsite.\n@@ -984,18 +969,27 @@ def find_context(context, viewname=None, iface=None,\n     """\n     context = aq_inner(context)\n     ret = None\n-    if viewname and context.defaultView() == viewname\\\n-       or iface and iface.providedBy(context)\\\n-       or IPloneSiteRoot.providedBy(context):\n+    if (\n+        viewname\n+        and context.defaultView() == viewname\n+        or iface\n+        and iface.providedBy(context)\n+        or IPloneSiteRoot.providedBy(context)\n+    ):\n         # Search for viewname or interface but stop at IPloneSiteRoot\n         ret = context\n     else:\n-        ret = find_context(aq_parent(context), viewname=viewname, iface=iface,\n-                           as_url=False, append_view=False)\n+        ret = find_context(\n+            aq_parent(context),\n+            viewname=viewname,\n+            iface=iface,\n+            as_url=False,\n+            append_view=False,\n+        )\n     if as_url:\n         url = ret.absolute_url()\n         if viewname and append_view and ret.defaultView() != viewname:\n-            url = \'%s/%s\' % (url, viewname)\n+            url = f"{url}/{viewname}"\n         return url\n     return ret\n \n@@ -1013,8 +1007,9 @@ def find_navroot(context, as_url=False):\n \n \n def find_event_listing(context, as_url=False):\n-    return find_context(context, viewname=\'event_listing\', iface=ISite,\n-                        as_url=as_url, append_view=True)\n+    return find_context(\n+        context, viewname="event_listing", iface=ISite, as_url=as_url, append_view=True\n+    )\n \n \n # Workaround for buggy strftime with timezone handling in DateTime.\ndiff --git a/plone/app/event/browser/__init__.py b/plone/app/event/browser/__init__.py\nindex 40a96afc6..e69de29bb 100644\n--- a/plone/app/event/browser/__init__.py\n+++ b/plone/app/event/browser/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/event/browser/event_listing.py b/plone/app/event/browser/event_listing.py\nindex 5aa1b8265..55c0f2e12 100644\n--- a/plone/app/event/browser/event_listing.py\n+++ b/plone/app/event/browser/event_listing.py\n@@ -1,7 +1,7 @@\n-# -*- coding: utf-8 -*-\n from calendar import monthrange\n from datetime import date\n from datetime import timedelta\n+from plone.app.contenttypes.behaviors.collection import ISyndicatableCollection\n from plone.app.event import _\n from plone.app.event.base import _prepare_range\n from plone.app.event.base import expand_events\n@@ -15,30 +15,18 @@\n from plone.app.event.base import start_end_query\n from plone.app.event.ical.exporter import construct_icalendar\n from plone.app.querystring import queryparser\n+from plone.base.batch import Batch\n+from plone.base.defaultpage import get_default_page\n from plone.memoize import view\n from plone.uuid.interfaces import IUUID\n-from Products.CMFPlone.PloneBatch import Batch\n from Products.Five.browser import BrowserView\n from zope.component import getMultiAdapter\n from zope.contentprovider.interfaces import IContentProvider\n \n \n-try:\n-    from Products.CMFPlone.defaultpage import get_default_page\n-except ImportError:\n-    # Plone 4\n-    from plone.app.layout.navigation.defaultpage import getDefaultPage as get_default_page  # noqa\n-\n-try:\n-    from plone.app.contenttypes.behaviors.collection import ISyndicatableCollection as ICollection  # noqa\n-except ImportError:\n-    ICollection = None\n-\n-\n class EventListing(BrowserView):\n-\n     def __init__(self, context, request):\n-        super(EventListing, self).__init__(context, request)\n+        super().__init__(context, request)\n \n         self.now = now = localized_now(context)\n \n@@ -47,36 +35,38 @@ def __init__(self, context, request):\n         self.default_context = context[default] if default else context\n \n         self.is_collection = False\n-        if ICollection:\n-            self.is_collection = ICollection.providedBy(self.default_context)\n+        if ISyndicatableCollection:\n+            self.is_collection = ISyndicatableCollection.providedBy(\n+                self.default_context\n+            )\n \n         # Request parameter\n         req = self.request.form\n \n-        b_size  = int(req.get(\'b_size\', 0))\n+        b_size = int(req.get("b_size", 0))\n         if not b_size and self.is_collection:\n-            collection_behavior = ICollection(self.default_context)\n-            b_size = getattr(collection_behavior, \'item_count\', 0)\n+            collection_behavior = ISyndicatableCollection(self.default_context)\n+            b_size = getattr(collection_behavior, "item_count", 0)\n         self.b_size = b_size or 10\n-        self.b_start = int(req.get(\'b_start\', 0))\n-        self.orphan  = int(req.get(\'orphan\', 1))\n-        self.mode    = req.get(\'mode\', None)\n-        self._date   = req.get(\'date\', None)\n-        self.tags    = req.get(\'tags\', None)\n-        self.searchable_text = req.get(\'SearchableText\', None)\n-        self.path    = req.get(\'path\', None)\n-\n-        day   = int(req.get(\'day\', 0)) or None\n-        month = int(req.get(\'month\', 0)) or None\n-        year  = int(req.get(\'year\', 0)) or None\n+        self.b_start = int(req.get("b_start", 0))\n+        self.orphan = int(req.get("orphan", 1))\n+        self.mode = req.get("mode", None)\n+        self._date = req.get("date", None)\n+        self.tags = req.get("tags", None)\n+        self.searchable_text = req.get("SearchableText", None)\n+        self.path = req.get("path", None)\n+\n+        day = int(req.get("day", 0)) or None\n+        month = int(req.get("month", 0)) or None\n+        year = int(req.get("year", 0)) or None\n \n         if not self._date and day or month or year:\n-            self._date = date(year or now.year,\n-                              month or now.month,\n-                              day or now.day).isoformat()\n+            self._date = date(\n+                year or now.year, month or now.month, day or now.day\n+            ).isoformat()\n \n         if self.mode is None:\n-            self.mode = \'day\' if self._date else \'future\'\n+            self.mode = "day" if self._date else "future"\n \n         self.uid = None  # Used to get all occurrences from a single event. Overrides all other settings  # noqa\n \n@@ -86,7 +76,7 @@ def show_filter(self):\n         if self.is_collection:\n             ctx = self.default_context\n             query = queryparser.parseFormquery(ctx, ctx.query)\n-            if \'start\' in query or \'end\' in query:\n+            if "start" in query or "end" in query:\n                 # Don\'t show the date filter, if a date is given in the\n                 # collection\'s query\n                 ret = False\n@@ -112,32 +102,39 @@ def _get_events(self, ret_mode=RET_MODE_ACCESSORS, expand=True):\n         kw = {}\n         if self.uid:\n             # In this case, restrict search for single event\n-            kw[\'UID\'] = self.uid\n+            kw["UID"] = self.uid\n         else:\n             if self.path:\n-                kw[\'path\'] = self.path\n+                kw["path"] = self.path\n             else:\n                 # Search current and subsequent folders\n-                kw[\'path\'] = \'/\'.join(context.getPhysicalPath())\n+                kw["path"] = "/".join(context.getPhysicalPath())\n \n             if self.tags:\n-                kw[\'Subject\'] = {\'query\': self.tags, \'operator\': \'and\'}\n+                kw["Subject"] = {"query": self.tags, "operator": "and"}\n \n             if self.searchable_text:\n-                kw[\'SearchableText\'] = self.searchable_text\n+                kw["SearchableText"] = self.searchable_text\n \n         # kw[\'b_start\'] = self.b_start\n         # kw[\'b_size\']  = self.b_size\n \n         start, end = self._start_end\n \n-        sort = \'start\'\n+        sort = "start"\n         sort_reverse = False\n-        if self.mode in (\'past\', \'all\'):\n+        if self.mode in ("past", "all"):\n             sort_reverse = True\n-        return get_events(context, start=start, end=end,\n-                          sort=sort, sort_reverse=sort_reverse,\n-                          ret_mode=ret_mode, expand=expand, **kw)\n+        return get_events(\n+            context,\n+            start=start,\n+            end=end,\n+            sort=sort,\n+            sort_reverse=sort_reverse,\n+            ret_mode=ret_mode,\n+            expand=expand,\n+            **kw,\n+        )\n \n     @view.memoize\n     def events(self, ret_mode=RET_MODE_ACCESSORS, expand=True, batch=True):\n@@ -145,33 +142,34 @@ def events(self, ret_mode=RET_MODE_ACCESSORS, expand=True, batch=True):\n         if self.is_collection:\n             ctx = self.default_context\n             # Whatever sorting is defined, we\'re overriding it.\n-            sort_on = \'start\'\n+            sort_on = "start"\n             sort_order = None\n-            if self.mode in (\'past\', \'all\'):\n-                sort_order = \'reverse\'\n+            if self.mode in ("past", "all"):\n+                sort_order = "reverse"\n             query = queryparser.parseFormquery(\n                 ctx, ctx.query, sort_on=sort_on, sort_order=sort_order\n             )\n-            custom_query = self.request.get(\'contentFilter\', {})\n-            if \'start\' not in query or \'end\' not in query:\n+            custom_query = self.request.get("contentFilter", {})\n+            if "start" not in query or "end" not in query:\n                 # ... else don\'t show the navigation bar\n                 start, end = self._start_end\n                 start, end = _prepare_range(ctx, start, end)\n                 custom_query.update(start_end_query(start, end))\n-            res = ctx.results(\n-                batch=False, brains=True, custom_query=custom_query\n-            )\n+            res = ctx.results(batch=False, brains=True, custom_query=custom_query)\n             if expand:\n                 # get start and end values from the query to ensure limited\n                 # listing for occurrences\n                 start, end = self._expand_events_start_end(\n-                    query.get(\'start\') or custom_query.get(\'start\'),\n-                    query.get(\'end\') or custom_query.get(\'end\')\n+                    query.get("start") or custom_query.get("start"),\n+                    query.get("end") or custom_query.get("end"),\n                 )\n                 res = expand_events(\n-                    res, ret_mode,\n-                    start=start, end=end,\n-                    sort=sort_on, sort_reverse=True if sort_order else False\n+                    res,\n+                    ret_mode,\n+                    start=start,\n+                    end=end,\n+                    sort=sort_on,\n+                    sort_reverse=True if sort_order else False,\n                 )\n         else:\n             res = self._get_events(ret_mode, expand=expand)\n@@ -186,17 +184,15 @@ def ical(self):\n         # Get as objects.\n         # Don\'t include occurrences to avoid having them along with their\n         # original events and it\'s recurrence definition in icalendar exports.\n-        events = self.events(ret_mode=RET_MODE_OBJECTS, expand=False,\n-                             batch=False)\n+        events = self.events(ret_mode=RET_MODE_OBJECTS, expand=False, batch=False)\n         cal = construct_icalendar(self.context, events)\n-        name = \'%s.ics\' % self.context.getId()\n+        name = "%s.ics" % self.context.getId()\n         contents = cal.to_ical()\n-        self.request.response.setHeader(\'Content-Type\', \'text/calendar\')\n+        self.request.response.setHeader("Content-Type", "text/calendar")\n         self.request.response.setHeader(\n-            \'Content-Disposition\',\n-            \'attachment; filename="%s"\' % name\n+            "Content-Disposition", \'attachment; filename="%s"\' % name\n         )\n-        self.request.response.setHeader(\'Content-Length\', len(contents))\n+        self.request.response.setHeader("Content-Length", len(contents))\n         self.request.response.write(contents)\n \n     @property\n@@ -204,16 +200,18 @@ def ical_url(self):\n         date = self.date\n         mode = self.mode\n \n-        qstr = \'&\'.join([\n-            it for it in [\'mode=%s\' % mode if mode else None,\n-                          \'date=%s\' % date if date else None]\n-            if it\n-        ])\n-        qstr = \'?%s\' % qstr if qstr else \'\'\n-        return \'%s/@@event_listing_ical%s\' % (\n-            self.context.absolute_url(),\n-            qstr\n+        qstr = "&".join(\n+            [\n+                it\n+                for it in [\n+                    "mode=%s" % mode if mode else None,\n+                    "date=%s" % date if date else None,\n+                ]\n+                if it\n+            ]\n         )\n+        qstr = "?%s" % qstr if qstr else ""\n+        return f"{self.context.absolute_url()}/@@event_listing_ical{qstr}"\n \n     # COLLECTION daterange start/end determination\n     def _expand_events_start_end(self, start, end):\n@@ -225,8 +223,8 @@ def _expand_events_start_end(self, start, end):\n         # wants to come up with some edgecases!\n         se = dict(start=None, end=None)\n         if start:\n-            q = start.get(\'query\')\n-            r = start.get(\'range\')\n+            q = start.get("query")\n+            r = start.get("range")\n             if r == "min":\n                 se["start"] = q\n             elif r == "max":\n@@ -236,16 +234,15 @@ def _expand_events_start_end(self, start, end):\n                 se["start"] = q[0]\n                 se["end"] = q[1]\n         if end:\n-            q = end.get(\'query\')\n-            r = end.get(\'range\')\n+            q = end.get("query")\n+            r = end.get("range")\n             if r == "min":\n                 se["start"] = q\n         return se["start"], se["end"]\n \n     def formatted_date(self, occ):\n         provider = getMultiAdapter(\n-            (self.context, self.request, self),\n-            IContentProvider, name=\'formatted_date\'\n+            (self.context, self.request, self), IContentProvider, name="formatted_date"\n         )\n         return provider(occ)\n \n@@ -261,181 +258,188 @@ def header_string(self):\n         mode = self.mode\n         main_msgid = None\n         sub_msgid = None\n-        if mode == \'all\':\n-            main_msgid = _(u"all_events", default=u"All events")\n+        if mode == "all":\n+            main_msgid = _("all_events", default="All events")\n \n-        elif mode == \'past\':\n-            main_msgid = _(u"past_events", default=u"Past events")\n+        elif mode == "past":\n+            main_msgid = _("past_events", default="Past events")\n \n-        elif mode == \'future\':\n-            main_msgid = _(u"future_events", default=u"Future events")\n+        elif mode == "future":\n+            main_msgid = _("future_events", default="Future events")\n \n-        elif mode == \'now\':\n-            main_msgid = _(u"todays_upcoming_events",\n-                           default=u"Todays upcoming events")\n+        elif mode == "now":\n+            main_msgid = _("todays_upcoming_events", default="Todays upcoming events")\n \n-        elif mode == \'today\':\n-            main_msgid = _(u"todays_events", default=u"Todays events")\n+        elif mode == "today":\n+            main_msgid = _("todays_events", default="Todays events")\n \n-        elif mode == \'7days\':\n-            main_msgid = _(u"7days_events", default=u"Events in next 7 days.")\n+        elif mode == "7days":\n+            main_msgid = _("7days_events", default="Events in next 7 days.")\n             sub_msgid = _(\n-                u"events_from_until",\n-                default=u"${from} until ${until}.",\n+                "events_from_until",\n+                default="${from} until ${until}.",\n                 mapping={\n-                    \'from\': "%s, %s. %s %s" % (\n-                        start_dict[\'wkday_name\'],\n+                    "from": "%s, %s. %s %s"\n+                    % (\n+                        start_dict["wkday_name"],\n                         start.day,\n-                        start_dict[\'month_name\'],\n-                        start.year\n+                        start_dict["month_name"],\n+                        start.year,\n                     ),\n-                    \'until\': "%s, %s. %s %s" % (\n-                        end_dict[\'wkday_name\'],\n+                    "until": "%s, %s. %s %s"\n+                    % (\n+                        end_dict["wkday_name"],\n                         end.day,\n-                        end_dict[\'month_name\'],\n-                        end.year\n+                        end_dict["month_name"],\n+                        end.year,\n                     ),\n-                }\n+                },\n             )\n \n-        elif mode == \'day\':\n+        elif mode == "day":\n             main_msgid = _(\n-                u"events_on_day",\n-                default=u"Events on ${day}",\n+                "events_on_day",\n+                default="Events on ${day}",\n                 mapping={\n-                    \'day\': "%s, %s. %s %s" % (\n-                        start_dict[\'wkday_name\'],\n+                    "day": "%s, %s. %s %s"\n+                    % (\n+                        start_dict["wkday_name"],\n                         start.day,\n-                        start_dict[\'month_name\'],\n-                        start.year\n+                        start_dict["month_name"],\n+                        start.year,\n                     ),\n-                }\n+                },\n             )\n \n-        elif mode == \'week\':\n-            main_msgid = _(u"events_in_week",\n-                           default=u"Events in week ${weeknumber}",\n-                           mapping={\'weeknumber\': start.isocalendar()[1]})\n+        elif mode == "week":\n+            main_msgid = _(\n+                "events_in_week",\n+                default="Events in week ${weeknumber}",\n+                mapping={"weeknumber": start.isocalendar()[1]},\n+            )\n             sub_msgid = _(\n-                u"events_from_until",\n-                default=u"${from} until ${until}.",\n+                "events_from_until",\n+                default="${from} until ${until}.",\n                 mapping={\n-                    \'from\': "%s, %s. %s %s" % (\n-                        start_dict[\'wkday_name\'],\n+                    "from": "%s, %s. %s %s"\n+                    % (\n+                        start_dict["wkday_name"],\n                         start.day,\n-                        start_dict[\'month_name\'],\n-                        start.year\n+                        start_dict["month_name"],\n+                        start.year,\n                     ),\n-                    \'until\': "%s, %s. %s %s" % (\n-                        end_dict[\'wkday_name\'],\n+                    "until": "%s, %s. %s %s"\n+                    % (\n+                        end_dict["wkday_name"],\n                         end.day,\n-                        end_dict[\'month_name\'],\n-                        end.year\n+                        end_dict["month_name"],\n+                        end.year,\n                     ),\n-                }\n+                },\n             )\n \n-        elif mode == \'month\':\n+        elif mode == "month":\n             main_msgid = _(\n-                u"events_in_month",\n-                default=u"Events in ${month} ${year}",\n+                "events_in_month",\n+                default="Events in ${month} ${year}",\n                 mapping={\n-                    \'month\': start_dict[\'month_name\'],\n-                    \'year\': start.year,\n-                }\n+                    "month": start_dict["month_name"],\n+                    "year": start.year,\n+                },\n             )\n \n         trans = self.context.translate\n-        return {\'main\': trans(main_msgid) if main_msgid else \'\',\n-                \'sub\': trans(sub_msgid) if sub_msgid else \'\'}\n+        return {\n+            "main": trans(main_msgid) if main_msgid else "",\n+            "sub": trans(sub_msgid) if sub_msgid else "",\n+        }\n \n     # MODE URLs\n-    def _date_nav_url(self, mode, datestr=\'\'):\n-        return \'%s?mode=%s%s\' % (\n+    def _date_nav_url(self, mode, datestr=""):\n+        return "{}?mode={}{}".format(\n             self.request.getURL(),\n             mode,\n-            \'&date=%s\' % datestr if datestr else \'\'\n+            "&date=%s" % datestr if datestr else "",\n         )\n \n     @property\n     def mode_all_url(self):\n-        return self._date_nav_url(\'all\')\n+        return self._date_nav_url("all")\n \n     @property\n     def mode_future_url(self):\n-        return self._date_nav_url(\'future\')\n+        return self._date_nav_url("future")\n \n     @property\n     def mode_past_url(self):\n-        return self._date_nav_url(\'past\')\n+        return self._date_nav_url("past")\n \n     @property\n     def mode_day_url(self):\n         now = self.date or self.now\n-        return self._date_nav_url(\'day\', now.date().isoformat())\n+        return self._date_nav_url("day", now.date().isoformat())\n \n     @property\n     def mode_week_url(self):\n         now = self.date or self.now\n-        return self._date_nav_url(\'week\', now.date().isoformat())\n+        return self._date_nav_url("week", now.date().isoformat())\n \n     @property\n     def mode_month_url(self):\n         now = self.date or self.now\n-        return self._date_nav_url(\'month\', now.date().isoformat())\n+        return self._date_nav_url("month", now.date().isoformat())\n \n     # DAY NAV\n     @property\n     def next_day_url(self):\n         now = self.date or self.now\n         datestr = (now + timedelta(days=1)).date().isoformat()\n-        return self._date_nav_url(\'day\', datestr)\n+        return self._date_nav_url("day", datestr)\n \n     @property\n     def today_url(self):\n-        return self._date_nav_url(\'day\')\n+        return self._date_nav_url("day")\n \n     @property\n     def prev_day_url(self):\n         now = self.date or self.now\n         datestr = (now - timedelta(days=1)).date().isoformat()\n-        return self._date_nav_url(\'day\', datestr)\n+        return self._date_nav_url("day", datestr)\n \n     # WEEK NAV\n     @property\n     def next_week_url(self):\n         now = self.date or self.now\n         datestr = (now + timedelta(days=7)).date().isoformat()\n-        return self._date_nav_url(\'week\', datestr)\n+        return self._date_nav_url("week", datestr)\n \n     @property\n     def this_week_url(self):\n-        return self._date_nav_url(\'week\')\n+        return self._date_nav_url("week")\n \n     @property\n     def prev_week_url(self):\n         now = self.date or self.now\n         datestr = (now - timedelta(days=7)).date().isoformat()\n-        return self._date_nav_url(\'week\', datestr)\n+        return self._date_nav_url("week", datestr)\n \n     # MONTH NAV\n     @property\n     def next_month_url(self):\n         now = self.date or self.now\n         last_day = monthrange(now.year, now.month)[1]  # (wkday, days)\n-        datestr = (now.replace(day=last_day) +\n-                   timedelta(days=1)).date().isoformat()\n-        return self._date_nav_url(\'month\', datestr)\n+        datestr = (now.replace(day=last_day) + timedelta(days=1)).date().isoformat()\n+        return self._date_nav_url("month", datestr)\n \n     @property\n     def this_month_url(self):\n-        return self._date_nav_url(\'month\')\n+        return self._date_nav_url("month")\n \n     @property\n     def prev_month_url(self):\n         now = self.date or self.now\n         datestr = (now.replace(day=1) - timedelta(days=1)).date().isoformat()\n-        return self._date_nav_url(\'month\', datestr)\n+        return self._date_nav_url("month", datestr)\n \n \n class EventListingIcal(EventListing):\n@@ -448,6 +452,7 @@ class EventEventListing(EventListing):\n     occurrences batched and navigatable with all the features, the EventListing\n     offers.\n     """\n+\n     def __init__(self, context, request):\n-        super(EventEventListing, self).__init__(context, request)\n+        super().__init__(context, request)\n         self.uid = IUUID(self.context)\ndiff --git a/plone/app/event/browser/event_summary.py b/plone/app/event/browser/event_summary.py\nindex 94735f7a6..de5653761 100644\n--- a/plone/app/event/browser/event_summary.py\n+++ b/plone/app/event/browser/event_summary.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_parent\n from plone.app.event import _\n from plone.event.interfaces import IEventAccessor\n@@ -13,13 +12,14 @@\n \n \n class EventSummaryView(BrowserView):\n-\n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n         self.data = IEventAccessor(context)\n         self.max_occurrences = 6\n-        self.excludes = [\'title\', ]\n+        self.excludes = [\n+            "title",\n+        ]\n \n     @property\n     def is_occurrence(self):\n@@ -33,8 +33,7 @@ def event_context(self):\n \n     def formatted_date(self, occ):\n         provider = getMultiAdapter(\n-            (self.context, self.request, self),\n-            IContentProvider, name=\'formatted_date\'\n+            (self.context, self.request, self), IContentProvider, name="formatted_date"\n         )\n         return provider(occ)\n \n@@ -50,8 +49,7 @@ def next_occurrences(self):\n         occurrences = []\n         adapter = IRecurrenceSupport(self.event_context, None)\n         if adapter:\n-            for cnt, occ in enumerate(adapter.occurrences(\n-                    range_start=self.data.start)):\n+            for cnt, occ in enumerate(adapter.occurrences(range_start=self.data.start)):\n                 if cnt == self.max_occurrences:\n                     break\n                 occurrences.append(occ)\n@@ -67,21 +65,21 @@ def num_more_occurrences(self):\n         if not uid:\n             # Might be an occurrence\n             return 0\n-        catalog = getToolByName(self.event_context, \'portal_catalog\')\n+        catalog = getToolByName(self.event_context, "portal_catalog")\n         brains = catalog(UID=uid)\n         if len(brains) == 0:\n             return 0\n         brain = brains[0]  # assuming, that current context is in the catalog\n         idx = catalog.getIndexDataForRID(brain.getRID())\n-        num = len(idx[\'start\']) - len(self.next_occurrences)\n+        num = len(idx["start"]) - len(self.next_occurrences)\n         return num if num > 0 else 0\n \n     @property\n     def more_occurrences_text(self):\n         msgid = _(\n-            u"msg_num_more_occurrences",\n-            default=u"There are ${results} more occurrences.",\n-            mapping={u"results": self.num_more_occurrences}\n+            "msg_num_more_occurrences",\n+            default="There are ${results} more occurrences.",\n+            mapping={"results": self.num_more_occurrences},\n         )\n         return self.context.translate(msgid)\n \n@@ -90,4 +88,3 @@ def more_occurrences_text(self):\n     def has_occurrences(self):\n         occs = [o for o in self.next_occurrences if IOccurrence.providedBy(o)]\n         return len(occs)\n-        \n\\ No newline at end of file\ndiff --git a/plone/app/event/browser/event_view.py b/plone/app/event/browser/event_view.py\nindex 15202bd2d..32ec01bc0 100644\n--- a/plone/app/event/browser/event_view.py\n+++ b/plone/app/event/browser/event_view.py\n@@ -1,11 +1,9 @@\n-# -*- coding: utf-8 -*-\n from plone.event.interfaces import IEventAccessor\n from plone.event.interfaces import IOccurrence\n from Products.Five.browser import BrowserView\n \n \n class EventView(BrowserView):\n-\n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n@@ -15,5 +13,5 @@ def __call__(self):\n         if IOccurrence.providedBy(self.context):\n             # The transient Occurrence objects cannot be edited. disable the\n             # edit border for them.\n-            self.request.set(\'disable_border\', True)\n+            self.request.set("disable_border", True)\n         return self.index()  # render me.\ndiff --git a/plone/app/event/browser/formatted_date.py b/plone/app/event/browser/formatted_date.py\nindex ce133dca9..42a3d5ed8 100644\n--- a/plone/app/event/browser/formatted_date.py\n+++ b/plone/app/event/browser/formatted_date.py\n@@ -1,11 +1,10 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import Explicit\n from plone.app.event.base import dates_for_display\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n \n \n class FormattedDateProvider(Explicit):\n-    template = ViewPageTemplateFile(u\'formatted_date.pt\')\n+    template = ViewPageTemplateFile("formatted_date.pt")\n \n     def __init__(self, context, request, view):\n         self.__parent__ = view\n@@ -24,9 +23,9 @@ def __call__(self, occ):\n         self.date_dict = dates_for_display(occ)\n         if self.date_dict is None:\n             # Don\'t break for potential Events without start/end.\n-            return u""\n+            return ""\n         return self.template(self)\n \n \n class FormattedStartDateProvider(FormattedDateProvider):\n-    template = ViewPageTemplateFile(u\'formatted_start_date.pt\')\n+    template = ViewPageTemplateFile("formatted_start_date.pt")\ndiff --git a/plone/app/event/browser/leadimage_viewlet.py b/plone/app/event/browser/leadimage_viewlet.py\nindex 1d923b120..434071e5f 100644\n--- a/plone/app/event/browser/leadimage_viewlet.py\n+++ b/plone/app/event/browser/leadimage_viewlet.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_parent\n from plone.app.contenttypes.behaviors.leadimage import ILeadImage\n from plone.app.layout.viewlets import ViewletBase\n@@ -8,7 +7,11 @@ class LeadImageViewlet(ViewletBase):\n     """plone.app.contenttypes LeadImageViewlet for Occurrence contexts, where\n     the image might be defined on the parent object.\n     """\n+\n     def update(self):\n         parent = aq_parent(self.context)\n-        self.available = ILeadImage.providedBy(parent) and\\\n-            True if getattr(parent, \'image\', False) else False\n+        self.available = (\n+            ILeadImage.providedBy(parent) and True\n+            if getattr(parent, "image", False)\n+            else False\n+        )\ndiff --git a/plone/app/event/configure.zcml b/plone/app/event/configure.zcml\nindex 42a0c5322..64e995a17 100644\n--- a/plone/app/event/configure.zcml\n+++ b/plone/app/event/configure.zcml\n@@ -34,7 +34,7 @@\n       directory="profiles/default"\n       title="plone.app.event"\n       description="plone.app.event framework registration."\n-      for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+      for="plone.base.interfaces.IPloneSiteRoot"\n       provides="Products.GenericSetup.interfaces.EXTENSION"\n       />\n \n@@ -43,7 +43,7 @@\n       title="plone.app.event testing"\n       directory="profiles/testing"\n       description="Testing profile for plone.app.event"\n-      for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+      for="plone.base.interfaces.IPloneSiteRoot"\n       provides="Products.GenericSetup.interfaces.EXTENSION"\n       />\n \n@@ -58,6 +58,6 @@\n   <utility\n       factory=".setuphandlers.HiddenProfiles"\n       name="plone.app.event"\n-      provides="Products.CMFPlone.interfaces.INonInstallable" />\n+      provides="plone.base.interfaces.INonInstallable" />\n \n </configure>\ndiff --git a/plone/app/event/dx/__init__.py b/plone/app/event/dx/__init__.py\nindex 40a96afc6..e69de29bb 100644\n--- a/plone/app/event/dx/__init__.py\n+++ b/plone/app/event/dx/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/event/dx/behaviors.py b/plone/app/event/dx/behaviors.py\nindex f414f0808..871c77ad9 100644\n--- a/plone/app/event/dx/behaviors.py\n+++ b/plone/app/event/dx/behaviors.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """Behaviors to enable calendarish event extension to dexterity content types.\n """\n from plone.app.dexterity.behaviors.metadata import ICategorization\n@@ -19,6 +18,7 @@\n from plone.app.z3cform.widget import DatetimeFieldWidget\n from plone.autoform import directives\n from plone.autoform.interfaces import IFormFieldProvider\n+from plone.base.utils import safe_text\n from plone.event.interfaces import IEventAccessor\n from plone.event.interfaces import IRecurrenceSupport\n from plone.event.utils import pydt\n@@ -27,7 +27,6 @@\n from plone.indexer import indexer\n from plone.supermodel import model\n from plone.uuid.interfaces import IUUID\n-from Products.CMFPlone.utils import safe_unicode\n from z3c.form.browser.checkbox import SingleCheckBoxFieldWidget\n from z3c.form.browser.text import TextFieldWidget\n from z3c.form.browser.textlines import TextLinesFieldWidget\n@@ -47,64 +46,51 @@ def first_weekday_sun0():\n \n \n class StartBeforeEnd(Invalid):\n-    __doc__ = _("error_invalid_date",\n-                default=u"Invalid start or end date")\n+    __doc__ = _("error_invalid_date", default="Invalid start or end date")\n \n \n @provider(IContextAwareDefaultFactory)\n def default_start(context):\n-    """Provide default start for the form.\n-    """\n+    """Provide default start for the form."""\n     return default_start_dt(context)\n \n \n @provider(IContextAwareDefaultFactory)\n def default_end(context):\n-    """Provide default end for the form.\n-    """\n+    """Provide default end for the form."""\n     return default_end_dt(context)\n \n \n class IEventBasic(model.Schema, IDXEvent):\n \n-    """ Basic event schema.\n-    """\n+    """Basic event schema."""\n+\n     start = schema.Datetime(\n-        title=_(\n-            u\'label_event_start\',\n-            default=u\'Event Starts\'\n-        ),\n+        title=_("label_event_start", default="Event Starts"),\n         description=_(\n-            u\'help_event_start\',\n-            default=u\'Date and Time, when the event begins.\'\n+            "help_event_start", default="Date and Time, when the event begins."\n         ),\n         required=True,\n-        defaultFactory=default_start\n+        defaultFactory=default_start,\n     )\n     directives.widget(\n-        \'start\',\n+        "start",\n         DatetimeFieldWidget,\n         default_timezone=default_timezone,\n-        klass=u\'event_start\'\n+        klass="event_start",\n     )\n \n     end = schema.Datetime(\n-        title=_(\n-            u\'label_event_end\',\n-            default=u\'Event Ends\'\n-        ),\n-        description=_(\n-            u\'help_event_end\',\n-            default=u\'Date and Time, when the event ends.\'\n-        ),\n+        title=_("label_event_end", default="Event Ends"),\n+        description=_("help_event_end", default="Date and Time, when the event ends."),\n         required=True,\n-        defaultFactory=default_end\n+        defaultFactory=default_end,\n     )\n     directives.widget(\n-        \'end\',\n+        "end",\n         DatetimeFieldWidget,\n         default_timezone=default_timezone,\n-        klass=u\'event_end\',\n+        klass="event_end",\n         pattern_options={\n             "behavior": "styled",\n             "after": "input.event_end",\n@@ -113,209 +99,134 @@ class IEventBasic(model.Schema, IDXEvent):\n     )\n \n     whole_day = schema.Bool(\n-        title=_(\n-            u\'label_event_whole_day\',\n-            default=u\'Whole Day\'\n-        ),\n-        description=_(\n-            u\'help_event_whole_day\',\n-            default=u\'Event lasts whole day.\'\n-        ),\n+        title=_("label_event_whole_day", default="Whole Day"),\n+        description=_("help_event_whole_day", default="Event lasts whole day."),\n         required=False,\n-        default=False\n-    )\n-    directives.widget(\n-        \'whole_day\',\n-        SingleCheckBoxFieldWidget,\n-        klass=u\'event_whole_day\'\n+        default=False,\n     )\n+    directives.widget("whole_day", SingleCheckBoxFieldWidget, klass="event_whole_day")\n \n     open_end = schema.Bool(\n-        title=_(\n-            u\'label_event_open_end\',\n-            default=u\'Open End\'\n-        ),\n-        description=_(\n-            u\'help_event_open_end\',\n-            default=u"This event is open ended."\n-        ),\n+        title=_("label_event_open_end", default="Open End"),\n+        description=_("help_event_open_end", default="This event is open ended."),\n         required=False,\n-        default=False\n-    )\n-    directives.widget(\n-        \'open_end\',\n-        SingleCheckBoxFieldWidget,\n-        klass=u\'event_open_end\'\n+        default=False,\n     )\n+    directives.widget("open_end", SingleCheckBoxFieldWidget, klass="event_open_end")\n \n     # icalendar event uid\n     sync_uid = schema.TextLine(required=False)\n-    directives.mode(sync_uid=\'hidden\')\n+    directives.mode(sync_uid="hidden")\n \n     @invariant\n     def validate_start_end(data):\n-        if (\n-            data.start\n-            and data.end\n-            and data.start > data.end\n-            and not data.open_end\n-        ):\n+        if data.start and data.end and data.start > data.end and not data.open_end:\n             raise StartBeforeEnd(\n-                _("error_end_must_be_after_start_date",\n-                  default=u"End date must be after start date.")\n+                _(\n+                    "error_end_must_be_after_start_date",\n+                    default="End date must be after start date.",\n+                )\n             )\n \n \n class IEventRecurrence(model.Schema, IDXEventRecurrence):\n \n-    """ Recurring Event Schema.\n-    """\n+    """Recurring Event Schema."""\n+\n     recurrence = schema.Text(\n-        title=_(\n-            u\'label_event_recurrence\',\n-            default=u\'Recurrence\'\n-        ),\n+        title=_("label_event_recurrence", default="Recurrence"),\n         description=_(\n-            u\'help_event_recurrence\',\n-            default=u\'Define the event recurrence rule.\'\n+            "help_event_recurrence", default="Define the event recurrence rule."\n         ),\n         required=False,\n-        default=None\n+        default=None,\n     )\n     directives.widget(\n-        \'recurrence\',\n+        "recurrence",\n         RecurrenceFieldWidget,\n-        start_field=u\'IEventBasic.start\',\n+        start_field="IEventBasic.start",\n         first_day=first_weekday_sun0,\n         show_repeat_forever=False,\n-        klass=u\'event_recurrence\'\n+        klass="event_recurrence",\n     )\n \n \n class IEventLocation(model.Schema):\n \n-    """ Event Location Schema.\n-    """\n+    """Event Location Schema."""\n+\n     location = schema.TextLine(\n-        title=_(\n-            u\'label_event_location\',\n-            default=u\'Location\'\n-        ),\n-        description=_(\n-            u\'help_event_location\',\n-            default=u\'Location of the event.\'\n-        ),\n+        title=_("label_event_location", default="Location"),\n+        description=_("help_event_location", default="Location of the event."),\n         required=False,\n-        default=None\n-    )\n-    directives.widget(\n-        \'location\',\n-        TextFieldWidget,\n-        klass=u\'event_location\'\n+        default=None,\n     )\n+    directives.widget("location", TextFieldWidget, klass="event_location")\n \n \n class IEventAttendees(model.Schema):\n \n-    """ Event Attendees Schema.\n-    """\n+    """Event Attendees Schema."""\n+\n     attendees = schema.Tuple(\n-        title=_(\n-            u\'label_event_attendees\',\n-            default=u\'Attendees\'\n-        ),\n-        description=_(\n-            u\'help_event_attendees\',\n-            default=u\'List of attendees.\'\n-        ),\n+        title=_("label_event_attendees", default="Attendees"),\n+        description=_("help_event_attendees", default="List of attendees."),\n         value_type=schema.TextLine(),\n         required=False,\n         missing_value=(),\n         default=(),\n     )\n-    directives.widget(\n-        \'attendees\',\n-        TextLinesFieldWidget,\n-        klass=u\'event_attendees\'\n-    )\n+    directives.widget("attendees", TextLinesFieldWidget, klass="event_attendees")\n \n \n class IEventContact(model.Schema):\n \n-    """ Event Contact Schema.\n-    """\n+    """Event Contact Schema."""\n+\n     contact_name = schema.TextLine(\n-        title=_(\n-            u\'label_event_contact_name\',\n-            default=u\'Contact Name\'\n-        ),\n+        title=_("label_event_contact_name", default="Contact Name"),\n         description=_(\n-            u\'help_event_contact_name\',\n-            default=u\'Name of a person to contact about this event.\'\n+            "help_event_contact_name",\n+            default="Name of a person to contact about this event.",\n         ),\n         required=False,\n-        default=None\n-    )\n-    directives.widget(\n-        \'contact_name\',\n-        TextFieldWidget,\n-        klass=u\'event_contact_name\'\n+        default=None,\n     )\n+    directives.widget("contact_name", TextFieldWidget, klass="event_contact_name")\n \n     contact_email = schema.TextLine(\n-        title=_(\n-            u\'label_event_contact_email\',\n-            default=u\'Contact E-mail\'\n-        ),\n+        title=_("label_event_contact_email", default="Contact E-mail"),\n         description=_(\n-            u\'help_event_contact_email\',\n-            default=u\'Email address to contact about this event.\'\n+            "help_event_contact_email",\n+            default="Email address to contact about this event.",\n         ),\n         required=False,\n-        default=None\n-    )\n-    directives.widget(\n-        \'contact_email\',\n-        TextFieldWidget,\n-        klass=u\'event_contact_email\'\n+        default=None,\n     )\n+    directives.widget("contact_email", TextFieldWidget, klass="event_contact_email")\n \n     contact_phone = schema.TextLine(\n-        title=_(\n-            u\'label_event_contact_phone\',\n-            default=u\'Contact Phone\'\n-        ),\n+        title=_("label_event_contact_phone", default="Contact Phone"),\n         description=_(\n-            u\'help_event_contact_phone\',\n-            default=u\'Phone number to contact about this event.\'\n+            "help_event_contact_phone",\n+            default="Phone number to contact about this event.",\n         ),\n         required=False,\n-        default=None\n-    )\n-    directives.widget(\n-        \'contact_phone\',\n-        TextFieldWidget,\n-        klass=u\'event_contact_phone\'\n+        default=None,\n     )\n+    directives.widget("contact_phone", TextFieldWidget, klass="event_contact_phone")\n \n     event_url = schema.URI(\n-        title=_(\n-            u\'label_event_url\',\n-            default=u\'Event URL\'\n-        ),\n+        title=_("label_event_url", default="Event URL"),\n         description=_(\n-            u\'help_event_url\',\n-            default=u\'Web address with more info about the event. \'\n-                    u\'Add http:// for external links.\'\n+            "help_event_url",\n+            default="Web address with more info about the event. "\n+            "Add http:// for external links.",\n         ),\n         required=False,\n-        default=None\n-    )\n-    directives.widget(\n-        \'event_url\',\n-        TextFieldWidget,\n-        klass=u\'event_url\'\n+        default=None,\n     )\n+    directives.widget("event_url", TextFieldWidget, klass="event_url")\n \n \n # Mark these interfaces as form field providers\n@@ -327,10 +238,10 @@ class IEventContact(model.Schema):\n \n \n # Language independent fields\n-alsoProvides(IEventBasic[\'start\'], ILanguageIndependentField)\n-alsoProvides(IEventBasic[\'end\'], ILanguageIndependentField)\n-alsoProvides(IEventBasic[\'whole_day\'], ILanguageIndependentField)\n-alsoProvides(IEventBasic[\'open_end\'], ILanguageIndependentField)\n+alsoProvides(IEventBasic["start"], ILanguageIndependentField)\n+alsoProvides(IEventBasic["end"], ILanguageIndependentField)\n+alsoProvides(IEventBasic["whole_day"], ILanguageIndependentField)\n+alsoProvides(IEventBasic["open_end"], ILanguageIndependentField)\n \n \n # Attribute indexer\n@@ -357,7 +268,7 @@ def end_indexer(obj):\n @indexer(IDXEvent)\n def location_indexer(obj):\n     location_adapter = IEventLocation(obj, None)\n-    location = getattr(location_adapter, \'location\', None)\n+    location = getattr(location_adapter, "location", None)\n     if not location:\n         raise AttributeError\n     return location\n@@ -374,16 +285,17 @@ def sync_uid_indexer(obj):\n \n # Object adapters\n \n+\n @adapter(IDXEvent)\n @implementer(IEventAccessor)\n-class EventAccessor(object):\n+class EventAccessor:\n \n     """Generic event accessor adapter implementation for Dexterity content\n-       objects.\n+    objects.\n     """\n \n     def __init__(self, context):\n-        object.__setattr__(self, \'context\', context)\n+        object.__setattr__(self, "context", context)\n \n         bm = dict(\n             start=IEventBasic,\n@@ -400,14 +312,14 @@ def __init__(self, context):\n             event_url=IEventContact,\n             subjects=ICategorization,\n         )\n-        object.__setattr__(self, \'_behavior_map\', bm)\n+        object.__setattr__(self, "_behavior_map", bm)\n \n     def __getattr__(self, name):\n         bm = self._behavior_map\n         if name in bm:  # adapt object with behavior and return the attribute\n             behavior = bm[name](self.context, None)\n             if behavior:\n-                return safe_unicode(getattr(behavior, name, None))\n+                return safe_text(getattr(behavior, name, None))\n         return None\n \n     def __setattr__(self, name, value):\n@@ -422,7 +334,7 @@ def __setattr__(self, name, value):\n             if name in bm:\n                 behavior = bm[name](self.context, None)\n                 if behavior:\n-                    setattr(behavior, name, safe_unicode(value))\n+                    setattr(behavior, name, safe_text(value))\n \n     def __delattr__(self, name):\n         bm = self._behavior_map\n@@ -439,7 +351,7 @@ def uid(self):\n \n     @property\n     def url(self):\n-        return safe_unicode(self.context.absolute_url())\n+        return safe_text(self.context.absolute_url())\n \n     @property\n     def created(self):\n@@ -461,7 +373,7 @@ def _recurrence_upcoming_event(self):\n \n     @property\n     def start(self):\n-        if getattr(self.context, \'recurrence\', None):\n+        if getattr(self.context, "recurrence", None):\n             start = self._recurrence_upcoming_event().start\n         else:\n             start = IEventBasic(self.context).start\n@@ -473,11 +385,11 @@ def start(self):\n     @start.setter\n     def start(self, value):\n         value = pydt(value)\n-        self._behavior_map[\'start\'](self.context).start = value\n+        self._behavior_map["start"](self.context).start = value\n \n     @property\n     def end(self):\n-        if getattr(self.context, \'recurrence\', None):\n+        if getattr(self.context, "recurrence", None):\n             end = self._recurrence_upcoming_event().end\n         elif self.open_end:\n             end = IEventBasic(self.context).start\n@@ -491,7 +403,7 @@ def end(self):\n     @end.setter\n     def end(self, value):\n         value = pydt(value)\n-        self._behavior_map[\'end\'](self.context).end = value\n+        self._behavior_map["end"](self.context).end = value\n \n     @property\n     def timezone(self):\n@@ -500,10 +412,10 @@ def timezone(self):\n         (START_TIMEZONENAME, END_TIMEZONENAME).\n         """\n         tz_start = tz_end = None\n-        tz = getattr(IEventBasic(self.context).start, \'tzinfo\', None)\n+        tz = getattr(IEventBasic(self.context).start, "tzinfo", None)\n         if tz:\n             tz_start = tz.zone\n-        tz = getattr(IEventBasic(self.context).end, \'tzinfo\', None)\n+        tz = getattr(IEventBasic(self.context).end, "tzinfo", None)\n         if tz:\n             tz_end = tz.zone\n         return tz_start if tz_start == tz_end else (tz_start, tz_end)\n@@ -511,12 +423,12 @@ def timezone(self):\n     @property\n     def sync_uid(self):\n         # Return externally set sync_uid or Plone\'s UUID + @domain.\n-        sync_uid = getattr(self.context, \'sync_uid\', None)\n+        sync_uid = getattr(self.context, "sync_uid", None)\n         if not sync_uid:\n             # Return internal sync_uid\n             request = getRequest() or {}\n-            domain = request.get(\'HTTP_HOST\', None)\n-            domain = \'@\' + domain if domain else \'\'\n+            domain = request.get("HTTP_HOST", None)\n+            domain = "@" + domain if domain else ""\n             sync_uid = self.uid + domain if self.uid else None\n         return sync_uid\n \n@@ -525,19 +437,19 @@ def sync_uid(self):\n \n     @property\n     def title(self):\n-        return safe_unicode(getattr(self.context, \'title\', None))\n+        return safe_text(getattr(self.context, "title", None))\n \n     @title.setter\n     def title(self, value):\n-        self.context.title = safe_unicode(value)\n+        self.context.title = safe_text(value)\n \n     @property\n     def description(self):\n-        return safe_unicode(getattr(self.context, \'description\', None))\n+        return safe_text(getattr(self.context, "description", None))\n \n     @description.setter\n     def description(self, value):\n-        self.context.description = safe_unicode(value)\n+        self.context.description = safe_text(value)\n \n     @property\n     def last_modified(self):\n@@ -551,11 +463,11 @@ def last_modified(self, value):\n \n     @property\n     def text(self):\n-        textvalue = getattr(self.context, \'text\', None)\n+        textvalue = getattr(self.context, "text", None)\n         if textvalue is None:\n-            return u\'\'\n-        return safe_unicode(textvalue.output_relative_to(self.context))\n+            return ""\n+        return safe_text(textvalue.output_relative_to(self.context))\n \n     @text.setter\n     def text(self, value):\n-        self.context.text = RichTextValue(raw=safe_unicode(value))\n+        self.context.text = RichTextValue(raw=safe_text(value))\ndiff --git a/plone/app/event/dx/interfaces.py b/plone/app/event/dx/interfaces.py\nindex 5a58804c6..fe6af56ec 100644\n--- a/plone/app/event/dx/interfaces.py\n+++ b/plone/app/event/dx/interfaces.py\n@@ -1,13 +1,10 @@\n-# -*- coding: utf-8 -*-\n from plone.event.interfaces import IEvent\n from plone.event.interfaces import IEventRecurrence\n \n \n class IDXEvent(IEvent):\n-    """ Marker interface for Dexterity events.\n-    """\n+    """Marker interface for Dexterity events."""\n \n \n class IDXEventRecurrence(IEventRecurrence):\n-    """ Marker interface for recurring Dexterity events.\n-    """\n+    """Marker interface for recurring Dexterity events."""\ndiff --git a/plone/app/event/dx/traverser.py b/plone/app/event/dx/traverser.py\nindex dc08c4d7f..553f258fe 100644\n--- a/plone/app/event/dx/traverser.py\n+++ b/plone/app/event/dx/traverser.py\n@@ -1,6 +1,5 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.event.recurrence import OccurrenceTraverser as DefaultTraverser\n from plone.app.event.dx.interfaces import IDXEventRecurrence\n+from plone.app.event.recurrence import OccurrenceTraverser as DefaultTraverser\n from plone.dexterity.browser.traversal import DexterityPublishTraverse\n from zope.component import adapter\n from zope.publisher.interfaces.browser import IBrowserRequest\n@@ -15,5 +14,6 @@ class OccurrenceTraverser(DefaultTraverser):\n     """\n \n     def fallbackTraverse(self, request, name):\n-        return DexterityPublishTraverse(\n-            self.context, request).publishTraverse(request, name)\n+        return DexterityPublishTraverse(self.context, request).publishTraverse(\n+            request, name\n+        )\ndiff --git a/plone/app/event/ical/__init__.py b/plone/app/event/ical/__init__.py\nindex 5d70fc712..50df7e310 100644\n--- a/plone/app/event/ical/__init__.py\n+++ b/plone/app/event/ical/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.ical.exporter import calendar_from_collection  # nopep8\n from plone.app.event.ical.exporter import calendar_from_container  # nopep8\n from plone.app.event.ical.exporter import calendar_from_event  # nopep8\ndiff --git a/plone/app/event/ical/exporter.py b/plone/app/event/ical/exporter.py\nindex aab1d33f0..6d4fb004a 100644\n--- a/plone/app/event/ical/exporter.py\n+++ b/plone/app/event/ical/exporter.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from datetime import datetime\n from datetime import timedelta\n@@ -37,19 +36,18 @@ def construct_icalendar(context, events):\n                    calendar.\n     """\n     cal = icalendar.Calendar()\n-    cal.add(\'prodid\', PRODID)\n-    cal.add(\'version\', VERSION)\n+    cal.add("prodid", PRODID)\n+    cal.add("version", VERSION)\n \n     cal_tz = default_timezone(context)\n     if cal_tz:\n-        cal.add(\'x-wr-timezone\', cal_tz)\n+        cal.add("x-wr-timezone", cal_tz)\n \n     tzmap = {}\n-    if not getattr(events, \'__getitem__\', False):\n+    if not getattr(events, "__getitem__", False):\n         events = [events]\n     for event in events:\n-        if ICatalogBrain.providedBy(event) or\\\n-                IContentListingObject.providedBy(event):\n+        if ICatalogBrain.providedBy(event) or IContentListingObject.providedBy(event):\n             event = event.getObject()\n         if not (IEvent.providedBy(event) or IOccurrence.providedBy(event)):\n             # Must be an event.\n@@ -59,7 +57,7 @@ def construct_icalendar(context, events):\n         # TODO: the standard wants each recurrence to have a valid timezone\n         # definition. sounds decent, but not realizable.\n         if not acc.whole_day:  # whole day events are exported as dates without\n-                               # timezone information\n+            # timezone information\n             if isinstance(tz, tuple):\n                 tz_start, tz_end = tz\n             else:\n@@ -70,20 +68,20 @@ def construct_icalendar(context, events):\n \n     for (tzid, transitions) in tzmap.items():\n         cal_tz = icalendar.Timezone()\n-        cal_tz.add(\'tzid\', tzid)\n-        cal_tz.add(\'x-lic-location\', tzid)\n+        cal_tz.add("tzid", tzid)\n+        cal_tz.add("x-lic-location", tzid)\n \n         for (transition, tzinfo) in transitions.items():\n \n-            if tzinfo[\'dst\']:\n+            if tzinfo["dst"]:\n                 cal_tz_sub = icalendar.TimezoneDaylight()\n             else:\n                 cal_tz_sub = icalendar.TimezoneStandard()\n \n-            cal_tz_sub.add(\'tzname\', tzinfo[\'name\'])\n-            cal_tz_sub.add(\'dtstart\', transition)\n-            cal_tz_sub.add(\'tzoffsetfrom\', tzinfo[\'tzoffsetfrom\'])\n-            cal_tz_sub.add(\'tzoffsetto\', tzinfo[\'tzoffsetto\'])\n+            cal_tz_sub.add("tzname", tzinfo["name"])\n+            cal_tz_sub.add("dtstart", transition)\n+            cal_tz_sub.add("tzoffsetfrom", tzinfo["tzoffsetfrom"])\n+            cal_tz_sub.add("tzoffsetto", tzinfo["tzoffsetto"])\n             # TODO: add rrule\n             # tzi.add(\'rrule\',\n             #         {\'freq\': \'yearly\', \'bymonth\': 10, \'byday\': \'-1su\'})\n@@ -111,12 +109,12 @@ def add_to_zones_map(tzmap, tzid, dt):\n     :rtype: dictionary\n     """\n \n-    if tzid.lower() == \'utc\' or not is_datetime(dt):\n+    if tzid.lower() == "utc" or not is_datetime(dt):\n         # no need to define UTC nor timezones for date objects.\n         return tzmap\n     null = datetime(1, 1, 1)\n     tz = pytz.timezone(tzid)\n-    transitions = getattr(tz, \'_utc_transition_times\', None)\n+    transitions = getattr(tz, "_utc_transition_times", None)\n     if not transitions:\n         return tzmap  # we need transition definitions\n     dtzl = tzdel(utc(dt))\n@@ -128,8 +126,7 @@ def add_to_zones_map(tzmap, tzid, dt):\n     #     datetime, which wouldn\'t create a match within the max-function. this\n     #     way we get the maximum transition time which is smaller than the\n     #     given datetime.\n-    transition = max(transitions,\n-                     key=lambda item: item if item <= dtzl else null)\n+    transition = max(transitions, key=lambda item: item if item <= dtzl else null)\n \n     # get previous transition to calculate tzoffsetfrom\n     idx = transitions.index(transition)\n@@ -142,6 +139,7 @@ def localize(tz, dt):\n             # (dt at beginning of all transitions, see above.)\n             return null\n         return pytz.utc.localize(dt).astimezone(tz)  # naive to utc + localize\n+\n     transition = localize(tz, transition)\n     dtstart = tzdel(transition)  # timezone dtstart must be in local time\n     prev_transition = localize(tz, prev_transition)\n@@ -151,10 +149,10 @@ def localize(tz, dt):\n     if dtstart in tzmap[tzid]:\n         return tzmap  # already there\n     tzmap[tzid][dtstart] = {\n-        \'dst\': transition.dst() > timedelta(0),\n-        \'name\': transition.tzname(),\n-        \'tzoffsetfrom\': prev_transition.utcoffset(),\n-        \'tzoffsetto\': transition.utcoffset(),\n+        "dst": transition.dst() > timedelta(0),\n+        "name": transition.tzname(),\n+        "tzoffsetfrom": prev_transition.utcoffset(),\n+        "tzoffsetto": transition.utcoffset(),\n         # TODO: recurrence rule\n     }\n     return tzmap\n@@ -175,9 +173,8 @@ def calendar_from_container(context):\n     Containerish context like a Folder.\n     """\n     context = aq_inner(context)\n-    path = \'/\'.join(context.getPhysicalPath())\n-    result = get_events(context, ret_mode=RET_MODE_BRAINS,\n-                        expand=False, path=path)\n+    path = "/".join(context.getPhysicalPath())\n+    result = get_events(context, ret_mode=RET_MODE_BRAINS, expand=False, path=path)\n     return construct_icalendar(context, result)\n \n \n@@ -189,14 +186,13 @@ def calendar_from_collection(context):\n     context = aq_inner(context)\n     # The keyword argument brains=False was added to plone.app.contenttypes\n     # after 1.0\n-    result = context.results(batch=False, sort_on=\'start\')\n+    result = context.results(batch=False, sort_on="start")\n     return construct_icalendar(context, result)\n \n \n @implementer(IICalendarEventComponent)\n-class ICalendarEventComponent(object):\n-    """Returns an icalendar object of the event.\n-    """\n+class ICalendarEventComponent:\n+    """Returns an icalendar object of the event."""\n \n     def __init__(self, context):\n         self.context = context\n@@ -206,33 +202,33 @@ def __init__(self, context):\n     @property\n     def dtstamp(self):\n         # must be in uc\n-        return {\'value\': utc(datetime.now())}\n+        return {"value": utc(datetime.now())}\n \n     @property\n     def created(self):\n         # must be in uc\n-        return {\'value\': utc(self.event.created)}\n+        return {"value": utc(self.event.created)}\n \n     @property\n     def last_modified(self):\n         # must be in uc\n-        return {\'value\': utc(self.event.last_modified)}\n+        return {"value": utc(self.event.last_modified)}\n \n     @property\n     def uid(self):\n-        return {\'value\': self.event.sync_uid}\n+        return {"value": self.event.sync_uid}\n \n     @property\n     def url(self):\n-        return {\'value\': self.event.url}\n+        return {"value": self.event.url}\n \n     @property\n     def summary(self):\n-        return {\'value\': self.event.title}\n+        return {"value": self.event.title}\n \n     @property\n     def description(self):\n-        return {\'value\': self.event.description}\n+        return {"value": self.event.description}\n \n     @property\n     def dtstart(self):\n@@ -242,7 +238,7 @@ def dtstart(self):\n             # specifies a "DTSTART" property with a DATE value type but no\n             # "DTEND" nor "DURATION" property, the event\'s duration is taken to\n             # be one day.\n-            return {\'value\': self.event.start.date()}\n+            return {"value": self.event.start.date()}\n \n         # Normal case + Open End case:\n         # RFC5545, 3.6.1\n@@ -250,7 +246,7 @@ def dtstart(self):\n         # specifies a "DTSTART" property with a DATE-TIME value type but no\n         # "DTEND" property, the event ends on the same calendar date and\n         # time of day specified by the "DTSTART" property.\n-        return {\'value\': self.event.start}\n+        return {"value": self.event.start}\n \n     @property\n     def dtend(self):\n@@ -273,7 +269,7 @@ def dtend(self):\n             # http://stackoverflow.com/questions/1716237/single-day-all-day-appointments-in-ics-files\n             # http://icalevents.com/1778-all-day-events-adding-a-day-or-not/\n             # http://www.innerjoin.org/iCalendar/all-day-events.html\n-            return {\'value\': self.event.end.date() + timedelta(days=1)}\n+            return {"value": self.event.end.date() + timedelta(days=1)}\n \n         elif self.event.open_end:\n             # RFC5545, 3.6.1\n@@ -283,7 +279,7 @@ def dtend(self):\n             # time of day specified by the "DTSTART" property.\n             return None\n \n-        return {\'value\': self.event.end}\n+        return {"value": self.event.end}\n \n     @property\n     def recurrence(self):\n@@ -292,14 +288,13 @@ def recurrence(self):\n \n         ret = []\n         for recdef in self.event.recurrence.split():\n-            prop, val = recdef.split(\':\')\n-            if prop == \'RRULE\':\n-                ret.append({\n-                    \'property\': prop,\n-                    \'value\': icalendar.prop.vRecur.from_ical(val)\n-                })\n-\n-            elif prop in (\'EXDATE\', \'RDATE\'):\n+            prop, val = recdef.split(":")\n+            if prop == "RRULE":\n+                ret.append(\n+                    {"property": prop, "value": icalendar.prop.vRecur.from_ical(val)}\n+                )\n+\n+            elif prop in ("EXDATE", "RDATE"):\n                 factory = icalendar.prop.vDDDLists\n \n                 # localize ex/rdate\n@@ -317,16 +312,13 @@ def recurrence(self):\n                     # TODO: REMOVE this workaround, once this failure is\n                     # fixed in recurrence widget.\n                     continue\n-                ret.append({\n-                    \'property\': prop,\n-                    \'value\': dtlist\n-                })\n+                ret.append({"property": prop, "value": dtlist})\n \n         return ret\n \n     @property\n     def location(self):\n-        return {\'value\': self.event.location}\n+        return {"value": self.event.location}\n \n     @property\n     def attendee(self):\n@@ -334,10 +326,10 @@ def attendee(self):\n         ret = []\n         for attendee in self.event.attendees or []:\n             att = icalendar.prop.vCalAddress(attendee)\n-            att.params[\'cn\'] = icalendar.prop.vText(attendee)\n-            att.params[\'ROLE\'] = icalendar.prop.vText(\'REQ-PARTICIPANT\')\n+            att.params["cn"] = icalendar.prop.vText(attendee)\n+            att.params["ROLE"] = icalendar.prop.vText("REQ-PARTICIPANT")\n             ret.append(att)\n-        return {\'value\': ret}\n+        return {"value": ret}\n \n     @property\n     def contact(self):\n@@ -352,7 +344,7 @@ def contact(self):\n         if event.event_url:\n             cn.append(event.event_url)\n \n-        return {\'value\': u\', \'.join(cn)}\n+        return {"value": ", ".join(cn)}\n \n     @property\n     def categories(self):\n@@ -360,12 +352,11 @@ def categories(self):\n         for cat in self.event.subjects or []:\n             ret.append(cat)\n         if ret:\n-            return {\'value\': ret}\n+            return {"value": ret}\n \n     @property\n     def geo(self):\n-        """Not implemented.\n-        """\n+        """Not implemented."""\n         return\n \n     def ical_add(self, prop, val):\n@@ -376,40 +367,39 @@ def ical_add(self, prop, val):\n             val = [val]\n \n         for _val in val:\n-            assert(isinstance(_val, dict))\n-            value = _val[\'value\']\n+            assert isinstance(_val, dict)\n+            value = _val["value"]\n             if not value:\n                 continue\n-            prop = _val.get(\'property\', prop)\n-            params = _val.get(\'parameters\', None)\n+            prop = _val.get("property", prop)\n+            params = _val.get("parameters", None)\n             self.ical.add(prop, value, params)\n \n     def to_ical(self):\n         # TODO: event.text\n \n         ical_add = self.ical_add\n-        ical_add(\'dtstamp\', self.dtstamp)\n-        ical_add(\'created\', self.created)\n-        ical_add(\'last-modified\', self.last_modified)\n-        ical_add(\'uid\', self.uid)\n-        ical_add(\'url\', self.url)\n-        ical_add(\'summary\', self.summary)\n-        ical_add(\'description\', self.description)\n-        ical_add(\'dtstart\', self.dtstart)\n-        ical_add(\'dtend\', self.dtend)\n+        ical_add("dtstamp", self.dtstamp)\n+        ical_add("created", self.created)\n+        ical_add("last-modified", self.last_modified)\n+        ical_add("uid", self.uid)\n+        ical_add("url", self.url)\n+        ical_add("summary", self.summary)\n+        ical_add("description", self.description)\n+        ical_add("dtstart", self.dtstart)\n+        ical_add("dtend", self.dtend)\n         ical_add(None, self.recurrence)  # property key set via val\n-        ical_add(\'location\', self.location)\n-        ical_add(\'attendee\', self.attendee)\n-        ical_add(\'contact\', self.contact)\n-        ical_add(\'categories\', self.categories)\n-        ical_add(\'geo\', self.geo)\n+        ical_add("location", self.location)\n+        ical_add("attendee", self.attendee)\n+        ical_add("contact", self.contact)\n+        ical_add("categories", self.categories)\n+        ical_add("geo", self.geo)\n \n         return self.ical\n \n \n class EventsICal(BrowserView):\n-    """Returns events in iCal format.\n-    """\n+    """Returns events in iCal format."""\n \n     def get_ical_string(self):\n         cal = IICalendar(self.context)\n@@ -417,11 +407,10 @@ def get_ical_string(self):\n \n     def __call__(self):\n         ical = self.get_ical_string()\n-        name = \'{0}.ics\'.format(self.context.getId())\n-        self.request.response.setHeader(\'Content-Type\', \'text/calendar\')\n+        name = f"{self.context.getId()}.ics"\n+        self.request.response.setHeader("Content-Type", "text/calendar")\n         self.request.response.setHeader(\n-            \'Content-Disposition\',\n-            \'attachment; filename="{0}"\'.format(name)\n+            "Content-Disposition", f\'attachment; filename="{name}"\'\n         )\n-        self.request.response.setHeader(\'Content-Length\', len(ical))\n+        self.request.response.setHeader("Content-Length", len(ical))\n         self.request.response.write(ical)\ndiff --git a/plone/app/event/ical/importer.py b/plone/app/event/ical/importer.py\nindex a6eeb71c9..022961c8a 100644\n--- a/plone/app/event/ical/importer.py\n+++ b/plone/app/event/ical/importer.py\n@@ -1,8 +1,8 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event import _\n from plone.app.event import base\n from plone.app.event.base import AnnotationAdapter\n from plone.app.event.interfaces import IICalendarImportEnabled\n+from plone.base.utils import safe_text\n from plone.event.interfaces import IEventAccessor\n from plone.event.utils import date_to_datetime\n from plone.event.utils import is_date\n@@ -12,10 +12,8 @@\n from plone.namedfile.field import NamedFile\n from plone.z3cform.layout import FormWrapper\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.utils import safe_unicode\n from Products.Five.browser import BrowserView\n from Products.statusmessages.interfaces import IStatusMessage\n-from six.moves import urllib\n from z3c.form import button\n from z3c.form import field\n from z3c.form import form\n@@ -33,28 +31,26 @@\n import datetime\n import icalendar\n import random\n-import six\n import transaction\n+import urllib\n \n \n-def ical_import(container, ics_resource, event_type,\n-                sync_strategy=base.SYNC_KEEP_NEWER):\n+def ical_import(\n+    container, ics_resource, event_type, sync_strategy=base.SYNC_KEEP_NEWER\n+):\n     cal = icalendar.Calendar.from_ical(ics_resource)\n-    events = cal.walk(\'VEVENT\')\n+    events = cal.walk("VEVENT")\n \n-    cat = getToolByName(container, \'portal_catalog\')\n-    container_path = \'/\'.join(container.getPhysicalPath())\n+    cat = getToolByName(container, "portal_catalog")\n+    container_path = "/".join(container.getPhysicalPath())\n \n     def _get_by_sync_uid(uid):\n-        return cat(\n-            sync_uid=uid,\n-            path={\'query\': container_path, \'depth\': 1}\n-        )\n+        return cat(sync_uid=uid, path={"query": container_path, "depth": 1})\n \n     def _get_prop(prop, item, default=None):\n         ret = default\n         if prop in item:\n-            ret = safe_unicode(item.decoded(prop))\n+            ret = safe_text(item.decoded(prop))\n         return ret\n \n     def _from_list(ical, prop):\n@@ -73,21 +69,21 @@ def _from_list(ical, prop):\n         # Zip multiple lines into one, since jquery.recurrenceinput.js does\n         # not support multiple lines here\n         # https://github.com/collective/jquery.recurrenceinput.js/issues/15\n-        ret = \'\'\n+        ret = ""\n         for item in val:\n-            ret = \'%s,\' % ret if ret else ret  # insert linebreak\n+            ret = "%s," % ret if ret else ret  # insert linebreak\n             ical_val = item.to_ical()\n-            if six.PY3 and isinstance(ical_val, six.binary_type):\n-                ical_val = ical_val.decode(\'utf8\')\n-            ret = \'%s%s\' % (ret, ical_val)\n-        return \'%s:%s\' % (prop, ret) if ret else None\n+            if isinstance(ical_val, bytes):\n+                ical_val = ical_val.decode("utf8")\n+            ret = f"{ret}{ical_val}"\n+        return f"{prop}:{ret}" if ret else None\n \n     count = 0\n     for item in events:\n-        start = _get_prop(\'DTSTART\', item)\n-        end = _get_prop(\'DTEND\', item)\n+        start = _get_prop("DTSTART", item)\n+        end = _get_prop("DTEND", item)\n         if not end:\n-            duration = _get_prop(\'DURATION\', item)\n+            duration = _get_prop("DURATION", item)\n             if duration:\n                 end = start + duration\n             # else: whole day or open end\n@@ -112,47 +108,47 @@ def _from_list(ical, prop):\n             # Open end event, see RFC 5545, 3.6.1\n             open_end = True\n             end = base.dt_end_of_day(date_to_datetime(start))\n-        assert(is_datetime(start))\n-        assert(is_datetime(end))\n+        assert is_datetime(start)\n+        assert is_datetime(end)\n \n         # Set timezone, if not already set\n         tz = base.default_timezone(container, as_tzinfo=True)\n-        if not getattr(start, \'tzinfo\', False):\n+        if not getattr(start, "tzinfo", False):\n             start = tz.localize(start)\n-        if not getattr(end, \'tzinfo\', False):\n+        if not getattr(end, "tzinfo", False):\n             end = tz.localize(end)\n \n-        title = _get_prop(\'SUMMARY\', item)\n-        description = _get_prop(\'DESCRIPTION\', item)\n-        location = _get_prop(\'LOCATION\', item)\n+        title = _get_prop("SUMMARY", item)\n+        description = _get_prop("DESCRIPTION", item)\n+        location = _get_prop("LOCATION", item)\n \n-        url = _get_prop(\'URL\', item)\n+        url = _get_prop("URL", item)\n \n-        rrule = _get_prop(\'RRULE\', item)\n-        rrule = rrule.to_ical() if rrule else \'\'\n+        rrule = _get_prop("RRULE", item)\n+        rrule = rrule.to_ical() if rrule else ""\n         if rrule:\n-            if six.PY3 and isinstance(rrule, six.binary_type):\n-                rrule = rrule.decode(\'utf8\')\n-            rrule = \'RRULE:%s\' % rrule\n-        rdates = _from_list(item, \'RDATE\')\n-        exdates = _from_list(item, \'EXDATE\')\n-        rrule = \'\\n\'.join([it for it in [rrule, rdates, exdates] if it])\n+            if isinstance(rrule, bytes):\n+                rrule = rrule.decode("utf8")\n+            rrule = "RRULE:%s" % rrule\n+        rdates = _from_list(item, "RDATE")\n+        exdates = _from_list(item, "EXDATE")\n+        rrule = "\\n".join([it for it in [rrule, rdates, exdates] if it])\n \n         # TODO: attendee-lists are not decoded properly and contain only\n         # vCalAddress values\n-        attendees = item.get(\'ATTENDEE\', ())\n+        attendees = item.get("ATTENDEE", ())\n \n-        contact = _get_prop(\'CONTACT\', item)\n-        categories = item.get(\'CATEGORIES\', ())\n-        if getattr(categories, \'__iter__\', False):\n-            categories = tuple([safe_unicode(it) for it in categories])\n+        contact = _get_prop("CONTACT", item)\n+        categories = item.get("CATEGORIES", ())\n+        if getattr(categories, "__iter__", False):\n+            categories = tuple(safe_text(it) for it in categories)\n \n-        ext_modified = utc(_get_prop(\'LAST-MODIFIED\', item))\n+        ext_modified = utc(_get_prop("LAST-MODIFIED", item))\n \n         content = None\n         new_content_id = None\n         existing_event = None\n-        sync_uid = _get_prop(\'UID\', item)\n+        sync_uid = _get_prop("UID", item)\n         if sync_uid and sync_strategy is not base.SYNC_NONE:\n             existing_event = _get_by_sync_uid(sync_uid)\n         if existing_event:\n@@ -163,8 +159,9 @@ def _from_list(ical, prop):\n             exist_event = existing_event[0].getObject()\n             acc = IEventAccessor(exist_event)\n \n-            if sync_strategy == base.SYNC_KEEP_NEWER and\\\n-                    (not ext_modified or acc.last_modified > ext_modified):\n+            if sync_strategy == base.SYNC_KEEP_NEWER and (\n+                not ext_modified or acc.last_modified > ext_modified\n+            ):\n                 # Update only if modified date was passed in and it is not\n                 # older than the current modified date.  The client is not\n                 # expected to update the "last-modified" property, it is the\n@@ -178,13 +175,12 @@ def _from_list(ical, prop):\n             content = exist_event\n         else:\n             new_content_id = str(random.randint(0, 99999999))\n-            container.invokeFactory(event_type,\n-                                    id=new_content_id,\n-                                    title=title,\n-                                    description=description)\n+            container.invokeFactory(\n+                event_type, id=new_content_id, title=title, description=description\n+            )\n             content = container[new_content_id]\n \n-        assert(content)  # At this point, a content must be available.\n+        assert content  # At this point, a content must be available.\n \n         event = IEventAccessor(content)\n         event.title = title\n@@ -221,7 +217,7 @@ def _from_list(ical, prop):\n \n         count += 1\n \n-    return {\'count\': count}\n+    return {"count": count}\n \n \n def no_file_protocol_url(value):\n@@ -230,65 +226,66 @@ def no_file_protocol_url(value):\n     This opens up security issues.\n     """\n     if value and value.startswith("file:"):\n-        raise Invalid(_(u"URLs with file: are not allowed."))\n+        raise Invalid(_("URLs with file: are not allowed."))\n     return True\n \n \n class IIcalendarImportSettings(Interface):\n \n     event_type = schema.Choice(\n-        title=_(\'ical_import_event_type_title\', default=u\'Event Type\'),\n+        title=_("ical_import_event_type_title", default="Event Type"),\n         description=_(\n-            \'ical_import_event_type_desc\',\n-            default=u"Content type of the event, which is created when "\n-                    u"importing icalendar resources."),\n-        vocabulary=\'plone.app.vocabularies.ReallyUserFriendlyTypes\',\n-        required=True\n+            "ical_import_event_type_desc",\n+            default="Content type of the event, which is created when "\n+            "importing icalendar resources.",\n+        ),\n+        vocabulary="plone.app.vocabularies.ReallyUserFriendlyTypes",\n+        required=True,\n     )\n \n     ical_url = schema.URI(\n-        title=_(\'ical_import_url_title\', default=u\'Icalendar URL\'),\n+        title=_("ical_import_url_title", default="Icalendar URL"),\n         description=_(\n-            \'ical_import_url_desc\',\n-            default=u"URL to an external icalendar resource file."),\n+            "ical_import_url_desc",\n+            default="URL to an external icalendar resource file.",\n+        ),\n         constraint=no_file_protocol_url,\n-        required=False\n+        required=False,\n     )\n \n     ical_file = NamedFile(\n-        title=_(\'ical_import_file_title\', default=u"Icalendar File"),\n+        title=_("ical_import_file_title", default="Icalendar File"),\n         description=_(\n-            \'ical_import_file_desc\',\n-            default=u"Icalendar resource file, if no URL is given."),\n-        required=False\n+            "ical_import_file_desc",\n+            default="Icalendar resource file, if no URL is given.",\n+        ),\n+        required=False,\n     )\n \n     sync_strategy = schema.Choice(\n-        title=_(\n-            \'ical_import_sync_strategy_title\',\n-            default=u"Synchronization Strategy"\n-        ),\n+        title=_("ical_import_sync_strategy_title", default="Synchronization Strategy"),\n         description=_(\n-            \'ical_import_sync_strategy_desc\',\n-            default=u"""Defines how to synchronize:\n+            "ical_import_sync_strategy_desc",\n+            default="""Defines how to synchronize:\n 1) "Keep newer": Import, if the imported event is modified after the existing\n    one.\n 2) "Keep mine": On conflicts, just do nothing.\n 3) "Keep theirs": On conflicts, update the existing event with the external\n    one.\n 4) "No Syncing": Don\'t synchronize but import events and create new ones, even\n-    if they already exist. For each one, create a new sync_uid."""),\n-        vocabulary=\'plone.app.event.SynchronizationStrategies\',\n+    if they already exist. For each one, create a new sync_uid.""",\n+        ),\n+        vocabulary="plone.app.event.SynchronizationStrategies",\n         required=True,\n-        default=base.SYNC_KEEP_NEWER\n+        default=base.SYNC_KEEP_NEWER,\n     )\n \n \n @adapter(IFolder)\n @implementer(IIcalendarImportSettings)\n class IcalendarImportSettings(AnnotationAdapter):\n-    """Annotation Adapter for IIcalendarImportSettings.\n-    """\n+    """Annotation Adapter for IIcalendarImportSettings."""\n+\n     ANNOTATION_KEY = "icalendar_import_settings"\n \n \n@@ -299,18 +296,18 @@ class IcalendarImportSettingsForm(form.Form):\n     def getContent(self):\n         data = {}\n         settings = IIcalendarImportSettings(self.context)\n-        data[\'event_type\'] = settings.event_type\n-        data[\'ical_url\'] = settings.ical_url\n-        data[\'sync_strategy\'] = settings.sync_strategy\n+        data["event_type"] = settings.event_type\n+        data["ical_url"] = settings.ical_url\n+        data["sync_strategy"] = settings.sync_strategy\n         return data\n \n     def save_data(self, data):\n         settings = IIcalendarImportSettings(self.context)\n-        settings.ical_url = data[\'ical_url\']\n-        settings.event_type = data[\'event_type\']\n-        settings.sync_strategy = data[\'sync_strategy\']\n+        settings.ical_url = data["ical_url"]\n+        settings.event_type = data["event_type"]\n+        settings.sync_strategy = data["sync_strategy"]\n \n-    @button.buttonAndHandler(u\'Save\')\n+    @button.buttonAndHandler("Save")\n     def handleSave(self, action):\n         data, errors = self.extractData()\n         if errors:\n@@ -319,12 +316,12 @@ def handleSave(self, action):\n         self.save_data(data)\n \n         IStatusMessage(self.request).addStatusMessage(\n-            _(\'msg_ical_import_settings_saved\',\n-              default=u"Ical import settings saved."), \'info\'\n+            _("msg_ical_import_settings_saved", default="Ical import settings saved."),\n+            "info",\n         )\n         self.request.response.redirect(self.context.absolute_url())\n \n-    @button.buttonAndHandler(u\'Save and Import\')\n+    @button.buttonAndHandler("Save and Import")\n     def handleSaveImport(self, action):\n         data, errors = self.extractData()\n         if errors:\n@@ -332,10 +329,10 @@ def handleSaveImport(self, action):\n \n         self.save_data(data)\n \n-        ical_file = data[\'ical_file\']\n-        ical_url = data[\'ical_url\']\n-        event_type = data[\'event_type\']\n-        sync_strategy = data[\'sync_strategy\']\n+        ical_file = data["ical_file"]\n+        ical_url = data["ical_url"]\n+        event_type = data["event_type"]\n+        sync_strategy = data["sync_strategy"]\n \n         if ical_file or ical_url:\n \n@@ -354,29 +351,35 @@ def handleSaveImport(self, action):\n                 sync_strategy=sync_strategy,\n             )\n \n-            count = import_metadata[\'count\']\n+            count = import_metadata["count"]\n \n             IStatusMessage(self.request).addStatusMessage(\n-                _(\'ical_import_imported\',\n-                  default=u"${num} events imported from ${filename}",\n-                  mapping={\'num\': count, \'filename\': ical_import_from}),\n-                \'info\')\n+                _(\n+                    "ical_import_imported",\n+                    default="${num} events imported from ${filename}",\n+                    mapping={"num": count, "filename": ical_import_from},\n+                ),\n+                "info",\n+            )\n \n         else:\n             IStatusMessage(self.request).addStatusMessage(\n-                _(\'ical_import_no_ics\',\n-                  default=u"Please provide either a icalendar ics file or a "\n-                          u"URL to a file."), \'error\')\n+                _(\n+                    "ical_import_no_ics",\n+                    default="Please provide either a icalendar ics file or a "\n+                    "URL to a file.",\n+                ),\n+                "error",\n+            )\n \n         self.request.response.redirect(self.context.absolute_url())\n \n-    @button.buttonAndHandler(u\'Cancel\')\n+    @button.buttonAndHandler("Cancel")\n     def handleCancel(self, action):\n         self.request.response.redirect(self.context.absolute_url())\n \n \n class IcalendarImportTool(BrowserView):\n-\n     @property\n     def available(self):\n         return IFolder.providedBy(self.context)\n@@ -394,15 +397,13 @@ class IcalendarImportSettingsFormView(FormWrapper):\n     form = IcalendarImportSettingsForm\n \n     def enable(self):\n-        """Enable icalendar import on this context.\n-        """\n+        """Enable icalendar import on this context."""\n         alsoProvides(self.context, IICalendarImportEnabled)\n-        self.context.reindexObject(idxs=(\'object_provides\'))\n+        self.context.reindexObject(idxs=("object_provides"))\n         self.request.response.redirect(self.context.absolute_url())\n \n     def disable(self):\n-        """Disable icalendar import on this context.\n-        """\n+        """Disable icalendar import on this context."""\n         noLongerProvides(self.context, IICalendarImportEnabled)\n-        self.context.reindexObject(idxs=(\'object_provides\'))\n+        self.context.reindexObject(idxs=("object_provides"))\n         self.request.response.redirect(self.context.absolute_url())\ndiff --git a/plone/app/event/interfaces.py b/plone/app/event/interfaces.py\nindex 64a1f5b19..cb9e52afb 100644\n--- a/plone/app/event/interfaces.py\n+++ b/plone/app/event/interfaces.py\n@@ -1,16 +1,13 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Interface\n from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n \n \n-ISO_DATE_FORMAT = \'%Y-%m-%d\'\n+ISO_DATE_FORMAT = "%Y-%m-%d"\n \n \n class IBrowserLayer(IDefaultBrowserLayer):\n-    """plone.app.event specific browser layer.\n-    """\n+    """plone.app.event specific browser layer."""\n \n \n class IICalendarImportEnabled(Interface):\n-    """Marker interface for contexts, where icalendar import is enabled.\n-    """\n+    """Marker interface for contexts, where icalendar import is enabled."""\ndiff --git a/plone/app/event/portlets/__init__.py b/plone/app/event/portlets/__init__.py\nindex dd39882f8..983ba273a 100644\n--- a/plone/app/event/portlets/__init__.py\n+++ b/plone/app/event/portlets/__init__.py\n@@ -1,9 +1,6 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.base import find_navroot\n from plone.app.event.base import find_ploneroot\n \n-import six\n-\n \n def get_calendar_url(context, search_base):\n     # search_base is always from the portal_root object. We won\'t include\n@@ -12,14 +9,12 @@ def get_calendar_url(context, search_base):\n     calendar_url = None\n     if search_base:\n         portal = find_ploneroot(context)\n-        if six.PY2 and isinstance(search_base, six.text_type):\n-            search_base = search_base.encode(\'utf8\')\n-        search_base = \'/\'.join(search_base.split(\'/\')[2:])\n+        search_base = "/".join(search_base.split("/")[2:])\n         calendar_url = portal.unrestrictedTraverse(\n-            search_base.lstrip(\'/\')  # start relative, first slash is omitted\n+            search_base.lstrip("/")  # start relative, first slash is omitted\n         ).absolute_url()\n     else:\n         site_url = find_navroot(context, as_url=True)\n-        calendar_url = \'%s/event_listing\' % site_url\n+        calendar_url = "%s/event_listing" % site_url\n \n     return calendar_url\ndiff --git a/plone/app/event/portlets/portlet_calendar.py b/plone/app/event/portlets/portlet_calendar.py\nindex fbf9dd600..cfd4d21d8 100644\n--- a/plone/app/event/portlets/portlet_calendar.py\n+++ b/plone/app/event/portlets/portlet_calendar.py\n@@ -1,6 +1,7 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from ComputedAttribute import ComputedAttribute\n+from plone.app.contenttypes.behaviors.collection import ISyndicatableCollection\n+from plone.app.contenttypes.interfaces import IFolder\n from plone.app.event import _\n from plone.app.event.base import _prepare_range\n from plone.app.event.base import construct_calendar\n@@ -30,45 +31,36 @@\n import json\n \n \n-try:\n-    from plone.app.contenttypes.behaviors.collection import ISyndicatableCollection as ICollection  # noqa\n-    from plone.app.contenttypes.interfaces import IFolder\n-    search_base_uid_source = CatalogSource(object_provides={\n-        \'query\': [\n-            ICollection.__identifier__,\n-            IFolder.__identifier__\n-        ],\n-        \'operator\': \'or\'\n-    })\n-except ImportError:\n-    search_base_uid_source = CatalogSource(is_folderish=True)\n-    ICollection = None\n+search_base_uid_source = CatalogSource(\n+    object_provides={\n+        "query": [ISyndicatableCollection.__identifier__, IFolder.__identifier__],\n+        "operator": "or",\n+    }\n+)\n \n-PLMF = MessageFactory(\'plonelocales\')\n+PLMF = MessageFactory("plonelocales")\n \n \n class ICalendarPortlet(IPortletDataProvider):\n-    """A portlet displaying a calendar\n-    """\n+    """A portlet displaying a calendar"""\n \n     state = schema.Tuple(\n-        title=_(u"Workflow state"),\n-        description=_(u"Items in which workflow state to show."),\n+        title=_("Workflow state"),\n+        description=_("Items in which workflow state to show."),\n         default=None,\n         required=False,\n-        value_type=schema.Choice(\n-            vocabulary="plone.app.vocabularies.WorkflowStates")\n+        value_type=schema.Choice(vocabulary="plone.app.vocabularies.WorkflowStates"),\n     )\n \n     search_base_uid = schema.Choice(\n-        title=_(u\'portlet_label_search_base\', default=u\'Search base\'),\n+        title=_("portlet_label_search_base", default="Search base"),\n         description=_(\n-            u\'portlet_help_search_base\',\n-            default=u\'Select search base Folder or Collection to search for \'\n-                    u\'events. The URL to to this item will also be used to \'\n-                    u\'link to in calendar searches. If empty, the whole site \'\n-                    u\'will be searched and the event listing view will be \'\n-                    u\'called on the site root.\'\n+            "portlet_help_search_base",\n+            default="Select search base Folder or Collection to search for "\n+            "events. The URL to to this item will also be used to "\n+            "link to in calendar searches. If empty, the whole site "\n+            "will be searched and the event listing view will be "\n+            "called on the site root.",\n         ),\n         required=False,\n         source=search_base_uid_source,\n@@ -77,7 +69,7 @@ class ICalendarPortlet(IPortletDataProvider):\n \n @implementer(ICalendarPortlet)\n class Assignment(base.Assignment):\n-    title = _(u\'Calendar\')\n+    title = _("Calendar")\n \n     # reduce upgrade pain\n     state = None\n@@ -92,15 +84,16 @@ def _uid(self):\n         # \'search_base\' attribute that needs to be converted.\n         path = self.search_base\n         try:\n-            search_base = getSite().unrestrictedTraverse(path.lstrip(\'/\'))\n+            search_base = getSite().unrestrictedTraverse(path.lstrip("/"))\n         except (AttributeError, KeyError, TypeError, NotFound):\n             return\n         return search_base.UID()\n+\n     search_base_uid = ComputedAttribute(_uid, 1)\n \n \n class Renderer(base.Renderer):\n-    render = ViewPageTemplateFile(\'portlet_calendar.pt\')\n+    render = ViewPageTemplateFile("portlet_calendar.pt")\n     _search_base = None\n \n     @property\n@@ -111,7 +104,9 @@ def search_base(self):\n \n     @property\n     def search_base_path(self):\n-        return \'/\'.join(self.search_base.getPhysicalPath()) if self.search_base else None  # noqa\n+        return (\n+            "/".join(self.search_base.getPhysicalPath()) if self.search_base else None\n+        )  # noqa\n \n     def update(self):\n         context = aq_inner(self.context)\n@@ -119,39 +114,40 @@ def update(self):\n         self.calendar_url = get_calendar_url(context, self.search_base_path)\n \n         self.year, self.month = year, month = self.year_month_display()\n-        self.prev_year, self.prev_month = prev_year, prev_month = (\n-            self.get_previous_month(year, month))\n-        self.next_year, self.next_month = next_year, next_month = (\n-            self.get_next_month(year, month))\n-        self.prev_query = \'?month=%s&year=%s\' % (prev_month, prev_year)\n-        self.next_query = \'?month=%s&year=%s\' % (next_month, next_year)\n+        self.prev_year, self.prev_month = (\n+            prev_year,\n+            prev_month,\n+        ) = self.get_previous_month(year, month)\n+        self.next_year, self.next_month = next_year, next_month = self.get_next_month(\n+            year, month\n+        )\n+        self.prev_query = f"?month={prev_month}&year={prev_year}"\n+        self.next_query = f"?month={next_month}&year={next_year}"\n \n         self.cal = calendar.Calendar(first_weekday())\n-        self._ts = getToolByName(context, \'translation_service\')\n+        self._ts = getToolByName(context, "translation_service")\n         self.month_name = PLMF(\n-            self._ts.month_msgid(month),\n-            default=self._ts.month_english(month)\n+            self._ts.month_msgid(month), default=self._ts.month_english(month)\n         )\n \n         # strftime %w interprets 0 as Sunday unlike the calendar.\n-        strftime_wkdays = [\n-            wkday_to_mon1(day) for day in self.cal.iterweekdays()\n-        ]\n+        strftime_wkdays = [wkday_to_mon1(day) for day in self.cal.iterweekdays()]\n         self.weekdays = [\n-            PLMF(self._ts.day_msgid(day, format=\'s\'),\n-                 default=self._ts.weekday_english(day, format=\'a\'))\n+            PLMF(\n+                self._ts.day_msgid(day, format="s"),\n+                default=self._ts.weekday_english(day, format="a"),\n+            )\n             for day in strftime_wkdays\n         ]\n \n     def year_month_display(self):\n-        """ Return the year and month to display in the calendar.\n-        """\n+        """Return the year and month to display in the calendar."""\n         context = aq_inner(self.context)\n         request = self.request\n \n         # Try to get year and month from request\n-        year = request.get(\'year\', None)\n-        month = request.get(\'month\', None)\n+        year = request.get("year", None)\n+        month = request.get("month", None)\n \n         # Or use current date\n         today = localized_today(context)\n@@ -184,12 +180,11 @@ def get_next_month(self, year, month):\n         return (year, month)\n \n     def date_events_url(self, date):\n-        return \'%s?mode=day&date=%s\' % (self.calendar_url, date)\n+        return f"{self.calendar_url}?mode=day&date={date}"\n \n     @property\n     def cal_data(self):\n-        """Calendar iterator over weeks and days of the month to display.\n-        """\n+        """Calendar iterator over weeks and days of the month to display."""\n         context = aq_inner(self.context)\n         today = localized_today(context)\n         year, month = self.year_month_display()\n@@ -201,22 +196,26 @@ def cal_data(self):\n         data = self.data\n         query = {}\n         if data.state:\n-            query[\'review_state\'] = data.state\n+            query["review_state"] = data.state\n \n         events = []\n-        query.update(self.request.get(\'contentFilter\', {}))\n-        if ICollection and ICollection.providedBy(self.search_base):\n+        query.update(self.request.get("contentFilter", {}))\n+        if ISyndicatableCollection and ISyndicatableCollection.providedBy(\n+            self.search_base\n+        ):\n             # Whatever sorting is defined, we\'re overriding it.\n             query = queryparser.parseFormquery(\n-                self.search_base, self.search_base.query,\n-                sort_on=\'start\', sort_order=None\n+                self.search_base,\n+                self.search_base.query,\n+                sort_on="start",\n+                sort_order=None,\n             )\n \n             # restrict start/end with those from query, if given.\n-            if \'start\' in query and query[\'start\'] > start:\n-                start = query[\'start\']\n-            if \'end\' in query and query[\'end\'] < end:\n-                end = query[\'end\']\n+            if "start" in query and query["start"] > start:\n+                start = query["start"]\n+            if "end" in query and query["end"] < end:\n+                end = query["end"]\n \n             start, end = _prepare_range(self.search_base, start, end)\n             query.update(start_end_query(start, end))\n@@ -224,16 +223,24 @@ def cal_data(self):\n                 batch=False, brains=True, custom_query=query\n             )\n             events = expand_events(\n-                events, ret_mode=RET_MODE_OBJECTS,\n-                start=start, end=end,\n-                sort=\'start\', sort_reverse=False\n+                events,\n+                ret_mode=RET_MODE_OBJECTS,\n+                start=start,\n+                end=end,\n+                sort="start",\n+                sort_reverse=False,\n             )\n         else:\n             if self.search_base_path:\n-                query[\'path\'] = {\'query\': self.search_base_path}\n-            events = get_events(context, start=start, end=end,\n-                                ret_mode=RET_MODE_OBJECTS,\n-                                expand=True, **query)\n+                query["path"] = {"query": self.search_base_path}\n+            events = get_events(\n+                context,\n+                start=start,\n+                end=end,\n+                ret_mode=RET_MODE_OBJECTS,\n+                expand=True,\n+                **query,\n+            )\n \n         cal_dict = construct_calendar(events, start=start, end=end)\n \n@@ -253,29 +260,31 @@ def cal_data(self):\n                     accessor = IEventAccessor(occ)\n                     location = accessor.location\n                     whole_day = accessor.whole_day\n-                    time = accessor.start.time().strftime(\'%H:%M\')\n+                    time = accessor.start.time().strftime("%H:%M")\n                     # TODO: make 24/12 hr format configurable\n                     events_string_list.append(\n-                        u\'{0}{1}{2}{3}\'.format(\n+                        "{}{}{}{}".format(\n                             accessor.title,\n-                            u\' {0}\'.format(time) if not whole_day else u\'\',\n-                            u\', \' if not whole_day and location else u\'\',\n-                            u\' {0}\'.format(location) if location else u\'\'\n+                            f" {time}" if not whole_day else "",\n+                            ", " if not whole_day and location else "",\n+                            f" {location}" if location else "",\n                         )\n                     )\n \n             caldata[-1].append(\n-                {\'date\': dat,\n-                 \'day\': dat.day,\n-                 \'prev_month\': dat.month < month,\n-                 \'next_month\': dat.month > month,\n-                 \'today\':\n-                    dat.year == today.year and\n-                    dat.month == today.month and\n-                    dat.day == today.day,\n-                 \'date_string\': u"%s-%s-%s" % (dat.year, dat.month, dat.day),\n-                 \'events_string\': u\' | \'.join(events_string_list),\n-                 \'events\': date_events})\n+                {\n+                    "date": dat,\n+                    "day": dat.day,\n+                    "prev_month": dat.month < month,\n+                    "next_month": dat.month > month,\n+                    "today": dat.year == today.year\n+                    and dat.month == today.month\n+                    and dat.day == today.day,\n+                    "date_string": f"{dat.year}-{dat.month}-{dat.day}",\n+                    "events_string": " | ".join(events_string_list),\n+                    "events": date_events,\n+                }\n+            )\n         return caldata\n \n     def nav_pattern_options(self, year, month):\n@@ -283,34 +292,34 @@ def nav_pattern_options(self, year, month):\n         if isinstance(val, bytes):\n             val = val.decode("utf-8")\n \n-        return json.dumps({\n-            \'url\': \'%s/@@render-portlet?portlethash=%s&year=%s&month=%s\' % (\n-                getSite().absolute_url(),\n-                val,\n-                year, month),\n-            \'target\': \'#portletwrapper-%s > *\' % val\n-        })\n+        return json.dumps(\n+            {\n+                "url": "%s/@@render-portlet?portlethash=%s&year=%s&month=%s"\n+                % (getSite().absolute_url(), val, year, month),\n+                "target": "#portletwrapper-%s > *" % val,\n+            }\n+        )\n \n     @property\n     def hash(self):\n         return self.request.form.get(\n-            \'portlethash\',\n-            getattr(self, \'__portlet_metadata__\', {}).get(\'hash\', \'\'))\n+            "portlethash", getattr(self, "__portlet_metadata__", {}).get("hash", "")\n+        )\n \n \n class AddForm(base.AddForm):\n     schema = ICalendarPortlet\n-    label = _(u"Add Calendar Portlet")\n-    description = _(u"This portlet displays events in a calendar.")\n+    label = _("Add Calendar Portlet")\n+    description = _("This portlet displays events in a calendar.")\n \n     def create(self, data):\n         return Assignment(\n-            state=data.get(\'state\', None),\n-            search_base_uid=data.get(\'search_base_uid\', None)\n+            state=data.get("state", None),\n+            search_base_uid=data.get("search_base_uid", None),\n         )\n \n \n class EditForm(base.EditForm):\n     schema = ICalendarPortlet\n-    label = _(u"Edit Calendar Portlet")\n-    description = _(u"This portlet displays events in a calendar.")\n+    label = _("Edit Calendar Portlet")\n+    description = _("This portlet displays events in a calendar.")\ndiff --git a/plone/app/event/portlets/portlet_events.py b/plone/app/event/portlets/portlet_events.py\nindex fe902e3a2..ed7f3bf66 100644\n--- a/plone/app/event/portlets/portlet_events.py\n+++ b/plone/app/event/portlets/portlet_events.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from ComputedAttribute import ComputedAttribute\n from plone.app.event import _\n@@ -9,15 +8,15 @@\n from plone.app.event.base import RET_MODE_ACCESSORS\n from plone.app.event.base import start_end_query\n from plone.app.event.portlets import get_calendar_url\n-from plone.app.event.portlets.portlet_calendar import ICollection\n+from plone.app.event.portlets.portlet_calendar import ISyndicatableCollection\n from plone.app.event.portlets.portlet_calendar import search_base_uid_source\n from plone.app.portlets.portlets import base\n from plone.app.querystring import queryparser\n from plone.app.uuid.utils import uuidToObject\n+from plone.base.interfaces.controlpanel import ISiteSchema\n from plone.memoize.compress import xhtml_compress\n from plone.portlets.interfaces import IPortletDataProvider\n from plone.registry.interfaces import IRegistry\n-from Products.CMFPlone.interfaces.controlpanel import ISiteSchema\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n from zExceptions import NotFound\n from zope import schema\n@@ -31,53 +30,52 @@\n class IEventsPortlet(IPortletDataProvider):\n \n     count = schema.Int(\n-        title=_(u\'Number of items to display\'),\n-        description=_(u\'How many items to list.\'),\n+        title=_("Number of items to display"),\n+        description=_("How many items to list."),\n         required=True,\n         default=5,\n         min=1,\n     )\n \n     state = schema.Tuple(\n-        title=_(u"Workflow state"),\n-        description=_(u"Items in which workflow state to show."),\n+        title=_("Workflow state"),\n+        description=_("Items in which workflow state to show."),\n         default=None,\n         required=False,\n-        value_type=schema.Choice(\n-            vocabulary="plone.app.vocabularies.WorkflowStates"\n-        )\n+        value_type=schema.Choice(vocabulary="plone.app.vocabularies.WorkflowStates"),\n     )\n \n     search_base_uid = schema.Choice(\n-        title=_(u\'portlet_label_search_base\', default=u\'Search base\'),\n+        title=_("portlet_label_search_base", default="Search base"),\n         description=_(\n-            u\'portlet_help_search_base\',\n-            default=u\'Select search base Folder or Collection to search for \'\n-                    u\'events. The URL to to this item will also be used to \'\n-                    u\'link to in calendar searches. If empty, the whole site \'\n-                    u\'will be searched and the event listing view will be \'\n-                    u\'called on the site root.\'\n+            "portlet_help_search_base",\n+            default="Select search base Folder or Collection to search for "\n+            "events. The URL to to this item will also be used to "\n+            "link to in calendar searches. If empty, the whole site "\n+            "will be searched and the event listing view will be "\n+            "called on the site root.",\n         ),\n         required=False,\n         source=search_base_uid_source,\n     )\n     thumb_scale = schema.TextLine(\n-        title=_(u"Override thumb scale"),\n+        title=_("Override thumb scale"),\n         description=_(\n-            u"Enter a valid scale name"\n-            u" (see \'Image Handling\' control panel) to override"\n-            u" (e.g. icon, tile, thumb, mini, preview, ... )."\n-            u" Leave empty to use default (see \'Site\' control panel)."\n+            "Enter a valid scale name"\n+            " (see \'Image Handling\' control panel) to override"\n+            " (e.g. icon, tile, thumb, mini, preview, ... )."\n+            " Leave empty to use default (see \'Site\' control panel)."\n         ),\n         required=False,\n-        default=u\'\')\n+        default="",\n+    )\n \n     no_thumbs = schema.Bool(\n-        title=_(u"Suppress thumbs"),\n-        description=_(\n-            u"If enabled, the portlet will not show thumbs."),\n+        title=_("Suppress thumbs"),\n+        description=_("If enabled, the portlet will not show thumbs."),\n         required=False,\n-        default=False)\n+        default=False,\n+    )\n \n \n @implementer(IEventsPortlet)\n@@ -87,8 +85,14 @@ class Assignment(base.Assignment):\n     thumb_scale = None\n     no_thumbs = False\n \n-    def __init__(self, count=5, state=None, search_base_uid=None,\n-                 thumb_scale=None, no_thumbs=False):\n+    def __init__(\n+        self,\n+        count=5,\n+        state=None,\n+        search_base_uid=None,\n+        thumb_scale=None,\n+        no_thumbs=False,\n+    ):\n         self.count = count\n         self.state = state\n         self.search_base_uid = search_base_uid\n@@ -97,7 +101,7 @@ def __init__(self, count=5, state=None, search_base_uid=None,\n \n     @property\n     def title(self):\n-        return _(u"Events")\n+        return _("Events")\n \n     def _uid(self):\n         # This is only called if the instance doesn\'t have a search_base_uid\n@@ -105,16 +109,17 @@ def _uid(self):\n         # \'search_base\' attribute that needs to be converted.\n         path = self.search_base\n         try:\n-            search_base = getSite().unrestrictedTraverse(path.lstrip(\'/\'))\n+            search_base = getSite().unrestrictedTraverse(path.lstrip("/"))\n         except (AttributeError, KeyError, TypeError, NotFound):\n             return\n         return search_base.UID()\n+\n     search_base_uid = ComputedAttribute(_uid, 1)\n \n \n class Renderer(base.Renderer):\n \n-    _template = ViewPageTemplateFile(\'portlet_events.pt\')\n+    _template = ViewPageTemplateFile("portlet_events.pt")\n     _search_base = None\n \n     @property\n@@ -125,13 +130,15 @@ def search_base(self):\n \n     @property\n     def search_base_path(self):\n-        return \'/\'.join(self.search_base.getPhysicalPath()) if self.search_base else None  # noqa\n+        return (\n+            "/".join(self.search_base.getPhysicalPath()) if self.search_base else None\n+        )  # noqa\n \n     def update(self):\n         context = aq_inner(self.context)\n         calendar_url = get_calendar_url(context, self.search_base_path)\n-        self.next_url = \'%s?mode=future\' % calendar_url\n-        self.prev_url = \'%s?mode=past\' % calendar_url\n+        self.next_url = "%s?mode=future" % calendar_url\n+        self.prev_url = "%s?mode=past" % calendar_url\n \n     def render(self):\n         return xhtml_compress(self._template())\n@@ -147,54 +154,60 @@ def events(self):\n \n         query = {}\n         if data.state:\n-            query[\'review_state\'] = data.state\n+            query["review_state"] = data.state\n \n         events = []\n-        query.update(self.request.get(\'contentFilter\', {}))\n-        if ICollection and ICollection.providedBy(self.search_base):\n+        query.update(self.request.get("contentFilter", {}))\n+        if ISyndicatableCollection.providedBy(self.search_base):\n             # Whatever sorting is defined, we\'re overriding it.\n             query = queryparser.parseFormquery(\n-                self.search_base, self.search_base.query,\n-                sort_on=\'start\', sort_order=None\n+                self.search_base,\n+                self.search_base.query,\n+                sort_on="start",\n+                sort_order=None,\n             )\n \n             start = None\n-            if \'start\' in query:\n-                start = query[\'start\']\n+            if "start" in query:\n+                start = query["start"]\n             else:\n                 start = localized_now(context)\n \n             end = None\n-            if \'end\' in query:\n-                end = query[\'end\']\n+            if "end" in query:\n+                end = query["end"]\n \n             start, end = _prepare_range(self.search_base, start, end)\n             query.update(start_end_query(start, end))\n             events = self.search_base.results(\n-                batch=False, brains=True, custom_query=query,\n-                limit=data.count\n+                batch=False, brains=True, custom_query=query, limit=data.count\n             )\n             events = expand_events(\n-                events, ret_mode=RET_MODE_ACCESSORS,\n-                start=start, end=end,\n-                sort=\'start\', sort_reverse=False\n+                events,\n+                ret_mode=RET_MODE_ACCESSORS,\n+                start=start,\n+                end=end,\n+                sort="start",\n+                sort_reverse=False,\n             )\n-            events = events[:data.count]  # limit expanded\n+            events = events[: data.count]  # limit expanded\n         else:\n             if self.search_base_path:\n-                query[\'path\'] = {\'query\': self.search_base_path}\n+                query["path"] = {"query": self.search_base_path}\n             events = get_events(\n-                context, start=localized_now(context),\n+                context,\n+                start=localized_now(context),\n                 ret_mode=RET_MODE_ACCESSORS,\n-                expand=True, limit=data.count, **query\n+                expand=True,\n+                limit=data.count,\n+                **query\n             )\n \n         return events\n \n     def formatted_date(self, event):\n         provider = getMultiAdapter(\n-            (self.context, self.request, self),\n-            IContentProvider, name=\'formatted_date\'\n+            (self.context, self.request, self), IContentProvider, name="formatted_date"\n         )\n         return provider(event)\n \n@@ -203,15 +216,14 @@ def thumb_scale(self):\n         Image sizes must fit to value in allowed image sizes.\n         None will suppress thumb.\n         """\n-        if getattr(self.data, \'no_thumbs\', False):\n+        if getattr(self.data, "no_thumbs", False):\n             # Individual setting overrides ...\n             return None\n-        thsize = getattr(self.data, \'thumb_scale\', None)\n+        thsize = getattr(self.data, "thumb_scale", None)\n         if thsize:\n             return thsize\n         registry = getUtility(IRegistry)\n-        settings = registry.forInterface(\n-            ISiteSchema, prefix="plone", check=False)\n+        settings = registry.forInterface(ISiteSchema, prefix="plone", check=False)\n         if settings.no_thumbs_portlet:\n             return None\n         thumb_scale_portlet = settings.thumb_scale_portlet\n@@ -220,16 +232,18 @@ def thumb_scale(self):\n \n class AddForm(base.AddForm):\n     schema = IEventsPortlet\n-    label = _(u"Add Events Portlet")\n-    description = _(u"This portlet lists upcoming Events.")\n+    label = _("Add Events Portlet")\n+    description = _("This portlet lists upcoming Events.")\n \n     def create(self, data):\n-        return Assignment(count=data.get(\'count\', 5),\n-                          state=data.get(\'state\', None),\n-                          search_base_uid=data.get(\'search_base_uid\', None))\n+        return Assignment(\n+            count=data.get("count", 5),\n+            state=data.get("state", None),\n+            search_base_uid=data.get("search_base_uid", None),\n+        )\n \n \n class EditForm(base.EditForm):\n     schema = IEventsPortlet\n-    label = _(u"Edit Events Portlet")\n-    description = _(u"This portlet lists upcoming Events.")\n+    label = _("Edit Events Portlet")\n+    description = _("This portlet lists upcoming Events.")\ndiff --git a/plone/app/event/recurrence.py b/plone/app/event/recurrence.py\nindex 4ca742e53..d6bfc216a 100644\n--- a/plone/app/event/recurrence.py\n+++ b/plone/app/event/recurrence.py\n@@ -1,8 +1,8 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_parent\n from OFS.SimpleItem import SimpleItem\n from plone.app.event.base import dt_start_of_day\n from plone.app.event.base import guess_date_from\n+from plone.base.utils import safe_text\n from plone.event.interfaces import IEventAccessor\n from plone.event.interfaces import IEventRecurrence\n from plone.event.interfaces import IOccurrence\n@@ -12,26 +12,19 @@\n from plone.event.utils import pydt\n from plone.namedfile.interfaces import IImageScaleTraversable\n from plone.namedfile.scaling import ImageScaling\n-from Products.CMFPlone.utils import safe_unicode\n from Products.Five.browser import BrowserView\n from zope.component import adapter\n from zope.interface import implementer\n from zope.publisher.interfaces.browser import IBrowserRequest\n+from ZPublisher.BaseRequest import DefaultPublishTraverse\n \n import datetime\n \n \n-try:\n-    from repoze.zope2.publishtraverse import DefaultPublishTraverse\n-except ImportError:\n-    from ZPublisher.BaseRequest import DefaultPublishTraverse\n-\n-\n @adapter(IEventRecurrence)\n @implementer(IRecurrenceSupport)\n-class RecurrenceSupport(object):\n-    """IRecurrenceSupport Adapter.\n-    """\n+class RecurrenceSupport:\n+    """IRecurrenceSupport Adapter."""\n \n     def __init__(self, context):\n         self.context = context\n@@ -60,26 +53,28 @@ def occurrences(self, range_start=None, range_end=None):\n         event = IEventAccessor(self.context)\n \n         # We try to get IEventBasic start without including recurrence\n-        event_start = getattr(self.context, \'start\', None)\n+        event_start = getattr(self.context, "start", None)\n         if not event_start:\n             event_start = event.start\n-        elif getattr(event, \'whole_day\', None):\n+        elif getattr(event, "whole_day", None):\n             event_start = dt_start_of_day(event_start)\n \n         # We get event ends by adding a duration to the start. This way, we\n         # prevent that the start and end lists are of different size if an\n         # event starts before range_start but ends afterwards.\n-        if (getattr(event, \'whole_day\', None) or\n-            getattr(event, \'open_end\', None)):\n+        if getattr(event, "whole_day", None) or getattr(event, "open_end", None):\n             duration = datetime.timedelta(hours=23, minutes=59, seconds=59)\n         else:\n-            event_end = getattr(self.context, \'end\', None)\n+            event_end = getattr(self.context, "end", None)\n             duration = event_end - event_start\n \n-        starts = recurrence_sequence_ical(event_start,\n-                                          recrule=event.recurrence,\n-                                          from_=range_start, until=range_end,\n-                                          duration=duration)\n+        starts = recurrence_sequence_ical(\n+            event_start,\n+            recrule=event.recurrence,\n+            from_=range_start,\n+            until=range_end,\n+            duration=duration,\n+        )\n \n         # XXX potentially occurrence won\'t need to be wrapped anymore\n         # but doing it for backwards compatibility as views/templates\n@@ -93,9 +88,8 @@ def get_obj(start):\n                 # remove it for a valid comparison.\n                 return self.context\n             return Occurrence(\n-                id=str(start.date()),\n-                start=start,\n-                end=start + duration).__of__(self.context)\n+                id=str(start.date()), start=start, end=start + duration\n+            ).__of__(self.context)\n \n         for start in starts:\n             yield get_obj(start)\n@@ -124,7 +118,7 @@ def publishTraverse(self, request, name):\n         return self.fallbackTraverse(request, name)\n \n     def fallbackTraverse(self, request, name):\n-        return super(OccurrenceTraverser, self).publishTraverse(request, name)\n+        return super().publishTraverse(request, name)\n \n \n @implementer(IOccurrence)\n@@ -137,20 +131,19 @@ def __init__(self, id, start, end):\n         self.id = id\n         self.start = start\n         self.end = end\n-        self.portal_type = \'Occurrence\'\n+        self.portal_type = "Occurrence"\n \n \n @adapter(IOccurrence)\n @implementer(IEventAccessor)\n-class EventOccurrenceAccessor(object):\n-    """Generic event accessor adapter implementation for Occurrence objects.\n-    """\n+class EventOccurrenceAccessor:\n+    """Generic event accessor adapter implementation for Occurrence objects."""\n \n     def __init__(self, context):\n-        object.__setattr__(self, \'context\', context)\n+        object.__setattr__(self, "context", context)\n \n-        own_attr = [\'start\', \'end\', \'url\']\n-        object.__setattr__(self, \'_own_attr\', own_attr)\n+        own_attr = ["start", "end", "url"]\n+        object.__setattr__(self, "_own_attr", own_attr)\n \n     def _get_context(self, name):\n         # TODO: save parent context on self, so it must not be called every\n@@ -176,13 +169,14 @@ def __delattr__(self, name):\n \n     @property\n     def url(self):\n-        return safe_unicode(self.context.absolute_url())\n+        return safe_text(self.context.absolute_url())\n \n \n class ImageScalingViewFactory(BrowserView):\n     """Factory for ImageScaling view for Occurrences.\n     Delegates to parent @@images view.\n     """\n+\n     def __new__(cls, context, request):\n         parent = aq_parent(context)\n         if IImageScaleTraversable.providedBy(parent):\ndiff --git a/plone/app/event/setuphandlers.py b/plone/app/event/setuphandlers.py\nindex 5d4be5c9c..fffa14684 100644\n--- a/plone/app/event/setuphandlers.py\n+++ b/plone/app/event/setuphandlers.py\n@@ -1,6 +1,5 @@\n-# -*- coding: utf-8 -*-\n+from plone.base.interfaces import INonInstallable\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.interfaces import INonInstallable\n from Products.ZCatalog.Catalog import CatalogError\n from zope.interface import implementer\n \n@@ -11,8 +10,7 @@\n \n \n @implementer(INonInstallable)\n-class HiddenProfiles(object):\n-\n+class HiddenProfiles:\n     def getNonInstallableProfiles(self):\n         """Prevents profiles, which should not be user-installable from showing\n         up in the profile list when creating a Plone site.\n@@ -20,7 +18,9 @@ def getNonInstallableProfiles(self):\n         plone.app.event:testing .. Testing profile, which provides an\n         example type.\n         """\n-        return [u\'plone.app.event:testing\', ]\n+        return [\n+            "plone.app.event:testing",\n+        ]\n \n \n def setup_catalog(context):\n@@ -34,35 +34,35 @@ def setup_catalog(context):\n         emptying-the-indexes-td2302709.html\n         https://mail.zope.org/pipermail/zope-cmf/2007-March/025664.html\n     """\n-    if context.readDataFile(\'plone.app.event-default.txt\') is None:\n+    if context.readDataFile("plone.app.event-default.txt") is None:\n         return\n     portal = context.getSite()\n-    catalog = getToolByName(portal, \'portal_catalog\')\n-    date_idxs = [\'start\', \'end\']\n-    field_idxs = [\'sync_uid\']\n+    catalog = getToolByName(portal, "portal_catalog")\n+    date_idxs = ["start", "end"]\n+    field_idxs = ["sync_uid"]\n     idxs = date_idxs + field_idxs\n \n-    class extra(object):\n-        recurdef = \'recurrence\'\n-        until = \'\'\n+    class extra:\n+        recurdef = "recurrence"\n+        until = ""\n \n     _catalog = catalog._catalog\n     for name in idxs:\n         if name in catalog.indexes():\n-            if _catalog.getIndex(name).meta_type == \'DateIndex\':\n+            if _catalog.getIndex(name).meta_type == "DateIndex":\n                 # delete old standard DateIndex\n                 catalog.delIndex(name)\n-                logger.info(\'Old catalog DateIndex %s deleted.\' % name)\n+                logger.info("Old catalog DateIndex %s deleted." % name)\n         if name not in catalog.indexes():\n             if name in date_idxs:\n                 # create new DateRecurringIndex\n-                catalog.addIndex(name, \'DateRecurringIndex\', extra=extra())\n-                logger.info(\'Catalog DateRecurringIndex %s created.\' % name)\n+                catalog.addIndex(name, "DateRecurringIndex", extra=extra())\n+                logger.info("Catalog DateRecurringIndex %s created." % name)\n             elif name in field_idxs:\n-                catalog.addIndex(name, \'FieldIndex\')\n-                logger.info(\'Catalog FieldIndex %s created.\' % name)\n+                catalog.addIndex(name, "FieldIndex")\n+                logger.info("Catalog FieldIndex %s created." % name)\n         try:\n             catalog.addColumn(name)\n-            logger.info(\'Catalog metadata column %s created.\' % name)\n+            logger.info("Catalog metadata column %s created." % name)\n         except CatalogError:\n-            logger.info(\'Catalog metadata column %s already exists.\' % name)\n+            logger.info("Catalog metadata column %s already exists." % name)\ndiff --git a/plone/app/event/testing.py b/plone/app/event/testing.py\nindex 4c60b4d47..a0a1e438e 100644\n--- a/plone/app/event/testing.py\n+++ b/plone/app/event/testing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.interfaces import IBrowserLayer\n from plone.app.robotframework.testing import AUTOLOGIN_LIBRARY_FIXTURE\n from plone.app.testing import FunctionalTesting\n@@ -6,22 +5,14 @@\n from plone.app.testing import PLONE_FIXTURE\n from plone.app.testing import PloneSandboxLayer\n from plone.registry.interfaces import IRegistry\n+from plone.testing.zope import installProduct\n+from plone.testing.zope import uninstallProduct\n+from plone.testing.zope import WSGI_SERVER_FIXTURE\n from zope.component import getUtility\n from zope.interface import alsoProvides\n \n import os\n \n-try:\n-    # plone.testing 7+, Plone 5.2+\n-    from plone.testing.zope import WSGI_SERVER_FIXTURE\n-    from plone.testing.zope import installProduct\n-    from plone.testing.zope import uninstallProduct\n-except ImportError:\n-    # plone.testing 6-, Plone 5.1\n-    from plone.testing.z2 import ZSERVER_FIXTURE as WSGI_SERVER_FIXTURE\n-    from plone.testing.z2 import installProduct\n-    from plone.testing.z2 import uninstallProduct\n-\n \n def set_browserlayer(request):\n     """Set the BrowserLayer for the request.\n@@ -37,22 +28,22 @@ def set_timezone(tz):\n     if tz is None:\n         return None\n     reg = getUtility(IRegistry)\n-    current_tz = reg.get(\'plone.portal_timezone\', None)\n-    reg[\'plone.portal_timezone\'] = tz\n+    current_tz = reg.get("plone.portal_timezone", None)\n+    reg["plone.portal_timezone"] = tz\n     return current_tz\n \n \n def set_env_timezone(tz):\n     if tz is None:\n-        os.environ.pop(\'TZ\')\n+        os.environ.pop("TZ")\n         return None\n-    current_tz = os.environ.get(\'TZ\', None)\n-    os.environ[\'TZ\'] = tz\n+    current_tz = os.environ.get("TZ", None)\n+    os.environ["TZ"] = tz\n     return current_tz\n \n \n def os_zone():\n-    return os.environ[\'TZ\'] if \'TZ\' in os.environ.keys() else None\n+    return os.environ["TZ"] if "TZ" in os.environ.keys() else None\n \n \n def make_fake_response(request):\n@@ -60,7 +51,7 @@ def make_fake_response(request):\n     headers = {}\n     output = []\n \n-    class Response(object):\n+    class Response:\n         def setHeader(self, header, value):\n             headers[header] = value\n \n@@ -79,31 +70,32 @@ def setUpZope(self, app, configurationContext):\n         self.ostz = os_zone()\n \n         # Install products that use an old-style initialize() function\n-        installProduct(app, \'Products.DateRecurringIndex\')\n+        installProduct(app, "Products.DateRecurringIndex")\n \n         # Load ZCML\n         import plone.app.event\n+\n         self.loadZCML(package=plone.app.event, context=configurationContext)\n \n     def setUpPloneSite(self, portal):\n-        self.applyProfile(portal, \'plone.app.event:default\')\n-        set_timezone(tz=\'UTC\')\n+        self.applyProfile(portal, "plone.app.event:default")\n+        set_timezone(tz="UTC")\n \n     def tearDownZope(self, app):\n         # Uninstall old-style Products\n-        uninstallProduct(app, \'Products.DateRecurringIndex\')\n+        uninstallProduct(app, "Products.DateRecurringIndex")\n \n         # reset OS TZ\n         if self.ostz:\n-            os.environ[\'TZ\'] = self.ostz\n-        elif \'TZ\' in os.environ:\n-            del os.environ[\'TZ\']\n+            os.environ["TZ"] = self.ostz\n+        elif "TZ" in os.environ:\n+            del os.environ["TZ"]\n \n \n PAEvent_FIXTURE = PAEventLayer()\n PAEvent_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(PAEvent_FIXTURE,),\n-    name="PAEvent:Integration")\n+    bases=(PAEvent_FIXTURE,), name="PAEvent:Integration"\n+)\n \n \n class PAEventDXLayer(PloneSandboxLayer):\n@@ -113,26 +105,27 @@ class PAEventDXLayer(PloneSandboxLayer):\n     def setUpZope(self, app, configurationContext):\n         self.ostz = os_zone()\n         import plone.app.event.dx\n-        self.loadZCML(package=plone.app.event.dx,\n-                      context=configurationContext)\n+\n+        self.loadZCML(package=plone.app.event.dx, context=configurationContext)\n \n     def setUpPloneSite(self, portal):\n-        self.applyProfile(portal, \'plone.app.event:testing\')\n-        set_timezone(tz=\'UTC\')\n+        self.applyProfile(portal, "plone.app.event:testing")\n+        set_timezone(tz="UTC")\n \n \n PAEventDX_FIXTURE = PAEventDXLayer()\n PAEventDX_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(PAEventDX_FIXTURE,),\n-    name="PAEventDX:Integration")\n+    bases=(PAEventDX_FIXTURE,), name="PAEventDX:Integration"\n+)\n # Functional testing needed for tests, with explicit transaction commits.\n PAEventDX_FUNCTIONAL_TESTING = FunctionalTesting(\n-    bases=(PAEventDX_FIXTURE,),\n-    name="PAEventDX:Functional")\n+    bases=(PAEventDX_FIXTURE,), name="PAEventDX:Functional"\n+)\n PAEventDX_ROBOT_TESTING = FunctionalTesting(\n     bases=(\n         PAEventDX_FIXTURE,\n         AUTOLOGIN_LIBRARY_FIXTURE,\n         WSGI_SERVER_FIXTURE,\n     ),\n-    name="plone.app.event.dx:Robot")\n+    name="plone.app.event.dx:Robot",\n+)\ndiff --git a/plone/app/event/tests/INACTIVE_test_robot.py b/plone/app/event/tests/INACTIVE_test_robot.py\nindex f155d5b2a..83e5c391d 100644\n--- a/plone/app/event/tests/INACTIVE_test_robot.py\n+++ b/plone/app/event/tests/INACTIVE_test_robot.py\n@@ -1,32 +1,31 @@\n # -*- conding: utf-8 -*-\n-import os\n-import robotsuite\n-import unittest\n-\n from plone.app.event.testing import PAEventDX_ROBOT_TESTING\n from plone.app.testing import ROBOT_TEST_LEVEL\n from plone.testing import layered\n \n+import os\n+import robotsuite\n+import unittest\n+\n \n def test_suite():\n     suite = unittest.TestSuite()\n     current_dir = os.path.abspath(os.path.dirname(__file__))\n-    robot_dir = os.path.join(current_dir, \'robot\')\n+    robot_dir = os.path.join(current_dir, "robot")\n     robot_tests = [\n-        os.path.join(\'robot\', doc) for doc in\n-        os.listdir(robot_dir) if doc.endswith(\'.robot\')\n-        and doc.startswith(\'test_\')\n+        os.path.join("robot", doc)\n+        for doc in os.listdir(robot_dir)\n+        if doc.endswith(".robot") and doc.startswith("test_")\n     ]\n     for robot_test in robot_tests:\n         robottestsuite = robotsuite.RobotTestSuite(\n             robot_test,\n-            noncritical=[\'unstable\'],\n+            noncritical=["unstable"],\n         )\n         robottestsuite.level = ROBOT_TEST_LEVEL\n-        suite.addTests([\n-            layered(\n-                robottestsuite,\n-                layer=PAEventDX_ROBOT_TESTING\n-            ),\n-        ])\n+        suite.addTests(\n+            [\n+                layered(robottestsuite, layer=PAEventDX_ROBOT_TESTING),\n+            ]\n+        )\n     return suite\ndiff --git a/plone/app/event/tests/__init__.py b/plone/app/event/tests/__init__.py\nindex 40a96afc6..e69de29bb 100644\n--- a/plone/app/event/tests/__init__.py\n+++ b/plone/app/event/tests/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/event/tests/base_setup.py b/plone/app/event/tests/base_setup.py\nindex 5958bcb44..c3f70d14b 100644\n--- a/plone/app/event/tests/base_setup.py\n+++ b/plone/app/event/tests/base_setup.py\n@@ -1,25 +1,23 @@\n-# -*- coding: utf-8 -*-\n-from Products.CMFCore.utils import getToolByName\n from datetime import datetime\n from datetime import timedelta\n from plone.app.event.dx import behaviors\n from plone.app.event.testing import set_browserlayer\n from plone.app.event.testing import set_timezone\n-from plone.app.testing import TEST_USER_ID\n from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n from plone.app.textfield.value import RichTextValue\n from plone.dexterity.utils import createContentInContainer\n+from Products.CMFCore.utils import getToolByName\n \n import pytz\n import unittest\n \n \n-TEST_TIMEZONE = \'Europe/Vienna\'\n+TEST_TIMEZONE = "Europe/Vienna"\n \n \n def patched_now(context=None):\n-    """Patch localized_now to allow stable results in tests.\n-    """\n+    """Patch localized_now to allow stable results in tests."""\n     if not context:\n         context = None\n     tzinfo = pytz.timezone(TEST_TIMEZONE)\n@@ -30,7 +28,7 @@ def patched_now(context=None):\n \n # Patch EventAccessor for IDXEvent to set the correct testing portal type.\n # For custom accessor in addons you would rather do that in an adapter.\n-behaviors.EventAccessor.event_type = \'plone.app.event.dx.event\'\n+behaviors.EventAccessor.event_type = "plone.app.event.dx.event"\n \n \n class AbstractSampleDataEvents(unittest.TestCase):\n@@ -38,11 +36,7 @@ class AbstractSampleDataEvents(unittest.TestCase):\n \n     def event_factory(self, container, **kwargs):\n         # Return the IEventAccessor.create event factory.\n-        return createContentInContainer(\n-            container,\n-            \'plone.app.event.dx.event\',\n-            **kwargs\n-        )\n+        return createContentInContainer(container, "plone.app.event.dx.event", **kwargs)\n \n     def make_dates(self):\n         tz = pytz.timezone(TEST_TIMEZONE)\n@@ -72,87 +66,92 @@ def setUp(self):\n         \'Future Event: 2013-05-15T10:00:00+02:00 - 2013-05-15T11:00:00+02:00\'\n \n         """\n-        self.portal = self.layer[\'portal\']\n-        self.app = self.layer[\'app\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.app = self.layer["app"]\n+        self.request = self.layer["request"]\n         set_browserlayer(self.request)\n         set_timezone(TEST_TIMEZONE)\n \n         now, past, future, far, duration = self.make_dates()\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n-        workflow = getToolByName(self.portal, \'portal_workflow\')\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+        workflow = getToolByName(self.portal, "portal_workflow")\n         workflow.setDefaultChain("simple_publication_workflow")\n \n         factory = self.event_factory\n         self.past_event = factory(\n             container=self.portal,\n-            id=\'past\',\n-            title=u\'Past Event\',\n+            id="past",\n+            title="Past Event",\n             start=past,\n             end=past + duration,\n-            location=u"Vienna",\n+            location="Vienna",\n             whole_day=True,\n-            recurrence=\'RRULE:FREQ=DAILY;COUNT=3\')\n-        workflow.doActionFor(self.past_event, \'publish\')\n+            recurrence="RRULE:FREQ=DAILY;COUNT=3",\n+        )\n+        workflow.doActionFor(self.past_event, "publish")\n         # adjust start and end according to whole_day and open_end\n         self.past_event.reindexObject()\n \n         self.now_event = factory(\n             container=self.portal,\n-            id=\'now\',\n-            title=u\'Now Event\',\n+            id="now",\n+            title="Now Event",\n             start=now,\n             end=now + duration,\n-            location=u"Vienna",\n+            location="Vienna",\n             recurrence="""RRULE:FREQ=DAILY;COUNT=3;INTERVAL=1\n RDATE:20130509T000000\n EXDATE:20130506T000000,20140404T000000""",\n-            contact_name=\'Auto Testdriver\',\n-            contact_email=\'testdriver@plone.org\',\n-            contact_phone=\'+123456789\',\n-            event_url=\'http://plone.org\',\n-            subject=(\'plone\', \'testing\'))  # change to subjects, once this is\n+            contact_name="Auto Testdriver",\n+            contact_email="testdriver@plone.org",\n+            contact_phone="+123456789",\n+            event_url="http://plone.org",\n+            subject=("plone", "testing"),\n+        )  # change to subjects, once this is\n         # fixed:\n         # https://github.com/plone/plone.dexterity/pull/18\n         # https://github.com/plone/plone.app.dexterity/issues/118\n-        workflow.doActionFor(self.now_event, \'publish\')\n+        workflow.doActionFor(self.now_event, "publish")\n         self.now_event.reindexObject()\n \n         self.future_event = factory(\n             container=self.portal,\n-            id=\'future\',\n-            title=u\'Future Event\',\n+            id="future",\n+            title="Future Event",\n             text=RichTextValue(\n-                u\'\xc3\x9cberraschung! Du kannst nach mir suchen\',\n-                \'text/plain\',\n-                \'text/html\',\n+                "\xc3\x9cberraschung! Du kannst nach mir suchen",\n+                "text/plain",\n+                "text/html",\n             ),\n             start=future,\n             end=future + duration,\n-            location=u\'Graz\')\n-        workflow.doActionFor(self.future_event, \'publish\')\n+            location="Graz",\n+        )\n+        workflow.doActionFor(self.future_event, "publish")\n         self.future_event.reindexObject()\n \n-        self.portal.invokeFactory(\'Folder\', \'sub\', title=u\'sub\')\n+        self.portal.invokeFactory("Folder", "sub", title="sub")\n         self.long_event = factory(\n             container=self.portal.sub,\n-            id=\'long\',\n-            title=u\'Long Event\',\n+            id="long",\n+            title="Long Event",\n             start=past,\n             end=far,\n-            location=u\'Schaftal\')\n-        workflow.doActionFor(self.long_event, \'publish\')\n+            location="Schaftal",\n+        )\n+        workflow.doActionFor(self.long_event, "publish")\n         self.long_event.reindexObject()\n \n         # plone.app.contenttypes ICollection type\n-        self.portal.invokeFactory(\'Collection\', \'collection\', title=u\'Col\')\n+        self.portal.invokeFactory("Collection", "collection", title="Col")\n         collection = self.portal.collection\n-        collection.sort_on = u\'start\'\n+        collection.sort_on = "start"\n         collection.reverse_sort = True\n         collection.query = [\n-            {\'i\': \'portal_type\',\n-             \'o\': \'plone.app.querystring.operation.selection.any\',\n-             \'v\': [\'Event\', \'plone.app.event.dx.event\']\n-             },\n+            {\n+                "i": "portal_type",\n+                "o": "plone.app.querystring.operation.selection.any",\n+                "v": ["Event", "plone.app.event.dx.event"],\n+            },\n         ]\n         collection.reindexObject()\ndiff --git a/plone/app/event/tests/robot/variables.py b/plone/app/event/tests/robot/variables.py\nindex 614ef1706..4514b019b 100644\n--- a/plone/app/event/tests/robot/variables.py\n+++ b/plone/app/event/tests/robot/variables.py\n@@ -4,6 +4,7 @@\n \n import locale\n \n+\n # important for MONTHNAME\n locale.setlocale(locale.LC_ALL, "en_US")\n \ndiff --git a/plone/app/event/tests/test_base_module.py b/plone/app/event/tests/test_base_module.py\nindex dd9e5c0ce..34395d332 100644\n--- a/plone/app/event/tests/test_base_module.py\n+++ b/plone/app/event/tests/test_base_module.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import date\n from datetime import datetime\n from datetime import timedelta\n@@ -41,7 +40,6 @@\n from zope.interface import directlyProvides\n \n import pytz\n-import six\n import unittest\n \n \n@@ -49,18 +47,17 @@ class TestBaseModule(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def assertEqualDatetime(self, date1, date2, msg=None):\n-        """ Compare two datetime instances to a resolution of minutes.\n-        """\n-        format_ = \'%Y-%m-%d %H:%M %Z\'\n+        """Compare two datetime instances to a resolution of minutes."""\n+        format_ = "%Y-%m-%d %H:%M %Z"\n         self.assertEqual(date1.strftime(format_), date2.strftime(format_), msg)\n \n     def test_default_end(self):\n         self.assertEqualDatetime(\n-            default_end() - timedelta(hours=DEFAULT_END_DELTA),\n-            default_start())\n+            default_end() - timedelta(hours=DEFAULT_END_DELTA), default_start()\n+        )\n \n     def test_default_start(self):\n         now = localized_now().replace(minute=0, second=0, microsecond=0)\n@@ -69,87 +66,81 @@ def test_default_start(self):\n     def test_DT(self):\n         # Python datetime with valid zone. Zope converts it to GMT+1...\n         # TODO: DateTime better shouldn\'t do this!\n-        cet = pytz.timezone(\'CET\')\n+        cet = pytz.timezone("CET")\n         self.assertEqual(\n             DT(datetime(2011, 11, 11, 11, 0, 0, tzinfo=cet)),\n-            DateTime(\'2011/11/11 11:00:00 GMT+1\')\n+            DateTime("2011/11/11 11:00:00 GMT+1"),\n         )\n \n         # Python dates get converted to a DateTime with timecomponent including\n         # a timezone\n-        self.assertEqual(\n-            DT(date(2011, 11, 11)),\n-            DateTime(\'2011/11/11 00:00:00 UTC\')\n-        )\n+        self.assertEqual(DT(date(2011, 11, 11)), DateTime("2011/11/11 00:00:00 UTC"))\n \n         # DateTime with valid zone\n         self.assertEqual(\n-            DT(DateTime(2011, 11, 11, 11, 0, 0, \'Europe/Vienna\')),\n-            DateTime(\'2011/11/11 11:00:00 Europe/Vienna\')\n+            DT(DateTime(2011, 11, 11, 11, 0, 0, "Europe/Vienna")),\n+            DateTime("2011/11/11 11:00:00 Europe/Vienna"),\n         )\n \n         # Zope DateTime with valid DateTime zone but invalid pytz is kept as is\n         self.assertEqual(\n-            DT(DateTime(2011, 11, 11, 11, 0, 0, \'GMT+1\')),\n-            DateTime(\'2011/11/11 11:00:00 GMT+1\')\n+            DT(DateTime(2011, 11, 11, 11, 0, 0, "GMT+1")),\n+            DateTime("2011/11/11 11:00:00 GMT+1"),\n         )\n \n         # Invalid datetime zones are converted to the portal timezone\n         # Testing with no timezone\n         self.assertEqual(\n-            DT(datetime(2011, 11, 11, 11, 0, 0)),\n-            DateTime(\'2011/11/11 11:00:00 UTC\')\n+            DT(datetime(2011, 11, 11, 11, 0, 0)), DateTime("2011/11/11 11:00:00 UTC")\n         )\n \n         # Conversion from string\n         self.assertEqual(\n-            DT(\'2011/11/11 11:00:00 Europe/Vienna\'),\n-            DateTime(\'2011/11/11 11:00:00 Europe/Vienna\')\n+            DT("2011/11/11 11:00:00 Europe/Vienna"),\n+            DateTime("2011/11/11 11:00:00 Europe/Vienna"),\n         )\n \n         # TEST WITH/WITHOUT MICROSECONDS\n \n         # From Python datetime\n \n-        tz = pytz.timezone(\'Europe/Vienna\')\n+        tz = pytz.timezone("Europe/Vienna")\n \n         # exact=False\n         self.assertEqual(\n-            DT(datetime(2012, 12, 12, 10, 10, 10, 123456,\n-               tzinfo=tz), exact=False),\n-            DateTime(\'2012/12/12 10:10:10 Europe/Vienna\')\n+            DT(datetime(2012, 12, 12, 10, 10, 10, 123456, tzinfo=tz), exact=False),\n+            DateTime("2012/12/12 10:10:10 Europe/Vienna"),\n         )\n \n         # exact=True\n         self.assertEqual(\n-            DT(datetime(2012, 12, 12, 10, 10, 10, 123456,\n-               tzinfo=tz), exact=True),\n-            DateTime(\'2012/12/12 10:10:10.123456 Europe/Vienna\')\n+            DT(datetime(2012, 12, 12, 10, 10, 10, 123456, tzinfo=tz), exact=True),\n+            DateTime("2012/12/12 10:10:10.123456 Europe/Vienna"),\n         )\n \n         # From Zope DateTime\n \n         # Exact=False\n         self.assertEqual(\n-            DT(DateTime(2012, 12, 12, 10, 10, 10.123456, \'Europe/Vienna\'),\n-               exact=False),\n-            DateTime(\'2012/12/12 10:10:10 Europe/Vienna\')\n+            DT(DateTime(2012, 12, 12, 10, 10, 10.123456, "Europe/Vienna"), exact=False),\n+            DateTime("2012/12/12 10:10:10 Europe/Vienna"),\n         )\n \n         # Exact=True\n         self.assertEqual(\n-            DT(DateTime(2012, 12, 12, 10, 10, 10.123456, \'Europe/Vienna\'),\n-               exact=True),\n-            DateTime(\'2012/12/12 10:10:10.123456 Europe/Vienna\')\n+            DT(DateTime(2012, 12, 12, 10, 10, 10.123456, "Europe/Vienna"), exact=True),\n+            DateTime("2012/12/12 10:10:10.123456 Europe/Vienna"),\n         )\n \n     def test_wkday_to_mon1(self):\n         from plone.app.event.base import wkday_to_mon1\n+\n         li = [wkday_to_mon1(day) for day in range(0, 7)]\n         self.assertEqual(li, [1, 2, 3, 4, 5, 6, 0])\n \n     def test_wkday_to_mon0(self):\n         from plone.app.event.base import wkday_to_mon0\n+\n         li = [wkday_to_mon0(day) for day in range(0, 7)]\n         self.assertEqual(li, [6, 0, 1, 2, 3, 4, 5])\n \n@@ -162,91 +153,105 @@ def test__default_timezone(self):\n \n     def test__dt_start_of_day(self):\n         from plone.app.event.base import dt_start_of_day\n+\n         self.assertEqual(\n             dt_start_of_day(datetime(2013, 2, 1, 18, 35)),\n-            datetime(2013, 2, 1, 0, 0, 0, 0)\n+            datetime(2013, 2, 1, 0, 0, 0, 0),\n         )\n         self.assertEqual(\n-            dt_start_of_day(date(2013, 2, 1)),\n-            datetime(2013, 2, 1, 0, 0, 0, 0)\n+            dt_start_of_day(date(2013, 2, 1)), datetime(2013, 2, 1, 0, 0, 0, 0)\n         )\n \n     def test__dt_end_of_day(self):\n         from plone.app.event.base import dt_end_of_day\n+\n         self.assertEqual(\n             dt_end_of_day(datetime(2013, 2, 1, 18, 35)),\n-            datetime(2013, 2, 1, 23, 59, 59, 0)\n+            datetime(2013, 2, 1, 23, 59, 59, 0),\n         )\n         self.assertEqual(\n-            dt_end_of_day(date(2013, 2, 1)),\n-            datetime(2013, 2, 1, 23, 59, 59, 0)\n+            dt_end_of_day(date(2013, 2, 1)), datetime(2013, 2, 1, 23, 59, 59, 0)\n         )\n \n     def test__start_end_from_mode(self):\n-        from plone.app.event.base import start_end_from_mode\n         from plone.app.event.base import dt_end_of_day\n+        from plone.app.event.base import start_end_from_mode\n \n         # ALL\n         #\n-        start, end = start_end_from_mode(\'all\')\n+        start, end = start_end_from_mode("all")\n         self.assertTrue(start is None and end is None)\n \n         # PAST\n         #\n-        start, end = start_end_from_mode(\'past\')\n+        start, end = start_end_from_mode("past")\n         self.assertTrue(start is None and isinstance(end, datetime))\n \n         # FUTURE\n         #\n-        start, end = start_end_from_mode(\'future\')\n+        start, end = start_end_from_mode("future")\n         self.assertTrue(isinstance(start, datetime) and end is None)\n \n         # NOW\n         #\n-        start, end = start_end_from_mode(\'now\')\n+        start, end = start_end_from_mode("now")\n         self.assertTrue(\n-            isinstance(start, datetime) and\n-            isinstance(end, datetime) and\n-            end.hour == 23 and end.minute == 59 and end.second == 59\n+            isinstance(start, datetime)\n+            and isinstance(end, datetime)\n+            and end.hour == 23\n+            and end.minute == 59\n+            and end.second == 59\n         )\n \n         # 7DAYS\n         #\n-        start, end = start_end_from_mode(\'7days\')\n+        start, end = start_end_from_mode("7days")\n         self.assertTrue(\n-            isinstance(start, datetime) and\n-            isinstance(end, datetime) and\n-            end == dt_end_of_day(start + timedelta(days=6))\n+            isinstance(start, datetime)\n+            and isinstance(end, datetime)\n+            and end == dt_end_of_day(start + timedelta(days=6))\n         )\n \n         # TODAY\n         #\n-        start, end = start_end_from_mode(\'today\')\n+        start, end = start_end_from_mode("today")\n         self.assertTrue(\n-            isinstance(start, datetime) and\n-            isinstance(end, datetime) and\n-            start.hour == 0 and start.minute == 0 and start.second == 0 and\n-            end.hour == 23 and end.minute == 59 and end.second == 59 and\n-            (start, end) == start_end_from_mode(\'day\')\n+            isinstance(start, datetime)\n+            and isinstance(end, datetime)\n+            and start.hour == 0\n+            and start.minute == 0\n+            and start.second == 0\n+            and end.hour == 23\n+            and end.minute == 59\n+            and end.second == 59\n+            and (start, end) == start_end_from_mode("day")\n         )\n \n         # DAY\n         #\n         day = datetime(2013, 2, 1, 18, 22)\n-        start, end = start_end_from_mode(\'day\', day)\n+        start, end = start_end_from_mode("day", day)\n         self.assertTrue(\n-            start.date() == day.date() == end.date() and\n-            start.hour == 0 and start.minute == 0 and start.second == 0 and\n-            end.hour == 23 and end.minute == 59 and end.second == 59\n+            start.date() == day.date() == end.date()\n+            and start.hour == 0\n+            and start.minute == 0\n+            and start.second == 0\n+            and end.hour == 23\n+            and end.minute == 59\n+            and end.second == 59\n         )\n \n         # test with date-only\n         day = datetime(2013, 2, 1)\n-        start, end = start_end_from_mode(\'day\', day)\n+        start, end = start_end_from_mode("day", day)\n         self.assertTrue(\n-            start.date() == day.date() == end.date() and\n-            start.hour == 0 and start.minute == 0 and start.second == 0 and\n-            end.hour == 23 and end.minute == 59 and end.second == 59\n+            start.date() == day.date() == end.date()\n+            and start.hour == 0\n+            and start.minute == 0\n+            and start.second == 0\n+            and end.hour == 23\n+            and end.minute == 59\n+            and end.second == 59\n         )\n \n         # WEEK\n@@ -265,90 +270,98 @@ def ret_6():\n \n         base.first_weekday = ret_0\n         day = datetime(2013, 2, 2)\n-        start, end = start_end_from_mode(\'week\', day)\n+        start, end = start_end_from_mode("week", day)\n         self.assertTrue(\n-            start.isoformat() == \'2013-01-28T00:00:00\' and\n-            end.isoformat() == \'2013-02-03T23:59:59\'\n+            start.isoformat() == "2013-01-28T00:00:00"\n+            and end.isoformat() == "2013-02-03T23:59:59"\n         )\n \n         base.first_weekday = ret_1\n         day = datetime(2013, 2, 2)\n-        start, end = start_end_from_mode(\'week\', day)\n+        start, end = start_end_from_mode("week", day)\n         self.assertTrue(\n-            start.isoformat() == \'2013-01-29T00:00:00\' and\n-            end.isoformat() == \'2013-02-04T23:59:59\'\n+            start.isoformat() == "2013-01-29T00:00:00"\n+            and end.isoformat() == "2013-02-04T23:59:59"\n         )\n \n         base.first_weekday = ret_6\n         day = datetime(2013, 2, 1)\n-        start, end = start_end_from_mode(\'week\', day)\n+        start, end = start_end_from_mode("week", day)\n         self.assertTrue(\n-            start.isoformat() == \'2013-01-27T00:00:00\' and\n-            end.isoformat() == \'2013-02-02T23:59:59\'\n+            start.isoformat() == "2013-01-27T00:00:00"\n+            and end.isoformat() == "2013-02-02T23:59:59"\n         )\n \n         base.first_weekday = orig_first_weekday  # restore orig first_weekday\n \n         # MONTH\n         #\n-        start, end = start_end_from_mode(\'month\')\n+        start, end = start_end_from_mode("month")\n         self.assertTrue(start < end and start.day == 1)\n \n         day = datetime(2013, 2, 7)\n-        start, end = start_end_from_mode(\'month\', day)\n+        start, end = start_end_from_mode("month", day)\n         self.assertTrue(\n-            start.year == 2013 and start.month == 2 and start.day == 1 and\n-            start.hour == 0 and start.minute == 0 and start.second == 0 and\n-            end.year == 2013 and end.month == 2 and end.day == 28 and\n-            end.hour == 23 and end.minute == 59 and end.second == 59\n+            start.year == 2013\n+            and start.month == 2\n+            and start.day == 1\n+            and start.hour == 0\n+            and start.minute == 0\n+            and start.second == 0\n+            and end.year == 2013\n+            and end.month == 2\n+            and end.day == 28\n+            and end.hour == 23\n+            and end.minute == 59\n+            and end.second == 59\n         )\n \n     def test_spell_date(self):\n         DT = DateTime(2015, 6, 6, 1, 2, 3)\n         date_spelled = spell_date(DT, self.portal)\n-        self.assertEqual(date_spelled[\'year\'], 2015)\n-        self.assertEqual(date_spelled[\'month\'], 6)\n-        self.assertEqual(date_spelled[\'month2\'], \'06\')\n-        self.assertEqual(date_spelled[\'day\'], 6)\n-        self.assertEqual(date_spelled[\'day2\'], \'06\')\n-        self.assertEqual(date_spelled[\'hour\'], 1)\n-        self.assertEqual(date_spelled[\'hour2\'], \'01\')\n-        self.assertEqual(date_spelled[\'minute\'], 2)\n-        self.assertEqual(date_spelled[\'minute2\'], \'02\')\n-        self.assertEqual(date_spelled[\'second\'], 3)\n-        self.assertEqual(date_spelled[\'second2\'], \'03\')\n-        self.assertEqual(date_spelled[\'week\'], 23)\n+        self.assertEqual(date_spelled["year"], 2015)\n+        self.assertEqual(date_spelled["month"], 6)\n+        self.assertEqual(date_spelled["month2"], "06")\n+        self.assertEqual(date_spelled["day"], 6)\n+        self.assertEqual(date_spelled["day2"], "06")\n+        self.assertEqual(date_spelled["hour"], 1)\n+        self.assertEqual(date_spelled["hour2"], "01")\n+        self.assertEqual(date_spelled["minute"], 2)\n+        self.assertEqual(date_spelled["minute2"], "02")\n+        self.assertEqual(date_spelled["second"], 3)\n+        self.assertEqual(date_spelled["second2"], "03")\n+        self.assertEqual(date_spelled["week"], 23)\n \n         # locale specific\n         # TODO: test better.\n-        self.assertTrue(isinstance(date_spelled[\'wkday\'], int))\n-        self.assertTrue(isinstance(date_spelled[\'month_name\'], six.string_types))\n-        self.assertTrue(isinstance(date_spelled[\'month_abbr\'], six.string_types))\n-        self.assertTrue(isinstance(date_spelled[\'wkday_name\'], six.string_types))\n-        self.assertTrue(isinstance(date_spelled[\'wkday_abbr\'], six.string_types))\n+        self.assertTrue(isinstance(date_spelled["wkday"], int))\n+        self.assertTrue(isinstance(date_spelled["month_name"], str))\n+        self.assertTrue(isinstance(date_spelled["month_abbr"], str))\n+        self.assertTrue(isinstance(date_spelled["wkday_name"], str))\n+        self.assertTrue(isinstance(date_spelled["wkday_abbr"], str))\n \n \n class TimezoneTest(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        set_env_timezone(\'UTC\')\n-        set_timezone(\'UTC\')\n+        self.portal = self.layer["portal"]\n+        set_env_timezone("UTC")\n+        set_timezone("UTC")\n \n     def test_default_timezone(self):\n-        self.assertTrue(os_default_timezone() == default_timezone() == \'UTC\')\n+        self.assertTrue(os_default_timezone() == default_timezone() == "UTC")\n \n         registry = getUtility(IRegistry)\n-        registry[\'plone.portal_timezone\'] = "Europe/Vienna"\n-        self.assertTrue(default_timezone() == \'Europe/Vienna\')\n+        registry["plone.portal_timezone"] = "Europe/Vienna"\n+        self.assertTrue(default_timezone() == "Europe/Vienna")\n \n \n class TestAnnotationAdapter(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def test_annotation_adapter(self):\n         # Normally called via adapter lookup from it\'s interface. but for\n@@ -359,7 +372,7 @@ def test_annotation_adapter(self):\n         self.assertEqual(an._data, None)\n \n         # ANNOTATION_KEY set, but no attribute set yet - an._data still None\n-        an.ANNOTATION_KEY = \'testing_annotation\'\n+        an.ANNOTATION_KEY = "testing_annotation"\n         an._data = IAnnotations(self.portal).get(an.ANNOTATION_KEY, None)\n \n         # Test attribute access, an._data still None\n@@ -374,21 +387,21 @@ def test_annotation_adapter(self):\n         self.assertTrue(an._data is not None)\n \n         # Set with something else than None\n-        an.foo = \'123\'\n-        self.assertEqual(an.foo, \'123\')\n+        an.foo = "123"\n+        self.assertEqual(an.foo, "123")\n \n \n class TestFindContext(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = portal = self.layer[\'portal\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = portal = self.layer["portal"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n-        portal.invokeFactory(\'Folder\', \'newsite\')\n-        portal.newsite.invokeFactory(\'Folder\', \'subfolder\')\n-        portal.invokeFactory(\'Folder\', \'subfolder2\')\n-        portal.subfolder2.invokeFactory(\'Folder\', \'subfolder3\')\n+        portal.invokeFactory("Folder", "newsite")\n+        portal.newsite.invokeFactory("Folder", "subfolder")\n+        portal.invokeFactory("Folder", "subfolder2")\n+        portal.subfolder2.invokeFactory("Folder", "subfolder3")\n \n         directlyProvides(portal.newsite, ISite)\n         self.assertTrue(ISite.providedBy(portal.newsite))\n@@ -401,44 +414,42 @@ def test_find_ploneroot(self):\n \n         self.assertEqual(\n             find_ploneroot(self.portal.newsite.subfolder, as_url=True),\n-            \'http://nohost/plone\'\n+            "http://nohost/plone",\n         )\n \n     def test_find_site(self):\n-        self.assertEqual(\n-            find_site(self.portal.newsite.subfolder),\n-            self.portal.newsite\n-        )\n+        self.assertEqual(find_site(self.portal.newsite.subfolder), self.portal.newsite)\n \n         self.assertEqual(\n             find_site(self.portal.newsite.subfolder, as_url=True),\n-            \'http://nohost/plone/newsite\'\n+            "http://nohost/plone/newsite",\n         )\n \n     def test_find_event_listing(self):\n-        self.portal.subfolder2.setLayout(\'event_listing\')\n+        self.portal.subfolder2.setLayout("event_listing")\n         self.assertEqual(\n             find_event_listing(self.portal.subfolder2.subfolder3),\n-            self.portal.subfolder2\n+            self.portal.subfolder2,\n         )\n         self.assertEqual(\n             find_event_listing(self.portal.subfolder2.subfolder3, as_url=True),\n-            \'http://nohost/plone/subfolder2\'\n+            "http://nohost/plone/subfolder2",\n         )\n \n         self.assertEqual(\n             find_context(\n                 self.portal.subfolder2.subfolder3,\n-                viewname=\'foo\',\n+                viewname="foo",\n                 as_url=True,\n-                append_view=True),\n-            \'http://nohost/plone/foo\'\n+                append_view=True,\n+            ),\n+            "http://nohost/plone/foo",\n         )\n \n \n class TestGetEventsDX(AbstractSampleDataEvents):\n-    """Test get_events with DX objects.\n-    """\n+    """Test get_events with DX objects."""\n+\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def test_get_events(self):\n@@ -447,17 +458,13 @@ def test_get_events(self):\n         res = get_events(self.portal)\n         self.assertEqual(len(res), 4)\n \n-        res = get_events(self.portal,\n-                         start=self.past,\n-                         end=self.future)\n+        res = get_events(self.portal, start=self.past, end=self.future)\n         self.assertEqual(len(res), 4)\n \n-        res = get_events(self.portal,\n-                         end=self.future)\n+        res = get_events(self.portal, end=self.future)\n         self.assertEqual(len(res), 4)\n \n-        res = get_events(self.portal,\n-                         start=self.past)\n+        res = get_events(self.portal, start=self.past)\n         self.assertEqual(len(res), 4)\n \n         # Limit\n@@ -475,21 +482,16 @@ def test_get_events(self):\n         self.assertTrue(res[0].start < res[-1].start)\n \n         # Test reversed sorting\n-        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS,\n-                         sort_reverse=True)\n+        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS, sort_reverse=True)\n         self.assertTrue(res[0].start > res[-1].start)\n \n         # Test sort_on\n-        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS,\n-                         sort="start")\n-        self.assertEqual(\n-            [it.title for it in res][2:],\n-            [u\'Now Event\', u\'Future Event\']\n-        )\n+        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS, sort="start")\n+        self.assertEqual([it.title for it in res][2:], ["Now Event", "Future Event"])\n         res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS, sort="end")\n         self.assertEqual(\n             [it.title for it in res],\n-            [u\'Past Event\', u\'Now Event\', u\'Future Event\', u\'Long Event\']\n+            ["Past Event", "Now Event", "Future Event", "Long Event"],\n         )\n \n         # Test expansion\n@@ -501,49 +503,42 @@ def test_get_events(self):\n         # Test sorting\n         self.assertTrue(res[0].start < res[-1].start)\n \n-        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS,\n-                         expand=True, sort_reverse=True)\n+        res = get_events(\n+            self.portal, ret_mode=RET_MODE_ACCESSORS, expand=True, sort_reverse=True\n+        )\n         # Test sorting\n         self.assertTrue(res[0].start > res[-1].start)\n \n         # only on now-date\n-        res = get_events(self.portal,\n-                         start=self.now,\n-                         end=self.now)\n+        res = get_events(self.portal, start=self.now, end=self.now)\n         self.assertEqual(len(res), 2)\n \n         # only on now-date as date\n         # NOTE: converting self.now to python datetime to allow testing also\n         # with dates as Zope DateTime objects.\n-        res = get_events(self.portal,\n-                         start=pydt(self.now).date(),\n-                         end=pydt(self.now).date())\n+        res = get_events(\n+            self.portal, start=pydt(self.now).date(), end=pydt(self.now).date()\n+        )\n         self.assertEqual(len(res), 2)\n \n         # only on past date\n-        res = get_events(self.portal,\n-                         start=self.past,\n-                         end=self.past)\n+        res = get_events(self.portal, start=self.past, end=self.past)\n         self.assertEqual(len(res), 2)\n \n         # one recurrence occurrence in far future\n-        res = get_events(self.portal,\n-                         start=self.far,\n-                         end=self.far)\n+        res = get_events(self.portal, start=self.far, end=self.far)\n         self.assertEqual(len(res), 1)\n \n         # from now on\n-        res = get_events(self.portal,\n-                         start=self.now)\n+        res = get_events(self.portal, start=self.now)\n         self.assertEqual(len(res), 3)\n \n         # until now\n-        res = get_events(self.portal,\n-                         end=self.now)\n+        res = get_events(self.portal, end=self.now)\n         self.assertEqual(len(res), 3)\n \n         # in subfolder\n-        path = \'/\'.join(self.portal.sub.getPhysicalPath())\n+        path = "/".join(self.portal.sub.getPhysicalPath())\n         res = get_events(self.portal, path=path)\n         self.assertEqual(len(res), 1)\n \n@@ -575,29 +570,35 @@ def test_get_event_limit(self):\n         factory = self.event_factory\n         factory(\n             container=self.portal,\n-            content_id=\'past_recur\',\n-            title=u\'Past Event recurring\',\n+            content_id="past_recur",\n+            title="Past Event recurring",\n             start=self.past,\n             end=self.past + self.duration,\n-            location=u"Dornbirn",\n-            recurrence=\'RRULE:FREQ=WEEKLY;COUNT=4\',\n+            location="Dornbirn",\n+            recurrence="RRULE:FREQ=WEEKLY;COUNT=4",\n         )\n \n         tomorrow = factory(\n             container=self.portal,\n-            content_id=\'tomorrow\',\n-            title=u\'Tomorrow event\',\n+            content_id="tomorrow",\n+            title="Tomorrow event",\n             start=self.tomorrow,\n             end=self.tomorrow + self.duration,\n             open_end=True,\n-            location=u"Dornbirn",\n+            location="Dornbirn",\n         )\n         tomorrow.reindexObject()\n \n-        limit = get_events(self.portal, start=self.now, expand=True,\n-                           ret_mode=RET_MODE_ACCESSORS, limit=3)\n-        all_ = get_events(self.portal, start=self.now, expand=True,\n-                          ret_mode=RET_MODE_ACCESSORS)\n+        limit = get_events(\n+            self.portal,\n+            start=self.now,\n+            expand=True,\n+            ret_mode=RET_MODE_ACCESSORS,\n+            limit=3,\n+        )\n+        all_ = get_events(\n+            self.portal, start=self.now, expand=True, ret_mode=RET_MODE_ACCESSORS\n+        )\n         self.assertEqual([e.url for e in limit], [e.url for e in all_[:3]])\n \n     def test_construct_calendar(self):\n@@ -619,28 +620,20 @@ def _num_events(values):\n \n         # Completly outside range and start, end given as datetime\n         cal = construct_calendar(\n-            res,\n-            start=datetime(2000, 1, 1, 10, 0),\n-            end=datetime(2000, 1, 2, 10, 0)\n+            res, start=datetime(2000, 1, 1, 10, 0), end=datetime(2000, 1, 2, 10, 0)\n         )\n         self.assertEqual(_num_events(cal.values()), 0)\n \n         # Within range\n-        cal = construct_calendar(\n-            res,\n-            start=date(2013, 5, 1),\n-            end=date(2013, 5, 31)\n-        )\n+        cal = construct_calendar(res, start=date(2013, 5, 1), end=date(2013, 5, 31))\n         self.assertEqual(_num_events(cal.values()), 35)\n         # First day must also be set in the calendar\n-        self.assertTrue(\'2013-05-01\' in cal.keys())\n+        self.assertTrue("2013-05-01" in cal.keys())\n \n         # invalid start\n         def _invalid_start():\n             return construct_calendar(\n-                res,\n-                start=\'invalid\',\n-                end=datetime(2000, 1, 2, 10, 0)\n+                res, start="invalid", end=datetime(2000, 1, 2, 10, 0)\n             )\n \n         self.assertRaises(AssertionError, _invalid_start)\n@@ -648,10 +641,9 @@ def _invalid_start():\n         # invalid end\n         def _invalid_end():\n             return construct_calendar(\n-                res,\n-                start=datetime(2000, 1, 1, 10, 0),\n-                end=\'invalid\'\n+                res, start=datetime(2000, 1, 1, 10, 0), end="invalid"\n             )\n+\n         self.assertRaises(AssertionError, _invalid_end)\n \n \n@@ -662,6 +654,7 @@ class TestGetEventsOptimizations(AbstractSampleDataEvents):\n     is actually a manifestation of a deeper sorting bug,\n     that also affects unlimited and unexpanded get_events().\n     """\n+\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n@@ -671,39 +664,40 @@ def setUp(self):\n         factory = self.event_factory\n         factory(\n             container=self.portal,\n-            content_id=\'past_recur\',\n-            title=u\'Past Recur\',\n+            content_id="past_recur",\n+            title="Past Recur",\n             start=self.past + self.duration,\n             end=self.past + self.duration + self.duration,\n-            location=u"Dornbirn",\n-            recurrence=\'RRULE:FREQ=WEEKLY;COUNT=4\',\n+            location="Dornbirn",\n+            recurrence="RRULE:FREQ=WEEKLY;COUNT=4",\n         )\n \n         tomorrow = factory(\n             container=self.portal,\n-            content_id=\'tomorrow\',\n-            title=u\'Tomorrow event\',\n+            content_id="tomorrow",\n+            title="Tomorrow event",\n             start=self.tomorrow,\n             end=self.tomorrow + self.duration,\n             open_end=True,\n-            location=u"Dornbirn",\n+            location="Dornbirn",\n         )\n         tomorrow.reindexObject()\n \n         self.occ = [\n-            (u\'Past Event\', \'2013-04-25 00:00:00\', \'2013-04-25 23:59:59\'),\n-            (u\'Long Event\', \'2013-04-25 10:00:00\', \'2013-06-04 10:00:00\'),\n-            (u\'Past Recur\', \'2013-04-25 11:00:00\', \'2013-04-25 12:00:00\'),\n-            (u\'Past Event\', \'2013-04-26 00:00:00\', \'2013-04-26 23:59:59\'),\n-            (u\'Past Event\', \'2013-04-27 00:00:00\', \'2013-04-27 23:59:59\'),\n-            (u\'Past Recur\', \'2013-05-02 11:00:00\', \'2013-05-02 12:00:00\'),\n-            (u\'Now Event\', \'2013-05-05 10:00:00\', \'2013-05-05 11:00:00\'),\n-            (u\'Tomorrow event\', \'2013-05-06 10:00:00\', \'2013-05-06 23:59:59\'),\n-            (u\'Now Event\', \'2013-05-07 10:00:00\', \'2013-05-07 11:00:00\'),\n-            (u\'Now Event\', \'2013-05-09 10:00:00\', \'2013-05-09 11:00:00\'),\n-            (u\'Past Recur\', \'2013-05-09 11:00:00\', \'2013-05-09 12:00:00\'),\n-            (u\'Future Event\', \'2013-05-15 10:00:00\', \'2013-05-15 11:00:00\'),\n-            (u\'Past Recur\', \'2013-05-16 11:00:00\', \'2013-05-16 12:00:00\')]\n+            ("Past Event", "2013-04-25 00:00:00", "2013-04-25 23:59:59"),\n+            ("Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            ("Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n+            ("Past Event", "2013-04-26 00:00:00", "2013-04-26 23:59:59"),\n+            ("Past Event", "2013-04-27 00:00:00", "2013-04-27 23:59:59"),\n+            ("Past Recur", "2013-05-02 11:00:00", "2013-05-02 12:00:00"),\n+            ("Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+            ("Tomorrow event", "2013-05-06 10:00:00", "2013-05-06 23:59:59"),\n+            ("Now Event", "2013-05-07 10:00:00", "2013-05-07 11:00:00"),\n+            ("Now Event", "2013-05-09 10:00:00", "2013-05-09 11:00:00"),\n+            ("Past Recur", "2013-05-09 11:00:00", "2013-05-09 12:00:00"),\n+            ("Future Event", "2013-05-15 10:00:00", "2013-05-15 11:00:00"),\n+            ("Past Recur", "2013-05-16 11:00:00", "2013-05-16 12:00:00"),\n+        ]\n \n     def diff(self, list1, list2):\n         c = set(list1).union(set(list2))\n@@ -711,73 +705,106 @@ def diff(self, list1, list2):\n         return list(c - d)\n \n     def fmt(self, seq):\n-        return [(x.title,\n-                 x.start.strftime(\'%Y-%m-%d %H:%M:%S\'),\n-                 x.end.strftime(\'%Y-%m-%d %H:%M:%S\'))\n-                for x in seq]\n+        return [\n+            (\n+                x.title,\n+                x.start.strftime("%Y-%m-%d %H:%M:%S"),\n+                x.end.strftime("%Y-%m-%d %H:%M:%S"),\n+            )\n+            for x in seq\n+        ]\n \n     # expand=True: events\n \n     def test_expand_all(self):\n         # all occurrences, sorted by start\n-        res = self.fmt(get_events(self.portal, expand=True,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(self.portal, expand=True, ret_mode=RET_MODE_ACCESSORS)\n+        )\n         self.assertEqual(res, self.occ)\n \n     def test_expand_all_limit(self):\n         # limited occurrences\n-        res = self.fmt(get_events(self.portal, expand=True,\n-                                  limit=3,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(self.portal, expand=True, limit=3, ret_mode=RET_MODE_ACCESSORS)\n+        )\n         expect = self.occ[:3]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n     def test_expand_start(self):\n         # now+future occurrences\n-        res = self.fmt(get_events(self.portal, expand=True,\n-                                  start=self.now,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal, expand=True, start=self.now, ret_mode=RET_MODE_ACCESSORS\n+            )\n+        )\n         expect = self.occ[1:2] + self.occ[6:]  # includes ongoing long event\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n     def test_expand_start_limit(self):\n         # limited now+future occurrences\n-        res = self.fmt(get_events(self.portal, expand=True,\n-                                  start=self.now, limit=3,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal,\n+                expand=True,\n+                start=self.now,\n+                limit=3,\n+                ret_mode=RET_MODE_ACCESSORS,\n+            )\n+        )\n         expect = self.occ[1:2] + self.occ[6:8]  # includes ongoing long event\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n     def test_expand_future_event(self):\n-        """make sure expand_events does not remove event objects (that need not be expanded)\n-        """\n+        """make sure expand_events does not remove event objects (that need not be expanded)"""\n         # create event happening next year (today + 365 days)\n         next_year = self.event_factory(\n             container=self.portal,\n-            content_id=\'next-year\',\n-            title=u\'Next year\',\n+            content_id="next-year",\n+            title="Next year",\n             start=self.tomorrow + timedelta(365),\n             end=self.tomorrow + timedelta(365) + self.duration,\n-            location=u"Dornbirn",\n-            recurrence=\'RRULE:FREQ=DAILY;COUNT=4\',\n+            location="Dornbirn",\n+            recurrence="RRULE:FREQ=DAILY;COUNT=4",\n         )\n         next_year.reindexObject()\n \n-\n-        ev = (u\'Next year\', \'2014-05-06 10:00:00\', \'2014-05-06 11:00:00\')  # original event\n-        rec1 = (u\'Next year\', \'2014-05-07 10:00:00\', \'2014-05-07 11:00:00\')  # first recurrence\n-        rec2 = (u\'Next year\', \'2014-05-08 10:00:00\', \'2014-05-08 11:00:00\')  # second recurrence\n-        rec3 = (u\'Next year\', \'2014-05-09 10:00:00\', \'2014-05-09 11:00:00\')  # third recurrence\n-        rec4 = (u\'Next year\', \'2014-05-10 10:00:00\', \'2014-05-10 11:00:00\')  # fourth recurrence\n-\n+        ev = (\n+            "Next year",\n+            "2014-05-06 10:00:00",\n+            "2014-05-06 11:00:00",\n+        )  # original event\n+        rec1 = (\n+            "Next year",\n+            "2014-05-07 10:00:00",\n+            "2014-05-07 11:00:00",\n+        )  # first recurrence\n+        rec2 = (\n+            "Next year",\n+            "2014-05-08 10:00:00",\n+            "2014-05-08 11:00:00",\n+        )  # second recurrence\n+        rec3 = (\n+            "Next year",\n+            "2014-05-09 10:00:00",\n+            "2014-05-09 11:00:00",\n+        )  # third recurrence\n+        rec4 = (\n+            "Next year",\n+            "2014-05-10 10:00:00",\n+            "2014-05-10 11:00:00",\n+        )  # fourth recurrence\n \n         # expand_events from today+200 until today+300\n-        res = self.fmt(expand_events(\n-            [next_year],\n-            RET_MODE_ACCESSORS,\n-            start=self.now + timedelta(200),\n-            end=self.now + timedelta(300),\n-            sort="start"))\n+        res = self.fmt(\n+            expand_events(\n+                [next_year],\n+                RET_MODE_ACCESSORS,\n+                start=self.now + timedelta(200),\n+                end=self.now + timedelta(300),\n+                sort="start",\n+            )\n+        )\n \n         # event is included in result even though it starts after the the `end` param of expand_events\n         # this is to make expand_events only use start/end to expand occurrences, not limit events given in the list\n@@ -788,12 +815,15 @@ def test_expand_future_event(self):\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n         # when the event does not happen after the search timespan, expand won\'t add original event\n-        res = self.fmt(get_events(\n-            self.portal,\n-            expand=True,\n-            start=self.now + timedelta(365+2),\n-            end=self.now + timedelta(365+3),\n-            ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal,\n+                expand=True,\n+                start=self.now + timedelta(365 + 2),\n+                end=self.now + timedelta(365 + 3),\n+                ret_mode=RET_MODE_ACCESSORS,\n+            )\n+        )\n         expect = [rec1, rec2]\n         self.assertEqual(res, expect)\n \n@@ -801,80 +831,110 @@ def test_expand_future_event(self):\n \n     def test_noexpand_all(self):\n         # all events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(self.portal, expand=False, ret_mode=RET_MODE_ACCESSORS)\n+        )\n         expect = [\n-            (u\'Past Event\', \'2013-04-25 00:00:00\', \'2013-04-25 23:59:59\'),\n-            (u\'Long Event\', \'2013-04-25 10:00:00\', \'2013-06-04 10:00:00\'),\n-            (u\'Past Recur\', \'2013-04-25 11:00:00\', \'2013-04-25 12:00:00\'),\n-            (u\'Now Event\', \'2013-05-05 10:00:00\', \'2013-05-05 11:00:00\'),\n-            (u\'Tomorrow event\', \'2013-05-06 10:00:00\', \'2013-05-06 23:59:59\'),\n-            (u\'Future Event\', \'2013-05-15 10:00:00\', \'2013-05-15 11:00:00\')]\n+            ("Past Event", "2013-04-25 00:00:00", "2013-04-25 23:59:59"),\n+            ("Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            ("Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n+            ("Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+            ("Tomorrow event", "2013-05-06 10:00:00", "2013-05-06 23:59:59"),\n+            ("Future Event", "2013-05-15 10:00:00", "2013-05-15 11:00:00"),\n+        ]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n         # limited events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  limit=3,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(self.portal, expand=False, limit=3, ret_mode=RET_MODE_ACCESSORS)\n+        )\n         self.assertEqual(res, expect[:3], self.diff(res, expect[:3]))\n \n     def test_noexpand_start(self):\n         # now+future events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  start=self.now,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal, expand=False, start=self.now, ret_mode=RET_MODE_ACCESSORS\n+            )\n+        )\n         expect = [\n-            (u\'Long Event\', \'2013-04-25 10:00:00\', \'2013-06-04 10:00:00\'),\n-            (u\'Now Event\', \'2013-05-05 10:00:00\', \'2013-05-05 11:00:00\'),\n-            (u\'Tomorrow event\', \'2013-05-06 10:00:00\', \'2013-05-06 23:59:59\'),\n+            ("Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            ("Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+            ("Tomorrow event", "2013-05-06 10:00:00", "2013-05-06 23:59:59"),\n             # Past Recur next occurrence: \'2013-05-09 11:00:00\'\n             # Past Recur brain.start: \'2013-04-25 11:00:00\'\n-            (u\'Past Recur\', \'2013-04-25 11:00:00\', \'2013-04-25 12:00:00\'),\n-            (u\'Future Event\', \'2013-05-15 10:00:00\', \'2013-05-15 11:00:00\')]\n+            ("Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n+            ("Future Event", "2013-05-15 10:00:00", "2013-05-15 11:00:00"),\n+        ]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n         # limited now+future events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  start=self.now, limit=3,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal,\n+                expand=False,\n+                start=self.now,\n+                limit=3,\n+                ret_mode=RET_MODE_ACCESSORS,\n+            )\n+        )\n         self.assertEqual(res, expect[:3], self.diff(res, expect[:3]))\n \n     def test_noexpand_end(self):\n         # past+now events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  end=self.now,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal, expand=False, end=self.now, ret_mode=RET_MODE_ACCESSORS\n+            )\n+        )\n         expect = [\n-            (u\'Past Event\', \'2013-04-25 00:00:00\', \'2013-04-25 23:59:59\'),\n-            (u\'Long Event\', \'2013-04-25 10:00:00\', \'2013-06-04 10:00:00\'),\n-            (u\'Past Recur\', \'2013-04-25 11:00:00\', \'2013-04-25 12:00:00\'),\n-            (u\'Now Event\', \'2013-05-05 10:00:00\', \'2013-05-05 11:00:00\')]\n+            ("Past Event", "2013-04-25 00:00:00", "2013-04-25 23:59:59"),\n+            ("Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            ("Past Recur", "2013-04-25 11:00:00", "2013-04-25 12:00:00"),\n+            ("Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+        ]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n         # limited past+now events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  end=self.now,\n-                                  limit=3,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal,\n+                expand=False,\n+                end=self.now,\n+                limit=3,\n+                ret_mode=RET_MODE_ACCESSORS,\n+            )\n+        )\n         self.assertEqual(res, expect[:3], self.diff(res, expect[:3]))\n \n     def test_noexpand_start_end(self):\n         # only now events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  start=self.now,\n-                                  end=self.now,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal,\n+                expand=False,\n+                start=self.now,\n+                end=self.now,\n+                ret_mode=RET_MODE_ACCESSORS,\n+            )\n+        )\n         expect = [\n-            (u\'Long Event\', \'2013-04-25 10:00:00\', \'2013-06-04 10:00:00\'),\n-            (u\'Now Event\', \'2013-05-05 10:00:00\', \'2013-05-05 11:00:00\')]\n+            ("Long Event", "2013-04-25 10:00:00", "2013-06-04 10:00:00"),\n+            ("Now Event", "2013-05-05 10:00:00", "2013-05-05 11:00:00"),\n+        ]\n         self.assertEqual(res, expect, self.diff(res, expect))\n \n         # limited now events\n-        res = self.fmt(get_events(self.portal, expand=False,\n-                                  start=self.now,\n-                                  end=self.now,\n-                                  limit=3,\n-                                  ret_mode=RET_MODE_ACCESSORS))\n+        res = self.fmt(\n+            get_events(\n+                self.portal,\n+                expand=False,\n+                start=self.now,\n+                end=self.now,\n+                limit=3,\n+                ret_mode=RET_MODE_ACCESSORS,\n+            )\n+        )\n         self.assertEqual(res, expect[:3], self.diff(res, expect[:3]))\n \n \n@@ -882,79 +942,82 @@ class TestDatesForDisplay(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_prep_display_with_time(self):\n         tz = pytz.timezone("Europe/Vienna")\n         event = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n+            "plone.app.event.dx.event",\n             id="event",\n             start=tz.localize(datetime(2000, 10, 12, 6, 0, 0)),\n-            end=tz.localize(datetime(2000, 10, 12, 18, 0, 0))\n+            end=tz.localize(datetime(2000, 10, 12, 18, 0, 0)),\n         )\n         self.assertEqual(\n             dates_for_display(event),\n-            {\'start_date\': u\'Oct 12, 2000\',\n-             \'start_time\': u\'06:00 AM\',\n-             \'start_iso\': \'2000-10-12T06:00:00+02:00\',\n-             \'end_date\': u\'Oct 12, 2000\',\n-             \'end_time\': u\'06:00 PM\',\n-             \'end_iso\': \'2000-10-12T18:00:00+02:00\',\n-             \'same_day\': True,\n-             \'same_time\': False,\n-             \'whole_day\': False,\n-             \'open_end\': False,\n-             }\n+            {\n+                "start_date": "Oct 12, 2000",\n+                "start_time": "06:00 AM",\n+                "start_iso": "2000-10-12T06:00:00+02:00",\n+                "end_date": "Oct 12, 2000",\n+                "end_time": "06:00 PM",\n+                "end_iso": "2000-10-12T18:00:00+02:00",\n+                "same_day": True,\n+                "same_time": False,\n+                "whole_day": False,\n+                "open_end": False,\n+            },\n         )\n \n     def test_prep_display_wholeday_sameday(self):\n         tz = pytz.timezone("Europe/Vienna")\n         event = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n+            "plone.app.event.dx.event",\n             id="event",\n             start=tz.localize(datetime(2000, 10, 12, 0, 0, 0)),\n             end=tz.localize(datetime(2000, 10, 12, 23, 59, 59)),\n-            whole_day=True\n+            whole_day=True,\n         )\n         self.assertEqual(\n             dates_for_display(event),\n-            {\'start_date\': u\'Oct 12, 2000\',\n-             \'start_time\': None,\n-             \'start_iso\': \'2000-10-12\',\n-             \'end_date\': u\'Oct 12, 2000\',\n-             \'end_time\': None,\n-             \'end_iso\': \'2000-10-12\',\n-             \'same_day\': True,\n-             \'same_time\': False,\n-             \'whole_day\': True,\n-             \'open_end\': False,\n-             }\n+            {\n+                "start_date": "Oct 12, 2000",\n+                "start_time": None,\n+                "start_iso": "2000-10-12",\n+                "end_date": "Oct 12, 2000",\n+                "end_time": None,\n+                "end_iso": "2000-10-12",\n+                "same_day": True,\n+                "same_time": False,\n+                "whole_day": True,\n+                "open_end": False,\n+            },\n         )\n \n     def test_prep_display_wholeday_differentdays(self):\n         tz = pytz.timezone("Europe/Vienna")\n         event = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n+            "plone.app.event.dx.event",\n             id="event",\n             start=tz.localize(datetime(2000, 10, 12, 0, 0, 0)),\n             end=tz.localize(datetime(2000, 10, 13, 23, 59, 59)),\n-            whole_day=True\n+            whole_day=True,\n         )\n         self.assertEqual(\n             dates_for_display(event),\n-            {\'start_date\': u\'Oct 12, 2000\',\n-             \'start_time\': None,\n-             \'start_iso\': \'2000-10-12\',\n-             \'end_date\': u\'Oct 13, 2000\',\n-             \'end_time\': None,\n-             \'end_iso\': \'2000-10-13\',\n-             \'same_day\': False,\n-             \'same_time\': False,\n-             \'whole_day\': True,\n-             \'open_end\': False,\n-             }\n+            {\n+                "start_date": "Oct 12, 2000",\n+                "start_time": None,\n+                "start_iso": "2000-10-12",\n+                "end_date": "Oct 13, 2000",\n+                "end_time": None,\n+                "end_iso": "2000-10-13",\n+                "same_day": False,\n+                "same_time": False,\n+                "whole_day": True,\n+                "open_end": False,\n+            },\n         )\ndiff --git a/plone/app/event/tests/test_catalog.py b/plone/app/event/tests/test_catalog.py\nindex 6570916cd..540dabad3 100644\n--- a/plone/app/event/tests/test_catalog.py\n+++ b/plone/app/event/tests/test_catalog.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.testing import PAEvent_INTEGRATION_TESTING\n from Products.CMFCore.utils import getToolByName\n \n@@ -9,15 +8,17 @@ class TextDXIntegration(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n+        self.portal = self.layer["portal"]\n+        self.catalog = getToolByName(self.portal, "portal_catalog")\n \n     def test_end_is_DateRecurringIndex(self):\n         # end should be a DateRecurringIndex\n-        self.assertEqual(self.catalog.Indexes[\'end\'].__class__.__name__,\n-                         \'DateRecurringIndex\')\n+        self.assertEqual(\n+            self.catalog.Indexes["end"].__class__.__name__, "DateRecurringIndex"\n+        )\n \n     def test_start_is_DateRecurringIndex(self):\n         # start should be a DateRecurringIndex\n-        self.assertEqual(self.catalog.Indexes[\'start\'].__class__.__name__,\n-                         \'DateRecurringIndex\')\n+        self.assertEqual(\n+            self.catalog.Indexes["start"].__class__.__name__, "DateRecurringIndex"\n+        )\ndiff --git a/plone/app/event/tests/test_dx_behaviors.py b/plone/app/event/tests/test_dx_behaviors.py\nindex 955347a46..9e0fcaf4d 100644\n--- a/plone/app/event/tests/test_dx_behaviors.py\n+++ b/plone/app/event/tests/test_dx_behaviors.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import datetime\n from datetime import timedelta\n from DateTime import DateTime\n@@ -30,46 +29,44 @@\n from plone.event.interfaces import IEventAccessor\n from plone.event.interfaces import IOccurrence\n from plone.event.interfaces import IRecurrenceSupport\n+from plone.testing.zope import Browser\n from plone.uuid.interfaces import IUUID\n+from unittest import mock\n from zope.annotation.interfaces import IAnnotations\n \n-import mock\n import pytz\n import unittest\n import zope.interface\n \n-try:\n-    # plone.testing 7+\n-    from plone.testing.zope import Browser\n-except ImportError:\n-    # plone.testing 6-\n-    from plone.testing.z2 import Browser\n-\n \n TEST_TIMEZONE = "Europe/Vienna"\n \n \n class MockEvent(SimpleItem):\n-    """ Mock event"""\n+    """Mock event"""\n \n \n class TestDXAddEdit(unittest.TestCase):\n     layer = PAEventDX_FUNCTIONAL_TESTING\n \n     def setUp(self):\n-        app = self.layer[\'app\']\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        app = self.layer["app"]\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n         self.browser = Browser(app)\n         self.browser.handleErrors = False\n         self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD,)\n+            "Authorization",\n+            "Basic %s:%s"\n+            % (\n+                SITE_OWNER_NAME,\n+                SITE_OWNER_PASSWORD,\n+            ),\n         )\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=patched_now)\n+    @mock.patch("plone.app.event.base.localized_now", new=patched_now)\n     def test_defaults(self):\n         """Test, if defaults are set correctly.\n \n@@ -98,27 +95,30 @@ def test_defaults(self):\n         form.add(e1)\n         """\n \n-        self.browser.open(\'{}/{}\'.format(\n-            self.portal.absolute_url(),\n-            \'++add++plone.app.event.dx.event\'\n-        ))\n+        self.browser.open(\n+            "{}/{}".format(\n+                self.portal.absolute_url(), "++add++plone.app.event.dx.event"\n+            )\n+        )\n \n         self.browser.getControl(\n-            name=\'form.widgets.IDublinCore.title\'\n+            name="form.widgets.IDublinCore.title"\n         ).value = "TestEvent"\n \n         # TODO: these values are simply not set in the pat-pickadate pattern.\n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.start\').value = \'2014-03-30\'\n+            name="form.widgets.IEventBasic.start"\n+        ).value = "2014-03-30"\n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.end\').value = \'2014-03-31\'\n+            name="form.widgets.IEventBasic.end"\n+        ).value = "2014-03-31"\n \n-        self.browser.getControl(\'Save\').click()\n+        self.browser.getControl("Save").click()\n \n         # CHECK VALUES\n         #\n         # TODO: fix all defaults\n-        event = self.portal[\'testevent\']\n+        event = self.portal["testevent"]\n         # self.assertEqual(\n         #     event.start,\n         #     patched_now()\n@@ -164,86 +164,91 @@ def test_edit_context(self):\n         # ADD\n         #\n         self.browser.open(self.portal.absolute_url())\n-        self.browser.getLink(\'plone.app.event.dx.event\').click()\n+        self.browser.getLink("plone.app.event.dx.event").click()\n         self.browser.getControl(\n-            name=\'form.widgets.IDublinCore.title\'\n+            name="form.widgets.IDublinCore.title"\n         ).value = "TestEvent"\n \n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.start\').value = "2014-03-30T03:51"\n+            name="form.widgets.IEventBasic.start"\n+        ).value = "2014-03-30T03:51"\n \n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.end\').value = "2014-03-30T04:51"\n+            name="form.widgets.IEventBasic.end"\n+        ).value = "2014-03-30T04:51"\n \n-        self.browser.getControl(\'Save\').click()\n+        self.browser.getControl("Save").click()\n \n         # CHECK VALUES\n         #\n-        self.assertTrue(self.browser.url.endswith(\'testevent/view\'))\n-        self.assertTrue(\'TestEvent\' in self.browser.contents)\n-        self.assertTrue(\'2014-03-30\' in self.browser.contents)\n+        self.assertTrue(self.browser.url.endswith("testevent/view"))\n+        self.assertTrue("TestEvent" in self.browser.contents)\n+        self.assertTrue("2014-03-30" in self.browser.contents)\n \n         #\n         # EDIT\n         #\n         testevent = self.portal.testevent\n-        self.browser.open(\'%s/@@edit\' % testevent.absolute_url())\n+        self.browser.open("%s/@@edit" % testevent.absolute_url())\n \n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.start\').value = "2014-03-31T03:51"\n+            name="form.widgets.IEventBasic.start"\n+        ).value = "2014-03-31T03:51"\n \n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.end\').value = "2014-03-31T04:51"\n+            name="form.widgets.IEventBasic.end"\n+        ).value = "2014-03-31T04:51"\n \n-        self.browser.getControl(\'Save\').click()\n+        self.browser.getControl("Save").click()\n \n         #\n         # EDIT AGAIN\n         #\n         testevent = self.portal.testevent\n-        self.browser.open(\'%s/@@edit\' % testevent.absolute_url())\n+        self.browser.open("%s/@@edit" % testevent.absolute_url())\n \n-        self.browser.getControl(\'Save\').click()\n+        self.browser.getControl("Save").click()\n \n         # CHECK DATES/TIMES, MUST NOT HAVE CHANGED\n         #\n-        self.assertTrue(\'2014-03-31\' in self.browser.contents)\n-        self.assertTrue(\'03:51\' in self.browser.contents)\n-        self.assertTrue(\'04:51\' in self.browser.contents)\n+        self.assertTrue("2014-03-31" in self.browser.contents)\n+        self.assertTrue("03:51" in self.browser.contents)\n+        self.assertTrue("04:51" in self.browser.contents)\n \n         #\n         # EDIT and set whole_day setting\n         #\n         testevent = self.portal.testevent\n-        self.browser.open(\'%s/@@edit\' % testevent.absolute_url())\n+        self.browser.open("%s/@@edit" % testevent.absolute_url())\n \n         self.browser.getControl(\n-            name=\'form.widgets.IEventBasic.whole_day:list\').value = True\n+            name="form.widgets.IEventBasic.whole_day:list"\n+        ).value = True\n \n-        self.browser.getControl(\'Save\').click()\n+        self.browser.getControl("Save").click()\n \n         # CHECK DATES/TIMES, IF THEY ADAPTED ACCORDING TO WHOLE DAY\n         #\n-        self.assertTrue(\'2014-03-31\' in self.browser.contents)\n-        self.assertTrue(\'0:00\' in self.browser.contents)\n-        self.assertTrue(\'23:59\' in self.browser.contents)\n+        self.assertTrue("2014-03-31" in self.browser.contents)\n+        self.assertTrue("0:00" in self.browser.contents)\n+        self.assertTrue("23:59" in self.browser.contents)\n \n \n class TestEventAccessor(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n         set_browserlayer(self.request)\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_event_accessor(self):\n         tz = pytz.timezone("Europe/Vienna")\n         e1 = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            title=u\'event1\',\n+            "plone.app.event.dx.event",\n+            title="event1",\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             end=tz.localize(datetime(2011, 11, 11, 12, 0)),\n         )\n@@ -273,10 +278,10 @@ def test_event_accessor_whole_day__open_end(self):\n \n         e1 = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            title=u\'event1\',\n+            "plone.app.event.dx.event",\n+            title="event1",\n             start=start,\n-            end=end\n+            end=end,\n         )\n         acc = IEventAccessor(e1)\n \n@@ -299,42 +304,38 @@ def test_event_accessor_whole_day__open_end(self):\n         self.assertEqual(acc.end, end_end)\n \n     def test_event_accessor__sync_uid(self):\n-        self.request.set(\'HTTP_HOST\', \'nohost\')\n+        self.request.set("HTTP_HOST", "nohost")\n \n         e1 = createContentInContainer(\n-            self.portal,\n-            \'plone.app.event.dx.event\',\n-            title=u\'event1\'\n+            self.portal, "plone.app.event.dx.event", title="event1"\n         )\n         acc = IEventAccessor(e1)\n \n         # setting no sync uid will automatically generate one\n-        self.assertTrue(acc.sync_uid, IUUID(e1) + \'@nohost\')\n+        self.assertTrue(acc.sync_uid, IUUID(e1) + "@nohost")\n         # it\'s not stored on the object though\n         self.assertEqual(e1.sync_uid, None)\n         # but it\'s indexed\n-        result = self.portal.portal_catalog(sync_uid=IUUID(e1) + \'@nohost\')\n+        result = self.portal.portal_catalog(sync_uid=IUUID(e1) + "@nohost")\n         self.assertEqual(len(result), 1)\n \n         # Setting the sync_uid\n-        acc.sync_uid = \'okay\'\n+        acc.sync_uid = "okay"\n         e1.reindexObject()\n-        self.assertEqual(acc.sync_uid, \'okay\')\n+        self.assertEqual(acc.sync_uid, "okay")\n         # Now, it\'s also stored on the object itself\n-        self.assertEqual(e1.sync_uid, \'okay\')\n+        self.assertEqual(e1.sync_uid, "okay")\n         # and indexed\n-        result = self.portal.portal_catalog(sync_uid=\'okay\')\n+        result = self.portal.portal_catalog(sync_uid="okay")\n         self.assertEqual(len(result), 1)\n \n     def test_event_accessor__start_end(self):\n         e1 = createContentInContainer(\n-            self.portal,\n-            \'plone.app.event.dx.event\',\n-            title=u\'event1\'\n+            self.portal, "plone.app.event.dx.event", title="event1"\n         )\n \n         dt = datetime(2161, 1, 1)  # United Federation of Planets\n-        DT = DateTime(\'2161/01/01 00:00:00 UTC\')\n+        DT = DateTime("2161/01/01 00:00:00 UTC")\n \n         acc = IEventAccessor(e1)\n \n@@ -362,10 +363,10 @@ class TestDXIntegration(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n         set_browserlayer(self.request)\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n         self.tz = pytz.timezone(TEST_TIMEZONE)\n \n     def test_start_defaults(self):\n@@ -389,15 +390,13 @@ def test_start_end_dates_indexed(self):\n         end = tz.localize(datetime(2011, 11, 11, 12, 0))\n         e1 = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            title=u\'event1\',\n+            "plone.app.event.dx.event",\n+            title="event1",\n             start=start,\n-            end=end\n+            end=end,\n         )\n \n-        result = self.portal.portal_catalog(\n-            path=\'/\'.join(e1.getPhysicalPath())\n-        )\n+        result = self.portal.portal_catalog(path="/".join(e1.getPhysicalPath()))\n         self.assertEqual(1, len(result))\n \n         # The start and end datetime\'s are indexed as Python datetimes\n@@ -408,15 +407,15 @@ def test_recurrence_indexing(self):\n         tz = pytz.timezone("Europe/Vienna")\n         e1 = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            title=u\'event1\',\n+            "plone.app.event.dx.event",\n+            title="event1",\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             end=tz.localize(datetime(2011, 11, 11, 12, 0)),\n         )\n \n         # When editing via behaviors, the attributes should also be available\n         # on the context itself.\n-        IEventRecurrence(e1).recurrence = \'RRULE:FREQ=DAILY;COUNT=4\'\n+        IEventRecurrence(e1).recurrence = "RRULE:FREQ=DAILY;COUNT=4"\n         self.assertTrue(e1.recurrence == IEventRecurrence(e1).recurrence)\n \n         e1.reindexObject()\n@@ -430,7 +429,7 @@ def test_recurrence_indexing(self):\n             self.portal,\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             ret_mode=base.RET_MODE_OBJECTS,\n-            expand=True\n+            expand=True,\n         )\n         self.assertEqual(len(result), 4)\n \n@@ -440,15 +439,15 @@ class TestDXEventRecurrence(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def test_recurrence(self):\n-        tz = pytz.timezone(\'Europe/Vienna\')\n+        tz = pytz.timezone("Europe/Vienna")\n         duration = timedelta(days=4)\n         mock = MockEvent()\n         mock.start = tz.localize(datetime(2011, 11, 11, 11, 0))\n         mock.end = mock.start + duration\n-        mock.recurrence = \'RRULE:FREQ=DAILY;COUNT=4\'\n+        mock.recurrence = "RRULE:FREQ=DAILY;COUNT=4"\n         zope.interface.alsoProvides(\n-            mock, IEvent, IEventBasic, IEventRecurrence,\n-            IDXEvent, IDXEventRecurrence)\n+            mock, IEvent, IEventBasic, IEventRecurrence, IDXEvent, IDXEventRecurrence\n+        )\n         result = IRecurrenceSupport(mock).occurrences()\n         result = list(result)  # cast generator to list\n \n@@ -462,8 +461,7 @@ def test_recurrence(self):\n \n \n class TestDXEventUnittest(unittest.TestCase):\n-    """ Unit test for Dexterity event behaviors.\n-    """\n+    """Unit test for Dexterity event behaviors."""\n \n     def setUp(self):\n         self.orig_tz = set_env_timezone(TEST_TIMEZONE)\n@@ -545,50 +543,51 @@ def test_validate_dont_validate_incomplete(self):\n \n \n class TestDXAnnotationStorageUpdate(unittest.TestCase):\n-    """ Unit tests for the Annotation Storage migration\n-    """\n+    """Unit tests for the Annotation Storage migration"""\n+\n     layer = PAEventDX_INTEGRATION_TESTING\n \n-    location = u"K\xc3\xb6ln"\n-    attendees = (u\'Peter\', u\'S\xc3\xb8ren\', u\'Madeleine\')\n-    contact_email = u\'person@email.com\'\n-    contact_name = u\'Peter Parker\'\n-    contact_phone = u\'555 123 456\'\n-    event_url = u\'http://my.event.url\'\n-    text = u\'<p>Cathedral Sprint in K\xc3\xb6ln</p>\'\n+    location = "K\xc3\xb6ln"\n+    attendees = ("Peter", "S\xc3\xb8ren", "Madeleine")\n+    contact_email = "person@email.com"\n+    contact_name = "Peter Parker"\n+    contact_phone = "555 123 456"\n+    event_url = "http://my.event.url"\n+    text = "<p>Cathedral Sprint in K\xc3\xb6ln</p>"\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n         set_browserlayer(self.request)\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_migrate_fields(self):\n-        tz = pytz.timezone(\'Europe/Berlin\')\n+        tz = pytz.timezone("Europe/Berlin")\n         e1 = createContentInContainer(\n             self.portal,\n-            \'Event\',\n-            title=u\'event1\',\n+            "Event",\n+            title="event1",\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             end=tz.localize(datetime(2011, 11, 11, 12, 0)),\n         )\n \n         # Fill the field values into the annotation storage\n         ann = IAnnotations(e1)\n-        ann[\'plone.app.event.dx.behaviors.IEventLocation.location\'] = \\\n-            self.location\n-        ann[\'plone.app.event.dx.behaviors.IEventAttendees.attendees\'] = \\\n-            self.attendees\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.contact_email\'] = \\\n-            self.contact_email\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.contact_name\'] = \\\n-            self.contact_name\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.contact_phone\'] = \\\n-            self.contact_phone\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.event_url\'] = \\\n-            self.event_url\n-        ann[\'plone.app.event.dx.behaviors.IEventSummary.text\'] = \\\n-            RichTextValue(raw=self.text)\n+        ann["plone.app.event.dx.behaviors.IEventLocation.location"] = self.location\n+        ann["plone.app.event.dx.behaviors.IEventAttendees.attendees"] = self.attendees\n+        ann[\n+            "plone.app.event.dx.behaviors.IEventContact.contact_email"\n+        ] = self.contact_email\n+        ann[\n+            "plone.app.event.dx.behaviors.IEventContact.contact_name"\n+        ] = self.contact_name\n+        ann[\n+            "plone.app.event.dx.behaviors.IEventContact.contact_phone"\n+        ] = self.contact_phone\n+        ann["plone.app.event.dx.behaviors.IEventContact.event_url"] = self.event_url\n+        ann["plone.app.event.dx.behaviors.IEventSummary.text"] = RichTextValue(\n+            raw=self.text\n+        )\n \n         # All behavior-related fields are not set yet\n         self.assertEqual(e1.location, None)\n@@ -612,31 +611,38 @@ def test_migrate_fields(self):\n         self.assertEqual(e1.text.raw, self.text)\n \n     def test_no_overwrite(self):\n-        tz = pytz.timezone(\'Europe/Berlin\')\n+        tz = pytz.timezone("Europe/Berlin")\n         e1 = createContentInContainer(\n             self.portal,\n-            \'Event\',\n-            title=u\'event1\',\n+            "Event",\n+            title="event1",\n             start=tz.localize(datetime(2011, 11, 11, 11, 0)),\n             end=tz.localize(datetime(2011, 11, 11, 12, 0)),\n         )\n \n         # Fill the field values into the annotation storage\n         ann = IAnnotations(e1)\n-        ann[\'plone.app.event.dx.behaviors.IEventLocation.location\'] = \\\n-            self.location + u\'X\'\n-        ann[\'plone.app.event.dx.behaviors.IEventAttendees.attendees\'] = \\\n-            self.attendees + (u\'Paula\',)\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.contact_email\'] = \\\n-            self.contact_email + u\'X\'\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.contact_name\'] = \\\n-            self.contact_name + u\'X\'\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.contact_phone\'] = \\\n-            self.contact_phone + u\'X\'\n-        ann[\'plone.app.event.dx.behaviors.IEventContact.event_url\'] = \\\n-            self.event_url + u\'X\'\n-        ann[\'plone.app.event.dx.behaviors.IEventSummary.text\'] = \\\n-            RichTextValue(raw=self.text + u\'X\')\n+        ann["plone.app.event.dx.behaviors.IEventLocation.location"] = (\n+            self.location + "X"\n+        )\n+        ann[\n+            "plone.app.event.dx.behaviors.IEventAttendees.attendees"\n+        ] = self.attendees + ("Paula",)\n+        ann["plone.app.event.dx.behaviors.IEventContact.contact_email"] = (\n+            self.contact_email + "X"\n+        )\n+        ann["plone.app.event.dx.behaviors.IEventContact.contact_name"] = (\n+            self.contact_name + "X"\n+        )\n+        ann["plone.app.event.dx.behaviors.IEventContact.contact_phone"] = (\n+            self.contact_phone + "X"\n+        )\n+        ann["plone.app.event.dx.behaviors.IEventContact.event_url"] = (\n+            self.event_url + "X"\n+        )\n+        ann["plone.app.event.dx.behaviors.IEventSummary.text"] = RichTextValue(\n+            raw=self.text + "X"\n+        )\n \n         # Add values into the fields in the new way\n         e1.location = self.location\ndiff --git a/plone/app/event/tests/test_event_listing.py b/plone/app/event/tests/test_event_listing.py\nindex d0d2ab213..b40a5bb2d 100644\n--- a/plone/app/event/tests/test_event_listing.py\n+++ b/plone/app/event/tests/test_event_listing.py\n@@ -1,65 +1,62 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.base import localized_today\n from plone.app.event.testing import make_fake_response\n from plone.app.event.testing import PAEventDX_INTEGRATION_TESTING\n-from plone.app.event.tests.base_setup import patched_now as PN\n from plone.app.event.tests.base_setup import AbstractSampleDataEvents\n-\n-import mock\n+from plone.app.event.tests.base_setup import patched_now as PN\n+from unittest import mock\n \n \n class TestEventsListingPortal(AbstractSampleDataEvents):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n-    def _listing_view(self, name=\'@@event_listing\'):\n+    def _listing_view(self, name="@@event_listing"):\n         return self.portal.restrictedTraverse(name)\n \n-    @mock.patch(\'plone.app.event.browser.event_listing.localized_now\', new=PN)\n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.browser.event_listing.localized_now", new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_get_events_future(self):\n         # Default mode is to show all events from now on.\n         view = self._listing_view()\n         self.assertEqual(len(view.events(batch=False)), 5)\n \n-    @mock.patch(\'plone.app.event.browser.event_listing.localized_now\', new=PN)\n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.browser.event_listing.localized_now", new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_get_events_past(self):\n-        self.request.form.update({\'mode\': \'past\'})\n+        self.request.form.update({"mode": "past"})\n         view = self._listing_view()\n         self.assertEqual(len(view.events(batch=False)), 5)\n \n-    @mock.patch(\'plone.app.event.browser.event_listing.localized_now\', new=PN)\n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.browser.event_listing.localized_now", new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_get_events_all(self):\n-        self.request.form.update({\'mode\': \'all\'})\n+        self.request.form.update({"mode": "all"})\n         view = self._listing_view()\n         self.assertEqual(len(view.events(batch=False)), 8)\n \n-    @mock.patch(\'plone.app.event.browser.event_listing.localized_now\', new=PN)\n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.browser.event_listing.localized_now", new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_get_events_today(self):\n         today = localized_today().isoformat()\n-        self.request.form.update({\'mode\': \'day\', \'date\': today})\n+        self.request.form.update({"mode": "day", "date": today})\n         view = self._listing_view()\n         self.assertEqual(len(view.events(batch=False)), 2)\n \n-    @mock.patch(\'plone.app.event.browser.event_listing.localized_now\', new=PN)\n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.browser.event_listing.localized_now", new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_events_listing_ical(self):\n         # Default mode is to show all events from now on.\n         headers, output, request = make_fake_response(self.request)\n-        view = self._listing_view(name=\'@@event_listing_ical\')\n+        view = self._listing_view(name="@@event_listing_ical")\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n-        icalstr = b\'\'.join(output)\n-        self.assertTrue(b\'Long Event\' in icalstr)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n+        icalstr = b"".join(output)\n+        self.assertTrue(b"Long Event" in icalstr)\n \n \n class TestEventsListingCollection(TestEventsListingPortal):\n-\n-    def _listing_view(self, name=\'@@event_listing\'):\n+    def _listing_view(self, name="@@event_listing"):\n         return self.portal.collection.restrictedTraverse(name)\n \n     def _collection_batching_base(self):\n@@ -70,40 +67,38 @@ def _collection_batching_base(self):\n         environment with newly calculated results.\n         """\n         # plone.app.contenttypes ICollection type\n-        self.portal.invokeFactory(\'Collection\', \'col_test\', title=u\'Col\')\n+        self.portal.invokeFactory("Collection", "col_test", title="Col")\n         collection = self.portal.col_test\n         collection.query = [\n-            {\'i\': \'portal_type\',\n-             \'o\': \'plone.app.querystring.operation.selection.any\',\n-             \'v\': [\'Event\', \'plone.app.event.dx.event\']\n-             },\n+            {\n+                "i": "portal_type",\n+                "o": "plone.app.querystring.operation.selection.any",\n+                "v": ["Event", "plone.app.event.dx.event"],\n+            },\n         ]\n-        self.request.form.update({\'mode\': \'all\'})\n+        self.request.form.update({"mode": "all"})\n         return collection\n \n     def test_collection_batching__all(self):\n-        """Don\'t limit the results.\n-        """\n+        """Don\'t limit the results."""\n         collection = self._collection_batching_base()\n-        view = collection.restrictedTraverse(\'@@event_listing\')\n-        self.assertEqual(len(view.events(batch=True)), 8)\n+        view = collection.restrictedTraverse("@@event_listing")\n+        self.assertEqual(view.events(batch=True).length, 8)\n \n     def test_collection_batching__reduce_by_collection_setting(self):\n-        """Limit the results by setting item_count on the collection.\n-        """\n+        """Limit the results by setting item_count on the collection."""\n         collection = self._collection_batching_base()\n-        view = collection.restrictedTraverse(\'@@event_listing\')\n+        view = collection.restrictedTraverse("@@event_listing")\n         collection.item_count = 4\n-        view = collection.restrictedTraverse(\'@@event_listing\')\n-        self.assertEqual(len(view.events(batch=True)), 4)\n+        view = collection.restrictedTraverse("@@event_listing")\n+        self.assertEqual(view.events(batch=True).length, 4)\n \n     def test_collection_batching__reduce_by_request_parameter(self):\n-        """Limit the results by using a request parameter.\n-        """\n+        """Limit the results by using a request parameter."""\n         collection = self._collection_batching_base()\n-        self.request.form.update({\'b_size\': 2})\n-        view = collection.restrictedTraverse(\'@@event_listing\')\n-        self.assertEqual(len(view.events(batch=True)), 2)\n+        self.request.form.update({"b_size": 2})\n+        view = collection.restrictedTraverse("@@event_listing")\n+        self.assertEqual(view.events(batch=True).length, 2)\n \n     def test_date_filtering(self):\n         """Test if date filters are available on Collections without start or\n@@ -111,46 +106,48 @@ def test_date_filtering(self):\n         """\n         # plone.app.contenttypes ICollection type\n         self.portal.invokeFactory(\n-            \'Collection\', \'col_without_date_criterion\', title=u\'Col\')\n+            "Collection", "col_without_date_criterion", title="Col"\n+        )\n         collection = self.portal.col_without_date_criterion\n         collection.query = [\n-            {\'i\': \'portal_type\',\n-             \'o\': \'plone.app.querystring.operation.selection.any\',\n-             \'v\': [\'Event\', \'plone.app.event.dx.event\']\n-             },\n+            {\n+                "i": "portal_type",\n+                "o": "plone.app.querystring.operation.selection.any",\n+                "v": ["Event", "plone.app.event.dx.event"],\n+            },\n         ]\n         view = self.portal.col_without_date_criterion.restrictedTraverse(\n-            \'@@event_listing\'\n+            "@@event_listing"\n         )\n         out = view()\n-        self.assertTrue(\'mode_past\' in out)\n+        self.assertTrue("mode_past" in out)\n \n     def test_no_date_filtering(self):\n         """Test if date filters are not available on Collections with start or\n         end search criterias.\n         """\n         # plone.app.contenttypes ICollection type\n-        self.portal.invokeFactory(\n-            \'Collection\', \'col_with_date_criterion\', title=u\'Col\')\n+        self.portal.invokeFactory("Collection", "col_with_date_criterion", title="Col")\n         collection = self.portal.col_with_date_criterion\n         collection.query = [\n-            {\'i\': \'portal_type\',\n-             \'o\': \'plone.app.querystring.operation.selection.any\',\n-             \'v\': [\'Event\', \'plone.app.event.dx.event\']\n-             },\n-            {\'i\': \'start\',\n-             \'o\': \'plone.app.querystring.operation.date.afterToday\',\n-             \'v\': \'\'}\n+            {\n+                "i": "portal_type",\n+                "o": "plone.app.querystring.operation.selection.any",\n+                "v": ["Event", "plone.app.event.dx.event"],\n+            },\n+            {\n+                "i": "start",\n+                "o": "plone.app.querystring.operation.date.afterToday",\n+                "v": "",\n+            },\n         ]\n-        view = self.portal.col_with_date_criterion.restrictedTraverse(\n-            \'@@event_listing\'\n-        )\n+        view = self.portal.col_with_date_criterion.restrictedTraverse("@@event_listing")\n         out = view()\n         for _class in [\n-            \'mode_future\',\n-            \'mode_past\',\n-            \'mode_month\',\n-            \'mode_week\',\n-            \'mode_day\',\n+            "mode_future",\n+            "mode_past",\n+            "mode_month",\n+            "mode_week",\n+            "mode_day",\n         ]:\n             self.assertTrue(_class not in out)\ndiff --git a/plone/app/event/tests/test_event_summary.py b/plone/app/event/tests/test_event_summary.py\nindex 3fb71ab2b..3a3a55874 100644\n--- a/plone/app/event/tests/test_event_summary.py\n+++ b/plone/app/event/tests/test_event_summary.py\n@@ -1,10 +1,8 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.dx.traverser import OccurrenceTraverser as OccTravDX\n from plone.app.event.testing import PAEventDX_INTEGRATION_TESTING\n-from plone.app.event.tests.base_setup import patched_now as PN\n from plone.app.event.tests.base_setup import AbstractSampleDataEvents\n-\n-import mock\n+from plone.app.event.tests.base_setup import patched_now as PN\n+from unittest import mock\n \n \n class TestEventSummaryDX(AbstractSampleDataEvents):\n@@ -14,24 +12,22 @@ class TestEventSummaryDX(AbstractSampleDataEvents):\n     def traverser(self):\n         return OccTravDX(self.now_event, self.request)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_summary__non_recurring(self):\n-        """Test if some specific content is included here.\n-        """\n-        view = self.portal.future.restrictedTraverse(\'@@event_summary\')\n+        """Test if some specific content is included here."""\n+        view = self.portal.future.restrictedTraverse("@@event_summary")\n \n         output = view()\n \n-        self.assertTrue(\'2013-05-15\' in output)\n-        self.assertTrue(\'(Europe/Vienna / UTC200)\' in output)\n-        self.assertTrue(\'Graz\' in output)\n-        self.assertTrue(\'All dates\' not in output)\n+        self.assertTrue("2013-05-15" in output)\n+        self.assertTrue("(Europe/Vienna / UTC200)" in output)\n+        self.assertTrue("Graz" in output)\n+        self.assertTrue("All dates" not in output)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_summary__recurring(self):\n-        """Test if some specific content is included here.\n-        """\n-        view = self.portal.now.restrictedTraverse(\'@@event_summary\')\n+        """Test if some specific content is included here."""\n+        view = self.portal.now.restrictedTraverse("@@event_summary")\n \n         self.assertEqual(view.is_occurrence, False)\n         self.assertEqual(len(view.next_occurrences), 3)\n@@ -40,18 +36,17 @@ def test_event_summary__recurring(self):\n         output = view()\n \n         # self.assertTrue(\'Now Event\' not in output)  # Title not shown by def.\n-        self.assertTrue(\'2013-05-05\' in output)\n-        self.assertTrue(\'All dates\' in output)\n-        self.assertTrue(\'2013-05-07\' in output)\n-        self.assertTrue(\'2013-05-09\' in output)\n-        self.assertTrue(\'http://plone.org\' in output)\n+        self.assertTrue("2013-05-05" in output)\n+        self.assertTrue("All dates" in output)\n+        self.assertTrue("2013-05-07" in output)\n+        self.assertTrue("2013-05-09" in output)\n+        self.assertTrue("http://plone.org" in output)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_summary__recurring_occurrence(self):\n-        """Test if some specific content is included here.\n-        """\n-        occ = self.traverser.publishTraverse(self.request, \'2013-05-07\')\n-        view = occ.restrictedTraverse(\'@@event_summary\')\n+        """Test if some specific content is included here."""\n+        occ = self.traverser.publishTraverse(self.request, "2013-05-07")\n+        view = occ.restrictedTraverse("@@event_summary")\n \n         self.assertEqual(view.is_occurrence, True)\n         # Lists only upcoming relative to occurrence\'s date\n@@ -62,14 +57,16 @@ def test_event_summary__recurring_occurrence(self):\n \n         output = view()\n \n-        self.assertTrue(\'Now Event\' not in output)  # Title not shown by def.\n-        self.assertTrue(\'All dates\' in output)\n-        self.assertTrue(\'2013-05-05\' not in output)  # Lists only upcoming relative to occurrence\'s date  # noqa\n-        self.assertTrue(\'2013-05-07\' in output)\n-        self.assertTrue(\'2013-05-09\' in output)\n-        self.assertTrue(\'http://plone.org\' in output)\n+        self.assertTrue("Now Event" not in output)  # Title not shown by def.\n+        self.assertTrue("All dates" in output)\n+        self.assertTrue(\n+            "2013-05-05" not in output\n+        )  # Lists only upcoming relative to occurrence\'s date  # noqa\n+        self.assertTrue("2013-05-07" in output)\n+        self.assertTrue("2013-05-09" in output)\n+        self.assertTrue("http://plone.org" in output)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_summary__recurring_last_occurrence(self):\n         """Test if some specific content is included here.\n \n@@ -77,8 +74,8 @@ def test_event_summary__recurring_last_occurrence(self):\n         the link to the event_listing view, where all occurrences of the event\n         are shown.\n         """\n-        occ = self.traverser.publishTraverse(self.request, \'2013-05-09\')\n-        view = occ.restrictedTraverse(\'@@event_summary\')\n+        occ = self.traverser.publishTraverse(self.request, "2013-05-09")\n+        view = occ.restrictedTraverse("@@event_summary")\n \n         self.assertEqual(view.is_occurrence, True)\n         # Lists only upcoming relative to occurrence\'s date. Here no other,\n@@ -91,29 +88,28 @@ def test_event_summary__recurring_last_occurrence(self):\n \n         output = view()\n \n-        self.assertTrue(\'Now Event\' not in output)  # Title not shown by def.\n-        self.assertTrue(\'All dates\' in output)\n-        self.assertTrue(\'2013-05-05\' not in output)\n-        self.assertTrue(\'2013-05-07\' not in output)\n-        self.assertTrue(\'2013-05-09\' in output)\n-        self.assertTrue(\'http://plone.org\' in output)\n+        self.assertTrue("Now Event" not in output)  # Title not shown by def.\n+        self.assertTrue("All dates" in output)\n+        self.assertTrue("2013-05-05" not in output)\n+        self.assertTrue("2013-05-07" not in output)\n+        self.assertTrue("2013-05-09" in output)\n+        self.assertTrue("http://plone.org" in output)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_summary__recurring_excludes(self):\n-        """Test if some specific content is excluded here.\n-        """\n-        view = self.portal.now.restrictedTraverse(\'@@event_summary\')\n+        """Test if some specific content is excluded here."""\n+        view = self.portal.now.restrictedTraverse("@@event_summary")\n         ex = view.excludes\n-        view.excludes = [\'occurrences\', \'event_url\']\n+        view.excludes = ["occurrences", "event_url"]\n \n         output = view()\n \n-        self.assertTrue(\'Now Event\' not in output)  # Title not shown by def.\n-        self.assertTrue(\'2013-05-05\' in output)\n-        self.assertTrue(\'All dates\' not in output)\n-        self.assertTrue(\'2013-05-07\' not in output)\n-        self.assertTrue(\'2013-05-09\' not in output)\n-        self.assertTrue(\'http://plone.org\' not in output)\n+        self.assertTrue("Now Event" not in output)  # Title not shown by def.\n+        self.assertTrue("2013-05-05" in output)\n+        self.assertTrue("All dates" not in output)\n+        self.assertTrue("2013-05-07" not in output)\n+        self.assertTrue("2013-05-09" not in output)\n+        self.assertTrue("http://plone.org" not in output)\n \n         # Restore default excludes\n         view.excludes = ex\ndiff --git a/plone/app/event/tests/test_event_view.py b/plone/app/event/tests/test_event_view.py\nindex 0a2382f8c..7b081cb60 100644\n--- a/plone/app/event/tests/test_event_view.py\n+++ b/plone/app/event/tests/test_event_view.py\n@@ -1,10 +1,8 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.dx.traverser import OccurrenceTraverser as OccTravDX\n from plone.app.event.testing import PAEventDX_FUNCTIONAL_TESTING\n-from plone.app.event.tests.base_setup import patched_now as PN\n from plone.app.event.tests.base_setup import AbstractSampleDataEvents\n-\n-import mock\n+from plone.app.event.tests.base_setup import patched_now as PN\n+from unittest import mock\n \n \n class FunctionalTestEventViewDX(AbstractSampleDataEvents):\n@@ -14,40 +12,42 @@ class FunctionalTestEventViewDX(AbstractSampleDataEvents):\n     def traverser(self):\n         return OccTravDX(self.now_event, self.request)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_view__non_recurring(self):\n-        view = self.portal.future.restrictedTraverse(\'@@event_view\')\n+        view = self.portal.future.restrictedTraverse("@@event_view")\n \n         output = view()\n \n-        self.assertTrue(\'Future Event\' in output)\n-        self.assertTrue(\'2013-05-15\' in output)\n-        self.assertTrue(\'(Europe/Vienna / UTC200)\' in output)\n-        self.assertTrue(\'Graz\' in output)\n-        self.assertTrue(\'All dates\' not in output)\n+        self.assertTrue("Future Event" in output)\n+        self.assertTrue("2013-05-15" in output)\n+        self.assertTrue("(Europe/Vienna / UTC200)" in output)\n+        self.assertTrue("Graz" in output)\n+        self.assertTrue("All dates" not in output)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_view__recurring(self):\n-        view = self.portal.now.restrictedTraverse(\'@@event_view\')\n+        view = self.portal.now.restrictedTraverse("@@event_view")\n \n         output = view()\n \n-        self.assertTrue(\'Now Event\' in output)\n-        self.assertTrue(\'2013-05-05\' in output)\n-        self.assertTrue(\'All dates\' in output)\n-        self.assertTrue(\'2013-05-07\' in output)\n-        self.assertTrue(\'2013-05-09\' in output)\n-        self.assertTrue(\'http://plone.org\' in output)\n+        self.assertTrue("Now Event" in output)\n+        self.assertTrue("2013-05-05" in output)\n+        self.assertTrue("All dates" in output)\n+        self.assertTrue("2013-05-07" in output)\n+        self.assertTrue("2013-05-09" in output)\n+        self.assertTrue("http://plone.org" in output)\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_event_view__recurring_occurrence(self):\n-        occ = self.traverser.publishTraverse(self.request, \'2013-05-07\')\n-        view = occ.restrictedTraverse(\'@@event_view\')\n+        occ = self.traverser.publishTraverse(self.request, "2013-05-07")\n+        view = occ.restrictedTraverse("@@event_view")\n \n         output = view()\n \n-        self.assertTrue(\'Now Event\' in output)\n-        self.assertTrue(\'2013-05-05\' not in output)  # Lists only upcoming relative to occurrence\'s date  # noqa\n-        self.assertTrue(\'2013-05-07\' in output)\n-        self.assertTrue(\'2013-05-09\' in output)\n-        self.assertTrue(\'http://plone.org\' in output)\n+        self.assertTrue("Now Event" in output)\n+        self.assertTrue(\n+            "2013-05-05" not in output\n+        )  # Lists only upcoming relative to occurrence\'s date  # noqa\n+        self.assertTrue("2013-05-07" in output)\n+        self.assertTrue("2013-05-09" in output)\n+        self.assertTrue("http://plone.org" in output)\ndiff --git a/plone/app/event/tests/test_ical_import.py b/plone/app/event/tests/test_ical_import.py\nindex 16cadaa12..05e0beb80 100644\n--- a/plone/app/event/tests/test_ical_import.py\n+++ b/plone/app/event/tests/test_ical_import.py\n@@ -1,45 +1,42 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.event.interfaces import IICalendarImportEnabled\n from plone.app.event.ical.importer import IcalendarImportSettingsFormView\n+from plone.app.event.interfaces import IICalendarImportEnabled\n from plone.app.event.testing import PAEventDX_FUNCTIONAL_TESTING\n from plone.app.testing import setRoles\n from plone.app.testing import SITE_OWNER_NAME\n from plone.app.testing import SITE_OWNER_PASSWORD\n from plone.app.testing import TEST_USER_ID\n+from plone.testing.zope import Browser\n \n import transaction\n import unittest\n \n-try:\n-    # plone.testing 7+\n-    from plone.testing.zope import Browser\n-except ImportError:\n-    # plone.testing 6-\n-    from plone.testing.z2 import Browser\n-\n \n class TestICALImportSettings(unittest.TestCase):\n \n     layer = PAEventDX_FUNCTIONAL_TESTING\n \n     def setUp(self):\n-        app = self.layer[\'app\']\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        app = self.layer["app"]\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n         self.browser = Browser(app)\n         self.browser.handleErrors = False\n         self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic %s:%s\' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD,)\n+            "Authorization",\n+            "Basic %s:%s"\n+            % (\n+                SITE_OWNER_NAME,\n+                SITE_OWNER_PASSWORD,\n+            ),\n         )\n \n     def test_enable_ical_import(self):\n         """Test that ical import can be enabled/disabled in the browser.\n         Failed in Zope4: https://github.com/zopefoundation/Zope/issues/397\n         """\n-        self.portal.invokeFactory(\'Folder\', \'f1\')\n-        f1 = self.portal[\'f1\']\n+        self.portal.invokeFactory("Folder", "f1")\n+        f1 = self.portal["f1"]\n         self.assertFalse(IICalendarImportEnabled.providedBy(f1))\n \n         # enable/disable with the view\n@@ -50,10 +47,10 @@ def test_enable_ical_import(self):\n         self.assertFalse(IICalendarImportEnabled.providedBy(f1))\n \n         # enable/disable with traversal\n-        enable_method = f1.restrictedTraverse(\'ical_import_settings/enable\')\n+        enable_method = f1.restrictedTraverse("ical_import_settings/enable")\n         enable_method()\n         self.assertTrue(IICalendarImportEnabled.providedBy(f1))\n-        disable_method = f1.restrictedTraverse(\'ical_import_settings/disable\')\n+        disable_method = f1.restrictedTraverse("ical_import_settings/disable")\n         disable_method()\n         self.assertFalse(IICalendarImportEnabled.providedBy(f1))\n \n@@ -61,18 +58,18 @@ def test_enable_ical_import(self):\n         transaction.commit()\n         f1_url = f1.absolute_url()\n         self.assertFalse(IICalendarImportEnabled.providedBy(f1))\n-        self.browser.open(f1_url + \'/ical_import_settings/enable\')\n-        self.browser.getControl(\'Confirm action\').click()\n+        self.browser.open(f1_url + "/ical_import_settings/enable")\n+        self.browser.getControl("Confirm action").click()\n         self.assertTrue(IICalendarImportEnabled.providedBy(f1))\n-        self.browser.open(f1_url + \'/ical_import_settings/disable\')\n-        self.browser.getControl(\'Confirm action\').click()\n+        self.browser.open(f1_url + "/ical_import_settings/disable")\n+        self.browser.getControl("Confirm action").click()\n         self.assertFalse(IICalendarImportEnabled.providedBy(f1))\n \n         # the form can be rendered\n-        self.browser.open(f1_url + \'/ical_import_settings\')\n+        self.browser.open(f1_url + "/ical_import_settings")\n         self.assertIn(\n-            \'URL to an external icalendar resource file\',\n-            self.browser.contents)\n+            "URL to an external icalendar resource file", self.browser.contents\n+        )\n \n     def test_constraint(self):\n         self.portal.invokeFactory("Folder", "f1")\n@@ -86,7 +83,11 @@ def test_constraint(self):\n \n         # Set it to a file url.\n         self.browser.open(f1_url + "/ical_import_settings")\n-        self.assertIn("URL to an external icalendar resource file", self.browser.contents)\n-        self.browser.getControl(name="form.widgets.ical_url").value = "file:///tmp/test.ical"\n+        self.assertIn(\n+            "URL to an external icalendar resource file", self.browser.contents\n+        )\n+        self.browser.getControl(\n+            name="form.widgets.ical_url"\n+        ).value = "file:///tmp/test.ical"\n         self.browser.getControl(name="form.buttons.save").click()\n         self.assertIn("URLs with file: are not allowed.", self.browser.contents)\ndiff --git a/plone/app/event/tests/test_icalendar.py b/plone/app/event/tests/test_icalendar.py\nindex a279ab755..94aa840ff 100644\n--- a/plone/app/event/tests/test_icalendar.py\n+++ b/plone/app/event/tests/test_icalendar.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import datetime\n from plone.app.event import base\n from plone.app.event.dx.traverser import OccurrenceTraverser as OccTravDX\n@@ -14,7 +13,6 @@\n \n import os\n import pytz\n-import six\n import unittest\n \n \n@@ -34,55 +32,54 @@ def checkOrder(self, text, *order):\n         for item in order:\n             position = text.find(item)\n             self.assertTrue(\n-                position >= 0,\n-                \'menu item "%s" missing or out of order\' % item\n+                position >= 0, \'menu item "%s" missing or out of order\' % item\n             )\n             text = text[position:]\n \n     def test_event_ical(self):\n         headers, output, request = make_fake_response(self.request)\n-        view = getMultiAdapter((self.now_event, request), name=\'ics_view\')\n+        view = getMultiAdapter((self.now_event, request), name="ics_view")\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n-        if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n+        output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n         self.checkOrder(\n             icalstr,\n-            \'BEGIN:VCALENDAR\',\n-            \'VERSION:2.0\',\n-            \'PRODID:-//Plone.org//NONSGML plone.app.event//EN\',\n-            \'X-WR-TIMEZONE:Europe/Vienna\',\n-            \'BEGIN:VEVENT\',\n-            \'SUMMARY:Now Event\',\n-            \'DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T100000\',\n-            \'DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T110000\',\n-            \'DTSTAMP;VALUE=DATE-TIME:\',\n-            \'UID:\',\n-            \'RRULE:FREQ=DAILY;COUNT=3;INTERVAL=1\',\n-            \'RDATE;TZID=Europe/Vienna:20130509T000000\',\n-            \'EXDATE;TZID=Europe/Vienna:20130506T000000,20140404T000000\',\n-            \'CATEGORIES:plone,testing\',\n-            \'CONTACT:Auto Testdriver\\\\, +123456789\\\\, testdriver@plone.org\\\\, http://plone\',  # noqa\n-            \' .org\',  # line longer than max length spec by icalendar\n-            \'CREATED;VALUE=DATE-TIME:\',\n-            \'LAST-MODIFIED;VALUE=DATE-TIME:\',\n-            \'LOCATION:Vienna\',\n-            \'URL:http://nohost/plone/now\',\n-            \'END:VEVENT\',\n-            \'BEGIN:VTIMEZONE\',\n-            \'TZID:Europe/Vienna\',\n-            \'X-LIC-LOCATION:Europe/Vienna\',\n-            \'BEGIN:DAYLIGHT\',\n-            \'DTSTART;VALUE=DATE-TIME:20130331T030000\',\n-            \'TZNAME:CEST\',\n-            \'TZOFFSETFROM:+0100\',\n-            \'TZOFFSETTO:+0200\',\n-            \'END:DAYLIGHT\',\n-            \'END:VTIMEZONE\',\n-            \'END:VCALENDAR\')\n+            "BEGIN:VCALENDAR",\n+            "VERSION:2.0",\n+            "PRODID:-//Plone.org//NONSGML plone.app.event//EN",\n+            "X-WR-TIMEZONE:Europe/Vienna",\n+            "BEGIN:VEVENT",\n+            "SUMMARY:Now Event",\n+            "DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T100000",\n+            "DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T110000",\n+            "DTSTAMP;VALUE=DATE-TIME:",\n+            "UID:",\n+            "RRULE:FREQ=DAILY;COUNT=3;INTERVAL=1",\n+            "RDATE;TZID=Europe/Vienna:20130509T000000",\n+            "EXDATE;TZID=Europe/Vienna:20130506T000000,20140404T000000",\n+            "CATEGORIES:plone,testing",\n+            "CONTACT:Auto Testdriver\\\\, +123456789\\\\, testdriver@plone.org\\\\, http://plone",  # noqa\n+            " .org",  # line longer than max length spec by icalendar\n+            "CREATED;VALUE=DATE-TIME:",\n+            "LAST-MODIFIED;VALUE=DATE-TIME:",\n+            "LOCATION:Vienna",\n+            "URL:http://nohost/plone/now",\n+            "END:VEVENT",\n+            "BEGIN:VTIMEZONE",\n+            "TZID:Europe/Vienna",\n+            "X-LIC-LOCATION:Europe/Vienna",\n+            "BEGIN:DAYLIGHT",\n+            "DTSTART;VALUE=DATE-TIME:20130331T030000",\n+            "TZNAME:CEST",\n+            "TZOFFSETFROM:+0100",\n+            "TZOFFSETTO:+0200",\n+            "END:DAYLIGHT",\n+            "END:VTIMEZONE",\n+            "END:VCALENDAR",\n+        )\n \n     def test_event_occurrence_ical(self):\n         """A event occurrence should not conain recurrence definitions from\n@@ -90,105 +87,100 @@ def test_event_occurrence_ical(self):\n         """\n         headers, output, request = make_fake_response(self.request)\n         occ = self.traverser(self.now_event, request).publishTraverse(\n-            request, \'2013-05-07\'\n+            request, "2013-05-07"\n         )\n-        view = getMultiAdapter((occ, request), name=\'ics_view\')\n+        view = getMultiAdapter((occ, request), name="ics_view")\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n-        if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n-        self.assertTrue(\'Now Event\' in icalstr)\n-        self.assertTrue(\'RRULE\' not in icalstr)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n+        output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n+        self.assertTrue("Now Event" in icalstr)\n+        self.assertTrue("RRULE" not in icalstr)\n \n     def test_portal_ical(self):\n         headers, output, request = make_fake_response(self.request)\n-        view = getMultiAdapter((self.portal, request), name=\'ics_view\')\n+        view = getMultiAdapter((self.portal, request), name="ics_view")\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n-        if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n+        output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n \n         # No occurrences in export. Otherwise count would be 8.\n-        self.assertEqual(icalstr.count(\'BEGIN:VEVENT\'), 4)\n+        self.assertEqual(icalstr.count("BEGIN:VEVENT"), 4)\n         self.checkOrder(\n             icalstr,\n-            \'BEGIN:VCALENDAR\',\n-            \'VERSION:2.0\',\n-            \'PRODID:-//Plone.org//NONSGML plone.app.event//EN\',\n-            \'X-WR-TIMEZONE:Europe/Vienna\',\n+            "BEGIN:VCALENDAR",\n+            "VERSION:2.0",\n+            "PRODID:-//Plone.org//NONSGML plone.app.event//EN",\n+            "X-WR-TIMEZONE:Europe/Vienna",\n             # whole_day event\n-            \'BEGIN:VEVENT\',\n-            \'SUMMARY:Past Event\',\n-            \'DTSTART;VALUE=DATE:20130425\',\n-            \'DTEND;VALUE=DATE:20130426\',\n-            \'DTSTAMP;VALUE=DATE-TIME:\',\n-            \'UID:\',\n-            \'RRULE:FREQ=DAILY;COUNT=3\',\n-            \'CREATED;VALUE=DATE-TIME:\',\n-            \'LAST-MODIFIED;VALUE=DATE-TIME:\',\n-            \'LOCATION:Vienna\',\n-            \'URL:http://nohost/plone/past\',\n-            \'END:VEVENT\',\n-\n-            \'BEGIN:VEVENT\',\n-            \'SUMMARY:Long Event\',\n-            \'DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130425T100000\',\n-            \'DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130604T100000\',\n-            \'DTSTAMP;VALUE=DATE-TIME:\',\n-            \'UID:\',\n-            \'CREATED;VALUE=DATE-TIME:\',\n-            \'LAST-MODIFIED;VALUE=DATE-TIME:\',\n-            \'LOCATION:Schaftal\',\n-            \'URL:http://nohost/plone/sub/long\',\n-            \'END:VEVENT\',\n-\n-            \'BEGIN:VEVENT\',\n-            \'SUMMARY:Now Event\',\n-            \'DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T100000\',\n-            \'DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T110000\',\n-            \'DTSTAMP;VALUE=DATE-TIME:\',\n-            \'UID:\',\n-            \'RRULE:FREQ=DAILY;COUNT=3;INTERVAL=1\',\n-            \'RDATE;TZID=Europe/Vienna:20130509T000000\',\n-            \'EXDATE;TZID=Europe/Vienna:20130506T000000,20140404T000000\',\n-            \'CATEGORIES:plone,testing\',\n-            \'CONTACT:Auto Testdriver\\\\, +123456789\\\\, testdriver@plone.org\\\\, http://plone\',  # noqa\n-            \' .org\',\n-            \'CREATED;VALUE=DATE-TIME:\',\n-            \'LAST-MODIFIED;VALUE=DATE-TIME:\',\n-            \'LOCATION:Vienna\',\n-            \'URL:http://nohost/plone/now\',\n-            \'END:VEVENT\',\n-\n-            \'BEGIN:VEVENT\',\n-            \'SUMMARY:Future Event\',\n-            \'DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130515T100000\',\n-            \'DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130515T110000\',\n-            \'DTSTAMP;VALUE=DATE-TIME:\',\n-            \'UID:\',\n-            \'CREATED;VALUE=DATE-TIME:\',\n-            \'LAST-MODIFIED;VALUE=DATE-TIME:\',\n-            \'LOCATION:Graz\',\n-            \'URL:http://nohost/plone/future\',\n-            \'END:VEVENT\',\n-\n-            \'BEGIN:VTIMEZONE\',\n-            \'TZID:Europe/Vienna\',\n-            \'X-LIC-LOCATION:Europe/Vienna\',\n-            \'BEGIN:DAYLIGHT\',\n-            \'DTSTART;VALUE=DATE-TIME:20130331T030000\',\n-            \'TZNAME:CEST\',\n-            \'TZOFFSETFROM:+0100\',\n-            \'TZOFFSETTO:+0200\',\n-            \'END:DAYLIGHT\',\n-            \'END:VTIMEZONE\',\n-            \'END:VCALENDAR\')\n+            "BEGIN:VEVENT",\n+            "SUMMARY:Past Event",\n+            "DTSTART;VALUE=DATE:20130425",\n+            "DTEND;VALUE=DATE:20130426",\n+            "DTSTAMP;VALUE=DATE-TIME:",\n+            "UID:",\n+            "RRULE:FREQ=DAILY;COUNT=3",\n+            "CREATED;VALUE=DATE-TIME:",\n+            "LAST-MODIFIED;VALUE=DATE-TIME:",\n+            "LOCATION:Vienna",\n+            "URL:http://nohost/plone/past",\n+            "END:VEVENT",\n+            "BEGIN:VEVENT",\n+            "SUMMARY:Long Event",\n+            "DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130425T100000",\n+            "DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130604T100000",\n+            "DTSTAMP;VALUE=DATE-TIME:",\n+            "UID:",\n+            "CREATED;VALUE=DATE-TIME:",\n+            "LAST-MODIFIED;VALUE=DATE-TIME:",\n+            "LOCATION:Schaftal",\n+            "URL:http://nohost/plone/sub/long",\n+            "END:VEVENT",\n+            "BEGIN:VEVENT",\n+            "SUMMARY:Now Event",\n+            "DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T100000",\n+            "DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130505T110000",\n+            "DTSTAMP;VALUE=DATE-TIME:",\n+            "UID:",\n+            "RRULE:FREQ=DAILY;COUNT=3;INTERVAL=1",\n+            "RDATE;TZID=Europe/Vienna:20130509T000000",\n+            "EXDATE;TZID=Europe/Vienna:20130506T000000,20140404T000000",\n+            "CATEGORIES:plone,testing",\n+            "CONTACT:Auto Testdriver\\\\, +123456789\\\\, testdriver@plone.org\\\\, http://plone",  # noqa\n+            " .org",\n+            "CREATED;VALUE=DATE-TIME:",\n+            "LAST-MODIFIED;VALUE=DATE-TIME:",\n+            "LOCATION:Vienna",\n+            "URL:http://nohost/plone/now",\n+            "END:VEVENT",\n+            "BEGIN:VEVENT",\n+            "SUMMARY:Future Event",\n+            "DTSTART;TZID=Europe/Vienna;VALUE=DATE-TIME:20130515T100000",\n+            "DTEND;TZID=Europe/Vienna;VALUE=DATE-TIME:20130515T110000",\n+            "DTSTAMP;VALUE=DATE-TIME:",\n+            "UID:",\n+            "CREATED;VALUE=DATE-TIME:",\n+            "LAST-MODIFIED;VALUE=DATE-TIME:",\n+            "LOCATION:Graz",\n+            "URL:http://nohost/plone/future",\n+            "END:VEVENT",\n+            "BEGIN:VTIMEZONE",\n+            "TZID:Europe/Vienna",\n+            "X-LIC-LOCATION:Europe/Vienna",\n+            "BEGIN:DAYLIGHT",\n+            "DTSTART;VALUE=DATE-TIME:20130331T030000",\n+            "TZNAME:CEST",\n+            "TZOFFSETFROM:+0100",\n+            "TZOFFSETTO:+0200",\n+            "END:DAYLIGHT",\n+            "END:VTIMEZONE",\n+            "END:VCALENDAR",\n+        )\n \n     def test_event_listing_ical_portal(self):\n         """Test event_listing ical export. It should contain all events from\n@@ -196,19 +188,16 @@ def test_event_listing_ical_portal(self):\n         are exported.\n         """\n         headers, output, request = make_fake_response(self.request)\n-        view = getMultiAdapter(\n-            (self.portal, request), name=\'event_listing_ical\'\n-        )\n-        view.mode = \'all\'\n+        view = getMultiAdapter((self.portal, request), name="event_listing_ical")\n+        view.mode = "all"\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n-        if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n+        output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n         # No occurrences in export. Otherwise count would be 8.\n-        self.assertEqual(icalstr.count(\'BEGIN:VEVENT\'), 4)\n+        self.assertEqual(icalstr.count("BEGIN:VEVENT"), 4)\n \n     def test_event_listing_ical_portal__specific_date(self):\n         """Test event_listing ical export for a specific date. The date is when\n@@ -216,38 +205,30 @@ def test_event_listing_ical_portal__specific_date(self):\n         original event and the long lasting event.\n         """\n         headers, output, request = make_fake_response(self.request)\n-        view = getMultiAdapter(\n-            (self.portal, request), name=\'event_listing_ical\'\n-        )\n-        view.mode = \'day\'\n-        view._date = \'2013-04-27\'\n+        view = getMultiAdapter((self.portal, request), name="event_listing_ical")\n+        view.mode = "day"\n+        view._date = "2013-04-27"\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n-        if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n-        self.assertEqual(icalstr.count(\'BEGIN:VEVENT\'), 2)\n-        self.assertTrue(\'Past Event\' in icalstr)\n-        self.assertTrue(\'Long Event\' in icalstr)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n+        output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n+        self.assertEqual(icalstr.count("BEGIN:VEVENT"), 2)\n+        self.assertTrue("Past Event" in icalstr)\n+        self.assertTrue("Long Event" in icalstr)\n \n     def test_collection_ical(self):\n-        """Test basic icalendar export from Collections.\n-        """\n+        """Test basic icalendar export from Collections."""\n         headers, output, request = make_fake_response(self.request)\n-        view = getMultiAdapter(\n-            (self.portal.collection, request),\n-            name=\'ics_view\'\n-        )\n+        view = getMultiAdapter((self.portal.collection, request), name="ics_view")\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n-        if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n-        self.assertEqual(icalstr.count(\'BEGIN:VEVENT\'), 4)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n+        output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n+        self.assertEqual(icalstr.count("BEGIN:VEVENT"), 4)\n \n     def test_collection_all_ical(self):\n         """Test basic icalendar export from Collections, which returns not only\n@@ -255,48 +236,45 @@ def test_collection_all_ical(self):\n         """\n         headers, output, request = make_fake_response(self.request)\n         self.portal.collection.query = [\n-            {\'i\': \'portal_type\',\n-             \'o\': \'plone.app.querystring.operation.selection.any\',\n-             \'v\': [\'Event\', \'plone.app.event.dx.event\', \'Page\']\n-             },\n+            {\n+                "i": "portal_type",\n+                "o": "plone.app.querystring.operation.selection.any",\n+                "v": ["Event", "plone.app.event.dx.event", "Page"],\n+            },\n         ]\n-        view = getMultiAdapter(\n-            (self.portal.collection, request),\n-            name=\'ics_view\'\n-        )\n+        view = getMultiAdapter((self.portal.collection, request), name="ics_view")\n         view()\n         self.assertEqual(len(headers), 3)\n-        self.assertEqual(headers[\'Content-Type\'], \'text/calendar\')\n-        self.assertTrue(\'Content-Length\' in headers)\n-        if six.PY3:\n-            output = [i.decode(\'utf8\') for i in output]\n-        icalstr = \'\'.join(output)\n-        self.assertEqual(icalstr.count(\'BEGIN:VEVENT\'), 4)\n+        self.assertEqual(headers["Content-Type"], "text/calendar")\n+        self.assertTrue("Content-Length" in headers)\n+        output = [i.decode("utf8") for i in output]\n+        icalstr = "".join(output)\n+        self.assertEqual(icalstr.count("BEGIN:VEVENT"), 4)\n \n \n class TestIcalImportDX(unittest.TestCase):\n     layer = PAEventDX_FUNCTIONAL_TESTING\n-    event_type = \'plone.app.event.dx.event\'\n+    event_type = "plone.app.event.dx.event"\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_import_from_ics(self):\n         # Ical import unit test.\n-        self.portal.invokeFactory(\'Folder\', \'impfolder1\')\n+        self.portal.invokeFactory("Folder", "impfolder1")\n         impfolder = self.portal.impfolder1\n \n         directory = os.path.dirname(__file__)\n-        with open(os.path.join(directory, \'icaltest.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest.ics"), "rb") as icsfile:\n             icsdata = icsfile.read()\n         res = ical_import(impfolder, icsdata, self.event_type)\n \n-        self.assertEqual(res[\'count\'], 5)\n+        self.assertEqual(res["count"], 5)\n         self.assertEqual(len(impfolder.contentIds()), 5)\n \n-        at = pytz.timezone(\'Europe/Vienna\')\n+        at = pytz.timezone("Europe/Vienna")\n         utc = pytz.utc\n \n         # Use pydt to normalize for DST times.\n@@ -304,146 +282,96 @@ def test_import_from_ics(self):\n         # TODO: test for attendees. see note in\n         # plone.app.event.ical.importer.ical_import\n         e1 = IEventAccessor(impfolder.e1)\n-        self.assertEqual(\n-            e1.start,\n-            at.localize(datetime(2013, 7, 19, 12, 0))\n-        )\n-        self.assertEqual(\n-            e1.end,\n-            at.localize(datetime(2013, 7, 20, 13, 0))\n-        )\n-        self.assertEqual(\n-            e1.description,\n-            \'A basic event with many properties.\'\n-        )\n-        self.assertEqual(\n-            e1.whole_day,\n-            False\n-        )\n-        self.assertEqual(\n-            e1.open_end,\n-            False\n-        )\n+        self.assertEqual(e1.start, at.localize(datetime(2013, 7, 19, 12, 0)))\n+        self.assertEqual(e1.end, at.localize(datetime(2013, 7, 20, 13, 0)))\n+        self.assertEqual(e1.description, "A basic event with many properties.")\n+        self.assertEqual(e1.whole_day, False)\n+        self.assertEqual(e1.open_end, False)\n         self.assertEqual(\n             e1.sync_uid,\n-            u\'48f1a7ad64e847568d860cd092344970\',\n+            "48f1a7ad64e847568d860cd092344970",\n         )\n \n         e2 = IEventAccessor(impfolder.e2)\n-        self.assertEqual(\n-            e2.start,\n-            utc.localize(datetime(1996, 4, 1, 1, 0))\n-        )\n-        self.assertEqual(\n-            e2.end,\n-            utc.localize(datetime(1996, 4, 1, 2, 0))\n-        )\n+        self.assertEqual(e2.start, utc.localize(datetime(1996, 4, 1, 1, 0)))\n+        self.assertEqual(e2.end, utc.localize(datetime(1996, 4, 1, 2, 0)))\n         self.assertEqual(\n             e2.recurrence,\n-            u\'RRULE:FREQ=DAILY;COUNT=100\\nEXDATE:19960402T010000Z,\'\n-            u\'19960403T010000Z,19960404T010000Z\'\n+            "RRULE:FREQ=DAILY;COUNT=100\\nEXDATE:19960402T010000Z,"\n+            "19960403T010000Z,19960404T010000Z",\n         )\n \n         e3 = IEventAccessor(impfolder.e3)\n-        self.assertEqual(\n-            e3.start,\n-            at.localize(datetime(2012, 3, 27, 10, 0))\n-        )\n-        self.assertEqual(\n-            e3.end,\n-            at.localize(datetime(2012, 3, 27, 18, 0))\n-        )\n+        self.assertEqual(e3.start, at.localize(datetime(2012, 3, 27, 10, 0)))\n+        self.assertEqual(e3.end, at.localize(datetime(2012, 3, 27, 18, 0)))\n         self.assertEqual(\n             e3.recurrence,\n-            u\'RRULE:FREQ=WEEKLY;UNTIL=20120703T080000Z;BYDAY=TU\\n\'\n-            u\'EXDATE:20120529T100000,20120403T100000,20120410T100000,\'\n-            u\'20120501T100000,20120417T100000\'\n+            "RRULE:FREQ=WEEKLY;UNTIL=20120703T080000Z;BYDAY=TU\\n"\n+            "EXDATE:20120529T100000,20120403T100000,20120410T100000,"\n+            "20120501T100000,20120417T100000",\n         )\n \n         e4 = IEventAccessor(impfolder.e4)\n-        self.assertEqual(\n-            e4.start,\n-            utc.localize(datetime(2013, 4, 4, 0, 0))\n-        )\n-        self.assertEqual(\n-            e4.end,\n-            utc.localize(datetime(2013, 4, 4, 23, 59, 59))\n-        )\n-        self.assertEqual(\n-            e4.whole_day,\n-            True\n-        )\n-        self.assertEqual(\n-            e4.open_end,\n-            False\n-        )\n+        self.assertEqual(e4.start, utc.localize(datetime(2013, 4, 4, 0, 0)))\n+        self.assertEqual(e4.end, utc.localize(datetime(2013, 4, 4, 23, 59, 59)))\n+        self.assertEqual(e4.whole_day, True)\n+        self.assertEqual(e4.open_end, False)\n \n         e5 = IEventAccessor(impfolder.e5)\n-        self.assertEqual(\n-            e5.start,\n-            utc.localize(datetime(2013, 4, 2, 12, 0))\n-        )\n-        self.assertEqual(\n-            e5.end,\n-            utc.localize(datetime(2013, 4, 2, 23, 59, 59))\n-        )\n-        self.assertEqual(\n-            e5.whole_day,\n-            False\n-        )\n-        self.assertEqual(\n-            e5.open_end,\n-            True\n-        )\n+        self.assertEqual(e5.start, utc.localize(datetime(2013, 4, 2, 12, 0)))\n+        self.assertEqual(e5.end, utc.localize(datetime(2013, 4, 2, 23, 59, 59)))\n+        self.assertEqual(e5.whole_day, False)\n+        self.assertEqual(e5.open_end, True)\n \n     def test_import_from_ics__no_sync(self):\n         """SYNC_NONE and importing the same file again should create new event\n         objects and give them each a new sync_uid.\n         """\n-        self.portal.invokeFactory(\'Folder\', \'impfolder2\')\n+        self.portal.invokeFactory("Folder", "impfolder2")\n         impfolder = self.portal.impfolder2\n \n         directory = os.path.dirname(__file__)\n-        with open(os.path.join(directory, \'icaltest.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest.ics"), "rb") as icsfile:\n             icsdata = icsfile.read()\n \n         res = ical_import(impfolder, icsdata, self.event_type)\n \n-        self.assertEqual(res[\'count\'], 5)\n+        self.assertEqual(res["count"], 5)\n \n-        e11 = impfolder[\'e1\']\n+        e11 = impfolder["e1"]\n         suid1 = IEventAccessor(e11).sync_uid\n \n-        res = ical_import(impfolder, icsdata, self.event_type,\n-                          sync_strategy=base.SYNC_NONE)\n-        self.assertEqual(res[\'count\'], 5)\n+        res = ical_import(\n+            impfolder, icsdata, self.event_type, sync_strategy=base.SYNC_NONE\n+        )\n+        self.assertEqual(res["count"], 5)\n \n-        e12 = impfolder[\'e1-1\']\n+        e12 = impfolder["e1-1"]\n         suid2 = IEventAccessor(e12).sync_uid\n \n         self.assertEqual(len(impfolder.contentIds()), 10)\n         self.assertNotEqual(suid1, suid2)\n \n     def test_import_from_ics__sync_keep_mine(self):\n-        """SYNC_KEEP_MINE and importing the same file again should do nothing.\n-        """\n-        self.portal.invokeFactory(\'Folder\', \'impfolder3\')\n+        """SYNC_KEEP_MINE and importing the same file again should do nothing."""\n+        self.portal.invokeFactory("Folder", "impfolder3")\n         impfolder = self.portal.impfolder3\n \n         directory = os.path.dirname(__file__)\n-        with open(os.path.join(directory, \'icaltest.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest.ics"), "rb") as icsfile:\n             icsdata = icsfile.read()\n \n         res = ical_import(impfolder, icsdata, self.event_type)\n-        self.assertEqual(res[\'count\'], 5)\n+        self.assertEqual(res["count"], 5)\n \n         e1a = IEventAccessor(impfolder.e1)\n         mod1 = e1a.last_modified\n         suid1 = e1a.sync_uid\n \n-        res = ical_import(impfolder, icsdata, self.event_type,\n-                          sync_strategy=base.SYNC_KEEP_MINE)\n-        self.assertEqual(res[\'count\'], 0)\n+        res = ical_import(\n+            impfolder, icsdata, self.event_type, sync_strategy=base.SYNC_KEEP_MINE\n+        )\n+        self.assertEqual(res["count"], 0)\n         e1a = IEventAccessor(impfolder.e1)\n         mod2 = e1a.last_modified\n         suid2 = e1a.sync_uid\n@@ -457,18 +385,18 @@ def test_import_from_ics__sync_drop_older(self):\n         """SYNC_KEEP_NEWER and importing the same file again should update only\n         newer and on equal modified date but drop the change when it is older.\n         """\n-        self.portal.invokeFactory(\'Folder\', \'impfolder4\')\n+        self.portal.invokeFactory("Folder", "impfolder4")\n         impfolder = self.portal.impfolder4\n \n         directory = os.path.dirname(__file__)\n-        with open(os.path.join(directory, \'icaltest.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest.ics"), "rb") as icsfile:\n             icsdata1 = icsfile.read()\n \n-        with open(os.path.join(directory, \'icaltest2.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest2.ics"), "rb") as icsfile:\n             icsdata2 = icsfile.read()\n \n         res = ical_import(impfolder, icsdata1, self.event_type)\n-        self.assertEqual(res[\'count\'], 5)\n+        self.assertEqual(res["count"], 5)\n \n         e1a = IEventAccessor(impfolder.e1)\n         mod1 = e1a.last_modified\n@@ -478,9 +406,10 @@ def test_import_from_ics__sync_drop_older(self):\n         start1 = e1a.start\n         end1 = e1a.end\n \n-        res = ical_import(impfolder, icsdata2, self.event_type,\n-                          sync_strategy=base.SYNC_KEEP_NEWER)\n-        self.assertEqual(res[\'count\'], 4)\n+        res = ical_import(\n+            impfolder, icsdata2, self.event_type, sync_strategy=base.SYNC_KEEP_NEWER\n+        )\n+        self.assertEqual(res["count"], 4)\n         e1a = IEventAccessor(impfolder.e1)\n         mod2 = e1a.last_modified\n         suid2 = e1a.sync_uid\n@@ -502,19 +431,19 @@ def test_import_from_ics__sync_keep_theirs(self):\n         """SYNC_KEEP_THEIRS and importing the same file again should update\n         all.\n         """\n-        self.portal.invokeFactory(\'Folder\', \'impfolder5\')\n+        self.portal.invokeFactory("Folder", "impfolder5")\n         impfolder = self.portal.impfolder5\n \n         directory = os.path.dirname(__file__)\n \n-        with open(os.path.join(directory, \'icaltest.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest.ics"), "rb") as icsfile:\n             icsdata1 = icsfile.read()\n \n-        with open(os.path.join(directory, \'icaltest2.ics\'), \'rb\') as icsfile:\n+        with open(os.path.join(directory, "icaltest2.ics"), "rb") as icsfile:\n             icsdata2 = icsfile.read()\n \n         res = ical_import(impfolder, icsdata1, self.event_type)\n-        self.assertEqual(res[\'count\'], 5)\n+        self.assertEqual(res["count"], 5)\n \n         e1a = IEventAccessor(impfolder.e1)\n         mod11 = e1a.last_modified\n@@ -531,9 +460,10 @@ def test_import_from_ics__sync_keep_theirs(self):\n         start21 = e2a.start\n         end21 = e2a.end\n \n-        res = ical_import(impfolder, icsdata2, self.event_type,\n-                          sync_strategy=base.SYNC_KEEP_THEIRS)\n-        self.assertEqual(res[\'count\'], 5)\n+        res = ical_import(\n+            impfolder, icsdata2, self.event_type, sync_strategy=base.SYNC_KEEP_THEIRS\n+        )\n+        self.assertEqual(res["count"], 5)\n \n         e1a = IEventAccessor(impfolder.e1)\n         mod12 = e1a.last_modified\ndiff --git a/plone/app/event/tests/test_portlet_calendar.py b/plone/app/event/tests/test_portlet_calendar.py\nindex 618bb8588..a5a8ada17 100644\n--- a/plone/app/event/tests/test_portlet_calendar.py\n+++ b/plone/app/event/tests/test_portlet_calendar.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from calendar import monthrange\n from datetime import datetime\n from datetime import timedelta\n@@ -27,33 +26,35 @@\n import unittest\n \n \n-TZNAME = \'Europe/Vienna\'\n-PTYPE = \'plone.app.event.dx.event\'\n+TZNAME = "Europe/Vienna"\n+PTYPE = "plone.app.event.dx.event"\n \n \n class PortletTest(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        portal = self.layer[\'portal\']\n+        portal = self.layer["portal"]\n         self.portal = portal\n-        self.request = self.layer[\'request\']\n-        setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+        self.request = self.layer["request"]\n+        setRoles(portal, TEST_USER_ID, ["Manager"])\n         setHooks()\n         setSite(portal)\n \n     def testPortletTypeRegistered(self):\n-        portlet = getUtility(IPortletType, name=\'portlets.Calendar\')\n-        self.assertEqual(portlet.addview, \'portlets.Calendar\')\n+        portlet = getUtility(IPortletType, name="portlets.Calendar")\n+        self.assertEqual(portlet.addview, "portlets.Calendar")\n \n     def testRegisteredInterfaces(self):\n-        portlet = getUtility(IPortletType, name=\'portlets.Calendar\')\n+        portlet = getUtility(IPortletType, name="portlets.Calendar")\n         registered_interfaces = [_getDottedName(i) for i in portlet.for_]\n         registered_interfaces.sort()\n-        self.assertEqual([\n-            \'plone.app.portlets.interfaces.IColumn\',\n-            \'plone.app.portlets.interfaces.IDashboard\'],\n-            registered_interfaces\n+        self.assertEqual(\n+            [\n+                "plone.app.portlets.interfaces.IColumn",\n+                "plone.app.portlets.interfaces.IDashboard",\n+            ],\n+            registered_interfaces,\n         )\n \n     def testInterfaces(self):\n@@ -62,13 +63,11 @@ def testInterfaces(self):\n         self.assertTrue(IPortletDataProvider.providedBy(portlet.data))\n \n     def testInvokeAddview(self):\n-        portlet = getUtility(IPortletType, name=\'portlets.Calendar\')\n-        mapping = self.portal.restrictedTraverse(\n-            \'++contextportlets++plone.leftcolumn\'\n-        )\n+        portlet = getUtility(IPortletType, name="portlets.Calendar")\n+        mapping = self.portal.restrictedTraverse("++contextportlets++plone.leftcolumn")\n         for m in mapping.keys():\n             del mapping[m]\n-        addview = mapping.restrictedTraverse(\'+/\' + portlet.addview)\n+        addview = mapping.restrictedTraverse("+/" + portlet.addview)\n \n         addview.createAndAdd(data={})\n \n@@ -79,17 +78,14 @@ def testInvokeAddview(self):\n \n     def testRenderer(self):\n         context = self.portal\n-        view = context.restrictedTraverse(\'@@plone\')\n+        view = context.restrictedTraverse("@@plone")\n         manager = getUtility(\n-            IPortletManager,\n-            name=\'plone.rightcolumn\',\n-            context=self.portal\n+            IPortletManager, name="plone.rightcolumn", context=self.portal\n         )\n         assignment = portlet_calendar.Assignment()\n \n         renderer = getMultiAdapter(\n-            (context, self.request, view, manager, assignment),\n-            IPortletRenderer\n+            (context, self.request, view, manager, assignment), IPortletRenderer\n         )\n         self.assertTrue(isinstance(renderer, portlet_calendar.Renderer))\n \n@@ -98,27 +94,26 @@ class RendererTest(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        portal = self.layer[\'portal\']\n+        portal = self.layer["portal"]\n         self.portal = portal\n-        self.request = self.layer[\'request\']\n-        self.wft = getToolByName(self.portal, \'portal_workflow\')\n+        self.request = self.layer["request"]\n+        self.wft = getToolByName(self.portal, "portal_workflow")\n         self.wft.setDefaultChain("simple_publication_workflow")\n-        setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(portal, TEST_USER_ID, ["Manager"])\n         setHooks()\n         setSite(portal)\n \n         set_env_timezone(TZNAME)\n         set_timezone(TZNAME)\n \n-    def renderer(self, context=None, request=None, view=None, manager=None,\n-                 assignment=None):\n+    def renderer(\n+        self, context=None, request=None, view=None, manager=None, assignment=None\n+    ):\n         context = context or self.portal\n         request = request or self.request\n-        view = view or context.restrictedTraverse(\'@@plone\')\n+        view = view or context.restrictedTraverse("@@plone")\n         manager = manager or getUtility(\n-            IPortletManager,\n-            name=\'plone.rightcolumn\',\n-            context=self.portal\n+            IPortletManager, name="plone.rightcolumn", context=self.portal\n         )\n         assignment = assignment or portlet_calendar.Assignment()\n \n@@ -132,49 +127,58 @@ def test_portlet_config(self):\n         end = start + timedelta(hours=1)\n \n         e1 = createContentInContainer(\n-            self.portal, PTYPE, title=u\'e1\', start=start, end=end)\n-        self.portal.invokeFactory(\'Folder\', \'eventfolder\')\n+            self.portal, PTYPE, title="e1", start=start, end=end\n+        )\n+        self.portal.invokeFactory("Folder", "eventfolder")\n         createContentInContainer(\n-            self.portal.eventfolder, PTYPE, title=u\'e2\', start=start, end=end)\n-        self.portal.portal_workflow.doActionFor(e1, \'publish\')\n+            self.portal.eventfolder, PTYPE, title="e2", start=start, end=end\n+        )\n+        self.portal.portal_workflow.doActionFor(e1, "publish")\n \n-        r = self.renderer(assignment=portlet_calendar.Assignment(\n-            state=(\'draft\',)))\n+        r = self.renderer(assignment=portlet_calendar.Assignment(state=("draft",)))\n         r.update()\n         rd = r.render()\n-        self.assertTrue(\'e1\' not in rd and \'e2\' not in rd)\n+        self.assertTrue("e1" not in rd and "e2" not in rd)\n \n-        r = self.renderer(assignment=portlet_calendar.Assignment(\n-            state=(\'published\', )))\n+        r = self.renderer(assignment=portlet_calendar.Assignment(state=("published",)))\n         r.update()\n         rd = r.render()\n-        self.assertTrue(\'e1\' in rd and \'e2\' not in rd)\n+        self.assertTrue("e1" in rd and "e2" not in rd)\n \n-        r = self.renderer(assignment=portlet_calendar.Assignment(\n-            state=(\'published\', \'private\',)))\n+        r = self.renderer(\n+            assignment=portlet_calendar.Assignment(\n+                state=(\n+                    "published",\n+                    "private",\n+                )\n+            )\n+        )\n         r.update()\n         rd = r.render()\n-        self.assertTrue(\'e1\' in rd and \'e2\' in rd)\n+        self.assertTrue("e1" in rd and "e2" in rd)\n \n         r = self.renderer(assignment=portlet_calendar.Assignment())\n         r.update()\n         rd = r.render()\n-        self.assertTrue(\'e1\' in rd and \'e2\' in rd)\n+        self.assertTrue("e1" in rd and "e2" in rd)\n \n         # No search base gives calendar urls with event_listing part\n-        self.assertTrue(\'event_listing?mode=day\' in rd)\n+        self.assertTrue("event_listing?mode=day" in rd)\n \n-        r = self.renderer(assignment=portlet_calendar.Assignment(\n-            search_base_uid=self.portal.eventfolder.UID()))\n+        r = self.renderer(\n+            assignment=portlet_calendar.Assignment(\n+                search_base_uid=self.portal.eventfolder.UID()\n+            )\n+        )\n         r.update()\n         rd = r.render()\n-        self.assertTrue(\'e1\' not in rd and \'e2\' in rd)\n+        self.assertTrue("e1" not in rd and "e2" in rd)\n \n         # A given search base gives calendar urls without event_listing part\n-        self.assertTrue(\'event_listing?mode=day\' not in rd)\n+        self.assertTrue("event_listing?mode=day" not in rd)\n \n         # link to calendar view in rendering\n-        self.assertTrue(\'?mode=day&amp;date=\' in rd)\n+        self.assertTrue("?mode=day&amp;date=" in rd)\n \n     def test_long_event(self):\n         tz = pytz.timezone(TZNAME)\n@@ -183,15 +187,14 @@ def test_long_event(self):\n         end = start + timedelta(days=2)\n \n         e1 = createContentInContainer(\n-            self.portal, PTYPE, title=u\'e1\', start=start, end=end)\n-        self.portal.portal_workflow.doActionFor(e1, \'publish\')\n-\n-        r = self.renderer(\n-            assignment=portlet_calendar.Assignment(state=(\'published\', ))\n+            self.portal, PTYPE, title="e1", start=start, end=end\n         )\n+        self.portal.portal_workflow.doActionFor(e1, "publish")\n+\n+        r = self.renderer(assignment=portlet_calendar.Assignment(state=("published",)))\n         r.update()\n         rd = r.render()\n-        self.assertEqual(rd.count(\'e1\'), 3)\n+        self.assertEqual(rd.count("e1"), 3)\n \n     def test_event_created_last_day_of_month_invalidate_cache(self):\n         # First render the calendar portlet when there\'s no events\n@@ -207,28 +210,24 @@ def test_event_created_last_day_of_month_invalidate_cache(self):\n         start = tz.localize(datetime(year, month, day, 23, 0, 0))\n         end = tz.localize(datetime(year, month, day, 23, 30, 0))\n         # Event starts at 23:00 and ends at 23:30\n-        createContentInContainer(\n-            self.portal, PTYPE, title=u\'e1\', start=start, end=end\n-        )\n+        createContentInContainer(self.portal, PTYPE, title="e1", start=start, end=end)\n \n         # Try to render the calendar portlet again, it must be different Now\n         r = self.renderer(assignment=portlet_calendar.Assignment())\n         r.update()\n-        self.assertNotEqual(\n-            html, r.render(), "Cache key wasn\'t invalidated"\n-        )\n+        self.assertNotEqual(html, r.render(), "Cache key wasn\'t invalidated")\n \n     def test_event_nonascii(self):\n         # test issue with non-ascii event title and location\n-        title = u\'Pl\xc3\xb6n\xe2\x82\xac\xc2\xa2\xc3\xb6nf M\xc3\xbcnchen 2012\'\n+        title = "Pl\xc3\xb6n\xe2\x82\xac\xc2\xa2\xc3\xb6nf M\xc3\xbcnchen 2012"\n \n         tz = pytz.timezone(TZNAME)\n         start = tz.localize(datetime.now())\n         end = start + timedelta(hours=1)\n         e1 = createContentInContainer(\n-            self.portal, PTYPE, title=title, start=start, end=end,\n-            location=u\'M\xc3\xbcnchen\')\n-        self.wft.doActionFor(e1, \'publish\')\n+            self.portal, PTYPE, title=title, start=start, end=end, location="M\xc3\xbcnchen"\n+        )\n+        self.wft.doActionFor(e1, "publish")\n         r = self.renderer(assignment=portlet_calendar.Assignment())\n         r.update()\n         self.assertTrue(title in r.render())\n@@ -238,16 +237,14 @@ def test_prev_next_query(self):\n         r.update()\n \n         year, month = r.year_month_display()\n-        prev_expected = \'?month={1}&year={0}\'.format(\n-            *r.get_previous_month(year, month))\n-        next_expected = \'?month={1}&year={0}\'.format(\n-            *r.get_next_month(year, month))\n+        prev_expected = "?month={1}&year={0}".format(*r.get_previous_month(year, month))\n+        next_expected = "?month={1}&year={0}".format(*r.get_next_month(year, month))\n         self.assertEqual(next_expected, r.next_query)\n         self.assertEqual(prev_expected, r.prev_query)\n \n     def test_invalid_request(self):\n-        self.request.form[\'month\'] = [3, 4]\n-        self.request.form[\'year\'] = [2011]\n+        self.request.form["month"] = [3, 4]\n+        self.request.form["year"] = [2011]\n         r = self.renderer()\n         r.update()\n         today = localized_today(self.portal)\ndiff --git a/plone/app/event/tests/test_portlet_events.py b/plone/app/event/tests/test_portlet_events.py\nindex db3cc01fc..a2e0a8e63 100644\n--- a/plone/app/event/tests/test_portlet_events.py\n+++ b/plone/app/event/tests/test_portlet_events.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import timedelta\n from plone.app.event.base import localized_now\n from plone.app.event.portlets import portlet_events\n@@ -29,34 +28,36 @@\n import unittest\n \n \n-TZNAME = \'Australia/Brisbane\'\n-PTYPE = \'plone.app.event.dx.event\'\n+TZNAME = "Australia/Brisbane"\n+PTYPE = "plone.app.event.dx.event"\n \n \n class PortletTest(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        portal = self.layer[\'portal\']\n+        portal = self.layer["portal"]\n         self.portal = portal\n-        self.request = self.layer[\'request\']\n+        self.request = self.layer["request"]\n         alsoProvides(self.request, IPloneFormLayer)\n-        setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(portal, TEST_USER_ID, ["Manager"])\n         setHooks()\n         setSite(portal)\n \n     def testPortletTypeRegistered(self):\n-        portlet = getUtility(IPortletType, name=\'portlets.Events\')\n-        self.assertEqual(portlet.addview, \'portlets.Events\')\n+        portlet = getUtility(IPortletType, name="portlets.Events")\n+        self.assertEqual(portlet.addview, "portlets.Events")\n \n     def testRegisteredInterfaces(self):\n-        portlet = getUtility(IPortletType, name=\'portlets.Events\')\n+        portlet = getUtility(IPortletType, name="portlets.Events")\n         registered_interfaces = [_getDottedName(i) for i in portlet.for_]\n         registered_interfaces.sort()\n         self.assertEqual(\n-            [\'plone.app.portlets.interfaces.IColumn\',\n-             \'plone.app.portlets.interfaces.IDashboard\'],\n-            registered_interfaces\n+            [\n+                "plone.app.portlets.interfaces.IColumn",\n+                "plone.app.portlets.interfaces.IDashboard",\n+            ],\n+            registered_interfaces,\n         )\n \n     def testInterfaces(self):\n@@ -65,13 +66,11 @@ def testInterfaces(self):\n         self.assertTrue(IPortletDataProvider.providedBy(portlet.data))\n \n     def testInvokeAddview(self):\n-        portlet = getUtility(IPortletType, name=\'portlets.Events\')\n-        mapping = self.portal.restrictedTraverse(\n-            \'++contextportlets++plone.leftcolumn\'\n-        )\n+        portlet = getUtility(IPortletType, name="portlets.Events")\n+        mapping = self.portal.restrictedTraverse("++contextportlets++plone.leftcolumn")\n         for m in mapping.keys():\n             del mapping[m]\n-        addview = mapping.restrictedTraverse(\'+/\' + portlet.addview)\n+        addview = mapping.restrictedTraverse("+/" + portlet.addview)\n \n         addview.createAndAdd(data={})\n \n@@ -83,37 +82,32 @@ def testInvokeAddview(self):\n     def testInvokeEditView(self):\n         mapping = PortletAssignmentMapping()\n \n-        mapping[\'foo\'] = portlet_events.Assignment(count=5)\n-        editview = getMultiAdapter((mapping[\'foo\'], self.request), name=\'edit\')\n+        mapping["foo"] = portlet_events.Assignment(count=5)\n+        editview = getMultiAdapter((mapping["foo"], self.request), name="edit")\n         self.assertTrue(isinstance(editview, portlet_events.EditForm))\n \n     def testRenderer(self):\n         context = self.portal\n-        view = context.restrictedTraverse(\'@@plone\')\n+        view = context.restrictedTraverse("@@plone")\n         manager = getUtility(\n-            IPortletManager, name=\'plone.leftcolumn\', context=self.portal\n+            IPortletManager, name="plone.leftcolumn", context=self.portal\n         )\n         assignment = portlet_events.Assignment(count=5)\n \n         renderer = getMultiAdapter(\n-            (context, self.request, view, manager, assignment),\n-            IPortletRenderer\n+            (context, self.request, view, manager, assignment), IPortletRenderer\n         )\n         self.assertTrue(isinstance(renderer, portlet_events.Renderer))\n \n     def test_disable_dasboard_breaks_event_portlet(self):\n         # Bug #8230: disabling the dashboard breaks the event portlet\n         self.portal.manage_permission(\n-            \'Portlets: Manage own portlets\',\n-            roles=[\'Manager\'],\n-            acquire=0\n+            "Portlets: Manage own portlets", roles=["Manager"], acquire=0\n         )\n \n-        portlet = getUtility(IPortletType, name=\'portlets.Events\')\n-        mapping = self.portal.restrictedTraverse(\n-            \'++contextportlets++plone.leftcolumn\'\n-        )\n-        addview = mapping.restrictedTraverse(\'+/\' + portlet.addview)\n+        portlet = getUtility(IPortletType, name="portlets.Events")\n+        mapping = self.portal.restrictedTraverse("++contextportlets++plone.leftcolumn")\n+        addview = mapping.restrictedTraverse("+/" + portlet.addview)\n \n         try:\n             addview.createAndAdd(data={})\n@@ -125,30 +119,30 @@ class RendererTest(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        portal = self.layer[\'portal\']\n+        portal = self.layer["portal"]\n         self.portal = portal\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n         wftool = getToolByName(self.portal, "portal_workflow")\n         wftool.setDefaultChain("simple_publication_workflow")\n         set_env_timezone(TZNAME)\n         set_timezone(TZNAME)\n \n-    def renderer(self, context=None, request=None, view=None, manager=None,\n-                 assignment=None):\n+    def renderer(\n+        self, context=None, request=None, view=None, manager=None, assignment=None\n+    ):\n         context = context or self.portal\n         request = request or self.request\n-        view = view or context.restrictedTraverse(\'@@plone\')\n+        view = view or context.restrictedTraverse("@@plone")\n         manager = manager or getUtility(\n-            IPortletManager, name=\'plone.leftcolumn\', context=self.portal\n+            IPortletManager, name="plone.leftcolumn", context=self.portal\n         )\n         assignment = assignment or portlet_events.Assignment(\n-            template=\'portlet_recent\', macro=\'portlet\'\n+            template="portlet_recent", macro="portlet"\n         )\n \n         return getMultiAdapter(\n-            (context, request, view, manager, assignment),\n-            IPortletRenderer\n+            (context, request, view, manager, assignment), IPortletRenderer\n         )\n \n     def test_portlet_event_renderer__get_events(self):\n@@ -156,27 +150,36 @@ def test_portlet_event_renderer__get_events(self):\n         end = start + timedelta(hours=1)\n \n         e1 = createContentInContainer(\n-            self.portal, PTYPE,\n-            id=\'e1\', title=u\'e1\', start=start, end=end)\n-        self.portal.portal_workflow.doActionFor(e1, \'publish\')\n+            self.portal, PTYPE, id="e1", title="e1", start=start, end=end\n+        )\n+        self.portal.portal_workflow.doActionFor(e1, "publish")\n \n-        self.portal.invokeFactory(\'Folder\', \'eventfolder\')\n+        self.portal.invokeFactory("Folder", "eventfolder")\n         createContentInContainer(\n-            self.portal.eventfolder, PTYPE,\n-            id=\'e2\', title=u\'e2\', start=start, end=end)\n+            self.portal.eventfolder, PTYPE, id="e2", title="e2", start=start, end=end\n+        )\n \n-        r = self.renderer(assignment=portlet_events.Assignment(\n-            count=5, state=(\'draft\',)))\n+        r = self.renderer(\n+            assignment=portlet_events.Assignment(count=5, state=("draft",))\n+        )\n         r.update()\n         self.assertEqual(0, len(r.events))\n \n-        r = self.renderer(assignment=portlet_events.Assignment(\n-            count=5, state=(\'published\', )))\n+        r = self.renderer(\n+            assignment=portlet_events.Assignment(count=5, state=("published",))\n+        )\n         r.update()\n         self.assertEqual(1, len(r.events))\n \n-        r = self.renderer(assignment=portlet_events.Assignment(\n-            count=5, state=(\'published\', \'private\',)))\n+        r = self.renderer(\n+            assignment=portlet_events.Assignment(\n+                count=5,\n+                state=(\n+                    "published",\n+                    "private",\n+                ),\n+            )\n+        )\n         r.update()\n         self.assertEqual(2, len(r.events))\n \n@@ -185,35 +188,48 @@ def test_portlet_event_renderer__get_events(self):\n         self.assertEqual(2, len(r.events))\n \n         # No search base gives calendar urls with event_listing part\n-        self.assertTrue(\'event_listing\' in r.render())\n+        self.assertTrue("event_listing" in r.render())\n \n-        r = self.renderer(assignment=portlet_events.Assignment(\n-            count=5, search_base_uid=self.portal.eventfolder.UID()))\n+        r = self.renderer(\n+            assignment=portlet_events.Assignment(\n+                count=5, search_base_uid=self.portal.eventfolder.UID()\n+            )\n+        )\n         r.update()\n         self.assertEqual(1, len(r.events))\n \n         # A given search base gives calendar urls without event_listing part\n-        self.assertTrue(\'event_listing\' not in r.render())\n+        self.assertTrue("event_listing" not in r.render())\n \n     def test_portlet_event_renderer__recurring(self):\n         start = localized_now() + timedelta(days=1)\n \n         e1 = createContentInContainer(\n-            self.portal, PTYPE, id=\'e1\', title=u\'Event 1\', start=start,\n-            recurrence=\'RRULE:FREQ=WEEKLY;COUNT=10\')\n+            self.portal,\n+            PTYPE,\n+            id="e1",\n+            title="Event 1",\n+            start=start,\n+            recurrence="RRULE:FREQ=WEEKLY;COUNT=10",\n+        )\n         createContentInContainer(\n-            self.portal, PTYPE, id=\'e1\', title=u\'Event 1\', start=start,\n-            recurrence=\'RRULE:FREQ=DAILY;COUNT=3\')\n+            self.portal,\n+            PTYPE,\n+            id="e1",\n+            title="Event 1",\n+            start=start,\n+            recurrence="RRULE:FREQ=DAILY;COUNT=3",\n+        )\n \n-        self.portal.portal_workflow.doActionFor(e1, \'publish\')\n+        self.portal.portal_workflow.doActionFor(e1, "publish")\n \n         r = self.renderer(\n-            assignment=portlet_events.Assignment(count=5,\n-                                                 state=(\'published\',)))\n+            assignment=portlet_events.Assignment(count=5, state=("published",))\n+        )\n         r.update()\n         events = r.events\n         self.assertEqual(5, len(events))\n-        self.assertTrue(\'Event 2\' not in [x.title for x in events])\n+        self.assertTrue("Event 2" not in [x.title for x in events])\n \n         rd = r.render()\n         occ1dt = start + timedelta(days=7)\n@@ -222,13 +238,14 @@ def test_portlet_event_renderer__recurring(self):\n         self.assertTrue(\'http://nohost/plone/e1"\' in rd)\n         # Occurrences should link to the Occurrence.\n         self.assertTrue(\n-            \'http://nohost/plone/e1/%s-%02d-%02d\' %\n-            (occ1dt.year, occ1dt.month, occ1dt.day) in rd\n+            "http://nohost/plone/e1/%s-%02d-%02d"\n+            % (occ1dt.year, occ1dt.month, occ1dt.day)\n+            in rd\n         )\n \n     def test_portlet_event_renderer__listing_link(self):\n         r = self.renderer(assignment=portlet_events.Assignment(count=5))\n         r.update()\n         rd = r.render()\n-        self.assertTrue(\'?mode=future\' in rd)\n-        self.assertTrue(\'?mode=past\' in rd)\n+        self.assertTrue("?mode=future" in rd)\n+        self.assertTrue("?mode=past" in rd)\ndiff --git a/plone/app/event/tests/test_recurrence.py b/plone/app/event/tests/test_recurrence.py\nindex c294a08b6..eedc5a883 100644\n--- a/plone/app/event/tests/test_recurrence.py\n+++ b/plone/app/event/tests/test_recurrence.py\n@@ -1,5 +1,3 @@\n-# -*- coding: utf-8 -*-\n-from mock import Mock\n from OFS.SimpleItem import SimpleItem\n from plone.app.event.base import get_events\n from plone.app.event.base import RET_MODE_ACCESSORS\n@@ -22,32 +20,26 @@\n from plone.event.interfaces import IEventRecurrence\n from plone.event.interfaces import IOccurrence\n from plone.event.interfaces import IRecurrenceSupport\n+from plone.testing.zope import Browser\n+from unittest import mock\n+from unittest.mock import Mock\n from zope.annotation.interfaces import IAnnotations\n from zope.interface import alsoProvides\n from zope.publisher.interfaces.browser import IBrowserView\n \n import datetime\n-import mock\n import pytz\n-import six\n import transaction\n import unittest\n import zope.component\n \n-try:\n-    # plone.testing 7+\n-    from plone.testing.zope import Browser\n-except ImportError:\n-    # plone.testing 6-\n-    from plone.testing.z2 import Browser\n-\n \n TZNAME = "Europe/Vienna"\n \n \n class TestTraversalDX(AbstractSampleDataEvents):\n-    """Test OccurrenceTraverser with DX objects.\n-    """\n+    """Test OccurrenceTraverser with DX objects."""\n+\n     layer = PAEventDX_FUNCTIONAL_TESTING\n \n     @property\n@@ -56,14 +48,11 @@ def occ_traverser_1(self):\n \n     def test_no_occurrence(self):\n         self.assertRaises(\n-            AttributeError,\n-            self.occ_traverser_1.publishTraverse,\n-            self.request,\n-            \'foo\'\n+            AttributeError, self.occ_traverser_1.publishTraverse, self.request, "foo"\n         )\n \n     def test_default_views(self):\n-        view = self.occ_traverser_1.publishTraverse(self.request, \'event_view\')\n+        view = self.occ_traverser_1.publishTraverse(self.request, "event_view")\n         self.assertTrue(IBrowserView.providedBy(view))\n \n     def test_occurrence(self):\n@@ -74,22 +63,26 @@ def test_occurrence(self):\n         self.assertRaises(\n             AttributeError,\n             self.occ_traverser_1.publishTraverse,\n-            self.request, \'2000-01-01\')\n+            self.request,\n+            "2000-01-01",\n+        )\n \n         # Try to traverse to future occurrence\n         self.assertRaises(\n             AttributeError,\n             self.occ_traverser_1.publishTraverse,\n-            self.request, \'2030-01-01\')\n+            self.request,\n+            "2030-01-01",\n+        )\n \n         # Traverse to existent occurrence\n-        item = self.occ_traverser_1.publishTraverse(self.request, \'2013-05-07\')\n+        item = self.occ_traverser_1.publishTraverse(self.request, "2013-05-07")\n         self.assertTrue(IOccurrence.providedBy(item))\n         self.assertEqual(type(self.now_event), type(item.aq_parent))\n \n         # Test attributes of Occurrence\n-        self.assertEqual(item.portal_type, \'Occurrence\')\n-        self.assertEqual(item.id, \'2013-05-07\')\n+        self.assertEqual(item.portal_type, "Occurrence")\n+        self.assertEqual(item.id, "2013-05-07")\n         delta = datetime.timedelta(days=2)\n         self.assertEqual(item.start, self.now + delta)\n         self.assertEqual(item.end, self.now + delta + self.duration)\n@@ -97,32 +90,26 @@ def test_occurrence(self):\n     def test_occurrence_accessor(self):\n         start = self.now\n         end = self.future\n-        occ = Occurrence(\'ignored\', start, end)\n+        occ = Occurrence("ignored", start, end)\n         occ = occ.__of__(self.now_event)\n         acc_occ = IEventAccessor(occ)\n         acc_ctx = IEventAccessor(self.now_event)\n         self.assertEqual(acc_occ.start, acc_ctx.start)\n-        self.assertEqual(acc_occ.url, \'http://nohost/plone/now/ignored\')\n+        self.assertEqual(acc_occ.url, "http://nohost/plone/now/ignored")\n \n     def test_traverse_occurrence(self):\n         transaction.commit()\n         browser = Browser(self.app)\n-        browser.addHeader(\n-            \'Authorization\', \'Basic %s:%s\' % (TEST_USER_ID, TEST_USER_PASSWORD)\n-        )\n-        url = \'/\'.join([self.now_event.absolute_url(), \'2013-05-07\'])\n+        browser.addHeader("Authorization", f"Basic {TEST_USER_ID}:{TEST_USER_PASSWORD}")\n+        url = "/".join([self.now_event.absolute_url(), "2013-05-07"])\n         browser.open(url)\n         title = self.now_event.title\n-        if six.PY2:\n-            title = title.encode(\'ascii\')\n         self.assertTrue(title in browser.contents)\n \n     def test_traverse_occurrence_imagescaling(self):\n         self.now_event.image = Mock()\n-        occurrence = self.occ_traverser_1.publishTraverse(\n-            self.request, \'2013-05-07\'\n-        )\n-        image_view = occurrence.restrictedTraverse(\'@@images\')\n+        occurrence = self.occ_traverser_1.publishTraverse(self.request, "2013-05-07")\n+        image_view = occurrence.restrictedTraverse("@@images")\n         self.assertEqual(image_view.context, self.now_event)\n \n \n@@ -130,8 +117,8 @@ class TestOccurrences(unittest.TestCase):\n     layer = PAEventDX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n \n         set_browserlayer(self.request)\n         set_env_timezone(TZNAME)\n@@ -141,77 +128,79 @@ def setUp(self):\n \n         yesterday = now - datetime.timedelta(days=1)\n \n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n         self.daily = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            id=\'daily\',\n-            title=u\'Daily Event\',\n+            "plone.app.event.dx.event",\n+            id="daily",\n+            title="Daily Event",\n             start=now,\n             end=now + datetime.timedelta(hours=1),\n-            location=u\'Vienna\',\n-            recurrence=\'RRULE:FREQ=DAILY;COUNT=4\',\n+            location="Vienna",\n+            recurrence="RRULE:FREQ=DAILY;COUNT=4",\n         )\n         self.interval = createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            id=\'interval\',\n-            title=u\'Interval Event\',\n+            "plone.app.event.dx.event",\n+            id="interval",\n+            title="Interval Event",\n             start=yesterday,\n             end=yesterday + datetime.timedelta(hours=1),\n-            location=u\'Halle\',\n-            recurrence=\'RRULE:FREQ=DAILY;INTERVAL=2;COUNT=5\',\n+            location="Halle",\n+            recurrence="RRULE:FREQ=DAILY;INTERVAL=2;COUNT=5",\n         )\n \n         self.now = now\n         self.yesterday = yesterday\n \n     def test_get_occurrences(self):\n-        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS,\n-                         expand=True)\n+        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS, expand=True)\n         self.assertEqual(len(res), 9)\n-        res = get_events(self.portal, start=self.now,\n-                         ret_mode=RET_MODE_ACCESSORS, expand=True)\n+        res = get_events(\n+            self.portal, start=self.now, ret_mode=RET_MODE_ACCESSORS, expand=True\n+        )\n         self.assertEqual(len(res), 8)\n \n-        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS,\n-                         expand=True, limit=5)\n+        res = get_events(self.portal, ret_mode=RET_MODE_ACCESSORS, expand=True, limit=5)\n         self.assertEqual(len(res), 5)\n         self.assertTrue(IEventAccessor.providedBy(res[0]))\n \n     def test_event_summary_occurrences(self):\n         createContentInContainer(\n             self.portal,\n-            \'plone.app.event.dx.event\',\n-            id=\'many\',\n-            title=u\'Interval Event\',\n-            location=u\'Brisbane\',\n-            recurrence=\'RRULE:FREQ=DAILY;COUNT=1000\'\n+            "plone.app.event.dx.event",\n+            id="many",\n+            title="Interval Event",\n+            location="Brisbane",\n+            recurrence="RRULE:FREQ=DAILY;COUNT=1000",\n         )\n \n         view = zope.component.getMultiAdapter(\n-            (self.portal[\'interval\'], self.request), name=\'event_summary\')\n+            (self.portal["interval"], self.request), name="event_summary"\n+        )\n         result = view.next_occurrences\n         # altogether 5 occurrences, start occurrence is included\n         self.assertEqual(5, len(result))\n \n         view = zope.component.getMultiAdapter(\n-            (self.portal[\'many\'], self.request), name=\'event_summary\')\n+            (self.portal["many"], self.request), name="event_summary"\n+        )\n \n         # Number of shown occurrences should match max_occurrences setting\n         self.assertEqual(len(view.next_occurrences), view.max_occurrences)\n         # num_more_occurrences should return number of remaining occurrences\n-        self.assertEqual(\n-            view.num_more_occurrences, 1000 - view.max_occurrences)\n+        self.assertEqual(view.num_more_occurrences, 1000 - view.max_occurrences)\n \n     def test_event_summary_occurrences_next_upcoming(self):\n-        event = IEventAccessor(self.portal[\'daily\'])\n+        event = IEventAccessor(self.portal["daily"])\n \n         date = patched_now()\n-        with mock.patch(\'plone.app.event.dx.behaviors.localized_now\',\n-                        return_value=date):\n+        with mock.patch(\n+            "plone.app.event.dx.behaviors.localized_now", return_value=date\n+        ):\n             view = zope.component.getMultiAdapter(\n-                (self.portal[\'daily\'], self.request), name=\'event_summary\')\n+                (self.portal["daily"], self.request), name="event_summary"\n+            )\n             # altogether 4 occurrences, start occurrence is included\n             self.assertEqual(4, len(view.next_occurrences))\n             self.assertEqual(event.start, date)\n@@ -219,10 +208,12 @@ def test_event_summary_occurrences_next_upcoming(self):\n \n         IAnnotations(self.request).clear()  # clear cache\n         next_date = patched_now() + datetime.timedelta(hours=24)\n-        with mock.patch(\'plone.app.event.dx.behaviors.localized_now\',\n-                        return_value=next_date):\n+        with mock.patch(\n+            "plone.app.event.dx.behaviors.localized_now", return_value=next_date\n+        ):\n             view = zope.component.getMultiAdapter(\n-                (self.portal[\'daily\'], self.request), name=\'event_summary\')\n+                (self.portal["daily"], self.request), name="event_summary"\n+            )\n             # 3 occurrences remaining\n             self.assertEqual(3, len(view.next_occurrences))\n             self.assertEqual(event.start, next_date)\n@@ -231,23 +222,27 @@ def test_event_summary_occurrences_next_upcoming(self):\n \n         IAnnotations(self.request).clear()  # clear cache\n         next_date = patched_now() + datetime.timedelta(days=10)\n-        with mock.patch(\'plone.app.event.dx.behaviors.localized_now\',\n-                        return_value=next_date):\n+        with mock.patch(\n+            "plone.app.event.dx.behaviors.localized_now", return_value=next_date\n+        ):\n             view = zope.component.getMultiAdapter(\n-                (self.portal[\'daily\'], self.request), name=\'event_summary\')\n+                (self.portal["daily"], self.request), name="event_summary"\n+            )\n             # no occurrences remaining, show all original 4\n             self.assertEqual(4, len(view.next_occurrences))\n             self.assertEqual(event.start, date)\n             self.assertEqual(event.end, date + datetime.timedelta(hours=1))\n \n     def test_event_summary_occurrences_whole_day(self):\n-        self.portal[\'daily\'].whole_day = True\n+        self.portal["daily"].whole_day = True\n \n         date = patched_now()\n-        with mock.patch(\'plone.app.event.dx.behaviors.localized_now\',\n-                        return_value=date):\n+        with mock.patch(\n+            "plone.app.event.dx.behaviors.localized_now", return_value=date\n+        ):\n             view = zope.component.getMultiAdapter(\n-                (self.portal[\'daily\'], self.request), name=\'event_summary\')\n+                (self.portal["daily"], self.request), name="event_summary"\n+            )\n             # altogether 4 occurrences, start occurrence is included\n             self.assertEqual(4, len(view.next_occurrences))\n             for occurrence in view.next_occurrences:\n@@ -258,10 +253,12 @@ def test_event_summary_occurrences_whole_day(self):\n \n         IAnnotations(self.request).clear()  # clear cache\n         next_date = patched_now() + datetime.timedelta(hours=24)\n-        with mock.patch(\'plone.app.event.dx.behaviors.localized_now\',\n-                        return_value=next_date):\n+        with mock.patch(\n+            "plone.app.event.dx.behaviors.localized_now", return_value=next_date\n+        ):\n             view = zope.component.getMultiAdapter(\n-                (self.portal[\'daily\'], self.request), name=\'event_summary\')\n+                (self.portal["daily"], self.request), name="event_summary"\n+            )\n             # 3 occurrences remaining\n             self.assertEqual(3, len(view.next_occurrences))\n             for occurrence in view.next_occurrences:\n@@ -272,10 +269,12 @@ def test_event_summary_occurrences_whole_day(self):\n \n         IAnnotations(self.request).clear()  # clear cache\n         next_date = patched_now() + datetime.timedelta(days=10)\n-        with mock.patch(\'plone.app.event.dx.behaviors.localized_now\',\n-                        return_value=next_date):\n+        with mock.patch(\n+            "plone.app.event.dx.behaviors.localized_now", return_value=next_date\n+        ):\n             view = zope.component.getMultiAdapter(\n-                (self.portal[\'daily\'], self.request), name=\'event_summary\')\n+                (self.portal["daily"], self.request), name="event_summary"\n+            )\n             # no occurrences remaining, show all original 4\n             self.assertEqual(4, len(view.next_occurrences))\n             for occurrence in view.next_occurrences:\n@@ -294,12 +293,12 @@ class TestRecurrenceSupport(unittest.TestCase):\n     layer = PAEvent_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.tz = tz = pytz.timezone(\'Europe/Vienna\')\n+        self.tz = tz = pytz.timezone("Europe/Vienna")\n         duration = datetime.timedelta(days=4)\n         data = MockEvent()\n         data.start = datetime.datetime(2011, 11, 11, 11, 00, tzinfo=tz)\n         data.end = data.start + duration\n-        data.recurrence = \'RRULE:FREQ=DAILY;COUNT=4\'\n+        data.recurrence = "RRULE:FREQ=DAILY;COUNT=4"\n         alsoProvides(data, IEvent, IEventRecurrence)\n         self.data = data\n \n@@ -344,8 +343,7 @@ def test_recurrence_occurrences_with_range_start_and_end(self):\n         # Test with range\n         rs = datetime.datetime(2011, 11, 11, 11, 0, tzinfo=self.tz)\n         re = datetime.datetime(2011, 11, 12, 11, 0, tzinfo=self.tz)\n-        result = IRecurrenceSupport(self.data).occurrences(range_start=rs,\n-                                                           range_end=re)\n+        result = IRecurrenceSupport(self.data).occurrences(range_start=rs, range_end=re)\n         result = list(result)  # cast generator to list\n \n         self.assertEqual(2, len(result))\ndiff --git a/plone/app/event/tests/test_search.py b/plone/app/event/tests/test_search.py\nindex 90fe3c038..7fbf03d5d 100644\n--- a/plone/app/event/tests/test_search.py\n+++ b/plone/app/event/tests/test_search.py\n@@ -1,15 +1,13 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event.testing import PAEventDX_FUNCTIONAL_TESTING\n-from plone.app.event.tests.base_setup import patched_now as PN\n from plone.app.event.tests.base_setup import AbstractSampleDataEvents\n-\n-import mock\n+from plone.app.event.tests.base_setup import patched_now as PN\n+from unittest import mock\n \n \n class FunctionalTestSearchEvent(AbstractSampleDataEvents):\n     layer = PAEventDX_FUNCTIONAL_TESTING\n \n-    @mock.patch(\'plone.app.event.base.localized_now\', new=PN)\n+    @mock.patch("plone.app.event.base.localized_now", new=PN)\n     def test_searchabletext(self):\n-        results = self.portal.portal_catalog(SearchableText=u\'\xc3\x9cberraschung\')\n+        results = self.portal.portal_catalog(SearchableText="\xc3\x9cberraschung")\n         self.assertTrue(len(results) == 1)\ndiff --git a/plone/app/event/upgrades/upgrades.py b/plone/app/event/upgrades/upgrades.py\nindex d7c866286..a716af579 100644\n--- a/plone/app/event/upgrades/upgrades.py\n+++ b/plone/app/event/upgrades/upgrades.py\n@@ -1,18 +1,19 @@\n-# -*- coding: utf-8 -*-\n-from Products.CMFCore.utils import getToolByName\n-from plone.app.event.dx.interfaces import IDXEvent\n from plone.app.event.dx.behaviors import IEventAttendees\n from plone.app.event.dx.behaviors import IEventContact\n from plone.app.event.dx.behaviors import IEventLocation\n+from plone.app.event.dx.interfaces import IDXEvent\n from plone.dexterity.interfaces import IDexterityFTI\n+from Products.CMFCore.utils import getToolByName\n from zope.annotation.interfaces import IAnnotatable\n from zope.annotation.interfaces import IAnnotations\n-from zope.event import notify\n from zope.component import queryUtility\n from zope.component.hooks import getSite\n+from zope.event import notify\n from zope.lifecycleevent import ObjectModifiedEvent\n \n import logging\n+\n+\n log = logging.getLogger(__name__)\n \n BEHAVIOR_LIST = [\n@@ -26,41 +27,47 @@ def enable_richtext_behavior(self):\n     fti = queryUtility(IDexterityFTI, name="Event", default=None)\n     if not fti:\n         return\n-    behaviors = [it for it in fti.behaviors\n-                 if \'plone.app.event.dx.behaviors.IEventSummary\' not in it]\n-    behaviors.extend([\n-        \'plone.app.contenttypes.behaviors.richtext.IRichText\',\n-    ])\n+    behaviors = [\n+        it\n+        for it in fti.behaviors\n+        if "plone.app.event.dx.behaviors.IEventSummary" not in it\n+    ]\n+    behaviors.extend(\n+        [\n+            "plone.app.contenttypes.behaviors.richtext.IRichText",\n+        ]\n+    )\n     behaviors = tuple(set(behaviors))\n-    fti._updateProperty(\'behaviors\', behaviors)\n+    fti._updateProperty("behaviors", behaviors)\n \n \n def upgrade_attribute_storage(context):\n     portal = getSite()\n-    catalog = getToolByName(portal, \'portal_catalog\')\n+    catalog = getToolByName(portal, "portal_catalog")\n     query = {}\n-    query[\'object_provides\'] = IDXEvent.__identifier__\n+    query["object_provides"] = IDXEvent.__identifier__\n     results = catalog(**query)\n-    log.info(\'There are {0} in total, stating migration...\'.format(\n-        len(results)))\n+    log.info(f"There are {len(results)} in total, stating migration...")\n     for result in results:\n         try:\n             event = result.getObject()\n         except:\n             log.warning(\n-                \'Not possible to fetch event object from catalog result for \'\n-                \'item: {0}.\'.format(result.getPath()))\n+                "Not possible to fetch event object from catalog result for "\n+                "item: {}.".format(result.getPath())\n+            )\n             continue\n         if not IAnnotatable.providedBy(event):\n             log.warning(\n-                \'The event at {0} does provide annotation capabilities, \'\n-                \'skipping.\'.format(event.absolute_url()))\n+                "The event at {} does provide annotation capabilities, "\n+                "skipping.".format(event.absolute_url())\n+            )\n             continue\n         annotations = IAnnotations(event)\n         did_work = False\n         for behavior in BEHAVIOR_LIST:\n             for name in behavior.names():\n-                fullname = \'{0}.{1}\'.format(behavior.__identifier__, name)\n+                fullname = f"{behavior.__identifier__}.{name}"\n                 oldvalue = annotations.get(fullname, None)\n                 # Only write the old value if there is no new value yet\n                 if oldvalue and not getattr(event, name, None):\n@@ -69,19 +76,24 @@ def upgrade_attribute_storage(context):\n         # The old IEventSummary behavior is gone, just look for the old name\n         # inside the annotation storage\n         oldvalue = annotations.get(\n-            \'plone.app.event.dx.behaviors.IEventSummary.text\', None)\n-        if oldvalue and not getattr(event, \'text\', None):\n-            setattr(event, \'text\', oldvalue)\n+            "plone.app.event.dx.behaviors.IEventSummary.text", None\n+        )\n+        if oldvalue and not getattr(event, "text", None):\n+            setattr(event, "text", oldvalue)\n             did_work = True\n         if did_work:\n             notify(ObjectModifiedEvent(event))\n-        log.debug(\'Handled event at {0}\'.format(event.absolute_url()))\n+        log.debug(f"Handled event at {event.absolute_url()}")\n \n \n def remove_event_listing_settings(context):\n     portal = getSite()\n-    actions = getToolByName(portal, \'portal_actions\')\n-    ob = getattr(actions, \'object\')\n-    if ob and getattr(ob, \'event_listing_settings\', False):\n-        actions.object.manage_delObjects([\'event_listing_settings\', ])\n-        log.debug(\'Removed event_listing_settings from object actions.\')\n+    actions = getToolByName(portal, "portal_actions")\n+    ob = getattr(actions, "object")\n+    if ob and getattr(ob, "event_listing_settings", False):\n+        actions.object.manage_delObjects(\n+            [\n+                "event_listing_settings",\n+            ]\n+        )\n+        log.debug("Removed event_listing_settings from object actions.")\ndiff --git a/plone/app/event/vocabularies.py b/plone/app/event/vocabularies.py\nindex bae395d4b..d6975f75b 100644\n--- a/plone/app/event/vocabularies.py\n+++ b/plone/app/event/vocabularies.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.event import _\n from plone.app.event import base\n from zope.interface import provider\n@@ -21,10 +20,10 @@ def SynchronizationStrategies(context):\n                       sync_uid.\n     """\n     items = [\n-        (_(\'sync_keep_newer\', default="Keep newer"), base.SYNC_KEEP_NEWER),\n-        (_(\'sync_keep_mine\', default="Keep mine"), base.SYNC_KEEP_MINE),\n-        (_(\'sync_keep_theirs\', default="Keep theirs"), base.SYNC_KEEP_THEIRS),\n-        (_(\'sync_none\', default="No Syncing"), base.SYNC_NONE),\n+        (_("sync_keep_newer", default="Keep newer"), base.SYNC_KEEP_NEWER),\n+        (_("sync_keep_mine", default="Keep mine"), base.SYNC_KEEP_MINE),\n+        (_("sync_keep_theirs", default="Keep theirs"), base.SYNC_KEEP_THEIRS),\n+        (_("sync_none", default="No Syncing"), base.SYNC_NONE),\n     ]\n     items = [SimpleTerm(title=i[0], value=i[1]) for i in items]\n     return SimpleVocabulary(items)\ndiff --git a/setup.cfg b/setup.cfg\nindex a5841d50b..00f7b1f84 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -3,7 +3,12 @@ ignore =\n     *.cfg\n     *.sh\n \n-\n-\n [bdist_wheel]\n universal = 1\n+\n+[isort]\n+# black compatible Plone isort rules:\n+profile = black\n+force_alphabetical_sort = True\n+force_single_line = True\n+lines_after_imports = 2\ndiff --git a/setup.py b/setup.py\nindex 89df4baad..f31d42e68 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,22 +1,23 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n import os\n \n \n-version = \'4.0.0a9.dev0\'\n+version = "4.0.0a9.dev0"\n \n \n-long_description = (\'\\n\\n\'.join([\n-    open("README.rst").read(),\n-    open(os.path.join(\'docs\', \'installation.rst\')).read(),\n-    open("CHANGES.rst").read(),\n-]))\n+long_description = "\\n\\n".join(\n+    [\n+        open("README.rst").read(),\n+        open(os.path.join("docs", "installation.rst")).read(),\n+        open("CHANGES.rst").read(),\n+    ]\n+)\n \n \n setup(\n-    name=\'plone.app.event\',\n+    name="plone.app.event",\n     version=version,\n     description="The Plone calendar framework",\n     long_description=long_description,\n@@ -31,83 +32,55 @@\n         "Programming Language :: Python :: 3.8",\n         "Programming Language :: Python :: 3.9",\n     ],\n-    keywords=\'plone event\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://github.com/plone/plone.app.event\',\n-    license=\'GPL version 2\',\n+    keywords="plone event",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://github.com/plone/plone.app.event",\n+    license="GPL version 2",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\', \'plone.app\'],\n+    namespace_packages=["plone", "plone.app"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n-        # -*- Extra requirements: -*-\n-        \'Acquisition\',\n-        \'DateTime\',\n-        \'Products.CMFCore\',\n-        \'Products.CMFPlone\',\n-        \'Products.DateRecurringIndex\',\n-        \'Products.GenericSetup\',\n-        \'Products.ZCatalog\',\n-        \'Products.statusmessages\',\n-        \'Zope2\',\n-        \'icalendar\',  # >4.0.2\n-        \'plone.app.contentlisting\',\n-        \'plone.app.dexterity\',\n-        \'plone.app.layout\',\n-        \'plone.app.multilingual\',\n-        \'plone.app.portlets >= 2.5.1\',\n-        \'plone.app.querystring\',\n-        \'plone.app.registry\',\n-        \'plone.app.textfield\',\n-        \'plone.app.vocabularies >= 2.1.15.dev0\',\n-        \'plone.app.z3cform>=2.0.1.dev0\',\n-        \'plone.autoform>=1.4\',\n-        \'plone.behavior\',\n-        \'plone.browserlayer\',\n-        \'plone.dexterity\',\n-        \'plone.event>=1.0\',\n-        \'plone.folder\',\n-        \'plone.formwidget.recurrence [z3cform] >= 1.2.4\',\n-        \'plone.indexer\',\n-        \'plone.memoize\',\n-        \'plone.namedfile\',\n-        \'plone.portlets\',\n-        \'plone.registry\',\n-        \'plone.supermodel\',\n-        \'plone.uuid\',\n-        \'plone.z3cform\',\n-        \'pytz\',\n-        \'six\',\n-        \'transaction\',\n-        \'z3c.form >= 3.2.1.dev0\',\n-        \'zope.annotation\',\n-        \'zope.component\',\n-        \'zope.container\',\n-        \'zope.contentprovider\',\n-        \'zope.event\',\n-        \'zope.globalrequest\',\n-        \'zope.i18n\',\n-        \'zope.i18nmessageid\',\n-        \'zope.interface\',\n-        \'zope.lifecycleevent\',\n-        \'zope.publisher\',\n-        \'zope.schema\',\n+        "setuptools",\n+        "plone.base",\n+        "Products.DateRecurringIndex",\n+        "Products.statusmessages",\n+        "icalendar",  # >4.0.2\n+        "plone.app.contentlisting",\n+        "plone.app.dexterity",\n+        "plone.app.layout",\n+        "plone.app.multilingual",\n+        "plone.app.portlets >= 2.5.1",\n+        "plone.app.querystring",\n+        "plone.app.registry",\n+        "plone.app.textfield",\n+        "plone.app.vocabularies >= 2.1.15.dev0",\n+        "plone.app.z3cform>=2.0.1.dev0",\n+        "plone.autoform>=1.4",\n+        "plone.behavior",\n+        "plone.browserlayer",\n+        "plone.dexterity",\n+        "plone.event>=1.0",\n+        "plone.folder",\n+        "plone.formwidget.recurrence [z3cform] >= 1.2.4",\n+        "plone.indexer",\n+        "plone.memoize",\n+        "plone.namedfile",\n+        "plone.portlets",\n+        "plone.registry",\n+        "plone.supermodel",\n+        "plone.uuid",\n+        "plone.z3cform",\n+        "pytz",\n+        "z3c.form >= 3.2.1.dev0",\n+        "zope.globalrequest",\n     ],\n     extras_require={\n-        \'dexterity\': [],  # BBB, remove with next version\n-        \'test\': [\n-            \'icalendar >= 3.10\',  # otherwise minor test failure\n-            \'mock\',\n-            \'plone.app.contenttypes >= 1.2a3\',\n-            \'plone.app.robotframework\',\n-            \'plone.app.testing [robot]\',\n-            \'plone.testing\',\n-            \'robotsuite\',\n-            \'transaction\',\n-            \'zExceptions\',\n-            \'zope.event\',\n+        "test": [\n+            "plone.app.robotframework",\n+            "plone.app.testing [robot]",\n+            "robotsuite",\n         ],\n     },\n )\n'

