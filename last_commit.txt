Repository: plone.testing


Branch: refs/heads/master
Date: 2018-04-23T09:45:07+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.testing/commit/0c4c439748c1b702eb7385f759492e698d31222a

more ReST fixes.

Files changed:
M src/plone/testing/README.rst

diff --git a/src/plone/testing/README.rst b/src/plone/testing/README.rst
index c3733fd..4adaf6b 100644
--- a/src/plone/testing/README.rst
+++ b/src/plone/testing/README.rst
@@ -37,57 +37,48 @@ In this documentation, we will use a number of testing-related terms.
 The following definitions apply:
 
 Unit test
-
     An automated test (i.e. one written in code) that tests a single unit (normally a function) in isolation.
     A unit test attempts to prove that the given function works as expected and gives the correct output given a particular input.
     It is common to have a number of unit tests for a single function, testing different inputs, including boundary cases and errors.
     Unit tests are typically quick to write and run.
 
 Integration test
-
     An automated test that tests how a number of units interact.
     In a Zope context, this often pertains to how a particular object or view interacts with the Zope framework, the ZODB persistence engine, and so on.
     Integration tests usually require some setup and can be slower to run than unit tests.
     It is common to have fewer integration tests than unit test.
 
 Functional test
-
     An automated test that tests a feature in an "end-to-end" fashion.
     In a Zope context, that normally means that it invokes an action in the same way that a user would, i.e. through a web request.
     Functional tests are normally slower to run than either unit or integration tests, and can be significantly slower to run.
     It is therefore common to have only a few functional tests for each major feature, relying on unit and integration tests for the bulk of testing.
 
 Black box testing
-
     Testing which only considers the system's defined inputs and outputs.
     For example, a functional test is normally a black box test that provides inputs only through the defined interface (e.g. URLs published in a web application), and makes assertions only on end outputs (e.g. the response returned for requests to those URLs).
 
 White box testing
-
     Testing which examines the internal state of a system to make assertions.
     Authors of unit and integration tests normally have significant knowledge of the implementation of the code under test, and can examine such things as data in a database or changes to the system's environment to determine if the test succeeded or failed.
 
 Assertion
-
     A check that determines whether a test succeeds or fails.
     For example, if a unit test for the function ``foo()`` expects it to return the value 1, an assertion could be written to verify this fact.
     A test is said to *fail* if any of its assertions fail.
     A test always contains one or more assertions.
 
 Test case
-
     A single unit, integration or functional test.
     Often shortened to just *test*.
     A test case sets up, executes and makes assertions against a single scenario that bears testing.
 
 Test fixture
-
     The state used as a baseline for one or more tests.
     The test fixture is *set up* before each test is executed, and *torn down* afterwards.
     This is a pre-requisite for *test isolation* - the principle that tests should be independent of one another.
 
 Layer
-
     The configuration of a test fixture shared by a number of tests.
     All test cases that belong to a particular layer will be executed together.
     The layer is *set up* once before the tests are executed, and *torn down* once after.
@@ -96,24 +87,20 @@ Layer
     The test runner will order test execution to minimise layer setup and tear-down.
 
 Test suite
-
     A collection of test cases (and layers) that are executed together.
 
 Test runner
-
     The program which executes tests.
     This is responsible for calling layer and test fixture set-up and tear-down methods.
     It also reports on the test run, usually by printing output to the console.
 
 Coverage
-
     To have confidence in your code, you should ensure it is adequately covered by tests.
     That is, each line of code, and each possible branching point (loops, ``if`` statements) should be executed by a test.
     This is known as *coverage*, and is normally measured as a percentage of lines of non-test code covered by tests.
     Coverage can be measured by the test runner, which keeps track of which lines of code were executed in a given test run.
 
 Doctest
-
     A style of testing where tests are written as examples that could be typed into the interactive Python interpreter.
     The test runner executes each example and checks the actual output against the expected output.
     Doctests can either be placed in the docstring of a method, or in a separate file.
@@ -259,31 +246,26 @@ For example, if you need both the ``zca`` and ``publisher`` extras, you can have
 The available extras are:
 
 ``zodb``
-
     ZODB testing.
     Depends on ``ZODB3``.
     The relevant layers and helpers are in the module ``plone.testing.zodb``.
 
 ``zca``
-
     Zope Component Architecture testing.
     Depends on core Zope Component Architecture packages such as ``zope.component`` and ``zope.event``.
     The relevant layers and helpers are in the module ``plone.testing.zca``.
 
 ``security``
-
     Security testing.
     Depends on ``zope.security``.
     The relevant layers and helpers are in the module ``plone.testing.security``.
 
 ``publisher``
-
     Zope Publisher testing.
     Depends on ``zope.publisher``, ``zope.browsermenu``, ``zope.browserpage``, ``zope.browserresource`` and ``zope.security`` and sets up ZCML directives.
     The relevant layers and helpers are in the module ``plone.testing.publisher``.
 
 ``z2``
-
     Zope 2 testing.
     Depends on the ``Zope2`` egg, which includes all the dependencies of the Zope 2 application server.
     The relevant layers and helpers are in the module ``plone.testing.z2``
@@ -405,27 +387,22 @@ Layers also allow re-use of test fixtures and set-up/tear-down code.
 At the most basic, a layer is an object with the following methods and attributes:
 
 ``setUp()``
-
     Called by the test runner when the layer is to be set up.
     This is called exactly once for each layer used during a test run.
 
 ``tearDown()``
-
     Called by the test runner when the layer is to be torn down.
     As with ``setUp()``, this is called exactly once for each layer.
 
 ``testSetUp()``
-
     Called immediately before each test case that uses the layer is executed.
     This is useful for setting up aspects of the fixture that are managed on a per-test basis, as opposed to fixture shared among all tests.
 
 ``testTearDown()``
-
     Called immediately after each test case that uses the layer is executed.
     This is a chance to perform any post-test cleanup to ensure the fixture is ready for the next test.
 
 ``__bases__``
-
     A tuple of base layers.
 
 Each test case is associated with zero or one layer.
@@ -538,19 +515,19 @@ Above, we are really saying that *instances* of ``ZIGSpaceShip`` will, by defaul
     You may find it useful to create other layer base/mix-in classes that extend ``plone.testing.Layer`` and provide helper methods for use in your own layers.
     This is perfectly acceptable, but please do not confuse a layer base class used in this manner with the concept of a *base layer* as described above:
 
-        * A class deriving from ``plone.testing.Layer`` is known as a *layer class*.
-          It defines the behaviour of the layer by implementing the lifecycle methods ``setUp()``, ``tearDown()``, ``testSetUp()`` and/or ``testTearDown()``.
+    * A class deriving from ``plone.testing.Layer`` is known as a *layer class*.
+      It defines the behaviour of the layer by implementing the lifecycle methods ``setUp()``, ``tearDown()``, ``testSetUp()`` and/or ``testTearDown()``.
 
-        * A layer class can be instantiated into an actual layer.
-          When a layer is associated with a test, it is the layer *instance* that is used.
+    * A layer class can be instantiated into an actual layer.
+      When a layer is associated with a test, it is the layer *instance* that is used.
 
-        * The instance is usually a shared, module-global object, although in some cases it is useful to create copies of layers by instantiating the class more than once.
+    * The instance is usually a shared, module-global object, although in some cases it is useful to create copies of layers by instantiating the class more than once.
 
-        * Subclassing an existing layer class is just straightforward OOP re-use: the test runner is not aware of the subclassing relationship.
+    * Subclassing an existing layer class is just straightforward OOP re-use: the test runner is not aware of the subclassing relationship.
 
-        * A layer *instance* can be associated with any number of layer *bases*, via its ``__bases__`` property (which is usually via the ``defaultBases`` variable in the class body and/or overridden using the ``bases`` argument to the ``Layer`` constructor).
-          These bases are layer *instances*, not classes.
-          The test runner will inspect the ``__bases__`` attribute of each layer instance it sets up to calculate layer pre-requisites and dependencies.
+    * A layer *instance* can be associated with any number of layer *bases*, via its ``__bases__`` property (which is usually via the ``defaultBases`` variable in the class body and/or overridden using the ``bases`` argument to the ``Layer`` constructor).
+      These bases are layer *instances*, not classes.
+      The test runner will inspect the ``__bases__`` attribute of each layer instance it sets up to calculate layer pre-requisites and dependencies.
 
     Also note that the `zope.testing`_ documentation contains examples of layers that are "old-style" classes where the ``setUp()`` and ``tearDown()`` methods are ``classmethod`` methods and class inheritance syntax is used to specify base layers.
     Whilst this pattern works, we discourage its use, because the classes created using this pattern are not really used as classes.


