Repository: plone.supermodel


Branch: refs/heads/master
Date: 2023-01-08T01:00:05+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.supermodel/commit/2216fb36cb96e69b76c889f616986a1be8bb3b21

Configuring for default

Files changed:
A .editorconfig
A .github/workflows/linting.yml
A .meta.toml
A lint-requirements.txt
A tox.ini
M pyproject.toml
M setup.cfg

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.github/workflows/linting.yml b/.github/workflows/linting.yml\nnew file mode 100644\nindex 0000000..a2139a8\n--- /dev/null\n+++ b/.github/workflows/linting.yml\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+name: Linting\n+on:\n+  push:\n+    branches: [master]\n+  pull_request:\n+    branches: [master]\n+  workflow_dispatch:\n+\n+jobs:\n+  test:\n+    name: Lint code\n+    runs-on: ${{ matrix.os }}\n+    strategy:\n+      matrix:\n+        python-version: ["3.8"]\n+        os: ["ubuntu-22.04"]\n+    steps:\n+      - uses: actions/checkout@v3\n+      - name: Set up Python\n+        uses: actions/setup-python@v4\n+        with:\n+          python-version: ${{ matrix.python-version }}\n+      - name: Cache packages\n+        uses: actions/cache@v3\n+        with:\n+          path: ~/.cache/pip\n+          key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles(\'lint-requirements.txt\', \'tox.ini\') }}\n+          restore-keys: |\n+            ${{ runner.os }}-pip-${{ matrix.python-version }}-\n+            ${{ runner.os }}-pip-\n+      - name: Install dependencies\n+        run: python -m pip install tox\n+      - name: Run formatters\n+        run: tox -e format\n+      # linters\n+      - name: QA\n+        run: tox -e lint\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..e393a44\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "6d382fce"\ndiff --git a/lint-requirements.txt b/lint-requirements.txt\nnew file mode 100644\nindex 0000000..dedd4cb\n--- /dev/null\n+++ b/lint-requirements.txt\n@@ -0,0 +1,7 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+black==22.12.0\n+codespell==2.2.2\n+flake8==6.0.0\n+isort==5.11.4\n+pyupgrade==3.3.1\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..a5b1745 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,9 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\ndiff --git a/setup.cfg b/setup.cfg\nindex 526aeb2..bb3f825 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,2 +1,21 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [bdist_wheel]\n universal = 0\n+\n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n+\n+[check-manifest]\n+ignore =\n+    .editorconfig\n+    .meta.toml\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..0c34067\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,37 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[tox]\n+envlist =\n+    format\n+    lint\n+\n+[testenv]\n+py_files = find plone -name "*.py"\n+rst_files = find plone -name "*.rst"\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat python code\n+skip_install = true\n+deps =\n+    pyupgrade\n+    isort\n+    black\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'{[testenv]py_files} | xargs pyupgrade --py38-plus *.py\'\n+    sh -c \'{[testenv]py_files} | xargs isort *.py\'\n+    sh -c \'{[testenv]py_files} | xargs black *.py\'\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    flake8\n+    codespell\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'{[testenv]py_files} | xargs flake8 *.py\'\n+    sh -c \'{[testenv]py_files} | xargs codespell *.py\'\n+    sh -c \'{[testenv]rst_files} | xargs codespell *.rst\'\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2023-01-08T01:02:26+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.supermodel/commit/ac0cedbb65c656b9b10bf227a06de6737045b17e

chore: run tox -e format

Files changed:
M plone/__init__.py
M plone/supermodel/__init__.py
M plone/supermodel/converters.py
M plone/supermodel/debug.py
M plone/supermodel/directives.py
M plone/supermodel/exportimport.py
M plone/supermodel/fields.py
M plone/supermodel/interfaces.py
M plone/supermodel/model.py
M plone/supermodel/parser.py
M plone/supermodel/patches.py
M plone/supermodel/serializer.py
M plone/supermodel/tests.py
M plone/supermodel/utils.py
M setup.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/supermodel/__init__.py b/plone/supermodel/__init__.py\nindex 6ccce91..2845b60 100644\n--- a/plone/supermodel/__init__.py\n+++ b/plone/supermodel/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from io import BytesIO\n from plone.supermodel import model\n from plone.supermodel import parser\n@@ -15,12 +14,12 @@\n _model_cache = {}\n \n \n-def xmlSchema(filename, schema=u"", policy=u"", _frame=2):\n+def xmlSchema(filename, schema="", policy="", _frame=2):\n     _model = loadFile(filename, policy=policy, _frame=_frame + 1)\n     return _model.schemata[schema]\n \n \n-def loadFile(filename, reload=False, policy=u"", _frame=2):\n+def loadFile(filename, reload=False, policy="", _frame=2):\n     global _model_cache\n     path = utils.relativeToCallingPackage(filename, _frame)\n     if reload or path not in _model_cache:\n@@ -31,13 +30,13 @@ def loadFile(filename, reload=False, policy=u"", _frame=2):\n     return _model_cache[path]\n \n \n-def loadString(model, policy=u""):\n-    if not isinstance(model, six.binary_type):\n+def loadString(model, policy=""):\n+    if not isinstance(model, bytes):\n         model = model.encode()\n     return parser.parse(BytesIO(model), policy=policy)\n \n \n-def serializeSchema(schema, name=u""):\n+def serializeSchema(schema, name=""):\n     return serializeModel(model.Model({name: schema}))\n \n \n@@ -47,10 +46,4 @@ def serializeModel(model):\n \n moduleProvides(IXMLToSchema)\n \n-__all__ = (\n-    \'xmlSchema\',\n-    \'loadFile\',\n-    \'loadString\',\n-    \'serializeSchema\',\n-    \'serializeModel\'\n-)\n+__all__ = ("xmlSchema", "loadFile", "loadString", "serializeSchema", "serializeModel")\ndiff --git a/plone/supermodel/converters.py b/plone/supermodel/converters.py\nindex 1458a46..8763dd2 100644\n--- a/plone/supermodel/converters.py\n+++ b/plone/supermodel/converters.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.supermodel.interfaces import IToUnicode\n from plone.supermodel.utils import fieldTypecast\n from zope.component import adapter\n@@ -19,10 +18,10 @@\n \n # Defaults\n \n+\n @implementer(IFromUnicode)\n @adapter(IField)\n-class DefaultFromUnicode(object):\n-\n+class DefaultFromUnicode:\n     def __init__(self, context):\n         self.context = context\n \n@@ -32,22 +31,22 @@ def fromUnicode(self, value):\n \n @implementer(IToUnicode)\n @adapter(IField)\n-class DefaultToUnicode(object):\n-\n+class DefaultToUnicode:\n     def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n-        if isinstance(value, six.binary_type):\n+        if isinstance(value, bytes):\n             return value.decode()\n-        return six.text_type(value)\n+        return str(value)\n \n \n # Date/time fields\n \n+\n @implementer(IFromUnicode)\n @adapter(IDate)\n-class DateFromUnicode(object):\n+class DateFromUnicode:\n \n     format = "%Y-%m-%d"\n \n@@ -63,7 +62,7 @@ def fromUnicode(self, value):\n \n @implementer(IFromUnicode)\n @adapter(IDatetime)\n-class DatetimeFromUnicode(object):\n+class DatetimeFromUnicode:\n \n     format = "%Y-%m-%d %H:%M:%S"\n \n@@ -79,10 +78,10 @@ def fromUnicode(self, value):\n \n # Interface fields\n \n+\n @implementer(IFromUnicode)\n @adapter(IInterfaceField)\n-class InterfaceFieldFromUnicode(object):\n-\n+class InterfaceFieldFromUnicode:\n     def __init__(self, context):\n         self.context = context\n \n@@ -94,13 +93,12 @@ def fromUnicode(self, value):\n \n @implementer(IToUnicode)\n @adapter(IInterfaceField)\n-class InterfaceFieldToUnicode(object):\n-\n+class InterfaceFieldToUnicode:\n     def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n-        return six.text_type(value.__identifier__)\n+        return str(value.__identifier__)\n \n \n # Object fields - we can read, but not write, as there is no way to know\n@@ -110,8 +108,7 @@ def toUnicode(self, value):\n \n @implementer(IFromUnicode)\n @adapter(IObject)\n-class ObjectFromUnicode(object):\n-\n+class ObjectFromUnicode:\n     def __init__(self, context):\n         self.context = context\n \n@@ -123,12 +120,11 @@ def fromUnicode(self, value):\n \n @implementer(IToUnicode)\n @adapter(IBytes)\n-class BytesToUnicode(object):\n-\n+class BytesToUnicode:\n     def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n-        if isinstance(value, six.binary_type):\n+        if isinstance(value, bytes):\n             return value.decode()\n-        return six.text_type(value)\n+        return str(value)\ndiff --git a/plone/supermodel/debug.py b/plone/supermodel/debug.py\nindex 7224c6c..c957c28 100644\n--- a/plone/supermodel/debug.py\n+++ b/plone/supermodel/debug.py\n@@ -1,15 +1,14 @@\n-# -*- coding: utf-8 -*-\n import threading\n \n \n class SupermodelParseInfo(threading.local):\n-\n     def __getattr__(self, name):\n-        if name == \'stack\':\n+        if name == "stack":\n             self.stack = [None]\n             return self.stack\n-        if name == \'i18n_domain\':\n-            return self.__dict__.get(\'i18n_domain\')\n+        if name == "i18n_domain":\n+            return self.__dict__.get("i18n_domain")\n         return self.__dict__[name]\n \n+\n parseinfo = SupermodelParseInfo()\ndiff --git a/plone/supermodel/directives.py b/plone/supermodel/directives.py\nindex 02b57cc..744d406 100644\n--- a/plone/supermodel/directives.py\n+++ b/plone/supermodel/directives.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.supermodel import loadFile\n from plone.supermodel.interfaces import DEFAULT_ORDER\n from plone.supermodel.interfaces import FIELDSETS_KEY\n@@ -21,14 +20,14 @@\n \n # Directive\n \n+\n class DirectiveClass(type):\n-    """A Directive is used to apply tagged values to a Schema\n-    """\n+    """A Directive is used to apply tagged values to a Schema"""\n \n     def __init__(self, name, bases, attrs):\n-        attrs.setdefault(\'finalize\', None)\n-        super(DirectiveClass, self).__init__(name, bases, attrs)\n-        self.__instance = super(DirectiveClass, self).__call__()\n+        attrs.setdefault("finalize", None)\n+        super().__init__(name, bases, attrs)\n+        self.__instance = super().__call__()\n \n     def __call__(self, *args, **kw):\n         instance = self.__instance\n@@ -37,16 +36,19 @@ def __call__(self, *args, **kw):\n         value = instance.factory(*args, **kw)\n         instance.store(tags, value)\n \n+\n Directive = DirectiveClass(\n-    \'Directive\',\n+    "Directive",\n     (),\n-    dict(__module__=\'plone.supermodel.directives\',),\n+    dict(\n+        __module__="plone.supermodel.directives",\n+    ),\n )\n \n \n class MetadataListDirective(Directive):\n-    """Store a list value in the tagged value under the key.\n-    """\n+    """Store a list value in the tagged value under the key."""\n+\n     key = None\n \n     def store(self, tags, value):\n@@ -54,8 +56,8 @@ def store(self, tags, value):\n \n \n class MetadataDictDirective(Directive):\n-    """Store a dict value in the tagged value under the key.\n-    """\n+    """Store a dict value in the tagged value under the key."""\n+\n     key = None\n \n     def store(self, tags, value):\n@@ -64,9 +66,10 @@ def store(self, tags, value):\n \n # Plugin\n \n+\n @adapter(ISchema)\n @implementer(ISchemaPlugin)\n-class CheckerPlugin(object):\n+class CheckerPlugin:\n \n     key = None\n \n@@ -82,11 +85,9 @@ def check(self):\n         for fieldName in self.fieldNames():\n             if fieldName not in schema:\n                 raise ValueError(\n-                    u\'The directive {0} applied to interface {1} \'\n-                    u\'refers to unknown field name {2}\'.format(\n-                        self.key,\n-                        schema.__identifier__,\n-                        fieldName\n+                    "The directive {} applied to interface {} "\n+                    "refers to unknown field name {}".format(\n+                        self.key, schema.__identifier__, fieldName\n                     )\n                 )\n             yield fieldName\n@@ -97,7 +98,6 @@ def __call__(self):\n \n \n class DictCheckerPlugin(CheckerPlugin):\n-\n     def fieldNames(self):\n         if self.value is None:\n             return []\n@@ -105,12 +105,10 @@ def fieldNames(self):\n \n \n class ListCheckerPlugin(CheckerPlugin):\n-\n     def fieldNames(self):\n         if self.value is None:\n             return\n-        for fieldName in self.value:\n-            yield fieldName\n+        yield from self.value\n \n \n class ListPositionCheckerPlugin(CheckerPlugin):\n@@ -126,21 +124,21 @@ def fieldNames(self):\n \n # Implementations\n \n+\n class load(Directive):\n-    """Directive used to specify the XML model file\n-    """\n+    """Directive used to specify the XML model file"""\n \n     def store(self, tags, value):\n-        tags[FILENAME_KEY] = value[\'filename\']\n-        tags[SCHEMA_NAME_KEY] = value[\'schema\']\n+        tags[FILENAME_KEY] = value["filename"]\n+        tags[SCHEMA_NAME_KEY] = value["schema"]\n \n-    def factory(self, filename, schema=u\'\'):\n+    def factory(self, filename, schema=""):\n         return dict(filename=filename, schema=schema)\n \n \n @adapter(ISchema)\n @implementer(ISchemaPlugin)\n-class SupermodelSchemaPlugin(object):\n+class SupermodelSchemaPlugin:\n \n     order = -1000\n \n@@ -159,7 +157,7 @@ def __call__(self):\n         schema = Element.queryTaggedValue(\n             interface,\n             SCHEMA_NAME_KEY,\n-            default=u\'\',\n+            default="",\n         )\n \n         moduleName = interface.__module__\n@@ -167,26 +165,26 @@ def __call__(self):\n \n         directory = moduleName\n \n-        if hasattr(module, \'__path__\'):\n+        if hasattr(module, "__path__"):\n             directory = module.__path__[0]\n         else:\n-            while \'.\' in moduleName:\n-                moduleName, _ = moduleName.rsplit(\'.\', 1)\n+            while "." in moduleName:\n+                moduleName, _ = moduleName.rsplit(".", 1)\n                 module = sys.modules.get(moduleName, None)\n-                if hasattr(module, \'__path__\'):\n+                if hasattr(module, "__path__"):\n                     directory = module.__path__[0]\n                     break\n \n         directory = os.path.abspath(directory)\n         # Let / act as path separator on all platforms\n-        filename = filename.replace(\'/\', os.path.sep)\n+        filename = filename.replace("/", os.path.sep)\n         filename = os.path.abspath(os.path.join(directory, filename))\n \n         model = loadFile(filename)\n         if schema not in model.schemata:\n             raise ValueError(\n-                \'Schema "{0}" specified for interface {1} does not exist \'\n-                \'in {2}.\'.format(\n+                \'Schema "{}" specified for interface {} does not exist \'\n+                "in {}.".format(\n                     schema,\n                     interface.__identifier__,\n                     filename,\n@@ -197,18 +195,12 @@ def __call__(self):\n \n \n class fieldset(MetadataListDirective):\n-    """Directive used to create fieldsets\n-    """\n+    """Directive used to create fieldsets"""\n+\n     key = FIELDSETS_KEY\n \n     def factory(\n-        self,\n-        name,\n-        label=None,\n-        description=None,\n-        fields=None,\n-        order=DEFAULT_ORDER,\n-        **kw\n+        self, name, label=None, description=None, fields=None, order=DEFAULT_ORDER, **kw\n     ):\n         fieldset = Fieldset(\n             name,\n@@ -230,8 +222,7 @@ def fieldNames(self):\n         if self.value is None:\n             return\n         for fieldset in self.value:\n-            for fieldName in fieldset.fields:\n-                yield fieldName\n+            yield from fieldset.fields\n \n \n try:\n@@ -239,16 +230,15 @@ def fieldNames(self):\n except ImportError:\n     pass\n else:\n+\n     class primary(MetadataListDirective):\n-        """Directive used to mark one or more fields as \'primary\'\n-        """\n+        """Directive used to mark one or more fields as \'primary\'"""\n+\n         key = PRIMARY_FIELDS_KEY\n \n         def factory(self, *args):\n             if not args:\n-                raise TypeError(\n-                    \'The primary directive expects at least one argument.\'\n-                )\n+                raise TypeError("The primary directive expects at least one argument.")\n             return args\n \n     class PrimaryFieldsPlugin(ListCheckerPlugin):\ndiff --git a/plone/supermodel/exportimport.py b/plone/supermodel/exportimport.py\nindex 247de45..4e3645d 100644\n--- a/plone/supermodel/exportimport.py\n+++ b/plone/supermodel/exportimport.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from lxml import etree\n from plone.supermodel.debug import parseinfo\n from plone.supermodel.interfaces import IDefaultFactory\n@@ -32,7 +31,7 @@ class OrderedDictField(zope.schema.Dict):\n \n \n @implementer(IFieldExportImportHandler)\n-class BaseHandler(object):\n+class BaseHandler:\n     """Base class for import/export handlers.\n \n     The read_field method is called to read one field of the known subtype\n@@ -45,21 +44,28 @@ class BaseHandler(object):\n     # Elements that we will not read/write. \'r\' means skip when reading;\n     # \'w\' means skip when writing; \'rw\' means skip always.\n \n-    filteredAttributes = {\'order\': \'rw\', \'unique\': \'rw\', \'defaultFactory\': \'w\'}\n+    filteredAttributes = {"order": "rw", "unique": "rw", "defaultFactory": "w"}\n \n     # Elements that are of the same type as the field itself\n-    fieldTypeAttributes = (\'min\', \'max\', \'default\', )\n+    fieldTypeAttributes = (\n+        "min",\n+        "max",\n+        "default",\n+    )\n \n     # Elements that are of the same type as the field itself, but are\n     # otherwise not validated\n-    nonValidatedfieldTypeAttributes = (\'missing_value\', )\n+    nonValidatedfieldTypeAttributes = ("missing_value",)\n \n     # Attributes that contain another field. Unfortunately,\n-    fieldInstanceAttributes = (\'key_type\', \'value_type\', )\n+    fieldInstanceAttributes = (\n+        "key_type",\n+        "value_type",\n+    )\n \n     # Fields that are always written\n \n-    forcedFields = frozenset([\'default\', \'missing_value\'])\n+    forcedFields = frozenset(["default", "missing_value"])\n \n     def __init__(self, klass):\n         self.klass = klass\n@@ -71,18 +77,15 @@ def __init__(self, klass):\n         for schema in implementedBy(self.klass).flattened():\n             self.fieldAttributes.update(zope.schema.getFields(schema))\n \n-        self.fieldAttributes[\'defaultFactory\'] = zope.schema.Object(\n-            __name__=\'defaultFactory\',\n-            title=u"defaultFactory",\n-            schema=Interface\n+        self.fieldAttributes["defaultFactory"] = zope.schema.Object(\n+            __name__="defaultFactory", title="defaultFactory", schema=Interface\n         )\n \n     def _constructField(self, attributes):\n         return self.klass(**attributes)\n \n     def read(self, element):\n-        """Read a field from the element and return a new instance\n-        """\n+        """Read a field from the element and return a new instance"""\n         attributes = {}\n         deferred = {}\n         deferred_nonvalidated = {}\n@@ -91,7 +94,7 @@ def read(self, element):\n             parseinfo.stack.append(attribute_element)\n             attribute_name = noNS(attribute_element.tag)\n \n-            if \'r\' in self.filteredAttributes.get(attribute_name, \'\'):\n+            if "r" in self.filteredAttributes.get(attribute_name, ""):\n                 continue\n \n             attributeField = self.fieldAttributes.get(attribute_name, None)\n@@ -105,33 +108,29 @@ def read(self, element):\n \n                 elif attribute_name in self.fieldInstanceAttributes:\n \n-                    attributeField_type = attribute_element.get(\'type\')\n+                    attributeField_type = attribute_element.get("type")\n                     handler = queryUtility(\n-                        IFieldExportImportHandler,\n-                        name=attributeField_type\n+                        IFieldExportImportHandler, name=attributeField_type\n                     )\n \n                     if handler is None:\n                         raise NotImplementedError(\n-                            u"Type %s used for %s not supported" %\n-                            (attributeField_type, attribute_name)\n+                            "Type %s used for %s not supported"\n+                            % (attributeField_type, attribute_name)\n                         )\n \n-                    attributes[attribute_name] = handler.read(\n-                        attribute_element\n-                    )\n+                    attributes[attribute_name] = handler.read(attribute_element)\n \n                 else:\n                     attributes[attribute_name] = self.readAttribute(\n-                        attribute_element,\n-                        attributeField\n+                        attribute_element, attributeField\n                     )\n             parseinfo.stack.pop()\n \n-        name = element.get(\'name\')\n+        name = element.get("name")\n         if name is not None:\n             name = str(name)\n-            attributes[\'__name__\'] = name\n+            attributes["__name__"] = name\n \n         field_instance = self._constructField(attributes)\n \n@@ -157,7 +156,7 @@ def read(self, element):\n \n                 clone = self.klass.__new__(self.klass)\n                 clone.__dict__.update(field_instance.__dict__)\n-                clone.__dict__[\'validate\'] = lambda value: True\n+                clone.__dict__["validate"] = lambda value: True\n \n                 attribute_element = deferred_nonvalidated[attribute_name]\n                 parseinfo.stack.append(attribute_element)\n@@ -173,33 +172,30 @@ def read(self, element):\n             # restrict to those that provide IContextAwareDefaultFactory\n             # or IDefaultFactory\n             if not (\n-                IContextAwareDefaultFactory.providedBy(\n-                    field_instance.defaultFactory\n-                ) or\n-                IDefaultFactory.providedBy(field_instance.defaultFactory)\n+                IContextAwareDefaultFactory.providedBy(field_instance.defaultFactory)\n+                or IDefaultFactory.providedBy(field_instance.defaultFactory)\n             ):\n                 raise ImportError(\n-                    u"defaultFactory must provide "\n-                    u"zope.schema.interfaces.IContextAwareDefaultFactory "\n-                    u"or plone.supermodel.IDefaultFactory"\n+                    "defaultFactory must provide "\n+                    "zope.schema.interfaces.IContextAwareDefaultFactory "\n+                    "or plone.supermodel.IDefaultFactory"\n                 )\n \n         return field_instance\n \n-    def write(self, field, name, type, elementName=\'field\'):\n-        """Create and return a new element representing the given field\n-        """\n+    def write(self, field, name, type, elementName="field"):\n+        """Create and return a new element representing the given field"""\n \n         element = etree.Element(elementName)\n \n         if name:\n-            element.set(\'name\', name)\n+            element.set("name", name)\n \n-        element.set(\'type\', type)\n+        element.set("type", type)\n \n         for attribute_name in sorted(self.fieldAttributes.keys()):\n             attributeField = self.fieldAttributes[attribute_name]\n-            if \'w\' in self.filteredAttributes.get(attribute_name, \'\'):\n+            if "w" in self.filteredAttributes.get(attribute_name, ""):\n                 continue\n             child = self.writeAttribute(attributeField, field)\n             if child is not None:\n@@ -224,7 +220,7 @@ def writeAttribute(self, attributeField, field, ignoreDefault=True):\n         attributeField = attributeField.bind(field)\n         value = attributeField.get(field)\n \n-        force = (elementName in self.forcedFields)\n+        force = elementName in self.forcedFields\n \n         if ignoreDefault and value == attributeField.default:\n             return None\n@@ -232,30 +228,22 @@ def writeAttribute(self, attributeField, field, ignoreDefault=True):\n         # The value points to another field. Recurse.\n         if IField.providedBy(value):\n             value_fieldType = IFieldNameExtractor(value)()\n-            handler = queryUtility(\n-                IFieldExportImportHandler,\n-                name=value_fieldType\n-            )\n+            handler = queryUtility(IFieldExportImportHandler, name=value_fieldType)\n             if handler is None:\n                 return None\n             return handler.write(\n-                value, name=None,\n-                type=value_fieldType,\n-                elementName=elementName\n+                value, name=None, type=value_fieldType, elementName=elementName\n             )\n \n         # For \'default\', \'missing_value\' etc, we want to validate against\n         # the imported field type itself, not the field type of the attribute\n-        if elementName in self.fieldTypeAttributes or \\\n-                elementName in self.nonValidatedfieldTypeAttributes:\n+        if (\n+            elementName in self.fieldTypeAttributes\n+            or elementName in self.nonValidatedfieldTypeAttributes\n+        ):\n             attributeField = field\n \n-        return valueToElement(\n-            attributeField,\n-            value,\n-            name=elementName,\n-            force=force\n-        )\n+        return valueToElement(attributeField, value, name=elementName, force=force)\n \n \n class DictHandler(BaseHandler):\n@@ -264,14 +252,12 @@ class DictHandler(BaseHandler):\n     """\n \n     def __init__(self, klass):\n-        super(DictHandler, self).__init__(klass)\n-        self.fieldAttributes[\'key_type\'] = zope.schema.Field(\n-            __name__=\'key_type\',\n-            title=u"Key type"\n+        super().__init__(klass)\n+        self.fieldAttributes["key_type"] = zope.schema.Field(\n+            __name__="key_type", title="Key type"\n         )\n-        self.fieldAttributes[\'value_type\'] = zope.schema.Field(\n-            __name__=\'value_type\',\n-            title=u"Value type"\n+        self.fieldAttributes["value_type"] = zope.schema.Field(\n+            __name__="value_type", title="Value type"\n         )\n \n \n@@ -283,60 +269,49 @@ class ObjectHandler(BaseHandler):\n     # We can\'t serialise the value or missing_value of an object field.\n \n     filteredAttributes = BaseHandler.filteredAttributes.copy()\n-    filteredAttributes.update({\'default\': \'w\', \'missing_value\': \'w\'})\n+    filteredAttributes.update({"default": "w", "missing_value": "w"})\n \n     def __init__(self, klass):\n-        super(ObjectHandler, self).__init__(klass)\n+        super().__init__(klass)\n \n         # This is not correctly set in the interface\n-        self.fieldAttributes[\'schema\'] = zope.schema.InterfaceField(\n-            __name__=\'schema\'\n-        )\n+        self.fieldAttributes["schema"] = zope.schema.InterfaceField(__name__="schema")\n \n \n class ChoiceHandler(BaseHandler):\n-    """Special handling for the Choice field\n-    """\n+    """Special handling for the Choice field"""\n \n     filteredAttributes = BaseHandler.filteredAttributes.copy()\n     filteredAttributes.update(\n-        {\'vocabulary\': \'w\',\n-         \'values\': \'w\',\n-         \'source\': \'w\',\n-         \'vocabularyName\': \'rw\'\n-         }\n+        {"vocabulary": "w", "values": "w", "source": "w", "vocabularyName": "rw"}\n     )\n \n     def __init__(self, klass):\n-        super(ChoiceHandler, self).__init__(klass)\n+        super().__init__(klass)\n \n         # Special options for the constructor. These are not automatically\n         # written.\n \n-        self.fieldAttributes[\'vocabulary\'] = zope.schema.TextLine(\n-            __name__=\'vocabulary\',\n-            title=u"Named vocabulary"\n+        self.fieldAttributes["vocabulary"] = zope.schema.TextLine(\n+            __name__="vocabulary", title="Named vocabulary"\n         )\n \n-        self.fieldAttributes[\'values\'] = zope.schema.List(\n-            __name__=\'values\',\n-            title=u"Values",\n-            value_type=zope.schema.Text(title=u"Value")\n+        self.fieldAttributes["values"] = zope.schema.List(\n+            __name__="values",\n+            title="Values",\n+            value_type=zope.schema.Text(title="Value"),\n         )\n \n         # XXX: We can\'t be more specific about the schema, since the field\n         # supports both ISource and IContextSourceBinder. However, the\n         # initialiser will validate.\n-        self.fieldAttributes[\'source\'] = zope.schema.Object(\n-            __name__=\'source\',\n-            title=u"Source",\n-            schema=Interface\n+        self.fieldAttributes["source"] = zope.schema.Object(\n+            __name__="source", title="Source", schema=Interface\n         )\n \n     def readAttribute(self, element, attributeField):\n-        if (\n-            etree.QName(element).localname == \'values\' and\n-            any([child.get(\'key\') for child in element])\n+        if etree.QName(element).localname == "values" and any(\n+            [child.get("key") for child in element]\n         ):\n             attributeField = OrderedDictField(\n                 key_type=zope.schema.TextLine(),\n@@ -345,64 +320,48 @@ def readAttribute(self, element, attributeField):\n         return elementToValue(attributeField, element)\n \n     def _constructField(self, attributes):\n-        if \'values\' in attributes:\n-            if isinstance(attributes[\'values\'], OrderedDict):\n-                attributes[\'values\'] = attributes[\'values\'].items()\n+        if "values" in attributes:\n+            if isinstance(attributes["values"], OrderedDict):\n+                attributes["values"] = attributes["values"].items()\n             terms = []\n-            for value in attributes[\'values\']:\n-                title = (value or u\'\')\n+            for value in attributes["values"]:\n+                title = value or ""\n                 if isinstance(value, tuple):\n                     value, title = value\n-                encoded = (value or \'\').encode(\'unicode_escape\')\n+                encoded = (value or "").encode("unicode_escape")\n                 if value != encoded:\n-                    value = value or u\'\'\n-                    term = SimpleTerm(\n-                        token=encoded,\n-                        value=value,\n-                        title=title\n-                    )\n+                    value = value or ""\n+                    term = SimpleTerm(token=encoded, value=value, title=title)\n                 else:\n                     term = SimpleTerm(value=value, title=title)\n                 terms.append(term)\n-            attributes[\'vocabulary\'] = SimpleVocabulary(terms)\n-            del attributes[\'values\']\n-        return super(ChoiceHandler, self)._constructField(attributes)\n+            attributes["vocabulary"] = SimpleVocabulary(terms)\n+            del attributes["values"]\n+        return super()._constructField(attributes)\n \n-    def write(self, field, name, type, elementName=\'field\'):\n+    def write(self, field, name, type, elementName="field"):\n \n-        element = super(ChoiceHandler, self).write(\n-            field,\n-            name,\n-            type,\n-            elementName\n-        )\n+        element = super().write(field, name, type, elementName)\n \n         # write vocabulary or values list\n \n         # Named vocabulary\n         if field.vocabularyName is not None and field.vocabulary is None:\n-            attributeField = self.fieldAttributes[\'vocabulary\']\n+            attributeField = self.fieldAttributes["vocabulary"]\n             child = valueToElement(\n-                attributeField,\n-                field.vocabularyName,\n-                name=\'vocabulary\',\n-                force=True\n+                attributeField, field.vocabularyName, name="vocabulary", force=True\n             )\n             element.append(child)\n \n         # Listed vocabulary - attempt to convert to a simple list of values\n-        elif (\n-            field.vocabularyName is None and\n-            IVocabularyTokenized.providedBy(field.vocabulary)\n+        elif field.vocabularyName is None and IVocabularyTokenized.providedBy(\n+            field.vocabulary\n         ):\n             value = []\n             for term in field.vocabulary:\n-                if (\n-                    isinstance(term.value, six.integer_types)\n-                    or (\n-                        isinstance(term.value, six.string_types)\n-                        and six.b(term.token) == term.value.encode(\'unicode_escape\')\n-                    )\n+                if isinstance(term.value, int) or (\n+                    isinstance(term.value, str)\n+                    and six.b(term.token) == term.value.encode("unicode_escape")\n                 ):\n                     if term.title and term.title != term.value:\n                         value.append((term.value, term.title))\n@@ -410,34 +369,31 @@ def write(self, field, name, type, elementName=\'field\'):\n                         value.append(term.value)\n                 else:\n                     raise NotImplementedError(\n-                        u"Cannot export a vocabulary that is not "\n-                        u"based on a simple list of values"\n+                        "Cannot export a vocabulary that is not "\n+                        "based on a simple list of values"\n                     )\n \n-            attributeField = self.fieldAttributes[\'values\']\n+            attributeField = self.fieldAttributes["values"]\n             if any(map(lambda v: isinstance(v, tuple), value)):\n+\n                 def _pair(v):\n                     return v if len(v) == 2 else (v[0],) * 2\n+\n                 value = OrderedDict(map(_pair, value))\n                 attributeField = OrderedDictField(\n                     key_type=zope.schema.TextLine(),\n                     value_type=zope.schema.TextLine(),\n                 )\n-            child = valueToElement(\n-                attributeField,\n-                value,\n-                name=\'values\',\n-                force=True\n-            )\n+            child = valueToElement(attributeField, value, name="values", force=True)\n             element.append(child)\n \n         # Anything else is not allowed - we can\'t export ISource/IVocabulary or\n         #  IContextSourceBinder objects.\n         else:\n             raise NotImplementedError(\n-                u"Choice fields with vocabularies not based on "\n-                u"a simple list of values or a named vocabulary "\n-                u"cannot be exported"\n+                "Choice fields with vocabularies not based on "\n+                "a simple list of values or a named vocabulary "\n+                "cannot be exported"\n             )\n \n         return element\ndiff --git a/plone/supermodel/fields.py b/plone/supermodel/fields.py\nindex 0e993f4..7cfbf00 100644\n--- a/plone/supermodel/fields.py\n+++ b/plone/supermodel/fields.py\n@@ -1,18 +1,15 @@\n-# -*- coding: utf-8 -*-\n import plone.supermodel.exportimport\n import zope.schema\n \n+\n # Field import/export handlers\n \n BytesHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Bytes)\n ASCIIHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.ASCII)\n-BytesLineHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.BytesLine)\n-ASCIILineHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.ASCIILine)\n+BytesLineHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.BytesLine)\n+ASCIILineHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.ASCIILine)\n TextHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Text)\n-TextLineHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.TextLine)\n+TextLineHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.TextLine)\n BoolHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Bool)\n IntHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Int)\n FloatHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Float)\n@@ -20,21 +17,17 @@\n TupleHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Tuple)\n ListHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.List)\n SetHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Set)\n-FrozenSetHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.FrozenSet)\n-PasswordHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.Password)\n+FrozenSetHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.FrozenSet)\n+PasswordHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Password)\n DictHandler = plone.supermodel.exportimport.DictHandler(zope.schema.Dict)\n-DatetimeHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.Datetime)\n+DatetimeHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Datetime)\n DateHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Date)\n-SourceTextHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.SourceText)\n+SourceTextHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.SourceText)\n URIHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.URI)\n IdHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Id)\n-DottedNameHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.DottedName)\n+DottedNameHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.DottedName)\n InterfaceFieldHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.InterfaceField)\n+    zope.schema.InterfaceField\n+)\n ObjectHandler = plone.supermodel.exportimport.ObjectHandler(zope.schema.Object)\n ChoiceHandler = plone.supermodel.exportimport.ChoiceHandler(zope.schema.Choice)\ndiff --git a/plone/supermodel/interfaces.py b/plone/supermodel/interfaces.py\nindex 115f330..a65420d 100644\n--- a/plone/supermodel/interfaces.py\n+++ b/plone/supermodel/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Interface\n from zope.interface.interfaces import IInterface\n \n@@ -8,74 +7,60 @@\n # Keys for tagged values on interfaces\n \n # absolute file name of model file\n-FILENAME_KEY = \'plone.supermodel.filename\'\n+FILENAME_KEY = "plone.supermodel.filename"\n \n # name of schema that was loaded from the model\n-SCHEMA_NAME_KEY = \'plone.supermodel.schemaname\'\n+SCHEMA_NAME_KEY = "plone.supermodel.schemaname"\n \n # list of fieldsets\n-FIELDSETS_KEY = \'plone.supermodel.fieldsets\'\n+FIELDSETS_KEY = "plone.supermodel.fieldsets"\n \n # Primary fields (requires plone.rfc822)\n-PRIMARY_FIELDS_KEY = \'plone.supermodel.primary\'\n+PRIMARY_FIELDS_KEY = "plone.supermodel.primary"\n \n # The namespace for the default supermodel schema/field parser\n \n-XML_NAMESPACE = u"http://namespaces.plone.org/supermodel/schema"\n-I18N_NAMESPACE = u\'http://xml.zope.org/namespaces/i18n\'\n+XML_NAMESPACE = "http://namespaces.plone.org/supermodel/schema"\n+I18N_NAMESPACE = "http://xml.zope.org/namespaces/i18n"\n \n DEFAULT_ORDER = 9999\n \n \n class ISchema(IInterface):\n-    """Describes a schema as generated by this library\n-    """\n+    """Describes a schema as generated by this library"""\n \n \n class IModel(Interface):\n-    """Describes a model as generated by this library\n-    """\n+    """Describes a model as generated by this library"""\n \n-    schema = zope.schema.InterfaceField(\n-        title=u"Default schema",\n-        readonly=True\n-    )\n+    schema = zope.schema.InterfaceField(title="Default schema", readonly=True)\n \n     schemata = zope.schema.Dict(\n-        title=u"Schemata",\n+        title="Schemata",\n         key_type=zope.schema.TextLine(\n-            title=u"Schema name",\n-            description=u"Default schema is under the key u\'\'."\n+            title="Schema name", description="Default schema is under the key u\'\'."\n         ),\n-        value_type=zope.schema.Object(\n-            title=u"Schema interface",\n-            schema=ISchema\n-        )\n+        value_type=zope.schema.Object(title="Schema interface", schema=ISchema),\n     )\n \n \n class IFieldset(Interface):\n-    """Describes a grouping of fields in the schema\n-    """\n+    """Describes a grouping of fields in the schema"""\n \n-    __name__ = zope.schema.TextLine(title=u"Fieldset name")\n+    __name__ = zope.schema.TextLine(title="Fieldset name")\n \n-    label = zope.schema.TextLine(title=u"Label")\n+    label = zope.schema.TextLine(title="Label")\n \n-    description = zope.schema.TextLine(\n-        title=u"Long description",\n-        required=False\n-    )\n+    description = zope.schema.TextLine(title="Long description", required=False)\n \n     order = zope.schema.Int(\n-        title=u"Order",\n+        title="Order",\n         required=False,\n         default=DEFAULT_ORDER,\n     )\n \n     fields = zope.schema.List(\n-        title=u"Field names",\n-        value_type=zope.schema.TextLine(title=u"Field name")\n+        title="Field names", value_type=zope.schema.TextLine(title="Field name")\n     )\n \n \n@@ -86,12 +71,12 @@ class ISchemaPlugin(Interface):\n     Execution is deferred until the full supermodel environment is available.\n     """\n \n-    order = zope.schema.Int(title=u"Order", required=False,\n-                            description=u"Sort key for plugin execution order")\n+    order = zope.schema.Int(\n+        title="Order", required=False, description="Sort key for plugin execution order"\n+    )\n \n     def __call__():\n-        """Execute plugin\n-        """\n+        """Execute plugin"""\n \n \n class IXMLToSchema(Interface):\n@@ -107,7 +92,7 @@ class IXMLToSchema(Interface):\n         model = loadFile(\'schema.xml\')\n     """\n \n-    def xmlSchema(filename, schema=u"", policy=u""):\n+    def xmlSchema(filename, schema="", policy=""):\n         """Given a filename relative to the current module, return an\n         interface representing the schema contained in that file. If there\n         are multiple <schema /> blocks, return the unnamed one, unless\n@@ -122,7 +107,7 @@ def xmlSchema(filename, schema=u"", policy=u""):\n         Raises an IOError if the file cannot be opened.\n         """\n \n-    def loadFile(filename, reload=False, policy=u""):\n+    def loadFile(filename, reload=False, policy=""):\n         """Return an IModel as contained in the given XML file, which is read\n         relative to the current module (unless it is an absolute path).\n \n@@ -132,11 +117,10 @@ def loadFile(filename, reload=False, policy=u""):\n         ISchemaPolicy.\n         """\n \n-    def loadString(model, policy=u""):\n-        """Load a model from a string rather than a file.\n-        """\n+    def loadString(model, policy=""):\n+        """Load a model from a string rather than a file."""\n \n-    def serializeSchema(schema, name=u""):\n+    def serializeSchema(schema, name=""):\n         """Return an XML string representing the given schema interface. This\n         is a convenience method around the serializeModel() method, below.\n         """\n@@ -154,16 +138,13 @@ class ISchemaPolicy(Interface):\n     """\n \n     def module(schemaName, tree):\n-        """Return the module name to use.\n-        """\n+        """Return the module name to use."""\n \n     def bases(schemaName, tree):\n-        """Return the bases to use.\n-        """\n+        """Return the bases to use."""\n \n     def name(schemaName, tree):\n-        """Return the schema name to use\n-        """\n+        """Return the schema name to use"""\n \n \n class IFieldExportImportHandler(Interface):\n@@ -173,12 +154,10 @@ class IFieldExportImportHandler(Interface):\n     """\n \n     def read(node):\n-        """Read a field from the node and return a new instance\n-        """\n+        """Read a field from the node and return a new instance"""\n \n-    def write(field, fieldName, fieldType, elementName=\'field\'):\n-        """Create and return a new node representing the given field\n-        """\n+    def write(field, fieldName, fieldType, elementName="field"):\n+        """Create and return a new node representing the given field"""\n \n \n class ISchemaMetadataHandler(Interface):\n@@ -188,13 +167,11 @@ class ISchemaMetadataHandler(Interface):\n     """\n \n     namespace = zope.schema.URI(\n-        title=u"XML namespace used by this handler",\n-        required=False\n+        title="XML namespace used by this handler", required=False\n     )\n \n     prefix = zope.schema.ASCII(\n-        title=u"Preferred XML schema namespace for serialisation",\n-        required=False\n+        title="Preferred XML schema namespace for serialisation", required=False\n     )\n \n     def read(schemaNode, schema):\n@@ -216,12 +193,10 @@ class IFieldMetadataHandler(Interface):\n     """\n \n     namespace = zope.schema.URI(\n-        title=u"XML namespace used by this handler",\n-        required=False\n+        title="XML namespace used by this handler", required=False\n     )\n     prefix = zope.schema.ASCII(\n-        title=u"Preferred XML schema namespace for serialisation",\n-        required=False\n+        title="Preferred XML schema namespace for serialisation", required=False\n     )\n \n     def read(fieldNode, schema, field):\n@@ -238,12 +213,10 @@ def write(fieldNode, schema, field):\n \n \n class IFieldNameExtractor(Interface):\n-    """Adapter to determine the canonical name of a field\n-    """\n+    """Adapter to determine the canonical name of a field"""\n \n     def __call__():\n-        """Return the name of the adapted field\n-        """\n+        """Return the name of the adapted field"""\n \n \n class IToUnicode(Interface):\n@@ -252,8 +225,7 @@ class IToUnicode(Interface):\n     """\n \n     def toUnicode(value):\n-        """Convert the field value to a unicode string.\n-        """\n+        """Convert the field value to a unicode string."""\n \n \n class IDefaultFactory(Interface):\n@@ -268,9 +240,7 @@ def __call__():\n \n \n class IInvariant(Interface):\n-    """Marker interface for a callable used as a form invariant.\n-    """\n+    """Marker interface for a callable used as a form invariant."""\n \n     def __call__(data):\n-        """Returns None or raises zope.interface.Invalid\n-        """\n+        """Returns None or raises zope.interface.Invalid"""\ndiff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex a3fca34..f5ac818 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.supermodel.interfaces import DEFAULT_ORDER\n from plone.supermodel.interfaces import IFieldset\n from plone.supermodel.interfaces import IModel\n@@ -14,32 +13,27 @@\n \n \n zope.deferredimport.defineFrom(\n-    \'plone.supermodel.directives\',\n-    \'load\',\n-    \'fieldset\',\n+    "plone.supermodel.directives",\n+    "load",\n+    "fieldset",\n )\n \n try:\n     from plone.rfc822.interfaces import IPrimaryField\n+\n     IPrimaryField  # PEP8\n except ImportError:\n     pass\n else:\n-    zope.deferredimport.defineFrom(\'plone.supermodel.directives\', \'primary\')\n+    zope.deferredimport.defineFrom("plone.supermodel.directives", "primary")\n \n-logger = logging.getLogger(\'plone.supermodel\')\n+logger = logging.getLogger("plone.supermodel")\n \n \n @implementer(IFieldset)\n-class Fieldset(object):\n-\n+class Fieldset:\n     def __init__(\n-        self,\n-        __name__,\n-        label=None,\n-        description=None,\n-        fields=None,\n-        order=DEFAULT_ORDER\n+        self, __name__, label=None, description=None, fields=None, order=DEFAULT_ORDER\n     ):\n         self.__name__ = __name__\n         self.label = label or __name__\n@@ -52,16 +46,13 @@ def __init__(\n             self.fields = []\n \n     def __repr__(self):\n-        return "<Fieldset \'{0}\' order {1:d} of {2}>".format(\n-            self.__name__,\n-            self.order,\n-            \', \'.join(self.fields)\n+        return "<Fieldset \'{}\' order {:d} of {}>".format(\n+            self.__name__, self.order, ", ".join(self.fields)\n         )\n \n \n @implementer(IModel)\n-class Model(object):\n-\n+class Model:\n     def __init__(self, schemata=None):\n         if schemata is None:\n             schemata = {}\n@@ -71,43 +62,37 @@ def __init__(self, schemata=None):\n \n     @property\n     def schema(self):\n-        return self.schemata.get(u"", None)\n+        return self.schemata.get("", None)\n \n \n @implementer(ISchema)\n class SchemaClass(InterfaceClass):\n-\n-    def __init__(self, name, bases=(), attrs=None, __doc__=None,\n-                 __module__=None):\n+    def __init__(self, name, bases=(), attrs=None, __doc__=None, __module__=None):\n         InterfaceClass.__init__(self, name, bases, attrs, __doc__, __module__)\n         self._SchemaClass_finalize()\n \n     def _SchemaClass_finalize(self):\n-        adapters = [(getattr(adapter, \'order\', 0), name, adapter)\n-                    for name, adapter in getAdapters((self,), ISchemaPlugin)]\n+        adapters = [\n+            (getattr(adapter, "order", 0), name, adapter)\n+            for name, adapter in getAdapters((self,), ISchemaPlugin)\n+        ]\n         adapters.sort()\n         for order, name, adapter in adapters:\n             adapter()\n \n \n-Schema = SchemaClass(\n-    \'Schema\',\n-    (Interface,),\n-    __module__=\'plone.supermodel.model\'\n-)\n+Schema = SchemaClass("Schema", (Interface,), __module__="plone.supermodel.model")\n \n \n def finalizeSchemas(parent=Schema):\n-    """Configuration action called after plone.supermodel is configured.\n-    """\n+    """Configuration action called after plone.supermodel is configured."""\n     if not isinstance(parent, SchemaClass):\n         raise TypeError(\n-            \'Only instances of plone.supermodel.model.SchemaClass can be \'\n-            \'finalized.\'\n+            "Only instances of plone.supermodel.model.SchemaClass can be " "finalized."\n         )\n \n     def walk(schema):\n-        # When we have behaviors on the Plone site root we got some shcmeas that \n+        # When we have behaviors on the Plone site root we got some shcmeas that\n         # are not SchemaClasses\n         if isinstance(schema, SchemaClass):\n             yield schema\n@@ -123,20 +108,18 @@ def walk(schema):\n             children = ()\n \n         for child in children:\n-            for s in walk(child):\n-                yield s\n+            yield from walk(child)\n \n     schemas = set(walk(parent))\n     for schema in sorted(schemas):\n-        if hasattr(schema, \'_SchemaClass_finalize\'):\n+        if hasattr(schema, "_SchemaClass_finalize"):\n             schema._SchemaClass_finalize()\n         elif isinstance(schema, InterfaceClass):\n             logger.warn(\n-                \'{0}.{1} is not an instance of SchemaClass. \'\n-                \'This can happen if the first base class of a schema is not a \'\n-                \'SchemaClass. See \'\n-                \'https://bugs.launchpad.net/zope.interface/+bug/791218\'.format(\n-                    schema.__module__,\n-                    schema.__name__\n+                "{}.{} is not an instance of SchemaClass. "\n+                "This can happen if the first base class of a schema is not a "\n+                "SchemaClass. See "\n+                "https://bugs.launchpad.net/zope.interface/+bug/791218".format(\n+                    schema.__module__, schema.__name__\n                 )\n             )\ndiff --git a/plone/supermodel/parser.py b/plone/supermodel/parser.py\nindex 8a5c55d..9e84dd8 100644\n--- a/plone/supermodel/parser.py\n+++ b/plone/supermodel/parser.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from lxml import etree\n from plone.supermodel.debug import parseinfo\n from plone.supermodel.interfaces import DEFAULT_ORDER\n@@ -29,31 +28,29 @@\n \n # Exception\n class SupermodelParseError(Exception):\n-\n     def __init__(self, orig_exc, fname, element, tb):\n         msg = str(orig_exc)\n         lineno = None\n-        if hasattr(orig_exc, \'lineno\'):\n+        if hasattr(orig_exc, "lineno"):\n             lineno = orig_exc.lineno\n         elif element is not None:\n-            lineno = getattr(element, \'sourceline\', \'unknown\')\n-        if fname or lineno != \'unknown\':\n-            msg += \'\\n  File "%s", line %s\' % (fname or \'<unknown>\', lineno)\n+            lineno = getattr(element, "sourceline", "unknown")\n+        if fname or lineno != "unknown":\n+            msg += \'\\n  File "{}", line {}\'.format(fname or "<unknown>", lineno)\n         if fname and lineno:\n             line = linecache.getline(fname, lineno).strip()\n-            msg += \'\\n    %s\' % line\n-        msg += \'\\n\'\n-        msg += \'\'.join(traceback.format_tb(tb))\n-        msg += \'\\n\'\n+            msg += "\\n    %s" % line\n+        msg += "\\n"\n+        msg += "".join(traceback.format_tb(tb))\n+        msg += "\\n"\n         self.args = [msg]\n \n \n # Helper adapters\n @implementer(ISchemaPolicy)\n-class DefaultSchemaPolicy(object):\n-\n+class DefaultSchemaPolicy:\n     def module(self, schemaName, tree):\n-        return \'plone.supermodel.generated\'\n+        return "plone.supermodel.generated"\n \n     def bases(self, schemaName, tree):\n         return ()\n@@ -63,9 +60,9 @@ def name(self, schemaName, tree):\n \n \n # Algorithm\n-def parse(source, policy=u""):\n+def parse(source, policy=""):\n     fname = None\n-    if isinstance(source, six.string_types):\n+    if isinstance(source, str):\n         fname = source\n \n     try:\n@@ -75,8 +72,7 @@ def parse(source, policy=u""):\n         # the filename and line number of the element that caused the problem.\n         # Keep the original traceback so the developer can debug where the\n         # problem happened.\n-        raise SupermodelParseError(\n-            e, fname, parseinfo.stack[-1], sys.exc_info()[2])\n+        raise SupermodelParseError(e, fname, parseinfo.stack[-1], sys.exc_info()[2])\n \n \n def _parse(source, policy):\n@@ -87,9 +83,7 @@ def _parse(source, policy):\n     tree = etree.parse(source, parser=parser)\n     root = tree.getroot()\n \n-    parseinfo.i18n_domain = root.attrib.get(\n-        ns(\'domain\', prefix=I18N_NAMESPACE)\n-    )\n+    parseinfo.i18n_domain = root.attrib.get(ns("domain", prefix=I18N_NAMESPACE))\n \n     model = Model()\n \n@@ -102,25 +96,24 @@ def _parse(source, policy):\n     def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n \n         # Parse field attributes\n-        fieldName = fieldElement.get(\'name\')\n-        fieldType = fieldElement.get(\'type\')\n+        fieldName = fieldElement.get("name")\n+        fieldType = fieldElement.get("type")\n \n         if fieldName is None or fieldType is None:\n             raise ValueError(\n-                \'The attributes \\\'name\\\' and \\\'type\\\' are required for each \'\n-                \'<field /> element\'\n+                "The attributes \'name\' and \'type\' are required for each "\n+                "<field /> element"\n             )\n \n         handler = handlers.get(fieldType)\n         if handler is None:\n             handler = handlers[fieldType] = queryUtility(\n-                IFieldExportImportHandler,\n-                name=fieldType\n+                IFieldExportImportHandler, name=fieldType\n             )\n             if handler is None:\n                 raise ValueError(\n-                    \'Field type {0} specified for field {1} is not \'\n-                    \'supported\'.format(fieldType, fieldName)\n+                    "Field type {} specified for field {} is not "\n+                    "supported".format(fieldType, fieldName)\n                 )\n \n         field = handler.read(fieldElement)\n@@ -137,17 +130,17 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n \n         return fieldName\n \n-    for schema_element in root.findall(ns(\'schema\')):\n+    for schema_element in root.findall(ns("schema")):\n         parseinfo.stack.append(schema_element)\n         schemaAttributes = {}\n \n-        schemaName = schema_element.get(\'name\')\n+        schemaName = schema_element.get("name")\n         if schemaName is None:\n-            schemaName = u""\n+            schemaName = ""\n \n         bases = ()\n         baseFields = {}\n-        based_on = schema_element.get(\'based-on\')\n+        based_on = schema_element.get("based-on")\n         if based_on is not None:\n             bases = tuple([resolve(dotted) for dotted in based_on.split()])\n             for base_schema in bases:\n@@ -156,14 +149,9 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n         fieldElements = {}\n \n         # Read global fields\n-        for fieldElement in schema_element.findall(ns(\'field\')):\n+        for fieldElement in schema_element.findall(ns("field")):\n             parseinfo.stack.append(fieldElement)\n-            readField(\n-                fieldElement,\n-                schemaAttributes,\n-                fieldElements,\n-                baseFields\n-            )\n+            readField(fieldElement, schemaAttributes, fieldElements, baseFields)\n             parseinfo.stack.pop()\n \n         # Read invariants, fieldsets and their fields\n@@ -174,32 +162,23 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n         for subelement in schema_element:\n             parseinfo.stack.append(subelement)\n \n-            if subelement.tag == ns(\'field\'):\n-                readField(\n-                    subelement,\n-                    schemaAttributes,\n-                    fieldElements,\n-                    baseFields\n-                )\n+            if subelement.tag == ns("field"):\n+                readField(subelement, schemaAttributes, fieldElements, baseFields)\n \n-            elif subelement.tag == ns(\'fieldset\'):\n+            elif subelement.tag == ns("fieldset"):\n \n-                fieldset_name = subelement.get(\'name\')\n+                fieldset_name = subelement.get("name")\n                 if fieldset_name is None:\n-                    raise ValueError(\n-                        u\'Fieldset in schema {0} has no name\'.format(\n-                            schemaName\n-                        )\n-                    )\n+                    raise ValueError(f"Fieldset in schema {schemaName} has no name")\n \n                 fieldset = fieldsets_by_name.get(fieldset_name)\n                 if fieldset is None:\n-                    fieldset_label = subelement.get(\'label\')\n-                    fieldset_description = subelement.get(\'description\')\n-                    fieldset_order = subelement.get(\'order\')\n+                    fieldset_label = subelement.get("label")\n+                    fieldset_description = subelement.get("description")\n+                    fieldset_order = subelement.get("order")\n                     if fieldset_order is None:\n                         fieldset_order = DEFAULT_ORDER\n-                    elif isinstance(fieldset_order, six.string_types):\n+                    elif isinstance(fieldset_order, str):\n                         fieldset_order = int(fieldset_order)\n                     fieldset = fieldsets_by_name[fieldset_name] = Fieldset(\n                         fieldset_name,\n@@ -210,25 +189,22 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                     fieldsets_by_name[fieldset_name] = fieldset\n                     fieldsets.append(fieldset)\n \n-                for fieldElement in subelement.findall(ns(\'field\')):\n+                for fieldElement in subelement.findall(ns("field")):\n                     parseinfo.stack.append(fieldElement)\n                     parsed_fieldName = readField(\n-                        fieldElement,\n-                        schemaAttributes,\n-                        fieldElements,\n-                        baseFields\n+                        fieldElement, schemaAttributes, fieldElements, baseFields\n                     )\n                     if parsed_fieldName:\n                         fieldset.fields.append(parsed_fieldName)\n                     parseinfo.stack.pop()\n \n-            elif subelement.tag == ns(\'invariant\'):\n+            elif subelement.tag == ns("invariant"):\n                 dotted = subelement.text\n                 invariant = resolve(dotted)\n                 if not IInvariant.providedBy(invariant):\n                     raise ImportError(\n-                        u\'Invariant functions must provide \'\n-                        u\'plone.supermodel.interfaces.IInvariant\'\n+                        "Invariant functions must provide "\n+                        "plone.supermodel.interfaces.IInvariant"\n                     )\n                 invariants.append(invariant)\n             parseinfo.stack.pop()\n@@ -237,13 +213,13 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n             name=policy_util.name(schemaName, tree),\n             bases=bases + policy_util.bases(schemaName, tree) + (Schema,),\n             __module__=policy_util.module(schemaName, tree),\n-            attrs=schemaAttributes\n+            attrs=schemaAttributes,\n         )\n \n         # add invariants to schema as tagged values\n         if invariants:\n-            schema_invariants = schema.queryTaggedValue(\'invariants\', [])\n-            schema.setTaggedValue(\'invariants\', schema_invariants + invariants)\n+            schema_invariants = schema.queryTaggedValue("invariants", [])\n+            schema.setTaggedValue("invariants", schema_invariants + invariants)\n \n         # Save fieldsets\n         schema.setTaggedValue(FIELDSETS_KEY, fieldsets)\n@@ -253,9 +229,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n             for fieldName in schema:\n                 if fieldName in fieldElements:\n                     metadata_handler.read(\n-                        fieldElements[fieldName],\n-                        schema,\n-                        schema[fieldName]\n+                        fieldElements[fieldName], schema, schema[fieldName]\n                     )\n \n         for handler_name, metadata_handler in schema_metadata_handlers:\n@@ -268,4 +242,4 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n     return model\n \n \n-__all__ = (\'parse\', )\n+__all__ = ("parse",)\ndiff --git a/plone/supermodel/patches.py b/plone/supermodel/patches.py\nindex 785f19e..3d01449 100644\n--- a/plone/supermodel/patches.py\n+++ b/plone/supermodel/patches.py\n@@ -1,15 +1,14 @@\n-# -*- coding: utf-8 -*-\n import zope.interface\n import zope.schema\n import zope.schema.interfaces\n \n \n class IDottedName(zope.interface.Interface):\n-    """A dotted name identifier.\n-    """\n+    """A dotted name identifier."""\n+\n+    min_dots = zope.schema.Int(title="Minimum number of dots", min=0, required=False)\n+    max_dots = zope.schema.Int(title="Maximum number of dots", min=0, required=False)\n \n-    min_dots = zope.schema.Int(title=u"Minimum number of dots", min=0, required=False)\n-    max_dots = zope.schema.Int(title=u"Maximum number of dots", min=0, required=False)\n \n # XXX: zope.schema omits these two interface declarations. We add them here\n # so that our parsers work.\ndiff --git a/plone/supermodel/serializer.py b/plone/supermodel/serializer.py\nindex cb91a3e..2212515 100644\n--- a/plone/supermodel/serializer.py\n+++ b/plone/supermodel/serializer.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from lxml import etree\n from plone.supermodel.interfaces import FIELDSETS_KEY\n from plone.supermodel.interfaces import I18N_NAMESPACE\n@@ -20,9 +19,8 @@\n \n @implementer(IFieldNameExtractor)\n @adapter(IField)\n-class DefaultFieldNameExtractor(object):\n-    """Extract a name\n-    """\n+class DefaultFieldNameExtractor:\n+    """Extract a name"""\n \n     def __init__(self, context):\n         self.context = context\n@@ -33,12 +31,12 @@ def __call__(self):\n         # workaround for the fact that some fields are defined in one\n         # module, but commonly used from zope.schema.*\n \n-        if field_module.startswith(\'zope.schema._bootstrapfields\'):\n+        if field_module.startswith("zope.schema._bootstrapfields"):\n             field_module = field_module.replace("._bootstrapfields", "")\n-        elif field_module.startswith(\'zope.schema._field\'):\n+        elif field_module.startswith("zope.schema._field"):\n             field_module = field_module.replace("._field", "")\n \n-        return "%s.%s" % (field_module, self.context.__class__.__name__)\n+        return f"{field_module}.{self.context.__class__.__name__}"\n \n \n # Algorithm\n@@ -50,23 +48,27 @@ def serialize(model):\n     schema_metadata_handlers = tuple(getUtilitiesFor(ISchemaMetadataHandler))\n     field_metadata_handlers = tuple(getUtilitiesFor(IFieldMetadataHandler))\n \n-    nsmap = {\'i18n\': I18N_NAMESPACE}\n+    nsmap = {"i18n": I18N_NAMESPACE}\n     for name, handler in schema_metadata_handlers + field_metadata_handlers:\n         namespace, prefix = handler.namespace, handler.prefix\n         if namespace is not None and prefix is not None:\n             nsmap[prefix] = namespace\n \n-    xml = etree.Element(\'model\', nsmap=nsmap)\n-    xml.set(\'xmlns\', XML_NAMESPACE)\n+    xml = etree.Element("model", nsmap=nsmap)\n+    xml.set("xmlns", XML_NAMESPACE)\n \n     def writeField(field, parentElement):\n         name_extractor = IFieldNameExtractor(field)\n         fieldType = name_extractor()\n         handler = handlers.get(fieldType, None)\n         if handler is None:\n-            handler = handlers[fieldType] = queryUtility(IFieldExportImportHandler, name=fieldType)\n+            handler = handlers[fieldType] = queryUtility(\n+                IFieldExportImportHandler, name=fieldType\n+            )\n             if handler is None:\n-                raise ValueError("Field type %s specified for field %s is not supported" % (fieldType, fieldName))\n+                raise ValueError(\n+                    f"Field type {fieldType} specified for field {fieldName} is not supported"\n+                )\n         fieldElement = handler.write(field, fieldName, fieldType)\n         if fieldElement is not None:\n             parentElement.append(fieldElement)\n@@ -82,20 +84,21 @@ def writeField(field, parentElement):\n         for fieldset in fieldsets:\n             fieldset_fields.update(fieldset.fields)\n \n-        non_fieldset_fields = [name for name, field in sortedFields(schema)\n-                                if name not in fieldset_fields]\n+        non_fieldset_fields = [\n+            name for name, field in sortedFields(schema) if name not in fieldset_fields\n+        ]\n \n-        schema_element = etree.Element(\'schema\')\n+        schema_element = etree.Element("schema")\n         if schemaName:\n-            schema_element.set(\'name\', schemaName)\n+            schema_element.set("name", schemaName)\n \n         bases = [b.__identifier__ for b in schema.__bases__ if b is not Schema]\n         if bases:\n-            schema_element.set(\'based-on\', \' \'.join(bases))\n+            schema_element.set("based-on", " ".join(bases))\n \n-        for invariant in schema.queryTaggedValue(\'invariants\', []):\n-            invariant_element = etree.Element(\'invariant\')\n-            invariant_element.text = "%s.%s" % (invariant.__module__, invariant.__name__)\n+        for invariant in schema.queryTaggedValue("invariants", []):\n+            invariant_element = etree.Element("invariant")\n+            invariant_element.text = f"{invariant.__module__}.{invariant.__name__}"\n             schema_element.append(invariant_element)\n \n         for fieldName in non_fieldset_fields:\n@@ -104,12 +107,12 @@ def writeField(field, parentElement):\n \n         for fieldset in fieldsets:\n \n-            fieldset_element = etree.Element(\'fieldset\')\n-            fieldset_element.set(\'name\', fieldset.__name__)\n+            fieldset_element = etree.Element("fieldset")\n+            fieldset_element.set("name", fieldset.__name__)\n             if fieldset.label:\n-                fieldset_element.set(\'label\', fieldset.label)\n+                fieldset_element.set("label", fieldset.label)\n             if fieldset.description:\n-                fieldset_element.set(\'description\', fieldset.description)\n+                fieldset_element.set("description", fieldset.description)\n \n             for fieldName in fieldset.fields:\n                 field = schema[fieldName]\n@@ -123,17 +126,17 @@ def writeField(field, parentElement):\n         xml.append(schema_element)\n \n     # handle i18n\n-    i18n_domain = xml.get(ns(\'domain\', prefix=I18N_NAMESPACE))\n-    for node in xml.xpath(\'//*[@i18n:translate]\', namespaces=nsmap):\n-        domain = node.get(ns(\'domain\', prefix=I18N_NAMESPACE), i18n_domain)\n+    i18n_domain = xml.get(ns("domain", prefix=I18N_NAMESPACE))\n+    for node in xml.xpath("//*[@i18n:translate]", namespaces=nsmap):\n+        domain = node.get(ns("domain", prefix=I18N_NAMESPACE), i18n_domain)\n         if i18n_domain is None:\n             i18n_domain = domain\n         if domain == i18n_domain:\n-            node.attrib.pop(ns(\'domain\', prefix=I18N_NAMESPACE))\n+            node.attrib.pop(ns("domain", prefix=I18N_NAMESPACE))\n     if i18n_domain:\n-        xml.set(ns(\'domain\', prefix=I18N_NAMESPACE), i18n_domain)\n+        xml.set(ns("domain", prefix=I18N_NAMESPACE), i18n_domain)\n \n     return prettyXML(xml)\n \n \n-__all__ = (\'serialize\', )\n+__all__ = ("serialize",)\ndiff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py\nindex ccd45d8..f7cd954 100644\n--- a/plone/supermodel/tests.py\n+++ b/plone/supermodel/tests.py\n@@ -1,11 +1,10 @@\n-# -*- coding: utf-8 -*-\n+from io import BytesIO\n+from io import StringIO\n from lxml import etree\n from plone.supermodel import utils\n from plone.supermodel.exportimport import ChoiceHandler\n from plone.supermodel.interfaces import IDefaultFactory\n from plone.supermodel.interfaces import IInvariant\n-from six import BytesIO\n-from six import StringIO\n from zope import schema\n from zope.interface import alsoProvides\n from zope.interface import implementer\n@@ -27,7 +26,7 @@\n \n def configure():\n     zope.component.testing.setUp()\n-    configuration = u"""\\\n+    configuration = """\\\n     <configure\n          xmlns="http://namespaces.zope.org/zope"\n          i18n_domain="plone.supermodel.tests">\n@@ -39,62 +38,62 @@ def configure():\n     </configure>\n     """\n     from zope.configuration import xmlconfig\n+\n     xmlconfig.xmlconfig(StringIO(configuration))\n \n \n class IBase(Interface):\n-    title = schema.TextLine(title=u"Title")\n-    description = schema.TextLine(title=u"Description")\n-    name = schema.TextLine(title=u"Name")\n+    title = schema.TextLine(title="Title")\n+    description = schema.TextLine(title="Description")\n+    name = schema.TextLine(title="Name")\n+\n \n # Used in fields.txt\n \n \n class IDummy(Interface):\n-    title = schema.TextLine(title=u"Title")\n+    title = schema.TextLine(title="Title")\n \n \n @implementer(IDummy)\n-class Dummy(object):\n-\n+class Dummy:\n     def __init__(self):\n-        self.title = u\'\'\n+        self.title = ""\n \n \n dummy1 = Dummy()\n \n \n @implementer(IContextSourceBinder)\n-class Binder(object):\n-\n+class Binder:\n     def __init__(self):\n         pass\n \n     def __call__(self, context):\n-        return SimpleVocabulary.fromValues([\'a\', \'d\', \'f\'])\n+        return SimpleVocabulary.fromValues(["a", "d", "f"])\n \n \n dummy_binder = Binder()\n-dummy_vocabulary_instance = SimpleVocabulary.fromItems([(1, \'a\'), (2, \'c\')])\n+dummy_vocabulary_instance = SimpleVocabulary.fromItems([(1, "a"), (2, "c")])\n \n \n @provider(IContextAwareDefaultFactory)\n def dummy_defaultCAFactory(context):\n-    return u\'b\'\n+    return "b"\n \n \n @provider(IDefaultFactory)\n def dummy_defaultFactory():\n-    return u\'b\'\n+    return "b"\n \n \n def dummy_defaultBadFactory():\n-    return u\'b\'\n+    return "b"\n \n \n @provider(IInvariant)\n def dummy_invariant(data):\n-    raise Invalid(u"Yikes! Invalid")\n+    raise Invalid("Yikes! Invalid")\n \n \n @provider(IInvariant)\n@@ -103,21 +102,19 @@ def dummy_invariant_prime(data):\n \n \n def dummy_unmarkedInvariant(data):\n-    """ lacks IInvariant marker """\n+    """lacks IInvariant marker"""\n     return None\n \n \n class TestUtils(unittest.TestCase):\n-\n     def test_syncSchema(self):\n-\n         class ISource(Interface):\n-            one = schema.TextLine(title=u"A")  # order: 0\n-            two = schema.Int(title=u"B")       # order: 1\n+            one = schema.TextLine(title="A")  # order: 0\n+            two = schema.Int(title="B")  # order: 1\n \n         class IDest(Interface):\n-            one = schema.TextLine(title=u"C")  # order: 0\n-            three = schema.Int(title=u"D")     # order: 1\n+            one = schema.TextLine(title="C")  # order: 0\n+            three = schema.Int(title="D")  # order: 1\n \n         ISource.setTaggedValue("tag1", "tag one")\n         ISource.setTaggedValue("tag2", "tag two")\n@@ -125,23 +122,22 @@ class IDest(Interface):\n \n         utils.syncSchema(ISource, IDest)\n \n-        self.assertEqual(u"C", IDest[\'one\'].title)\n+        self.assertEqual("C", IDest["one"].title)\n \n-        self.assertEqual([\'one\', \'two\'], getFieldNamesInOrder(ISource))\n-        self.assertEqual([\'two\', \'one\', \'three\'], getFieldNamesInOrder(IDest))\n+        self.assertEqual(["one", "two"], getFieldNamesInOrder(ISource))\n+        self.assertEqual(["two", "one", "three"], getFieldNamesInOrder(IDest))\n \n         self.assertEqual("first tag", IDest.getTaggedValue("tag1"))\n         self.assertEqual("tag two", IDest.getTaggedValue("tag2"))\n \n     def test_syncSchema_overwrite(self):\n-\n         class ISource(Interface):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n \n         class IDest(Interface):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         ISource.setTaggedValue("tag1", "tag one")\n         ISource.setTaggedValue("tag2", "tag two")\n@@ -149,159 +145,167 @@ class IDest(Interface):\n \n         utils.syncSchema(ISource, IDest, overwrite=True)\n \n-        self.assertEqual(u"A", IDest[\'one\'].title)\n+        self.assertEqual("A", IDest["one"].title)\n \n-        self.assertEqual([\'one\', \'two\'], getFieldNamesInOrder(ISource))\n-        self.assertEqual([\'one\', \'two\'], getFieldNamesInOrder(IDest))\n+        self.assertEqual(["one", "two"], getFieldNamesInOrder(ISource))\n+        self.assertEqual(["one", "two"], getFieldNamesInOrder(IDest))\n \n         self.assertEqual("tag one", IDest.getTaggedValue("tag1"))\n         self.assertEqual("tag two", IDest.getTaggedValue("tag2"))\n \n     def test_syncSchema_overwrite_no_bases(self):\n-\n         class IBase(Interface):\n-            base = schema.TextLine(title=u"Base")\n+            base = schema.TextLine(title="Base")\n \n         class ISource(IBase):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n \n         class IDest(Interface):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         utils.syncSchema(ISource, IDest, overwrite=False, sync_bases=False)\n \n-        self.assertEqual((Interface, ), IDest.__bases__)\n-        self.assertEqual([\'two\', \'one\', \'three\'], getFieldNamesInOrder(IDest))\n+        self.assertEqual((Interface,), IDest.__bases__)\n+        self.assertEqual(["two", "one", "three"], getFieldNamesInOrder(IDest))\n \n     def test_syncSchema_overwrite_with_bases(self):\n-\n         class IBase(Interface):\n-            base = schema.TextLine(title=u"Base")\n+            base = schema.TextLine(title="Base")\n \n         class IOtherBase(Interface):\n-            foo = schema.TextLine(title=u"Foo")\n+            foo = schema.TextLine(title="Foo")\n \n         class ISource(IBase):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n \n         class IDest(IOtherBase):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         utils.syncSchema(ISource, IDest, overwrite=True, sync_bases=True)\n \n-        self.assertEqual((IBase, ), IDest.__bases__)\n-        self.assertEqual([\'base\', \'one\', \'two\'], getFieldNamesInOrder(IDest))\n+        self.assertEqual((IBase,), IDest.__bases__)\n+        self.assertEqual(["base", "one", "two"], getFieldNamesInOrder(IDest))\n \n     def test_syncSchema_overwrite_with_bases_and_no_overwrite(self):\n-\n         class IBase(Interface):\n-            base = schema.TextLine(title=u"Base")\n+            base = schema.TextLine(title="Base")\n \n         class IOtherBase(Interface):\n-            foo = schema.TextLine(title=u"Foo")\n+            foo = schema.TextLine(title="Foo")\n \n         class ISource(IBase):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n \n         class IDest(IOtherBase):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         utils.syncSchema(ISource, IDest, overwrite=False, sync_bases=True)\n \n-        self.assertEqual((IBase, IOtherBase, ), IDest.__bases__)\n-        self.assertEqual([\'base\', \'foo\', \'two\', \'one\', \'three\'], getFieldNamesInOrder(IDest))\n+        self.assertEqual(\n+            (\n+                IBase,\n+                IOtherBase,\n+            ),\n+            IDest.__bases__,\n+        )\n+        self.assertEqual(\n+            ["base", "foo", "two", "one", "three"], getFieldNamesInOrder(IDest)\n+        )\n \n     def test_syncSchema_overwrite_with_bases_and_no_overwrite_with_old_bases(self):\n-\n         class IBase(Interface):\n-            base = schema.TextLine(title=u"Base")\n+            base = schema.TextLine(title="Base")\n \n         class IOtherBase(Interface):\n-            foo = schema.TextLine(title=u"Foo")\n+            foo = schema.TextLine(title="Foo")\n \n         class ISource(IBase):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n \n         class IDest(IOtherBase, IBase):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         utils.syncSchema(ISource, IDest, overwrite=False, sync_bases=True)\n \n-        self.assertEqual((IBase, IOtherBase, ), IDest.__bases__)\n-        self.assertEqual([\'base\', \'foo\', \'two\', \'one\', \'three\'], getFieldNamesInOrder(IDest))\n+        self.assertEqual(\n+            (\n+                IBase,\n+                IOtherBase,\n+            ),\n+            IDest.__bases__,\n+        )\n+        self.assertEqual(\n+            ["base", "foo", "two", "one", "three"], getFieldNamesInOrder(IDest)\n+        )\n \n     def test_syncSchema_with_markers_no_overwrite(self):\n-\n         class IMarker(Interface):\n             pass\n \n         class ISource(Interface):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n-            four = schema.Text(title=u"C")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n+            four = schema.Text(title="C")\n \n-        alsoProvides(ISource[\'one\'], IMarker)\n-        alsoProvides(ISource[\'four\'], IMarker)\n+        alsoProvides(ISource["one"], IMarker)\n+        alsoProvides(ISource["four"], IMarker)\n \n         class IDest(Interface):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         utils.syncSchema(ISource, IDest)\n \n-        self.assertFalse(IMarker.providedBy(IDest[\'one\']))\n-        self.assertFalse(IMarker.providedBy(IDest[\'two\']))\n-        self.assertFalse(IMarker.providedBy(IDest[\'three\']))\n-        self.assertTrue(IMarker.providedBy(IDest[\'four\']))\n+        self.assertFalse(IMarker.providedBy(IDest["one"]))\n+        self.assertFalse(IMarker.providedBy(IDest["two"]))\n+        self.assertFalse(IMarker.providedBy(IDest["three"]))\n+        self.assertTrue(IMarker.providedBy(IDest["four"]))\n \n     def test_syncSchema_with_markers_overwrite(self):\n-\n         class IMarker(Interface):\n             pass\n \n         class ISource(Interface):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n-            four = schema.Text(title=u"C")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n+            four = schema.Text(title="C")\n \n-        alsoProvides(ISource[\'one\'], IMarker)\n-        alsoProvides(ISource[\'four\'], IMarker)\n+        alsoProvides(ISource["one"], IMarker)\n+        alsoProvides(ISource["four"], IMarker)\n \n         class IDest(Interface):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         utils.syncSchema(ISource, IDest, overwrite=True)\n \n-        self.assertTrue(IMarker.providedBy(IDest[\'one\']))\n-        self.assertFalse(IMarker.providedBy(IDest[\'two\']))\n-        self.assertTrue(IMarker.providedBy(IDest[\'four\']))\n+        self.assertTrue(IMarker.providedBy(IDest["one"]))\n+        self.assertFalse(IMarker.providedBy(IDest["two"]))\n+        self.assertTrue(IMarker.providedBy(IDest["four"]))\n \n     def test_syncSchema_always_overwrites_fields_from_bases(self):\n-\n         class IBase(Interface):\n-            one = schema.TextLine(title=u\'A\')\n+            one = schema.TextLine(title="A")\n \n         class ISource(Interface):\n-            one = schema.TextLine(title=u\'B\')\n+            one = schema.TextLine(title="B")\n \n         class IDest(IBase):\n             pass\n \n         utils.syncSchema(ISource, IDest, overwrite=False)\n \n-        self.assertTrue(IDest[\'one\'].interface is IDest)\n+        self.assertTrue(IDest["one"].interface is IDest)\n \n     def test_mergedTaggedValueList(self):\n-\n         class IBase1(Interface):\n             pass\n \n@@ -314,14 +318,15 @@ class IBase3(Interface):\n         class ISchema(IBase1, IBase2, IBase3):\n             pass\n \n-        IBase1.setTaggedValue(u"foo", [1, 2])  # more specific than IBase2 and IBase3\n-        IBase3.setTaggedValue(u"foo", [3, 4])  # least specific of the bases\n-        ISchema.setTaggedValue(u"foo", [4, 5])  # most specific\n+        IBase1.setTaggedValue("foo", [1, 2])  # more specific than IBase2 and IBase3\n+        IBase3.setTaggedValue("foo", [3, 4])  # least specific of the bases\n+        ISchema.setTaggedValue("foo", [4, 5])  # most specific\n \n-        self.assertEqual([3, 4, 1, 2, 4, 5], utils.mergedTaggedValueList(ISchema, u"foo"))\n+        self.assertEqual(\n+            [3, 4, 1, 2, 4, 5], utils.mergedTaggedValueList(ISchema, "foo")\n+        )\n \n     def test_mergedTaggedValueDict(self):\n-\n         class IBase1(Interface):\n             pass\n \n@@ -334,22 +339,25 @@ class IBase3(Interface):\n         class ISchema(IBase1, IBase2, IBase3):\n             pass\n \n-        IBase1.setTaggedValue(u"foo", {1: 1, 2: 1})      # more specific than IBase2 and IBase3\n-        IBase3.setTaggedValue(u"foo", {3: 3, 2: 3, 4: 3})  # least specific of the bases\n-        ISchema.setTaggedValue(u"foo", {4: 4, 5: 4})      # most specific\n+        IBase1.setTaggedValue(\n+            "foo", {1: 1, 2: 1}\n+        )  # more specific than IBase2 and IBase3\n+        IBase3.setTaggedValue("foo", {3: 3, 2: 3, 4: 3})  # least specific of the bases\n+        ISchema.setTaggedValue("foo", {4: 4, 5: 4})  # most specific\n \n-        self.assertEqual({1: 1, 2: 1, 3: 3, 4: 4, 5: 4}, utils.mergedTaggedValueDict(ISchema, u"foo"))\n+        self.assertEqual(\n+            {1: 1, 2: 1, 3: 3, 4: 4, 5: 4}, utils.mergedTaggedValueDict(ISchema, "foo")\n+        )\n \n \n class TestValueToElement(unittest.TestCase):\n-\n     def setUp(self):\n         configure()\n \n     tearDown = zope.component.testing.tearDown\n \n     def _assertSerialized(self, field, value, expected):\n-        element = utils.valueToElement(field, value, b\'value\')\n+        element = utils.valueToElement(field, value, b"value")\n         sio = StringIO() if six.PY2 else BytesIO()\n         etree.ElementTree(element).write(sio)\n         self.assertEqual(sio.getvalue(), expected)\n@@ -359,177 +367,195 @@ def _assertSerialized(self, field, value, expected):\n     def test_lists(self):\n         field = schema.List(value_type=schema.Int())\n         value = []\n-        self._assertSerialized(field, value, b\'<value/>\')\n+        self._assertSerialized(field, value, b"<value/>")\n         value = [1, 2]\n         self._assertSerialized(\n-            field, value,\n-            b\'<value>\'\n-            b\'<element>1</element>\'\n-            b\'<element>2</element>\'\n-            b\'</value>\'\n+            field,\n+            value,\n+            b"<value>" b"<element>1</element>" b"<element>2</element>" b"</value>",\n         )\n \n     def test_sets(self):\n-        field = schema.Set(value_type=schema.Int(),\n+        field = schema.Set(\n+            value_type=schema.Int(),\n         )\n-        value = set([])\n-        self._assertSerialized(field, value, b\'<value/>\')\n-        value = set([3, 4, 2, 1])\n+        value = set()\n+        self._assertSerialized(field, value, b"<value/>")\n+        value = {3, 4, 2, 1}\n         # Sets should be sorted to ensure nice diffs\n         self._assertSerialized(\n-            field, value,\n-            b\'<value>\'\n-            b\'<element>1</element>\'\n-            b\'<element>2</element>\'\n-            b\'<element>3</element>\'\n-            b\'<element>4</element>\'\n-            b\'</value>\'\n+            field,\n+            value,\n+            b"<value>"\n+            b"<element>1</element>"\n+            b"<element>2</element>"\n+            b"<element>3</element>"\n+            b"<element>4</element>"\n+            b"</value>",\n         )\n \n-        field = schema.Set(value_type=schema.Choice([\'a\',\'b\',\'c\']),)\n-        value = set([\'b\', \'a\'])\n+        field = schema.Set(\n+            value_type=schema.Choice(["a", "b", "c"]),\n+        )\n+        value = {"b", "a"}\n         # Sets should be sorted to ensure nice diffs\n         self._assertSerialized(\n-            field, value,\n-            b\'<value>\'\n-            b\'<element>a</element>\'\n-            b\'<element>b</element>\'\n-            b\'</value>\'\n+            field,\n+            value,\n+            b"<value>" b"<element>a</element>" b"<element>b</element>" b"</value>",\n         )\n \n     def test_nested_lists(self):\n         field = schema.List(value_type=schema.List(value_type=schema.Int()))\n         value = []\n-        self._assertSerialized(field, value, b\'<value/>\')\n+        self._assertSerialized(field, value, b"<value/>")\n         value = [[1], [1, 2], []]\n-        self._assertSerialized(field, value,\n-            b\'<value>\'\n-            b\'<element><element>1</element></element>\'\n-            b\'<element><element>1</element><element>2</element></element>\'\n-            b\'<element/>\'\n-            b\'</value>\'\n+        self._assertSerialized(\n+            field,\n+            value,\n+            b"<value>"\n+            b"<element><element>1</element></element>"\n+            b"<element><element>1</element><element>2</element></element>"\n+            b"<element/>"\n+            b"</value>",\n         )\n \n     def test_dicts(self):\n         field = schema.Dict(key_type=schema.Int(), value_type=schema.TextLine())\n         value = {}\n-        self._assertSerialized(field, value, b\'<value/>\')\n-        value = {1: \'one\', 2: \'two\'}\n-        self._assertSerialized(field, value,\n-            b\'<value>\'\n+        self._assertSerialized(field, value, b"<value/>")\n+        value = {1: "one", 2: "two"}\n+        self._assertSerialized(\n+            field,\n+            value,\n+            b"<value>"\n             b\'<element key="1">one</element>\'\n             b\'<element key="2">two</element>\'\n-            b\'</value>\'\n+            b"</value>",\n         )\n \n     def test_nested_dicts(self):\n-        field = schema.Dict(key_type=schema.Int(),\n+        field = schema.Dict(\n+            key_type=schema.Int(),\n             value_type=schema.Dict(\n                 key_type=schema.Int(),\n                 value_type=schema.TextLine(),\n             ),\n         )\n         value = {}\n-        self._assertSerialized(field, value, b\'<value/>\')\n-        value = {1: {2: \'two\'}, 3: {4: \'four\', 5: \'five\'}, 6: {}}\n-        self._assertSerialized(field, value,\n-            b\'<value>\'\n+        self._assertSerialized(field, value, b"<value/>")\n+        value = {1: {2: "two"}, 3: {4: "four", 5: "five"}, 6: {}}\n+        self._assertSerialized(\n+            field,\n+            value,\n+            b"<value>"\n             b\'<element key="1"><element key="2">two</element></element>\'\n             b\'<element key="3"><element key="4">four</element><element key="5">five</element></element>\'\n             b\'<element key="6"/>\'\n-            b\'</value>\'\n+            b"</value>",\n         )\n \n \n-\n-\n-\n class TestChoiceHandling(unittest.TestCase):\n-\n     def setUp(self):\n         configure()\n         self.handler = ChoiceHandler(schema.Choice)\n \n     def _choice(self):\n-        vocab = SimpleVocabulary(\n-            [SimpleTerm(t, title=t) for t in (u\'a\', u\'b\', u\'c\')]\n-            )\n-        expected = \'<field name="myfield" type="zope.schema.Choice">\'\\\n-            \'<values>\'\\\n-            \'<element>a</element><element>b</element><element>c</element>\'\\\n-            \'</values>\'\\\n-            \'</field>\'\n+        vocab = SimpleVocabulary([SimpleTerm(t, title=t) for t in ("a", "b", "c")])\n+        expected = (\n+            \'<field name="myfield" type="zope.schema.Choice">\'\n+            "<values>"\n+            "<element>a</element><element>b</element><element>c</element>"\n+            "</values>"\n+            "</field>"\n+        )\n         return (schema.Choice(vocabulary=vocab), expected)\n \n     def _choice_with_empty(self):\n         # add an empty string term to vocabulary\n-        vocab = SimpleVocabulary([SimpleTerm(t, title=t) for t in (u\'a\', u\'\')])\n-        expected = \'<field name="myfield" type="zope.schema.Choice">\'\\\n-            \'<values>\'\\\n-            \'<element>a</element>\'\\\n-            \'<element></element>\'\\\n-            \'</values>\'\\\n-            \'</field>\'\n+        vocab = SimpleVocabulary([SimpleTerm(t, title=t) for t in ("a", "")])\n+        expected = (\n+            \'<field name="myfield" type="zope.schema.Choice">\'\n+            "<values>"\n+            "<element>a</element>"\n+            "<element></element>"\n+            "</values>"\n+            "</field>"\n+        )\n         return (schema.Choice(vocabulary=vocab), expected)\n \n     def _choice_with_term_titles(self):\n         # two terms with distinct titles, one with same as value:\n         vocab = SimpleVocabulary(\n-            [SimpleTerm(t, title=t.upper()) for t in (u\'a\', u\'b\')] +\n-            [SimpleTerm(u\'c\', title=u\'c\')],\n-            )\n-        expected = \'<field name="myfield" type="zope.schema.Choice">\'\\\n-            \'<values>\'\\\n-            \'<element key="a">A</element>\'\\\n-            \'<element key="b">B</element>\'\\\n-            \'<element key="c">c</element>\'\\\n-            \'</values>\'\\\n-            \'</field>\'\n+            [SimpleTerm(t, title=t.upper()) for t in ("a", "b")]\n+            + [SimpleTerm("c", title="c")],\n+        )\n+        expected = (\n+            \'<field name="myfield" type="zope.schema.Choice">\'\n+            "<values>"\n+            \'<element key="a">A</element>\'\n+            \'<element key="b">B</element>\'\n+            \'<element key="c">c</element>\'\n+            "</values>"\n+            "</field>"\n+        )\n         return (schema.Choice(vocabulary=vocab), expected)\n \n     def _choice_with_term_titles_and_ns(self):\n         # two terms with distinct titles, one with same as value:\n         vocab = SimpleVocabulary(\n-            [SimpleTerm(t, title=t.upper()) for t in (u\'a\', u\'b\')] +\n-            [SimpleTerm(u\'c\', title=u\'c\')],\n-            )\n-        expected = \'<field name="myfield" type="zope.schema.Choice"\'\\\n-            \'      xmlns="http://namespaces.plone.org/supermodel/schema">\'\\\n-            \'<values>\'\\\n-            \'<element key="a">A</element>\'\\\n-            \'<element key="b">B</element>\'\\\n-            \'<element key="c">c</element>\'\\\n-            \'</values>\'\\\n-            \'</field>\'\n+            [SimpleTerm(t, title=t.upper()) for t in ("a", "b")]\n+            + [SimpleTerm("c", title="c")],\n+        )\n+        expected = (\n+            \'<field name="myfield" type="zope.schema.Choice"\'\n+            \'      xmlns="http://namespaces.plone.org/supermodel/schema">\'\n+            "<values>"\n+            \'<element key="a">A</element>\'\n+            \'<element key="b">B</element>\'\n+            \'<element key="c">c</element>\'\n+            "</values>"\n+            "</field>"\n+        )\n         return (schema.Choice(vocabulary=vocab), expected)\n \n     def _choice_with_integers(self):\n-        vocab = SimpleVocabulary([SimpleTerm(1, title=u\'One\')])\n-        expected = \'<field name="myfield" type="zope.schema.Choice">\'\\\n-            \'<values>\'\\\n-            \'<element key="1">One</element>\'\\\n-            \'</values>\'\\\n-            \'</field>\'\n+        vocab = SimpleVocabulary([SimpleTerm(1, title="One")])\n+        expected = (\n+            \'<field name="myfield" type="zope.schema.Choice">\'\n+            "<values>"\n+            \'<element key="1">One</element>\'\n+            "</values>"\n+            "</field>"\n+        )\n         return (schema.Choice(vocabulary=vocab), expected)\n \n     def test_choice_serialized(self):\n-        """ Tests a regular choice, one with empty string term in vocab,\n+        """Tests a regular choice, one with empty string term in vocab,\n         and another with terms that have titles\n         """\n         choice = self._choice()\n         choice_with_empty = self._choice_with_empty()\n         choice_with_term_titles = self._choice_with_term_titles()\n         choice_with_integers = self._choice_with_integers()\n-        for case in (choice, choice_with_empty, choice_with_term_titles, choice_with_integers):\n+        for case in (\n+            choice,\n+            choice_with_empty,\n+            choice_with_term_titles,\n+            choice_with_integers,\n+        ):\n             field, expected = case\n-            expected = six.binary_type(expected) if six.PY2 \\\n-                else six.binary_type(expected, encoding=\'latin-1\')\n-            el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-            self.assertEquals(etree.tostring(el), expected)\n+            expected = (\n+                bytes(expected) if six.PY2 else bytes(expected, encoding="latin-1")\n+            )\n+            el = self.handler.write(field, "myfield", "zope.schema.Choice")\n+            self.assertEqual(etree.tostring(el), expected)\n \n     def test_choice_parsing(self):\n         def _termvalues(vocab):\n             return tuple((t.value, t.title) for t in vocab)\n+\n         cases = (\n             self._choice(),\n             self._choice_with_empty(),\n@@ -547,62 +573,67 @@ def _termvalues(vocab):\n \n class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n-        if six.PY2:\n-            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n-        else:\n-            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n-            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n-            got = re.sub(\n-                \'plone.supermodel.parser.SupermodelParseError\',\n-                \'SupermodelParseError\', got)\n-            got = re.sub(\n-                \'zope.interface.exceptions.Invalid\',\n-                \'Invalid\', got)\n-            got = re.sub(\n-                "(Import|ModuleNotFound)Error: No module named "\n-                "\'plone.supermodel.tests.nonExistentFactory\'; "\n-                "\'plone.supermodel.tests\' is not a package",\n-                \'ImportError: No module named nonExistentFactory\', got)\n+        want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+        want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+        got = re.sub(\n+            "plone.supermodel.parser.SupermodelParseError", "SupermodelParseError", got\n+        )\n+        got = re.sub("zope.interface.exceptions.Invalid", "Invalid", got)\n+        got = re.sub(\n+            "(Import|ModuleNotFound)Error: No module named "\n+            "\'plone.supermodel.tests.nonExistentFactory\'; "\n+            "\'plone.supermodel.tests\' is not a package",\n+            "ImportError: No module named nonExistentFactory",\n+            got,\n+        )\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \n-optionflags = doctest.ELLIPSIS | \\\n-    doctest.REPORT_UDIFF | \\\n-    doctest.NORMALIZE_WHITESPACE | \\\n-    doctest.REPORT_ONLY_FIRST_FAILURE\n+optionflags = (\n+    doctest.ELLIPSIS\n+    | doctest.REPORT_UDIFF\n+    | doctest.NORMALIZE_WHITESPACE\n+    | doctest.REPORT_ONLY_FIRST_FAILURE\n+)\n \n \n def test_suite():\n-    return unittest.TestSuite((\n-        unittest.makeSuite(TestUtils),\n-        unittest.makeSuite(TestValueToElement),\n-        unittest.makeSuite(TestChoiceHandling),\n-        doctest.DocFileSuite(\n-            \'fields.rst\',\n-            setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown,\n-            optionflags=optionflags,\n-            checker=Py23DocChecker()),\n-        doctest.DocFileSuite(\n-            \'directives.rst\',\n-            setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown,\n-            optionflags=optionflags,\n-            checker=Py23DocChecker()),\n-        doctest.DocFileSuite(\n-            \'schema.rst\',\n-            setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown,\n-            optionflags=optionflags,\n-            checker=Py23DocChecker()),\n-        doctest.DocFileSuite(\n-            \'schemaclass.rst\',\n-            setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown,\n-            optionflags=optionflags,\n-            checker=Py23DocChecker()),\n-    ))\n-\n-\n-if __name__ == \'__main__\':\n-    unittest.main(default=\'test_suite\')\n+    return unittest.TestSuite(\n+        (\n+            unittest.defaultTestLoader.loadTestsFromTestCase(TestUtils),\n+            unittest.defaultTestLoader.loadTestsFromTestCase(TestValueToElement),\n+            unittest.defaultTestLoader.loadTestsFromTestCase(TestChoiceHandling),\n+            doctest.DocFileSuite(\n+                "fields.rst",\n+                setUp=zope.component.testing.setUp,\n+                tearDown=zope.component.testing.tearDown,\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n+            ),\n+            doctest.DocFileSuite(\n+                "directives.rst",\n+                setUp=zope.component.testing.setUp,\n+                tearDown=zope.component.testing.tearDown,\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n+            ),\n+            doctest.DocFileSuite(\n+                "schema.rst",\n+                setUp=zope.component.testing.setUp,\n+                tearDown=zope.component.testing.tearDown,\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n+            ),\n+            doctest.DocFileSuite(\n+                "schemaclass.rst",\n+                setUp=zope.component.testing.setUp,\n+                tearDown=zope.component.testing.tearDown,\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n+            ),\n+        )\n+    )\n+\n+\n+if __name__ == "__main__":\n+    unittest.main(default="test_suite")\ndiff --git a/plone/supermodel/utils.py b/plone/supermodel/utils.py\nindex c3b35a4..fa6b157 100644\n--- a/plone/supermodel/utils.py\n+++ b/plone/supermodel/utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from collections import OrderedDict\n from lxml import etree\n from plone.supermodel.debug import parseinfo\n@@ -24,34 +23,32 @@\n \n \n _marker = object()\n-noNS_re = re.compile(r\'^{\\S+}\')\n+noNS_re = re.compile(r"^{\\S+}")\n \n \n def ns(name, prefix=XML_NAMESPACE):\n-    """Return the element or attribute name with the given prefix\n-    """\n+    """Return the element or attribute name with the given prefix"""\n \n-    return u\'{%s}%s\' % (prefix, name)\n+    return f"{{{prefix}}}{name}"\n \n \n def noNS(name):\n-    """Return the tag with no namespace\n-    """\n-    return noNS_re.sub(\'\', name)\n+    """Return the tag with no namespace"""\n+    return noNS_re.sub("", name)\n \n \n def indent(node, level=0):\n \n     INDENT_SIZE = 2\n-    node_indent = level * (\' \' * INDENT_SIZE)\n-    child_indent = (level + 1) * (\' \' * INDENT_SIZE)\n+    node_indent = level * (" " * INDENT_SIZE)\n+    child_indent = (level + 1) * (" " * INDENT_SIZE)\n \n     # node has childen\n     if len(node):\n \n         # add indent before first child node\n         if not node.text or not node.text.strip():\n-            node.text = \'\\n\' + child_indent\n+            node.text = "\\n" + child_indent\n \n         # let each child indent itself\n         last_idx = len(node) - 1\n@@ -61,11 +58,11 @@ def indent(node, level=0):\n             # add a tail for the next child node...\n             if idx != last_idx:\n                 if not child.tail or not child.tail.strip():\n-                    child.tail = \'\\n\' + child_indent\n+                    child.tail = "\\n" + child_indent\n             # ... or for the closing element of this node\n             else:\n                 if not child.tail or not child.tail.strip():\n-                    child.tail = \'\\n\' + node_indent\n+                    child.tail = "\\n" + node_indent\n \n \n def prettyXML(tree):\n@@ -77,10 +74,10 @@ def prettyXML(tree):\n \n \n def fieldTypecast(field, value):\n-    typecast = getattr(field, \'_type\', None)\n+    typecast = getattr(field, "_type", None)\n     if typecast is not None:\n         if not isinstance(typecast, (list, tuple)):\n-            typecast = (typecast, )\n+            typecast = (typecast,)\n         for tc in reversed(typecast):\n             if callable(tc):\n                 try:\n@@ -104,15 +101,15 @@ def elementToValue(field, element, default=_marker):\n         key_converter = IFromUnicode(field.key_type)\n         value = OrderedDict()\n         for child in element.iterchildren(tag=etree.Element):\n-            if noNS(child.tag.lower()) != \'element\':\n+            if noNS(child.tag.lower()) != "element":\n                 continue\n             parseinfo.stack.append(child)\n \n-            key_text = child.attrib.get(\'key\')\n+            key_text = child.attrib.get("key")\n             if key_text is None:\n                 k = None\n             else:\n-                k = key_converter.fromUnicode(six.text_type(key_text))\n+                k = key_converter.fromUnicode(str(key_text))\n \n             value[k] = elementToValue(field.value_type, child)\n             parseinfo.stack.pop()\n@@ -121,7 +118,7 @@ def elementToValue(field, element, default=_marker):\n     elif ICollection.providedBy(field):\n         value = []\n         for child in element.iterchildren(tag=etree.Element):\n-            if noNS(child.tag.lower()) != \'element\':\n+            if noNS(child.tag.lower()) != "element":\n                 continue\n             parseinfo.stack.append(child)\n             v = elementToValue(field.value_type, child)\n@@ -137,7 +134,7 @@ def elementToValue(field, element, default=_marker):\n         except:\n             pass\n \n-        if vocabulary and hasattr(vocabulary, \'by_value\'):\n+        if vocabulary and hasattr(vocabulary, "by_value"):\n             try:\n                 field._type = type(list(vocabulary.by_value.keys())[0])\n             except:\n@@ -152,17 +149,16 @@ def elementToValue(field, element, default=_marker):\n             value = field.missing_value\n         else:\n             converter = IFromUnicode(field)\n-            if isinstance(text, six.binary_type):\n+            if isinstance(text, bytes):\n                 text = text.decode()\n             else:\n-                text = six.text_type(text)\n+                text = str(text)\n             value = converter.fromUnicode(text)\n \n         # handle i18n\n-        if isinstance(value, six.string_types) and \\\n-                parseinfo.i18n_domain is not None:\n-            translate_attr = ns(\'translate\', I18N_NAMESPACE)\n-            domain_attr = ns(\'domain\', I18N_NAMESPACE)\n+        if isinstance(value, str) and parseinfo.i18n_domain is not None:\n+            translate_attr = ns("translate", I18N_NAMESPACE)\n+            domain_attr = ns("domain", I18N_NAMESPACE)\n             msgid = element.attrib.get(translate_attr)\n             domain = element.attrib.get(domain_attr, parseinfo.i18n_domain)\n             if msgid:\n@@ -194,9 +190,8 @@ def valueToElement(field, value, name=None, force=False):\n         if IDict.providedBy(field):\n             key_converter = IToUnicode(field.key_type)\n             for k, v in sorted(value.items()):\n-                list_element = valueToElement(\n-                    field.value_type, v, \'element\', force)\n-                list_element.attrib[\'key\'] = key_converter.toUnicode(k)\n+                list_element = valueToElement(field.value_type, v, "element", force)\n+                list_element.attrib["key"] = key_converter.toUnicode(k)\n                 child.append(list_element)\n \n         elif ICollection.providedBy(field):\n@@ -204,8 +199,7 @@ def valueToElement(field, value, name=None, force=False):\n                 # Serliazation should be consistent even if value was not really a set\n                 value = sorted(value)\n             for v in value:\n-                list_element = valueToElement(\n-                    field.value_type, v, \'element\', force)\n+                list_element = valueToElement(field.value_type, v, "element", force)\n                 child.append(list_element)\n \n         else:\n@@ -214,11 +208,11 @@ def valueToElement(field, value, name=None, force=False):\n \n             # handle i18n\n             if isinstance(value, Message):\n-                child.set(ns(\'domain\', I18N_NAMESPACE), value.domain)\n+                child.set(ns("domain", I18N_NAMESPACE), value.domain)\n                 if not value.default:\n-                    child.set(ns(\'translate\', I18N_NAMESPACE), \'\')\n+                    child.set(ns("translate", I18N_NAMESPACE), "")\n                 else:\n-                    child.set(ns(\'translate\', I18N_NAMESPACE), child.text)\n+                    child.set(ns("translate", I18N_NAMESPACE), child.text)\n                     child.text = converter.toUnicode(value.default)\n \n     return child\n@@ -232,12 +226,12 @@ def relativeToCallingPackage(filename, callingFrame=2):\n     if os.path.isabs(filename):\n         return filename\n     else:\n-        name = sys._getframe(callingFrame).f_globals[\'__name__\']\n+        name = sys._getframe(callingFrame).f_globals["__name__"]\n         module = sys.modules[name]\n-        if hasattr(module, \'__path__\'):\n+        if hasattr(module, "__path__"):\n             directory = module.__path__[0]\n         elif "." in name:\n-            parent_module = name[:name.rfind(\'.\')]\n+            parent_module = name[: name.rfind(".")]\n             directory = sys.modules[parent_module].__path__[0]\n         else:\n             directory = name\n@@ -246,13 +240,17 @@ def relativeToCallingPackage(filename, callingFrame=2):\n \n \n def sortedFields(schema):\n-    """Like getFieldsInOrder, but does not include fields from bases\n-    """\n+    """Like getFieldsInOrder, but does not include fields from bases"""\n     fields = []\n     for name in schema.names(all=False):\n         field = schema[name]\n         if IField.providedBy(field):\n-            fields.append((name, field, ))\n+            fields.append(\n+                (\n+                    name,\n+                    field,\n+                )\n+            )\n     fields.sort(key=lambda item: item[1].order)\n     return fields\n \n@@ -298,7 +296,7 @@ def syncSchema(source, dest, overwrite=False, sync_bases=False):\n         for name in to_delete:\n             # delattr(dest, name)\n             del dest._InterfaceClass__attrs[name]\n-            if hasattr(dest, \'_v_attrs\') and dest._v_attrs is not None:\n+            if hasattr(dest, "_v_attrs") and dest._v_attrs is not None:\n                 del dest._v_attrs[name]\n \n     # Add fields that are in source, but not in dest\n@@ -316,7 +314,7 @@ def syncSchema(source, dest, overwrite=False, sync_bases=False):\n \n             # setattr(dest, name, clone)\n             dest._InterfaceClass__attrs[name] = clone\n-            if hasattr(dest, \'_v_attrs\'):\n+            if hasattr(dest, "_v_attrs"):\n                 if dest._v_attrs is None:\n                     dest._v_attrs = {}\n                 dest._v_attrs[name] = clone\ndiff --git a/setup.py b/setup.py\nindex 9cada3b..715a213 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,21 +1,19 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n+\n import os\n \n \n def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n-version = \'2.0.1.dev0\'\n \n-long_description = (\n-    read(\'README.rst\') + \'\\n\' +\n-    read(\'CHANGES.rst\') + \'\\n\'\n-    )\n+version = "2.0.1.dev0"\n+\n+long_description = read("README.rst") + "\\n" + read("CHANGES.rst") + "\\n"\n \n setup(\n-    name=\'plone.supermodel\',\n+    name="plone.supermodel",\n     version=version,\n     description="Serialize Zope schema definitions to and from XML",\n     long_description=long_description,\n@@ -34,35 +32,35 @@ def read(*rnames):\n         "Topic :: Software Development :: Libraries :: Python Modules",\n         "License :: OSI Approved :: BSD License",\n     ],\n-    keywords=\'Plone XML schema\',\n-    author=\'Martin Aspeli\',\n-    author_email=\'optilude@gmail.com\',\n-    url=\'https://github.com/plone/plone.supermodel\',\n-    license=\'BSD\',\n+    keywords="Plone XML schema",\n+    author="Martin Aspeli",\n+    author_email="optilude@gmail.com",\n+    url="https://github.com/plone/plone.supermodel",\n+    license="BSD",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'lxml\',\n-        \'zope.component\',\n-        \'zope.i18nmessageid\',\n-        \'zope.interface\',\n-        \'zope.schema>=4.1.0\',\n-        \'zope.deferredimport\',\n-        \'zope.dottedname\',\n-        \'z3c.zcmlhook\',\n+        "setuptools",\n+        "six",\n+        "lxml",\n+        "zope.component",\n+        "zope.i18nmessageid",\n+        "zope.interface",\n+        "zope.schema>=4.1.0",\n+        "zope.deferredimport",\n+        "zope.dottedname",\n+        "z3c.zcmlhook",\n     ],\n     extras_require={\n-        \'lxml\': [],  # BBB\n-        \'plone.rfc822\': [\'plone.rfc822\'],\n-        \'test\': [\n-            \'plone.rfc822\',\n-            ],\n+        "lxml": [],  # BBB\n+        "plone.rfc822": ["plone.rfc822"],\n+        "test": [\n+            "plone.rfc822",\n+        ],\n     },\n     entry_points="""\n     # -*- Entry points: -*-\n     """,\n-    )\n+)\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2023-01-08T01:20:13+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.supermodel/commit/fe692a55272deef7e6d6a1470b671965fb1a6137

chore: flake8 fixes

Files changed:
M plone/supermodel/__init__.py
M plone/supermodel/converters.py
M plone/supermodel/parser.py
M plone/supermodel/utils.py

b'diff --git a/plone/supermodel/__init__.py b/plone/supermodel/__init__.py\nindex 2845b60..3b0b9c8 100644\n--- a/plone/supermodel/__init__.py\n+++ b/plone/supermodel/__init__.py\n@@ -7,8 +7,6 @@\n from plone.supermodel.interfaces import IXMLToSchema\n from zope.interface import moduleProvides\n \n-import six\n-\n \n # Cache models by absolute filename\n _model_cache = {}\ndiff --git a/plone/supermodel/converters.py b/plone/supermodel/converters.py\nindex 8763dd2..4bdde60 100644\n--- a/plone/supermodel/converters.py\n+++ b/plone/supermodel/converters.py\n@@ -12,7 +12,6 @@\n from zope.schema.interfaces import IObject\n \n import datetime\n-import six\n import time\n \n \ndiff --git a/plone/supermodel/parser.py b/plone/supermodel/parser.py\nindex 9e84dd8..73feda4 100644\n--- a/plone/supermodel/parser.py\n+++ b/plone/supermodel/parser.py\n@@ -21,7 +21,6 @@\n from zope.schema import getFields\n \n import linecache\n-import six\n import sys\n import traceback\n \ndiff --git a/plone/supermodel/utils.py b/plone/supermodel/utils.py\nindex fa6b157..39016f4 100644\n--- a/plone/supermodel/utils.py\n+++ b/plone/supermodel/utils.py\n@@ -15,6 +15,7 @@\n from zope.schema.interfaces import IField\n from zope.schema.interfaces import IFromUnicode\n from zope.schema.interfaces import ISet\n+from zope.schema.interfaces import IVocabularyFactory\n \n import os.path\n import re\n@@ -83,7 +84,7 @@ def fieldTypecast(field, value):\n                 try:\n                     value = tc(value)\n                     break\n-                except:\n+                except Exception:\n                     pass\n     return value\n \n@@ -131,13 +132,13 @@ def elementToValue(field, element, default=_marker):\n         try:\n             vcf = getUtility(IVocabularyFactory, field.vocabularyName)\n             vocabulary = vcf(None)\n-        except:\n+        except Exception:\n             pass\n \n         if vocabulary and hasattr(vocabulary, "by_value"):\n             try:\n                 field._type = type(list(vocabulary.by_value.keys())[0])\n-            except:\n+            except Exception:\n                 pass\n \n         value = fieldTypecast(field, element.text)\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2023-01-08T01:29:21+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.supermodel/commit/7353bfcb74c00a05dadc52ac2ed2e3655dd639d0

chore: codespell typos fixes

Files changed:
M plone/supermodel/interfaces.py
M plone/supermodel/schema.rst
M plone/supermodel/utils.py

b'diff --git a/plone/supermodel/interfaces.py b/plone/supermodel/interfaces.py\nindex a65420d..3d89535 100644\n--- a/plone/supermodel/interfaces.py\n+++ b/plone/supermodel/interfaces.py\n@@ -150,7 +150,7 @@ def name(schemaName, tree):\n class IFieldExportImportHandler(Interface):\n     """Named utilities corresponding to node names should be registered for\n     this interface. They will be called upon to build a schema fields out of\n-    DOM ndoes.\n+    DOM nodes.\n     """\n \n     def read(node):\ndiff --git a/plone/supermodel/schema.rst b/plone/supermodel/schema.rst\nindex bcf9e48..7cc8620 100644\n--- a/plone/supermodel/schema.rst\n+++ b/plone/supermodel/schema.rst\n@@ -167,7 +167,7 @@ directory.\n     >>> tmpdir = tempfile.mkdtemp()\n     >>> schema_filename = os.path.join(tmpdir, \'schema.xml\')\n     >>> with open(schema_filename, \'w\') as fd:\n-    ...     _ = fd.write(schema)  # On Py3 write resturns the schema len\n+    ...     _ = fd.write(schema)  # On Py3 write returns the schema len\n \n We can define interfaces from this using a helper function:\n \ndiff --git a/plone/supermodel/utils.py b/plone/supermodel/utils.py\nindex 39016f4..33caf63 100644\n--- a/plone/supermodel/utils.py\n+++ b/plone/supermodel/utils.py\n@@ -44,7 +44,7 @@ def indent(node, level=0):\n     node_indent = level * (" " * INDENT_SIZE)\n     child_indent = (level + 1) * (" " * INDENT_SIZE)\n \n-    # node has childen\n+    # node has children\n     if len(node):\n \n         # add indent before first child node\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2023-01-08T01:29:21+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.supermodel/commit/238e8c60b0b613a39ad4dcbd1c6ba81713a2c903

Add news entry

Files changed:
A news/1.bugfix

b'diff --git a/news/1.bugfix b/news/1.bugfix\nnew file mode 100644\nindex 0000000..858a8e6\n--- /dev/null\n+++ b/news/1.bugfix\n@@ -0,0 +1,2 @@\n+Unify repository configuration via github.com/plone/meta.\n+[gforcada]\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2023-01-16T12:43:10+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.supermodel/commit/f87365ab44b129a50206fdcbc31ca209c2ad82a9

Merge pull request #43 from plone/config-with-default-template-a6927e10

Config with default template

Files changed:
A .editorconfig
A .github/workflows/linting.yml
A .meta.toml
A lint-requirements.txt
A news/1.bugfix
A tox.ini
M plone/__init__.py
M plone/supermodel/__init__.py
M plone/supermodel/converters.py
M plone/supermodel/debug.py
M plone/supermodel/directives.py
M plone/supermodel/exportimport.py
M plone/supermodel/fields.py
M plone/supermodel/interfaces.py
M plone/supermodel/model.py
M plone/supermodel/parser.py
M plone/supermodel/patches.py
M plone/supermodel/schema.rst
M plone/supermodel/serializer.py
M plone/supermodel/tests.py
M plone/supermodel/utils.py
M pyproject.toml
M setup.cfg
M setup.py

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.github/workflows/linting.yml b/.github/workflows/linting.yml\nnew file mode 100644\nindex 0000000..a2139a8\n--- /dev/null\n+++ b/.github/workflows/linting.yml\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+name: Linting\n+on:\n+  push:\n+    branches: [master]\n+  pull_request:\n+    branches: [master]\n+  workflow_dispatch:\n+\n+jobs:\n+  test:\n+    name: Lint code\n+    runs-on: ${{ matrix.os }}\n+    strategy:\n+      matrix:\n+        python-version: ["3.8"]\n+        os: ["ubuntu-22.04"]\n+    steps:\n+      - uses: actions/checkout@v3\n+      - name: Set up Python\n+        uses: actions/setup-python@v4\n+        with:\n+          python-version: ${{ matrix.python-version }}\n+      - name: Cache packages\n+        uses: actions/cache@v3\n+        with:\n+          path: ~/.cache/pip\n+          key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles(\'lint-requirements.txt\', \'tox.ini\') }}\n+          restore-keys: |\n+            ${{ runner.os }}-pip-${{ matrix.python-version }}-\n+            ${{ runner.os }}-pip-\n+      - name: Install dependencies\n+        run: python -m pip install tox\n+      - name: Run formatters\n+        run: tox -e format\n+      # linters\n+      - name: QA\n+        run: tox -e lint\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..e393a44\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "6d382fce"\ndiff --git a/lint-requirements.txt b/lint-requirements.txt\nnew file mode 100644\nindex 0000000..dedd4cb\n--- /dev/null\n+++ b/lint-requirements.txt\n@@ -0,0 +1,7 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+black==22.12.0\n+codespell==2.2.2\n+flake8==6.0.0\n+isort==5.11.4\n+pyupgrade==3.3.1\ndiff --git a/news/1.bugfix b/news/1.bugfix\nnew file mode 100644\nindex 0000000..858a8e6\n--- /dev/null\n+++ b/news/1.bugfix\n@@ -0,0 +1,2 @@\n+Unify repository configuration via github.com/plone/meta.\n+[gforcada]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/supermodel/__init__.py b/plone/supermodel/__init__.py\nindex 6ccce91..3b0b9c8 100644\n--- a/plone/supermodel/__init__.py\n+++ b/plone/supermodel/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from io import BytesIO\n from plone.supermodel import model\n from plone.supermodel import parser\n@@ -8,19 +7,17 @@\n from plone.supermodel.interfaces import IXMLToSchema\n from zope.interface import moduleProvides\n \n-import six\n-\n \n # Cache models by absolute filename\n _model_cache = {}\n \n \n-def xmlSchema(filename, schema=u"", policy=u"", _frame=2):\n+def xmlSchema(filename, schema="", policy="", _frame=2):\n     _model = loadFile(filename, policy=policy, _frame=_frame + 1)\n     return _model.schemata[schema]\n \n \n-def loadFile(filename, reload=False, policy=u"", _frame=2):\n+def loadFile(filename, reload=False, policy="", _frame=2):\n     global _model_cache\n     path = utils.relativeToCallingPackage(filename, _frame)\n     if reload or path not in _model_cache:\n@@ -31,13 +28,13 @@ def loadFile(filename, reload=False, policy=u"", _frame=2):\n     return _model_cache[path]\n \n \n-def loadString(model, policy=u""):\n-    if not isinstance(model, six.binary_type):\n+def loadString(model, policy=""):\n+    if not isinstance(model, bytes):\n         model = model.encode()\n     return parser.parse(BytesIO(model), policy=policy)\n \n \n-def serializeSchema(schema, name=u""):\n+def serializeSchema(schema, name=""):\n     return serializeModel(model.Model({name: schema}))\n \n \n@@ -47,10 +44,4 @@ def serializeModel(model):\n \n moduleProvides(IXMLToSchema)\n \n-__all__ = (\n-    \'xmlSchema\',\n-    \'loadFile\',\n-    \'loadString\',\n-    \'serializeSchema\',\n-    \'serializeModel\'\n-)\n+__all__ = ("xmlSchema", "loadFile", "loadString", "serializeSchema", "serializeModel")\ndiff --git a/plone/supermodel/converters.py b/plone/supermodel/converters.py\nindex 1458a46..4bdde60 100644\n--- a/plone/supermodel/converters.py\n+++ b/plone/supermodel/converters.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.supermodel.interfaces import IToUnicode\n from plone.supermodel.utils import fieldTypecast\n from zope.component import adapter\n@@ -13,16 +12,15 @@\n from zope.schema.interfaces import IObject\n \n import datetime\n-import six\n import time\n \n \n # Defaults\n \n+\n @implementer(IFromUnicode)\n @adapter(IField)\n-class DefaultFromUnicode(object):\n-\n+class DefaultFromUnicode:\n     def __init__(self, context):\n         self.context = context\n \n@@ -32,22 +30,22 @@ def fromUnicode(self, value):\n \n @implementer(IToUnicode)\n @adapter(IField)\n-class DefaultToUnicode(object):\n-\n+class DefaultToUnicode:\n     def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n-        if isinstance(value, six.binary_type):\n+        if isinstance(value, bytes):\n             return value.decode()\n-        return six.text_type(value)\n+        return str(value)\n \n \n # Date/time fields\n \n+\n @implementer(IFromUnicode)\n @adapter(IDate)\n-class DateFromUnicode(object):\n+class DateFromUnicode:\n \n     format = "%Y-%m-%d"\n \n@@ -63,7 +61,7 @@ def fromUnicode(self, value):\n \n @implementer(IFromUnicode)\n @adapter(IDatetime)\n-class DatetimeFromUnicode(object):\n+class DatetimeFromUnicode:\n \n     format = "%Y-%m-%d %H:%M:%S"\n \n@@ -79,10 +77,10 @@ def fromUnicode(self, value):\n \n # Interface fields\n \n+\n @implementer(IFromUnicode)\n @adapter(IInterfaceField)\n-class InterfaceFieldFromUnicode(object):\n-\n+class InterfaceFieldFromUnicode:\n     def __init__(self, context):\n         self.context = context\n \n@@ -94,13 +92,12 @@ def fromUnicode(self, value):\n \n @implementer(IToUnicode)\n @adapter(IInterfaceField)\n-class InterfaceFieldToUnicode(object):\n-\n+class InterfaceFieldToUnicode:\n     def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n-        return six.text_type(value.__identifier__)\n+        return str(value.__identifier__)\n \n \n # Object fields - we can read, but not write, as there is no way to know\n@@ -110,8 +107,7 @@ def toUnicode(self, value):\n \n @implementer(IFromUnicode)\n @adapter(IObject)\n-class ObjectFromUnicode(object):\n-\n+class ObjectFromUnicode:\n     def __init__(self, context):\n         self.context = context\n \n@@ -123,12 +119,11 @@ def fromUnicode(self, value):\n \n @implementer(IToUnicode)\n @adapter(IBytes)\n-class BytesToUnicode(object):\n-\n+class BytesToUnicode:\n     def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n-        if isinstance(value, six.binary_type):\n+        if isinstance(value, bytes):\n             return value.decode()\n-        return six.text_type(value)\n+        return str(value)\ndiff --git a/plone/supermodel/debug.py b/plone/supermodel/debug.py\nindex 7224c6c..c957c28 100644\n--- a/plone/supermodel/debug.py\n+++ b/plone/supermodel/debug.py\n@@ -1,15 +1,14 @@\n-# -*- coding: utf-8 -*-\n import threading\n \n \n class SupermodelParseInfo(threading.local):\n-\n     def __getattr__(self, name):\n-        if name == \'stack\':\n+        if name == "stack":\n             self.stack = [None]\n             return self.stack\n-        if name == \'i18n_domain\':\n-            return self.__dict__.get(\'i18n_domain\')\n+        if name == "i18n_domain":\n+            return self.__dict__.get("i18n_domain")\n         return self.__dict__[name]\n \n+\n parseinfo = SupermodelParseInfo()\ndiff --git a/plone/supermodel/directives.py b/plone/supermodel/directives.py\nindex 02b57cc..744d406 100644\n--- a/plone/supermodel/directives.py\n+++ b/plone/supermodel/directives.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.supermodel import loadFile\n from plone.supermodel.interfaces import DEFAULT_ORDER\n from plone.supermodel.interfaces import FIELDSETS_KEY\n@@ -21,14 +20,14 @@\n \n # Directive\n \n+\n class DirectiveClass(type):\n-    """A Directive is used to apply tagged values to a Schema\n-    """\n+    """A Directive is used to apply tagged values to a Schema"""\n \n     def __init__(self, name, bases, attrs):\n-        attrs.setdefault(\'finalize\', None)\n-        super(DirectiveClass, self).__init__(name, bases, attrs)\n-        self.__instance = super(DirectiveClass, self).__call__()\n+        attrs.setdefault("finalize", None)\n+        super().__init__(name, bases, attrs)\n+        self.__instance = super().__call__()\n \n     def __call__(self, *args, **kw):\n         instance = self.__instance\n@@ -37,16 +36,19 @@ def __call__(self, *args, **kw):\n         value = instance.factory(*args, **kw)\n         instance.store(tags, value)\n \n+\n Directive = DirectiveClass(\n-    \'Directive\',\n+    "Directive",\n     (),\n-    dict(__module__=\'plone.supermodel.directives\',),\n+    dict(\n+        __module__="plone.supermodel.directives",\n+    ),\n )\n \n \n class MetadataListDirective(Directive):\n-    """Store a list value in the tagged value under the key.\n-    """\n+    """Store a list value in the tagged value under the key."""\n+\n     key = None\n \n     def store(self, tags, value):\n@@ -54,8 +56,8 @@ def store(self, tags, value):\n \n \n class MetadataDictDirective(Directive):\n-    """Store a dict value in the tagged value under the key.\n-    """\n+    """Store a dict value in the tagged value under the key."""\n+\n     key = None\n \n     def store(self, tags, value):\n@@ -64,9 +66,10 @@ def store(self, tags, value):\n \n # Plugin\n \n+\n @adapter(ISchema)\n @implementer(ISchemaPlugin)\n-class CheckerPlugin(object):\n+class CheckerPlugin:\n \n     key = None\n \n@@ -82,11 +85,9 @@ def check(self):\n         for fieldName in self.fieldNames():\n             if fieldName not in schema:\n                 raise ValueError(\n-                    u\'The directive {0} applied to interface {1} \'\n-                    u\'refers to unknown field name {2}\'.format(\n-                        self.key,\n-                        schema.__identifier__,\n-                        fieldName\n+                    "The directive {} applied to interface {} "\n+                    "refers to unknown field name {}".format(\n+                        self.key, schema.__identifier__, fieldName\n                     )\n                 )\n             yield fieldName\n@@ -97,7 +98,6 @@ def __call__(self):\n \n \n class DictCheckerPlugin(CheckerPlugin):\n-\n     def fieldNames(self):\n         if self.value is None:\n             return []\n@@ -105,12 +105,10 @@ def fieldNames(self):\n \n \n class ListCheckerPlugin(CheckerPlugin):\n-\n     def fieldNames(self):\n         if self.value is None:\n             return\n-        for fieldName in self.value:\n-            yield fieldName\n+        yield from self.value\n \n \n class ListPositionCheckerPlugin(CheckerPlugin):\n@@ -126,21 +124,21 @@ def fieldNames(self):\n \n # Implementations\n \n+\n class load(Directive):\n-    """Directive used to specify the XML model file\n-    """\n+    """Directive used to specify the XML model file"""\n \n     def store(self, tags, value):\n-        tags[FILENAME_KEY] = value[\'filename\']\n-        tags[SCHEMA_NAME_KEY] = value[\'schema\']\n+        tags[FILENAME_KEY] = value["filename"]\n+        tags[SCHEMA_NAME_KEY] = value["schema"]\n \n-    def factory(self, filename, schema=u\'\'):\n+    def factory(self, filename, schema=""):\n         return dict(filename=filename, schema=schema)\n \n \n @adapter(ISchema)\n @implementer(ISchemaPlugin)\n-class SupermodelSchemaPlugin(object):\n+class SupermodelSchemaPlugin:\n \n     order = -1000\n \n@@ -159,7 +157,7 @@ def __call__(self):\n         schema = Element.queryTaggedValue(\n             interface,\n             SCHEMA_NAME_KEY,\n-            default=u\'\',\n+            default="",\n         )\n \n         moduleName = interface.__module__\n@@ -167,26 +165,26 @@ def __call__(self):\n \n         directory = moduleName\n \n-        if hasattr(module, \'__path__\'):\n+        if hasattr(module, "__path__"):\n             directory = module.__path__[0]\n         else:\n-            while \'.\' in moduleName:\n-                moduleName, _ = moduleName.rsplit(\'.\', 1)\n+            while "." in moduleName:\n+                moduleName, _ = moduleName.rsplit(".", 1)\n                 module = sys.modules.get(moduleName, None)\n-                if hasattr(module, \'__path__\'):\n+                if hasattr(module, "__path__"):\n                     directory = module.__path__[0]\n                     break\n \n         directory = os.path.abspath(directory)\n         # Let / act as path separator on all platforms\n-        filename = filename.replace(\'/\', os.path.sep)\n+        filename = filename.replace("/", os.path.sep)\n         filename = os.path.abspath(os.path.join(directory, filename))\n \n         model = loadFile(filename)\n         if schema not in model.schemata:\n             raise ValueError(\n-                \'Schema "{0}" specified for interface {1} does not exist \'\n-                \'in {2}.\'.format(\n+                \'Schema "{}" specified for interface {} does not exist \'\n+                "in {}.".format(\n                     schema,\n                     interface.__identifier__,\n                     filename,\n@@ -197,18 +195,12 @@ def __call__(self):\n \n \n class fieldset(MetadataListDirective):\n-    """Directive used to create fieldsets\n-    """\n+    """Directive used to create fieldsets"""\n+\n     key = FIELDSETS_KEY\n \n     def factory(\n-        self,\n-        name,\n-        label=None,\n-        description=None,\n-        fields=None,\n-        order=DEFAULT_ORDER,\n-        **kw\n+        self, name, label=None, description=None, fields=None, order=DEFAULT_ORDER, **kw\n     ):\n         fieldset = Fieldset(\n             name,\n@@ -230,8 +222,7 @@ def fieldNames(self):\n         if self.value is None:\n             return\n         for fieldset in self.value:\n-            for fieldName in fieldset.fields:\n-                yield fieldName\n+            yield from fieldset.fields\n \n \n try:\n@@ -239,16 +230,15 @@ def fieldNames(self):\n except ImportError:\n     pass\n else:\n+\n     class primary(MetadataListDirective):\n-        """Directive used to mark one or more fields as \'primary\'\n-        """\n+        """Directive used to mark one or more fields as \'primary\'"""\n+\n         key = PRIMARY_FIELDS_KEY\n \n         def factory(self, *args):\n             if not args:\n-                raise TypeError(\n-                    \'The primary directive expects at least one argument.\'\n-                )\n+                raise TypeError("The primary directive expects at least one argument.")\n             return args\n \n     class PrimaryFieldsPlugin(ListCheckerPlugin):\ndiff --git a/plone/supermodel/exportimport.py b/plone/supermodel/exportimport.py\nindex 247de45..4e3645d 100644\n--- a/plone/supermodel/exportimport.py\n+++ b/plone/supermodel/exportimport.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from lxml import etree\n from plone.supermodel.debug import parseinfo\n from plone.supermodel.interfaces import IDefaultFactory\n@@ -32,7 +31,7 @@ class OrderedDictField(zope.schema.Dict):\n \n \n @implementer(IFieldExportImportHandler)\n-class BaseHandler(object):\n+class BaseHandler:\n     """Base class for import/export handlers.\n \n     The read_field method is called to read one field of the known subtype\n@@ -45,21 +44,28 @@ class BaseHandler(object):\n     # Elements that we will not read/write. \'r\' means skip when reading;\n     # \'w\' means skip when writing; \'rw\' means skip always.\n \n-    filteredAttributes = {\'order\': \'rw\', \'unique\': \'rw\', \'defaultFactory\': \'w\'}\n+    filteredAttributes = {"order": "rw", "unique": "rw", "defaultFactory": "w"}\n \n     # Elements that are of the same type as the field itself\n-    fieldTypeAttributes = (\'min\', \'max\', \'default\', )\n+    fieldTypeAttributes = (\n+        "min",\n+        "max",\n+        "default",\n+    )\n \n     # Elements that are of the same type as the field itself, but are\n     # otherwise not validated\n-    nonValidatedfieldTypeAttributes = (\'missing_value\', )\n+    nonValidatedfieldTypeAttributes = ("missing_value",)\n \n     # Attributes that contain another field. Unfortunately,\n-    fieldInstanceAttributes = (\'key_type\', \'value_type\', )\n+    fieldInstanceAttributes = (\n+        "key_type",\n+        "value_type",\n+    )\n \n     # Fields that are always written\n \n-    forcedFields = frozenset([\'default\', \'missing_value\'])\n+    forcedFields = frozenset(["default", "missing_value"])\n \n     def __init__(self, klass):\n         self.klass = klass\n@@ -71,18 +77,15 @@ def __init__(self, klass):\n         for schema in implementedBy(self.klass).flattened():\n             self.fieldAttributes.update(zope.schema.getFields(schema))\n \n-        self.fieldAttributes[\'defaultFactory\'] = zope.schema.Object(\n-            __name__=\'defaultFactory\',\n-            title=u"defaultFactory",\n-            schema=Interface\n+        self.fieldAttributes["defaultFactory"] = zope.schema.Object(\n+            __name__="defaultFactory", title="defaultFactory", schema=Interface\n         )\n \n     def _constructField(self, attributes):\n         return self.klass(**attributes)\n \n     def read(self, element):\n-        """Read a field from the element and return a new instance\n-        """\n+        """Read a field from the element and return a new instance"""\n         attributes = {}\n         deferred = {}\n         deferred_nonvalidated = {}\n@@ -91,7 +94,7 @@ def read(self, element):\n             parseinfo.stack.append(attribute_element)\n             attribute_name = noNS(attribute_element.tag)\n \n-            if \'r\' in self.filteredAttributes.get(attribute_name, \'\'):\n+            if "r" in self.filteredAttributes.get(attribute_name, ""):\n                 continue\n \n             attributeField = self.fieldAttributes.get(attribute_name, None)\n@@ -105,33 +108,29 @@ def read(self, element):\n \n                 elif attribute_name in self.fieldInstanceAttributes:\n \n-                    attributeField_type = attribute_element.get(\'type\')\n+                    attributeField_type = attribute_element.get("type")\n                     handler = queryUtility(\n-                        IFieldExportImportHandler,\n-                        name=attributeField_type\n+                        IFieldExportImportHandler, name=attributeField_type\n                     )\n \n                     if handler is None:\n                         raise NotImplementedError(\n-                            u"Type %s used for %s not supported" %\n-                            (attributeField_type, attribute_name)\n+                            "Type %s used for %s not supported"\n+                            % (attributeField_type, attribute_name)\n                         )\n \n-                    attributes[attribute_name] = handler.read(\n-                        attribute_element\n-                    )\n+                    attributes[attribute_name] = handler.read(attribute_element)\n \n                 else:\n                     attributes[attribute_name] = self.readAttribute(\n-                        attribute_element,\n-                        attributeField\n+                        attribute_element, attributeField\n                     )\n             parseinfo.stack.pop()\n \n-        name = element.get(\'name\')\n+        name = element.get("name")\n         if name is not None:\n             name = str(name)\n-            attributes[\'__name__\'] = name\n+            attributes["__name__"] = name\n \n         field_instance = self._constructField(attributes)\n \n@@ -157,7 +156,7 @@ def read(self, element):\n \n                 clone = self.klass.__new__(self.klass)\n                 clone.__dict__.update(field_instance.__dict__)\n-                clone.__dict__[\'validate\'] = lambda value: True\n+                clone.__dict__["validate"] = lambda value: True\n \n                 attribute_element = deferred_nonvalidated[attribute_name]\n                 parseinfo.stack.append(attribute_element)\n@@ -173,33 +172,30 @@ def read(self, element):\n             # restrict to those that provide IContextAwareDefaultFactory\n             # or IDefaultFactory\n             if not (\n-                IContextAwareDefaultFactory.providedBy(\n-                    field_instance.defaultFactory\n-                ) or\n-                IDefaultFactory.providedBy(field_instance.defaultFactory)\n+                IContextAwareDefaultFactory.providedBy(field_instance.defaultFactory)\n+                or IDefaultFactory.providedBy(field_instance.defaultFactory)\n             ):\n                 raise ImportError(\n-                    u"defaultFactory must provide "\n-                    u"zope.schema.interfaces.IContextAwareDefaultFactory "\n-                    u"or plone.supermodel.IDefaultFactory"\n+                    "defaultFactory must provide "\n+                    "zope.schema.interfaces.IContextAwareDefaultFactory "\n+                    "or plone.supermodel.IDefaultFactory"\n                 )\n \n         return field_instance\n \n-    def write(self, field, name, type, elementName=\'field\'):\n-        """Create and return a new element representing the given field\n-        """\n+    def write(self, field, name, type, elementName="field"):\n+        """Create and return a new element representing the given field"""\n \n         element = etree.Element(elementName)\n \n         if name:\n-            element.set(\'name\', name)\n+            element.set("name", name)\n \n-        element.set(\'type\', type)\n+        element.set("type", type)\n \n         for attribute_name in sorted(self.fieldAttributes.keys()):\n             attributeField = self.fieldAttributes[attribute_name]\n-            if \'w\' in self.filteredAttributes.get(attribute_name, \'\'):\n+            if "w" in self.filteredAttributes.get(attribute_name, ""):\n                 continue\n             child = self.writeAttribute(attributeField, field)\n             if child is not None:\n@@ -224,7 +220,7 @@ def writeAttribute(self, attributeField, field, ignoreDefault=True):\n         attributeField = attributeField.bind(field)\n         value = attributeField.get(field)\n \n-        force = (elementName in self.forcedFields)\n+        force = elementName in self.forcedFields\n \n         if ignoreDefault and value == attributeField.default:\n             return None\n@@ -232,30 +228,22 @@ def writeAttribute(self, attributeField, field, ignoreDefault=True):\n         # The value points to another field. Recurse.\n         if IField.providedBy(value):\n             value_fieldType = IFieldNameExtractor(value)()\n-            handler = queryUtility(\n-                IFieldExportImportHandler,\n-                name=value_fieldType\n-            )\n+            handler = queryUtility(IFieldExportImportHandler, name=value_fieldType)\n             if handler is None:\n                 return None\n             return handler.write(\n-                value, name=None,\n-                type=value_fieldType,\n-                elementName=elementName\n+                value, name=None, type=value_fieldType, elementName=elementName\n             )\n \n         # For \'default\', \'missing_value\' etc, we want to validate against\n         # the imported field type itself, not the field type of the attribute\n-        if elementName in self.fieldTypeAttributes or \\\n-                elementName in self.nonValidatedfieldTypeAttributes:\n+        if (\n+            elementName in self.fieldTypeAttributes\n+            or elementName in self.nonValidatedfieldTypeAttributes\n+        ):\n             attributeField = field\n \n-        return valueToElement(\n-            attributeField,\n-            value,\n-            name=elementName,\n-            force=force\n-        )\n+        return valueToElement(attributeField, value, name=elementName, force=force)\n \n \n class DictHandler(BaseHandler):\n@@ -264,14 +252,12 @@ class DictHandler(BaseHandler):\n     """\n \n     def __init__(self, klass):\n-        super(DictHandler, self).__init__(klass)\n-        self.fieldAttributes[\'key_type\'] = zope.schema.Field(\n-            __name__=\'key_type\',\n-            title=u"Key type"\n+        super().__init__(klass)\n+        self.fieldAttributes["key_type"] = zope.schema.Field(\n+            __name__="key_type", title="Key type"\n         )\n-        self.fieldAttributes[\'value_type\'] = zope.schema.Field(\n-            __name__=\'value_type\',\n-            title=u"Value type"\n+        self.fieldAttributes["value_type"] = zope.schema.Field(\n+            __name__="value_type", title="Value type"\n         )\n \n \n@@ -283,60 +269,49 @@ class ObjectHandler(BaseHandler):\n     # We can\'t serialise the value or missing_value of an object field.\n \n     filteredAttributes = BaseHandler.filteredAttributes.copy()\n-    filteredAttributes.update({\'default\': \'w\', \'missing_value\': \'w\'})\n+    filteredAttributes.update({"default": "w", "missing_value": "w"})\n \n     def __init__(self, klass):\n-        super(ObjectHandler, self).__init__(klass)\n+        super().__init__(klass)\n \n         # This is not correctly set in the interface\n-        self.fieldAttributes[\'schema\'] = zope.schema.InterfaceField(\n-            __name__=\'schema\'\n-        )\n+        self.fieldAttributes["schema"] = zope.schema.InterfaceField(__name__="schema")\n \n \n class ChoiceHandler(BaseHandler):\n-    """Special handling for the Choice field\n-    """\n+    """Special handling for the Choice field"""\n \n     filteredAttributes = BaseHandler.filteredAttributes.copy()\n     filteredAttributes.update(\n-        {\'vocabulary\': \'w\',\n-         \'values\': \'w\',\n-         \'source\': \'w\',\n-         \'vocabularyName\': \'rw\'\n-         }\n+        {"vocabulary": "w", "values": "w", "source": "w", "vocabularyName": "rw"}\n     )\n \n     def __init__(self, klass):\n-        super(ChoiceHandler, self).__init__(klass)\n+        super().__init__(klass)\n \n         # Special options for the constructor. These are not automatically\n         # written.\n \n-        self.fieldAttributes[\'vocabulary\'] = zope.schema.TextLine(\n-            __name__=\'vocabulary\',\n-            title=u"Named vocabulary"\n+        self.fieldAttributes["vocabulary"] = zope.schema.TextLine(\n+            __name__="vocabulary", title="Named vocabulary"\n         )\n \n-        self.fieldAttributes[\'values\'] = zope.schema.List(\n-            __name__=\'values\',\n-            title=u"Values",\n-            value_type=zope.schema.Text(title=u"Value")\n+        self.fieldAttributes["values"] = zope.schema.List(\n+            __name__="values",\n+            title="Values",\n+            value_type=zope.schema.Text(title="Value"),\n         )\n \n         # XXX: We can\'t be more specific about the schema, since the field\n         # supports both ISource and IContextSourceBinder. However, the\n         # initialiser will validate.\n-        self.fieldAttributes[\'source\'] = zope.schema.Object(\n-            __name__=\'source\',\n-            title=u"Source",\n-            schema=Interface\n+        self.fieldAttributes["source"] = zope.schema.Object(\n+            __name__="source", title="Source", schema=Interface\n         )\n \n     def readAttribute(self, element, attributeField):\n-        if (\n-            etree.QName(element).localname == \'values\' and\n-            any([child.get(\'key\') for child in element])\n+        if etree.QName(element).localname == "values" and any(\n+            [child.get("key") for child in element]\n         ):\n             attributeField = OrderedDictField(\n                 key_type=zope.schema.TextLine(),\n@@ -345,64 +320,48 @@ def readAttribute(self, element, attributeField):\n         return elementToValue(attributeField, element)\n \n     def _constructField(self, attributes):\n-        if \'values\' in attributes:\n-            if isinstance(attributes[\'values\'], OrderedDict):\n-                attributes[\'values\'] = attributes[\'values\'].items()\n+        if "values" in attributes:\n+            if isinstance(attributes["values"], OrderedDict):\n+                attributes["values"] = attributes["values"].items()\n             terms = []\n-            for value in attributes[\'values\']:\n-                title = (value or u\'\')\n+            for value in attributes["values"]:\n+                title = value or ""\n                 if isinstance(value, tuple):\n                     value, title = value\n-                encoded = (value or \'\').encode(\'unicode_escape\')\n+                encoded = (value or "").encode("unicode_escape")\n                 if value != encoded:\n-                    value = value or u\'\'\n-                    term = SimpleTerm(\n-                        token=encoded,\n-                        value=value,\n-                        title=title\n-                    )\n+                    value = value or ""\n+                    term = SimpleTerm(token=encoded, value=value, title=title)\n                 else:\n                     term = SimpleTerm(value=value, title=title)\n                 terms.append(term)\n-            attributes[\'vocabulary\'] = SimpleVocabulary(terms)\n-            del attributes[\'values\']\n-        return super(ChoiceHandler, self)._constructField(attributes)\n+            attributes["vocabulary"] = SimpleVocabulary(terms)\n+            del attributes["values"]\n+        return super()._constructField(attributes)\n \n-    def write(self, field, name, type, elementName=\'field\'):\n+    def write(self, field, name, type, elementName="field"):\n \n-        element = super(ChoiceHandler, self).write(\n-            field,\n-            name,\n-            type,\n-            elementName\n-        )\n+        element = super().write(field, name, type, elementName)\n \n         # write vocabulary or values list\n \n         # Named vocabulary\n         if field.vocabularyName is not None and field.vocabulary is None:\n-            attributeField = self.fieldAttributes[\'vocabulary\']\n+            attributeField = self.fieldAttributes["vocabulary"]\n             child = valueToElement(\n-                attributeField,\n-                field.vocabularyName,\n-                name=\'vocabulary\',\n-                force=True\n+                attributeField, field.vocabularyName, name="vocabulary", force=True\n             )\n             element.append(child)\n \n         # Listed vocabulary - attempt to convert to a simple list of values\n-        elif (\n-            field.vocabularyName is None and\n-            IVocabularyTokenized.providedBy(field.vocabulary)\n+        elif field.vocabularyName is None and IVocabularyTokenized.providedBy(\n+            field.vocabulary\n         ):\n             value = []\n             for term in field.vocabulary:\n-                if (\n-                    isinstance(term.value, six.integer_types)\n-                    or (\n-                        isinstance(term.value, six.string_types)\n-                        and six.b(term.token) == term.value.encode(\'unicode_escape\')\n-                    )\n+                if isinstance(term.value, int) or (\n+                    isinstance(term.value, str)\n+                    and six.b(term.token) == term.value.encode("unicode_escape")\n                 ):\n                     if term.title and term.title != term.value:\n                         value.append((term.value, term.title))\n@@ -410,34 +369,31 @@ def write(self, field, name, type, elementName=\'field\'):\n                         value.append(term.value)\n                 else:\n                     raise NotImplementedError(\n-                        u"Cannot export a vocabulary that is not "\n-                        u"based on a simple list of values"\n+                        "Cannot export a vocabulary that is not "\n+                        "based on a simple list of values"\n                     )\n \n-            attributeField = self.fieldAttributes[\'values\']\n+            attributeField = self.fieldAttributes["values"]\n             if any(map(lambda v: isinstance(v, tuple), value)):\n+\n                 def _pair(v):\n                     return v if len(v) == 2 else (v[0],) * 2\n+\n                 value = OrderedDict(map(_pair, value))\n                 attributeField = OrderedDictField(\n                     key_type=zope.schema.TextLine(),\n                     value_type=zope.schema.TextLine(),\n                 )\n-            child = valueToElement(\n-                attributeField,\n-                value,\n-                name=\'values\',\n-                force=True\n-            )\n+            child = valueToElement(attributeField, value, name="values", force=True)\n             element.append(child)\n \n         # Anything else is not allowed - we can\'t export ISource/IVocabulary or\n         #  IContextSourceBinder objects.\n         else:\n             raise NotImplementedError(\n-                u"Choice fields with vocabularies not based on "\n-                u"a simple list of values or a named vocabulary "\n-                u"cannot be exported"\n+                "Choice fields with vocabularies not based on "\n+                "a simple list of values or a named vocabulary "\n+                "cannot be exported"\n             )\n \n         return element\ndiff --git a/plone/supermodel/fields.py b/plone/supermodel/fields.py\nindex 0e993f4..7cfbf00 100644\n--- a/plone/supermodel/fields.py\n+++ b/plone/supermodel/fields.py\n@@ -1,18 +1,15 @@\n-# -*- coding: utf-8 -*-\n import plone.supermodel.exportimport\n import zope.schema\n \n+\n # Field import/export handlers\n \n BytesHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Bytes)\n ASCIIHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.ASCII)\n-BytesLineHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.BytesLine)\n-ASCIILineHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.ASCIILine)\n+BytesLineHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.BytesLine)\n+ASCIILineHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.ASCIILine)\n TextHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Text)\n-TextLineHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.TextLine)\n+TextLineHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.TextLine)\n BoolHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Bool)\n IntHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Int)\n FloatHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Float)\n@@ -20,21 +17,17 @@\n TupleHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Tuple)\n ListHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.List)\n SetHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Set)\n-FrozenSetHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.FrozenSet)\n-PasswordHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.Password)\n+FrozenSetHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.FrozenSet)\n+PasswordHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Password)\n DictHandler = plone.supermodel.exportimport.DictHandler(zope.schema.Dict)\n-DatetimeHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.Datetime)\n+DatetimeHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Datetime)\n DateHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Date)\n-SourceTextHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.SourceText)\n+SourceTextHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.SourceText)\n URIHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.URI)\n IdHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.Id)\n-DottedNameHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.DottedName)\n+DottedNameHandler = plone.supermodel.exportimport.BaseHandler(zope.schema.DottedName)\n InterfaceFieldHandler = plone.supermodel.exportimport.BaseHandler(\n-    zope.schema.InterfaceField)\n+    zope.schema.InterfaceField\n+)\n ObjectHandler = plone.supermodel.exportimport.ObjectHandler(zope.schema.Object)\n ChoiceHandler = plone.supermodel.exportimport.ChoiceHandler(zope.schema.Choice)\ndiff --git a/plone/supermodel/interfaces.py b/plone/supermodel/interfaces.py\nindex 115f330..3d89535 100644\n--- a/plone/supermodel/interfaces.py\n+++ b/plone/supermodel/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Interface\n from zope.interface.interfaces import IInterface\n \n@@ -8,74 +7,60 @@\n # Keys for tagged values on interfaces\n \n # absolute file name of model file\n-FILENAME_KEY = \'plone.supermodel.filename\'\n+FILENAME_KEY = "plone.supermodel.filename"\n \n # name of schema that was loaded from the model\n-SCHEMA_NAME_KEY = \'plone.supermodel.schemaname\'\n+SCHEMA_NAME_KEY = "plone.supermodel.schemaname"\n \n # list of fieldsets\n-FIELDSETS_KEY = \'plone.supermodel.fieldsets\'\n+FIELDSETS_KEY = "plone.supermodel.fieldsets"\n \n # Primary fields (requires plone.rfc822)\n-PRIMARY_FIELDS_KEY = \'plone.supermodel.primary\'\n+PRIMARY_FIELDS_KEY = "plone.supermodel.primary"\n \n # The namespace for the default supermodel schema/field parser\n \n-XML_NAMESPACE = u"http://namespaces.plone.org/supermodel/schema"\n-I18N_NAMESPACE = u\'http://xml.zope.org/namespaces/i18n\'\n+XML_NAMESPACE = "http://namespaces.plone.org/supermodel/schema"\n+I18N_NAMESPACE = "http://xml.zope.org/namespaces/i18n"\n \n DEFAULT_ORDER = 9999\n \n \n class ISchema(IInterface):\n-    """Describes a schema as generated by this library\n-    """\n+    """Describes a schema as generated by this library"""\n \n \n class IModel(Interface):\n-    """Describes a model as generated by this library\n-    """\n+    """Describes a model as generated by this library"""\n \n-    schema = zope.schema.InterfaceField(\n-        title=u"Default schema",\n-        readonly=True\n-    )\n+    schema = zope.schema.InterfaceField(title="Default schema", readonly=True)\n \n     schemata = zope.schema.Dict(\n-        title=u"Schemata",\n+        title="Schemata",\n         key_type=zope.schema.TextLine(\n-            title=u"Schema name",\n-            description=u"Default schema is under the key u\'\'."\n+            title="Schema name", description="Default schema is under the key u\'\'."\n         ),\n-        value_type=zope.schema.Object(\n-            title=u"Schema interface",\n-            schema=ISchema\n-        )\n+        value_type=zope.schema.Object(title="Schema interface", schema=ISchema),\n     )\n \n \n class IFieldset(Interface):\n-    """Describes a grouping of fields in the schema\n-    """\n+    """Describes a grouping of fields in the schema"""\n \n-    __name__ = zope.schema.TextLine(title=u"Fieldset name")\n+    __name__ = zope.schema.TextLine(title="Fieldset name")\n \n-    label = zope.schema.TextLine(title=u"Label")\n+    label = zope.schema.TextLine(title="Label")\n \n-    description = zope.schema.TextLine(\n-        title=u"Long description",\n-        required=False\n-    )\n+    description = zope.schema.TextLine(title="Long description", required=False)\n \n     order = zope.schema.Int(\n-        title=u"Order",\n+        title="Order",\n         required=False,\n         default=DEFAULT_ORDER,\n     )\n \n     fields = zope.schema.List(\n-        title=u"Field names",\n-        value_type=zope.schema.TextLine(title=u"Field name")\n+        title="Field names", value_type=zope.schema.TextLine(title="Field name")\n     )\n \n \n@@ -86,12 +71,12 @@ class ISchemaPlugin(Interface):\n     Execution is deferred until the full supermodel environment is available.\n     """\n \n-    order = zope.schema.Int(title=u"Order", required=False,\n-                            description=u"Sort key for plugin execution order")\n+    order = zope.schema.Int(\n+        title="Order", required=False, description="Sort key for plugin execution order"\n+    )\n \n     def __call__():\n-        """Execute plugin\n-        """\n+        """Execute plugin"""\n \n \n class IXMLToSchema(Interface):\n@@ -107,7 +92,7 @@ class IXMLToSchema(Interface):\n         model = loadFile(\'schema.xml\')\n     """\n \n-    def xmlSchema(filename, schema=u"", policy=u""):\n+    def xmlSchema(filename, schema="", policy=""):\n         """Given a filename relative to the current module, return an\n         interface representing the schema contained in that file. If there\n         are multiple <schema /> blocks, return the unnamed one, unless\n@@ -122,7 +107,7 @@ def xmlSchema(filename, schema=u"", policy=u""):\n         Raises an IOError if the file cannot be opened.\n         """\n \n-    def loadFile(filename, reload=False, policy=u""):\n+    def loadFile(filename, reload=False, policy=""):\n         """Return an IModel as contained in the given XML file, which is read\n         relative to the current module (unless it is an absolute path).\n \n@@ -132,11 +117,10 @@ def loadFile(filename, reload=False, policy=u""):\n         ISchemaPolicy.\n         """\n \n-    def loadString(model, policy=u""):\n-        """Load a model from a string rather than a file.\n-        """\n+    def loadString(model, policy=""):\n+        """Load a model from a string rather than a file."""\n \n-    def serializeSchema(schema, name=u""):\n+    def serializeSchema(schema, name=""):\n         """Return an XML string representing the given schema interface. This\n         is a convenience method around the serializeModel() method, below.\n         """\n@@ -154,31 +138,26 @@ class ISchemaPolicy(Interface):\n     """\n \n     def module(schemaName, tree):\n-        """Return the module name to use.\n-        """\n+        """Return the module name to use."""\n \n     def bases(schemaName, tree):\n-        """Return the bases to use.\n-        """\n+        """Return the bases to use."""\n \n     def name(schemaName, tree):\n-        """Return the schema name to use\n-        """\n+        """Return the schema name to use"""\n \n \n class IFieldExportImportHandler(Interface):\n     """Named utilities corresponding to node names should be registered for\n     this interface. They will be called upon to build a schema fields out of\n-    DOM ndoes.\n+    DOM nodes.\n     """\n \n     def read(node):\n-        """Read a field from the node and return a new instance\n-        """\n+        """Read a field from the node and return a new instance"""\n \n-    def write(field, fieldName, fieldType, elementName=\'field\'):\n-        """Create and return a new node representing the given field\n-        """\n+    def write(field, fieldName, fieldType, elementName="field"):\n+        """Create and return a new node representing the given field"""\n \n \n class ISchemaMetadataHandler(Interface):\n@@ -188,13 +167,11 @@ class ISchemaMetadataHandler(Interface):\n     """\n \n     namespace = zope.schema.URI(\n-        title=u"XML namespace used by this handler",\n-        required=False\n+        title="XML namespace used by this handler", required=False\n     )\n \n     prefix = zope.schema.ASCII(\n-        title=u"Preferred XML schema namespace for serialisation",\n-        required=False\n+        title="Preferred XML schema namespace for serialisation", required=False\n     )\n \n     def read(schemaNode, schema):\n@@ -216,12 +193,10 @@ class IFieldMetadataHandler(Interface):\n     """\n \n     namespace = zope.schema.URI(\n-        title=u"XML namespace used by this handler",\n-        required=False\n+        title="XML namespace used by this handler", required=False\n     )\n     prefix = zope.schema.ASCII(\n-        title=u"Preferred XML schema namespace for serialisation",\n-        required=False\n+        title="Preferred XML schema namespace for serialisation", required=False\n     )\n \n     def read(fieldNode, schema, field):\n@@ -238,12 +213,10 @@ def write(fieldNode, schema, field):\n \n \n class IFieldNameExtractor(Interface):\n-    """Adapter to determine the canonical name of a field\n-    """\n+    """Adapter to determine the canonical name of a field"""\n \n     def __call__():\n-        """Return the name of the adapted field\n-        """\n+        """Return the name of the adapted field"""\n \n \n class IToUnicode(Interface):\n@@ -252,8 +225,7 @@ class IToUnicode(Interface):\n     """\n \n     def toUnicode(value):\n-        """Convert the field value to a unicode string.\n-        """\n+        """Convert the field value to a unicode string."""\n \n \n class IDefaultFactory(Interface):\n@@ -268,9 +240,7 @@ def __call__():\n \n \n class IInvariant(Interface):\n-    """Marker interface for a callable used as a form invariant.\n-    """\n+    """Marker interface for a callable used as a form invariant."""\n \n     def __call__(data):\n-        """Returns None or raises zope.interface.Invalid\n-        """\n+        """Returns None or raises zope.interface.Invalid"""\ndiff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex a3fca34..f5ac818 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.supermodel.interfaces import DEFAULT_ORDER\n from plone.supermodel.interfaces import IFieldset\n from plone.supermodel.interfaces import IModel\n@@ -14,32 +13,27 @@\n \n \n zope.deferredimport.defineFrom(\n-    \'plone.supermodel.directives\',\n-    \'load\',\n-    \'fieldset\',\n+    "plone.supermodel.directives",\n+    "load",\n+    "fieldset",\n )\n \n try:\n     from plone.rfc822.interfaces import IPrimaryField\n+\n     IPrimaryField  # PEP8\n except ImportError:\n     pass\n else:\n-    zope.deferredimport.defineFrom(\'plone.supermodel.directives\', \'primary\')\n+    zope.deferredimport.defineFrom("plone.supermodel.directives", "primary")\n \n-logger = logging.getLogger(\'plone.supermodel\')\n+logger = logging.getLogger("plone.supermodel")\n \n \n @implementer(IFieldset)\n-class Fieldset(object):\n-\n+class Fieldset:\n     def __init__(\n-        self,\n-        __name__,\n-        label=None,\n-        description=None,\n-        fields=None,\n-        order=DEFAULT_ORDER\n+        self, __name__, label=None, description=None, fields=None, order=DEFAULT_ORDER\n     ):\n         self.__name__ = __name__\n         self.label = label or __name__\n@@ -52,16 +46,13 @@ def __init__(\n             self.fields = []\n \n     def __repr__(self):\n-        return "<Fieldset \'{0}\' order {1:d} of {2}>".format(\n-            self.__name__,\n-            self.order,\n-            \', \'.join(self.fields)\n+        return "<Fieldset \'{}\' order {:d} of {}>".format(\n+            self.__name__, self.order, ", ".join(self.fields)\n         )\n \n \n @implementer(IModel)\n-class Model(object):\n-\n+class Model:\n     def __init__(self, schemata=None):\n         if schemata is None:\n             schemata = {}\n@@ -71,43 +62,37 @@ def __init__(self, schemata=None):\n \n     @property\n     def schema(self):\n-        return self.schemata.get(u"", None)\n+        return self.schemata.get("", None)\n \n \n @implementer(ISchema)\n class SchemaClass(InterfaceClass):\n-\n-    def __init__(self, name, bases=(), attrs=None, __doc__=None,\n-                 __module__=None):\n+    def __init__(self, name, bases=(), attrs=None, __doc__=None, __module__=None):\n         InterfaceClass.__init__(self, name, bases, attrs, __doc__, __module__)\n         self._SchemaClass_finalize()\n \n     def _SchemaClass_finalize(self):\n-        adapters = [(getattr(adapter, \'order\', 0), name, adapter)\n-                    for name, adapter in getAdapters((self,), ISchemaPlugin)]\n+        adapters = [\n+            (getattr(adapter, "order", 0), name, adapter)\n+            for name, adapter in getAdapters((self,), ISchemaPlugin)\n+        ]\n         adapters.sort()\n         for order, name, adapter in adapters:\n             adapter()\n \n \n-Schema = SchemaClass(\n-    \'Schema\',\n-    (Interface,),\n-    __module__=\'plone.supermodel.model\'\n-)\n+Schema = SchemaClass("Schema", (Interface,), __module__="plone.supermodel.model")\n \n \n def finalizeSchemas(parent=Schema):\n-    """Configuration action called after plone.supermodel is configured.\n-    """\n+    """Configuration action called after plone.supermodel is configured."""\n     if not isinstance(parent, SchemaClass):\n         raise TypeError(\n-            \'Only instances of plone.supermodel.model.SchemaClass can be \'\n-            \'finalized.\'\n+            "Only instances of plone.supermodel.model.SchemaClass can be " "finalized."\n         )\n \n     def walk(schema):\n-        # When we have behaviors on the Plone site root we got some shcmeas that \n+        # When we have behaviors on the Plone site root we got some shcmeas that\n         # are not SchemaClasses\n         if isinstance(schema, SchemaClass):\n             yield schema\n@@ -123,20 +108,18 @@ def walk(schema):\n             children = ()\n \n         for child in children:\n-            for s in walk(child):\n-                yield s\n+            yield from walk(child)\n \n     schemas = set(walk(parent))\n     for schema in sorted(schemas):\n-        if hasattr(schema, \'_SchemaClass_finalize\'):\n+        if hasattr(schema, "_SchemaClass_finalize"):\n             schema._SchemaClass_finalize()\n         elif isinstance(schema, InterfaceClass):\n             logger.warn(\n-                \'{0}.{1} is not an instance of SchemaClass. \'\n-                \'This can happen if the first base class of a schema is not a \'\n-                \'SchemaClass. See \'\n-                \'https://bugs.launchpad.net/zope.interface/+bug/791218\'.format(\n-                    schema.__module__,\n-                    schema.__name__\n+                "{}.{} is not an instance of SchemaClass. "\n+                "This can happen if the first base class of a schema is not a "\n+                "SchemaClass. See "\n+                "https://bugs.launchpad.net/zope.interface/+bug/791218".format(\n+                    schema.__module__, schema.__name__\n                 )\n             )\ndiff --git a/plone/supermodel/parser.py b/plone/supermodel/parser.py\nindex 8a5c55d..73feda4 100644\n--- a/plone/supermodel/parser.py\n+++ b/plone/supermodel/parser.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from lxml import etree\n from plone.supermodel.debug import parseinfo\n from plone.supermodel.interfaces import DEFAULT_ORDER\n@@ -22,38 +21,35 @@\n from zope.schema import getFields\n \n import linecache\n-import six\n import sys\n import traceback\n \n \n # Exception\n class SupermodelParseError(Exception):\n-\n     def __init__(self, orig_exc, fname, element, tb):\n         msg = str(orig_exc)\n         lineno = None\n-        if hasattr(orig_exc, \'lineno\'):\n+        if hasattr(orig_exc, "lineno"):\n             lineno = orig_exc.lineno\n         elif element is not None:\n-            lineno = getattr(element, \'sourceline\', \'unknown\')\n-        if fname or lineno != \'unknown\':\n-            msg += \'\\n  File "%s", line %s\' % (fname or \'<unknown>\', lineno)\n+            lineno = getattr(element, "sourceline", "unknown")\n+        if fname or lineno != "unknown":\n+            msg += \'\\n  File "{}", line {}\'.format(fname or "<unknown>", lineno)\n         if fname and lineno:\n             line = linecache.getline(fname, lineno).strip()\n-            msg += \'\\n    %s\' % line\n-        msg += \'\\n\'\n-        msg += \'\'.join(traceback.format_tb(tb))\n-        msg += \'\\n\'\n+            msg += "\\n    %s" % line\n+        msg += "\\n"\n+        msg += "".join(traceback.format_tb(tb))\n+        msg += "\\n"\n         self.args = [msg]\n \n \n # Helper adapters\n @implementer(ISchemaPolicy)\n-class DefaultSchemaPolicy(object):\n-\n+class DefaultSchemaPolicy:\n     def module(self, schemaName, tree):\n-        return \'plone.supermodel.generated\'\n+        return "plone.supermodel.generated"\n \n     def bases(self, schemaName, tree):\n         return ()\n@@ -63,9 +59,9 @@ def name(self, schemaName, tree):\n \n \n # Algorithm\n-def parse(source, policy=u""):\n+def parse(source, policy=""):\n     fname = None\n-    if isinstance(source, six.string_types):\n+    if isinstance(source, str):\n         fname = source\n \n     try:\n@@ -75,8 +71,7 @@ def parse(source, policy=u""):\n         # the filename and line number of the element that caused the problem.\n         # Keep the original traceback so the developer can debug where the\n         # problem happened.\n-        raise SupermodelParseError(\n-            e, fname, parseinfo.stack[-1], sys.exc_info()[2])\n+        raise SupermodelParseError(e, fname, parseinfo.stack[-1], sys.exc_info()[2])\n \n \n def _parse(source, policy):\n@@ -87,9 +82,7 @@ def _parse(source, policy):\n     tree = etree.parse(source, parser=parser)\n     root = tree.getroot()\n \n-    parseinfo.i18n_domain = root.attrib.get(\n-        ns(\'domain\', prefix=I18N_NAMESPACE)\n-    )\n+    parseinfo.i18n_domain = root.attrib.get(ns("domain", prefix=I18N_NAMESPACE))\n \n     model = Model()\n \n@@ -102,25 +95,24 @@ def _parse(source, policy):\n     def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n \n         # Parse field attributes\n-        fieldName = fieldElement.get(\'name\')\n-        fieldType = fieldElement.get(\'type\')\n+        fieldName = fieldElement.get("name")\n+        fieldType = fieldElement.get("type")\n \n         if fieldName is None or fieldType is None:\n             raise ValueError(\n-                \'The attributes \\\'name\\\' and \\\'type\\\' are required for each \'\n-                \'<field /> element\'\n+                "The attributes \'name\' and \'type\' are required for each "\n+                "<field /> element"\n             )\n \n         handler = handlers.get(fieldType)\n         if handler is None:\n             handler = handlers[fieldType] = queryUtility(\n-                IFieldExportImportHandler,\n-                name=fieldType\n+                IFieldExportImportHandler, name=fieldType\n             )\n             if handler is None:\n                 raise ValueError(\n-                    \'Field type {0} specified for field {1} is not \'\n-                    \'supported\'.format(fieldType, fieldName)\n+                    "Field type {} specified for field {} is not "\n+                    "supported".format(fieldType, fieldName)\n                 )\n \n         field = handler.read(fieldElement)\n@@ -137,17 +129,17 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n \n         return fieldName\n \n-    for schema_element in root.findall(ns(\'schema\')):\n+    for schema_element in root.findall(ns("schema")):\n         parseinfo.stack.append(schema_element)\n         schemaAttributes = {}\n \n-        schemaName = schema_element.get(\'name\')\n+        schemaName = schema_element.get("name")\n         if schemaName is None:\n-            schemaName = u""\n+            schemaName = ""\n \n         bases = ()\n         baseFields = {}\n-        based_on = schema_element.get(\'based-on\')\n+        based_on = schema_element.get("based-on")\n         if based_on is not None:\n             bases = tuple([resolve(dotted) for dotted in based_on.split()])\n             for base_schema in bases:\n@@ -156,14 +148,9 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n         fieldElements = {}\n \n         # Read global fields\n-        for fieldElement in schema_element.findall(ns(\'field\')):\n+        for fieldElement in schema_element.findall(ns("field")):\n             parseinfo.stack.append(fieldElement)\n-            readField(\n-                fieldElement,\n-                schemaAttributes,\n-                fieldElements,\n-                baseFields\n-            )\n+            readField(fieldElement, schemaAttributes, fieldElements, baseFields)\n             parseinfo.stack.pop()\n \n         # Read invariants, fieldsets and their fields\n@@ -174,32 +161,23 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n         for subelement in schema_element:\n             parseinfo.stack.append(subelement)\n \n-            if subelement.tag == ns(\'field\'):\n-                readField(\n-                    subelement,\n-                    schemaAttributes,\n-                    fieldElements,\n-                    baseFields\n-                )\n+            if subelement.tag == ns("field"):\n+                readField(subelement, schemaAttributes, fieldElements, baseFields)\n \n-            elif subelement.tag == ns(\'fieldset\'):\n+            elif subelement.tag == ns("fieldset"):\n \n-                fieldset_name = subelement.get(\'name\')\n+                fieldset_name = subelement.get("name")\n                 if fieldset_name is None:\n-                    raise ValueError(\n-                        u\'Fieldset in schema {0} has no name\'.format(\n-                            schemaName\n-                        )\n-                    )\n+                    raise ValueError(f"Fieldset in schema {schemaName} has no name")\n \n                 fieldset = fieldsets_by_name.get(fieldset_name)\n                 if fieldset is None:\n-                    fieldset_label = subelement.get(\'label\')\n-                    fieldset_description = subelement.get(\'description\')\n-                    fieldset_order = subelement.get(\'order\')\n+                    fieldset_label = subelement.get("label")\n+                    fieldset_description = subelement.get("description")\n+                    fieldset_order = subelement.get("order")\n                     if fieldset_order is None:\n                         fieldset_order = DEFAULT_ORDER\n-                    elif isinstance(fieldset_order, six.string_types):\n+                    elif isinstance(fieldset_order, str):\n                         fieldset_order = int(fieldset_order)\n                     fieldset = fieldsets_by_name[fieldset_name] = Fieldset(\n                         fieldset_name,\n@@ -210,25 +188,22 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                     fieldsets_by_name[fieldset_name] = fieldset\n                     fieldsets.append(fieldset)\n \n-                for fieldElement in subelement.findall(ns(\'field\')):\n+                for fieldElement in subelement.findall(ns("field")):\n                     parseinfo.stack.append(fieldElement)\n                     parsed_fieldName = readField(\n-                        fieldElement,\n-                        schemaAttributes,\n-                        fieldElements,\n-                        baseFields\n+                        fieldElement, schemaAttributes, fieldElements, baseFields\n                     )\n                     if parsed_fieldName:\n                         fieldset.fields.append(parsed_fieldName)\n                     parseinfo.stack.pop()\n \n-            elif subelement.tag == ns(\'invariant\'):\n+            elif subelement.tag == ns("invariant"):\n                 dotted = subelement.text\n                 invariant = resolve(dotted)\n                 if not IInvariant.providedBy(invariant):\n                     raise ImportError(\n-                        u\'Invariant functions must provide \'\n-                        u\'plone.supermodel.interfaces.IInvariant\'\n+                        "Invariant functions must provide "\n+                        "plone.supermodel.interfaces.IInvariant"\n                     )\n                 invariants.append(invariant)\n             parseinfo.stack.pop()\n@@ -237,13 +212,13 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n             name=policy_util.name(schemaName, tree),\n             bases=bases + policy_util.bases(schemaName, tree) + (Schema,),\n             __module__=policy_util.module(schemaName, tree),\n-            attrs=schemaAttributes\n+            attrs=schemaAttributes,\n         )\n \n         # add invariants to schema as tagged values\n         if invariants:\n-            schema_invariants = schema.queryTaggedValue(\'invariants\', [])\n-            schema.setTaggedValue(\'invariants\', schema_invariants + invariants)\n+            schema_invariants = schema.queryTaggedValue("invariants", [])\n+            schema.setTaggedValue("invariants", schema_invariants + invariants)\n \n         # Save fieldsets\n         schema.setTaggedValue(FIELDSETS_KEY, fieldsets)\n@@ -253,9 +228,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n             for fieldName in schema:\n                 if fieldName in fieldElements:\n                     metadata_handler.read(\n-                        fieldElements[fieldName],\n-                        schema,\n-                        schema[fieldName]\n+                        fieldElements[fieldName], schema, schema[fieldName]\n                     )\n \n         for handler_name, metadata_handler in schema_metadata_handlers:\n@@ -268,4 +241,4 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n     return model\n \n \n-__all__ = (\'parse\', )\n+__all__ = ("parse",)\ndiff --git a/plone/supermodel/patches.py b/plone/supermodel/patches.py\nindex 785f19e..3d01449 100644\n--- a/plone/supermodel/patches.py\n+++ b/plone/supermodel/patches.py\n@@ -1,15 +1,14 @@\n-# -*- coding: utf-8 -*-\n import zope.interface\n import zope.schema\n import zope.schema.interfaces\n \n \n class IDottedName(zope.interface.Interface):\n-    """A dotted name identifier.\n-    """\n+    """A dotted name identifier."""\n+\n+    min_dots = zope.schema.Int(title="Minimum number of dots", min=0, required=False)\n+    max_dots = zope.schema.Int(title="Maximum number of dots", min=0, required=False)\n \n-    min_dots = zope.schema.Int(title=u"Minimum number of dots", min=0, required=False)\n-    max_dots = zope.schema.Int(title=u"Maximum number of dots", min=0, required=False)\n \n # XXX: zope.schema omits these two interface declarations. We add them here\n # so that our parsers work.\ndiff --git a/plone/supermodel/schema.rst b/plone/supermodel/schema.rst\nindex bcf9e48..7cc8620 100644\n--- a/plone/supermodel/schema.rst\n+++ b/plone/supermodel/schema.rst\n@@ -167,7 +167,7 @@ directory.\n     >>> tmpdir = tempfile.mkdtemp()\n     >>> schema_filename = os.path.join(tmpdir, \'schema.xml\')\n     >>> with open(schema_filename, \'w\') as fd:\n-    ...     _ = fd.write(schema)  # On Py3 write resturns the schema len\n+    ...     _ = fd.write(schema)  # On Py3 write returns the schema len\n \n We can define interfaces from this using a helper function:\n \ndiff --git a/plone/supermodel/serializer.py b/plone/supermodel/serializer.py\nindex cb91a3e..2212515 100644\n--- a/plone/supermodel/serializer.py\n+++ b/plone/supermodel/serializer.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from lxml import etree\n from plone.supermodel.interfaces import FIELDSETS_KEY\n from plone.supermodel.interfaces import I18N_NAMESPACE\n@@ -20,9 +19,8 @@\n \n @implementer(IFieldNameExtractor)\n @adapter(IField)\n-class DefaultFieldNameExtractor(object):\n-    """Extract a name\n-    """\n+class DefaultFieldNameExtractor:\n+    """Extract a name"""\n \n     def __init__(self, context):\n         self.context = context\n@@ -33,12 +31,12 @@ def __call__(self):\n         # workaround for the fact that some fields are defined in one\n         # module, but commonly used from zope.schema.*\n \n-        if field_module.startswith(\'zope.schema._bootstrapfields\'):\n+        if field_module.startswith("zope.schema._bootstrapfields"):\n             field_module = field_module.replace("._bootstrapfields", "")\n-        elif field_module.startswith(\'zope.schema._field\'):\n+        elif field_module.startswith("zope.schema._field"):\n             field_module = field_module.replace("._field", "")\n \n-        return "%s.%s" % (field_module, self.context.__class__.__name__)\n+        return f"{field_module}.{self.context.__class__.__name__}"\n \n \n # Algorithm\n@@ -50,23 +48,27 @@ def serialize(model):\n     schema_metadata_handlers = tuple(getUtilitiesFor(ISchemaMetadataHandler))\n     field_metadata_handlers = tuple(getUtilitiesFor(IFieldMetadataHandler))\n \n-    nsmap = {\'i18n\': I18N_NAMESPACE}\n+    nsmap = {"i18n": I18N_NAMESPACE}\n     for name, handler in schema_metadata_handlers + field_metadata_handlers:\n         namespace, prefix = handler.namespace, handler.prefix\n         if namespace is not None and prefix is not None:\n             nsmap[prefix] = namespace\n \n-    xml = etree.Element(\'model\', nsmap=nsmap)\n-    xml.set(\'xmlns\', XML_NAMESPACE)\n+    xml = etree.Element("model", nsmap=nsmap)\n+    xml.set("xmlns", XML_NAMESPACE)\n \n     def writeField(field, parentElement):\n         name_extractor = IFieldNameExtractor(field)\n         fieldType = name_extractor()\n         handler = handlers.get(fieldType, None)\n         if handler is None:\n-            handler = handlers[fieldType] = queryUtility(IFieldExportImportHandler, name=fieldType)\n+            handler = handlers[fieldType] = queryUtility(\n+                IFieldExportImportHandler, name=fieldType\n+            )\n             if handler is None:\n-                raise ValueError("Field type %s specified for field %s is not supported" % (fieldType, fieldName))\n+                raise ValueError(\n+                    f"Field type {fieldType} specified for field {fieldName} is not supported"\n+                )\n         fieldElement = handler.write(field, fieldName, fieldType)\n         if fieldElement is not None:\n             parentElement.append(fieldElement)\n@@ -82,20 +84,21 @@ def writeField(field, parentElement):\n         for fieldset in fieldsets:\n             fieldset_fields.update(fieldset.fields)\n \n-        non_fieldset_fields = [name for name, field in sortedFields(schema)\n-                                if name not in fieldset_fields]\n+        non_fieldset_fields = [\n+            name for name, field in sortedFields(schema) if name not in fieldset_fields\n+        ]\n \n-        schema_element = etree.Element(\'schema\')\n+        schema_element = etree.Element("schema")\n         if schemaName:\n-            schema_element.set(\'name\', schemaName)\n+            schema_element.set("name", schemaName)\n \n         bases = [b.__identifier__ for b in schema.__bases__ if b is not Schema]\n         if bases:\n-            schema_element.set(\'based-on\', \' \'.join(bases))\n+            schema_element.set("based-on", " ".join(bases))\n \n-        for invariant in schema.queryTaggedValue(\'invariants\', []):\n-            invariant_element = etree.Element(\'invariant\')\n-            invariant_element.text = "%s.%s" % (invariant.__module__, invariant.__name__)\n+        for invariant in schema.queryTaggedValue("invariants", []):\n+            invariant_element = etree.Element("invariant")\n+            invariant_element.text = f"{invariant.__module__}.{invariant.__name__}"\n             schema_element.append(invariant_element)\n \n         for fieldName in non_fieldset_fields:\n@@ -104,12 +107,12 @@ def writeField(field, parentElement):\n \n         for fieldset in fieldsets:\n \n-            fieldset_element = etree.Element(\'fieldset\')\n-            fieldset_element.set(\'name\', fieldset.__name__)\n+            fieldset_element = etree.Element("fieldset")\n+            fieldset_element.set("name", fieldset.__name__)\n             if fieldset.label:\n-                fieldset_element.set(\'label\', fieldset.label)\n+                fieldset_element.set("label", fieldset.label)\n             if fieldset.description:\n-                fieldset_element.set(\'description\', fieldset.description)\n+                fieldset_element.set("description", fieldset.description)\n \n             for fieldName in fieldset.fields:\n                 field = schema[fieldName]\n@@ -123,17 +126,17 @@ def writeField(field, parentElement):\n         xml.append(schema_element)\n \n     # handle i18n\n-    i18n_domain = xml.get(ns(\'domain\', prefix=I18N_NAMESPACE))\n-    for node in xml.xpath(\'//*[@i18n:translate]\', namespaces=nsmap):\n-        domain = node.get(ns(\'domain\', prefix=I18N_NAMESPACE), i18n_domain)\n+    i18n_domain = xml.get(ns("domain", prefix=I18N_NAMESPACE))\n+    for node in xml.xpath("//*[@i18n:translate]", namespaces=nsmap):\n+        domain = node.get(ns("domain", prefix=I18N_NAMESPACE), i18n_domain)\n         if i18n_domain is None:\n             i18n_domain = domain\n         if domain == i18n_domain:\n-            node.attrib.pop(ns(\'domain\', prefix=I18N_NAMESPACE))\n+            node.attrib.pop(ns("domain", prefix=I18N_NAMESPACE))\n     if i18n_domain:\n-        xml.set(ns(\'domain\', prefix=I18N_NAMESPACE), i18n_domain)\n+        xml.set(ns("domain", prefix=I18N_NAMESPACE), i18n_domain)\n \n     return prettyXML(xml)\n \n \n-__all__ = (\'serialize\', )\n+__all__ = ("serialize",)\ndiff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py\nindex ccd45d8..f7cd954 100644\n--- a/plone/supermodel/tests.py\n+++ b/plone/supermodel/tests.py\n@@ -1,11 +1,10 @@\n-# -*- coding: utf-8 -*-\n+from io import BytesIO\n+from io import StringIO\n from lxml import etree\n from plone.supermodel import utils\n from plone.supermodel.exportimport import ChoiceHandler\n from plone.supermodel.interfaces import IDefaultFactory\n from plone.supermodel.interfaces import IInvariant\n-from six import BytesIO\n-from six import StringIO\n from zope import schema\n from zope.interface import alsoProvides\n from zope.interface import implementer\n@@ -27,7 +26,7 @@\n \n def configure():\n     zope.component.testing.setUp()\n-    configuration = u"""\\\n+    configuration = """\\\n     <configure\n          xmlns="http://namespaces.zope.org/zope"\n          i18n_domain="plone.supermodel.tests">\n@@ -39,62 +38,62 @@ def configure():\n     </configure>\n     """\n     from zope.configuration import xmlconfig\n+\n     xmlconfig.xmlconfig(StringIO(configuration))\n \n \n class IBase(Interface):\n-    title = schema.TextLine(title=u"Title")\n-    description = schema.TextLine(title=u"Description")\n-    name = schema.TextLine(title=u"Name")\n+    title = schema.TextLine(title="Title")\n+    description = schema.TextLine(title="Description")\n+    name = schema.TextLine(title="Name")\n+\n \n # Used in fields.txt\n \n \n class IDummy(Interface):\n-    title = schema.TextLine(title=u"Title")\n+    title = schema.TextLine(title="Title")\n \n \n @implementer(IDummy)\n-class Dummy(object):\n-\n+class Dummy:\n     def __init__(self):\n-        self.title = u\'\'\n+        self.title = ""\n \n \n dummy1 = Dummy()\n \n \n @implementer(IContextSourceBinder)\n-class Binder(object):\n-\n+class Binder:\n     def __init__(self):\n         pass\n \n     def __call__(self, context):\n-        return SimpleVocabulary.fromValues([\'a\', \'d\', \'f\'])\n+        return SimpleVocabulary.fromValues(["a", "d", "f"])\n \n \n dummy_binder = Binder()\n-dummy_vocabulary_instance = SimpleVocabulary.fromItems([(1, \'a\'), (2, \'c\')])\n+dummy_vocabulary_instance = SimpleVocabulary.fromItems([(1, "a"), (2, "c")])\n \n \n @provider(IContextAwareDefaultFactory)\n def dummy_defaultCAFactory(context):\n-    return u\'b\'\n+    return "b"\n \n \n @provider(IDefaultFactory)\n def dummy_defaultFactory():\n-    return u\'b\'\n+    return "b"\n \n \n def dummy_defaultBadFactory():\n-    return u\'b\'\n+    return "b"\n \n \n @provider(IInvariant)\n def dummy_invariant(data):\n-    raise Invalid(u"Yikes! Invalid")\n+    raise Invalid("Yikes! Invalid")\n \n \n @provider(IInvariant)\n@@ -103,21 +102,19 @@ def dummy_invariant_prime(data):\n \n \n def dummy_unmarkedInvariant(data):\n-    """ lacks IInvariant marker """\n+    """lacks IInvariant marker"""\n     return None\n \n \n class TestUtils(unittest.TestCase):\n-\n     def test_syncSchema(self):\n-\n         class ISource(Interface):\n-            one = schema.TextLine(title=u"A")  # order: 0\n-            two = schema.Int(title=u"B")       # order: 1\n+            one = schema.TextLine(title="A")  # order: 0\n+            two = schema.Int(title="B")  # order: 1\n \n         class IDest(Interface):\n-            one = schema.TextLine(title=u"C")  # order: 0\n-            three = schema.Int(title=u"D")     # order: 1\n+            one = schema.TextLine(title="C")  # order: 0\n+            three = schema.Int(title="D")  # order: 1\n \n         ISource.setTaggedValue("tag1", "tag one")\n         ISource.setTaggedValue("tag2", "tag two")\n@@ -125,23 +122,22 @@ class IDest(Interface):\n \n         utils.syncSchema(ISource, IDest)\n \n-        self.assertEqual(u"C", IDest[\'one\'].title)\n+        self.assertEqual("C", IDest["one"].title)\n \n-        self.assertEqual([\'one\', \'two\'], getFieldNamesInOrder(ISource))\n-        self.assertEqual([\'two\', \'one\', \'three\'], getFieldNamesInOrder(IDest))\n+        self.assertEqual(["one", "two"], getFieldNamesInOrder(ISource))\n+        self.assertEqual(["two", "one", "three"], getFieldNamesInOrder(IDest))\n \n         self.assertEqual("first tag", IDest.getTaggedValue("tag1"))\n         self.assertEqual("tag two", IDest.getTaggedValue("tag2"))\n \n     def test_syncSchema_overwrite(self):\n-\n         class ISource(Interface):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n \n         class IDest(Interface):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         ISource.setTaggedValue("tag1", "tag one")\n         ISource.setTaggedValue("tag2", "tag two")\n@@ -149,159 +145,167 @@ class IDest(Interface):\n \n         utils.syncSchema(ISource, IDest, overwrite=True)\n \n-        self.assertEqual(u"A", IDest[\'one\'].title)\n+        self.assertEqual("A", IDest["one"].title)\n \n-        self.assertEqual([\'one\', \'two\'], getFieldNamesInOrder(ISource))\n-        self.assertEqual([\'one\', \'two\'], getFieldNamesInOrder(IDest))\n+        self.assertEqual(["one", "two"], getFieldNamesInOrder(ISource))\n+        self.assertEqual(["one", "two"], getFieldNamesInOrder(IDest))\n \n         self.assertEqual("tag one", IDest.getTaggedValue("tag1"))\n         self.assertEqual("tag two", IDest.getTaggedValue("tag2"))\n \n     def test_syncSchema_overwrite_no_bases(self):\n-\n         class IBase(Interface):\n-            base = schema.TextLine(title=u"Base")\n+            base = schema.TextLine(title="Base")\n \n         class ISource(IBase):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n \n         class IDest(Interface):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         utils.syncSchema(ISource, IDest, overwrite=False, sync_bases=False)\n \n-        self.assertEqual((Interface, ), IDest.__bases__)\n-        self.assertEqual([\'two\', \'one\', \'three\'], getFieldNamesInOrder(IDest))\n+        self.assertEqual((Interface,), IDest.__bases__)\n+        self.assertEqual(["two", "one", "three"], getFieldNamesInOrder(IDest))\n \n     def test_syncSchema_overwrite_with_bases(self):\n-\n         class IBase(Interface):\n-            base = schema.TextLine(title=u"Base")\n+            base = schema.TextLine(title="Base")\n \n         class IOtherBase(Interface):\n-            foo = schema.TextLine(title=u"Foo")\n+            foo = schema.TextLine(title="Foo")\n \n         class ISource(IBase):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n \n         class IDest(IOtherBase):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         utils.syncSchema(ISource, IDest, overwrite=True, sync_bases=True)\n \n-        self.assertEqual((IBase, ), IDest.__bases__)\n-        self.assertEqual([\'base\', \'one\', \'two\'], getFieldNamesInOrder(IDest))\n+        self.assertEqual((IBase,), IDest.__bases__)\n+        self.assertEqual(["base", "one", "two"], getFieldNamesInOrder(IDest))\n \n     def test_syncSchema_overwrite_with_bases_and_no_overwrite(self):\n-\n         class IBase(Interface):\n-            base = schema.TextLine(title=u"Base")\n+            base = schema.TextLine(title="Base")\n \n         class IOtherBase(Interface):\n-            foo = schema.TextLine(title=u"Foo")\n+            foo = schema.TextLine(title="Foo")\n \n         class ISource(IBase):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n \n         class IDest(IOtherBase):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         utils.syncSchema(ISource, IDest, overwrite=False, sync_bases=True)\n \n-        self.assertEqual((IBase, IOtherBase, ), IDest.__bases__)\n-        self.assertEqual([\'base\', \'foo\', \'two\', \'one\', \'three\'], getFieldNamesInOrder(IDest))\n+        self.assertEqual(\n+            (\n+                IBase,\n+                IOtherBase,\n+            ),\n+            IDest.__bases__,\n+        )\n+        self.assertEqual(\n+            ["base", "foo", "two", "one", "three"], getFieldNamesInOrder(IDest)\n+        )\n \n     def test_syncSchema_overwrite_with_bases_and_no_overwrite_with_old_bases(self):\n-\n         class IBase(Interface):\n-            base = schema.TextLine(title=u"Base")\n+            base = schema.TextLine(title="Base")\n \n         class IOtherBase(Interface):\n-            foo = schema.TextLine(title=u"Foo")\n+            foo = schema.TextLine(title="Foo")\n \n         class ISource(IBase):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n \n         class IDest(IOtherBase, IBase):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         utils.syncSchema(ISource, IDest, overwrite=False, sync_bases=True)\n \n-        self.assertEqual((IBase, IOtherBase, ), IDest.__bases__)\n-        self.assertEqual([\'base\', \'foo\', \'two\', \'one\', \'three\'], getFieldNamesInOrder(IDest))\n+        self.assertEqual(\n+            (\n+                IBase,\n+                IOtherBase,\n+            ),\n+            IDest.__bases__,\n+        )\n+        self.assertEqual(\n+            ["base", "foo", "two", "one", "three"], getFieldNamesInOrder(IDest)\n+        )\n \n     def test_syncSchema_with_markers_no_overwrite(self):\n-\n         class IMarker(Interface):\n             pass\n \n         class ISource(Interface):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n-            four = schema.Text(title=u"C")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n+            four = schema.Text(title="C")\n \n-        alsoProvides(ISource[\'one\'], IMarker)\n-        alsoProvides(ISource[\'four\'], IMarker)\n+        alsoProvides(ISource["one"], IMarker)\n+        alsoProvides(ISource["four"], IMarker)\n \n         class IDest(Interface):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         utils.syncSchema(ISource, IDest)\n \n-        self.assertFalse(IMarker.providedBy(IDest[\'one\']))\n-        self.assertFalse(IMarker.providedBy(IDest[\'two\']))\n-        self.assertFalse(IMarker.providedBy(IDest[\'three\']))\n-        self.assertTrue(IMarker.providedBy(IDest[\'four\']))\n+        self.assertFalse(IMarker.providedBy(IDest["one"]))\n+        self.assertFalse(IMarker.providedBy(IDest["two"]))\n+        self.assertFalse(IMarker.providedBy(IDest["three"]))\n+        self.assertTrue(IMarker.providedBy(IDest["four"]))\n \n     def test_syncSchema_with_markers_overwrite(self):\n-\n         class IMarker(Interface):\n             pass\n \n         class ISource(Interface):\n-            one = schema.TextLine(title=u"A")\n-            two = schema.Int(title=u"B")\n-            four = schema.Text(title=u"C")\n+            one = schema.TextLine(title="A")\n+            two = schema.Int(title="B")\n+            four = schema.Text(title="C")\n \n-        alsoProvides(ISource[\'one\'], IMarker)\n-        alsoProvides(ISource[\'four\'], IMarker)\n+        alsoProvides(ISource["one"], IMarker)\n+        alsoProvides(ISource["four"], IMarker)\n \n         class IDest(Interface):\n-            one = schema.TextLine(title=u"C")\n-            three = schema.Int(title=u"D")\n+            one = schema.TextLine(title="C")\n+            three = schema.Int(title="D")\n \n         utils.syncSchema(ISource, IDest, overwrite=True)\n \n-        self.assertTrue(IMarker.providedBy(IDest[\'one\']))\n-        self.assertFalse(IMarker.providedBy(IDest[\'two\']))\n-        self.assertTrue(IMarker.providedBy(IDest[\'four\']))\n+        self.assertTrue(IMarker.providedBy(IDest["one"]))\n+        self.assertFalse(IMarker.providedBy(IDest["two"]))\n+        self.assertTrue(IMarker.providedBy(IDest["four"]))\n \n     def test_syncSchema_always_overwrites_fields_from_bases(self):\n-\n         class IBase(Interface):\n-            one = schema.TextLine(title=u\'A\')\n+            one = schema.TextLine(title="A")\n \n         class ISource(Interface):\n-            one = schema.TextLine(title=u\'B\')\n+            one = schema.TextLine(title="B")\n \n         class IDest(IBase):\n             pass\n \n         utils.syncSchema(ISource, IDest, overwrite=False)\n \n-        self.assertTrue(IDest[\'one\'].interface is IDest)\n+        self.assertTrue(IDest["one"].interface is IDest)\n \n     def test_mergedTaggedValueList(self):\n-\n         class IBase1(Interface):\n             pass\n \n@@ -314,14 +318,15 @@ class IBase3(Interface):\n         class ISchema(IBase1, IBase2, IBase3):\n             pass\n \n-        IBase1.setTaggedValue(u"foo", [1, 2])  # more specific than IBase2 and IBase3\n-        IBase3.setTaggedValue(u"foo", [3, 4])  # least specific of the bases\n-        ISchema.setTaggedValue(u"foo", [4, 5])  # most specific\n+        IBase1.setTaggedValue("foo", [1, 2])  # more specific than IBase2 and IBase3\n+        IBase3.setTaggedValue("foo", [3, 4])  # least specific of the bases\n+        ISchema.setTaggedValue("foo", [4, 5])  # most specific\n \n-        self.assertEqual([3, 4, 1, 2, 4, 5], utils.mergedTaggedValueList(ISchema, u"foo"))\n+        self.assertEqual(\n+            [3, 4, 1, 2, 4, 5], utils.mergedTaggedValueList(ISchema, "foo")\n+        )\n \n     def test_mergedTaggedValueDict(self):\n-\n         class IBase1(Interface):\n             pass\n \n@@ -334,22 +339,25 @@ class IBase3(Interface):\n         class ISchema(IBase1, IBase2, IBase3):\n             pass\n \n-        IBase1.setTaggedValue(u"foo", {1: 1, 2: 1})      # more specific than IBase2 and IBase3\n-        IBase3.setTaggedValue(u"foo", {3: 3, 2: 3, 4: 3})  # least specific of the bases\n-        ISchema.setTaggedValue(u"foo", {4: 4, 5: 4})      # most specific\n+        IBase1.setTaggedValue(\n+            "foo", {1: 1, 2: 1}\n+        )  # more specific than IBase2 and IBase3\n+        IBase3.setTaggedValue("foo", {3: 3, 2: 3, 4: 3})  # least specific of the bases\n+        ISchema.setTaggedValue("foo", {4: 4, 5: 4})  # most specific\n \n-        self.assertEqual({1: 1, 2: 1, 3: 3, 4: 4, 5: 4}, utils.mergedTaggedValueDict(ISchema, u"foo"))\n+        self.assertEqual(\n+            {1: 1, 2: 1, 3: 3, 4: 4, 5: 4}, utils.mergedTaggedValueDict(ISchema, "foo")\n+        )\n \n \n class TestValueToElement(unittest.TestCase):\n-\n     def setUp(self):\n         configure()\n \n     tearDown = zope.component.testing.tearDown\n \n     def _assertSerialized(self, field, value, expected):\n-        element = utils.valueToElement(field, value, b\'value\')\n+        element = utils.valueToElement(field, value, b"value")\n         sio = StringIO() if six.PY2 else BytesIO()\n         etree.ElementTree(element).write(sio)\n         self.assertEqual(sio.getvalue(), expected)\n@@ -359,177 +367,195 @@ def _assertSerialized(self, field, value, expected):\n     def test_lists(self):\n         field = schema.List(value_type=schema.Int())\n         value = []\n-        self._assertSerialized(field, value, b\'<value/>\')\n+        self._assertSerialized(field, value, b"<value/>")\n         value = [1, 2]\n         self._assertSerialized(\n-            field, value,\n-            b\'<value>\'\n-            b\'<element>1</element>\'\n-            b\'<element>2</element>\'\n-            b\'</value>\'\n+            field,\n+            value,\n+            b"<value>" b"<element>1</element>" b"<element>2</element>" b"</value>",\n         )\n \n     def test_sets(self):\n-        field = schema.Set(value_type=schema.Int(),\n+        field = schema.Set(\n+            value_type=schema.Int(),\n         )\n-        value = set([])\n-        self._assertSerialized(field, value, b\'<value/>\')\n-        value = set([3, 4, 2, 1])\n+        value = set()\n+        self._assertSerialized(field, value, b"<value/>")\n+        value = {3, 4, 2, 1}\n         # Sets should be sorted to ensure nice diffs\n         self._assertSerialized(\n-            field, value,\n-            b\'<value>\'\n-            b\'<element>1</element>\'\n-            b\'<element>2</element>\'\n-            b\'<element>3</element>\'\n-            b\'<element>4</element>\'\n-            b\'</value>\'\n+            field,\n+            value,\n+            b"<value>"\n+            b"<element>1</element>"\n+            b"<element>2</element>"\n+            b"<element>3</element>"\n+            b"<element>4</element>"\n+            b"</value>",\n         )\n \n-        field = schema.Set(value_type=schema.Choice([\'a\',\'b\',\'c\']),)\n-        value = set([\'b\', \'a\'])\n+        field = schema.Set(\n+            value_type=schema.Choice(["a", "b", "c"]),\n+        )\n+        value = {"b", "a"}\n         # Sets should be sorted to ensure nice diffs\n         self._assertSerialized(\n-            field, value,\n-            b\'<value>\'\n-            b\'<element>a</element>\'\n-            b\'<element>b</element>\'\n-            b\'</value>\'\n+            field,\n+            value,\n+            b"<value>" b"<element>a</element>" b"<element>b</element>" b"</value>",\n         )\n \n     def test_nested_lists(self):\n         field = schema.List(value_type=schema.List(value_type=schema.Int()))\n         value = []\n-        self._assertSerialized(field, value, b\'<value/>\')\n+        self._assertSerialized(field, value, b"<value/>")\n         value = [[1], [1, 2], []]\n-        self._assertSerialized(field, value,\n-            b\'<value>\'\n-            b\'<element><element>1</element></element>\'\n-            b\'<element><element>1</element><element>2</element></element>\'\n-            b\'<element/>\'\n-            b\'</value>\'\n+        self._assertSerialized(\n+            field,\n+            value,\n+            b"<value>"\n+            b"<element><element>1</element></element>"\n+            b"<element><element>1</element><element>2</element></element>"\n+            b"<element/>"\n+            b"</value>",\n         )\n \n     def test_dicts(self):\n         field = schema.Dict(key_type=schema.Int(), value_type=schema.TextLine())\n         value = {}\n-        self._assertSerialized(field, value, b\'<value/>\')\n-        value = {1: \'one\', 2: \'two\'}\n-        self._assertSerialized(field, value,\n-            b\'<value>\'\n+        self._assertSerialized(field, value, b"<value/>")\n+        value = {1: "one", 2: "two"}\n+        self._assertSerialized(\n+            field,\n+            value,\n+            b"<value>"\n             b\'<element key="1">one</element>\'\n             b\'<element key="2">two</element>\'\n-            b\'</value>\'\n+            b"</value>",\n         )\n \n     def test_nested_dicts(self):\n-        field = schema.Dict(key_type=schema.Int(),\n+        field = schema.Dict(\n+            key_type=schema.Int(),\n             value_type=schema.Dict(\n                 key_type=schema.Int(),\n                 value_type=schema.TextLine(),\n             ),\n         )\n         value = {}\n-        self._assertSerialized(field, value, b\'<value/>\')\n-        value = {1: {2: \'two\'}, 3: {4: \'four\', 5: \'five\'}, 6: {}}\n-        self._assertSerialized(field, value,\n-            b\'<value>\'\n+        self._assertSerialized(field, value, b"<value/>")\n+        value = {1: {2: "two"}, 3: {4: "four", 5: "five"}, 6: {}}\n+        self._assertSerialized(\n+            field,\n+            value,\n+            b"<value>"\n             b\'<element key="1"><element key="2">two</element></element>\'\n             b\'<element key="3"><element key="4">four</element><element key="5">five</element></element>\'\n             b\'<element key="6"/>\'\n-            b\'</value>\'\n+            b"</value>",\n         )\n \n \n-\n-\n-\n class TestChoiceHandling(unittest.TestCase):\n-\n     def setUp(self):\n         configure()\n         self.handler = ChoiceHandler(schema.Choice)\n \n     def _choice(self):\n-        vocab = SimpleVocabulary(\n-            [SimpleTerm(t, title=t) for t in (u\'a\', u\'b\', u\'c\')]\n-            )\n-        expected = \'<field name="myfield" type="zope.schema.Choice">\'\\\n-            \'<values>\'\\\n-            \'<element>a</element><element>b</element><element>c</element>\'\\\n-            \'</values>\'\\\n-            \'</field>\'\n+        vocab = SimpleVocabulary([SimpleTerm(t, title=t) for t in ("a", "b", "c")])\n+        expected = (\n+            \'<field name="myfield" type="zope.schema.Choice">\'\n+            "<values>"\n+            "<element>a</element><element>b</element><element>c</element>"\n+            "</values>"\n+            "</field>"\n+        )\n         return (schema.Choice(vocabulary=vocab), expected)\n \n     def _choice_with_empty(self):\n         # add an empty string term to vocabulary\n-        vocab = SimpleVocabulary([SimpleTerm(t, title=t) for t in (u\'a\', u\'\')])\n-        expected = \'<field name="myfield" type="zope.schema.Choice">\'\\\n-            \'<values>\'\\\n-            \'<element>a</element>\'\\\n-            \'<element></element>\'\\\n-            \'</values>\'\\\n-            \'</field>\'\n+        vocab = SimpleVocabulary([SimpleTerm(t, title=t) for t in ("a", "")])\n+        expected = (\n+            \'<field name="myfield" type="zope.schema.Choice">\'\n+            "<values>"\n+            "<element>a</element>"\n+            "<element></element>"\n+            "</values>"\n+            "</field>"\n+        )\n         return (schema.Choice(vocabulary=vocab), expected)\n \n     def _choice_with_term_titles(self):\n         # two terms with distinct titles, one with same as value:\n         vocab = SimpleVocabulary(\n-            [SimpleTerm(t, title=t.upper()) for t in (u\'a\', u\'b\')] +\n-            [SimpleTerm(u\'c\', title=u\'c\')],\n-            )\n-        expected = \'<field name="myfield" type="zope.schema.Choice">\'\\\n-            \'<values>\'\\\n-            \'<element key="a">A</element>\'\\\n-            \'<element key="b">B</element>\'\\\n-            \'<element key="c">c</element>\'\\\n-            \'</values>\'\\\n-            \'</field>\'\n+            [SimpleTerm(t, title=t.upper()) for t in ("a", "b")]\n+            + [SimpleTerm("c", title="c")],\n+        )\n+        expected = (\n+            \'<field name="myfield" type="zope.schema.Choice">\'\n+            "<values>"\n+            \'<element key="a">A</element>\'\n+            \'<element key="b">B</element>\'\n+            \'<element key="c">c</element>\'\n+            "</values>"\n+            "</field>"\n+        )\n         return (schema.Choice(vocabulary=vocab), expected)\n \n     def _choice_with_term_titles_and_ns(self):\n         # two terms with distinct titles, one with same as value:\n         vocab = SimpleVocabulary(\n-            [SimpleTerm(t, title=t.upper()) for t in (u\'a\', u\'b\')] +\n-            [SimpleTerm(u\'c\', title=u\'c\')],\n-            )\n-        expected = \'<field name="myfield" type="zope.schema.Choice"\'\\\n-            \'      xmlns="http://namespaces.plone.org/supermodel/schema">\'\\\n-            \'<values>\'\\\n-            \'<element key="a">A</element>\'\\\n-            \'<element key="b">B</element>\'\\\n-            \'<element key="c">c</element>\'\\\n-            \'</values>\'\\\n-            \'</field>\'\n+            [SimpleTerm(t, title=t.upper()) for t in ("a", "b")]\n+            + [SimpleTerm("c", title="c")],\n+        )\n+        expected = (\n+            \'<field name="myfield" type="zope.schema.Choice"\'\n+            \'      xmlns="http://namespaces.plone.org/supermodel/schema">\'\n+            "<values>"\n+            \'<element key="a">A</element>\'\n+            \'<element key="b">B</element>\'\n+            \'<element key="c">c</element>\'\n+            "</values>"\n+            "</field>"\n+        )\n         return (schema.Choice(vocabulary=vocab), expected)\n \n     def _choice_with_integers(self):\n-        vocab = SimpleVocabulary([SimpleTerm(1, title=u\'One\')])\n-        expected = \'<field name="myfield" type="zope.schema.Choice">\'\\\n-            \'<values>\'\\\n-            \'<element key="1">One</element>\'\\\n-            \'</values>\'\\\n-            \'</field>\'\n+        vocab = SimpleVocabulary([SimpleTerm(1, title="One")])\n+        expected = (\n+            \'<field name="myfield" type="zope.schema.Choice">\'\n+            "<values>"\n+            \'<element key="1">One</element>\'\n+            "</values>"\n+            "</field>"\n+        )\n         return (schema.Choice(vocabulary=vocab), expected)\n \n     def test_choice_serialized(self):\n-        """ Tests a regular choice, one with empty string term in vocab,\n+        """Tests a regular choice, one with empty string term in vocab,\n         and another with terms that have titles\n         """\n         choice = self._choice()\n         choice_with_empty = self._choice_with_empty()\n         choice_with_term_titles = self._choice_with_term_titles()\n         choice_with_integers = self._choice_with_integers()\n-        for case in (choice, choice_with_empty, choice_with_term_titles, choice_with_integers):\n+        for case in (\n+            choice,\n+            choice_with_empty,\n+            choice_with_term_titles,\n+            choice_with_integers,\n+        ):\n             field, expected = case\n-            expected = six.binary_type(expected) if six.PY2 \\\n-                else six.binary_type(expected, encoding=\'latin-1\')\n-            el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-            self.assertEquals(etree.tostring(el), expected)\n+            expected = (\n+                bytes(expected) if six.PY2 else bytes(expected, encoding="latin-1")\n+            )\n+            el = self.handler.write(field, "myfield", "zope.schema.Choice")\n+            self.assertEqual(etree.tostring(el), expected)\n \n     def test_choice_parsing(self):\n         def _termvalues(vocab):\n             return tuple((t.value, t.title) for t in vocab)\n+\n         cases = (\n             self._choice(),\n             self._choice_with_empty(),\n@@ -547,62 +573,67 @@ def _termvalues(vocab):\n \n class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n-        if six.PY2:\n-            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n-        else:\n-            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n-            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n-            got = re.sub(\n-                \'plone.supermodel.parser.SupermodelParseError\',\n-                \'SupermodelParseError\', got)\n-            got = re.sub(\n-                \'zope.interface.exceptions.Invalid\',\n-                \'Invalid\', got)\n-            got = re.sub(\n-                "(Import|ModuleNotFound)Error: No module named "\n-                "\'plone.supermodel.tests.nonExistentFactory\'; "\n-                "\'plone.supermodel.tests\' is not a package",\n-                \'ImportError: No module named nonExistentFactory\', got)\n+        want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+        want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+        got = re.sub(\n+            "plone.supermodel.parser.SupermodelParseError", "SupermodelParseError", got\n+        )\n+        got = re.sub("zope.interface.exceptions.Invalid", "Invalid", got)\n+        got = re.sub(\n+            "(Import|ModuleNotFound)Error: No module named "\n+            "\'plone.supermodel.tests.nonExistentFactory\'; "\n+            "\'plone.supermodel.tests\' is not a package",\n+            "ImportError: No module named nonExistentFactory",\n+            got,\n+        )\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \n-optionflags = doctest.ELLIPSIS | \\\n-    doctest.REPORT_UDIFF | \\\n-    doctest.NORMALIZE_WHITESPACE | \\\n-    doctest.REPORT_ONLY_FIRST_FAILURE\n+optionflags = (\n+    doctest.ELLIPSIS\n+    | doctest.REPORT_UDIFF\n+    | doctest.NORMALIZE_WHITESPACE\n+    | doctest.REPORT_ONLY_FIRST_FAILURE\n+)\n \n \n def test_suite():\n-    return unittest.TestSuite((\n-        unittest.makeSuite(TestUtils),\n-        unittest.makeSuite(TestValueToElement),\n-        unittest.makeSuite(TestChoiceHandling),\n-        doctest.DocFileSuite(\n-            \'fields.rst\',\n-            setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown,\n-            optionflags=optionflags,\n-            checker=Py23DocChecker()),\n-        doctest.DocFileSuite(\n-            \'directives.rst\',\n-            setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown,\n-            optionflags=optionflags,\n-            checker=Py23DocChecker()),\n-        doctest.DocFileSuite(\n-            \'schema.rst\',\n-            setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown,\n-            optionflags=optionflags,\n-            checker=Py23DocChecker()),\n-        doctest.DocFileSuite(\n-            \'schemaclass.rst\',\n-            setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown,\n-            optionflags=optionflags,\n-            checker=Py23DocChecker()),\n-    ))\n-\n-\n-if __name__ == \'__main__\':\n-    unittest.main(default=\'test_suite\')\n+    return unittest.TestSuite(\n+        (\n+            unittest.defaultTestLoader.loadTestsFromTestCase(TestUtils),\n+            unittest.defaultTestLoader.loadTestsFromTestCase(TestValueToElement),\n+            unittest.defaultTestLoader.loadTestsFromTestCase(TestChoiceHandling),\n+            doctest.DocFileSuite(\n+                "fields.rst",\n+                setUp=zope.component.testing.setUp,\n+                tearDown=zope.component.testing.tearDown,\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n+            ),\n+            doctest.DocFileSuite(\n+                "directives.rst",\n+                setUp=zope.component.testing.setUp,\n+                tearDown=zope.component.testing.tearDown,\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n+            ),\n+            doctest.DocFileSuite(\n+                "schema.rst",\n+                setUp=zope.component.testing.setUp,\n+                tearDown=zope.component.testing.tearDown,\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n+            ),\n+            doctest.DocFileSuite(\n+                "schemaclass.rst",\n+                setUp=zope.component.testing.setUp,\n+                tearDown=zope.component.testing.tearDown,\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n+            ),\n+        )\n+    )\n+\n+\n+if __name__ == "__main__":\n+    unittest.main(default="test_suite")\ndiff --git a/plone/supermodel/utils.py b/plone/supermodel/utils.py\nindex c3b35a4..33caf63 100644\n--- a/plone/supermodel/utils.py\n+++ b/plone/supermodel/utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from collections import OrderedDict\n from lxml import etree\n from plone.supermodel.debug import parseinfo\n@@ -16,6 +15,7 @@\n from zope.schema.interfaces import IField\n from zope.schema.interfaces import IFromUnicode\n from zope.schema.interfaces import ISet\n+from zope.schema.interfaces import IVocabularyFactory\n \n import os.path\n import re\n@@ -24,34 +24,32 @@\n \n \n _marker = object()\n-noNS_re = re.compile(r\'^{\\S+}\')\n+noNS_re = re.compile(r"^{\\S+}")\n \n \n def ns(name, prefix=XML_NAMESPACE):\n-    """Return the element or attribute name with the given prefix\n-    """\n+    """Return the element or attribute name with the given prefix"""\n \n-    return u\'{%s}%s\' % (prefix, name)\n+    return f"{{{prefix}}}{name}"\n \n \n def noNS(name):\n-    """Return the tag with no namespace\n-    """\n-    return noNS_re.sub(\'\', name)\n+    """Return the tag with no namespace"""\n+    return noNS_re.sub("", name)\n \n \n def indent(node, level=0):\n \n     INDENT_SIZE = 2\n-    node_indent = level * (\' \' * INDENT_SIZE)\n-    child_indent = (level + 1) * (\' \' * INDENT_SIZE)\n+    node_indent = level * (" " * INDENT_SIZE)\n+    child_indent = (level + 1) * (" " * INDENT_SIZE)\n \n-    # node has childen\n+    # node has children\n     if len(node):\n \n         # add indent before first child node\n         if not node.text or not node.text.strip():\n-            node.text = \'\\n\' + child_indent\n+            node.text = "\\n" + child_indent\n \n         # let each child indent itself\n         last_idx = len(node) - 1\n@@ -61,11 +59,11 @@ def indent(node, level=0):\n             # add a tail for the next child node...\n             if idx != last_idx:\n                 if not child.tail or not child.tail.strip():\n-                    child.tail = \'\\n\' + child_indent\n+                    child.tail = "\\n" + child_indent\n             # ... or for the closing element of this node\n             else:\n                 if not child.tail or not child.tail.strip():\n-                    child.tail = \'\\n\' + node_indent\n+                    child.tail = "\\n" + node_indent\n \n \n def prettyXML(tree):\n@@ -77,16 +75,16 @@ def prettyXML(tree):\n \n \n def fieldTypecast(field, value):\n-    typecast = getattr(field, \'_type\', None)\n+    typecast = getattr(field, "_type", None)\n     if typecast is not None:\n         if not isinstance(typecast, (list, tuple)):\n-            typecast = (typecast, )\n+            typecast = (typecast,)\n         for tc in reversed(typecast):\n             if callable(tc):\n                 try:\n                     value = tc(value)\n                     break\n-                except:\n+                except Exception:\n                     pass\n     return value\n \n@@ -104,15 +102,15 @@ def elementToValue(field, element, default=_marker):\n         key_converter = IFromUnicode(field.key_type)\n         value = OrderedDict()\n         for child in element.iterchildren(tag=etree.Element):\n-            if noNS(child.tag.lower()) != \'element\':\n+            if noNS(child.tag.lower()) != "element":\n                 continue\n             parseinfo.stack.append(child)\n \n-            key_text = child.attrib.get(\'key\')\n+            key_text = child.attrib.get("key")\n             if key_text is None:\n                 k = None\n             else:\n-                k = key_converter.fromUnicode(six.text_type(key_text))\n+                k = key_converter.fromUnicode(str(key_text))\n \n             value[k] = elementToValue(field.value_type, child)\n             parseinfo.stack.pop()\n@@ -121,7 +119,7 @@ def elementToValue(field, element, default=_marker):\n     elif ICollection.providedBy(field):\n         value = []\n         for child in element.iterchildren(tag=etree.Element):\n-            if noNS(child.tag.lower()) != \'element\':\n+            if noNS(child.tag.lower()) != "element":\n                 continue\n             parseinfo.stack.append(child)\n             v = elementToValue(field.value_type, child)\n@@ -134,13 +132,13 @@ def elementToValue(field, element, default=_marker):\n         try:\n             vcf = getUtility(IVocabularyFactory, field.vocabularyName)\n             vocabulary = vcf(None)\n-        except:\n+        except Exception:\n             pass\n \n-        if vocabulary and hasattr(vocabulary, \'by_value\'):\n+        if vocabulary and hasattr(vocabulary, "by_value"):\n             try:\n                 field._type = type(list(vocabulary.by_value.keys())[0])\n-            except:\n+            except Exception:\n                 pass\n \n         value = fieldTypecast(field, element.text)\n@@ -152,17 +150,16 @@ def elementToValue(field, element, default=_marker):\n             value = field.missing_value\n         else:\n             converter = IFromUnicode(field)\n-            if isinstance(text, six.binary_type):\n+            if isinstance(text, bytes):\n                 text = text.decode()\n             else:\n-                text = six.text_type(text)\n+                text = str(text)\n             value = converter.fromUnicode(text)\n \n         # handle i18n\n-        if isinstance(value, six.string_types) and \\\n-                parseinfo.i18n_domain is not None:\n-            translate_attr = ns(\'translate\', I18N_NAMESPACE)\n-            domain_attr = ns(\'domain\', I18N_NAMESPACE)\n+        if isinstance(value, str) and parseinfo.i18n_domain is not None:\n+            translate_attr = ns("translate", I18N_NAMESPACE)\n+            domain_attr = ns("domain", I18N_NAMESPACE)\n             msgid = element.attrib.get(translate_attr)\n             domain = element.attrib.get(domain_attr, parseinfo.i18n_domain)\n             if msgid:\n@@ -194,9 +191,8 @@ def valueToElement(field, value, name=None, force=False):\n         if IDict.providedBy(field):\n             key_converter = IToUnicode(field.key_type)\n             for k, v in sorted(value.items()):\n-                list_element = valueToElement(\n-                    field.value_type, v, \'element\', force)\n-                list_element.attrib[\'key\'] = key_converter.toUnicode(k)\n+                list_element = valueToElement(field.value_type, v, "element", force)\n+                list_element.attrib["key"] = key_converter.toUnicode(k)\n                 child.append(list_element)\n \n         elif ICollection.providedBy(field):\n@@ -204,8 +200,7 @@ def valueToElement(field, value, name=None, force=False):\n                 # Serliazation should be consistent even if value was not really a set\n                 value = sorted(value)\n             for v in value:\n-                list_element = valueToElement(\n-                    field.value_type, v, \'element\', force)\n+                list_element = valueToElement(field.value_type, v, "element", force)\n                 child.append(list_element)\n \n         else:\n@@ -214,11 +209,11 @@ def valueToElement(field, value, name=None, force=False):\n \n             # handle i18n\n             if isinstance(value, Message):\n-                child.set(ns(\'domain\', I18N_NAMESPACE), value.domain)\n+                child.set(ns("domain", I18N_NAMESPACE), value.domain)\n                 if not value.default:\n-                    child.set(ns(\'translate\', I18N_NAMESPACE), \'\')\n+                    child.set(ns("translate", I18N_NAMESPACE), "")\n                 else:\n-                    child.set(ns(\'translate\', I18N_NAMESPACE), child.text)\n+                    child.set(ns("translate", I18N_NAMESPACE), child.text)\n                     child.text = converter.toUnicode(value.default)\n \n     return child\n@@ -232,12 +227,12 @@ def relativeToCallingPackage(filename, callingFrame=2):\n     if os.path.isabs(filename):\n         return filename\n     else:\n-        name = sys._getframe(callingFrame).f_globals[\'__name__\']\n+        name = sys._getframe(callingFrame).f_globals["__name__"]\n         module = sys.modules[name]\n-        if hasattr(module, \'__path__\'):\n+        if hasattr(module, "__path__"):\n             directory = module.__path__[0]\n         elif "." in name:\n-            parent_module = name[:name.rfind(\'.\')]\n+            parent_module = name[: name.rfind(".")]\n             directory = sys.modules[parent_module].__path__[0]\n         else:\n             directory = name\n@@ -246,13 +241,17 @@ def relativeToCallingPackage(filename, callingFrame=2):\n \n \n def sortedFields(schema):\n-    """Like getFieldsInOrder, but does not include fields from bases\n-    """\n+    """Like getFieldsInOrder, but does not include fields from bases"""\n     fields = []\n     for name in schema.names(all=False):\n         field = schema[name]\n         if IField.providedBy(field):\n-            fields.append((name, field, ))\n+            fields.append(\n+                (\n+                    name,\n+                    field,\n+                )\n+            )\n     fields.sort(key=lambda item: item[1].order)\n     return fields\n \n@@ -298,7 +297,7 @@ def syncSchema(source, dest, overwrite=False, sync_bases=False):\n         for name in to_delete:\n             # delattr(dest, name)\n             del dest._InterfaceClass__attrs[name]\n-            if hasattr(dest, \'_v_attrs\') and dest._v_attrs is not None:\n+            if hasattr(dest, "_v_attrs") and dest._v_attrs is not None:\n                 del dest._v_attrs[name]\n \n     # Add fields that are in source, but not in dest\n@@ -316,7 +315,7 @@ def syncSchema(source, dest, overwrite=False, sync_bases=False):\n \n             # setattr(dest, name, clone)\n             dest._InterfaceClass__attrs[name] = clone\n-            if hasattr(dest, \'_v_attrs\'):\n+            if hasattr(dest, "_v_attrs"):\n                 if dest._v_attrs is None:\n                     dest._v_attrs = {}\n                 dest._v_attrs[name] = clone\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..a5b1745 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,9 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\ndiff --git a/setup.cfg b/setup.cfg\nindex 526aeb2..bb3f825 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,2 +1,21 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [bdist_wheel]\n universal = 0\n+\n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n+\n+[check-manifest]\n+ignore =\n+    .editorconfig\n+    .meta.toml\ndiff --git a/setup.py b/setup.py\nindex 9cada3b..715a213 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,21 +1,19 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n+\n import os\n \n \n def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n-version = \'2.0.1.dev0\'\n \n-long_description = (\n-    read(\'README.rst\') + \'\\n\' +\n-    read(\'CHANGES.rst\') + \'\\n\'\n-    )\n+version = "2.0.1.dev0"\n+\n+long_description = read("README.rst") + "\\n" + read("CHANGES.rst") + "\\n"\n \n setup(\n-    name=\'plone.supermodel\',\n+    name="plone.supermodel",\n     version=version,\n     description="Serialize Zope schema definitions to and from XML",\n     long_description=long_description,\n@@ -34,35 +32,35 @@ def read(*rnames):\n         "Topic :: Software Development :: Libraries :: Python Modules",\n         "License :: OSI Approved :: BSD License",\n     ],\n-    keywords=\'Plone XML schema\',\n-    author=\'Martin Aspeli\',\n-    author_email=\'optilude@gmail.com\',\n-    url=\'https://github.com/plone/plone.supermodel\',\n-    license=\'BSD\',\n+    keywords="Plone XML schema",\n+    author="Martin Aspeli",\n+    author_email="optilude@gmail.com",\n+    url="https://github.com/plone/plone.supermodel",\n+    license="BSD",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'lxml\',\n-        \'zope.component\',\n-        \'zope.i18nmessageid\',\n-        \'zope.interface\',\n-        \'zope.schema>=4.1.0\',\n-        \'zope.deferredimport\',\n-        \'zope.dottedname\',\n-        \'z3c.zcmlhook\',\n+        "setuptools",\n+        "six",\n+        "lxml",\n+        "zope.component",\n+        "zope.i18nmessageid",\n+        "zope.interface",\n+        "zope.schema>=4.1.0",\n+        "zope.deferredimport",\n+        "zope.dottedname",\n+        "z3c.zcmlhook",\n     ],\n     extras_require={\n-        \'lxml\': [],  # BBB\n-        \'plone.rfc822\': [\'plone.rfc822\'],\n-        \'test\': [\n-            \'plone.rfc822\',\n-            ],\n+        "lxml": [],  # BBB\n+        "plone.rfc822": ["plone.rfc822"],\n+        "test": [\n+            "plone.rfc822",\n+        ],\n     },\n     entry_points="""\n     # -*- Entry points: -*-\n     """,\n-    )\n+)\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..0c34067\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,37 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[tox]\n+envlist =\n+    format\n+    lint\n+\n+[testenv]\n+py_files = find plone -name "*.py"\n+rst_files = find plone -name "*.rst"\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat python code\n+skip_install = true\n+deps =\n+    pyupgrade\n+    isort\n+    black\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'{[testenv]py_files} | xargs pyupgrade --py38-plus *.py\'\n+    sh -c \'{[testenv]py_files} | xargs isort *.py\'\n+    sh -c \'{[testenv]py_files} | xargs black *.py\'\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    flake8\n+    codespell\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'{[testenv]py_files} | xargs flake8 *.py\'\n+    sh -c \'{[testenv]py_files} | xargs codespell *.py\'\n+    sh -c \'{[testenv]rst_files} | xargs codespell *.rst\'\n'

