Repository: plone.app.dexterity


Branch: refs/heads/master
Date: 2022-04-04T12:30:09+02:00
Author: Philipp Auersperg-Castell (zworkb) <phil@bluedynamics.com>
Commit: https://github.com/plone/plone.app.dexterity/commit/a8cca780f39d2bc5a47d153863dfe80c6eb9104d

PLIP 2780: textindexer

integration of collective.textindexer -&gt; plone.app.dexterity.textindexer

Files changed:
A plone/app/dexterity/textindexer/__init__.py
A plone/app/dexterity/textindexer/behavior.py
A plone/app/dexterity/textindexer/configure.zcml
A plone/app/dexterity/textindexer/converters.py
A plone/app/dexterity/textindexer/directives.py
A plone/app/dexterity/textindexer/indexer.py
A plone/app/dexterity/textindexer/interfaces.py
A plone/app/dexterity/textindexer/schemaeditor.py
A plone/app/dexterity/textindexer/supermodel.py
A plone/app/dexterity/textindexer/testing.py
A plone/app/dexterity/textindexer/tests/__init__.py
A plone/app/dexterity/textindexer/tests/behaviors.py
A plone/app/dexterity/textindexer/tests/behaviors.rst
A plone/app/dexterity/textindexer/tests/configure.zcml
A plone/app/dexterity/textindexer/tests/helpers.py
A plone/app/dexterity/textindexer/tests/test_basic_behavior.py
A plone/app/dexterity/textindexer/tests/test_behaviors.py
A plone/app/dexterity/textindexer/tests/test_directives.py
A plone/app/dexterity/textindexer/tests/test_schemaeditor.py
A plone/app/dexterity/textindexer/tests/test_supermodel_handler.py
A plone/app/dexterity/textindexer/tests/test_utils.py
A plone/app/dexterity/textindexer/utils.py
M docs/advanced/catalog-indexing-strategies.rst
M plone/app/dexterity/configure.zcml
M plone/app/dexterity/permissions.py
M setup.py

b'diff --git a/docs/advanced/catalog-indexing-strategies.rst b/docs/advanced/catalog-indexing-strategies.rst\nindex 892745b..6df622b 100644\n--- a/docs/advanced/catalog-indexing-strategies.rst\n+++ b/docs/advanced/catalog-indexing-strategies.rst\n@@ -12,9 +12,9 @@ Making content searchable\n \n Plone\'s main index is called *SearchableText*. This is the index which is searched when you use the main portal search. Fields in your custom content types are not necessarily added to SearchableText. Fields added via Dublin-core behaviors are automatically part of SearchableText; others are not.\n \n-So, you may need to explicitly add fields to SearchableText if you wish their information to be findable via the main search. There are all sorts of highly customizable ways to do this, but the easiest is to use the `collective.dexteritytextindexer  <https://github.com/collective/collective.dexteritytextindexer>`_ add-on package.\n+So, you may need to explicitly add fields to SearchableText if you wish their information to be findable via the main search. There are all sorts of highly customizable ways to do this, but the easiest is to use the `plone.app.dexterity.textindexer  <https://github.com/collective/plone.app.dexterity.textindexer>`_ add-on package.\n \n-Add ``collective.dexteritytextindexer`` to your buildout and you will gain a new Dexterity behavior that will allow you to easily add fields to SearchableText. Once you turn on this behavior, you will then need to specify fields for addition to SearchableText.\n+Add ``plone.app.dexterity.textindexer`` to your buildout and you will gain a new Dexterity behavior that will allow you to easily add fields to SearchableText. Once you turn on this behavior, you will then need to specify fields for addition to SearchableText.\n \n .. note::\n \n@@ -22,7 +22,7 @@ Add ``collective.dexteritytextindexer`` to your buildout and you will gain a new\n \n Once you have turned on the indexer behavior, edit the XML field model to add ``indexer:searchable="true"`` to the ``field`` tag for each field you wish to add to the SearchableText index.\n \n-See the `collective.dexteritytextindexer  <https://github.com/collective/collective.dexteritytextindexer>`_ package documentation for details and for information on how to use it via Python schema.\n+See the `plone.app.dexterity.textindexer  <https://github.com/collective/plone.app.dexterity.textindexer>`_ package documentation for details and for information on how to use it via Python schema.\n \n \n Creating and using custom indexes\ndiff --git a/plone/app/dexterity/configure.zcml b/plone/app/dexterity/configure.zcml\nindex 5d0ea42..d9494d4 100644\n--- a/plone/app/dexterity/configure.zcml\n+++ b/plone/app/dexterity/configure.zcml\n@@ -37,6 +37,7 @@\n \n   <include package=".browser" />\n   <include package=".behaviors" />\n+  <include package=".textindexer" />\n   <include package=".upgrades" />\n \n   <include file="events.zcml" />\ndiff --git a/plone/app/dexterity/permissions.py b/plone/app/dexterity/permissions.py\nindex 8f71294..0c8b893 100644\n--- a/plone/app/dexterity/permissions.py\n+++ b/plone/app/dexterity/permissions.py\n@@ -17,7 +17,6 @@\n from zope.publisher.browser import TestRequest\n from zope.security.interfaces import IPermission\n \n-import six\n \n try:\n     from plone.app.z3cform.interfaces import IFieldPermissionChecker\n@@ -57,7 +56,7 @@ def _validate_vocabulary_name(self, schema, field, vocabulary_name):\n             widgets = mergedTaggedValueDict(schema, WIDGETS_KEY)\n             widget = widgets.get(field.getName())\n             if widget:\n-                if isinstance(widget, six.string_types):\n+                if isinstance(widget, str):\n                     widget = resolveDottedName(widget)\n                 if widget:\n                     widget = widget(field, self._request)\ndiff --git a/plone/app/dexterity/textindexer/__init__.py b/plone/app/dexterity/textindexer/__init__.py\nnew file mode 100644\nindex 0000000..2d51073\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/__init__.py\n@@ -0,0 +1,13 @@\n+# -*- coding: utf-8 -*-\n+"""Dynamic SearchableText index for dexterity content types\n+"""\n+\n+from plone.app.dexterity.textindexer import utils\n+from plone.app.dexterity.behaviors.metadata import IBasic\n+\n+from plone.app.dexterity.textindexer.interfaces import IDynamicTextIndexExtender, IDexterityTextIndexFieldConverter\n+\n+from plone.app.dexterity.textindexer.directives import searchable, SEARCHABLE_KEY\n+\n+utils.searchable(IBasic, \'title\')\n+utils.searchable(IBasic, \'description\')\ndiff --git a/plone/app/dexterity/textindexer/behavior.py b/plone/app/dexterity/textindexer/behavior.py\nnew file mode 100644\nindex 0000000..4372f03\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/behavior.py\n@@ -0,0 +1,11 @@\n+# -*- coding: utf-8 -*-\n+"""IDexterityTextIndexer    dexterity behavior interface for enabling\n+the dexteritytextindexer\n+"""\n+from zope.interface import Interface\n+\n+\n+class IDexterityTextIndexer(Interface):\n+    """Dexterity behavior interface for enabling the dynamic SearchableText\n+    indexer on a content type.\n+    """\ndiff --git a/plone/app/dexterity/textindexer/configure.zcml b/plone/app/dexterity/textindexer/configure.zcml\nnew file mode 100644\nindex 0000000..75b87c3\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/configure.zcml\n@@ -0,0 +1,62 @@\n+<configure xmlns="http://namespaces.zope.org/zope"\n+           xmlns:i18n="http://namespaces.zope.org/i18n"\n+           xmlns:plone="http://namespaces.plone.org/plone"\n+           xmlns:zcml="http://namespaces.zope.org/zcml"\n+           i18n_domain="plone.app.dexterity.textindexer">\n+\n+    <!-- marker behavior for enabling indexer -->\n+    <plone:behavior\n+          title="Dynamic SearchableText indexer behavior"\n+          name="plone.textindexer"\n+          description="Enables the dynamic SearchableText indexer for a content type"\n+          provides="plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer"\n+          />\n+\n+    <utility\n+        factory=".supermodel.IndexerSchema"\n+        name="plone.textindexer.indexer"\n+        />\n+\n+    <adapter\n+        factory="plone.app.dexterity.textindexer.indexer.dynamic_searchable_text_indexer"\n+        name="SearchableText" />\n+\n+    <!-- field converters -->\n+    <adapter\n+        factory="plone.app.dexterity.textindexer.converters.DefaultDexterityTextIndexFieldConverter"\n+        />\n+\n+    <adapter\n+        zcml:condition="installed plone.namedfile"\n+        factory="plone.app.dexterity.textindexer.converters.NamedfileFieldConverter"\n+        />\n+\n+    <adapter\n+        zcml:condition="installed plone.app.textfield"\n+        factory="plone.app.dexterity.textindexer.converters.DexterityRichTextIndexFieldConverter"\n+        />\n+\n+    <adapter\n+        factory="plone.app.dexterity.textindexer.converters.IntFieldConverter"\n+        />\n+\n+    <adapter\n+        factory="plone.app.dexterity.textindexer.converters.TupleFieldConverter"\n+        />\n+\n+    <!-- plone.schemaeditor adapter -->\n+    <adapter\n+        provides="plone.schemaeditor.interfaces.IFieldEditorExtender"\n+        for="plone.schemaeditor.interfaces.ISchemaContext\n+             zope.schema.interfaces.IField"\n+        name="plone.schemaeditor.searchabletext"\n+        factory=".schemaeditor.get_searchabletext_schema"\n+        />\n+\n+    <adapter\n+        provides=".schemaeditor.ISearchableTextField"\n+        for="zope.schema.interfaces.IField"\n+        factory=".schemaeditor.SearchableTextField"\n+        />\n+\n+</configure>\ndiff --git a/plone/app/dexterity/textindexer/converters.py b/plone/app/dexterity/textindexer/converters.py\nnew file mode 100644\nindex 0000000..9d47e94\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/converters.py\n@@ -0,0 +1,143 @@\n+# -*- coding: utf-8 -*-\n+"""\n+DefaultDexterityTextIndexFieldConverter    the default field converter\n+NamedfileFieldConverter                    an optional namedfile field\n+converter only enabled when plone.namedfile is installed\n+"""\n+\n+from plone.app.dexterity.textindexer import interfaces\n+from plone import api\n+from plone.dexterity.interfaces import IDexterityContent\n+from Products.CMFPlone.utils import safe_unicode\n+from z3c.form.interfaces import IWidget\n+from ZODB.POSException import ConflictError\n+from zope.component import adapter\n+from zope.interface import implementer\n+from zope.schema.interfaces import IField\n+from zope.schema.interfaces import IInt\n+from zope.schema.interfaces import ITuple\n+\n+import logging\n+\n+from plone.namedfile.interfaces import INamedFileField\n+from plone.app.textfield.interfaces import IRichText\n+\n+\n+LOGGER = logging.getLogger(\'plone.app.dexterity.textindexer\')\n+\n+\n+@implementer(interfaces.IDexterityTextIndexFieldConverter)\n+@adapter(IDexterityContent, IField, IWidget)\n+class DefaultDexterityTextIndexFieldConverter(object):\n+    """Fallback field converter which uses the rendered widget in display\n+    mode for generating a indexable string.\n+    """\n+\n+    def __init__(self, context, field, widget):\n+        """Initialize field converter"""\n+        self.context = context\n+        self.field = field\n+        self.widget = widget\n+\n+    def convert(self):\n+        """Convert the adapted field value to text/plain for indexing"""\n+        html = self.widget.render().strip()\n+        transforms = api.portal.get_tool(\'portal_transforms\')\n+        stream = transforms.convertTo(\'text/plain\', html, mimetype=\'text/html\')\n+        return stream.getData().strip()\n+\n+\n+@implementer(interfaces.IDexterityTextIndexFieldConverter)\n+@adapter(IDexterityContent, IRichText, IWidget)\n+class DexterityRichTextIndexFieldConverter(object):\n+    """Fallback field converter which uses the rendered widget in display\n+    mode for generating a indexable string.\n+    """\n+\n+    def __init__(self, context, field, widget):\n+        """Initialize field converter"""\n+        self.context = context\n+        self.field = field\n+\n+    def convert(self):\n+        """Convert a rich text field value to text/plain for indexing"""\n+        textvalue = self.field.get(self.context)\n+        if textvalue is None:\n+            return \'\'\n+        html = safe_unicode(textvalue.output)\n+        transforms = api.portal.get_tool(\'portal_transforms\')\n+        stream = transforms.convertTo(\n+            \'text/plain\', html, mimetype=textvalue.mimeType\n+        )\n+        return stream.getData().strip()\n+\n+\n+@implementer(interfaces.IDexterityTextIndexFieldConverter)\n+@adapter(IDexterityContent, INamedFileField, IWidget)\n+class NamedfileFieldConverter(DefaultDexterityTextIndexFieldConverter):\n+    """Converts the file data of a named file using portal_transforms.\n+    """\n+\n+    def convert(self):\n+        """Transforms file data to text for indexing safely.\n+        """\n+        storage = self.field.interface(self.context)\n+        data = self.field.get(storage)\n+\n+        # if there is no data, do nothing\n+        if not data or data.getSize() == 0:\n+            return \'\'\n+\n+        # if data is already in text/plain, just return it\n+        if data.contentType == \'text/plain\':\n+            return data.data\n+\n+        # if there is no path to text/plain, do nothing\n+        transforms = api.portal.get_tool(\'portal_transforms\')\n+\n+        # pylint: disable=W0212\n+        # W0212: Access to a protected member _findPath of a client class\n+        if not transforms._findPath(data.contentType, \'text/plain\'):\n+            return \'\'\n+        # pylint: enable=W0212\n+\n+        # convert it to text/plain\n+        try:\n+            datastream = transforms.convertTo(\n+                \'text/plain\', data.data, mimetype=data.contentType,\n+                filename=data.filename)\n+            return datastream.getData()\n+\n+        except (ConflictError, KeyboardInterrupt):\n+            raise\n+\n+        except Exception as e:\n+            LOGGER.error(\'Error while trying to convert file contents \'\n+                            \'to "text/plain": %s\', str(e))\n+\n+\n+@implementer(interfaces.IDexterityTextIndexFieldConverter)\n+@adapter(IDexterityContent, IInt, IWidget)\n+class IntFieldConverter(DefaultDexterityTextIndexFieldConverter):\n+    """Converts the data of a int field"""\n+\n+    def convert(self):\n+        """return the adapted field value"""\n+        storage = self.field.interface(self.context)\n+        value = self.field.get(storage)\n+        return str(value)\n+\n+\n+@implementer(interfaces.IDexterityTextIndexFieldConverter)\n+@adapter(IDexterityContent, ITuple, IWidget)\n+class TupleFieldConverter(DefaultDexterityTextIndexFieldConverter):\n+    """Converts the data of a tuple field"""\n+\n+    def convert(self):\n+        """return the adapted field value"""\n+        storage = self.field.interface(self.context)\n+        result = []\n+        if self.field.get(storage):\n+            for value in self.field.get(storage):\n+                result.append(value)\n+        return \' \'.join(result)\ndiff --git a/plone/app/dexterity/textindexer/directives.py b/plone/app/dexterity/textindexer/directives.py\nnew file mode 100644\nindex 0000000..46f43e6\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/directives.py\n@@ -0,0 +1,29 @@\n+# -*- coding: utf-8 -*-\n+from plone.supermodel.directives import MetadataListDirective\n+from zope.interface import Interface\n+from zope.interface.interfaces import IInterface\n+\n+\n+SEARCHABLE_KEY = u\'plone.app.dexterity.textindexer.searchable\'\n+\n+\n+class searchable(MetadataListDirective):\n+    """Directive used to mark a field as searchable.\n+    """\n+\n+    key = SEARCHABLE_KEY\n+    value = \'true\'\n+\n+    def factory(self, *args):\n+        """The searchable directive accepts as arguments one or more\n+        fieldnames (string) of fields which should be searchable.\n+        """\n+        if not args:\n+            raise TypeError(\'The searchable directive expects at \'\n+                            \'least one argument.\')\n+\n+        form_interface = Interface\n+        if IInterface.providedBy(args[0]):\n+            form_interface = args[0]\n+            args = args[1:]\n+        return [(form_interface, field, self.value) for field in args]\ndiff --git a/plone/app/dexterity/textindexer/indexer.py b/plone/app/dexterity/textindexer/indexer.py\nnew file mode 100644\nindex 0000000..837eee0\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/indexer.py\n@@ -0,0 +1,161 @@\n+# -*- coding: utf-8 -*-\n+"""Contains the indexer and some helper methods for indexing.\n+"""\n+\n+from plone.app.dexterity.textindexer import interfaces\n+from plone.app.dexterity.textindexer.behavior import IDexterityTextIndexer\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.dexterity.utils import iterSchemata\n+from plone.indexer import indexer\n+from plone.supermodel.utils import mergedTaggedValueList\n+from plone.z3cform import z2\n+from z3c.form.field import Field\n+from z3c.form.interfaces import DISPLAY_MODE\n+from z3c.form.interfaces import IContextAware\n+from z3c.form.interfaces import IField\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.interfaces import IFormLayer\n+from zope import schema\n+from zope.component import getAdapters\n+from zope.component import getMultiAdapter\n+from zope.globalrequest import getRequest\n+from zope.interface import alsoProvides\n+\n+import logging\n+\n+\n+LOGGER = logging.getLogger(\'plone.app.dexterity.textindexer\')\n+\n+\n+class FakeView(object):\n+    """This fake view is used for enabled z3c forms z2 mode on.\n+    """\n+\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n+\n+\n+@indexer(IDexterityTextIndexer)\n+def dynamic_searchable_text_indexer(obj):\n+    """Dynamic searchable text indexer.\n+    """\n+    # if the object does not provide a request, get one.\n+    # This happens when running scripts (bin/instance run script.py)\n+    try:\n+        request = obj.REQUEST\n+    except AttributeError:\n+        request = getRequest()\n+\n+    # We need to make sure that we have z2 mode switched on for z3c form.\n+    # Since we do not really have any view to do this on, we just use\n+    # a fake view. For switching z2 mode on, it\'s only necessary that\n+    # there is a view.request.\n+    view = FakeView(obj, request)\n+    z2.switch_on(view, request_layer=IFormLayer)\n+\n+    indexed = []\n+\n+    for _storage, fields in get_searchable_contexts_and_fields(obj):\n+        for field in fields:\n+\n+            # we need the form-field, not the schema-field we\n+            # already have..\n+            form_field = Field(field, interface=field.interface,\n+                               prefix=\'\')\n+\n+            # get the widget\n+            try:\n+                widget = get_field_widget(obj, form_field, request)\n+            except TypeError:\n+                # Some times the field value is wrong, then the converter\n+                # failes. We should not fail, so we catch this error.\n+                continue\n+\n+            # get the converter for this field / widget\n+            converter = getMultiAdapter(\n+                (obj, field, widget),\n+                interfaces.IDexterityTextIndexFieldConverter)\n+\n+            # convert the field value\n+            value = converter.convert()\n+\n+            # if no value was returned, we don\'t need to index\n+            # anything.\n+            if not value:\n+                continue\n+\n+            # only accept strings\n+            assert isinstance(value, str), \'expected converted \' + \\\n+                \'value of IDexterityTextIndexFieldConverter to be a str\'\n+\n+            indexed.append(value)\n+\n+    # after converting all fields, run additional\n+    # IDynamicTextIndexExtender adapters.\n+    for _name, adapter in getAdapters(\n+        (obj,), interfaces.IDynamicTextIndexExtender\n+    ):\n+        extended_value = adapter()\n+\n+        # if no value was returned, we don\'t need to index anything.\n+        if not extended_value:\n+            continue\n+\n+        # only accept strings\n+        assert isinstance(extended_value, str), \'expected converted \' + \\\n+            \'value of IDynamicTextIndexExtender to be a str\'\n+\n+        indexed.append(extended_value)\n+\n+    return \' \'.join(indexed)\n+\n+\n+def get_field_widget(obj, field, request):\n+    """Returns the field widget of a field in display mode without\n+    touching any form.\n+    The `field` should be a z3c form field, not a zope schema field.\n+    """\n+\n+    assert IField.providedBy(field), \'field is not a form field\'\n+\n+    if field.widgetFactory.get(DISPLAY_MODE) is not None:\n+        factory = field.widgetFactory.get(DISPLAY_MODE)\n+        widget = factory(field.field, request)\n+    else:\n+        widget = getMultiAdapter(\n+            (field.field, request), IFieldWidget)\n+    widget.name = \'\' + field.__name__  # prefix not needed\n+    widget.id = widget.name.replace(\'.\', \'-\')\n+    widget.context = obj\n+    alsoProvides(widget, IContextAware)\n+    widget.mode = DISPLAY_MODE\n+    widget.ignoreRequest = True\n+    widget.update()\n+    return widget\n+\n+\n+def get_searchable_contexts_and_fields(obj):\n+    """Returns a generator of tuples, which contains a storage object for\n+    each schema (adapted `obj`) and a list of fields on this schema which\n+    are searchable.\n+    """\n+\n+    for schemata in iterSchemata(obj):\n+        fields = []\n+        tagged_values = mergedTaggedValueList(schemata, SEARCHABLE_KEY)\n+        if not tagged_values:\n+            continue\n+\n+        for _i, name, _v in tagged_values:\n+            field = schema.getFields(schemata).get(name)\n+            if not field:\n+                dottedname = \'.\'.join((schemata.__module__, schemata.__name__))\n+                logging.error(\'%s has no field "%s"\', dottedname, name)\n+\n+            elif field not in fields:\n+                fields.append(field)\n+\n+        if fields:\n+            storage = schemata(obj)\n+            yield storage, fields\ndiff --git a/plone/app/dexterity/textindexer/interfaces.py b/plone/app/dexterity/textindexer/interfaces.py\nnew file mode 100644\nindex 0000000..4eb18d5\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/interfaces.py\n@@ -0,0 +1,35 @@\n+# -*- coding: utf-8 -*-\n+"""\n+IDexterityTextIndexFieldConverter  field converter adapter interface\n+IDynamicTextIndexExtender          dynmaic text extender adapter interface\n+"""\n+\n+from zope.interface import Interface\n+\n+\n+# Supermodel namespace and prefix\n+INDEXER_NAMESPACE = \'http://namespaces.plone.org/supermodel/indexer\'\n+INDEXER_PREFIX = \'indexer\'\n+\n+\n+class IDexterityTextIndexFieldConverter(Interface):\n+    """Interface for a multi-adapter which converts the field value of the\n+    adapted field into a human readable, translated text for indexing in\n+    the searchable text index.\n+    """\n+\n+    def __init__(self, context, field, widget):\n+        """The multi-adpater adapts the context, the field and the widget.\n+        """\n+\n+    def convert(self):\n+        """Returns a string containing the words to index. Translatable\n+        Message-objects are already translated into normal strings. On a\n+        multi-language site the\n+        """\n+\n+\n+class IDynamicTextIndexExtender(Interface):\n+    """Adapter interface for a named adapter which extends the dynamic\n+    text indexer.\n+    """\ndiff --git a/plone/app/dexterity/textindexer/schemaeditor.py b/plone/app/dexterity/textindexer/schemaeditor.py\nnew file mode 100644\nindex 0000000..c48fdc5\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/schemaeditor.py\n@@ -0,0 +1,73 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.app.dexterity.textindexer.interfaces import INDEXER_NAMESPACE\n+from plone.app.dexterity.textindexer.interfaces import INDEXER_PREFIX\n+from plone.schemaeditor.interfaces import IFieldEditorExtender\n+from plone.schemaeditor.interfaces import ISchemaContext\n+from zope import schema\n+from zope.component import adapter\n+from zope.i18nmessageid import MessageFactory\n+from zope.interface import implementer\n+from zope.interface import Interface\n+from zope.schema.interfaces import IField\n+\n+\n+_ = MessageFactory(\'plone.app.dexterity.textindexer\')\n+\n+\n+class ISearchableTextField(Interface):\n+    searchable = schema.Bool(\n+        title=_(\'Searchable\'),\n+        required=False\n+    )\n+\n+\n+@adapter(IField)\n+@implementer(ISearchableTextField)\n+class SearchableTextField(object):\n+\n+    namespace = INDEXER_NAMESPACE\n+    prefix = INDEXER_PREFIX\n+\n+    def __init__(self, field):\n+        self.field = field\n+        self.schema = field.interface\n+\n+    def _read_searchable(self):\n+        tagged_value = self.schema.queryTaggedValue(SEARCHABLE_KEY, [])\n+\n+        name = self.field.__name__\n+        value = (Interface, name, \'true\')\n+\n+        return value in tagged_value\n+\n+    def _write_searchable(self, value):\n+        tagged_value = self.schema.queryTaggedValue(SEARCHABLE_KEY, [])\n+\n+        name = self.field.__name__\n+        new_value = (Interface, name, bool(value) and \'true\' or \'false\')\n+        old_value = (Interface, name, bool(value) and \'false\' or \'true\')\n+\n+        while old_value in tagged_value:\n+            tagged_value.remove(old_value)\n+\n+        if bool(value) and new_value not in tagged_value:\n+            tagged_value.append(new_value)\n+\n+        self.schema.setTaggedValue(SEARCHABLE_KEY, tagged_value)\n+\n+    searchable = property(_read_searchable, _write_searchable)\n+\n+\n+# ISearchableTextField could be registered directly as a named adapter\n+# providing IFieldEditorExtender for ISchemaContext and IField, but instead,\n+# we register a separate callable which returns the schema only if additional\n+# conditions pass:\n+@adapter(ISchemaContext, IField)\n+@implementer(IFieldEditorExtender)\n+def get_searchabletext_schema(schema_context, field):\n+    behavior = \\\n+        \'plone.textindexer\'\n+    fti = getattr(schema_context, \'fti\', None)\n+    if fti and behavior in getattr(fti, \'behaviors\', []):\n+        return ISearchableTextField\ndiff --git a/plone/app/dexterity/textindexer/supermodel.py b/plone/app/dexterity/textindexer/supermodel.py\nnew file mode 100644\nindex 0000000..2c8068e\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/supermodel.py\n@@ -0,0 +1,38 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.app.dexterity.textindexer.interfaces import INDEXER_NAMESPACE\n+from plone.app.dexterity.textindexer.interfaces import INDEXER_PREFIX\n+from plone.supermodel.parser import IFieldMetadataHandler\n+from plone.supermodel.utils import ns\n+from zope.interface import implementer\n+from zope.interface import Interface\n+\n+\n+@implementer(IFieldMetadataHandler)\n+class IndexerSchema(object):\n+    """Support the indexer: namespace in model definitions.\n+    """\n+\n+    namespace = INDEXER_NAMESPACE\n+    prefix = INDEXER_PREFIX\n+\n+    def _add_searchable(self, schema, value):\n+        tagged_value = schema.queryTaggedValue(SEARCHABLE_KEY, [])\n+        tagged_value.append(value)\n+        schema.setTaggedValue(SEARCHABLE_KEY, tagged_value)\n+\n+    def read(self, fieldNode, schema, field):\n+        name = field.__name__\n+        searchable = fieldNode.get(ns(\'searchable\', self.namespace))\n+\n+        if searchable:\n+            value = (Interface, name, \'true\')\n+            self._add_searchable(schema, value)\n+\n+    def write(self, fieldNode, schema, field):\n+        name = field.__name__\n+        searchable = schema.queryTaggedValue(SEARCHABLE_KEY, [])\n+        field_names = [fld[1] for fld in searchable]\n+\n+        if name in field_names:\n+            fieldNode.set(ns(\'searchable\', self.namespace), \'true\')\ndiff --git a/plone/app/dexterity/textindexer/testing.py b/plone/app/dexterity/textindexer/testing.py\nnew file mode 100644\nindex 0000000..6e58a62\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/testing.py\n@@ -0,0 +1,87 @@\n+# -*- coding: utf-8 -*-\n+"""Testing setup providing layers and fixtures\n+TextIndexerLayer                   basic text indexer layer\n+TEXT_INDEXER_FIXTURE               text indexer fixture\n+TEXT_INTEXER_INTEGRATION_TESTING   integration testing layer\n+TEXT_INDEXER_FUNCTIONAL_TESTING    functional testing layer\n+"""\n+\n+from plone.app.testing import FunctionalTesting\n+from plone.app.testing import IntegrationTesting\n+from plone.app.testing import PLONE_FIXTURE\n+from plone.app.testing import PloneSandboxLayer\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from six import StringIO\n+\n+import logging\n+\n+\n+class TextIndexerLayer(PloneSandboxLayer):\n+\n+    defaultBases = (PLONE_FIXTURE,)\n+\n+    def __init__(self, *args, **kwargs):\n+        super(TextIndexerLayer, self).__init__(*args, **kwargs)\n+        self.log = None\n+        self.log_handler = None\n+\n+    def setUpZope(self, app, configurationContext):\n+        """After setting up zope, load all necessary zcml files.\n+        """\n+        import plone.app.dexterity.textindexer\n+        self.loadZCML(\n+            package=plone.app.dexterity.textindexer,\n+            context=configurationContext)\n+        import plone.app.dexterity.textindexer.tests\n+        self.loadZCML(\n+            package=plone.app.dexterity.textindexer.tests,\n+            context=configurationContext)\n+\n+    def setUpPloneSite(self, portal):\n+        """After setting up plone, give Manager role to the test user.\n+        """\n+        setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+\n+    def testSetUp(self):\n+        super(TextIndexerLayer, self).testSetUp()\n+        self.log = StringIO()\n+        self.log_handler = logging.StreamHandler(self.log)\n+        logging.root.addHandler(self.log_handler)\n+        self[\'read_log\'] = self.read_log\n+\n+    def testTearDown(self):\n+        super(TextIndexerLayer, self).testTearDown()\n+        logging.root.removeHandler(self.log_handler)\n+\n+    def read_log(self):\n+        self.log.seek(0)\n+        return self.log.read().strip()\n+\n+\n+TEXT_INDEXER_FIXTURE = TextIndexerLayer()\n+TEXT_INTEXER_INTEGRATION_TESTING = IntegrationTesting(\n+    bases=(TEXT_INDEXER_FIXTURE,),\n+    name=\'plone.app.dexterity.textindexer:Integration\')\n+\n+\n+class TextIndexerFunctionalLayer(PloneSandboxLayer):\n+\n+    defaultBases = (TEXT_INDEXER_FIXTURE,)\n+\n+    def setUpZope(self, app, configurationContext):\n+        import plone.app.dexterity\n+        self.loadZCML(\n+            package=plone.app.dexterity,\n+            context=configurationContext)\n+\n+    def setUpPloneSite(self, portal):\n+        self.applyProfile(portal, \'plone.app.dexterity:default\')\n+\n+\n+TEXT_INDEXER_FUNCTIONAL_FIXTURE = TextIndexerFunctionalLayer()\n+\n+TEXT_INDEXER_FUNCTIONAL_TESTING = FunctionalTesting(\n+    bases=(TEXT_INDEXER_FUNCTIONAL_FIXTURE,),\n+    name=\'plone.app.dexterity.textindexer:Functional\'\n+)\ndiff --git a/plone/app/dexterity/textindexer/tests/__init__.py b/plone/app/dexterity/textindexer/tests/__init__.py\nnew file mode 100644\nindex 0000000..2242eb2\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/__init__.py\n@@ -0,0 +1,4 @@\n+# -*- coding: utf-8 -*-\n+"""Testing module containing the tests\n+for plone.app.dexterity.textindexer.\n+"""\ndiff --git a/plone/app/dexterity/textindexer/tests/behaviors.py b/plone/app/dexterity/textindexer/tests/behaviors.py\nnew file mode 100644\nindex 0000000..254dd80\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/behaviors.py\n@@ -0,0 +1,119 @@\n+# -*- coding: utf-8 -*-\n+"""Contains different behaviors needed for testing.\n+"""\n+from plone.app.dexterity import textindexer\n+from plone.app.textfield import RichText\n+from plone.autoform.interfaces import IFormFieldProvider\n+from plone.supermodel import model\n+from zope import schema\n+from zope.interface import provider\n+\n+\n+@provider(IFormFieldProvider)\n+class ISimpleBehavior(model.Schema):\n+    """Simple behavior containing simple text line fields.\n+    """\n+\n+    textindexer.searchable(\'foo\')\n+    foo = schema.TextLine(title=u\'Foo\')\n+\n+    bar = schema.TextLine(title=u\'Bar\')\n+\n+\n+@provider(IFormFieldProvider)\n+class IListBehavior(model.Schema):\n+    """More advanced behavior with a list of fields.\n+    """\n+\n+    textindexer.searchable(\'list_field\')\n+\n+    list_field = schema.List(\n+        title=u\'List field\',\n+        value_type=schema.TextLine()\n+    )\n+\n+\n+@provider(IFormFieldProvider)\n+class IIntBehavior(model.Schema):\n+    """Basic behavior with a integer field.\n+    """\n+\n+    textindexer.searchable(\'int_field\')\n+    int_field = schema.Int(title=u\'Int\')\n+\n+\n+@provider(IFormFieldProvider)\n+class IRichTextBehavior(model.Schema):\n+    """Basic behavior with a rich-text field.\n+    """\n+\n+    textindexer.searchable(\'richtext_field\')\n+    richtext_field = RichText(\n+        title=u\'Body text\',\n+        default_mime_type=\'text/html\',\n+        output_mime_type=\'text/x-html\',\n+        allowed_mime_types=(\'text/html\', \'text/plain\',),\n+        default=u\'\',\n+    )\n+\n+@provider(IFormFieldProvider)\n+class IEmptyRichTextBehavior(model.Schema):\n+    """Behavior with a rich-text field without a default value.\n+    """\n+\n+    textindexer.searchable(\'foo\')\n+    foo = schema.TextLine(title=u\'Foo\')\n+\n+    textindexer.searchable(\'empty_richtext_field\')\n+    empty_richtext_field = RichText(\n+        title=u\'Body text\',\n+        default_mime_type=\'text/html\',\n+        output_mime_type=\'text/x-html\',\n+        allowed_mime_types=(\'text/html\', \'text/plain\',),\n+    )\n+\n+@provider(IFormFieldProvider)\n+class ITupleBehavior(model.Schema):\n+    """Basic behavior with a tuple field.\n+    """\n+\n+    textindexer.searchable(\'tuple_field\')\n+    tuple_field = schema.Tuple(\n+        title=u\'Tuple\',\n+        value_type=schema.TextLine(),\n+        required=False,\n+        missing_value=(),\n+    )\n+\n+\n+@provider(IFormFieldProvider)\n+class ITupleChoiceBehavior(model.Schema):\n+    """Basic behavior with a tuple choice field.\n+    """\n+\n+    textindexer.searchable(\'tuple_choice_field\')\n+    tuple_choice_field = schema.Tuple(\n+        title=u\'Tuple choice\',\n+        value_type=schema.Choice(\n+            vocabulary=\'plone.app.vocabularies.Keywords\'\n+        ),\n+        required=False,\n+        missing_value=(),\n+    )\n+\n+\n+@provider(IFormFieldProvider)\n+class IInheritedBehavior(ISimpleBehavior):\n+    """Behavior extending from ISimpleBehavior for testing inheritance.\n+    """\n+\n+\n+@provider(IFormFieldProvider)\n+class IMissingFieldBehavior(model.Schema):\n+    """A behavior defining a field as searchable which does not exist.\n+    """\n+\n+    textindexer.searchable(\'foo\')\n+    foo = schema.TextLine(title=u\'Foo\')\n+\n+    textindexer.searchable(\'bar\')\ndiff --git a/plone/app/dexterity/textindexer/tests/behaviors.rst b/plone/app/dexterity/textindexer/tests/behaviors.rst\nnew file mode 100644\nindex 0000000..39668ae\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/behaviors.rst\n@@ -0,0 +1,306 @@\n+Test everything with behaviors::\n+\n+    >>> from Products.CMFCore.utils import getToolByName\n+    >>> from plone.app.testing import TEST_USER_NAME\n+    >>> from plone.app.testing import login\n+    >>> from plone.dexterity.fti import DexterityFTI\n+    >>> from plone.dexterity.utils import createContentInContainer\n+\n+    >>> portal = layer[\'portal\']\n+    >>> login(portal, TEST_USER_NAME)\n+\n+\n+Helpers::\n+\n+    >>> def obj2brain(obj):\n+    ...     catalog = getToolByName(obj, \'portal_catalog\')\n+    ...     query = {\'path\': {\'query\': \'/\'.join(obj.getPhysicalPath()),\n+    ...                       \'depth\': 0}}\n+    ...     brains = catalog(query)\n+    ...     if len(brains) == 0:\n+    ...         raise Exception(\'Not in catalog: %s\' % obj)\n+    ...     else:\n+    ...         return brains[0]\n+\n+    >>> def getSearchableText(obj):\n+    ...     brain = obj2brain(obj)\n+    ...     catalog = getToolByName(obj, \'portal_catalog\')\n+    ...     data = catalog.getIndexDataForRID(brain.getRID())\n+    ...     return data[\'SearchableText\']\n+\n+\n+First test it with a simple behavior::\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import ISimpleBehavior\n+    >>> fti = DexterityFTI(\'SimpleFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.ISimpleBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'SimpleFTI\', fti)\n+    \'SimpleFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj1 = createContentInContainer(portal, \'SimpleFTI\',\n+    ...                                 checkContstraints=False,\n+    ...                                 foo=\'foox\',\n+    ...                                 bar=\'barx\')\n+    >>> obj1\n+    <Item at /plone/simplefti>\n+    >>> getSearchableText(obj1)\n+    [\'foox\']\n+\n+\n+Test, if the value getter works also, when the request has stored another value for this field.\n+\n+::\n+\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> portal.REQUEST.form[\'foo\'] = \'blubb\'\n+    >>> obj1 = createContentInContainer(portal, \'SimpleFTI\',\n+    ...                                 checkContstraints=False,\n+    ...                                 foo=\'foox\',\n+    ...                                 bar=\'barx\')\n+    >>> obj1\n+    <Item at /plone/simplefti-1>\n+    >>> getSearchableText(obj1)\n+    [\'foox\']\n+\n+\n+Does a list work?\n+\n+::\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IListBehavior\n+    >>> fti = DexterityFTI(\'ListFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.IListBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'ListFTI\', fti)\n+    \'ListFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj2 = createContentInContainer(portal, \'ListFTI\',\n+    ...                                 checkContstraints=False,\n+    ...                                 list_field=[\'hello\', u\'little\', \'world\'])\n+\n+    >>> obj2\n+    <Item at /plone/listfti>\n+    >>> getSearchableText(obj2)\n+    [\'hello\', \'little\', \'world\']\n+\n+\n+Do ints work?\n+\n+::\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IIntBehavior\n+    >>> fti = DexterityFTI(\'IntFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.IIntBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'IntFTI\', fti)\n+    \'IntFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj3 = createContentInContainer(portal, \'IntFTI\',\n+    ...                                 checkContstraints=False,\n+    ...                                 int_field=57)\n+\n+    >>> obj3\n+    <Item at /plone/intfti>\n+\n+In Plone 4.3 int-values are stored as unicodes.\n+Since our test should work also for old Plones, we convert everything\n+to string here::\n+\n+    >>> list(map(str, getSearchableText(obj3)))\n+    [\'57\']\n+\n+\n+Do rich-text fields work?\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IRichTextBehavior\n+    >>> from plone.app.textfield.value import RichTextValue\n+    >>> fti = DexterityFTI(\'RichTextFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.IRichTextBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'RichTextFTI\', fti)\n+    \'RichTextFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> rtv = RichTextValue(\n+    ...     raw=\'<p>In for an <em>inch</em>, in for a <strong>pound.</strong></p>\',\n+    ...     mimeType=\'text/html\',\n+    ...     outputMimeType=\'text/html\',\n+    ...     encoding=\'utf-8\',\n+    ... )\n+    >>> obj4 = createContentInContainer(\n+    ...    portal,\n+    ...    \'RichTextFTI\',\n+    ...    checkContstraints=False,\n+    ...    richtext_field=rtv,\n+    ... )\n+\n+    >>> obj4\n+    <Item at /plone/richtextfti>\n+\n+    >>> getSearchableText(obj4)\n+    [\'in\', \'for\', \'an\', \'inch\', \'in\', \'for\', \'a\', \'pound\']\n+\n+\n+Values are not duplicated in SearchableText when field comes from real interface\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import ISimpleBehavior\n+    >>> fti = DexterityFTI(\'SimpleFTI2\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.ISimpleBehavior\',\n+    ... )\n+    >>> fti.model_source = \'<model xmlns="http://namespaces.plone.org/supermodel/schema" xmlns:i18n="http://xml.zope.org/namespaces/i18n" i18n:domain="plone"><schema based-on="plone.app.dexterity.textindexer.tests.test_behaviors.ITestingSchema"></schema></model>\'\n+    >>> portal.portal_types._setObject(\'SimpleFTI2\', fti)\n+    \'SimpleFTI2\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj1 = createContentInContainer(portal, \'SimpleFTI2\',\n+    ...                                 checkContstraints=False,\n+    ...                                 foo=\'foox\',\n+    ...                                 bar=\'barx\',\n+    ...                                 testing_field=\'bla\')\n+    >>> obj1\n+    <Item at /plone/simplefti2>\n+    >>> getSearchableText(obj1)\n+    [\'bla\', \'foox\']\n+\n+\n+Do empty rich-text fields work?\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IEmptyRichTextBehavior\n+    >>> fti = DexterityFTI(\'EmptyRichTextFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.IEmptyRichTextBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'EmptyRichTextFTI\', fti)\n+    \'EmptyRichTextFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj_empty_rich_text = createContentInContainer(\n+    ...    portal,\n+    ...    \'EmptyRichTextFTI\',\n+    ...    checkContstraints=False,\n+    ...    foo=\'Hello World\',\n+    ... )\n+\n+    >>> obj_empty_rich_text\n+    <Item at /plone/emptyrichtextfti>\n+\n+    >>> getSearchableText(obj_empty_rich_text)\n+    [\'hello\', \'world\']\n+\n+\n+Do tuple fields work?\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IRichTextBehavior\n+    >>> fti = DexterityFTI(\'TupleFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.ITupleBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'TupleFTI\', fti)\n+    \'TupleFTI\'\n+    >>> schema = fti.lookupSchema()\n+    >>> obj5 = createContentInContainer(\n+    ...    portal,\n+    ...    \'TupleFTI\',\n+    ...    checkContstraints=False,\n+    ...    tuple_field=(\'My\', \'kingdom\', \'for\', \'a\', \'horse\'),\n+    ... )\n+\n+    >>> obj5\n+    <Item at /plone/tuplefti>\n+\n+    >>> getSearchableText(obj5)\n+    [\'my\', \'kingdom\', \'for\', \'a\', \'horse\']\n+\n+\n+Do tuple fields with choice values work?\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IRichTextBehavior\n+    >>> fti = DexterityFTI(\'TupleChoiceFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.ITupleChoiceBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'TupleChoiceFTI\', fti)\n+    \'TupleChoiceFTI\'\n+    >>> schema = fti.lookupSchema()\n+    >>> obj6 = createContentInContainer(\n+    ...    portal,\n+    ...    \'TupleChoiceFTI\',\n+    ...    checkContstraints=False,\n+    ...    tuple_choice_field=(\'Knights\', \'ni\'),\n+    ... )\n+\n+    >>> obj6\n+    <Item at /plone/tuplechoicefti>\n+\n+    >>> getSearchableText(obj6)\n+    [\'knights\', \'ni\']\n+\n+\n+When a schema marks a field as searchable which does not exist it should:\n+\n+- not break indexing other fields\n+- log an error\n+\n+::\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IMissingFieldBehavior\n+    >>> fti = DexterityFTI(\'MissingFieldFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.IMissingFieldBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'MissingFieldFTI\', fti)\n+    \'MissingFieldFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj = createContentInContainer(portal, \'MissingFieldFTI\',\n+    ...                                checkContstraints=False,\n+    ...                                foo=\'foo value\')\n+    >>> obj\n+    <Item at /plone/missingfieldfti>\n+    >>> getSearchableText(obj)\n+    [\'foo\', \'value\']\n+\n+    >>> \'IMissingFieldBehavior has no field "bar"\' in layer[\'read_log\']()\n+    True\n+\n+\n+Test, if a subclassed schema also inherits the searchable configuration of\n+it\'s superclass::\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IInheritedBehavior\n+    >>> fti = DexterityFTI(\'InheritedFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.IInheritedBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'InheritedFTI\', fti)\n+    \'InheritedFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj1 = createContentInContainer(portal, \'InheritedFTI\',\n+    ...                                 checkContstraints=False,\n+    ...                                 foo=\'foo value\',\n+    ...                                 bar=\'bar value\')\n+    >>> obj1\n+    <Item at /plone/inheritedfti>\n+    >>> getSearchableText(obj1)\n+    [\'foo\', \'value\']\ndiff --git a/plone/app/dexterity/textindexer/tests/configure.zcml b/plone/app/dexterity/textindexer/tests/configure.zcml\nnew file mode 100644\nindex 0000000..123e556\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/configure.zcml\n@@ -0,0 +1,68 @@\n+<configure xmlns="http://namespaces.zope.org/zope"\n+           xmlns:plone="http://namespaces.plone.org/plone"\n+           i18n_domain="plone.app.dexterity.textindexer">\n+\n+    <plone:behavior\n+          title="simple behavior"\n+          description=""\n+          provides=".behaviors.ISimpleBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="list behavior"\n+          description=""\n+          provides=".behaviors.IListBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="int behavior"\n+          description=""\n+          provides=".behaviors.IIntBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="richtext behavior"\n+          description=""\n+          provides=".behaviors.IRichTextBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="empty richtext behavior"\n+          description=""\n+          provides=".behaviors.IEmptyRichTextBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="tuple behavior"\n+          description=""\n+          provides=".behaviors.ITupleBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="tuple choice behavior"\n+          description=""\n+          provides=".behaviors.ITupleChoiceBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="inherited behavior"\n+          description=""\n+          provides=".behaviors.IInheritedBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="missing field behavior"\n+          description=""\n+          provides=".behaviors.IMissingFieldBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+</configure>\ndiff --git a/plone/app/dexterity/textindexer/tests/helpers.py b/plone/app/dexterity/textindexer/tests/helpers.py\nnew file mode 100644\nindex 0000000..96bb84a\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/helpers.py\n@@ -0,0 +1,14 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.supermodel.utils import mergedTaggedValueList\n+\n+\n+def get_searchable_fields(iface):\n+    fieldnames = []\n+\n+    for flag_iface, fieldname, value in mergedTaggedValueList(\n+            iface, SEARCHABLE_KEY):\n+        if flag_iface == iface and value:\n+            fieldnames.append(fieldname)\n+\n+    return fieldnames\ndiff --git a/plone/app/dexterity/textindexer/tests/test_basic_behavior.py b/plone/app/dexterity/textindexer/tests/test_basic_behavior.py\nnew file mode 100644\nindex 0000000..81597e2\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/test_basic_behavior.py\n@@ -0,0 +1,13 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.dexterity.textindexer.tests.helpers import get_searchable_fields\n+from plone.app.dexterity.behaviors.metadata import IBasic\n+from unittest import TestCase\n+\n+\n+class TestBasicBehaviorIsSearchable(TestCase):\n+\n+    def test_title_is_searchable(self):\n+        self.assertIn(\'title\', get_searchable_fields(IBasic))\n+\n+    def test_description_is_searchable(self):\n+        self.assertIn(\'description\', get_searchable_fields(IBasic))\ndiff --git a/plone/app/dexterity/textindexer/tests/test_behaviors.py b/plone/app/dexterity/textindexer/tests/test_behaviors.py\nnew file mode 100644\nindex 0000000..20a0f79\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/test_behaviors.py\n@@ -0,0 +1,29 @@\n+# -*- coding: utf-8 -*-\n+"""Containing a tests suite for testing the behaviors.\n+"""\n+\n+from plone.app.dexterity.textindexer import testing\n+from plone.app.dexterity.textindexer.directives import searchable\n+from plone.supermodel import model\n+from plone.testing import layered\n+from zope import schema\n+\n+import doctest\n+import unittest as unittest\n+\n+\n+def test_suite():\n+    """Test suite testing the behaviors with a doctest from behaviors.txt\n+    """\n+    suite = unittest.TestSuite()\n+    suite.addTests([\n+        layered(doctest.DocFileSuite(\'behaviors.rst\'),\n+                layer=testing.TEXT_INTEXER_INTEGRATION_TESTING),\n+    ])\n+    return suite\n+\n+\n+class ITestingSchema(model.Schema):\n+\n+    searchable("testing_field")\n+    testing_field = schema.TextLine(title=\'Testing field\')\ndiff --git a/plone/app/dexterity/textindexer/tests/test_directives.py b/plone/app/dexterity/textindexer/tests/test_directives.py\nnew file mode 100644\nindex 0000000..f7ae010\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/test_directives.py\n@@ -0,0 +1,55 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.dexterity.textindexer.directives import searchable\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.supermodel import model\n+from plone.supermodel.utils import mergedTaggedValueList\n+from zope import schema\n+from zope.interface import Interface\n+\n+import unittest\n+import zope.component.testing\n+\n+\n+class TestDirectives(unittest.TestCase):\n+\n+    def tearDown(self):\n+        """Tear down the testing setup.\n+        """\n+        zope.component.testing.tearDown()\n+\n+    def test_schema_directives_store_tagged_values(self):\n+        """Test, if the schema directive values are stored as tagged\n+        values.\n+        """\n+\n+        class IDummy(model.Schema):\n+            """Dummy schema class.\n+            """\n+            searchable(\'foo\')\n+            foo = schema.TextLine(title=u\'Foo\')\n+\n+        self.assertEqual(\n+            [(Interface, \'foo\', \'true\')],\n+            mergedTaggedValueList(IDummy, SEARCHABLE_KEY))\n+\n+    def test_inherited_schema_still_has_tagged_value(self):\n+        """An inherited schema should still have the tagged value information\n+        inherited from its superclass.\n+        """\n+\n+        class IFoo(model.Schema):\n+            """Class with a searchable field\n+            """\n+            searchable(\'baz\')\n+            baz = schema.TextLine(title=u\'baz\')\n+\n+        class IBar(IFoo):\n+            """Schema class which inherits a field from IFoo.\n+            """\n+\n+        self.assertEqual(\n+            [(Interface, \'baz\', \'true\')],\n+            mergedTaggedValueList(IFoo, SEARCHABLE_KEY))\n+        self.assertEqual(\n+            [(Interface, \'baz\', \'true\')],\n+            mergedTaggedValueList(IBar, SEARCHABLE_KEY))\ndiff --git a/plone/app/dexterity/textindexer/tests/test_schemaeditor.py b/plone/app/dexterity/textindexer/tests/test_schemaeditor.py\nnew file mode 100644\nindex 0000000..84c256a\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/test_schemaeditor.py\n@@ -0,0 +1,110 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.dexterity.textindexer.testing import TEXT_INDEXER_FUNCTIONAL_TESTING  # noqa\n+from plone import api\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from plone.app.testing import TEST_USER_NAME\n+from plone.app.testing import TEST_USER_PASSWORD\n+from plone.dexterity.fti import DexterityFTI\n+from plone.testing.z2 import Browser\n+\n+import transaction\n+import unittest\n+\n+\n+class TestSchemaEditor(unittest.TestCase):\n+\n+    layer = TEXT_INDEXER_FUNCTIONAL_TESTING\n+\n+    def setUp(self):\n+        portal_types = api.portal.get_tool(\'portal_types\')\n+\n+        # Define new portal type without behavior\n+        fti = DexterityFTI(str(\'without_behavior\'), title=\'Without Behavior\')\n+        fti.behaviors = (\n+            \'plone.app.dexterity.behaviors.metadata.IBasic\',\n+        )\n+        fti.model_source = u"""\\\n+<model xmlns="http://namespaces.plone.org/supermodel/schema">\n+<schema>\n+<field name="custom" type="zope.schema.TextLine">\n+  <description />\n+  <required>False</required>\n+  <title>Custom field</title>\n+</field>\n+</schema>\n+</model>"""\n+        portal_types._setObject(str(\'without_behavior\'), fti)\n+\n+        # Define new portal type with behavior\n+        fti = DexterityFTI(str(\'with_behavior\'), title=\'With Behavior\')\n+        fti.behaviors = (\n+            \'plone.app.dexterity.behaviors.metadata.IBasic\',\n+            \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\'\n+        )\n+        fti.model_source = u"""\\\n+<model xmlns="http://namespaces.plone.org/supermodel/schema">\n+<schema>\n+<field name="custom" type="zope.schema.TextLine">\n+  <description />\n+  <required>False</required>\n+  <title>Custom field</title>\n+</field>\n+</schema>\n+</model>"""\n+        portal_types._setObject(str(\'with_behavior\'), fti)\n+\n+        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Manager\'])\n+        transaction.commit()\n+\n+        self.browser = Browser(self.layer[\'app\'])\n+        self.browser.addHeader(\n+            \'Authorization\', \'Basic {0}:{1}\'.format(\n+                TEST_USER_NAME, TEST_USER_PASSWORD))\n+        self.portal_url = self.layer[\'portal\'].absolute_url()\n+\n+    def test_searchable_field_is_not_visible_without_behavior(self):\n+        self.browser.open(self.portal_url +\n+                          \'/dexterity-types/without_behavior/custom\')\n+        self.assertRaises(LookupError, self.browser.getControl, \'Searchable\')\n+\n+    def test_searchable_field_is_visible_with_behavior(self):\n+        self.browser.open(self.portal_url +\n+                          \'/dexterity-types/with_behavior/custom\')\n+        control = self.browser.getControl(\'Searchable\')\n+        self.assertEqual(control.control.type, \'checkbox\')\n+\n+    def test_searchable_field_is_disabled_by_default(self):\n+        self.browser.open(self.portal_url +\n+                          \'/dexterity-types/with_behavior/custom\')\n+        self.assertFalse(\n+            self.browser.getControl(\'Searchable\').selected)\n+\n+    def test_searchable_field_change_is_saved(self):\n+        portal_types = api.portal.get_tool(\'portal_types\')\n+        fti = portal_types[\'with_behavior\']\n+        self.assertNotIn(\'indexer:searchable="true"\', fti.model_source)\n+\n+        self.browser.open(self.portal_url +\n+                          \'/dexterity-types/with_behavior/custom\')\n+        self.browser.getControl(\'Searchable\').click()\n+        self.browser.getControl(\'Save\').click()\n+\n+        self.browser.open(\n+            self.portal_url + \'/dexterity-types/with_behavior/custom\')\n+        self.assertTrue(\n+            self.browser.getControl(\'Searchable\').selected)\n+\n+        fti._p_jar.sync()\n+        self.assertIn(\'indexer:searchable="true"\', fti.model_source)\n+\n+        self.browser.getControl(\'Searchable\').click()\n+        self.browser.getControl(\'Save\').click()\n+\n+        self.browser.open(\n+            self.portal_url + \'/dexterity-types/with_behavior/custom\')\n+        self.assertFalse(\n+            self.browser.getControl(\'Searchable\').selected)\n+\n+        fti._p_jar.sync()\n+        self.assertNotIn(\'indexer:searchable="true"\', fti.model_source)\ndiff --git a/plone/app/dexterity/textindexer/tests/test_supermodel_handler.py b/plone/app/dexterity/textindexer/tests/test_supermodel_handler.py\nnew file mode 100644\nindex 0000000..bcc5032\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/test_supermodel_handler.py\n@@ -0,0 +1,120 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.app.dexterity.textindexer.supermodel import IndexerSchema\n+from plone.supermodel.utils import ns\n+from xml.etree import ElementTree\n+from zope.interface import Interface\n+\n+import unittest\n+import zope.schema\n+\n+\n+class TestIndexerSchema(unittest.TestCase):\n+    """Tests for the supermodel field metadata handler.\n+    """\n+\n+    namespace = \'http://namespaces.plone.org/supermodel/indexer\'\n+\n+    def test_read(self):\n+        field_node = ElementTree.Element(\'field\')\n+        field_node.set(ns(\'searchable\', self.namespace), \'true\')\n+\n+        class IDummy(Interface):\n+            dummy = zope.schema.TextLine(title=u\'dummy\')\n+\n+        handler = IndexerSchema()\n+        handler.read(field_node, IDummy, IDummy[\'dummy\'])\n+\n+        self.assertEqual(\n+            [(Interface, \'dummy\', \'true\')],\n+            IDummy.getTaggedValue(SEARCHABLE_KEY))\n+\n+    def test_read_multiple(self):\n+        field_node1 = ElementTree.Element(\'field\')\n+        field_node1.set(ns(\'searchable\', self.namespace), \'true\')\n+\n+        field_node2 = ElementTree.Element(\'field\')\n+\n+        field_node3 = ElementTree.Element(\'field\')\n+        field_node3.set(ns(\'searchable\', self.namespace), \'true\')\n+\n+        class IDummy(Interface):\n+            dummy1 = zope.schema.TextLine(title=u\'dummy1\')\n+            dummy2 = zope.schema.TextLine(title=u\'dummy2\')\n+            dummy3 = zope.schema.TextLine(title=u\'dummy3\')\n+\n+        handler = IndexerSchema()\n+        handler.read(field_node1, IDummy, IDummy[\'dummy1\'])\n+        handler.read(field_node2, IDummy, IDummy[\'dummy2\'])\n+        handler.read(field_node3, IDummy, IDummy[\'dummy3\'])\n+\n+        self.assertEqual([\n+            (Interface, \'dummy1\', \'true\'),\n+            (Interface, \'dummy3\', \'true\')],\n+            IDummy.getTaggedValue(SEARCHABLE_KEY))\n+\n+    def test_read_no_data(self):\n+        field_node = ElementTree.Element(\'field\')\n+\n+        class IDummy(Interface):\n+            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+\n+        handler = IndexerSchema()\n+        handler.read(field_node, IDummy, IDummy[\'dummy\'])\n+\n+        self.assertEqual(None, IDummy.queryTaggedValue(SEARCHABLE_KEY))\n+\n+    def test_write(self):\n+        field_node = ElementTree.Element(\'field\')\n+\n+        class IDummy(Interface):\n+            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+\n+        IDummy.setTaggedValue(SEARCHABLE_KEY, [(Interface, \'dummy\', \'true\')])\n+\n+        handler = IndexerSchema()\n+        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+\n+        self.assertEqual(\n+            \'true\',\n+            field_node.get(ns(\'searchable\', self.namespace)))\n+\n+    def test_write_partial(self):\n+        field_node = ElementTree.Element(\'field\')\n+        field_node2 = ElementTree.Element(\'field\')\n+\n+        class IDummy(Interface):\n+            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+            dummy2 = zope.schema.TextLine(title=u\'dummy2\')\n+\n+        IDummy.setTaggedValue(SEARCHABLE_KEY, [(Interface, \'dummy\', \'true\')])\n+\n+        handler = IndexerSchema()\n+        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node2, IDummy, IDummy[\'dummy2\'])\n+\n+        self.assertEqual(\n+            \'true\',\n+            field_node.get(ns(\'searchable\', self.namespace)))\n+        self.assertEqual(\n+            None,\n+            field_node2.get(ns(\'searchable\', self.namespace)))\n+\n+    def test_write_no_data(self):\n+        field_node = ElementTree.Element(\'field\')\n+\n+        class IDummy(Interface):\n+            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+\n+        handler = IndexerSchema()\n+        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+\n+        self.assertEqual(\n+            None,\n+            field_node.get(ns(\'searchable\', self.namespace)))\n+\n+\n+def test_suite():\n+    suite = unittest.TestSuite()\n+    suite.addTest(unittest.makeSuite(TestIndexerSchema))\n+    return suite\ndiff --git a/plone/app/dexterity/textindexer/tests/test_utils.py b/plone/app/dexterity/textindexer/tests/test_utils.py\nnew file mode 100644\nindex 0000000..6f58cc9\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/test_utils.py\n@@ -0,0 +1,56 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.dexterity.textindexer.tests.helpers import get_searchable_fields\n+from plone.app.dexterity.textindexer.utils import no_longer_searchable\n+from plone.app.dexterity.textindexer.utils import searchable\n+from plone.supermodel import model\n+from unittest import TestCase\n+from zope import schema\n+\n+\n+class IExample(model.Schema):\n+\n+    foo = schema.TextLine(title=u\'foo\')\n+\n+\n+class IBar(model.Schema):\n+    pass\n+\n+\n+class IBaz(model.Schema):\n+    baz = schema.TextLine(title=u\'baz\')\n+\n+\n+class TestUtils(TestCase):\n+    """Test utils module.\n+    """\n+\n+    def test_marking_field_as_searchable(self):\n+        self.assertEqual(get_searchable_fields(IExample), [])\n+        searchable(IExample, u\'foo\')\n+        self.assertEqual(get_searchable_fields(IExample), [\'foo\'])\n+\n+    def test_break_when_field_does_not_exist(self):\n+        with self.assertRaises(AttributeError) as cm:\n+            searchable(IBar, u\'foo\')\n+\n+        self.assertEqual(\n+            str(cm.exception),\n+            \'plone.app.dexterity.textindexer.tests.test_utils.IBar\'\n+            \' has no field "foo"\')\n+\n+    def test_no_longer_searchable_removes_flag(self):\n+        self.assertEqual(get_searchable_fields(IBaz), [])\n+        searchable(IBaz, u\'baz\')\n+        self.assertEqual(get_searchable_fields(IBaz), [\'baz\'])\n+        self.assertTrue(no_longer_searchable(IBaz, \'baz\'))\n+        self.assertFalse(no_longer_searchable(IBaz, \'baz\'))\n+        self.assertEqual(get_searchable_fields(IBaz), [])\n+\n+    def test_no_longer_searchable_breaks_when_field_does_not_exist(self):\n+        with self.assertRaises(AttributeError) as cm:\n+            no_longer_searchable(IBar, u\'foo\')\n+\n+        self.assertEqual(\n+            str(cm.exception),\n+            \'plone.app.dexterity.textindexer.tests.test_utils.IBar\'\n+            \' has no field "foo"\')\ndiff --git a/plone/app/dexterity/textindexer/utils.py b/plone/app/dexterity/textindexer/utils.py\nnew file mode 100644\nindex 0000000..d5b51df\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/utils.py\n@@ -0,0 +1,51 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from zope import schema\n+\n+\n+def searchable(iface, field_name):\n+    """\n+        mark a field in existing iface as searchable\n+    """\n+\n+    if schema.getFields(iface).get(field_name) is None:\n+        dottedname = \'.\'.join((iface.__module__, iface.__name__))\n+        raise AttributeError(\n+            \'{0} has no field "{1}"\'.format(\n+                dottedname,\n+                field_name\n+            )\n+        )\n+\n+    store = iface.queryTaggedValue(SEARCHABLE_KEY)\n+    if store is None:\n+        store = []\n+    store.append((iface, field_name, \'true\'))\n+    iface.setTaggedValue(SEARCHABLE_KEY, store)\n+\n+\n+def no_longer_searchable(iface, field_name):\n+    """Removes a "searchable" mark from a previously marked\n+    field.\n+    """\n+\n+    if schema.getFields(iface).get(field_name) is None:\n+        dottedname = \'.\'.join((iface.__module__, iface.__name__))\n+        raise AttributeError(\n+            \'{0} has no field "{1}"\'.format(\n+                dottedname,\n+                field_name\n+            )\n+        )\n+\n+    store = iface.queryTaggedValue(SEARCHABLE_KEY)\n+    if store is None:\n+        return False\n+\n+    key = (iface, field_name, \'true\')\n+    if key not in store:\n+        return False\n+\n+    store.remove(key)\n+    iface.setTaggedValue(SEARCHABLE_KEY, store)\n+    return True\ndiff --git a/setup.py b/setup.py\nindex 6bb5aca..31ef399 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -69,7 +69,6 @@\n         \'Products.CMFCore\',\n         \'Products.GenericSetup\',\n         \'setuptools\',\n-        \'six\',\n         \'Zope2\',\n         \'zope.browserpage\',\n         \'zope.interface\',\n'

Repository: plone.app.dexterity


Branch: refs/heads/master
Date: 2022-04-04T12:36:19+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.dexterity/commit/f06c985b89066890db3da71e290e020b1226a4db

add newsfile

Files changed:
A news/2780.feature

b'diff --git a/news/2780.feature b/news/2780.feature\nnew file mode 100644\nindex 0000000..ffe38c8\n--- /dev/null\n+++ b/news/2780.feature\n@@ -0,0 +1,2 @@\n+PLIP 2780: Move features of collective.dexteritytextindexer to core.\n+[zworkb]\n'

Repository: plone.app.dexterity


Branch: refs/heads/master
Date: 2022-04-06T17:55:13+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.dexterity/commit/f64971f41131470a2ca0ed38f19a5674de628a24

pyupgrade, isort, black

Files changed:
M plone/app/dexterity/textindexer/__init__.py
M plone/app/dexterity/textindexer/behavior.py
M plone/app/dexterity/textindexer/converters.py
M plone/app/dexterity/textindexer/directives.py
M plone/app/dexterity/textindexer/indexer.py
M plone/app/dexterity/textindexer/interfaces.py
M plone/app/dexterity/textindexer/schemaeditor.py
M plone/app/dexterity/textindexer/supermodel.py
M plone/app/dexterity/textindexer/testing.py
M plone/app/dexterity/textindexer/tests/__init__.py
M plone/app/dexterity/textindexer/tests/behaviors.py
M plone/app/dexterity/textindexer/tests/helpers.py
M plone/app/dexterity/textindexer/tests/test_basic_behavior.py
M plone/app/dexterity/textindexer/tests/test_behaviors.py
M plone/app/dexterity/textindexer/tests/test_directives.py
M plone/app/dexterity/textindexer/tests/test_schemaeditor.py
M plone/app/dexterity/textindexer/tests/test_supermodel_handler.py
M plone/app/dexterity/textindexer/tests/test_utils.py
M plone/app/dexterity/textindexer/utils.py
M setup.cfg

b'diff --git a/plone/app/dexterity/textindexer/__init__.py b/plone/app/dexterity/textindexer/__init__.py\nindex 2d51073..f1ecefc 100644\n--- a/plone/app/dexterity/textindexer/__init__.py\n+++ b/plone/app/dexterity/textindexer/__init__.py\n@@ -1,13 +1,13 @@\n-# -*- coding: utf-8 -*-\n """Dynamic SearchableText index for dexterity content types\n """\n \n-from plone.app.dexterity.textindexer import utils\n from plone.app.dexterity.behaviors.metadata import IBasic\n+from plone.app.dexterity.textindexer import utils\n+from plone.app.dexterity.textindexer.directives import searchable\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.app.dexterity.textindexer.interfaces import IDexterityTextIndexFieldConverter\n+from plone.app.dexterity.textindexer.interfaces import IDynamicTextIndexExtender\n \n-from plone.app.dexterity.textindexer.interfaces import IDynamicTextIndexExtender, IDexterityTextIndexFieldConverter\n-\n-from plone.app.dexterity.textindexer.directives import searchable, SEARCHABLE_KEY\n \n-utils.searchable(IBasic, \'title\')\n-utils.searchable(IBasic, \'description\')\n+utils.searchable(IBasic, "title")\n+utils.searchable(IBasic, "description")\ndiff --git a/plone/app/dexterity/textindexer/behavior.py b/plone/app/dexterity/textindexer/behavior.py\nindex 4372f03..ed9a965 100644\n--- a/plone/app/dexterity/textindexer/behavior.py\n+++ b/plone/app/dexterity/textindexer/behavior.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """IDexterityTextIndexer    dexterity behavior interface for enabling\n the dexteritytextindexer\n """\ndiff --git a/plone/app/dexterity/textindexer/converters.py b/plone/app/dexterity/textindexer/converters.py\nindex 9d47e94..437ecdf 100644\n--- a/plone/app/dexterity/textindexer/converters.py\n+++ b/plone/app/dexterity/textindexer/converters.py\n@@ -1,13 +1,14 @@\n-# -*- coding: utf-8 -*-\n """\n DefaultDexterityTextIndexFieldConverter    the default field converter\n NamedfileFieldConverter                    an optional namedfile field\n converter only enabled when plone.namedfile is installed\n """\n \n-from plone.app.dexterity.textindexer import interfaces\n from plone import api\n+from plone.app.dexterity.textindexer import interfaces\n+from plone.app.textfield.interfaces import IRichText\n from plone.dexterity.interfaces import IDexterityContent\n+from plone.namedfile.interfaces import INamedFileField\n from Products.CMFPlone.utils import safe_unicode\n from z3c.form.interfaces import IWidget\n from ZODB.POSException import ConflictError\n@@ -19,16 +20,13 @@\n \n import logging\n \n-from plone.namedfile.interfaces import INamedFileField\n-from plone.app.textfield.interfaces import IRichText\n \n-\n-LOGGER = logging.getLogger(\'plone.app.dexterity.textindexer\')\n+LOGGER = logging.getLogger("plone.app.dexterity.textindexer")\n \n \n @implementer(interfaces.IDexterityTextIndexFieldConverter)\n @adapter(IDexterityContent, IField, IWidget)\n-class DefaultDexterityTextIndexFieldConverter(object):\n+class DefaultDexterityTextIndexFieldConverter:\n     """Fallback field converter which uses the rendered widget in display\n     mode for generating a indexable string.\n     """\n@@ -42,14 +40,14 @@ def __init__(self, context, field, widget):\n     def convert(self):\n         """Convert the adapted field value to text/plain for indexing"""\n         html = self.widget.render().strip()\n-        transforms = api.portal.get_tool(\'portal_transforms\')\n-        stream = transforms.convertTo(\'text/plain\', html, mimetype=\'text/html\')\n+        transforms = api.portal.get_tool("portal_transforms")\n+        stream = transforms.convertTo("text/plain", html, mimetype="text/html")\n         return stream.getData().strip()\n \n \n @implementer(interfaces.IDexterityTextIndexFieldConverter)\n @adapter(IDexterityContent, IRichText, IWidget)\n-class DexterityRichTextIndexFieldConverter(object):\n+class DexterityRichTextIndexFieldConverter:\n     """Fallback field converter which uses the rendered widget in display\n     mode for generating a indexable string.\n     """\n@@ -63,57 +61,58 @@ def convert(self):\n         """Convert a rich text field value to text/plain for indexing"""\n         textvalue = self.field.get(self.context)\n         if textvalue is None:\n-            return \'\'\n+            return ""\n         html = safe_unicode(textvalue.output)\n-        transforms = api.portal.get_tool(\'portal_transforms\')\n-        stream = transforms.convertTo(\n-            \'text/plain\', html, mimetype=textvalue.mimeType\n-        )\n+        transforms = api.portal.get_tool("portal_transforms")\n+        stream = transforms.convertTo("text/plain", html, mimetype=textvalue.mimeType)\n         return stream.getData().strip()\n \n \n @implementer(interfaces.IDexterityTextIndexFieldConverter)\n @adapter(IDexterityContent, INamedFileField, IWidget)\n class NamedfileFieldConverter(DefaultDexterityTextIndexFieldConverter):\n-    """Converts the file data of a named file using portal_transforms.\n-    """\n+    """Converts the file data of a named file using portal_transforms."""\n \n     def convert(self):\n-        """Transforms file data to text for indexing safely.\n-        """\n+        """Transforms file data to text for indexing safely."""\n         storage = self.field.interface(self.context)\n         data = self.field.get(storage)\n \n         # if there is no data, do nothing\n         if not data or data.getSize() == 0:\n-            return \'\'\n+            return ""\n \n         # if data is already in text/plain, just return it\n-        if data.contentType == \'text/plain\':\n+        if data.contentType == "text/plain":\n             return data.data\n \n         # if there is no path to text/plain, do nothing\n-        transforms = api.portal.get_tool(\'portal_transforms\')\n+        transforms = api.portal.get_tool("portal_transforms")\n \n         # pylint: disable=W0212\n         # W0212: Access to a protected member _findPath of a client class\n-        if not transforms._findPath(data.contentType, \'text/plain\'):\n-            return \'\'\n+        if not transforms._findPath(data.contentType, "text/plain"):\n+            return ""\n         # pylint: enable=W0212\n \n         # convert it to text/plain\n         try:\n             datastream = transforms.convertTo(\n-                \'text/plain\', data.data, mimetype=data.contentType,\n-                filename=data.filename)\n+                "text/plain",\n+                data.data,\n+                mimetype=data.contentType,\n+                filename=data.filename,\n+            )\n             return datastream.getData()\n \n         except (ConflictError, KeyboardInterrupt):\n             raise\n \n         except Exception as e:\n-            LOGGER.error(\'Error while trying to convert file contents \'\n-                            \'to "text/plain": %s\', str(e))\n+            LOGGER.error(\n+                "Error while trying to convert file contents " \'to "text/plain": %s\',\n+                str(e),\n+            )\n \n \n @implementer(interfaces.IDexterityTextIndexFieldConverter)\n@@ -140,4 +139,4 @@ def convert(self):\n         if self.field.get(storage):\n             for value in self.field.get(storage):\n                 result.append(value)\n-        return \' \'.join(result)\n+        return " ".join(result)\ndiff --git a/plone/app/dexterity/textindexer/directives.py b/plone/app/dexterity/textindexer/directives.py\nindex 46f43e6..e4526a1 100644\n--- a/plone/app/dexterity/textindexer/directives.py\n+++ b/plone/app/dexterity/textindexer/directives.py\n@@ -1,26 +1,25 @@\n-# -*- coding: utf-8 -*-\n from plone.supermodel.directives import MetadataListDirective\n from zope.interface import Interface\n from zope.interface.interfaces import IInterface\n \n \n-SEARCHABLE_KEY = u\'plone.app.dexterity.textindexer.searchable\'\n+SEARCHABLE_KEY = "plone.app.dexterity.textindexer.searchable"\n \n \n class searchable(MetadataListDirective):\n-    """Directive used to mark a field as searchable.\n-    """\n+    """Directive used to mark a field as searchable."""\n \n     key = SEARCHABLE_KEY\n-    value = \'true\'\n+    value = "true"\n \n     def factory(self, *args):\n         """The searchable directive accepts as arguments one or more\n         fieldnames (string) of fields which should be searchable.\n         """\n         if not args:\n-            raise TypeError(\'The searchable directive expects at \'\n-                            \'least one argument.\')\n+            raise TypeError(\n+                "The searchable directive expects at " "least one argument."\n+            )\n \n         form_interface = Interface\n         if IInterface.providedBy(args[0]):\ndiff --git a/plone/app/dexterity/textindexer/indexer.py b/plone/app/dexterity/textindexer/indexer.py\nindex 837eee0..b77da9c 100644\n--- a/plone/app/dexterity/textindexer/indexer.py\n+++ b/plone/app/dexterity/textindexer/indexer.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """Contains the indexer and some helper methods for indexing.\n """\n \n@@ -24,12 +23,11 @@\n import logging\n \n \n-LOGGER = logging.getLogger(\'plone.app.dexterity.textindexer\')\n+LOGGER = logging.getLogger("plone.app.dexterity.textindexer")\n \n \n-class FakeView(object):\n-    """This fake view is used for enabled z3c forms z2 mode on.\n-    """\n+class FakeView:\n+    """This fake view is used for enabled z3c forms z2 mode on."""\n \n     def __init__(self, context, request):\n         self.context = context\n@@ -38,8 +36,7 @@ def __init__(self, context, request):\n \n @indexer(IDexterityTextIndexer)\n def dynamic_searchable_text_indexer(obj):\n-    """Dynamic searchable text indexer.\n-    """\n+    """Dynamic searchable text indexer."""\n     # if the object does not provide a request, get one.\n     # This happens when running scripts (bin/instance run script.py)\n     try:\n@@ -61,8 +58,7 @@ def dynamic_searchable_text_indexer(obj):\n \n             # we need the form-field, not the schema-field we\n             # already have..\n-            form_field = Field(field, interface=field.interface,\n-                               prefix=\'\')\n+            form_field = Field(field, interface=field.interface, prefix="")\n \n             # get the widget\n             try:\n@@ -74,8 +70,8 @@ def dynamic_searchable_text_indexer(obj):\n \n             # get the converter for this field / widget\n             converter = getMultiAdapter(\n-                (obj, field, widget),\n-                interfaces.IDexterityTextIndexFieldConverter)\n+                (obj, field, widget), interfaces.IDexterityTextIndexFieldConverter\n+            )\n \n             # convert the field value\n             value = converter.convert()\n@@ -86,16 +82,16 @@ def dynamic_searchable_text_indexer(obj):\n                 continue\n \n             # only accept strings\n-            assert isinstance(value, str), \'expected converted \' + \\\n-                \'value of IDexterityTextIndexFieldConverter to be a str\'\n+            assert isinstance(value, str), (\n+                "expected converted "\n+                + "value of IDexterityTextIndexFieldConverter to be a str"\n+            )\n \n             indexed.append(value)\n \n     # after converting all fields, run additional\n     # IDynamicTextIndexExtender adapters.\n-    for _name, adapter in getAdapters(\n-        (obj,), interfaces.IDynamicTextIndexExtender\n-    ):\n+    for _name, adapter in getAdapters((obj,), interfaces.IDynamicTextIndexExtender):\n         extended_value = adapter()\n \n         # if no value was returned, we don\'t need to index anything.\n@@ -103,12 +99,13 @@ def dynamic_searchable_text_indexer(obj):\n             continue\n \n         # only accept strings\n-        assert isinstance(extended_value, str), \'expected converted \' + \\\n-            \'value of IDynamicTextIndexExtender to be a str\'\n+        assert isinstance(extended_value, str), (\n+            "expected converted " + "value of IDynamicTextIndexExtender to be a str"\n+        )\n \n         indexed.append(extended_value)\n \n-    return \' \'.join(indexed)\n+    return " ".join(indexed)\n \n \n def get_field_widget(obj, field, request):\n@@ -117,16 +114,15 @@ def get_field_widget(obj, field, request):\n     The `field` should be a z3c form field, not a zope schema field.\n     """\n \n-    assert IField.providedBy(field), \'field is not a form field\'\n+    assert IField.providedBy(field), "field is not a form field"\n \n     if field.widgetFactory.get(DISPLAY_MODE) is not None:\n         factory = field.widgetFactory.get(DISPLAY_MODE)\n         widget = factory(field.field, request)\n     else:\n-        widget = getMultiAdapter(\n-            (field.field, request), IFieldWidget)\n-    widget.name = \'\' + field.__name__  # prefix not needed\n-    widget.id = widget.name.replace(\'.\', \'-\')\n+        widget = getMultiAdapter((field.field, request), IFieldWidget)\n+    widget.name = "" + field.__name__  # prefix not needed\n+    widget.id = widget.name.replace(".", "-")\n     widget.context = obj\n     alsoProvides(widget, IContextAware)\n     widget.mode = DISPLAY_MODE\n@@ -150,7 +146,7 @@ def get_searchable_contexts_and_fields(obj):\n         for _i, name, _v in tagged_values:\n             field = schema.getFields(schemata).get(name)\n             if not field:\n-                dottedname = \'.\'.join((schemata.__module__, schemata.__name__))\n+                dottedname = ".".join((schemata.__module__, schemata.__name__))\n                 logging.error(\'%s has no field "%s"\', dottedname, name)\n \n             elif field not in fields:\ndiff --git a/plone/app/dexterity/textindexer/interfaces.py b/plone/app/dexterity/textindexer/interfaces.py\nindex 4eb18d5..03340ea 100644\n--- a/plone/app/dexterity/textindexer/interfaces.py\n+++ b/plone/app/dexterity/textindexer/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """\n IDexterityTextIndexFieldConverter  field converter adapter interface\n IDynamicTextIndexExtender          dynmaic text extender adapter interface\n@@ -8,8 +7,8 @@\n \n \n # Supermodel namespace and prefix\n-INDEXER_NAMESPACE = \'http://namespaces.plone.org/supermodel/indexer\'\n-INDEXER_PREFIX = \'indexer\'\n+INDEXER_NAMESPACE = "http://namespaces.plone.org/supermodel/indexer"\n+INDEXER_PREFIX = "indexer"\n \n \n class IDexterityTextIndexFieldConverter(Interface):\n@@ -19,8 +18,7 @@ class IDexterityTextIndexFieldConverter(Interface):\n     """\n \n     def __init__(self, context, field, widget):\n-        """The multi-adpater adapts the context, the field and the widget.\n-        """\n+        """The multi-adpater adapts the context, the field and the widget."""\n \n     def convert(self):\n         """Returns a string containing the words to index. Translatable\ndiff --git a/plone/app/dexterity/textindexer/schemaeditor.py b/plone/app/dexterity/textindexer/schemaeditor.py\nindex c48fdc5..a9e7d44 100644\n--- a/plone/app/dexterity/textindexer/schemaeditor.py\n+++ b/plone/app/dexterity/textindexer/schemaeditor.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n from plone.app.dexterity.textindexer.interfaces import INDEXER_NAMESPACE\n from plone.app.dexterity.textindexer.interfaces import INDEXER_PREFIX\n@@ -12,19 +11,16 @@\n from zope.schema.interfaces import IField\n \n \n-_ = MessageFactory(\'plone.app.dexterity.textindexer\')\n+_ = MessageFactory("plone.app.dexterity.textindexer")\n \n \n class ISearchableTextField(Interface):\n-    searchable = schema.Bool(\n-        title=_(\'Searchable\'),\n-        required=False\n-    )\n+    searchable = schema.Bool(title=_("Searchable"), required=False)\n \n \n @adapter(IField)\n @implementer(ISearchableTextField)\n-class SearchableTextField(object):\n+class SearchableTextField:\n \n     namespace = INDEXER_NAMESPACE\n     prefix = INDEXER_PREFIX\n@@ -37,7 +33,7 @@ def _read_searchable(self):\n         tagged_value = self.schema.queryTaggedValue(SEARCHABLE_KEY, [])\n \n         name = self.field.__name__\n-        value = (Interface, name, \'true\')\n+        value = (Interface, name, "true")\n \n         return value in tagged_value\n \n@@ -45,8 +41,8 @@ def _write_searchable(self, value):\n         tagged_value = self.schema.queryTaggedValue(SEARCHABLE_KEY, [])\n \n         name = self.field.__name__\n-        new_value = (Interface, name, bool(value) and \'true\' or \'false\')\n-        old_value = (Interface, name, bool(value) and \'false\' or \'true\')\n+        new_value = (Interface, name, bool(value) and "true" or "false")\n+        old_value = (Interface, name, bool(value) and "false" or "true")\n \n         while old_value in tagged_value:\n             tagged_value.remove(old_value)\n@@ -66,8 +62,7 @@ def _write_searchable(self, value):\n @adapter(ISchemaContext, IField)\n @implementer(IFieldEditorExtender)\n def get_searchabletext_schema(schema_context, field):\n-    behavior = \\\n-        \'plone.textindexer\'\n-    fti = getattr(schema_context, \'fti\', None)\n-    if fti and behavior in getattr(fti, \'behaviors\', []):\n+    behavior = "plone.textindexer"\n+    fti = getattr(schema_context, "fti", None)\n+    if fti and behavior in getattr(fti, "behaviors", []):\n         return ISearchableTextField\ndiff --git a/plone/app/dexterity/textindexer/supermodel.py b/plone/app/dexterity/textindexer/supermodel.py\nindex 2c8068e..9893b48 100644\n--- a/plone/app/dexterity/textindexer/supermodel.py\n+++ b/plone/app/dexterity/textindexer/supermodel.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n from plone.app.dexterity.textindexer.interfaces import INDEXER_NAMESPACE\n from plone.app.dexterity.textindexer.interfaces import INDEXER_PREFIX\n@@ -9,9 +8,8 @@\n \n \n @implementer(IFieldMetadataHandler)\n-class IndexerSchema(object):\n-    """Support the indexer: namespace in model definitions.\n-    """\n+class IndexerSchema:\n+    """Support the indexer: namespace in model definitions."""\n \n     namespace = INDEXER_NAMESPACE\n     prefix = INDEXER_PREFIX\n@@ -23,10 +21,10 @@ def _add_searchable(self, schema, value):\n \n     def read(self, fieldNode, schema, field):\n         name = field.__name__\n-        searchable = fieldNode.get(ns(\'searchable\', self.namespace))\n+        searchable = fieldNode.get(ns("searchable", self.namespace))\n \n         if searchable:\n-            value = (Interface, name, \'true\')\n+            value = (Interface, name, "true")\n             self._add_searchable(schema, value)\n \n     def write(self, fieldNode, schema, field):\n@@ -35,4 +33,4 @@ def write(self, fieldNode, schema, field):\n         field_names = [fld[1] for fld in searchable]\n \n         if name in field_names:\n-            fieldNode.set(ns(\'searchable\', self.namespace), \'true\')\n+            fieldNode.set(ns("searchable", self.namespace), "true")\ndiff --git a/plone/app/dexterity/textindexer/testing.py b/plone/app/dexterity/textindexer/testing.py\nindex 6e58a62..84ccb4a 100644\n--- a/plone/app/dexterity/textindexer/testing.py\n+++ b/plone/app/dexterity/textindexer/testing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """Testing setup providing layers and fixtures\n TextIndexerLayer                   basic text indexer layer\n TEXT_INDEXER_FIXTURE               text indexer fixture\n@@ -22,36 +21,36 @@ class TextIndexerLayer(PloneSandboxLayer):\n     defaultBases = (PLONE_FIXTURE,)\n \n     def __init__(self, *args, **kwargs):\n-        super(TextIndexerLayer, self).__init__(*args, **kwargs)\n+        super().__init__(*args, **kwargs)\n         self.log = None\n         self.log_handler = None\n \n     def setUpZope(self, app, configurationContext):\n-        """After setting up zope, load all necessary zcml files.\n-        """\n+        """After setting up zope, load all necessary zcml files."""\n         import plone.app.dexterity.textindexer\n+\n         self.loadZCML(\n-            package=plone.app.dexterity.textindexer,\n-            context=configurationContext)\n+            package=plone.app.dexterity.textindexer, context=configurationContext\n+        )\n         import plone.app.dexterity.textindexer.tests\n+\n         self.loadZCML(\n-            package=plone.app.dexterity.textindexer.tests,\n-            context=configurationContext)\n+            package=plone.app.dexterity.textindexer.tests, context=configurationContext\n+        )\n \n     def setUpPloneSite(self, portal):\n-        """After setting up plone, give Manager role to the test user.\n-        """\n-        setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+        """After setting up plone, give Manager role to the test user."""\n+        setRoles(portal, TEST_USER_ID, ["Manager"])\n \n     def testSetUp(self):\n-        super(TextIndexerLayer, self).testSetUp()\n+        super().testSetUp()\n         self.log = StringIO()\n         self.log_handler = logging.StreamHandler(self.log)\n         logging.root.addHandler(self.log_handler)\n-        self[\'read_log\'] = self.read_log\n+        self["read_log"] = self.read_log\n \n     def testTearDown(self):\n-        super(TextIndexerLayer, self).testTearDown()\n+        super().testTearDown()\n         logging.root.removeHandler(self.log_handler)\n \n     def read_log(self):\n@@ -61,8 +60,8 @@ def read_log(self):\n \n TEXT_INDEXER_FIXTURE = TextIndexerLayer()\n TEXT_INTEXER_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(TEXT_INDEXER_FIXTURE,),\n-    name=\'plone.app.dexterity.textindexer:Integration\')\n+    bases=(TEXT_INDEXER_FIXTURE,), name="plone.app.dexterity.textindexer:Integration"\n+)\n \n \n class TextIndexerFunctionalLayer(PloneSandboxLayer):\n@@ -71,17 +70,16 @@ class TextIndexerFunctionalLayer(PloneSandboxLayer):\n \n     def setUpZope(self, app, configurationContext):\n         import plone.app.dexterity\n-        self.loadZCML(\n-            package=plone.app.dexterity,\n-            context=configurationContext)\n+\n+        self.loadZCML(package=plone.app.dexterity, context=configurationContext)\n \n     def setUpPloneSite(self, portal):\n-        self.applyProfile(portal, \'plone.app.dexterity:default\')\n+        self.applyProfile(portal, "plone.app.dexterity:default")\n \n \n TEXT_INDEXER_FUNCTIONAL_FIXTURE = TextIndexerFunctionalLayer()\n \n TEXT_INDEXER_FUNCTIONAL_TESTING = FunctionalTesting(\n     bases=(TEXT_INDEXER_FUNCTIONAL_FIXTURE,),\n-    name=\'plone.app.dexterity.textindexer:Functional\'\n+    name="plone.app.dexterity.textindexer:Functional",\n )\ndiff --git a/plone/app/dexterity/textindexer/tests/__init__.py b/plone/app/dexterity/textindexer/tests/__init__.py\nindex 2242eb2..5bfeab4 100644\n--- a/plone/app/dexterity/textindexer/tests/__init__.py\n+++ b/plone/app/dexterity/textindexer/tests/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """Testing module containing the tests\n for plone.app.dexterity.textindexer.\n """\ndiff --git a/plone/app/dexterity/textindexer/tests/behaviors.py b/plone/app/dexterity/textindexer/tests/behaviors.py\nindex 254dd80..3ac2646 100644\n--- a/plone/app/dexterity/textindexer/tests/behaviors.py\n+++ b/plone/app/dexterity/textindexer/tests/behaviors.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """Contains different behaviors needed for testing.\n """\n from plone.app.dexterity import textindexer\n@@ -11,75 +10,74 @@\n \n @provider(IFormFieldProvider)\n class ISimpleBehavior(model.Schema):\n-    """Simple behavior containing simple text line fields.\n-    """\n+    """Simple behavior containing simple text line fields."""\n \n-    textindexer.searchable(\'foo\')\n-    foo = schema.TextLine(title=u\'Foo\')\n+    textindexer.searchable("foo")\n+    foo = schema.TextLine(title="Foo")\n \n-    bar = schema.TextLine(title=u\'Bar\')\n+    bar = schema.TextLine(title="Bar")\n \n \n @provider(IFormFieldProvider)\n class IListBehavior(model.Schema):\n-    """More advanced behavior with a list of fields.\n-    """\n+    """More advanced behavior with a list of fields."""\n \n-    textindexer.searchable(\'list_field\')\n+    textindexer.searchable("list_field")\n \n-    list_field = schema.List(\n-        title=u\'List field\',\n-        value_type=schema.TextLine()\n-    )\n+    list_field = schema.List(title="List field", value_type=schema.TextLine())\n \n \n @provider(IFormFieldProvider)\n class IIntBehavior(model.Schema):\n-    """Basic behavior with a integer field.\n-    """\n+    """Basic behavior with a integer field."""\n \n-    textindexer.searchable(\'int_field\')\n-    int_field = schema.Int(title=u\'Int\')\n+    textindexer.searchable("int_field")\n+    int_field = schema.Int(title="Int")\n \n \n @provider(IFormFieldProvider)\n class IRichTextBehavior(model.Schema):\n-    """Basic behavior with a rich-text field.\n-    """\n+    """Basic behavior with a rich-text field."""\n \n-    textindexer.searchable(\'richtext_field\')\n+    textindexer.searchable("richtext_field")\n     richtext_field = RichText(\n-        title=u\'Body text\',\n-        default_mime_type=\'text/html\',\n-        output_mime_type=\'text/x-html\',\n-        allowed_mime_types=(\'text/html\', \'text/plain\',),\n-        default=u\'\',\n+        title="Body text",\n+        default_mime_type="text/html",\n+        output_mime_type="text/x-html",\n+        allowed_mime_types=(\n+            "text/html",\n+            "text/plain",\n+        ),\n+        default="",\n     )\n \n+\n @provider(IFormFieldProvider)\n class IEmptyRichTextBehavior(model.Schema):\n-    """Behavior with a rich-text field without a default value.\n-    """\n+    """Behavior with a rich-text field without a default value."""\n \n-    textindexer.searchable(\'foo\')\n-    foo = schema.TextLine(title=u\'Foo\')\n+    textindexer.searchable("foo")\n+    foo = schema.TextLine(title="Foo")\n \n-    textindexer.searchable(\'empty_richtext_field\')\n+    textindexer.searchable("empty_richtext_field")\n     empty_richtext_field = RichText(\n-        title=u\'Body text\',\n-        default_mime_type=\'text/html\',\n-        output_mime_type=\'text/x-html\',\n-        allowed_mime_types=(\'text/html\', \'text/plain\',),\n+        title="Body text",\n+        default_mime_type="text/html",\n+        output_mime_type="text/x-html",\n+        allowed_mime_types=(\n+            "text/html",\n+            "text/plain",\n+        ),\n     )\n \n+\n @provider(IFormFieldProvider)\n class ITupleBehavior(model.Schema):\n-    """Basic behavior with a tuple field.\n-    """\n+    """Basic behavior with a tuple field."""\n \n-    textindexer.searchable(\'tuple_field\')\n+    textindexer.searchable("tuple_field")\n     tuple_field = schema.Tuple(\n-        title=u\'Tuple\',\n+        title="Tuple",\n         value_type=schema.TextLine(),\n         required=False,\n         missing_value=(),\n@@ -88,15 +86,12 @@ class ITupleBehavior(model.Schema):\n \n @provider(IFormFieldProvider)\n class ITupleChoiceBehavior(model.Schema):\n-    """Basic behavior with a tuple choice field.\n-    """\n+    """Basic behavior with a tuple choice field."""\n \n-    textindexer.searchable(\'tuple_choice_field\')\n+    textindexer.searchable("tuple_choice_field")\n     tuple_choice_field = schema.Tuple(\n-        title=u\'Tuple choice\',\n-        value_type=schema.Choice(\n-            vocabulary=\'plone.app.vocabularies.Keywords\'\n-        ),\n+        title="Tuple choice",\n+        value_type=schema.Choice(vocabulary="plone.app.vocabularies.Keywords"),\n         required=False,\n         missing_value=(),\n     )\n@@ -104,16 +99,14 @@ class ITupleChoiceBehavior(model.Schema):\n \n @provider(IFormFieldProvider)\n class IInheritedBehavior(ISimpleBehavior):\n-    """Behavior extending from ISimpleBehavior for testing inheritance.\n-    """\n+    """Behavior extending from ISimpleBehavior for testing inheritance."""\n \n \n @provider(IFormFieldProvider)\n class IMissingFieldBehavior(model.Schema):\n-    """A behavior defining a field as searchable which does not exist.\n-    """\n+    """A behavior defining a field as searchable which does not exist."""\n \n-    textindexer.searchable(\'foo\')\n-    foo = schema.TextLine(title=u\'Foo\')\n+    textindexer.searchable("foo")\n+    foo = schema.TextLine(title="Foo")\n \n-    textindexer.searchable(\'bar\')\n+    textindexer.searchable("bar")\ndiff --git a/plone/app/dexterity/textindexer/tests/helpers.py b/plone/app/dexterity/textindexer/tests/helpers.py\nindex 96bb84a..3cb6486 100644\n--- a/plone/app/dexterity/textindexer/tests/helpers.py\n+++ b/plone/app/dexterity/textindexer/tests/helpers.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n from plone.supermodel.utils import mergedTaggedValueList\n \n@@ -6,8 +5,7 @@\n def get_searchable_fields(iface):\n     fieldnames = []\n \n-    for flag_iface, fieldname, value in mergedTaggedValueList(\n-            iface, SEARCHABLE_KEY):\n+    for flag_iface, fieldname, value in mergedTaggedValueList(iface, SEARCHABLE_KEY):\n         if flag_iface == iface and value:\n             fieldnames.append(fieldname)\n \ndiff --git a/plone/app/dexterity/textindexer/tests/test_basic_behavior.py b/plone/app/dexterity/textindexer/tests/test_basic_behavior.py\nindex 81597e2..0651f14 100644\n--- a/plone/app/dexterity/textindexer/tests/test_basic_behavior.py\n+++ b/plone/app/dexterity/textindexer/tests/test_basic_behavior.py\n@@ -1,13 +1,11 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.dexterity.textindexer.tests.helpers import get_searchable_fields\n from plone.app.dexterity.behaviors.metadata import IBasic\n+from plone.app.dexterity.textindexer.tests.helpers import get_searchable_fields\n from unittest import TestCase\n \n \n class TestBasicBehaviorIsSearchable(TestCase):\n-\n     def test_title_is_searchable(self):\n-        self.assertIn(\'title\', get_searchable_fields(IBasic))\n+        self.assertIn("title", get_searchable_fields(IBasic))\n \n     def test_description_is_searchable(self):\n-        self.assertIn(\'description\', get_searchable_fields(IBasic))\n+        self.assertIn("description", get_searchable_fields(IBasic))\ndiff --git a/plone/app/dexterity/textindexer/tests/test_behaviors.py b/plone/app/dexterity/textindexer/tests/test_behaviors.py\nindex 20a0f79..6e8e22c 100644\n--- a/plone/app/dexterity/textindexer/tests/test_behaviors.py\n+++ b/plone/app/dexterity/textindexer/tests/test_behaviors.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """Containing a tests suite for testing the behaviors.\n """\n \n@@ -13,17 +12,20 @@\n \n \n def test_suite():\n-    """Test suite testing the behaviors with a doctest from behaviors.txt\n-    """\n+    """Test suite testing the behaviors with a doctest from behaviors.txt"""\n     suite = unittest.TestSuite()\n-    suite.addTests([\n-        layered(doctest.DocFileSuite(\'behaviors.rst\'),\n-                layer=testing.TEXT_INTEXER_INTEGRATION_TESTING),\n-    ])\n+    suite.addTests(\n+        [\n+            layered(\n+                doctest.DocFileSuite("behaviors.rst"),\n+                layer=testing.TEXT_INTEXER_INTEGRATION_TESTING,\n+            ),\n+        ]\n+    )\n     return suite\n \n \n class ITestingSchema(model.Schema):\n \n     searchable("testing_field")\n-    testing_field = schema.TextLine(title=\'Testing field\')\n+    testing_field = schema.TextLine(title="Testing field")\ndiff --git a/plone/app/dexterity/textindexer/tests/test_directives.py b/plone/app/dexterity/textindexer/tests/test_directives.py\nindex f7ae010..0980dff 100644\n--- a/plone/app/dexterity/textindexer/tests/test_directives.py\n+++ b/plone/app/dexterity/textindexer/tests/test_directives.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.dexterity.textindexer.directives import searchable\n from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n from plone.supermodel import model\n@@ -11,10 +10,8 @@\n \n \n class TestDirectives(unittest.TestCase):\n-\n     def tearDown(self):\n-        """Tear down the testing setup.\n-        """\n+        """Tear down the testing setup."""\n         zope.component.testing.tearDown()\n \n     def test_schema_directives_store_tagged_values(self):\n@@ -23,14 +20,14 @@ def test_schema_directives_store_tagged_values(self):\n         """\n \n         class IDummy(model.Schema):\n-            """Dummy schema class.\n-            """\n-            searchable(\'foo\')\n-            foo = schema.TextLine(title=u\'Foo\')\n+            """Dummy schema class."""\n+\n+            searchable("foo")\n+            foo = schema.TextLine(title="Foo")\n \n         self.assertEqual(\n-            [(Interface, \'foo\', \'true\')],\n-            mergedTaggedValueList(IDummy, SEARCHABLE_KEY))\n+            [(Interface, "foo", "true")], mergedTaggedValueList(IDummy, SEARCHABLE_KEY)\n+        )\n \n     def test_inherited_schema_still_has_tagged_value(self):\n         """An inherited schema should still have the tagged value information\n@@ -38,18 +35,17 @@ def test_inherited_schema_still_has_tagged_value(self):\n         """\n \n         class IFoo(model.Schema):\n-            """Class with a searchable field\n-            """\n-            searchable(\'baz\')\n-            baz = schema.TextLine(title=u\'baz\')\n+            """Class with a searchable field"""\n+\n+            searchable("baz")\n+            baz = schema.TextLine(title="baz")\n \n         class IBar(IFoo):\n-            """Schema class which inherits a field from IFoo.\n-            """\n+            """Schema class which inherits a field from IFoo."""\n \n         self.assertEqual(\n-            [(Interface, \'baz\', \'true\')],\n-            mergedTaggedValueList(IFoo, SEARCHABLE_KEY))\n+            [(Interface, "baz", "true")], mergedTaggedValueList(IFoo, SEARCHABLE_KEY)\n+        )\n         self.assertEqual(\n-            [(Interface, \'baz\', \'true\')],\n-            mergedTaggedValueList(IBar, SEARCHABLE_KEY))\n+            [(Interface, "baz", "true")], mergedTaggedValueList(IBar, SEARCHABLE_KEY)\n+        )\ndiff --git a/plone/app/dexterity/textindexer/tests/test_schemaeditor.py b/plone/app/dexterity/textindexer/tests/test_schemaeditor.py\nindex 84c256a..3db1abc 100644\n--- a/plone/app/dexterity/textindexer/tests/test_schemaeditor.py\n+++ b/plone/app/dexterity/textindexer/tests/test_schemaeditor.py\n@@ -1,6 +1,5 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.dexterity.textindexer.testing import TEXT_INDEXER_FUNCTIONAL_TESTING  # noqa\n from plone import api\n+from plone.app.dexterity.textindexer.testing import TEXT_INDEXER_FUNCTIONAL_TESTING\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n@@ -17,14 +16,12 @@ class TestSchemaEditor(unittest.TestCase):\n     layer = TEXT_INDEXER_FUNCTIONAL_TESTING\n \n     def setUp(self):\n-        portal_types = api.portal.get_tool(\'portal_types\')\n+        portal_types = api.portal.get_tool("portal_types")\n \n         # Define new portal type without behavior\n-        fti = DexterityFTI(str(\'without_behavior\'), title=\'Without Behavior\')\n-        fti.behaviors = (\n-            \'plone.app.dexterity.behaviors.metadata.IBasic\',\n-        )\n-        fti.model_source = u"""\\\n+        fti = DexterityFTI("without_behavior", title="Without Behavior")\n+        fti.behaviors = ("plone.app.dexterity.behaviors.metadata.IBasic",)\n+        fti.model_source = """\\\n <model xmlns="http://namespaces.plone.org/supermodel/schema">\n <schema>\n <field name="custom" type="zope.schema.TextLine">\n@@ -34,15 +31,15 @@ def setUp(self):\n </field>\n </schema>\n </model>"""\n-        portal_types._setObject(str(\'without_behavior\'), fti)\n+        portal_types._setObject("without_behavior", fti)\n \n         # Define new portal type with behavior\n-        fti = DexterityFTI(str(\'with_behavior\'), title=\'With Behavior\')\n+        fti = DexterityFTI("with_behavior", title="With Behavior")\n         fti.behaviors = (\n-            \'plone.app.dexterity.behaviors.metadata.IBasic\',\n-            \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\'\n+            "plone.app.dexterity.behaviors.metadata.IBasic",\n+            "plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer",\n         )\n-        fti.model_source = u"""\\\n+        fti.model_source = """\\\n <model xmlns="http://namespaces.plone.org/supermodel/schema">\n <schema>\n <field name="custom" type="zope.schema.TextLine">\n@@ -52,59 +49,50 @@ def setUp(self):\n </field>\n </schema>\n </model>"""\n-        portal_types._setObject(str(\'with_behavior\'), fti)\n+        portal_types._setObject("with_behavior", fti)\n \n-        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Manager\'])\n+        setRoles(self.layer["portal"], TEST_USER_ID, ["Manager"])\n         transaction.commit()\n \n-        self.browser = Browser(self.layer[\'app\'])\n+        self.browser = Browser(self.layer["app"])\n         self.browser.addHeader(\n-            \'Authorization\', \'Basic {0}:{1}\'.format(\n-                TEST_USER_NAME, TEST_USER_PASSWORD))\n-        self.portal_url = self.layer[\'portal\'].absolute_url()\n+            "Authorization", f"Basic {TEST_USER_NAME}:{TEST_USER_PASSWORD}"\n+        )\n+        self.portal_url = self.layer["portal"].absolute_url()\n \n     def test_searchable_field_is_not_visible_without_behavior(self):\n-        self.browser.open(self.portal_url +\n-                          \'/dexterity-types/without_behavior/custom\')\n-        self.assertRaises(LookupError, self.browser.getControl, \'Searchable\')\n+        self.browser.open(self.portal_url + "/dexterity-types/without_behavior/custom")\n+        self.assertRaises(LookupError, self.browser.getControl, "Searchable")\n \n     def test_searchable_field_is_visible_with_behavior(self):\n-        self.browser.open(self.portal_url +\n-                          \'/dexterity-types/with_behavior/custom\')\n-        control = self.browser.getControl(\'Searchable\')\n-        self.assertEqual(control.control.type, \'checkbox\')\n+        self.browser.open(self.portal_url + "/dexterity-types/with_behavior/custom")\n+        control = self.browser.getControl("Searchable")\n+        self.assertEqual(control.control.type, "checkbox")\n \n     def test_searchable_field_is_disabled_by_default(self):\n-        self.browser.open(self.portal_url +\n-                          \'/dexterity-types/with_behavior/custom\')\n-        self.assertFalse(\n-            self.browser.getControl(\'Searchable\').selected)\n+        self.browser.open(self.portal_url + "/dexterity-types/with_behavior/custom")\n+        self.assertFalse(self.browser.getControl("Searchable").selected)\n \n     def test_searchable_field_change_is_saved(self):\n-        portal_types = api.portal.get_tool(\'portal_types\')\n-        fti = portal_types[\'with_behavior\']\n+        portal_types = api.portal.get_tool("portal_types")\n+        fti = portal_types["with_behavior"]\n         self.assertNotIn(\'indexer:searchable="true"\', fti.model_source)\n \n-        self.browser.open(self.portal_url +\n-                          \'/dexterity-types/with_behavior/custom\')\n-        self.browser.getControl(\'Searchable\').click()\n-        self.browser.getControl(\'Save\').click()\n+        self.browser.open(self.portal_url + "/dexterity-types/with_behavior/custom")\n+        self.browser.getControl("Searchable").click()\n+        self.browser.getControl("Save").click()\n \n-        self.browser.open(\n-            self.portal_url + \'/dexterity-types/with_behavior/custom\')\n-        self.assertTrue(\n-            self.browser.getControl(\'Searchable\').selected)\n+        self.browser.open(self.portal_url + "/dexterity-types/with_behavior/custom")\n+        self.assertTrue(self.browser.getControl("Searchable").selected)\n \n         fti._p_jar.sync()\n         self.assertIn(\'indexer:searchable="true"\', fti.model_source)\n \n-        self.browser.getControl(\'Searchable\').click()\n-        self.browser.getControl(\'Save\').click()\n+        self.browser.getControl("Searchable").click()\n+        self.browser.getControl("Save").click()\n \n-        self.browser.open(\n-            self.portal_url + \'/dexterity-types/with_behavior/custom\')\n-        self.assertFalse(\n-            self.browser.getControl(\'Searchable\').selected)\n+        self.browser.open(self.portal_url + "/dexterity-types/with_behavior/custom")\n+        self.assertFalse(self.browser.getControl("Searchable").selected)\n \n         fti._p_jar.sync()\n         self.assertNotIn(\'indexer:searchable="true"\', fti.model_source)\ndiff --git a/plone/app/dexterity/textindexer/tests/test_supermodel_handler.py b/plone/app/dexterity/textindexer/tests/test_supermodel_handler.py\nindex bcc5032..be09d3c 100644\n--- a/plone/app/dexterity/textindexer/tests/test_supermodel_handler.py\n+++ b/plone/app/dexterity/textindexer/tests/test_supermodel_handler.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n from plone.app.dexterity.textindexer.supermodel import IndexerSchema\n from plone.supermodel.utils import ns\n@@ -10,108 +9,99 @@\n \n \n class TestIndexerSchema(unittest.TestCase):\n-    """Tests for the supermodel field metadata handler.\n-    """\n+    """Tests for the supermodel field metadata handler."""\n \n-    namespace = \'http://namespaces.plone.org/supermodel/indexer\'\n+    namespace = "http://namespaces.plone.org/supermodel/indexer"\n \n     def test_read(self):\n-        field_node = ElementTree.Element(\'field\')\n-        field_node.set(ns(\'searchable\', self.namespace), \'true\')\n+        field_node = ElementTree.Element("field")\n+        field_node.set(ns("searchable", self.namespace), "true")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy\')\n+            dummy = zope.schema.TextLine(title="dummy")\n \n         handler = IndexerSchema()\n-        handler.read(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.read(field_node, IDummy, IDummy["dummy"])\n \n         self.assertEqual(\n-            [(Interface, \'dummy\', \'true\')],\n-            IDummy.getTaggedValue(SEARCHABLE_KEY))\n+            [(Interface, "dummy", "true")], IDummy.getTaggedValue(SEARCHABLE_KEY)\n+        )\n \n     def test_read_multiple(self):\n-        field_node1 = ElementTree.Element(\'field\')\n-        field_node1.set(ns(\'searchable\', self.namespace), \'true\')\n+        field_node1 = ElementTree.Element("field")\n+        field_node1.set(ns("searchable", self.namespace), "true")\n \n-        field_node2 = ElementTree.Element(\'field\')\n+        field_node2 = ElementTree.Element("field")\n \n-        field_node3 = ElementTree.Element(\'field\')\n-        field_node3.set(ns(\'searchable\', self.namespace), \'true\')\n+        field_node3 = ElementTree.Element("field")\n+        field_node3.set(ns("searchable", self.namespace), "true")\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.TextLine(title=u\'dummy1\')\n-            dummy2 = zope.schema.TextLine(title=u\'dummy2\')\n-            dummy3 = zope.schema.TextLine(title=u\'dummy3\')\n+            dummy1 = zope.schema.TextLine(title="dummy1")\n+            dummy2 = zope.schema.TextLine(title="dummy2")\n+            dummy3 = zope.schema.TextLine(title="dummy3")\n \n         handler = IndexerSchema()\n-        handler.read(field_node1, IDummy, IDummy[\'dummy1\'])\n-        handler.read(field_node2, IDummy, IDummy[\'dummy2\'])\n-        handler.read(field_node3, IDummy, IDummy[\'dummy3\'])\n+        handler.read(field_node1, IDummy, IDummy["dummy1"])\n+        handler.read(field_node2, IDummy, IDummy["dummy2"])\n+        handler.read(field_node3, IDummy, IDummy["dummy3"])\n \n-        self.assertEqual([\n-            (Interface, \'dummy1\', \'true\'),\n-            (Interface, \'dummy3\', \'true\')],\n-            IDummy.getTaggedValue(SEARCHABLE_KEY))\n+        self.assertEqual(\n+            [(Interface, "dummy1", "true"), (Interface, "dummy3", "true")],\n+            IDummy.getTaggedValue(SEARCHABLE_KEY),\n+        )\n \n     def test_read_no_data(self):\n-        field_node = ElementTree.Element(\'field\')\n+        field_node = ElementTree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+            dummy = zope.schema.TextLine(title="dummy1")\n \n         handler = IndexerSchema()\n-        handler.read(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.read(field_node, IDummy, IDummy["dummy"])\n \n         self.assertEqual(None, IDummy.queryTaggedValue(SEARCHABLE_KEY))\n \n     def test_write(self):\n-        field_node = ElementTree.Element(\'field\')\n+        field_node = ElementTree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+            dummy = zope.schema.TextLine(title="dummy1")\n \n-        IDummy.setTaggedValue(SEARCHABLE_KEY, [(Interface, \'dummy\', \'true\')])\n+        IDummy.setTaggedValue(SEARCHABLE_KEY, [(Interface, "dummy", "true")])\n \n         handler = IndexerSchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n-        self.assertEqual(\n-            \'true\',\n-            field_node.get(ns(\'searchable\', self.namespace)))\n+        self.assertEqual("true", field_node.get(ns("searchable", self.namespace)))\n \n     def test_write_partial(self):\n-        field_node = ElementTree.Element(\'field\')\n-        field_node2 = ElementTree.Element(\'field\')\n+        field_node = ElementTree.Element("field")\n+        field_node2 = ElementTree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy1\')\n-            dummy2 = zope.schema.TextLine(title=u\'dummy2\')\n+            dummy = zope.schema.TextLine(title="dummy1")\n+            dummy2 = zope.schema.TextLine(title="dummy2")\n \n-        IDummy.setTaggedValue(SEARCHABLE_KEY, [(Interface, \'dummy\', \'true\')])\n+        IDummy.setTaggedValue(SEARCHABLE_KEY, [(Interface, "dummy", "true")])\n \n         handler = IndexerSchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n-        handler.write(field_node2, IDummy, IDummy[\'dummy2\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n+        handler.write(field_node2, IDummy, IDummy["dummy2"])\n \n-        self.assertEqual(\n-            \'true\',\n-            field_node.get(ns(\'searchable\', self.namespace)))\n-        self.assertEqual(\n-            None,\n-            field_node2.get(ns(\'searchable\', self.namespace)))\n+        self.assertEqual("true", field_node.get(ns("searchable", self.namespace)))\n+        self.assertEqual(None, field_node2.get(ns("searchable", self.namespace)))\n \n     def test_write_no_data(self):\n-        field_node = ElementTree.Element(\'field\')\n+        field_node = ElementTree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+            dummy = zope.schema.TextLine(title="dummy1")\n \n         handler = IndexerSchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n-        self.assertEqual(\n-            None,\n-            field_node.get(ns(\'searchable\', self.namespace)))\n+        self.assertEqual(None, field_node.get(ns("searchable", self.namespace)))\n \n \n def test_suite():\ndiff --git a/plone/app/dexterity/textindexer/tests/test_utils.py b/plone/app/dexterity/textindexer/tests/test_utils.py\nindex 6f58cc9..1afc936 100644\n--- a/plone/app/dexterity/textindexer/tests/test_utils.py\n+++ b/plone/app/dexterity/textindexer/tests/test_utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.dexterity.textindexer.tests.helpers import get_searchable_fields\n from plone.app.dexterity.textindexer.utils import no_longer_searchable\n from plone.app.dexterity.textindexer.utils import searchable\n@@ -9,7 +8,7 @@\n \n class IExample(model.Schema):\n \n-    foo = schema.TextLine(title=u\'foo\')\n+    foo = schema.TextLine(title="foo")\n \n \n class IBar(model.Schema):\n@@ -17,40 +16,41 @@ class IBar(model.Schema):\n \n \n class IBaz(model.Schema):\n-    baz = schema.TextLine(title=u\'baz\')\n+    baz = schema.TextLine(title="baz")\n \n \n class TestUtils(TestCase):\n-    """Test utils module.\n-    """\n+    """Test utils module."""\n \n     def test_marking_field_as_searchable(self):\n         self.assertEqual(get_searchable_fields(IExample), [])\n-        searchable(IExample, u\'foo\')\n-        self.assertEqual(get_searchable_fields(IExample), [\'foo\'])\n+        searchable(IExample, "foo")\n+        self.assertEqual(get_searchable_fields(IExample), ["foo"])\n \n     def test_break_when_field_does_not_exist(self):\n         with self.assertRaises(AttributeError) as cm:\n-            searchable(IBar, u\'foo\')\n+            searchable(IBar, "foo")\n \n         self.assertEqual(\n             str(cm.exception),\n-            \'plone.app.dexterity.textindexer.tests.test_utils.IBar\'\n-            \' has no field "foo"\')\n+            "plone.app.dexterity.textindexer.tests.test_utils.IBar"\n+            \' has no field "foo"\',\n+        )\n \n     def test_no_longer_searchable_removes_flag(self):\n         self.assertEqual(get_searchable_fields(IBaz), [])\n-        searchable(IBaz, u\'baz\')\n-        self.assertEqual(get_searchable_fields(IBaz), [\'baz\'])\n-        self.assertTrue(no_longer_searchable(IBaz, \'baz\'))\n-        self.assertFalse(no_longer_searchable(IBaz, \'baz\'))\n+        searchable(IBaz, "baz")\n+        self.assertEqual(get_searchable_fields(IBaz), ["baz"])\n+        self.assertTrue(no_longer_searchable(IBaz, "baz"))\n+        self.assertFalse(no_longer_searchable(IBaz, "baz"))\n         self.assertEqual(get_searchable_fields(IBaz), [])\n \n     def test_no_longer_searchable_breaks_when_field_does_not_exist(self):\n         with self.assertRaises(AttributeError) as cm:\n-            no_longer_searchable(IBar, u\'foo\')\n+            no_longer_searchable(IBar, "foo")\n \n         self.assertEqual(\n             str(cm.exception),\n-            \'plone.app.dexterity.textindexer.tests.test_utils.IBar\'\n-            \' has no field "foo"\')\n+            "plone.app.dexterity.textindexer.tests.test_utils.IBar"\n+            \' has no field "foo"\',\n+        )\ndiff --git a/plone/app/dexterity/textindexer/utils.py b/plone/app/dexterity/textindexer/utils.py\nindex d5b51df..c39d99f 100644\n--- a/plone/app/dexterity/textindexer/utils.py\n+++ b/plone/app/dexterity/textindexer/utils.py\n@@ -1,26 +1,20 @@\n-# -*- coding: utf-8 -*-\n from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n from zope import schema\n \n \n def searchable(iface, field_name):\n     """\n-        mark a field in existing iface as searchable\n+    mark a field in existing iface as searchable\n     """\n \n     if schema.getFields(iface).get(field_name) is None:\n-        dottedname = \'.\'.join((iface.__module__, iface.__name__))\n-        raise AttributeError(\n-            \'{0} has no field "{1}"\'.format(\n-                dottedname,\n-                field_name\n-            )\n-        )\n+        dottedname = ".".join((iface.__module__, iface.__name__))\n+        raise AttributeError(f\'{dottedname} has no field "{field_name}"\')\n \n     store = iface.queryTaggedValue(SEARCHABLE_KEY)\n     if store is None:\n         store = []\n-    store.append((iface, field_name, \'true\'))\n+    store.append((iface, field_name, "true"))\n     iface.setTaggedValue(SEARCHABLE_KEY, store)\n \n \n@@ -30,19 +24,14 @@ def no_longer_searchable(iface, field_name):\n     """\n \n     if schema.getFields(iface).get(field_name) is None:\n-        dottedname = \'.\'.join((iface.__module__, iface.__name__))\n-        raise AttributeError(\n-            \'{0} has no field "{1}"\'.format(\n-                dottedname,\n-                field_name\n-            )\n-        )\n+        dottedname = ".".join((iface.__module__, iface.__name__))\n+        raise AttributeError(f\'{dottedname} has no field "{field_name}"\')\n \n     store = iface.queryTaggedValue(SEARCHABLE_KEY)\n     if store is None:\n         return False\n \n-    key = (iface, field_name, \'true\')\n+    key = (iface, field_name, "true")\n     if key not in store:\n         return False\n \ndiff --git a/setup.cfg b/setup.cfg\nindex ed50d96..b39c284 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -9,3 +9,10 @@ ignore =\n \n [bdist_wheel]\n universal = 1\n+\n+[isort]\n+# black compatible Plone isort rules:\n+profile = black\n+force_alphabetical_sort = True\n+force_single_line = True\n+lines_after_imports = 2\n'

Repository: plone.app.dexterity


Branch: refs/heads/master
Date: 2022-04-06T17:56:55+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.dexterity/commit/6edf7f1f0a07eece1e16fcfe4e6884ef92983774

Update docs/advanced/catalog-indexing-strategies.rst

Co-authored-by: Maik Derstappen &lt;md@derico.de&gt;

Files changed:
M docs/advanced/catalog-indexing-strategies.rst

b"diff --git a/docs/advanced/catalog-indexing-strategies.rst b/docs/advanced/catalog-indexing-strategies.rst\nindex 6df622b..4528d7f 100644\n--- a/docs/advanced/catalog-indexing-strategies.rst\n+++ b/docs/advanced/catalog-indexing-strategies.rst\n@@ -14,7 +14,7 @@ Plone's main index is called *SearchableText*. This is the index which is search\n \n So, you may need to explicitly add fields to SearchableText if you wish their information to be findable via the main search. There are all sorts of highly customizable ways to do this, but the easiest is to use the `plone.app.dexterity.textindexer  <https://github.com/collective/plone.app.dexterity.textindexer>`_ add-on package.\n \n-Add ``plone.app.dexterity.textindexer`` to your buildout and you will gain a new Dexterity behavior that will allow you to easily add fields to SearchableText. Once you turn on this behavior, you will then need to specify fields for addition to SearchableText.\n+Add ``plone.app.dexterity`` to your buildout and you will gain the new Dexterity behavior `plone.textindexer` that will allow you to easily add fields to SearchableText. Once you turn on this behavior, you will then need to specify fields for addition to SearchableText.\n \n .. note::\n \n"

Repository: plone.app.dexterity


Branch: refs/heads/master
Date: 2022-04-07T08:50:00+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.dexterity/commit/d70675ac709d742ec66be25c75fea8c22a3bccbd

use named behaviors in tests

Files changed:
M plone/app/dexterity/textindexer/tests/behaviors.rst
M plone/app/dexterity/textindexer/tests/test_schemaeditor.py

b'diff --git a/plone/app/dexterity/textindexer/tests/behaviors.rst b/plone/app/dexterity/textindexer/tests/behaviors.rst\nindex 39668ae..8d4e8aa 100644\n--- a/plone/app/dexterity/textindexer/tests/behaviors.rst\n+++ b/plone/app/dexterity/textindexer/tests/behaviors.rst\n@@ -34,7 +34,7 @@ First test it with a simple behavior::\n     >>> from plone.app.dexterity.textindexer.tests.behaviors import ISimpleBehavior\n     >>> fti = DexterityFTI(\'SimpleFTI\')\n     >>> fti.behaviors = (\n-    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.textindexer\',\n     ...     \'plone.app.dexterity.textindexer.tests.behaviors.ISimpleBehavior\',\n     ... )\n     >>> portal.portal_types._setObject(\'SimpleFTI\', fti)\n@@ -75,7 +75,7 @@ Does a list work?\n     >>> from plone.app.dexterity.textindexer.tests.behaviors import IListBehavior\n     >>> fti = DexterityFTI(\'ListFTI\')\n     >>> fti.behaviors = (\n-    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.textindexer\',\n     ...     \'plone.app.dexterity.textindexer.tests.behaviors.IListBehavior\',\n     ... )\n     >>> portal.portal_types._setObject(\'ListFTI\', fti)\n@@ -99,7 +99,7 @@ Do ints work?\n     >>> from plone.app.dexterity.textindexer.tests.behaviors import IIntBehavior\n     >>> fti = DexterityFTI(\'IntFTI\')\n     >>> fti.behaviors = (\n-    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.textindexer\',\n     ...     \'plone.app.dexterity.textindexer.tests.behaviors.IIntBehavior\',\n     ... )\n     >>> portal.portal_types._setObject(\'IntFTI\', fti)\n@@ -127,7 +127,7 @@ Do rich-text fields work?\n     >>> from plone.app.textfield.value import RichTextValue\n     >>> fti = DexterityFTI(\'RichTextFTI\')\n     >>> fti.behaviors = (\n-    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.textindexer\',\n     ...     \'plone.app.dexterity.textindexer.tests.behaviors.IRichTextBehavior\',\n     ... )\n     >>> portal.portal_types._setObject(\'RichTextFTI\', fti)\n@@ -159,7 +159,7 @@ Values are not duplicated in SearchableText when field comes from real interface\n     >>> from plone.app.dexterity.textindexer.tests.behaviors import ISimpleBehavior\n     >>> fti = DexterityFTI(\'SimpleFTI2\')\n     >>> fti.behaviors = (\n-    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.textindexer\',\n     ...     \'plone.app.dexterity.textindexer.tests.behaviors.ISimpleBehavior\',\n     ... )\n     >>> fti.model_source = \'<model xmlns="http://namespaces.plone.org/supermodel/schema" xmlns:i18n="http://xml.zope.org/namespaces/i18n" i18n:domain="plone"><schema based-on="plone.app.dexterity.textindexer.tests.test_behaviors.ITestingSchema"></schema></model>\'\n@@ -183,7 +183,7 @@ Do empty rich-text fields work?\n     >>> from plone.app.dexterity.textindexer.tests.behaviors import IEmptyRichTextBehavior\n     >>> fti = DexterityFTI(\'EmptyRichTextFTI\')\n     >>> fti.behaviors = (\n-    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.textindexer\',\n     ...     \'plone.app.dexterity.textindexer.tests.behaviors.IEmptyRichTextBehavior\',\n     ... )\n     >>> portal.portal_types._setObject(\'EmptyRichTextFTI\', fti)\n@@ -209,7 +209,7 @@ Do tuple fields work?\n     >>> from plone.app.dexterity.textindexer.tests.behaviors import IRichTextBehavior\n     >>> fti = DexterityFTI(\'TupleFTI\')\n     >>> fti.behaviors = (\n-    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.textindexer\',\n     ...     \'plone.app.dexterity.textindexer.tests.behaviors.ITupleBehavior\',\n     ... )\n     >>> portal.portal_types._setObject(\'TupleFTI\', fti)\n@@ -234,7 +234,7 @@ Do tuple fields with choice values work?\n     >>> from plone.app.dexterity.textindexer.tests.behaviors import IRichTextBehavior\n     >>> fti = DexterityFTI(\'TupleChoiceFTI\')\n     >>> fti.behaviors = (\n-    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.textindexer\',\n     ...     \'plone.app.dexterity.textindexer.tests.behaviors.ITupleChoiceBehavior\',\n     ... )\n     >>> portal.portal_types._setObject(\'TupleChoiceFTI\', fti)\n@@ -264,7 +264,7 @@ When a schema marks a field as searchable which does not exist it should:\n     >>> from plone.app.dexterity.textindexer.tests.behaviors import IMissingFieldBehavior\n     >>> fti = DexterityFTI(\'MissingFieldFTI\')\n     >>> fti.behaviors = (\n-    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.textindexer\',\n     ...     \'plone.app.dexterity.textindexer.tests.behaviors.IMissingFieldBehavior\',\n     ... )\n     >>> portal.portal_types._setObject(\'MissingFieldFTI\', fti)\n@@ -289,7 +289,7 @@ it\'s superclass::\n     >>> from plone.app.dexterity.textindexer.tests.behaviors import IInheritedBehavior\n     >>> fti = DexterityFTI(\'InheritedFTI\')\n     >>> fti.behaviors = (\n-    ...     \'plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer\',\n+    ...     \'plone.textindexer\',\n     ...     \'plone.app.dexterity.textindexer.tests.behaviors.IInheritedBehavior\',\n     ... )\n     >>> portal.portal_types._setObject(\'InheritedFTI\', fti)\ndiff --git a/plone/app/dexterity/textindexer/tests/test_schemaeditor.py b/plone/app/dexterity/textindexer/tests/test_schemaeditor.py\nindex 3db1abc..88317ac 100644\n--- a/plone/app/dexterity/textindexer/tests/test_schemaeditor.py\n+++ b/plone/app/dexterity/textindexer/tests/test_schemaeditor.py\n@@ -20,7 +20,7 @@ def setUp(self):\n \n         # Define new portal type without behavior\n         fti = DexterityFTI("without_behavior", title="Without Behavior")\n-        fti.behaviors = ("plone.app.dexterity.behaviors.metadata.IBasic",)\n+        fti.behaviors = ("plone.basic",)\n         fti.model_source = """\\\n <model xmlns="http://namespaces.plone.org/supermodel/schema">\n <schema>\n@@ -36,8 +36,8 @@ def setUp(self):\n         # Define new portal type with behavior\n         fti = DexterityFTI("with_behavior", title="With Behavior")\n         fti.behaviors = (\n-            "plone.app.dexterity.behaviors.metadata.IBasic",\n-            "plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer",\n+            "plone.basic",\n+            "plone.textindexer",\n         )\n         fti.model_source = """\\\n <model xmlns="http://namespaces.plone.org/supermodel/schema">\n'

Repository: plone.app.dexterity


Branch: refs/heads/master
Date: 2022-04-07T10:53:29+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.dexterity/commit/a69a3d3125e574eb4fc7fedee82698408b23f891

update docs

Files changed:
M docs/advanced/catalog-indexing-strategies.rst

b'diff --git a/docs/advanced/catalog-indexing-strategies.rst b/docs/advanced/catalog-indexing-strategies.rst\nindex 4528d7f..1b61743 100644\n--- a/docs/advanced/catalog-indexing-strategies.rst\n+++ b/docs/advanced/catalog-indexing-strategies.rst\n@@ -12,9 +12,9 @@ Making content searchable\n \n Plone\'s main index is called *SearchableText*. This is the index which is searched when you use the main portal search. Fields in your custom content types are not necessarily added to SearchableText. Fields added via Dublin-core behaviors are automatically part of SearchableText; others are not.\n \n-So, you may need to explicitly add fields to SearchableText if you wish their information to be findable via the main search. There are all sorts of highly customizable ways to do this, but the easiest is to use the `plone.app.dexterity.textindexer  <https://github.com/collective/plone.app.dexterity.textindexer>`_ add-on package.\n+So, you may need to explicitly add fields to SearchableText if you wish their information to be findable via the main search. There are all sorts of highly customizable ways to do this, but the easiest is to use the the behavior ``plone.textindexer`` that is shipped with plone.app.dexterity.\n \n-Add ``plone.app.dexterity`` to your buildout and you will gain the new Dexterity behavior `plone.textindexer` that will allow you to easily add fields to SearchableText. Once you turn on this behavior, you will then need to specify fields for addition to SearchableText.\n+It allows you to easily add fields to SearchableText. Once you turn on this behavior, you will then need to specify fields for addition to SearchableText.\n \n .. note::\n \n@@ -22,7 +22,7 @@ Add ``plone.app.dexterity`` to your buildout and you will gain the new Dexterity\n \n Once you have turned on the indexer behavior, edit the XML field model to add ``indexer:searchable="true"`` to the ``field`` tag for each field you wish to add to the SearchableText index.\n \n-See the `plone.app.dexterity.textindexer  <https://github.com/collective/plone.app.dexterity.textindexer>`_ package documentation for details and for information on how to use it via Python schema.\n+See the `/backend/indexing  <https://6-dev-docs.plone.org/backend/indexing>`_ package documentation for details and for information on how to use it via Python schema.\n \n \n Creating and using custom indexes\n'

Repository: plone.app.dexterity


Branch: refs/heads/master
Date: 2022-04-07T11:07:37+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.dexterity/commit/795ff3e1a3da949883dee0f7eb7d924b0ef861a5

Merge pull request #344 from plone/plip-2780-3

PLIP 2780: textindexer

Files changed:
A news/2780.feature
A plone/app/dexterity/textindexer/__init__.py
A plone/app/dexterity/textindexer/behavior.py
A plone/app/dexterity/textindexer/configure.zcml
A plone/app/dexterity/textindexer/converters.py
A plone/app/dexterity/textindexer/directives.py
A plone/app/dexterity/textindexer/indexer.py
A plone/app/dexterity/textindexer/interfaces.py
A plone/app/dexterity/textindexer/schemaeditor.py
A plone/app/dexterity/textindexer/supermodel.py
A plone/app/dexterity/textindexer/testing.py
A plone/app/dexterity/textindexer/tests/__init__.py
A plone/app/dexterity/textindexer/tests/behaviors.py
A plone/app/dexterity/textindexer/tests/behaviors.rst
A plone/app/dexterity/textindexer/tests/configure.zcml
A plone/app/dexterity/textindexer/tests/helpers.py
A plone/app/dexterity/textindexer/tests/test_basic_behavior.py
A plone/app/dexterity/textindexer/tests/test_behaviors.py
A plone/app/dexterity/textindexer/tests/test_directives.py
A plone/app/dexterity/textindexer/tests/test_schemaeditor.py
A plone/app/dexterity/textindexer/tests/test_supermodel_handler.py
A plone/app/dexterity/textindexer/tests/test_utils.py
A plone/app/dexterity/textindexer/utils.py
M docs/advanced/catalog-indexing-strategies.rst
M plone/app/dexterity/configure.zcml
M plone/app/dexterity/permissions.py
M setup.py

b'diff --git a/docs/advanced/catalog-indexing-strategies.rst b/docs/advanced/catalog-indexing-strategies.rst\nindex 892745b..1b61743 100644\n--- a/docs/advanced/catalog-indexing-strategies.rst\n+++ b/docs/advanced/catalog-indexing-strategies.rst\n@@ -12,9 +12,9 @@ Making content searchable\n \n Plone\'s main index is called *SearchableText*. This is the index which is searched when you use the main portal search. Fields in your custom content types are not necessarily added to SearchableText. Fields added via Dublin-core behaviors are automatically part of SearchableText; others are not.\n \n-So, you may need to explicitly add fields to SearchableText if you wish their information to be findable via the main search. There are all sorts of highly customizable ways to do this, but the easiest is to use the `collective.dexteritytextindexer  <https://github.com/collective/collective.dexteritytextindexer>`_ add-on package.\n+So, you may need to explicitly add fields to SearchableText if you wish their information to be findable via the main search. There are all sorts of highly customizable ways to do this, but the easiest is to use the the behavior ``plone.textindexer`` that is shipped with plone.app.dexterity.\n \n-Add ``collective.dexteritytextindexer`` to your buildout and you will gain a new Dexterity behavior that will allow you to easily add fields to SearchableText. Once you turn on this behavior, you will then need to specify fields for addition to SearchableText.\n+It allows you to easily add fields to SearchableText. Once you turn on this behavior, you will then need to specify fields for addition to SearchableText.\n \n .. note::\n \n@@ -22,7 +22,7 @@ Add ``collective.dexteritytextindexer`` to your buildout and you will gain a new\n \n Once you have turned on the indexer behavior, edit the XML field model to add ``indexer:searchable="true"`` to the ``field`` tag for each field you wish to add to the SearchableText index.\n \n-See the `collective.dexteritytextindexer  <https://github.com/collective/collective.dexteritytextindexer>`_ package documentation for details and for information on how to use it via Python schema.\n+See the `/backend/indexing  <https://6-dev-docs.plone.org/backend/indexing>`_ package documentation for details and for information on how to use it via Python schema.\n \n \n Creating and using custom indexes\ndiff --git a/news/2780.feature b/news/2780.feature\nnew file mode 100644\nindex 0000000..ffe38c8\n--- /dev/null\n+++ b/news/2780.feature\n@@ -0,0 +1,2 @@\n+PLIP 2780: Move features of collective.dexteritytextindexer to core.\n+[zworkb]\ndiff --git a/plone/app/dexterity/configure.zcml b/plone/app/dexterity/configure.zcml\nindex 5d0ea42..d9494d4 100644\n--- a/plone/app/dexterity/configure.zcml\n+++ b/plone/app/dexterity/configure.zcml\n@@ -37,6 +37,7 @@\n \n   <include package=".browser" />\n   <include package=".behaviors" />\n+  <include package=".textindexer" />\n   <include package=".upgrades" />\n \n   <include file="events.zcml" />\ndiff --git a/plone/app/dexterity/permissions.py b/plone/app/dexterity/permissions.py\nindex 8f71294..0c8b893 100644\n--- a/plone/app/dexterity/permissions.py\n+++ b/plone/app/dexterity/permissions.py\n@@ -17,7 +17,6 @@\n from zope.publisher.browser import TestRequest\n from zope.security.interfaces import IPermission\n \n-import six\n \n try:\n     from plone.app.z3cform.interfaces import IFieldPermissionChecker\n@@ -57,7 +56,7 @@ def _validate_vocabulary_name(self, schema, field, vocabulary_name):\n             widgets = mergedTaggedValueDict(schema, WIDGETS_KEY)\n             widget = widgets.get(field.getName())\n             if widget:\n-                if isinstance(widget, six.string_types):\n+                if isinstance(widget, str):\n                     widget = resolveDottedName(widget)\n                 if widget:\n                     widget = widget(field, self._request)\ndiff --git a/plone/app/dexterity/textindexer/__init__.py b/plone/app/dexterity/textindexer/__init__.py\nnew file mode 100644\nindex 0000000..f1ecefc\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/__init__.py\n@@ -0,0 +1,13 @@\n+"""Dynamic SearchableText index for dexterity content types\n+"""\n+\n+from plone.app.dexterity.behaviors.metadata import IBasic\n+from plone.app.dexterity.textindexer import utils\n+from plone.app.dexterity.textindexer.directives import searchable\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.app.dexterity.textindexer.interfaces import IDexterityTextIndexFieldConverter\n+from plone.app.dexterity.textindexer.interfaces import IDynamicTextIndexExtender\n+\n+\n+utils.searchable(IBasic, "title")\n+utils.searchable(IBasic, "description")\ndiff --git a/plone/app/dexterity/textindexer/behavior.py b/plone/app/dexterity/textindexer/behavior.py\nnew file mode 100644\nindex 0000000..ed9a965\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/behavior.py\n@@ -0,0 +1,10 @@\n+"""IDexterityTextIndexer    dexterity behavior interface for enabling\n+the dexteritytextindexer\n+"""\n+from zope.interface import Interface\n+\n+\n+class IDexterityTextIndexer(Interface):\n+    """Dexterity behavior interface for enabling the dynamic SearchableText\n+    indexer on a content type.\n+    """\ndiff --git a/plone/app/dexterity/textindexer/configure.zcml b/plone/app/dexterity/textindexer/configure.zcml\nnew file mode 100644\nindex 0000000..75b87c3\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/configure.zcml\n@@ -0,0 +1,62 @@\n+<configure xmlns="http://namespaces.zope.org/zope"\n+           xmlns:i18n="http://namespaces.zope.org/i18n"\n+           xmlns:plone="http://namespaces.plone.org/plone"\n+           xmlns:zcml="http://namespaces.zope.org/zcml"\n+           i18n_domain="plone.app.dexterity.textindexer">\n+\n+    <!-- marker behavior for enabling indexer -->\n+    <plone:behavior\n+          title="Dynamic SearchableText indexer behavior"\n+          name="plone.textindexer"\n+          description="Enables the dynamic SearchableText indexer for a content type"\n+          provides="plone.app.dexterity.textindexer.behavior.IDexterityTextIndexer"\n+          />\n+\n+    <utility\n+        factory=".supermodel.IndexerSchema"\n+        name="plone.textindexer.indexer"\n+        />\n+\n+    <adapter\n+        factory="plone.app.dexterity.textindexer.indexer.dynamic_searchable_text_indexer"\n+        name="SearchableText" />\n+\n+    <!-- field converters -->\n+    <adapter\n+        factory="plone.app.dexterity.textindexer.converters.DefaultDexterityTextIndexFieldConverter"\n+        />\n+\n+    <adapter\n+        zcml:condition="installed plone.namedfile"\n+        factory="plone.app.dexterity.textindexer.converters.NamedfileFieldConverter"\n+        />\n+\n+    <adapter\n+        zcml:condition="installed plone.app.textfield"\n+        factory="plone.app.dexterity.textindexer.converters.DexterityRichTextIndexFieldConverter"\n+        />\n+\n+    <adapter\n+        factory="plone.app.dexterity.textindexer.converters.IntFieldConverter"\n+        />\n+\n+    <adapter\n+        factory="plone.app.dexterity.textindexer.converters.TupleFieldConverter"\n+        />\n+\n+    <!-- plone.schemaeditor adapter -->\n+    <adapter\n+        provides="plone.schemaeditor.interfaces.IFieldEditorExtender"\n+        for="plone.schemaeditor.interfaces.ISchemaContext\n+             zope.schema.interfaces.IField"\n+        name="plone.schemaeditor.searchabletext"\n+        factory=".schemaeditor.get_searchabletext_schema"\n+        />\n+\n+    <adapter\n+        provides=".schemaeditor.ISearchableTextField"\n+        for="zope.schema.interfaces.IField"\n+        factory=".schemaeditor.SearchableTextField"\n+        />\n+\n+</configure>\ndiff --git a/plone/app/dexterity/textindexer/converters.py b/plone/app/dexterity/textindexer/converters.py\nnew file mode 100644\nindex 0000000..437ecdf\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/converters.py\n@@ -0,0 +1,142 @@\n+"""\n+DefaultDexterityTextIndexFieldConverter    the default field converter\n+NamedfileFieldConverter                    an optional namedfile field\n+converter only enabled when plone.namedfile is installed\n+"""\n+\n+from plone import api\n+from plone.app.dexterity.textindexer import interfaces\n+from plone.app.textfield.interfaces import IRichText\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.namedfile.interfaces import INamedFileField\n+from Products.CMFPlone.utils import safe_unicode\n+from z3c.form.interfaces import IWidget\n+from ZODB.POSException import ConflictError\n+from zope.component import adapter\n+from zope.interface import implementer\n+from zope.schema.interfaces import IField\n+from zope.schema.interfaces import IInt\n+from zope.schema.interfaces import ITuple\n+\n+import logging\n+\n+\n+LOGGER = logging.getLogger("plone.app.dexterity.textindexer")\n+\n+\n+@implementer(interfaces.IDexterityTextIndexFieldConverter)\n+@adapter(IDexterityContent, IField, IWidget)\n+class DefaultDexterityTextIndexFieldConverter:\n+    """Fallback field converter which uses the rendered widget in display\n+    mode for generating a indexable string.\n+    """\n+\n+    def __init__(self, context, field, widget):\n+        """Initialize field converter"""\n+        self.context = context\n+        self.field = field\n+        self.widget = widget\n+\n+    def convert(self):\n+        """Convert the adapted field value to text/plain for indexing"""\n+        html = self.widget.render().strip()\n+        transforms = api.portal.get_tool("portal_transforms")\n+        stream = transforms.convertTo("text/plain", html, mimetype="text/html")\n+        return stream.getData().strip()\n+\n+\n+@implementer(interfaces.IDexterityTextIndexFieldConverter)\n+@adapter(IDexterityContent, IRichText, IWidget)\n+class DexterityRichTextIndexFieldConverter:\n+    """Fallback field converter which uses the rendered widget in display\n+    mode for generating a indexable string.\n+    """\n+\n+    def __init__(self, context, field, widget):\n+        """Initialize field converter"""\n+        self.context = context\n+        self.field = field\n+\n+    def convert(self):\n+        """Convert a rich text field value to text/plain for indexing"""\n+        textvalue = self.field.get(self.context)\n+        if textvalue is None:\n+            return ""\n+        html = safe_unicode(textvalue.output)\n+        transforms = api.portal.get_tool("portal_transforms")\n+        stream = transforms.convertTo("text/plain", html, mimetype=textvalue.mimeType)\n+        return stream.getData().strip()\n+\n+\n+@implementer(interfaces.IDexterityTextIndexFieldConverter)\n+@adapter(IDexterityContent, INamedFileField, IWidget)\n+class NamedfileFieldConverter(DefaultDexterityTextIndexFieldConverter):\n+    """Converts the file data of a named file using portal_transforms."""\n+\n+    def convert(self):\n+        """Transforms file data to text for indexing safely."""\n+        storage = self.field.interface(self.context)\n+        data = self.field.get(storage)\n+\n+        # if there is no data, do nothing\n+        if not data or data.getSize() == 0:\n+            return ""\n+\n+        # if data is already in text/plain, just return it\n+        if data.contentType == "text/plain":\n+            return data.data\n+\n+        # if there is no path to text/plain, do nothing\n+        transforms = api.portal.get_tool("portal_transforms")\n+\n+        # pylint: disable=W0212\n+        # W0212: Access to a protected member _findPath of a client class\n+        if not transforms._findPath(data.contentType, "text/plain"):\n+            return ""\n+        # pylint: enable=W0212\n+\n+        # convert it to text/plain\n+        try:\n+            datastream = transforms.convertTo(\n+                "text/plain",\n+                data.data,\n+                mimetype=data.contentType,\n+                filename=data.filename,\n+            )\n+            return datastream.getData()\n+\n+        except (ConflictError, KeyboardInterrupt):\n+            raise\n+\n+        except Exception as e:\n+            LOGGER.error(\n+                "Error while trying to convert file contents " \'to "text/plain": %s\',\n+                str(e),\n+            )\n+\n+\n+@implementer(interfaces.IDexterityTextIndexFieldConverter)\n+@adapter(IDexterityContent, IInt, IWidget)\n+class IntFieldConverter(DefaultDexterityTextIndexFieldConverter):\n+    """Converts the data of a int field"""\n+\n+    def convert(self):\n+        """return the adapted field value"""\n+        storage = self.field.interface(self.context)\n+        value = self.field.get(storage)\n+        return str(value)\n+\n+\n+@implementer(interfaces.IDexterityTextIndexFieldConverter)\n+@adapter(IDexterityContent, ITuple, IWidget)\n+class TupleFieldConverter(DefaultDexterityTextIndexFieldConverter):\n+    """Converts the data of a tuple field"""\n+\n+    def convert(self):\n+        """return the adapted field value"""\n+        storage = self.field.interface(self.context)\n+        result = []\n+        if self.field.get(storage):\n+            for value in self.field.get(storage):\n+                result.append(value)\n+        return " ".join(result)\ndiff --git a/plone/app/dexterity/textindexer/directives.py b/plone/app/dexterity/textindexer/directives.py\nnew file mode 100644\nindex 0000000..e4526a1\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/directives.py\n@@ -0,0 +1,28 @@\n+from plone.supermodel.directives import MetadataListDirective\n+from zope.interface import Interface\n+from zope.interface.interfaces import IInterface\n+\n+\n+SEARCHABLE_KEY = "plone.app.dexterity.textindexer.searchable"\n+\n+\n+class searchable(MetadataListDirective):\n+    """Directive used to mark a field as searchable."""\n+\n+    key = SEARCHABLE_KEY\n+    value = "true"\n+\n+    def factory(self, *args):\n+        """The searchable directive accepts as arguments one or more\n+        fieldnames (string) of fields which should be searchable.\n+        """\n+        if not args:\n+            raise TypeError(\n+                "The searchable directive expects at " "least one argument."\n+            )\n+\n+        form_interface = Interface\n+        if IInterface.providedBy(args[0]):\n+            form_interface = args[0]\n+            args = args[1:]\n+        return [(form_interface, field, self.value) for field in args]\ndiff --git a/plone/app/dexterity/textindexer/indexer.py b/plone/app/dexterity/textindexer/indexer.py\nnew file mode 100644\nindex 0000000..b77da9c\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/indexer.py\n@@ -0,0 +1,157 @@\n+"""Contains the indexer and some helper methods for indexing.\n+"""\n+\n+from plone.app.dexterity.textindexer import interfaces\n+from plone.app.dexterity.textindexer.behavior import IDexterityTextIndexer\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.dexterity.utils import iterSchemata\n+from plone.indexer import indexer\n+from plone.supermodel.utils import mergedTaggedValueList\n+from plone.z3cform import z2\n+from z3c.form.field import Field\n+from z3c.form.interfaces import DISPLAY_MODE\n+from z3c.form.interfaces import IContextAware\n+from z3c.form.interfaces import IField\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.interfaces import IFormLayer\n+from zope import schema\n+from zope.component import getAdapters\n+from zope.component import getMultiAdapter\n+from zope.globalrequest import getRequest\n+from zope.interface import alsoProvides\n+\n+import logging\n+\n+\n+LOGGER = logging.getLogger("plone.app.dexterity.textindexer")\n+\n+\n+class FakeView:\n+    """This fake view is used for enabled z3c forms z2 mode on."""\n+\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n+\n+\n+@indexer(IDexterityTextIndexer)\n+def dynamic_searchable_text_indexer(obj):\n+    """Dynamic searchable text indexer."""\n+    # if the object does not provide a request, get one.\n+    # This happens when running scripts (bin/instance run script.py)\n+    try:\n+        request = obj.REQUEST\n+    except AttributeError:\n+        request = getRequest()\n+\n+    # We need to make sure that we have z2 mode switched on for z3c form.\n+    # Since we do not really have any view to do this on, we just use\n+    # a fake view. For switching z2 mode on, it\'s only necessary that\n+    # there is a view.request.\n+    view = FakeView(obj, request)\n+    z2.switch_on(view, request_layer=IFormLayer)\n+\n+    indexed = []\n+\n+    for _storage, fields in get_searchable_contexts_and_fields(obj):\n+        for field in fields:\n+\n+            # we need the form-field, not the schema-field we\n+            # already have..\n+            form_field = Field(field, interface=field.interface, prefix="")\n+\n+            # get the widget\n+            try:\n+                widget = get_field_widget(obj, form_field, request)\n+            except TypeError:\n+                # Some times the field value is wrong, then the converter\n+                # failes. We should not fail, so we catch this error.\n+                continue\n+\n+            # get the converter for this field / widget\n+            converter = getMultiAdapter(\n+                (obj, field, widget), interfaces.IDexterityTextIndexFieldConverter\n+            )\n+\n+            # convert the field value\n+            value = converter.convert()\n+\n+            # if no value was returned, we don\'t need to index\n+            # anything.\n+            if not value:\n+                continue\n+\n+            # only accept strings\n+            assert isinstance(value, str), (\n+                "expected converted "\n+                + "value of IDexterityTextIndexFieldConverter to be a str"\n+            )\n+\n+            indexed.append(value)\n+\n+    # after converting all fields, run additional\n+    # IDynamicTextIndexExtender adapters.\n+    for _name, adapter in getAdapters((obj,), interfaces.IDynamicTextIndexExtender):\n+        extended_value = adapter()\n+\n+        # if no value was returned, we don\'t need to index anything.\n+        if not extended_value:\n+            continue\n+\n+        # only accept strings\n+        assert isinstance(extended_value, str), (\n+            "expected converted " + "value of IDynamicTextIndexExtender to be a str"\n+        )\n+\n+        indexed.append(extended_value)\n+\n+    return " ".join(indexed)\n+\n+\n+def get_field_widget(obj, field, request):\n+    """Returns the field widget of a field in display mode without\n+    touching any form.\n+    The `field` should be a z3c form field, not a zope schema field.\n+    """\n+\n+    assert IField.providedBy(field), "field is not a form field"\n+\n+    if field.widgetFactory.get(DISPLAY_MODE) is not None:\n+        factory = field.widgetFactory.get(DISPLAY_MODE)\n+        widget = factory(field.field, request)\n+    else:\n+        widget = getMultiAdapter((field.field, request), IFieldWidget)\n+    widget.name = "" + field.__name__  # prefix not needed\n+    widget.id = widget.name.replace(".", "-")\n+    widget.context = obj\n+    alsoProvides(widget, IContextAware)\n+    widget.mode = DISPLAY_MODE\n+    widget.ignoreRequest = True\n+    widget.update()\n+    return widget\n+\n+\n+def get_searchable_contexts_and_fields(obj):\n+    """Returns a generator of tuples, which contains a storage object for\n+    each schema (adapted `obj`) and a list of fields on this schema which\n+    are searchable.\n+    """\n+\n+    for schemata in iterSchemata(obj):\n+        fields = []\n+        tagged_values = mergedTaggedValueList(schemata, SEARCHABLE_KEY)\n+        if not tagged_values:\n+            continue\n+\n+        for _i, name, _v in tagged_values:\n+            field = schema.getFields(schemata).get(name)\n+            if not field:\n+                dottedname = ".".join((schemata.__module__, schemata.__name__))\n+                logging.error(\'%s has no field "%s"\', dottedname, name)\n+\n+            elif field not in fields:\n+                fields.append(field)\n+\n+        if fields:\n+            storage = schemata(obj)\n+            yield storage, fields\ndiff --git a/plone/app/dexterity/textindexer/interfaces.py b/plone/app/dexterity/textindexer/interfaces.py\nnew file mode 100644\nindex 0000000..03340ea\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/interfaces.py\n@@ -0,0 +1,33 @@\n+"""\n+IDexterityTextIndexFieldConverter  field converter adapter interface\n+IDynamicTextIndexExtender          dynmaic text extender adapter interface\n+"""\n+\n+from zope.interface import Interface\n+\n+\n+# Supermodel namespace and prefix\n+INDEXER_NAMESPACE = "http://namespaces.plone.org/supermodel/indexer"\n+INDEXER_PREFIX = "indexer"\n+\n+\n+class IDexterityTextIndexFieldConverter(Interface):\n+    """Interface for a multi-adapter which converts the field value of the\n+    adapted field into a human readable, translated text for indexing in\n+    the searchable text index.\n+    """\n+\n+    def __init__(self, context, field, widget):\n+        """The multi-adpater adapts the context, the field and the widget."""\n+\n+    def convert(self):\n+        """Returns a string containing the words to index. Translatable\n+        Message-objects are already translated into normal strings. On a\n+        multi-language site the\n+        """\n+\n+\n+class IDynamicTextIndexExtender(Interface):\n+    """Adapter interface for a named adapter which extends the dynamic\n+    text indexer.\n+    """\ndiff --git a/plone/app/dexterity/textindexer/schemaeditor.py b/plone/app/dexterity/textindexer/schemaeditor.py\nnew file mode 100644\nindex 0000000..a9e7d44\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/schemaeditor.py\n@@ -0,0 +1,68 @@\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.app.dexterity.textindexer.interfaces import INDEXER_NAMESPACE\n+from plone.app.dexterity.textindexer.interfaces import INDEXER_PREFIX\n+from plone.schemaeditor.interfaces import IFieldEditorExtender\n+from plone.schemaeditor.interfaces import ISchemaContext\n+from zope import schema\n+from zope.component import adapter\n+from zope.i18nmessageid import MessageFactory\n+from zope.interface import implementer\n+from zope.interface import Interface\n+from zope.schema.interfaces import IField\n+\n+\n+_ = MessageFactory("plone.app.dexterity.textindexer")\n+\n+\n+class ISearchableTextField(Interface):\n+    searchable = schema.Bool(title=_("Searchable"), required=False)\n+\n+\n+@adapter(IField)\n+@implementer(ISearchableTextField)\n+class SearchableTextField:\n+\n+    namespace = INDEXER_NAMESPACE\n+    prefix = INDEXER_PREFIX\n+\n+    def __init__(self, field):\n+        self.field = field\n+        self.schema = field.interface\n+\n+    def _read_searchable(self):\n+        tagged_value = self.schema.queryTaggedValue(SEARCHABLE_KEY, [])\n+\n+        name = self.field.__name__\n+        value = (Interface, name, "true")\n+\n+        return value in tagged_value\n+\n+    def _write_searchable(self, value):\n+        tagged_value = self.schema.queryTaggedValue(SEARCHABLE_KEY, [])\n+\n+        name = self.field.__name__\n+        new_value = (Interface, name, bool(value) and "true" or "false")\n+        old_value = (Interface, name, bool(value) and "false" or "true")\n+\n+        while old_value in tagged_value:\n+            tagged_value.remove(old_value)\n+\n+        if bool(value) and new_value not in tagged_value:\n+            tagged_value.append(new_value)\n+\n+        self.schema.setTaggedValue(SEARCHABLE_KEY, tagged_value)\n+\n+    searchable = property(_read_searchable, _write_searchable)\n+\n+\n+# ISearchableTextField could be registered directly as a named adapter\n+# providing IFieldEditorExtender for ISchemaContext and IField, but instead,\n+# we register a separate callable which returns the schema only if additional\n+# conditions pass:\n+@adapter(ISchemaContext, IField)\n+@implementer(IFieldEditorExtender)\n+def get_searchabletext_schema(schema_context, field):\n+    behavior = "plone.textindexer"\n+    fti = getattr(schema_context, "fti", None)\n+    if fti and behavior in getattr(fti, "behaviors", []):\n+        return ISearchableTextField\ndiff --git a/plone/app/dexterity/textindexer/supermodel.py b/plone/app/dexterity/textindexer/supermodel.py\nnew file mode 100644\nindex 0000000..9893b48\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/supermodel.py\n@@ -0,0 +1,36 @@\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.app.dexterity.textindexer.interfaces import INDEXER_NAMESPACE\n+from plone.app.dexterity.textindexer.interfaces import INDEXER_PREFIX\n+from plone.supermodel.parser import IFieldMetadataHandler\n+from plone.supermodel.utils import ns\n+from zope.interface import implementer\n+from zope.interface import Interface\n+\n+\n+@implementer(IFieldMetadataHandler)\n+class IndexerSchema:\n+    """Support the indexer: namespace in model definitions."""\n+\n+    namespace = INDEXER_NAMESPACE\n+    prefix = INDEXER_PREFIX\n+\n+    def _add_searchable(self, schema, value):\n+        tagged_value = schema.queryTaggedValue(SEARCHABLE_KEY, [])\n+        tagged_value.append(value)\n+        schema.setTaggedValue(SEARCHABLE_KEY, tagged_value)\n+\n+    def read(self, fieldNode, schema, field):\n+        name = field.__name__\n+        searchable = fieldNode.get(ns("searchable", self.namespace))\n+\n+        if searchable:\n+            value = (Interface, name, "true")\n+            self._add_searchable(schema, value)\n+\n+    def write(self, fieldNode, schema, field):\n+        name = field.__name__\n+        searchable = schema.queryTaggedValue(SEARCHABLE_KEY, [])\n+        field_names = [fld[1] for fld in searchable]\n+\n+        if name in field_names:\n+            fieldNode.set(ns("searchable", self.namespace), "true")\ndiff --git a/plone/app/dexterity/textindexer/testing.py b/plone/app/dexterity/textindexer/testing.py\nnew file mode 100644\nindex 0000000..84ccb4a\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/testing.py\n@@ -0,0 +1,85 @@\n+"""Testing setup providing layers and fixtures\n+TextIndexerLayer                   basic text indexer layer\n+TEXT_INDEXER_FIXTURE               text indexer fixture\n+TEXT_INTEXER_INTEGRATION_TESTING   integration testing layer\n+TEXT_INDEXER_FUNCTIONAL_TESTING    functional testing layer\n+"""\n+\n+from plone.app.testing import FunctionalTesting\n+from plone.app.testing import IntegrationTesting\n+from plone.app.testing import PLONE_FIXTURE\n+from plone.app.testing import PloneSandboxLayer\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from six import StringIO\n+\n+import logging\n+\n+\n+class TextIndexerLayer(PloneSandboxLayer):\n+\n+    defaultBases = (PLONE_FIXTURE,)\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self.log = None\n+        self.log_handler = None\n+\n+    def setUpZope(self, app, configurationContext):\n+        """After setting up zope, load all necessary zcml files."""\n+        import plone.app.dexterity.textindexer\n+\n+        self.loadZCML(\n+            package=plone.app.dexterity.textindexer, context=configurationContext\n+        )\n+        import plone.app.dexterity.textindexer.tests\n+\n+        self.loadZCML(\n+            package=plone.app.dexterity.textindexer.tests, context=configurationContext\n+        )\n+\n+    def setUpPloneSite(self, portal):\n+        """After setting up plone, give Manager role to the test user."""\n+        setRoles(portal, TEST_USER_ID, ["Manager"])\n+\n+    def testSetUp(self):\n+        super().testSetUp()\n+        self.log = StringIO()\n+        self.log_handler = logging.StreamHandler(self.log)\n+        logging.root.addHandler(self.log_handler)\n+        self["read_log"] = self.read_log\n+\n+    def testTearDown(self):\n+        super().testTearDown()\n+        logging.root.removeHandler(self.log_handler)\n+\n+    def read_log(self):\n+        self.log.seek(0)\n+        return self.log.read().strip()\n+\n+\n+TEXT_INDEXER_FIXTURE = TextIndexerLayer()\n+TEXT_INTEXER_INTEGRATION_TESTING = IntegrationTesting(\n+    bases=(TEXT_INDEXER_FIXTURE,), name="plone.app.dexterity.textindexer:Integration"\n+)\n+\n+\n+class TextIndexerFunctionalLayer(PloneSandboxLayer):\n+\n+    defaultBases = (TEXT_INDEXER_FIXTURE,)\n+\n+    def setUpZope(self, app, configurationContext):\n+        import plone.app.dexterity\n+\n+        self.loadZCML(package=plone.app.dexterity, context=configurationContext)\n+\n+    def setUpPloneSite(self, portal):\n+        self.applyProfile(portal, "plone.app.dexterity:default")\n+\n+\n+TEXT_INDEXER_FUNCTIONAL_FIXTURE = TextIndexerFunctionalLayer()\n+\n+TEXT_INDEXER_FUNCTIONAL_TESTING = FunctionalTesting(\n+    bases=(TEXT_INDEXER_FUNCTIONAL_FIXTURE,),\n+    name="plone.app.dexterity.textindexer:Functional",\n+)\ndiff --git a/plone/app/dexterity/textindexer/tests/__init__.py b/plone/app/dexterity/textindexer/tests/__init__.py\nnew file mode 100644\nindex 0000000..5bfeab4\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/__init__.py\n@@ -0,0 +1,3 @@\n+"""Testing module containing the tests\n+for plone.app.dexterity.textindexer.\n+"""\ndiff --git a/plone/app/dexterity/textindexer/tests/behaviors.py b/plone/app/dexterity/textindexer/tests/behaviors.py\nnew file mode 100644\nindex 0000000..3ac2646\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/behaviors.py\n@@ -0,0 +1,112 @@\n+"""Contains different behaviors needed for testing.\n+"""\n+from plone.app.dexterity import textindexer\n+from plone.app.textfield import RichText\n+from plone.autoform.interfaces import IFormFieldProvider\n+from plone.supermodel import model\n+from zope import schema\n+from zope.interface import provider\n+\n+\n+@provider(IFormFieldProvider)\n+class ISimpleBehavior(model.Schema):\n+    """Simple behavior containing simple text line fields."""\n+\n+    textindexer.searchable("foo")\n+    foo = schema.TextLine(title="Foo")\n+\n+    bar = schema.TextLine(title="Bar")\n+\n+\n+@provider(IFormFieldProvider)\n+class IListBehavior(model.Schema):\n+    """More advanced behavior with a list of fields."""\n+\n+    textindexer.searchable("list_field")\n+\n+    list_field = schema.List(title="List field", value_type=schema.TextLine())\n+\n+\n+@provider(IFormFieldProvider)\n+class IIntBehavior(model.Schema):\n+    """Basic behavior with a integer field."""\n+\n+    textindexer.searchable("int_field")\n+    int_field = schema.Int(title="Int")\n+\n+\n+@provider(IFormFieldProvider)\n+class IRichTextBehavior(model.Schema):\n+    """Basic behavior with a rich-text field."""\n+\n+    textindexer.searchable("richtext_field")\n+    richtext_field = RichText(\n+        title="Body text",\n+        default_mime_type="text/html",\n+        output_mime_type="text/x-html",\n+        allowed_mime_types=(\n+            "text/html",\n+            "text/plain",\n+        ),\n+        default="",\n+    )\n+\n+\n+@provider(IFormFieldProvider)\n+class IEmptyRichTextBehavior(model.Schema):\n+    """Behavior with a rich-text field without a default value."""\n+\n+    textindexer.searchable("foo")\n+    foo = schema.TextLine(title="Foo")\n+\n+    textindexer.searchable("empty_richtext_field")\n+    empty_richtext_field = RichText(\n+        title="Body text",\n+        default_mime_type="text/html",\n+        output_mime_type="text/x-html",\n+        allowed_mime_types=(\n+            "text/html",\n+            "text/plain",\n+        ),\n+    )\n+\n+\n+@provider(IFormFieldProvider)\n+class ITupleBehavior(model.Schema):\n+    """Basic behavior with a tuple field."""\n+\n+    textindexer.searchable("tuple_field")\n+    tuple_field = schema.Tuple(\n+        title="Tuple",\n+        value_type=schema.TextLine(),\n+        required=False,\n+        missing_value=(),\n+    )\n+\n+\n+@provider(IFormFieldProvider)\n+class ITupleChoiceBehavior(model.Schema):\n+    """Basic behavior with a tuple choice field."""\n+\n+    textindexer.searchable("tuple_choice_field")\n+    tuple_choice_field = schema.Tuple(\n+        title="Tuple choice",\n+        value_type=schema.Choice(vocabulary="plone.app.vocabularies.Keywords"),\n+        required=False,\n+        missing_value=(),\n+    )\n+\n+\n+@provider(IFormFieldProvider)\n+class IInheritedBehavior(ISimpleBehavior):\n+    """Behavior extending from ISimpleBehavior for testing inheritance."""\n+\n+\n+@provider(IFormFieldProvider)\n+class IMissingFieldBehavior(model.Schema):\n+    """A behavior defining a field as searchable which does not exist."""\n+\n+    textindexer.searchable("foo")\n+    foo = schema.TextLine(title="Foo")\n+\n+    textindexer.searchable("bar")\ndiff --git a/plone/app/dexterity/textindexer/tests/behaviors.rst b/plone/app/dexterity/textindexer/tests/behaviors.rst\nnew file mode 100644\nindex 0000000..8d4e8aa\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/behaviors.rst\n@@ -0,0 +1,306 @@\n+Test everything with behaviors::\n+\n+    >>> from Products.CMFCore.utils import getToolByName\n+    >>> from plone.app.testing import TEST_USER_NAME\n+    >>> from plone.app.testing import login\n+    >>> from plone.dexterity.fti import DexterityFTI\n+    >>> from plone.dexterity.utils import createContentInContainer\n+\n+    >>> portal = layer[\'portal\']\n+    >>> login(portal, TEST_USER_NAME)\n+\n+\n+Helpers::\n+\n+    >>> def obj2brain(obj):\n+    ...     catalog = getToolByName(obj, \'portal_catalog\')\n+    ...     query = {\'path\': {\'query\': \'/\'.join(obj.getPhysicalPath()),\n+    ...                       \'depth\': 0}}\n+    ...     brains = catalog(query)\n+    ...     if len(brains) == 0:\n+    ...         raise Exception(\'Not in catalog: %s\' % obj)\n+    ...     else:\n+    ...         return brains[0]\n+\n+    >>> def getSearchableText(obj):\n+    ...     brain = obj2brain(obj)\n+    ...     catalog = getToolByName(obj, \'portal_catalog\')\n+    ...     data = catalog.getIndexDataForRID(brain.getRID())\n+    ...     return data[\'SearchableText\']\n+\n+\n+First test it with a simple behavior::\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import ISimpleBehavior\n+    >>> fti = DexterityFTI(\'SimpleFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.textindexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.ISimpleBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'SimpleFTI\', fti)\n+    \'SimpleFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj1 = createContentInContainer(portal, \'SimpleFTI\',\n+    ...                                 checkContstraints=False,\n+    ...                                 foo=\'foox\',\n+    ...                                 bar=\'barx\')\n+    >>> obj1\n+    <Item at /plone/simplefti>\n+    >>> getSearchableText(obj1)\n+    [\'foox\']\n+\n+\n+Test, if the value getter works also, when the request has stored another value for this field.\n+\n+::\n+\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> portal.REQUEST.form[\'foo\'] = \'blubb\'\n+    >>> obj1 = createContentInContainer(portal, \'SimpleFTI\',\n+    ...                                 checkContstraints=False,\n+    ...                                 foo=\'foox\',\n+    ...                                 bar=\'barx\')\n+    >>> obj1\n+    <Item at /plone/simplefti-1>\n+    >>> getSearchableText(obj1)\n+    [\'foox\']\n+\n+\n+Does a list work?\n+\n+::\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IListBehavior\n+    >>> fti = DexterityFTI(\'ListFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.textindexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.IListBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'ListFTI\', fti)\n+    \'ListFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj2 = createContentInContainer(portal, \'ListFTI\',\n+    ...                                 checkContstraints=False,\n+    ...                                 list_field=[\'hello\', u\'little\', \'world\'])\n+\n+    >>> obj2\n+    <Item at /plone/listfti>\n+    >>> getSearchableText(obj2)\n+    [\'hello\', \'little\', \'world\']\n+\n+\n+Do ints work?\n+\n+::\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IIntBehavior\n+    >>> fti = DexterityFTI(\'IntFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.textindexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.IIntBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'IntFTI\', fti)\n+    \'IntFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj3 = createContentInContainer(portal, \'IntFTI\',\n+    ...                                 checkContstraints=False,\n+    ...                                 int_field=57)\n+\n+    >>> obj3\n+    <Item at /plone/intfti>\n+\n+In Plone 4.3 int-values are stored as unicodes.\n+Since our test should work also for old Plones, we convert everything\n+to string here::\n+\n+    >>> list(map(str, getSearchableText(obj3)))\n+    [\'57\']\n+\n+\n+Do rich-text fields work?\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IRichTextBehavior\n+    >>> from plone.app.textfield.value import RichTextValue\n+    >>> fti = DexterityFTI(\'RichTextFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.textindexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.IRichTextBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'RichTextFTI\', fti)\n+    \'RichTextFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> rtv = RichTextValue(\n+    ...     raw=\'<p>In for an <em>inch</em>, in for a <strong>pound.</strong></p>\',\n+    ...     mimeType=\'text/html\',\n+    ...     outputMimeType=\'text/html\',\n+    ...     encoding=\'utf-8\',\n+    ... )\n+    >>> obj4 = createContentInContainer(\n+    ...    portal,\n+    ...    \'RichTextFTI\',\n+    ...    checkContstraints=False,\n+    ...    richtext_field=rtv,\n+    ... )\n+\n+    >>> obj4\n+    <Item at /plone/richtextfti>\n+\n+    >>> getSearchableText(obj4)\n+    [\'in\', \'for\', \'an\', \'inch\', \'in\', \'for\', \'a\', \'pound\']\n+\n+\n+Values are not duplicated in SearchableText when field comes from real interface\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import ISimpleBehavior\n+    >>> fti = DexterityFTI(\'SimpleFTI2\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.textindexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.ISimpleBehavior\',\n+    ... )\n+    >>> fti.model_source = \'<model xmlns="http://namespaces.plone.org/supermodel/schema" xmlns:i18n="http://xml.zope.org/namespaces/i18n" i18n:domain="plone"><schema based-on="plone.app.dexterity.textindexer.tests.test_behaviors.ITestingSchema"></schema></model>\'\n+    >>> portal.portal_types._setObject(\'SimpleFTI2\', fti)\n+    \'SimpleFTI2\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj1 = createContentInContainer(portal, \'SimpleFTI2\',\n+    ...                                 checkContstraints=False,\n+    ...                                 foo=\'foox\',\n+    ...                                 bar=\'barx\',\n+    ...                                 testing_field=\'bla\')\n+    >>> obj1\n+    <Item at /plone/simplefti2>\n+    >>> getSearchableText(obj1)\n+    [\'bla\', \'foox\']\n+\n+\n+Do empty rich-text fields work?\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IEmptyRichTextBehavior\n+    >>> fti = DexterityFTI(\'EmptyRichTextFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.textindexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.IEmptyRichTextBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'EmptyRichTextFTI\', fti)\n+    \'EmptyRichTextFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj_empty_rich_text = createContentInContainer(\n+    ...    portal,\n+    ...    \'EmptyRichTextFTI\',\n+    ...    checkContstraints=False,\n+    ...    foo=\'Hello World\',\n+    ... )\n+\n+    >>> obj_empty_rich_text\n+    <Item at /plone/emptyrichtextfti>\n+\n+    >>> getSearchableText(obj_empty_rich_text)\n+    [\'hello\', \'world\']\n+\n+\n+Do tuple fields work?\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IRichTextBehavior\n+    >>> fti = DexterityFTI(\'TupleFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.textindexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.ITupleBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'TupleFTI\', fti)\n+    \'TupleFTI\'\n+    >>> schema = fti.lookupSchema()\n+    >>> obj5 = createContentInContainer(\n+    ...    portal,\n+    ...    \'TupleFTI\',\n+    ...    checkContstraints=False,\n+    ...    tuple_field=(\'My\', \'kingdom\', \'for\', \'a\', \'horse\'),\n+    ... )\n+\n+    >>> obj5\n+    <Item at /plone/tuplefti>\n+\n+    >>> getSearchableText(obj5)\n+    [\'my\', \'kingdom\', \'for\', \'a\', \'horse\']\n+\n+\n+Do tuple fields with choice values work?\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IRichTextBehavior\n+    >>> fti = DexterityFTI(\'TupleChoiceFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.textindexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.ITupleChoiceBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'TupleChoiceFTI\', fti)\n+    \'TupleChoiceFTI\'\n+    >>> schema = fti.lookupSchema()\n+    >>> obj6 = createContentInContainer(\n+    ...    portal,\n+    ...    \'TupleChoiceFTI\',\n+    ...    checkContstraints=False,\n+    ...    tuple_choice_field=(\'Knights\', \'ni\'),\n+    ... )\n+\n+    >>> obj6\n+    <Item at /plone/tuplechoicefti>\n+\n+    >>> getSearchableText(obj6)\n+    [\'knights\', \'ni\']\n+\n+\n+When a schema marks a field as searchable which does not exist it should:\n+\n+- not break indexing other fields\n+- log an error\n+\n+::\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IMissingFieldBehavior\n+    >>> fti = DexterityFTI(\'MissingFieldFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.textindexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.IMissingFieldBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'MissingFieldFTI\', fti)\n+    \'MissingFieldFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj = createContentInContainer(portal, \'MissingFieldFTI\',\n+    ...                                checkContstraints=False,\n+    ...                                foo=\'foo value\')\n+    >>> obj\n+    <Item at /plone/missingfieldfti>\n+    >>> getSearchableText(obj)\n+    [\'foo\', \'value\']\n+\n+    >>> \'IMissingFieldBehavior has no field "bar"\' in layer[\'read_log\']()\n+    True\n+\n+\n+Test, if a subclassed schema also inherits the searchable configuration of\n+it\'s superclass::\n+\n+    >>> from plone.app.dexterity.textindexer.tests.behaviors import IInheritedBehavior\n+    >>> fti = DexterityFTI(\'InheritedFTI\')\n+    >>> fti.behaviors = (\n+    ...     \'plone.textindexer\',\n+    ...     \'plone.app.dexterity.textindexer.tests.behaviors.IInheritedBehavior\',\n+    ... )\n+    >>> portal.portal_types._setObject(\'InheritedFTI\', fti)\n+    \'InheritedFTI\'\n+    >>> schema = fti.lookupSchema()\n+\n+    >>> obj1 = createContentInContainer(portal, \'InheritedFTI\',\n+    ...                                 checkContstraints=False,\n+    ...                                 foo=\'foo value\',\n+    ...                                 bar=\'bar value\')\n+    >>> obj1\n+    <Item at /plone/inheritedfti>\n+    >>> getSearchableText(obj1)\n+    [\'foo\', \'value\']\ndiff --git a/plone/app/dexterity/textindexer/tests/configure.zcml b/plone/app/dexterity/textindexer/tests/configure.zcml\nnew file mode 100644\nindex 0000000..123e556\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/configure.zcml\n@@ -0,0 +1,68 @@\n+<configure xmlns="http://namespaces.zope.org/zope"\n+           xmlns:plone="http://namespaces.plone.org/plone"\n+           i18n_domain="plone.app.dexterity.textindexer">\n+\n+    <plone:behavior\n+          title="simple behavior"\n+          description=""\n+          provides=".behaviors.ISimpleBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="list behavior"\n+          description=""\n+          provides=".behaviors.IListBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="int behavior"\n+          description=""\n+          provides=".behaviors.IIntBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="richtext behavior"\n+          description=""\n+          provides=".behaviors.IRichTextBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="empty richtext behavior"\n+          description=""\n+          provides=".behaviors.IEmptyRichTextBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="tuple behavior"\n+          description=""\n+          provides=".behaviors.ITupleBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="tuple choice behavior"\n+          description=""\n+          provides=".behaviors.ITupleChoiceBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="inherited behavior"\n+          description=""\n+          provides=".behaviors.IInheritedBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+    <plone:behavior\n+          title="missing field behavior"\n+          description=""\n+          provides=".behaviors.IMissingFieldBehavior"\n+          for="plone.dexterity.interfaces.IDexterityContent"\n+          />\n+\n+</configure>\ndiff --git a/plone/app/dexterity/textindexer/tests/helpers.py b/plone/app/dexterity/textindexer/tests/helpers.py\nnew file mode 100644\nindex 0000000..3cb6486\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/helpers.py\n@@ -0,0 +1,12 @@\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.supermodel.utils import mergedTaggedValueList\n+\n+\n+def get_searchable_fields(iface):\n+    fieldnames = []\n+\n+    for flag_iface, fieldname, value in mergedTaggedValueList(iface, SEARCHABLE_KEY):\n+        if flag_iface == iface and value:\n+            fieldnames.append(fieldname)\n+\n+    return fieldnames\ndiff --git a/plone/app/dexterity/textindexer/tests/test_basic_behavior.py b/plone/app/dexterity/textindexer/tests/test_basic_behavior.py\nnew file mode 100644\nindex 0000000..0651f14\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/test_basic_behavior.py\n@@ -0,0 +1,11 @@\n+from plone.app.dexterity.behaviors.metadata import IBasic\n+from plone.app.dexterity.textindexer.tests.helpers import get_searchable_fields\n+from unittest import TestCase\n+\n+\n+class TestBasicBehaviorIsSearchable(TestCase):\n+    def test_title_is_searchable(self):\n+        self.assertIn("title", get_searchable_fields(IBasic))\n+\n+    def test_description_is_searchable(self):\n+        self.assertIn("description", get_searchable_fields(IBasic))\ndiff --git a/plone/app/dexterity/textindexer/tests/test_behaviors.py b/plone/app/dexterity/textindexer/tests/test_behaviors.py\nnew file mode 100644\nindex 0000000..6e8e22c\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/test_behaviors.py\n@@ -0,0 +1,31 @@\n+"""Containing a tests suite for testing the behaviors.\n+"""\n+\n+from plone.app.dexterity.textindexer import testing\n+from plone.app.dexterity.textindexer.directives import searchable\n+from plone.supermodel import model\n+from plone.testing import layered\n+from zope import schema\n+\n+import doctest\n+import unittest as unittest\n+\n+\n+def test_suite():\n+    """Test suite testing the behaviors with a doctest from behaviors.txt"""\n+    suite = unittest.TestSuite()\n+    suite.addTests(\n+        [\n+            layered(\n+                doctest.DocFileSuite("behaviors.rst"),\n+                layer=testing.TEXT_INTEXER_INTEGRATION_TESTING,\n+            ),\n+        ]\n+    )\n+    return suite\n+\n+\n+class ITestingSchema(model.Schema):\n+\n+    searchable("testing_field")\n+    testing_field = schema.TextLine(title="Testing field")\ndiff --git a/plone/app/dexterity/textindexer/tests/test_directives.py b/plone/app/dexterity/textindexer/tests/test_directives.py\nnew file mode 100644\nindex 0000000..0980dff\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/test_directives.py\n@@ -0,0 +1,51 @@\n+from plone.app.dexterity.textindexer.directives import searchable\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.supermodel import model\n+from plone.supermodel.utils import mergedTaggedValueList\n+from zope import schema\n+from zope.interface import Interface\n+\n+import unittest\n+import zope.component.testing\n+\n+\n+class TestDirectives(unittest.TestCase):\n+    def tearDown(self):\n+        """Tear down the testing setup."""\n+        zope.component.testing.tearDown()\n+\n+    def test_schema_directives_store_tagged_values(self):\n+        """Test, if the schema directive values are stored as tagged\n+        values.\n+        """\n+\n+        class IDummy(model.Schema):\n+            """Dummy schema class."""\n+\n+            searchable("foo")\n+            foo = schema.TextLine(title="Foo")\n+\n+        self.assertEqual(\n+            [(Interface, "foo", "true")], mergedTaggedValueList(IDummy, SEARCHABLE_KEY)\n+        )\n+\n+    def test_inherited_schema_still_has_tagged_value(self):\n+        """An inherited schema should still have the tagged value information\n+        inherited from its superclass.\n+        """\n+\n+        class IFoo(model.Schema):\n+            """Class with a searchable field"""\n+\n+            searchable("baz")\n+            baz = schema.TextLine(title="baz")\n+\n+        class IBar(IFoo):\n+            """Schema class which inherits a field from IFoo."""\n+\n+        self.assertEqual(\n+            [(Interface, "baz", "true")], mergedTaggedValueList(IFoo, SEARCHABLE_KEY)\n+        )\n+        self.assertEqual(\n+            [(Interface, "baz", "true")], mergedTaggedValueList(IBar, SEARCHABLE_KEY)\n+        )\ndiff --git a/plone/app/dexterity/textindexer/tests/test_schemaeditor.py b/plone/app/dexterity/textindexer/tests/test_schemaeditor.py\nnew file mode 100644\nindex 0000000..88317ac\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/test_schemaeditor.py\n@@ -0,0 +1,98 @@\n+from plone import api\n+from plone.app.dexterity.textindexer.testing import TEXT_INDEXER_FUNCTIONAL_TESTING\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from plone.app.testing import TEST_USER_NAME\n+from plone.app.testing import TEST_USER_PASSWORD\n+from plone.dexterity.fti import DexterityFTI\n+from plone.testing.z2 import Browser\n+\n+import transaction\n+import unittest\n+\n+\n+class TestSchemaEditor(unittest.TestCase):\n+\n+    layer = TEXT_INDEXER_FUNCTIONAL_TESTING\n+\n+    def setUp(self):\n+        portal_types = api.portal.get_tool("portal_types")\n+\n+        # Define new portal type without behavior\n+        fti = DexterityFTI("without_behavior", title="Without Behavior")\n+        fti.behaviors = ("plone.basic",)\n+        fti.model_source = """\\\n+<model xmlns="http://namespaces.plone.org/supermodel/schema">\n+<schema>\n+<field name="custom" type="zope.schema.TextLine">\n+  <description />\n+  <required>False</required>\n+  <title>Custom field</title>\n+</field>\n+</schema>\n+</model>"""\n+        portal_types._setObject("without_behavior", fti)\n+\n+        # Define new portal type with behavior\n+        fti = DexterityFTI("with_behavior", title="With Behavior")\n+        fti.behaviors = (\n+            "plone.basic",\n+            "plone.textindexer",\n+        )\n+        fti.model_source = """\\\n+<model xmlns="http://namespaces.plone.org/supermodel/schema">\n+<schema>\n+<field name="custom" type="zope.schema.TextLine">\n+  <description />\n+  <required>False</required>\n+  <title>Custom field</title>\n+</field>\n+</schema>\n+</model>"""\n+        portal_types._setObject("with_behavior", fti)\n+\n+        setRoles(self.layer["portal"], TEST_USER_ID, ["Manager"])\n+        transaction.commit()\n+\n+        self.browser = Browser(self.layer["app"])\n+        self.browser.addHeader(\n+            "Authorization", f"Basic {TEST_USER_NAME}:{TEST_USER_PASSWORD}"\n+        )\n+        self.portal_url = self.layer["portal"].absolute_url()\n+\n+    def test_searchable_field_is_not_visible_without_behavior(self):\n+        self.browser.open(self.portal_url + "/dexterity-types/without_behavior/custom")\n+        self.assertRaises(LookupError, self.browser.getControl, "Searchable")\n+\n+    def test_searchable_field_is_visible_with_behavior(self):\n+        self.browser.open(self.portal_url + "/dexterity-types/with_behavior/custom")\n+        control = self.browser.getControl("Searchable")\n+        self.assertEqual(control.control.type, "checkbox")\n+\n+    def test_searchable_field_is_disabled_by_default(self):\n+        self.browser.open(self.portal_url + "/dexterity-types/with_behavior/custom")\n+        self.assertFalse(self.browser.getControl("Searchable").selected)\n+\n+    def test_searchable_field_change_is_saved(self):\n+        portal_types = api.portal.get_tool("portal_types")\n+        fti = portal_types["with_behavior"]\n+        self.assertNotIn(\'indexer:searchable="true"\', fti.model_source)\n+\n+        self.browser.open(self.portal_url + "/dexterity-types/with_behavior/custom")\n+        self.browser.getControl("Searchable").click()\n+        self.browser.getControl("Save").click()\n+\n+        self.browser.open(self.portal_url + "/dexterity-types/with_behavior/custom")\n+        self.assertTrue(self.browser.getControl("Searchable").selected)\n+\n+        fti._p_jar.sync()\n+        self.assertIn(\'indexer:searchable="true"\', fti.model_source)\n+\n+        self.browser.getControl("Searchable").click()\n+        self.browser.getControl("Save").click()\n+\n+        self.browser.open(self.portal_url + "/dexterity-types/with_behavior/custom")\n+        self.assertFalse(self.browser.getControl("Searchable").selected)\n+\n+        fti._p_jar.sync()\n+        self.assertNotIn(\'indexer:searchable="true"\', fti.model_source)\ndiff --git a/plone/app/dexterity/textindexer/tests/test_supermodel_handler.py b/plone/app/dexterity/textindexer/tests/test_supermodel_handler.py\nnew file mode 100644\nindex 0000000..be09d3c\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/test_supermodel_handler.py\n@@ -0,0 +1,110 @@\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from plone.app.dexterity.textindexer.supermodel import IndexerSchema\n+from plone.supermodel.utils import ns\n+from xml.etree import ElementTree\n+from zope.interface import Interface\n+\n+import unittest\n+import zope.schema\n+\n+\n+class TestIndexerSchema(unittest.TestCase):\n+    """Tests for the supermodel field metadata handler."""\n+\n+    namespace = "http://namespaces.plone.org/supermodel/indexer"\n+\n+    def test_read(self):\n+        field_node = ElementTree.Element("field")\n+        field_node.set(ns("searchable", self.namespace), "true")\n+\n+        class IDummy(Interface):\n+            dummy = zope.schema.TextLine(title="dummy")\n+\n+        handler = IndexerSchema()\n+        handler.read(field_node, IDummy, IDummy["dummy"])\n+\n+        self.assertEqual(\n+            [(Interface, "dummy", "true")], IDummy.getTaggedValue(SEARCHABLE_KEY)\n+        )\n+\n+    def test_read_multiple(self):\n+        field_node1 = ElementTree.Element("field")\n+        field_node1.set(ns("searchable", self.namespace), "true")\n+\n+        field_node2 = ElementTree.Element("field")\n+\n+        field_node3 = ElementTree.Element("field")\n+        field_node3.set(ns("searchable", self.namespace), "true")\n+\n+        class IDummy(Interface):\n+            dummy1 = zope.schema.TextLine(title="dummy1")\n+            dummy2 = zope.schema.TextLine(title="dummy2")\n+            dummy3 = zope.schema.TextLine(title="dummy3")\n+\n+        handler = IndexerSchema()\n+        handler.read(field_node1, IDummy, IDummy["dummy1"])\n+        handler.read(field_node2, IDummy, IDummy["dummy2"])\n+        handler.read(field_node3, IDummy, IDummy["dummy3"])\n+\n+        self.assertEqual(\n+            [(Interface, "dummy1", "true"), (Interface, "dummy3", "true")],\n+            IDummy.getTaggedValue(SEARCHABLE_KEY),\n+        )\n+\n+    def test_read_no_data(self):\n+        field_node = ElementTree.Element("field")\n+\n+        class IDummy(Interface):\n+            dummy = zope.schema.TextLine(title="dummy1")\n+\n+        handler = IndexerSchema()\n+        handler.read(field_node, IDummy, IDummy["dummy"])\n+\n+        self.assertEqual(None, IDummy.queryTaggedValue(SEARCHABLE_KEY))\n+\n+    def test_write(self):\n+        field_node = ElementTree.Element("field")\n+\n+        class IDummy(Interface):\n+            dummy = zope.schema.TextLine(title="dummy1")\n+\n+        IDummy.setTaggedValue(SEARCHABLE_KEY, [(Interface, "dummy", "true")])\n+\n+        handler = IndexerSchema()\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n+\n+        self.assertEqual("true", field_node.get(ns("searchable", self.namespace)))\n+\n+    def test_write_partial(self):\n+        field_node = ElementTree.Element("field")\n+        field_node2 = ElementTree.Element("field")\n+\n+        class IDummy(Interface):\n+            dummy = zope.schema.TextLine(title="dummy1")\n+            dummy2 = zope.schema.TextLine(title="dummy2")\n+\n+        IDummy.setTaggedValue(SEARCHABLE_KEY, [(Interface, "dummy", "true")])\n+\n+        handler = IndexerSchema()\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n+        handler.write(field_node2, IDummy, IDummy["dummy2"])\n+\n+        self.assertEqual("true", field_node.get(ns("searchable", self.namespace)))\n+        self.assertEqual(None, field_node2.get(ns("searchable", self.namespace)))\n+\n+    def test_write_no_data(self):\n+        field_node = ElementTree.Element("field")\n+\n+        class IDummy(Interface):\n+            dummy = zope.schema.TextLine(title="dummy1")\n+\n+        handler = IndexerSchema()\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n+\n+        self.assertEqual(None, field_node.get(ns("searchable", self.namespace)))\n+\n+\n+def test_suite():\n+    suite = unittest.TestSuite()\n+    suite.addTest(unittest.makeSuite(TestIndexerSchema))\n+    return suite\ndiff --git a/plone/app/dexterity/textindexer/tests/test_utils.py b/plone/app/dexterity/textindexer/tests/test_utils.py\nnew file mode 100644\nindex 0000000..1afc936\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/tests/test_utils.py\n@@ -0,0 +1,56 @@\n+from plone.app.dexterity.textindexer.tests.helpers import get_searchable_fields\n+from plone.app.dexterity.textindexer.utils import no_longer_searchable\n+from plone.app.dexterity.textindexer.utils import searchable\n+from plone.supermodel import model\n+from unittest import TestCase\n+from zope import schema\n+\n+\n+class IExample(model.Schema):\n+\n+    foo = schema.TextLine(title="foo")\n+\n+\n+class IBar(model.Schema):\n+    pass\n+\n+\n+class IBaz(model.Schema):\n+    baz = schema.TextLine(title="baz")\n+\n+\n+class TestUtils(TestCase):\n+    """Test utils module."""\n+\n+    def test_marking_field_as_searchable(self):\n+        self.assertEqual(get_searchable_fields(IExample), [])\n+        searchable(IExample, "foo")\n+        self.assertEqual(get_searchable_fields(IExample), ["foo"])\n+\n+    def test_break_when_field_does_not_exist(self):\n+        with self.assertRaises(AttributeError) as cm:\n+            searchable(IBar, "foo")\n+\n+        self.assertEqual(\n+            str(cm.exception),\n+            "plone.app.dexterity.textindexer.tests.test_utils.IBar"\n+            \' has no field "foo"\',\n+        )\n+\n+    def test_no_longer_searchable_removes_flag(self):\n+        self.assertEqual(get_searchable_fields(IBaz), [])\n+        searchable(IBaz, "baz")\n+        self.assertEqual(get_searchable_fields(IBaz), ["baz"])\n+        self.assertTrue(no_longer_searchable(IBaz, "baz"))\n+        self.assertFalse(no_longer_searchable(IBaz, "baz"))\n+        self.assertEqual(get_searchable_fields(IBaz), [])\n+\n+    def test_no_longer_searchable_breaks_when_field_does_not_exist(self):\n+        with self.assertRaises(AttributeError) as cm:\n+            no_longer_searchable(IBar, "foo")\n+\n+        self.assertEqual(\n+            str(cm.exception),\n+            "plone.app.dexterity.textindexer.tests.test_utils.IBar"\n+            \' has no field "foo"\',\n+        )\ndiff --git a/plone/app/dexterity/textindexer/utils.py b/plone/app/dexterity/textindexer/utils.py\nnew file mode 100644\nindex 0000000..c39d99f\n--- /dev/null\n+++ b/plone/app/dexterity/textindexer/utils.py\n@@ -0,0 +1,40 @@\n+from plone.app.dexterity.textindexer.directives import SEARCHABLE_KEY\n+from zope import schema\n+\n+\n+def searchable(iface, field_name):\n+    """\n+    mark a field in existing iface as searchable\n+    """\n+\n+    if schema.getFields(iface).get(field_name) is None:\n+        dottedname = ".".join((iface.__module__, iface.__name__))\n+        raise AttributeError(f\'{dottedname} has no field "{field_name}"\')\n+\n+    store = iface.queryTaggedValue(SEARCHABLE_KEY)\n+    if store is None:\n+        store = []\n+    store.append((iface, field_name, "true"))\n+    iface.setTaggedValue(SEARCHABLE_KEY, store)\n+\n+\n+def no_longer_searchable(iface, field_name):\n+    """Removes a "searchable" mark from a previously marked\n+    field.\n+    """\n+\n+    if schema.getFields(iface).get(field_name) is None:\n+        dottedname = ".".join((iface.__module__, iface.__name__))\n+        raise AttributeError(f\'{dottedname} has no field "{field_name}"\')\n+\n+    store = iface.queryTaggedValue(SEARCHABLE_KEY)\n+    if store is None:\n+        return False\n+\n+    key = (iface, field_name, "true")\n+    if key not in store:\n+        return False\n+\n+    store.remove(key)\n+    iface.setTaggedValue(SEARCHABLE_KEY, store)\n+    return True\ndiff --git a/setup.py b/setup.py\nindex 6bb5aca..31ef399 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -69,7 +69,6 @@\n         \'Products.CMFCore\',\n         \'Products.GenericSetup\',\n         \'setuptools\',\n-        \'six\',\n         \'Zope2\',\n         \'zope.browserpage\',\n         \'zope.interface\',\n'

