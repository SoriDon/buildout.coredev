Repository: plone.restapi


Branch: refs/heads/master
Date: 2021-12-07T20:07:48-03:00
Author: Ã‰rico Andrei (ericof) <ericof@gmail.com>
Commit: https://github.com/plone/plone.restapi/commit/764b8e267d2fe084bd46bf86f89336bcd7f2e0d5

Refactor SearchableText_blocks indexer to keep the order of the blocks when indexing

Files changed:
A src/plone/restapi/tests/test_indexers.py
M src/plone/restapi/indexers.py
M src/plone/restapi/indexers.zcml

b'diff --git a/src/plone/restapi/indexers.py b/src/plone/restapi/indexers.py\nindex c3663a91d..589c9351d 100644\n--- a/src/plone/restapi/indexers.py\n+++ b/src/plone/restapi/indexers.py\n@@ -2,7 +2,7 @@\n # This is an experimental feature meant for use in Volto only!\n # This code is likely to change in the future, even within minor releases.\n # We will make sure plone.restapi latest always works with the latest Volto release.\n-# This code is planned to being refactored into CMFPlone 6.0 as soon as Volto 4 final is out.\n+# This code is planned to being refactored into plone.volto before CMFPlone 6.0 is out.\n # <tisto@plone.org>\n \n from plone.app.contenttypes.indexers import SearchableText\n@@ -27,6 +27,8 @@ def _extract_text(block):\n @implementer(IBlockSearchableText)\n @adapter(IBlocks, IBrowserRequest)\n class TextBlockSearchableText:\n+    """Searchable Text indexer for Text (DraftJS) blocks."""\n+\n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n@@ -38,6 +40,8 @@ def __call__(self, value):\n @implementer(IBlockSearchableText)\n @adapter(IBlocks, IBrowserRequest)\n class TableBlockSearchableText:\n+    """Searchable Text indexer for Table blocks."""\n+\n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n@@ -55,59 +59,48 @@ def __call__(self, value):\n         return result\n \n \n+@implementer(IBlockSearchableText)\n+@adapter(IBlocks, IBrowserRequest)\n+class SlateTextIndexer:\n+    """Searchable Text indexer for Slate blocks."""\n+\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n+\n+    def __call__(self, block):\n+        block = block or {}\n+        # BBB compatibility with slate blocks that used the "plaintext" field\n+        return block.get("plaintext", "")\n+\n+\n @indexer(IBlocks)\n def SearchableText_blocks(obj):\n+    """Extract text to be used by the SearchableText index in the Catalog."""\n     request = getRequest()\n     blocks = obj.blocks\n+    blocks_layout = obj.blocks_layout\n     blocks_text = []\n-\n-    for block in blocks.values():\n-\n+    for block_id in blocks_layout.get("items", []):\n+        block = blocks.get(block_id, {})\n+        # searchableText is the conventional way of storing\n+        # searchable info in a block\n         searchableText = block.get("searchableText", "")\n         if searchableText:\n             # TODO: should we evaluate in some way this value? maybe passing\n             # it into html/plain text transformer?\n             blocks_text.append(searchableText)\n-\n-        block_type = block.get("@type", "")\n-        adapter = queryMultiAdapter(\n-            (obj, request), IBlockSearchableText, name=block_type\n-        )\n-\n-        if adapter is not None:\n-            text = adapter(block)\n-\n+        else:\n+            # Use server side adapters to extract the text data\n+            block_type = block.get("@type", "")\n+            adapter = queryMultiAdapter(\n+                (obj, request), IBlockSearchableText, name=block_type\n+            )\n+            text = adapter(block) if adapter is not None else ""\n             if text:\n                 blocks_text.append(text)\n \n+    # Extract text using the base plone.app.contenttypes indexer\n     std_text = SearchableText(obj)\n     blocks_text.append(std_text)\n-\n     return " ".join(blocks_text)\n-\n-\n-class SlateTextIndexer:\n-    """SlateTextIndexer."""\n-\n-    def __init__(self, context, request):\n-        """__init__.\n-\n-        :param context:\n-        :param request:\n-        """\n-        self.context = context\n-        self.request = request\n-\n-    def __call__(self, block):\n-        """__call__.\n-\n-        :param block:\n-        """\n-        # text indexer for slate blocks. Relies on the slate field\n-        block = block or {}\n-\n-        if block.get("searchableText"):\n-            return\n-\n-        # BBB compatibility with slate blocks that used the "plaintext" field\n-        return (block or {}).get("plaintext", "")\ndiff --git a/src/plone/restapi/indexers.zcml b/src/plone/restapi/indexers.zcml\nindex 39ec49297..345a065ec 100644\n--- a/src/plone/restapi/indexers.zcml\n+++ b/src/plone/restapi/indexers.zcml\n@@ -15,9 +15,6 @@\n         />\n     <adapter\n         factory=".indexers.SlateTextIndexer"\n-        provides="plone.restapi.interfaces.IBlockSearchableText"\n-        for="*\n-             *"\n         name="slate"\n         />\n     <adapter\ndiff --git a/src/plone/restapi/tests/test_indexers.py b/src/plone/restapi/tests/test_indexers.py\nnew file mode 100644\nindex 000000000..b4c7270f0\n--- /dev/null\n+++ b/src/plone/restapi/tests/test_indexers.py\n@@ -0,0 +1,176 @@\n+from plone.dexterity.interfaces import IDexterityFTI\n+from plone.restapi.indexers import SearchableText_blocks\n+from plone.restapi.testing import PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+from uuid import uuid4\n+from zope.component import queryUtility\n+\n+import unittest\n+\n+\n+class TestSearchableTextIndexer(unittest.TestCase):\n+\n+    layer = PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        fti = queryUtility(IDexterityFTI, name="Document")\n+        behavior_list = [a for a in fti.behaviors]\n+        behavior_list.append("volto.blocks")\n+        fti.behaviors = tuple(behavior_list)\n+        self.portal.invokeFactory(\n+            "Document",\n+            id="doc1",\n+            title="Title is here",\n+            description="Description is there",\n+            blocks={},\n+            blocks_layout={"items": []},\n+        )\n+        self.document = self.portal["doc1"]\n+\n+    @staticmethod\n+    def _extract_searchable_text(obj):\n+        indexer = SearchableText_blocks(obj)\n+        return indexer()\n+\n+    @staticmethod\n+    def _add_blocks(obj, raw_blocks):\n+        blocks = {str(uuid4()): block for block in raw_blocks}\n+        layout = list(blocks.keys())\n+        obj.blocks = blocks\n+        obj.blocks_layout["items"] = layout\n+\n+    def test_indexer_no_blocks(self):\n+        result = self._extract_searchable_text(self.document)\n+        self.assertIn("Title is here", result)\n+        self.assertIn("Description is there", result)\n+\n+    def test_indexer_block_has_searchableText(self):\n+        document = self.document\n+        self._add_blocks(\n+            document,\n+            [{"@type": "new-block", "attribute": "bar", "searchableText": "Foo Bar"}],\n+        )\n+        result = self._extract_searchable_text(document)\n+        self.assertIn("Title is here Description is there ", result)\n+        self.assertIn("Foo Bar", result)\n+\n+    def test_indexer_multiple_blocks(self):\n+        document = self.document\n+        self._add_blocks(\n+            document,\n+            [\n+                {"@type": "a-block", "key": "value", "searchableText": "Plone is a"},\n+                {"@type": "a-block", "attribute": "bar", "searchableText": "CMS"},\n+            ],\n+        )\n+        result = self._extract_searchable_text(document)\n+        self.assertIn("Plone is a CMS ", result)\n+\n+    def test_indexer_block_slate_bbb(self):\n+        document = self.document\n+        self._add_blocks(\n+            document,\n+            [\n+                {\n+                    "@type": "slate",\n+                    "plaintext": "Follow Plone Conference",\n+                    "value": [{"children": [{"text": "Follow Plone Conference"}]}],\n+                }\n+            ],\n+        )\n+        result = self._extract_searchable_text(document)\n+        self.assertIn("Title is here Description is there ", result)\n+        self.assertIn("Follow Plone Conference", result)\n+\n+    def test_indexer_block_text(self):\n+        document = self.document\n+        self._add_blocks(\n+            document,\n+            [\n+                {\n+                    "@type": "text",\n+                    "text": {\n+                        "blocks": [\n+                            {\n+                                "data": {},\n+                                "depth": 0,\n+                                "entityRanges": [],\n+                                "inlineStyleRanges": [],\n+                                "key": "behki",\n+                                "text": "Plone is a powerful content management system",\n+                                "type": "unstyled",\n+                            }\n+                        ],\n+                        "entityMap": {},\n+                    },\n+                }\n+            ],\n+        )\n+        result = self._extract_searchable_text(document)\n+        self.assertIn("Title is here Description is there ", result)\n+        self.assertIn("Plone is a powerful content management system", result)\n+\n+    def test_indexer_block_table(self):\n+        document = self.document\n+        self._add_blocks(\n+            document,\n+            [\n+                {\n+                    "@type": "table",\n+                    "table": {\n+                        "rows": [\n+                            {\n+                                "key": "a",\n+                                "cells": [\n+                                    {\n+                                        "type": "data",\n+                                        "key": "b",\n+                                        "value": {\n+                                            "blocks": [\n+                                                {\n+                                                    "data": {},\n+                                                    "depth": 0,\n+                                                    "entityRanges": [],\n+                                                    "inlineStyleRanges": [],\n+                                                    "key": "fgm98",\n+                                                    "text": "My header",\n+                                                    "type": "header-two",\n+                                                },\n+                                            ],\n+                                            "entityMap": {},\n+                                        },\n+                                    },\n+                                ],\n+                            },\n+                            {\n+                                "key": "c",\n+                                "cells": [\n+                                    {\n+                                        "type": "data",\n+                                        "key": "d",\n+                                        "value": {\n+                                            "blocks": [\n+                                                {\n+                                                    "data": {},\n+                                                    "depth": 0,\n+                                                    "entityRanges": [],\n+                                                    "inlineStyleRanges": [],\n+                                                    "key": "mmm99",\n+                                                    "text": "My data",\n+                                                    "type": "text",\n+                                                },\n+                                            ],\n+                                            "entityMap": {},\n+                                        },\n+                                    },\n+                                ],\n+                            },\n+                        ]\n+                    },\n+                }\n+            ],\n+        )\n+        result = self._extract_searchable_text(document)\n+        self.assertIn("Title is here Description is there ", result)\n+        self.assertIn("My data", result)\n'

Repository: plone.restapi


Branch: refs/heads/master
Date: 2021-12-07T20:08:16-03:00
Author: Ã‰rico Andrei (ericof) <ericof@gmail.com>
Commit: https://github.com/plone/plone.restapi/commit/8bb506defc7bd9b7237a6b48bf76688a688ab24f

Update documentation.

Files changed:
M docs/source/blocks.rst

b'diff --git a/docs/source/blocks.rst b/docs/source/blocks.rst\nindex 2e4a9c117..e957bf339 100644\n--- a/docs/source/blocks.rst\n+++ b/docs/source/blocks.rst\n@@ -169,7 +169,29 @@ SearchableText indexing for blocks\n \n As the main consumer of plone.restapi\'s blocks, this functionality is specific to Volto blocks. By default searchable text (for Plone\'s SearchableText index) is extracted from `text` blocks.\n \n-To extract searchable text for other types of blocks, you need to write an adapter that can process that type of block.::\n+To extract searchable text for other types of blocks, there are two approaches:\n+\n+Client side solution\n+++++++++++++++++++++\n+\n+The block provides the data to be indexed in its **searchableText** attribute::\n+\n+  {\n+    "@type": "image",\n+    "align": "center",\n+    "alt": "Plone Conference 2021 logo",\n+    "searchableText": "Plone Conference 2021 logo",\n+    "size": "l",\n+    "url": "https://2021.ploneconf.org/images/logoandfamiliesalt.svg"\n+  }\n+\n+\n+This is the preferred solution.\n+\n+Server side solution\n+++++++++++++++++++++\n+\n+ For each new block, you need to write an adapter that will extract the searchable text from the block information::\n \n   @implementer(IBlockSearchableText)\n   @adapter(IBlocks, IBrowserRequest)\n@@ -186,4 +208,3 @@ See ``plone.restapi.interfaces.IBlockSearchableText`` for details. The ``__call_\n This adapter needs to be registered as a named adapter, where the name is the same as the block type (its `@type` property from the block value).::\n \n     <adapter name="image" factory=".indexers.ImageBlockSearchableText" />\n-\n'

Repository: plone.restapi


Branch: refs/heads/master
Date: 2021-12-07T20:08:34-03:00
Author: Ã‰rico Andrei (ericof) <ericof@gmail.com>
Commit: https://github.com/plone/plone.restapi/commit/d15cc4bf1cf30cf9cee746b8e0f5932e98084189

Update changelog.

Files changed:
A news/1292.bugfix

b'diff --git a/news/1292.bugfix b/news/1292.bugfix\nnew file mode 100644\nindex 000000000..33c15b53c\n--- /dev/null\n+++ b/news/1292.bugfix\n@@ -0,0 +1,2 @@\n+SearchableText indexer should maintain the order of the blocks\n+[ericof]\n\\ No newline at end of file\n'

Repository: plone.restapi


Branch: refs/heads/master
Date: 2021-12-07T20:26:00-03:00
Author: Ã‰rico Andrei (ericof) <ericof@gmail.com>
Commit: https://github.com/plone/plone.restapi/commit/0c19d36411dfa42e8146a0b1d4ec0afe171a4184

Fix test_blocks_searchable_text

Files changed:
M src/plone/restapi/tests/test_blocks_searchable_text.py

b'diff --git a/src/plone/restapi/tests/test_blocks_searchable_text.py b/src/plone/restapi/tests/test_blocks_searchable_text.py\nindex 414679d5e..9867a371c 100644\n--- a/src/plone/restapi/tests/test_blocks_searchable_text.py\n+++ b/src/plone/restapi/tests/test_blocks_searchable_text.py\n@@ -50,6 +50,7 @@ def test_search_text(self):\n         response = self.api_session.patch(\n             "/doc",\n             json={\n+                "blocks_layout": {"items": ["uuid1", "uuid2"]},\n                 "blocks": {\n                     "uuid1": {\n                         "@type": "text",\n@@ -85,7 +86,7 @@ def test_search_text(self):\n                             "entityMap": {},\n                         },\n                     },\n-                }\n+                },\n             },\n         )\n \n@@ -147,6 +148,7 @@ def __call__(self, value):\n         }\n \n         self.doc.blocks = blocks\n+        self.doc.blocks_layout = {"items": ["uuid1", "uuid3"]}\n         from plone.indexer.interfaces import IIndexableObject\n         from zope.component import queryMultiAdapter\n \n@@ -160,6 +162,7 @@ def test_index_searchableText_value(self):\n         response = self.api_session.patch(\n             "/doc",\n             json={\n+                "blocks_layout": {"items": ["uuid1", "uuid2"]},\n                 "blocks": {\n                     "uuid1": {\n                         "@type": "text",\n@@ -182,7 +185,7 @@ def test_index_searchableText_value(self):\n                         "@type": "custom_type",\n                         "searchableText": "custom text foo",\n                     },\n-                }\n+                },\n             },\n         )\n \n@@ -231,10 +234,12 @@ def test_search_slate_text(self):\n                 "value": [],\n             },\n         }\n-        self.doc.blocks_layout = [\n-            "38541872-06c2-41c9-8709-37107e597b18",\n-            "4fcfeb9b-f73e-427c-9e06-2e4d53b06865",\n-        ]\n+        self.doc.blocks_layout = {\n+            "items": [\n+                "38541872-06c2-41c9-8709-37107e597b18",\n+                "4fcfeb9b-f73e-427c-9e06-2e4d53b06865",\n+            ]\n+        }\n         self.portal.portal_catalog.indexObject(self.doc)\n \n         query = {"SearchableText": "climatic"}\n@@ -342,9 +347,7 @@ def test_search_table_text(self):\n                 },\n             }\n         }\n-        self.doc.blocks_layout = [\n-            "uuid1",\n-        ]\n+        self.doc.blocks_layout = {"items": ["uuid1"]}\n         self.portal.portal_catalog.indexObject(self.doc)\n \n         query = {"SearchableText": "foo"}\n'

Repository: plone.restapi


Branch: refs/heads/master
Date: 2021-12-09T15:21:44-03:00
Author: Ã‰rico Andrei (ericof) <ericof@gmail.com>
Commit: https://github.com/plone/plone.restapi/commit/e8e1e4d40c83aa1ab9ae559db2cabcc8b6777c07

Implement recursive indexing of blocks

Files changed:
M src/plone/restapi/indexers.py
M src/plone/restapi/tests/test_indexers.py

b'diff --git a/src/plone/restapi/indexers.py b/src/plone/restapi/indexers.py\nindex 589c9351d..58392c016 100644\n--- a/src/plone/restapi/indexers.py\n+++ b/src/plone/restapi/indexers.py\n@@ -74,6 +74,58 @@ def __call__(self, block):\n         return block.get("plaintext", "")\n \n \n+def extract_subblocks(block):\n+    """Extract subblocks from a block.\n+\n+    :param block: Dictionary with block information.\n+    :returns: A list with subblocks, if present, or an empty list.\n+    """\n+    if "data" in block and "blocks" in block["data"]:\n+        raw_blocks = block["data"]["blocks"]\n+    elif "blocks" in block:\n+        raw_blocks = block["blocks"]\n+    else:\n+        raw_blocks = None\n+    return list(raw_blocks.values()) if isinstance(raw_blocks, dict) else []\n+\n+\n+def extract_text(block, obj, request):\n+    """Extract text information from a block.\n+\n+    This function tries the following methods, until it finds a result:\n+        1. searchableText attribute\n+        2. Server side adapter\n+        3. Subblocks\n+\n+    The decision to use the server side adapter before the subblocks traversal\n+    allows addon developers to choose this implementation when they want a\n+    more granular control of the indexing.\n+\n+    :param block: Dictionary with block information.\n+    :param obj: Context to be used to get a IBlockSearchableText.\n+    :param request: Current request.\n+    :returns: A string with text found in the block.\n+    """\n+    result = ""\n+    block_type = block.get("@type", "")\n+    subblocks = extract_subblocks(block)\n+    # searchableText is the conventional way of storing\n+    # searchable info in a block\n+    searchableText = block.get("searchableText", "")\n+    if searchableText:\n+        # TODO: should we evaluate in some way this value? maybe passing\n+        # it into html/plain text transformer?\n+        return searchableText\n+    # Use server side adapters to extract the text data\n+    adapter = queryMultiAdapter((obj, request), IBlockSearchableText, name=block_type)\n+    result = adapter(block) if adapter is not None else ""\n+    if not result and subblocks:\n+        for subblock in subblocks:\n+            tmp_result = extract_text(subblock, obj, request)\n+            result = f"{result} {tmp_result}"\n+    return result\n+\n+\n @indexer(IBlocks)\n def SearchableText_blocks(obj):\n     """Extract text to be used by the SearchableText index in the Catalog."""\n@@ -83,24 +135,9 @@ def SearchableText_blocks(obj):\n     blocks_text = []\n     for block_id in blocks_layout.get("items", []):\n         block = blocks.get(block_id, {})\n-        # searchableText is the conventional way of storing\n-        # searchable info in a block\n-        searchableText = block.get("searchableText", "")\n-        if searchableText:\n-            # TODO: should we evaluate in some way this value? maybe passing\n-            # it into html/plain text transformer?\n-            blocks_text.append(searchableText)\n-        else:\n-            # Use server side adapters to extract the text data\n-            block_type = block.get("@type", "")\n-            adapter = queryMultiAdapter(\n-                (obj, request), IBlockSearchableText, name=block_type\n-            )\n-            text = adapter(block) if adapter is not None else ""\n-            if text:\n-                blocks_text.append(text)\n+        blocks_text.append(extract_text(block, obj, request))\n \n     # Extract text using the base plone.app.contenttypes indexer\n     std_text = SearchableText(obj)\n     blocks_text.append(std_text)\n-    return " ".join(blocks_text)\n+    return " ".join([text.strip() for text in blocks_text if text.strip()])\ndiff --git a/src/plone/restapi/tests/test_indexers.py b/src/plone/restapi/tests/test_indexers.py\nindex b4c7270f0..0e227a4c9 100644\n--- a/src/plone/restapi/tests/test_indexers.py\n+++ b/src/plone/restapi/tests/test_indexers.py\n@@ -7,6 +7,86 @@\n import unittest\n \n \n+DRAFTJS_BLOCK = {\n+    "@type": "text",\n+    "text": {\n+        "blocks": [\n+            {\n+                "data": {},\n+                "depth": 0,\n+                "entityRanges": [],\n+                "inlineStyleRanges": [],\n+                "key": "behki",\n+                "text": "Plone is a powerful content management system",\n+                "type": "unstyled",\n+            }\n+        ],\n+        "entityMap": {},\n+    },\n+}\n+\n+SLATE_BLOCK = {\n+    "@type": "slate",\n+    "plaintext": "Follow Plone Conference",\n+    "value": [{"children": [{"text": "Follow Plone Conference"}]}],\n+}\n+\n+\n+TABLE_BLOCK = {\n+    "@type": "table",\n+    "table": {\n+        "rows": [\n+            {\n+                "key": "a",\n+                "cells": [\n+                    {\n+                        "type": "data",\n+                        "key": "b",\n+                        "value": {\n+                            "blocks": [\n+                                {\n+                                    "data": {},\n+                                    "depth": 0,\n+                                    "entityRanges": [],\n+                                    "inlineStyleRanges": [],\n+                                    "key": "fgm98",\n+                                    "text": "My header",\n+                                    "type": "header-two",\n+                                },\n+                            ],\n+                            "entityMap": {},\n+                        },\n+                    },\n+                ],\n+            },\n+            {\n+                "key": "c",\n+                "cells": [\n+                    {\n+                        "type": "data",\n+                        "key": "d",\n+                        "value": {\n+                            "blocks": [\n+                                {\n+                                    "data": {},\n+                                    "depth": 0,\n+                                    "entityRanges": [],\n+                                    "inlineStyleRanges": [],\n+                                    "key": "mmm99",\n+                                    "text": "My data",\n+                                    "type": "text",\n+                                },\n+                            ],\n+                            "entityMap": {},\n+                        },\n+                    },\n+                ],\n+            },\n+        ]\n+    },\n+}\n+\n+\n class TestSearchableTextIndexer(unittest.TestCase):\n \n     layer = PLONE_RESTAPI_DX_INTEGRATION_TESTING\n@@ -52,7 +132,7 @@ def test_indexer_block_has_searchableText(self):\n             [{"@type": "new-block", "attribute": "bar", "searchableText": "Foo Bar"}],\n         )\n         result = self._extract_searchable_text(document)\n-        self.assertIn("Title is here Description is there ", result)\n+        self.assertIn("Title is here Description is there", result)\n         self.assertIn("Foo Bar", result)\n \n     def test_indexer_multiple_blocks(self):\n@@ -72,15 +152,11 @@ def test_indexer_block_slate_bbb(self):\n         self._add_blocks(\n             document,\n             [\n-                {\n-                    "@type": "slate",\n-                    "plaintext": "Follow Plone Conference",\n-                    "value": [{"children": [{"text": "Follow Plone Conference"}]}],\n-                }\n+                SLATE_BLOCK,\n             ],\n         )\n         result = self._extract_searchable_text(document)\n-        self.assertIn("Title is here Description is there ", result)\n+        self.assertIn("Title is here Description is there", result)\n         self.assertIn("Follow Plone Conference", result)\n \n     def test_indexer_block_text(self):\n@@ -88,27 +164,11 @@ def test_indexer_block_text(self):\n         self._add_blocks(\n             document,\n             [\n-                {\n-                    "@type": "text",\n-                    "text": {\n-                        "blocks": [\n-                            {\n-                                "data": {},\n-                                "depth": 0,\n-                                "entityRanges": [],\n-                                "inlineStyleRanges": [],\n-                                "key": "behki",\n-                                "text": "Plone is a powerful content management system",\n-                                "type": "unstyled",\n-                            }\n-                        ],\n-                        "entityMap": {},\n-                    },\n-                }\n+                DRAFTJS_BLOCK,\n             ],\n         )\n         result = self._extract_searchable_text(document)\n-        self.assertIn("Title is here Description is there ", result)\n+        self.assertIn("Title is here Description is there", result)\n         self.assertIn("Plone is a powerful content management system", result)\n \n     def test_indexer_block_table(self):\n@@ -116,61 +176,40 @@ def test_indexer_block_table(self):\n         self._add_blocks(\n             document,\n             [\n-                {\n-                    "@type": "table",\n-                    "table": {\n-                        "rows": [\n-                            {\n-                                "key": "a",\n-                                "cells": [\n-                                    {\n-                                        "type": "data",\n-                                        "key": "b",\n-                                        "value": {\n-                                            "blocks": [\n-                                                {\n-                                                    "data": {},\n-                                                    "depth": 0,\n-                                                    "entityRanges": [],\n-                                                    "inlineStyleRanges": [],\n-                                                    "key": "fgm98",\n-                                                    "text": "My header",\n-                                                    "type": "header-two",\n-                                                },\n-                                            ],\n-                                            "entityMap": {},\n-                                        },\n-                                    },\n-                                ],\n-                            },\n-                            {\n-                                "key": "c",\n-                                "cells": [\n-                                    {\n-                                        "type": "data",\n-                                        "key": "d",\n-                                        "value": {\n-                                            "blocks": [\n-                                                {\n-                                                    "data": {},\n-                                                    "depth": 0,\n-                                                    "entityRanges": [],\n-                                                    "inlineStyleRanges": [],\n-                                                    "key": "mmm99",\n-                                                    "text": "My data",\n-                                                    "type": "text",\n-                                                },\n-                                            ],\n-                                            "entityMap": {},\n-                                        },\n-                                    },\n-                                ],\n-                            },\n-                        ]\n+                TABLE_BLOCK,\n+            ],\n+        )\n+        result = self._extract_searchable_text(document)\n+        self.assertIn("Title is here Description is there", result)\n+        self.assertIn("My data", result)\n+\n+    def test_indexer_block_with_subblocks(self):\n+        document = self.document\n+        block = {\n+            "@type": "complex-block",\n+            "blocks": {\n+                "ad625c27-670a-412e-821d-57870b6e82f1": SLATE_BLOCK,\n+                "80c5d58d-4baf-4adc-8ef4-36810df5628d": DRAFTJS_BLOCK,\n+                "4061b21d-c971-4ccc-a719-d8b24214fd8b": {\n+                    "@type": "old-complex-block",\n+                    "data": {\n+                        "blocks": {\n+                            "116feae0-7aa3-40f4-a776-fc893d78b353": TABLE_BLOCK,\n+                        }\n                     },\n-                }\n+                },\n+            },\n+        }\n+        self._add_blocks(\n+            document,\n+            [\n+                block,\n             ],\n         )\n         result = self._extract_searchable_text(document)\n-        self.assertIn("Title is here Description is there ", result)\n+        # From Slate sub block\n+        self.assertIn("Follow Plone Conference", result)\n+        # From DraftJS\n+        self.assertIn("Plone is a powerful content management system", result)\n+        # From Table block\n         self.assertIn("My data", result)\n'

Repository: plone.restapi


Branch: refs/heads/master
Date: 2021-12-09T15:23:16-03:00
Author: Ã‰rico Andrei (ericof) <ericof@gmail.com>
Commit: https://github.com/plone/plone.restapi/commit/0e87f935901ff1810f47c922698849e6dff38ddf

Move logic of _extract_text function inside the DraftJS indexer

Files changed:
M src/plone/restapi/indexers.py

b'diff --git a/src/plone/restapi/indexers.py b/src/plone/restapi/indexers.py\nindex 58392c016..3ee2734ed 100644\n--- a/src/plone/restapi/indexers.py\n+++ b/src/plone/restapi/indexers.py\n@@ -16,14 +16,6 @@\n from zope.publisher.interfaces.browser import IBrowserRequest\n \n \n-def _extract_text(block):\n-    result = ""\n-    for paragraph in block.get("text", {}).get("blocks", {}):\n-        text = paragraph["text"]\n-        result = " ".join((result, text))\n-    return result\n-\n-\n @implementer(IBlockSearchableText)\n @adapter(IBlocks, IBrowserRequest)\n class TextBlockSearchableText:\n@@ -34,7 +26,11 @@ def __init__(self, context, request):\n         self.request = request\n \n     def __call__(self, value):\n-        return _extract_text(value)\n+        result = ""\n+        for paragraph in value.get("text", {}).get("blocks", {}):\n+            text = paragraph["text"]\n+            result = " ".join((result, text))\n+        return result\n \n \n @implementer(IBlockSearchableText)\n'

Repository: plone.restapi


Branch: refs/heads/master
Date: 2021-12-09T21:09:19-03:00
Author: Ã‰rico Andrei (ericof) <ericof@gmail.com>
Commit: https://github.com/plone/plone.restapi/commit/2c3707086c6d5ca2ee79652beb1682cf411dd48b

Add a line break between blocks

Files changed:
M src/plone/restapi/indexers.py

b'diff --git a/src/plone/restapi/indexers.py b/src/plone/restapi/indexers.py\nindex 3ee2734ed..4d142edc5 100644\n--- a/src/plone/restapi/indexers.py\n+++ b/src/plone/restapi/indexers.py\n@@ -118,7 +118,7 @@ def extract_text(block, obj, request):\n     if not result and subblocks:\n         for subblock in subblocks:\n             tmp_result = extract_text(subblock, obj, request)\n-            result = f"{result} {tmp_result}"\n+            result = f"{result}\\n{tmp_result}"\n     return result\n \n \n'

Repository: plone.restapi


Branch: refs/heads/master
Date: 2021-12-09T21:11:32-03:00
Author: Ã‰rico Andrei (ericof) <ericof@gmail.com>
Commit: https://github.com/plone/plone.restapi/commit/4ad07be81a06870b5af075417a426fdbf00506c9

Refactor text extraction

Files changed:
M src/plone/restapi/indexers.py

b'diff --git a/src/plone/restapi/indexers.py b/src/plone/restapi/indexers.py\nindex 4d142edc5..b7dd49c8d 100644\n--- a/src/plone/restapi/indexers.py\n+++ b/src/plone/restapi/indexers.py\n@@ -104,7 +104,6 @@ def extract_text(block, obj, request):\n     """\n     result = ""\n     block_type = block.get("@type", "")\n-    subblocks = extract_subblocks(block)\n     # searchableText is the conventional way of storing\n     # searchable info in a block\n     searchableText = block.get("searchableText", "")\n@@ -115,7 +114,8 @@ def extract_text(block, obj, request):\n     # Use server side adapters to extract the text data\n     adapter = queryMultiAdapter((obj, request), IBlockSearchableText, name=block_type)\n     result = adapter(block) if adapter is not None else ""\n-    if not result and subblocks:\n+    if not result:\n+        subblocks = extract_subblocks(block)\n         for subblock in subblocks:\n             tmp_result = extract_text(subblock, obj, request)\n             result = f"{result}\\n{tmp_result}"\n'

Repository: plone.restapi


Branch: refs/heads/master
Date: 2021-12-10T08:53:31-03:00
Author: Ã‰rico Andrei (ericof) <ericof@gmail.com>
Commit: https://github.com/plone/plone.restapi/commit/a37557ea45bf74d548aa72929f39b5d462ad6ca6

Merge pull request #1293 from plone/issue-1292-searchabletext-order

Keep order of blocks when indexing SearchableText

Files changed:
A news/1292.bugfix
A src/plone/restapi/tests/test_indexers.py
M docs/source/blocks.rst
M src/plone/restapi/indexers.py
M src/plone/restapi/indexers.zcml
M src/plone/restapi/tests/test_blocks_searchable_text.py

b'diff --git a/docs/source/blocks.rst b/docs/source/blocks.rst\nindex 2e4a9c117..e957bf339 100644\n--- a/docs/source/blocks.rst\n+++ b/docs/source/blocks.rst\n@@ -169,7 +169,29 @@ SearchableText indexing for blocks\n \n As the main consumer of plone.restapi\'s blocks, this functionality is specific to Volto blocks. By default searchable text (for Plone\'s SearchableText index) is extracted from `text` blocks.\n \n-To extract searchable text for other types of blocks, you need to write an adapter that can process that type of block.::\n+To extract searchable text for other types of blocks, there are two approaches:\n+\n+Client side solution\n+++++++++++++++++++++\n+\n+The block provides the data to be indexed in its **searchableText** attribute::\n+\n+  {\n+    "@type": "image",\n+    "align": "center",\n+    "alt": "Plone Conference 2021 logo",\n+    "searchableText": "Plone Conference 2021 logo",\n+    "size": "l",\n+    "url": "https://2021.ploneconf.org/images/logoandfamiliesalt.svg"\n+  }\n+\n+\n+This is the preferred solution.\n+\n+Server side solution\n+++++++++++++++++++++\n+\n+ For each new block, you need to write an adapter that will extract the searchable text from the block information::\n \n   @implementer(IBlockSearchableText)\n   @adapter(IBlocks, IBrowserRequest)\n@@ -186,4 +208,3 @@ See ``plone.restapi.interfaces.IBlockSearchableText`` for details. The ``__call_\n This adapter needs to be registered as a named adapter, where the name is the same as the block type (its `@type` property from the block value).::\n \n     <adapter name="image" factory=".indexers.ImageBlockSearchableText" />\n-\ndiff --git a/news/1292.bugfix b/news/1292.bugfix\nnew file mode 100644\nindex 000000000..33c15b53c\n--- /dev/null\n+++ b/news/1292.bugfix\n@@ -0,0 +1,2 @@\n+SearchableText indexer should maintain the order of the blocks\n+[ericof]\n\\ No newline at end of file\ndiff --git a/src/plone/restapi/indexers.py b/src/plone/restapi/indexers.py\nindex c3663a91d..b7dd49c8d 100644\n--- a/src/plone/restapi/indexers.py\n+++ b/src/plone/restapi/indexers.py\n@@ -2,7 +2,7 @@\n # This is an experimental feature meant for use in Volto only!\n # This code is likely to change in the future, even within minor releases.\n # We will make sure plone.restapi latest always works with the latest Volto release.\n-# This code is planned to being refactored into CMFPlone 6.0 as soon as Volto 4 final is out.\n+# This code is planned to being refactored into plone.volto before CMFPlone 6.0 is out.\n # <tisto@plone.org>\n \n from plone.app.contenttypes.indexers import SearchableText\n@@ -16,28 +16,28 @@\n from zope.publisher.interfaces.browser import IBrowserRequest\n \n \n-def _extract_text(block):\n-    result = ""\n-    for paragraph in block.get("text", {}).get("blocks", {}):\n-        text = paragraph["text"]\n-        result = " ".join((result, text))\n-    return result\n-\n-\n @implementer(IBlockSearchableText)\n @adapter(IBlocks, IBrowserRequest)\n class TextBlockSearchableText:\n+    """Searchable Text indexer for Text (DraftJS) blocks."""\n+\n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n \n     def __call__(self, value):\n-        return _extract_text(value)\n+        result = ""\n+        for paragraph in value.get("text", {}).get("blocks", {}):\n+            text = paragraph["text"]\n+            result = " ".join((result, text))\n+        return result\n \n \n @implementer(IBlockSearchableText)\n @adapter(IBlocks, IBrowserRequest)\n class TableBlockSearchableText:\n+    """Searchable Text indexer for Table blocks."""\n+\n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n@@ -55,59 +55,85 @@ def __call__(self, value):\n         return result\n \n \n-@indexer(IBlocks)\n-def SearchableText_blocks(obj):\n-    request = getRequest()\n-    blocks = obj.blocks\n-    blocks_text = []\n-\n-    for block in blocks.values():\n-\n-        searchableText = block.get("searchableText", "")\n-        if searchableText:\n-            # TODO: should we evaluate in some way this value? maybe passing\n-            # it into html/plain text transformer?\n-            blocks_text.append(searchableText)\n+@implementer(IBlockSearchableText)\n+@adapter(IBlocks, IBrowserRequest)\n+class SlateTextIndexer:\n+    """Searchable Text indexer for Slate blocks."""\n \n-        block_type = block.get("@type", "")\n-        adapter = queryMultiAdapter(\n-            (obj, request), IBlockSearchableText, name=block_type\n-        )\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n \n-        if adapter is not None:\n-            text = adapter(block)\n+    def __call__(self, block):\n+        block = block or {}\n+        # BBB compatibility with slate blocks that used the "plaintext" field\n+        return block.get("plaintext", "")\n \n-            if text:\n-                blocks_text.append(text)\n \n-    std_text = SearchableText(obj)\n-    blocks_text.append(std_text)\n+def extract_subblocks(block):\n+    """Extract subblocks from a block.\n \n-    return " ".join(blocks_text)\n+    :param block: Dictionary with block information.\n+    :returns: A list with subblocks, if present, or an empty list.\n+    """\n+    if "data" in block and "blocks" in block["data"]:\n+        raw_blocks = block["data"]["blocks"]\n+    elif "blocks" in block:\n+        raw_blocks = block["blocks"]\n+    else:\n+        raw_blocks = None\n+    return list(raw_blocks.values()) if isinstance(raw_blocks, dict) else []\n \n \n-class SlateTextIndexer:\n-    """SlateTextIndexer."""\n+def extract_text(block, obj, request):\n+    """Extract text information from a block.\n \n-    def __init__(self, context, request):\n-        """__init__.\n+    This function tries the following methods, until it finds a result:\n+        1. searchableText attribute\n+        2. Server side adapter\n+        3. Subblocks\n \n-        :param context:\n-        :param request:\n-        """\n-        self.context = context\n-        self.request = request\n+    The decision to use the server side adapter before the subblocks traversal\n+    allows addon developers to choose this implementation when they want a\n+    more granular control of the indexing.\n \n-    def __call__(self, block):\n-        """__call__.\n+    :param block: Dictionary with block information.\n+    :param obj: Context to be used to get a IBlockSearchableText.\n+    :param request: Current request.\n+    :returns: A string with text found in the block.\n+    """\n+    result = ""\n+    block_type = block.get("@type", "")\n+    # searchableText is the conventional way of storing\n+    # searchable info in a block\n+    searchableText = block.get("searchableText", "")\n+    if searchableText:\n+        # TODO: should we evaluate in some way this value? maybe passing\n+        # it into html/plain text transformer?\n+        return searchableText\n+    # Use server side adapters to extract the text data\n+    adapter = queryMultiAdapter((obj, request), IBlockSearchableText, name=block_type)\n+    result = adapter(block) if adapter is not None else ""\n+    if not result:\n+        subblocks = extract_subblocks(block)\n+        for subblock in subblocks:\n+            tmp_result = extract_text(subblock, obj, request)\n+            result = f"{result}\\n{tmp_result}"\n+    return result\n \n-        :param block:\n-        """\n-        # text indexer for slate blocks. Relies on the slate field\n-        block = block or {}\n \n-        if block.get("searchableText"):\n-            return\n+@indexer(IBlocks)\n+def SearchableText_blocks(obj):\n+    """Extract text to be used by the SearchableText index in the Catalog."""\n+    request = getRequest()\n+    blocks = obj.blocks\n+    blocks_layout = obj.blocks_layout\n+    blocks_text = []\n+    for block_id in blocks_layout.get("items", []):\n+        block = blocks.get(block_id, {})\n+        blocks_text.append(extract_text(block, obj, request))\n \n-        # BBB compatibility with slate blocks that used the "plaintext" field\n-        return (block or {}).get("plaintext", "")\n+    # Extract text using the base plone.app.contenttypes indexer\n+    std_text = SearchableText(obj)\n+    blocks_text.append(std_text)\n+    return " ".join([text.strip() for text in blocks_text if text.strip()])\ndiff --git a/src/plone/restapi/indexers.zcml b/src/plone/restapi/indexers.zcml\nindex 39ec49297..345a065ec 100644\n--- a/src/plone/restapi/indexers.zcml\n+++ b/src/plone/restapi/indexers.zcml\n@@ -15,9 +15,6 @@\n         />\n     <adapter\n         factory=".indexers.SlateTextIndexer"\n-        provides="plone.restapi.interfaces.IBlockSearchableText"\n-        for="*\n-             *"\n         name="slate"\n         />\n     <adapter\ndiff --git a/src/plone/restapi/tests/test_blocks_searchable_text.py b/src/plone/restapi/tests/test_blocks_searchable_text.py\nindex 414679d5e..9867a371c 100644\n--- a/src/plone/restapi/tests/test_blocks_searchable_text.py\n+++ b/src/plone/restapi/tests/test_blocks_searchable_text.py\n@@ -50,6 +50,7 @@ def test_search_text(self):\n         response = self.api_session.patch(\n             "/doc",\n             json={\n+                "blocks_layout": {"items": ["uuid1", "uuid2"]},\n                 "blocks": {\n                     "uuid1": {\n                         "@type": "text",\n@@ -85,7 +86,7 @@ def test_search_text(self):\n                             "entityMap": {},\n                         },\n                     },\n-                }\n+                },\n             },\n         )\n \n@@ -147,6 +148,7 @@ def __call__(self, value):\n         }\n \n         self.doc.blocks = blocks\n+        self.doc.blocks_layout = {"items": ["uuid1", "uuid3"]}\n         from plone.indexer.interfaces import IIndexableObject\n         from zope.component import queryMultiAdapter\n \n@@ -160,6 +162,7 @@ def test_index_searchableText_value(self):\n         response = self.api_session.patch(\n             "/doc",\n             json={\n+                "blocks_layout": {"items": ["uuid1", "uuid2"]},\n                 "blocks": {\n                     "uuid1": {\n                         "@type": "text",\n@@ -182,7 +185,7 @@ def test_index_searchableText_value(self):\n                         "@type": "custom_type",\n                         "searchableText": "custom text foo",\n                     },\n-                }\n+                },\n             },\n         )\n \n@@ -231,10 +234,12 @@ def test_search_slate_text(self):\n                 "value": [],\n             },\n         }\n-        self.doc.blocks_layout = [\n-            "38541872-06c2-41c9-8709-37107e597b18",\n-            "4fcfeb9b-f73e-427c-9e06-2e4d53b06865",\n-        ]\n+        self.doc.blocks_layout = {\n+            "items": [\n+                "38541872-06c2-41c9-8709-37107e597b18",\n+                "4fcfeb9b-f73e-427c-9e06-2e4d53b06865",\n+            ]\n+        }\n         self.portal.portal_catalog.indexObject(self.doc)\n \n         query = {"SearchableText": "climatic"}\n@@ -342,9 +347,7 @@ def test_search_table_text(self):\n                 },\n             }\n         }\n-        self.doc.blocks_layout = [\n-            "uuid1",\n-        ]\n+        self.doc.blocks_layout = {"items": ["uuid1"]}\n         self.portal.portal_catalog.indexObject(self.doc)\n \n         query = {"SearchableText": "foo"}\ndiff --git a/src/plone/restapi/tests/test_indexers.py b/src/plone/restapi/tests/test_indexers.py\nnew file mode 100644\nindex 000000000..0e227a4c9\n--- /dev/null\n+++ b/src/plone/restapi/tests/test_indexers.py\n@@ -0,0 +1,215 @@\n+from plone.dexterity.interfaces import IDexterityFTI\n+from plone.restapi.indexers import SearchableText_blocks\n+from plone.restapi.testing import PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+from uuid import uuid4\n+from zope.component import queryUtility\n+\n+import unittest\n+\n+\n+DRAFTJS_BLOCK = {\n+    "@type": "text",\n+    "text": {\n+        "blocks": [\n+            {\n+                "data": {},\n+                "depth": 0,\n+                "entityRanges": [],\n+                "inlineStyleRanges": [],\n+                "key": "behki",\n+                "text": "Plone is a powerful content management system",\n+                "type": "unstyled",\n+            }\n+        ],\n+        "entityMap": {},\n+    },\n+}\n+\n+SLATE_BLOCK = {\n+    "@type": "slate",\n+    "plaintext": "Follow Plone Conference",\n+    "value": [{"children": [{"text": "Follow Plone Conference"}]}],\n+}\n+\n+\n+TABLE_BLOCK = {\n+    "@type": "table",\n+    "table": {\n+        "rows": [\n+            {\n+                "key": "a",\n+                "cells": [\n+                    {\n+                        "type": "data",\n+                        "key": "b",\n+                        "value": {\n+                            "blocks": [\n+                                {\n+                                    "data": {},\n+                                    "depth": 0,\n+                                    "entityRanges": [],\n+                                    "inlineStyleRanges": [],\n+                                    "key": "fgm98",\n+                                    "text": "My header",\n+                                    "type": "header-two",\n+                                },\n+                            ],\n+                            "entityMap": {},\n+                        },\n+                    },\n+                ],\n+            },\n+            {\n+                "key": "c",\n+                "cells": [\n+                    {\n+                        "type": "data",\n+                        "key": "d",\n+                        "value": {\n+                            "blocks": [\n+                                {\n+                                    "data": {},\n+                                    "depth": 0,\n+                                    "entityRanges": [],\n+                                    "inlineStyleRanges": [],\n+                                    "key": "mmm99",\n+                                    "text": "My data",\n+                                    "type": "text",\n+                                },\n+                            ],\n+                            "entityMap": {},\n+                        },\n+                    },\n+                ],\n+            },\n+        ]\n+    },\n+}\n+\n+\n+class TestSearchableTextIndexer(unittest.TestCase):\n+\n+    layer = PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        fti = queryUtility(IDexterityFTI, name="Document")\n+        behavior_list = [a for a in fti.behaviors]\n+        behavior_list.append("volto.blocks")\n+        fti.behaviors = tuple(behavior_list)\n+        self.portal.invokeFactory(\n+            "Document",\n+            id="doc1",\n+            title="Title is here",\n+            description="Description is there",\n+            blocks={},\n+            blocks_layout={"items": []},\n+        )\n+        self.document = self.portal["doc1"]\n+\n+    @staticmethod\n+    def _extract_searchable_text(obj):\n+        indexer = SearchableText_blocks(obj)\n+        return indexer()\n+\n+    @staticmethod\n+    def _add_blocks(obj, raw_blocks):\n+        blocks = {str(uuid4()): block for block in raw_blocks}\n+        layout = list(blocks.keys())\n+        obj.blocks = blocks\n+        obj.blocks_layout["items"] = layout\n+\n+    def test_indexer_no_blocks(self):\n+        result = self._extract_searchable_text(self.document)\n+        self.assertIn("Title is here", result)\n+        self.assertIn("Description is there", result)\n+\n+    def test_indexer_block_has_searchableText(self):\n+        document = self.document\n+        self._add_blocks(\n+            document,\n+            [{"@type": "new-block", "attribute": "bar", "searchableText": "Foo Bar"}],\n+        )\n+        result = self._extract_searchable_text(document)\n+        self.assertIn("Title is here Description is there", result)\n+        self.assertIn("Foo Bar", result)\n+\n+    def test_indexer_multiple_blocks(self):\n+        document = self.document\n+        self._add_blocks(\n+            document,\n+            [\n+                {"@type": "a-block", "key": "value", "searchableText": "Plone is a"},\n+                {"@type": "a-block", "attribute": "bar", "searchableText": "CMS"},\n+            ],\n+        )\n+        result = self._extract_searchable_text(document)\n+        self.assertIn("Plone is a CMS ", result)\n+\n+    def test_indexer_block_slate_bbb(self):\n+        document = self.document\n+        self._add_blocks(\n+            document,\n+            [\n+                SLATE_BLOCK,\n+            ],\n+        )\n+        result = self._extract_searchable_text(document)\n+        self.assertIn("Title is here Description is there", result)\n+        self.assertIn("Follow Plone Conference", result)\n+\n+    def test_indexer_block_text(self):\n+        document = self.document\n+        self._add_blocks(\n+            document,\n+            [\n+                DRAFTJS_BLOCK,\n+            ],\n+        )\n+        result = self._extract_searchable_text(document)\n+        self.assertIn("Title is here Description is there", result)\n+        self.assertIn("Plone is a powerful content management system", result)\n+\n+    def test_indexer_block_table(self):\n+        document = self.document\n+        self._add_blocks(\n+            document,\n+            [\n+                TABLE_BLOCK,\n+            ],\n+        )\n+        result = self._extract_searchable_text(document)\n+        self.assertIn("Title is here Description is there", result)\n+        self.assertIn("My data", result)\n+\n+    def test_indexer_block_with_subblocks(self):\n+        document = self.document\n+        block = {\n+            "@type": "complex-block",\n+            "blocks": {\n+                "ad625c27-670a-412e-821d-57870b6e82f1": SLATE_BLOCK,\n+                "80c5d58d-4baf-4adc-8ef4-36810df5628d": DRAFTJS_BLOCK,\n+                "4061b21d-c971-4ccc-a719-d8b24214fd8b": {\n+                    "@type": "old-complex-block",\n+                    "data": {\n+                        "blocks": {\n+                            "116feae0-7aa3-40f4-a776-fc893d78b353": TABLE_BLOCK,\n+                        }\n+                    },\n+                },\n+            },\n+        }\n+        self._add_blocks(\n+            document,\n+            [\n+                block,\n+            ],\n+        )\n+        result = self._extract_searchable_text(document)\n+        # From Slate sub block\n+        self.assertIn("Follow Plone Conference", result)\n+        # From DraftJS\n+        self.assertIn("Plone is a powerful content management system", result)\n+        # From Table block\n+        self.assertIn("My data", result)\n'

