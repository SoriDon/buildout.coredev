Repository: plone.schemaeditor


Branch: refs/heads/master
Date: 2023-01-27T09:45:17+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.schemaeditor/commit/ded0c3dddf115da6ac0f8be496b4ee4ee41cec95

Configuring with plone/meta

Files changed:
A .editorconfig
A .github/workflows/linting.yml
A .meta.toml
A lint-requirements.txt
A tox.ini
M pyproject.toml
M setup.cfg

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.github/workflows/linting.yml b/.github/workflows/linting.yml\nnew file mode 100644\nindex 0000000..a2139a8\n--- /dev/null\n+++ b/.github/workflows/linting.yml\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+name: Linting\n+on:\n+  push:\n+    branches: [master]\n+  pull_request:\n+    branches: [master]\n+  workflow_dispatch:\n+\n+jobs:\n+  test:\n+    name: Lint code\n+    runs-on: ${{ matrix.os }}\n+    strategy:\n+      matrix:\n+        python-version: ["3.8"]\n+        os: ["ubuntu-22.04"]\n+    steps:\n+      - uses: actions/checkout@v3\n+      - name: Set up Python\n+        uses: actions/setup-python@v4\n+        with:\n+          python-version: ${{ matrix.python-version }}\n+      - name: Cache packages\n+        uses: actions/cache@v3\n+        with:\n+          path: ~/.cache/pip\n+          key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles(\'lint-requirements.txt\', \'tox.ini\') }}\n+          restore-keys: |\n+            ${{ runner.os }}-pip-${{ matrix.python-version }}-\n+            ${{ runner.os }}-pip-\n+      - name: Install dependencies\n+        run: python -m pip install tox\n+      - name: Run formatters\n+        run: tox -e format\n+      # linters\n+      - name: QA\n+        run: tox -e lint\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..500dbfe\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "c0d7e43c"\ndiff --git a/lint-requirements.txt b/lint-requirements.txt\nnew file mode 100644\nindex 0000000..129db4d\n--- /dev/null\n+++ b/lint-requirements.txt\n@@ -0,0 +1,8 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+black==22.12.0\n+check-manifest==0.49\n+codespell==2.2.2\n+flake8==6.0.0\n+isort==5.11.4\n+pyupgrade==3.3.1\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..0f96c85 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,24 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "internal"\n+name = "Internal:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "documentation"\n+name = "Documentation:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "tests"\n+name = "Tests"\n+showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\ndiff --git a/setup.cfg b/setup.cfg\nindex 526aeb2..8849fbc 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,2 +1,23 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [bdist_wheel]\n universal = 0\n+\n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n+\n+[check-manifest]\n+ignore =\n+    .editorconfig\n+    .meta.toml\n+    tox.ini\n+    lint-requirements.txt\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..5d1a605\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[tox]\n+envlist =\n+    format\n+    lint\n+\n+[testenv]\n+py_files = git ls-files "*.py"\n+text_files = git ls-files "*.rst" "*.md"\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat python code\n+skip_install = true\n+deps =\n+    pyupgrade\n+    isort\n+    black\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'{[testenv]py_files} | xargs pyupgrade --py38-plus\'\n+    sh -c \'{[testenv]py_files} | xargs isort\'\n+    sh -c \'{[testenv]py_files} | xargs black\'\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    flake8\n+    codespell\n+    check-manifest\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'{[testenv]py_files} | xargs flake8\'\n+    sh -c \'{[testenv]py_files} | xargs codespell\'\n+    sh -c \'{[testenv]text_files} | xargs codespell\'\n+    check-manifest\n'

Repository: plone.schemaeditor


Branch: refs/heads/master
Date: 2023-01-27T09:45:17+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.schemaeditor/commit/25ea2a6e53df85eb5272016fbf9866711a5e6ea2

chore: tox -e format (black/isort/pyupgrade)

Files changed:
M plone/__init__.py
M plone/schemaeditor/__init__.py
M plone/schemaeditor/browser/__init__.py
M plone/schemaeditor/browser/field/edit.py
M plone/schemaeditor/browser/field/fieldset.py
M plone/schemaeditor/browser/field/order.py
M plone/schemaeditor/browser/field/traversal.py
M plone/schemaeditor/browser/schema/__init__.py
M plone/schemaeditor/browser/schema/add_field.py
M plone/schemaeditor/browser/schema/add_fieldset.py
M plone/schemaeditor/browser/schema/delete_fieldset.py
M plone/schemaeditor/browser/schema/listing.py
M plone/schemaeditor/browser/schema/traversal.py
M plone/schemaeditor/fields.py
M plone/schemaeditor/interfaces.py
M plone/schemaeditor/schema.py
M plone/schemaeditor/testing.py
M plone/schemaeditor/tests/fixtures.py
M plone/schemaeditor/tests/test_fields.py
M plone/schemaeditor/tests/test_robot.py
M plone/schemaeditor/tests/tests.py
M plone/schemaeditor/utils.py
M plone/schemaeditor/vocabularies.py
M setup.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex 85880ef..05f0beb 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,7 +1,7 @@\n-# -*- coding: utf-8 -*-\n # See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n try:\n-    __import__(\'pkg_resources\').declare_namespace(__name__)\n+    __import__("pkg_resources").declare_namespace(__name__)\n except ImportError:\n     from pkgutil import extend_path\n+\n     __path__ = extend_path(__path__, __name__)\ndiff --git a/plone/schemaeditor/__init__.py b/plone/schemaeditor/__init__.py\nindex 1936adc..8efe8b3 100644\n--- a/plone/schemaeditor/__init__.py\n+++ b/plone/schemaeditor/__init__.py\n@@ -1,5 +1,4 @@\n-# -*- coding: utf-8 -*-\n from zope.i18nmessageid import MessageFactory\n \n \n-_ = MessageFactory(\'plone\')\n+_ = MessageFactory("plone")\ndiff --git a/plone/schemaeditor/browser/__init__.py b/plone/schemaeditor/browser/__init__.py\nindex ec51c5a..792d600 100644\n--- a/plone/schemaeditor/browser/__init__.py\n+++ b/plone/schemaeditor/browser/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n #\ndiff --git a/plone/schemaeditor/browser/field/edit.py b/plone/schemaeditor/browser/field/edit.py\nindex 4760ff8..ccf9179 100644\n--- a/plone/schemaeditor/browser/field/edit.py\n+++ b/plone/schemaeditor/browser/field/edit.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from plone.autoform.form import AutoExtensibleForm\n from plone.schemaeditor import _\n@@ -26,7 +25,6 @@\n from zope.schema.interfaces import IField\n from zope.security.interfaces import ForbiddenAttribute\n \n-\n import six\n \n \n@@ -35,17 +33,16 @@\n \n class IFieldTitle(Interface):\n     title = schema.TextLine(\n-        title=schema.interfaces.ITextLine[\'title\'].title,\n-        description=schema.interfaces.ITextLine[\'title\'].description,\n-        default=u\'\',\n+        title=schema.interfaces.ITextLine["title"].title,\n+        description=schema.interfaces.ITextLine["title"].description,\n+        default="",\n         required=True,\n     )\n \n \n @implementer(IFieldTitle)\n @adapter(IField)\n-class FieldTitleAdapter(object):\n-\n+class FieldTitleAdapter:\n     def __init__(self, field):\n         self.field = field\n \n@@ -54,6 +51,7 @@ def _read_title(self):\n \n     def _write_title(self, value):\n         self.field.title = value\n+\n     title = property(_read_title, _write_title)\n \n \n@@ -62,7 +60,6 @@ class IFieldProxy(Interface):\n \n \n class FieldProxySpecification(ObjectSpecificationDescriptor):\n-\n     def __get__(self, inst, cls=None):\n         if inst is None:\n             return getObjectSpecification(cls)\n@@ -71,42 +68,44 @@ def __get__(self, inst, cls=None):\n \n \n @implementer(IFieldProxy)\n-class FieldProxy(object):\n+class FieldProxy:\n \n     __providedBy__ = FieldProxySpecification()\n \n     def __init__(self, context):\n-        self.__class__ = type(context.__class__.__name__,\n-                              (self.__class__, context.__class__), {})\n+        self.__class__ = type(\n+            context.__class__.__name__, (self.__class__, context.__class__), {}\n+        )\n         self.__dict__ = context.__dict__\n \n \n @implementer(IDataManager)\n @adapter(IFieldProxy, IField)\n class FieldDataManager(AttributeField):\n-\n     def get(self):\n-        value = super(FieldDataManager, self).get()\n+        value = super().get()\n         if isinstance(value, Message) and value.default:\n             return value.default\n         return value\n \n     def set(self, value):\n         try:\n-            old_value = super(FieldDataManager, self).get()\n+            old_value = super().get()\n         except (AttributeError, ForbiddenAttribute):\n             old_value = None\n         if isinstance(old_value, Message):\n-            value = Message(six.text_type(old_value),\n-                            domain=old_value.domain,\n-                            default=value,\n-                            mapping=old_value.mapping)\n-        super(FieldDataManager, self).set(value)\n+            value = Message(\n+                str(old_value),\n+                domain=old_value.domain,\n+                default=value,\n+                mapping=old_value.mapping,\n+            )\n+        super().set(value)\n \n \n @implementer(IFieldEditForm)\n class FieldEditForm(AutoExtensibleForm, form.EditForm):\n-    id = \'edit-field-form\'\n+    id = "edit-field-form"\n \n     def __init__(self, context, request):\n         super(form.EditForm, self).__init__(context, request)\n@@ -126,13 +125,18 @@ def _schema(self):\n     @lazy_property\n     def additionalSchemata(self):\n         schema_context = self.context.__parent__\n-        return [v for k, v in getAdapters((schema_context, self.field),\n-                                          interfaces.IFieldEditorExtender)]\n+        return [\n+            v\n+            for k, v in getAdapters(\n+                (schema_context, self.field), interfaces.IFieldEditorExtender\n+            )\n+        ]\n \n     @lazy_property\n     def label(self):\n-        return _(u"Edit Field \'${fieldname}\'",\n-                 mapping={\'fieldname\': self.field.__name__})\n+        return _(\n+            "Edit Field \'${fieldname}\'", mapping={"fieldname": self.field.__name__}\n+        )\n \n     def updateFields(self):\n         # use a custom \'title\' field to make sure it is required\n@@ -140,7 +144,8 @@ def updateFields(self):\n \n         # omit the order attribute since it\'s managed elsewhere\n         fields += field.Fields(self._schema).omit(\n-            \'order\', \'title\', \'default\', \'missing_value\', \'readonly\')\n+            "order", "title", "default", "missing_value", "readonly"\n+        )\n         self.fields = fields\n \n         if "required" in self.fields:\n@@ -150,7 +155,7 @@ def updateFields(self):\n \n         self.updateFieldsFromSchemata()\n \n-    @button.buttonAndHandler(_(u\'Save\'), name=\'save\')\n+    @button.buttonAndHandler(_("Save"), name="save")\n     def handleSave(self, action):\n         data, errors = self.extractData()\n         if errors:\n@@ -158,36 +163,35 @@ def handleSave(self, action):\n             return\n \n         # clear current min/max to avoid range errors\n-        if \'min\' in data:\n+        if "min" in data:\n             self.field.min = None\n-        if \'max\' in data:\n+        if "max" in data:\n             self.field.max = None\n \n         changes = self.applyChanges(data)\n \n         if changes:\n             IStatusMessage(self.request).addStatusMessage(\n-                self.successMessage, type=\'info\')\n+                self.successMessage, type="info"\n+            )\n         else:\n             IStatusMessage(self.request).addStatusMessage(\n-                self.noChangesMessage, type=\'info\')\n+                self.noChangesMessage, type="info"\n+            )\n \n         notify(SchemaModifiedEvent(self.context.__parent__))\n \n-    @button.buttonAndHandler(_(u\'Cancel\'), name=\'cancel\')\n+    @button.buttonAndHandler(_("Cancel"), name="cancel")\n     def handleCancel(self, action):\n         self.redirectToParent()\n \n     def redirectToParent(self):\n         parent = aq_inner(self.context).__parent__\n         url = parent.absolute_url()\n-        if hasattr(parent, \'schemaEditorView\') and parent.schemaEditorView:\n-            url += \'/@@\' + parent.schemaEditorView\n+        if hasattr(parent, "schemaEditorView") and parent.schemaEditorView:\n+            url += "/@@" + parent.schemaEditorView\n \n         self.request.response.redirect(url)\n \n \n-EditView = wrap_form(\n-    FieldEditForm,\n-    index=ViewPageTemplateFile(\'edit.pt\')\n-)\n+EditView = wrap_form(FieldEditForm, index=ViewPageTemplateFile("edit.pt"))\ndiff --git a/plone/schemaeditor/browser/field/fieldset.py b/plone/schemaeditor/browser/field/fieldset.py\nindex 8389f88..2150b8c 100644\n--- a/plone/schemaeditor/browser/field/fieldset.py\n+++ b/plone/schemaeditor/browser/field/fieldset.py\n@@ -1,7 +1,6 @@\n-# -*- coding: utf-8 -*-\n from plone.schemaeditor.interfaces import IEditableSchema\n-from plone.schemaeditor.utils import new_field_position\n from plone.schemaeditor.utils import get_fieldset_from_index\n+from plone.schemaeditor.utils import new_field_position\n from plone.schemaeditor.utils import SchemaModifiedEvent\n from Products.Five import BrowserView\n from zope.container.contained import notifyContainerModified\n@@ -9,10 +8,8 @@\n \n \n class ChangeFieldsetView(BrowserView):\n-\n     def change(self, fieldset_index):\n-        """ AJAX method to change the fieldset of a field\n-        """\n+        """AJAX method to change the fieldset of a field"""\n         schema = self.context.field.interface\n         field_name = self.context.field.__name__\n         fieldset = get_fieldset_from_index(schema, fieldset_index)\ndiff --git a/plone/schemaeditor/browser/field/order.py b/plone/schemaeditor/browser/field/order.py\nindex e42bb80..babd924 100644\n--- a/plone/schemaeditor/browser/field/order.py\n+++ b/plone/schemaeditor/browser/field/order.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.schemaeditor.interfaces import IEditableSchema\n from plone.schemaeditor.utils import FieldRemovedEvent\n from plone.schemaeditor.utils import SchemaModifiedEvent\n@@ -11,7 +10,6 @@\n \n \n class FieldOrderView(BrowserView):\n-\n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n@@ -19,7 +17,7 @@ def __init__(self, context, request):\n         self.schema = context.field.interface\n \n     def move(self, pos, fieldset_index):\n-        """ AJAX method to change field position within its schema.\n+        """AJAX method to change field position within its schema.\n         The position is relative to the fieldset.\n         """\n         schema = IEditableSchema(self.schema)\n@@ -29,15 +27,13 @@ def move(self, pos, fieldset_index):\n         fieldset_index -= 1  # index 0 is default fieldset\n \n         fieldsets = self.schema.queryTaggedValue(FIELDSETS_KEY, [])\n-        new_fieldset = fieldset_index >= 0 and fieldsets[\n-            fieldset_index] or None\n+        new_fieldset = fieldset_index >= 0 and fieldsets[fieldset_index] or None\n         schema.changeFieldFieldset(fieldname, new_fieldset)\n \n         ordered_field_ids = [info[0] for info in sortedFields(self.schema)]\n         if new_fieldset:\n             old_field_of_position = new_fieldset.fields[pos]\n-            new_absolute_position = ordered_field_ids.index(\n-                old_field_of_position)\n+            new_absolute_position = ordered_field_ids.index(old_field_of_position)\n         else:\n             new_absolute_position = pos\n \n@@ -55,4 +51,4 @@ def delete(self):\n         schema.removeField(self.field.getName())\n         notify(ObjectRemovedEvent(self.field, self.schema))\n         notify(FieldRemovedEvent(self.__parent__.__parent__, self.field))\n-        self.request.response.setHeader(\'Content-Type\', \'application/json\')\n+        self.request.response.setHeader("Content-Type", "application/json")\ndiff --git a/plone/schemaeditor/browser/field/traversal.py b/plone/schemaeditor/browser/field/traversal.py\nindex da444f9..853e1d6 100644\n--- a/plone/schemaeditor/browser/field/traversal.py\n+++ b/plone/schemaeditor/browser/field/traversal.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from OFS.SimpleItem import SimpleItem\n from plone.schemaeditor.browser.field.edit import EditView\n from plone.schemaeditor.interfaces import IFieldContext\n@@ -10,11 +9,10 @@\n @implementer(IFieldContext, IBrowserPublisher)\n class FieldContext(SimpleItem):\n \n-    """ wrapper for published zope 3 schema fields\n-    """\n+    """wrapper for published zope 3 schema fields"""\n \n     def __init__(self, context, request):\n-        super(FieldContext, self).__init__()\n+        super().__init__()\n         self.field = context\n         self.request = request\n \n@@ -23,8 +21,7 @@ def __init__(self, context, request):\n         self.__name__ = self.field.__name__\n \n     def publishTraverse(self, request, name):\n-        """ It\'s not valid to traverse to anything below a field context.\n-        """\n+        """It\'s not valid to traverse to anything below a field context."""\n         # hack to make inline validation work\n         # (plone.app.z3cform doesn\'t know the form is the default view)\n         if name == self.__name__:\n@@ -36,6 +33,5 @@ def publishTraverse(self, request, name):\n         )\n \n     def browserDefault(self, request):\n-        """ Really we want to show the field EditView.\n-        """\n-        return self, (\'@@edit\',)\n+        """Really we want to show the field EditView."""\n+        return self, ("@@edit",)\ndiff --git a/plone/schemaeditor/browser/schema/__init__.py b/plone/schemaeditor/browser/schema/__init__.py\nindex ec51c5a..792d600 100644\n--- a/plone/schemaeditor/browser/schema/__init__.py\n+++ b/plone/schemaeditor/browser/schema/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n #\ndiff --git a/plone/schemaeditor/browser/schema/add_field.py b/plone/schemaeditor/browser/schema/add_field.py\nindex 6735f59..8f1629d 100644\n--- a/plone/schemaeditor/browser/schema/add_field.py\n+++ b/plone/schemaeditor/browser/schema/add_field.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.form import AutoExtensibleForm\n from plone.schemaeditor import _\n from plone.schemaeditor import interfaces\n@@ -25,8 +24,8 @@\n class FieldAddForm(AutoExtensibleForm, form.AddForm):\n \n     fields = field.Fields(interfaces.INewField)\n-    label = _(\'Add new field\')\n-    id = \'add-field-form\'\n+    label = _("Add new field")\n+    id = "add-field-form"\n \n     # This is a trick: we want autoform to handle the additionalSchemata,\n     # but want to provide our own base schema below in updateFields.\n@@ -38,16 +37,17 @@ def _schema(self):\n \n     @lazy_property\n     def additionalSchemata(self):\n-        return [v for k, v in getAdapters((self.context, ),\n-                                          interfaces.IFieldEditorExtender)]\n+        return [\n+            v for k, v in getAdapters((self.context,), interfaces.IFieldEditorExtender)\n+        ]\n \n     def create(self, data):\n         extra = {}\n-        factory = data.pop(\'factory\')\n+        factory = data.pop("factory")\n \n         # remove fieldset_id from data\n-        if \'fieldset_id\' in data:\n-            fieldset_id = data.pop(\'fieldset_id\')\n+        if "fieldset_id" in data:\n+            fieldset_id = data.pop("fieldset_id")\n \n         # split regular attributes and extra ones\n         for key in list(data.keys()):\n@@ -61,7 +61,7 @@ def create(self, data):\n         # set the extra attributes using the proper adapter\n         for schemata in self.additionalSchemata:\n             for key in extra:\n-                (interface_name, property_name) = key.split(\'.\')\n+                (interface_name, property_name) = key.split(".")\n                 if interface_name != schemata.__name__:\n                     continue\n                 setattr(schemata(field_obj), property_name, extra[key])\n@@ -70,10 +70,10 @@ def create(self, data):\n \n     def add(self, new_field):\n         schema = self.context.schema\n-        fieldset_id = int(self.request.form.get(\'fieldset_id\', 0))\n+        fieldset_id = int(self.request.form.get("fieldset_id", 0))\n \n         if self.widgets:\n-            fieldset_widget = self.widgets.get(\'fieldset_id\')\n+            fieldset_widget = self.widgets.get("fieldset_id")\n             if fieldset_widget:\n                 fieldset_id = int(fieldset_widget.extract())\n             position = new_field_position(schema, fieldset_id, new_field=True)\n@@ -85,10 +85,8 @@ def add(self, new_field):\n             editable_schema.addField(new_field)\n         except ValueError:\n             raise WidgetActionExecutionError(\n-                \'__name__\',\n-                Invalid(\n-                    u\'Please select a field name that is not already used.\'\n-                )\n+                "__name__",\n+                Invalid("Please select a field name that is not already used."),\n             )\n         if fieldset_id:\n             fieldset = get_fieldset_from_index(schema, fieldset_id)\n@@ -98,22 +96,20 @@ def add(self, new_field):\n         notify(ObjectAddedEvent(new_field, schema))\n         notify(FieldAddedEvent(self.context, new_field))\n         IStatusMessage(self.request).addStatusMessage(\n-            _(u\'Field added successfully.\'), type=\'info\')\n+            _("Field added successfully."), type="info"\n+        )\n \n     def updateWidgets(self):\n-        super(FieldAddForm, self).updateWidgets()\n-        fieldset_id_widget = self.widgets.get(\'fieldset_id\')\n+        super().updateWidgets()\n+        fieldset_id_widget = self.widgets.get("fieldset_id")\n         if fieldset_id_widget:\n             if not fieldset_id_widget.value or fieldset_id_widget.value == NO_VALUE:\n-                fieldset_id = int(self.request.form.get(\'fieldset_id\', 0))\n+                fieldset_id = int(self.request.form.get("fieldset_id", 0))\n                 fieldset_id_widget.value = fieldset_id\n             fieldset_id_widget.mode = HIDDEN_MODE\n \n     def nextURL(self):\n-        return \'@@add-field\'\n+        return "@@add-field"\n \n \n-FieldAddFormPage = wrap_form(\n-    FieldAddForm,\n-    index=ViewPageTemplateFile(\'add.pt\')\n-)\n+FieldAddFormPage = wrap_form(FieldAddForm, index=ViewPageTemplateFile("add.pt"))\ndiff --git a/plone/schemaeditor/browser/schema/add_fieldset.py b/plone/schemaeditor/browser/schema/add_fieldset.py\nindex a7dc1b4..3d4d81b 100644\n--- a/plone/schemaeditor/browser/schema/add_fieldset.py\n+++ b/plone/schemaeditor/browser/schema/add_fieldset.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.schemaeditor import _\n from plone.schemaeditor.interfaces import INewFieldset\n from plone.schemaeditor.utils import SchemaModifiedEvent\n@@ -19,8 +18,8 @@\n class FieldsetAddForm(form.AddForm):\n \n     fields = field.Fields(INewFieldset)\n-    label = _(\'Add new fieldset\')\n-    id = \'add-fieldset-form\'\n+    label = _("Add new fieldset")\n+    id = "add-fieldset-form"\n \n     def create(self, data):\n         return Fieldset(**data)\n@@ -34,28 +33,21 @@ def add(self, new_fieldset):\n             for elem in mergedTaggedValueList(additional_schema, FIELDSETS_KEY):\n                 extra_fieldsets.append(elem)\n \n-        for fieldset in (fieldsets + extra_fieldsets):\n+        for fieldset in fieldsets + extra_fieldsets:\n             if fieldset.__name__ == new_fieldset.__name__:\n-                msg = _(\n-                    u\'Please select a fieldset name that is not already used.\'\n-                )\n-                raise WidgetActionExecutionError(\n-                    \'__name__\',\n-                    Invalid(msg)\n-                )\n+                msg = _("Please select a fieldset name that is not already used.")\n+                raise WidgetActionExecutionError("__name__", Invalid(msg))\n \n         fieldsets.append(new_fieldset)\n         schema.setTaggedValue(FIELDSETS_KEY, fieldsets)\n         notifyContainerModified(schema)\n         notify(SchemaModifiedEvent(self.context))\n         IStatusMessage(self.request).addStatusMessage(\n-            _(u\'Fieldset added successfully.\'), type=\'info\')\n+            _("Fieldset added successfully."), type="info"\n+        )\n \n     def nextURL(self):\n-        return \'@@add-fieldset\'\n+        return "@@add-fieldset"\n \n \n-FieldsetAddFormPage = wrap_form(\n-    FieldsetAddForm,\n-    index=ViewPageTemplateFile(\'add.pt\')\n-)\n+FieldsetAddFormPage = wrap_form(FieldsetAddForm, index=ViewPageTemplateFile("add.pt"))\ndiff --git a/plone/schemaeditor/browser/schema/delete_fieldset.py b/plone/schemaeditor/browser/schema/delete_fieldset.py\nindex 6f50cb9..0a4697c 100644\n--- a/plone/schemaeditor/browser/schema/delete_fieldset.py\n+++ b/plone/schemaeditor/browser/schema/delete_fieldset.py\n@@ -8,9 +8,8 @@\n \n \n class DeleteFieldset(BrowserView):\n-\n     def __call__(self):\n-        fieldset_name = self.request.form.get(\'name\')\n+        fieldset_name = self.request.form.get("name")\n         schema = self.context.schema\n         fieldsets = schema.queryTaggedValue(FIELDSETS_KEY, [])\n \n@@ -19,15 +18,16 @@ def __call__(self):\n             if fieldset.__name__ == fieldset_name:\n                 if fieldset.fields:\n                     IStatusMessage(self.request).addStatusMessage(\n-                        _(u\'Only empty fieldsets can be deleted\'),\n-                        type=\'error\')\n+                        _("Only empty fieldsets can be deleted"), type="error"\n+                    )\n                     return self.request.RESPONSE.redirect(self.nextURL)\n                 continue\n             else:\n                 new_fieldsets.append(fieldset)\n         if len(fieldsets) == len(new_fieldsets):\n             IStatusMessage(self.request).addStatusMessage(\n-                _(u\'Fieldset not found\'), type=\'error\')\n+                _("Fieldset not found"), type="error"\n+            )\n             return self.request.RESPONSE.redirect(self.nextURL)\n \n         schema.setTaggedValue(FIELDSETS_KEY, new_fieldsets)\n@@ -35,9 +35,10 @@ def __call__(self):\n         notifyContainerModified(schema)\n         notify(SchemaModifiedEvent(self.context))\n         IStatusMessage(self.request).addStatusMessage(\n-            _(u\'Fieldset deleted successfully.\'), type=\'info\')\n+            _("Fieldset deleted successfully."), type="info"\n+        )\n         return self.request.RESPONSE.redirect(self.nextURL)\n \n     @property\n     def nextURL(self):\n-        return self.request.get(\'HTTP_REFERER\')\n+        return self.request.get("HTTP_REFERER")\ndiff --git a/plone/schemaeditor/browser/schema/listing.py b/plone/schemaeditor/browser/schema/listing.py\nindex 89b8686..c620403 100644\n--- a/plone/schemaeditor/browser/schema/listing.py\n+++ b/plone/schemaeditor/browser/schema/listing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.form import AutoExtensibleForm\n from plone.memoize.instance import memoize\n from plone.schemaeditor import _\n@@ -28,7 +27,7 @@ class SchemaListing(AutoExtensibleForm, form.Form):\n     ignoreContext = True\n     ignoreRequest = True\n     showEmptyGroups = True\n-    template = ViewPageTemplateFile(\'schema_listing.pt\')\n+    template = ViewPageTemplateFile("schema_listing.pt")\n     ignoreRequiredOnExtract = True\n \n     @property\n@@ -40,28 +39,26 @@ def additionalSchemata(self):\n         return self.context.additionalSchemata\n \n     def _iterateOverWidgets(self):\n-        for widget in self.widgets.values():\n-            yield widget\n+        yield from self.widgets.values()\n         for group in self.groups:\n-            for widget in group.widgets.values():\n-                yield widget\n+            yield from group.widgets.values()\n \n     def render(self):\n         for widget in self._iterateOverWidgets():\n             # disable fields from behaviors\n             if widget.field.interface is not self.context.schema:\n-                widget.disabled = \'disabled\'\n+                widget.disabled = "disabled"\n \n             # limit size of the preview for text areas\n-            if hasattr(widget, \'rows\'):\n+            if hasattr(widget, "rows"):\n                 if widget.rows is None or widget.rows > 5:\n                     widget.rows = 5\n \n-        return super(SchemaListing, self).render()\n+        return super().render()\n \n     @memoize\n     def _field_factory(self, field):\n-        field_identifier = u\'{0}.{1}\'.format(\n+        field_identifier = "{}.{}".format(\n             field.__module__,\n             field.__class__.__name__,\n         )\n@@ -79,7 +76,7 @@ def field_type(self, field):\n             return field.__class__.__name__\n \n     def protected_field(self, field):\n-        field_identifier = u\'{0}.{1}\'.format(\n+        field_identifier = "{}.{}".format(\n             field.__module__,\n             field.__class__.__name__,\n         )\n@@ -89,7 +86,7 @@ def protected_field(self, field):\n     def edit_url(self, field):\n         field_factory = self._field_factory(field)\n         if field_factory is not None and field_factory.editable(field):\n-            return \'{0}/{1}\'.format(\n+            return "{}/{}".format(\n                 self.context.absolute_url(),\n                 field.__name__,\n             )\n@@ -107,7 +104,7 @@ def can_delete_fieldset(self, fieldset):\n     def delete_url(self, field):\n         if field.__name__ in self.context.fieldsWhichCannotBeDeleted:\n             return\n-        url = \'{0}/{1}/@@delete\'.format(\n+        url = "{}/{}/@@delete".format(\n             self.context.absolute_url(),\n             field.__name__,\n         )\n@@ -116,14 +113,14 @@ def delete_url(self, field):\n         return url\n \n     @button.buttonAndHandler(\n-        _(u\'Done\'),\n+        _("Done"),\n     )\n     def handleDone(self, action):\n         return self.request.RESPONSE.redirect(self.context.absolute_url())\n \n     @button.buttonAndHandler(\n-        _(u\'Save Defaults\'),\n-        condition=lambda form: getattr(form.context, \'showSaveDefaults\', True)\n+        _("Save Defaults"),\n+        condition=lambda form: getattr(form.context, "showSaveDefaults", True),\n     )\n     def handleSaveDefaults(self, action):\n         for group in self.groups:\n@@ -135,8 +132,7 @@ def handleSaveDefaults(self, action):\n \n         for widget in self._iterateOverWidgets():\n             widget_name = widget.field.getName()\n-            if (widget.field.interface is self.context.schema and\n-                    widget_name in data):\n+            if widget.field.interface is self.context.schema and widget_name in data:\n                 self.context.schema[widget_name].default = data[widget_name]\n         notify(SchemaModifiedEvent(self.context))\n \n@@ -155,33 +151,36 @@ class ReadOnlySchemaListing(SchemaListing):\n \n     def edit_url(self, field):\n         return\n+\n     delete_url = edit_url\n \n \n class SchemaListingPage(FormWrapper):\n \n-    """ Form wrapper so we can get a form with layout.\n+    """Form wrapper so we can get a form with layout.\n \n-        We define an explicit subclass rather than using the wrap_form method\n-        from plone.z3cform.layout so that we can inject the schema name into\n-        the form label.\n+    We define an explicit subclass rather than using the wrap_form method\n+    from plone.z3cform.layout so that we can inject the schema name into\n+    the form label.\n     """\n+\n     form = SchemaListing\n \n     @property\n     def label(self):\n-        """ In a dexterity schema editing context, we need to\n-            construct a label that will specify the field being\n-            edited. Outside that context (e.g., plone.app.users),\n-            we should respect the label if specified.\n+        """In a dexterity schema editing context, we need to\n+        construct a label that will specify the field being\n+        edited. Outside that context (e.g., plone.app.users),\n+        we should respect the label if specified.\n         """\n \n-        context_label = getattr(self.context, \'label\', None)\n+        context_label = getattr(self.context, "label", None)\n         if context_label is not None:\n             return context_label\n         if self.context.Title() != self.context.__name__:\n-            return _(u\'Edit ${title} (${name})\',\n-                     mapping={\'title\': self.context.Title(),\n-                              \'name\': self.context.__name__})\n+            return _(\n+                "Edit ${title} (${name})",\n+                mapping={"title": self.context.Title(), "name": self.context.__name__},\n+            )\n         else:\n-            return _(u\'Edit ${name}\', mapping={\'name\': self.context.__name__})\n+            return _("Edit ${name}", mapping={"name": self.context.__name__})\ndiff --git a/plone/schemaeditor/browser/schema/traversal.py b/plone/schemaeditor/browser/schema/traversal.py\nindex db9f2c7..921af0c 100644\n--- a/plone/schemaeditor/browser/schema/traversal.py\n+++ b/plone/schemaeditor/browser/schema/traversal.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from OFS.SimpleItem import SimpleItem\n from plone.schemaeditor.browser.field.traversal import FieldContext\n from plone.schemaeditor.interfaces import ISchemaContext\n@@ -10,8 +9,8 @@\n @implementer(ISchemaContext, IBrowserPublisher)\n class SchemaContext(SimpleItem):\n \n-    """ This is a transient item that allows us to traverse through (a wrapper\n-        of) a zope 3 schema to (a wrapper of) a zope 3 schema field.\n+    """This is a transient item that allows us to traverse through (a wrapper\n+    of) a zope 3 schema to (a wrapper of) a zope 3 schema field.\n     """\n \n     schemaEditorView = None\n@@ -20,7 +19,7 @@ class SchemaContext(SimpleItem):\n     fieldsWhichCannotBeDeleted = ()\n     enableFieldsets = True\n \n-    def __init__(self, context, request, name=u\'schema\', title=None):\n+    def __init__(self, context, request, name="schema", title=None):\n         self.schema = context\n         self.request = request\n \n@@ -32,19 +31,16 @@ def __init__(self, context, request, name=u\'schema\', title=None):\n         self.Title = lambda: title\n \n     def publishTraverse(self, request, name):\n-        """ Look up the field whose name matches the next URL path element,\n+        """Look up the field whose name matches the next URL path element,\n         and wrap it.\n         """\n         try:\n             return FieldContext(self.schema[name], self.request).__of__(self)\n         except KeyError:\n-            return DefaultPublishTraverse(self, request).publishTraverse(\n-                request,\n-                name\n-            )\n+            return DefaultPublishTraverse(self, request).publishTraverse(request, name)\n \n     def browserDefault(self, request):\n-        """ If not traversing through the schema to a field,\n+        """If not traversing through the schema to a field,\n         show the SchemaListingPage.\n         """\n-        return self, (\'@@edit\',)\n+        return self, ("@@edit",)\ndiff --git a/plone/schemaeditor/fields.py b/plone/schemaeditor/fields.py\nindex 4cb2f3a..a6c00f4 100644\n--- a/plone/schemaeditor/fields.py\n+++ b/plone/schemaeditor/fields.py\n@@ -1,7 +1,6 @@\n-# -*- coding: utf-8 -*-\n-from plone.schemaeditor import schema as se_schema\n from plone.schemaeditor import _\n from plone.schemaeditor import interfaces\n+from plone.schemaeditor import schema as se_schema\n from plone.schemaeditor.interfaces import IFieldFactory\n from z3c.form import validator\n from zope import component\n@@ -23,14 +22,15 @@\n @interface.implementer(interfaces.IFieldEditFormSchema)\n @component.adapter(schema_ifaces.IField)\n def getFirstFieldSchema(field):\n-    return [s for s in field.__provides__.__iro__ if\n-            s.isOrExtends(schema_ifaces.IField)][0]\n+    return [\n+        s for s in field.__provides__.__iro__ if s.isOrExtends(schema_ifaces.IField)\n+    ][0]\n \n \n @implementer(IFieldFactory)\n-class FieldFactory(object):\n+class FieldFactory:\n \n-    title = u\'\'\n+    title = ""\n \n     def __init__(self, fieldcls, title, *args, **kw):\n         self.fieldcls = fieldcls\n@@ -44,15 +44,15 @@ def __call__(self, *args, **kw):\n         return self.fieldcls(*(self.args + args), **kwargs)\n \n     def available(self):\n-        """ field is addable in the current context """\n+        """field is addable in the current context"""\n         return True\n \n     def editable(self, field):\n-        """ test whether a given instance of a field is editable """\n+        """test whether a given instance of a field is editable"""\n         return True\n \n     def protected(self, field):\n-        """ test whether a given instance of a field is protected """\n+        """test whether a given instance of a field is protected"""\n         return False\n \n \n@@ -61,41 +61,40 @@ def FieldsVocabularyFactory(context):\n     field_factories = getUtilitiesFor(IFieldFactory)\n     allowedFields = getattr(context, "allowedFields", None)\n     if allowedFields is not None:\n-        field_factories = [(id, factory) for id, factory in field_factories\n-                           if id in allowedFields]\n+        field_factories = [\n+            (id, factory) for id, factory in field_factories if id in allowedFields\n+        ]\n     terms = []\n     for (field_id, factory) in field_factories:\n         terms.append(\n             SimpleVocabulary.createTerm(\n-                factory,\n-                factory.title,\n-                translate(factory.title, context=request)\n+                factory, factory.title, translate(factory.title, context=request)\n             )\n         )\n-    terms = sorted(terms, key=operator.attrgetter(\'title\'))\n+    terms = sorted(terms, key=operator.attrgetter("title"))\n     return SimpleVocabulary(terms)\n \n \n # TextLineFactory is the default. We need to set that here to avoid a\n # circular import.\n TextLineFactory = FieldFactory(\n-    schema.TextLine, _(u\'label_textline_field\', default=u\'Text line (String)\'))\n-interfaces.INewField[\'factory\'].__dict__[\'default\'] = TextLineFactory\n+    schema.TextLine, _("label_textline_field", default="Text line (String)")\n+)\n+interfaces.INewField["factory"].__dict__["default"] = TextLineFactory\n \n-TextFactory = FieldFactory(\n-    schema.Text, _(u\'label_text_field\', default=u\'Text\'))\n-IntFactory = FieldFactory(\n-    schema.Int, _(u\'label_integer_field\', default=u\'Integer\'))\n+TextFactory = FieldFactory(schema.Text, _("label_text_field", default="Text"))\n+IntFactory = FieldFactory(schema.Int, _("label_integer_field", default="Integer"))\n FloatFactory = FieldFactory(\n-    schema.Float, _(u\'label_float_field\', default=u\'Floating-point number\'))\n-BoolFactory = FieldFactory(\n-    schema.Bool, _(u\'label_boolean_field\', default=u\'Yes/No\'))\n+    schema.Float, _("label_float_field", default="Floating-point number")\n+)\n+BoolFactory = FieldFactory(schema.Bool, _("label_boolean_field", default="Yes/No"))\n PasswordFactory = FieldFactory(\n-    schema.Password, _(u\'label_password_field\', default=u\'Password\'))\n+    schema.Password, _("label_password_field", default="Password")\n+)\n DatetimeFactory = FieldFactory(\n-    schema.Datetime, _(u\'label_datetime_field\', default=u\'Date/Time\'))\n-DateFactory = FieldFactory(\n-    schema.Date, _(u\'label_date_field\', default=u\'Date\'))\n+    schema.Datetime, _("label_datetime_field", default="Date/Time")\n+)\n+DateFactory = FieldFactory(schema.Date, _("label_date_field", default="Date"))\n \n \n @interface.implementer(interfaces.IFieldEditFormSchema)\n@@ -105,136 +104,141 @@ def getChoiceFieldSchema(field):\n \n \n ChoiceFactory = FieldFactory(\n-    schema.Choice, _(u\'label_choice_field\', default=u\'Choice\'),\n-    values=[])\n+    schema.Choice, _("label_choice_field", default="Choice"), values=[]\n+)\n \n \n @interface.implementer(se_schema.ITextLineChoice)\n @component.adapter(schema_ifaces.IChoice)\n-class TextLineChoiceField(object):\n-\n+class TextLineChoiceField:\n     def __init__(self, field):\n-        self.__dict__[\'field\'] = field\n+        self.__dict__["field"] = field\n \n     def __getattr__(self, name):\n-        if name == \'values\':\n+        if name == "values":\n             values = []\n-            for term in (self.field.vocabulary or []):\n+            for term in self.field.vocabulary or []:\n                 if term.value != term.title:\n-                    values.append(u\'{0:s}|{1:s}\'.format(\n-                        term.value, term.title))\n+                    values.append(f"{term.value:s}|{term.title:s}")\n                 else:\n                     values.append(term.value)\n             return values\n \n-\n         return getattr(self.field, name)\n \n     def _constructVocabulary(self, value):\n         terms = []\n         if value:\n             for item in value:\n-                if item and u\'|\' in item:\n-                    voc_value, voc_title = item.split(u\'|\', 1)\n+                if item and "|" in item:\n+                    voc_value, voc_title = item.split("|", 1)\n                 else:\n                     voc_value = item\n                     voc_title = item\n \n                 term = vocabulary.SimpleTerm(\n-                    token=voc_value.encode(\'unicode_escape\'),\n-                    value=voc_value, title=voc_title)\n+                    token=voc_value.encode("unicode_escape"),\n+                    value=voc_value,\n+                    title=voc_title,\n+                )\n                 terms.append(term)\n \n         return vocabulary.SimpleVocabulary(terms)\n \n     def __setattr__(self, name, value):\n-        if name == \'values\' and value:\n+        if name == "values" and value:\n             vocab = self._constructVocabulary(value)\n-            return setattr(self.field, \'vocabulary\', vocab)\n-        elif name == \'values\' and not value:\n+            return setattr(self.field, "vocabulary", vocab)\n+        elif name == "values" and not value:\n             return\n \n-        if name == \'vocabularyName\' and value:\n-            setattr(self.field, \'values\', None)\n-            setattr(self.field, \'vocabulary\', None)\n-            return setattr(self.field, \'vocabularyName\', value)\n-        elif name == \'vocabularyName\' and not value:\n-            return setattr(self.field, \'vocabularyName\', None)\n+        if name == "vocabularyName" and value:\n+            setattr(self.field, "values", None)\n+            setattr(self.field, "vocabulary", None)\n+            return setattr(self.field, "vocabularyName", value)\n+        elif name == "vocabularyName" and not value:\n+            return setattr(self.field, "vocabularyName", None)\n \n         return setattr(self.field, name, value)\n \n     def __delattr__(self, name):\n-        if name == \'values\':\n+        if name == "values":\n             del self.field.vocabulary\n \n         return delattr(self.field, name)\n \n \n-@component.adapter(interface.Interface, interface.Interface,\n-                   interfaces.IFieldEditForm,\n-                   se_schema.ITextLinesField, interface.Interface)\n+@component.adapter(\n+    interface.Interface,\n+    interface.Interface,\n+    interfaces.IFieldEditForm,\n+    se_schema.ITextLinesField,\n+    interface.Interface,\n+)\n class VocabularyValuesValidator(validator.SimpleFieldValidator):\n \n-    """Ensure duplicate vocabulary terms are not submitted\n-    """\n+    """Ensure duplicate vocabulary terms are not submitted"""\n \n     def validate(self, values):\n         if values is None:\n-            return super(VocabularyValuesValidator, self).validate(\n-                values)\n+            return super().validate(values)\n \n         by_value = {}\n         by_token = {}\n         for value in values:\n-            term = vocabulary.SimpleTerm(token=value.encode(\'unicode_escape\'),\n-                                         value=value, title=value)\n+            term = vocabulary.SimpleTerm(\n+                token=value.encode("unicode_escape"), value=value, title=value\n+            )\n             if term.value in by_value:\n                 raise interface.Invalid(\n-                    _(\'field_edit_error_conflicting_values\',\n-                      default=u"The \'${value1}\' vocabulary value conflicts "\n-                              u"with \'${value2}\'.",\n-                      mapping={\'value1\': value,\n-                               \'value2\': by_value[term.value].value}))\n+                    _(\n+                        "field_edit_error_conflicting_values",\n+                        default="The \'${value1}\' vocabulary value conflicts "\n+                        "with \'${value2}\'.",\n+                        mapping={"value1": value, "value2": by_value[term.value].value},\n+                    )\n+                )\n \n             if term.token in by_token:\n                 raise interface.Invalid(\n-                    _(\'field_edit_error_conflicting_values\',\n-                      default=u"The \'${value1}\' vocabulary value conflicts "\n-                              u"with \'${value2}\'.",\n-                      mapping={\'value1\': value,\n-                               \'value2\': by_value[term.token].value}))\n+                    _(\n+                        "field_edit_error_conflicting_values",\n+                        default="The \'${value1}\' vocabulary value conflicts "\n+                        "with \'${value2}\'.",\n+                        mapping={"value1": value, "value2": by_value[term.token].value},\n+                    )\n+                )\n \n             by_value[term.value] = term\n             by_token[term.token] = term\n \n-        return super(VocabularyValuesValidator, self).validate(values)\n+        return super().validate(values)\n \n \n class VocabularyNameValidator(validator.SimpleFieldValidator):\n \n-    """Ensure user has not submitted a vocabulary values AND a factory\n-    """\n+    """Ensure user has not submitted a vocabulary values AND a factory"""\n \n     def validate(self, values):\n         if values is None:\n-            return super(VocabularyNameValidator, self).validate(\n-                values)\n+            return super().validate(values)\n \n-        if values and self.request.form.get(\'form.widgets.values\', None):\n+        if values and self.request.form.get("form.widgets.values", None):\n             raise interface.Invalid(\n-                _(\'field_edit_error_values_and_name\',\n-                  default=u\'You can not set a vocabulary name AND vocabulary \'\n-                          u\'values. Please clear values field or set no value \'\n-                          u\'here.\'\n-                  )\n+                _(\n+                    "field_edit_error_values_and_name",\n+                    default="You can not set a vocabulary name AND vocabulary "\n+                    "values. Please clear values field or set no value "\n+                    "here.",\n+                )\n             )\n \n-        return super(VocabularyNameValidator, self).validate(values)\n+        return super().validate(values)\n \n \n validator.WidgetValidatorDiscriminators(\n-    VocabularyNameValidator,\n-    field=se_schema.ITextLineChoice[\'vocabularyName\'])\n+    VocabularyNameValidator, field=se_schema.ITextLineChoice["vocabularyName"]\n+)\n \n \n @interface.implementer(interfaces.IFieldEditFormSchema)\n@@ -245,49 +249,47 @@ def getMultiChoiceFieldSchema(field):\n \n MultiChoiceFactory = FieldFactory(\n     schema.Set,\n-    _(u\'label_multi_choice_field\', default=u\'Multiple Choice\'),\n-    value_type=schema.Choice(values=[]))\n+    _("label_multi_choice_field", default="Multiple Choice"),\n+    value_type=schema.Choice(values=[]),\n+)\n \n \n @interface.implementer_only(se_schema.ITextLineChoice)\n @component.adapter(schema_ifaces.ISet)\n class TextLineMultiChoiceField(TextLineChoiceField):\n-\n     def __init__(self, field):\n-        self.__dict__[\'field\'] = field\n+        self.__dict__["field"] = field\n \n     def __getattr__(self, name):\n         field = self.field\n-        if name == \'values\':\n+        if name == "values":\n             values = []\n-            for term in (self.field.value_type.vocabulary or []):\n+            for term in self.field.value_type.vocabulary or []:\n                 if term.value != term.title:\n-                    values.append(u\'{0:s}|{1:s}\'.format(\n-                        term.value, term.title))\n+                    values.append(f"{term.value:s}|{term.title:s}")\n                 else:\n                     values.append(term.value)\n             return values\n-        elif name == \'vocabularyName\':\n-            return getattr(field.value_type, name, None) or \\\n-                   getattr(field, name)\n+        elif name == "vocabularyName":\n+            return getattr(field.value_type, name, None) or getattr(field, name)\n         else:\n             return getattr(field, name)\n \n     def __setattr__(self, name, value):\n-        if name == \'values\' and value:\n+        if name == "values" and value:\n             vocab = self._constructVocabulary(value)\n-            return setattr(self.field.value_type, \'vocabulary\', vocab)\n-        elif name == \'values\' and not value:\n+            return setattr(self.field.value_type, "vocabulary", vocab)\n+        elif name == "values" and not value:\n             return\n \n-        if name == \'vocabularyName\' and value:\n-            setattr(self.field.value_type, \'values\', None)\n-            setattr(self.field.value_type, \'vocabulary\', None)\n-            setattr(self.field.value_type, \'vocabularyName\', value)\n-            return setattr(self.field, \'vocabularyName\', value)\n-        elif name == \'vocabularyName\' and not value:\n-            setattr(self.field.value_type, \'vocabularyName\', None)\n-            return setattr(self.field, \'vocabularyName\', None)\n+        if name == "vocabularyName" and value:\n+            setattr(self.field.value_type, "values", None)\n+            setattr(self.field.value_type, "vocabulary", None)\n+            setattr(self.field.value_type, "vocabularyName", value)\n+            return setattr(self.field, "vocabularyName", value)\n+        elif name == "vocabularyName" and not value:\n+            setattr(self.field.value_type, "vocabularyName", None)\n+            return setattr(self.field, "vocabularyName", None)\n \n         return setattr(self.field, name, value)\n \n@@ -296,6 +298,6 @@ def __setattr__(self, name, value):\n @component.adapter(schema_ifaces.IBool, IObjectAddedEvent)\n def setBoolWidget(field, event):\n     schema = field.interface\n-    widgets = schema.queryTaggedValue(\'plone.autoform.widgets\', {})\n-    widgets[field.__name__] = \'z3c.form.browser.radio.RadioFieldWidget\'\n-    schema.setTaggedValue(\'plone.autoform.widgets\', widgets)\n+    widgets = schema.queryTaggedValue("plone.autoform.widgets", {})\n+    widgets[field.__name__] = "z3c.form.browser.radio.RadioFieldWidget"\n+    schema.setTaggedValue("plone.autoform.widgets", widgets)\ndiff --git a/plone/schemaeditor/interfaces.py b/plone/schemaeditor/interfaces.py\nindex 43470b5..f7d17bd 100644\n--- a/plone/schemaeditor/interfaces.py\n+++ b/plone/schemaeditor/interfaces.py\n@@ -1,13 +1,12 @@\n-# -*- coding: utf-8 -*-\n from OFS.interfaces import IItem\n from plone.schemaeditor import _\n from z3c.form.interfaces import IEditForm\n-from zope.interface.interfaces import IObjectEvent\n from zope.interface import Invalid\n from zope.interface import invariant\n from zope.interface.interfaces import Attribute\n from zope.interface.interfaces import IInterface\n from zope.interface.interfaces import Interface\n+from zope.interface.interfaces import IObjectEvent\n from zope.publisher.interfaces.browser import IBrowserPage\n from zope.schema import ASCIILine\n from zope.schema import Bool\n@@ -22,89 +21,76 @@\n \n \n class ISchemaView(IBrowserPage):\n-    """ A publishable view of a zope 3 schema\n-    """\n+    """A publishable view of a zope 3 schema"""\n \n \n class ISchemaContext(IItem):\n-    """ A publishable wrapper of a zope 3 schema\n-    """\n+    """A publishable wrapper of a zope 3 schema"""\n \n-    schema = Object(\n-        schema=IInterface\n-    )\n+    schema = Object(schema=IInterface)\n \n-    schemaEditorView = Attribute(\n-        """Name of the schema editor view. Optional.""")\n+    schemaEditorView = Attribute("""Name of the schema editor view. Optional.""")\n \n-    additionalSchemata = Attribute(\n-        """Additional schemas that may modify this one.""")\n+    additionalSchemata = Attribute("""Additional schemas that may modify this one.""")\n \n     allowedFields = Attribute(\n         """List of field factory ids that may be added to this schema.\n         Or None to allow all fields.\n-        """)\n+        """\n+    )\n \n     fieldsWhichCannotBeDeleted = Attribute(\n         """List of field names that may not be deleted from this schema."""\n     )\n \n-    enableFieldsets = Attribute(\n-        """Enable extra fieldsets."""\n-    )\n+    enableFieldsets = Attribute("""Enable extra fieldsets.""")\n \n \n class ISchemaModifiedEvent(IObjectEvent):\n \n-    object = Object(\n-        schema=ISchemaContext\n-    )\n+    object = Object(schema=ISchemaContext)\n \n \n class IFieldContext(IItem):\n-    """ A publishable wrapper of a zope 3 schema field\n-    """\n+    """A publishable wrapper of a zope 3 schema field"""\n \n-    field = Object(\n-        schema=IField\n-    )\n+    field = Object(schema=IField)\n \n \n class IFieldEditorExtender(IInterface):\n-    """ An additional schema for use when editing a field."""\n+    """An additional schema for use when editing a field."""\n \n \n class IFieldFactory(IField):\n-    """ A component that instantiates a field when called."""\n-    title = TextLine(title=u\'Title\')\n+    """A component that instantiates a field when called."""\n+\n+    title = TextLine(title="Title")\n \n     def available(self):\n-        """ field is addable in the current context """\n+        """field is addable in the current context"""\n \n     def editable(self, field):\n-        """ test whether a given instance of a field is editable """\n+        """test whether a given instance of a field is editable"""\n \n     def protected(self, field):\n-        """ test whether a given instance of a field is protected """\n+        """test whether a given instance of a field is protected"""\n \n \n class IEditableSchema(Interface):\n-    """ Interface for adding/removing fields to/from a schema.\n-    """\n+    """Interface for adding/removing fields to/from a schema."""\n \n     def addField(field, name=None):\n-        """ Add a field to a schema\n+        """Add a field to a schema\n \n         If not provided, the field\'s name will be taken from its __name__\n         attribute.\n         """\n \n     def removeField(field_name):\n-        """ Remove a field from a schema\n-        """\n+        """Remove a field from a schema"""\n \n     def moveField(field_name, new_pos):\n-        """ Move a field to the (new_pos)th position in the schema\'s sort \xc3\xa7\n+        """Move a field to the (new_pos)th position in the schema\'s sort \xc3\xa7\n         order (indexed beginning at 0).\n \n         Schema fields are assigned an \'order\' attribute that increments for\n@@ -120,71 +106,67 @@ def changeFieldFieldset(field_name, next_fieldset):\n \n \n class IFieldEditForm(IEditForm):\n-    """ Marker interface for field edit forms\n-    """\n+    """Marker interface for field edit forms"""\n \n \n class IFieldEditFormSchema(Interface):\n-    """ The schema describing the form fields for a field.\n-    """\n+    """The schema describing the form fields for a field."""\n \n \n RESERVED_NAMES = (\n-    \'subject\',\n-    \'format\',\n-    \'language\',\n-    \'creators\',\n-    \'contributors\',\n-    \'rights\',\n-    \'effective_date\',\n-    \'expiration_date\',\n+    "subject",\n+    "format",\n+    "language",\n+    "creators",\n+    "contributors",\n+    "rights",\n+    "effective_date",\n+    "expiration_date",\n )\n \n # a letter followed by letters, numbers, or underscore\n-ID_RE = re.compile(r\'^[a-z][\\w\\d\\.]*$\')\n+ID_RE = re.compile(r"^[a-z][\\w\\d\\.]*$")\n \n \n def isValidFieldName(value):\n     if not ID_RE.match(value):\n         raise Invalid(\n-            _(u\'Please start with a lowercase letter and after this use only letters, \'\n-              u\'numbers and the following characters: _.\')\n+            _(\n+                "Please start with a lowercase letter and after this use only letters, "\n+                "numbers and the following characters: _."\n+            )\n         )\n     if value in RESERVED_NAMES:\n-        raise Invalid(\n-            _(u"\'${name}\' is a reserved field name.", mapping={\'name\': value}))\n+        raise Invalid(_("\'${name}\' is a reserved field name.", mapping={"name": value}))\n     return True\n \n \n class INewField(Interface):\n \n     fieldset_id = Int(\n-        title=_(u\'Fieldset ID\'),\n-        description=_(u\'Used to decide where to put this field.\'),\n+        title=_("Fieldset ID"),\n+        description=_("Used to decide where to put this field."),\n         required=True,\n     )\n \n-    title = TextLine(\n-        title=_(u\'Title\'),\n-        required=True\n-    )\n+    title = TextLine(title=_("Title"), required=True)\n \n     __name__ = ASCIILine(\n-        title=_(u\'Short Name\'),\n-        description=_(u\'Used for programmatic access to the field.\'),\n+        title=_("Short Name"),\n+        description=_("Used for programmatic access to the field."),\n         required=True,\n         constraint=isValidFieldName,\n     )\n \n     description = Text(\n-        title=_(u\'Help Text\'),\n-        description=_(u\'Shows up in the form as help text for the field.\'),\n-        required=False\n+        title=_("Help Text"),\n+        description=_("Shows up in the form as help text for the field."),\n+        required=False,\n     )\n \n     factory = Choice(\n-        title=_(u\'Field type\'),\n-        vocabulary=\'Fields\',\n+        title=_("Field type"),\n+        vocabulary="Fields",\n         required=True,\n         # This can\'t be done yet or we\'ll create circular import problem.\n         # So it will be injected from fields.py\n@@ -192,10 +174,8 @@ class INewField(Interface):\n     )\n \n     required = Bool(\n-        title=_(u\'Required field\'),\n-        description=_(\n-            u\'Check this box if you want this field to be required.\'\n-        ),\n+        title=_("Required field"),\n+        description=_("Check this box if you want this field to be required."),\n         default=False,\n         required=False,\n     )\n@@ -203,33 +183,23 @@ class INewField(Interface):\n     @invariant\n     def checkTitleAndDescriptionTypes(data):\n         if data.__name__ is not None and data.factory is not None:\n-            if data.__name__ == \'title\' and \\\n-                    data.factory.fieldcls is not TextLine:\n+            if data.__name__ == "title" and data.factory.fieldcls is not TextLine:\n                 raise Invalid(\n-                    _(u"The \'title\' field must be a Text line (string) field.")\n-                )\n-            if data.__name__ == \'description\' and \\\n-                    data.factory.fieldcls is not Text:\n-                raise Invalid(\n-                    _(u"The \'description\' field must be a Text field.")\n+                    _("The \'title\' field must be a Text line (string) field.")\n                 )\n+            if data.__name__ == "description" and data.factory.fieldcls is not Text:\n+                raise Invalid(_("The \'description\' field must be a Text field."))\n \n \n class INewFieldset(Interface):\n \n-    label = TextLine(\n-        title=_(u\'Title\'),\n-        required=True\n-    )\n+    label = TextLine(title=_("Title"), required=True)\n \n     __name__ = ASCIILine(\n-        title=_(u\'Short Name\'),\n-        description=_(u\'Used for programmatic access to the fieldset.\'),\n+        title=_("Short Name"),\n+        description=_("Used for programmatic access to the fieldset."),\n         required=True,\n         constraint=isValidFieldName,\n     )\n \n-    description = Text(\n-        title=_(u\'Description\'),\n-        required=False\n-    )\n+    description = Text(title=_("Description"), required=False)\ndiff --git a/plone/schemaeditor/schema.py b/plone/schemaeditor/schema.py\nindex d289f94..c4d1e58 100644\n--- a/plone/schemaeditor/schema.py\n+++ b/plone/schemaeditor/schema.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.z3cform.interfaces import IDateField\n from plone.app.z3cform.interfaces import IDatetimeField\n from plone.schemaeditor import _\n@@ -8,11 +7,12 @@\n \n \n # get rid of unhelpful help text\n-interfaces.IMinMaxLen[\'min_length\'].description = u\'\'\n-interfaces.IMinMaxLen[\'max_length\'].description = u\'\'\n+interfaces.IMinMaxLen["min_length"].description = ""\n+interfaces.IMinMaxLen["max_length"].description = ""\n \n # now fix up some of the schemas with missing details\n \n+\n class IBool(interfaces.IBool, interfaces.IFromUnicode):\n     pass\n \n@@ -20,45 +20,45 @@ class IBool(interfaces.IBool, interfaces.IFromUnicode):\n class IFloat(interfaces.IFloat, interfaces.IFromUnicode):\n \n     min = schema.Float(\n-        title=interfaces.IFloat[\'min\'].title,\n-        required=interfaces.IFloat[\'min\'].required,\n-        default=interfaces.IFloat[\'min\'].default,\n+        title=interfaces.IFloat["min"].title,\n+        required=interfaces.IFloat["min"].required,\n+        default=interfaces.IFloat["min"].default,\n     )\n \n     max = schema.Float(\n-        title=interfaces.IFloat[\'max\'].title,\n-        required=interfaces.IFloat[\'max\'].required,\n-        default=interfaces.IFloat[\'max\'].default,\n+        title=interfaces.IFloat["max"].title,\n+        required=interfaces.IFloat["max"].required,\n+        default=interfaces.IFloat["max"].default,\n     )\n \n \n class IDatetime(IDatetimeField):\n \n     min = schema.Datetime(\n-        title=interfaces.IDatetime[\'min\'].title,\n-        required=interfaces.IDatetime[\'min\'].required,\n-        default=interfaces.IDatetime[\'min\'].default,\n+        title=interfaces.IDatetime["min"].title,\n+        required=interfaces.IDatetime["min"].required,\n+        default=interfaces.IDatetime["min"].default,\n     )\n \n     max = schema.Datetime(\n-        title=interfaces.IDatetime[\'max\'].title,\n-        required=interfaces.IDatetime[\'max\'].required,\n-        default=interfaces.IDatetime[\'max\'].default,\n+        title=interfaces.IDatetime["max"].title,\n+        required=interfaces.IDatetime["max"].required,\n+        default=interfaces.IDatetime["max"].default,\n     )\n \n \n class IDate(IDateField):\n \n     min = schema.Date(\n-        title=interfaces.IDate[\'min\'].title,\n-        required=interfaces.IDate[\'min\'].required,\n-        default=interfaces.IDate[\'min\'].default,\n+        title=interfaces.IDate["min"].title,\n+        required=interfaces.IDate["min"].required,\n+        default=interfaces.IDate["min"].default,\n     )\n \n     max = schema.Date(\n-        title=interfaces.IDate[\'max\'].title,\n-        required=interfaces.IDate[\'max\'].required,\n-        default=interfaces.IDate[\'max\'].default,\n+        title=interfaces.IDate["max"].title,\n+        required=interfaces.IDate["max"].required,\n+        default=interfaces.IDate["max"].default,\n     )\n \n \n@@ -74,17 +74,18 @@ class ITextLinesField(interfaces.IList):\n class ITextLineChoice(interfaces.IField):\n \n     values = schema.List(\n-        title=_(u\'Possible values\'),\n-        description=_(u\'Enter allowed choices one per line.\'),\n-        required=interfaces.IChoice[\'vocabulary\'].required,\n-        default=interfaces.IChoice[\'vocabulary\'].default,\n-        value_type=schema.TextLine())\n+        title=_("Possible values"),\n+        description=_("Enter allowed choices one per line."),\n+        required=interfaces.IChoice["vocabulary"].required,\n+        default=interfaces.IChoice["vocabulary"].default,\n+        value_type=schema.TextLine(),\n+    )\n     alsoProvides(values, ITextLinesField)\n \n     vocabularyName = schema.Choice(\n-        title=interfaces.IChoice[\'vocabularyName\'].title,\n-        description=interfaces.IChoice[\'vocabularyName\'].description,\n-        default=interfaces.IChoice[\'vocabularyName\'].default,\n+        title=interfaces.IChoice["vocabularyName"].title,\n+        description=interfaces.IChoice["vocabularyName"].description,\n+        default=interfaces.IChoice["vocabularyName"].default,\n         required=False,\n-        vocabulary=\'plone.schemaeditor.VocabulariesVocabulary\',\n+        vocabulary="plone.schemaeditor.VocabulariesVocabulary",\n     )\ndiff --git a/plone/schemaeditor/testing.py b/plone/schemaeditor/testing.py\nindex 432a4f3..266c380 100644\n--- a/plone/schemaeditor/testing.py\n+++ b/plone/schemaeditor/testing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """Base module for unittesting."""\n from plone.app.robotframework.testing import AUTOLOGIN_LIBRARY_FIXTURE\n from plone.app.testing import FunctionalTesting\n@@ -9,11 +8,11 @@\n \n class PloneSchemaeditorRobotLayer(PloneSandboxLayer):\n \n-    defaultBases = (PLONE_FIXTURE, )\n+    defaultBases = (PLONE_FIXTURE,)\n \n \n FIXTURE = PloneSchemaeditorRobotLayer(\n-    name=\'ROBOT\',\n+    name="ROBOT",\n )\n \n \n@@ -23,5 +22,5 @@ class PloneSchemaeditorRobotLayer(PloneSandboxLayer):\n         AUTOLOGIN_LIBRARY_FIXTURE,\n         z2.ZSERVER_FIXTURE,\n     ),\n-    name=\'ACCEPTANCE\'\n+    name="ACCEPTANCE",\n )\ndiff --git a/plone/schemaeditor/tests/fixtures.py b/plone/schemaeditor/tests/fixtures.py\nindex 5585818..6ac95fa 100644\n--- a/plone/schemaeditor/tests/fixtures.py\n+++ b/plone/schemaeditor/tests/fixtures.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.schemaeditor.browser.schema.traversal import SchemaContext\n from plone.supermodel import model\n from plone.z3cform import layout\n@@ -11,7 +10,7 @@\n \n class IDummySchema(Interface):\n \n-    model.fieldset(\'alpha\', fields=[\'fieldA\'])\n+    model.fieldset("alpha", fields=["fieldA"])\n \n     field1 = schema.TextLine()\n     field2 = schema.TextLine()\n@@ -22,17 +21,17 @@ class IDummySchema(Interface):\n \n \n class DummySchemaContext(SchemaContext):\n-\n     def __init__(self, context, request):\n-        super(DummySchemaContext, self).__init__(\n-            IDummySchema, request, name=\'@@schemaeditor\')\n+        super().__init__(IDummySchema, request, name="@@schemaeditor")\n \n \n def log_event(object, event):\n-    print(\'[event: {0} on {1}]\'.format(\n-        event.__class__.__name__,\n-        object.__class__.__name__,\n-    ))       # noqa\n+    print(\n+        "[event: {} on {}]".format(\n+            event.__class__.__name__,\n+            object.__class__.__name__,\n+        )\n+    )  # noqa\n \n \n class EditForm(EditForm):\n@@ -42,43 +41,36 @@ class EditForm(EditForm):\n \n     def update(self):\n         self.fields = field.Fields(IDummySchema)\n-        super(EditForm, self).update()\n+        super().update()\n \n \n EditView = layout.wrap_form(EditForm)\n \n \n-class BaseVocabulary(object):\n-\n+class BaseVocabulary:\n     def __call__(self, context):\n-        terms = [SimpleVocabulary.createTerm(\n-            value,\n-            value,\n-            label)\n-            for value, label in self.values_list]\n+        terms = [\n+            SimpleVocabulary.createTerm(value, value, label)\n+            for value, label in self.values_list\n+        ]\n         return SimpleVocabulary(terms)\n \n \n class CountriesVocabulary(BaseVocabulary):\n \n-    values_list = [(\'fr\', u\'France\'),\n-                   (\'uk\', u\'United Kingdom\'),\n-                   (\'es\', u\'Spain\')]\n+    values_list = [("fr", "France"), ("uk", "United Kingdom"), ("es", "Spain")]\n \n \n class CategoriesVocabulary(BaseVocabulary):\n \n-    values_list = [(\'php\', u\'PHP\'),\n-                   (\'c\', u\'C\'),\n-                   (\'ruby\', u\'Ruby\')]\n-\n+    values_list = [("php", "PHP"), ("c", "C"), ("ruby", "Ruby")]\n \n-class DummyKeyring(object):\n \n+class DummyKeyring:\n     def random(self):\n-        return \'a\'\n+        return "a"\n \n \n DummyKeyManager = {\n-    u\'_forms\': DummyKeyring(),\n+    "_forms": DummyKeyring(),\n }\ndiff --git a/plone/schemaeditor/tests/test_fields.py b/plone/schemaeditor/tests/test_fields.py\nindex cbd9057..a1886ce 100644\n--- a/plone/schemaeditor/tests/test_fields.py\n+++ b/plone/schemaeditor/tests/test_fields.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.testing import PLONE_FIXTURE\n from plone.schemaeditor.fields import TextLineChoiceField\n from plone.schemaeditor.fields import TextLineMultiChoiceField\n@@ -7,8 +6,8 @@\n import unittest\n \n \n-class DummyField(object):\n-    """ Dummy field """\n+class DummyField:\n+    """Dummy field"""\n \n     def __init__(self):\n         self.value_type = self\n@@ -22,33 +21,22 @@ class VocabularyTestCase(unittest.TestCase):\n \n     def assertVocabulary(self, voc, values):\n         self.assertTrue(IVocabularyTokenized.providedBy(voc))\n-        self.assertEqual(\n-            [(term.value, term.token, term.title) for term in voc],\n-            values\n-        )\n+        self.assertEqual([(term.value, term.token, term.title) for term in voc], values)\n \n     def test_singlechoice_voc(self):\n         field = TextLineChoiceField(DummyField())\n-        field.values = [u\'New York\', u\'city2|M\xc3\xbcnchen\']\n-        self.assertEqual(\n-            field.values,\n-            [u\'New York\', u\'city2|M\xc3\xbcnchen\']\n-        )\n+        field.values = ["New York", "city2|M\xc3\xbcnchen"]\n+        self.assertEqual(field.values, ["New York", "city2|M\xc3\xbcnchen"])\n         self.assertVocabulary(\n             field.vocabulary,\n-            [(u\'New York\', u\'New York\', u\'New York\'),\n-             (u\'city2\', u\'city2\', u\'M\xc3\xbcnchen\')]\n-          )\n+            [("New York", "New York", "New York"), ("city2", "city2", "M\xc3\xbcnchen")],\n+        )\n \n     def test_multichoice_voc(self):\n         field = TextLineMultiChoiceField(DummyField())\n-        field.values = [u\'New York\', u\'city1|Z\xc3\xbcrich\']\n-        self.assertEqual(\n-            field.values,\n-            [u\'New York\', u\'city1|Z\xc3\xbcrich\']\n-        )\n+        field.values = ["New York", "city1|Z\xc3\xbcrich"]\n+        self.assertEqual(field.values, ["New York", "city1|Z\xc3\xbcrich"])\n         self.assertVocabulary(\n             field.vocabulary,\n-            [(u\'New York\', u\'New York\', u\'New York\'),\n-             (u\'city1\', u\'city1\', u\'Z\xc3\xbcrich\')]\n-            )\n+            [("New York", "New York", "New York"), ("city1", "city1", "Z\xc3\xbcrich")],\n+        )\ndiff --git a/plone/schemaeditor/tests/test_robot.py b/plone/schemaeditor/tests/test_robot.py\nindex 8c0dbd4..14749ea 100644\n--- a/plone/schemaeditor/tests/test_robot.py\n+++ b/plone/schemaeditor/tests/test_robot.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.testing import ROBOT_TEST_LEVEL\n from plone.schemaeditor.testing import ACCEPTANCE\n from plone.testing import layered\n@@ -11,19 +10,18 @@\n def test_suite():\n     suite = unittest.TestSuite()\n     current_dir = os.path.abspath(os.path.dirname(__file__))\n-    robot_dir = os.path.join(current_dir, \'robot\')\n+    robot_dir = os.path.join(current_dir, "robot")\n     robot_tests = [\n-        os.path.join(\'robot\', doc) for doc in\n-        os.listdir(robot_dir) if doc.endswith(\'.robot\') and\n-        doc.startswith(\'test_\')\n+        os.path.join("robot", doc)\n+        for doc in os.listdir(robot_dir)\n+        if doc.endswith(".robot") and doc.startswith("test_")\n     ]\n     for robot_test in robot_tests:\n         robottestsuite = robotsuite.RobotTestSuite(robot_test)\n         robottestsuite.level = ROBOT_TEST_LEVEL\n-        suite.addTests([\n-            layered(\n-                robottestsuite,\n-                layer=ACCEPTANCE\n-            ),\n-        ])\n+        suite.addTests(\n+            [\n+                layered(robottestsuite, layer=ACCEPTANCE),\n+            ]\n+        )\n     return suite\ndiff --git a/plone/schemaeditor/tests/tests.py b/plone/schemaeditor/tests/tests.py\nindex e43aba1..e583158 100644\n--- a/plone/schemaeditor/tests/tests.py\n+++ b/plone/schemaeditor/tests/tests.py\n@@ -1,11 +1,10 @@\n-# -*- coding: utf-8 -*-\n from plone.z3cform.interfaces import IFormWrapper\n from plone.z3cform.templates import ZopeTwoFormTemplateFactory\n from Testing import ZopeTestCase as ztc\n+from Zope2.App import zcml\n from zope.interface import classImplements\n from zope.interface import implementedBy\n from zope.interface import Interface\n-from Zope2.App import zcml\n from ZPublisher.BaseRequest import BaseRequest\n \n import doctest\n@@ -16,16 +15,17 @@\n import unittest\n \n \n-optionflags = (doctest.ELLIPSIS |\n-               doctest.NORMALIZE_WHITESPACE |\n-               doctest.REPORT_ONLY_FIRST_FAILURE)\n+optionflags = (\n+    doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE | doctest.REPORT_ONLY_FIRST_FAILURE\n+)\n \n \n def setUp(self):\n     from Zope2.App.schema import configure_vocabulary_registry\n+\n     configure_vocabulary_registry()\n \n-    zcml.load_config(\'browser_testing.zcml\', plone.schemaeditor.tests)\n+    zcml.load_config("browser_testing.zcml", plone.schemaeditor.tests)\n \n     # add a test layer to the request so we can use special form templates\n     # that don\'t pull in main_template\n@@ -39,36 +39,35 @@ def tearDown(self):\n class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n         if six.PY2:\n-            want = re.sub(\'zExceptions.unauthorized.Unauthorized\', \'Unauthorized\', want)\n+            want = re.sub("zExceptions.unauthorized.Unauthorized", "Unauthorized", want)\n             got = re.sub("u\'(.*?)\'", "\'\\\\1\'", got)\n             want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \n def test_suite():\n-    return unittest.TestSuite([\n-\n-        ztc.FunctionalDocFileSuite(\n-            \'field_schemata.rst\',\n-            \'editing.rst\',\n-            \'extending.rst\',\n-            \'choice.rst\',\n-            \'minmax.rst\',\n-            setUp=setUp,\n-            tearDown=tearDown,\n-            optionflags=optionflags,\n-            checker=Py23DocChecker(),\n-        ),\n-\n-    ])\n+    return unittest.TestSuite(\n+        [\n+            ztc.FunctionalDocFileSuite(\n+                "field_schemata.rst",\n+                "editing.rst",\n+                "extending.rst",\n+                "choice.rst",\n+                "minmax.rst",\n+                setUp=setUp,\n+                tearDown=tearDown,\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n+            ),\n+        ]\n+    )\n \n \n class ITestLayer(Interface):\n     pass\n \n \n-class RenderWidget(object):\n-\n+class RenderWidget:\n     def __init__(self, widget, request):\n         self.widget = widget\n \n@@ -77,6 +76,7 @@ def __call__(self):\n \n \n layout_factory = ZopeTwoFormTemplateFactory(\n-    os.path.join(os.path.dirname(__file__), \'layout.pt\'),\n-    form=IFormWrapper, request=ITestLayer,\n+    os.path.join(os.path.dirname(__file__), "layout.pt"),\n+    form=IFormWrapper,\n+    request=ITestLayer,\n )\ndiff --git a/plone/schemaeditor/utils.py b/plone/schemaeditor/utils.py\nindex 61f6144..28c0023 100644\n--- a/plone/schemaeditor/utils.py\n+++ b/plone/schemaeditor/utils.py\n@@ -1,30 +1,36 @@\n-# -*- coding: utf-8 -*-\n from plone.schemaeditor.interfaces import IEditableSchema\n from plone.schemaeditor.interfaces import ISchemaModifiedEvent\n from plone.supermodel.interfaces import FIELDSETS_KEY\n from zope.component import adapter\n-from zope.interface.interfaces import ObjectEvent\n from zope.interface import implementer\n from zope.interface.interfaces import IInterface\n+from zope.interface.interfaces import ObjectEvent\n from zope.schema.interfaces import IField\n \n import pkg_resources\n \n+\n _zope_interface_version_major = int(\n-    pkg_resources.require(\'zope.interface\')[0].version.split(\'.\')[0]\n+    pkg_resources.require("zope.interface")[0].version.split(".")[0]\n )\n \n+\n def sortedFields(schema):\n-    """ Like getFieldsInOrder, but does not include fields from bases\n+    """Like getFieldsInOrder, but does not include fields from bases\n \n-        This is verbatim from plone.supermodel\'s utils.py but I didn\'t\n-        want to create a dependency.\n+    This is verbatim from plone.supermodel\'s utils.py but I didn\'t\n+    want to create a dependency.\n     """\n     fields = []\n     for name in schema.names(all=False):\n         field = schema[name]\n         if IField.providedBy(field):\n-            fields.append((name, field,))\n+            fields.append(\n+                (\n+                    name,\n+                    field,\n+                )\n+            )\n     fields.sort(key=lambda item: item[1].order)\n     return fields\n \n@@ -49,8 +55,7 @@ def get_field_fieldset(schema, field_name):\n \n \n def get_fieldset_from_index(schema, index):\n-    """Return a fieldset from a schema according to it\'s index.\n-    """\n+    """Return a fieldset from a schema according to it\'s index."""\n     index = int(index or 0) - 1\n     fieldsets = schema.queryTaggedValue(FIELDSETS_KEY, [])\n     return fieldsets[index] if index >= 0 else None\n@@ -85,11 +90,11 @@ def new_field_position(schema, fieldset_id=None, new_field=False):\n \n @implementer(IEditableSchema)\n @adapter(IInterface)\n-class EditableSchema(object):\n+class EditableSchema:\n \n-    """ Zope 3 schema adapter to allow addition/removal of schema fields\n+    """Zope 3 schema adapter to allow addition/removal of schema fields\n \n-        XXX this needs to be made threadsafe\n+    XXX this needs to be made threadsafe\n     """\n \n     def __init__(self, schema):\n@@ -102,7 +107,7 @@ def addField(self, field, name=None):\n \n         if name in self.schema._InterfaceClass__attrs:\n             raise ValueError(\n-                \'{0} schema already has a "{1}" field\'.format(\n+                \'{} schema already has a "{}" field\'.format(\n                     self.schema.__identifier__,\n                     name,\n                 )\n@@ -112,35 +117,34 @@ def addField(self, field, name=None):\n         if _zope_interface_version_major >= 5:\n             self.schema._v_attrs = None\n         else:\n-            if hasattr(self.schema, \'_v_attrs\'):\n+            if hasattr(self.schema, "_v_attrs"):\n                 self.schema._v_attrs[name] = field\n \n         field.interface = self.schema\n \n     def removeField(self, field_name):\n-        """ Remove a field\n-        """\n+        """Remove a field"""\n         try:\n             self.schema[field_name].interface = None\n             del self.schema._InterfaceClass__attrs[field_name]\n             if _zope_interface_version_major >= 5:\n                 self.schema._v_attrs = None\n             else:\n-                if hasattr(self.schema, \'_v_attrs\'):\n+                if hasattr(self.schema, "_v_attrs"):\n                     del self.schema._v_attrs[field_name]\n             for fieldset in self.schema.queryTaggedValue(FIELDSETS_KEY, []):\n                 if field_name in fieldset.fields:\n                     fieldset.fields.remove(field_name)\n         except KeyError:\n             raise ValueError(\n-                \'{0} schema has no "{1}" field\'.format(\n+                \'{} schema has no "{}" field\'.format(\n                     self.schema.__identifier__,\n                     field_name,\n                 )\n             )\n \n     def moveField(self, field_name, new_pos):\n-        """ Move a field to the (new_pos)th position in the schema\'s sort\n+        """Move a field to the (new_pos)th position in the schema\'s sort\n         order (indexed beginning at 0).\n \n         Schema fields are assigned an \'order\' attribute that increments for\n@@ -149,18 +153,16 @@ def moveField(self, field_name, new_pos):\n         unique.\n         """\n         moving_field = self.schema[field_name]\n-        ordered_field_ids = [\n-            name for (name, field) in sortedFields(self.schema)]\n+        ordered_field_ids = [name for (name, field) in sortedFields(self.schema)]\n \n         # make sure this is sane\n         if not isinstance(new_pos, int):\n-            raise IndexError(\'The new field position must be an integer.\')\n+            raise IndexError("The new field position must be an integer.")\n         if new_pos < 0:\n-            raise IndexError(\'The new field position must be greater than 0.\')\n+            raise IndexError("The new field position must be greater than 0.")\n         if new_pos >= len(ordered_field_ids):\n             raise IndexError(\n-                \'The new field position must be less than the number of \'\n-                \'fields.\'\n+                "The new field position must be less than the number of " "fields."\n             )\n \n         # determine which fields we have to update the order attribute on\n@@ -176,14 +178,12 @@ def moveField(self, field_name, new_pos):\n                 slice_end = None\n             intervening_fields = [\n                 self.schema[field_id]\n-                for field_id\n-                in ordered_field_ids[cur_pos - 1:slice_end:-1]\n+                for field_id in ordered_field_ids[cur_pos - 1 : slice_end : -1]\n             ]\n         elif new_pos > cur_pos:\n             intervening_fields = [\n                 self.schema[field_id]\n-                for field_id\n-                in ordered_field_ids[cur_pos + 1:new_pos + 1]\n+                for field_id in ordered_field_ids[cur_pos + 1 : new_pos + 1]\n             ]\n \n         # do a little dance\n@@ -198,8 +198,9 @@ def moveField(self, field_name, new_pos):\n         fieldset = get_field_fieldset(self.schema, field_name)\n         if fieldset is not None:\n             ordered_field_ids = [info[0] for info in sortedFields(self.schema)]\n-            fieldset.fields = sorted(fieldset.fields,\n-                                     key=lambda x: ordered_field_ids.index(x))\n+            fieldset.fields = sorted(\n+                fieldset.fields, key=lambda x: ordered_field_ids.index(x)\n+            )\n \n     def changeFieldFieldset(self, field_name, next_fieldset):\n         """Move a field from a fieldset to another,\n@@ -221,9 +222,8 @@ class SchemaModifiedEvent(ObjectEvent):\n \n \n class FieldModifiedEvent(SchemaModifiedEvent):\n-\n     def __init__(self, obj, field):\n-        super(FieldModifiedEvent, self).__init__(obj)\n+        super().__init__(obj)\n         self.field = field\n \n \ndiff --git a/plone/schemaeditor/vocabularies.py b/plone/schemaeditor/vocabularies.py\nindex 6b41040..1ec343b 100644\n--- a/plone/schemaeditor/vocabularies.py\n+++ b/plone/schemaeditor/vocabularies.py\n@@ -1,23 +1,20 @@\n-# -*- coding: utf-8 -*-\n from zope.component import getUtilitiesFor\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n \n-class VocabulariesVocabulary(object):\n+class VocabulariesVocabulary:\n \n-    """Vocabulary for a list of available vocabulary factories\n-    """\n+    """Vocabulary for a list of available vocabulary factories"""\n \n     def __call__(self, context):\n         terms = []\n         for name, vocabulary in getUtilitiesFor(IVocabularyFactory):\n-            doc = (vocabulary.__doc__ or \'\').strip().split(\'\\n\')\n+            doc = (vocabulary.__doc__ or "").strip().split("\\n")\n             doc = [l.strip() for l in doc if l.strip()]\n             if len(doc) > 0:\n-                terms.append(\n-                    SimpleTerm(name, name, \'{0} - {1}\'.format(name, doc[0])))\n+                terms.append(SimpleTerm(name, name, f"{name} - {doc[0]}"))\n             else:\n                 terms.append(SimpleTerm(name, name, name))\n \ndiff --git a/setup.py b/setup.py\nindex 12d920e..058bc2d 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,16 +1,14 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n \n-version = \'4.0.1.dev0\'\n+version = "4.0.1.dev0"\n \n setup(\n-    name=\'plone.schemaeditor\',\n+    name="plone.schemaeditor",\n     version=version,\n     description="Provides through-the-web editing of a zope schema/interface.",\n-    long_description=open("README.rst").read() + "\\n" +\n-    open("CHANGES.rst").read(),\n+    long_description=open("README.rst").read() + "\\n" + open("CHANGES.rst").read(),\n     classifiers=[\n         "Development Status :: 6 - Mature",\n         "Framework :: Zope",\n@@ -26,35 +24,37 @@\n         "Topic :: Software Development :: Libraries :: Python Modules",\n         "License :: OSI Approved :: BSD License",\n     ],\n-    keywords=\'plone schema ttw\',\n-    author=\'David Glick\',\n-    author_email=\'dglick@gmail.com\',\n-    url=\'https://github.com/plone/plone.schemaeditor\',\n-    license=\'BSD\',\n+    keywords="plone schema ttw",\n+    author="David Glick",\n+    author_email="dglick@gmail.com",\n+    url="https://github.com/plone/plone.schemaeditor",\n+    license="BSD",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'Zope\',\n-        \'zope.cachedescriptors\',\n-        \'zope.component\',\n-        \'zope.container\',\n-        \'zope.globalrequest\',\n-        \'zope.interface\',\n-        \'zope.lifecycleevent\',\n-        \'zope.schema\',\n-        \'zope.publisher\',\n-        \'z3c.form\',\n-        \'plone.z3cform\',\n-        \'plone.app.z3cform\',\n-        \'plone.autoform\',\n+        "setuptools",\n+        "six",\n+        "Zope",\n+        "zope.cachedescriptors",\n+        "zope.component",\n+        "zope.container",\n+        "zope.globalrequest",\n+        "zope.interface",\n+        "zope.lifecycleevent",\n+        "zope.schema",\n+        "zope.publisher",\n+        "z3c.form",\n+        "plone.z3cform",\n+        "plone.app.z3cform",\n+        "plone.autoform",\n     ],\n-    extras_require={\'test\': [\n-        \'plone.app.dexterity\',\n-        \'plone.app.testing\',\n-        \'plone.app.robotframework\',\n-    ]},\n+    extras_require={\n+        "test": [\n+            "plone.app.dexterity",\n+            "plone.app.testing",\n+            "plone.app.robotframework",\n+        ]\n+    },\n )\n'

Repository: plone.schemaeditor


Branch: refs/heads/master
Date: 2023-01-27T09:45:17+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.schemaeditor/commit/99e5edd2f72697d86f07d7cfbe12445bfe1069b0

chore: no need for old imports

Files changed:
M plone/__init__.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex 05f0beb..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,7 +1 @@\n-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n-try:\n-    __import__("pkg_resources").declare_namespace(__name__)\n-except ImportError:\n-    from pkgutil import extend_path\n-\n-    __path__ = extend_path(__path__, __name__)\n+__import__("pkg_resources").declare_namespace(__name__)\n'

Repository: plone.schemaeditor


Branch: refs/heads/master
Date: 2023-01-27T09:45:17+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.schemaeditor/commit/3f90f907f09de2869ea528bf9e11f41c6e78b34a

chore: tox -e lint

Files changed:
M CHANGES.rst
M plone/schemaeditor/browser/field/edit.py
M plone/schemaeditor/browser/schema/add_field.py
M plone/schemaeditor/vocabularies.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex c0279f2..b08351e 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -198,7 +198,7 @@ Bug fixes:\n   Fixes: #30.\n   [thet]\n \n-- JavaScript formating according to style guides.\n+- JavaScript formatting according to style guides.\n   [thet]\n \n - Cleanup:\ndiff --git a/plone/schemaeditor/browser/field/edit.py b/plone/schemaeditor/browser/field/edit.py\nindex ccf9179..916af35 100644\n--- a/plone/schemaeditor/browser/field/edit.py\n+++ b/plone/schemaeditor/browser/field/edit.py\n@@ -25,8 +25,6 @@\n from zope.schema.interfaces import IField\n from zope.security.interfaces import ForbiddenAttribute\n \n-import six\n-\n \n _marker = object()\n \ndiff --git a/plone/schemaeditor/browser/schema/add_field.py b/plone/schemaeditor/browser/schema/add_field.py\nindex 8f1629d..9546921 100644\n--- a/plone/schemaeditor/browser/schema/add_field.py\n+++ b/plone/schemaeditor/browser/schema/add_field.py\n@@ -47,7 +47,7 @@ def create(self, data):\n \n         # remove fieldset_id from data\n         if "fieldset_id" in data:\n-            fieldset_id = data.pop("fieldset_id")\n+            _ = data.pop("fieldset_id")\n \n         # split regular attributes and extra ones\n         for key in list(data.keys()):\ndiff --git a/plone/schemaeditor/vocabularies.py b/plone/schemaeditor/vocabularies.py\nindex 1ec343b..45ebc37 100644\n--- a/plone/schemaeditor/vocabularies.py\n+++ b/plone/schemaeditor/vocabularies.py\n@@ -12,7 +12,7 @@ def __call__(self, context):\n         terms = []\n         for name, vocabulary in getUtilitiesFor(IVocabularyFactory):\n             doc = (vocabulary.__doc__ or "").strip().split("\\n")\n-            doc = [l.strip() for l in doc if l.strip()]\n+            doc = [item.strip() for item in doc if item.strip()]\n             if len(doc) > 0:\n                 terms.append(SimpleTerm(name, name, f"{name} - {doc[0]}"))\n             else:\n'

Repository: plone.schemaeditor


Branch: refs/heads/master
Date: 2023-01-27T09:45:59+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.schemaeditor/commit/eb34863e7358009656da774ee9956a9ded04d851

Add news entry

Files changed:
A news/1.internal

b'diff --git a/news/1.internal b/news/1.internal\nnew file mode 100644\nindex 0000000..b325713\n--- /dev/null\n+++ b/news/1.internal\n@@ -0,0 +1,2 @@\n+Configure configuration files.\n+[gforcada]\n'

Repository: plone.schemaeditor


Branch: refs/heads/master
Date: 2023-01-27T15:35:34+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.schemaeditor/commit/50faaccdb949a1261228a3bf8781235ec54bf804

Merge pull request #97 from plone/config-with-default-template-6f6170ae

Config with default template 2023-01-27

Files changed:
A .editorconfig
A .github/workflows/linting.yml
A .meta.toml
A lint-requirements.txt
A news/1.internal
A tox.ini
M CHANGES.rst
M plone/__init__.py
M plone/schemaeditor/__init__.py
M plone/schemaeditor/browser/__init__.py
M plone/schemaeditor/browser/field/edit.py
M plone/schemaeditor/browser/field/fieldset.py
M plone/schemaeditor/browser/field/order.py
M plone/schemaeditor/browser/field/traversal.py
M plone/schemaeditor/browser/schema/__init__.py
M plone/schemaeditor/browser/schema/add_field.py
M plone/schemaeditor/browser/schema/add_fieldset.py
M plone/schemaeditor/browser/schema/delete_fieldset.py
M plone/schemaeditor/browser/schema/listing.py
M plone/schemaeditor/browser/schema/traversal.py
M plone/schemaeditor/fields.py
M plone/schemaeditor/interfaces.py
M plone/schemaeditor/schema.py
M plone/schemaeditor/testing.py
M plone/schemaeditor/tests/fixtures.py
M plone/schemaeditor/tests/test_fields.py
M plone/schemaeditor/tests/test_robot.py
M plone/schemaeditor/tests/tests.py
M plone/schemaeditor/utils.py
M plone/schemaeditor/vocabularies.py
M pyproject.toml
M setup.cfg
M setup.py

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.github/workflows/linting.yml b/.github/workflows/linting.yml\nnew file mode 100644\nindex 0000000..a2139a8\n--- /dev/null\n+++ b/.github/workflows/linting.yml\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+name: Linting\n+on:\n+  push:\n+    branches: [master]\n+  pull_request:\n+    branches: [master]\n+  workflow_dispatch:\n+\n+jobs:\n+  test:\n+    name: Lint code\n+    runs-on: ${{ matrix.os }}\n+    strategy:\n+      matrix:\n+        python-version: ["3.8"]\n+        os: ["ubuntu-22.04"]\n+    steps:\n+      - uses: actions/checkout@v3\n+      - name: Set up Python\n+        uses: actions/setup-python@v4\n+        with:\n+          python-version: ${{ matrix.python-version }}\n+      - name: Cache packages\n+        uses: actions/cache@v3\n+        with:\n+          path: ~/.cache/pip\n+          key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles(\'lint-requirements.txt\', \'tox.ini\') }}\n+          restore-keys: |\n+            ${{ runner.os }}-pip-${{ matrix.python-version }}-\n+            ${{ runner.os }}-pip-\n+      - name: Install dependencies\n+        run: python -m pip install tox\n+      - name: Run formatters\n+        run: tox -e format\n+      # linters\n+      - name: QA\n+        run: tox -e lint\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..500dbfe\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "c0d7e43c"\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex c0279f2..b08351e 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -198,7 +198,7 @@ Bug fixes:\n   Fixes: #30.\n   [thet]\n \n-- JavaScript formating according to style guides.\n+- JavaScript formatting according to style guides.\n   [thet]\n \n - Cleanup:\ndiff --git a/lint-requirements.txt b/lint-requirements.txt\nnew file mode 100644\nindex 0000000..129db4d\n--- /dev/null\n+++ b/lint-requirements.txt\n@@ -0,0 +1,8 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+black==22.12.0\n+check-manifest==0.49\n+codespell==2.2.2\n+flake8==6.0.0\n+isort==5.11.4\n+pyupgrade==3.3.1\ndiff --git a/news/1.internal b/news/1.internal\nnew file mode 100644\nindex 0000000..b325713\n--- /dev/null\n+++ b/news/1.internal\n@@ -0,0 +1,2 @@\n+Configure configuration files.\n+[gforcada]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 85880ef..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,7 +1 @@\n-# -*- coding: utf-8 -*-\n-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n-try:\n-    __import__(\'pkg_resources\').declare_namespace(__name__)\n-except ImportError:\n-    from pkgutil import extend_path\n-    __path__ = extend_path(__path__, __name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/schemaeditor/__init__.py b/plone/schemaeditor/__init__.py\nindex 1936adc..8efe8b3 100644\n--- a/plone/schemaeditor/__init__.py\n+++ b/plone/schemaeditor/__init__.py\n@@ -1,5 +1,4 @@\n-# -*- coding: utf-8 -*-\n from zope.i18nmessageid import MessageFactory\n \n \n-_ = MessageFactory(\'plone\')\n+_ = MessageFactory("plone")\ndiff --git a/plone/schemaeditor/browser/__init__.py b/plone/schemaeditor/browser/__init__.py\nindex ec51c5a..792d600 100644\n--- a/plone/schemaeditor/browser/__init__.py\n+++ b/plone/schemaeditor/browser/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n #\ndiff --git a/plone/schemaeditor/browser/field/edit.py b/plone/schemaeditor/browser/field/edit.py\nindex 4760ff8..916af35 100644\n--- a/plone/schemaeditor/browser/field/edit.py\n+++ b/plone/schemaeditor/browser/field/edit.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from plone.autoform.form import AutoExtensibleForm\n from plone.schemaeditor import _\n@@ -27,25 +26,21 @@\n from zope.security.interfaces import ForbiddenAttribute\n \n \n-import six\n-\n-\n _marker = object()\n \n \n class IFieldTitle(Interface):\n     title = schema.TextLine(\n-        title=schema.interfaces.ITextLine[\'title\'].title,\n-        description=schema.interfaces.ITextLine[\'title\'].description,\n-        default=u\'\',\n+        title=schema.interfaces.ITextLine["title"].title,\n+        description=schema.interfaces.ITextLine["title"].description,\n+        default="",\n         required=True,\n     )\n \n \n @implementer(IFieldTitle)\n @adapter(IField)\n-class FieldTitleAdapter(object):\n-\n+class FieldTitleAdapter:\n     def __init__(self, field):\n         self.field = field\n \n@@ -54,6 +49,7 @@ def _read_title(self):\n \n     def _write_title(self, value):\n         self.field.title = value\n+\n     title = property(_read_title, _write_title)\n \n \n@@ -62,7 +58,6 @@ class IFieldProxy(Interface):\n \n \n class FieldProxySpecification(ObjectSpecificationDescriptor):\n-\n     def __get__(self, inst, cls=None):\n         if inst is None:\n             return getObjectSpecification(cls)\n@@ -71,42 +66,44 @@ def __get__(self, inst, cls=None):\n \n \n @implementer(IFieldProxy)\n-class FieldProxy(object):\n+class FieldProxy:\n \n     __providedBy__ = FieldProxySpecification()\n \n     def __init__(self, context):\n-        self.__class__ = type(context.__class__.__name__,\n-                              (self.__class__, context.__class__), {})\n+        self.__class__ = type(\n+            context.__class__.__name__, (self.__class__, context.__class__), {}\n+        )\n         self.__dict__ = context.__dict__\n \n \n @implementer(IDataManager)\n @adapter(IFieldProxy, IField)\n class FieldDataManager(AttributeField):\n-\n     def get(self):\n-        value = super(FieldDataManager, self).get()\n+        value = super().get()\n         if isinstance(value, Message) and value.default:\n             return value.default\n         return value\n \n     def set(self, value):\n         try:\n-            old_value = super(FieldDataManager, self).get()\n+            old_value = super().get()\n         except (AttributeError, ForbiddenAttribute):\n             old_value = None\n         if isinstance(old_value, Message):\n-            value = Message(six.text_type(old_value),\n-                            domain=old_value.domain,\n-                            default=value,\n-                            mapping=old_value.mapping)\n-        super(FieldDataManager, self).set(value)\n+            value = Message(\n+                str(old_value),\n+                domain=old_value.domain,\n+                default=value,\n+                mapping=old_value.mapping,\n+            )\n+        super().set(value)\n \n \n @implementer(IFieldEditForm)\n class FieldEditForm(AutoExtensibleForm, form.EditForm):\n-    id = \'edit-field-form\'\n+    id = "edit-field-form"\n \n     def __init__(self, context, request):\n         super(form.EditForm, self).__init__(context, request)\n@@ -126,13 +123,18 @@ def _schema(self):\n     @lazy_property\n     def additionalSchemata(self):\n         schema_context = self.context.__parent__\n-        return [v for k, v in getAdapters((schema_context, self.field),\n-                                          interfaces.IFieldEditorExtender)]\n+        return [\n+            v\n+            for k, v in getAdapters(\n+                (schema_context, self.field), interfaces.IFieldEditorExtender\n+            )\n+        ]\n \n     @lazy_property\n     def label(self):\n-        return _(u"Edit Field \'${fieldname}\'",\n-                 mapping={\'fieldname\': self.field.__name__})\n+        return _(\n+            "Edit Field \'${fieldname}\'", mapping={"fieldname": self.field.__name__}\n+        )\n \n     def updateFields(self):\n         # use a custom \'title\' field to make sure it is required\n@@ -140,7 +142,8 @@ def updateFields(self):\n \n         # omit the order attribute since it\'s managed elsewhere\n         fields += field.Fields(self._schema).omit(\n-            \'order\', \'title\', \'default\', \'missing_value\', \'readonly\')\n+            "order", "title", "default", "missing_value", "readonly"\n+        )\n         self.fields = fields\n \n         if "required" in self.fields:\n@@ -150,7 +153,7 @@ def updateFields(self):\n \n         self.updateFieldsFromSchemata()\n \n-    @button.buttonAndHandler(_(u\'Save\'), name=\'save\')\n+    @button.buttonAndHandler(_("Save"), name="save")\n     def handleSave(self, action):\n         data, errors = self.extractData()\n         if errors:\n@@ -158,36 +161,35 @@ def handleSave(self, action):\n             return\n \n         # clear current min/max to avoid range errors\n-        if \'min\' in data:\n+        if "min" in data:\n             self.field.min = None\n-        if \'max\' in data:\n+        if "max" in data:\n             self.field.max = None\n \n         changes = self.applyChanges(data)\n \n         if changes:\n             IStatusMessage(self.request).addStatusMessage(\n-                self.successMessage, type=\'info\')\n+                self.successMessage, type="info"\n+            )\n         else:\n             IStatusMessage(self.request).addStatusMessage(\n-                self.noChangesMessage, type=\'info\')\n+                self.noChangesMessage, type="info"\n+            )\n \n         notify(SchemaModifiedEvent(self.context.__parent__))\n \n-    @button.buttonAndHandler(_(u\'Cancel\'), name=\'cancel\')\n+    @button.buttonAndHandler(_("Cancel"), name="cancel")\n     def handleCancel(self, action):\n         self.redirectToParent()\n \n     def redirectToParent(self):\n         parent = aq_inner(self.context).__parent__\n         url = parent.absolute_url()\n-        if hasattr(parent, \'schemaEditorView\') and parent.schemaEditorView:\n-            url += \'/@@\' + parent.schemaEditorView\n+        if hasattr(parent, "schemaEditorView") and parent.schemaEditorView:\n+            url += "/@@" + parent.schemaEditorView\n \n         self.request.response.redirect(url)\n \n \n-EditView = wrap_form(\n-    FieldEditForm,\n-    index=ViewPageTemplateFile(\'edit.pt\')\n-)\n+EditView = wrap_form(FieldEditForm, index=ViewPageTemplateFile("edit.pt"))\ndiff --git a/plone/schemaeditor/browser/field/fieldset.py b/plone/schemaeditor/browser/field/fieldset.py\nindex 8389f88..2150b8c 100644\n--- a/plone/schemaeditor/browser/field/fieldset.py\n+++ b/plone/schemaeditor/browser/field/fieldset.py\n@@ -1,7 +1,6 @@\n-# -*- coding: utf-8 -*-\n from plone.schemaeditor.interfaces import IEditableSchema\n-from plone.schemaeditor.utils import new_field_position\n from plone.schemaeditor.utils import get_fieldset_from_index\n+from plone.schemaeditor.utils import new_field_position\n from plone.schemaeditor.utils import SchemaModifiedEvent\n from Products.Five import BrowserView\n from zope.container.contained import notifyContainerModified\n@@ -9,10 +8,8 @@\n \n \n class ChangeFieldsetView(BrowserView):\n-\n     def change(self, fieldset_index):\n-        """ AJAX method to change the fieldset of a field\n-        """\n+        """AJAX method to change the fieldset of a field"""\n         schema = self.context.field.interface\n         field_name = self.context.field.__name__\n         fieldset = get_fieldset_from_index(schema, fieldset_index)\ndiff --git a/plone/schemaeditor/browser/field/order.py b/plone/schemaeditor/browser/field/order.py\nindex e42bb80..babd924 100644\n--- a/plone/schemaeditor/browser/field/order.py\n+++ b/plone/schemaeditor/browser/field/order.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.schemaeditor.interfaces import IEditableSchema\n from plone.schemaeditor.utils import FieldRemovedEvent\n from plone.schemaeditor.utils import SchemaModifiedEvent\n@@ -11,7 +10,6 @@\n \n \n class FieldOrderView(BrowserView):\n-\n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n@@ -19,7 +17,7 @@ def __init__(self, context, request):\n         self.schema = context.field.interface\n \n     def move(self, pos, fieldset_index):\n-        """ AJAX method to change field position within its schema.\n+        """AJAX method to change field position within its schema.\n         The position is relative to the fieldset.\n         """\n         schema = IEditableSchema(self.schema)\n@@ -29,15 +27,13 @@ def move(self, pos, fieldset_index):\n         fieldset_index -= 1  # index 0 is default fieldset\n \n         fieldsets = self.schema.queryTaggedValue(FIELDSETS_KEY, [])\n-        new_fieldset = fieldset_index >= 0 and fieldsets[\n-            fieldset_index] or None\n+        new_fieldset = fieldset_index >= 0 and fieldsets[fieldset_index] or None\n         schema.changeFieldFieldset(fieldname, new_fieldset)\n \n         ordered_field_ids = [info[0] for info in sortedFields(self.schema)]\n         if new_fieldset:\n             old_field_of_position = new_fieldset.fields[pos]\n-            new_absolute_position = ordered_field_ids.index(\n-                old_field_of_position)\n+            new_absolute_position = ordered_field_ids.index(old_field_of_position)\n         else:\n             new_absolute_position = pos\n \n@@ -55,4 +51,4 @@ def delete(self):\n         schema.removeField(self.field.getName())\n         notify(ObjectRemovedEvent(self.field, self.schema))\n         notify(FieldRemovedEvent(self.__parent__.__parent__, self.field))\n-        self.request.response.setHeader(\'Content-Type\', \'application/json\')\n+        self.request.response.setHeader("Content-Type", "application/json")\ndiff --git a/plone/schemaeditor/browser/field/traversal.py b/plone/schemaeditor/browser/field/traversal.py\nindex da444f9..853e1d6 100644\n--- a/plone/schemaeditor/browser/field/traversal.py\n+++ b/plone/schemaeditor/browser/field/traversal.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from OFS.SimpleItem import SimpleItem\n from plone.schemaeditor.browser.field.edit import EditView\n from plone.schemaeditor.interfaces import IFieldContext\n@@ -10,11 +9,10 @@\n @implementer(IFieldContext, IBrowserPublisher)\n class FieldContext(SimpleItem):\n \n-    """ wrapper for published zope 3 schema fields\n-    """\n+    """wrapper for published zope 3 schema fields"""\n \n     def __init__(self, context, request):\n-        super(FieldContext, self).__init__()\n+        super().__init__()\n         self.field = context\n         self.request = request\n \n@@ -23,8 +21,7 @@ def __init__(self, context, request):\n         self.__name__ = self.field.__name__\n \n     def publishTraverse(self, request, name):\n-        """ It\'s not valid to traverse to anything below a field context.\n-        """\n+        """It\'s not valid to traverse to anything below a field context."""\n         # hack to make inline validation work\n         # (plone.app.z3cform doesn\'t know the form is the default view)\n         if name == self.__name__:\n@@ -36,6 +33,5 @@ def publishTraverse(self, request, name):\n         )\n \n     def browserDefault(self, request):\n-        """ Really we want to show the field EditView.\n-        """\n-        return self, (\'@@edit\',)\n+        """Really we want to show the field EditView."""\n+        return self, ("@@edit",)\ndiff --git a/plone/schemaeditor/browser/schema/__init__.py b/plone/schemaeditor/browser/schema/__init__.py\nindex ec51c5a..792d600 100644\n--- a/plone/schemaeditor/browser/schema/__init__.py\n+++ b/plone/schemaeditor/browser/schema/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n #\ndiff --git a/plone/schemaeditor/browser/schema/add_field.py b/plone/schemaeditor/browser/schema/add_field.py\nindex 6735f59..9546921 100644\n--- a/plone/schemaeditor/browser/schema/add_field.py\n+++ b/plone/schemaeditor/browser/schema/add_field.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.form import AutoExtensibleForm\n from plone.schemaeditor import _\n from plone.schemaeditor import interfaces\n@@ -25,8 +24,8 @@\n class FieldAddForm(AutoExtensibleForm, form.AddForm):\n \n     fields = field.Fields(interfaces.INewField)\n-    label = _(\'Add new field\')\n-    id = \'add-field-form\'\n+    label = _("Add new field")\n+    id = "add-field-form"\n \n     # This is a trick: we want autoform to handle the additionalSchemata,\n     # but want to provide our own base schema below in updateFields.\n@@ -38,16 +37,17 @@ def _schema(self):\n \n     @lazy_property\n     def additionalSchemata(self):\n-        return [v for k, v in getAdapters((self.context, ),\n-                                          interfaces.IFieldEditorExtender)]\n+        return [\n+            v for k, v in getAdapters((self.context,), interfaces.IFieldEditorExtender)\n+        ]\n \n     def create(self, data):\n         extra = {}\n-        factory = data.pop(\'factory\')\n+        factory = data.pop("factory")\n \n         # remove fieldset_id from data\n-        if \'fieldset_id\' in data:\n-            fieldset_id = data.pop(\'fieldset_id\')\n+        if "fieldset_id" in data:\n+            _ = data.pop("fieldset_id")\n \n         # split regular attributes and extra ones\n         for key in list(data.keys()):\n@@ -61,7 +61,7 @@ def create(self, data):\n         # set the extra attributes using the proper adapter\n         for schemata in self.additionalSchemata:\n             for key in extra:\n-                (interface_name, property_name) = key.split(\'.\')\n+                (interface_name, property_name) = key.split(".")\n                 if interface_name != schemata.__name__:\n                     continue\n                 setattr(schemata(field_obj), property_name, extra[key])\n@@ -70,10 +70,10 @@ def create(self, data):\n \n     def add(self, new_field):\n         schema = self.context.schema\n-        fieldset_id = int(self.request.form.get(\'fieldset_id\', 0))\n+        fieldset_id = int(self.request.form.get("fieldset_id", 0))\n \n         if self.widgets:\n-            fieldset_widget = self.widgets.get(\'fieldset_id\')\n+            fieldset_widget = self.widgets.get("fieldset_id")\n             if fieldset_widget:\n                 fieldset_id = int(fieldset_widget.extract())\n             position = new_field_position(schema, fieldset_id, new_field=True)\n@@ -85,10 +85,8 @@ def add(self, new_field):\n             editable_schema.addField(new_field)\n         except ValueError:\n             raise WidgetActionExecutionError(\n-                \'__name__\',\n-                Invalid(\n-                    u\'Please select a field name that is not already used.\'\n-                )\n+                "__name__",\n+                Invalid("Please select a field name that is not already used."),\n             )\n         if fieldset_id:\n             fieldset = get_fieldset_from_index(schema, fieldset_id)\n@@ -98,22 +96,20 @@ def add(self, new_field):\n         notify(ObjectAddedEvent(new_field, schema))\n         notify(FieldAddedEvent(self.context, new_field))\n         IStatusMessage(self.request).addStatusMessage(\n-            _(u\'Field added successfully.\'), type=\'info\')\n+            _("Field added successfully."), type="info"\n+        )\n \n     def updateWidgets(self):\n-        super(FieldAddForm, self).updateWidgets()\n-        fieldset_id_widget = self.widgets.get(\'fieldset_id\')\n+        super().updateWidgets()\n+        fieldset_id_widget = self.widgets.get("fieldset_id")\n         if fieldset_id_widget:\n             if not fieldset_id_widget.value or fieldset_id_widget.value == NO_VALUE:\n-                fieldset_id = int(self.request.form.get(\'fieldset_id\', 0))\n+                fieldset_id = int(self.request.form.get("fieldset_id", 0))\n                 fieldset_id_widget.value = fieldset_id\n             fieldset_id_widget.mode = HIDDEN_MODE\n \n     def nextURL(self):\n-        return \'@@add-field\'\n+        return "@@add-field"\n \n \n-FieldAddFormPage = wrap_form(\n-    FieldAddForm,\n-    index=ViewPageTemplateFile(\'add.pt\')\n-)\n+FieldAddFormPage = wrap_form(FieldAddForm, index=ViewPageTemplateFile("add.pt"))\ndiff --git a/plone/schemaeditor/browser/schema/add_fieldset.py b/plone/schemaeditor/browser/schema/add_fieldset.py\nindex a7dc1b4..3d4d81b 100644\n--- a/plone/schemaeditor/browser/schema/add_fieldset.py\n+++ b/plone/schemaeditor/browser/schema/add_fieldset.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.schemaeditor import _\n from plone.schemaeditor.interfaces import INewFieldset\n from plone.schemaeditor.utils import SchemaModifiedEvent\n@@ -19,8 +18,8 @@\n class FieldsetAddForm(form.AddForm):\n \n     fields = field.Fields(INewFieldset)\n-    label = _(\'Add new fieldset\')\n-    id = \'add-fieldset-form\'\n+    label = _("Add new fieldset")\n+    id = "add-fieldset-form"\n \n     def create(self, data):\n         return Fieldset(**data)\n@@ -34,28 +33,21 @@ def add(self, new_fieldset):\n             for elem in mergedTaggedValueList(additional_schema, FIELDSETS_KEY):\n                 extra_fieldsets.append(elem)\n \n-        for fieldset in (fieldsets + extra_fieldsets):\n+        for fieldset in fieldsets + extra_fieldsets:\n             if fieldset.__name__ == new_fieldset.__name__:\n-                msg = _(\n-                    u\'Please select a fieldset name that is not already used.\'\n-                )\n-                raise WidgetActionExecutionError(\n-                    \'__name__\',\n-                    Invalid(msg)\n-                )\n+                msg = _("Please select a fieldset name that is not already used.")\n+                raise WidgetActionExecutionError("__name__", Invalid(msg))\n \n         fieldsets.append(new_fieldset)\n         schema.setTaggedValue(FIELDSETS_KEY, fieldsets)\n         notifyContainerModified(schema)\n         notify(SchemaModifiedEvent(self.context))\n         IStatusMessage(self.request).addStatusMessage(\n-            _(u\'Fieldset added successfully.\'), type=\'info\')\n+            _("Fieldset added successfully."), type="info"\n+        )\n \n     def nextURL(self):\n-        return \'@@add-fieldset\'\n+        return "@@add-fieldset"\n \n \n-FieldsetAddFormPage = wrap_form(\n-    FieldsetAddForm,\n-    index=ViewPageTemplateFile(\'add.pt\')\n-)\n+FieldsetAddFormPage = wrap_form(FieldsetAddForm, index=ViewPageTemplateFile("add.pt"))\ndiff --git a/plone/schemaeditor/browser/schema/delete_fieldset.py b/plone/schemaeditor/browser/schema/delete_fieldset.py\nindex 6f50cb9..0a4697c 100644\n--- a/plone/schemaeditor/browser/schema/delete_fieldset.py\n+++ b/plone/schemaeditor/browser/schema/delete_fieldset.py\n@@ -8,9 +8,8 @@\n \n \n class DeleteFieldset(BrowserView):\n-\n     def __call__(self):\n-        fieldset_name = self.request.form.get(\'name\')\n+        fieldset_name = self.request.form.get("name")\n         schema = self.context.schema\n         fieldsets = schema.queryTaggedValue(FIELDSETS_KEY, [])\n \n@@ -19,15 +18,16 @@ def __call__(self):\n             if fieldset.__name__ == fieldset_name:\n                 if fieldset.fields:\n                     IStatusMessage(self.request).addStatusMessage(\n-                        _(u\'Only empty fieldsets can be deleted\'),\n-                        type=\'error\')\n+                        _("Only empty fieldsets can be deleted"), type="error"\n+                    )\n                     return self.request.RESPONSE.redirect(self.nextURL)\n                 continue\n             else:\n                 new_fieldsets.append(fieldset)\n         if len(fieldsets) == len(new_fieldsets):\n             IStatusMessage(self.request).addStatusMessage(\n-                _(u\'Fieldset not found\'), type=\'error\')\n+                _("Fieldset not found"), type="error"\n+            )\n             return self.request.RESPONSE.redirect(self.nextURL)\n \n         schema.setTaggedValue(FIELDSETS_KEY, new_fieldsets)\n@@ -35,9 +35,10 @@ def __call__(self):\n         notifyContainerModified(schema)\n         notify(SchemaModifiedEvent(self.context))\n         IStatusMessage(self.request).addStatusMessage(\n-            _(u\'Fieldset deleted successfully.\'), type=\'info\')\n+            _("Fieldset deleted successfully."), type="info"\n+        )\n         return self.request.RESPONSE.redirect(self.nextURL)\n \n     @property\n     def nextURL(self):\n-        return self.request.get(\'HTTP_REFERER\')\n+        return self.request.get("HTTP_REFERER")\ndiff --git a/plone/schemaeditor/browser/schema/listing.py b/plone/schemaeditor/browser/schema/listing.py\nindex 89b8686..c620403 100644\n--- a/plone/schemaeditor/browser/schema/listing.py\n+++ b/plone/schemaeditor/browser/schema/listing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.form import AutoExtensibleForm\n from plone.memoize.instance import memoize\n from plone.schemaeditor import _\n@@ -28,7 +27,7 @@ class SchemaListing(AutoExtensibleForm, form.Form):\n     ignoreContext = True\n     ignoreRequest = True\n     showEmptyGroups = True\n-    template = ViewPageTemplateFile(\'schema_listing.pt\')\n+    template = ViewPageTemplateFile("schema_listing.pt")\n     ignoreRequiredOnExtract = True\n \n     @property\n@@ -40,28 +39,26 @@ def additionalSchemata(self):\n         return self.context.additionalSchemata\n \n     def _iterateOverWidgets(self):\n-        for widget in self.widgets.values():\n-            yield widget\n+        yield from self.widgets.values()\n         for group in self.groups:\n-            for widget in group.widgets.values():\n-                yield widget\n+            yield from group.widgets.values()\n \n     def render(self):\n         for widget in self._iterateOverWidgets():\n             # disable fields from behaviors\n             if widget.field.interface is not self.context.schema:\n-                widget.disabled = \'disabled\'\n+                widget.disabled = "disabled"\n \n             # limit size of the preview for text areas\n-            if hasattr(widget, \'rows\'):\n+            if hasattr(widget, "rows"):\n                 if widget.rows is None or widget.rows > 5:\n                     widget.rows = 5\n \n-        return super(SchemaListing, self).render()\n+        return super().render()\n \n     @memoize\n     def _field_factory(self, field):\n-        field_identifier = u\'{0}.{1}\'.format(\n+        field_identifier = "{}.{}".format(\n             field.__module__,\n             field.__class__.__name__,\n         )\n@@ -79,7 +76,7 @@ def field_type(self, field):\n             return field.__class__.__name__\n \n     def protected_field(self, field):\n-        field_identifier = u\'{0}.{1}\'.format(\n+        field_identifier = "{}.{}".format(\n             field.__module__,\n             field.__class__.__name__,\n         )\n@@ -89,7 +86,7 @@ def protected_field(self, field):\n     def edit_url(self, field):\n         field_factory = self._field_factory(field)\n         if field_factory is not None and field_factory.editable(field):\n-            return \'{0}/{1}\'.format(\n+            return "{}/{}".format(\n                 self.context.absolute_url(),\n                 field.__name__,\n             )\n@@ -107,7 +104,7 @@ def can_delete_fieldset(self, fieldset):\n     def delete_url(self, field):\n         if field.__name__ in self.context.fieldsWhichCannotBeDeleted:\n             return\n-        url = \'{0}/{1}/@@delete\'.format(\n+        url = "{}/{}/@@delete".format(\n             self.context.absolute_url(),\n             field.__name__,\n         )\n@@ -116,14 +113,14 @@ def delete_url(self, field):\n         return url\n \n     @button.buttonAndHandler(\n-        _(u\'Done\'),\n+        _("Done"),\n     )\n     def handleDone(self, action):\n         return self.request.RESPONSE.redirect(self.context.absolute_url())\n \n     @button.buttonAndHandler(\n-        _(u\'Save Defaults\'),\n-        condition=lambda form: getattr(form.context, \'showSaveDefaults\', True)\n+        _("Save Defaults"),\n+        condition=lambda form: getattr(form.context, "showSaveDefaults", True),\n     )\n     def handleSaveDefaults(self, action):\n         for group in self.groups:\n@@ -135,8 +132,7 @@ def handleSaveDefaults(self, action):\n \n         for widget in self._iterateOverWidgets():\n             widget_name = widget.field.getName()\n-            if (widget.field.interface is self.context.schema and\n-                    widget_name in data):\n+            if widget.field.interface is self.context.schema and widget_name in data:\n                 self.context.schema[widget_name].default = data[widget_name]\n         notify(SchemaModifiedEvent(self.context))\n \n@@ -155,33 +151,36 @@ class ReadOnlySchemaListing(SchemaListing):\n \n     def edit_url(self, field):\n         return\n+\n     delete_url = edit_url\n \n \n class SchemaListingPage(FormWrapper):\n \n-    """ Form wrapper so we can get a form with layout.\n+    """Form wrapper so we can get a form with layout.\n \n-        We define an explicit subclass rather than using the wrap_form method\n-        from plone.z3cform.layout so that we can inject the schema name into\n-        the form label.\n+    We define an explicit subclass rather than using the wrap_form method\n+    from plone.z3cform.layout so that we can inject the schema name into\n+    the form label.\n     """\n+\n     form = SchemaListing\n \n     @property\n     def label(self):\n-        """ In a dexterity schema editing context, we need to\n-            construct a label that will specify the field being\n-            edited. Outside that context (e.g., plone.app.users),\n-            we should respect the label if specified.\n+        """In a dexterity schema editing context, we need to\n+        construct a label that will specify the field being\n+        edited. Outside that context (e.g., plone.app.users),\n+        we should respect the label if specified.\n         """\n \n-        context_label = getattr(self.context, \'label\', None)\n+        context_label = getattr(self.context, "label", None)\n         if context_label is not None:\n             return context_label\n         if self.context.Title() != self.context.__name__:\n-            return _(u\'Edit ${title} (${name})\',\n-                     mapping={\'title\': self.context.Title(),\n-                              \'name\': self.context.__name__})\n+            return _(\n+                "Edit ${title} (${name})",\n+                mapping={"title": self.context.Title(), "name": self.context.__name__},\n+            )\n         else:\n-            return _(u\'Edit ${name}\', mapping={\'name\': self.context.__name__})\n+            return _("Edit ${name}", mapping={"name": self.context.__name__})\ndiff --git a/plone/schemaeditor/browser/schema/traversal.py b/plone/schemaeditor/browser/schema/traversal.py\nindex db9f2c7..921af0c 100644\n--- a/plone/schemaeditor/browser/schema/traversal.py\n+++ b/plone/schemaeditor/browser/schema/traversal.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from OFS.SimpleItem import SimpleItem\n from plone.schemaeditor.browser.field.traversal import FieldContext\n from plone.schemaeditor.interfaces import ISchemaContext\n@@ -10,8 +9,8 @@\n @implementer(ISchemaContext, IBrowserPublisher)\n class SchemaContext(SimpleItem):\n \n-    """ This is a transient item that allows us to traverse through (a wrapper\n-        of) a zope 3 schema to (a wrapper of) a zope 3 schema field.\n+    """This is a transient item that allows us to traverse through (a wrapper\n+    of) a zope 3 schema to (a wrapper of) a zope 3 schema field.\n     """\n \n     schemaEditorView = None\n@@ -20,7 +19,7 @@ class SchemaContext(SimpleItem):\n     fieldsWhichCannotBeDeleted = ()\n     enableFieldsets = True\n \n-    def __init__(self, context, request, name=u\'schema\', title=None):\n+    def __init__(self, context, request, name="schema", title=None):\n         self.schema = context\n         self.request = request\n \n@@ -32,19 +31,16 @@ def __init__(self, context, request, name=u\'schema\', title=None):\n         self.Title = lambda: title\n \n     def publishTraverse(self, request, name):\n-        """ Look up the field whose name matches the next URL path element,\n+        """Look up the field whose name matches the next URL path element,\n         and wrap it.\n         """\n         try:\n             return FieldContext(self.schema[name], self.request).__of__(self)\n         except KeyError:\n-            return DefaultPublishTraverse(self, request).publishTraverse(\n-                request,\n-                name\n-            )\n+            return DefaultPublishTraverse(self, request).publishTraverse(request, name)\n \n     def browserDefault(self, request):\n-        """ If not traversing through the schema to a field,\n+        """If not traversing through the schema to a field,\n         show the SchemaListingPage.\n         """\n-        return self, (\'@@edit\',)\n+        return self, ("@@edit",)\ndiff --git a/plone/schemaeditor/fields.py b/plone/schemaeditor/fields.py\nindex 4cb2f3a..a6c00f4 100644\n--- a/plone/schemaeditor/fields.py\n+++ b/plone/schemaeditor/fields.py\n@@ -1,7 +1,6 @@\n-# -*- coding: utf-8 -*-\n-from plone.schemaeditor import schema as se_schema\n from plone.schemaeditor import _\n from plone.schemaeditor import interfaces\n+from plone.schemaeditor import schema as se_schema\n from plone.schemaeditor.interfaces import IFieldFactory\n from z3c.form import validator\n from zope import component\n@@ -23,14 +22,15 @@\n @interface.implementer(interfaces.IFieldEditFormSchema)\n @component.adapter(schema_ifaces.IField)\n def getFirstFieldSchema(field):\n-    return [s for s in field.__provides__.__iro__ if\n-            s.isOrExtends(schema_ifaces.IField)][0]\n+    return [\n+        s for s in field.__provides__.__iro__ if s.isOrExtends(schema_ifaces.IField)\n+    ][0]\n \n \n @implementer(IFieldFactory)\n-class FieldFactory(object):\n+class FieldFactory:\n \n-    title = u\'\'\n+    title = ""\n \n     def __init__(self, fieldcls, title, *args, **kw):\n         self.fieldcls = fieldcls\n@@ -44,15 +44,15 @@ def __call__(self, *args, **kw):\n         return self.fieldcls(*(self.args + args), **kwargs)\n \n     def available(self):\n-        """ field is addable in the current context """\n+        """field is addable in the current context"""\n         return True\n \n     def editable(self, field):\n-        """ test whether a given instance of a field is editable """\n+        """test whether a given instance of a field is editable"""\n         return True\n \n     def protected(self, field):\n-        """ test whether a given instance of a field is protected """\n+        """test whether a given instance of a field is protected"""\n         return False\n \n \n@@ -61,41 +61,40 @@ def FieldsVocabularyFactory(context):\n     field_factories = getUtilitiesFor(IFieldFactory)\n     allowedFields = getattr(context, "allowedFields", None)\n     if allowedFields is not None:\n-        field_factories = [(id, factory) for id, factory in field_factories\n-                           if id in allowedFields]\n+        field_factories = [\n+            (id, factory) for id, factory in field_factories if id in allowedFields\n+        ]\n     terms = []\n     for (field_id, factory) in field_factories:\n         terms.append(\n             SimpleVocabulary.createTerm(\n-                factory,\n-                factory.title,\n-                translate(factory.title, context=request)\n+                factory, factory.title, translate(factory.title, context=request)\n             )\n         )\n-    terms = sorted(terms, key=operator.attrgetter(\'title\'))\n+    terms = sorted(terms, key=operator.attrgetter("title"))\n     return SimpleVocabulary(terms)\n \n \n # TextLineFactory is the default. We need to set that here to avoid a\n # circular import.\n TextLineFactory = FieldFactory(\n-    schema.TextLine, _(u\'label_textline_field\', default=u\'Text line (String)\'))\n-interfaces.INewField[\'factory\'].__dict__[\'default\'] = TextLineFactory\n+    schema.TextLine, _("label_textline_field", default="Text line (String)")\n+)\n+interfaces.INewField["factory"].__dict__["default"] = TextLineFactory\n \n-TextFactory = FieldFactory(\n-    schema.Text, _(u\'label_text_field\', default=u\'Text\'))\n-IntFactory = FieldFactory(\n-    schema.Int, _(u\'label_integer_field\', default=u\'Integer\'))\n+TextFactory = FieldFactory(schema.Text, _("label_text_field", default="Text"))\n+IntFactory = FieldFactory(schema.Int, _("label_integer_field", default="Integer"))\n FloatFactory = FieldFactory(\n-    schema.Float, _(u\'label_float_field\', default=u\'Floating-point number\'))\n-BoolFactory = FieldFactory(\n-    schema.Bool, _(u\'label_boolean_field\', default=u\'Yes/No\'))\n+    schema.Float, _("label_float_field", default="Floating-point number")\n+)\n+BoolFactory = FieldFactory(schema.Bool, _("label_boolean_field", default="Yes/No"))\n PasswordFactory = FieldFactory(\n-    schema.Password, _(u\'label_password_field\', default=u\'Password\'))\n+    schema.Password, _("label_password_field", default="Password")\n+)\n DatetimeFactory = FieldFactory(\n-    schema.Datetime, _(u\'label_datetime_field\', default=u\'Date/Time\'))\n-DateFactory = FieldFactory(\n-    schema.Date, _(u\'label_date_field\', default=u\'Date\'))\n+    schema.Datetime, _("label_datetime_field", default="Date/Time")\n+)\n+DateFactory = FieldFactory(schema.Date, _("label_date_field", default="Date"))\n \n \n @interface.implementer(interfaces.IFieldEditFormSchema)\n@@ -105,136 +104,141 @@ def getChoiceFieldSchema(field):\n \n \n ChoiceFactory = FieldFactory(\n-    schema.Choice, _(u\'label_choice_field\', default=u\'Choice\'),\n-    values=[])\n+    schema.Choice, _("label_choice_field", default="Choice"), values=[]\n+)\n \n \n @interface.implementer(se_schema.ITextLineChoice)\n @component.adapter(schema_ifaces.IChoice)\n-class TextLineChoiceField(object):\n-\n+class TextLineChoiceField:\n     def __init__(self, field):\n-        self.__dict__[\'field\'] = field\n+        self.__dict__["field"] = field\n \n     def __getattr__(self, name):\n-        if name == \'values\':\n+        if name == "values":\n             values = []\n-            for term in (self.field.vocabulary or []):\n+            for term in self.field.vocabulary or []:\n                 if term.value != term.title:\n-                    values.append(u\'{0:s}|{1:s}\'.format(\n-                        term.value, term.title))\n+                    values.append(f"{term.value:s}|{term.title:s}")\n                 else:\n                     values.append(term.value)\n             return values\n \n-\n         return getattr(self.field, name)\n \n     def _constructVocabulary(self, value):\n         terms = []\n         if value:\n             for item in value:\n-                if item and u\'|\' in item:\n-                    voc_value, voc_title = item.split(u\'|\', 1)\n+                if item and "|" in item:\n+                    voc_value, voc_title = item.split("|", 1)\n                 else:\n                     voc_value = item\n                     voc_title = item\n \n                 term = vocabulary.SimpleTerm(\n-                    token=voc_value.encode(\'unicode_escape\'),\n-                    value=voc_value, title=voc_title)\n+                    token=voc_value.encode("unicode_escape"),\n+                    value=voc_value,\n+                    title=voc_title,\n+                )\n                 terms.append(term)\n \n         return vocabulary.SimpleVocabulary(terms)\n \n     def __setattr__(self, name, value):\n-        if name == \'values\' and value:\n+        if name == "values" and value:\n             vocab = self._constructVocabulary(value)\n-            return setattr(self.field, \'vocabulary\', vocab)\n-        elif name == \'values\' and not value:\n+            return setattr(self.field, "vocabulary", vocab)\n+        elif name == "values" and not value:\n             return\n \n-        if name == \'vocabularyName\' and value:\n-            setattr(self.field, \'values\', None)\n-            setattr(self.field, \'vocabulary\', None)\n-            return setattr(self.field, \'vocabularyName\', value)\n-        elif name == \'vocabularyName\' and not value:\n-            return setattr(self.field, \'vocabularyName\', None)\n+        if name == "vocabularyName" and value:\n+            setattr(self.field, "values", None)\n+            setattr(self.field, "vocabulary", None)\n+            return setattr(self.field, "vocabularyName", value)\n+        elif name == "vocabularyName" and not value:\n+            return setattr(self.field, "vocabularyName", None)\n \n         return setattr(self.field, name, value)\n \n     def __delattr__(self, name):\n-        if name == \'values\':\n+        if name == "values":\n             del self.field.vocabulary\n \n         return delattr(self.field, name)\n \n \n-@component.adapter(interface.Interface, interface.Interface,\n-                   interfaces.IFieldEditForm,\n-                   se_schema.ITextLinesField, interface.Interface)\n+@component.adapter(\n+    interface.Interface,\n+    interface.Interface,\n+    interfaces.IFieldEditForm,\n+    se_schema.ITextLinesField,\n+    interface.Interface,\n+)\n class VocabularyValuesValidator(validator.SimpleFieldValidator):\n \n-    """Ensure duplicate vocabulary terms are not submitted\n-    """\n+    """Ensure duplicate vocabulary terms are not submitted"""\n \n     def validate(self, values):\n         if values is None:\n-            return super(VocabularyValuesValidator, self).validate(\n-                values)\n+            return super().validate(values)\n \n         by_value = {}\n         by_token = {}\n         for value in values:\n-            term = vocabulary.SimpleTerm(token=value.encode(\'unicode_escape\'),\n-                                         value=value, title=value)\n+            term = vocabulary.SimpleTerm(\n+                token=value.encode("unicode_escape"), value=value, title=value\n+            )\n             if term.value in by_value:\n                 raise interface.Invalid(\n-                    _(\'field_edit_error_conflicting_values\',\n-                      default=u"The \'${value1}\' vocabulary value conflicts "\n-                              u"with \'${value2}\'.",\n-                      mapping={\'value1\': value,\n-                               \'value2\': by_value[term.value].value}))\n+                    _(\n+                        "field_edit_error_conflicting_values",\n+                        default="The \'${value1}\' vocabulary value conflicts "\n+                        "with \'${value2}\'.",\n+                        mapping={"value1": value, "value2": by_value[term.value].value},\n+                    )\n+                )\n \n             if term.token in by_token:\n                 raise interface.Invalid(\n-                    _(\'field_edit_error_conflicting_values\',\n-                      default=u"The \'${value1}\' vocabulary value conflicts "\n-                              u"with \'${value2}\'.",\n-                      mapping={\'value1\': value,\n-                               \'value2\': by_value[term.token].value}))\n+                    _(\n+                        "field_edit_error_conflicting_values",\n+                        default="The \'${value1}\' vocabulary value conflicts "\n+                        "with \'${value2}\'.",\n+                        mapping={"value1": value, "value2": by_value[term.token].value},\n+                    )\n+                )\n \n             by_value[term.value] = term\n             by_token[term.token] = term\n \n-        return super(VocabularyValuesValidator, self).validate(values)\n+        return super().validate(values)\n \n \n class VocabularyNameValidator(validator.SimpleFieldValidator):\n \n-    """Ensure user has not submitted a vocabulary values AND a factory\n-    """\n+    """Ensure user has not submitted a vocabulary values AND a factory"""\n \n     def validate(self, values):\n         if values is None:\n-            return super(VocabularyNameValidator, self).validate(\n-                values)\n+            return super().validate(values)\n \n-        if values and self.request.form.get(\'form.widgets.values\', None):\n+        if values and self.request.form.get("form.widgets.values", None):\n             raise interface.Invalid(\n-                _(\'field_edit_error_values_and_name\',\n-                  default=u\'You can not set a vocabulary name AND vocabulary \'\n-                          u\'values. Please clear values field or set no value \'\n-                          u\'here.\'\n-                  )\n+                _(\n+                    "field_edit_error_values_and_name",\n+                    default="You can not set a vocabulary name AND vocabulary "\n+                    "values. Please clear values field or set no value "\n+                    "here.",\n+                )\n             )\n \n-        return super(VocabularyNameValidator, self).validate(values)\n+        return super().validate(values)\n \n \n validator.WidgetValidatorDiscriminators(\n-    VocabularyNameValidator,\n-    field=se_schema.ITextLineChoice[\'vocabularyName\'])\n+    VocabularyNameValidator, field=se_schema.ITextLineChoice["vocabularyName"]\n+)\n \n \n @interface.implementer(interfaces.IFieldEditFormSchema)\n@@ -245,49 +249,47 @@ def getMultiChoiceFieldSchema(field):\n \n MultiChoiceFactory = FieldFactory(\n     schema.Set,\n-    _(u\'label_multi_choice_field\', default=u\'Multiple Choice\'),\n-    value_type=schema.Choice(values=[]))\n+    _("label_multi_choice_field", default="Multiple Choice"),\n+    value_type=schema.Choice(values=[]),\n+)\n \n \n @interface.implementer_only(se_schema.ITextLineChoice)\n @component.adapter(schema_ifaces.ISet)\n class TextLineMultiChoiceField(TextLineChoiceField):\n-\n     def __init__(self, field):\n-        self.__dict__[\'field\'] = field\n+        self.__dict__["field"] = field\n \n     def __getattr__(self, name):\n         field = self.field\n-        if name == \'values\':\n+        if name == "values":\n             values = []\n-            for term in (self.field.value_type.vocabulary or []):\n+            for term in self.field.value_type.vocabulary or []:\n                 if term.value != term.title:\n-                    values.append(u\'{0:s}|{1:s}\'.format(\n-                        term.value, term.title))\n+                    values.append(f"{term.value:s}|{term.title:s}")\n                 else:\n                     values.append(term.value)\n             return values\n-        elif name == \'vocabularyName\':\n-            return getattr(field.value_type, name, None) or \\\n-                   getattr(field, name)\n+        elif name == "vocabularyName":\n+            return getattr(field.value_type, name, None) or getattr(field, name)\n         else:\n             return getattr(field, name)\n \n     def __setattr__(self, name, value):\n-        if name == \'values\' and value:\n+        if name == "values" and value:\n             vocab = self._constructVocabulary(value)\n-            return setattr(self.field.value_type, \'vocabulary\', vocab)\n-        elif name == \'values\' and not value:\n+            return setattr(self.field.value_type, "vocabulary", vocab)\n+        elif name == "values" and not value:\n             return\n \n-        if name == \'vocabularyName\' and value:\n-            setattr(self.field.value_type, \'values\', None)\n-            setattr(self.field.value_type, \'vocabulary\', None)\n-            setattr(self.field.value_type, \'vocabularyName\', value)\n-            return setattr(self.field, \'vocabularyName\', value)\n-        elif name == \'vocabularyName\' and not value:\n-            setattr(self.field.value_type, \'vocabularyName\', None)\n-            return setattr(self.field, \'vocabularyName\', None)\n+        if name == "vocabularyName" and value:\n+            setattr(self.field.value_type, "values", None)\n+            setattr(self.field.value_type, "vocabulary", None)\n+            setattr(self.field.value_type, "vocabularyName", value)\n+            return setattr(self.field, "vocabularyName", value)\n+        elif name == "vocabularyName" and not value:\n+            setattr(self.field.value_type, "vocabularyName", None)\n+            return setattr(self.field, "vocabularyName", None)\n \n         return setattr(self.field, name, value)\n \n@@ -296,6 +298,6 @@ def __setattr__(self, name, value):\n @component.adapter(schema_ifaces.IBool, IObjectAddedEvent)\n def setBoolWidget(field, event):\n     schema = field.interface\n-    widgets = schema.queryTaggedValue(\'plone.autoform.widgets\', {})\n-    widgets[field.__name__] = \'z3c.form.browser.radio.RadioFieldWidget\'\n-    schema.setTaggedValue(\'plone.autoform.widgets\', widgets)\n+    widgets = schema.queryTaggedValue("plone.autoform.widgets", {})\n+    widgets[field.__name__] = "z3c.form.browser.radio.RadioFieldWidget"\n+    schema.setTaggedValue("plone.autoform.widgets", widgets)\ndiff --git a/plone/schemaeditor/interfaces.py b/plone/schemaeditor/interfaces.py\nindex 43470b5..f7d17bd 100644\n--- a/plone/schemaeditor/interfaces.py\n+++ b/plone/schemaeditor/interfaces.py\n@@ -1,13 +1,12 @@\n-# -*- coding: utf-8 -*-\n from OFS.interfaces import IItem\n from plone.schemaeditor import _\n from z3c.form.interfaces import IEditForm\n-from zope.interface.interfaces import IObjectEvent\n from zope.interface import Invalid\n from zope.interface import invariant\n from zope.interface.interfaces import Attribute\n from zope.interface.interfaces import IInterface\n from zope.interface.interfaces import Interface\n+from zope.interface.interfaces import IObjectEvent\n from zope.publisher.interfaces.browser import IBrowserPage\n from zope.schema import ASCIILine\n from zope.schema import Bool\n@@ -22,89 +21,76 @@\n \n \n class ISchemaView(IBrowserPage):\n-    """ A publishable view of a zope 3 schema\n-    """\n+    """A publishable view of a zope 3 schema"""\n \n \n class ISchemaContext(IItem):\n-    """ A publishable wrapper of a zope 3 schema\n-    """\n+    """A publishable wrapper of a zope 3 schema"""\n \n-    schema = Object(\n-        schema=IInterface\n-    )\n+    schema = Object(schema=IInterface)\n \n-    schemaEditorView = Attribute(\n-        """Name of the schema editor view. Optional.""")\n+    schemaEditorView = Attribute("""Name of the schema editor view. Optional.""")\n \n-    additionalSchemata = Attribute(\n-        """Additional schemas that may modify this one.""")\n+    additionalSchemata = Attribute("""Additional schemas that may modify this one.""")\n \n     allowedFields = Attribute(\n         """List of field factory ids that may be added to this schema.\n         Or None to allow all fields.\n-        """)\n+        """\n+    )\n \n     fieldsWhichCannotBeDeleted = Attribute(\n         """List of field names that may not be deleted from this schema."""\n     )\n \n-    enableFieldsets = Attribute(\n-        """Enable extra fieldsets."""\n-    )\n+    enableFieldsets = Attribute("""Enable extra fieldsets.""")\n \n \n class ISchemaModifiedEvent(IObjectEvent):\n \n-    object = Object(\n-        schema=ISchemaContext\n-    )\n+    object = Object(schema=ISchemaContext)\n \n \n class IFieldContext(IItem):\n-    """ A publishable wrapper of a zope 3 schema field\n-    """\n+    """A publishable wrapper of a zope 3 schema field"""\n \n-    field = Object(\n-        schema=IField\n-    )\n+    field = Object(schema=IField)\n \n \n class IFieldEditorExtender(IInterface):\n-    """ An additional schema for use when editing a field."""\n+    """An additional schema for use when editing a field."""\n \n \n class IFieldFactory(IField):\n-    """ A component that instantiates a field when called."""\n-    title = TextLine(title=u\'Title\')\n+    """A component that instantiates a field when called."""\n+\n+    title = TextLine(title="Title")\n \n     def available(self):\n-        """ field is addable in the current context """\n+        """field is addable in the current context"""\n \n     def editable(self, field):\n-        """ test whether a given instance of a field is editable """\n+        """test whether a given instance of a field is editable"""\n \n     def protected(self, field):\n-        """ test whether a given instance of a field is protected """\n+        """test whether a given instance of a field is protected"""\n \n \n class IEditableSchema(Interface):\n-    """ Interface for adding/removing fields to/from a schema.\n-    """\n+    """Interface for adding/removing fields to/from a schema."""\n \n     def addField(field, name=None):\n-        """ Add a field to a schema\n+        """Add a field to a schema\n \n         If not provided, the field\'s name will be taken from its __name__\n         attribute.\n         """\n \n     def removeField(field_name):\n-        """ Remove a field from a schema\n-        """\n+        """Remove a field from a schema"""\n \n     def moveField(field_name, new_pos):\n-        """ Move a field to the (new_pos)th position in the schema\'s sort \xc3\xa7\n+        """Move a field to the (new_pos)th position in the schema\'s sort \xc3\xa7\n         order (indexed beginning at 0).\n \n         Schema fields are assigned an \'order\' attribute that increments for\n@@ -120,71 +106,67 @@ def changeFieldFieldset(field_name, next_fieldset):\n \n \n class IFieldEditForm(IEditForm):\n-    """ Marker interface for field edit forms\n-    """\n+    """Marker interface for field edit forms"""\n \n \n class IFieldEditFormSchema(Interface):\n-    """ The schema describing the form fields for a field.\n-    """\n+    """The schema describing the form fields for a field."""\n \n \n RESERVED_NAMES = (\n-    \'subject\',\n-    \'format\',\n-    \'language\',\n-    \'creators\',\n-    \'contributors\',\n-    \'rights\',\n-    \'effective_date\',\n-    \'expiration_date\',\n+    "subject",\n+    "format",\n+    "language",\n+    "creators",\n+    "contributors",\n+    "rights",\n+    "effective_date",\n+    "expiration_date",\n )\n \n # a letter followed by letters, numbers, or underscore\n-ID_RE = re.compile(r\'^[a-z][\\w\\d\\.]*$\')\n+ID_RE = re.compile(r"^[a-z][\\w\\d\\.]*$")\n \n \n def isValidFieldName(value):\n     if not ID_RE.match(value):\n         raise Invalid(\n-            _(u\'Please start with a lowercase letter and after this use only letters, \'\n-              u\'numbers and the following characters: _.\')\n+            _(\n+                "Please start with a lowercase letter and after this use only letters, "\n+                "numbers and the following characters: _."\n+            )\n         )\n     if value in RESERVED_NAMES:\n-        raise Invalid(\n-            _(u"\'${name}\' is a reserved field name.", mapping={\'name\': value}))\n+        raise Invalid(_("\'${name}\' is a reserved field name.", mapping={"name": value}))\n     return True\n \n \n class INewField(Interface):\n \n     fieldset_id = Int(\n-        title=_(u\'Fieldset ID\'),\n-        description=_(u\'Used to decide where to put this field.\'),\n+        title=_("Fieldset ID"),\n+        description=_("Used to decide where to put this field."),\n         required=True,\n     )\n \n-    title = TextLine(\n-        title=_(u\'Title\'),\n-        required=True\n-    )\n+    title = TextLine(title=_("Title"), required=True)\n \n     __name__ = ASCIILine(\n-        title=_(u\'Short Name\'),\n-        description=_(u\'Used for programmatic access to the field.\'),\n+        title=_("Short Name"),\n+        description=_("Used for programmatic access to the field."),\n         required=True,\n         constraint=isValidFieldName,\n     )\n \n     description = Text(\n-        title=_(u\'Help Text\'),\n-        description=_(u\'Shows up in the form as help text for the field.\'),\n-        required=False\n+        title=_("Help Text"),\n+        description=_("Shows up in the form as help text for the field."),\n+        required=False,\n     )\n \n     factory = Choice(\n-        title=_(u\'Field type\'),\n-        vocabulary=\'Fields\',\n+        title=_("Field type"),\n+        vocabulary="Fields",\n         required=True,\n         # This can\'t be done yet or we\'ll create circular import problem.\n         # So it will be injected from fields.py\n@@ -192,10 +174,8 @@ class INewField(Interface):\n     )\n \n     required = Bool(\n-        title=_(u\'Required field\'),\n-        description=_(\n-            u\'Check this box if you want this field to be required.\'\n-        ),\n+        title=_("Required field"),\n+        description=_("Check this box if you want this field to be required."),\n         default=False,\n         required=False,\n     )\n@@ -203,33 +183,23 @@ class INewField(Interface):\n     @invariant\n     def checkTitleAndDescriptionTypes(data):\n         if data.__name__ is not None and data.factory is not None:\n-            if data.__name__ == \'title\' and \\\n-                    data.factory.fieldcls is not TextLine:\n+            if data.__name__ == "title" and data.factory.fieldcls is not TextLine:\n                 raise Invalid(\n-                    _(u"The \'title\' field must be a Text line (string) field.")\n-                )\n-            if data.__name__ == \'description\' and \\\n-                    data.factory.fieldcls is not Text:\n-                raise Invalid(\n-                    _(u"The \'description\' field must be a Text field.")\n+                    _("The \'title\' field must be a Text line (string) field.")\n                 )\n+            if data.__name__ == "description" and data.factory.fieldcls is not Text:\n+                raise Invalid(_("The \'description\' field must be a Text field."))\n \n \n class INewFieldset(Interface):\n \n-    label = TextLine(\n-        title=_(u\'Title\'),\n-        required=True\n-    )\n+    label = TextLine(title=_("Title"), required=True)\n \n     __name__ = ASCIILine(\n-        title=_(u\'Short Name\'),\n-        description=_(u\'Used for programmatic access to the fieldset.\'),\n+        title=_("Short Name"),\n+        description=_("Used for programmatic access to the fieldset."),\n         required=True,\n         constraint=isValidFieldName,\n     )\n \n-    description = Text(\n-        title=_(u\'Description\'),\n-        required=False\n-    )\n+    description = Text(title=_("Description"), required=False)\ndiff --git a/plone/schemaeditor/schema.py b/plone/schemaeditor/schema.py\nindex d289f94..c4d1e58 100644\n--- a/plone/schemaeditor/schema.py\n+++ b/plone/schemaeditor/schema.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.z3cform.interfaces import IDateField\n from plone.app.z3cform.interfaces import IDatetimeField\n from plone.schemaeditor import _\n@@ -8,11 +7,12 @@\n \n \n # get rid of unhelpful help text\n-interfaces.IMinMaxLen[\'min_length\'].description = u\'\'\n-interfaces.IMinMaxLen[\'max_length\'].description = u\'\'\n+interfaces.IMinMaxLen["min_length"].description = ""\n+interfaces.IMinMaxLen["max_length"].description = ""\n \n # now fix up some of the schemas with missing details\n \n+\n class IBool(interfaces.IBool, interfaces.IFromUnicode):\n     pass\n \n@@ -20,45 +20,45 @@ class IBool(interfaces.IBool, interfaces.IFromUnicode):\n class IFloat(interfaces.IFloat, interfaces.IFromUnicode):\n \n     min = schema.Float(\n-        title=interfaces.IFloat[\'min\'].title,\n-        required=interfaces.IFloat[\'min\'].required,\n-        default=interfaces.IFloat[\'min\'].default,\n+        title=interfaces.IFloat["min"].title,\n+        required=interfaces.IFloat["min"].required,\n+        default=interfaces.IFloat["min"].default,\n     )\n \n     max = schema.Float(\n-        title=interfaces.IFloat[\'max\'].title,\n-        required=interfaces.IFloat[\'max\'].required,\n-        default=interfaces.IFloat[\'max\'].default,\n+        title=interfaces.IFloat["max"].title,\n+        required=interfaces.IFloat["max"].required,\n+        default=interfaces.IFloat["max"].default,\n     )\n \n \n class IDatetime(IDatetimeField):\n \n     min = schema.Datetime(\n-        title=interfaces.IDatetime[\'min\'].title,\n-        required=interfaces.IDatetime[\'min\'].required,\n-        default=interfaces.IDatetime[\'min\'].default,\n+        title=interfaces.IDatetime["min"].title,\n+        required=interfaces.IDatetime["min"].required,\n+        default=interfaces.IDatetime["min"].default,\n     )\n \n     max = schema.Datetime(\n-        title=interfaces.IDatetime[\'max\'].title,\n-        required=interfaces.IDatetime[\'max\'].required,\n-        default=interfaces.IDatetime[\'max\'].default,\n+        title=interfaces.IDatetime["max"].title,\n+        required=interfaces.IDatetime["max"].required,\n+        default=interfaces.IDatetime["max"].default,\n     )\n \n \n class IDate(IDateField):\n \n     min = schema.Date(\n-        title=interfaces.IDate[\'min\'].title,\n-        required=interfaces.IDate[\'min\'].required,\n-        default=interfaces.IDate[\'min\'].default,\n+        title=interfaces.IDate["min"].title,\n+        required=interfaces.IDate["min"].required,\n+        default=interfaces.IDate["min"].default,\n     )\n \n     max = schema.Date(\n-        title=interfaces.IDate[\'max\'].title,\n-        required=interfaces.IDate[\'max\'].required,\n-        default=interfaces.IDate[\'max\'].default,\n+        title=interfaces.IDate["max"].title,\n+        required=interfaces.IDate["max"].required,\n+        default=interfaces.IDate["max"].default,\n     )\n \n \n@@ -74,17 +74,18 @@ class ITextLinesField(interfaces.IList):\n class ITextLineChoice(interfaces.IField):\n \n     values = schema.List(\n-        title=_(u\'Possible values\'),\n-        description=_(u\'Enter allowed choices one per line.\'),\n-        required=interfaces.IChoice[\'vocabulary\'].required,\n-        default=interfaces.IChoice[\'vocabulary\'].default,\n-        value_type=schema.TextLine())\n+        title=_("Possible values"),\n+        description=_("Enter allowed choices one per line."),\n+        required=interfaces.IChoice["vocabulary"].required,\n+        default=interfaces.IChoice["vocabulary"].default,\n+        value_type=schema.TextLine(),\n+    )\n     alsoProvides(values, ITextLinesField)\n \n     vocabularyName = schema.Choice(\n-        title=interfaces.IChoice[\'vocabularyName\'].title,\n-        description=interfaces.IChoice[\'vocabularyName\'].description,\n-        default=interfaces.IChoice[\'vocabularyName\'].default,\n+        title=interfaces.IChoice["vocabularyName"].title,\n+        description=interfaces.IChoice["vocabularyName"].description,\n+        default=interfaces.IChoice["vocabularyName"].default,\n         required=False,\n-        vocabulary=\'plone.schemaeditor.VocabulariesVocabulary\',\n+        vocabulary="plone.schemaeditor.VocabulariesVocabulary",\n     )\ndiff --git a/plone/schemaeditor/testing.py b/plone/schemaeditor/testing.py\nindex 432a4f3..266c380 100644\n--- a/plone/schemaeditor/testing.py\n+++ b/plone/schemaeditor/testing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """Base module for unittesting."""\n from plone.app.robotframework.testing import AUTOLOGIN_LIBRARY_FIXTURE\n from plone.app.testing import FunctionalTesting\n@@ -9,11 +8,11 @@\n \n class PloneSchemaeditorRobotLayer(PloneSandboxLayer):\n \n-    defaultBases = (PLONE_FIXTURE, )\n+    defaultBases = (PLONE_FIXTURE,)\n \n \n FIXTURE = PloneSchemaeditorRobotLayer(\n-    name=\'ROBOT\',\n+    name="ROBOT",\n )\n \n \n@@ -23,5 +22,5 @@ class PloneSchemaeditorRobotLayer(PloneSandboxLayer):\n         AUTOLOGIN_LIBRARY_FIXTURE,\n         z2.ZSERVER_FIXTURE,\n     ),\n-    name=\'ACCEPTANCE\'\n+    name="ACCEPTANCE",\n )\ndiff --git a/plone/schemaeditor/tests/fixtures.py b/plone/schemaeditor/tests/fixtures.py\nindex 5585818..6ac95fa 100644\n--- a/plone/schemaeditor/tests/fixtures.py\n+++ b/plone/schemaeditor/tests/fixtures.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.schemaeditor.browser.schema.traversal import SchemaContext\n from plone.supermodel import model\n from plone.z3cform import layout\n@@ -11,7 +10,7 @@\n \n class IDummySchema(Interface):\n \n-    model.fieldset(\'alpha\', fields=[\'fieldA\'])\n+    model.fieldset("alpha", fields=["fieldA"])\n \n     field1 = schema.TextLine()\n     field2 = schema.TextLine()\n@@ -22,17 +21,17 @@ class IDummySchema(Interface):\n \n \n class DummySchemaContext(SchemaContext):\n-\n     def __init__(self, context, request):\n-        super(DummySchemaContext, self).__init__(\n-            IDummySchema, request, name=\'@@schemaeditor\')\n+        super().__init__(IDummySchema, request, name="@@schemaeditor")\n \n \n def log_event(object, event):\n-    print(\'[event: {0} on {1}]\'.format(\n-        event.__class__.__name__,\n-        object.__class__.__name__,\n-    ))       # noqa\n+    print(\n+        "[event: {} on {}]".format(\n+            event.__class__.__name__,\n+            object.__class__.__name__,\n+        )\n+    )  # noqa\n \n \n class EditForm(EditForm):\n@@ -42,43 +41,36 @@ class EditForm(EditForm):\n \n     def update(self):\n         self.fields = field.Fields(IDummySchema)\n-        super(EditForm, self).update()\n+        super().update()\n \n \n EditView = layout.wrap_form(EditForm)\n \n \n-class BaseVocabulary(object):\n-\n+class BaseVocabulary:\n     def __call__(self, context):\n-        terms = [SimpleVocabulary.createTerm(\n-            value,\n-            value,\n-            label)\n-            for value, label in self.values_list]\n+        terms = [\n+            SimpleVocabulary.createTerm(value, value, label)\n+            for value, label in self.values_list\n+        ]\n         return SimpleVocabulary(terms)\n \n \n class CountriesVocabulary(BaseVocabulary):\n \n-    values_list = [(\'fr\', u\'France\'),\n-                   (\'uk\', u\'United Kingdom\'),\n-                   (\'es\', u\'Spain\')]\n+    values_list = [("fr", "France"), ("uk", "United Kingdom"), ("es", "Spain")]\n \n \n class CategoriesVocabulary(BaseVocabulary):\n \n-    values_list = [(\'php\', u\'PHP\'),\n-                   (\'c\', u\'C\'),\n-                   (\'ruby\', u\'Ruby\')]\n-\n+    values_list = [("php", "PHP"), ("c", "C"), ("ruby", "Ruby")]\n \n-class DummyKeyring(object):\n \n+class DummyKeyring:\n     def random(self):\n-        return \'a\'\n+        return "a"\n \n \n DummyKeyManager = {\n-    u\'_forms\': DummyKeyring(),\n+    "_forms": DummyKeyring(),\n }\ndiff --git a/plone/schemaeditor/tests/test_fields.py b/plone/schemaeditor/tests/test_fields.py\nindex cbd9057..a1886ce 100644\n--- a/plone/schemaeditor/tests/test_fields.py\n+++ b/plone/schemaeditor/tests/test_fields.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.testing import PLONE_FIXTURE\n from plone.schemaeditor.fields import TextLineChoiceField\n from plone.schemaeditor.fields import TextLineMultiChoiceField\n@@ -7,8 +6,8 @@\n import unittest\n \n \n-class DummyField(object):\n-    """ Dummy field """\n+class DummyField:\n+    """Dummy field"""\n \n     def __init__(self):\n         self.value_type = self\n@@ -22,33 +21,22 @@ class VocabularyTestCase(unittest.TestCase):\n \n     def assertVocabulary(self, voc, values):\n         self.assertTrue(IVocabularyTokenized.providedBy(voc))\n-        self.assertEqual(\n-            [(term.value, term.token, term.title) for term in voc],\n-            values\n-        )\n+        self.assertEqual([(term.value, term.token, term.title) for term in voc], values)\n \n     def test_singlechoice_voc(self):\n         field = TextLineChoiceField(DummyField())\n-        field.values = [u\'New York\', u\'city2|M\xc3\xbcnchen\']\n-        self.assertEqual(\n-            field.values,\n-            [u\'New York\', u\'city2|M\xc3\xbcnchen\']\n-        )\n+        field.values = ["New York", "city2|M\xc3\xbcnchen"]\n+        self.assertEqual(field.values, ["New York", "city2|M\xc3\xbcnchen"])\n         self.assertVocabulary(\n             field.vocabulary,\n-            [(u\'New York\', u\'New York\', u\'New York\'),\n-             (u\'city2\', u\'city2\', u\'M\xc3\xbcnchen\')]\n-          )\n+            [("New York", "New York", "New York"), ("city2", "city2", "M\xc3\xbcnchen")],\n+        )\n \n     def test_multichoice_voc(self):\n         field = TextLineMultiChoiceField(DummyField())\n-        field.values = [u\'New York\', u\'city1|Z\xc3\xbcrich\']\n-        self.assertEqual(\n-            field.values,\n-            [u\'New York\', u\'city1|Z\xc3\xbcrich\']\n-        )\n+        field.values = ["New York", "city1|Z\xc3\xbcrich"]\n+        self.assertEqual(field.values, ["New York", "city1|Z\xc3\xbcrich"])\n         self.assertVocabulary(\n             field.vocabulary,\n-            [(u\'New York\', u\'New York\', u\'New York\'),\n-             (u\'city1\', u\'city1\', u\'Z\xc3\xbcrich\')]\n-            )\n+            [("New York", "New York", "New York"), ("city1", "city1", "Z\xc3\xbcrich")],\n+        )\ndiff --git a/plone/schemaeditor/tests/test_robot.py b/plone/schemaeditor/tests/test_robot.py\nindex 8c0dbd4..14749ea 100644\n--- a/plone/schemaeditor/tests/test_robot.py\n+++ b/plone/schemaeditor/tests/test_robot.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.testing import ROBOT_TEST_LEVEL\n from plone.schemaeditor.testing import ACCEPTANCE\n from plone.testing import layered\n@@ -11,19 +10,18 @@\n def test_suite():\n     suite = unittest.TestSuite()\n     current_dir = os.path.abspath(os.path.dirname(__file__))\n-    robot_dir = os.path.join(current_dir, \'robot\')\n+    robot_dir = os.path.join(current_dir, "robot")\n     robot_tests = [\n-        os.path.join(\'robot\', doc) for doc in\n-        os.listdir(robot_dir) if doc.endswith(\'.robot\') and\n-        doc.startswith(\'test_\')\n+        os.path.join("robot", doc)\n+        for doc in os.listdir(robot_dir)\n+        if doc.endswith(".robot") and doc.startswith("test_")\n     ]\n     for robot_test in robot_tests:\n         robottestsuite = robotsuite.RobotTestSuite(robot_test)\n         robottestsuite.level = ROBOT_TEST_LEVEL\n-        suite.addTests([\n-            layered(\n-                robottestsuite,\n-                layer=ACCEPTANCE\n-            ),\n-        ])\n+        suite.addTests(\n+            [\n+                layered(robottestsuite, layer=ACCEPTANCE),\n+            ]\n+        )\n     return suite\ndiff --git a/plone/schemaeditor/tests/tests.py b/plone/schemaeditor/tests/tests.py\nindex e43aba1..e583158 100644\n--- a/plone/schemaeditor/tests/tests.py\n+++ b/plone/schemaeditor/tests/tests.py\n@@ -1,11 +1,10 @@\n-# -*- coding: utf-8 -*-\n from plone.z3cform.interfaces import IFormWrapper\n from plone.z3cform.templates import ZopeTwoFormTemplateFactory\n from Testing import ZopeTestCase as ztc\n+from Zope2.App import zcml\n from zope.interface import classImplements\n from zope.interface import implementedBy\n from zope.interface import Interface\n-from Zope2.App import zcml\n from ZPublisher.BaseRequest import BaseRequest\n \n import doctest\n@@ -16,16 +15,17 @@\n import unittest\n \n \n-optionflags = (doctest.ELLIPSIS |\n-               doctest.NORMALIZE_WHITESPACE |\n-               doctest.REPORT_ONLY_FIRST_FAILURE)\n+optionflags = (\n+    doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE | doctest.REPORT_ONLY_FIRST_FAILURE\n+)\n \n \n def setUp(self):\n     from Zope2.App.schema import configure_vocabulary_registry\n+\n     configure_vocabulary_registry()\n \n-    zcml.load_config(\'browser_testing.zcml\', plone.schemaeditor.tests)\n+    zcml.load_config("browser_testing.zcml", plone.schemaeditor.tests)\n \n     # add a test layer to the request so we can use special form templates\n     # that don\'t pull in main_template\n@@ -39,36 +39,35 @@ def tearDown(self):\n class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n         if six.PY2:\n-            want = re.sub(\'zExceptions.unauthorized.Unauthorized\', \'Unauthorized\', want)\n+            want = re.sub("zExceptions.unauthorized.Unauthorized", "Unauthorized", want)\n             got = re.sub("u\'(.*?)\'", "\'\\\\1\'", got)\n             want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \n def test_suite():\n-    return unittest.TestSuite([\n-\n-        ztc.FunctionalDocFileSuite(\n-            \'field_schemata.rst\',\n-            \'editing.rst\',\n-            \'extending.rst\',\n-            \'choice.rst\',\n-            \'minmax.rst\',\n-            setUp=setUp,\n-            tearDown=tearDown,\n-            optionflags=optionflags,\n-            checker=Py23DocChecker(),\n-        ),\n-\n-    ])\n+    return unittest.TestSuite(\n+        [\n+            ztc.FunctionalDocFileSuite(\n+                "field_schemata.rst",\n+                "editing.rst",\n+                "extending.rst",\n+                "choice.rst",\n+                "minmax.rst",\n+                setUp=setUp,\n+                tearDown=tearDown,\n+                optionflags=optionflags,\n+                checker=Py23DocChecker(),\n+            ),\n+        ]\n+    )\n \n \n class ITestLayer(Interface):\n     pass\n \n \n-class RenderWidget(object):\n-\n+class RenderWidget:\n     def __init__(self, widget, request):\n         self.widget = widget\n \n@@ -77,6 +76,7 @@ def __call__(self):\n \n \n layout_factory = ZopeTwoFormTemplateFactory(\n-    os.path.join(os.path.dirname(__file__), \'layout.pt\'),\n-    form=IFormWrapper, request=ITestLayer,\n+    os.path.join(os.path.dirname(__file__), "layout.pt"),\n+    form=IFormWrapper,\n+    request=ITestLayer,\n )\ndiff --git a/plone/schemaeditor/utils.py b/plone/schemaeditor/utils.py\nindex 61f6144..28c0023 100644\n--- a/plone/schemaeditor/utils.py\n+++ b/plone/schemaeditor/utils.py\n@@ -1,30 +1,36 @@\n-# -*- coding: utf-8 -*-\n from plone.schemaeditor.interfaces import IEditableSchema\n from plone.schemaeditor.interfaces import ISchemaModifiedEvent\n from plone.supermodel.interfaces import FIELDSETS_KEY\n from zope.component import adapter\n-from zope.interface.interfaces import ObjectEvent\n from zope.interface import implementer\n from zope.interface.interfaces import IInterface\n+from zope.interface.interfaces import ObjectEvent\n from zope.schema.interfaces import IField\n \n import pkg_resources\n \n+\n _zope_interface_version_major = int(\n-    pkg_resources.require(\'zope.interface\')[0].version.split(\'.\')[0]\n+    pkg_resources.require("zope.interface")[0].version.split(".")[0]\n )\n \n+\n def sortedFields(schema):\n-    """ Like getFieldsInOrder, but does not include fields from bases\n+    """Like getFieldsInOrder, but does not include fields from bases\n \n-        This is verbatim from plone.supermodel\'s utils.py but I didn\'t\n-        want to create a dependency.\n+    This is verbatim from plone.supermodel\'s utils.py but I didn\'t\n+    want to create a dependency.\n     """\n     fields = []\n     for name in schema.names(all=False):\n         field = schema[name]\n         if IField.providedBy(field):\n-            fields.append((name, field,))\n+            fields.append(\n+                (\n+                    name,\n+                    field,\n+                )\n+            )\n     fields.sort(key=lambda item: item[1].order)\n     return fields\n \n@@ -49,8 +55,7 @@ def get_field_fieldset(schema, field_name):\n \n \n def get_fieldset_from_index(schema, index):\n-    """Return a fieldset from a schema according to it\'s index.\n-    """\n+    """Return a fieldset from a schema according to it\'s index."""\n     index = int(index or 0) - 1\n     fieldsets = schema.queryTaggedValue(FIELDSETS_KEY, [])\n     return fieldsets[index] if index >= 0 else None\n@@ -85,11 +90,11 @@ def new_field_position(schema, fieldset_id=None, new_field=False):\n \n @implementer(IEditableSchema)\n @adapter(IInterface)\n-class EditableSchema(object):\n+class EditableSchema:\n \n-    """ Zope 3 schema adapter to allow addition/removal of schema fields\n+    """Zope 3 schema adapter to allow addition/removal of schema fields\n \n-        XXX this needs to be made threadsafe\n+    XXX this needs to be made threadsafe\n     """\n \n     def __init__(self, schema):\n@@ -102,7 +107,7 @@ def addField(self, field, name=None):\n \n         if name in self.schema._InterfaceClass__attrs:\n             raise ValueError(\n-                \'{0} schema already has a "{1}" field\'.format(\n+                \'{} schema already has a "{}" field\'.format(\n                     self.schema.__identifier__,\n                     name,\n                 )\n@@ -112,35 +117,34 @@ def addField(self, field, name=None):\n         if _zope_interface_version_major >= 5:\n             self.schema._v_attrs = None\n         else:\n-            if hasattr(self.schema, \'_v_attrs\'):\n+            if hasattr(self.schema, "_v_attrs"):\n                 self.schema._v_attrs[name] = field\n \n         field.interface = self.schema\n \n     def removeField(self, field_name):\n-        """ Remove a field\n-        """\n+        """Remove a field"""\n         try:\n             self.schema[field_name].interface = None\n             del self.schema._InterfaceClass__attrs[field_name]\n             if _zope_interface_version_major >= 5:\n                 self.schema._v_attrs = None\n             else:\n-                if hasattr(self.schema, \'_v_attrs\'):\n+                if hasattr(self.schema, "_v_attrs"):\n                     del self.schema._v_attrs[field_name]\n             for fieldset in self.schema.queryTaggedValue(FIELDSETS_KEY, []):\n                 if field_name in fieldset.fields:\n                     fieldset.fields.remove(field_name)\n         except KeyError:\n             raise ValueError(\n-                \'{0} schema has no "{1}" field\'.format(\n+                \'{} schema has no "{}" field\'.format(\n                     self.schema.__identifier__,\n                     field_name,\n                 )\n             )\n \n     def moveField(self, field_name, new_pos):\n-        """ Move a field to the (new_pos)th position in the schema\'s sort\n+        """Move a field to the (new_pos)th position in the schema\'s sort\n         order (indexed beginning at 0).\n \n         Schema fields are assigned an \'order\' attribute that increments for\n@@ -149,18 +153,16 @@ def moveField(self, field_name, new_pos):\n         unique.\n         """\n         moving_field = self.schema[field_name]\n-        ordered_field_ids = [\n-            name for (name, field) in sortedFields(self.schema)]\n+        ordered_field_ids = [name for (name, field) in sortedFields(self.schema)]\n \n         # make sure this is sane\n         if not isinstance(new_pos, int):\n-            raise IndexError(\'The new field position must be an integer.\')\n+            raise IndexError("The new field position must be an integer.")\n         if new_pos < 0:\n-            raise IndexError(\'The new field position must be greater than 0.\')\n+            raise IndexError("The new field position must be greater than 0.")\n         if new_pos >= len(ordered_field_ids):\n             raise IndexError(\n-                \'The new field position must be less than the number of \'\n-                \'fields.\'\n+                "The new field position must be less than the number of " "fields."\n             )\n \n         # determine which fields we have to update the order attribute on\n@@ -176,14 +178,12 @@ def moveField(self, field_name, new_pos):\n                 slice_end = None\n             intervening_fields = [\n                 self.schema[field_id]\n-                for field_id\n-                in ordered_field_ids[cur_pos - 1:slice_end:-1]\n+                for field_id in ordered_field_ids[cur_pos - 1 : slice_end : -1]\n             ]\n         elif new_pos > cur_pos:\n             intervening_fields = [\n                 self.schema[field_id]\n-                for field_id\n-                in ordered_field_ids[cur_pos + 1:new_pos + 1]\n+                for field_id in ordered_field_ids[cur_pos + 1 : new_pos + 1]\n             ]\n \n         # do a little dance\n@@ -198,8 +198,9 @@ def moveField(self, field_name, new_pos):\n         fieldset = get_field_fieldset(self.schema, field_name)\n         if fieldset is not None:\n             ordered_field_ids = [info[0] for info in sortedFields(self.schema)]\n-            fieldset.fields = sorted(fieldset.fields,\n-                                     key=lambda x: ordered_field_ids.index(x))\n+            fieldset.fields = sorted(\n+                fieldset.fields, key=lambda x: ordered_field_ids.index(x)\n+            )\n \n     def changeFieldFieldset(self, field_name, next_fieldset):\n         """Move a field from a fieldset to another,\n@@ -221,9 +222,8 @@ class SchemaModifiedEvent(ObjectEvent):\n \n \n class FieldModifiedEvent(SchemaModifiedEvent):\n-\n     def __init__(self, obj, field):\n-        super(FieldModifiedEvent, self).__init__(obj)\n+        super().__init__(obj)\n         self.field = field\n \n \ndiff --git a/plone/schemaeditor/vocabularies.py b/plone/schemaeditor/vocabularies.py\nindex 6b41040..45ebc37 100644\n--- a/plone/schemaeditor/vocabularies.py\n+++ b/plone/schemaeditor/vocabularies.py\n@@ -1,23 +1,20 @@\n-# -*- coding: utf-8 -*-\n from zope.component import getUtilitiesFor\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n \n-class VocabulariesVocabulary(object):\n+class VocabulariesVocabulary:\n \n-    """Vocabulary for a list of available vocabulary factories\n-    """\n+    """Vocabulary for a list of available vocabulary factories"""\n \n     def __call__(self, context):\n         terms = []\n         for name, vocabulary in getUtilitiesFor(IVocabularyFactory):\n-            doc = (vocabulary.__doc__ or \'\').strip().split(\'\\n\')\n-            doc = [l.strip() for l in doc if l.strip()]\n+            doc = (vocabulary.__doc__ or "").strip().split("\\n")\n+            doc = [item.strip() for item in doc if item.strip()]\n             if len(doc) > 0:\n-                terms.append(\n-                    SimpleTerm(name, name, \'{0} - {1}\'.format(name, doc[0])))\n+                terms.append(SimpleTerm(name, name, f"{name} - {doc[0]}"))\n             else:\n                 terms.append(SimpleTerm(name, name, name))\n \ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..0f96c85 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,24 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "internal"\n+name = "Internal:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "documentation"\n+name = "Documentation:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "tests"\n+name = "Tests"\n+showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\ndiff --git a/setup.cfg b/setup.cfg\nindex 526aeb2..8849fbc 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,2 +1,23 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [bdist_wheel]\n universal = 0\n+\n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n+\n+[check-manifest]\n+ignore =\n+    .editorconfig\n+    .meta.toml\n+    tox.ini\n+    lint-requirements.txt\ndiff --git a/setup.py b/setup.py\nindex 12d920e..058bc2d 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,16 +1,14 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n \n-version = \'4.0.1.dev0\'\n+version = "4.0.1.dev0"\n \n setup(\n-    name=\'plone.schemaeditor\',\n+    name="plone.schemaeditor",\n     version=version,\n     description="Provides through-the-web editing of a zope schema/interface.",\n-    long_description=open("README.rst").read() + "\\n" +\n-    open("CHANGES.rst").read(),\n+    long_description=open("README.rst").read() + "\\n" + open("CHANGES.rst").read(),\n     classifiers=[\n         "Development Status :: 6 - Mature",\n         "Framework :: Zope",\n@@ -26,35 +24,37 @@\n         "Topic :: Software Development :: Libraries :: Python Modules",\n         "License :: OSI Approved :: BSD License",\n     ],\n-    keywords=\'plone schema ttw\',\n-    author=\'David Glick\',\n-    author_email=\'dglick@gmail.com\',\n-    url=\'https://github.com/plone/plone.schemaeditor\',\n-    license=\'BSD\',\n+    keywords="plone schema ttw",\n+    author="David Glick",\n+    author_email="dglick@gmail.com",\n+    url="https://github.com/plone/plone.schemaeditor",\n+    license="BSD",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'Zope\',\n-        \'zope.cachedescriptors\',\n-        \'zope.component\',\n-        \'zope.container\',\n-        \'zope.globalrequest\',\n-        \'zope.interface\',\n-        \'zope.lifecycleevent\',\n-        \'zope.schema\',\n-        \'zope.publisher\',\n-        \'z3c.form\',\n-        \'plone.z3cform\',\n-        \'plone.app.z3cform\',\n-        \'plone.autoform\',\n+        "setuptools",\n+        "six",\n+        "Zope",\n+        "zope.cachedescriptors",\n+        "zope.component",\n+        "zope.container",\n+        "zope.globalrequest",\n+        "zope.interface",\n+        "zope.lifecycleevent",\n+        "zope.schema",\n+        "zope.publisher",\n+        "z3c.form",\n+        "plone.z3cform",\n+        "plone.app.z3cform",\n+        "plone.autoform",\n     ],\n-    extras_require={\'test\': [\n-        \'plone.app.dexterity\',\n-        \'plone.app.testing\',\n-        \'plone.app.robotframework\',\n-    ]},\n+    extras_require={\n+        "test": [\n+            "plone.app.dexterity",\n+            "plone.app.testing",\n+            "plone.app.robotframework",\n+        ]\n+    },\n )\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..5d1a605\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[tox]\n+envlist =\n+    format\n+    lint\n+\n+[testenv]\n+py_files = git ls-files "*.py"\n+text_files = git ls-files "*.rst" "*.md"\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat python code\n+skip_install = true\n+deps =\n+    pyupgrade\n+    isort\n+    black\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'{[testenv]py_files} | xargs pyupgrade --py38-plus\'\n+    sh -c \'{[testenv]py_files} | xargs isort\'\n+    sh -c \'{[testenv]py_files} | xargs black\'\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    flake8\n+    codespell\n+    check-manifest\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'{[testenv]py_files} | xargs flake8\'\n+    sh -c \'{[testenv]py_files} | xargs codespell\'\n+    sh -c \'{[testenv]text_files} | xargs codespell\'\n+    check-manifest\n'

