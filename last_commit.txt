Repository: plone.session


Branch: refs/heads/master
Date: 2022-03-30T19:18:35+03:00
Author: David Batranu (david-batranu) <david.batranu@eaudeweb.ro>
Commit: https://github.com/plone/plone.session/commit/d6c7d5aae7ca491d09ffc95f9983f6529778c0de

[refs #22] Per-user keyrings, session invalidation

Generate a Keyring for each user id, this makes it possible to
invalidate the keyring on logout, meaning other user sessions using
the same authentication token will become invalid.

This protects against session stealing (copying the __ac cookie) and
creates a working server-side log-out.

Files changed:
M plone/session/plugins/session.py

b'diff --git a/plone/session/plugins/session.py b/plone/session/plugins/session.py\nindex 963d6a5..d24fde3 100644\n--- a/plone/session/plugins/session.py\n+++ b/plone/session/plugins/session.py\n@@ -5,6 +5,7 @@\n from App.config import getConfiguration\n from email.utils import formatdate\n from plone.keyring.interfaces import IKeyManager\n+from plone.keyring.keyring import Keyring\n from plone.session import tktauth\n from plone.session.interfaces import ISessionPlugin\n from Products.PageTemplates.PageTemplateFile import PageTemplateFile\n@@ -73,6 +74,7 @@ class SessionPlugin(BasePlugin):\n     external_ticket_name = \'ticket\'\n     secure = False\n     _shared_secret = None\n+    secret_prefix = "_plone.session_"\n \n     # These mod_auth_tkt options are not yet implemented (by intent)\n     # ignoreIP = True # you always want this on the public internet\n@@ -138,16 +140,23 @@ def __init__(self, id, title=None, path="/"):\n         self.title = title\n         self.path = path\n \n-    def _getSigningSecret(self):\n+    def _getSecretKey(self, userid):\n+        return "{}{}".format(self.secret_prefix, userid)\n+\n+    def _getSigningSecret(self, userid):\n         if self._shared_secret is not None:\n             return self._shared_secret\n         manager = getUtility(IKeyManager)\n-        return manager.secret()\n+        secret_key = self._getSecretKey(userid)\n+        if secret_key not in manager:\n+            manager[secret_key] = Keyring(1)\n+            manager[secret_key].fill()\n+        return manager.secret(ring=secret_key)\n \n     # ISessionPlugin implementation\n     def _setupSession(self, userid, response, tokens=(), user_data=\'\'):\n         cookie = tktauth.createTicket(\n-            secret=self._getSigningSecret(),\n+            secret=self._getSigningSecret(userid),\n             userid=userid,\n             tokens=tokens,\n             user_data=user_data,\n@@ -186,7 +195,6 @@ def extractCredentials(self, request):\n             return creds\n \n         creds["source"] = "plone.session"  # XXX should this be the id?\n-\n         return creds\n \n     # IAuthenticationPlugin implementation\n@@ -208,8 +216,11 @@ def authenticateCredentials(self, credentials):\n         return (info[\'id\'], info[\'login\'])\n \n     def _validateTicket(self, ticket, now=None):\n+        _, userid, _, _, _ = tktauth.splitTicket(ticket)\n+\n         if now is None:\n             now = time.time()\n+\n         if self._shared_secret is not None:\n             ticket_data = tktauth.validateTicket(\n                 self._shared_secret,\n@@ -223,7 +234,14 @@ def _validateTicket(self, ticket, now=None):\n             manager = queryUtility(IKeyManager)\n             if manager is None:\n                 return None\n-            for secret in manager[u"_system"]:\n+\n+            secret_key = self._getSecretKey(userid)\n+            if secret_key in manager:\n+                secrets = manager[secret_key]\n+            else:\n+                secrets = manager[u"_system"]\n+\n+            for secret in secrets:\n                 if secret is None:\n                     continue\n                 ticket_data = tktauth.validateTicket(\n@@ -259,6 +277,13 @@ def updateCredentials(self, request, response, login, new_password):\n \n     # ICredentialsResetPlugin implementation\n     def resetCredentials(self, request, response):\n+        ticket = binascii.a2b_base64(request.get(self.cookie_name))\n+        _, userid, _, _, _ = tktauth.splitTicket(ticket)\n+        secret_key = self._getSecretKey(userid)\n+        manager = getUtility(IKeyManager)\n+        if manager[secret_key]:\n+            manager.clear(ring=secret_key)\n+            manager.rotate(ring=secret_key)\n         response = self.REQUEST["RESPONSE"]\n         if self.cookie_domain:\n             response.expireCookie(\n@@ -275,8 +300,10 @@ def manage_clearSecrets(self, REQUEST):\n         sessions and requires users to login again.\n         """\n         manager = getUtility(IKeyManager)\n-        manager.clear()\n-        manager.rotate()\n+        for ring in manager:\n+            if ring.startswith(self.secret_prefix) or ring == "_system":\n+                manager.clear(ring=ring)\n+                manager.rotate(ring=ring)\n         response = REQUEST.response\n         response.redirect(\n             \'%s/manage_secret?manage_tabs_message=%s\' %\n@@ -289,7 +316,9 @@ def manage_createNewSecret(self, REQUEST):\n         """Create a new (signing) secret.\n         """\n         manager = getUtility(IKeyManager)\n-        manager.rotate()\n+        for ring in manager:\n+            if ring.startswith(self.secret_prefix) or ring == "_system":\n+                manager.rotate(ring=ring)\n         response = REQUEST.response\n         response.redirect(\n             \'%s/manage_secret?manage_tabs_message=%s\' %\n'

Repository: plone.session


Branch: refs/heads/master
Date: 2022-04-01T12:05:48+03:00
Author: David Batranu (david-batranu) <david.batranu@eaudeweb.ro>
Commit: https://github.com/plone/plone.session/commit/f453ce9dcb7a146fa265f569b8f0ccb5eaa231d7

[refs #22] Adding news, tests, optionally enable.

Files changed:
A news/26.feature.txt
M plone/session/plugins/secret.pt
M plone/session/plugins/session.py
M plone/session/tests/testPAS.py

b'diff --git a/news/26.feature.txt b/news/26.feature.txt\nnew file mode 100644\nindex 0000000..1699107\n--- /dev/null\n+++ b/news/26.feature.txt\n@@ -0,0 +1 @@\n+Creating per-user keyrings in order to have session invalidation on log-out (server-side logout). [david-batranu]\n\\ No newline at end of file\ndiff --git a/plone/session/plugins/secret.pt b/plone/session/plugins/secret.pt\nindex 0d9dc51..0f37379 100644\n--- a/plone/session/plugins/secret.pt\n+++ b/plone/session/plugins/secret.pt\n@@ -73,6 +73,9 @@ By clicking the button below you clear all secrets used to validate sessions.\n This will immediately log out all users who use session authentication and\n require them to log in again.\n </p>\n+<p tal:condition="context/per_user_keyring">\n+In addition to the system keyring each user keyring will also be invalidated (since per-user keyrings are enabled).\n+</p>\n <form method="post" action="." tal:attributes="action string:${context/absolute_url}">\n     <input type="submit" name="manage_clearSecrets:method" value="Clear secrets"/>\n     <input tal:replace="structure context/@@authenticator/authenticator" />\n@@ -89,5 +92,22 @@ were five secrets present.\n     <input tal:replace="structure context/@@authenticator/authenticator" />\n </form>\n \n+<h4>Use per-user keyrings (server-side logout)<span tal:condition="context/per_user_keyring">(enabled)</span></h4>\n+<p>\n+By clicking the button below a separate keyring will be created for each user when\n+they login. The keyring will be cleared and regenerated when the user logs out,\n+thus invalidating their session cookie, making it impossible to re-use a previous cookie.\n+Per-user keyrings use a single secret.\n+</p>\n+<p>\n+Users that have an active, valid session will still be able to use it (system keyring) until it expires.\n+They will then switch to their own keyring when they log in again.\n+</p>\n+<form method="post" action="." tal:attributes="action string:${context/absolute_url}">\n+    <input type="submit" name="manage_togglePerUserKeyring:method"\n+        tal:attributes="value python:test(context.per_user_keyring, \'Disable per-user keyrings\', \'Enable per-user keyrings\')"/>\n+    <input tal:replace="structure context/@@authenticator/authenticator" />\n+</form>\n+\n \n <h1 tal:replace="structure here/manage_page_footer"> PAGE FOOTER </h1>\ndiff --git a/plone/session/plugins/session.py b/plone/session/plugins/session.py\nindex d24fde3..66731f0 100644\n--- a/plone/session/plugins/session.py\n+++ b/plone/session/plugins/session.py\n@@ -8,6 +8,7 @@\n from plone.keyring.keyring import Keyring\n from plone.session import tktauth\n from plone.session.interfaces import ISessionPlugin\n+from plone.protect.interfaces import IDisableCSRFProtection\n from Products.PageTemplates.PageTemplateFile import PageTemplateFile\n from Products.PluggableAuthService.interfaces.plugins import IAuthenticationPlugin  # noqa\n from Products.PluggableAuthService.interfaces.plugins import ICredentialsResetPlugin  # noqa\n@@ -18,6 +19,7 @@\n from zope.component import getUtility\n from zope.component import queryUtility\n from zope.interface import implementer\n+from zope.interface import alsoProvides\n \n import binascii\n import time\n@@ -75,6 +77,7 @@ class SessionPlugin(BasePlugin):\n     secure = False\n     _shared_secret = None\n     secret_prefix = "_plone.session_"\n+    per_user_keyring = False\n \n     # These mod_auth_tkt options are not yet implemented (by intent)\n     # ignoreIP = True # you always want this on the public internet\n@@ -129,6 +132,16 @@ class SessionPlugin(BasePlugin):\n             "type": "boolean",\n             "mode": "w",\n         },\n+        {\n+            "id": "per_user_keyring",\n+            "label": (\n+                "Create a keyring for each user. "\n+                "Enables server-side logout."\n+                "Toggle this from the \\"Manage secrets\\" tab."\n+            ),\n+            "type": "boolean",\n+            "mode": "r",\n+        },\n     )\n \n     manage_options = (\n@@ -147,11 +160,15 @@ def _getSigningSecret(self, userid):\n         if self._shared_secret is not None:\n             return self._shared_secret\n         manager = getUtility(IKeyManager)\n-        secret_key = self._getSecretKey(userid)\n-        if secret_key not in manager:\n-            manager[secret_key] = Keyring(1)\n-            manager[secret_key].fill()\n-        return manager.secret(ring=secret_key)\n+        if self.per_user_keyring:\n+            # Setup a new keyring for the logged-in user.\n+            # This will be invalidated on logout.\n+            secret_key = self._getSecretKey(userid)\n+            if secret_key not in manager:\n+                manager[secret_key] = Keyring(1)\n+                manager[secret_key].fill()\n+            return manager.secret(ring=secret_key)\n+        return manager.secret()\n \n     # ISessionPlugin implementation\n     def _setupSession(self, userid, response, tokens=(), user_data=\'\'):\n@@ -277,13 +294,23 @@ def updateCredentials(self, request, response, login, new_password):\n \n     # ICredentialsResetPlugin implementation\n     def resetCredentials(self, request, response):\n-        ticket = binascii.a2b_base64(request.get(self.cookie_name))\n-        _, userid, _, _, _ = tktauth.splitTicket(ticket)\n-        secret_key = self._getSecretKey(userid)\n-        manager = getUtility(IKeyManager)\n-        if manager[secret_key]:\n-            manager.clear(ring=secret_key)\n-            manager.rotate(ring=secret_key)\n+        if self.per_user_keyring:\n+            # Prevent plone.protect from redirecting to @@confirm-action\n+            # instead of logging-out.\n+            # Caused by invalidating the user keyring.\n+            alsoProvides(request, IDisableCSRFProtection)\n+            # Sometimes (found during testing) the __ac cookie is not\n+            # set by this plugin, and fails the base64 decode.\n+            # Using extractCredentials again as it safely gets the decoded\n+            # cookie.\n+            creds = self.extractCredentials(request)\n+            if "cookie" in creds:\n+                _, userid, _, _, _ = tktauth.splitTicket(creds["cookie"])\n+                secret_key = self._getSecretKey(userid)\n+                manager = getUtility(IKeyManager)\n+                if manager[secret_key]:\n+                    manager.clear(ring=secret_key)\n+                    manager.rotate(ring=secret_key)\n         response = self.REQUEST["RESPONSE"]\n         if self.cookie_domain:\n             response.expireCookie(\n@@ -325,6 +352,19 @@ def manage_createNewSecret(self, REQUEST):\n             (self.absolute_url(), \'New+secret+created.\')\n         )\n \n+    @security.protected(ManageUsers)\n+    @postonly\n+    def manage_togglePerUserKeyring(self, REQUEST):\n+        """Toggle per-user keyrings.\n+        """\n+        self.per_user_keyring = not self.per_user_keyring\n+        response = REQUEST.response\n+        action = "enabled" if self.per_user_keyring else "disabled"\n+        response.redirect(\n+            \'%s/manage_secret?manage_tabs_message=%s\' %\n+            (self.absolute_url(), \'Per-user+keyrings+%s.\' % (action, ))\n+        )\n+\n     @security.protected(ManageUsers)\n     def haveSharedSecret(self):\n         return self._shared_secret is not None\ndiff --git a/plone/session/tests/testPAS.py b/plone/session/tests/testPAS.py\nindex ce94e17..5fee972 100644\n--- a/plone/session/tests/testPAS.py\n+++ b/plone/session/tests/testPAS.py\n@@ -161,3 +161,44 @@ def testSpecialCharUserid(self):\n         # This step would fail.\n         session._setupSession(unicode_userid, response)\n \n+    def testCookieInvalidAfterLogout(self):\n+        response = MockResponse()\n+        session = self.folder.pas.session\n+        session.per_user_keyring = True\n+        session._setupSession(self.userid, response)\n+\n+        cookie = response.cookie\n+        request = self.makeRequest(cookie)\n+\n+        creds = session.extractCredentials(request)\n+        auth = session._validateTicket(creds["cookie"])\n+        self.assertIsNotNone(auth)\n+\n+        logout()\n+        session.resetCredentials(request, response)\n+\n+        creds = session.extractCredentials(request)\n+        auth = session._validateTicket(creds["cookie"])\n+        self.assertIsNone(auth)\n+\n+    def testCookieValidAfterLogout(self):\n+        """Disable per-user keyrings and test that the session\n+        is still valid after logout (the usual Plone behavior)."""\n+        response = MockResponse()\n+        session = self.folder.pas.session\n+        session.per_user_keyring = False\n+        session._setupSession(self.userid, response)\n+\n+        cookie = response.cookie\n+        request = self.makeRequest(cookie)\n+\n+        creds = session.extractCredentials(request)\n+        auth = session._validateTicket(creds["cookie"])\n+        self.assertIsNotNone(auth)\n+\n+        logout()\n+        session.resetCredentials(request, response)\n+\n+        creds = session.extractCredentials(request)\n+        auth = session._validateTicket(creds["cookie"])\n+        self.assertIsNotNone(auth)\n\\ No newline at end of file\n'

Repository: plone.session


Branch: refs/heads/master
Date: 2022-05-02T12:12:50+03:00
Author: David Batranu (david-batranu) <david.batranu@eaudeweb.ro>
Commit: https://github.com/plone/plone.session/commit/4114ee09283879dcc3e6f0cd5210d07c119f8a6b

[refs #22] Trying to remove IDisableCSRFProtection

Tests now pass without IDisableCSRFProtection, unknown why.

Files changed:
M plone/session/plugins/session.py

b'diff --git a/plone/session/plugins/session.py b/plone/session/plugins/session.py\nindex 66731f0..64a585a 100644\n--- a/plone/session/plugins/session.py\n+++ b/plone/session/plugins/session.py\n@@ -8,7 +8,6 @@\n from plone.keyring.keyring import Keyring\n from plone.session import tktauth\n from plone.session.interfaces import ISessionPlugin\n-from plone.protect.interfaces import IDisableCSRFProtection\n from Products.PageTemplates.PageTemplateFile import PageTemplateFile\n from Products.PluggableAuthService.interfaces.plugins import IAuthenticationPlugin  # noqa\n from Products.PluggableAuthService.interfaces.plugins import ICredentialsResetPlugin  # noqa\n@@ -295,10 +294,6 @@ def updateCredentials(self, request, response, login, new_password):\n     # ICredentialsResetPlugin implementation\n     def resetCredentials(self, request, response):\n         if self.per_user_keyring:\n-            # Prevent plone.protect from redirecting to @@confirm-action\n-            # instead of logging-out.\n-            # Caused by invalidating the user keyring.\n-            alsoProvides(request, IDisableCSRFProtection)\n             # Sometimes (found during testing) the __ac cookie is not\n             # set by this plugin, and fails the base64 decode.\n             # Using extractCredentials again as it safely gets the decoded\n'

Repository: plone.session


Branch: refs/heads/master
Date: 2022-08-24T15:37:03+02:00
Author: Maurits van Rees (mauritsvanrees) <m.van.rees@zestsoftware.nl>
Commit: https://github.com/plone/plone.session/commit/e10c43ab172026b9b90619ab5df68c2efb9389a2

Merge pull request #26 from david-batranu/22_per_user_secret

[fixes #22] Per-user keyrings, session invalidation

Files changed:
A news/26.feature.txt
M plone/session/plugins/secret.pt
M plone/session/plugins/session.py
M plone/session/tests/testPAS.py

b'diff --git a/news/26.feature.txt b/news/26.feature.txt\nnew file mode 100644\nindex 0000000..1699107\n--- /dev/null\n+++ b/news/26.feature.txt\n@@ -0,0 +1 @@\n+Creating per-user keyrings in order to have session invalidation on log-out (server-side logout). [david-batranu]\n\\ No newline at end of file\ndiff --git a/plone/session/plugins/secret.pt b/plone/session/plugins/secret.pt\nindex 0d9dc51..0f37379 100644\n--- a/plone/session/plugins/secret.pt\n+++ b/plone/session/plugins/secret.pt\n@@ -73,6 +73,9 @@ By clicking the button below you clear all secrets used to validate sessions.\n This will immediately log out all users who use session authentication and\n require them to log in again.\n </p>\n+<p tal:condition="context/per_user_keyring">\n+In addition to the system keyring each user keyring will also be invalidated (since per-user keyrings are enabled).\n+</p>\n <form method="post" action="." tal:attributes="action string:${context/absolute_url}">\n     <input type="submit" name="manage_clearSecrets:method" value="Clear secrets"/>\n     <input tal:replace="structure context/@@authenticator/authenticator" />\n@@ -89,5 +92,22 @@ were five secrets present.\n     <input tal:replace="structure context/@@authenticator/authenticator" />\n </form>\n \n+<h4>Use per-user keyrings (server-side logout)<span tal:condition="context/per_user_keyring">(enabled)</span></h4>\n+<p>\n+By clicking the button below a separate keyring will be created for each user when\n+they login. The keyring will be cleared and regenerated when the user logs out,\n+thus invalidating their session cookie, making it impossible to re-use a previous cookie.\n+Per-user keyrings use a single secret.\n+</p>\n+<p>\n+Users that have an active, valid session will still be able to use it (system keyring) until it expires.\n+They will then switch to their own keyring when they log in again.\n+</p>\n+<form method="post" action="." tal:attributes="action string:${context/absolute_url}">\n+    <input type="submit" name="manage_togglePerUserKeyring:method"\n+        tal:attributes="value python:test(context.per_user_keyring, \'Disable per-user keyrings\', \'Enable per-user keyrings\')"/>\n+    <input tal:replace="structure context/@@authenticator/authenticator" />\n+</form>\n+\n \n <h1 tal:replace="structure here/manage_page_footer"> PAGE FOOTER </h1>\ndiff --git a/plone/session/plugins/session.py b/plone/session/plugins/session.py\nindex e0858c3..1a6d474 100644\n--- a/plone/session/plugins/session.py\n+++ b/plone/session/plugins/session.py\n@@ -5,6 +5,7 @@\n from App.config import getConfiguration\n from email.utils import formatdate\n from plone.keyring.interfaces import IKeyManager\n+from plone.keyring.keyring import Keyring\n from plone.session import tktauth\n from plone.session.interfaces import ISessionPlugin\n from Products.PageTemplates.PageTemplateFile import PageTemplateFile\n@@ -17,6 +18,7 @@\n from zope.component import getUtility\n from zope.component import queryUtility\n from zope.interface import implementer\n+from zope.interface import alsoProvides\n \n import binascii\n import time\n@@ -73,6 +75,8 @@ class SessionPlugin(BasePlugin):\n     external_ticket_name = \'ticket\'\n     secure = False\n     _shared_secret = None\n+    secret_prefix = "_plone.session_"\n+    per_user_keyring = False\n \n     # These mod_auth_tkt options are not yet implemented (by intent)\n     # ignoreIP = True # you always want this on the public internet\n@@ -127,6 +131,16 @@ class SessionPlugin(BasePlugin):\n             "type": "boolean",\n             "mode": "w",\n         },\n+        {\n+            "id": "per_user_keyring",\n+            "label": (\n+                "Create a keyring for each user. "\n+                "Enables server-side logout."\n+                "Toggle this from the \\"Manage secrets\\" tab."\n+            ),\n+            "type": "boolean",\n+            "mode": "r",\n+        },\n     )\n \n     manage_options = (\n@@ -138,16 +152,27 @@ def __init__(self, id, title=None, path="/"):\n         self.title = title\n         self.path = path\n \n-    def _getSigningSecret(self):\n+    def _getSecretKey(self, userid):\n+        return "{}{}".format(self.secret_prefix, userid)\n+\n+    def _getSigningSecret(self, userid):\n         if self._shared_secret is not None:\n             return self._shared_secret\n         manager = getUtility(IKeyManager)\n+        if self.per_user_keyring:\n+            # Setup a new keyring for the logged-in user.\n+            # This will be invalidated on logout.\n+            secret_key = self._getSecretKey(userid)\n+            if secret_key not in manager:\n+                manager[secret_key] = Keyring(1)\n+                manager[secret_key].fill()\n+            return manager.secret(ring=secret_key)\n         return manager.secret()\n \n     # ISessionPlugin implementation\n     def _setupSession(self, userid, response, tokens=(), user_data=\'\'):\n         cookie = tktauth.createTicket(\n-            secret=self._getSigningSecret(),\n+            secret=self._getSigningSecret(userid),\n             userid=userid,\n             tokens=tokens,\n             user_data=user_data,\n@@ -186,7 +211,6 @@ def extractCredentials(self, request):\n             return creds\n \n         creds["source"] = "plone.session"  # XXX should this be the id?\n-\n         return creds\n \n     # IAuthenticationPlugin implementation\n@@ -208,8 +232,11 @@ def authenticateCredentials(self, credentials):\n         return (info[\'id\'], info[\'login\'])\n \n     def _validateTicket(self, ticket, now=None):\n+        _, userid, _, _, _ = tktauth.splitTicket(ticket)\n+\n         if now is None:\n             now = time.time()\n+\n         if self._shared_secret is not None:\n             ticket_data = tktauth.validateTicket(\n                 self._shared_secret,\n@@ -223,7 +250,14 @@ def _validateTicket(self, ticket, now=None):\n             manager = queryUtility(IKeyManager)\n             if manager is None:\n                 return None\n-            for secret in manager[u"_system"]:\n+\n+            secret_key = self._getSecretKey(userid)\n+            if secret_key in manager:\n+                secrets = manager[secret_key]\n+            else:\n+                secrets = manager[u"_system"]\n+\n+            for secret in secrets:\n                 if secret is None:\n                     continue\n                 ticket_data = tktauth.validateTicket(\n@@ -259,6 +293,19 @@ def updateCredentials(self, request, response, login, new_password):\n \n     # ICredentialsResetPlugin implementation\n     def resetCredentials(self, request, response):\n+        if self.per_user_keyring:\n+            # Sometimes (found during testing) the __ac cookie is not\n+            # set by this plugin, and fails the base64 decode.\n+            # Using extractCredentials again as it safely gets the decoded\n+            # cookie.\n+            creds = self.extractCredentials(request)\n+            if "cookie" in creds:\n+                _, userid, _, _, _ = tktauth.splitTicket(creds["cookie"])\n+                secret_key = self._getSecretKey(userid)\n+                manager = getUtility(IKeyManager)\n+                if manager[secret_key]:\n+                    manager.clear(ring=secret_key)\n+                    manager.rotate(ring=secret_key)\n         response = self.REQUEST["RESPONSE"]\n         if self.cookie_domain:\n             response.expireCookie(\n@@ -275,8 +322,10 @@ def manage_clearSecrets(self, REQUEST):\n         sessions and requires users to login again.\n         """\n         manager = getUtility(IKeyManager)\n-        manager.clear()\n-        manager.rotate()\n+        for ring in manager:\n+            if ring.startswith(self.secret_prefix) or ring == "_system":\n+                manager.clear(ring=ring)\n+                manager.rotate(ring=ring)\n         response = REQUEST.response\n         response.redirect(\n             \'%s/manage_secret?manage_tabs_message=%s\' %\n@@ -289,13 +338,28 @@ def manage_createNewSecret(self, REQUEST):\n         """Create a new (signing) secret.\n         """\n         manager = getUtility(IKeyManager)\n-        manager.rotate()\n+        for ring in manager:\n+            if ring.startswith(self.secret_prefix) or ring == "_system":\n+                manager.rotate(ring=ring)\n         response = REQUEST.response\n         response.redirect(\n             \'%s/manage_secret?manage_tabs_message=%s\' %\n             (self.absolute_url(), \'New+secret+created.\')\n         )\n \n+    @security.protected(ManageUsers)\n+    @postonly\n+    def manage_togglePerUserKeyring(self, REQUEST):\n+        """Toggle per-user keyrings.\n+        """\n+        self.per_user_keyring = not self.per_user_keyring\n+        response = REQUEST.response\n+        action = "enabled" if self.per_user_keyring else "disabled"\n+        response.redirect(\n+            \'%s/manage_secret?manage_tabs_message=%s\' %\n+            (self.absolute_url(), \'Per-user+keyrings+%s.\' % (action, ))\n+        )\n+\n     @security.protected(ManageUsers)\n     def haveSharedSecret(self):\n         return self._shared_secret is not None\ndiff --git a/plone/session/tests/testPAS.py b/plone/session/tests/testPAS.py\nindex 9734e40..57cd0b9 100644\n--- a/plone/session/tests/testPAS.py\n+++ b/plone/session/tests/testPAS.py\n@@ -168,3 +168,44 @@ def testSpecialCharUserid(self):\n         # This step would fail.\n         session._setupSession(unicode_userid, response)\n \n+    def testCookieInvalidAfterLogout(self):\n+        response = MockResponse()\n+        session = self.folder.pas.session\n+        session.per_user_keyring = True\n+        session._setupSession(self.userid, response)\n+\n+        cookie = response.cookie\n+        request = self.makeRequest(cookie)\n+\n+        creds = session.extractCredentials(request)\n+        auth = session._validateTicket(creds["cookie"])\n+        self.assertIsNotNone(auth)\n+\n+        logout()\n+        session.resetCredentials(request, response)\n+\n+        creds = session.extractCredentials(request)\n+        auth = session._validateTicket(creds["cookie"])\n+        self.assertIsNone(auth)\n+\n+    def testCookieValidAfterLogout(self):\n+        """Disable per-user keyrings and test that the session\n+        is still valid after logout (the usual Plone behavior)."""\n+        response = MockResponse()\n+        session = self.folder.pas.session\n+        session.per_user_keyring = False\n+        session._setupSession(self.userid, response)\n+\n+        cookie = response.cookie\n+        request = self.makeRequest(cookie)\n+\n+        creds = session.extractCredentials(request)\n+        auth = session._validateTicket(creds["cookie"])\n+        self.assertIsNotNone(auth)\n+\n+        logout()\n+        session.resetCredentials(request, response)\n+\n+        creds = session.extractCredentials(request)\n+        auth = session._validateTicket(creds["cookie"])\n+        self.assertIsNotNone(auth)\n\\ No newline at end of file\n'

