Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2017-02-06T07:07:53+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/Products.CMFEditions/commit/410c1cfb191186bc93538935225c43eaf727dff4

make tests run in Zope 4

Files changed:
M CHANGES.rst
M Products/CMFEditions/tests/test_IntegrationTests.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 4382b29..9c41f6d 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -14,7 +14,8 @@ New features:
 
 Bug fixes:
 
-- *add item here*
+- Make tests run in Zope 4 (includes some cleanup).
+  [pbauer]
 
 
 3.0 (2016-12-05)
diff --git a/Products/CMFEditions/tests/test_IntegrationTests.py b/Products/CMFEditions/tests/test_IntegrationTests.py
index 1ce69c1..ee74912 100644
--- a/Products/CMFEditions/tests/test_IntegrationTests.py
+++ b/Products/CMFEditions/tests/test_IntegrationTests.py
@@ -23,17 +23,17 @@
 """Top level integration tests (without UI)
 
 """
-import sys
-import imp
-
-import transaction
-
-from zope.interface.interface import InterfaceClass
-from zope.component.persistentregistry import PersistentComponents
-import ZODB.interfaces
-from ZODB import broken
+from AccessControl.rolemanager import _string_hash
 from Acquisition import aq_base
 from Products.CMFEditions.tests.base import CMFEditionsBaseTestCase
+from ZODB import broken
+from zope.component.persistentregistry import PersistentComponents
+from zope.interface.interface import InterfaceClass
+
+import ZODB.interfaces
+import imp
+import sys
+import transaction
 
 
 class TestIntegration(CMFEditionsBaseTestCase):
@@ -41,7 +41,7 @@ class TestIntegration(CMFEditionsBaseTestCase):
     def afterSetUp(self):
         # we need to have the Manager role to be able to add things
         # to the portal root
-        self.setRoles(['Manager',])
+        self.setRoles(['Manager', ])
 
         # add an additional user
         self.portal.acl_users.userFolderAddUser('reviewer', 'reviewer',
@@ -136,17 +136,18 @@ def test05_getHistory(self):
         # test some of the log entries"""
         h1 = history[1]
         self.assertEqual(h1.version_id, 1)
-        #self.assertEqual(h1.action, h1.ACTION_CHECKIN)
-        #self.assertEqual(h1.message, 'v2\nsecond line')
-        #self.failUnless(h1.user_id)
-        #self.assertEqual(h1.path, '/'.join(doc.getPhysicalPath()))
-        #self.failUnless(h1.timestamp)
+        # self.assertEqual(h1.action, h1.ACTION_CHECKIN)
+        # self.assertEqual(h1.message, 'v2\nsecond line')
+        # self.failUnless(h1.user_id)
+        # self.assertEqual(h1.path, '/'.join(doc.getPhysicalPath()))
+        # self.failUnless(h1.timestamp)
 
     def test06_retrieveSpecificVersion(self):
         portal_repo = self.portal.portal_repository
         doc = self.portal.doc
 
-        review_state = self.portal.portal_workflow.getInfoFor(doc, 'review_state')
+        review_state = self.portal.portal_workflow.getInfoFor(
+            doc, 'review_state')
 
         # store the work edition two times
         doc.setTitle("v1")
@@ -166,7 +167,8 @@ def test06_retrieveSpecificVersion(self):
 
         # since 1.0beta1 the workflows review state is saved to the
         # system metadata by a modifier.
-        self.assertEqual(retrieved_doc.sys_metadata["review_state"], review_state)
+        self.assertEqual(
+            retrieved_doc.sys_metadata["review_state"], review_state)
 
     def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):
         portal_repo = self.portal.portal_repository
@@ -177,7 +179,8 @@ def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):
         portal_repo.applyVersionControl(doc)
 
         # copy
-        self.portal.manage_pasteObjects(self.portal.manage_copyObjects(ids=['doc']))
+        self.portal.manage_pasteObjects(
+            self.portal.manage_copyObjects(ids=['doc']))
         copy = self.portal.copy_of_doc
 
         # the copy shall not have a history yet: that's correct
@@ -186,7 +189,7 @@ def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):
         # just to be sure the history is definitivels different
         self.failIfEqual(
             portal_historyidhandler.queryUid(doc),
-            portal_historyidhandler.queryUid(copy)) # may be None
+            portal_historyidhandler.queryUid(copy))  # may be None
 
     def test08_loopOverHistory(self):
         portal_repo = self.portal.portal_repository
@@ -221,8 +224,8 @@ def test09_retrieveAndRevertRetainWorkingCopiesWorkflowInfo(self):
 
         # ----- retrieve
         # check if retrieved object carries the working copies workflow info
-        retrieved_data = portal_repo.retrieve(doc, 0, preserve=['review_state',
-                                                      'workflow_history'])
+        retrieved_data = portal_repo.retrieve(
+            doc, 0, preserve=['review_state', 'workflow_history'])
         self.assertEqual(retrieved_data.object.review_state,
                          "fake rev state v2")
         self.assertEqual(retrieved_data.object.workflow_history[0],
@@ -332,13 +335,11 @@ def test11_versionAFolderishObjectThatTreatsChildrensAsInsideRefs(self):
         self.assertEqual(portal_historyidhandler.queryUid(doc1), orig_uid1)
         self.assertEqual(portal_historyidhandler.queryUid(doc2), orig_uid2)
 
-
     def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):
         portal_repo = self.portal.portal_repository
         doc = self.portal.doc
         perm = 'Access contents information'
-        roles = list(doc.valid_roles())
-        member_role = 'p0r%s' % roles.index('Member')
+        member_role = 'permission_%srole_%s' % (_string_hash(perm), _string_hash('Member'))
 
         doc.manage_permission(perm, ('Manager',), 0)
 
@@ -351,13 +352,13 @@ def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):
         settings = doc.permission_settings(perm)[0]
         self.failUnless(settings['acquire'])
         role_enabled = [r for r in settings['roles']
-                                        if r['name'] == member_role][0]
+                        if r['name'] == member_role][0]
         self.failUnless(role_enabled['checked'])
 
         # ----- retrieve
         # check if retrieved object carries the working copy's permissions
-        retrieved_data = portal_repo.retrieve(doc, 0,
-                        preserve=['_Access_contents_information_Permission'])
+        retrieved_data = portal_repo.retrieve(
+            doc, 0, preserve=['_Access_contents_information_Permission'])
         settings = retrieved_data.object.permission_settings(perm)[0]
         self.failUnless(settings['acquire'])
         role_enabled = [r for r in settings['roles']
@@ -372,7 +373,7 @@ def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):
         self.failUnless(role_enabled['checked'])
 
         # check if the preserved data is returned correctly
-        preserved = retrieved_data.preserved_data['_Access_contents_information_Permission']
+        preserved = retrieved_data.preserved_data['_Access_contents_information_Permission']  # noqa
         self.assertEqual(preserved, ('Manager',))
 
         # ----- revert
@@ -381,7 +382,7 @@ def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):
         settings = doc.permission_settings(perm)[0]
         self.failUnless(settings['acquire'])
         role_enabled = [r for r in settings['roles']
-                                        if r['name'] == member_role][0]
+                        if r['name'] == member_role][0]
         self.failUnless(role_enabled['checked'])
 
     def test13_revertUpdatesCatalog(self):
@@ -400,8 +401,8 @@ def test13_revertUpdatesCatalog(self):
         self.assertEqual(len(results), 1)
         self.assertEqual(results[0].getObject(), doc)
 
-        retrieved_data = portal_repo.retrieve(doc, 0,
-                        preserve=['_Access_contents_information_Permission'])
+        retrieved_data = portal_repo.retrieve(
+            doc, 0, preserve=['_Access_contents_information_Permission'])
         retrieved_doc = retrieved_data.object
         self.failUnless('Plain text' in retrieved_doc.getText())
         # Test that basic retrieval did not alter the catalog
@@ -602,8 +603,8 @@ def test16_revertInsideRefsUpdatesCatalog(self):
         self.assertEqual(len(results), 1)
         self.assertEqual(results[0].getObject(), doc)
 
-        retrieved_data = portal_repo.retrieve(fol, 0,
-                        preserve=['_Access_contents_information_Permission'])
+        retrieved_data = portal_repo.retrieve(
+            fol, 0, preserve=['_Access_contents_information_Permission'])
         retrieved_doc = retrieved_data.object.doc1
         self.assertEqual(retrieved_doc.Title(), 'v1 of doc1')
         # Test that basic retrieval did not alter the catalog
@@ -659,7 +660,7 @@ def test17_moveInsideRefThenRevertChangesUid(self):
         ret_folder = retrieved_data.object
         ret_doc = ret_folder.doc1
         self.failIf(portal_historyidhandler.queryUid(ret_doc) == orig_uid,
-                         "UIDs should not be equal, current value: %s"%orig_uid)
+                    "UIDs should not be equal, current value: %s" % orig_uid)
 
         # revert to original state, ensure that subobject changes are
         # reverted and that uid is changed
@@ -669,7 +670,7 @@ def test17_moveInsideRefThenRevertChangesUid(self):
 
         # check if reversion worked correctly
         self.failIf(portal_historyidhandler.queryUid(reverted_doc) == orig_uid,
-                         "UIDs should not be equal, current value: %s"%orig_uid)
+                    "UIDs should not be equal, current value: %s" % orig_uid)
 
     def test18_retrieveObjectWhichHasBeenReplaced(self):
         portal_repo = self.portal.portal_repository
@@ -686,7 +687,7 @@ def test18_retrieveObjectWhichHasBeenReplaced(self):
         portal_repo.applyVersionControl(doc2, comment='first save')
 
         transaction.savepoint(optimistic=True)
-        fol.manage_renameObjects(['doc1','doc2'],['doc1_renamed', 'doc1'])
+        fol.manage_renameObjects(['doc1', 'doc2'], ['doc1_renamed', 'doc1'])
 
         doc1 = fol.doc1_renamed
         doc2 = fol.doc1
@@ -733,7 +734,7 @@ def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolde
 
         fol.manage_delObjects(['doc1'])
         transaction.savepoint(optimistic=True)
-        fol.manage_renameObjects(['doc2'],['doc1'])
+        fol.manage_renameObjects(['doc2'], ['doc1'])
 
         doc2 = fol.doc1
 
@@ -788,7 +789,7 @@ def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(
 
         transaction.savepoint(optimistic=True)
         self.portal.manage_pasteObjects(fol.manage_cutObjects(['doc1']))
-        fol.manage_renameObjects(['doc2'],['doc1'])
+        fol.manage_renameObjects(['doc2'], ['doc1'])
 
         doc2 = fol.doc1
         doc1 = self.portal.doc1
@@ -846,7 +847,6 @@ def test21_DontLeaveDanglingCatalogEntriesWhenInvokingFactory(self):
 
         portal_repo.save(fol, comment='second save')
 
-
         retrieved_data = portal_repo.retrieve(fol, 0)
         ret_fol = retrieved_data.object
         self.assertEqual(ret_fol.objectIds(), ['doc1', 'doc2'])


Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2017-02-06T08:34:19+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFEditions/commit/c6d50424fc9d31953a6fc2fc741bea64f709a0e2

make it work in both, Zope2 2.13.* and Zope2 4.*

Files changed:
M Products/CMFEditions/tests/test_IntegrationTests.py

diff --git a/Products/CMFEditions/tests/test_IntegrationTests.py b/Products/CMFEditions/tests/test_IntegrationTests.py
index ee74912..c1ad5b6 100644
--- a/Products/CMFEditions/tests/test_IntegrationTests.py
+++ b/Products/CMFEditions/tests/test_IntegrationTests.py
@@ -23,7 +23,6 @@
 """Top level integration tests (without UI)
 
 """
-from AccessControl.rolemanager import _string_hash
 from Acquisition import aq_base
 from Products.CMFEditions.tests.base import CMFEditionsBaseTestCase
 from ZODB import broken
@@ -35,6 +34,12 @@
 import sys
 import transaction
 
+try:
+    from AccessControl.rolemanager import _string_hash
+    has_zope4 = True
+except ImportError:
+    has_zope4 = False
+
 
 class TestIntegration(CMFEditionsBaseTestCase):
 
@@ -339,7 +344,14 @@ def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):
         portal_repo = self.portal.portal_repository
         doc = self.portal.doc
         perm = 'Access contents information'
-        member_role = 'permission_%srole_%s' % (_string_hash(perm), _string_hash('Member'))
+        if has_zope4:
+            member_role = 'permission_{0}role_{1}'.format(
+                _string_hash(perm),
+                _string_hash('Member')
+            )
+        else:
+            roles = list(doc.valid_roles())
+            member_role = 'p0r{0}'.format(roles.index('Member'))
 
         doc.manage_permission(perm, ('Manager',), 0)
 
@@ -361,15 +373,19 @@ def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):
             doc, 0, preserve=['_Access_contents_information_Permission'])
         settings = retrieved_data.object.permission_settings(perm)[0]
         self.failUnless(settings['acquire'])
-        role_enabled = [r for r in settings['roles']
-                                        if r['name'] == member_role][0]
+        role_enabled = [
+            r for r in settings['roles']
+            if r['name'] == member_role
+        ][0]
         self.failUnless(role_enabled['checked'])
 
         # check that the working copy's permissions are unchanged
         settings = doc.permission_settings(perm)[0]
         self.failUnless(settings['acquire'])
-        role_enabled = [r for r in settings['roles']
-                                        if r['name'] == member_role][0]
+        role_enabled = [
+            r for r in settings['roles']
+            if r['name'] == member_role
+        ][0]
         self.failUnless(role_enabled['checked'])
 
         # check if the preserved data is returned correctly
@@ -610,7 +626,7 @@ def test16_revertInsideRefsUpdatesCatalog(self):
         # Test that basic retrieval did not alter the catalog
         results = cat(SearchableText='v1', )
         self.assertEqual(len(results), 0)
-        results = cat(SearchableText='v2',  portal_type='Document')
+        results = cat(SearchableText='v2', portal_type='Document')
         self.assertEqual(len(results), 1)
         self.assertEqual(results[0].getObject(), doc)
 
@@ -625,10 +641,11 @@ def test16_revertInsideRefsUpdatesCatalog(self):
         self.assertEqual(results[0].getObject().Title(), 'v1 of doc1')
 
     def test17_moveInsideRefThenRevertChangesUid(self):
-        # When an object is contained in an 'Inside references folder' and has been moved
-        # into another location, it should maintain its CMF Uid, if the folder is then
-        # reverted to a state where it contained the object (which now exists with the same
-        # uid in a different location), the uid of the reverted object should be changed.
+        # When an object is contained in an 'Inside references folder' and
+        # has been moved into another location, it should maintain its CMF Uid,
+        # if the folder is then reverted to a state where it contained the
+        # object (which now exists with the same uid in a different location),
+        # the uid of the reverted object should be changed.
         portal_repo = self.portal.portal_repository
         portal_historyidhandler = self.portal.portal_historyidhandler
         fol = self.portal.fol
@@ -708,12 +725,13 @@ def test18_retrieveObjectWhichHasBeenReplaced(self):
         self.assertEqual(rev_doc.getId(), 'doc1_renamed')
         self.assertEqual(rev_doc.Title(), 'v1 of doc1')
 
-    def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolder(self):
+    def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolder(self):  # noqa
         # disabled by gregweb/21-10-2006
         # reason: Needs concentrated and deeper look.
-        # --> Ideas exist, pleas contact us on the list if you like to work on that.
-        # I know one should not do that! But solving this would bring more risks
-        # into the 1.0final than leaving the bug to be solved afterwards.
+        # --> Ideas exist, pleas contact us on the list if you like to work
+        #     on that.
+        # I know one should not do that! But solving this would bring more
+        # risks into the 1.0final than leaving the bug to be solved afterwards.
         portal_repo = self.portal.portal_repository
         fol = self.portal.fol
         doc1 = fol.doc1
@@ -763,12 +781,13 @@ def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolde
         self.assertEqual(rev_doc2.getId(), 'doc2')
         self.assertEqual(rev_doc2.Title(), 'v1 of doc2')
 
-    def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(self):
+    def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(self):  # noqa
         # disabled by gregweb/21-10-2006
         # reason: Needs concentrated and deeper look.
-        # --> Ideas exist, pleas contact us on the list if you like to work on that.
-        # I know one should not do that! But solving this would bring more risks
-        # into the 1.0final than leaving the bug to be solved afterwards.
+        # --> Ideas exist, pleas contact us on the list if you like to work
+        #     on that.
+        # I know one should not do that! But solving this would bring more
+        # risks into the 1.0final than leaving the bug to be solved afterwards.
         portal_repo = self.portal.portal_repository
         fol = self.portal.fol
         doc1 = fol.doc1


Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2017-02-06T22:46:28+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFEditions/commit/a3b96edc05a42511e2d61f580a9aecf4b01e6281

Merge pull request #45 from plone/plonezope4

make tests run in Zope 4

Files changed:
M CHANGES.rst
M Products/CMFEditions/tests/test_IntegrationTests.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 4382b29..9c41f6d 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -14,7 +14,8 @@ New features:
 
 Bug fixes:
 
-- *add item here*
+- Make tests run in Zope 4 (includes some cleanup).
+  [pbauer]
 
 
 3.0 (2016-12-05)
diff --git a/Products/CMFEditions/tests/test_IntegrationTests.py b/Products/CMFEditions/tests/test_IntegrationTests.py
index 1ce69c1..c1ad5b6 100644
--- a/Products/CMFEditions/tests/test_IntegrationTests.py
+++ b/Products/CMFEditions/tests/test_IntegrationTests.py
@@ -23,17 +23,22 @@
 """Top level integration tests (without UI)
 
 """
-import sys
-import imp
+from Acquisition import aq_base
+from Products.CMFEditions.tests.base import CMFEditionsBaseTestCase
+from ZODB import broken
+from zope.component.persistentregistry import PersistentComponents
+from zope.interface.interface import InterfaceClass
 
+import ZODB.interfaces
+import imp
+import sys
 import transaction
 
-from zope.interface.interface import InterfaceClass
-from zope.component.persistentregistry import PersistentComponents
-import ZODB.interfaces
-from ZODB import broken
-from Acquisition import aq_base
-from Products.CMFEditions.tests.base import CMFEditionsBaseTestCase
+try:
+    from AccessControl.rolemanager import _string_hash
+    has_zope4 = True
+except ImportError:
+    has_zope4 = False
 
 
 class TestIntegration(CMFEditionsBaseTestCase):
@@ -41,7 +46,7 @@ class TestIntegration(CMFEditionsBaseTestCase):
     def afterSetUp(self):
         # we need to have the Manager role to be able to add things
         # to the portal root
-        self.setRoles(['Manager',])
+        self.setRoles(['Manager', ])
 
         # add an additional user
         self.portal.acl_users.userFolderAddUser('reviewer', 'reviewer',
@@ -136,17 +141,18 @@ def test05_getHistory(self):
         # test some of the log entries"""
         h1 = history[1]
         self.assertEqual(h1.version_id, 1)
-        #self.assertEqual(h1.action, h1.ACTION_CHECKIN)
-        #self.assertEqual(h1.message, 'v2\nsecond line')
-        #self.failUnless(h1.user_id)
-        #self.assertEqual(h1.path, '/'.join(doc.getPhysicalPath()))
-        #self.failUnless(h1.timestamp)
+        # self.assertEqual(h1.action, h1.ACTION_CHECKIN)
+        # self.assertEqual(h1.message, 'v2\nsecond line')
+        # self.failUnless(h1.user_id)
+        # self.assertEqual(h1.path, '/'.join(doc.getPhysicalPath()))
+        # self.failUnless(h1.timestamp)
 
     def test06_retrieveSpecificVersion(self):
         portal_repo = self.portal.portal_repository
         doc = self.portal.doc
 
-        review_state = self.portal.portal_workflow.getInfoFor(doc, 'review_state')
+        review_state = self.portal.portal_workflow.getInfoFor(
+            doc, 'review_state')
 
         # store the work edition two times
         doc.setTitle("v1")
@@ -166,7 +172,8 @@ def test06_retrieveSpecificVersion(self):
 
         # since 1.0beta1 the workflows review state is saved to the
         # system metadata by a modifier.
-        self.assertEqual(retrieved_doc.sys_metadata["review_state"], review_state)
+        self.assertEqual(
+            retrieved_doc.sys_metadata["review_state"], review_state)
 
     def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):
         portal_repo = self.portal.portal_repository
@@ -177,7 +184,8 @@ def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):
         portal_repo.applyVersionControl(doc)
 
         # copy
-        self.portal.manage_pasteObjects(self.portal.manage_copyObjects(ids=['doc']))
+        self.portal.manage_pasteObjects(
+            self.portal.manage_copyObjects(ids=['doc']))
         copy = self.portal.copy_of_doc
 
         # the copy shall not have a history yet: that's correct
@@ -186,7 +194,7 @@ def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):
         # just to be sure the history is definitivels different
         self.failIfEqual(
             portal_historyidhandler.queryUid(doc),
-            portal_historyidhandler.queryUid(copy)) # may be None
+            portal_historyidhandler.queryUid(copy))  # may be None
 
     def test08_loopOverHistory(self):
         portal_repo = self.portal.portal_repository
@@ -221,8 +229,8 @@ def test09_retrieveAndRevertRetainWorkingCopiesWorkflowInfo(self):
 
         # ----- retrieve
         # check if retrieved object carries the working copies workflow info
-        retrieved_data = portal_repo.retrieve(doc, 0, preserve=['review_state',
-                                                      'workflow_history'])
+        retrieved_data = portal_repo.retrieve(
+            doc, 0, preserve=['review_state', 'workflow_history'])
         self.assertEqual(retrieved_data.object.review_state,
                          "fake rev state v2")
         self.assertEqual(retrieved_data.object.workflow_history[0],
@@ -332,13 +340,18 @@ def test11_versionAFolderishObjectThatTreatsChildrensAsInsideRefs(self):
         self.assertEqual(portal_historyidhandler.queryUid(doc1), orig_uid1)
         self.assertEqual(portal_historyidhandler.queryUid(doc2), orig_uid2)
 
-
     def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):
         portal_repo = self.portal.portal_repository
         doc = self.portal.doc
         perm = 'Access contents information'
-        roles = list(doc.valid_roles())
-        member_role = 'p0r%s' % roles.index('Member')
+        if has_zope4:
+            member_role = 'permission_{0}role_{1}'.format(
+                _string_hash(perm),
+                _string_hash('Member')
+            )
+        else:
+            roles = list(doc.valid_roles())
+            member_role = 'p0r{0}'.format(roles.index('Member'))
 
         doc.manage_permission(perm, ('Manager',), 0)
 
@@ -351,28 +364,32 @@ def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):
         settings = doc.permission_settings(perm)[0]
         self.failUnless(settings['acquire'])
         role_enabled = [r for r in settings['roles']
-                                        if r['name'] == member_role][0]
+                        if r['name'] == member_role][0]
         self.failUnless(role_enabled['checked'])
 
         # ----- retrieve
         # check if retrieved object carries the working copy's permissions
-        retrieved_data = portal_repo.retrieve(doc, 0,
-                        preserve=['_Access_contents_information_Permission'])
+        retrieved_data = portal_repo.retrieve(
+            doc, 0, preserve=['_Access_contents_information_Permission'])
         settings = retrieved_data.object.permission_settings(perm)[0]
         self.failUnless(settings['acquire'])
-        role_enabled = [r for r in settings['roles']
-                                        if r['name'] == member_role][0]
+        role_enabled = [
+            r for r in settings['roles']
+            if r['name'] == member_role
+        ][0]
         self.failUnless(role_enabled['checked'])
 
         # check that the working copy's permissions are unchanged
         settings = doc.permission_settings(perm)[0]
         self.failUnless(settings['acquire'])
-        role_enabled = [r for r in settings['roles']
-                                        if r['name'] == member_role][0]
+        role_enabled = [
+            r for r in settings['roles']
+            if r['name'] == member_role
+        ][0]
         self.failUnless(role_enabled['checked'])
 
         # check if the preserved data is returned correctly
-        preserved = retrieved_data.preserved_data['_Access_contents_information_Permission']
+        preserved = retrieved_data.preserved_data['_Access_contents_information_Permission']  # noqa
         self.assertEqual(preserved, ('Manager',))
 
         # ----- revert
@@ -381,7 +398,7 @@ def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):
         settings = doc.permission_settings(perm)[0]
         self.failUnless(settings['acquire'])
         role_enabled = [r for r in settings['roles']
-                                        if r['name'] == member_role][0]
+                        if r['name'] == member_role][0]
         self.failUnless(role_enabled['checked'])
 
     def test13_revertUpdatesCatalog(self):
@@ -400,8 +417,8 @@ def test13_revertUpdatesCatalog(self):
         self.assertEqual(len(results), 1)
         self.assertEqual(results[0].getObject(), doc)
 
-        retrieved_data = portal_repo.retrieve(doc, 0,
-                        preserve=['_Access_contents_information_Permission'])
+        retrieved_data = portal_repo.retrieve(
+            doc, 0, preserve=['_Access_contents_information_Permission'])
         retrieved_doc = retrieved_data.object
         self.failUnless('Plain text' in retrieved_doc.getText())
         # Test that basic retrieval did not alter the catalog
@@ -602,14 +619,14 @@ def test16_revertInsideRefsUpdatesCatalog(self):
         self.assertEqual(len(results), 1)
         self.assertEqual(results[0].getObject(), doc)
 
-        retrieved_data = portal_repo.retrieve(fol, 0,
-                        preserve=['_Access_contents_information_Permission'])
+        retrieved_data = portal_repo.retrieve(
+            fol, 0, preserve=['_Access_contents_information_Permission'])
         retrieved_doc = retrieved_data.object.doc1
         self.assertEqual(retrieved_doc.Title(), 'v1 of doc1')
         # Test that basic retrieval did not alter the catalog
         results = cat(SearchableText='v1', )
         self.assertEqual(len(results), 0)
-        results = cat(SearchableText='v2',  portal_type='Document')
+        results = cat(SearchableText='v2', portal_type='Document')
         self.assertEqual(len(results), 1)
         self.assertEqual(results[0].getObject(), doc)
 
@@ -624,10 +641,11 @@ def test16_revertInsideRefsUpdatesCatalog(self):
         self.assertEqual(results[0].getObject().Title(), 'v1 of doc1')
 
     def test17_moveInsideRefThenRevertChangesUid(self):
-        # When an object is contained in an 'Inside references folder' and has been moved
-        # into another location, it should maintain its CMF Uid, if the folder is then
-        # reverted to a state where it contained the object (which now exists with the same
-        # uid in a different location), the uid of the reverted object should be changed.
+        # When an object is contained in an 'Inside references folder' and
+        # has been moved into another location, it should maintain its CMF Uid,
+        # if the folder is then reverted to a state where it contained the
+        # object (which now exists with the same uid in a different location),
+        # the uid of the reverted object should be changed.
         portal_repo = self.portal.portal_repository
         portal_historyidhandler = self.portal.portal_historyidhandler
         fol = self.portal.fol
@@ -659,7 +677,7 @@ def test17_moveInsideRefThenRevertChangesUid(self):
         ret_folder = retrieved_data.object
         ret_doc = ret_folder.doc1
         self.failIf(portal_historyidhandler.queryUid(ret_doc) == orig_uid,
-                         "UIDs should not be equal, current value: %s"%orig_uid)
+                    "UIDs should not be equal, current value: %s" % orig_uid)
 
         # revert to original state, ensure that subobject changes are
         # reverted and that uid is changed
@@ -669,7 +687,7 @@ def test17_moveInsideRefThenRevertChangesUid(self):
 
         # check if reversion worked correctly
         self.failIf(portal_historyidhandler.queryUid(reverted_doc) == orig_uid,
-                         "UIDs should not be equal, current value: %s"%orig_uid)
+                    "UIDs should not be equal, current value: %s" % orig_uid)
 
     def test18_retrieveObjectWhichHasBeenReplaced(self):
         portal_repo = self.portal.portal_repository
@@ -686,7 +704,7 @@ def test18_retrieveObjectWhichHasBeenReplaced(self):
         portal_repo.applyVersionControl(doc2, comment='first save')
 
         transaction.savepoint(optimistic=True)
-        fol.manage_renameObjects(['doc1','doc2'],['doc1_renamed', 'doc1'])
+        fol.manage_renameObjects(['doc1', 'doc2'], ['doc1_renamed', 'doc1'])
 
         doc1 = fol.doc1_renamed
         doc2 = fol.doc1
@@ -707,12 +725,13 @@ def test18_retrieveObjectWhichHasBeenReplaced(self):
         self.assertEqual(rev_doc.getId(), 'doc1_renamed')
         self.assertEqual(rev_doc.Title(), 'v1 of doc1')
 
-    def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolder(self):
+    def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolder(self):  # noqa
         # disabled by gregweb/21-10-2006
         # reason: Needs concentrated and deeper look.
-        # --> Ideas exist, pleas contact us on the list if you like to work on that.
-        # I know one should not do that! But solving this would bring more risks
-        # into the 1.0final than leaving the bug to be solved afterwards.
+        # --> Ideas exist, pleas contact us on the list if you like to work
+        #     on that.
+        # I know one should not do that! But solving this would bring more
+        # risks into the 1.0final than leaving the bug to be solved afterwards.
         portal_repo = self.portal.portal_repository
         fol = self.portal.fol
         doc1 = fol.doc1
@@ -733,7 +752,7 @@ def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolde
 
         fol.manage_delObjects(['doc1'])
         transaction.savepoint(optimistic=True)
-        fol.manage_renameObjects(['doc2'],['doc1'])
+        fol.manage_renameObjects(['doc2'], ['doc1'])
 
         doc2 = fol.doc1
 
@@ -762,12 +781,13 @@ def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolde
         self.assertEqual(rev_doc2.getId(), 'doc2')
         self.assertEqual(rev_doc2.Title(), 'v1 of doc2')
 
-    def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(self):
+    def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(self):  # noqa
         # disabled by gregweb/21-10-2006
         # reason: Needs concentrated and deeper look.
-        # --> Ideas exist, pleas contact us on the list if you like to work on that.
-        # I know one should not do that! But solving this would bring more risks
-        # into the 1.0final than leaving the bug to be solved afterwards.
+        # --> Ideas exist, pleas contact us on the list if you like to work
+        #     on that.
+        # I know one should not do that! But solving this would bring more
+        # risks into the 1.0final than leaving the bug to be solved afterwards.
         portal_repo = self.portal.portal_repository
         fol = self.portal.fol
         doc1 = fol.doc1
@@ -788,7 +808,7 @@ def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(
 
         transaction.savepoint(optimistic=True)
         self.portal.manage_pasteObjects(fol.manage_cutObjects(['doc1']))
-        fol.manage_renameObjects(['doc2'],['doc1'])
+        fol.manage_renameObjects(['doc2'], ['doc1'])
 
         doc2 = fol.doc1
         doc1 = self.portal.doc1
@@ -846,7 +866,6 @@ def test21_DontLeaveDanglingCatalogEntriesWhenInvokingFactory(self):
 
         portal_repo.save(fol, comment='second save')
 
-
         retrieved_data = portal_repo.retrieve(fol, 0)
         ret_fol = retrieved_data.object
         self.assertEqual(ret_fol.objectIds(), ['doc1', 'doc2'])


