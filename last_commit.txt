Repository: plone.tiles


Branch: refs/heads/master
Date: 2016-08-17T16:21:21+02:00
Author: Gil Forcada (gforcada) <gforcada@gnome.org>
Commit: https://github.com/plone/plone.tiles/commit/62f27afcda50cb74d6f433a3f3946a5201036d3d

Fix typos and doc hints

Files changed:
M README.rst

diff --git a/README.rst b/README.rst
index 5303eba..fbc7038 100644
--- a/README.rst
+++ b/README.rst
@@ -1,3 +1,4 @@
+===========
 plone.tiles
 ===========
 
@@ -10,7 +11,7 @@ plone.tiles
 
 
 Introduction
-------------
+============
 
 For the purposes of this package,
 a tile is a browser view and an associated utility providing some metadata about that view.
@@ -20,7 +21,7 @@ The idea is that a UI (such as Mosaic) can present the user with a list of inser
 
 A tile is inserted into a layout as a link:
 
-.. code:: xml
+.. code-block:: xml
 
     <link rel="tile" target="placeholder" href="./@@sample.tile/tile1?option1=value1" />
 
@@ -48,7 +49,7 @@ There are three interfaces describing tiles in this package:
     which gives the canonical tile URL,
     including the id sub-path and any query string parameters.
     (Note that tiles also correctly implement ``IAbsoluteURL``.)
-```IPersistentTile``
+``IPersistentTile``
     describes a tile that stores its configuration in object annotations,
     and is needed when configuration values cannot be encoded into a query string.
     The default implementation is in ``plone.tiles.PersistentTile``.
@@ -78,14 +79,14 @@ Creating a Simple Tile
 
 The most basic tile looks like this:
 
-.. code:: python
+.. code-block:: python
 
     from plone.tiles import Tile
 
     class MyTile(Tile):
 
         def __call__(self):
-            return u"<html><body><p>Hello world</p></body></html>"
+            return u'<html><body><p>Hello world</p></body></html>'
 
 Note that the tile is expected to return a complete HTML document.
 This will be interpolated into the page output according to the following rules:
@@ -94,12 +95,14 @@ This will be interpolated into the page output according to the following rules:
 * The contents of the tile's ``<body />`` section will replace the tile placeholder as indicated by the tile link.
 
 Note that this package does *not* provide these interpolations.
-For a Plone implementation of the interpolation algorithm, see `plone.app.blocks`_
+For a Plone implementation of the interpolation algorithm, see `plone.app.blocks`_.
 
 If you require a persistent tile, subclass ``plone.tiles.PersistentTile`` instead.
 You may also need a schema interface if you want a configurable transient or persistent tile.
 
-To register the tile, use ZCML like this::
+To register the tile, use ZCML like this:
+
+.. code-block:: xml
 
     <configure xmlns:plone="http://namespaces.plone.org/plone">
 
@@ -120,48 +123,56 @@ To register the tile, use ZCML like this::
     </configure>
 
 The first five attributes describe the tile by configuring an appropriate ``ITileType`` directive.
-The rest mimics the ``<browser:page />`` directive, so you can specify a ``template`` file and omit the ``class``, or use both a ``template`` and ``class``.
+The rest mimics the ``<browser:page />`` directive,
+so you can specify a ``template`` file and omit the ``class``, or use both a ``template`` and ``class``.
 
-If you want to register a persistent tile with a custom schema, but a template only, you can do e.g.::
+If you want to register a persistent tile with a custom schema, but a template only, you can do e.g.:
 
-        <plone:tile
-            name="sample.persistenttile"
-            title="A title for the tile"
-            description="My tile's description"
-            add_permission="my.add.Permission"
-            schema=".interfaces.IMyTileSchema"
-            class="plone.tiles.PersistentTile"
-            template="mytile.pt"
-            permission="zope.Public"
-            for="*"
-            />
+.. code-block:: xml
+
+    <plone:tile
+        name="sample.persistenttile"
+        title="A title for the tile"
+        description="My tile's description"
+        add_permission="my.add.Permission"
+        schema=".interfaces.IMyTileSchema"
+        class="plone.tiles.PersistentTile"
+        template="mytile.pt"
+        permission="zope.Public"
+        for="*"
+        />
 
 If you want to override an existing tile, e.g. with a new layer or more specific context,
 you *must* omit the tile metadata (title, description, icon, add permission or schema).
-If you include any metadata you will get a conflict error on Zope startup. This example shows how to use a different template for our tile::
+If you include any metadata you will get a conflict error on Zope startup.
+This example shows how to use a different template for our tile:
 
-        <plone:tile
-            name="sample.persistenttile"
-            template="override.pt"
-            permission="zope.Public"
-            for="*"
-            layer=".interfaces.IMyLayer"
-            />
+.. code-block:: xml
+
+    <plone:tile
+        name="sample.persistenttile"
+        template="override.pt"
+        permission="zope.Public"
+        for="*"
+        layer=".interfaces.IMyLayer"
+        />
 
 ZCML Reference
 --------------
 
 The ``plone:tile`` directive uses the namespace ``xmlns:plone="http://namespaces.plone.org/plone"``.
-In order to enable it loading of its ``meta.zcml`` is needed, use::
+In order to enable it loading of its ``meta.zcml`` is needed, use:
+
+.. code-block:: xml
 
     <include package="plone.tiles" file="meta.zcml" />
 
 When registering a tile, in the background two registrations are done:
 
-1) How to **add** the tile (registered as a utility component as a instance of ``plone.tiles.type.TileType``).
+1) How to **add** the tile (registered as a utility component as an instance of ``plone.tiles.type.TileType``).
 
    It is possible to register a tile without adding capabilities.
-   However, such a tile needs to be directly called, there wont be any TTW adding possible.
+   However, such a tile needs to be directly called, there won't be any TTW adding possible.
 
    This registration can be done once only.
 
@@ -177,7 +188,7 @@ When registering a tile, in the background two registrations are done:
    - ``delete_permission`` (optional, default to add_permission)
    - ``schema`` (optional)
 
-2) How to **render** the tile (as a usal page).
+2) How to **render** the tile (as a usual page).
 
    It is possible to register different renderers for the same ``name`` but for different contexts (``for`` or ``layer``).
 
@@ -229,7 +240,7 @@ The **directives attributes** have the following meaning:
     The layer (request marker interface) the tile is available for.
 
 ``class``
-    Class implementing this tile. A browser view providing ``IBasicTile`` or one of its derivates.
+    Class implementing this tile. A browser view providing ``IBasicTile`` or one of its derivatives.
 
 ``template``
     The name of a template that renders this tile.


Repository: plone.tiles


Branch: refs/heads/master
Date: 2016-08-18T10:32:55+02:00
Author: Gil Forcada (gforcada) <gforcada@gnome.org>
Commit: https://github.com/plone/plone.tiles/commit/e164e45f397e6f3559b494a8afb18e70c038bd5f

Typos and reformat tiles.rst

Files changed:
M plone/tiles/tiles.rst

diff --git a/plone/tiles/tiles.rst b/plone/tiles/tiles.rst
index 51e6b13..e633953 100644
--- a/plone/tiles/tiles.rst
+++ b/plone/tiles/tiles.rst
@@ -1,25 +1,26 @@
 Tiles in detail
 ===============
 
-Tiles are a form of view component used to compose pages. Think of a tile as
-a view describing one part of a page, that can be configured with some data
-described by a schema and inserted into a layout via a dedicated GUI.
+Tiles are a form of view component used to compose pages.
+Think of a tile as a view describing one part of a page,
+that can be configured with some data described by a schema and inserted into a layout via a dedicated GUI.
 
-Like a browser view, a tile can be traversed to and published on its own. The
-tile should then return a full HTML page, including a <head /> with any
-required resources, and a <body /> with the visible part of the tile. This
-will then be merged into the page, using a system such as
-``plone.app.blocks``.
+Like a browser view, a tile can be traversed to and published on its own.
+The tile should then return a full HTML page,
+including a <head /> with any required resources,
+and a <body /> with the visible part of the tile.
+This will then be merged into the page, using a system such as ``plone.app.blocks``.
 
-The API in this package provides support for tiles being configured according
-to a schema with data either passed on the query string (transient tiles) or
-retrieved from annotations (persistent tiles).
+The API in this package provides support for tiles being configured according to a schema,
+with data either passed on the query string (transient tiles) or retrieved from annotations (persistent tiles).
 
-Note that there is no direct UI support in this package, so the forms that
-allow users to construct and edit tiles must live elsewhere. You may be
-interested in ``plone.app.tiles`` and ``plone.app.mosaic`` for that purpose.
+Note that there is no direct UI support in this package,
+so the forms that allow users to construct and edit tiles must live elsewhere.
+You may be interested in ``plone.app.tiles`` and ``plone.app.mosaic`` for that purpose.
 
-To use the package, you should first load its ZCML configuration.
+To use the package, you should first load its ZCML configuration:
+
+.. code-block:: python
 
     >>> configuration = """\
     ... <configure
@@ -43,19 +44,23 @@ To use the package, you should first load its ZCML configuration.
 A simple transient tile
 -----------------------
 
-A basic tile is a view that implements the ``ITile`` interface. The easiest
-way to do this is to subclass the ``Tile`` class.
+A basic tile is a view that implements the ``ITile`` interface.
+The easiest way to do this is to subclass the ``Tile`` class:
+
+.. code-block:: python
 
     >>> from plone.tiles import Tile
     >>> class SampleTile(Tile):
     ...
-    ...     __name__ = 'sample.tile' # would normally be set by ZCML handler
+    ...     __name__ = 'sample.tile' # would normally be set by a ZCML handler
     ...
     ...     def __call__(self):
-    ...         return "<html><body><b>My tile</b></body></html>"
+    ...         return '<html><body><b>My tile</b></body></html>'
 
 The tile is a browser view:
 
+.. code-block:: python
+
     >>> from plone.tiles.interfaces import ITile
     >>> ITile.implementedBy(SampleTile)
     True
@@ -64,32 +69,37 @@ The tile is a browser view:
     >>> IBrowserView.implementedBy(SampleTile)
     True
 
-The tile instance has a ``__name__`` attribute (normally set at class level
-by the ``<plone:tile />`` ZCML directive), as well as a property ``id``. The
-id may be set explicitly, either in code, or by sub-path traversal. For
-example, if the tile name is ``example.tile``, the id may be set to ``tile1``
-using a URL like ``http://example.com/foo/@@example.tile/tile1``.
+The tile instance has a ``__name__`` attribute
+(normally set at class level by the ``<plone:tile />`` ZCML directive),
+as well as a property ``id``.
+The id may be set explicitly, either in code, or by sub-path traversal.
+For example, if the tile name is ``example.tile``,
+the id may be set to ``tile1`` using an URL like ``http://example.com/foo/@@example.tile/tile1``.
+
+This tile is registered as a normal browser view,
+alongside a utility that provides some information about the tile itself.
+Normally, this is done using the ``<plone:tile />`` directive.
+Here's how to create one manually:
 
-This tile is registered as a normal browser view, alongside a utility that
-provides some information about the tile itself. Normally, this is done
-using the ``<plone:tile />`` directive. Here's how to create one manually:
+.. code-block:: python
 
     >>> from plone.tiles.type import TileType
     >>> sampleTileType = TileType(
     ...     u'sample.tile',
-    ...     u"Sample tile",
-    ...     "dummy.Permission",
-    ...     "dummy.Permission",
-    ...     description=u"A tile used for testing",
+    ...     u'Sample tile',
+    ...     'dummy.Permission',
+    ...     'dummy.Permission',
+    ...     description=u'A tile used for testing',
     ...     schema=None)
 
-The name should match the view name and the name the utility is registered
-under. The title and description may be used by the UI. The add permission
-is the name of a permission that will be required to insert the tile. The
-schema attribute may be used to indicate schema interface describing the
-tile's configurable data - more on this below.
+The name should match the view name and the name the utility is registered under.
+The title and description may be used by the UI.
+The add permission is the name of a permission that will be required to insert the tile.
+The schema attribute may be used to indicate schema interface describing the tile's configurable data - more on this below.
 
-To register a tile in ZCML, we could do::
+To register a tile in ZCML, we could do:
+
+.. code-block:: xml
 
     <plone:tile
         name="sample.tile"
@@ -101,31 +111,35 @@ To register a tile in ZCML, we could do::
         permission="zope.Public"
         />
 
-**Note:** The tile name should be a dotted name, prefixed by a namespace you
-control. It's a good idea to use a package name for this purpose.
+.. note:: The tile name should be a dotted name, prefixed by a namespace you control.
+   It's a good idea to use a package name for this purpose.
 
-It is also possible to specify a ``layer`` or ``template`` like the
-``browser:page`` directive, as well as a ``schema``, which we will describe
-below.
+It is also possible to specify a ``layer`` or ``template`` like the ``browser:page`` directive, as well as a ``schema``,
+which we will describe below.
 
 We'll register the sample tile directly here, for later testing.
 
+.. code-block:: python
+
     >>> from zope.component import provideAdapter, provideUtility
     >>> from zope.interface import Interface
     >>> from plone.tiles.interfaces import IBasicTile
 
     >>> provideUtility(sampleTileType, name=u'sample.tile')
-    >>> provideAdapter(SampleTile, (Interface, Interface), IBasicTile, name=u"sample.tile")
+    >>> provideAdapter(SampleTile, (Interface, Interface), IBasicTile, name=u'sample.tile')
 
 Tile traversal
 --------------
 
-Tiles are publishable as a normal browser view. They will normally be called
-with a sub-path that specifies a tile id. This allows tiles to be made aware
-of their instance name. The id is unique within the page layout where the tile
-is used, and may be the basis for looking up tile data.
+Tiles are publishable as a normal browser view.
+They will normally be called with a sub-path that specifies a tile id.
+This allows tiles to be made aware of their instance name.
+The id is unique within the page layout where the tile is used,
+and may be the basis for looking up tile data.
 
-For example, a tile may be saved in a layout as a link like::
+For example, a tile may be saved in a layout as a link like:
+
+.. code-block:: html
 
     <link rel="tile" target="mytile" href="./@@sample.tile/tile1" />
 
@@ -133,30 +147,34 @@ For example, a tile may be saved in a layout as a link like::
 the element with id ``mytile`` with the body of the rendered tile - see
 ``plone.app.blocks`` for details).
 
-Let's create a sample context, look up the view as it would be during
-traversal, and verify how the tile is instantiated.
+Let's create a sample context,
+look up the view as it would be during traversal,
+and verify how the tile is instantiated.
 
-    >>> from zope.interface import implements
+.. code-block:: python
+
+    >>> from zope.component import getMultiAdapter
+    >>> from zope.interface import Interface
+    >>> from zope.interface import implementer
+    >>> from zope.publisher.browser import TestRequest
 
     >>> class IContext(Interface):
     ...     pass
 
-    >>> class Context(object):
-    ...     implements(IContext)
-
-    >>> from zope.publisher.browser import TestRequest
+    >>> @implementer(IContext)
+    ... class Context(object):
+    ...     pass
 
     >>> context = Context()
     >>> request = TestRequest()
 
-    >>> from zope.interface import Interface
-    >>> from zope.component import getMultiAdapter
-
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> tile = tile['tile1'] # simulates sub-path traversal
 
 The tile will now be aware of its name and id:
 
+.. code-block:: python
+
     >>> isinstance(tile, SampleTile)
     True
     >>> tile.__parent__ is context
@@ -167,18 +185,22 @@ The tile will now be aware of its name and id:
     'sample.tile'
 
 The sub-path traversal is implemented using a custom ``__getitem__()`` method.
-To look up a view on a tile, you can traverse to it *after* you've traversed
-to the id sub-path:
+To look up a view on a tile,
+you can traverse to it *after* you've traversed to the id sub-path:
+
+.. code-block:: python
 
-    >>> from zope.interface import Interface
     >>> from zope.component import adapts
+    >>> from zope.interface import Interface
     >>> from zope.publisher.browser import BrowserView
     >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer
+
     >>> class TestView(BrowserView):
     ...     adapts(SampleTile, IDefaultBrowserLayer)
     ...     def __call__(self):
-    ...         return "Dummy view"
-    >>> provideAdapter(TestView, provides=Interface, name="test-view")
+    ...         return 'Dummy view'
+
+    >>> provideAdapter(TestView, provides=Interface, name='test-view')
 
     >>> tile.id is not None
     True
@@ -187,15 +209,19 @@ to the id sub-path:
 
 If there is no view and we have an id already, we will get a ``KeyError``:
 
+.. code-block:: python
+
     >>> tile['not-known'] # doctest: +ELLIPSIS
     Traceback (most recent call last):
     ...
     KeyError: 'not-known'
 
-To ensure consistency with Zope's various tangles publication machines, it
-is also possible to traverse using the ``publishTraverse`` method::
+To ensure consistency with Zope's various tangles publication machines,
+it is also possible to traverse using the ``publishTraverse`` method:
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+.. code-block:: python
+
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> tile = tile.publishTraverse(request, 'tile1') # simulates sub-path traversal
 
     >>> isinstance(tile, SampleTile)
@@ -210,32 +236,41 @@ is also possible to traverse using the ``publishTraverse`` method::
 Transient tile data
 -------------------
 
-Let us now consider how tiles may have data. In the simplest case, tile
-data is passed on the query string, and described according to a schema.
+Let us now consider how tiles may have data.
+In the simplest case, tile data is passed on the query string, and described according to a schema.
 A simple schema may look like:
 
+.. code-block:: python
+
     >>> import zope.schema
+
     >>> class ISampleTileData(Interface):
-    ...     title = zope.schema.TextLine(title=u"Tile title")
-    ...     cssClass = zope.schema.ASCIILine(title=u"CSS class to apply")
-    ...     count = zope.schema.Int(title=u"Number of things to show in the tile")
+    ...     title = zope.schema.TextLine(title=u'Tile title')
+    ...     cssClass = zope.schema.ASCIILine(title=u'CSS class to apply')
+    ...     count = zope.schema.Int(title=u'Number of things to show in the tile')
+
+We would normally have listed this interface when registering this tile in ZCML.
+We can simply update the utility here.
 
-We would normally have listed this interface when registering this tile in
-ZCML. We can simply update the utility here.
+.. code-block:: python
 
     >>> sampleTileType.schema = ISampleTileData
 
 Tile data is represented by a simple dictionary. For example:
 
-    >>> data = {'title': u"My title", 'count': 5, 'cssClass': 'foo'}
+.. code-block:: python
+
+    >>> data = {'title': u'My title', 'count': 5, 'cssClass': 'foo'}
 
-The idea is that a tile add form is built from the schema interface, and its
-data saved to a dictionary.
+The idea is that a tile add form is built from the schema interface, and its data saved to a dictionary.
 
-For transient tiles, this data is then encoded into the tile query string. To
-help with this, a utility function can be used to encode a dict to a query
-string, applying Zope form marshalers according to the types described in
-the schema:
+For transient tiles,
+this data is then encoded into the tile query string.
+To help with this,
+a utility function can be used to encode a dict to a query string,
+applying Zope form marshalers according to the types described in the schema:
+
+.. code-block:: python
 
     >>> from plone.tiles.data import encode
     >>> encode(data, ISampleTileData)
@@ -243,34 +278,39 @@ the schema:
 
 The ``count%3Along=5`` bit is the encoded version of ``count:long=5``.
 
-Note that not all field types may be saved. In particular, object, interface,
-set or frozen set fields may not be saved, and will result in a ``KeyError``.
+Note that not all field types may be saved.
+In particular, object, interface, set or frozen set fields may not be saved, and will result in a ``KeyError``.
 Lengthy text fields or bytes fields with binary data may also be a problem.
-For these types of fields, look to use persistent tiles instead.
+For these types of fields,
+look to use persistent tiles instead.
+
+Furthermore, the conversion may not be perfect.
+For example, Zope's form marshalers cannot distinguish between unicode and ascii fields.
+Therefore, there is a corresponding ``decode()`` method that may be used to ensure that the values match the schema:
 
-Furthermore, the conversion may not be perfect. For example, Zope's form
-marshalers cannot distinguish between unicode and ascii fields. Therefore,
-there is a corresponding ``decode()`` method that may be used to ensure that
-the values match the schema:
+.. code-block:: python
 
-    >>> marshaled = {'title': u"My tile", 'count': 5, 'cssClass': u'foo'}
+    >>> marshaled = {'title': u'My tile', 'count': 5, 'cssClass': u'foo'}
 
     >>> from plone.tiles.data import decode
     >>> decode(marshaled, ISampleTileData)
     {'count': 5, 'cssClass': 'foo', 'title': u'My tile'}
 
-When saved into a layout, the tile link would now look like::
+When saved into a layout, the tile link would now look like:
+
+.. code-block:: html
 
     <link rel="tile" target="mytile"
       href="./@@sample.tile/tile1?title=My+title&count%3Along=5&cssClass=foo" />
 
-Let's simulate traversal once more and see how the data is now available to
-the tile instance:
+Let's simulate traversal once more and see how the data is now available to the tile instance:
+
+.. code-block:: python
 
     >>> context = Context()
     >>> request = TestRequest(form={'title': u'My title', 'count': 5, 'cssClass': u'foo'})
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> tile = tile['tile1']
 
     >>> sorted(tile.data.items())
@@ -278,38 +318,39 @@ the tile instance:
 
 Notice also how the data has been properly decoded according to the schema.
 
-Transient tiles will get their data directly from the request
-parameters but, if a `_tiledata` JSON-encoded parameter is present in
-the request, this one will be used instead::
+Transient tiles will get their data directly from the request parameters but,
+if a `_tiledata` JSON-encoded parameter is present in the request,
+this one will be used instead:
 
-    >>> try:
-    ...     import json
-    ... except ImportError:
-    ...     import simplejson as json
+.. code-block:: python
+
+    >>> import json
 
     >>> request = TestRequest(form={
     ...     'title': u'My title', 'count': 5, 'cssClass': u'foo',
     ...     '_tiledata': json.dumps({'title': u'Your title', 'count': 6, 'cssClass': u'bar'})
     ...     })
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> tile = tile['tile1']
 
     >>> sorted(tile.data.items())
     [(u'count', 6), (u'cssClass', u'bar'), (u'title', u'Your title')]
 
-This way we can use transient tiles safely in contexts where the tile
-data can be confused with raw data coming from a form, e.g. in an edit form.
+This way we can use transient tiles safely in contexts where the tile data can be confused with raw data coming from a form, e.g. in an edit form.
 
 The tile data manager
 ---------------------
 
-The ``data`` attribute is a convenience attribute to get hold of a (cached)
-copy of the data returned by an ``ITileDataManager``. This interface provides
-three methods: ``get()``, to return the tile's data, ``set()``, to update it
-with a new dictionary of data, and ``delete()``, to delete the data.
+The ``data`` attribute is a convenience attribute to get hold of a (cached) copy of the data returned by an ``ITileDataManager``.
+This interface provides three methods:
+``get()``, to return the tile's data,
+``set()``, to update it with a new dictionary of data,
+and ``delete()``, to delete the data.
+
+This adapter is mostly useful for writing UI around tiles.
+Using our tile above, we can get the data like so:
 
-This adapter is mostly useful for writing UI around tiles. Using our tile
-above, we can get the data like so:
+.. code-block:: python
 
     >>> from plone.tiles.interfaces import ITileDataManager
     >>> dataManager = ITileDataManager(tile)
@@ -318,51 +359,61 @@ above, we can get the data like so:
 
 We can also update the tile data:
 
+.. code-block:: python
+
     >>> dataManager.set({'count': 1, 'cssClass': 'bar', 'title': u'Another title'})
     >>> sorted(dataManager.get().items())
     [('count', 1), ('cssClass', 'bar'), ('title', u'Another title')]
 
 The data can also be deleted:
 
+.. code-block:: python
+
     >>> dataManager.delete()
     >>> sorted(dataManager.get().items())
     [('count', None), ('cssClass', None), ('title', None)]
 
-Note that in the case of a transient tile, all we are doing is
-modifying the ``form`` dictionary of the request (or the `_tiledata`
-parameter of this dictionary, if present). The data needs to be
-encoded into the query string, either using the ``encode()`` method or
-via the tile's ``IAbsoluteURL`` adapter (see below for details).
+Note that in the case of a transient tile,
+all we are doing is modifying the ``form`` dictionary of the request
+(or the `_tiledata` parameter of this dictionary, if present).
+The data needs to be encoded into the query string,
+either using the ``encode()`` method or via the tile's ``IAbsoluteURL`` adapter (see below for details).
 
 For persistent tiles, the data manager is a bit more interesting.
 
 Persistent tiles
 ----------------
 
-Not all types of data can be placed in a query string. For more substantial
-storage requirements, you can use persistent tiles, which store data in
-annotations.
+Not all types of data can be placed in a query string.
+For more substantial storage requirements,
+you can use persistent tiles, which store data in annotations.
 
-*Note:* If you have more intricate requirements, you can also write your own
-``ITileDataManager`` to handle data retrieval. In this case, you probably
-still want to derive from ``PersistentTile``, to get the appropriate
-``IAbsoluteURL`` adapter, among other things.
+.. note:: If you have more intricate requirements,
+   you can also write your own ``ITileDataManager`` to handle data retrieval.
+   In this case, you probably still want to derive from ``PersistentTile``,
+   to get the appropriate ``IAbsoluteURL`` adapter, among other things.
 
 First, we need to write up annotations support.
 
+.. code-block:: python
+
     >>> from zope.annotation.attribute import AttributeAnnotations
     >>> provideAdapter(AttributeAnnotations)
 
 We also need a context that is annotatable.
 
+.. code-block:: python
+
     >>> from zope.annotation.interfaces import IAttributeAnnotatable
     >>> from zope.interface import alsoProvides
     >>> alsoProvides(context, IAttributeAnnotatable)
 
 Now, let's create a persistent tile with a schema.
 
+.. code-block:: python
+
     >>> class IPersistentSampleData(Interface):
-    ...     text = zope.schema.Text(title=u"Detailed text", missing_value=u"Missing!")
+    ...     text = zope.schema.Text(title=u'Detailed text', missing_value=u'Missing!')
 
     >>> from plone.tiles import PersistentTile
     >>> class PersistentSampleTile(PersistentTile):
@@ -370,25 +421,27 @@ Now, let's create a persistent tile with a schema.
     ...     __name__ = 'sample.persistenttile' # would normally be set by ZCML handler
     ...
     ...     def __call__(self):
-    ...         return u"<b>You said</b> %s" % self.data['text']
+    ...         return u'<b>You said</b> %s' % self.data['text']
 
     >>> persistentSampleTileType = TileType(
     ...     u'sample.persistenttile',
-    ...     u"Persistent sample tile",
-    ...     "dummy.Permission",
-    ...     "dummy.Permission",
-    ...     description=u"A tile used for testing",
+    ...     u'Persistent sample tile',
+    ...     'dummy.Permission',
+    ...     'dummy.Permission',
+    ...     description=u'A tile used for testing',
     ...     schema=IPersistentSampleData)
 
     >>> provideUtility(persistentSampleTileType, name=u'sample.persistenttile')
-    >>> provideAdapter(PersistentSampleTile, (Interface, Interface), IBasicTile, name=u"sample.persistenttile")
+    >>> provideAdapter(PersistentSampleTile, (Interface, Interface), IBasicTile, name=u'sample.persistenttile')
+
+We can now traverse to the tile as before.
+By default, there is no data, and the field's missing value will be used.
 
-We can now traverse to the tile as before. By default, there is no data, and
-the field's missing value will be used.
+.. code-block:: python
 
     >>> request = TestRequest()
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.persistenttile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.persistenttile')
     >>> tile = tile['tile2']
     >>> tile.__name__
     'sample.persistenttile'
@@ -400,16 +453,22 @@ the field's missing value will be used.
 
 At this point, there is nothing in the annotations for the type either:
 
+.. code-block:: python
+
     >>> dict(getattr(context, '__annotations__', {})).keys()
     []
 
 We can write data to the context's annotations using an ``ITileDataManager``:
 
+.. code-block:: python
+
     >>> dataManager = ITileDataManager(tile)
-    >>> dataManager.set({'text': u"Hello!"})
+    >>> dataManager.set({'text': u'Hello!'})
 
 This writes data to annotations:
 
+.. code-block:: python
+
     >>> dict(context.__annotations__).keys()
     [u'plone.tiles.data.tile2']
     >>> context.__annotations__[u'plone.tiles.data.tile2']
@@ -417,15 +476,19 @@ This writes data to annotations:
 
 We can get this from the data manager too, of course:
 
+.. code-block:: python
+
     >>> dataManager.get()
     {'text': u'Hello!'}
 
-Note that as with transient tiles, the ``data`` attribute is cached and will
-only be looked up once.
+Note that as with transient tiles,
+the ``data`` attribute is cached and will only be looked up once.
 
 If we now look up the tile again, we will get the new value:
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.persistenttile")
+.. code-block:: python
+
+    >>> tile = getMultiAdapter((context, request), name=u'sample.persistenttile')
     >>> tile = tile['tile2']
     >>> tile()
     u'<b>You said</b> Hello!'
@@ -435,31 +498,33 @@ If we now look up the tile again, we will get the new value:
 
 We can also remove the annotation using the data manager:
 
+.. code-block:: python
+
     >>> dataManager.delete()
     >>> sorted(dict(context.__annotations__).items()) # doctest: +ELLIPSIS
     []
 
-
 Overriding transient data with persistent
 -----------------------------------------
 
-To be able to re-use the same centrally managed tile based layouts for
-multiple context objects, but still allow optional customization for
-tiles, it's possible to override otherwise transient tile configuration
-with context specific persistent configuration.
+To be able to re-use the same centrally managed tile based layouts for multiple context objects,
+but still allow optional customization for tiles,
+it's possible to override otherwise transient tile configuration with context specific persistent configuration.
 
-This is done by either by setting a client side request header or query param
-``X-Tile-Persistent``:
+This is done by either by setting a client side request header or query param ``X-Tile-Persistent``:
+
+.. code-block:: python
 
     >>> request = TestRequest(
     ...     form={'title': u'My title', 'count': 5, 'cssClass': u'foo',
     ...           'X-Tile-Persistent': 'yes'}
     ... )
 
-Yet, just adding the flag, doesn't create new persistent annotations
-on GET requests:
+Yet, just adding the flag, doesn't create new persistent annotations on GET requests:
+
+.. code-block:: python
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> ITileDataManager(tile)
     <plone.tiles.data.PersistentTileDataManager object at ...>
 
@@ -472,6 +537,8 @@ on GET requests:
 
 That's because the data is persistent only once it's set:
 
+.. code-block:: python
+
     >>> data = ITileDataManager(tile).get()
     >>> data.update({'count': 6})
     >>> ITileDataManager(tile).set(data)
@@ -486,10 +553,12 @@ That's because the data is persistent only once it's set:
 
 Without the persistent flag, fixed transient data would be returned:
 
+.. code-block:: python
+
     >>> request = TestRequest(
     ...     form={'title': u'My title', 'count': 5, 'cssClass': u'foo'},
     ... )
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> ITileDataManager(tile)
     <plone.tiles.data.TransientTileDataManager object at ...>
 
@@ -499,11 +568,13 @@ Without the persistent flag, fixed transient data would be returned:
 
 Finally, the persistent override could also be deleted:
 
+.. code-block:: python
+
     >>> request = TestRequest(
     ...     form={'title': u'My title', 'count': 5, 'cssClass': u'foo',
     ...           'X-Tile-Persistent': 'yes'}
     ... )
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> ITileDataManager(tile)
     <plone.tiles.data.PersistentTileDataManager object at ...>
 
@@ -520,7 +591,7 @@ Finally, the persistent override could also be deleted:
     >>> request = TestRequest(
     ...     form={'title': u'My title', 'count': 5, 'cssClass': u'foo'},
     ... )
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> ITileDataManager(tile)
     <plone.tiles.data.TransientTileDataManager object at ...>
 
@@ -528,14 +599,17 @@ Finally, the persistent override could also be deleted:
 Tile URLs
 ---------
 
-As we have seen, tiles have a canonical URL. For transient tiles, this may
-also encode some tile data.
+As we have seen, tiles have a canonical URL.
+For transient tiles, this may also encode some tile data.
 
 If you have a tile instance and you need to know the canonical tile URL,
 you can use the ``IAbsoluteURL`` API.
 
-For the purposes of testing, we need to ensure that we can get an absolute URL
-for the context. We'll achieve that with a dummy adapter:
+For the purposes of testing,
+we need to ensure that we can get an absolute URL for the context.
+We'll achieve that with a dummy adapter:
+
+.. code-block:: python
 
     >>> from zope.interface import implements
     >>> from zope.component import adapts
@@ -552,14 +626,14 @@ for the context. We'll achieve that with a dummy adapter:
     ...         self.request = request
     ...
     ...     def __unicode__(self):
-    ...         return u"http://example.com/context"
+    ...         return u'http://example.com/context'
     ...     def __str__(self):
-    ...         return u"http://example.com/context"
+    ...         return u'http://example.com/context'
     ...     def __call__(self):
     ...         return self.__str__()
     ...     def breadcrumbs(self):
     ...         return ({'name': u'context', 'url': 'http://example.com/context'},)
-    >>> provideAdapter(DummyAbsoluteURL, name=u"absolute_url")
+    >>> provideAdapter(DummyAbsoluteURL, name=u'absolute_url')
     >>> provideAdapter(DummyAbsoluteURL)
 
     >>> from zope.traversing.browser.absoluteurl import absoluteURL
@@ -567,7 +641,7 @@ for the context. We'll achieve that with a dummy adapter:
 
     >>> context = Context()
     >>> request = TestRequest(form={'title': u'My title', 'count': 5, 'cssClass': u'foo'})
-    >>> transientTile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> transientTile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> transientTile = transientTile['tile1']
 
     >>> absoluteURL(transientTile, request)
@@ -580,15 +654,19 @@ for the context. We'll achieve that with a dummy adapter:
 
 For convenience, the tile URL is also available under the ``url`` property:
 
+.. code-block:: python
+
     >>> transientTile.url
     'http://example.com/context/@@sample.tile/tile1?title=My+title&cssClass=foo&count%3Along=5'
 
 The tile absolute URL structure remains unaltered if the data is
 coming from a `_tiledata` JSON-encoded parameter instead of from the request
-parameters directly::
+parameters directly:
+
+.. code-block:: python
 
     >>> request = TestRequest(form={'_tiledata': json.dumps({'title': u'Your title', 'count': 6, 'cssClass': u'bar'})})
-    >>> transientTile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> transientTile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> transientTile = transientTile['tile1']
 
     >>> absoluteURL(transientTile, request)
@@ -596,9 +674,11 @@ parameters directly::
 
 For persistent tiles, the are no data parameters:
 
+.. code-block:: python
+
     >>> context = Context()
     >>> request = TestRequest(form={'title': u'Ignored', 'count': 0, 'cssClass': u'ignored'})
-    >>> persistentTile = getMultiAdapter((context, request), name=u"sample.persistenttile")
+    >>> persistentTile = getMultiAdapter((context, request), name=u'sample.persistenttile')
     >>> persistentTile = persistentTile['tile2']
 
     >>> absoluteURL(persistentTile, request)
@@ -611,17 +691,21 @@ For persistent tiles, the are no data parameters:
 
 And again, for convenience:
 
+.. code-block:: python
+
     >>> persistentTile.url
     'http://example.com/context/@@sample.persistenttile/tile2'
 
-If the tile doesn't have an id, we don't get any sub-path
+If the tile doesn't have an id, we don't get any sub-path:
+
+.. code-block:: python
 
     >>> request = TestRequest(form={'title': u'My title', 'count': 5, 'cssClass': u'foo'})
-    >>> transientTile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> transientTile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> absoluteURL(transientTile, request)
     'http://example.com/context/@@sample.tile?title=My+title&cssClass=foo&count%3Along=5'
 
     >>> request = TestRequest()
-    >>> persistentTile = getMultiAdapter((context, request), name=u"sample.persistenttile")
+    >>> persistentTile = getMultiAdapter((context, request), name=u'sample.persistenttile')
     >>> absoluteURL(persistentTile, request)
     'http://example.com/context/@@sample.persistenttile'


Repository: plone.tiles


Branch: refs/heads/master
Date: 2016-08-18T10:32:55+02:00
Author: Gil Forcada (gforcada) <gforcada@gnome.org>
Commit: https://github.com/plone/plone.tiles/commit/eaaae3d5cf561420447a2717e1da871245f904d8

Typos and reformat directives.rst

Files changed:
M plone/tiles/directives.rst

diff --git a/plone/tiles/directives.rst b/plone/tiles/directives.rst
index 835480a..d26ecf3 100644
--- a/plone/tiles/directives.rst
+++ b/plone/tiles/directives.rst
@@ -1,23 +1,27 @@
 ZCML directive
 ==============
 
-A tile is really just a browser view providing ``IBasicTile`` (or, more
-commonly, ``ITile`` or ``IPersistentTile``) coupled with a named utility
-providing ``ITileType``. The names of the browser view and the tile should
-match.
-
-To make it easier to register these components, this package provides a
-``<plone:tile />`` directive that sets up both. It supports several use cases:
-
-  * Registering a new tile from a class
-  * Registering a new tile from a template only
-  * Registering a new tile form a class and a template
-  * Registering a new tile for an existing tile type (e.g. for a new layer)
-
-To test this, we have created a dummy schema and a dummy tile in ``tests.py``,
+A tile is really just a browser view providing ``IBasicTile``
+(or, more commonly, ``ITile`` or ``IPersistentTile``)
+coupled with a named utility providing ``ITileType``.
+The names of the browser view and the tile should match.
+
+To make it easier to register these components,
+this package provides a ``<plone:tile />`` directive that sets up both.
+It supports several use cases:
+
+* Registering a new tile from a class
+* Registering a new tile from a template only
+* Registering a new tile form a class and a template
+* Registering a new tile for an existing tile type (e.g. for a new layer)
+
+To test this,
+we have created a dummy schema and a dummy tile in ``tests.py``,
 and a dummy template in ``test.pt``.
 
-Let's show how these may be used by registering several tiles::
+Let's show how these may be used by registering several tiles:
+
+.. code-block:: python
 
     >>> configuration = """\
     ... <configure package="plone.tiles"
@@ -103,12 +107,14 @@ Let's show how these may be used by registering several tiles::
     >>> from zope.configuration import xmlconfig
     >>> xmlconfig.xmlconfig(StringIO(configuration))
 
-Let's check how the tiles were registered::
+Let's check how the tiles were registered:
+
+.. code-block:: python
 
     >>> from zope.component import getUtility
     >>> from plone.tiles.interfaces import ITileType
 
-    >>> tile1_type = getUtility(ITileType, name=u"dummy1")
+    >>> tile1_type = getUtility(ITileType, name=u'dummy1')
     >>> tile1_type
     <TileType dummy1 (Dummy tile 1)>
     >>> tile1_type.description
@@ -123,7 +129,7 @@ Let's check how the tiles were registered::
     >>> tile1_type.schema
     <InterfaceClass plone.tiles.tests.IDummySchema>
 
-    >>> tile2_type = getUtility(ITileType, name=u"dummy2")
+    >>> tile2_type = getUtility(ITileType, name=u'dummy2')
     >>> tile2_type
     <TileType dummy2 (Dummy tile 2)>
     >>> tile2_type.description is None
@@ -133,7 +139,7 @@ Let's check how the tiles were registered::
     >>> tile2_type.schema is None
     True
 
-    >>> tile3_type = getUtility(ITileType, name=u"dummy3")
+    >>> tile3_type = getUtility(ITileType, name=u'dummy3')
     >>> tile3_type
     <TileType dummy3 (Dummy tile 3)>
     >>> tile3_type.description is None
@@ -143,7 +149,7 @@ Let's check how the tiles were registered::
     >>> tile3_type.schema is None
     True
 
-    >>> tile4_type = getUtility(ITileType, name=u"dummy4")
+    >>> tile4_type = getUtility(ITileType, name=u'dummy4')
     >>> tile4_type
     <TileType dummy4 (Dummy tile 4)>
     >>> tile4_type.description is None
@@ -153,7 +159,9 @@ Let's check how the tiles were registered::
     >>> tile4_type.schema
     <InterfaceClass plone.tiles.tests.IDummySchema>
 
-Finally, let's check that we can look up the tiles::
+Finally, let's check that we can look up the tiles:
+
+.. code-block:: python
 
     >>> from zope.publisher.browser import TestRequest
     >>> from zope.interface import implements, alsoProvides
@@ -171,7 +179,7 @@ Finally, let's check that we can look up the tiles::
     >>> from plone.tiles import Tile, PersistentTile
     >>> from plone.tiles.tests import DummyTile, DummyTileWithTemplate
 
-    >>> tile1 = getMultiAdapter((context, layer_request), name="dummy1")
+    >>> tile1 = getMultiAdapter((context, layer_request), name='dummy1')
     >>> isinstance(tile1, DummyTileWithTemplate)
     True
     >>> print tile1()
@@ -179,7 +187,7 @@ Finally, let's check that we can look up the tiles::
     >>> tile1.__name__
     'dummy1'
 
-    >>> tile2 = getMultiAdapter((context, request), name="dummy2")
+    >>> tile2 = getMultiAdapter((context, request), name='dummy2')
     >>> isinstance(tile2, DummyTile)
     True
     >>> print tile2()
@@ -187,7 +195,7 @@ Finally, let's check that we can look up the tiles::
     >>> tile2.__name__
     'dummy2'
 
-    >>> tile3 = getMultiAdapter((context, request), name="dummy3")
+    >>> tile3 = getMultiAdapter((context, request), name='dummy3')
     >>> isinstance(tile3, Tile)
     True
     >>> print tile3()
@@ -195,7 +203,7 @@ Finally, let's check that we can look up the tiles::
     >>> tile3.__name__
     'dummy3'
 
-    >>> tile4 = getMultiAdapter((context, request), name="dummy4")
+    >>> tile4 = getMultiAdapter((context, request), name='dummy4')
     >>> isinstance(tile4, PersistentTile)
     True
     >>> print tile4()
@@ -203,7 +211,7 @@ Finally, let's check that we can look up the tiles::
     >>> tile4.__name__
     'dummy4'
 
-    >>> tile3_layer = getMultiAdapter((context, layer_request), name="dummy3")
+    >>> tile3_layer = getMultiAdapter((context, layer_request), name='dummy3')
     >>> isinstance(tile3_layer, DummyTile)
     True
     >>> print tile3_layer()


Repository: plone.tiles


Branch: refs/heads/master
Date: 2016-08-18T10:32:56+02:00
Author: Gil Forcada (gforcada) <gforcada@gnome.org>
Commit: https://github.com/plone/plone.tiles/commit/0aeeb1be037e2080aa5e6dca60222f39cd29d25b

Typos and reformat data.rst

Files changed:
M plone/tiles/data.rst

diff --git a/plone/tiles/data.rst b/plone/tiles/data.rst
index 2a40190..78f3ecc 100644
--- a/plone/tiles/data.rst
+++ b/plone/tiles/data.rst
@@ -2,8 +2,9 @@
 Data encoding/decoding
 ======================
 
-This test exercises the ``encode()`` and ``decode()`` methods in
-``plone.tiles.data``.
+This test exercises the ``encode()`` and ``decode()`` methods in ``plone.tiles.data``.
+
+.. code-block:: python
 
     >>> from zope.interface import Interface
     >>> from zope import schema
@@ -15,28 +16,34 @@ Encoding
 
 First, we'll create a simple schema that exercises several field types:
 
+.. code-block:: python
+
     >>> weekdays = [u'Monday', u'Tuesday', u'Wednesday', u'Thursday',
     ...             u'Friday', u'Saturday', u'Sunday']
     >>> class ISimple(Interface):
-    ...     text_line   = schema.TextLine(title=u"Text")
-    ...     ascii_line  = schema.ASCIILine(title=u"ASCII")
-    ...     text        = schema.Text(title=u"Text", missing_value=u"Missing")
-    ...     ascii       = schema.ASCII(title=u"ASCII")
-    ...     int         = schema.Int(title=u"Int")
-    ...     float       = schema.Float(title=u"Float")
-    ...     bool        = schema.Bool(title=u"Bool")
-    ...     weekday     = schema.Choice(title=u"Weekday", values=weekdays)
+    ...     text_line   = schema.TextLine(title=u'Text')
+    ...     ascii_line  = schema.ASCIILine(title=u'ASCII')
+    ...     text        = schema.Text(title=u'Text', missing_value=u'Missing')
+    ...     ascii       = schema.ASCII(title=u'ASCII')
+    ...     int         = schema.Int(title=u'Int')
+    ...     float       = schema.Float(title=u'Float')
+    ...     bool        = schema.Bool(title=u'Bool')
+    ...     weekday     = schema.Choice(title=u'Weekday', values=weekdays)
     ...     list        = schema.List(value_type=schema.TextLine())
     ...     listchoice  = schema.List(value_type=schema.Choice(vocabulary='foobar'))
 
 A simple encode produces a query string:
 
+.. code-block:: python
+
     >>> data = dict(text_line=u'A', ascii_line='B', text=u'C\nD', ascii='E\nF', int=3, float=1.2, bool=False, weekday=u'Saturday')
     >>> encode(data, ISimple)
     'text_line=A&ascii_line=B&text%3Atext=C%0AD&ascii%3Atext=E%0AF&int%3Along=3&float%3Afloat=1.2&bool%3Aboolean=&weekday=Saturday'
 
-Notice how a boolean is encoded as an empty value. If it were true, it'd be
-encoded as 1:
+Notice how a boolean is encoded as an empty value.
+If it were true, it'd be encoded as 1:
+
+.. code-block:: python
 
     >>> data = dict(text_line=u'A', ascii_line='B', text=u'C\nD', ascii='E\nF', int=3, float=1.2, bool=True, weekday=u'Saturday')
     >>> encode(data, ISimple)
@@ -44,27 +51,35 @@ encoded as 1:
 
 If the data dictionary has values not in the interface, they are ignored:
 
+.. code-block:: python
+
     >>> data = dict(text_line=u'A', ascii_line='B', text=u'C\nD', ascii='E\nF', int=3, float=1.2, bool=True, weekday=u'Saturday', foo=123)
     >>> encode(data, ISimple)
     'text_line=A&ascii_line=B&text%3Atext=C%0AD&ascii%3Atext=E%0AF&int%3Along=3&float%3Afloat=1.2&bool%3Aboolean=1&weekday=Saturday'
 
 If the data dictionary omits some fields, they are ignored.
 
+.. code-block:: python
+
     >>> data = dict(text_line=u'A', ascii_line='B', text=u'C\nD', ascii='E\nF', float=1.2, bool=True, foo=123)
     >>> encode(data, ISimple)
     'text_line=A&ascii_line=B&text%3Atext=C%0AD&ascii%3Atext=E%0AF&float%3Afloat=1.2&bool%3Aboolean=1'
 
 It is also possible to explicitly ignore some fields:
 
+.. code-block:: python
+
     >>> data = dict(text_line=u'A', ascii_line='B', text=u'C\nD', ascii='E\nF', float=1.2, bool=True, foo=123)
     >>> encode(data, ISimple, ignore=('text_line', 'text',))
     'ascii_line=B&ascii%3Atext=E%0AF&float%3Afloat=1.2&bool%3Aboolean=1'
 
 Lists and tuples may also be encoded. The value type will be encoded as well.
 
+.. code-block:: python
+
     >>> class ISequences(Interface):
-    ...     list    = schema.List(title=u"List", value_type=schema.ASCIILine(title=u"Text"))
-    ...     tuple   = schema.Tuple(title=u"List", value_type=schema.Int(title=u"Int"))
+    ...     list    = schema.List(title=u'List', value_type=schema.ASCIILine(title=u'Text'))
+    ...     tuple   = schema.Tuple(title=u'List', value_type=schema.Int(title=u'Int'))
 
     >>> data = dict(list=['a', 'b'], tuple=(1,2,3))
     >>> encode(data, ISequences)
@@ -72,21 +87,25 @@ Lists and tuples may also be encoded. The value type will be encoded as well.
 
 Even dictionaries may be encoded. And the value type will be encoded as well.
 
+.. code-block:: python
+
     >>> class IRecords(Interface):
-    ...     record = schema.Dict(title=u"Record")
-    ...     records = schema.List(title=u"Records", value_type=schema.Dict())
+    ...     record = schema.Dict(title=u'Record')
+    ...     records = schema.List(title=u'Records', value_type=schema.Dict())
 
     >>> data = dict(record={'a': 'b', 'c': True}, records=[{'a': 'b', 'c': True}])
     >>> encode(data, IRecords)
     'record.a%3Arecord=b&record.c%3Aboolean%3Arecord=1&records.a%3Arecords=b&records.c%3Aboolean%3Arecords=1'
 
-Unsupported fields will raise a ComponentLookupError. This also
-applies to the value_type of a list or tuple:
+Unsupported fields will raise a ComponentLookupError.
+This also applies to the value_type of a list or tuple:
+
+.. code-block:: python
 
     >>> class IUnsupported(Interface):
-    ...     decimal     = schema.Decimal(title=u"Decimal")
-    ...     list        = schema.List(title=u"Set", value_type=schema.Decimal(title=u"Decimal"))
-    ...     bytes_line  = schema.BytesLine(title=u"Bytes line")
+    ...     decimal     = schema.Decimal(title=u'Decimal')
+    ...     list        = schema.List(title=u'Set', value_type=schema.Decimal(title=u'Decimal'))
+    ...     bytes_line  = schema.BytesLine(title=u'Bytes line')
 
     >>> from decimal import Decimal
     >>> data = dict(decimal=Decimal(2), list=[Decimal(1), Decimal(2),], bytes_line='abc')
@@ -106,19 +125,22 @@ applies to the value_type of a list or tuple:
 Decoding
 --------
 
-The decoder exists because the Zope form marshalers are not perfect: for
-instance, they cannot adequately deal with the differences between unicode
-and ASCII. ``zope.schema`` is picky about that sort of thing.
+The decoder exists because the Zope form marshalers are not perfect:
+for instance, they cannot adequately deal with the differences between unicode and ASCII.
+``zope.schema`` is picky about that sort of thing.
 
-Let's use a data dictionary that may have come back from a query string like
-the first example above.
+Let's use a data dictionary that may have come back from a query string like the first example above.
+
+.. code-block:: python
 
     >>> data = dict(text_line=u'A', ascii_line=u'B', text=u'C\nD', ascii=u'E\nF', int=3, float=1.2, bool=False, weekday=u'Saturday')
     >>> sorted(decode(data, ISimple).items())
     [('ascii', 'E\nF'), ('ascii_line', 'B'), ('bool', False), ('float', 1.2), ('int', 3), ('list', None), ('listchoice', None), ('text', u'C\nD'), ('text_line', u'A'), ('weekday', u'Saturday')]
 
-If any values are missing from the input dictionary, they will default to
-``missing_value``.
+If any values are missing from the input dictionary,
+they will default to ``missing_value``.
+
+.. code-block:: python
 
     >>> data = dict(text_line=u'A', ascii_line=u'B', int=3, float=1.2, bool=False, weekday=u'Saturday')
     >>> sorted(decode(data, ISimple).items())
@@ -126,24 +148,32 @@ If any values are missing from the input dictionary, they will default to
 
 If you pass ``missing=False``, the values are ignored instead.
 
+.. code-block:: python
+
     >>> data = dict(text_line=u'A', ascii_line=u'B', int=3, float=1.2, bool=False)
     >>> sorted(decode(data, ISimple, missing=False).items())
     [('ascii_line', 'B'), ('bool', False), ('float', 1.2), ('int', 3), ('text_line', u'A')]
 
 Decoding also works for lists and their value types:
 
+.. code-block:: python
+
     >>> data = dict(list=[u'a', u'b'])
     >>> sorted(decode(data, ISequences, missing=False).items())
     [('list', ['a', 'b'])]
 
 Decoding should work with lists and the ISimple schema
 
+.. code-block:: python
+
     >>> data = dict(list=['a', 'b'])
     >>> sorted(decode(data, ISimple, missing=False).items())
     [('list', [u'a', u'b'])]
 
 And list choice fields
 
+.. code-block:: python
+
     >>> data = dict(listchoice=['a', 'b'])
     >>> sorted(decode(data, ISimple, missing=False).items())
     [('listchoice', ['a', 'b'])]


Repository: plone.tiles


Branch: refs/heads/master
Date: 2016-08-18T10:32:56+02:00
Author: Gil Forcada (gforcada) <gforcada@gnome.org>
Commit: https://github.com/plone/plone.tiles/commit/04be812d701e1f510aff736342309cef4d517bd2

Typos and reformat esi.rst

Files changed:
M plone/tiles/esi.rst

diff --git a/plone/tiles/esi.rst b/plone/tiles/esi.rst
index d7804c0..45fcdc6 100644
--- a/plone/tiles/esi.rst
+++ b/plone/tiles/esi.rst
@@ -1,15 +1,16 @@
 ESI support
 ===========
 
-Some sites may choose to render tiles in a delayed fashion using Edge Side
-Includes or some similar mechanism. ``plone.tiles`` includes some support to
-help render ESI placeholders. This is used in ``plone.app.blocks`` to
-facilitate ESI rendering. Since ESI normally involves a "dumb" replacement
-operation, ``plone.tiles`` also provides a means of accessing just the head
-and/or just the body of a tile.
+Some sites may choose to render tiles in a delayed fashion using Edge Side Includes or some similar mechanism.
+``plone.tiles`` includes some support to help render ESI placeholders.
+This is used in ``plone.app.blocks`` to facilitate ESI rendering.
+Since ESI normally involves a "dumb" replacement operation,
+``plone.tiles`` also provides a means of accessing just the head and/or just the body of a tile.
 
 To use the package, you should first load its ZCML configuration.
 
+.. code-block:: python
+
     >>> configuration = """\
     ... <configure
     ...      xmlns="http://namespaces.zope.org/zope"
@@ -32,35 +33,38 @@ To use the package, you should first load its ZCML configuration.
 Marking a tile as ESI-rendered
 ------------------------------
 
-For ESI rendering to be available, the tile must be marked with the
-``IESIRendered`` marker interface. We can create a dummy tile with this
-interface like so:
+For ESI rendering to be available, the tile must be marked with the ``IESIRendered`` marker interface.
+We can create a dummy tile with this interface like so:
+
+.. code-block:: python
 
-    >>> from zope.interface import implements
+    >>> from zope.interface import implementer
     >>> from plone.tiles.interfaces import IESIRendered
     >>> from plone.tiles import Tile
 
-    >>> class SampleTile(Tile):
-    ...     implements(IESIRendered)
+    >>> @implementer(IESIRendered)
+    ... class SampleTile(Tile):
     ...
     ...     __name__ = 'sample.tile' # would normally be set by ZCML handler
     ...
     ...     def __call__(self):
-    ...         return "<html><head><title>Title</title></head><body><b>My tile</b></body></html>"
+    ...         return '<html><head><title>Title</title></head><body><b>My tile</b></body></html>'
 
-Above, we have created a simple HTML string. This would normally be rendered
-using a page template.
+Above, we have created a simple HTML string.
+This would normally be rendered using a page template.
 
-We'll register this tile manually here. Ordinarily, of course, it would be
-registered via ZCML.
+We'll register this tile manually here.
+Ordinarily, of course, it would be registered via ZCML.
+
+.. code-block:: python
 
     >>> from plone.tiles.type import TileType
     >>> sampleTileType = TileType(
     ...     name=u'sample.tile',
-    ...     title=u"Sample tile",
-    ...     description=u"A tile used for testing",
-    ...     add_permission="dummy.Permission",
-    ...     view_permission="dummy.Permission",
+    ...     title=u'Sample tile',
+    ...     description=u'A tile used for testing',
+    ...     add_permission='dummy.Permission',
+    ...     view_permission='dummy.Permission',
     ...     schema=None)
 
     >>> from zope.component import provideAdapter, provideUtility
@@ -68,34 +72,43 @@ registered via ZCML.
     >>> from plone.tiles.interfaces import IBasicTile
 
     >>> provideUtility(sampleTileType, name=u'sample.tile')
-    >>> provideAdapter(SampleTile, (Interface, Interface), IBasicTile, name=u"sample.tile")
+    >>> provideAdapter(SampleTile, (Interface, Interface), IBasicTile, name=u'sample.tile')
 
 ESI lookup
 ----------
 
-When a page is rendered (for example by a system like ``plone.app.blocks``,
-but see below), a tile placeholder may be replaced by a link such as::
+When a page is rendered
+(for example by a system like ``plone.app.blocks``, but see below),
+a tile placeholder may be replaced by a link such as:
+
+.. code-block:: xml
 
     <esi:include src="/path/to/context/@@sample.tile/tile1/@@esi-body" />
 
-When this is resolved, it will return the body part of the tile. Equally,
-a tile in the head can be replaced by::
+When this is resolved, it will return the body part of the tile.
+Equally, a tile in the head can be replaced by:
+
+.. code-block:: xml
 
     <esi:include src="/path/to/context/@@sample.tile/tile1/@@esi-head" />
 
-To illustrate how this works, let's create a sample context, look up the view
-as it would be during traversal, and instantiate the tile, before looking up
-the ESI views and rendering them.
+To illustrate how this works,
+let's create a sample context,
+look up the view as it would be during traversal,
+and instantiate the tile,
+before looking up the ESI views and rendering them.
+
+.. code-block:: python
 
-    >>> from zope.interface import implements
+    >>> from zope.interface import implementer
+    >>> from zope.publisher.browser import TestRequest
 
     >>> class IContext(Interface):
     ...     pass
 
-    >>> class Context(object):
-    ...     implements(IContext)
-
-    >>> from zope.publisher.browser import TestRequest
+    >>> @implementer(IContext)
+    ... class Context(object):
+    ...     pass
 
     >>> class IntegratedTestRequest(TestRequest):
     ...     @property
@@ -105,80 +118,90 @@ the ESI views and rendering them.
     >>> context = Context()
     >>> request = IntegratedTestRequest()
 
-    >>> from zope.interface import Interface
-    >>> from zope.component import getMultiAdapter
-
 The following simulates traversal to ``context/@@sample.tile/tile1``
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+.. code-block:: python
+
+    >>> from zope.interface import Interface
+    >>> from zope.component import getMultiAdapter
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> tile = tile['tile1'] # simulates sub-path traversal
 
-This tile should be ESI rendered::
+This tile should be ESI rendered:
+
+.. code-block:: python
 
     >>> IESIRendered.providedBy(tile)
     True
 
 At this point, we can look up the ESI views:
 
-    >>> head = getMultiAdapter((tile, request), name="esi-head")
+.. code-block:: python
+
+    >>> head = getMultiAdapter((tile, request), name='esi-head')
     >>> print head()
     <title>Title</title>
 
-    >>> body = getMultiAdapter((tile, request), name="esi-body")
+    >>> body = getMultiAdapter((tile, request), name='esi-body')
     >>> print body()
     <b>My tile</b>
 
 Tiles without heads or bodies
 -----------------------------
 
-In general, tiles are supposed to return full HTML documents. The ``esi-head``
-and ``esi-body`` views are tolerant of tiles that do not. If they cannot find
-a ``<head />`` or ``<body />`` element, respectively, they will return the
-underlying tile output unaltered.
+In general, tiles are supposed to return full HTML documents.
+The ``esi-head`` and ``esi-body`` views are tolerant of tiles that do not.
+If they cannot find a ``<head />`` or ``<body />`` element, respectively, they will return the underlying tile output unaltered.
 
 For example:
 
+.. code-block:: python
+
     >>> from plone.tiles.esi import ESITile
     >>> class LazyTile(ESITile):
     ...     __name__ = 'sample.esi1' # would normally be set by ZCML handler
     ...     def __call__(self):
-    ...         return "<title>Page title</title>"
+    ...         return '<title>Page title</title>'
 
-We won't bother to register this for this test, instead just instantiating
-it directly:
+We won't bother to register this for this test, instead just instantiating it directly:
+
+.. code-block:: python
 
     >>> tile = LazyTile(context, request)['tile1']
 
     >>> IESIRendered.providedBy(tile)
     True
 
-    >>> head = getMultiAdapter((tile, request), name="esi-head")
+    >>> head = getMultiAdapter((tile, request), name='esi-head')
     >>> print head()
     <title>Page title</title>
 
-Of course, the ESI body renderer would return the same thing, since it can't
-extract a specific body either:
+Of course, the ESI body renderer would return the same thing,
+since it can't extract a specific body either:
+
+.. code-block:: python
 
-    >>> body = getMultiAdapter((tile, request), name="esi-body")
+    >>> body = getMultiAdapter((tile, request), name='esi-body')
     >>> print body()
     <title>Page title</title>
 
-In this case, we would likely end up with invalid HTML, since the
-``<title />`` tag is not allowed in the body. Whether and how to resolve
-this is left up to the ESI interpolation implementation.
+In this case, we would likely end up with invalid HTML,
+since the ``<title />`` tag is not allowed in the body.
+Whether and how to resolve this is left up to the ESI interpolation implementation.
 
 Convenience classes and placeholder rendering
 ---------------------------------------------
 
 Two convenience base classes can be found in the ``plone.tiles.esi`` module.
-These extend the standard ``Tile`` and ``PersistentTile`` classes
-to provide the ``IESIRendered`` interface.
+These extend the standard ``Tile`` and ``PersistentTile`` classes to provide the ``IESIRendered`` interface.
 
 * ``plone.tiles.esi.ESITile``, a transient, ESI-rendered tile
 * ``plone.tiles.esi.ESIPersistentTile``, a persistent, ESI-rendered tile
 
-These are particularly useful if you are creating a template-only tile and
-want ESI rendering. For example::
+These are particularly useful if you are creating a template-only tile and want ESI rendering.
+For example:
+
+.. code-block:: xml
 
     <plone:tile
         name="sample.esitile"
@@ -190,52 +213,58 @@ want ESI rendering. For example::
         permission="zope.View"
         />
 
-Additionally, these base classes implement a ``__call__()`` method that will
-render a tile placeholder if the request contains an ``X-ESI-Enabled``
-header set to the literal 'true'.
+Additionally,
+these base classes implement a ``__call__()`` method that will render a tile placeholder,
+if the request contains an ``X-ESI-Enabled`` header set to the literal 'true'.
 
-The placeholder is a simple HTML ``<a />`` tag, which can be transformed into
-an ``<esi:include />`` tag using the helper function ``substituteESILinks()``.
-The reason for this indirection is that the ``esi`` namespace is not allowed
-in HTML documents and are liable to be stripped out by transforms using the
-``libxml2`` / ``lxml`` HTML parser.
+The placeholder is a simple HTML ``<a />`` tag,
+which can be transformed into an ``<esi:include />`` tag using the helper function ``substituteESILinks()``.
+The reason for this indirection is that the ``esi`` namespace is not allowed in HTML documents,
+and are liable to be stripped out by transforms using the ``libxml2`` / ``lxml`` HTML parser.
 
 Let us now create a simple ESI tile. To benefit from the default rendering,
 we should implement the ``render()`` method instead of ``__call__()``. Setting
 a page template as the ``index`` class variable or using the ``template``
 attribute to the ZCML directive will work also.
 
+.. code-block:: python
+
     >>> from plone.tiles.esi import ESITile
 
     >>> class SampleESITile(ESITile):
     ...     __name__ = 'sample.esitile' # would normally be set by ZCML handler
     ...
     ...     def render(self):
-    ...         return "<html><head><title>Title</title></head><body><b>My ESI tile</b></body></html>"
+    ...         return '<html><head><title>Title</title></head><body><b>My ESI tile</b></body></html>'
 
     >>> sampleESITileType = TileType(
     ...     name=u'sample.esitile',
-    ...     title=u"Sample ESI tile",
-    ...     description=u"A tile used for testing ESI",
-    ...     add_permission="dummy.Permission",
-    ...     view_permission="dummy.Permission",
+    ...     title=u'Sample ESI tile',
+    ...     description=u'A tile used for testing ESI',
+    ...     add_permission='dummy.Permission',
+    ...     view_permission='dummy.Permission',
     ...     schema=None)
 
     >>> provideUtility(sampleESITileType, name=u'sample.esitile')
-    >>> provideAdapter(SampleESITile, (Interface, Interface), IBasicTile, name=u"sample.esitile")
+    >>> provideAdapter(SampleESITile, (Interface, Interface), IBasicTile, name=u'sample.esitile')
 
 The following simulates traversal to ``context/@@sample.esitile/tile1``
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.esitile")
+.. code-block:: python
+
+    >>> tile = getMultiAdapter((context, request), name=u'sample.esitile')
     >>> tile = tile['tile1'] # simulates sub-path traversal
 
 By default, the tile renders as normal:
 
+.. code-block:: python
+
     >>> print tile()
     <html><head><title>Title</title></head><body><b>My ESI tile</b></body></html>
 
-However, if we opt into ESI rendering via a request header, we get a different
-view:
+However, if we opt into ESI rendering via a request header, we get a different view:
+
+.. code-block:: python
 
     >>> from plone.tiles.interfaces import ESI_HEADER_KEY
     >>> request.environ[ESI_HEADER_KEY] = 'true'
@@ -252,6 +281,8 @@ view:
 
 This can be transformed into a proper ESI tag with ``substituteESILinks()``:
 
+.. code-block:: python
+
     >>> from plone.tiles.esi import substituteESILinks
     >>> print substituteESILinks(tile()) # doctest: +NORMALIZE_WHITESPACE
     <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
@@ -262,9 +293,11 @@ This can be transformed into a proper ESI tag with ``substituteESILinks()``:
         </body>
     </html>
 
-It is also possible to render the ESI tile for the head. This is done with
-a class variable 'head' (which would of course normally be set within the
-class):
+It is also possible to render the ESI tile for the head.
+This is done with a class variable 'head'
+(which would of course normally be set within the class):
+
+.. code-block:: python
 
     >>> SampleESITile.head = True
     >>> print tile() # doctest: +NORMALIZE_WHITESPACE


Repository: plone.tiles


Branch: refs/heads/master
Date: 2016-08-18T10:32:56+02:00
Author: Gil Forcada (gforcada) <gforcada@gnome.org>
Commit: https://github.com/plone/plone.tiles/commit/9d091c89be178417f25526646a5c6efec455943c

Update CHANGES

Files changed:
M CHANGES.rst

diff --git a/CHANGES.rst b/CHANGES.rst
index 57cc432..ea52864 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,8 +4,8 @@ Changelog
 1.6.1 (unreleased)
 ------------------
 
-- Nothing changed yet.
-
+- Reformat docs.
+  [gforcada]
 
 1.6 (2016-06-27)
 ----------------


Repository: plone.tiles


Branch: refs/heads/master
Date: 2016-08-19T13:26:47+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.tiles/commit/11c96304cc88672b5267ca6b092122558f19b463

Merge pull request #10 from plone/gforcada-typos

Reformat docs

Files changed:
M CHANGES.rst
M README.rst
M plone/tiles/data.rst
M plone/tiles/directives.rst
M plone/tiles/esi.rst
M plone/tiles/tiles.rst

diff --git a/CHANGES.rst b/CHANGES.rst
index 57cc432..ea52864 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,8 +4,8 @@ Changelog
 1.6.1 (unreleased)
 ------------------
 
-- Nothing changed yet.
-
+- Reformat docs.
+  [gforcada]
 
 1.6 (2016-06-27)
 ----------------
diff --git a/README.rst b/README.rst
index 5303eba..fbc7038 100644
--- a/README.rst
+++ b/README.rst
@@ -1,3 +1,4 @@
+===========
 plone.tiles
 ===========
 
@@ -10,7 +11,7 @@ plone.tiles
 
 
 Introduction
-------------
+============
 
 For the purposes of this package,
 a tile is a browser view and an associated utility providing some metadata about that view.
@@ -20,7 +21,7 @@ The idea is that a UI (such as Mosaic) can present the user with a list of inser
 
 A tile is inserted into a layout as a link:
 
-.. code:: xml
+.. code-block:: xml
 
     <link rel="tile" target="placeholder" href="./@@sample.tile/tile1?option1=value1" />
 
@@ -48,7 +49,7 @@ There are three interfaces describing tiles in this package:
     which gives the canonical tile URL,
     including the id sub-path and any query string parameters.
     (Note that tiles also correctly implement ``IAbsoluteURL``.)
-```IPersistentTile``
+``IPersistentTile``
     describes a tile that stores its configuration in object annotations,
     and is needed when configuration values cannot be encoded into a query string.
     The default implementation is in ``plone.tiles.PersistentTile``.
@@ -78,14 +79,14 @@ Creating a Simple Tile
 
 The most basic tile looks like this:
 
-.. code:: python
+.. code-block:: python
 
     from plone.tiles import Tile
 
     class MyTile(Tile):
 
         def __call__(self):
-            return u"<html><body><p>Hello world</p></body></html>"
+            return u'<html><body><p>Hello world</p></body></html>'
 
 Note that the tile is expected to return a complete HTML document.
 This will be interpolated into the page output according to the following rules:
@@ -94,12 +95,14 @@ This will be interpolated into the page output according to the following rules:
 * The contents of the tile's ``<body />`` section will replace the tile placeholder as indicated by the tile link.
 
 Note that this package does *not* provide these interpolations.
-For a Plone implementation of the interpolation algorithm, see `plone.app.blocks`_
+For a Plone implementation of the interpolation algorithm, see `plone.app.blocks`_.
 
 If you require a persistent tile, subclass ``plone.tiles.PersistentTile`` instead.
 You may also need a schema interface if you want a configurable transient or persistent tile.
 
-To register the tile, use ZCML like this::
+To register the tile, use ZCML like this:
+
+.. code-block:: xml
 
     <configure xmlns:plone="http://namespaces.plone.org/plone">
 
@@ -120,48 +123,56 @@ To register the tile, use ZCML like this::
     </configure>
 
 The first five attributes describe the tile by configuring an appropriate ``ITileType`` directive.
-The rest mimics the ``<browser:page />`` directive, so you can specify a ``template`` file and omit the ``class``, or use both a ``template`` and ``class``.
+The rest mimics the ``<browser:page />`` directive,
+so you can specify a ``template`` file and omit the ``class``, or use both a ``template`` and ``class``.
 
-If you want to register a persistent tile with a custom schema, but a template only, you can do e.g.::
+If you want to register a persistent tile with a custom schema, but a template only, you can do e.g.:
 
-        <plone:tile
-            name="sample.persistenttile"
-            title="A title for the tile"
-            description="My tile's description"
-            add_permission="my.add.Permission"
-            schema=".interfaces.IMyTileSchema"
-            class="plone.tiles.PersistentTile"
-            template="mytile.pt"
-            permission="zope.Public"
-            for="*"
-            />
+.. code-block:: xml
+
+    <plone:tile
+        name="sample.persistenttile"
+        title="A title for the tile"
+        description="My tile's description"
+        add_permission="my.add.Permission"
+        schema=".interfaces.IMyTileSchema"
+        class="plone.tiles.PersistentTile"
+        template="mytile.pt"
+        permission="zope.Public"
+        for="*"
+        />
 
 If you want to override an existing tile, e.g. with a new layer or more specific context,
 you *must* omit the tile metadata (title, description, icon, add permission or schema).
-If you include any metadata you will get a conflict error on Zope startup. This example shows how to use a different template for our tile::
+If you include any metadata you will get a conflict error on Zope startup.
+This example shows how to use a different template for our tile:
 
-        <plone:tile
-            name="sample.persistenttile"
-            template="override.pt"
-            permission="zope.Public"
-            for="*"
-            layer=".interfaces.IMyLayer"
-            />
+.. code-block:: xml
+
+    <plone:tile
+        name="sample.persistenttile"
+        template="override.pt"
+        permission="zope.Public"
+        for="*"
+        layer=".interfaces.IMyLayer"
+        />
 
 ZCML Reference
 --------------
 
 The ``plone:tile`` directive uses the namespace ``xmlns:plone="http://namespaces.plone.org/plone"``.
-In order to enable it loading of its ``meta.zcml`` is needed, use::
+In order to enable it loading of its ``meta.zcml`` is needed, use:
+
+.. code-block:: xml
 
     <include package="plone.tiles" file="meta.zcml" />
 
 When registering a tile, in the background two registrations are done:
 
-1) How to **add** the tile (registered as a utility component as a instance of ``plone.tiles.type.TileType``).
+1) How to **add** the tile (registered as a utility component as an instance of ``plone.tiles.type.TileType``).
 
    It is possible to register a tile without adding capabilities.
-   However, such a tile needs to be directly called, there wont be any TTW adding possible.
+   However, such a tile needs to be directly called, there won't be any TTW adding possible.
 
    This registration can be done once only.
 
@@ -177,7 +188,7 @@ When registering a tile, in the background two registrations are done:
    - ``delete_permission`` (optional, default to add_permission)
    - ``schema`` (optional)
 
-2) How to **render** the tile (as a usal page).
+2) How to **render** the tile (as a usual page).
 
    It is possible to register different renderers for the same ``name`` but for different contexts (``for`` or ``layer``).
 
@@ -229,7 +240,7 @@ The **directives attributes** have the following meaning:
     The layer (request marker interface) the tile is available for.
 
 ``class``
-    Class implementing this tile. A browser view providing ``IBasicTile`` or one of its derivates.
+    Class implementing this tile. A browser view providing ``IBasicTile`` or one of its derivatives.
 
 ``template``
     The name of a template that renders this tile.
diff --git a/plone/tiles/data.rst b/plone/tiles/data.rst
index 2a40190..78f3ecc 100644
--- a/plone/tiles/data.rst
+++ b/plone/tiles/data.rst
@@ -2,8 +2,9 @@
 Data encoding/decoding
 ======================
 
-This test exercises the ``encode()`` and ``decode()`` methods in
-``plone.tiles.data``.
+This test exercises the ``encode()`` and ``decode()`` methods in ``plone.tiles.data``.
+
+.. code-block:: python
 
     >>> from zope.interface import Interface
     >>> from zope import schema
@@ -15,28 +16,34 @@ Encoding
 
 First, we'll create a simple schema that exercises several field types:
 
+.. code-block:: python
+
     >>> weekdays = [u'Monday', u'Tuesday', u'Wednesday', u'Thursday',
     ...             u'Friday', u'Saturday', u'Sunday']
     >>> class ISimple(Interface):
-    ...     text_line   = schema.TextLine(title=u"Text")
-    ...     ascii_line  = schema.ASCIILine(title=u"ASCII")
-    ...     text        = schema.Text(title=u"Text", missing_value=u"Missing")
-    ...     ascii       = schema.ASCII(title=u"ASCII")
-    ...     int         = schema.Int(title=u"Int")
-    ...     float       = schema.Float(title=u"Float")
-    ...     bool        = schema.Bool(title=u"Bool")
-    ...     weekday     = schema.Choice(title=u"Weekday", values=weekdays)
+    ...     text_line   = schema.TextLine(title=u'Text')
+    ...     ascii_line  = schema.ASCIILine(title=u'ASCII')
+    ...     text        = schema.Text(title=u'Text', missing_value=u'Missing')
+    ...     ascii       = schema.ASCII(title=u'ASCII')
+    ...     int         = schema.Int(title=u'Int')
+    ...     float       = schema.Float(title=u'Float')
+    ...     bool        = schema.Bool(title=u'Bool')
+    ...     weekday     = schema.Choice(title=u'Weekday', values=weekdays)
     ...     list        = schema.List(value_type=schema.TextLine())
     ...     listchoice  = schema.List(value_type=schema.Choice(vocabulary='foobar'))
 
 A simple encode produces a query string:
 
+.. code-block:: python
+
     >>> data = dict(text_line=u'A', ascii_line='B', text=u'C\nD', ascii='E\nF', int=3, float=1.2, bool=False, weekday=u'Saturday')
     >>> encode(data, ISimple)
     'text_line=A&ascii_line=B&text%3Atext=C%0AD&ascii%3Atext=E%0AF&int%3Along=3&float%3Afloat=1.2&bool%3Aboolean=&weekday=Saturday'
 
-Notice how a boolean is encoded as an empty value. If it were true, it'd be
-encoded as 1:
+Notice how a boolean is encoded as an empty value.
+If it were true, it'd be encoded as 1:
+
+.. code-block:: python
 
     >>> data = dict(text_line=u'A', ascii_line='B', text=u'C\nD', ascii='E\nF', int=3, float=1.2, bool=True, weekday=u'Saturday')
     >>> encode(data, ISimple)
@@ -44,27 +51,35 @@ encoded as 1:
 
 If the data dictionary has values not in the interface, they are ignored:
 
+.. code-block:: python
+
     >>> data = dict(text_line=u'A', ascii_line='B', text=u'C\nD', ascii='E\nF', int=3, float=1.2, bool=True, weekday=u'Saturday', foo=123)
     >>> encode(data, ISimple)
     'text_line=A&ascii_line=B&text%3Atext=C%0AD&ascii%3Atext=E%0AF&int%3Along=3&float%3Afloat=1.2&bool%3Aboolean=1&weekday=Saturday'
 
 If the data dictionary omits some fields, they are ignored.
 
+.. code-block:: python
+
     >>> data = dict(text_line=u'A', ascii_line='B', text=u'C\nD', ascii='E\nF', float=1.2, bool=True, foo=123)
     >>> encode(data, ISimple)
     'text_line=A&ascii_line=B&text%3Atext=C%0AD&ascii%3Atext=E%0AF&float%3Afloat=1.2&bool%3Aboolean=1'
 
 It is also possible to explicitly ignore some fields:
 
+.. code-block:: python
+
     >>> data = dict(text_line=u'A', ascii_line='B', text=u'C\nD', ascii='E\nF', float=1.2, bool=True, foo=123)
     >>> encode(data, ISimple, ignore=('text_line', 'text',))
     'ascii_line=B&ascii%3Atext=E%0AF&float%3Afloat=1.2&bool%3Aboolean=1'
 
 Lists and tuples may also be encoded. The value type will be encoded as well.
 
+.. code-block:: python
+
     >>> class ISequences(Interface):
-    ...     list    = schema.List(title=u"List", value_type=schema.ASCIILine(title=u"Text"))
-    ...     tuple   = schema.Tuple(title=u"List", value_type=schema.Int(title=u"Int"))
+    ...     list    = schema.List(title=u'List', value_type=schema.ASCIILine(title=u'Text'))
+    ...     tuple   = schema.Tuple(title=u'List', value_type=schema.Int(title=u'Int'))
 
     >>> data = dict(list=['a', 'b'], tuple=(1,2,3))
     >>> encode(data, ISequences)
@@ -72,21 +87,25 @@ Lists and tuples may also be encoded. The value type will be encoded as well.
 
 Even dictionaries may be encoded. And the value type will be encoded as well.
 
+.. code-block:: python
+
     >>> class IRecords(Interface):
-    ...     record = schema.Dict(title=u"Record")
-    ...     records = schema.List(title=u"Records", value_type=schema.Dict())
+    ...     record = schema.Dict(title=u'Record')
+    ...     records = schema.List(title=u'Records', value_type=schema.Dict())
 
     >>> data = dict(record={'a': 'b', 'c': True}, records=[{'a': 'b', 'c': True}])
     >>> encode(data, IRecords)
     'record.a%3Arecord=b&record.c%3Aboolean%3Arecord=1&records.a%3Arecords=b&records.c%3Aboolean%3Arecords=1'
 
-Unsupported fields will raise a ComponentLookupError. This also
-applies to the value_type of a list or tuple:
+Unsupported fields will raise a ComponentLookupError.
+This also applies to the value_type of a list or tuple:
+
+.. code-block:: python
 
     >>> class IUnsupported(Interface):
-    ...     decimal     = schema.Decimal(title=u"Decimal")
-    ...     list        = schema.List(title=u"Set", value_type=schema.Decimal(title=u"Decimal"))
-    ...     bytes_line  = schema.BytesLine(title=u"Bytes line")
+    ...     decimal     = schema.Decimal(title=u'Decimal')
+    ...     list        = schema.List(title=u'Set', value_type=schema.Decimal(title=u'Decimal'))
+    ...     bytes_line  = schema.BytesLine(title=u'Bytes line')
 
     >>> from decimal import Decimal
     >>> data = dict(decimal=Decimal(2), list=[Decimal(1), Decimal(2),], bytes_line='abc')
@@ -106,19 +125,22 @@ applies to the value_type of a list or tuple:
 Decoding
 --------
 
-The decoder exists because the Zope form marshalers are not perfect: for
-instance, they cannot adequately deal with the differences between unicode
-and ASCII. ``zope.schema`` is picky about that sort of thing.
+The decoder exists because the Zope form marshalers are not perfect:
+for instance, they cannot adequately deal with the differences between unicode and ASCII.
+``zope.schema`` is picky about that sort of thing.
 
-Let's use a data dictionary that may have come back from a query string like
-the first example above.
+Let's use a data dictionary that may have come back from a query string like the first example above.
+
+.. code-block:: python
 
     >>> data = dict(text_line=u'A', ascii_line=u'B', text=u'C\nD', ascii=u'E\nF', int=3, float=1.2, bool=False, weekday=u'Saturday')
     >>> sorted(decode(data, ISimple).items())
     [('ascii', 'E\nF'), ('ascii_line', 'B'), ('bool', False), ('float', 1.2), ('int', 3), ('list', None), ('listchoice', None), ('text', u'C\nD'), ('text_line', u'A'), ('weekday', u'Saturday')]
 
-If any values are missing from the input dictionary, they will default to
-``missing_value``.
+If any values are missing from the input dictionary,
+they will default to ``missing_value``.
+
+.. code-block:: python
 
     >>> data = dict(text_line=u'A', ascii_line=u'B', int=3, float=1.2, bool=False, weekday=u'Saturday')
     >>> sorted(decode(data, ISimple).items())
@@ -126,24 +148,32 @@ If any values are missing from the input dictionary, they will default to
 
 If you pass ``missing=False``, the values are ignored instead.
 
+.. code-block:: python
+
     >>> data = dict(text_line=u'A', ascii_line=u'B', int=3, float=1.2, bool=False)
     >>> sorted(decode(data, ISimple, missing=False).items())
     [('ascii_line', 'B'), ('bool', False), ('float', 1.2), ('int', 3), ('text_line', u'A')]
 
 Decoding also works for lists and their value types:
 
+.. code-block:: python
+
     >>> data = dict(list=[u'a', u'b'])
     >>> sorted(decode(data, ISequences, missing=False).items())
     [('list', ['a', 'b'])]
 
 Decoding should work with lists and the ISimple schema
 
+.. code-block:: python
+
     >>> data = dict(list=['a', 'b'])
     >>> sorted(decode(data, ISimple, missing=False).items())
     [('list', [u'a', u'b'])]
 
 And list choice fields
 
+.. code-block:: python
+
     >>> data = dict(listchoice=['a', 'b'])
     >>> sorted(decode(data, ISimple, missing=False).items())
     [('listchoice', ['a', 'b'])]
diff --git a/plone/tiles/directives.rst b/plone/tiles/directives.rst
index 835480a..d26ecf3 100644
--- a/plone/tiles/directives.rst
+++ b/plone/tiles/directives.rst
@@ -1,23 +1,27 @@
 ZCML directive
 ==============
 
-A tile is really just a browser view providing ``IBasicTile`` (or, more
-commonly, ``ITile`` or ``IPersistentTile``) coupled with a named utility
-providing ``ITileType``. The names of the browser view and the tile should
-match.
-
-To make it easier to register these components, this package provides a
-``<plone:tile />`` directive that sets up both. It supports several use cases:
-
-  * Registering a new tile from a class
-  * Registering a new tile from a template only
-  * Registering a new tile form a class and a template
-  * Registering a new tile for an existing tile type (e.g. for a new layer)
-
-To test this, we have created a dummy schema and a dummy tile in ``tests.py``,
+A tile is really just a browser view providing ``IBasicTile``
+(or, more commonly, ``ITile`` or ``IPersistentTile``)
+coupled with a named utility providing ``ITileType``.
+The names of the browser view and the tile should match.
+
+To make it easier to register these components,
+this package provides a ``<plone:tile />`` directive that sets up both.
+It supports several use cases:
+
+* Registering a new tile from a class
+* Registering a new tile from a template only
+* Registering a new tile form a class and a template
+* Registering a new tile for an existing tile type (e.g. for a new layer)
+
+To test this,
+we have created a dummy schema and a dummy tile in ``tests.py``,
 and a dummy template in ``test.pt``.
 
-Let's show how these may be used by registering several tiles::
+Let's show how these may be used by registering several tiles:
+
+.. code-block:: python
 
     >>> configuration = """\
     ... <configure package="plone.tiles"
@@ -103,12 +107,14 @@ Let's show how these may be used by registering several tiles::
     >>> from zope.configuration import xmlconfig
     >>> xmlconfig.xmlconfig(StringIO(configuration))
 
-Let's check how the tiles were registered::
+Let's check how the tiles were registered:
+
+.. code-block:: python
 
     >>> from zope.component import getUtility
     >>> from plone.tiles.interfaces import ITileType
 
-    >>> tile1_type = getUtility(ITileType, name=u"dummy1")
+    >>> tile1_type = getUtility(ITileType, name=u'dummy1')
     >>> tile1_type
     <TileType dummy1 (Dummy tile 1)>
     >>> tile1_type.description
@@ -123,7 +129,7 @@ Let's check how the tiles were registered::
     >>> tile1_type.schema
     <InterfaceClass plone.tiles.tests.IDummySchema>
 
-    >>> tile2_type = getUtility(ITileType, name=u"dummy2")
+    >>> tile2_type = getUtility(ITileType, name=u'dummy2')
     >>> tile2_type
     <TileType dummy2 (Dummy tile 2)>
     >>> tile2_type.description is None
@@ -133,7 +139,7 @@ Let's check how the tiles were registered::
     >>> tile2_type.schema is None
     True
 
-    >>> tile3_type = getUtility(ITileType, name=u"dummy3")
+    >>> tile3_type = getUtility(ITileType, name=u'dummy3')
     >>> tile3_type
     <TileType dummy3 (Dummy tile 3)>
     >>> tile3_type.description is None
@@ -143,7 +149,7 @@ Let's check how the tiles were registered::
     >>> tile3_type.schema is None
     True
 
-    >>> tile4_type = getUtility(ITileType, name=u"dummy4")
+    >>> tile4_type = getUtility(ITileType, name=u'dummy4')
     >>> tile4_type
     <TileType dummy4 (Dummy tile 4)>
     >>> tile4_type.description is None
@@ -153,7 +159,9 @@ Let's check how the tiles were registered::
     >>> tile4_type.schema
     <InterfaceClass plone.tiles.tests.IDummySchema>
 
-Finally, let's check that we can look up the tiles::
+Finally, let's check that we can look up the tiles:
+
+.. code-block:: python
 
     >>> from zope.publisher.browser import TestRequest
     >>> from zope.interface import implements, alsoProvides
@@ -171,7 +179,7 @@ Finally, let's check that we can look up the tiles::
     >>> from plone.tiles import Tile, PersistentTile
     >>> from plone.tiles.tests import DummyTile, DummyTileWithTemplate
 
-    >>> tile1 = getMultiAdapter((context, layer_request), name="dummy1")
+    >>> tile1 = getMultiAdapter((context, layer_request), name='dummy1')
     >>> isinstance(tile1, DummyTileWithTemplate)
     True
     >>> print tile1()
@@ -179,7 +187,7 @@ Finally, let's check that we can look up the tiles::
     >>> tile1.__name__
     'dummy1'
 
-    >>> tile2 = getMultiAdapter((context, request), name="dummy2")
+    >>> tile2 = getMultiAdapter((context, request), name='dummy2')
     >>> isinstance(tile2, DummyTile)
     True
     >>> print tile2()
@@ -187,7 +195,7 @@ Finally, let's check that we can look up the tiles::
     >>> tile2.__name__
     'dummy2'
 
-    >>> tile3 = getMultiAdapter((context, request), name="dummy3")
+    >>> tile3 = getMultiAdapter((context, request), name='dummy3')
     >>> isinstance(tile3, Tile)
     True
     >>> print tile3()
@@ -195,7 +203,7 @@ Finally, let's check that we can look up the tiles::
     >>> tile3.__name__
     'dummy3'
 
-    >>> tile4 = getMultiAdapter((context, request), name="dummy4")
+    >>> tile4 = getMultiAdapter((context, request), name='dummy4')
     >>> isinstance(tile4, PersistentTile)
     True
     >>> print tile4()
@@ -203,7 +211,7 @@ Finally, let's check that we can look up the tiles::
     >>> tile4.__name__
     'dummy4'
 
-    >>> tile3_layer = getMultiAdapter((context, layer_request), name="dummy3")
+    >>> tile3_layer = getMultiAdapter((context, layer_request), name='dummy3')
     >>> isinstance(tile3_layer, DummyTile)
     True
     >>> print tile3_layer()
diff --git a/plone/tiles/esi.rst b/plone/tiles/esi.rst
index d7804c0..45fcdc6 100644
--- a/plone/tiles/esi.rst
+++ b/plone/tiles/esi.rst
@@ -1,15 +1,16 @@
 ESI support
 ===========
 
-Some sites may choose to render tiles in a delayed fashion using Edge Side
-Includes or some similar mechanism. ``plone.tiles`` includes some support to
-help render ESI placeholders. This is used in ``plone.app.blocks`` to
-facilitate ESI rendering. Since ESI normally involves a "dumb" replacement
-operation, ``plone.tiles`` also provides a means of accessing just the head
-and/or just the body of a tile.
+Some sites may choose to render tiles in a delayed fashion using Edge Side Includes or some similar mechanism.
+``plone.tiles`` includes some support to help render ESI placeholders.
+This is used in ``plone.app.blocks`` to facilitate ESI rendering.
+Since ESI normally involves a "dumb" replacement operation,
+``plone.tiles`` also provides a means of accessing just the head and/or just the body of a tile.
 
 To use the package, you should first load its ZCML configuration.
 
+.. code-block:: python
+
     >>> configuration = """\
     ... <configure
     ...      xmlns="http://namespaces.zope.org/zope"
@@ -32,35 +33,38 @@ To use the package, you should first load its ZCML configuration.
 Marking a tile as ESI-rendered
 ------------------------------
 
-For ESI rendering to be available, the tile must be marked with the
-``IESIRendered`` marker interface. We can create a dummy tile with this
-interface like so:
+For ESI rendering to be available, the tile must be marked with the ``IESIRendered`` marker interface.
+We can create a dummy tile with this interface like so:
+
+.. code-block:: python
 
-    >>> from zope.interface import implements
+    >>> from zope.interface import implementer
     >>> from plone.tiles.interfaces import IESIRendered
     >>> from plone.tiles import Tile
 
-    >>> class SampleTile(Tile):
-    ...     implements(IESIRendered)
+    >>> @implementer(IESIRendered)
+    ... class SampleTile(Tile):
     ...
     ...     __name__ = 'sample.tile' # would normally be set by ZCML handler
     ...
     ...     def __call__(self):
-    ...         return "<html><head><title>Title</title></head><body><b>My tile</b></body></html>"
+    ...         return '<html><head><title>Title</title></head><body><b>My tile</b></body></html>'
 
-Above, we have created a simple HTML string. This would normally be rendered
-using a page template.
+Above, we have created a simple HTML string.
+This would normally be rendered using a page template.
 
-We'll register this tile manually here. Ordinarily, of course, it would be
-registered via ZCML.
+We'll register this tile manually here.
+Ordinarily, of course, it would be registered via ZCML.
+
+.. code-block:: python
 
     >>> from plone.tiles.type import TileType
     >>> sampleTileType = TileType(
     ...     name=u'sample.tile',
-    ...     title=u"Sample tile",
-    ...     description=u"A tile used for testing",
-    ...     add_permission="dummy.Permission",
-    ...     view_permission="dummy.Permission",
+    ...     title=u'Sample tile',
+    ...     description=u'A tile used for testing',
+    ...     add_permission='dummy.Permission',
+    ...     view_permission='dummy.Permission',
     ...     schema=None)
 
     >>> from zope.component import provideAdapter, provideUtility
@@ -68,34 +72,43 @@ registered via ZCML.
     >>> from plone.tiles.interfaces import IBasicTile
 
     >>> provideUtility(sampleTileType, name=u'sample.tile')
-    >>> provideAdapter(SampleTile, (Interface, Interface), IBasicTile, name=u"sample.tile")
+    >>> provideAdapter(SampleTile, (Interface, Interface), IBasicTile, name=u'sample.tile')
 
 ESI lookup
 ----------
 
-When a page is rendered (for example by a system like ``plone.app.blocks``,
-but see below), a tile placeholder may be replaced by a link such as::
+When a page is rendered
+(for example by a system like ``plone.app.blocks``, but see below),
+a tile placeholder may be replaced by a link such as:
+
+.. code-block:: xml
 
     <esi:include src="/path/to/context/@@sample.tile/tile1/@@esi-body" />
 
-When this is resolved, it will return the body part of the tile. Equally,
-a tile in the head can be replaced by::
+When this is resolved, it will return the body part of the tile.
+Equally, a tile in the head can be replaced by:
+
+.. code-block:: xml
 
     <esi:include src="/path/to/context/@@sample.tile/tile1/@@esi-head" />
 
-To illustrate how this works, let's create a sample context, look up the view
-as it would be during traversal, and instantiate the tile, before looking up
-the ESI views and rendering them.
+To illustrate how this works,
+let's create a sample context,
+look up the view as it would be during traversal,
+and instantiate the tile,
+before looking up the ESI views and rendering them.
+
+.. code-block:: python
 
-    >>> from zope.interface import implements
+    >>> from zope.interface import implementer
+    >>> from zope.publisher.browser import TestRequest
 
     >>> class IContext(Interface):
     ...     pass
 
-    >>> class Context(object):
-    ...     implements(IContext)
-
-    >>> from zope.publisher.browser import TestRequest
+    >>> @implementer(IContext)
+    ... class Context(object):
+    ...     pass
 
     >>> class IntegratedTestRequest(TestRequest):
     ...     @property
@@ -105,80 +118,90 @@ the ESI views and rendering them.
     >>> context = Context()
     >>> request = IntegratedTestRequest()
 
-    >>> from zope.interface import Interface
-    >>> from zope.component import getMultiAdapter
-
 The following simulates traversal to ``context/@@sample.tile/tile1``
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+.. code-block:: python
+
+    >>> from zope.interface import Interface
+    >>> from zope.component import getMultiAdapter
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> tile = tile['tile1'] # simulates sub-path traversal
 
-This tile should be ESI rendered::
+This tile should be ESI rendered:
+
+.. code-block:: python
 
     >>> IESIRendered.providedBy(tile)
     True
 
 At this point, we can look up the ESI views:
 
-    >>> head = getMultiAdapter((tile, request), name="esi-head")
+.. code-block:: python
+
+    >>> head = getMultiAdapter((tile, request), name='esi-head')
     >>> print head()
     <title>Title</title>
 
-    >>> body = getMultiAdapter((tile, request), name="esi-body")
+    >>> body = getMultiAdapter((tile, request), name='esi-body')
     >>> print body()
     <b>My tile</b>
 
 Tiles without heads or bodies
 -----------------------------
 
-In general, tiles are supposed to return full HTML documents. The ``esi-head``
-and ``esi-body`` views are tolerant of tiles that do not. If they cannot find
-a ``<head />`` or ``<body />`` element, respectively, they will return the
-underlying tile output unaltered.
+In general, tiles are supposed to return full HTML documents.
+The ``esi-head`` and ``esi-body`` views are tolerant of tiles that do not.
+If they cannot find a ``<head />`` or ``<body />`` element, respectively, they will return the underlying tile output unaltered.
 
 For example:
 
+.. code-block:: python
+
     >>> from plone.tiles.esi import ESITile
     >>> class LazyTile(ESITile):
     ...     __name__ = 'sample.esi1' # would normally be set by ZCML handler
     ...     def __call__(self):
-    ...         return "<title>Page title</title>"
+    ...         return '<title>Page title</title>'
 
-We won't bother to register this for this test, instead just instantiating
-it directly:
+We won't bother to register this for this test, instead just instantiating it directly:
+
+.. code-block:: python
 
     >>> tile = LazyTile(context, request)['tile1']
 
     >>> IESIRendered.providedBy(tile)
     True
 
-    >>> head = getMultiAdapter((tile, request), name="esi-head")
+    >>> head = getMultiAdapter((tile, request), name='esi-head')
     >>> print head()
     <title>Page title</title>
 
-Of course, the ESI body renderer would return the same thing, since it can't
-extract a specific body either:
+Of course, the ESI body renderer would return the same thing,
+since it can't extract a specific body either:
+
+.. code-block:: python
 
-    >>> body = getMultiAdapter((tile, request), name="esi-body")
+    >>> body = getMultiAdapter((tile, request), name='esi-body')
     >>> print body()
     <title>Page title</title>
 
-In this case, we would likely end up with invalid HTML, since the
-``<title />`` tag is not allowed in the body. Whether and how to resolve
-this is left up to the ESI interpolation implementation.
+In this case, we would likely end up with invalid HTML,
+since the ``<title />`` tag is not allowed in the body.
+Whether and how to resolve this is left up to the ESI interpolation implementation.
 
 Convenience classes and placeholder rendering
 ---------------------------------------------
 
 Two convenience base classes can be found in the ``plone.tiles.esi`` module.
-These extend the standard ``Tile`` and ``PersistentTile`` classes
-to provide the ``IESIRendered`` interface.
+These extend the standard ``Tile`` and ``PersistentTile`` classes to provide the ``IESIRendered`` interface.
 
 * ``plone.tiles.esi.ESITile``, a transient, ESI-rendered tile
 * ``plone.tiles.esi.ESIPersistentTile``, a persistent, ESI-rendered tile
 
-These are particularly useful if you are creating a template-only tile and
-want ESI rendering. For example::
+These are particularly useful if you are creating a template-only tile and want ESI rendering.
+For example:
+
+.. code-block:: xml
 
     <plone:tile
         name="sample.esitile"
@@ -190,52 +213,58 @@ want ESI rendering. For example::
         permission="zope.View"
         />
 
-Additionally, these base classes implement a ``__call__()`` method that will
-render a tile placeholder if the request contains an ``X-ESI-Enabled``
-header set to the literal 'true'.
+Additionally,
+these base classes implement a ``__call__()`` method that will render a tile placeholder,
+if the request contains an ``X-ESI-Enabled`` header set to the literal 'true'.
 
-The placeholder is a simple HTML ``<a />`` tag, which can be transformed into
-an ``<esi:include />`` tag using the helper function ``substituteESILinks()``.
-The reason for this indirection is that the ``esi`` namespace is not allowed
-in HTML documents and are liable to be stripped out by transforms using the
-``libxml2`` / ``lxml`` HTML parser.
+The placeholder is a simple HTML ``<a />`` tag,
+which can be transformed into an ``<esi:include />`` tag using the helper function ``substituteESILinks()``.
+The reason for this indirection is that the ``esi`` namespace is not allowed in HTML documents,
+and are liable to be stripped out by transforms using the ``libxml2`` / ``lxml`` HTML parser.
 
 Let us now create a simple ESI tile. To benefit from the default rendering,
 we should implement the ``render()`` method instead of ``__call__()``. Setting
 a page template as the ``index`` class variable or using the ``template``
 attribute to the ZCML directive will work also.
 
+.. code-block:: python
+
     >>> from plone.tiles.esi import ESITile
 
     >>> class SampleESITile(ESITile):
     ...     __name__ = 'sample.esitile' # would normally be set by ZCML handler
     ...
     ...     def render(self):
-    ...         return "<html><head><title>Title</title></head><body><b>My ESI tile</b></body></html>"
+    ...         return '<html><head><title>Title</title></head><body><b>My ESI tile</b></body></html>'
 
     >>> sampleESITileType = TileType(
     ...     name=u'sample.esitile',
-    ...     title=u"Sample ESI tile",
-    ...     description=u"A tile used for testing ESI",
-    ...     add_permission="dummy.Permission",
-    ...     view_permission="dummy.Permission",
+    ...     title=u'Sample ESI tile',
+    ...     description=u'A tile used for testing ESI',
+    ...     add_permission='dummy.Permission',
+    ...     view_permission='dummy.Permission',
     ...     schema=None)
 
     >>> provideUtility(sampleESITileType, name=u'sample.esitile')
-    >>> provideAdapter(SampleESITile, (Interface, Interface), IBasicTile, name=u"sample.esitile")
+    >>> provideAdapter(SampleESITile, (Interface, Interface), IBasicTile, name=u'sample.esitile')
 
 The following simulates traversal to ``context/@@sample.esitile/tile1``
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.esitile")
+.. code-block:: python
+
+    >>> tile = getMultiAdapter((context, request), name=u'sample.esitile')
     >>> tile = tile['tile1'] # simulates sub-path traversal
 
 By default, the tile renders as normal:
 
+.. code-block:: python
+
     >>> print tile()
     <html><head><title>Title</title></head><body><b>My ESI tile</b></body></html>
 
-However, if we opt into ESI rendering via a request header, we get a different
-view:
+However, if we opt into ESI rendering via a request header, we get a different view:
+
+.. code-block:: python
 
     >>> from plone.tiles.interfaces import ESI_HEADER_KEY
     >>> request.environ[ESI_HEADER_KEY] = 'true'
@@ -252,6 +281,8 @@ view:
 
 This can be transformed into a proper ESI tag with ``substituteESILinks()``:
 
+.. code-block:: python
+
     >>> from plone.tiles.esi import substituteESILinks
     >>> print substituteESILinks(tile()) # doctest: +NORMALIZE_WHITESPACE
     <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
@@ -262,9 +293,11 @@ This can be transformed into a proper ESI tag with ``substituteESILinks()``:
         </body>
     </html>
 
-It is also possible to render the ESI tile for the head. This is done with
-a class variable 'head' (which would of course normally be set within the
-class):
+It is also possible to render the ESI tile for the head.
+This is done with a class variable 'head'
+(which would of course normally be set within the class):
+
+.. code-block:: python
 
     >>> SampleESITile.head = True
     >>> print tile() # doctest: +NORMALIZE_WHITESPACE
diff --git a/plone/tiles/tiles.rst b/plone/tiles/tiles.rst
index 51e6b13..e633953 100644
--- a/plone/tiles/tiles.rst
+++ b/plone/tiles/tiles.rst
@@ -1,25 +1,26 @@
 Tiles in detail
 ===============
 
-Tiles are a form of view component used to compose pages. Think of a tile as
-a view describing one part of a page, that can be configured with some data
-described by a schema and inserted into a layout via a dedicated GUI.
+Tiles are a form of view component used to compose pages.
+Think of a tile as a view describing one part of a page,
+that can be configured with some data described by a schema and inserted into a layout via a dedicated GUI.
 
-Like a browser view, a tile can be traversed to and published on its own. The
-tile should then return a full HTML page, including a <head /> with any
-required resources, and a <body /> with the visible part of the tile. This
-will then be merged into the page, using a system such as
-``plone.app.blocks``.
+Like a browser view, a tile can be traversed to and published on its own.
+The tile should then return a full HTML page,
+including a <head /> with any required resources,
+and a <body /> with the visible part of the tile.
+This will then be merged into the page, using a system such as ``plone.app.blocks``.
 
-The API in this package provides support for tiles being configured according
-to a schema with data either passed on the query string (transient tiles) or
-retrieved from annotations (persistent tiles).
+The API in this package provides support for tiles being configured according to a schema,
+with data either passed on the query string (transient tiles) or retrieved from annotations (persistent tiles).
 
-Note that there is no direct UI support in this package, so the forms that
-allow users to construct and edit tiles must live elsewhere. You may be
-interested in ``plone.app.tiles`` and ``plone.app.mosaic`` for that purpose.
+Note that there is no direct UI support in this package,
+so the forms that allow users to construct and edit tiles must live elsewhere.
+You may be interested in ``plone.app.tiles`` and ``plone.app.mosaic`` for that purpose.
 
-To use the package, you should first load its ZCML configuration.
+To use the package, you should first load its ZCML configuration:
+
+.. code-block:: python
 
     >>> configuration = """\
     ... <configure
@@ -43,19 +44,23 @@ To use the package, you should first load its ZCML configuration.
 A simple transient tile
 -----------------------
 
-A basic tile is a view that implements the ``ITile`` interface. The easiest
-way to do this is to subclass the ``Tile`` class.
+A basic tile is a view that implements the ``ITile`` interface.
+The easiest way to do this is to subclass the ``Tile`` class:
+
+.. code-block:: python
 
     >>> from plone.tiles import Tile
     >>> class SampleTile(Tile):
     ...
-    ...     __name__ = 'sample.tile' # would normally be set by ZCML handler
+    ...     __name__ = 'sample.tile' # would normally be set by a ZCML handler
     ...
     ...     def __call__(self):
-    ...         return "<html><body><b>My tile</b></body></html>"
+    ...         return '<html><body><b>My tile</b></body></html>'
 
 The tile is a browser view:
 
+.. code-block:: python
+
     >>> from plone.tiles.interfaces import ITile
     >>> ITile.implementedBy(SampleTile)
     True
@@ -64,32 +69,37 @@ The tile is a browser view:
     >>> IBrowserView.implementedBy(SampleTile)
     True
 
-The tile instance has a ``__name__`` attribute (normally set at class level
-by the ``<plone:tile />`` ZCML directive), as well as a property ``id``. The
-id may be set explicitly, either in code, or by sub-path traversal. For
-example, if the tile name is ``example.tile``, the id may be set to ``tile1``
-using a URL like ``http://example.com/foo/@@example.tile/tile1``.
+The tile instance has a ``__name__`` attribute
+(normally set at class level by the ``<plone:tile />`` ZCML directive),
+as well as a property ``id``.
+The id may be set explicitly, either in code, or by sub-path traversal.
+For example, if the tile name is ``example.tile``,
+the id may be set to ``tile1`` using an URL like ``http://example.com/foo/@@example.tile/tile1``.
+
+This tile is registered as a normal browser view,
+alongside a utility that provides some information about the tile itself.
+Normally, this is done using the ``<plone:tile />`` directive.
+Here's how to create one manually:
 
-This tile is registered as a normal browser view, alongside a utility that
-provides some information about the tile itself. Normally, this is done
-using the ``<plone:tile />`` directive. Here's how to create one manually:
+.. code-block:: python
 
     >>> from plone.tiles.type import TileType
     >>> sampleTileType = TileType(
     ...     u'sample.tile',
-    ...     u"Sample tile",
-    ...     "dummy.Permission",
-    ...     "dummy.Permission",
-    ...     description=u"A tile used for testing",
+    ...     u'Sample tile',
+    ...     'dummy.Permission',
+    ...     'dummy.Permission',
+    ...     description=u'A tile used for testing',
     ...     schema=None)
 
-The name should match the view name and the name the utility is registered
-under. The title and description may be used by the UI. The add permission
-is the name of a permission that will be required to insert the tile. The
-schema attribute may be used to indicate schema interface describing the
-tile's configurable data - more on this below.
+The name should match the view name and the name the utility is registered under.
+The title and description may be used by the UI.
+The add permission is the name of a permission that will be required to insert the tile.
+The schema attribute may be used to indicate schema interface describing the tile's configurable data - more on this below.
 
-To register a tile in ZCML, we could do::
+To register a tile in ZCML, we could do:
+
+.. code-block:: xml
 
     <plone:tile
         name="sample.tile"
@@ -101,31 +111,35 @@ To register a tile in ZCML, we could do::
         permission="zope.Public"
         />
 
-**Note:** The tile name should be a dotted name, prefixed by a namespace you
-control. It's a good idea to use a package name for this purpose.
+.. note:: The tile name should be a dotted name, prefixed by a namespace you control.
+   It's a good idea to use a package name for this purpose.
 
-It is also possible to specify a ``layer`` or ``template`` like the
-``browser:page`` directive, as well as a ``schema``, which we will describe
-below.
+It is also possible to specify a ``layer`` or ``template`` like the ``browser:page`` directive, as well as a ``schema``,
+which we will describe below.
 
 We'll register the sample tile directly here, for later testing.
 
+.. code-block:: python
+
     >>> from zope.component import provideAdapter, provideUtility
     >>> from zope.interface import Interface
     >>> from plone.tiles.interfaces import IBasicTile
 
     >>> provideUtility(sampleTileType, name=u'sample.tile')
-    >>> provideAdapter(SampleTile, (Interface, Interface), IBasicTile, name=u"sample.tile")
+    >>> provideAdapter(SampleTile, (Interface, Interface), IBasicTile, name=u'sample.tile')
 
 Tile traversal
 --------------
 
-Tiles are publishable as a normal browser view. They will normally be called
-with a sub-path that specifies a tile id. This allows tiles to be made aware
-of their instance name. The id is unique within the page layout where the tile
-is used, and may be the basis for looking up tile data.
+Tiles are publishable as a normal browser view.
+They will normally be called with a sub-path that specifies a tile id.
+This allows tiles to be made aware of their instance name.
+The id is unique within the page layout where the tile is used,
+and may be the basis for looking up tile data.
 
-For example, a tile may be saved in a layout as a link like::
+For example, a tile may be saved in a layout as a link like:
+
+.. code-block:: html
 
     <link rel="tile" target="mytile" href="./@@sample.tile/tile1" />
 
@@ -133,30 +147,34 @@ For example, a tile may be saved in a layout as a link like::
 the element with id ``mytile`` with the body of the rendered tile - see
 ``plone.app.blocks`` for details).
 
-Let's create a sample context, look up the view as it would be during
-traversal, and verify how the tile is instantiated.
+Let's create a sample context,
+look up the view as it would be during traversal,
+and verify how the tile is instantiated.
 
-    >>> from zope.interface import implements
+.. code-block:: python
+
+    >>> from zope.component import getMultiAdapter
+    >>> from zope.interface import Interface
+    >>> from zope.interface import implementer
+    >>> from zope.publisher.browser import TestRequest
 
     >>> class IContext(Interface):
     ...     pass
 
-    >>> class Context(object):
-    ...     implements(IContext)
-
-    >>> from zope.publisher.browser import TestRequest
+    >>> @implementer(IContext)
+    ... class Context(object):
+    ...     pass
 
     >>> context = Context()
     >>> request = TestRequest()
 
-    >>> from zope.interface import Interface
-    >>> from zope.component import getMultiAdapter
-
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> tile = tile['tile1'] # simulates sub-path traversal
 
 The tile will now be aware of its name and id:
 
+.. code-block:: python
+
     >>> isinstance(tile, SampleTile)
     True
     >>> tile.__parent__ is context
@@ -167,18 +185,22 @@ The tile will now be aware of its name and id:
     'sample.tile'
 
 The sub-path traversal is implemented using a custom ``__getitem__()`` method.
-To look up a view on a tile, you can traverse to it *after* you've traversed
-to the id sub-path:
+To look up a view on a tile,
+you can traverse to it *after* you've traversed to the id sub-path:
+
+.. code-block:: python
 
-    >>> from zope.interface import Interface
     >>> from zope.component import adapts
+    >>> from zope.interface import Interface
     >>> from zope.publisher.browser import BrowserView
     >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer
+
     >>> class TestView(BrowserView):
     ...     adapts(SampleTile, IDefaultBrowserLayer)
     ...     def __call__(self):
-    ...         return "Dummy view"
-    >>> provideAdapter(TestView, provides=Interface, name="test-view")
+    ...         return 'Dummy view'
+
+    >>> provideAdapter(TestView, provides=Interface, name='test-view')
 
     >>> tile.id is not None
     True
@@ -187,15 +209,19 @@ to the id sub-path:
 
 If there is no view and we have an id already, we will get a ``KeyError``:
 
+.. code-block:: python
+
     >>> tile['not-known'] # doctest: +ELLIPSIS
     Traceback (most recent call last):
     ...
     KeyError: 'not-known'
 
-To ensure consistency with Zope's various tangles publication machines, it
-is also possible to traverse using the ``publishTraverse`` method::
+To ensure consistency with Zope's various tangles publication machines,
+it is also possible to traverse using the ``publishTraverse`` method:
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+.. code-block:: python
+
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> tile = tile.publishTraverse(request, 'tile1') # simulates sub-path traversal
 
     >>> isinstance(tile, SampleTile)
@@ -210,32 +236,41 @@ is also possible to traverse using the ``publishTraverse`` method::
 Transient tile data
 -------------------
 
-Let us now consider how tiles may have data. In the simplest case, tile
-data is passed on the query string, and described according to a schema.
+Let us now consider how tiles may have data.
+In the simplest case, tile data is passed on the query string, and described according to a schema.
 A simple schema may look like:
 
+.. code-block:: python
+
     >>> import zope.schema
+
     >>> class ISampleTileData(Interface):
-    ...     title = zope.schema.TextLine(title=u"Tile title")
-    ...     cssClass = zope.schema.ASCIILine(title=u"CSS class to apply")
-    ...     count = zope.schema.Int(title=u"Number of things to show in the tile")
+    ...     title = zope.schema.TextLine(title=u'Tile title')
+    ...     cssClass = zope.schema.ASCIILine(title=u'CSS class to apply')
+    ...     count = zope.schema.Int(title=u'Number of things to show in the tile')
+
+We would normally have listed this interface when registering this tile in ZCML.
+We can simply update the utility here.
 
-We would normally have listed this interface when registering this tile in
-ZCML. We can simply update the utility here.
+.. code-block:: python
 
     >>> sampleTileType.schema = ISampleTileData
 
 Tile data is represented by a simple dictionary. For example:
 
-    >>> data = {'title': u"My title", 'count': 5, 'cssClass': 'foo'}
+.. code-block:: python
+
+    >>> data = {'title': u'My title', 'count': 5, 'cssClass': 'foo'}
 
-The idea is that a tile add form is built from the schema interface, and its
-data saved to a dictionary.
+The idea is that a tile add form is built from the schema interface, and its data saved to a dictionary.
 
-For transient tiles, this data is then encoded into the tile query string. To
-help with this, a utility function can be used to encode a dict to a query
-string, applying Zope form marshalers according to the types described in
-the schema:
+For transient tiles,
+this data is then encoded into the tile query string.
+To help with this,
+a utility function can be used to encode a dict to a query string,
+applying Zope form marshalers according to the types described in the schema:
+
+.. code-block:: python
 
     >>> from plone.tiles.data import encode
     >>> encode(data, ISampleTileData)
@@ -243,34 +278,39 @@ the schema:
 
 The ``count%3Along=5`` bit is the encoded version of ``count:long=5``.
 
-Note that not all field types may be saved. In particular, object, interface,
-set or frozen set fields may not be saved, and will result in a ``KeyError``.
+Note that not all field types may be saved.
+In particular, object, interface, set or frozen set fields may not be saved, and will result in a ``KeyError``.
 Lengthy text fields or bytes fields with binary data may also be a problem.
-For these types of fields, look to use persistent tiles instead.
+For these types of fields,
+look to use persistent tiles instead.
+
+Furthermore, the conversion may not be perfect.
+For example, Zope's form marshalers cannot distinguish between unicode and ascii fields.
+Therefore, there is a corresponding ``decode()`` method that may be used to ensure that the values match the schema:
 
-Furthermore, the conversion may not be perfect. For example, Zope's form
-marshalers cannot distinguish between unicode and ascii fields. Therefore,
-there is a corresponding ``decode()`` method that may be used to ensure that
-the values match the schema:
+.. code-block:: python
 
-    >>> marshaled = {'title': u"My tile", 'count': 5, 'cssClass': u'foo'}
+    >>> marshaled = {'title': u'My tile', 'count': 5, 'cssClass': u'foo'}
 
     >>> from plone.tiles.data import decode
     >>> decode(marshaled, ISampleTileData)
     {'count': 5, 'cssClass': 'foo', 'title': u'My tile'}
 
-When saved into a layout, the tile link would now look like::
+When saved into a layout, the tile link would now look like:
+
+.. code-block:: html
 
     <link rel="tile" target="mytile"
       href="./@@sample.tile/tile1?title=My+title&count%3Along=5&cssClass=foo" />
 
-Let's simulate traversal once more and see how the data is now available to
-the tile instance:
+Let's simulate traversal once more and see how the data is now available to the tile instance:
+
+.. code-block:: python
 
     >>> context = Context()
     >>> request = TestRequest(form={'title': u'My title', 'count': 5, 'cssClass': u'foo'})
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> tile = tile['tile1']
 
     >>> sorted(tile.data.items())
@@ -278,38 +318,39 @@ the tile instance:
 
 Notice also how the data has been properly decoded according to the schema.
 
-Transient tiles will get their data directly from the request
-parameters but, if a `_tiledata` JSON-encoded parameter is present in
-the request, this one will be used instead::
+Transient tiles will get their data directly from the request parameters but,
+if a `_tiledata` JSON-encoded parameter is present in the request,
+this one will be used instead:
 
-    >>> try:
-    ...     import json
-    ... except ImportError:
-    ...     import simplejson as json
+.. code-block:: python
+
+    >>> import json
 
     >>> request = TestRequest(form={
     ...     'title': u'My title', 'count': 5, 'cssClass': u'foo',
     ...     '_tiledata': json.dumps({'title': u'Your title', 'count': 6, 'cssClass': u'bar'})
     ...     })
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> tile = tile['tile1']
 
     >>> sorted(tile.data.items())
     [(u'count', 6), (u'cssClass', u'bar'), (u'title', u'Your title')]
 
-This way we can use transient tiles safely in contexts where the tile
-data can be confused with raw data coming from a form, e.g. in an edit form.
+This way we can use transient tiles safely in contexts where the tile data can be confused with raw data coming from a form, e.g. in an edit form.
 
 The tile data manager
 ---------------------
 
-The ``data`` attribute is a convenience attribute to get hold of a (cached)
-copy of the data returned by an ``ITileDataManager``. This interface provides
-three methods: ``get()``, to return the tile's data, ``set()``, to update it
-with a new dictionary of data, and ``delete()``, to delete the data.
+The ``data`` attribute is a convenience attribute to get hold of a (cached) copy of the data returned by an ``ITileDataManager``.
+This interface provides three methods:
+``get()``, to return the tile's data,
+``set()``, to update it with a new dictionary of data,
+and ``delete()``, to delete the data.
+
+This adapter is mostly useful for writing UI around tiles.
+Using our tile above, we can get the data like so:
 
-This adapter is mostly useful for writing UI around tiles. Using our tile
-above, we can get the data like so:
+.. code-block:: python
 
     >>> from plone.tiles.interfaces import ITileDataManager
     >>> dataManager = ITileDataManager(tile)
@@ -318,51 +359,61 @@ above, we can get the data like so:
 
 We can also update the tile data:
 
+.. code-block:: python
+
     >>> dataManager.set({'count': 1, 'cssClass': 'bar', 'title': u'Another title'})
     >>> sorted(dataManager.get().items())
     [('count', 1), ('cssClass', 'bar'), ('title', u'Another title')]
 
 The data can also be deleted:
 
+.. code-block:: python
+
     >>> dataManager.delete()
     >>> sorted(dataManager.get().items())
     [('count', None), ('cssClass', None), ('title', None)]
 
-Note that in the case of a transient tile, all we are doing is
-modifying the ``form`` dictionary of the request (or the `_tiledata`
-parameter of this dictionary, if present). The data needs to be
-encoded into the query string, either using the ``encode()`` method or
-via the tile's ``IAbsoluteURL`` adapter (see below for details).
+Note that in the case of a transient tile,
+all we are doing is modifying the ``form`` dictionary of the request
+(or the `_tiledata` parameter of this dictionary, if present).
+The data needs to be encoded into the query string,
+either using the ``encode()`` method or via the tile's ``IAbsoluteURL`` adapter (see below for details).
 
 For persistent tiles, the data manager is a bit more interesting.
 
 Persistent tiles
 ----------------
 
-Not all types of data can be placed in a query string. For more substantial
-storage requirements, you can use persistent tiles, which store data in
-annotations.
+Not all types of data can be placed in a query string.
+For more substantial storage requirements,
+you can use persistent tiles, which store data in annotations.
 
-*Note:* If you have more intricate requirements, you can also write your own
-``ITileDataManager`` to handle data retrieval. In this case, you probably
-still want to derive from ``PersistentTile``, to get the appropriate
-``IAbsoluteURL`` adapter, among other things.
+.. note:: If you have more intricate requirements,
+   you can also write your own ``ITileDataManager`` to handle data retrieval.
+   In this case, you probably still want to derive from ``PersistentTile``,
+   to get the appropriate ``IAbsoluteURL`` adapter, among other things.
 
 First, we need to write up annotations support.
 
+.. code-block:: python
+
     >>> from zope.annotation.attribute import AttributeAnnotations
     >>> provideAdapter(AttributeAnnotations)
 
 We also need a context that is annotatable.
 
+.. code-block:: python
+
     >>> from zope.annotation.interfaces import IAttributeAnnotatable
     >>> from zope.interface import alsoProvides
     >>> alsoProvides(context, IAttributeAnnotatable)
 
 Now, let's create a persistent tile with a schema.
 
+.. code-block:: python
+
     >>> class IPersistentSampleData(Interface):
-    ...     text = zope.schema.Text(title=u"Detailed text", missing_value=u"Missing!")
+    ...     text = zope.schema.Text(title=u'Detailed text', missing_value=u'Missing!')
 
     >>> from plone.tiles import PersistentTile
     >>> class PersistentSampleTile(PersistentTile):
@@ -370,25 +421,27 @@ Now, let's create a persistent tile with a schema.
     ...     __name__ = 'sample.persistenttile' # would normally be set by ZCML handler
     ...
     ...     def __call__(self):
-    ...         return u"<b>You said</b> %s" % self.data['text']
+    ...         return u'<b>You said</b> %s' % self.data['text']
 
     >>> persistentSampleTileType = TileType(
     ...     u'sample.persistenttile',
-    ...     u"Persistent sample tile",
-    ...     "dummy.Permission",
-    ...     "dummy.Permission",
-    ...     description=u"A tile used for testing",
+    ...     u'Persistent sample tile',
+    ...     'dummy.Permission',
+    ...     'dummy.Permission',
+    ...     description=u'A tile used for testing',
     ...     schema=IPersistentSampleData)
 
     >>> provideUtility(persistentSampleTileType, name=u'sample.persistenttile')
-    >>> provideAdapter(PersistentSampleTile, (Interface, Interface), IBasicTile, name=u"sample.persistenttile")
+    >>> provideAdapter(PersistentSampleTile, (Interface, Interface), IBasicTile, name=u'sample.persistenttile')
+
+We can now traverse to the tile as before.
+By default, there is no data, and the field's missing value will be used.
 
-We can now traverse to the tile as before. By default, there is no data, and
-the field's missing value will be used.
+.. code-block:: python
 
     >>> request = TestRequest()
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.persistenttile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.persistenttile')
     >>> tile = tile['tile2']
     >>> tile.__name__
     'sample.persistenttile'
@@ -400,16 +453,22 @@ the field's missing value will be used.
 
 At this point, there is nothing in the annotations for the type either:
 
+.. code-block:: python
+
     >>> dict(getattr(context, '__annotations__', {})).keys()
     []
 
 We can write data to the context's annotations using an ``ITileDataManager``:
 
+.. code-block:: python
+
     >>> dataManager = ITileDataManager(tile)
-    >>> dataManager.set({'text': u"Hello!"})
+    >>> dataManager.set({'text': u'Hello!'})
 
 This writes data to annotations:
 
+.. code-block:: python
+
     >>> dict(context.__annotations__).keys()
     [u'plone.tiles.data.tile2']
     >>> context.__annotations__[u'plone.tiles.data.tile2']
@@ -417,15 +476,19 @@ This writes data to annotations:
 
 We can get this from the data manager too, of course:
 
+.. code-block:: python
+
     >>> dataManager.get()
     {'text': u'Hello!'}
 
-Note that as with transient tiles, the ``data`` attribute is cached and will
-only be looked up once.
+Note that as with transient tiles,
+the ``data`` attribute is cached and will only be looked up once.
 
 If we now look up the tile again, we will get the new value:
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.persistenttile")
+.. code-block:: python
+
+    >>> tile = getMultiAdapter((context, request), name=u'sample.persistenttile')
     >>> tile = tile['tile2']
     >>> tile()
     u'<b>You said</b> Hello!'
@@ -435,31 +498,33 @@ If we now look up the tile again, we will get the new value:
 
 We can also remove the annotation using the data manager:
 
+.. code-block:: python
+
     >>> dataManager.delete()
     >>> sorted(dict(context.__annotations__).items()) # doctest: +ELLIPSIS
     []
 
-
 Overriding transient data with persistent
 -----------------------------------------
 
-To be able to re-use the same centrally managed tile based layouts for
-multiple context objects, but still allow optional customization for
-tiles, it's possible to override otherwise transient tile configuration
-with context specific persistent configuration.
+To be able to re-use the same centrally managed tile based layouts for multiple context objects,
+but still allow optional customization for tiles,
+it's possible to override otherwise transient tile configuration with context specific persistent configuration.
 
-This is done by either by setting a client side request header or query param
-``X-Tile-Persistent``:
+This is done by either by setting a client side request header or query param ``X-Tile-Persistent``:
+
+.. code-block:: python
 
     >>> request = TestRequest(
     ...     form={'title': u'My title', 'count': 5, 'cssClass': u'foo',
     ...           'X-Tile-Persistent': 'yes'}
     ... )
 
-Yet, just adding the flag, doesn't create new persistent annotations
-on GET requests:
+Yet, just adding the flag, doesn't create new persistent annotations on GET requests:
+
+.. code-block:: python
 
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> ITileDataManager(tile)
     <plone.tiles.data.PersistentTileDataManager object at ...>
 
@@ -472,6 +537,8 @@ on GET requests:
 
 That's because the data is persistent only once it's set:
 
+.. code-block:: python
+
     >>> data = ITileDataManager(tile).get()
     >>> data.update({'count': 6})
     >>> ITileDataManager(tile).set(data)
@@ -486,10 +553,12 @@ That's because the data is persistent only once it's set:
 
 Without the persistent flag, fixed transient data would be returned:
 
+.. code-block:: python
+
     >>> request = TestRequest(
     ...     form={'title': u'My title', 'count': 5, 'cssClass': u'foo'},
     ... )
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> ITileDataManager(tile)
     <plone.tiles.data.TransientTileDataManager object at ...>
 
@@ -499,11 +568,13 @@ Without the persistent flag, fixed transient data would be returned:
 
 Finally, the persistent override could also be deleted:
 
+.. code-block:: python
+
     >>> request = TestRequest(
     ...     form={'title': u'My title', 'count': 5, 'cssClass': u'foo',
     ...           'X-Tile-Persistent': 'yes'}
     ... )
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> ITileDataManager(tile)
     <plone.tiles.data.PersistentTileDataManager object at ...>
 
@@ -520,7 +591,7 @@ Finally, the persistent override could also be deleted:
     >>> request = TestRequest(
     ...     form={'title': u'My title', 'count': 5, 'cssClass': u'foo'},
     ... )
-    >>> tile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> tile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> ITileDataManager(tile)
     <plone.tiles.data.TransientTileDataManager object at ...>
 
@@ -528,14 +599,17 @@ Finally, the persistent override could also be deleted:
 Tile URLs
 ---------
 
-As we have seen, tiles have a canonical URL. For transient tiles, this may
-also encode some tile data.
+As we have seen, tiles have a canonical URL.
+For transient tiles, this may also encode some tile data.
 
 If you have a tile instance and you need to know the canonical tile URL,
 you can use the ``IAbsoluteURL`` API.
 
-For the purposes of testing, we need to ensure that we can get an absolute URL
-for the context. We'll achieve that with a dummy adapter:
+For the purposes of testing,
+we need to ensure that we can get an absolute URL for the context.
+We'll achieve that with a dummy adapter:
+
+.. code-block:: python
 
     >>> from zope.interface import implements
     >>> from zope.component import adapts
@@ -552,14 +626,14 @@ for the context. We'll achieve that with a dummy adapter:
     ...         self.request = request
     ...
     ...     def __unicode__(self):
-    ...         return u"http://example.com/context"
+    ...         return u'http://example.com/context'
     ...     def __str__(self):
-    ...         return u"http://example.com/context"
+    ...         return u'http://example.com/context'
     ...     def __call__(self):
     ...         return self.__str__()
     ...     def breadcrumbs(self):
     ...         return ({'name': u'context', 'url': 'http://example.com/context'},)
-    >>> provideAdapter(DummyAbsoluteURL, name=u"absolute_url")
+    >>> provideAdapter(DummyAbsoluteURL, name=u'absolute_url')
     >>> provideAdapter(DummyAbsoluteURL)
 
     >>> from zope.traversing.browser.absoluteurl import absoluteURL
@@ -567,7 +641,7 @@ for the context. We'll achieve that with a dummy adapter:
 
     >>> context = Context()
     >>> request = TestRequest(form={'title': u'My title', 'count': 5, 'cssClass': u'foo'})
-    >>> transientTile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> transientTile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> transientTile = transientTile['tile1']
 
     >>> absoluteURL(transientTile, request)
@@ -580,15 +654,19 @@ for the context. We'll achieve that with a dummy adapter:
 
 For convenience, the tile URL is also available under the ``url`` property:
 
+.. code-block:: python
+
     >>> transientTile.url
     'http://example.com/context/@@sample.tile/tile1?title=My+title&cssClass=foo&count%3Along=5'
 
 The tile absolute URL structure remains unaltered if the data is
 coming from a `_tiledata` JSON-encoded parameter instead of from the request
-parameters directly::
+parameters directly:
+
+.. code-block:: python
 
     >>> request = TestRequest(form={'_tiledata': json.dumps({'title': u'Your title', 'count': 6, 'cssClass': u'bar'})})
-    >>> transientTile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> transientTile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> transientTile = transientTile['tile1']
 
     >>> absoluteURL(transientTile, request)
@@ -596,9 +674,11 @@ parameters directly::
 
 For persistent tiles, the are no data parameters:
 
+.. code-block:: python
+
     >>> context = Context()
     >>> request = TestRequest(form={'title': u'Ignored', 'count': 0, 'cssClass': u'ignored'})
-    >>> persistentTile = getMultiAdapter((context, request), name=u"sample.persistenttile")
+    >>> persistentTile = getMultiAdapter((context, request), name=u'sample.persistenttile')
     >>> persistentTile = persistentTile['tile2']
 
     >>> absoluteURL(persistentTile, request)
@@ -611,17 +691,21 @@ For persistent tiles, the are no data parameters:
 
 And again, for convenience:
 
+.. code-block:: python
+
     >>> persistentTile.url
     'http://example.com/context/@@sample.persistenttile/tile2'
 
-If the tile doesn't have an id, we don't get any sub-path
+If the tile doesn't have an id, we don't get any sub-path:
+
+.. code-block:: python
 
     >>> request = TestRequest(form={'title': u'My title', 'count': 5, 'cssClass': u'foo'})
-    >>> transientTile = getMultiAdapter((context, request), name=u"sample.tile")
+    >>> transientTile = getMultiAdapter((context, request), name=u'sample.tile')
     >>> absoluteURL(transientTile, request)
     'http://example.com/context/@@sample.tile?title=My+title&cssClass=foo&count%3Along=5'
 
     >>> request = TestRequest()
-    >>> persistentTile = getMultiAdapter((context, request), name=u"sample.persistenttile")
+    >>> persistentTile = getMultiAdapter((context, request), name=u'sample.persistenttile')
     >>> absoluteURL(persistentTile, request)
     'http://example.com/context/@@sample.persistenttile'


