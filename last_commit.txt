Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T18:58:22+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/f365e9d6869986a8870edd70162f60a63f542724

Configuring with plone/meta

Files changed:
A .editorconfig
A .meta.toml
A .pre-commit-config.yaml
A news/a864b30f.internal
A tox.ini
M pyproject.toml
M setup.cfg

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..ab85364\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "a864b30f"\ndiff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nnew file mode 100644\nindex 0000000..fdafec1\n--- /dev/null\n+++ b/.pre-commit-config.yaml\n@@ -0,0 +1,42 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+ci:\n+    autofix_prs: false\n+    autoupdate_schedule: monthly\n+\n+repos:\n+-   repo: https://github.com/asottile/pyupgrade\n+    rev: v3.3.1\n+    hooks:\n+    -   id: pyupgrade\n+        args: [--py38-plus]\n+-   repo: https://github.com/pycqa/isort\n+    rev: 5.12.0\n+    hooks:\n+    -   id: isort\n+-   repo: https://github.com/psf/black\n+    rev: 23.3.0\n+    hooks:\n+    -   id: black\n+-   repo: https://github.com/collective/zpretty\n+    rev: 3.0.3\n+    hooks:\n+    -   id: zpretty\n+-   repo: https://github.com/PyCQA/flake8\n+    rev: 6.0.0\n+    hooks:\n+    -   id: flake8\n+-   repo: https://github.com/codespell-project/codespell\n+    rev: v2.2.4\n+    hooks:\n+    -   id: codespell\n+        additional_dependencies:\n+          - tomli\n+-   repo: https://github.com/mgedmin/check-manifest\n+    rev: "0.49"\n+    hooks:\n+    -   id: check-manifest\n+-   repo: https://github.com/regebro/pyroma\n+    rev: "4.2"\n+    hooks:\n+    -   id: pyroma\ndiff --git a/news/a864b30f.internal b/news/a864b30f.internal\nnew file mode 100644\nindex 0000000..c08f539\n--- /dev/null\n+++ b/news/a864b30f.internal\n@@ -0,0 +1,2 @@\n+Update configuration files.\n+[plone devs]\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..639f77a 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,65 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "internal"\n+name = "Internal:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "documentation"\n+name = "Documentation:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "tests"\n+name = "Tests"\n+showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\n+\n+\n+[tool.dependencychecker]\n+Zope = [\n+  # Zope own provided namespaces\n+  \'App\', \'OFS\', \'Products.Five\', \'Products.OFSP\', \'Products.PageTemplates\',\n+  \'Products.SiteAccess\', \'Shared\', \'Testing\', \'ZPublisher\', \'ZTUtils\',\n+  \'Zope2\', \'webdav\', \'zmi\',\n+  # ExtensionClass own provided namespaces\n+  \'ExtensionClass\', \'ComputedAttribute\', \'MethodObject\',\n+  # Zope dependencies\n+  \'AccessControl\', \'Acquisition\', \'AuthEncoding\', \'beautifulsoup4\', \'BTrees\',\n+  \'cffi\', \'Chameleon\', \'DateTime\', \'DocumentTemplate\',\n+  \'MultiMapping\', \'multipart\', \'PasteDeploy\', \'Persistence\', \'persistent\',\n+  \'pycparser\', \'python-gettext\', \'pytz\', \'RestrictedPython\', \'roman\',\n+  \'soupsieve\', \'transaction\', \'waitress\', \'WebOb\', \'WebTest\', \'WSGIProxy2\',\n+  \'z3c.pt\', \'zc.lockfile\', \'ZConfig\', \'zExceptions\', \'ZODB\', \'zodbpickle\',\n+  \'zope.annotation\', \'zope.browser\', \'zope.browsermenu\', \'zope.browserpage\',\n+  \'zope.browserresource\', \'zope.cachedescriptors\', \'zope.component\',\n+  \'zope.configuration\', \'zope.container\', \'zope.contentprovider\',\n+  \'zope.contenttype\', \'zope.datetime\', \'zope.deferredimport\',\n+  \'zope.deprecation\', \'zope.dottedname\', \'zope.event\', \'zope.exceptions\',\n+  \'zope.filerepresentation\', \'zope.globalrequest\', \'zope.hookable\',\n+  \'zope.i18n\', \'zope.i18nmessageid\', \'zope.interface\', \'zope.lifecycleevent\',\n+  \'zope.location\', \'zope.pagetemplate\', \'zope.processlifetime\', \'zope.proxy\',\n+  \'zope.ptresource\', \'zope.publisher\', \'zope.schema\', \'zope.security\',\n+  \'zope.sequencesort\', \'zope.site\', \'zope.size\', \'zope.structuredtext\',\n+  \'zope.tal\', \'zope.tales\', \'zope.testbrowser\', \'zope.testing\',\n+  \'zope.traversing\', \'zope.viewlet\'\n+]\n+\'Products.CMFCore\' = [\n+  \'docutils\', \'five.localsitemanager\', \'Missing\', \'Products.BTreeFolder2\',\n+  \'Products.GenericSetup\', \'Products.MailHost\', \'Products.PythonScripts\',\n+  \'Products.StandardCacheManagers\', \'Products.ZCatalog\', \'Record\',\n+  \'zope.sendmail\', \'Zope\'\n+]\n+\'plone.base\' = [\n+  \'plone.batching\', \'plone.registry\', \'plone.schema\',\'plone.z3cform\',\n+  \'Products.CMFCore\', \'Products.CMFDynamicViewFTI\',\n+]\n+python-dateutil = [\'dateutil\']\ndiff --git a/setup.cfg b/setup.cfg\nindex e78a412..0da8f8f 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,13 +1,23 @@\n-[zopeskel]\n-template = plone\n-\n-[isort]\n-force_alphabetical_sort = True\n-force_single_line = True\n-lines_after_imports = 2\n-line_length = 200\n-not_skip = __init__.py\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[bdist_wheel]\n+universal = 0\n \n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n \n-[bdist_wheel]\n-universal = 1\n+[check-manifest]\n+ignore =\n+    .editorconfig\n+    .meta.toml\n+    .pre-commit-config.yaml\n+    tox.ini\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..e6193f7\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,76 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[tox]\n+# We need 4.4.0 for constrain_package_deps.\n+min_version = 4.4.0\n+envlist =\n+    format\n+    lint\n+    test\n+\n+[testenv]\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat code\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a pyupgrade\n+    pre-commit run -a isort\n+    pre-commit run -a black\n+    pre-commit run -a zpretty\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a\n+\n+[testenv:dependencies]\n+description = check if the package defines all its dependencies\n+skip_install = true\n+deps =\n+    build\n+    z3c.dependencychecker==2.11\n+commands =\n+    python -m build --sdist --no-isolation\n+    dependencychecker\n+\n+[testenv:dependencies-graph]\n+description = generate a graph out of the package\'s dependencies\n+deps =\n+    pipdeptree==2.5.1\n+    graphviz  # optional dependency of pipdeptree\n+commands =\n+    sh -c \'pipdeptree --exclude setuptools,wheel,pipdeptree,zope.interface,zope.component --graph-output svg > dependencies.svg\'\n+\n+[testenv:test]\n+use_develop = true\n+constrain_package_deps = true\n+set_env = ROBOT_BROWSER=headlesschrome\n+deps =\n+    zope.testrunner\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    zope-testrunner --all --test-path={toxinidir} -s plone.registry {posargs}\n+extras =\n+    test\n+\n+[testenv:coverage]\n+use_develop = true\n+constrain_package_deps = true\n+set_env = ROBOT_BROWSER=headlesschrome\n+deps =\n+    coverage\n+    zope.testrunner\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    coverage run {envbindir}/zope-testrunner --all --test-path={toxinidir} -s plone.registry {posargs}\n+    coverage report -m --format markdown\n+extras =\n+    test\n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:03:36+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/3fe894e9cccfa35b34a1cc4f82ed80ddc8ed19d2

chore: pyupgrade

Files changed:
M plone/__init__.py
M plone/registry/__init__.py
M plone/registry/events.py
M plone/registry/field.py
M plone/registry/fieldfactory.py
M plone/registry/fieldref.py
M plone/registry/interfaces.py
M plone/registry/record.py
M plone/registry/recordsproxy.py
M plone/registry/registry.py
M plone/registry/tests.py
M setup.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..de40ea7 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n __import__(\'pkg_resources\').declare_namespace(__name__)\ndiff --git a/plone/registry/__init__.py b/plone/registry/__init__.py\nindex 73c057b..f10cc39 100644\n--- a/plone/registry/__init__.py\n+++ b/plone/registry/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.registry.fieldref import FieldRef\n from plone.registry.record import Record\n from plone.registry.registry import Registry\ndiff --git a/plone/registry/events.py b/plone/registry/events.py\nindex a086c53..aeba2f6 100644\n--- a/plone/registry/events.py\n+++ b/plone/registry/events.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.registry.interfaces import IInterfaceAwareRecord\n from plone.registry.interfaces import IRecordAddedEvent\n from plone.registry.interfaces import IRecordEvent\n@@ -11,13 +10,13 @@\n \n \n @implementer(IRecordEvent)\n-class RecordEvent(object):\n+class RecordEvent:\n \n     def __init__(self, record):\n         self.record = record\n \n     def __repr__(self):\n-        return "<%s for %s>" % (self.__class__.__name__, self.record.__name__)\n+        return f"<{self.__class__.__name__} for {self.record.__name__}>"\n \n \n @implementer(IRecordAddedEvent)\n@@ -34,7 +33,7 @@ class RecordRemovedEvent(RecordEvent):\n class RecordModifiedEvent(RecordEvent):\n \n     def __init__(self, record, oldValue, newValue):\n-        super(RecordModifiedEvent, self).__init__(record)\n+        super().__init__(record)\n         self.oldValue = oldValue\n         self.newValue = newValue\n \ndiff --git a/plone/registry/field.py b/plone/registry/field.py\nindex 2bd60a3..f87c11e 100644\n--- a/plone/registry/field.py\n+++ b/plone/registry/field.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """This module defines persistent versions of various fields.\n \n The idea is that when a record is created, we copy relevant field properties\n@@ -22,15 +21,10 @@\n except ImportError:\n     HASPLONESCHEMA = False\n \n-if sys.version_info >= (3,):\n-    basestring = str\n-    text_type = str\n-    _primitives = (int, bool, str, bytes, tuple,\n-                   list, set, frozenset, dict, float)\n-else:\n-    text_type = unicode\n-    _primitives = (int, long, bool, str, unicode, tuple,\n-                   list, set, frozenset, dict, float)\n+basestring = str\n+text_type = str\n+_primitives = (int, bool, str, bytes, tuple,\n+               list, set, frozenset, dict, float)\n \n _missing_value_marker = object()\n \n@@ -39,7 +33,7 @@ def is_primitive(value):\n     return value is None or isinstance(value, _primitives)\n \n \n-class DisallowedProperty(object):\n+class DisallowedProperty:\n     """A property that may not be set on an instance. It may still be set\n     defined in a base class.\n     """\n@@ -61,12 +55,12 @@ def __get__(self, inst, type_=None):\n \n     def __set__(self, inst, value):\n         raise ValueError(\n-            u"Persistent fields does not support setting the `{0}` "\n-            u"property".format(self._name)\n+            "Persistent fields does not support setting the `{}` "\n+            "property".format(self._name)\n         )\n \n \n-class StubbornProperty(object):\n+class StubbornProperty:\n     """A property that stays stubbornly at a single, pre-defined value.\n     """\n     uses = []\n@@ -83,7 +77,7 @@ def __get__(self, inst, type_=None):\n         return self._value\n \n \n-class InterfaceConstrainedProperty(object):\n+class InterfaceConstrainedProperty:\n     """A property that may only contain values providing a certain interface.\n     """\n     uses = []\n@@ -99,8 +93,8 @@ def __set__(self, inst, value):\n             and not self._interface.providedBy(value)\n         ):\n             raise ValueError(\n-                u"The property `{0}` may only contain objects "\n-                "providing `{1}`.".format(\n+                "The property `{}` may only contain objects "\n+                "providing `{}`.".format(\n                     self._name,\n                     self._interface.__identifier__,\n                 )\ndiff --git a/plone/registry/fieldfactory.py b/plone/registry/fieldfactory.py\nindex 1d30861..a88e320 100644\n--- a/plone/registry/fieldfactory.py\n+++ b/plone/registry/fieldfactory.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.registry.field import DisallowedProperty\n from plone.registry.field import InterfaceConstrainedProperty\n from plone.registry.field import is_primitive\n@@ -40,9 +39,9 @@ def persistentFieldAdapter(context):\n \n     instance = persistent_class.__new__(persistent_class)\n \n-    context_dict = dict(\n-        [(k, v) for k, v in context.__dict__.items() if k not in ignored]\n-    )\n+    context_dict = {\n+        k: v for k, v in context.__dict__.items() if k not in ignored\n+    }\n \n     for key, iface in constrained:\n         value = context_dict.get(key, None)\n@@ -51,8 +50,8 @@ def persistentFieldAdapter(context):\n         value = iface(value, None)\n         if value is None:\n             __traceback_info__ = (\n-                "The property `{0}` cannot be adapted to "\n-                "`{1}`.".format(key, iface.__identifier__,)\n+                "The property `{}` cannot be adapted to "\n+                "`{}`.".format(key, iface.__identifier__,)\n             )\n             return None\n         context_dict[key] = value\ndiff --git a/plone/registry/fieldref.py b/plone/registry/fieldref.py\nindex a4ae488..a2582af 100644\n--- a/plone/registry/fieldref.py\n+++ b/plone/registry/fieldref.py\n@@ -1,11 +1,10 @@\n-# -*- coding: utf-8 -*-\n from plone.registry.interfaces import IFieldRef\n from zope.interface import implementedBy\n from zope.interface import implementer\n \n \n @implementer(IFieldRef)\n-class FieldRef(object):\n+class FieldRef:\n     """Default field reference.\n     """\n \ndiff --git a/plone/registry/interfaces.py b/plone/registry/interfaces.py\nindex 743811d..180b9cf 100644\n--- a/plone/registry/interfaces.py\n+++ b/plone/registry/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope import schema\n from zope.interface import Interface\n from zope.interface.interfaces import IInterface\n@@ -24,11 +23,11 @@ class IPersistentField(IField):\n     """\n \n     interfaceName = schema.DottedName(\n-        title=u\'Dotted name to an interface the field was constructed from\',\n+        title=\'Dotted name to an interface the field was constructed from\',\n         required=False\n     )\n     fieldName = schema.ASCIILine(\n-        title=u\'Name of the field in the original interface, if any\',\n+        title=\'Name of the field in the original interface, if any\',\n         required=False\n     )\n \n@@ -43,10 +42,10 @@ class IFieldRef(Interface):\n     """\n \n     recordName = schema.DottedName(\n-        title=u\'Name of the record containing the reference field\'\n+        title=\'Name of the record containing the reference field\'\n     )\n     originalField = schema.Object(\n-        title=u\'Referenced field\',\n+        title=\'Referenced field\',\n         schema=IField\n     )\n \n@@ -64,13 +63,13 @@ class IRecord(Interface):\n     """\n \n     field = schema.Object(\n-        title=u\'A field describing this record\',\n+        title=\'A field describing this record\',\n         schema=IPersistentField\n     )\n \n     value = schema.Field(\n-        title=u\'The value of this record\',\n-        description=u\'Must be valid according to the record\\\'s field\'\n+        title=\'The value of this record\',\n+        description=\'Must be valid according to the record\\\'s field\'\n     )\n \n \n@@ -79,9 +78,9 @@ class IRecordEvent(Interface):\n     """\n \n     record = schema.Object(\n-        title=u\'The record that was added.\',\n-        description=u\'Both __name__ and __parent__ will be set before the \'\n-                    u\'event is fired\',\n+        title=\'The record that was added.\',\n+        description=\'Both __name__ and __parent__ will be set before the \'\n+                    \'event is fired\',\n         schema=IRecord\n     )\n \n@@ -100,8 +99,8 @@ class IRecordModifiedEvent(IRecordEvent):\n     """Event fired when a record\'s value is modified.\n     """\n \n-    oldValue = schema.Field(title=u\'The record\\\'s previous value\')\n-    newValue = schema.Field(title=u\'The record\\\'s new value\')\n+    oldValue = schema.Field(title=\'The record\\\'s previous value\')\n+    newValue = schema.Field(title=\'The record\\\'s new value\')\n \n \n class IInterfaceAwareRecord(Interface):\n@@ -109,17 +108,17 @@ class IInterfaceAwareRecord(Interface):\n     interface its field came from.\n     """\n \n-    interfaceName = schema.DottedName(title=u"Dotted name to interface")\n+    interfaceName = schema.DottedName(title="Dotted name to interface")\n \n     interface = schema.Object(\n-        title=u\'Interface that provided the record\',\n-        description=u\'May be None if the interface is no longer available\',\n+        title=\'Interface that provided the record\',\n+        description=\'May be None if the interface is no longer available\',\n         schema=IInterface,\n         readonly=True\n     )\n \n     fieldName = schema.ASCIILine(\n-        title=u\'Name of the field in the original interface\'\n+        title=\'Name of the field in the original interface\'\n     )\n \n \n@@ -128,18 +127,18 @@ class IRegistry(Interface):\n     """\n \n     records = schema.Dict(\n-        title=u\'The records of the registry\',\n+        title=\'The records of the registry\',\n         key_type=schema.DottedName(\n-            title=u\'Name of the record\',\n-            description=u\'By convention, this should include the \'\n-                        u\'package name and optionally an interface \'\n-                        u\'named, if the record can be described by a \'\n-                        u\'field in an interface (see also \'\n-                        u\'registerInterface() below), e.g. \'\n-                        u\'my.package.interfaces.IMySettings.somefield.\',\n+            title=\'Name of the record\',\n+            description=\'By convention, this should include the \'\n+                        \'package name and optionally an interface \'\n+                        \'named, if the record can be described by a \'\n+                        \'field in an interface (see also \'\n+                        \'registerInterface() below), e.g. \'\n+                        \'my.package.interfaces.IMySettings.somefield.\',\n         ),\n         value_type=schema.Object(\n-            title=u\'The record for this name\',\n+            title=\'The record for this name\',\n             schema=IRecord,\n         ),\n     )\n@@ -190,20 +189,20 @@ class IRecordsProxy(Interface):\n     """\n \n     __schema__ = schema.Object(\n-        title=u\'Interface providing records\',\n+        title=\'Interface providing records\',\n         schema=IInterface,\n         readonly=True\n     )\n \n     __registry__ = schema.Object(\n-        title=u\'Registry where records will be looked up\',\n+        title=\'Registry where records will be looked up\',\n         schema=IRegistry,\n         readonly=True)\n \n     __omitted__ = schema.Tuple(\n-        title=u\'Fields that are not stored in the registry\',\n-        description=u\'If any of these are accessed, you will get an \'\n-                    u\'AttributeError\',\n-        value_type=schema.ASCIILine(title=u\'Fieldname\'),\n+        title=\'Fields that are not stored in the registry\',\n+        description=\'If any of these are accessed, you will get an \'\n+                    \'AttributeError\',\n+        value_type=schema.ASCIILine(title=\'Fieldname\'),\n         readonly=True\n     )\ndiff --git a/plone/registry/record.py b/plone/registry/record.py\nindex ca2575e..a0f47a7 100644\n--- a/plone/registry/record.py\n+++ b/plone/registry/record.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from persistent import Persistent\n from plone.registry.events import RecordModifiedEvent\n from plone.registry.interfaces import IInterfaceAwareRecord\n@@ -25,7 +24,7 @@ class Record(Persistent):\n     values may be loaded during automated migration.\n     """\n \n-    __name__ = u""\n+    __name__ = ""\n     __parent__ = None\n \n     def __init__(self, field, value=_marker, _validate=True):\ndiff --git a/plone/registry/recordsproxy.py b/plone/registry/recordsproxy.py\nindex 47182f9..b35e897 100644\n--- a/plone/registry/recordsproxy.py\n+++ b/plone/registry/recordsproxy.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.registry.interfaces import IRecordsProxy\n from zope.interface import alsoProvides\n from zope.interface import implementer\n@@ -16,14 +15,13 @@\n     from collections import UserDict\n     from collections.abc import MutableMapping as DictMixin\n \n-if sys.version_info >= (3,):\n-    basestring = str\n+basestring = str\n \n _marker = object()\n \n \n @implementer(IRecordsProxy)\n-class RecordsProxy(object):\n+class RecordsProxy:\n     """A proxy that maps an interface to a number of records\n     """\n \n@@ -44,7 +42,7 @@ def __init__(self, registry, schema, omitted=(), prefix=None):\n \n     def __getattr__(self, name):\n         if not self.__dict__ or name in self.__dict__.keys():\n-           return super(RecordsProxy, self).__getattr__(name)\n+           return super().__getattr__(name)\n         if name not in self.__schema__:\n             raise AttributeError(name)\n         value = self.__registry__.get(self.__prefix__ + name, _marker)\n@@ -62,7 +60,7 @@ def __setattr__(self, name, value):\n             self.__dict__[name] = value\n \n     def __repr__(self):\n-        return "<{0} for {1}>".format(\n+        return "<{} for {}>".format(\n             self.__class__.__name__,\n             self.__schema__.__identifier__\n         )\ndiff --git a/plone/registry/registry.py b/plone/registry/registry.py\nindex c14f5d1..f7a76e2 100644\n--- a/plone/registry/registry.py\n+++ b/plone/registry/registry.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from BTrees.OOBTree import OOBTree\n from persistent import Persistent\n from plone.registry.events import RecordAddedEvent\n@@ -22,8 +21,7 @@\n import warnings\n \n import sys\n-if sys.version_info >= (3,):\n-    basestring = str\n+basestring = str\n \n \n @implementer(IRegistry)\n@@ -76,7 +74,7 @@ def forInterface(self, interface, check=True, omit=(), prefix=None,\n             for name in getFieldNames(interface):\n                 if name not in omit and prefix + name not in self:\n                     raise KeyError(\n-                        "Interface `{0}` defines a field `{1}`, for which "\n+                        "Interface `{}` defines a field `{}`, for which "\n                         "there is no record.".format(\n                             interface.__identifier__,\n                             name\n@@ -103,7 +101,7 @@ def registerInterface(self, interface, omit=(), prefix=None):\n             if persistent_field is None:\n                 raise TypeError(\n                     "There is no persistent field equivalent for the field "\n-                    "`{0}` of type `{1}`.".format(\n+                    "`{}` of type `{}`.".format(\n                         name,\n                         field.__class__.__name__\n                     )\n@@ -163,7 +161,7 @@ def _migrateRecords(self):\n         self._records = records\n \n \n-class _Records(object):\n+class _Records:\n     """The records stored in the registry. This implements dict-like access\n     to records, where as the Registry object implements dict-like read-only\n     access to values.\n@@ -306,4 +304,4 @@ def __init__(self, parent):\n             "used.",\n             DeprecationWarning\n         )\n-        super(Records, self).__init__(parent)\n+        super().__init__(parent)\ndiff --git a/plone/registry/tests.py b/plone/registry/tests.py\nindex d89ab62..a83d383 100644\n--- a/plone/registry/tests.py\n+++ b/plone/registry/tests.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.registry.fieldfactory import choicePersistentFieldAdapter\n from plone.registry.fieldfactory import persistentFieldAdapter\n from zope.component import eventtesting\n@@ -53,20 +52,20 @@ class IMailSettings(Interface):\n     """Settings for email\n     """\n \n-    sender = schema.TextLine(title=u"Mail sender", default=u"root@localhost")\n-    smtp_host = schema.URI(title=u"SMTP host server")\n+    sender = schema.TextLine(title="Mail sender", default="root@localhost")\n+    smtp_host = schema.URI(title="SMTP host server")\n \n \n class IMailPreferences(Interface):\n     """Settings for email\n     """\n     max_daily = schema.Int(\n-        title=u"Maximum number of emails per day",\n+        title="Maximum number of emails per day",\n         min=0,\n         default=3\n     )\n     settings = schema.Object(\n-        title=u"Mail setings to use",\n+        title="Mail setings to use",\n         schema=IMailSettings\n     )\n \n@@ -101,10 +100,10 @@ def vocabFactory(obj):\n         reg = getVocabularyRegistry()\n         reg.register(\'my.vocab\', vocabFactory)\n \n-        class T(object):\n+        class T:\n             f = None\n \n-        f = Choice(__name__=\'f\', title=u"Test", vocabulary="my.vocab")\n+        f = Choice(__name__=\'f\', title="Test", vocabulary="my.vocab")\n         t = T()\n \n         # Bug: this would give "AttributeError: can\'t set attribute" on\n@@ -145,11 +144,11 @@ def test_auto_migration(self):\n         registry._records = Records(registry)\n         registry._records.data = OOBTree()\n \n-        f = field.TextLine(title=u"Foo")\n+        f = field.TextLine(title="Foo")\n \n-        record = Record(f, u"Bar")\n+        record = Record(f, "Bar")\n         record.__dict__[\'field\'] = f\n-        record.__dict__[\'value\'] = u"Bar"\n+        record.__dict__[\'value\'] = "Bar"\n \n         registry._records.data[\'foo.bar\'] = record\n \n@@ -159,9 +158,9 @@ def test_auto_migration(self):\n \n         # Migration should have happened\n \n-        self.assertEqual(value, u"Bar")\n-        self.assertEqual(registry.records[\'foo.bar\'].field.title, u"Foo")\n-        self.assertEqual(registry.records[\'foo.bar\'].value, u"Bar")\n+        self.assertEqual(value, "Bar")\n+        self.assertEqual(registry.records[\'foo.bar\'].field.title, "Foo")\n+        self.assertEqual(registry.records[\'foo.bar\'].value, "Bar")\n \n         self.assertFalse(isinstance(registry._records, Records))\n         self.assertTrue(isinstance(registry._records, _Records))\n@@ -193,6 +192,6 @@ def test_suite():\n             tearDown=testing.tearDown,\n             checker=PolyglotOutputChecker()\n         ),\n-        unittest.makeSuite(TestBugs),\n-        unittest.makeSuite(TestMigration),\n+        unittest.defaultTestLoader.loadTestsFromTestCase(TestBugs),\n+        unittest.defaultTestLoader.loadTestsFromTestCase(TestMigration),\n     ])\ndiff --git a/setup.py b/setup.py\nindex 0f1cd4c..b58c5a2 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:03:36+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/cc00b45db1db0081b58eab727bb9cf4afbdac02d

chore: remove unneeded aliases

Files changed:
M plone/registry/field.py
M plone/registry/recordsproxy.py
M plone/registry/registry.py

b"diff --git a/plone/registry/field.py b/plone/registry/field.py\nindex f87c11e..08b9823 100644\n--- a/plone/registry/field.py\n+++ b/plone/registry/field.py\n@@ -21,8 +21,6 @@\n except ImportError:\n     HASPLONESCHEMA = False\n \n-basestring = str\n-text_type = str\n _primitives = (int, bool, str, bytes, tuple,\n                list, set, frozenset, dict, float)\n \n@@ -228,7 +226,7 @@ class Choice(PersistentField, zope.schema.Choice):\n \n     def __init__(self, values=None, vocabulary=None, source=None, **kw):\n \n-        if vocabulary is not None and not isinstance(vocabulary, basestring):\n+        if vocabulary is not None and not isinstance(vocabulary, str):\n             values = self._normalized_values(vocabulary)\n             if values is None:\n                 raise ValueError(\n@@ -265,7 +263,7 @@ def __init__(self, values=None, vocabulary=None, source=None, **kw):\n \n     def _normalized_values(self, vocabulary):\n         if getattr(vocabulary, '__iter__', None):\n-            if all([isinstance(term.value, text_type) for term in vocabulary]):\n+            if all([isinstance(term.value, str) for term in vocabulary]):\n                 return [term.value for term in vocabulary]\n         return None\n \ndiff --git a/plone/registry/recordsproxy.py b/plone/registry/recordsproxy.py\nindex b35e897..1dee8d1 100644\n--- a/plone/registry/recordsproxy.py\n+++ b/plone/registry/recordsproxy.py\n@@ -15,8 +15,6 @@\n     from collections import UserDict\n     from collections.abc import MutableMapping as DictMixin\n \n-basestring = str\n-\n _marker = object()\n \n \n@@ -125,7 +123,7 @@ def keys(self):\n         return list(iter(self))\n \n     def _validate(self, key):\n-        if not isinstance(key, basestring) or not self._validkey(key):\n+        if not isinstance(key, str) or not self._validkey(key):\n             raise TypeError(\n                 'expected a valid key (alphanumeric or underscore, starting '\n                 'with alpha)'\ndiff --git a/plone/registry/registry.py b/plone/registry/registry.py\nindex f7a76e2..bae9af9 100644\n--- a/plone/registry/registry.py\n+++ b/plone/registry/registry.py\n@@ -21,7 +21,6 @@\n import warnings\n \n import sys\n-basestring = str\n \n \n @implementer(IRegistry)\n@@ -268,9 +267,9 @@ def _getField(self, name):\n         field = self._fields[name]\n \n         # Handle field reference pointers\n-        if isinstance(field, basestring):\n+        if isinstance(field, str):\n             recordName = field\n-            while isinstance(field, basestring):\n+            while isinstance(field, str):\n                 recordName = field\n                 field = self._fields[recordName]\n             field = FieldRef(recordName, field)\n"

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:04:02+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/9975b61d434314730435e8a33f68990b5735e353

chore: isort

Files changed:
M plone/registry/field.py
M plone/registry/recordsproxy.py
M plone/registry/registry.py
M plone/registry/tests.py

b'diff --git a/plone/registry/field.py b/plone/registry/field.py\nindex 08b9823..8c01115 100644\n--- a/plone/registry/field.py\n+++ b/plone/registry/field.py\n@@ -11,9 +11,10 @@\n from zope.schema.interfaces import IContextSourceBinder\n from zope.schema.vocabulary import SimpleVocabulary\n \n+import sys\n import zope.schema\n import zope.schema._field\n-import sys\n+\n \n try:\n     import plone.schema\ndiff --git a/plone/registry/recordsproxy.py b/plone/registry/recordsproxy.py\nindex 1dee8d1..30f028a 100644\n--- a/plone/registry/recordsproxy.py\n+++ b/plone/registry/recordsproxy.py\n@@ -9,8 +9,8 @@\n \n \n try:\n-    from UserDict import UserDict\n     from UserDict import DictMixin\n+    from UserDict import UserDict\n except ImportError:\n     from collections import UserDict\n     from collections.abc import MutableMapping as DictMixin\ndiff --git a/plone/registry/registry.py b/plone/registry/registry.py\nindex bae9af9..1ec8170 100644\n--- a/plone/registry/registry.py\n+++ b/plone/registry/registry.py\n@@ -18,9 +18,8 @@\n from zope.schema import getFieldsInOrder\n \n import re\n-import warnings\n-\n import sys\n+import warnings\n \n \n @implementer(IRegistry)\ndiff --git a/plone/registry/tests.py b/plone/registry/tests.py\nindex a83d383..8af002b 100644\n--- a/plone/registry/tests.py\n+++ b/plone/registry/tests.py\n@@ -1,9 +1,9 @@\n from plone.registry.fieldfactory import choicePersistentFieldAdapter\n from plone.registry.fieldfactory import persistentFieldAdapter\n+from zope import schema\n from zope.component import eventtesting\n from zope.component import provideAdapter\n from zope.component import testing\n-from zope import schema\n from zope.interface import Interface\n \n import doctest\n@@ -90,7 +90,6 @@ def tearDown(self):\n \n     def test_bind_choice(self):\n         from plone.registry.field import Choice\n-\n         from zope.schema.vocabulary import getVocabularyRegistry\n         from zope.schema.vocabulary import SimpleVocabulary\n \n@@ -111,7 +110,8 @@ class T:\n         f.bind(t)\n \n     def test_fieldref_interfaces(self):\n-        from plone.registry import field, FieldRef\n+        from plone.registry import field\n+        from plone.registry import FieldRef\n         from plone.registry.interfaces import IFieldRef\n         from zope.schema.interfaces import ICollection\n \n@@ -133,10 +133,11 @@ def tearDown(self):\n     def test_auto_migration(self):\n \n         from BTrees.OOBTree import OOBTree\n-\n-        from plone.registry.registry import Registry, Records, _Records\n-        from plone.registry.record import Record\n         from plone.registry import field\n+        from plone.registry.record import Record\n+        from plone.registry.registry import _Records\n+        from plone.registry.registry import Records\n+        from plone.registry.registry import Registry\n \n         # Create an "old-looking registry"\n \n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:06:59+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/986096cc67fe35435014487b7605bef64df12696

chore: black

Files changed:
M plone/__init__.py
M plone/registry/events.py
M plone/registry/field.py
M plone/registry/fieldfactory.py
M plone/registry/fieldref.py
M plone/registry/interfaces.py
M plone/registry/record.py
M plone/registry/recordsproxy.py
M plone/registry/registry.py
M plone/registry/tests.py
M setup.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex de40ea7..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1 +1 @@\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/registry/events.py b/plone/registry/events.py\nindex aeba2f6..9ce5e88 100644\n--- a/plone/registry/events.py\n+++ b/plone/registry/events.py\n@@ -11,7 +11,6 @@\n \n @implementer(IRecordEvent)\n class RecordEvent:\n-\n     def __init__(self, record):\n         self.record = record\n \n@@ -31,7 +30,6 @@ class RecordRemovedEvent(RecordEvent):\n \n @implementer(IRecordModifiedEvent)\n class RecordModifiedEvent(RecordEvent):\n-\n     def __init__(self, record, oldValue, newValue):\n         super().__init__(record)\n         self.oldValue = oldValue\ndiff --git a/plone/registry/field.py b/plone/registry/field.py\nindex 8c01115..6fcbbb8 100644\n--- a/plone/registry/field.py\n+++ b/plone/registry/field.py\n@@ -18,12 +18,12 @@\n \n try:\n     import plone.schema\n+\n     HASPLONESCHEMA = True\n except ImportError:\n     HASPLONESCHEMA = False\n \n-_primitives = (int, bool, str, bytes, tuple,\n-               list, set, frozenset, dict, float)\n+_primitives = (int, bool, str, bytes, tuple, list, set, frozenset, dict, float)\n \n _missing_value_marker = object()\n \n@@ -36,6 +36,7 @@ class DisallowedProperty:\n     """A property that may not be set on an instance. It may still be set\n     defined in a base class.\n     """\n+\n     uses = []\n \n     def __init__(self, name):\n@@ -46,8 +47,9 @@ def __get__(self, inst, type_=None):\n         # look for the object in bases\n         if type_ is not None:\n             for c in type_.__mro__:\n-                if self._name in c.__dict__ and not \\\n-                        isinstance(c.__dict__[self._name], DisallowedProperty):\n+                if self._name in c.__dict__ and not isinstance(\n+                    c.__dict__[self._name], DisallowedProperty\n+                ):\n                     function = c.__dict__[self._name]\n                     return function.__get__(inst, type_)\n         raise AttributeError(self._name)\n@@ -60,8 +62,8 @@ def __set__(self, inst, value):\n \n \n class StubbornProperty:\n-    """A property that stays stubbornly at a single, pre-defined value.\n-    """\n+    """A property that stays stubbornly at a single, pre-defined value."""\n+\n     uses = []\n \n     def __init__(self, name, value):\n@@ -77,8 +79,8 @@ def __get__(self, inst, type_=None):\n \n \n class InterfaceConstrainedProperty:\n-    """A property that may only contain values providing a certain interface.\n-    """\n+    """A property that may only contain values providing a certain interface."""\n+\n     uses = []\n \n     def __init__(self, name, interface):\n@@ -87,10 +89,7 @@ def __init__(self, name, interface):\n         self._interface = interface\n \n     def __set__(self, inst, value):\n-        if (\n-            value != inst.missing_value\n-            and not self._interface.providedBy(value)\n-        ):\n+        if value != inst.missing_value and not self._interface.providedBy(value):\n             raise ValueError(\n                 "The property `{}` may only contain objects "\n                 "providing `{}`.".format(\n@@ -103,27 +102,24 @@ def __set__(self, inst, value):\n \n @implementer(IPersistentField)\n class PersistentField(Persistent):\n-    """Base class for persistent field definitions.\n-    """\n+    """Base class for persistent field definitions."""\n+\n     # Persistent fields do not have an order\n-    order = StubbornProperty(\'order\', -1)\n+    order = StubbornProperty("order", -1)\n \n     # We don\'t allow setting a custom constraint, as this would introduce a\n     # dependency on a symbol such as a function that may go away\n-    constraint = DisallowedProperty(\'constraint\')\n+    constraint = DisallowedProperty("constraint")\n \n     # Details about which interface/field name we originally came form, if any\n     interfaceName = None\n     fieldName = None\n \n \n-class PersistentCollectionField(\n-    PersistentField,\n-    zope.schema._field.AbstractCollection\n-):\n-    """Ensure that value_type is a persistent field\n-    """\n-    value_type = InterfaceConstrainedProperty(\'value_type\', IPersistentField)\n+class PersistentCollectionField(PersistentField, zope.schema._field.AbstractCollection):\n+    """Ensure that value_type is a persistent field"""\n+\n+    value_type = InterfaceConstrainedProperty("value_type", IPersistentField)\n \n \n class Bytes(PersistentField, zope.schema.Bytes):\n@@ -187,9 +183,8 @@ class Password(PersistentField, zope.schema.Password):\n \n \n class Dict(PersistentField, zope.schema.Dict):\n-\n-    key_type = InterfaceConstrainedProperty(\'key_type\', IPersistentField)\n-    value_type = InterfaceConstrainedProperty(\'value_type\', IPersistentField)\n+    key_type = InterfaceConstrainedProperty("key_type", IPersistentField)\n+    value_type = InterfaceConstrainedProperty("value_type", IPersistentField)\n \n \n class Datetime(PersistentField, zope.schema.Datetime):\n@@ -226,7 +221,6 @@ class Choice(PersistentField, zope.schema.Choice):\n     _vocabulary = None\n \n     def __init__(self, values=None, vocabulary=None, source=None, **kw):\n-\n         if vocabulary is not None and not isinstance(vocabulary, str):\n             values = self._normalized_values(vocabulary)\n             if values is None:\n@@ -241,10 +235,12 @@ def __init__(self, values=None, vocabulary=None, source=None, **kw):\n                 "vocabularies or vocabularies based on simple value sets."\n             )\n \n-        assert not (values is None and vocabulary is None), (\n-            "You must specify either values or vocabulary.")\n-        assert values is None or vocabulary is None, (\n-            "You cannot specify both values and vocabulary.")\n+        assert not (\n+            values is None and vocabulary is None\n+        ), "You must specify either values or vocabulary."\n+        assert (\n+            values is None or vocabulary is None\n+        ), "You cannot specify both values and vocabulary."\n \n         self.vocabularyName = None\n \n@@ -263,7 +259,7 @@ def __init__(self, values=None, vocabulary=None, source=None, **kw):\n         self._init_field = False\n \n     def _normalized_values(self, vocabulary):\n-        if getattr(vocabulary, \'__iter__\', None):\n+        if getattr(vocabulary, "__iter__", None):\n             if all([isinstance(term.value, str) for term in vocabulary]):\n                 return [term.value for term in vocabulary]\n         return None\n@@ -275,7 +271,8 @@ def vocabulary(self):\n             return self._vocabulary\n         if self._values is not None:\n             return SimpleVocabulary.fromValues(self._values)\n-    DisallowedProperty.uses.append(\'vocabulary\')\n+\n+    DisallowedProperty.uses.append("vocabulary")\n \n     # override bind to allow us to keep constraints on the \'vocabulary\'\n     # property\n@@ -293,7 +290,7 @@ def bind(self, object):\n \n \n if HASPLONESCHEMA:\n-    class JSONField(PersistentField, plone.schema.JSONField):\n \n+    class JSONField(PersistentField, plone.schema.JSONField):\n         key_type = InterfaceConstrainedProperty("key_type", IPersistentField)\n         value_type = InterfaceConstrainedProperty("value_type", IPersistentField)\ndiff --git a/plone/registry/fieldfactory.py b/plone/registry/fieldfactory.py\nindex a88e320..73a238c 100644\n--- a/plone/registry/fieldfactory.py\n+++ b/plone/registry/fieldfactory.py\n@@ -17,8 +17,7 @@\n @implementer(IPersistentField)\n @adapter(IField)\n def persistentFieldAdapter(context):\n-    """Turn a non-persistent field into a persistent one\n-    """\n+    """Turn a non-persistent field into a persistent one"""\n \n     if IPersistentField.providedBy(context):\n         return context\n@@ -39,9 +38,7 @@ def persistentFieldAdapter(context):\n \n     instance = persistent_class.__new__(persistent_class)\n \n-    context_dict = {\n-        k: v for k, v in context.__dict__.items() if k not in ignored\n-    }\n+    context_dict = {k: v for k, v in context.__dict__.items() if k not in ignored}\n \n     for key, iface in constrained:\n         value = context_dict.get(key, None)\n@@ -51,7 +48,10 @@ def persistentFieldAdapter(context):\n         if value is None:\n             __traceback_info__ = (\n                 "The property `{}` cannot be adapted to "\n-                "`{}`.".format(key, iface.__identifier__,)\n+                "`{}`.".format(\n+                    key,\n+                    iface.__identifier__,\n+                )\n             )\n             return None\n         context_dict[key] = value\n@@ -63,14 +63,14 @@ def persistentFieldAdapter(context):\n @implementer(IPersistentField)\n @adapter(IChoice)\n def choicePersistentFieldAdapter(context):\n-    """Special handling for Choice fields.\n-    """\n+    """Special handling for Choice fields."""\n     instance = persistentFieldAdapter(context)\n     if instance is None:\n         return None\n \n-    if ISource.providedBy(context.vocabulary) or \\\n-            IContextSourceBinder.providedBy(context.vocabulary):\n+    if ISource.providedBy(context.vocabulary) or IContextSourceBinder.providedBy(\n+        context.vocabulary\n+    ):\n         safe = False\n \n         # Attempt to reverse engineer a \'values\' argument\ndiff --git a/plone/registry/fieldref.py b/plone/registry/fieldref.py\nindex a2582af..4d291a4 100644\n--- a/plone/registry/fieldref.py\n+++ b/plone/registry/fieldref.py\n@@ -5,8 +5,7 @@\n \n @implementer(IFieldRef)\n class FieldRef:\n-    """Default field reference.\n-    """\n+    """Default field reference."""\n \n     def __init__(self, name, originalField):\n         self.recordName = name\n@@ -14,7 +13,7 @@ def __init__(self, name, originalField):\n \n     @property\n     def __providedBy__(self):\n-        provided = getattr(self, \'__provides__\', None)\n+        provided = getattr(self, "__provides__", None)\n         if provided is None:\n             provided = implementedBy(self.__class__)\n \ndiff --git a/plone/registry/interfaces.py b/plone/registry/interfaces.py\nindex 180b9cf..a0a584e 100644\n--- a/plone/registry/interfaces.py\n+++ b/plone/registry/interfaces.py\n@@ -6,8 +6,7 @@\n \n \n class InvalidRegistryKey(InvalidDottedName):\n-    """A registry key is a dotted name with up to one \'/\'.\n-    """\n+    """A registry key is a dotted name with up to one \'/\'."""\n \n \n class IPersistentField(IField):\n@@ -23,12 +22,11 @@ class IPersistentField(IField):\n     """\n \n     interfaceName = schema.DottedName(\n-        title=\'Dotted name to an interface the field was constructed from\',\n-        required=False\n+        title="Dotted name to an interface the field was constructed from",\n+        required=False,\n     )\n     fieldName = schema.ASCIILine(\n-        title=\'Name of the field in the original interface, if any\',\n-        required=False\n+        title="Name of the field in the original interface, if any", required=False\n     )\n \n \n@@ -42,12 +40,9 @@ class IFieldRef(Interface):\n     """\n \n     recordName = schema.DottedName(\n-        title=\'Name of the record containing the reference field\'\n-    )\n-    originalField = schema.Object(\n-        title=\'Referenced field\',\n-        schema=IField\n+        title="Name of the record containing the reference field"\n     )\n+    originalField = schema.Object(title="Referenced field", schema=IField)\n \n \n class IRecord(Interface):\n@@ -63,44 +58,39 @@ class IRecord(Interface):\n     """\n \n     field = schema.Object(\n-        title=\'A field describing this record\',\n-        schema=IPersistentField\n+        title="A field describing this record", schema=IPersistentField\n     )\n \n     value = schema.Field(\n-        title=\'The value of this record\',\n-        description=\'Must be valid according to the record\\\'s field\'\n+        title="The value of this record",\n+        description="Must be valid according to the record\'s field",\n     )\n \n \n class IRecordEvent(Interface):\n-    """Base interface for record level events\n-    """\n+    """Base interface for record level events"""\n \n     record = schema.Object(\n-        title=\'The record that was added.\',\n-        description=\'Both __name__ and __parent__ will be set before the \'\n-                    \'event is fired\',\n-        schema=IRecord\n+        title="The record that was added.",\n+        description="Both __name__ and __parent__ will be set before the "\n+        "event is fired",\n+        schema=IRecord,\n     )\n \n \n class IRecordAddedEvent(IRecordEvent):\n-    """Event fired when a record is added to a registry.\n-    """\n+    """Event fired when a record is added to a registry."""\n \n \n class IRecordRemovedEvent(IRecordEvent):\n-    """Event fired when a record is removed from a registry.\n-    """\n+    """Event fired when a record is removed from a registry."""\n \n \n class IRecordModifiedEvent(IRecordEvent):\n-    """Event fired when a record\'s value is modified.\n-    """\n+    """Event fired when a record\'s value is modified."""\n \n-    oldValue = schema.Field(title=\'The record\\\'s previous value\')\n-    newValue = schema.Field(title=\'The record\\\'s new value\')\n+    oldValue = schema.Field(title="The record\'s previous value")\n+    newValue = schema.Field(title="The record\'s new value")\n \n \n class IInterfaceAwareRecord(Interface):\n@@ -111,34 +101,31 @@ class IInterfaceAwareRecord(Interface):\n     interfaceName = schema.DottedName(title="Dotted name to interface")\n \n     interface = schema.Object(\n-        title=\'Interface that provided the record\',\n-        description=\'May be None if the interface is no longer available\',\n+        title="Interface that provided the record",\n+        description="May be None if the interface is no longer available",\n         schema=IInterface,\n-        readonly=True\n+        readonly=True,\n     )\n \n-    fieldName = schema.ASCIILine(\n-        title=\'Name of the field in the original interface\'\n-    )\n+    fieldName = schema.ASCIILine(title="Name of the field in the original interface")\n \n \n class IRegistry(Interface):\n-    """The configuration registry\n-    """\n+    """The configuration registry"""\n \n     records = schema.Dict(\n-        title=\'The records of the registry\',\n+        title="The records of the registry",\n         key_type=schema.DottedName(\n-            title=\'Name of the record\',\n-            description=\'By convention, this should include the \'\n-                        \'package name and optionally an interface \'\n-                        \'named, if the record can be described by a \'\n-                        \'field in an interface (see also \'\n-                        \'registerInterface() below), e.g. \'\n-                        \'my.package.interfaces.IMySettings.somefield.\',\n+            title="Name of the record",\n+            description="By convention, this should include the "\n+            "package name and optionally an interface "\n+            "named, if the record can be described by a "\n+            "field in an interface (see also "\n+            "registerInterface() below), e.g. "\n+            "my.package.interfaces.IMySettings.somefield.",\n         ),\n         value_type=schema.Object(\n-            title=\'The record for this name\',\n+            title="The record for this name",\n             schema=IRecord,\n         ),\n     )\n@@ -162,8 +149,7 @@ def __setitem__(key, value):\n         """\n \n     def __contains__(key):\n-        """Determine if the registry contains a record for the given key.\n-        """\n+        """Determine if the registry contains a record for the given key."""\n \n     def forInterface(interface, check=True, omit=(), prefix=None):\n         """Get an IRecordsProxy for the given interface. If `check` is True,\n@@ -189,20 +175,18 @@ class IRecordsProxy(Interface):\n     """\n \n     __schema__ = schema.Object(\n-        title=\'Interface providing records\',\n-        schema=IInterface,\n-        readonly=True\n+        title="Interface providing records", schema=IInterface, readonly=True\n     )\n \n     __registry__ = schema.Object(\n-        title=\'Registry where records will be looked up\',\n+        title="Registry where records will be looked up",\n         schema=IRegistry,\n-        readonly=True)\n+        readonly=True,\n+    )\n \n     __omitted__ = schema.Tuple(\n-        title=\'Fields that are not stored in the registry\',\n-        description=\'If any of these are accessed, you will get an \'\n-                    \'AttributeError\',\n-        value_type=schema.ASCIILine(title=\'Fieldname\'),\n-        readonly=True\n+        title="Fields that are not stored in the registry",\n+        description="If any of these are accessed, you will get an " "AttributeError",\n+        value_type=schema.ASCIILine(title="Fieldname"),\n+        readonly=True,\n     )\ndiff --git a/plone/registry/record.py b/plone/registry/record.py\nindex a0f47a7..70a033a 100644\n--- a/plone/registry/record.py\n+++ b/plone/registry/record.py\n@@ -28,7 +28,6 @@ class Record(Persistent):\n     __parent__ = None\n \n     def __init__(self, field, value=_marker, _validate=True):\n-\n         if _validate and not IPersistentField.providedBy(field):\n             raise ValueError("Field is not persistent")\n \n@@ -70,7 +69,6 @@ def _get_value(self):\n         return self._value\n \n     def _set_value(self, value):\n-\n         field = self.field\n \n         if field is None:\ndiff --git a/plone/registry/recordsproxy.py b/plone/registry/recordsproxy.py\nindex 30f028a..3467558 100644\n--- a/plone/registry/recordsproxy.py\n+++ b/plone/registry/recordsproxy.py\n@@ -20,27 +20,26 @@\n \n @implementer(IRecordsProxy)\n class RecordsProxy:\n-    """A proxy that maps an interface to a number of records\n-    """\n+    """A proxy that maps an interface to a number of records"""\n \n     def __init__(self, registry, schema, omitted=(), prefix=None):\n         if prefix is None:\n-            prefix = schema.__identifier__ + \'.\'\n+            prefix = schema.__identifier__ + "."\n         elif not prefix.endswith("."):\n-            prefix += \'.\'\n+            prefix += "."\n \n         # skip __setattr__\n-        self.__dict__[\'__schema__\'] = schema\n-        self.__dict__[\'__registry__\'] = registry\n-        self.__dict__[\'__omitted__\'] = omitted\n-        self.__dict__[\'__prefix__\'] = prefix\n-        self.__dict__[\'__parent__\'] = registry\n+        self.__dict__["__schema__"] = schema\n+        self.__dict__["__registry__"] = registry\n+        self.__dict__["__omitted__"] = omitted\n+        self.__dict__["__prefix__"] = prefix\n+        self.__dict__["__parent__"] = registry\n \n         alsoProvides(self, schema)\n \n     def __getattr__(self, name):\n         if not self.__dict__ or name in self.__dict__.keys():\n-           return super().__getattr__(name)\n+            return super().__getattr__(name)\n         if name not in self.__schema__:\n             raise AttributeError(name)\n         value = self.__registry__.get(self.__prefix__ + name, _marker)\n@@ -59,26 +58,25 @@ def __setattr__(self, name, value):\n \n     def __repr__(self):\n         return "<{} for {}>".format(\n-            self.__class__.__name__,\n-            self.__schema__.__identifier__\n+            self.__class__.__name__, self.__schema__.__identifier__\n         )\n \n \n class RecordsProxyCollection(DictMixin):\n-    """A proxy that maps a collection of RecordsProxy objects\n-    """\n+    """A proxy that maps a collection of RecordsProxy objects"""\n \n     _validkey = re.compile(r"([a-zA-Z][a-zA-Z0-9_.-]*)$").match\n \n     # ord(\'.\') == ord(\'/\') - 1\n \n-    def __init__(self, registry, schema, check=True, omitted=(), prefix=None,\n-                 factory=None):\n+    def __init__(\n+        self, registry, schema, check=True, omitted=(), prefix=None, factory=None\n+    ):\n         if prefix is None:\n             prefix = schema.__identifier__\n \n         if not prefix.endswith("/"):\n-            prefix += \'/\'\n+            prefix += "/"\n \n         self.registry = registry\n         self.schema = schema\n@@ -91,27 +89,23 @@ def __getitem__(self, key):\n         if key in iter(self):\n             prefix = self.prefix + key\n             proxy = self.registry.forInterface(\n-                self.schema,\n-                self.check,\n-                self.omitted,\n-                prefix,\n-                self.factory\n+                self.schema, self.check, self.omitted, prefix, self.factory\n             )\n             return proxy\n         raise KeyError(key)\n \n     def __iter__(self):\n         min = self.prefix\n-        max = self.prefix[:-1] + \'0\'\n+        max = self.prefix[:-1] + "0"\n         keys = self.registry.records.keys(min, max)\n         len_prefix = len(self.prefix)\n         last = None\n         for name in keys:\n             name = name[len_prefix:]\n-            if \'.\' not in name:\n+            if "." not in name:\n                 yield name\n             else:\n-                key = name.rsplit(\'.\', 1)[0]\n+                key = name.rsplit(".", 1)[0]\n                 if key != last:\n                     yield key\n                     last = key\n@@ -125,27 +119,22 @@ def keys(self):\n     def _validate(self, key):\n         if not isinstance(key, str) or not self._validkey(key):\n             raise TypeError(\n-                \'expected a valid key (alphanumeric or underscore, starting \'\n-                \'with alpha)\'\n+                "expected a valid key (alphanumeric or underscore, starting "\n+                "with alpha)"\n             )\n         return str(key)\n \n     def has_key(self, key):\n         key = self._validate(key)\n         prefix = self.prefix + key\n-        names = self.registry.records.keys(prefix + \'.\', prefix + \'/\')\n+        names = self.registry.records.keys(prefix + ".", prefix + "/")\n         return bool(names)\n \n     def add(self, key):\n         key = self._validate(key)\n         prefix = self.prefix + key\n         self.registry.registerInterface(self.schema, self.omitted, prefix)\n-        proxy = self.registry.forInterface(\n-            self.schema,\n-            False,\n-            self.omitted,\n-            prefix\n-        )\n+        proxy = self.registry.forInterface(self.schema, False, self.omitted, prefix)\n         return proxy\n \n     def __setitem__(self, key, value):\n@@ -176,6 +165,6 @@ def __delitem__(self, key):\n         if key not in self:\n             raise KeyError(key)\n         prefix = self.prefix + key\n-        names = list(self.registry.records.keys(prefix + \'.\', prefix + \'/\'))\n+        names = list(self.registry.records.keys(prefix + ".", prefix + "/"))\n         for name in names:\n             del self.registry.records[name]\ndiff --git a/plone/registry/registry.py b/plone/registry/registry.py\nindex 1ec8170..fb81011 100644\n--- a/plone/registry/registry.py\n+++ b/plone/registry/registry.py\n@@ -24,8 +24,7 @@\n \n @implementer(IRegistry)\n class Registry(Persistent):\n-    """The persistent registry\n-    """\n+    """The persistent registry"""\n \n     def __init__(self):\n         self._records = _Records(self)\n@@ -60,23 +59,19 @@ def records(self):\n \n     # Schema interface API\n \n-    def forInterface(self, interface, check=True, omit=(), prefix=None,\n-                     factory=None):\n+    def forInterface(self, interface, check=True, omit=(), prefix=None, factory=None):\n         if prefix is None:\n             prefix = interface.__identifier__\n \n         if not prefix.endswith("."):\n-            prefix += \'.\'\n+            prefix += "."\n \n         if check:\n             for name in getFieldNames(interface):\n                 if name not in omit and prefix + name not in self:\n                     raise KeyError(\n                         "Interface `{}` defines a field `{}`, for which "\n-                        "there is no record.".format(\n-                            interface.__identifier__,\n-                            name\n-                        )\n+                        "there is no record.".format(interface.__identifier__, name)\n                     )\n \n         if factory is None:\n@@ -89,7 +84,7 @@ def registerInterface(self, interface, omit=(), prefix=None):\n             prefix = interface.__identifier__\n \n         if not prefix.endswith("."):\n-            prefix += \'.\'\n+            prefix += "."\n \n         for name, field in getFieldsInOrder(interface):\n             if name in omit or field.readonly:\n@@ -99,10 +94,7 @@ def registerInterface(self, interface, omit=(), prefix=None):\n             if persistent_field is None:\n                 raise TypeError(\n                     "There is no persistent field equivalent for the field "\n-                    "`{}` of type `{}`.".format(\n-                        name,\n-                        field.__class__.__name__\n-                    )\n+                    "`{}` of type `{}`.".format(name, field.__class__.__name__)\n                 )\n \n             persistent_field.interfaceName = interface.__identifier__\n@@ -120,22 +112,12 @@ def registerInterface(self, interface, omit=(), prefix=None):\n                 except:\n                     value = persistent_field.default\n \n-            self.records[record_name] = Record(\n-                persistent_field,\n-                value,\n-                _validate=False\n-            )\n-\n-    def collectionOfInterface(self, interface, check=True, omit=(),\n-                              prefix=None, factory=None):\n-        return RecordsProxyCollection(\n-            self,\n-            interface,\n-            check,\n-            omit,\n-            prefix,\n-            factory\n-        )\n+            self.records[record_name] = Record(persistent_field, value, _validate=False)\n+\n+    def collectionOfInterface(\n+        self, interface, check=True, omit=(), prefix=None, factory=None\n+    ):\n+        return RecordsProxyCollection(self, interface, check, omit, prefix, factory)\n \n     # BBB\n \n@@ -145,16 +127,13 @@ def _migrateRecords(self):\n         """\n         records = _Records(self)\n \n-        oldData = getattr(self._records, \'data\', None)\n+        oldData = getattr(self._records, "data", None)\n         if oldData is not None:\n             for name, oldRecord in oldData.iteritems():\n                 oldRecord._p_activate()\n-                if (\n-                    \'field\' in oldRecord.__dict__\n-                    and \'value\' in oldRecord.__dict__\n-                ):\n-                    records._fields[name] = oldRecord.__dict__[\'field\']\n-                    records._values[name] = oldRecord.__dict__[\'value\']\n+                if "field" in oldRecord.__dict__ and "value" in oldRecord.__dict__:\n+                    records._fields[name] = oldRecord.__dict__["field"]\n+                    records._values[name] = oldRecord.__dict__["value"]\n \n         self._records = records\n \n@@ -164,6 +143,7 @@ class _Records:\n     to records, where as the Registry object implements dict-like read-only\n     access to values.\n     """\n+\n     __parent__ = None\n \n     # Similar to zope.schema._field._isdotted, but allows up to one \'/\'\n@@ -205,7 +185,6 @@ def __delitem__(self, name):\n         notify(RecordRemovedEvent(record))\n \n     def __getitem__(self, name):\n-\n         field = self._getField(name)\n         value = self._values[name]\n \n@@ -249,7 +228,7 @@ def values(self, min=None, max=None):\n         return [self[name] for name in self.keys(min, max)]\n \n     def items(self, min=None, max=None):\n-        return [(name, self[name],) for name in self.keys(min, max)]\n+        return [(name, self[name]) for name in self.keys(min, max)]\n \n     def setdefault(self, key, value):\n         if key not in self:\n@@ -280,12 +259,10 @@ def _setField(self, name, field):\n             raise ValueError("The record\'s field must be an IPersistentField.")\n         if IFieldRef.providedBy(field):\n             if field.recordName not in self._fields:\n-                raise ValueError(\n-                    "Field reference points to non-existent record"\n-                )\n+                raise ValueError("Field reference points to non-existent record")\n             self._fields[name] = field.recordName  # a pointer, of sorts\n         else:\n-            field.__name__ = \'value\'\n+            field.__name__ = "value"\n             self._fields[name] = field\n \n \n@@ -298,8 +275,7 @@ class Records(_Records, Persistent):\n \n     def __init__(self, parent):\n         warnings.warn(\n-            "The Records persistent class is deprecated and should not be "\n-            "used.",\n-            DeprecationWarning\n+            "The Records persistent class is deprecated and should not be " "used.",\n+            DeprecationWarning,\n         )\n         super().__init__(parent)\ndiff --git a/plone/registry/tests.py b/plone/registry/tests.py\nindex 8af002b..db8be56 100644\n--- a/plone/registry/tests.py\n+++ b/plone/registry/tests.py\n@@ -12,62 +12,53 @@\n import unittest\n \n \n-SKIP_PYTHON_2 = doctest.register_optionflag(\'SKIP_PYTHON_2\')\n-SKIP_PYTHON_3 = doctest.register_optionflag(\'SKIP_PYTHON_3\')\n-IGNORE_B = doctest.register_optionflag(\'IGNORE_B\')\n-IGNORE_U = doctest.register_optionflag(\'IGNORE_U\')\n+SKIP_PYTHON_2 = doctest.register_optionflag("SKIP_PYTHON_2")\n+SKIP_PYTHON_3 = doctest.register_optionflag("SKIP_PYTHON_3")\n+IGNORE_B = doctest.register_optionflag("IGNORE_B")\n+IGNORE_U = doctest.register_optionflag("IGNORE_U")\n \n \n class PolyglotOutputChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n         # fix changed objectfield class in zope4\n         got = re.sub(\n-            \'zope.schema._field.Object\',\n-            \'zope.schema._bootstrapfields.Object\', got)\n+            "zope.schema._field.Object", "zope.schema._bootstrapfields.Object", got\n+        )\n \n         if optionflags & SKIP_PYTHON_3 and sys.version_info >= (3,):\n             return True\n         elif optionflags & SKIP_PYTHON_2:\n             return True\n \n-        if hasattr(self, \'_toAscii\'):\n+        if hasattr(self, "_toAscii"):\n             got = self._toAscii(got)\n             want = self._toAscii(want)\n \n         # Naive fix for comparing byte strings\n         if got != want and optionflags & IGNORE_B:\n-            got = re.sub(r\'^b([\\\'"])\', r\'\\1\', got)\n-            want = re.sub(r\'^b([\\\'"])\', r\'\\1\', want)\n+            got = re.sub(r\'^b([\\\'"])\', r"\\1", got)\n+            want = re.sub(r\'^b([\\\'"])\', r"\\1", want)\n \n         # Naive fix for comparing byte strings\n         if got != want and optionflags & IGNORE_U:\n-            got = re.sub(r\'^u([\\\'"])\', r\'\\1\', got)\n-            want = re.sub(r\'^u([\\\'"])\', r\'\\1\', want)\n+            got = re.sub(r\'^u([\\\'"])\', r"\\1", got)\n+            want = re.sub(r\'^u([\\\'"])\', r"\\1", want)\n \n-        return doctest.OutputChecker.check_output(\n-            self, want, got, optionflags)\n+        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \n class IMailSettings(Interface):\n-    """Settings for email\n-    """\n+    """Settings for email"""\n \n     sender = schema.TextLine(title="Mail sender", default="root@localhost")\n     smtp_host = schema.URI(title="SMTP host server")\n \n \n class IMailPreferences(Interface):\n-    """Settings for email\n-    """\n-    max_daily = schema.Int(\n-        title="Maximum number of emails per day",\n-        min=0,\n-        default=3\n-    )\n-    settings = schema.Object(\n-        title="Mail setings to use",\n-        schema=IMailSettings\n-    )\n+    """Settings for email"""\n+\n+    max_daily = schema.Int(title="Maximum number of emails per day", min=0, default=3)\n+    settings = schema.Object(title="Mail setings to use", schema=IMailSettings)\n \n \n def setUp(test=None):\n@@ -79,8 +70,7 @@ def setUp(test=None):\n \n \n class TestBugs(unittest.TestCase):\n-    """Regression tests for bugs that have been fixed\n-    """\n+    """Regression tests for bugs that have been fixed"""\n \n     def setUp(self):\n         setUp(self)\n@@ -94,15 +84,15 @@ def test_bind_choice(self):\n         from zope.schema.vocabulary import SimpleVocabulary\n \n         def vocabFactory(obj):\n-            return SimpleVocabulary.fromValues([\'one\', \'two\'])\n+            return SimpleVocabulary.fromValues(["one", "two"])\n \n         reg = getVocabularyRegistry()\n-        reg.register(\'my.vocab\', vocabFactory)\n+        reg.register("my.vocab", vocabFactory)\n \n         class T:\n             f = None\n \n-        f = Choice(__name__=\'f\', title="Test", vocabulary="my.vocab")\n+        f = Choice(__name__="f", title="Test", vocabulary="my.vocab")\n         t = T()\n \n         # Bug: this would give "AttributeError: can\'t set attribute" on\n@@ -116,14 +106,13 @@ def test_fieldref_interfaces(self):\n         from zope.schema.interfaces import ICollection\n \n         listField = field.List(value_type=field.ASCIILine())\n-        ref = FieldRef(\'some.record\', listField)\n+        ref = FieldRef("some.record", listField)\n \n         self.assertTrue(ICollection.providedBy(ref))\n         self.assertTrue(IFieldRef.providedBy(ref))\n \n \n class TestMigration(unittest.TestCase):\n-\n     def setUp(self):\n         setUp(self)\n \n@@ -131,7 +120,6 @@ def tearDown(self):\n         testing.tearDown(self)\n \n     def test_auto_migration(self):\n-\n         from BTrees.OOBTree import OOBTree\n         from plone.registry import field\n         from plone.registry.record import Record\n@@ -148,51 +136,53 @@ def test_auto_migration(self):\n         f = field.TextLine(title="Foo")\n \n         record = Record(f, "Bar")\n-        record.__dict__[\'field\'] = f\n-        record.__dict__[\'value\'] = "Bar"\n+        record.__dict__["field"] = f\n+        record.__dict__["value"] = "Bar"\n \n-        registry._records.data[\'foo.bar\'] = record\n+        registry._records.data["foo.bar"] = record\n \n         # Attempt to access it\n \n-        value = registry[\'foo.bar\']\n+        value = registry["foo.bar"]\n \n         # Migration should have happened\n \n         self.assertEqual(value, "Bar")\n-        self.assertEqual(registry.records[\'foo.bar\'].field.title, "Foo")\n-        self.assertEqual(registry.records[\'foo.bar\'].value, "Bar")\n+        self.assertEqual(registry.records["foo.bar"].field.title, "Foo")\n+        self.assertEqual(registry.records["foo.bar"].value, "Bar")\n \n         self.assertFalse(isinstance(registry._records, Records))\n         self.assertTrue(isinstance(registry._records, _Records))\n \n \n def test_suite():\n-    return unittest.TestSuite([\n-        doctest.DocFileSuite(\n-            \'registry.rst\',\n-            package=\'plone.registry\',\n-            optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,\n-            setUp=setUp,\n-            tearDown=testing.tearDown,\n-            checker=PolyglotOutputChecker()\n-        ),\n-        doctest.DocFileSuite(\n-            \'events.rst\',\n-            package=\'plone.registry\',\n-            optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,\n-            setUp=setUp,\n-            tearDown=testing.tearDown,\n-            checker=PolyglotOutputChecker()\n-        ),\n-        doctest.DocFileSuite(\n-            \'field.rst\',\n-            package=\'plone.registry\',\n-            optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,\n-            setUp=setUp,\n-            tearDown=testing.tearDown,\n-            checker=PolyglotOutputChecker()\n-        ),\n-        unittest.defaultTestLoader.loadTestsFromTestCase(TestBugs),\n-        unittest.defaultTestLoader.loadTestsFromTestCase(TestMigration),\n-    ])\n+    return unittest.TestSuite(\n+        [\n+            doctest.DocFileSuite(\n+                "registry.rst",\n+                package="plone.registry",\n+                optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,\n+                setUp=setUp,\n+                tearDown=testing.tearDown,\n+                checker=PolyglotOutputChecker(),\n+            ),\n+            doctest.DocFileSuite(\n+                "events.rst",\n+                package="plone.registry",\n+                optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,\n+                setUp=setUp,\n+                tearDown=testing.tearDown,\n+                checker=PolyglotOutputChecker(),\n+            ),\n+            doctest.DocFileSuite(\n+                "field.rst",\n+                package="plone.registry",\n+                optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,\n+                setUp=setUp,\n+                tearDown=testing.tearDown,\n+                checker=PolyglotOutputChecker(),\n+            ),\n+            unittest.defaultTestLoader.loadTestsFromTestCase(TestBugs),\n+            unittest.defaultTestLoader.loadTestsFromTestCase(TestMigration),\n+        ]\n+    )\ndiff --git a/setup.py b/setup.py\nindex b58c5a2..1e8d538 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -7,24 +7,25 @@\n def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n-version = \'1.2.2.dev0\'\n+\n+version = "1.2.2.dev0"\n \n description = "Registry for application settings (like debconf/ about:config)"\n long_description = (\n-    read(\'README.rst\') +\n-    \'\\n\' +\n-    read(\'plone\', \'registry\', \'registry.rst\') +\n-    \'\\n\' +\n-    read(\'plone\', \'registry\', \'events.rst\') +\n-    \'\\n\' +\n-    read(\'plone\', \'registry\', \'field.rst\') +\n-    \'\\n\' +\n-    read(\'CHANGES.rst\') +\n-    \'\\n\'\n+    read("README.rst")\n+    + "\\n"\n+    + read("plone", "registry", "registry.rst")\n+    + "\\n"\n+    + read("plone", "registry", "events.rst")\n+    + "\\n"\n+    + read("plone", "registry", "field.rst")\n+    + "\\n"\n+    + read("CHANGES.rst")\n+    + "\\n"\n )\n \n setup(\n-    name=\'plone.registry\',\n+    name="plone.registry",\n     version=version,\n     description=description,\n     long_description=long_description,\n@@ -44,26 +45,24 @@ def read(*rnames):\n         "Programming Language :: Python :: 3.8",\n         "Topic :: Software Development :: Libraries :: Python Modules",\n     ],\n-    keywords=\'configuration registry\',\n-    author=\'Martin Aspeli, Wichert Akkerman, Hanno Schlichting\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://pypi.org/project/plone.registry\',\n-    license=\'GPL\',\n+    keywords="configuration registry",\n+    author="Martin Aspeli, Wichert Akkerman, Hanno Schlichting",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://pypi.org/project/plone.registry",\n+    license="GPL",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n-        \'zope.component\',\n-        \'zope.dottedname\',\n-        \'zope.event\',\n-        \'zope.interface\',\n-        \'zope.schema\',\n+        "setuptools",\n+        "zope.component",\n+        "zope.dottedname",\n+        "zope.event",\n+        "zope.interface",\n+        "zope.schema",\n     ],\n-    extras_require={\n-        \'test\': [\'BTrees\', \'plone.schema\']\n-    },\n+    extras_require={"test": ["BTrees", "plone.schema"]},\n     entry_points="""\n     # -*- Entry points: -*-\n     """,\n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:07:28+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/b245e660c5c75e2abf63f45879a64d0318578040

chore: zpretty

Files changed:
M plone/registry/configure.zcml

b'diff --git a/plone/registry/configure.zcml b/plone/registry/configure.zcml\nindex 6e1e133..4bd6a95 100644\n--- a/plone/registry/configure.zcml\n+++ b/plone/registry/configure.zcml\n@@ -1,10 +1,11 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    i18n_domain="plone.registry">\n+    i18n_domain="plone.registry"\n+    >\n \n-    <adapter factory=".fieldfactory.persistentFieldAdapter" />\n-    <adapter factory=".fieldfactory.choicePersistentFieldAdapter" />\n+  <adapter factory=".fieldfactory.persistentFieldAdapter" />\n+  <adapter factory=".fieldfactory.choicePersistentFieldAdapter" />\n \n-    <subscriber handler=".events.redispatchInterfaceAwareRecordEvents" />\n+  <subscriber handler=".events.redispatchInterfaceAwareRecordEvents" />\n \n </configure>\n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:11:13+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/0ebd40275f344a9871b3bb4007b94be157c1fcf4

chore: update trove classifiers

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex 1e8d538..e800972 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -32,17 +32,15 @@ def read(*rnames):\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Framework :: Plone",\n-        "Framework :: Plone :: 5.1",\n-        "Framework :: Plone :: 5.2",\n+        "Framework :: Plone :: 6.0",\n         "Framework :: Plone :: Core",\n         "License :: OSI Approved :: GNU General Public License (GPL)",\n-        "Programming Language :: Python :: 2",\n-        "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python",\n         "Programming Language :: Python :: 3",\n-        "Programming Language :: Python :: 3.5",\n-        "Programming Language :: Python :: 3.6",\n-        "Programming Language :: Python :: 3.7",\n         "Programming Language :: Python :: 3.8",\n+        "Programming Language :: Python :: 3.9",\n+        "Programming Language :: Python :: 3.10",\n+        "Programming Language :: Python :: 3.11",\n         "Topic :: Software Development :: Libraries :: Python Modules",\n     ],\n     keywords="configuration registry",\n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:11:29+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/9d6ec1ef0465b5b4d6c95242456e4781bc34950c

feat: pyroma

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex e800972..8046e39 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -52,6 +52,7 @@ def read(*rnames):\n     namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n+    python_requires=">=3.8",\n     install_requires=[\n         "setuptools",\n         "zope.component",\n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:13:29+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/fee08998080a8520ae4c9c8f368a057bff2257eb

feat: codespell

Files changed:
M plone/registry/events.py
M plone/registry/registry.py
M plone/registry/tests.py

b'diff --git a/plone/registry/events.py b/plone/registry/events.py\nindex 9ce5e88..976ee22 100644\n--- a/plone/registry/events.py\n+++ b/plone/registry/events.py\n@@ -39,7 +39,7 @@ def __init__(self, record, oldValue, newValue):\n @adapter(IRecordEvent)\n def redispatchInterfaceAwareRecordEvents(event):\n     """When an interface-aware record received a record event,\n-    redispatch the event in a simlar manner to the IObjectEvent redispatcher.\n+    redispatch the event in a similar manner to the IObjectEvent redispatcher.\n \n     Note that this means one IRecordModifiedEvent will be fired for each\n     change to a record.\ndiff --git a/plone/registry/registry.py b/plone/registry/registry.py\nindex fb81011..313f759 100644\n--- a/plone/registry/registry.py\n+++ b/plone/registry/registry.py\n@@ -102,7 +102,7 @@ def registerInterface(self, interface, omit=(), prefix=None):\n \n             value = persistent_field.default\n \n-            # Attempt to retain the exisiting value\n+            # Attempt to retain the existing value\n             if record_name in self.records:\n                 existing_record = self.records[record_name]\n                 value = existing_record.value\ndiff --git a/plone/registry/tests.py b/plone/registry/tests.py\nindex db8be56..5f57f10 100644\n--- a/plone/registry/tests.py\n+++ b/plone/registry/tests.py\n@@ -58,7 +58,7 @@ class IMailPreferences(Interface):\n     """Settings for email"""\n \n     max_daily = schema.Int(title="Maximum number of emails per day", min=0, default=3)\n-    settings = schema.Object(title="Mail setings to use", schema=IMailSettings)\n+    settings = schema.Object(title="Mail settings to use", schema=IMailSettings)\n \n \n def setUp(test=None):\n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:17:08+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/a76152d9146463deb8b5d784fec0026a5c3dc04a

chore: configure flake8

Files changed:
M setup.cfg

b'diff --git a/setup.cfg b/setup.cfg\nindex 0da8f8f..73dc257 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -14,6 +14,8 @@ ignore =\n     E203,\n     # black takes care of spaces after commas\n     E231,\n+per-file-ignores =\n+    plone/registry/__init__.py:F401\n \n [check-manifest]\n ignore =\n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:17:41+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/c1523c75926e59a760aaa391a26cf09f31c7abfc

feat: flake8

Files changed:
M plone/registry/field.py
M plone/registry/recordsproxy.py
M plone/registry/registry.py

b'diff --git a/plone/registry/field.py b/plone/registry/field.py\nindex 6fcbbb8..5e1e3ac 100644\n--- a/plone/registry/field.py\n+++ b/plone/registry/field.py\n@@ -11,7 +11,6 @@\n from zope.schema.interfaces import IContextSourceBinder\n from zope.schema.vocabulary import SimpleVocabulary\n \n-import sys\n import zope.schema\n import zope.schema._field\n \ndiff --git a/plone/registry/recordsproxy.py b/plone/registry/recordsproxy.py\nindex 3467558..8cca9c9 100644\n--- a/plone/registry/recordsproxy.py\n+++ b/plone/registry/recordsproxy.py\n@@ -5,14 +5,11 @@\n from zope.schema.interfaces import RequiredMissing\n \n import re\n-import sys\n \n \n try:\n     from UserDict import DictMixin\n-    from UserDict import UserDict\n except ImportError:\n-    from collections import UserDict\n     from collections.abc import MutableMapping as DictMixin\n \n _marker = object()\ndiff --git a/plone/registry/registry.py b/plone/registry/registry.py\nindex 313f759..d9cf553 100644\n--- a/plone/registry/registry.py\n+++ b/plone/registry/registry.py\n@@ -18,7 +18,6 @@\n from zope.schema import getFieldsInOrder\n \n import re\n-import sys\n import warnings\n \n \n@@ -109,7 +108,7 @@ def registerInterface(self, interface, omit=(), prefix=None):\n                 bound_field = persistent_field.bind(existing_record)\n                 try:\n                     bound_field.validate(value)\n-                except:\n+                except Exception:\n                     value = persistent_field.default\n \n             self.records[record_name] = Record(persistent_field, value, _validate=False)\n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:22:19+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/ff042a3bb0e6e4c5e10cc248aeaa36c8d8d6bec9

fix: remove fallback import

Files changed:
M plone/registry/recordsproxy.py

b'diff --git a/plone/registry/recordsproxy.py b/plone/registry/recordsproxy.py\nindex 8cca9c9..b1e9dba 100644\n--- a/plone/registry/recordsproxy.py\n+++ b/plone/registry/recordsproxy.py\n@@ -1,3 +1,4 @@\n+from collections.abc import MutableMapping\n from plone.registry.interfaces import IRecordsProxy\n from zope.interface import alsoProvides\n from zope.interface import implementer\n@@ -7,11 +8,6 @@\n import re\n \n \n-try:\n-    from UserDict import DictMixin\n-except ImportError:\n-    from collections.abc import MutableMapping as DictMixin\n-\n _marker = object()\n \n \n@@ -59,7 +55,7 @@ def __repr__(self):\n         )\n \n \n-class RecordsProxyCollection(DictMixin):\n+class RecordsProxyCollection(MutableMapping):\n     """A proxy that maps a collection of RecordsProxy objects"""\n \n     _validkey = re.compile(r"([a-zA-Z][a-zA-Z0-9_.-]*)$").match\n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:23:00+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/5a6f054ae16033235ad32867c07ec2fd2d958520

feat: configure z3c.dependencychecker

Files changed:
M pyproject.toml

b"diff --git a/pyproject.toml b/pyproject.toml\nindex 639f77a..547e351 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -82,3 +82,4 @@ Zope = [\n   'Products.CMFCore', 'Products.CMFDynamicViewFTI',\n ]\n python-dateutil = ['dateutil']\n+ignore-packages = ['plone.schema']\n"

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:30:29+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/3909619e26ff5a09ec64befbbf9d693fbadfcb44

fix: drop more python 2 compatibility

Files changed:
M plone/registry/registry.rst
M plone/registry/tests.py

b'diff --git a/plone/registry/registry.rst b/plone/registry/registry.rst\nindex 5952d69..f00fb5c 100644\n--- a/plone/registry/registry.rst\n+++ b/plone/registry/registry.rst\n@@ -74,12 +74,7 @@ We can set a different value, either in the ``Record`` constructor or via the ``\n \n Note that the value is validated against the field::\n \n-    >>> age_record.value = -1  # doctest: +SKIP_PYTHON_3\n-    Traceback (most recent call last):\n-    ...\n-    TooSmall: (-1, 0)\n-\n-    >>> age_record.value = -1  # doctest: +SKIP_PYTHON_2\n+    >>> age_record.value = -1\n     Traceback (most recent call last):\n     ...\n     zope.schema._bootstrapinterfaces.TooSmall: (-1, 0)\n@@ -138,12 +133,7 @@ you can access its value through dict-like operations on the registry itself::\n \n Again, values are validated::\n \n-    >>> registry[\'plone.registry.tests.cms\'] = b\'Joomla\'  # doctest: +SKIP_PYTHON_3\n-    Traceback (most recent call last):\n-    ...\n-    WrongType: (\'Joomla\', <type \'unicode\'>...)\n-\n-    >>> registry[\'plone.registry.tests.cms\'] = b\'Joomla\'  # doctest: +SKIP_PYTHON_2\n+    >>> registry[\'plone.registry.tests.cms\'] = b\'Joomla\'\n     Traceback (most recent call last):\n     ...\n     zope.schema._bootstrapinterfaces.WrongType: (b\'Joomla\', <class \'str\'>, \'value\')\n@@ -488,20 +478,15 @@ The two values are separate::\n \n Validation uses the underlying field::\n \n-    >>> registry[\'plone.registry.tests.timeout.override\'] = -1  # doctest: +SKIP_PYTHON_3\n-    Traceback (most recent call last):\n-    ...\n-    TooSmall: (-1, 0)\n-\n-    >>> registry[\'plone.registry.tests.timeout.override\'] = -1  # doctest: +SKIP_PYTHON_2\n+    >>> registry[\'plone.registry.tests.timeout.override\'] = -1\n     Traceback (most recent call last):\n     ...\n     zope.schema._bootstrapinterfaces.TooSmall: (-1, 0)\n \n The reference field exposes the standard field properties, e.g.::\n \n-    >>> timeout_override_record.field.title  # doctest: +SKIP_PYTHON_3\n-    u\'Timeout\'\n+    >>> timeout_override_record.field.title\n+    \'Timeout\'\n     >>> timeout_override_record.field.min\n     0\n \ndiff --git a/plone/registry/tests.py b/plone/registry/tests.py\nindex 5f57f10..19cfc3a 100644\n--- a/plone/registry/tests.py\n+++ b/plone/registry/tests.py\n@@ -8,13 +8,9 @@\n \n import doctest\n import re\n-import sys\n import unittest\n \n \n-SKIP_PYTHON_2 = doctest.register_optionflag("SKIP_PYTHON_2")\n-SKIP_PYTHON_3 = doctest.register_optionflag("SKIP_PYTHON_3")\n-IGNORE_B = doctest.register_optionflag("IGNORE_B")\n IGNORE_U = doctest.register_optionflag("IGNORE_U")\n \n \n@@ -25,20 +21,10 @@ def check_output(self, want, got, optionflags):\n             "zope.schema._field.Object", "zope.schema._bootstrapfields.Object", got\n         )\n \n-        if optionflags & SKIP_PYTHON_3 and sys.version_info >= (3,):\n-            return True\n-        elif optionflags & SKIP_PYTHON_2:\n-            return True\n-\n         if hasattr(self, "_toAscii"):\n             got = self._toAscii(got)\n             want = self._toAscii(want)\n \n-        # Naive fix for comparing byte strings\n-        if got != want and optionflags & IGNORE_B:\n-            got = re.sub(r\'^b([\\\'"])\', r"\\1", got)\n-            want = re.sub(r\'^b([\\\'"])\', r"\\1", want)\n-\n         # Naive fix for comparing byte strings\n         if got != want and optionflags & IGNORE_U:\n             got = re.sub(r\'^u([\\\'"])\', r"\\1", got)\n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-23T19:31:07+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.registry/commit/bc1035a4dcd4f3e6517e6aef8a35c4dd9b8f2032

Add news entry

Files changed:
A news/1.breaking

b'diff --git a/news/1.breaking b/news/1.breaking\nnew file mode 100644\nindex 0000000..6a2e7d2\n--- /dev/null\n+++ b/news/1.breaking\n@@ -0,0 +1,2 @@\n+Drop python 2.7 compatibility.\n+[gforcada]\n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-24T12:52:49+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.registry/commit/08fcc86d1d77d2f6fad56e8b347344ff71d0de43

bump version

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex 8046e39..808559b 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -8,7 +8,7 @@ def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n \n-version = "1.2.2.dev0"\n+version = "2.0.0.dev0"\n \n description = "Registry for application settings (like debconf/ about:config)"\n long_description = (\n'

Repository: plone.registry


Branch: refs/heads/master
Date: 2023-04-24T19:08:11+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.registry/commit/03e9a405b5e5fb3c0aceba770ac64bb6a97a2fa4

Merge pull request #26 from plone/config-with-default-template-59299cef

Config with default template

Files changed:
A .editorconfig
A .meta.toml
A .pre-commit-config.yaml
A news/1.breaking
A news/a864b30f.internal
A tox.ini
M plone/__init__.py
M plone/registry/__init__.py
M plone/registry/configure.zcml
M plone/registry/events.py
M plone/registry/field.py
M plone/registry/fieldfactory.py
M plone/registry/fieldref.py
M plone/registry/interfaces.py
M plone/registry/record.py
M plone/registry/recordsproxy.py
M plone/registry/registry.py
M plone/registry/registry.rst
M plone/registry/tests.py
M pyproject.toml
M setup.cfg
M setup.py

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..ab85364\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "a864b30f"\ndiff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nnew file mode 100644\nindex 0000000..fdafec1\n--- /dev/null\n+++ b/.pre-commit-config.yaml\n@@ -0,0 +1,42 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+ci:\n+    autofix_prs: false\n+    autoupdate_schedule: monthly\n+\n+repos:\n+-   repo: https://github.com/asottile/pyupgrade\n+    rev: v3.3.1\n+    hooks:\n+    -   id: pyupgrade\n+        args: [--py38-plus]\n+-   repo: https://github.com/pycqa/isort\n+    rev: 5.12.0\n+    hooks:\n+    -   id: isort\n+-   repo: https://github.com/psf/black\n+    rev: 23.3.0\n+    hooks:\n+    -   id: black\n+-   repo: https://github.com/collective/zpretty\n+    rev: 3.0.3\n+    hooks:\n+    -   id: zpretty\n+-   repo: https://github.com/PyCQA/flake8\n+    rev: 6.0.0\n+    hooks:\n+    -   id: flake8\n+-   repo: https://github.com/codespell-project/codespell\n+    rev: v2.2.4\n+    hooks:\n+    -   id: codespell\n+        additional_dependencies:\n+          - tomli\n+-   repo: https://github.com/mgedmin/check-manifest\n+    rev: "0.49"\n+    hooks:\n+    -   id: check-manifest\n+-   repo: https://github.com/regebro/pyroma\n+    rev: "4.2"\n+    hooks:\n+    -   id: pyroma\ndiff --git a/news/1.breaking b/news/1.breaking\nnew file mode 100644\nindex 0000000..6a2e7d2\n--- /dev/null\n+++ b/news/1.breaking\n@@ -0,0 +1,2 @@\n+Drop python 2.7 compatibility.\n+[gforcada]\ndiff --git a/news/a864b30f.internal b/news/a864b30f.internal\nnew file mode 100644\nindex 0000000..c08f539\n--- /dev/null\n+++ b/news/a864b30f.internal\n@@ -0,0 +1,2 @@\n+Update configuration files.\n+[plone devs]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/registry/__init__.py b/plone/registry/__init__.py\nindex 73c057b..f10cc39 100644\n--- a/plone/registry/__init__.py\n+++ b/plone/registry/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.registry.fieldref import FieldRef\n from plone.registry.record import Record\n from plone.registry.registry import Registry\ndiff --git a/plone/registry/configure.zcml b/plone/registry/configure.zcml\nindex 6e1e133..4bd6a95 100644\n--- a/plone/registry/configure.zcml\n+++ b/plone/registry/configure.zcml\n@@ -1,10 +1,11 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    i18n_domain="plone.registry">\n+    i18n_domain="plone.registry"\n+    >\n \n-    <adapter factory=".fieldfactory.persistentFieldAdapter" />\n-    <adapter factory=".fieldfactory.choicePersistentFieldAdapter" />\n+  <adapter factory=".fieldfactory.persistentFieldAdapter" />\n+  <adapter factory=".fieldfactory.choicePersistentFieldAdapter" />\n \n-    <subscriber handler=".events.redispatchInterfaceAwareRecordEvents" />\n+  <subscriber handler=".events.redispatchInterfaceAwareRecordEvents" />\n \n </configure>\ndiff --git a/plone/registry/events.py b/plone/registry/events.py\nindex a086c53..976ee22 100644\n--- a/plone/registry/events.py\n+++ b/plone/registry/events.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.registry.interfaces import IInterfaceAwareRecord\n from plone.registry.interfaces import IRecordAddedEvent\n from plone.registry.interfaces import IRecordEvent\n@@ -11,13 +10,12 @@\n \n \n @implementer(IRecordEvent)\n-class RecordEvent(object):\n-\n+class RecordEvent:\n     def __init__(self, record):\n         self.record = record\n \n     def __repr__(self):\n-        return "<%s for %s>" % (self.__class__.__name__, self.record.__name__)\n+        return f"<{self.__class__.__name__} for {self.record.__name__}>"\n \n \n @implementer(IRecordAddedEvent)\n@@ -32,9 +30,8 @@ class RecordRemovedEvent(RecordEvent):\n \n @implementer(IRecordModifiedEvent)\n class RecordModifiedEvent(RecordEvent):\n-\n     def __init__(self, record, oldValue, newValue):\n-        super(RecordModifiedEvent, self).__init__(record)\n+        super().__init__(record)\n         self.oldValue = oldValue\n         self.newValue = newValue\n \n@@ -42,7 +39,7 @@ def __init__(self, record, oldValue, newValue):\n @adapter(IRecordEvent)\n def redispatchInterfaceAwareRecordEvents(event):\n     """When an interface-aware record received a record event,\n-    redispatch the event in a simlar manner to the IObjectEvent redispatcher.\n+    redispatch the event in a similar manner to the IObjectEvent redispatcher.\n \n     Note that this means one IRecordModifiedEvent will be fired for each\n     change to a record.\ndiff --git a/plone/registry/field.py b/plone/registry/field.py\nindex 2bd60a3..5e1e3ac 100644\n--- a/plone/registry/field.py\n+++ b/plone/registry/field.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """This module defines persistent versions of various fields.\n \n The idea is that when a record is created, we copy relevant field properties\n@@ -14,23 +13,16 @@\n \n import zope.schema\n import zope.schema._field\n-import sys\n+\n \n try:\n     import plone.schema\n+\n     HASPLONESCHEMA = True\n except ImportError:\n     HASPLONESCHEMA = False\n \n-if sys.version_info >= (3,):\n-    basestring = str\n-    text_type = str\n-    _primitives = (int, bool, str, bytes, tuple,\n-                   list, set, frozenset, dict, float)\n-else:\n-    text_type = unicode\n-    _primitives = (int, long, bool, str, unicode, tuple,\n-                   list, set, frozenset, dict, float)\n+_primitives = (int, bool, str, bytes, tuple, list, set, frozenset, dict, float)\n \n _missing_value_marker = object()\n \n@@ -39,10 +31,11 @@ def is_primitive(value):\n     return value is None or isinstance(value, _primitives)\n \n \n-class DisallowedProperty(object):\n+class DisallowedProperty:\n     """A property that may not be set on an instance. It may still be set\n     defined in a base class.\n     """\n+\n     uses = []\n \n     def __init__(self, name):\n@@ -53,22 +46,23 @@ def __get__(self, inst, type_=None):\n         # look for the object in bases\n         if type_ is not None:\n             for c in type_.__mro__:\n-                if self._name in c.__dict__ and not \\\n-                        isinstance(c.__dict__[self._name], DisallowedProperty):\n+                if self._name in c.__dict__ and not isinstance(\n+                    c.__dict__[self._name], DisallowedProperty\n+                ):\n                     function = c.__dict__[self._name]\n                     return function.__get__(inst, type_)\n         raise AttributeError(self._name)\n \n     def __set__(self, inst, value):\n         raise ValueError(\n-            u"Persistent fields does not support setting the `{0}` "\n-            u"property".format(self._name)\n+            "Persistent fields does not support setting the `{}` "\n+            "property".format(self._name)\n         )\n \n \n-class StubbornProperty(object):\n-    """A property that stays stubbornly at a single, pre-defined value.\n-    """\n+class StubbornProperty:\n+    """A property that stays stubbornly at a single, pre-defined value."""\n+\n     uses = []\n \n     def __init__(self, name, value):\n@@ -83,9 +77,9 @@ def __get__(self, inst, type_=None):\n         return self._value\n \n \n-class InterfaceConstrainedProperty(object):\n-    """A property that may only contain values providing a certain interface.\n-    """\n+class InterfaceConstrainedProperty:\n+    """A property that may only contain values providing a certain interface."""\n+\n     uses = []\n \n     def __init__(self, name, interface):\n@@ -94,13 +88,10 @@ def __init__(self, name, interface):\n         self._interface = interface\n \n     def __set__(self, inst, value):\n-        if (\n-            value != inst.missing_value\n-            and not self._interface.providedBy(value)\n-        ):\n+        if value != inst.missing_value and not self._interface.providedBy(value):\n             raise ValueError(\n-                u"The property `{0}` may only contain objects "\n-                "providing `{1}`.".format(\n+                "The property `{}` may only contain objects "\n+                "providing `{}`.".format(\n                     self._name,\n                     self._interface.__identifier__,\n                 )\n@@ -110,27 +101,24 @@ def __set__(self, inst, value):\n \n @implementer(IPersistentField)\n class PersistentField(Persistent):\n-    """Base class for persistent field definitions.\n-    """\n+    """Base class for persistent field definitions."""\n+\n     # Persistent fields do not have an order\n-    order = StubbornProperty(\'order\', -1)\n+    order = StubbornProperty("order", -1)\n \n     # We don\'t allow setting a custom constraint, as this would introduce a\n     # dependency on a symbol such as a function that may go away\n-    constraint = DisallowedProperty(\'constraint\')\n+    constraint = DisallowedProperty("constraint")\n \n     # Details about which interface/field name we originally came form, if any\n     interfaceName = None\n     fieldName = None\n \n \n-class PersistentCollectionField(\n-    PersistentField,\n-    zope.schema._field.AbstractCollection\n-):\n-    """Ensure that value_type is a persistent field\n-    """\n-    value_type = InterfaceConstrainedProperty(\'value_type\', IPersistentField)\n+class PersistentCollectionField(PersistentField, zope.schema._field.AbstractCollection):\n+    """Ensure that value_type is a persistent field"""\n+\n+    value_type = InterfaceConstrainedProperty("value_type", IPersistentField)\n \n \n class Bytes(PersistentField, zope.schema.Bytes):\n@@ -194,9 +182,8 @@ class Password(PersistentField, zope.schema.Password):\n \n \n class Dict(PersistentField, zope.schema.Dict):\n-\n-    key_type = InterfaceConstrainedProperty(\'key_type\', IPersistentField)\n-    value_type = InterfaceConstrainedProperty(\'value_type\', IPersistentField)\n+    key_type = InterfaceConstrainedProperty("key_type", IPersistentField)\n+    value_type = InterfaceConstrainedProperty("value_type", IPersistentField)\n \n \n class Datetime(PersistentField, zope.schema.Datetime):\n@@ -233,8 +220,7 @@ class Choice(PersistentField, zope.schema.Choice):\n     _vocabulary = None\n \n     def __init__(self, values=None, vocabulary=None, source=None, **kw):\n-\n-        if vocabulary is not None and not isinstance(vocabulary, basestring):\n+        if vocabulary is not None and not isinstance(vocabulary, str):\n             values = self._normalized_values(vocabulary)\n             if values is None:\n                 raise ValueError(\n@@ -248,10 +234,12 @@ def __init__(self, values=None, vocabulary=None, source=None, **kw):\n                 "vocabularies or vocabularies based on simple value sets."\n             )\n \n-        assert not (values is None and vocabulary is None), (\n-            "You must specify either values or vocabulary.")\n-        assert values is None or vocabulary is None, (\n-            "You cannot specify both values and vocabulary.")\n+        assert not (\n+            values is None and vocabulary is None\n+        ), "You must specify either values or vocabulary."\n+        assert (\n+            values is None or vocabulary is None\n+        ), "You cannot specify both values and vocabulary."\n \n         self.vocabularyName = None\n \n@@ -270,8 +258,8 @@ def __init__(self, values=None, vocabulary=None, source=None, **kw):\n         self._init_field = False\n \n     def _normalized_values(self, vocabulary):\n-        if getattr(vocabulary, \'__iter__\', None):\n-            if all([isinstance(term.value, text_type) for term in vocabulary]):\n+        if getattr(vocabulary, "__iter__", None):\n+            if all([isinstance(term.value, str) for term in vocabulary]):\n                 return [term.value for term in vocabulary]\n         return None\n \n@@ -282,7 +270,8 @@ def vocabulary(self):\n             return self._vocabulary\n         if self._values is not None:\n             return SimpleVocabulary.fromValues(self._values)\n-    DisallowedProperty.uses.append(\'vocabulary\')\n+\n+    DisallowedProperty.uses.append("vocabulary")\n \n     # override bind to allow us to keep constraints on the \'vocabulary\'\n     # property\n@@ -300,7 +289,7 @@ def bind(self, object):\n \n \n if HASPLONESCHEMA:\n-    class JSONField(PersistentField, plone.schema.JSONField):\n \n+    class JSONField(PersistentField, plone.schema.JSONField):\n         key_type = InterfaceConstrainedProperty("key_type", IPersistentField)\n         value_type = InterfaceConstrainedProperty("value_type", IPersistentField)\ndiff --git a/plone/registry/fieldfactory.py b/plone/registry/fieldfactory.py\nindex 1d30861..73a238c 100644\n--- a/plone/registry/fieldfactory.py\n+++ b/plone/registry/fieldfactory.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.registry.field import DisallowedProperty\n from plone.registry.field import InterfaceConstrainedProperty\n from plone.registry.field import is_primitive\n@@ -18,8 +17,7 @@\n @implementer(IPersistentField)\n @adapter(IField)\n def persistentFieldAdapter(context):\n-    """Turn a non-persistent field into a persistent one\n-    """\n+    """Turn a non-persistent field into a persistent one"""\n \n     if IPersistentField.providedBy(context):\n         return context\n@@ -40,9 +38,7 @@ def persistentFieldAdapter(context):\n \n     instance = persistent_class.__new__(persistent_class)\n \n-    context_dict = dict(\n-        [(k, v) for k, v in context.__dict__.items() if k not in ignored]\n-    )\n+    context_dict = {k: v for k, v in context.__dict__.items() if k not in ignored}\n \n     for key, iface in constrained:\n         value = context_dict.get(key, None)\n@@ -51,8 +47,11 @@ def persistentFieldAdapter(context):\n         value = iface(value, None)\n         if value is None:\n             __traceback_info__ = (\n-                "The property `{0}` cannot be adapted to "\n-                "`{1}`.".format(key, iface.__identifier__,)\n+                "The property `{}` cannot be adapted to "\n+                "`{}`.".format(\n+                    key,\n+                    iface.__identifier__,\n+                )\n             )\n             return None\n         context_dict[key] = value\n@@ -64,14 +63,14 @@ def persistentFieldAdapter(context):\n @implementer(IPersistentField)\n @adapter(IChoice)\n def choicePersistentFieldAdapter(context):\n-    """Special handling for Choice fields.\n-    """\n+    """Special handling for Choice fields."""\n     instance = persistentFieldAdapter(context)\n     if instance is None:\n         return None\n \n-    if ISource.providedBy(context.vocabulary) or \\\n-            IContextSourceBinder.providedBy(context.vocabulary):\n+    if ISource.providedBy(context.vocabulary) or IContextSourceBinder.providedBy(\n+        context.vocabulary\n+    ):\n         safe = False\n \n         # Attempt to reverse engineer a \'values\' argument\ndiff --git a/plone/registry/fieldref.py b/plone/registry/fieldref.py\nindex a4ae488..4d291a4 100644\n--- a/plone/registry/fieldref.py\n+++ b/plone/registry/fieldref.py\n@@ -1,13 +1,11 @@\n-# -*- coding: utf-8 -*-\n from plone.registry.interfaces import IFieldRef\n from zope.interface import implementedBy\n from zope.interface import implementer\n \n \n @implementer(IFieldRef)\n-class FieldRef(object):\n-    """Default field reference.\n-    """\n+class FieldRef:\n+    """Default field reference."""\n \n     def __init__(self, name, originalField):\n         self.recordName = name\n@@ -15,7 +13,7 @@ def __init__(self, name, originalField):\n \n     @property\n     def __providedBy__(self):\n-        provided = getattr(self, \'__provides__\', None)\n+        provided = getattr(self, "__provides__", None)\n         if provided is None:\n             provided = implementedBy(self.__class__)\n \ndiff --git a/plone/registry/interfaces.py b/plone/registry/interfaces.py\nindex 743811d..a0a584e 100644\n--- a/plone/registry/interfaces.py\n+++ b/plone/registry/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope import schema\n from zope.interface import Interface\n from zope.interface.interfaces import IInterface\n@@ -7,8 +6,7 @@\n \n \n class InvalidRegistryKey(InvalidDottedName):\n-    """A registry key is a dotted name with up to one \'/\'.\n-    """\n+    """A registry key is a dotted name with up to one \'/\'."""\n \n \n class IPersistentField(IField):\n@@ -24,12 +22,11 @@ class IPersistentField(IField):\n     """\n \n     interfaceName = schema.DottedName(\n-        title=u\'Dotted name to an interface the field was constructed from\',\n-        required=False\n+        title="Dotted name to an interface the field was constructed from",\n+        required=False,\n     )\n     fieldName = schema.ASCIILine(\n-        title=u\'Name of the field in the original interface, if any\',\n-        required=False\n+        title="Name of the field in the original interface, if any", required=False\n     )\n \n \n@@ -43,12 +40,9 @@ class IFieldRef(Interface):\n     """\n \n     recordName = schema.DottedName(\n-        title=u\'Name of the record containing the reference field\'\n-    )\n-    originalField = schema.Object(\n-        title=u\'Referenced field\',\n-        schema=IField\n+        title="Name of the record containing the reference field"\n     )\n+    originalField = schema.Object(title="Referenced field", schema=IField)\n \n \n class IRecord(Interface):\n@@ -64,44 +58,39 @@ class IRecord(Interface):\n     """\n \n     field = schema.Object(\n-        title=u\'A field describing this record\',\n-        schema=IPersistentField\n+        title="A field describing this record", schema=IPersistentField\n     )\n \n     value = schema.Field(\n-        title=u\'The value of this record\',\n-        description=u\'Must be valid according to the record\\\'s field\'\n+        title="The value of this record",\n+        description="Must be valid according to the record\'s field",\n     )\n \n \n class IRecordEvent(Interface):\n-    """Base interface for record level events\n-    """\n+    """Base interface for record level events"""\n \n     record = schema.Object(\n-        title=u\'The record that was added.\',\n-        description=u\'Both __name__ and __parent__ will be set before the \'\n-                    u\'event is fired\',\n-        schema=IRecord\n+        title="The record that was added.",\n+        description="Both __name__ and __parent__ will be set before the "\n+        "event is fired",\n+        schema=IRecord,\n     )\n \n \n class IRecordAddedEvent(IRecordEvent):\n-    """Event fired when a record is added to a registry.\n-    """\n+    """Event fired when a record is added to a registry."""\n \n \n class IRecordRemovedEvent(IRecordEvent):\n-    """Event fired when a record is removed from a registry.\n-    """\n+    """Event fired when a record is removed from a registry."""\n \n \n class IRecordModifiedEvent(IRecordEvent):\n-    """Event fired when a record\'s value is modified.\n-    """\n+    """Event fired when a record\'s value is modified."""\n \n-    oldValue = schema.Field(title=u\'The record\\\'s previous value\')\n-    newValue = schema.Field(title=u\'The record\\\'s new value\')\n+    oldValue = schema.Field(title="The record\'s previous value")\n+    newValue = schema.Field(title="The record\'s new value")\n \n \n class IInterfaceAwareRecord(Interface):\n@@ -109,37 +98,34 @@ class IInterfaceAwareRecord(Interface):\n     interface its field came from.\n     """\n \n-    interfaceName = schema.DottedName(title=u"Dotted name to interface")\n+    interfaceName = schema.DottedName(title="Dotted name to interface")\n \n     interface = schema.Object(\n-        title=u\'Interface that provided the record\',\n-        description=u\'May be None if the interface is no longer available\',\n+        title="Interface that provided the record",\n+        description="May be None if the interface is no longer available",\n         schema=IInterface,\n-        readonly=True\n+        readonly=True,\n     )\n \n-    fieldName = schema.ASCIILine(\n-        title=u\'Name of the field in the original interface\'\n-    )\n+    fieldName = schema.ASCIILine(title="Name of the field in the original interface")\n \n \n class IRegistry(Interface):\n-    """The configuration registry\n-    """\n+    """The configuration registry"""\n \n     records = schema.Dict(\n-        title=u\'The records of the registry\',\n+        title="The records of the registry",\n         key_type=schema.DottedName(\n-            title=u\'Name of the record\',\n-            description=u\'By convention, this should include the \'\n-                        u\'package name and optionally an interface \'\n-                        u\'named, if the record can be described by a \'\n-                        u\'field in an interface (see also \'\n-                        u\'registerInterface() below), e.g. \'\n-                        u\'my.package.interfaces.IMySettings.somefield.\',\n+            title="Name of the record",\n+            description="By convention, this should include the "\n+            "package name and optionally an interface "\n+            "named, if the record can be described by a "\n+            "field in an interface (see also "\n+            "registerInterface() below), e.g. "\n+            "my.package.interfaces.IMySettings.somefield.",\n         ),\n         value_type=schema.Object(\n-            title=u\'The record for this name\',\n+            title="The record for this name",\n             schema=IRecord,\n         ),\n     )\n@@ -163,8 +149,7 @@ def __setitem__(key, value):\n         """\n \n     def __contains__(key):\n-        """Determine if the registry contains a record for the given key.\n-        """\n+        """Determine if the registry contains a record for the given key."""\n \n     def forInterface(interface, check=True, omit=(), prefix=None):\n         """Get an IRecordsProxy for the given interface. If `check` is True,\n@@ -190,20 +175,18 @@ class IRecordsProxy(Interface):\n     """\n \n     __schema__ = schema.Object(\n-        title=u\'Interface providing records\',\n-        schema=IInterface,\n-        readonly=True\n+        title="Interface providing records", schema=IInterface, readonly=True\n     )\n \n     __registry__ = schema.Object(\n-        title=u\'Registry where records will be looked up\',\n+        title="Registry where records will be looked up",\n         schema=IRegistry,\n-        readonly=True)\n+        readonly=True,\n+    )\n \n     __omitted__ = schema.Tuple(\n-        title=u\'Fields that are not stored in the registry\',\n-        description=u\'If any of these are accessed, you will get an \'\n-                    u\'AttributeError\',\n-        value_type=schema.ASCIILine(title=u\'Fieldname\'),\n-        readonly=True\n+        title="Fields that are not stored in the registry",\n+        description="If any of these are accessed, you will get an " "AttributeError",\n+        value_type=schema.ASCIILine(title="Fieldname"),\n+        readonly=True,\n     )\ndiff --git a/plone/registry/record.py b/plone/registry/record.py\nindex ca2575e..70a033a 100644\n--- a/plone/registry/record.py\n+++ b/plone/registry/record.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from persistent import Persistent\n from plone.registry.events import RecordModifiedEvent\n from plone.registry.interfaces import IInterfaceAwareRecord\n@@ -25,11 +24,10 @@ class Record(Persistent):\n     values may be loaded during automated migration.\n     """\n \n-    __name__ = u""\n+    __name__ = ""\n     __parent__ = None\n \n     def __init__(self, field, value=_marker, _validate=True):\n-\n         if _validate and not IPersistentField.providedBy(field):\n             raise ValueError("Field is not persistent")\n \n@@ -71,7 +69,6 @@ def _get_value(self):\n         return self._value\n \n     def _set_value(self, value):\n-\n         field = self.field\n \n         if field is None:\ndiff --git a/plone/registry/recordsproxy.py b/plone/registry/recordsproxy.py\nindex 47182f9..b1e9dba 100644\n--- a/plone/registry/recordsproxy.py\n+++ b/plone/registry/recordsproxy.py\n@@ -1,4 +1,4 @@\n-# -*- coding: utf-8 -*-\n+from collections.abc import MutableMapping\n from plone.registry.interfaces import IRecordsProxy\n from zope.interface import alsoProvides\n from zope.interface import implementer\n@@ -6,45 +6,33 @@\n from zope.schema.interfaces import RequiredMissing\n \n import re\n-import sys\n \n \n-try:\n-    from UserDict import UserDict\n-    from UserDict import DictMixin\n-except ImportError:\n-    from collections import UserDict\n-    from collections.abc import MutableMapping as DictMixin\n-\n-if sys.version_info >= (3,):\n-    basestring = str\n-\n _marker = object()\n \n \n @implementer(IRecordsProxy)\n-class RecordsProxy(object):\n-    """A proxy that maps an interface to a number of records\n-    """\n+class RecordsProxy:\n+    """A proxy that maps an interface to a number of records"""\n \n     def __init__(self, registry, schema, omitted=(), prefix=None):\n         if prefix is None:\n-            prefix = schema.__identifier__ + \'.\'\n+            prefix = schema.__identifier__ + "."\n         elif not prefix.endswith("."):\n-            prefix += \'.\'\n+            prefix += "."\n \n         # skip __setattr__\n-        self.__dict__[\'__schema__\'] = schema\n-        self.__dict__[\'__registry__\'] = registry\n-        self.__dict__[\'__omitted__\'] = omitted\n-        self.__dict__[\'__prefix__\'] = prefix\n-        self.__dict__[\'__parent__\'] = registry\n+        self.__dict__["__schema__"] = schema\n+        self.__dict__["__registry__"] = registry\n+        self.__dict__["__omitted__"] = omitted\n+        self.__dict__["__prefix__"] = prefix\n+        self.__dict__["__parent__"] = registry\n \n         alsoProvides(self, schema)\n \n     def __getattr__(self, name):\n         if not self.__dict__ or name in self.__dict__.keys():\n-           return super(RecordsProxy, self).__getattr__(name)\n+            return super().__getattr__(name)\n         if name not in self.__schema__:\n             raise AttributeError(name)\n         value = self.__registry__.get(self.__prefix__ + name, _marker)\n@@ -62,27 +50,26 @@ def __setattr__(self, name, value):\n             self.__dict__[name] = value\n \n     def __repr__(self):\n-        return "<{0} for {1}>".format(\n-            self.__class__.__name__,\n-            self.__schema__.__identifier__\n+        return "<{} for {}>".format(\n+            self.__class__.__name__, self.__schema__.__identifier__\n         )\n \n \n-class RecordsProxyCollection(DictMixin):\n-    """A proxy that maps a collection of RecordsProxy objects\n-    """\n+class RecordsProxyCollection(MutableMapping):\n+    """A proxy that maps a collection of RecordsProxy objects"""\n \n     _validkey = re.compile(r"([a-zA-Z][a-zA-Z0-9_.-]*)$").match\n \n     # ord(\'.\') == ord(\'/\') - 1\n \n-    def __init__(self, registry, schema, check=True, omitted=(), prefix=None,\n-                 factory=None):\n+    def __init__(\n+        self, registry, schema, check=True, omitted=(), prefix=None, factory=None\n+    ):\n         if prefix is None:\n             prefix = schema.__identifier__\n \n         if not prefix.endswith("/"):\n-            prefix += \'/\'\n+            prefix += "/"\n \n         self.registry = registry\n         self.schema = schema\n@@ -95,27 +82,23 @@ def __getitem__(self, key):\n         if key in iter(self):\n             prefix = self.prefix + key\n             proxy = self.registry.forInterface(\n-                self.schema,\n-                self.check,\n-                self.omitted,\n-                prefix,\n-                self.factory\n+                self.schema, self.check, self.omitted, prefix, self.factory\n             )\n             return proxy\n         raise KeyError(key)\n \n     def __iter__(self):\n         min = self.prefix\n-        max = self.prefix[:-1] + \'0\'\n+        max = self.prefix[:-1] + "0"\n         keys = self.registry.records.keys(min, max)\n         len_prefix = len(self.prefix)\n         last = None\n         for name in keys:\n             name = name[len_prefix:]\n-            if \'.\' not in name:\n+            if "." not in name:\n                 yield name\n             else:\n-                key = name.rsplit(\'.\', 1)[0]\n+                key = name.rsplit(".", 1)[0]\n                 if key != last:\n                     yield key\n                     last = key\n@@ -127,29 +110,24 @@ def keys(self):\n         return list(iter(self))\n \n     def _validate(self, key):\n-        if not isinstance(key, basestring) or not self._validkey(key):\n+        if not isinstance(key, str) or not self._validkey(key):\n             raise TypeError(\n-                \'expected a valid key (alphanumeric or underscore, starting \'\n-                \'with alpha)\'\n+                "expected a valid key (alphanumeric or underscore, starting "\n+                "with alpha)"\n             )\n         return str(key)\n \n     def has_key(self, key):\n         key = self._validate(key)\n         prefix = self.prefix + key\n-        names = self.registry.records.keys(prefix + \'.\', prefix + \'/\')\n+        names = self.registry.records.keys(prefix + ".", prefix + "/")\n         return bool(names)\n \n     def add(self, key):\n         key = self._validate(key)\n         prefix = self.prefix + key\n         self.registry.registerInterface(self.schema, self.omitted, prefix)\n-        proxy = self.registry.forInterface(\n-            self.schema,\n-            False,\n-            self.omitted,\n-            prefix\n-        )\n+        proxy = self.registry.forInterface(self.schema, False, self.omitted, prefix)\n         return proxy\n \n     def __setitem__(self, key, value):\n@@ -180,6 +158,6 @@ def __delitem__(self, key):\n         if key not in self:\n             raise KeyError(key)\n         prefix = self.prefix + key\n-        names = list(self.registry.records.keys(prefix + \'.\', prefix + \'/\'))\n+        names = list(self.registry.records.keys(prefix + ".", prefix + "/"))\n         for name in names:\n             del self.registry.records[name]\ndiff --git a/plone/registry/registry.py b/plone/registry/registry.py\nindex c14f5d1..d9cf553 100644\n--- a/plone/registry/registry.py\n+++ b/plone/registry/registry.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from BTrees.OOBTree import OOBTree\n from persistent import Persistent\n from plone.registry.events import RecordAddedEvent\n@@ -21,15 +20,10 @@\n import re\n import warnings\n \n-import sys\n-if sys.version_info >= (3,):\n-    basestring = str\n-\n \n @implementer(IRegistry)\n class Registry(Persistent):\n-    """The persistent registry\n-    """\n+    """The persistent registry"""\n \n     def __init__(self):\n         self._records = _Records(self)\n@@ -64,23 +58,19 @@ def records(self):\n \n     # Schema interface API\n \n-    def forInterface(self, interface, check=True, omit=(), prefix=None,\n-                     factory=None):\n+    def forInterface(self, interface, check=True, omit=(), prefix=None, factory=None):\n         if prefix is None:\n             prefix = interface.__identifier__\n \n         if not prefix.endswith("."):\n-            prefix += \'.\'\n+            prefix += "."\n \n         if check:\n             for name in getFieldNames(interface):\n                 if name not in omit and prefix + name not in self:\n                     raise KeyError(\n-                        "Interface `{0}` defines a field `{1}`, for which "\n-                        "there is no record.".format(\n-                            interface.__identifier__,\n-                            name\n-                        )\n+                        "Interface `{}` defines a field `{}`, for which "\n+                        "there is no record.".format(interface.__identifier__, name)\n                     )\n \n         if factory is None:\n@@ -93,7 +83,7 @@ def registerInterface(self, interface, omit=(), prefix=None):\n             prefix = interface.__identifier__\n \n         if not prefix.endswith("."):\n-            prefix += \'.\'\n+            prefix += "."\n \n         for name, field in getFieldsInOrder(interface):\n             if name in omit or field.readonly:\n@@ -103,10 +93,7 @@ def registerInterface(self, interface, omit=(), prefix=None):\n             if persistent_field is None:\n                 raise TypeError(\n                     "There is no persistent field equivalent for the field "\n-                    "`{0}` of type `{1}`.".format(\n-                        name,\n-                        field.__class__.__name__\n-                    )\n+                    "`{}` of type `{}`.".format(name, field.__class__.__name__)\n                 )\n \n             persistent_field.interfaceName = interface.__identifier__\n@@ -114,32 +101,22 @@ def registerInterface(self, interface, omit=(), prefix=None):\n \n             value = persistent_field.default\n \n-            # Attempt to retain the exisiting value\n+            # Attempt to retain the existing value\n             if record_name in self.records:\n                 existing_record = self.records[record_name]\n                 value = existing_record.value\n                 bound_field = persistent_field.bind(existing_record)\n                 try:\n                     bound_field.validate(value)\n-                except:\n+                except Exception:\n                     value = persistent_field.default\n \n-            self.records[record_name] = Record(\n-                persistent_field,\n-                value,\n-                _validate=False\n-            )\n-\n-    def collectionOfInterface(self, interface, check=True, omit=(),\n-                              prefix=None, factory=None):\n-        return RecordsProxyCollection(\n-            self,\n-            interface,\n-            check,\n-            omit,\n-            prefix,\n-            factory\n-        )\n+            self.records[record_name] = Record(persistent_field, value, _validate=False)\n+\n+    def collectionOfInterface(\n+        self, interface, check=True, omit=(), prefix=None, factory=None\n+    ):\n+        return RecordsProxyCollection(self, interface, check, omit, prefix, factory)\n \n     # BBB\n \n@@ -149,25 +126,23 @@ def _migrateRecords(self):\n         """\n         records = _Records(self)\n \n-        oldData = getattr(self._records, \'data\', None)\n+        oldData = getattr(self._records, "data", None)\n         if oldData is not None:\n             for name, oldRecord in oldData.iteritems():\n                 oldRecord._p_activate()\n-                if (\n-                    \'field\' in oldRecord.__dict__\n-                    and \'value\' in oldRecord.__dict__\n-                ):\n-                    records._fields[name] = oldRecord.__dict__[\'field\']\n-                    records._values[name] = oldRecord.__dict__[\'value\']\n+                if "field" in oldRecord.__dict__ and "value" in oldRecord.__dict__:\n+                    records._fields[name] = oldRecord.__dict__["field"]\n+                    records._values[name] = oldRecord.__dict__["value"]\n \n         self._records = records\n \n \n-class _Records(object):\n+class _Records:\n     """The records stored in the registry. This implements dict-like access\n     to records, where as the Registry object implements dict-like read-only\n     access to values.\n     """\n+\n     __parent__ = None\n \n     # Similar to zope.schema._field._isdotted, but allows up to one \'/\'\n@@ -209,7 +184,6 @@ def __delitem__(self, name):\n         notify(RecordRemovedEvent(record))\n \n     def __getitem__(self, name):\n-\n         field = self._getField(name)\n         value = self._values[name]\n \n@@ -253,7 +227,7 @@ def values(self, min=None, max=None):\n         return [self[name] for name in self.keys(min, max)]\n \n     def items(self, min=None, max=None):\n-        return [(name, self[name],) for name in self.keys(min, max)]\n+        return [(name, self[name]) for name in self.keys(min, max)]\n \n     def setdefault(self, key, value):\n         if key not in self:\n@@ -270,9 +244,9 @@ def _getField(self, name):\n         field = self._fields[name]\n \n         # Handle field reference pointers\n-        if isinstance(field, basestring):\n+        if isinstance(field, str):\n             recordName = field\n-            while isinstance(field, basestring):\n+            while isinstance(field, str):\n                 recordName = field\n                 field = self._fields[recordName]\n             field = FieldRef(recordName, field)\n@@ -284,12 +258,10 @@ def _setField(self, name, field):\n             raise ValueError("The record\'s field must be an IPersistentField.")\n         if IFieldRef.providedBy(field):\n             if field.recordName not in self._fields:\n-                raise ValueError(\n-                    "Field reference points to non-existent record"\n-                )\n+                raise ValueError("Field reference points to non-existent record")\n             self._fields[name] = field.recordName  # a pointer, of sorts\n         else:\n-            field.__name__ = \'value\'\n+            field.__name__ = "value"\n             self._fields[name] = field\n \n \n@@ -302,8 +274,7 @@ class Records(_Records, Persistent):\n \n     def __init__(self, parent):\n         warnings.warn(\n-            "The Records persistent class is deprecated and should not be "\n-            "used.",\n-            DeprecationWarning\n+            "The Records persistent class is deprecated and should not be " "used.",\n+            DeprecationWarning,\n         )\n-        super(Records, self).__init__(parent)\n+        super().__init__(parent)\ndiff --git a/plone/registry/registry.rst b/plone/registry/registry.rst\nindex 5952d69..f00fb5c 100644\n--- a/plone/registry/registry.rst\n+++ b/plone/registry/registry.rst\n@@ -74,12 +74,7 @@ We can set a different value, either in the ``Record`` constructor or via the ``\n \n Note that the value is validated against the field::\n \n-    >>> age_record.value = -1  # doctest: +SKIP_PYTHON_3\n-    Traceback (most recent call last):\n-    ...\n-    TooSmall: (-1, 0)\n-\n-    >>> age_record.value = -1  # doctest: +SKIP_PYTHON_2\n+    >>> age_record.value = -1\n     Traceback (most recent call last):\n     ...\n     zope.schema._bootstrapinterfaces.TooSmall: (-1, 0)\n@@ -138,12 +133,7 @@ you can access its value through dict-like operations on the registry itself::\n \n Again, values are validated::\n \n-    >>> registry[\'plone.registry.tests.cms\'] = b\'Joomla\'  # doctest: +SKIP_PYTHON_3\n-    Traceback (most recent call last):\n-    ...\n-    WrongType: (\'Joomla\', <type \'unicode\'>...)\n-\n-    >>> registry[\'plone.registry.tests.cms\'] = b\'Joomla\'  # doctest: +SKIP_PYTHON_2\n+    >>> registry[\'plone.registry.tests.cms\'] = b\'Joomla\'\n     Traceback (most recent call last):\n     ...\n     zope.schema._bootstrapinterfaces.WrongType: (b\'Joomla\', <class \'str\'>, \'value\')\n@@ -488,20 +478,15 @@ The two values are separate::\n \n Validation uses the underlying field::\n \n-    >>> registry[\'plone.registry.tests.timeout.override\'] = -1  # doctest: +SKIP_PYTHON_3\n-    Traceback (most recent call last):\n-    ...\n-    TooSmall: (-1, 0)\n-\n-    >>> registry[\'plone.registry.tests.timeout.override\'] = -1  # doctest: +SKIP_PYTHON_2\n+    >>> registry[\'plone.registry.tests.timeout.override\'] = -1\n     Traceback (most recent call last):\n     ...\n     zope.schema._bootstrapinterfaces.TooSmall: (-1, 0)\n \n The reference field exposes the standard field properties, e.g.::\n \n-    >>> timeout_override_record.field.title  # doctest: +SKIP_PYTHON_3\n-    u\'Timeout\'\n+    >>> timeout_override_record.field.title\n+    \'Timeout\'\n     >>> timeout_override_record.field.min\n     0\n \ndiff --git a/plone/registry/tests.py b/plone/registry/tests.py\nindex d89ab62..19cfc3a 100644\n--- a/plone/registry/tests.py\n+++ b/plone/registry/tests.py\n@@ -1,74 +1,50 @@\n-# -*- coding: utf-8 -*-\n from plone.registry.fieldfactory import choicePersistentFieldAdapter\n from plone.registry.fieldfactory import persistentFieldAdapter\n+from zope import schema\n from zope.component import eventtesting\n from zope.component import provideAdapter\n from zope.component import testing\n-from zope import schema\n from zope.interface import Interface\n \n import doctest\n import re\n-import sys\n import unittest\n \n \n-SKIP_PYTHON_2 = doctest.register_optionflag(\'SKIP_PYTHON_2\')\n-SKIP_PYTHON_3 = doctest.register_optionflag(\'SKIP_PYTHON_3\')\n-IGNORE_B = doctest.register_optionflag(\'IGNORE_B\')\n-IGNORE_U = doctest.register_optionflag(\'IGNORE_U\')\n+IGNORE_U = doctest.register_optionflag("IGNORE_U")\n \n \n class PolyglotOutputChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n         # fix changed objectfield class in zope4\n         got = re.sub(\n-            \'zope.schema._field.Object\',\n-            \'zope.schema._bootstrapfields.Object\', got)\n+            "zope.schema._field.Object", "zope.schema._bootstrapfields.Object", got\n+        )\n \n-        if optionflags & SKIP_PYTHON_3 and sys.version_info >= (3,):\n-            return True\n-        elif optionflags & SKIP_PYTHON_2:\n-            return True\n-\n-        if hasattr(self, \'_toAscii\'):\n+        if hasattr(self, "_toAscii"):\n             got = self._toAscii(got)\n             want = self._toAscii(want)\n \n-        # Naive fix for comparing byte strings\n-        if got != want and optionflags & IGNORE_B:\n-            got = re.sub(r\'^b([\\\'"])\', r\'\\1\', got)\n-            want = re.sub(r\'^b([\\\'"])\', r\'\\1\', want)\n-\n         # Naive fix for comparing byte strings\n         if got != want and optionflags & IGNORE_U:\n-            got = re.sub(r\'^u([\\\'"])\', r\'\\1\', got)\n-            want = re.sub(r\'^u([\\\'"])\', r\'\\1\', want)\n+            got = re.sub(r\'^u([\\\'"])\', r"\\1", got)\n+            want = re.sub(r\'^u([\\\'"])\', r"\\1", want)\n \n-        return doctest.OutputChecker.check_output(\n-            self, want, got, optionflags)\n+        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \n class IMailSettings(Interface):\n-    """Settings for email\n-    """\n+    """Settings for email"""\n \n-    sender = schema.TextLine(title=u"Mail sender", default=u"root@localhost")\n-    smtp_host = schema.URI(title=u"SMTP host server")\n+    sender = schema.TextLine(title="Mail sender", default="root@localhost")\n+    smtp_host = schema.URI(title="SMTP host server")\n \n \n class IMailPreferences(Interface):\n-    """Settings for email\n-    """\n-    max_daily = schema.Int(\n-        title=u"Maximum number of emails per day",\n-        min=0,\n-        default=3\n-    )\n-    settings = schema.Object(\n-        title=u"Mail setings to use",\n-        schema=IMailSettings\n-    )\n+    """Settings for email"""\n+\n+    max_daily = schema.Int(title="Maximum number of emails per day", min=0, default=3)\n+    settings = schema.Object(title="Mail settings to use", schema=IMailSettings)\n \n \n def setUp(test=None):\n@@ -80,8 +56,7 @@ def setUp(test=None):\n \n \n class TestBugs(unittest.TestCase):\n-    """Regression tests for bugs that have been fixed\n-    """\n+    """Regression tests for bugs that have been fixed"""\n \n     def setUp(self):\n         setUp(self)\n@@ -91,20 +66,19 @@ def tearDown(self):\n \n     def test_bind_choice(self):\n         from plone.registry.field import Choice\n-\n         from zope.schema.vocabulary import getVocabularyRegistry\n         from zope.schema.vocabulary import SimpleVocabulary\n \n         def vocabFactory(obj):\n-            return SimpleVocabulary.fromValues([\'one\', \'two\'])\n+            return SimpleVocabulary.fromValues(["one", "two"])\n \n         reg = getVocabularyRegistry()\n-        reg.register(\'my.vocab\', vocabFactory)\n+        reg.register("my.vocab", vocabFactory)\n \n-        class T(object):\n+        class T:\n             f = None\n \n-        f = Choice(__name__=\'f\', title=u"Test", vocabulary="my.vocab")\n+        f = Choice(__name__="f", title="Test", vocabulary="my.vocab")\n         t = T()\n \n         # Bug: this would give "AttributeError: can\'t set attribute" on\n@@ -112,19 +86,19 @@ class T(object):\n         f.bind(t)\n \n     def test_fieldref_interfaces(self):\n-        from plone.registry import field, FieldRef\n+        from plone.registry import field\n+        from plone.registry import FieldRef\n         from plone.registry.interfaces import IFieldRef\n         from zope.schema.interfaces import ICollection\n \n         listField = field.List(value_type=field.ASCIILine())\n-        ref = FieldRef(\'some.record\', listField)\n+        ref = FieldRef("some.record", listField)\n \n         self.assertTrue(ICollection.providedBy(ref))\n         self.assertTrue(IFieldRef.providedBy(ref))\n \n \n class TestMigration(unittest.TestCase):\n-\n     def setUp(self):\n         setUp(self)\n \n@@ -132,12 +106,12 @@ def tearDown(self):\n         testing.tearDown(self)\n \n     def test_auto_migration(self):\n-\n         from BTrees.OOBTree import OOBTree\n-\n-        from plone.registry.registry import Registry, Records, _Records\n-        from plone.registry.record import Record\n         from plone.registry import field\n+        from plone.registry.record import Record\n+        from plone.registry.registry import _Records\n+        from plone.registry.registry import Records\n+        from plone.registry.registry import Registry\n \n         # Create an "old-looking registry"\n \n@@ -145,54 +119,56 @@ def test_auto_migration(self):\n         registry._records = Records(registry)\n         registry._records.data = OOBTree()\n \n-        f = field.TextLine(title=u"Foo")\n+        f = field.TextLine(title="Foo")\n \n-        record = Record(f, u"Bar")\n-        record.__dict__[\'field\'] = f\n-        record.__dict__[\'value\'] = u"Bar"\n+        record = Record(f, "Bar")\n+        record.__dict__["field"] = f\n+        record.__dict__["value"] = "Bar"\n \n-        registry._records.data[\'foo.bar\'] = record\n+        registry._records.data["foo.bar"] = record\n \n         # Attempt to access it\n \n-        value = registry[\'foo.bar\']\n+        value = registry["foo.bar"]\n \n         # Migration should have happened\n \n-        self.assertEqual(value, u"Bar")\n-        self.assertEqual(registry.records[\'foo.bar\'].field.title, u"Foo")\n-        self.assertEqual(registry.records[\'foo.bar\'].value, u"Bar")\n+        self.assertEqual(value, "Bar")\n+        self.assertEqual(registry.records["foo.bar"].field.title, "Foo")\n+        self.assertEqual(registry.records["foo.bar"].value, "Bar")\n \n         self.assertFalse(isinstance(registry._records, Records))\n         self.assertTrue(isinstance(registry._records, _Records))\n \n \n def test_suite():\n-    return unittest.TestSuite([\n-        doctest.DocFileSuite(\n-            \'registry.rst\',\n-            package=\'plone.registry\',\n-            optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,\n-            setUp=setUp,\n-            tearDown=testing.tearDown,\n-            checker=PolyglotOutputChecker()\n-        ),\n-        doctest.DocFileSuite(\n-            \'events.rst\',\n-            package=\'plone.registry\',\n-            optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,\n-            setUp=setUp,\n-            tearDown=testing.tearDown,\n-            checker=PolyglotOutputChecker()\n-        ),\n-        doctest.DocFileSuite(\n-            \'field.rst\',\n-            package=\'plone.registry\',\n-            optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,\n-            setUp=setUp,\n-            tearDown=testing.tearDown,\n-            checker=PolyglotOutputChecker()\n-        ),\n-        unittest.makeSuite(TestBugs),\n-        unittest.makeSuite(TestMigration),\n-    ])\n+    return unittest.TestSuite(\n+        [\n+            doctest.DocFileSuite(\n+                "registry.rst",\n+                package="plone.registry",\n+                optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,\n+                setUp=setUp,\n+                tearDown=testing.tearDown,\n+                checker=PolyglotOutputChecker(),\n+            ),\n+            doctest.DocFileSuite(\n+                "events.rst",\n+                package="plone.registry",\n+                optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,\n+                setUp=setUp,\n+                tearDown=testing.tearDown,\n+                checker=PolyglotOutputChecker(),\n+            ),\n+            doctest.DocFileSuite(\n+                "field.rst",\n+                package="plone.registry",\n+                optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,\n+                setUp=setUp,\n+                tearDown=testing.tearDown,\n+                checker=PolyglotOutputChecker(),\n+            ),\n+            unittest.defaultTestLoader.loadTestsFromTestCase(TestBugs),\n+            unittest.defaultTestLoader.loadTestsFromTestCase(TestMigration),\n+        ]\n+    )\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..547e351 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,66 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "internal"\n+name = "Internal:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "documentation"\n+name = "Documentation:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "tests"\n+name = "Tests"\n+showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\n+\n+\n+[tool.dependencychecker]\n+Zope = [\n+  # Zope own provided namespaces\n+  \'App\', \'OFS\', \'Products.Five\', \'Products.OFSP\', \'Products.PageTemplates\',\n+  \'Products.SiteAccess\', \'Shared\', \'Testing\', \'ZPublisher\', \'ZTUtils\',\n+  \'Zope2\', \'webdav\', \'zmi\',\n+  # ExtensionClass own provided namespaces\n+  \'ExtensionClass\', \'ComputedAttribute\', \'MethodObject\',\n+  # Zope dependencies\n+  \'AccessControl\', \'Acquisition\', \'AuthEncoding\', \'beautifulsoup4\', \'BTrees\',\n+  \'cffi\', \'Chameleon\', \'DateTime\', \'DocumentTemplate\',\n+  \'MultiMapping\', \'multipart\', \'PasteDeploy\', \'Persistence\', \'persistent\',\n+  \'pycparser\', \'python-gettext\', \'pytz\', \'RestrictedPython\', \'roman\',\n+  \'soupsieve\', \'transaction\', \'waitress\', \'WebOb\', \'WebTest\', \'WSGIProxy2\',\n+  \'z3c.pt\', \'zc.lockfile\', \'ZConfig\', \'zExceptions\', \'ZODB\', \'zodbpickle\',\n+  \'zope.annotation\', \'zope.browser\', \'zope.browsermenu\', \'zope.browserpage\',\n+  \'zope.browserresource\', \'zope.cachedescriptors\', \'zope.component\',\n+  \'zope.configuration\', \'zope.container\', \'zope.contentprovider\',\n+  \'zope.contenttype\', \'zope.datetime\', \'zope.deferredimport\',\n+  \'zope.deprecation\', \'zope.dottedname\', \'zope.event\', \'zope.exceptions\',\n+  \'zope.filerepresentation\', \'zope.globalrequest\', \'zope.hookable\',\n+  \'zope.i18n\', \'zope.i18nmessageid\', \'zope.interface\', \'zope.lifecycleevent\',\n+  \'zope.location\', \'zope.pagetemplate\', \'zope.processlifetime\', \'zope.proxy\',\n+  \'zope.ptresource\', \'zope.publisher\', \'zope.schema\', \'zope.security\',\n+  \'zope.sequencesort\', \'zope.site\', \'zope.size\', \'zope.structuredtext\',\n+  \'zope.tal\', \'zope.tales\', \'zope.testbrowser\', \'zope.testing\',\n+  \'zope.traversing\', \'zope.viewlet\'\n+]\n+\'Products.CMFCore\' = [\n+  \'docutils\', \'five.localsitemanager\', \'Missing\', \'Products.BTreeFolder2\',\n+  \'Products.GenericSetup\', \'Products.MailHost\', \'Products.PythonScripts\',\n+  \'Products.StandardCacheManagers\', \'Products.ZCatalog\', \'Record\',\n+  \'zope.sendmail\', \'Zope\'\n+]\n+\'plone.base\' = [\n+  \'plone.batching\', \'plone.registry\', \'plone.schema\',\'plone.z3cform\',\n+  \'Products.CMFCore\', \'Products.CMFDynamicViewFTI\',\n+]\n+python-dateutil = [\'dateutil\']\n+ignore-packages = [\'plone.schema\']\ndiff --git a/setup.cfg b/setup.cfg\nindex e78a412..73dc257 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,13 +1,25 @@\n-[zopeskel]\n-template = plone\n-\n-[isort]\n-force_alphabetical_sort = True\n-force_single_line = True\n-lines_after_imports = 2\n-line_length = 200\n-not_skip = __init__.py\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[bdist_wheel]\n+universal = 0\n \n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n+per-file-ignores =\n+    plone/registry/__init__.py:F401\n \n-[bdist_wheel]\n-universal = 1\n+[check-manifest]\n+ignore =\n+    .editorconfig\n+    .meta.toml\n+    .pre-commit-config.yaml\n+    tox.ini\ndiff --git a/setup.py b/setup.py\nindex 0f1cd4c..808559b 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n@@ -8,63 +7,61 @@\n def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n-version = \'1.2.2.dev0\'\n+\n+version = "2.0.0.dev0"\n \n description = "Registry for application settings (like debconf/ about:config)"\n long_description = (\n-    read(\'README.rst\') +\n-    \'\\n\' +\n-    read(\'plone\', \'registry\', \'registry.rst\') +\n-    \'\\n\' +\n-    read(\'plone\', \'registry\', \'events.rst\') +\n-    \'\\n\' +\n-    read(\'plone\', \'registry\', \'field.rst\') +\n-    \'\\n\' +\n-    read(\'CHANGES.rst\') +\n-    \'\\n\'\n+    read("README.rst")\n+    + "\\n"\n+    + read("plone", "registry", "registry.rst")\n+    + "\\n"\n+    + read("plone", "registry", "events.rst")\n+    + "\\n"\n+    + read("plone", "registry", "field.rst")\n+    + "\\n"\n+    + read("CHANGES.rst")\n+    + "\\n"\n )\n \n setup(\n-    name=\'plone.registry\',\n+    name="plone.registry",\n     version=version,\n     description=description,\n     long_description=long_description,\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Framework :: Plone",\n-        "Framework :: Plone :: 5.1",\n-        "Framework :: Plone :: 5.2",\n+        "Framework :: Plone :: 6.0",\n         "Framework :: Plone :: Core",\n         "License :: OSI Approved :: GNU General Public License (GPL)",\n-        "Programming Language :: Python :: 2",\n-        "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python",\n         "Programming Language :: Python :: 3",\n-        "Programming Language :: Python :: 3.5",\n-        "Programming Language :: Python :: 3.6",\n-        "Programming Language :: Python :: 3.7",\n         "Programming Language :: Python :: 3.8",\n+        "Programming Language :: Python :: 3.9",\n+        "Programming Language :: Python :: 3.10",\n+        "Programming Language :: Python :: 3.11",\n         "Topic :: Software Development :: Libraries :: Python Modules",\n     ],\n-    keywords=\'configuration registry\',\n-    author=\'Martin Aspeli, Wichert Akkerman, Hanno Schlichting\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://pypi.org/project/plone.registry\',\n-    license=\'GPL\',\n+    keywords="configuration registry",\n+    author="Martin Aspeli, Wichert Akkerman, Hanno Schlichting",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://pypi.org/project/plone.registry",\n+    license="GPL",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n+    python_requires=">=3.8",\n     install_requires=[\n-        \'setuptools\',\n-        \'zope.component\',\n-        \'zope.dottedname\',\n-        \'zope.event\',\n-        \'zope.interface\',\n-        \'zope.schema\',\n+        "setuptools",\n+        "zope.component",\n+        "zope.dottedname",\n+        "zope.event",\n+        "zope.interface",\n+        "zope.schema",\n     ],\n-    extras_require={\n-        \'test\': [\'BTrees\', \'plone.schema\']\n-    },\n+    extras_require={"test": ["BTrees", "plone.schema"]},\n     entry_points="""\n     # -*- Entry points: -*-\n     """,\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..e6193f7\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,76 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[tox]\n+# We need 4.4.0 for constrain_package_deps.\n+min_version = 4.4.0\n+envlist =\n+    format\n+    lint\n+    test\n+\n+[testenv]\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat code\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a pyupgrade\n+    pre-commit run -a isort\n+    pre-commit run -a black\n+    pre-commit run -a zpretty\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a\n+\n+[testenv:dependencies]\n+description = check if the package defines all its dependencies\n+skip_install = true\n+deps =\n+    build\n+    z3c.dependencychecker==2.11\n+commands =\n+    python -m build --sdist --no-isolation\n+    dependencychecker\n+\n+[testenv:dependencies-graph]\n+description = generate a graph out of the package\'s dependencies\n+deps =\n+    pipdeptree==2.5.1\n+    graphviz  # optional dependency of pipdeptree\n+commands =\n+    sh -c \'pipdeptree --exclude setuptools,wheel,pipdeptree,zope.interface,zope.component --graph-output svg > dependencies.svg\'\n+\n+[testenv:test]\n+use_develop = true\n+constrain_package_deps = true\n+set_env = ROBOT_BROWSER=headlesschrome\n+deps =\n+    zope.testrunner\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    zope-testrunner --all --test-path={toxinidir} -s plone.registry {posargs}\n+extras =\n+    test\n+\n+[testenv:coverage]\n+use_develop = true\n+constrain_package_deps = true\n+set_env = ROBOT_BROWSER=headlesschrome\n+deps =\n+    coverage\n+    zope.testrunner\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    coverage run {envbindir}/zope-testrunner --all --test-path={toxinidir} -s plone.registry {posargs}\n+    coverage report -m --format markdown\n+extras =\n+    test\n'

