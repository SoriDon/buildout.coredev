Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2023-03-10T12:23:02+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/f590351777681759422858807ea58675054f22d2

Fixed test layer setup.

Created content was bleeding into layers from other packages.
See some notes in https://github.com/plone/buildout.coredev/pull/846

On my original PR for linkintegrity where I removed compatibility with Plone 5.2, Archetypes and Python 2, all was well.
After merge, the core jobs failed.
Difference: the PR jobs are run in parallel threads, and that made it pass.

You can see this locally (without the fixes in the current PR) in the coredev buildout:

- `bin/test -j4` passes
- `bin/test` fails

Files changed:
A news/846.bugfix
A plone/app/linkintegrity/tests/utils.py
M plone/app/linkintegrity/testing.py
M plone/app/linkintegrity/tests/test_circular.py
M plone/app/linkintegrity/tests/test_functional.py
M plone/app/linkintegrity/tests/test_handlers.py
M plone/app/linkintegrity/tests/test_imagescales.py
M plone/app/linkintegrity/tests/test_references.py
D plone/app/linkintegrity/tests/base.py

b'diff --git a/news/846.bugfix b/news/846.bugfix\nnew file mode 100644\nindex 0000000..53023f2\n--- /dev/null\n+++ b/news/846.bugfix\n@@ -0,0 +1,3 @@\n+Fixed test layer setup.\n+Created content was bleeding into layers from other packages.\n+[maurits]\ndiff --git a/plone/app/linkintegrity/testing.py b/plone/app/linkintegrity/testing.py\nindex 90b031f..1239036 100644\n--- a/plone/app/linkintegrity/testing.py\n+++ b/plone/app/linkintegrity/testing.py\n@@ -1,14 +1,13 @@\n from base64 import decodebytes\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FIXTURE\n from plone.app.testing import layers\n from plone.app.testing import login\n-from plone.app.testing import ploneSite\n+from plone.app.testing import PLONE_FIXTURE\n+from plone.app.testing import PloneSandboxLayer\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n from plone.app.testing import TEST_USER_PASSWORD\n from plone.namedfile.file import NamedImage\n-from plone.testing import zope\n from Products.CMFCore.utils import getToolByName\n from zope.configuration import xmlconfig\n \n@@ -32,59 +31,47 @@ def create(container, type_name, **kwargs):\n     return content\n \n \n-class LinkIntegrityLayer(zope.Layer):\n+class LinkIntegrityLayer(PloneSandboxLayer):\n     """Base Layer for Dexterity testing.\n     """\n \n-    # defaultBases = (PLONE_FIXTURE, )\n-    defaultBases = (\n-        PLONE_APP_CONTENTTYPES_FIXTURE,\n-    )\n+    defaultBases = (PLONE_FIXTURE, )\n \n-    def setUp(self):\n-        self.setUpContent()\n-\n-    def setUpMembers(self, portal):\n-        pm = getToolByName(portal, \'portal_membership\')\n-        pm.addMember(\'editor\', TEST_USER_PASSWORD, [\'Editor\'], [])\n-        pm.addMember(\'member\', TEST_USER_PASSWORD, [\'Member\'], [])\n-        pm.addMember(\'authenticated\', TEST_USER_PASSWORD, [], [])\n-\n-    def setUpContent(self):\n+    def setUpZope(self, app, configurationContext):\n         import plone.app.linkintegrity\n \n         xmlconfig.file(\'configure.zcml\', plone.app.linkintegrity,\n-                       context=self[\'configurationContext\'])\n+                       context=configurationContext)\n \n-        with ploneSite() as portal:\n-            setRoles(portal, TEST_USER_ID, [\'Manager\', ])\n-            login(portal, TEST_USER_NAME)\n+    def setUpPloneSite(self, portal):\n+        setRoles(portal, TEST_USER_ID, [\'Manager\', ])\n+        login(portal, TEST_USER_NAME)\n \n-            # Create sample documents\n-            type_data = dict(type_name=\'Document\')\n-            for i in range(1, 4):\n-                type_data[\'id\'] = \'doc{0:d}\'.format(i)\n-                type_data[\'title\'] = \'Test Page {0:d}\'.format(i)\n-                create(portal, **type_data)\n+        # Create sample documents\n+        type_data = dict(type_name=\'Document\')\n+        for i in range(1, 4):\n+            type_data[\'id\'] = \'doc{0:d}\'.format(i)\n+            type_data[\'title\'] = \'Test Page {0:d}\'.format(i)\n+            create(portal, **type_data)\n \n-            create(portal, \'File\', id=\'file1\', title=\'File 1\', file=GIF)\n-            create(portal, \'Folder\', id=\'folder1\', title=\'Folder 1\')\n-            subfolder = portal[\'folder1\']\n-            create(subfolder, \'Document\', id=\'doc4\', title=\'Test Page 4\')\n+        create(portal, \'File\', id=\'file1\', title=\'File 1\', file=GIF)\n+        create(portal, \'Folder\', id=\'folder1\', title=\'Folder 1\')\n+        subfolder = portal[\'folder1\']\n+        create(subfolder, \'Document\', id=\'doc4\', title=\'Test Page 4\')\n \n-            self.setUpMembers(portal)\n-\n-            # Create an object that does not provide the behavior to live along\n-            create(portal, \'News Item\', id=\'news1\', title=\'News 1\')\n+        # setup members\n+        pm = getToolByName(portal, \'portal_membership\')\n+        pm.addMember(\'editor\', TEST_USER_PASSWORD, [\'Editor\'], [])\n+        pm.addMember(\'member\', TEST_USER_PASSWORD, [\'Member\'], [])\n+        pm.addMember(\'authenticated\', TEST_USER_PASSWORD, [], [])\n \n-            # create a DX NamedImage\n-            portal.invokeFactory(\'Image\', \'image1\')\n-            portal[\'image1\'].image = NamedImage(GIF, \'image/gif\',\n-                                                u\'sample.gif\')\n+        # Create an object that does not provide the behavior to live along\n+        create(portal, \'News Item\', id=\'news1\', title=\'News 1\')\n \n-    def tearDown(self):\n-        with zope.zopeApp() as app:\n-            zope.uninstallProduct(app, \'plone.app.linkintegrity\')\n+        # create a NamedImage\n+        portal.invokeFactory(\'Image\', \'image1\')\n+        portal[\'image1\'].image = NamedImage(GIF, \'image/gif\',\n+                                            u\'sample.gif\')\n \n \n PLONE_APP_LINKINTEGRITY_FIXTURE = LinkIntegrityLayer()\ndiff --git a/plone/app/linkintegrity/tests/base.py b/plone/app/linkintegrity/tests/base.py\ndeleted file mode 100644\nindex 621d9a3..0000000\n--- a/plone/app/linkintegrity/tests/base.py\n+++ /dev/null\n@@ -1,59 +0,0 @@\n-from plone.app.linkintegrity import testing\n-from plone.app.relationfield.behavior import IRelatedItems\n-from plone.app.testing import setRoles\n-from plone.app.testing import TEST_USER_ID\n-from plone.app.testing import TEST_USER_NAME\n-from plone.app.testing import TEST_USER_PASSWORD\n-from plone.app.textfield import RichTextValue\n-from plone.testing.zope import Browser\n-from z3c.form.interfaces import IFormLayer\n-from zope.component import getMultiAdapter\n-from zope.interface import alsoProvides\n-from zope.lifecycleevent import modified\n-\n-import unittest\n-\n-\n-class BaseTestCase(unittest.TestCase):\n-    """Base testcase for testing Dexterity content types"""\n-\n-    layer = testing.PLONE_APP_LINKINTEGRITY_FUNCTIONAL_TESTING\n-\n-    def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        alsoProvides(self.request, IFormLayer)\n-\n-        # Get a testbrowser\n-        self.browser = Browser(self.layer[\'app\'])\n-        self.browser.handleErrors = False\n-        self.browser.addHeader(\'Referer\', self.portal.absolute_url())\n-        self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic {0:s}:{1:s}\'.format(TEST_USER_NAME, TEST_USER_PASSWORD))\n-\n-        # Do an initial page load to make sure the bundles get compiled\n-        # (which currently commits a transaction)\n-        # before we render exception views\n-        self.browser.open(self.portal.absolute_url())\n-\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\', ])\n-\n-    def _get_token(self, obj):\n-        return getMultiAdapter(\n-            (obj, self.request), name=\'authenticator\').token()\n-\n-    def _set_text(self, obj, text):\n-        obj.text = RichTextValue(text)\n-        modified(obj)\n-\n-    def _get_text(self, obj):\n-        return obj.text.raw\n-\n-    def _set_related_items(self, obj, items):\n-        assert IRelatedItems.providedBy(obj)\n-        setattr(obj, \'relatedItems\', items)\n-        modified(obj)\n-\n-    def _get_related_items(self, obj):\n-        return obj.relatedItems\ndiff --git a/plone/app/linkintegrity/tests/test_circular.py b/plone/app/linkintegrity/tests/test_circular.py\nindex 89d5a7f..b3a3c1f 100644\n--- a/plone/app/linkintegrity/tests/test_circular.py\n+++ b/plone/app/linkintegrity/tests/test_circular.py\n@@ -1,11 +1,27 @@\n+from plone.app.linkintegrity import testing\n from plone.app.linkintegrity.browser.info import DeleteConfirmationInfo\n from plone.app.linkintegrity.testing import create\n-from plone.app.linkintegrity.tests.base import BaseTestCase\n+from plone.app.linkintegrity.tests.utils import set_text\n from plone.app.linkintegrity.utils import getOutgoingLinks\n from plone.app.linkintegrity.utils import hasIncomingLinks\n+from plone.app.textfield import RichTextValue\n+from zope.lifecycleevent import modified\n \n+import unittest\n \n-class CircularReferencesTestCase:\n+\n+class CircularReferencesTestCase(unittest.TestCase):\n+    """Circular reference testcase"""\n+\n+    layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+        self.request = self.layer[\'request\']\n+\n+    def _set_text(self, obj, text):\n+        obj.text = RichTextValue(text)\n+        modified(obj)\n \n     def test_circular_reference_manages_relations(self):\n         doc1 = self.portal[\'doc1\']\n@@ -14,9 +30,9 @@ def test_circular_reference_manages_relations(self):\n         self.assertFalse(hasIncomingLinks(doc1))\n         self.assertFalse(hasIncomingLinks(doc2))\n         self.assertFalse(hasIncomingLinks(doc3))\n-        self._set_text(doc1, \'<a href="doc2">doc2</a>\')\n-        self._set_text(doc2, \'<a href="doc3">doc3</a>\')\n-        self._set_text(doc3, \'<a href="doc1">doc1</a>\')\n+        set_text(doc1, \'<a href="doc2">doc2</a>\')\n+        set_text(doc2, \'<a href="doc3">doc3</a>\')\n+        set_text(doc3, \'<a href="doc1">doc1</a>\')\n         self.assertTrue(hasIncomingLinks(doc1))\n         self.assertTrue(hasIncomingLinks(doc2))\n         self.assertTrue(hasIncomingLinks(doc3))\n@@ -30,10 +46,10 @@ def test_circular_reference_subfolder_deletion(self):\n \n         # This tests the behaviour when removing objects\n         # referencing each other in a circle.\n-        self._set_text(doc1, \'<a href="doc2">documents...</a>\')\n-        self._set_text(doc2, \'<a href="doc3">go round...</a>\')\n-        self._set_text(doc3, \'<a href="folder1/doc4">and round.</a>\')\n-        self._set_text(doc4, \'<a href="../doc1">in circles.</a>\')\n+        set_text(doc1, \'<a href="doc2">documents...</a>\')\n+        set_text(doc2, \'<a href="doc3">go round...</a>\')\n+        set_text(doc3, \'<a href="folder1/doc4">and round.</a>\')\n+        set_text(doc4, \'<a href="../doc1">in circles.</a>\')\n \n         self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [doc2])\n         self.assertEqual([r.to_object for r in getOutgoingLinks(doc2)], [doc3])\n@@ -52,9 +68,9 @@ def test_internal_breaches_are_dropped(self):\n         doc1 = self.portal.doc1\n         doc4 = self.portal.folder1.doc4\n         doc5 = self.portal.folder1.doc5\n-        self._set_text(doc1, \'<a href="folder1">f1</a>\')\n-        self._set_text(doc4, \'<a href="doc5">d5</a><a href="../doc1">d1</a>\')\n-        self._set_text(doc5, \'<a href="../folder1">f1</a>\')\n+        set_text(doc1, \'<a href="folder1">f1</a>\')\n+        set_text(doc4, \'<a href="doc5">d5</a><a href="../doc1">d1</a>\')\n+        set_text(doc5, \'<a href="../folder1">f1</a>\')\n \n         doc4_breaches = set([r.to_object for r in getOutgoingLinks(doc4)])\n         # the order of breaches is non-deterministic\n@@ -79,7 +95,3 @@ def test_internal_breaches_are_dropped(self):\n         self.assertNotIn(\'Potential link breakage\', view())\n         view = doc4.restrictedTraverse(\'delete_confirmation_info\')\n         self.assertNotIn(\'Potential link breakage\', view())\n-\n-\n-class CircularReferencesDXTestCase(BaseTestCase, CircularReferencesTestCase):\n-    """Circular reference testcase for dx content types"""\ndiff --git a/plone/app/linkintegrity/tests/test_functional.py b/plone/app/linkintegrity/tests/test_functional.py\nindex 357906c..ac5cb83 100644\n--- a/plone/app/linkintegrity/tests/test_functional.py\n+++ b/plone/app/linkintegrity/tests/test_functional.py\n@@ -1,25 +1,52 @@\n from plone.app.linkintegrity import testing\n-from plone.app.linkintegrity.tests.base import BaseTestCase\n+from plone.app.linkintegrity.tests.utils import set_text\n from plone.app.linkintegrity.utils import getIncomingLinks\n from plone.app.linkintegrity.utils import getOutgoingLinks\n from plone.app.linkintegrity.utils import hasOutgoingLinks\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n from plone.app.testing import TEST_USER_PASSWORD\n from plone.registry.interfaces import IRegistry\n from plone.testing.zope import Browser\n from plone.base.interfaces import IEditingSchema\n from zc.relation.interfaces import ICatalog\n+from zope.component import getMultiAdapter\n from zope.component import getUtility\n \n import transaction\n import unittest\n \n \n-class FunctionalReferenceTestCase(BaseTestCase):\n+class FunctionalReferenceTestCase(unittest.TestCase):\n     """functional reference testcase"""\n \n     layer = testing.PLONE_APP_LINKINTEGRITY_FUNCTIONAL_TESTING\n \n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+        self.request = self.layer[\'request\']\n+        # alsoProvides(self.request, IFormLayer)\n+\n+        # Get a testbrowser\n+        self.browser = Browser(self.layer[\'app\'])\n+        self.browser.handleErrors = False\n+        self.browser.addHeader(\'Referer\', self.portal.absolute_url())\n+        self.browser.addHeader(\n+            \'Authorization\',\n+            \'Basic {0:s}:{1:s}\'.format(TEST_USER_NAME, TEST_USER_PASSWORD))\n+\n+        # Do an initial page load to make sure the bundles get compiled\n+        # (which currently commits a transaction)\n+        # before we render exception views\n+        self.browser.open(self.portal.absolute_url())\n+\n+        setRoles(self.portal, TEST_USER_ID, [\'Manager\', ])\n+\n+    def _get_token(self, obj):\n+        return getMultiAdapter(\n+            (obj, self.request), name=\'authenticator\').token()\n+\n     @unittest.skip(\'Re-enable after https://github.com/plone/plone.app.content/issues/38\')  # noqa\n     def test_file_reference_linkintegrity_page_is_shown(self):\n         doc1 = self.portal.doc1\n@@ -27,7 +54,7 @@ def test_file_reference_linkintegrity_page_is_shown(self):\n                                id=\'file2\', file=testing.GIF)\n \n         self.assertFalse(hasOutgoingLinks(doc1))\n-        self._set_text(doc1, \'<a href="file2">A File</a>\')\n+        set_text(doc1, \'<a href="file2">A File</a>\')\n         self.assertTrue(hasOutgoingLinks(doc1))\n         self.assertIn(\'file2\', self.portal.objectIds())\n \n@@ -90,7 +117,7 @@ def test_renaming_referenced_item(self):\n         # This tests makes sure items that are linked to can still be\n         # renamed (see the related bug report in #6608).  First we need\n         # to create the necessary links:\n-        self._set_text(doc1, \'<a href="doc2">doc2</a>\')\n+        set_text(doc1, \'<a href="doc2">doc2</a>\')\n         self.assertEqual(\n             [i.from_object for i in getIncomingLinks(doc2)], [doc1])\n \n@@ -131,8 +158,8 @@ def test_removal_in_subfolder(self):\n \n         # This tests ensuring link integrity when removing an referenced\n         # object contained in a folder that is removed.\n-        self._set_text(doc1, \'<a href="folder1/doc4">a document</a>\')\n-        self._set_text(doc2, \'<a href="folder1/doc4">a document</a>\')\n+        set_text(doc1, \'<a href="folder1/doc4">a document</a>\')\n+        set_text(doc2, \'<a href="folder1/doc4">a document</a>\')\n \n         # Make changes visible to testbrowseropen\n         transaction.commit()\n@@ -162,7 +189,7 @@ def test_removal_with_cookie_auth(self):\n \n         # This tests ensures link integrity working correctly without\n         # http basic authentication (see the bug report in #6607).\n-        self._set_text(doc1, \'<a href="doc2">doc2</a>\')\n+        set_text(doc1, \'<a href="doc2">doc2</a>\')\n         transaction.commit()\n \n         browser = Browser(self.layer[\'app\'])\n@@ -198,7 +225,7 @@ def test_linkintegrity_on_off_switch(self):\n         doc2 = self.portal.doc2\n \n         # This tests switching link integrity checking on and off.\n-        self._set_text(doc1, \'<a href="doc2">a document</a>\')\n+        set_text(doc1, \'<a href="doc2">a document</a>\')\n         transaction.commit()\n \n         # This should lead us back to the "folder contents" listing,\n@@ -232,8 +259,8 @@ def test_update(self):\n \n         # This tests updating link integrity information for all site content,\n         # i.e. after migrating from a previous version.\n-        self._set_text(doc1, \'<a href="doc2">a document</a>\')\n-        self._set_text(doc2, \'<a href="folder1/doc4">a document</a>\')\n+        set_text(doc1, \'<a href="doc2">a document</a>\')\n+        set_text(doc2, \'<a href="folder1/doc4">a document</a>\')\n \n         catalog = getUtility(ICatalog)\n         rels = [i for i in catalog.findRelations()]\n@@ -271,7 +298,7 @@ def test_references_on_cloned_objects(self):\n \n         # This tests ensures that link integrity is correctly setup when\n         # cloning an object.\n-        self._set_text(doc1, \'<a href="doc2">a document</a>\')\n+        set_text(doc1, \'<a href="doc2">a document</a>\')\n \n         # Next we clone the document:\n         token = self._get_token(doc1)\n@@ -318,7 +345,7 @@ def test_files_with_spaces_removal(self):\n         self.assertIn(\'some spaces.doc\', self.portal.objectIds())\n         spaces1 = self.portal[\'some spaces.doc\']\n \n-        self._set_text(doc1, \'<a href="some spaces.doc">a document</a>\')\n+        set_text(doc1, \'<a href="some spaces.doc">a document</a>\')\n \n         # The document should now have a reference to the file:\n         self.assertEqual(\n@@ -350,7 +377,7 @@ def test_removal_via_zmi(self):\n \n         # This tests ensuring link integrity when removing an object via\n         # the ZMI.\n-        self._set_text(doc1, \'<a href="doc2">a document</a>\')\n+        set_text(doc1, \'<a href="doc2">a document</a>\')\n         self.assertEqual([i.to_object for i in getOutgoingLinks(doc1)], [doc2])\n \n         transaction.commit()\ndiff --git a/plone/app/linkintegrity/tests/test_handlers.py b/plone/app/linkintegrity/tests/test_handlers.py\nindex 4de0cff..acc020f 100644\n--- a/plone/app/linkintegrity/tests/test_handlers.py\n+++ b/plone/app/linkintegrity/tests/test_handlers.py\n@@ -1,12 +1,19 @@\n+from plone.app.linkintegrity import testing\n from plone.app.linkintegrity.handlers import findObject\n from plone.app.linkintegrity.testing import create\n-from plone.app.linkintegrity.tests.base import BaseTestCase\n from plone.app.testing import logout\n \n+import unittest\n \n-class ReferenceGenerationTestCase(BaseTestCase):\n+\n+class ReferenceGenerationTestCase(unittest.TestCase):\n     """ testing the handlers.findObject function """\n \n+    layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+\n     def test_relative_to_portal_root_1(self):\n         obj, components = findObject(self.portal.doc1, \'/plone/doc2\')\n         self.assertEqual(obj.absolute_url_path(), \'/plone/doc2\')\ndiff --git a/plone/app/linkintegrity/tests/test_imagescales.py b/plone/app/linkintegrity/tests/test_imagescales.py\nindex e31f40f..0ffc9cd 100644\n--- a/plone/app/linkintegrity/tests/test_imagescales.py\n+++ b/plone/app/linkintegrity/tests/test_imagescales.py\n@@ -1,12 +1,20 @@\n-from plone.app.linkintegrity.tests.base import BaseTestCase\n+from plone.app.linkintegrity import testing\n+from plone.app.linkintegrity.tests.utils import set_text\n from plone.app.linkintegrity.utils import getIncomingLinks\n from plone.app.linkintegrity.utils import getOutgoingLinks\n from plone.uuid.interfaces import IUUID\n \n+import unittest\n \n-class ImageReferenceTestCase(BaseTestCase):\n+\n+class ImageReferenceTestCase(unittest.TestCase):\n     """image reference testcase"""\n \n+    layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+\n     def test_image_tag_reference_creation(self):\n         doc1 = self.portal.doc1\n         img1 = self.portal.image1\n@@ -15,7 +23,7 @@ def test_image_tag_reference_creation(self):\n         # ensuring link integrity. Any archetype-based content object\n         # which refers to other (local) objects by `<img>` or `<a>` tags\n         # should create references between those objects on save.\n-        self._set_text(doc1, img1.restrictedTraverse(\'@@images\').tag())\n+        set_text(doc1, img1.restrictedTraverse(\'@@images\').tag())\n \n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n@@ -33,7 +41,7 @@ def test_image_scale_reference_creation(self):\n         img1 = self.portal.image1\n \n         # Linking image scales should also work:\n-        self._set_text(\n+        set_text(\n             doc1, \'<a href="image1/@@images/image_thumb">an image</a>\')\n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n@@ -49,7 +57,7 @@ def test_image_resolveuid_reference_creation(self):\n         img1 = self.portal.image1\n \n         # Linking via the "resolveuid/UID" method should also work:\n-        self._set_text(doc1, \'<a href="resolveuid/{0:s}">an image</a>\'.format(\n+        set_text(doc1, \'<a href="resolveuid/{0:s}">an image</a>\'.format(\n             IUUID(img1)))\n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\ndiff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py\nindex e327338..55b0faf 100644\n--- a/plone/app/linkintegrity/tests/test_references.py\n+++ b/plone/app/linkintegrity/tests/test_references.py\n@@ -1,10 +1,11 @@\n from plone.app.linkintegrity import testing\n from plone.app.linkintegrity.parser import extractLinks\n-from plone.app.linkintegrity.tests.base import BaseTestCase\n+from plone.app.linkintegrity.tests.utils import set_text\n from plone.app.linkintegrity.utils import getIncomingLinks\n from plone.app.linkintegrity.utils import getOutgoingLinks\n from plone.app.linkintegrity.utils import hasIncomingLinks\n from plone.app.linkintegrity.utils import hasOutgoingLinks\n+from plone.app.relationfield.behavior import IRelatedItems\n from plone.app.testing import login\n from plone.app.testing import logout\n from plone.app.testing import TEST_USER_NAME\n@@ -12,17 +13,32 @@\n from z3c.relationfield.event import _setRelation\n from zc.relation.interfaces import ICatalog\n from zope.component import getUtility\n-from zope.intid.interfaces import IIntIds\n from zope.lifecycleevent import modified\n+from zope.intid.interfaces import IIntIds\n \n+import unittest\n \n-class ReferenceGenerationTestCase(BaseTestCase):\n+\n+class ReferenceGenerationTestCase(unittest.TestCase):\n     """reference generation testcase"""\n \n+    layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+\n+    def _set_related_items(self, obj, items):\n+        assert IRelatedItems.providedBy(obj)\n+        setattr(obj, \'relatedItems\', items)\n+        modified(obj)\n+\n+    def _get_related_items(self, obj):\n+        return obj.relatedItems\n+\n     def test_is_linked(self):\n         img1 = self.portal[\'image1\']\n         doc1 = self.portal[\'doc1\']\n-        self._set_text(doc1, \'<img src="image1"></img>\')\n+        set_text(doc1, \'<img src="image1"></img>\')\n         self.assertTrue(hasIncomingLinks(img1))\n \n     def test_referal_to_private_files(self):\n@@ -34,7 +50,7 @@ def test_referal_to_private_files(self):\n         # the link in question and set up the permissions accordingly.\n         doc = self.portal.doc1\n         img = self.portal.image1\n-        self._set_text(doc, \'<a href="image1">Image 1</a>\')\n+        set_text(doc, \'<a href="image1">Image 1</a>\')\n \n         roles = (\'Member\', )\n         self.portal.manage_permission(\'List folder contents\', roles=roles)\n@@ -80,21 +96,21 @@ def test_referal_to_private_files(self):\n \n     def test_link_extraction_easy(self):\n         doc1 = self.portal.doc1\n-        self._set_text(doc1, \'<a href="doc2">Doc 2</a>\')\n+        set_text(doc1, \'<a href="doc2">Doc 2</a>\')\n         self.assertEqual(\n-            extractLinks(self._get_text(doc1)),\n+            extractLinks(doc1.text.raw),\n             (\'doc2\', )\n         )\n \n     def test_link_extraction_more_complex(self):\n         doc2 = self.portal.doc2\n-        self._set_text(\n+        set_text(\n             doc2,\n             \'<a href="doc1">Doc 2</a>\' +\n             \'<a href="folder1/doc3"><img src="image1" /></a>\',\n         )\n         self.assertEqual(\n-            extractLinks(self._get_text(doc2)),\n+            extractLinks(doc2.text.raw),\n             (\'doc1\',\n              \'folder1/doc3\',\n              \'image1\')\n@@ -106,16 +122,16 @@ def test_broken_references(self):\n         doc1 = self.portal.doc1\n \n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)\n-        self._set_text(doc1, \'<a href="doc1a">Doc 1a</a>\')\n+        set_text(doc1, \'<a href="doc1a">Doc 1a</a>\')\n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 1)\n-        self.assertEqual([l.to_object for l in getOutgoingLinks(doc1)],\n+        self.assertEqual([link.to_object for link in getOutgoingLinks(doc1)],\n                          [self.portal.doc1a])\n \n         # Now delete the target item, suppress events and test again,\n         # The reference should be a ghost not in any folder anymore.\n         # check if it has no acquition parent!\n         self.portal._delObject(doc1a.id, suppress_events=True)\n-        objs = [l.to_object for l in getOutgoingLinks(doc1)]\n+        objs = [link.to_object for link in getOutgoingLinks(doc1)]\n         self.assertEqual(len(objs), 1)\n         obj = objs[0]\n         if obj is not None:\n@@ -128,9 +144,9 @@ def test_broken_references(self):\n     def test_relative_upwards_link_generates_matching_reference(self):\n         doc1 = self.portal.doc1\n         doc3 = self.portal.folder1.doc3\n-        self._set_text(doc3, \'<a href="../doc1">go!</a>\')\n+        set_text(doc3, \'<a href="../doc1">go!</a>\')\n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)\n-        self.assertEqual([l.to_object for l in getOutgoingLinks(doc3)],\n+        self.assertEqual([link.to_object for link in getOutgoingLinks(doc3)],\n                          [doc1])\n \n     def test_unicode_links(self):\n@@ -140,11 +156,11 @@ def test_unicode_links(self):\n         # eventually plays well with transaction machinery.\n         # Add bad link, should not raise exception and there should not\n         # be any references added.\n-        self._set_text(\n+        set_text(\n             doc1,\n             \'<a href="\xc3\xb6?foo=bar&baz=bam">bug</a>\')\n \n-        self.assertEqual([l for l in getOutgoingLinks(doc1)], [])\n+        self.assertEqual([link for link in getOutgoingLinks(doc1)], [])\n \n     def test_reference_orthogonality(self):\n         doc = self.portal.doc1\n@@ -152,10 +168,10 @@ def test_reference_orthogonality(self):\n         tag = img.restrictedTraverse(\'@@images\').tag()\n \n         # This tests the behavior when other references already exist.\n-        self.assertEqual([l for l in getOutgoingLinks(doc)], [])\n-        self.assertEqual([l for l in getIncomingLinks(doc)], [])\n-        self.assertEqual([l for l in getOutgoingLinks(img)], [])\n-        self.assertEqual([l for l in getOutgoingLinks(img)], [])\n+        self.assertEqual([link for link in getOutgoingLinks(doc)], [])\n+        self.assertEqual([link for link in getIncomingLinks(doc)], [])\n+        self.assertEqual([link for link in getOutgoingLinks(img)], [])\n+        self.assertEqual([link for link in getOutgoingLinks(img)], [])\n \n         # Then establish a reference between the document and image as\n         # a related item:\n@@ -164,9 +180,9 @@ def test_reference_orthogonality(self):\n \n         # Next edit the document body and insert a link to the image,\n         # which should trigger the creation of a link integrity reference:\n-        self._set_text(doc, tag)\n+        set_text(doc, tag)\n \n-        self.assertEqual([l.to_object for l in getOutgoingLinks(doc)], [img])\n+        self.assertEqual([link.to_object for link in getOutgoingLinks(doc)], [img])\n \n         # And the related item reference remains in place:\n         self.assertEqual(self._get_related_items(doc), [img, ])\n@@ -174,8 +190,8 @@ def test_reference_orthogonality(self):\n         # Finally, edit the document body again, this time removing the\n         # link to the image, which should trigger the removal of the\n         # link integrity reference:\n-        self._set_text(doc, \'where did my link go?\')\n-        self.assertEqual([l.to_object for l in getOutgoingLinks(doc)], [])\n+        set_text(doc, \'where did my link go?\')\n+        self.assertEqual([link.to_object for link in getOutgoingLinks(doc)], [])\n \n         # And again the related item reference remains in place:\n         self.assertEqual(self._get_related_items(doc), [img, ])\ndiff --git a/plone/app/linkintegrity/tests/utils.py b/plone/app/linkintegrity/tests/utils.py\nnew file mode 100644\nindex 0000000..895e85f\n--- /dev/null\n+++ b/plone/app/linkintegrity/tests/utils.py\n@@ -0,0 +1,7 @@\n+from plone.app.textfield import RichTextValue\n+from zope.lifecycleevent import modified\n+\n+\n+def set_text(obj, text):\n+    obj.text = RichTextValue(text)\n+    modified(obj)\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2023-03-10T17:19:08+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/b946a803578a7e67d9572bbd7a6551561a6b02f3

Merge pull request #88 from plone/maurits-cleanup-test-layers

Fixed test layer setup.

Files changed:
A news/846.bugfix
A plone/app/linkintegrity/tests/utils.py
M plone/app/linkintegrity/testing.py
M plone/app/linkintegrity/tests/test_circular.py
M plone/app/linkintegrity/tests/test_functional.py
M plone/app/linkintegrity/tests/test_handlers.py
M plone/app/linkintegrity/tests/test_imagescales.py
M plone/app/linkintegrity/tests/test_references.py
D plone/app/linkintegrity/tests/base.py

b'diff --git a/news/846.bugfix b/news/846.bugfix\nnew file mode 100644\nindex 0000000..53023f2\n--- /dev/null\n+++ b/news/846.bugfix\n@@ -0,0 +1,3 @@\n+Fixed test layer setup.\n+Created content was bleeding into layers from other packages.\n+[maurits]\ndiff --git a/plone/app/linkintegrity/testing.py b/plone/app/linkintegrity/testing.py\nindex 90b031f..1239036 100644\n--- a/plone/app/linkintegrity/testing.py\n+++ b/plone/app/linkintegrity/testing.py\n@@ -1,14 +1,13 @@\n from base64 import decodebytes\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FIXTURE\n from plone.app.testing import layers\n from plone.app.testing import login\n-from plone.app.testing import ploneSite\n+from plone.app.testing import PLONE_FIXTURE\n+from plone.app.testing import PloneSandboxLayer\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n from plone.app.testing import TEST_USER_PASSWORD\n from plone.namedfile.file import NamedImage\n-from plone.testing import zope\n from Products.CMFCore.utils import getToolByName\n from zope.configuration import xmlconfig\n \n@@ -32,59 +31,47 @@ def create(container, type_name, **kwargs):\n     return content\n \n \n-class LinkIntegrityLayer(zope.Layer):\n+class LinkIntegrityLayer(PloneSandboxLayer):\n     """Base Layer for Dexterity testing.\n     """\n \n-    # defaultBases = (PLONE_FIXTURE, )\n-    defaultBases = (\n-        PLONE_APP_CONTENTTYPES_FIXTURE,\n-    )\n+    defaultBases = (PLONE_FIXTURE, )\n \n-    def setUp(self):\n-        self.setUpContent()\n-\n-    def setUpMembers(self, portal):\n-        pm = getToolByName(portal, \'portal_membership\')\n-        pm.addMember(\'editor\', TEST_USER_PASSWORD, [\'Editor\'], [])\n-        pm.addMember(\'member\', TEST_USER_PASSWORD, [\'Member\'], [])\n-        pm.addMember(\'authenticated\', TEST_USER_PASSWORD, [], [])\n-\n-    def setUpContent(self):\n+    def setUpZope(self, app, configurationContext):\n         import plone.app.linkintegrity\n \n         xmlconfig.file(\'configure.zcml\', plone.app.linkintegrity,\n-                       context=self[\'configurationContext\'])\n+                       context=configurationContext)\n \n-        with ploneSite() as portal:\n-            setRoles(portal, TEST_USER_ID, [\'Manager\', ])\n-            login(portal, TEST_USER_NAME)\n+    def setUpPloneSite(self, portal):\n+        setRoles(portal, TEST_USER_ID, [\'Manager\', ])\n+        login(portal, TEST_USER_NAME)\n \n-            # Create sample documents\n-            type_data = dict(type_name=\'Document\')\n-            for i in range(1, 4):\n-                type_data[\'id\'] = \'doc{0:d}\'.format(i)\n-                type_data[\'title\'] = \'Test Page {0:d}\'.format(i)\n-                create(portal, **type_data)\n+        # Create sample documents\n+        type_data = dict(type_name=\'Document\')\n+        for i in range(1, 4):\n+            type_data[\'id\'] = \'doc{0:d}\'.format(i)\n+            type_data[\'title\'] = \'Test Page {0:d}\'.format(i)\n+            create(portal, **type_data)\n \n-            create(portal, \'File\', id=\'file1\', title=\'File 1\', file=GIF)\n-            create(portal, \'Folder\', id=\'folder1\', title=\'Folder 1\')\n-            subfolder = portal[\'folder1\']\n-            create(subfolder, \'Document\', id=\'doc4\', title=\'Test Page 4\')\n+        create(portal, \'File\', id=\'file1\', title=\'File 1\', file=GIF)\n+        create(portal, \'Folder\', id=\'folder1\', title=\'Folder 1\')\n+        subfolder = portal[\'folder1\']\n+        create(subfolder, \'Document\', id=\'doc4\', title=\'Test Page 4\')\n \n-            self.setUpMembers(portal)\n-\n-            # Create an object that does not provide the behavior to live along\n-            create(portal, \'News Item\', id=\'news1\', title=\'News 1\')\n+        # setup members\n+        pm = getToolByName(portal, \'portal_membership\')\n+        pm.addMember(\'editor\', TEST_USER_PASSWORD, [\'Editor\'], [])\n+        pm.addMember(\'member\', TEST_USER_PASSWORD, [\'Member\'], [])\n+        pm.addMember(\'authenticated\', TEST_USER_PASSWORD, [], [])\n \n-            # create a DX NamedImage\n-            portal.invokeFactory(\'Image\', \'image1\')\n-            portal[\'image1\'].image = NamedImage(GIF, \'image/gif\',\n-                                                u\'sample.gif\')\n+        # Create an object that does not provide the behavior to live along\n+        create(portal, \'News Item\', id=\'news1\', title=\'News 1\')\n \n-    def tearDown(self):\n-        with zope.zopeApp() as app:\n-            zope.uninstallProduct(app, \'plone.app.linkintegrity\')\n+        # create a NamedImage\n+        portal.invokeFactory(\'Image\', \'image1\')\n+        portal[\'image1\'].image = NamedImage(GIF, \'image/gif\',\n+                                            u\'sample.gif\')\n \n \n PLONE_APP_LINKINTEGRITY_FIXTURE = LinkIntegrityLayer()\ndiff --git a/plone/app/linkintegrity/tests/base.py b/plone/app/linkintegrity/tests/base.py\ndeleted file mode 100644\nindex 621d9a3..0000000\n--- a/plone/app/linkintegrity/tests/base.py\n+++ /dev/null\n@@ -1,59 +0,0 @@\n-from plone.app.linkintegrity import testing\n-from plone.app.relationfield.behavior import IRelatedItems\n-from plone.app.testing import setRoles\n-from plone.app.testing import TEST_USER_ID\n-from plone.app.testing import TEST_USER_NAME\n-from plone.app.testing import TEST_USER_PASSWORD\n-from plone.app.textfield import RichTextValue\n-from plone.testing.zope import Browser\n-from z3c.form.interfaces import IFormLayer\n-from zope.component import getMultiAdapter\n-from zope.interface import alsoProvides\n-from zope.lifecycleevent import modified\n-\n-import unittest\n-\n-\n-class BaseTestCase(unittest.TestCase):\n-    """Base testcase for testing Dexterity content types"""\n-\n-    layer = testing.PLONE_APP_LINKINTEGRITY_FUNCTIONAL_TESTING\n-\n-    def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        alsoProvides(self.request, IFormLayer)\n-\n-        # Get a testbrowser\n-        self.browser = Browser(self.layer[\'app\'])\n-        self.browser.handleErrors = False\n-        self.browser.addHeader(\'Referer\', self.portal.absolute_url())\n-        self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic {0:s}:{1:s}\'.format(TEST_USER_NAME, TEST_USER_PASSWORD))\n-\n-        # Do an initial page load to make sure the bundles get compiled\n-        # (which currently commits a transaction)\n-        # before we render exception views\n-        self.browser.open(self.portal.absolute_url())\n-\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\', ])\n-\n-    def _get_token(self, obj):\n-        return getMultiAdapter(\n-            (obj, self.request), name=\'authenticator\').token()\n-\n-    def _set_text(self, obj, text):\n-        obj.text = RichTextValue(text)\n-        modified(obj)\n-\n-    def _get_text(self, obj):\n-        return obj.text.raw\n-\n-    def _set_related_items(self, obj, items):\n-        assert IRelatedItems.providedBy(obj)\n-        setattr(obj, \'relatedItems\', items)\n-        modified(obj)\n-\n-    def _get_related_items(self, obj):\n-        return obj.relatedItems\ndiff --git a/plone/app/linkintegrity/tests/test_circular.py b/plone/app/linkintegrity/tests/test_circular.py\nindex 89d5a7f..b3a3c1f 100644\n--- a/plone/app/linkintegrity/tests/test_circular.py\n+++ b/plone/app/linkintegrity/tests/test_circular.py\n@@ -1,11 +1,27 @@\n+from plone.app.linkintegrity import testing\n from plone.app.linkintegrity.browser.info import DeleteConfirmationInfo\n from plone.app.linkintegrity.testing import create\n-from plone.app.linkintegrity.tests.base import BaseTestCase\n+from plone.app.linkintegrity.tests.utils import set_text\n from plone.app.linkintegrity.utils import getOutgoingLinks\n from plone.app.linkintegrity.utils import hasIncomingLinks\n+from plone.app.textfield import RichTextValue\n+from zope.lifecycleevent import modified\n \n+import unittest\n \n-class CircularReferencesTestCase:\n+\n+class CircularReferencesTestCase(unittest.TestCase):\n+    """Circular reference testcase"""\n+\n+    layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+        self.request = self.layer[\'request\']\n+\n+    def _set_text(self, obj, text):\n+        obj.text = RichTextValue(text)\n+        modified(obj)\n \n     def test_circular_reference_manages_relations(self):\n         doc1 = self.portal[\'doc1\']\n@@ -14,9 +30,9 @@ def test_circular_reference_manages_relations(self):\n         self.assertFalse(hasIncomingLinks(doc1))\n         self.assertFalse(hasIncomingLinks(doc2))\n         self.assertFalse(hasIncomingLinks(doc3))\n-        self._set_text(doc1, \'<a href="doc2">doc2</a>\')\n-        self._set_text(doc2, \'<a href="doc3">doc3</a>\')\n-        self._set_text(doc3, \'<a href="doc1">doc1</a>\')\n+        set_text(doc1, \'<a href="doc2">doc2</a>\')\n+        set_text(doc2, \'<a href="doc3">doc3</a>\')\n+        set_text(doc3, \'<a href="doc1">doc1</a>\')\n         self.assertTrue(hasIncomingLinks(doc1))\n         self.assertTrue(hasIncomingLinks(doc2))\n         self.assertTrue(hasIncomingLinks(doc3))\n@@ -30,10 +46,10 @@ def test_circular_reference_subfolder_deletion(self):\n \n         # This tests the behaviour when removing objects\n         # referencing each other in a circle.\n-        self._set_text(doc1, \'<a href="doc2">documents...</a>\')\n-        self._set_text(doc2, \'<a href="doc3">go round...</a>\')\n-        self._set_text(doc3, \'<a href="folder1/doc4">and round.</a>\')\n-        self._set_text(doc4, \'<a href="../doc1">in circles.</a>\')\n+        set_text(doc1, \'<a href="doc2">documents...</a>\')\n+        set_text(doc2, \'<a href="doc3">go round...</a>\')\n+        set_text(doc3, \'<a href="folder1/doc4">and round.</a>\')\n+        set_text(doc4, \'<a href="../doc1">in circles.</a>\')\n \n         self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [doc2])\n         self.assertEqual([r.to_object for r in getOutgoingLinks(doc2)], [doc3])\n@@ -52,9 +68,9 @@ def test_internal_breaches_are_dropped(self):\n         doc1 = self.portal.doc1\n         doc4 = self.portal.folder1.doc4\n         doc5 = self.portal.folder1.doc5\n-        self._set_text(doc1, \'<a href="folder1">f1</a>\')\n-        self._set_text(doc4, \'<a href="doc5">d5</a><a href="../doc1">d1</a>\')\n-        self._set_text(doc5, \'<a href="../folder1">f1</a>\')\n+        set_text(doc1, \'<a href="folder1">f1</a>\')\n+        set_text(doc4, \'<a href="doc5">d5</a><a href="../doc1">d1</a>\')\n+        set_text(doc5, \'<a href="../folder1">f1</a>\')\n \n         doc4_breaches = set([r.to_object for r in getOutgoingLinks(doc4)])\n         # the order of breaches is non-deterministic\n@@ -79,7 +95,3 @@ def test_internal_breaches_are_dropped(self):\n         self.assertNotIn(\'Potential link breakage\', view())\n         view = doc4.restrictedTraverse(\'delete_confirmation_info\')\n         self.assertNotIn(\'Potential link breakage\', view())\n-\n-\n-class CircularReferencesDXTestCase(BaseTestCase, CircularReferencesTestCase):\n-    """Circular reference testcase for dx content types"""\ndiff --git a/plone/app/linkintegrity/tests/test_functional.py b/plone/app/linkintegrity/tests/test_functional.py\nindex 357906c..ac5cb83 100644\n--- a/plone/app/linkintegrity/tests/test_functional.py\n+++ b/plone/app/linkintegrity/tests/test_functional.py\n@@ -1,25 +1,52 @@\n from plone.app.linkintegrity import testing\n-from plone.app.linkintegrity.tests.base import BaseTestCase\n+from plone.app.linkintegrity.tests.utils import set_text\n from plone.app.linkintegrity.utils import getIncomingLinks\n from plone.app.linkintegrity.utils import getOutgoingLinks\n from plone.app.linkintegrity.utils import hasOutgoingLinks\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n from plone.app.testing import TEST_USER_PASSWORD\n from plone.registry.interfaces import IRegistry\n from plone.testing.zope import Browser\n from plone.base.interfaces import IEditingSchema\n from zc.relation.interfaces import ICatalog\n+from zope.component import getMultiAdapter\n from zope.component import getUtility\n \n import transaction\n import unittest\n \n \n-class FunctionalReferenceTestCase(BaseTestCase):\n+class FunctionalReferenceTestCase(unittest.TestCase):\n     """functional reference testcase"""\n \n     layer = testing.PLONE_APP_LINKINTEGRITY_FUNCTIONAL_TESTING\n \n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+        self.request = self.layer[\'request\']\n+        # alsoProvides(self.request, IFormLayer)\n+\n+        # Get a testbrowser\n+        self.browser = Browser(self.layer[\'app\'])\n+        self.browser.handleErrors = False\n+        self.browser.addHeader(\'Referer\', self.portal.absolute_url())\n+        self.browser.addHeader(\n+            \'Authorization\',\n+            \'Basic {0:s}:{1:s}\'.format(TEST_USER_NAME, TEST_USER_PASSWORD))\n+\n+        # Do an initial page load to make sure the bundles get compiled\n+        # (which currently commits a transaction)\n+        # before we render exception views\n+        self.browser.open(self.portal.absolute_url())\n+\n+        setRoles(self.portal, TEST_USER_ID, [\'Manager\', ])\n+\n+    def _get_token(self, obj):\n+        return getMultiAdapter(\n+            (obj, self.request), name=\'authenticator\').token()\n+\n     @unittest.skip(\'Re-enable after https://github.com/plone/plone.app.content/issues/38\')  # noqa\n     def test_file_reference_linkintegrity_page_is_shown(self):\n         doc1 = self.portal.doc1\n@@ -27,7 +54,7 @@ def test_file_reference_linkintegrity_page_is_shown(self):\n                                id=\'file2\', file=testing.GIF)\n \n         self.assertFalse(hasOutgoingLinks(doc1))\n-        self._set_text(doc1, \'<a href="file2">A File</a>\')\n+        set_text(doc1, \'<a href="file2">A File</a>\')\n         self.assertTrue(hasOutgoingLinks(doc1))\n         self.assertIn(\'file2\', self.portal.objectIds())\n \n@@ -90,7 +117,7 @@ def test_renaming_referenced_item(self):\n         # This tests makes sure items that are linked to can still be\n         # renamed (see the related bug report in #6608).  First we need\n         # to create the necessary links:\n-        self._set_text(doc1, \'<a href="doc2">doc2</a>\')\n+        set_text(doc1, \'<a href="doc2">doc2</a>\')\n         self.assertEqual(\n             [i.from_object for i in getIncomingLinks(doc2)], [doc1])\n \n@@ -131,8 +158,8 @@ def test_removal_in_subfolder(self):\n \n         # This tests ensuring link integrity when removing an referenced\n         # object contained in a folder that is removed.\n-        self._set_text(doc1, \'<a href="folder1/doc4">a document</a>\')\n-        self._set_text(doc2, \'<a href="folder1/doc4">a document</a>\')\n+        set_text(doc1, \'<a href="folder1/doc4">a document</a>\')\n+        set_text(doc2, \'<a href="folder1/doc4">a document</a>\')\n \n         # Make changes visible to testbrowseropen\n         transaction.commit()\n@@ -162,7 +189,7 @@ def test_removal_with_cookie_auth(self):\n \n         # This tests ensures link integrity working correctly without\n         # http basic authentication (see the bug report in #6607).\n-        self._set_text(doc1, \'<a href="doc2">doc2</a>\')\n+        set_text(doc1, \'<a href="doc2">doc2</a>\')\n         transaction.commit()\n \n         browser = Browser(self.layer[\'app\'])\n@@ -198,7 +225,7 @@ def test_linkintegrity_on_off_switch(self):\n         doc2 = self.portal.doc2\n \n         # This tests switching link integrity checking on and off.\n-        self._set_text(doc1, \'<a href="doc2">a document</a>\')\n+        set_text(doc1, \'<a href="doc2">a document</a>\')\n         transaction.commit()\n \n         # This should lead us back to the "folder contents" listing,\n@@ -232,8 +259,8 @@ def test_update(self):\n \n         # This tests updating link integrity information for all site content,\n         # i.e. after migrating from a previous version.\n-        self._set_text(doc1, \'<a href="doc2">a document</a>\')\n-        self._set_text(doc2, \'<a href="folder1/doc4">a document</a>\')\n+        set_text(doc1, \'<a href="doc2">a document</a>\')\n+        set_text(doc2, \'<a href="folder1/doc4">a document</a>\')\n \n         catalog = getUtility(ICatalog)\n         rels = [i for i in catalog.findRelations()]\n@@ -271,7 +298,7 @@ def test_references_on_cloned_objects(self):\n \n         # This tests ensures that link integrity is correctly setup when\n         # cloning an object.\n-        self._set_text(doc1, \'<a href="doc2">a document</a>\')\n+        set_text(doc1, \'<a href="doc2">a document</a>\')\n \n         # Next we clone the document:\n         token = self._get_token(doc1)\n@@ -318,7 +345,7 @@ def test_files_with_spaces_removal(self):\n         self.assertIn(\'some spaces.doc\', self.portal.objectIds())\n         spaces1 = self.portal[\'some spaces.doc\']\n \n-        self._set_text(doc1, \'<a href="some spaces.doc">a document</a>\')\n+        set_text(doc1, \'<a href="some spaces.doc">a document</a>\')\n \n         # The document should now have a reference to the file:\n         self.assertEqual(\n@@ -350,7 +377,7 @@ def test_removal_via_zmi(self):\n \n         # This tests ensuring link integrity when removing an object via\n         # the ZMI.\n-        self._set_text(doc1, \'<a href="doc2">a document</a>\')\n+        set_text(doc1, \'<a href="doc2">a document</a>\')\n         self.assertEqual([i.to_object for i in getOutgoingLinks(doc1)], [doc2])\n \n         transaction.commit()\ndiff --git a/plone/app/linkintegrity/tests/test_handlers.py b/plone/app/linkintegrity/tests/test_handlers.py\nindex 4de0cff..acc020f 100644\n--- a/plone/app/linkintegrity/tests/test_handlers.py\n+++ b/plone/app/linkintegrity/tests/test_handlers.py\n@@ -1,12 +1,19 @@\n+from plone.app.linkintegrity import testing\n from plone.app.linkintegrity.handlers import findObject\n from plone.app.linkintegrity.testing import create\n-from plone.app.linkintegrity.tests.base import BaseTestCase\n from plone.app.testing import logout\n \n+import unittest\n \n-class ReferenceGenerationTestCase(BaseTestCase):\n+\n+class ReferenceGenerationTestCase(unittest.TestCase):\n     """ testing the handlers.findObject function """\n \n+    layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+\n     def test_relative_to_portal_root_1(self):\n         obj, components = findObject(self.portal.doc1, \'/plone/doc2\')\n         self.assertEqual(obj.absolute_url_path(), \'/plone/doc2\')\ndiff --git a/plone/app/linkintegrity/tests/test_imagescales.py b/plone/app/linkintegrity/tests/test_imagescales.py\nindex e31f40f..0ffc9cd 100644\n--- a/plone/app/linkintegrity/tests/test_imagescales.py\n+++ b/plone/app/linkintegrity/tests/test_imagescales.py\n@@ -1,12 +1,20 @@\n-from plone.app.linkintegrity.tests.base import BaseTestCase\n+from plone.app.linkintegrity import testing\n+from plone.app.linkintegrity.tests.utils import set_text\n from plone.app.linkintegrity.utils import getIncomingLinks\n from plone.app.linkintegrity.utils import getOutgoingLinks\n from plone.uuid.interfaces import IUUID\n \n+import unittest\n \n-class ImageReferenceTestCase(BaseTestCase):\n+\n+class ImageReferenceTestCase(unittest.TestCase):\n     """image reference testcase"""\n \n+    layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+\n     def test_image_tag_reference_creation(self):\n         doc1 = self.portal.doc1\n         img1 = self.portal.image1\n@@ -15,7 +23,7 @@ def test_image_tag_reference_creation(self):\n         # ensuring link integrity. Any archetype-based content object\n         # which refers to other (local) objects by `<img>` or `<a>` tags\n         # should create references between those objects on save.\n-        self._set_text(doc1, img1.restrictedTraverse(\'@@images\').tag())\n+        set_text(doc1, img1.restrictedTraverse(\'@@images\').tag())\n \n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n@@ -33,7 +41,7 @@ def test_image_scale_reference_creation(self):\n         img1 = self.portal.image1\n \n         # Linking image scales should also work:\n-        self._set_text(\n+        set_text(\n             doc1, \'<a href="image1/@@images/image_thumb">an image</a>\')\n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n@@ -49,7 +57,7 @@ def test_image_resolveuid_reference_creation(self):\n         img1 = self.portal.image1\n \n         # Linking via the "resolveuid/UID" method should also work:\n-        self._set_text(doc1, \'<a href="resolveuid/{0:s}">an image</a>\'.format(\n+        set_text(doc1, \'<a href="resolveuid/{0:s}">an image</a>\'.format(\n             IUUID(img1)))\n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\ndiff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py\nindex e327338..55b0faf 100644\n--- a/plone/app/linkintegrity/tests/test_references.py\n+++ b/plone/app/linkintegrity/tests/test_references.py\n@@ -1,10 +1,11 @@\n from plone.app.linkintegrity import testing\n from plone.app.linkintegrity.parser import extractLinks\n-from plone.app.linkintegrity.tests.base import BaseTestCase\n+from plone.app.linkintegrity.tests.utils import set_text\n from plone.app.linkintegrity.utils import getIncomingLinks\n from plone.app.linkintegrity.utils import getOutgoingLinks\n from plone.app.linkintegrity.utils import hasIncomingLinks\n from plone.app.linkintegrity.utils import hasOutgoingLinks\n+from plone.app.relationfield.behavior import IRelatedItems\n from plone.app.testing import login\n from plone.app.testing import logout\n from plone.app.testing import TEST_USER_NAME\n@@ -12,17 +13,32 @@\n from z3c.relationfield.event import _setRelation\n from zc.relation.interfaces import ICatalog\n from zope.component import getUtility\n-from zope.intid.interfaces import IIntIds\n from zope.lifecycleevent import modified\n+from zope.intid.interfaces import IIntIds\n \n+import unittest\n \n-class ReferenceGenerationTestCase(BaseTestCase):\n+\n+class ReferenceGenerationTestCase(unittest.TestCase):\n     """reference generation testcase"""\n \n+    layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+\n+    def _set_related_items(self, obj, items):\n+        assert IRelatedItems.providedBy(obj)\n+        setattr(obj, \'relatedItems\', items)\n+        modified(obj)\n+\n+    def _get_related_items(self, obj):\n+        return obj.relatedItems\n+\n     def test_is_linked(self):\n         img1 = self.portal[\'image1\']\n         doc1 = self.portal[\'doc1\']\n-        self._set_text(doc1, \'<img src="image1"></img>\')\n+        set_text(doc1, \'<img src="image1"></img>\')\n         self.assertTrue(hasIncomingLinks(img1))\n \n     def test_referal_to_private_files(self):\n@@ -34,7 +50,7 @@ def test_referal_to_private_files(self):\n         # the link in question and set up the permissions accordingly.\n         doc = self.portal.doc1\n         img = self.portal.image1\n-        self._set_text(doc, \'<a href="image1">Image 1</a>\')\n+        set_text(doc, \'<a href="image1">Image 1</a>\')\n \n         roles = (\'Member\', )\n         self.portal.manage_permission(\'List folder contents\', roles=roles)\n@@ -80,21 +96,21 @@ def test_referal_to_private_files(self):\n \n     def test_link_extraction_easy(self):\n         doc1 = self.portal.doc1\n-        self._set_text(doc1, \'<a href="doc2">Doc 2</a>\')\n+        set_text(doc1, \'<a href="doc2">Doc 2</a>\')\n         self.assertEqual(\n-            extractLinks(self._get_text(doc1)),\n+            extractLinks(doc1.text.raw),\n             (\'doc2\', )\n         )\n \n     def test_link_extraction_more_complex(self):\n         doc2 = self.portal.doc2\n-        self._set_text(\n+        set_text(\n             doc2,\n             \'<a href="doc1">Doc 2</a>\' +\n             \'<a href="folder1/doc3"><img src="image1" /></a>\',\n         )\n         self.assertEqual(\n-            extractLinks(self._get_text(doc2)),\n+            extractLinks(doc2.text.raw),\n             (\'doc1\',\n              \'folder1/doc3\',\n              \'image1\')\n@@ -106,16 +122,16 @@ def test_broken_references(self):\n         doc1 = self.portal.doc1\n \n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)\n-        self._set_text(doc1, \'<a href="doc1a">Doc 1a</a>\')\n+        set_text(doc1, \'<a href="doc1a">Doc 1a</a>\')\n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 1)\n-        self.assertEqual([l.to_object for l in getOutgoingLinks(doc1)],\n+        self.assertEqual([link.to_object for link in getOutgoingLinks(doc1)],\n                          [self.portal.doc1a])\n \n         # Now delete the target item, suppress events and test again,\n         # The reference should be a ghost not in any folder anymore.\n         # check if it has no acquition parent!\n         self.portal._delObject(doc1a.id, suppress_events=True)\n-        objs = [l.to_object for l in getOutgoingLinks(doc1)]\n+        objs = [link.to_object for link in getOutgoingLinks(doc1)]\n         self.assertEqual(len(objs), 1)\n         obj = objs[0]\n         if obj is not None:\n@@ -128,9 +144,9 @@ def test_broken_references(self):\n     def test_relative_upwards_link_generates_matching_reference(self):\n         doc1 = self.portal.doc1\n         doc3 = self.portal.folder1.doc3\n-        self._set_text(doc3, \'<a href="../doc1">go!</a>\')\n+        set_text(doc3, \'<a href="../doc1">go!</a>\')\n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)\n-        self.assertEqual([l.to_object for l in getOutgoingLinks(doc3)],\n+        self.assertEqual([link.to_object for link in getOutgoingLinks(doc3)],\n                          [doc1])\n \n     def test_unicode_links(self):\n@@ -140,11 +156,11 @@ def test_unicode_links(self):\n         # eventually plays well with transaction machinery.\n         # Add bad link, should not raise exception and there should not\n         # be any references added.\n-        self._set_text(\n+        set_text(\n             doc1,\n             \'<a href="\xc3\xb6?foo=bar&baz=bam">bug</a>\')\n \n-        self.assertEqual([l for l in getOutgoingLinks(doc1)], [])\n+        self.assertEqual([link for link in getOutgoingLinks(doc1)], [])\n \n     def test_reference_orthogonality(self):\n         doc = self.portal.doc1\n@@ -152,10 +168,10 @@ def test_reference_orthogonality(self):\n         tag = img.restrictedTraverse(\'@@images\').tag()\n \n         # This tests the behavior when other references already exist.\n-        self.assertEqual([l for l in getOutgoingLinks(doc)], [])\n-        self.assertEqual([l for l in getIncomingLinks(doc)], [])\n-        self.assertEqual([l for l in getOutgoingLinks(img)], [])\n-        self.assertEqual([l for l in getOutgoingLinks(img)], [])\n+        self.assertEqual([link for link in getOutgoingLinks(doc)], [])\n+        self.assertEqual([link for link in getIncomingLinks(doc)], [])\n+        self.assertEqual([link for link in getOutgoingLinks(img)], [])\n+        self.assertEqual([link for link in getOutgoingLinks(img)], [])\n \n         # Then establish a reference between the document and image as\n         # a related item:\n@@ -164,9 +180,9 @@ def test_reference_orthogonality(self):\n \n         # Next edit the document body and insert a link to the image,\n         # which should trigger the creation of a link integrity reference:\n-        self._set_text(doc, tag)\n+        set_text(doc, tag)\n \n-        self.assertEqual([l.to_object for l in getOutgoingLinks(doc)], [img])\n+        self.assertEqual([link.to_object for link in getOutgoingLinks(doc)], [img])\n \n         # And the related item reference remains in place:\n         self.assertEqual(self._get_related_items(doc), [img, ])\n@@ -174,8 +190,8 @@ def test_reference_orthogonality(self):\n         # Finally, edit the document body again, this time removing the\n         # link to the image, which should trigger the removal of the\n         # link integrity reference:\n-        self._set_text(doc, \'where did my link go?\')\n-        self.assertEqual([l.to_object for l in getOutgoingLinks(doc)], [])\n+        set_text(doc, \'where did my link go?\')\n+        self.assertEqual([link.to_object for link in getOutgoingLinks(doc)], [])\n \n         # And again the related item reference remains in place:\n         self.assertEqual(self._get_related_items(doc), [img, ])\ndiff --git a/plone/app/linkintegrity/tests/utils.py b/plone/app/linkintegrity/tests/utils.py\nnew file mode 100644\nindex 0000000..895e85f\n--- /dev/null\n+++ b/plone/app/linkintegrity/tests/utils.py\n@@ -0,0 +1,7 @@\n+from plone.app.textfield import RichTextValue\n+from zope.lifecycleevent import modified\n+\n+\n+def set_text(obj, text):\n+    obj.text = RichTextValue(text)\n+    modified(obj)\n'

