Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2017-08-28T22:24:30+02:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.app.iterate/commit/ca68a98c5bb4d013c89b9d05220b0ac087d04c1b

Don't depend on AT (part 3)

Files changed:
M CHANGES.rst
M plone/app/iterate/copier.py

diff --git a/CHANGES.rst b/CHANGES.rst
index fae5b69..1c2dcaf 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -14,7 +14,8 @@ New features:
 
 Bug fixes:
 
-- *add item here*
+- Do not depend on Products.Archetypes anymore. (part 3)
+  [tomgross]
 
 
 3.3.4 (2017-08-27)
diff --git a/plone/app/iterate/copier.py b/plone/app/iterate/copier.py
index e7cbb4d..ae73c8b 100644
--- a/plone/app/iterate/copier.py
+++ b/plone/app/iterate/copier.py
@@ -29,7 +29,6 @@
 from Acquisition import aq_inner
 from Acquisition import aq_parent
 from interfaces import CheckinException
-from Products.Archetypes.Referenceable import Referenceable
 from Products.CMFCore import interfaces as cmf_ifaces
 from Products.CMFCore.utils import getToolByName
 from Products.DCWorkflow.DCWorkflow import DCWorkflowDefinition
@@ -42,6 +41,14 @@
 from zope.lifecycleevent import ObjectMovedEvent
 
 import interfaces
+import pkg_resources
+
+try:
+    pkg_resources.get_distribution('Products.Archetypes')
+    from Products.Archetypes.Referenceable import Referenceable
+    HAS_AT = True
+except pkg_resources.NotFound:
+    HAS_AT = False
 
 
 @interface.implementer(interfaces.IObjectCopier)
@@ -137,8 +144,9 @@ def _replaceBaseline(self, baseline):
                 baseline_container._setProperty('default_page', baseline_id)
 
         # reregister our references with the reference machinery after moving
-        Referenceable.manage_afterAdd(new_baseline, new_baseline,
-                                      baseline_container)
+        if HAS_AT:
+            Referenceable.manage_afterAdd(new_baseline, new_baseline,
+                                          baseline_container)
 
         notify(ObjectMovedEvent(new_baseline, wc_container,
                                 wc_id, baseline_container, baseline_id))


Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2017-08-31T11:57:40+02:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.app.iterate/commit/64c3506d49180429d21dc49c2c01bf092eb8db9c

Refactor copier base class to handle AT/DX better

Files changed:
M plone/app/iterate/base.py
M plone/app/iterate/copier.py
M plone/app/iterate/dexterity/copier.py

diff --git a/plone/app/iterate/base.py b/plone/app/iterate/base.py
index c2e895b..7ad92a3 100644
--- a/plone/app/iterate/base.py
+++ b/plone/app/iterate/base.py
@@ -31,9 +31,13 @@
 from plone.app.iterate.event import BeforeCheckoutEvent
 from plone.app.iterate.event import CancelCheckoutEvent
 from plone.app.iterate.event import CheckoutEvent
+from plone.app.iterate import interfaces
 from plone.app.iterate.interfaces import ICheckinCheckoutPolicy
 from plone.app.iterate.interfaces import IObjectCopier
 from plone.app.iterate.util import get_storage
+from Products.CMFCore import interfaces as cmf_ifaces
+from Products.CMFCore.utils import getToolByName
+from zope import component
 from zope.component import queryAdapter
 from zope.event import notify
 from zope.interface import implementer
@@ -97,3 +101,60 @@ def getWorkingCopy(self):
 
     def getProperties(self, obj, default=None):
         return get_storage(obj, default=default)
+
+
+@implementer(interfaces.IObjectCopier)
+@component.adapter(interfaces.IIterateAware)
+class BaseContentCopier(object):
+
+    def __init__(self, context):
+        self.context = context
+
+    def _recursivelyReattachUIDs(self, baseline, new_baseline):
+        original_refs = len(new_baseline.getRefs())
+        original_back_refs = len(new_baseline.getBRefs())
+        new_baseline._setUID(baseline.UID())
+        new_refs = len(new_baseline.getRefs())
+        new_back_refs = len(new_baseline.getBRefs())
+        if original_refs != new_refs:
+            self._removeDuplicateReferences(new_baseline, backrefs=False)
+        if original_back_refs != new_back_refs:
+            self._removeDuplicateReferences(new_baseline, backrefs=True)
+
+        if cmf_ifaces.IFolderish.providedBy(baseline):
+            new_ids = new_baseline.contentIds()
+            for child in baseline.contentValues():
+                if child.getId() in new_ids:
+                    self._recursivelyReattachUIDs(
+                        child, new_baseline[child.getId()])
+
+    def _removeDuplicateReferences(self, item, backrefs=False):
+        # Remove duplicate (back) references from this item.
+        reference_tool = getToolByName(self.context, 'reference_catalog')
+        if backrefs:
+            ref_func = reference_tool.getBackReferences
+        else:
+            ref_func = reference_tool.getReferences
+        try:
+            # Plone 4.1 or later
+            brains = ref_func(item, objects=False)
+        except TypeError:
+            # Plone 4.0 or earlier.  Nothing to fix here
+            return
+        for brain in brains:
+            if brain.getObject() is None:
+                reference_tool.uncatalog_object(brain.getPath())
+
+    #################################
+    # Checkout Support Methods
+
+    def _copyBaseline(self, container):
+        # copy the context from source to the target container
+        source_container = aq_parent(aq_inner(self.context))
+        clipboard = source_container.manage_copyObjects([self.context.getId()])
+        result = container.manage_pasteObjects(clipboard)
+
+        # get a reference to the working copy
+        target_id = result[0]['new_id']
+        target = container._getOb(target_id)
+        return target
\ No newline at end of file
diff --git a/plone/app/iterate/copier.py b/plone/app/iterate/copier.py
index ae73c8b..6dc943a 100644
--- a/plone/app/iterate/copier.py
+++ b/plone/app/iterate/copier.py
@@ -28,8 +28,10 @@
 from Acquisition import aq_base
 from Acquisition import aq_inner
 from Acquisition import aq_parent
-from interfaces import CheckinException
-from Products.CMFCore import interfaces as cmf_ifaces
+from plone.app.iterate import interfaces
+from plone.app.iterate.interfaces import CheckinException
+from plone.app.iterate.base import BaseContentCopier
+from Products.Archetypes.Referenceable import Referenceable
 from Products.CMFCore.utils import getToolByName
 from Products.DCWorkflow.DCWorkflow import DCWorkflowDefinition
 from relation import WorkingCopyRelation
@@ -40,23 +42,11 @@
 from zope.event import notify
 from zope.lifecycleevent import ObjectMovedEvent
 
-import interfaces
-import pkg_resources
-
-try:
-    pkg_resources.get_distribution('Products.Archetypes')
-    from Products.Archetypes.Referenceable import Referenceable
-    HAS_AT = True
-except pkg_resources.NotFound:
-    HAS_AT = False
-
 
 @interface.implementer(interfaces.IObjectCopier)
 @component.adapter(interfaces.IIterateAware)
-class ContentCopier(object):
-
-    def __init__(self, context):
-        self.context = context
+class ContentCopier(BaseContentCopier):
+    """ Content copier for Archetypes """
 
     def copyTo(self, container):
         wc = self._copyBaseline(container)
@@ -144,9 +134,8 @@ def _replaceBaseline(self, baseline):
                 baseline_container._setProperty('default_page', baseline_id)
 
         # reregister our references with the reference machinery after moving
-        if HAS_AT:
-            Referenceable.manage_afterAdd(new_baseline, new_baseline,
-                                          baseline_container)
+        Referenceable.manage_afterAdd(new_baseline, new_baseline,
+                                      baseline_container)
 
         notify(ObjectMovedEvent(new_baseline, wc_container,
                                 wc_id, baseline_container, baseline_id))
@@ -183,41 +172,6 @@ def _reassembleWorkingCopy(self, new_baseline, baseline):
 
         return new_baseline
 
-    def _recursivelyReattachUIDs(self, baseline, new_baseline):
-        original_refs = len(new_baseline.getRefs())
-        original_back_refs = len(new_baseline.getBRefs())
-        new_baseline._setUID(baseline.UID())
-        new_refs = len(new_baseline.getRefs())
-        new_back_refs = len(new_baseline.getBRefs())
-        if original_refs != new_refs:
-            self._removeDuplicateReferences(new_baseline, backrefs=False)
-        if original_back_refs != new_back_refs:
-            self._removeDuplicateReferences(new_baseline, backrefs=True)
-
-        if cmf_ifaces.IFolderish.providedBy(baseline):
-            new_ids = new_baseline.contentIds()
-            for child in baseline.contentValues():
-                if child.getId() in new_ids:
-                    self._recursivelyReattachUIDs(
-                        child, new_baseline[child.getId()])
-
-    def _removeDuplicateReferences(self, item, backrefs=False):
-        # Remove duplicate (back) references from this item.
-        reference_tool = getToolByName(self.context, 'reference_catalog')
-        if backrefs:
-            ref_func = reference_tool.getBackReferences
-        else:
-            ref_func = reference_tool.getReferences
-        try:
-            # Plone 4.1 or later
-            brains = ref_func(item, objects=False)
-        except TypeError:
-            # Plone 4.0 or earlier.  Nothing to fix here
-            return
-        for brain in brains:
-            if brain.getObject() is None:
-                reference_tool.uncatalog_object(brain.getPath())
-
     def _deleteWorkingCopyRelation(self):
         # delete the wc reference keeping a reference to it for its annotations
         refs = self.context.getReferenceImpl(WorkingCopyRelation.relationship)
@@ -228,17 +182,6 @@ def _deleteWorkingCopyRelation(self):
     #################################
     # Checkout Support Methods
 
-    def _copyBaseline(self, container):
-        # copy the context from source to the target container
-        source_container = aq_parent(aq_inner(self.context))
-        clipboard = source_container.manage_copyObjects([self.context.getId()])
-        result = container.manage_pasteObjects(clipboard)
-
-        # get a reference to the working copy
-        target_id = result[0]['new_id']
-        target = container._getOb(target_id)
-        return target
-
     def _handleReferences(self, baseline, wc, mode, wc_ref):
 
         annotations = IAnnotations(wc_ref)
diff --git a/plone/app/iterate/dexterity/copier.py b/plone/app/iterate/dexterity/copier.py
index 19bec8a..2639bf8 100644
--- a/plone/app/iterate/dexterity/copier.py
+++ b/plone/app/iterate/dexterity/copier.py
@@ -1,7 +1,7 @@
 # -*- coding: utf-8 -*-
 from Acquisition import aq_inner
 from Acquisition import aq_parent
-from plone.app.iterate import copier
+from plone.app.iterate.base import BaseContentCopier
 from plone.app.iterate import interfaces
 from plone.app.iterate.dexterity import ITERATE_RELATION_NAME
 from plone.app.iterate.dexterity.relation import StagingRelationValue
@@ -15,13 +15,11 @@
 from zope import component
 from zope.annotation.interfaces import IAnnotations
 from zope.event import notify
-from zope.interface import implementer
 from zope.intid.interfaces import IIntIds
 from zope.schema import getFieldsInOrder
 
 
-@implementer(interfaces.IObjectCopier)
-class ContentCopier(copier.ContentCopier):
+class ContentCopier(BaseContentCopier):
 
     def copyTo(self, container):
         context = aq_inner(self.context)
@@ -32,8 +30,6 @@ def copyTo(self, container):
         # create a relation
         relation = StagingRelationValue(wc_id)
         event._setRelation(context, ITERATE_RELATION_NAME, relation)
-        #
-        self._handleReferences(self.context, wc, 'checkout', relation)
         return wc, relation
 
     def merge(self):
@@ -41,10 +37,6 @@ def merge(self):
 
         # delete the working copy reference to the baseline
         wc_ref = self._deleteWorkingCopyRelation()
-
-        # reassemble references on the new baseline
-        self._handleReferences(baseline, self.context, 'checkin', wc_ref)
-
         # move the working copy to the baseline container, deleting the
         # baseline
         new_baseline = self._replaceBaseline(baseline)


Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2017-08-31T12:01:53+02:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/plone.app.iterate/commit/2cb22830d6d1572ded07e33736f854f85d276f65

Fix findings of static code analysis

Files changed:
M plone/app/iterate/base.py
M plone/app/iterate/copier.py
M plone/app/iterate/dexterity/copier.py
M plone/app/iterate/tests/test_iterate.py

diff --git a/plone/app/iterate/base.py b/plone/app/iterate/base.py
index 7ad92a3..d22c6b7 100644
--- a/plone/app/iterate/base.py
+++ b/plone/app/iterate/base.py
@@ -28,10 +28,10 @@
 
 from Acquisition import aq_inner
 from Acquisition import aq_parent
+from plone.app.iterate import interfaces
 from plone.app.iterate.event import BeforeCheckoutEvent
 from plone.app.iterate.event import CancelCheckoutEvent
 from plone.app.iterate.event import CheckoutEvent
-from plone.app.iterate import interfaces
 from plone.app.iterate.interfaces import ICheckinCheckoutPolicy
 from plone.app.iterate.interfaces import IObjectCopier
 from plone.app.iterate.util import get_storage
diff --git a/plone/app/iterate/copier.py b/plone/app/iterate/copier.py
index 6dc943a..acd0134 100644
--- a/plone/app/iterate/copier.py
+++ b/plone/app/iterate/copier.py
@@ -29,8 +29,8 @@
 from Acquisition import aq_inner
 from Acquisition import aq_parent
 from plone.app.iterate import interfaces
-from plone.app.iterate.interfaces import CheckinException
 from plone.app.iterate.base import BaseContentCopier
+from plone.app.iterate.interfaces import CheckinException
 from Products.Archetypes.Referenceable import Referenceable
 from Products.CMFCore.utils import getToolByName
 from Products.DCWorkflow.DCWorkflow import DCWorkflowDefinition
diff --git a/plone/app/iterate/dexterity/copier.py b/plone/app/iterate/dexterity/copier.py
index 2639bf8..d8a474f 100644
--- a/plone/app/iterate/dexterity/copier.py
+++ b/plone/app/iterate/dexterity/copier.py
@@ -36,7 +36,7 @@ def merge(self):
         baseline = self._getBaseline()
 
         # delete the working copy reference to the baseline
-        wc_ref = self._deleteWorkingCopyRelation()
+        self._deleteWorkingCopyRelation()
         # move the working copy to the baseline container, deleting the
         # baseline
         new_baseline = self._replaceBaseline(baseline)
diff --git a/plone/app/iterate/tests/test_iterate.py b/plone/app/iterate/tests/test_iterate.py
index 0b9dde3..b8fccc9 100644
--- a/plone/app/iterate/tests/test_iterate.py
+++ b/plone/app/iterate/tests/test_iterate.py
@@ -21,7 +21,6 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ##################################################################
 """
-$Id: test_iterate.py 1595 2006-08-24 00:15:21Z hazmat $
 """
 
 from AccessControl import getSecurityManager
@@ -283,9 +282,9 @@ def test_checkinObjectLinkedInParentsRichTextField(self):
         subobject_uid = subobject.UID()
 
         # link (by uid) the subobject in it's parent's rich text field
-        link_html = '<a class="internal-link" href="resolveuid/%s">' \
+        link_html = '<a class="internal-link" href="resolveuid/{0}">' \
             'Link to subobject</a>'
-        rich_text_folder.setText(link_html % subobject_uid)
+        rich_text_folder.setText(link_html.format(subobject_uid))
 
         # try to checkout and checkin the subobject
         wc = ICheckinCheckoutPolicy(subobject).checkout(rich_text_folder)


Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2017-09-07T08:47:01+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.iterate/commit/db4b64ab27462642ed7b9fb5058e0751a09f8185

Merge pull request #52 from plone/no_at_dependency

Don't depend on AT (part 3)

Files changed:
M CHANGES.rst
M plone/app/iterate/base.py
M plone/app/iterate/copier.py
M plone/app/iterate/dexterity/copier.py
M plone/app/iterate/tests/test_iterate.py

diff --git a/CHANGES.rst b/CHANGES.rst
index fae5b69..1c2dcaf 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -14,7 +14,8 @@ New features:
 
 Bug fixes:
 
-- *add item here*
+- Do not depend on Products.Archetypes anymore. (part 3)
+  [tomgross]
 
 
 3.3.4 (2017-08-27)
diff --git a/plone/app/iterate/base.py b/plone/app/iterate/base.py
index c2e895b..d22c6b7 100644
--- a/plone/app/iterate/base.py
+++ b/plone/app/iterate/base.py
@@ -28,12 +28,16 @@
 
 from Acquisition import aq_inner
 from Acquisition import aq_parent
+from plone.app.iterate import interfaces
 from plone.app.iterate.event import BeforeCheckoutEvent
 from plone.app.iterate.event import CancelCheckoutEvent
 from plone.app.iterate.event import CheckoutEvent
 from plone.app.iterate.interfaces import ICheckinCheckoutPolicy
 from plone.app.iterate.interfaces import IObjectCopier
 from plone.app.iterate.util import get_storage
+from Products.CMFCore import interfaces as cmf_ifaces
+from Products.CMFCore.utils import getToolByName
+from zope import component
 from zope.component import queryAdapter
 from zope.event import notify
 from zope.interface import implementer
@@ -97,3 +101,60 @@ def getWorkingCopy(self):
 
     def getProperties(self, obj, default=None):
         return get_storage(obj, default=default)
+
+
+@implementer(interfaces.IObjectCopier)
+@component.adapter(interfaces.IIterateAware)
+class BaseContentCopier(object):
+
+    def __init__(self, context):
+        self.context = context
+
+    def _recursivelyReattachUIDs(self, baseline, new_baseline):
+        original_refs = len(new_baseline.getRefs())
+        original_back_refs = len(new_baseline.getBRefs())
+        new_baseline._setUID(baseline.UID())
+        new_refs = len(new_baseline.getRefs())
+        new_back_refs = len(new_baseline.getBRefs())
+        if original_refs != new_refs:
+            self._removeDuplicateReferences(new_baseline, backrefs=False)
+        if original_back_refs != new_back_refs:
+            self._removeDuplicateReferences(new_baseline, backrefs=True)
+
+        if cmf_ifaces.IFolderish.providedBy(baseline):
+            new_ids = new_baseline.contentIds()
+            for child in baseline.contentValues():
+                if child.getId() in new_ids:
+                    self._recursivelyReattachUIDs(
+                        child, new_baseline[child.getId()])
+
+    def _removeDuplicateReferences(self, item, backrefs=False):
+        # Remove duplicate (back) references from this item.
+        reference_tool = getToolByName(self.context, 'reference_catalog')
+        if backrefs:
+            ref_func = reference_tool.getBackReferences
+        else:
+            ref_func = reference_tool.getReferences
+        try:
+            # Plone 4.1 or later
+            brains = ref_func(item, objects=False)
+        except TypeError:
+            # Plone 4.0 or earlier.  Nothing to fix here
+            return
+        for brain in brains:
+            if brain.getObject() is None:
+                reference_tool.uncatalog_object(brain.getPath())
+
+    #################################
+    # Checkout Support Methods
+
+    def _copyBaseline(self, container):
+        # copy the context from source to the target container
+        source_container = aq_parent(aq_inner(self.context))
+        clipboard = source_container.manage_copyObjects([self.context.getId()])
+        result = container.manage_pasteObjects(clipboard)
+
+        # get a reference to the working copy
+        target_id = result[0]['new_id']
+        target = container._getOb(target_id)
+        return target
\ No newline at end of file
diff --git a/plone/app/iterate/copier.py b/plone/app/iterate/copier.py
index e7cbb4d..acd0134 100644
--- a/plone/app/iterate/copier.py
+++ b/plone/app/iterate/copier.py
@@ -28,9 +28,10 @@
 from Acquisition import aq_base
 from Acquisition import aq_inner
 from Acquisition import aq_parent
-from interfaces import CheckinException
+from plone.app.iterate import interfaces
+from plone.app.iterate.base import BaseContentCopier
+from plone.app.iterate.interfaces import CheckinException
 from Products.Archetypes.Referenceable import Referenceable
-from Products.CMFCore import interfaces as cmf_ifaces
 from Products.CMFCore.utils import getToolByName
 from Products.DCWorkflow.DCWorkflow import DCWorkflowDefinition
 from relation import WorkingCopyRelation
@@ -41,15 +42,11 @@
 from zope.event import notify
 from zope.lifecycleevent import ObjectMovedEvent
 
-import interfaces
-
 
 @interface.implementer(interfaces.IObjectCopier)
 @component.adapter(interfaces.IIterateAware)
-class ContentCopier(object):
-
-    def __init__(self, context):
-        self.context = context
+class ContentCopier(BaseContentCopier):
+    """ Content copier for Archetypes """
 
     def copyTo(self, container):
         wc = self._copyBaseline(container)
@@ -175,41 +172,6 @@ def _reassembleWorkingCopy(self, new_baseline, baseline):
 
         return new_baseline
 
-    def _recursivelyReattachUIDs(self, baseline, new_baseline):
-        original_refs = len(new_baseline.getRefs())
-        original_back_refs = len(new_baseline.getBRefs())
-        new_baseline._setUID(baseline.UID())
-        new_refs = len(new_baseline.getRefs())
-        new_back_refs = len(new_baseline.getBRefs())
-        if original_refs != new_refs:
-            self._removeDuplicateReferences(new_baseline, backrefs=False)
-        if original_back_refs != new_back_refs:
-            self._removeDuplicateReferences(new_baseline, backrefs=True)
-
-        if cmf_ifaces.IFolderish.providedBy(baseline):
-            new_ids = new_baseline.contentIds()
-            for child in baseline.contentValues():
-                if child.getId() in new_ids:
-                    self._recursivelyReattachUIDs(
-                        child, new_baseline[child.getId()])
-
-    def _removeDuplicateReferences(self, item, backrefs=False):
-        # Remove duplicate (back) references from this item.
-        reference_tool = getToolByName(self.context, 'reference_catalog')
-        if backrefs:
-            ref_func = reference_tool.getBackReferences
-        else:
-            ref_func = reference_tool.getReferences
-        try:
-            # Plone 4.1 or later
-            brains = ref_func(item, objects=False)
-        except TypeError:
-            # Plone 4.0 or earlier.  Nothing to fix here
-            return
-        for brain in brains:
-            if brain.getObject() is None:
-                reference_tool.uncatalog_object(brain.getPath())
-
     def _deleteWorkingCopyRelation(self):
         # delete the wc reference keeping a reference to it for its annotations
         refs = self.context.getReferenceImpl(WorkingCopyRelation.relationship)
@@ -220,17 +182,6 @@ def _deleteWorkingCopyRelation(self):
     #################################
     # Checkout Support Methods
 
-    def _copyBaseline(self, container):
-        # copy the context from source to the target container
-        source_container = aq_parent(aq_inner(self.context))
-        clipboard = source_container.manage_copyObjects([self.context.getId()])
-        result = container.manage_pasteObjects(clipboard)
-
-        # get a reference to the working copy
-        target_id = result[0]['new_id']
-        target = container._getOb(target_id)
-        return target
-
     def _handleReferences(self, baseline, wc, mode, wc_ref):
 
         annotations = IAnnotations(wc_ref)
diff --git a/plone/app/iterate/dexterity/copier.py b/plone/app/iterate/dexterity/copier.py
index 19bec8a..d8a474f 100644
--- a/plone/app/iterate/dexterity/copier.py
+++ b/plone/app/iterate/dexterity/copier.py
@@ -1,7 +1,7 @@
 # -*- coding: utf-8 -*-
 from Acquisition import aq_inner
 from Acquisition import aq_parent
-from plone.app.iterate import copier
+from plone.app.iterate.base import BaseContentCopier
 from plone.app.iterate import interfaces
 from plone.app.iterate.dexterity import ITERATE_RELATION_NAME
 from plone.app.iterate.dexterity.relation import StagingRelationValue
@@ -15,13 +15,11 @@
 from zope import component
 from zope.annotation.interfaces import IAnnotations
 from zope.event import notify
-from zope.interface import implementer
 from zope.intid.interfaces import IIntIds
 from zope.schema import getFieldsInOrder
 
 
-@implementer(interfaces.IObjectCopier)
-class ContentCopier(copier.ContentCopier):
+class ContentCopier(BaseContentCopier):
 
     def copyTo(self, container):
         context = aq_inner(self.context)
@@ -32,19 +30,13 @@ def copyTo(self, container):
         # create a relation
         relation = StagingRelationValue(wc_id)
         event._setRelation(context, ITERATE_RELATION_NAME, relation)
-        #
-        self._handleReferences(self.context, wc, 'checkout', relation)
         return wc, relation
 
     def merge(self):
         baseline = self._getBaseline()
 
         # delete the working copy reference to the baseline
-        wc_ref = self._deleteWorkingCopyRelation()
-
-        # reassemble references on the new baseline
-        self._handleReferences(baseline, self.context, 'checkin', wc_ref)
-
+        self._deleteWorkingCopyRelation()
         # move the working copy to the baseline container, deleting the
         # baseline
         new_baseline = self._replaceBaseline(baseline)
diff --git a/plone/app/iterate/tests/test_iterate.py b/plone/app/iterate/tests/test_iterate.py
index 0b9dde3..b8fccc9 100644
--- a/plone/app/iterate/tests/test_iterate.py
+++ b/plone/app/iterate/tests/test_iterate.py
@@ -21,7 +21,6 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ##################################################################
 """
-$Id: test_iterate.py 1595 2006-08-24 00:15:21Z hazmat $
 """
 
 from AccessControl import getSecurityManager
@@ -283,9 +282,9 @@ def test_checkinObjectLinkedInParentsRichTextField(self):
         subobject_uid = subobject.UID()
 
         # link (by uid) the subobject in it's parent's rich text field
-        link_html = '<a class="internal-link" href="resolveuid/%s">' \
+        link_html = '<a class="internal-link" href="resolveuid/{0}">' \
             'Link to subobject</a>'
-        rich_text_folder.setText(link_html % subobject_uid)
+        rich_text_folder.setText(link_html.format(subobject_uid))
 
         # try to checkout and checkin the subobject
         wc = ICheckinCheckoutPolicy(subobject).checkout(rich_text_folder)


