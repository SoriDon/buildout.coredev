Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2021-10-30T18:22:10+02:00
Author: Peter Holzer (agitator) <peter.holzer@agitator.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/29f00791e640179de1ccd50f8f2aad3c3a2f8f11

Remove atcontenttypes dependencies and migration and keep BaseClassMigratorForm

Files changed:
A plone/app/contenttypes/browser/migration.py
M docs/README.rst
M plone/app/contenttypes/browser/configure.zcml
M plone/app/contenttypes/configure.zcml
M plone/app/contenttypes/tests/test_content_profile.py
M plone/app/contenttypes/utils.py
M setup.py
D plone/app/contenttypes/migration/__init__.py
D plone/app/contenttypes/migration/atct_migrator.pt
D plone/app/contenttypes/migration/atct_migrator_results.pt
D plone/app/contenttypes/migration/browser.py
D plone/app/contenttypes/migration/configure.zcml
D plone/app/contenttypes/migration/custom_migration.pt
D plone/app/contenttypes/migration/custom_migration.py
D plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
D plone/app/contenttypes/migration/dxmigration.py
D plone/app/contenttypes/migration/field_migrators.py
D plone/app/contenttypes/migration/migration.py
D plone/app/contenttypes/migration/migrator.css
D plone/app/contenttypes/migration/pac_installer.pt
D plone/app/contenttypes/migration/patches.py
D plone/app/contenttypes/migration/topics.py
D plone/app/contenttypes/migration/utils.py
D plone/app/contenttypes/migration/vocabularies.py
D plone/app/contenttypes/tests/test_migration.py
D plone/app/contenttypes/tests/test_migration_browser.py
D plone/app/contenttypes/tests/test_migration_custom.py
D plone/app/contenttypes/tests/test_migration_topic.py
D plone/app/contenttypes/tests/test_upgrades_migrate_to_pa_event.py

b'diff --git a/docs/README.rst b/docs/README.rst\nindex 7a548698..646a4ed3 100644\n--- a/docs/README.rst\n+++ b/docs/README.rst\n@@ -20,7 +20,7 @@ plone.app.contenttypes documentation\n Introduction\n ------------\n \n-plone.app.contenttypes provides default content types for Plone based on Dexterity. It replaces ``Products.ATContentTypes`` and provides the default-types in Plone 5. It can be used as an add-on in Plone 4.x.\n+plone.app.contenttypes provides default content types for Plone based on Dexterity.\n \n It contains the following types:\n \n@@ -33,383 +33,21 @@ It contains the following types:\n * Link\n * News Item\n \n-The main difference from a users perspective is that these types are editable and extendable through-the-web. This means you can add or remove fields and behaviors using the control-panel "Dexterity Content Types" (``/@@dexterity-types``).\n-\n-**Warning: Using plone.app.contenttypes on a site with existing Archetypes-based content requires migrating the sites content. Please see the chapter "Migration".**\n+These types are editable and extendable through-the-web and you can add or remove fields and behaviors using the control-panel "Dexterity Content Types" (``/@@dexterity-types``).\n \n \n Compatibility\n -------------\n \n-The versions 1.2.x (build from the master-branch) are used in Plone 5.\n-\n-Version 1.1b5 and later are tested with Plone 4.3.x. The versions build from the branch 1.1.x will stay compatible with Plone 4.3.x.\n+Version 3 is build for Plone 6 only.\n \n-For support of Plone 4.1 and 4.2 please use versions 1.0.x. Please note that they do not provide the full functionality.\n+Check previous major releases if you need to support older versions of Plone.\n \n \n Installation\n ------------\n \n-This package is included in Plone 5 and does not need installation.\n-\n-To use plone.app.contenttypes in Plone 4.x add this line in the eggs section of your ``buildout.cfg``\n-\n-.. code:: ini\n-\n-    eggs =\n-        ...\n-        plone.app.contenttypes\n-\n-If you have a Plone site with mixed Archetypes and Dexterity content use the extra requirement ``atrefs``.\n-\n-.. code:: ini\n-\n-    eggs =\n-        ...\n-        plone.app.contenttypes [atrefs]\n-\n-This will also install the package `plone.app.referenceablebehavior <https://pypi.python.org/pypi/plone.app.referenceablebehavior>`_ that allows you to reference dexterity-based content from archetypes-based content. You will have to enable the behavior ``plone.app.referenceablebehavior.referenceable.IReferenceable`` for all types that need to be referenced by Archetypes-content.\n-\n-\n-What happens to existing content?\n----------------------------------\n-\n-If you install plone.app.contenttypes in a existing site all Archetypes-based content of the default types still exists and can be viewed but can\'t be edited. On installation plone.app.contenttypes removes the type-definitions for the old default-types like this:\n-\n-.. code:: xml\n-\n-    <object name="Document" remove="True" />\n-\n-They are then replaced by new Definitions:\n-\n-.. code:: xml\n-\n-    <object meta_type="Dexterity FTI" name="Document" />\n-\n-To make the existing content editable again you need to migrate it to Dexterity (please see the section on migration) or uninstall plone.app.contenttypes (see the section on uninstalling).\n-\n-Archetypes-based content provided by add-ons (e.g. Products.PloneFormGen) will still work since only the default-types are replaced.\n-\n-If you install plone.app.contenttypes on a fresh site (i.e. when no content has been edited or added) the usual default-content (Events, News, Members...) will be created as dexterity-content.\n-\n-\n-Uninstalling\n-------------\n-\n-Uninstalling the default-types is not officially supported in Plone 5. If you really want to switch back to Archetypes-based types you have to to the following:\n-\n-* Go to the ZMI\n-* In portal_types delete the default-types\n-* In portal_setup navigate to the tab \'import\', select the profile \'Archetypes Content Types for Plone\' and install all steps including dependencies.\n-\n-Any content you created based on plone.app.contenttypes will no longer be editable until you reinstall plone.app.contenttypes.\n-\n-\n-Dependencies\n-------------\n-\n-* ``plone.app.dexterity >= 2.0.7``. Dexterity is shipped with Plone 4.3.x. Version pins for Dexterity are included in Plone 4.2.x. For Plone 4.1.x you need to pin the right version for Dexterity in your buildout. See `Installing Dexterity on older versions of Plone <http://docs.plone.org/external/plone.app.dexterity/docs/install.html#installing-dexterity-on-older-versions-of-plone>`_.\n-\n-* ``plone.dexterity >= 2.2.1``. Olders version of plone.dexterity break the rss-views because plone.app.contenttypes uses behaviors for the richtext-fields.\n-\n-* ``plone.app.event >= 1.1.4``. This provides the behaviors used for the event-type.\n-\n-* ``plone.app.portlets >= 2.5a1``. In older version the event-portlet will not work with the new event-type.\n-\n-These are the version-pins for Plone 4.3.4:\n-\n-.. code:: ini\n-\n-    [buildout]\n-    versions = versions\n-\n-    [versions]\n-    plone.app.event = 1.1.4\n-\n-Plone 4.3.3 also needs ``plone.app.portlets = 2.5.2``\n-\n-Plone-versions before 4.3.3 need to pin more packages:\n-\n-.. code:: ini\n-\n-    [buildout]\n-    versions = versions\n-\n-    [versions]\n-    plone.dexterity = 2.2.1\n-    plone.app.dexterity = 2.0.11\n-    plone.schemaeditor = 1.3.5\n-    plone.app.event = 1.1b1\n-    plone.app.portlets = 2.5.1\n-\n-For migrations to work you need at least ``Products.contentmigration = 2.1.9`` and ``plone.app.intid`` (part of Plone since Plone 4.1.0).\n-\n-\n-Migration\n----------\n-\n-\n-Migrating the default-types\n-^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-To migrate your existing content from Archetypes to Dexterity use the form at ``/@@atct_migrator``.\n-\n-\n-Migrating Archetypes-based default-types content to plone.app.contenttypes\n-``````````````````````````````````````````````````````````````````````````\n-\n-`plone.app.contenttypes <https://pypi.python.org/pypi/plone.app.contenttypes/>`_ can migrate the following archetypes-based default types:\n-\n-* Document\n-* Event\n-* File\n-* Folder\n-* Image\n-* Link\n-* News Item\n-* Collection\n-* Topic (old Collections)\n-\n-The following non-default types will also be migrated:\n-\n-* The AT-based Event-type provided by plone.app.event\n-* The DX-based Event-type provided by plone.app.event\n-* The Event-type provided by plone.app.contenttypes until version 1.0\n-* News Items with blobs (provided by https://github.com/plone/plone.app.blob/pull/2)\n-* Files and Images without blobs\n-\n-The migration tries to keep most features (including portlets, comments, contentrules, local roles and local workflows).\n-\n-**Warning:** Versions of content are not migrated. During migration you will lose all old revisions.\n-\n-\n-Migrating only certain types\n-````````````````````````````\n-\n-There is also a view ``/@@pac_installer`` that allows you to install plone.app.contenttypes without replacing those archetypes-types with the dexterity-types of which there are existing objects in the site. Afterwards it redirects to the migration-form and only the types that you chose to migrate are installed. This allows you to keep certain types as archetypes while migrating others to dexterity (for example if you did heavy customizations of these types and do not have the time to reimplement these features in dexterity).\n-\n-\n-Migrating Topics\n-````````````````\n-\n-Topics are migrated to Collections. However, the old type Topic had support for Subtopics, a feature that does not exit in Collections. Subtopics are nested Topics that inherited search terms from their parents. Since Collections are not folderish (i.e. they cannot contain content) Subtopics cannot be migrated unless Collections are made folderish (i.e. that they can contain content). Also the feature that search terms can be inherited from parents does not exist for Collections.\n-\n-The migration-form will warn you if you have subtopics in your site and your Collections are not folderish. You then have several options:\n-\n-1. You can delete all Subtopics before migrating and achieve their functionality in another way (e.g. using eea.facetednavigation).\n-2. You can choose to not migrate Topics by not selecting them. This will keep your old Topics functional. You can still add new Collections.\n-3. You can modify Collections to be folderish or create your own folderish content-type.   That type would need a base-class that inherits from ``plone.dexterity.content.Container`` instead of ``plone.dexterity.content.Item``:\n-\n-   .. code-block:: python\n-\n-      from plone.app.contenttypes.behaviors.collection import ICollection\n-      from plone.dexterity.content import Container\n-      from zope.interface import implementer\n-\n-      @implementer(ICollection)\n-      class FolderishCollection(Container):\n-          pass\n-\n-   You can either use a new Collection type or simply modify the default type to use this new base-class by overriding the klass-attribute of the default Collection. To override add a ``Collection.xml`` in your own package:\n-\n-   .. code-block:: xml\n-\n-      <?xml version="1.0"?>\n-      <object name="Collection" meta_type="Dexterity FTI">\n-       <property name="klass">my.package.content.FolderishCollection</property>\n-      </object>\n-\n-   If you really need it you could add the functionality to inherit search terms to your own folderish Collections by extending the behavior like in the example at https://github.com/plone/plone.app.contenttypes/commit/366cc1a911c81954645ec6aabce925df4a297c63\n-\n-\n-Migrating content that is translated with LinguaPlone\n-`````````````````````````````````````````````````````\n-\n-Since LinguaPlone does not support Dexterity you need to migrate from LinguaPlone to plone.app.multilingual (http://pypi.python.org/pypi/plone.app.multilingual). The migration from Products.LinguaPlone to plone.app.multilingual should happen **before** the migration from Archetypes to plone.app.contenttypes. For details on the migration see--\n-http://pypi.python.org/pypi/plone.app.multilingual#linguaplone-migration\n-\n-\n-Migrating default-content that was extended with archetypes.schemaextender\n-``````````````````````````````````````````````````````````````````````````\n-\n-\n-The migration-form warns you if any of your old types were extended with additional fields using `archetypes.schemaextender   <https://pypi.python.org/pypi/archetypes.schemaextender/>`_. The data contained in these fields will be lost during migration (with the exception of images added with collective.contentleadimage).\n-\n-To keep the data you would need to write a custom migration for your types dexterity-behaviors for the functionality provided by the schemaextenders. This is an advanced development task and beyond the scope of this documentation.\n-\n-\n-Migrating images created with collective.contentleadimage\n-`````````````````````````````````````````````````````````\n-\n-`collective.contentleadimage <https://pypi.python.org/pypi/collective.contentleadimage/>`_ was a popular addon that allows you to add images to any content in your site by extending the default types. To make sure these images are kept during migration you have to enable the behavior "Lead Image" on all those types where you want to migrate images added using collective.contentleadimage.\n-\n-The old types that use leadimages are listed in the navigation-form with the comment *"extended fields: \'leadImage\', \'leadImage_caption\'"*. The migration-form informs you which new types have the behavior enabled and which do not. Depending on the way you installed plone.app.contenttypes you might have to first install these types by (re-)installing plone.app.contenttypes.\n-\n-\n-Migrating in code (e.g. in a upgrade-step)\n-``````````````````````````````````````````\n-\n-You can run the migration in your own code by using the view `migrate_from_atct`. Here is an example of an upgrade-step that migrates all default content-types.\n-\n-.. code-block:: python\n-\n-    def migrate_to_pac(setup):\n-      portal = api.portal.get()\n-      request = getRequest()\n-      pac_migration = api.content.get_view(\'migrate_from_atct\', portal, request)\n-      pac_migration(\n-          migrate=True,\n-          content_types=\'all\',\n-          migrate_schemaextended_content=True,\n-          reindex_catalog=False)\n-\n-With `content_types` you can also pass a list of types to be migrated. Make sure to use the key from the dictionary `plone.app.contenttypes.migration.vocabularies.ATCT_LIST` to identify the types.\n-\n-\n-Migrating custom content\n-^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-During migrations of the default types any custom content-types will not be migrated and will continue to work as expected.\n-\n-\n-Using the migration-form to migrate custom content\n-``````````````````````````````````````````````````\n-\n-To help you migrating these types to Dexterity plone.app.contenttypes contains a migration form (``/@@custom_migration``) that allows you to migrate any (custom or default) Archetypes-type to any (custom or default) Dexterity-type. The only requirement is that the target-type (the Dexterity-type you want to migrate to) has to exist and that the class of the old type is still present. It makes no difference if the type you are migrating from is still registered in portal_types or is already removed or replaced by a dexterity-version using the same name.\n-\n-In the form ``/@@custom_migration`` you can select a Dexterity-type for any Archetypes-types that exists in the portal. You can then map the source-types fields to the targets fields. You can also choose to ignore fields. You have to take care that the values can be migrated (since there is no validation for that), e.g. it would make no sense to migrate a ImageField to a TextField. There are build-in methods for most field-types, custom or rarely used fields might not migrate properly (you can create a issue if you miss a migration that is not yet supported).\n-\n-After you map the fields you can test the configuration. During a test one item will be test-migrated and Plone checks if the migrated item will be accessible without throwing a errors. After the test any changes will be rolled back.\n-\n-Migrating custom types in your own code\n-```````````````````````````````````````\n-\n-It is recommended that you reuse the migration-code provided by plone.app.contenttypes in ``plone.app.contenttypes.migration.migration.migrateCustomAT`` for custom migrations.\n-\n-To do this you have to simply pass a mapping of source- to target-fields to a migration-method for each type.\n-\n-..  code-block:: python\n-\n-\n-    from plone.app.contenttypes.migration.migration import migrateCustomAT\n-\n-    def my_custom_migration():\n-        fields_mapping = (\n-                {\'AT_field_name\': \'some_field\',\n-                 \'DX_field_name\': \'description\',\n-                 },\n-\n-                # Migrate AT imagefield to DX imagefield using the mapping in\n-                # plone.app.contenttypes.migration.field_migrators.FIELDS_MAPPING\n-                {\'AT_field_name\': \'some_atimage\',\n-                 \'DX_field_name\': \'some_dximage\',\n-                 \'DX_field_type\': \'NamedBlobImage\',\n-                 },\n-        )\n-        migrateCustomAT(\n-            fields_mapping,\n-            src_type=\'SomeATType\',\n-            dst_type=\'SomeDXType\')\n-\n-A field-dict without a key ``DX_field_type`` from one of the migrators in ``plone.app.contenttypes.migration.field_migrators.FIELDS_MAPPING`` will always use ``plone.app.contenttypes.migration.field_migrators.migrate_simplefield`` as its migration-method. That can migrate most field-types where the value does not have to change (e.g. strings, lists, tuples, dicts etc.).\n-\n-``plone.app.contenttypes.migration.field_migrators`` has special field migrators for the following field-types: ``RichText``, ``NamedBlobFile``, ``NamedBlobImage``, ``Datetime``, ``Date``. They transform values from the Archetypes-version of such fields to their Dexterity counterparts.\n-\n-\n-Custom field-migrators\n-``````````````````````\n-\n-If you use rare or custom fields or want to apply special transforms to your data while migrating you can pass custom methods as ``field_migrator`` with the fields_mapping. This way you can migrate fields that are usually not migrateable.\n-\n-Here is an example where this method is used to migrate a Richtext-Field into a Tuple-Field by passing the custom field-migrator ``some_field_migrator``. In such a custom migrator you can do just about anything you wish.\n-\n-\n-..  code-block:: python\n-\n-    from plone.app.contenttypes.migration.migration import migrateCustomAT\n-\n-\n-    def some_field_migrator(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-        """A simple example that transforms pipe-delimited richtext to a tuple.\n-        """\n-        field = src_obj.getField(src_fieldname)\n-        at_value = field.get(src_obj)\n-        at_value = at_value.replace(\'<p>\', \'\').replace(\'</p>\', \'\')\n-        dx_value = [safe_unicode(i) for i in at_value.split(\'|\')]\n-        setattr(dst_obj, dst_fieldname, tuple(dx_value))\n-\n-\n-    def my_custom_migration():\n-        """\n-        """\n-        fields_mapping = (\n-                # Migrate using our custom migrator\n-                {\'AT_field_name\': \'some_richtext_field\',\n-                 \'DX_field_name\': \'some_tuple_field\',\n-                 \'field_migrator\': some_field_migrator},\n-        )\n-        migrateCustomAT(\n-            fields_mapping,\n-            src_type=\'SomeATType\',\n-            dst_type=\'SomeDXType\')\n-\n-Alternatively you could also extends the mapping from ``plone.app.contenttypes.migration.field_migrators.FIELDS_MAPPING`` to add new or replace existing migrators for specific field-types.\n-\n-\n-Migrating from old versions of plone.app.contenttypes\n-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-Before version 1.0a2 the content-items did not implement marker-interfaces. They will break in newer versions since the views are now registered for these interfaces (e.g. ``plone.app.contenttypes.interfaces.IDocument``). To fix this you can call the view ``/@@fix_base_classes`` on your site-root.\n-\n-Since plone.app.contenttypes 1.1a1, the Collection type uses the new Collection behavior and the Event type utilizes behaviors from `plone.app.event <http://pypi.python.org/pypi/plone.app.event>`_. In order to upgrade:\n-\n-1. First run the default profile (``plone.app.contenttypes:default``) or reinstall plone.app.contenttypes\n-2. Then run the upgrade steps.\n-\n-\n-\n-Widgets\n--------\n-\n-When used in Plone 4.x plone.app.contenttypes uses the default z3c.form widgets. All widgets work as they used to with Archetypes except for the keywords-widget for which a simple linesfield is used. Replacing that with a nicer implementation is explained below.\n-\n-It is also possible to use ``plone.app.widgets`` to switch to the widgets that are used in Plone 5.\n-\n-\n-How to override widgets\n-^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-To override the default keywords-widgets with a nicer widget you can use the package `collective.z3cform.widgets <https://pypi.python.org/pypi/collective.z3cform.widgets>`_.\n-\n-Add ``collective.z3cform.widgets`` to your ``buildout`` and in your own package register the override in your ``configure.zcml``:\n-\n-.. code:: xml\n-\n-    <adapter factory=".subjects.SubjectsFieldWidget" />\n-\n-Then add a file ``subjects.py``\n-\n-.. code:: python\n-\n-    # -*- coding: UTF-8 -*-\n-    from collective.z3cform.widgets.token_input_widget import TokenInputFieldWidget\n-    from plone.app.dexterity.behaviors.metadata import ICategorization\n-    from plone.app.z3cform.interfaces import IPloneFormLayer\n-    from z3c.form.interfaces import IFieldWidget\n-    from z3c.form.util import getSpecification\n-    from z3c.form.widget import FieldWidget\n-    from zope.component import adapter\n-    from zope.interface import implementer\n-\n-\n-    @adapter(getSpecification(ICategorization[\'subjects\']), IPloneFormLayer)\n-    @implementer(IFieldWidget)\n-    def SubjectsFieldWidget(field, request):\n-        widget = FieldWidget(field, TokenInputFieldWidget(field, request))\n-        return widget\n-\n-Once you install ``collective.z3cform.widgets`` in the quickinstaller, the new widget will then be used for all types.\n+This package is included in Plone 6 and does not need installation.\n \n \n Information for Addon-Developers\n@@ -418,43 +56,12 @@ Information for Addon-Developers\n Design decisions\n ^^^^^^^^^^^^^^^^\n \n-Schemata that are defined in XML-files using ``plone.supermodel`` allow editing those types\' schemata through the web. \n-This is the case for the default File, Image and Link content types. \n+Schemata that are defined in XML-files using ``plone.supermodel`` allow editing those types\' schemata through the web.\n+This is the case for the default File, Image and Link content types.\n Schemata coming from behaviors, on the other hand, are not editable through the web.\n The Document, News Item, Folder and Event default types, for example, have no schemata of their own at all, all their fields are provided by behaviors.\n \n \n-Installation as a dependency from another product\n-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-If you want to add plone.app.contenttypes as a dependency from another products use the profile ``plone-content`` in your ``metadata.xml`` to have Plone populate a new site with DX-based default-content.\n-\n-.. code:: xml\n-\n-    <metadata>\n-      <version>1</version>\n-        <dependencies>\n-            <dependency>profile-plone.app.contenttypes:plone-content</dependency>\n-        </dependencies>\n-    </metadata>\n-\n-If you use the profile ``default`` then the default-content in new sites will still be Archetypes-based. You\'ll then have to migrate that content using the migration-form ``@@atct_migrator`` or delete it by hand.\n-\n-\n-Using folderish types\n-^^^^^^^^^^^^^^^^^^^^^\n-\n-At some point all default types will probably be folderish. If you want the default types to be folderish before that happens please look at https://pypi.python.org/pypi/collective.folderishtypes.\n-\n-\n-Changing the base class for existing objects\n-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-If you changed the base-class of existing types (e.g. because you changed them to be folderish) you also need to upgrade the base-class of existing objects. You can use the following form for this: ``@@base_class_migrator_form``.\n-\n-This form lets you select classes to be updated and shows the number of objects for each class. This form can be used to change the base-class of any dexterity-types instances. The migration will also transform itemish content to folderish content if the new class is folderish. You might want to use the method ``plone.app.contenttypes.migration.dxmigration.migrate_base_class_to_new_class`` in your own upgrade-steps.\n-\n-\n Extending the types\n ^^^^^^^^^^^^^^^^^^^\n \n@@ -530,52 +137,20 @@ For more complex features you should always consider create custom behaviors and\n For more information on custom dexterity-types and custom behaviors please read the `dexterity documentation <http://docs.plone.org/external/plone.app.dexterity/docs/>`_.\n \n \n-Differences to Products.ATContentTypes\n---------------------------------------\n-\n-- The image of the News Item is not a field on the contenttype but a behavior that can add a image to any contenttypes (similar to http://pypi.python.org/pypi/collective.contentleadimage)\n-- All richtext-fields are also provided by a reuseable behavior.\n-- The functionality to transform (rotate and flip) images has been removed.\n-- There is no more field ``Location``. If you need georeferenceable consider using ``collective.geo.behaviour``\n-- The link on the image of the newsitem triggers an overlay\n-- The link-type now allows the of the variables ``${navigation_root_url}`` and ``${portal_url}`` to construct relative urls.\n-- The ``getQuery()`` function now returns a list of dict instead of a list of CatalogContentListingObject;\n-  use of ``getRawQuery()`` is deprecated.\n-- The views for Folders and Collections changed their names and now share a common implementation (since version 1.2a8):\n-\n-  - ``folder_listing_view`` (Folders) and ``collection_view`` (Collections) -> ``listing_view`` (Folders and Collections)\n-  - ``folder_summary_view`` (Folders) and ``summary_view`` (Collections) -> ``summary_view`` (Folders and Collections)\n-  - ``folder_tabular_view`` (Folders) and ``tabular_view`` (Collections) -> ``tabular_view`` (Folders and Collections)\n-  - ``folder_full_view`` (Folders) and ``all_content`` (Collections) -> ``full_view`` (Folders and Collections)\n-  - ``atct_album_view`` (Folders) and ``thumbnail_view`` (Collections) -> ``album_view`` (Folders and Collections)\n-\n-\n-\n-Toubleshooting\n---------------\n-\n-Please report issues in the bugtracker at https://github.com/plone/plone.app.contenttypes/issues.\n-\n-ValueError on installing\n-^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-When you try to install plone.app.contenttypes < 1.1a1 in a existing site you might get the following error::\n+Changing the base class for existing objects\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-      (...)\n-      Module Products.GenericSetup.utils, line 509, in _importBody\n-      Module Products.CMFCore.exportimport.typeinfo, line 60, in _importNode\n-      Module Products.GenericSetup.utils, line 730, in _initProperties\n-    ValueError: undefined property \'schema\'\n+If you changed the base-class of existing types (e.g. because you changed them to be folderish) you also need to upgrade the base-class of existing objects. You can use the following form for this: ``@@base_class_migrator_form``.\n \n-Before installing plone.app.contenttypes you have to reinstall plone.app.collection to update collections to the version that uses Dexterity.\n+This form lets you select classes to be updated and shows the number of objects for each class. This form can be used to change the base-class of any dexterity-types instances. The migration will also transform itemish content to folderish content if the new class is folderish. You might want to use the method ``plone.app.contenttypes.migration.dxmigration.migrate_base_class_to_new_class`` in your own upgrade-steps.\n \n \n-Branches\n---------\n+Source Code\n+===========\n \n-The master-branch supports Plone 5 only. From this 1.2.x-releases will be cut.\n+Contributors please read the document `Process for Plone core\'s development <https://docs.plone.org/develop/coredev/docs/index.html>`_\n \n-The 1.1.x-branch supports Plone 4.3.x. From this 1.1.x-releases will be cut.\n+Sources are at the `Plone code repository hosted at Github <https://github.com/plone/plone.app.contenttypes>`_.\n \n \n License\n@@ -590,7 +165,7 @@ Contributors\n * Philip Bauer <bauer@starzel.de>\n * Michael Mulich <michael.mulich@gmail.com>\n * Timo Stollenwerk <contact@timostollenwerk.net>\n-* Peter Holzer <hpeter@agitator.com>\n+* Peter Holzer <peter.holzer@agitator.com>\n * Patrick Gerken <gerken@starzel.de>\n * Steffen Lindner <lindner@starzel.de>\n * Daniel Widerin <daniel@widerin.net>\ndiff --git a/plone/app/contenttypes/browser/configure.zcml b/plone/app/contenttypes/browser/configure.zcml\nindex 519254d4..35af72c9 100644\n--- a/plone/app/contenttypes/browser/configure.zcml\n+++ b/plone/app/contenttypes/browser/configure.zcml\n@@ -246,4 +246,17 @@\n     <browser:page name="thumbnail_view" template="templates/listing_album.pt"/>\n   </browser:pages>\n \n+  <utility\n+      factory=".migration.ChangedBaseClasses"\n+      name="plone.app.contenttypes.migration.changed_base_classes"\n+      provides="zope.schema.interfaces.IVocabularyFactory" />\n+\n+  <browser:page\n+    name="base_class_migrator_form"\n+    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+    class=".migration.BaseClassMigrator"\n+    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"\n+    permission="cmf.ManagePortal"\n+    />\n+\n </configure>\ndiff --git a/plone/app/contenttypes/browser/migration.py b/plone/app/contenttypes/browser/migration.py\nnew file mode 100644\nindex 00000000..3576b931\n--- /dev/null\n+++ b/plone/app/contenttypes/browser/migration.py\n@@ -0,0 +1,128 @@\n+from plone.app.contenttypes.content import Document\n+from plone.app.contenttypes.content import File\n+from plone.app.contenttypes.content import Folder\n+from plone.app.contenttypes.content import Image\n+from plone.app.contenttypes.content import Link\n+from plone.app.contenttypes.content import NewsItem\n+from plone.app.contenttypes.utils import DEFAULT_TYPES\n+from plone.app.contenttypes.utils import get_old_class_name_string\n+from plone.app.contenttypes.utils import migrate_base_class_to_new_class\n+from plone.app.contenttypes.utils import list_of_changed_base_class_names\n+from plone.browserlayer.interfaces import ILocalBrowserLayerType\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.dexterity.interfaces import IDexterityFTI\n+from plone.z3cform.layout import wrap_form\n+from Products.CMFCore.utils import getToolByName\n+from Products.CMFPlone import PloneMessageFactory as _\n+from Products.CMFPlone.utils import get_installer\n+from Products.Five.browser import BrowserView\n+from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n+from Products.statusmessages.interfaces import IStatusMessage\n+from z3c.form import button\n+from z3c.form import field\n+from z3c.form import form\n+from z3c.form.browser.checkbox import CheckBoxFieldWidget\n+from z3c.form.interfaces import HIDDEN_MODE\n+from zExceptions import NotFound\n+from zope import schema\n+from zope.component import getMultiAdapter\n+from zope.component import queryUtility\n+from zope.interface import Interface\n+from zope.schema.interfaces import IVocabularyFactory\n+from zope.schema.vocabulary import SimpleVocabulary\n+from zope.interface import implementer\n+\n+import logging\n+import pkg_resources\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+\n+@implementer(IVocabularyFactory)\n+class ChangedBaseClasses(object):\n+\n+    def __call__(self, context):\n+        """Return a vocabulary with all changed base classes."""\n+        list_of_class_names = list_of_changed_base_class_names(context) or {}\n+        return SimpleVocabulary(\n+            [SimpleVocabulary.createTerm(\n+                class_name, class_name,\n+                \'{0} ({1})\'.format(\n+                    class_name, list_of_class_names[class_name]))\n+             for class_name in list_of_class_names.keys()]\n+        )\n+\n+\n+class IBaseClassMigratorForm(Interface):\n+\n+    changed_base_classes = schema.List(\n+        title=u\'Changed base classes\',\n+        description=u\'Select changed base classes you want to migrate\',\n+        value_type=schema.Choice(\n+            vocabulary=\'plone.app.contenttypes.migration.changed_base_classes\',\n+        ),\n+        required=True,\n+    )\n+    migrate_to_folderish = schema.Bool(\n+        title=u\'Migrate to folderish type?\',\n+        description=(\n+            u\'Select this option if you changed a type from being \'\n+            u\'itemish to being folderish but the class of the type is still \'\n+            u\'the same.\'\n+        ),\n+        default=False,\n+    )\n+\n+\n+class BaseClassMigratorForm(form.Form):\n+\n+    fields = field.Fields(IBaseClassMigratorForm)\n+    fields[\'changed_base_classes\'].widgetFactory = CheckBoxFieldWidget\n+    ignoreContext = True\n+    enableCSRFProtection = True\n+\n+    @button.buttonAndHandler(u\'Update\', name=\'update\')\n+    def handle_migrate(self, action):\n+        data, errors = self.extractData()\n+\n+        if errors:\n+            return\n+\n+        changed_base_classes = data.get(\'changed_base_classes\', [])\n+        if not changed_base_classes:\n+            return\n+\n+        migrate_to_folderish = data.get(\'changed_base_classes\', False)\n+        catalog = getToolByName(self.context, \'portal_catalog\')\n+        migrated = []\n+        not_migrated = []\n+        for brain in catalog():\n+            try:\n+                obj = brain.getObject()\n+            except (KeyError, NotFound):\n+                continue\n+            old_class_name = get_old_class_name_string(obj)\n+            if old_class_name in changed_base_classes:\n+                if migrate_base_class_to_new_class(\n+                        obj, migrate_to_folderish=migrate_to_folderish):\n+                    migrated.append(obj)\n+                else:\n+                    not_migrated.append(obj)\n+\n+        messages = IStatusMessage(self.request)\n+        info_message_template = \'There are {0} objects migrated.\'\n+        warn_message_template = \'There are not {0} objects migrated.\'\n+        if migrated:\n+            msg = info_message_template.format(len(migrated))\n+            messages.addStatusMessage(msg, type=\'info\')\n+        if not_migrated:\n+            msg = warn_message_template.format(len(not_migrated))\n+            messages.addStatusMessage(msg, type=\'warn\')\n+        self.request.response.redirect(self.request[\'ACTUAL_URL\'])\n+\n+\n+BaseClassMigrator = wrap_form(\n+    BaseClassMigratorForm,\n+)\ndiff --git a/plone/app/contenttypes/configure.zcml b/plone/app/contenttypes/configure.zcml\nindex 3399fbc3..0b1131a4 100644\n--- a/plone/app/contenttypes/configure.zcml\n+++ b/plone/app/contenttypes/configure.zcml\n@@ -37,11 +37,6 @@\n   <include file="subscribers.zcml" />\n   <include file="upgrades.zcml" />\n \n-  <configure zcml:condition="installed Products.ATContentTypes">\n-  <include\n-    zcml:condition="installed archetypes.schemaextender"\n-    package=".migration" />\n-  </configure>\n \n   <utility\n       factory=".setuphandlers.HiddenProfiles"\ndiff --git a/plone/app/contenttypes/migration/__init__.py b/plone/app/contenttypes/migration/__init__.py\ndeleted file mode 100644\nindex 40a96afc..00000000\n--- a/plone/app/contenttypes/migration/__init__.py\n+++ /dev/null\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/contenttypes/migration/atct_migrator.pt b/plone/app/contenttypes/migration/atct_migrator.pt\ndeleted file mode 100644\nindex c6a49e54..00000000\n--- a/plone/app/contenttypes/migration/atct_migrator.pt\n+++ /dev/null\n@@ -1,124 +0,0 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"\n-      xmlns:tal="http://xml.zope.org/namespaces/tal"\n-      xmlns:metal="http://xml.zope.org/namespaces/metal"\n-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-      lang="en"\n-      metal:use-macro="context/@@main_template/macros/master"\n-      i18n:domain="plone">\n-\n-<metal:block fill-slot="top_slot"\n-    tal:define="dummy python:request.set(\'disable_border\', 1);\n-                disable_column_two python:request.set(\'disable_plone.rightcolumn\', 1);\n-                disable_column_two python:request.set(\'disable_plone.leftcolumn\', 1);\n-                portal_url portal_state/portal_url">\n-  <link rel="stylesheet" type="text/css" href="" media="screen" tal:attributes="href string:${portal_url}/++resource++pac_migrator.css">\n-</metal:block>\n-\n-<body>\n-\n-<metal:custom_title fill-slot="content-title">\n-  <h1 class="documentFirstHeading" i18n:translate="">Migration control panel</h1>\n-</metal:custom_title>\n-<metal:custom_desc fill-slot="content-description">\n-  <div class="documentDescription" i18n:translate="">Migrate Archetypes content types to respective Dexterity content types.</div>\n-</metal:custom_desc>\n-\n-<metal:content-core fill-slot="content-core">\n-<metal:block define-macro="content-core"\n-             tal:define="helpers context/@@atct_migrator_helpers;\n-                         linguaplone_installed helpers/linguaplone_installed;\n-                         object_number helpers/objects_to_be_migrated;\n-                         subtopics helpers/site_has_subtopics;\n-                         collections_are_folderish helpers/collections_are_folderish;\n-                         has_contentleadimage helpers/has_contentleadimage;\n-                         installed_types helpers/installed_types;">\n-  <div class="important">\n-    <h2 i18n:translate="">Important</h2>\n-    <p i18n:translate="">Before migrating your content please read the <a i18n:name="migrationsection" i18n:translate="" href="https://github.com/plone/plone.app.contenttypes#migration">migration-section in the documentation of plone.app.contenttypes</a></p>\n-    <h3 i18n:translate="">Migrating content that is translated with LinguaPlone</h3>\n-    <p i18n:translate="">Since LinguaPlone does not support Dexterity you need to migrate from LinguaPlone to <a i18n:name="multilingual" href="http://pypi.python.org/pypi/plone.app.multilingual">plone.app.multilingual</a>. The migration from Products.LinguaPlone to plone.app.multilingual should happen before the migration from Archetypes to plone.app.contenttypes. For details on the migration see the <a i18n:name="documentation" href="http://pypi.python.org/pypi/plone.app.multilingual#linguaplone-migration">documentation</a></p>\n-    <h3 i18n:translate="">Migrating default-content that was extended with archetypes.schemaextender</h3>\n-    <p i18n:translate="">The migration should warn you if any of your types are extended with <a i18n:name="schemaextender" href="https://pypi.python.org/pypi/archetypes.schemaextender">archetypes.schemaextender</a>. You can still migrate this content but the data contained in these fields will be lost.\n-    If you need to keep the data in these fields you need to write a custom migration for your types and dexterity-behaviors for the data stored in the extended fields.</p>\n-    <h3 i18n:translate="">Note about how long it might take</h3>\n-    <p i18n:translate="">Depending of the number of archetypes in your portal, it may take a <strong>really</strong> long time for the migration to be done.\n-    Stay calm, be patient and check your logs for progress-information.</p>\n-  </div>\n-  <tal:block condition="object_number">\n-    <tal:block condition="not:linguaplone_installed">\n-      <div class="important">\n-        <h2 i18n:translate="">Estimation</h2>\n-        <p i18n:translate="">You currently have <span class="strong" i18n:name="number_of_objects" tal:content="helpers/objects_to_be_migrated">23</span> archetypes objects to be migrated.</p>\n-        <p i18n:translate="" tal:define="time helpers/estimated_migration_time">The estimated time for the migration is around:\n-        <strong>\n-          <tal:block i18n:name="hours" content="time/hours">4</tal:block> hours\n-          <tal:block i18n:name="minutes" content="time/minutes">45</tal:block> minutes\n-          <tal:block i18n:name="seconds" content="time/seconds">23</tal:block> seconds\n-        </strong>\n-        </p>\n-        <p>\n-        <span i18n:translate="" tal:omit-tag="">Please note that migrating references will increase this time.</span>\n-        </p>\n-      </div>\n-      <div id="migration-options">\n-        <h2 i18n:translate="">Migrate contents</h2>\n-        <div class="documentDescription">\n-          <p i18n:translate="">You can select which content types you want to migrate and\n-            choose to migrate references or not.</p>\n-        </div>\n-        <tal:form metal:use-macro="context/@@ploneform-macros/titlelessform">\n-            This is the real migration form.\n-        </tal:form>\n-      </div>\n-    </tal:block>\n-    <tal:block condition="linguaplone_installed">\n-      <div class="important">\n-        <h2 i18n:translate="">Warning</h2>\n-        <p i18n:translate="" class="strong">Since you effectively have Products.LinguaPlone installed in your portal, you\'re not allowed to continue this migration.</p>\n-        <p i18n:translate="">Have a look above for more information.</p>\n-      </div>\n-    </tal:block>\n-    <tal:block condition="python: subtopics and not collections_are_folderish">\n-      <div class="important">\n-        <h2 i18n:translate="">Error</h2>\n-        <p i18n:translate="">Your site has <span i18n:name="n" tal:replace="python: len(subtopics)" /> subtopic(s). Before migrating them you have to either remove all subtopics or create folderish Collections to be able to migrate them. Inheriting criteria to sub-collections is not supported by the default types. You can still migrate other content.</p>\n-        <p><a i18n:translate="" href="https://pypi.python.org/pypi/plone.app.contenttypes#migration">See here for details.</a></p>\n-        <p i18n:translate="">Your subtopics:</p>\n-        <ul>\n-          <li tal:repeat="subtopic subtopics"><a href="" target="_new" tal:attributes="href subtopic" tal:content="subtopic"></a></li>\n-        </ul>\n-      </div>\n-    </tal:block>\n-    <tal:block condition="python: subtopics and collections_are_folderish">\n-      <div class="important">\n-        <h2 i18n:translate="">Warning</h2>\n-        <p i18n:translate="">Your site has <span i18n:name="n" tal:replace="python: len(subtopics)" /> subtopic(s). You can migrate them since you have folderish Collections but their functionality to inherit criteria will not work unless you.</p>\n-      </div>\n-    </tal:block>\n-    <tal:block condition="python: has_contentleadimage"\n-               tal:define="installed_with_behavior python:installed_types[\'installed_with_behavior\'];\n-                           installed_without_behavior python:installed_types[\'installed_without_behavior\'];\n-                           not_installed python:installed_types[\'not_installed\']">\n-      <div class="important">\n-        <h2 i18n:translate="">Warning</h2>\n-        <p i18n:translate="">\n-          Your site seems to use the addon <a i18n:name="contentleadimage" href="https://pypi.python.org/pypi/collective.contentleadimage/">collective.contentleadimage</a>.\n-          This addons allows you to add images to any content in your site. These images will <strong>not</strong> be migrated unless you enable the behavior "Lead Image" on all those types where you want to migrate images added using collective.contentleadimage. Depending on the way you installed plone.app.contenttypes you might have to first install these types by (re-)installing plone.app.contenttypes. The old types that use leadimages are listed in the navigation-form with the comment <em>"extended fields: \'leadImage\', \'leadImage_caption\'"</em>\n-        </p>\n-        <p tal:condition="python:installed_with_behavior" i18n:translate="">These types are installed and have the image-behavior: <span i18n:name="types" tal:content="python:\', \'.join(installed_with_behavior)">Document, Image</span></p>\n-        <p tal:condition="python:installed_without_behavior" i18n:translate="">These types are installed but do not have the behavior enabled: <span i18n:name="types" tal:content="python:\', \'.join(installed_without_behavior)">Link, File</span></p>\n-        <p tal:condition="python:not_installed" i18n:translate="">These types are not installed yet: <span i18n:name="types" tal:content="python:\', \'.join(not_installed)">News Item, Folder</span></p>\n-      </div>\n-    </tal:block>\n-\n-  </tal:block>\n-  <tal:block condition="not:object_number">\n-    <div class="important">\n-      <h2 i18n:translate="">Warning</h2>\n-      <p i18n:translate="" class="strong">No content to migrate.</p>\n-  </tal:block>\n-\n-</metal:block>\n-</metal:content-core>\n-</body>\n-</html>\ndiff --git a/plone/app/contenttypes/migration/atct_migrator_results.pt b/plone/app/contenttypes/migration/atct_migrator_results.pt\ndeleted file mode 100644\nindex 65875308..00000000\n--- a/plone/app/contenttypes/migration/atct_migrator_results.pt\n+++ /dev/null\n@@ -1,84 +0,0 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"\n-      xmlns:tal="http://xml.zope.org/namespaces/tal"\n-      xmlns:metal="http://xml.zope.org/namespaces/metal"\n-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-      lang="en"\n-      metal:use-macro="context/@@main_template/macros/master"\n-      i18n:domain="plone">\n-\n-<metal:block fill-slot="top_slot"\n-    tal:define="dummy python:request.set(\'disable_border\', 1);\n-                disable_column_two python:request.set(\'disable_plone.rightcolumn\', 1);\n-                disable_column_two python:request.set(\'disable_plone.leftcolumn\', 1);\n-                portal_url portal_state/portal_url">\n-  <link rel="stylesheet" type="text/css" href="" media="screen" tal:attributes="href string:${portal_url}/++resource++pac_migrator.css">\n-</metal:block>\n-\n-<body>\n-\n-<metal:custom_title fill-slot="content-title">\n-  <h1 class="documentFirstHeading" i18n:translate="">Congratulations! You migrated from Archetypes to Dexterity.</h1>\n-</metal:custom_title>\n-\n-<metal:content-core fill-slot="content-core">\n-<metal:block define-macro="content-core"\n-    tal:define="results view/results">\n-\n-  <tal:success tal:condition="results">\n-    <p>The migration finished within <span tal:replace="results/duration">20</span></p>\n-\n-    <h3>Migrated Content</h3>\n-    <table>\n-    <tr>\n-      <th>Old Type</th>\n-      <th>New Type</th>\n-      <th>Items</th>\n-    </tr>\n-    <tal:block tal:repeat="ct results/content_types">\n-    <tr>\n-      <td tal:content="python:results[\'migrated_types\'][ct][\'old_meta_type\']"></td>\n-      <td tal:content="python:results[\'migrated_types\'][ct][\'type_name\']"></td>\n-      <td tal:content="python:results[\'migrated_types\'][ct][\'amount_migrated\']"></td>\n-    </tr>\n-    </tal:block>\n-    </table>\n-\n-    <h3>Content before Migration</h3>\n-    <table>\n-    <tr>\n-      <th>Type</th>\n-      <th>Items</th>\n-    </tr>\n-    <tr tal:repeat="ct python:sorted(results[\'before\'].keys())">\n-      <td tal:content="ct"></td>\n-      <td tal:content="python:results[\'before\'][ct]"></td>\n-    </tr>\n-    </table>\n-\n-    <h3>Content after Migration</h3>\n-    <table>\n-    <tr>\n-      <th>Type</th>\n-      <th>Items</th>\n-    </tr>\n-    <tr tal:repeat="ct python:sorted(results[\'after\'].keys())">\n-      <td tal:content="ct"></td>\n-      <td tal:content="python:results[\'after\'][ct]"></td>\n-    </tr>\n-    </table>\n-  </tal:success>\n-\n-  <div class="links">\n-    <a href="atct_migrator" tal:attributes="href string:${portal_url}/@@atct_migrator">\n-      <span i18n:translate="">Back to the Migration-Form</span>\n-    </a>\n-    <br/>\n-    <a href="" tal:attributes="href portal_url">\n-      <span i18n:translate="">Back to Plone</span>\n-    </a>\n-  </div>\n-\n-</metal:block>\n-</metal:content-core>\n-</body>\n-</html>\ndiff --git a/plone/app/contenttypes/migration/browser.py b/plone/app/contenttypes/migration/browser.py\ndeleted file mode 100644\nindex b36cb9fc..00000000\n--- a/plone/app/contenttypes/migration/browser.py\n+++ /dev/null\n@@ -1,627 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from datetime import datetime\n-from datetime import timedelta\n-from plone.app.contenttypes.content import Document\n-from plone.app.contenttypes.content import File\n-from plone.app.contenttypes.content import Folder\n-from plone.app.contenttypes.content import Image\n-from plone.app.contenttypes.content import Link\n-from plone.app.contenttypes.content import NewsItem\n-from plone.app.contenttypes.migration import dxmigration\n-from plone.app.contenttypes.migration import migration\n-from plone.app.contenttypes.migration.patches import patch_before_migration\n-from plone.app.contenttypes.migration.patches import undo_patch_after_migration\n-from plone.app.contenttypes.migration.utils import installTypeIfNeeded\n-from plone.app.contenttypes.migration.utils import isSchemaExtended\n-from plone.app.contenttypes.migration.utils import restore_references\n-from plone.app.contenttypes.migration.utils import store_references\n-from plone.app.contenttypes.migration.vocabularies import ATCT_LIST\n-from plone.app.contenttypes.upgrades import use_new_view_names\n-from plone.app.contenttypes.utils import DEFAULT_TYPES\n-from plone.browserlayer.interfaces import ILocalBrowserLayerType\n-from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.interfaces import IDexterityFTI\n-from plone.z3cform.layout import wrap_form\n-from pprint import pformat\n-from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone import PloneMessageFactory as _\n-from Products.CMFPlone.utils import get_installer\n-from Products.Five.browser import BrowserView\n-from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n-from Products.statusmessages.interfaces import IStatusMessage\n-from z3c.form import button\n-from z3c.form import field\n-from z3c.form import form\n-from z3c.form.browser.checkbox import CheckBoxFieldWidget\n-from z3c.form.interfaces import HIDDEN_MODE\n-from zExceptions import NotFound\n-from zope import schema\n-from zope.component import getMultiAdapter\n-from zope.component import queryUtility\n-from zope.interface import Interface\n-\n-import logging\n-import pkg_resources\n-\n-\n-try:\n-    pkg_resources.get_distribution(\'collective.contentleadimage\')\n-except pkg_resources.DistributionNotFound:\n-    HAS_CONTENTLEADIMAGE = False\n-else:\n-    HAS_CONTENTLEADIMAGE = True\n-\n-logger = logging.getLogger(__name__)\n-\n-\n-# Average time to migrate one archetype object, in milliseconds.\n-# This very much depends on the size of the object and system-speed\n-ONE_OBJECT_MIGRATION_TIME = 500\n-\n-\n-class FixBaseClasses(BrowserView):\n-\n-    def __call__(self):\n-        """Make sure all content objects use the proper base classes.\n-        Instances before version 1.0b1 had no base-class.\n-        To update them call @@fix_base_classes on your site-root.\n-        """\n-        out = \'\'\n-        portal_types = [\n-            (\'Document\', Document),\n-            (\'File\', File),\n-            (\'Folder\', Folder),\n-            (\'Image\', Image),\n-            (\'Link\', Link),\n-            (\'News Item\', NewsItem),\n-        ]\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        query = {}\n-        for portal_type, portal_type_class in portal_types:\n-            query[\'portal_type\'] = portal_type\n-            results = catalog(query)\n-            for brain in results:\n-                try:\n-                    obj = brain.getObject()\n-                except (KeyError, NotFound):\n-                    logger.exception(\'Can not resolve object from brain.\')\n-                    continue\n-                if IDexterityContent.providedBy(obj):\n-                    object_class_name = obj.__class__.__name__\n-                    target_class_name = portal_type_class.__name__\n-                    if not object_class_name == target_class_name:\n-                        obj.__class__ = portal_type_class\n-                        out += \'Make {0} use {1}\\n as base class.\'.format(\n-                            obj.Title(),\n-                            portal_type_class.__name__,\n-                        )\n-        return out\n-\n-\n-class MigrateFromATContentTypes(BrowserView):\n-    """Migrate the default-types (except event and topic).\n-    This view can be called directly and it will migrate all content\n-    provided they were not schema-extended.\n-    This is also called by the migration-form below with some variables.\n-    """\n-\n-    def __call__(self,\n-                 migrate=False,\n-                 content_types=\'all\',\n-                 migrate_schemaextended_content=False,\n-                 migrate_references=True,\n-                 from_form=False,\n-                 reindex_catalog=True,\n-                 patch_searchabletext=False,\n-                 ):\n-\n-        portal = self.context\n-\n-        if not from_form and migrate not in [\'1\', \'True\', \'true\', 1]:\n-            url1 = \'{0}/@@migrate_from_atct?migrate=1\'.format(\n-                portal.absolute_url())\n-            url2 = \'{0}/@@atct_migrator\'.format(portal.absolute_url())\n-            msg = u\'Warning \\n\'\n-            msg += u\'-------\\n\'\n-            msg += u\'You are accessing "@@migrate_from_atct" directly. \'\n-            msg += u\'This will migrate all content to dexterity!\\n\\n\'\n-            msg += u\'Really migrate all content now: {0}\\n\\n\'.format(url1)\n-            msg += u\'First select what to migrate: {0}\'.format(url2)\n-            return msg\n-\n-        helpers = getMultiAdapter((portal, self.request),\n-                                  name=\'atct_migrator_helpers\')\n-        if helpers.linguaplone_installed():\n-            msg = \'Warning\\n\'\n-            msg += \'Migration aborted since Products.LinguaPlone is \'\n-            msg += \'installed. See \'\n-            msg += \'http://github.com/plone/plone.app.contenttypes#migration \'\n-            msg += \'for more information.\'\n-            return msg\n-\n-        stats_before = self.stats()\n-        starttime = datetime.now()\n-\n-        self.request[\'plone.app.contenttypes_migration_running\'] = True\n-\n-        msg = \'Starting Migration\\n\\n\'\n-        msg += \'\\n-----------------------------\\n\'\n-        msg += \'Content statictics:\\n\'\n-        msg += pformat(stats_before)\n-        msg += \'\\n-----------------------------\\n\'\n-        msg += \'Types to be migrated:\\n\'\n-        msg += pformat(content_types)\n-        msg += \'\\n-----------------------------\\n\'\n-        logger.info(msg)\n-\n-        # store references on the portal\n-        if migrate_references:\n-            store_references(portal)\n-        catalog = portal.portal_catalog\n-\n-        # Patch various things that make migration harder\n-        (link_integrity,\n-         queue_indexing,\n-         patch_searchabletext) = patch_before_migration(patch_searchabletext)\n-\n-        not_migrated = []\n-        migrated_types = {}\n-\n-        for (k, v) in ATCT_LIST.items():\n-            if content_types != \'all\' and k not in content_types:\n-                not_migrated.append(k)\n-                continue\n-            # test if the ct is extended beyond blobimage and blobfile\n-            if len(isSchemaExtended(v[\'iface\'])) > len(v[\'extended_fields\']) \\\n-                    and not migrate_schemaextended_content:\n-                not_migrated.append(k)\n-                continue\n-            query = {\n-                \'object_provides\': v[\'iface\'].__identifier__,\n-                \'meta_type\': v[\'old_meta_type\'],\n-            }\n-            amount_to_be_migrated = len(\n-                catalog.unrestrictedSearchResults(query))\n-            starttime_for_current = datetime.now()\n-            logger.info(\n-                \'Start migrating {0} objects from {1} to {2}\'.format(\n-                    amount_to_be_migrated,\n-                    v[\'old_meta_type\'],\n-                    v[\'type_name\'],\n-                )\n-            )\n-            installTypeIfNeeded(v[\'type_name\'])\n-\n-            # call the migrator\n-            v[\'migrator\'](portal)\n-\n-            # logging\n-            duration_current = datetime.now() - starttime_for_current\n-            duration_human = str(timedelta(seconds=duration_current.seconds))\n-            logger.info(\n-                \'Finished migrating {0} objects from {1} to {2} in {3}\'.format(\n-                    amount_to_be_migrated,\n-                    v[\'old_meta_type\'],\n-                    v[\'type_name\'],\n-                    duration_human),\n-            )\n-\n-            # some data for the results-page\n-            migrated_types[k] = {}\n-            migrated_types[k][\'amount_migrated\'] = amount_to_be_migrated\n-            migrated_types[k][\'old_meta_type\'] = v[\'old_meta_type\']\n-            migrated_types[k][\'type_name\'] = v[\'type_name\']\n-\n-        # if there are blobnewsitems we just migrate them silently.\n-        migration.migrate_blobnewsitems(portal)\n-\n-        # make sure the view-methods on the plone site are updated\n-        use_new_view_names(portal, types_to_fix=[\'Plone Site\'])\n-\n-        if reindex_catalog:\n-            logger.info(\'Rebuiling catalog. This may take a while...\')\n-            catalog.clearFindAndRebuild()\n-\n-        # restore references\n-        if migrate_references:\n-            restore_references(portal)\n-\n-        # Revert to the original state\n-        undo_patch_after_migration(\n-            link_integrity, queue_indexing, patch_searchabletext)\n-\n-        duration = str(timedelta(seconds=(datetime.now() - starttime).seconds))\n-        if not_migrated:\n-            msg = (\n-                \'The following types were not migrated: \\n {0}\'.format(\n-                    \'\\n\'.join(not_migrated)\n-                )\n-            )\n-        else:\n-            msg = \'Migration successful\\n\\n\'\n-        msg += \'\\n-----------------------------\\n\'\n-        msg += \'Migration finished in: {0}\'.format(duration)\n-        msg += \'\\n-----------------------------\\n\'\n-        msg += \'Migration statictics:\\n\'\n-        msg += pformat(migrated_types)\n-        msg += \'\\n-----------------------------\\n\'\n-        msg += \'State before:\\n\'\n-        msg += pformat(stats_before)\n-        msg += \'\\n-----------------------------\\n\'\n-        msg += \'Stats after:\\n\'\n-        msg += pformat(self.stats())\n-        msg += \'\\n-----------------------------\\n\'\n-        if not from_form:\n-            logger.info(msg)\n-            return msg\n-        else:\n-            stats = {\n-                \'duration\': duration,\n-                \'before\': stats_before,\n-                \'after\': self.stats(),\n-                \'content_types\': content_types,\n-                \'migrated_types\': migrated_types,\n-            }\n-            logger.info(msg)\n-            return stats\n-\n-    def stats(self):\n-        results = {}\n-        catalog = self.context.portal_catalog\n-        for brain in catalog():\n-            descriptor = \'{} ({})\'.format(brain.portal_type, brain.meta_type)\n-            results[descriptor] = results.get(descriptor, 0) + 1\n-        return results\n-\n-\n-class IATCTMigratorForm(Interface):\n-\n-    content_types = schema.List(\n-        title=u\'Existing content that can be migrated\',\n-        description=u\'Select which content types you want to migrate\',\n-        value_type=schema.Choice(\n-            vocabulary=\'plone.app.contenttypes.migration.atctypes\',\n-        ),\n-        required=False,\n-    )\n-\n-    migrate_references = schema.Bool(\n-        title=u\'Migrate references?\',\n-        description=(\n-            u\'Select this option to migrate references.\'\n-        ),\n-        default=True,\n-        required=False,\n-    )\n-\n-    extended_content = schema.List(\n-        title=(\n-            u\'Migrate content that was extended \'\n-            u\'using archetypes.schemaextender?\'\n-        ),\n-        description=(\n-            u\'Warning: You will loose all data in the extended fields!\'\n-        ),\n-        value_type=schema.Choice(\n-            vocabulary=\'plone.app.contenttypes.migration.extendedtypes\',\n-        ),\n-        required=False,\n-    )\n-\n-    reindex_catalog = schema.Bool(\n-        title=_(u\'Rebuild the catalog after the migration.\'),\n-        description=_(u\'This operation can take a very long time.\'),\n-        default=True,\n-        required=False,\n-    )\n-\n-    patch_searchabletext = schema.Bool(\n-        title=_(u\'Disable reindexing objects during migration?\'),\n-        description=_(\n-            u\'This can speed up your migration a lot if you have a lot of files with searchable text.\'  # noqa: E501\n-        ),\n-        default=False,\n-        required=False,\n-    )\n-\n-\n-class ATCTMigratorForm(form.Form):\n-    template = ViewPageTemplateFile(\'atct_migrator.pt\')\n-    results_template = ViewPageTemplateFile(\'atct_migrator_results.pt\')\n-\n-    fields = field.Fields(IATCTMigratorForm)\n-    fields[\'content_types\'].widgetFactory = CheckBoxFieldWidget\n-    fields[\'extended_content\'].widgetFactory = CheckBoxFieldWidget\n-    ignoreContext = True\n-    enableCSRFProtection = True\n-\n-    results = None\n-\n-    @button.buttonAndHandler(u\'Migrate\', name=\'migrate\')\n-    def handle_migrate(self, action):\n-        data, errors = self.extractData()\n-        context = self.context\n-\n-        if errors:\n-            return\n-\n-        content_types = data[\'content_types\'] or []\n-        content_types.extend(data[\'extended_content\'] or [])\n-\n-        migration_view = getMultiAdapter(\n-            (context, self.request),\n-            name=u\'migrate_from_atct\'\n-        )\n-        # store results where `render` can find them\n-        self.results = migration_view(\n-            content_types=content_types,\n-            migrate_schemaextended_content=True,\n-            migrate_references=data[\'migrate_references\'],\n-            from_form=True,\n-            reindex_catalog=data[\'reindex_catalog\'],\n-            patch_searchabletext=data[\'patch_searchabletext\'],\n-        )\n-\n-    def updateActions(self):\n-        super(ATCTMigratorForm, self).updateActions()\n-        self.actions[\'migrate\'].addClass(\'btn-danger\')\n-\n-    def updateWidgets(self):\n-        """ Overload to set defaults and hide empty widgets. """\n-        form.Form.updateWidgets(self)\n-        # 1. Select all items in the checkboxwidget\n-        ct_widget = self.widgets[\'content_types\']\n-        # Only override when rendering the form. When you unselect\n-        # everything the value will be [], not ())\n-        if ct_widget.value == ():\n-            ct_widget.value = list(ATCT_LIST)\n-            # Call update again since the list-items checked-states are\n-            # assigned in z3c.form.browser.checkbox.CheckBoxWidget.update\n-            # using the widget.value.\n-            ct_widget.update()\n-        # 2. Hide empty widget\n-        for title, widget in self.widgets.items():\n-            if title not in (\'content_types\', \'extended_content\'):\n-                continue\n-            if not len(widget.items):\n-                # the vocabulary is empty, we hide the widget\n-                widget.mode = HIDDEN_MODE\n-\n-    def render(self):\n-        if self.results:\n-            return self.results_template()\n-        else:\n-            return super(ATCTMigratorForm, self).render()\n-\n-\n-class IBaseClassMigratorForm(Interface):\n-\n-    changed_base_classes = schema.List(\n-        title=u\'Changed base classes\',\n-        description=u\'Select changed base classes you want to migrate\',\n-        value_type=schema.Choice(\n-            vocabulary=\'plone.app.contenttypes.migration.changed_base_classes\',\n-        ),\n-        required=True,\n-    )\n-    migrate_to_folderish = schema.Bool(\n-        title=u\'Migrate to folderish type?\',\n-        description=(\n-            u\'Select this option if you changed a type from being \'\n-            u\'itemish to being folderish but the class of the type is still \'\n-            u\'the same.\'\n-        ),\n-        default=False,\n-    )\n-\n-\n-class BaseClassMigratorForm(form.Form):\n-\n-    fields = field.Fields(IBaseClassMigratorForm)\n-    fields[\'changed_base_classes\'].widgetFactory = CheckBoxFieldWidget\n-    ignoreContext = True\n-    enableCSRFProtection = True\n-\n-    @button.buttonAndHandler(u\'Update\', name=\'update\')\n-    def handle_migrate(self, action):\n-        data, errors = self.extractData()\n-\n-        if errors:\n-            return\n-\n-        changed_base_classes = data.get(\'changed_base_classes\', [])\n-        if not changed_base_classes:\n-            return\n-\n-        migrate_to_folderish = data.get(\'changed_base_classes\', False)\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        migrated = []\n-        not_migrated = []\n-        for brain in catalog():\n-            try:\n-                obj = brain.getObject()\n-            except (KeyError, NotFound):\n-                continue\n-            old_class_name = dxmigration.get_old_class_name_string(obj)\n-            if old_class_name in changed_base_classes:\n-                if dxmigration.migrate_base_class_to_new_class(\n-                        obj, migrate_to_folderish=migrate_to_folderish):\n-                    migrated.append(obj)\n-                else:\n-                    not_migrated.append(obj)\n-\n-        messages = IStatusMessage(self.request)\n-        info_message_template = \'There are {0} objects migrated.\'\n-        warn_message_template = \'There are not {0} objects migrated.\'\n-        if migrated:\n-            msg = info_message_template.format(len(migrated))\n-            messages.addStatusMessage(msg, type=\'info\')\n-        if not_migrated:\n-            msg = warn_message_template.format(len(not_migrated))\n-            messages.addStatusMessage(msg, type=\'warn\')\n-        self.request.response.redirect(self.request[\'ACTUAL_URL\'])\n-\n-\n-BaseClassMigrator = wrap_form(\n-    BaseClassMigratorForm,\n-)\n-\n-\n-class ATCTMigratorHelpers(BrowserView):\n-\n-    def objects_to_be_migrated(self):\n-        """ Return the number of AT objects in the portal """\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        query = {\'meta_type\': [i[\'old_meta_type\'] for i in ATCT_LIST.values()]}\n-        brains = catalog(query)\n-        self._objects_to_be_migrated = len(brains)\n-        return self._objects_to_be_migrated\n-\n-    def estimated_migration_time(self):\n-        """ Return the estimated migration time """\n-        total_time = self.objects_to_be_migrated() * ONE_OBJECT_MIGRATION_TIME\n-        hours, remainder = divmod(total_time // 1000, 3600)\n-        minutes, seconds = divmod(remainder, 60)\n-        return {\n-            \'hours\': hours,\n-            \'minutes\': minutes,\n-            \'seconds\': seconds\n-        }\n-\n-    def linguaplone_installed(self):\n-        """Is Products.LinguaPlone installed?\n-        """\n-        existing = queryUtility(ILocalBrowserLayerType, name=\'LinguaPlone\')\n-        return bool(existing)\n-\n-    def site_has_subtopics(self):\n-        """Check if there are subtopics. Since Collections are itemish by\n-        default the migration of subtopics would fail Collections are changed\n-        to be folderish.\n-        """\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        query = {\'meta_type\': \'ATTopic\'}\n-        results = []\n-        brains = catalog(query)\n-        for brain in brains:\n-            for item in catalog(path={\'query\': brain.getPath(), \'depth\': 1}):\n-                results.append(item.getURL())\n-        if results:\n-            results = set(results)\n-            paths = \'\\n\'.join(results)\n-            logger.info(\'Found {0} subtopics at: \\n{1}\'.format(\n-                len(results), paths))\n-            return results\n-\n-    def collections_are_folderish(self):\n-        """Since Collections are itemish by default the migration would fail\n-        if there are any subtopics. As a workaround we allow to migrate to\n-        custom folderish Collections. The custom Collections have to fulfill\n-        the following criteria:\n-        1. The id if the type has to be Collection (not collection). You can\n-           change a type\'s id in portal_types\n-        2. The type has to have the collection-behavior.\n-\n-        This much can even be done ttw. For the views of collections\n-        to work the base-class of the Collections also has to implement the\n-        interface `plone.app.contenttypes.interfaces.ICollection`.\n-\n-        This is what such a class would look like:\n-\n-            from plone.app.contenttypes.behaviors.collection import ICollection\n-            from plone.dexterity.content import Container\n-            from zope.interface import implementer\n-\n-            @implementer(ICollection)\n-            class FolderishCollection(Container):\n-                pass\n-\n-        You can either use a completely new fti or overwrite the default fti\n-        like this:\n-\n-            <?xml version="1.0"?>\n-            <object name="Collection" meta_type="Dexterity FTI">\n-             <property name="klass">my.package.content.FolderishCollection\n-             </property>\n-            </object>\n-\n-        """\n-        fti = queryUtility(IDexterityFTI, name=\'Collection\')\n-        if fti and fti.content_meta_type == \'Dexterity Container\':\n-            return True\n-        # test for lowercase ttw-type\n-        fti = queryUtility(IDexterityFTI, name=\'collection\')\n-        behavior = \'plone.app.contenttypes.behaviors.collection.ICollection\'\n-        if fti and behavior in fti.behaviors:\n-            logger.warn("You are trying to migrate topic to collection. "\n-                        "Instead you need a type \'Collection\'.")\n-\n-    def has_contentleadimage(self):\n-        return HAS_CONTENTLEADIMAGE\n-\n-    def installed_types(self):\n-        """Which types are already Dexterity and which are not."""\n-        results = {}\n-        results[\'installed_with_behavior\'] = []\n-        results[\'installed_without_behavior\'] = []\n-        results[\'not_installed\'] = []\n-        behavior = \'plone.app.contenttypes.behaviors.leadimage.ILeadImage\'\n-        for type_name in DEFAULT_TYPES:\n-            fti = queryUtility(IDexterityFTI, name=type_name)\n-            if fti:\n-                if behavior in fti.behaviors:\n-                    results[\'installed_with_behavior\'].append(type_name)\n-                else:\n-                    results[\'installed_without_behavior\'].append(type_name)\n-            else:\n-                results[\'not_installed\'].append(type_name)\n-        return results\n-\n-\n-class PACInstaller(form.Form):\n-    """Install p.a.c and redirect to migration-form."""\n-\n-    fields = field.Fields()\n-    template = ViewPageTemplateFile(\'pac_installer.pt\')\n-    enableCSRFProtection = True\n-\n-    @property\n-    def pac_installable(self):\n-        qi = get_installer(self.context)\n-        pac_installed = qi.is_product_installed(\'plone.app.contenttypes\')\n-        pac_installable = qi.is_product_installable(\'plone.app.contenttypes\')\n-        return pac_installable and not pac_installed\n-\n-    @property\n-    def pac_installed(self):\n-        qi = get_installer(self.context)\n-        return qi.is_product_installed(\'plone.app.contenttypes\')\n-\n-    @button.buttonAndHandler(_(u\'Install\'), name=\'install\')\n-    def handle_install(self, action):\n-        """ install p.a.c\n-        """\n-        url = self.context.absolute_url()\n-        portal_setup = getToolByName(self.context, \'portal_setup\')\n-        portal_setup.runAllImportStepsFromProfile(\n-            \'profile-plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'],\n-        )\n-\n-        # For types without any instances we want to instantly\n-        # replace the AT-FTI\'s with DX-FTI\'s.\n-        self.installTypesWithoutItems()\n-\n-        url = url + \'/@@atct_migrator\'\n-        self.request.response.redirect(url)\n-\n-    def installTypesWithoutItems(self):\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        for types_name in DEFAULT_TYPES:\n-            if not catalog.unrestrictedSearchResults(portal_type=types_name):\n-                installTypeIfNeeded(types_name)\n-\n-    @button.buttonAndHandler(\n-        _(u\'label_cancel\', default=u\'Cancel\'), name=\'cancel\')\n-    def handle_cancel(self, action):\n-        self.request.response.redirect(self.context.absolute_url())\ndiff --git a/plone/app/contenttypes/migration/configure.zcml b/plone/app/contenttypes/migration/configure.zcml\ndeleted file mode 100644\nindex b4056f3c..00000000\n--- a/plone/app/contenttypes/migration/configure.zcml\n+++ /dev/null\n@@ -1,112 +0,0 @@\n-<configure\n-    xmlns="http://namespaces.zope.org/zope"\n-    xmlns:five="http://namespaces.zope.org/five"\n-    xmlns:i18n="http://namespaces.zope.org/i18n"\n-    xmlns:browser="http://namespaces.zope.org/browser"\n-    xmlns:plone="http://namespaces.plone.org/plone"\n-    i18n_domain="plone">\n-\n-  <browser:resource\n-      name="pac_migrator.css"\n-      file="migrator.css"\n-      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"/>\n-\n-  <browser:page\n-    name="fix_base_classes"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"\n-    class=".browser.FixBaseClasses"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="migrate_from_atct"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"\n-    class=".browser.MigrateFromATContentTypes"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="atct_migrator"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".browser.ATCTMigratorForm"\n-    layer="..interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="base_class_migrator_form"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".browser.BaseClassMigrator"\n-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="atct_migrator_helpers"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".browser.ATCTMigratorHelpers"\n-    layer="..interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="pac_installer"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".browser.PACInstaller"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="custom_migration"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".custom_migration.CustomMigrationForm"\n-    layer="..interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    template="custom_migration.pt"\n-    />\n-\n-  <browser:page\n-    name="display_dx_fields"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".custom_migration.DisplayDXFields"\n-    layer="..interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    template="custom_migration_display_dx_fields.pt"\n-    />\n-\n-  <browser:page\n-    name="test_migration"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".custom_migration.TestMigration"\n-    layer="..interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="export_all_references"\n-    for="*"\n-    class=".utils.ExportAllReferences"\n-    layer="..interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <utility\n-      factory=".vocabularies.ATCTypesVocabulary"\n-      name="plone.app.contenttypes.migration.atctypes"\n-      provides="zope.schema.interfaces.IVocabularyFactory" />\n-\n-  <utility\n-      factory=".vocabularies.ExtendedTypesVocabulary"\n-      name="plone.app.contenttypes.migration.extendedtypes"\n-      provides="zope.schema.interfaces.IVocabularyFactory" />\n-\n-  <utility\n-      factory=".vocabularies.ChangedBaseClasses"\n-      name="plone.app.contenttypes.migration.changed_base_classes"\n-      provides="zope.schema.interfaces.IVocabularyFactory" />\n-\n-  <adapter name="nullmigrator" factory=".migration.BaseCustomMigator"/>\n-\n-</configure>\ndiff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt\ndeleted file mode 100644\nindex 7d19a2cb..00000000\n--- a/plone/app/contenttypes/migration/custom_migration.pt\n+++ /dev/null\n@@ -1,159 +0,0 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"\n-      xmlns:tal="http://xml.zope.org/namespaces/tal"\n-      xmlns:metal="http://xml.zope.org/namespaces/metal"\n-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-      lang="en"\n-      metal:use-macro="context/@@main_template/macros/master"\n-      i18n:domain="plone">\n-\n-<metal:block fill-slot="top_slot"\n-    tal:define="dummy python:request.set(\'disable_border\', 1);\n-                disable_column_two python:request.set(\'disable_plone.rightcolumn\', 1);\n-                disable_column_two python:request.set(\'disable_plone.leftcolumn\', 1);\n-                portal_state context/@@plone_portal_state;\n-                portal_url portal_state/portal_url">\n-  <link rel="stylesheet" type="text/css" href="" media="screen" tal:attributes="href string:${portal_url}/++resource++pac_migrator.css">\n-</metal:block>\n-\n-<body>\n-\n-<metal:custom_title fill-slot="content-title">\n-  <h1 class="documentFirstHeading" i18n:translate="">Custom types migration control panel</h1>\n-</metal:custom_title>\n-<metal:custom_desc fill-slot="content-description">\n-  <div class="documentDescription" i18n:translate="">Migrate custom Archetypes content types to any available Dexterity content types.</div>\n-</metal:custom_desc>\n-\n-<metal:content-core fill-slot="content-core">\n-<metal:block define-macro="content-core"\n-             tal:define="at_types view/getAllArchetypeTypes">\n-  <div class="important">\n-    <h2 i18n:translate="">Important</h2>\n-    <p i18n:translate="">Before migrating your content please read the <a href="https://github.com/plone/plone.app.contenttypes#migration" i18n:name="migrationsection" i18n:translate="">migration-section in the documentation of plone.app.contenttypes</a></p>\n-\n-\n-    <h3>Migrating content that is translated with LinguaPlone</h3>\n-    <p i18n:translate="">Since LinguaPlone does not support Dexterity you need to migrate from LinguaPlone to <a i18n:name="multilingual" href="http://pypi.python.org/pypi/plone.app.multilingual">plone.app.multilingual</a>. The migration from Products.LinguaPlone to plone.app.multilingual should happen before the migration from Archetypes to plone.app.contenttypes. For details on the migration see the <a i18n:name="documentation" i18n:translate="" href="http://pypi.python.org/pypi/plone.app.multilingual#linguaplone-migration">documentation</a></p>\n-    <h3 i18n:translate="">Note about how long it might take</h3>\n-    <p i18n:translate="">Depending of the number of archetypes in your portal, it may take a <strong>really</strong> long time for the migration to be done.\n-    Stay calm, be patient and check your logs for progress-information.</p>\n-    </div>\n-    <script type="text/javascript">\n-        // function that toggle an icon by calling the p_viewName view\n-        function getDXFields(at_typename, dx_typename) {\n-          at_safe = at_typename.replace(\' \', \'_space_\');\n-          $.ajax({\n-            url: \'@@display_dx_fields\',\n-            dataType: \'html\',\n-            data: {\'at_typename\': at_typename,\n-                   \'dx_typename\': dx_typename},\n-            cache: false,\n-            success: function(data) {\n-                var $div = $(\'#hook_at_fti_\' + at_safe);\n-                $div.empty();\n-                $div.html(data);\n-              },\n-            error: function(jqXHR, textStatus, errorThrown) {\n-              }\n-            });\n-        }\n-        $(document).ready(function () {\n-            $(\'input[name="form.button.Test"]\').on( "click", function(e) {\n-                e.preventDefault();\n-                var $this = $(this);\n-                var tested_type = $this.parent().siblings(\'select.selectedType\');\n-                $this.parent().removeClass(\'error\');\n-                $this.parent().siblings(\'.fieldsMapping\').removeClass(\'error\');\n-                $this.parent().removeClass(\'success\');\n-                $this.parent().addClass(\'testing\');\n-                $.ajax({\n-                    url: \'@@test_migration?\' + $(this).parents(\'form\').serialize() + \'&tested_type=\' + tested_type.attr(\'name\'),\n-                    dataType: \'json\',\n-                    success: function(data) {\n-                        $this.parent().removeClass(\'testing\');\n-                        if(data.status === \'error\') {\n-                            $this.parent().addClass(\'error\');\n-                            $this.parent().siblings(\'.fieldsMapping\').addClass(\'error\');\n-                        }\n-                        else\xc2\xa0{\n-                            $this.parent().addClass(\'success\');\n-                        }\n-                    },\n-                    error: function(jqXHR, textStatus, errorThrown) {\n-                        $this.parent().removeClass(\'testing\');\n-                        $this.parent().addClass(\'error\');\n-                        $this.parent().siblings(\'.fieldsMapping\').addClass(\'error\');\n-                    }\n-                });\n-            });\n-        });\n-    </script>\n-    <tal:block condition="at_types">\n-        <div id="migration-options">\n-          <h2 i18n:translate="">Migrate contents</h2>\n-          <div\n-            class="documentDescription">\n-            <p i18n:translate="">You can select which AT content type you want to migrate to an existing DX content type.</p>\n-            <form id="migrateCustomATForm" method="post"\n-                  tal:attributes="action python:context.absolute_url() + \'/@@custom_migration\'">\n-\n-            <input class="field" type="checkbox" name="patch_searchabletext" id="patch_searchabletext" />\n-            <label for="patch_searchabletext" i18n:translate="">Disable reindexing objects during migration</label>\n-            <span class="formHelp" id="patch_searchabletext_help" i18n:translate="">This can speed up your migration a lot if you have a lot of files with searchable text.</span>\n-\n-            <table>\n-                <tr tal:repeat="at_type at_types">\n-                  <tal:block tal:define="safe_at_id python:at_type[\'id\'].replace(\' \', \'_space_\')">\n-                    <td valign="top">\n-                        <p tal:content="at_type/title" style="font-weight: bold;">AT content type title</p>\n-                        <tal:block repeat="field python: view.getFieldsForATType(at_type)">\n-                            <p tal:content="field/title" i18n:translate="">Field name</p>\n-                            <input type="hidden" tal:attributes="name string:${safe_at_id}:list;\n-                                                                 value string:${field/id}__type__${field/type};" />\n-                        </tal:block>\n-                    </td>\n-                    <td valign="top">\n-                        <select tal:attributes="onChange string:javascript:getDXFields(at_typename=\'${at_type/id}\', this.value);\n-                                                name string:dx_select_${safe_at_id};"\n-                                class="selectedType">\n-                            <option value="" selected="selected" i18n:translate="">Do not migrate</option>\n-                            <option tal:repeat="dx_type view/getDXFTIs"\n-                                    tal:attributes="value dx_type/id"\n-                                    tal:content="dx_type/title"\n-                                    i18n:translate="">DX type name</option>\n-                        </select>\n-                        <div id="hook_at_fti_News_Item"\n-                             class="field fieldsMapping"\n-                             tal:attributes="id string:hook_at_fti_${safe_at_id}" />\n-                        <br />\n-                        <div class="testConfig">\n-                            <input type="submit"\n-                                   name="form.button.Test"\n-                                   class="btn btn-primary"\n-                                   value="Test configuration"\n-                                   i18n:attributes="value"\n-                                   i18n:domain="plone"/>&nbsp;\n-                        </div>\n-                    </td>\n-                  </tal:block>\n-                </tr>\n-            </table>\n-            <div>\n-              <br />\n-              <input type="submit" name="form.button.Migrate" class="btn btn-primary" value="Migrate" i18n:attributes="value" i18n:domain="plone"/>&nbsp;\n-              <input type="submit" name="form.button.Cancel" class="btn btn-secondary" value="Cancel" i18n:attributes="value" i18n:domain="plone"/>\n-            </div>\n-            </form>\n-          </div>\n-        </div>\n-    </tal:block>\n-  <tal:block condition="not:at_types">\n-    <div class="important">\n-      <h2 i18n:translate="">Warning</h2>\n-      <p i18n:translate="" class="strong">No content to migrate.</p>\n-  </tal:block>\n-\n-</metal:block>\n-</metal:content-core>\n-</body>\n-</html>\ndiff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py\ndeleted file mode 100644\nindex 2cfdabb1..00000000\n--- a/plone/app/contenttypes/migration/custom_migration.py\n+++ /dev/null\n@@ -1,350 +0,0 @@\n-# -*- coding: UTF-8 -*-\n-from plone.app.contenttypes import _\n-from plone.app.contenttypes.migration.migration import migrateCustomAT\n-from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.interfaces import IDexterityFTI\n-from plone.dexterity.utils import iterSchemataForType\n-from Products.Archetypes.interfaces import IBaseObject\n-from Products.ATContentTypes.content.schemata import ATContentTypeSchema\n-from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.utils import safe_unicode\n-from Products.Five.browser import BrowserView\n-from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n-from Products.statusmessages.interfaces import IStatusMessage\n-from zExceptions import NotFound\n-from zope.i18n import translate\n-\n-import json\n-import logging\n-import traceback\n-\n-\n-logger = logging.getLogger(__name__)\n-\n-HAS_EXTENDER = True\n-try:\n-    from archetypes.schemaextender.extender import instanceSchemaFactory\n-except ImportError:\n-    HAS_EXTENDER = False\n-\n-\n-class CustomMigrationForm(BrowserView):\n-\n-    template = ViewPageTemplateFile(\'custom_migration.pt\')\n-    at_metadata_fields = ATContentTypeSchema.keys()\n-    dx_metadata_fields = list(at_metadata_fields)\n-    # some metadata names are different between AT and DX...\n-    dx_metadata_fields.remove(\'allowDiscussion\')\n-    dx_metadata_fields.remove(\'excludeFromNav\')\n-    dx_metadata_fields.append(\'allow_discussion\')\n-    dx_metadata_fields.append(\'exclude_from_nav\')\n-\n-    def __call__(self):\n-        # check that we can actually access this form,\n-        # aka the current user has an advice to add or edit\n-        form = self.request.form\n-        cancelled = form.get(\'form.button.Cancel\', False)\n-        submitted = form.get(\'form.button.Migrate\', False)\n-        # test = form.get(\'form.button.Test\', False)\n-        if submitted:\n-            # proceed, call the migration methdd\n-            results = self.migrate()\n-            messages = IStatusMessage(self.request)\n-            for migration_result in results:\n-                res_type = migration_result.get(\'type\')\n-                res_infos = migration_result.get(\'infos\')\n-                if res_infos.get(\'errors\'):\n-                    messages.add(\n-                        u\'Error when migrating "{0}" type. Check the \'\n-                        u\'log for other informations.\'.format(res_type),\n-                        type=u\'error\',\n-                    )\n-                else:\n-                    raw_message = \'Migration applied successfully for {0} \' \\\n-                        \'"{1}" items.\'\n-                    msg = translate(\n-                        raw_message.format(res_infos.get(\'counter\'), res_type),\n-                        domain=\'plone.app.contenttypes\',\n-                    )\n-                    messages.add(msg, type=u\'info\')\n-        elif cancelled:\n-            self.request.response.redirect(form.get(\'form.HTTP_REFERER\'))\n-        return self.index()\n-\n-    def getAllArchetypeTypes(self):\n-        at_types = self.getATFTIs()\n-        at_types.extend(self.getATTypesWithoutFTI())\n-        return at_types\n-\n-    def getATFTIs(self):\n-        \'\'\'Returns a list of all AT types with existing instances\n-        (including default-types).\n-        \'\'\'\n-        results = []\n-        archetype_tool = getToolByName(self.context, \'archetype_tool\', None)\n-        # if we do not have archetype_tool, it means that we have\n-        # no registered AT types\n-        if not archetype_tool:\n-            return results\n-\n-        typesTool = getToolByName(self.context, \'portal_types\')\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        registeredTypeNames = [registered[\'name\'] for registered\n-                               in archetype_tool.listRegisteredTypes()]\n-        for fti in typesTool.listTypeInfo():\n-            ftiId = fti.getId()\n-            if hasattr(fti, \'content_meta_type\') and \\\n-               fti.content_meta_type in registeredTypeNames and \\\n-               catalog(portal_type=ftiId):\n-                results.append({\'id\': ftiId,\n-                                \'title\': fti.Title(),\n-                                \'removed\': False})\n-        return results\n-\n-    def getATTypesWithoutFTI(self):\n-        """Returns a list of the id\'s of archetypes-types that are\n-           not registered in portal_types but still have instances.\n-        """\n-        results = []\n-        all_registered_types = [i[\'id\'] for i in self.getATFTIs()]\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        for meta_type in catalog.uniqueValuesFor(\'meta_type\'):\n-            # querying for meta_type will only return at-types\n-            brain = catalog(meta_type=meta_type, sort_limit=1)[0]\n-            try:\n-                obj = brain.getObject()\n-            except (KeyError, NotFound):\n-                continue\n-            if IDexterityContent.providedBy(obj):\n-                continue\n-            if not IBaseObject.providedBy(obj):\n-                # Discussion items are neither AT not DX\n-                continue\n-            typename = brain.portal_type\n-            if typename not in all_registered_types:\n-                results.append({\'id\': typename,\n-                                \'title\': typename,\n-                                \'removed\': True})\n-        return results\n-\n-    def getDXFTIs(self):\n-        \'\'\'Returns the FTI\'s of all DX-Types (including default-types).\'\'\'\n-        results = []\n-        portal = self.context\n-        ttool = getToolByName(portal, \'portal_types\')\n-        for fti in ttool.listTypeInfo():\n-            if IDexterityFTI.providedBy(fti):\n-                results.append({\'id\': fti.getId(),\n-                                \'title\': fti.Title()})\n-        return results\n-\n-    def getFieldsForATType(self, typeinfo):\n-        \'\'\'Returns schema fields (name and type) for the given AT typename.\'\'\'\n-        if typeinfo[\'removed\']:\n-            return self.getFieldsForATTypeWithoutFTI(typeinfo[\'id\'])\n-        return self.getFieldsForATTypeWithFTI(typeinfo[\'id\'])\n-\n-    def getFieldsForATTypeWithFTI(self, typename):\n-        \'\'\'Returns schema fields (name and type) from the fti.\'\'\'\n-        results = []\n-        typesTool = getToolByName(self.context, \'portal_types\')\n-        fti = typesTool.getTypeInfo(typename)\n-        archetype_tool = getToolByName(self.context, \'archetype_tool\', None)\n-        if not fti or not archetype_tool:\n-            return results\n-        schema = None\n-        # a schema instance is stored in the archetype_tool\n-        for regType in archetype_tool.listRegisteredTypes():\n-            if regType[\'meta_type\'] == fti.content_meta_type:\n-                if HAS_EXTENDER:\n-                    schema = instanceSchemaFactory(regType[\'klass\'])\n-                else:\n-                    schema = regType[\'schema\']\n-                break\n-        if not schema:\n-            return results\n-        for field in schema.fields():\n-            if not field.getName() in self.at_metadata_fields:\n-                translated_label = translate(safe_unicode(field.widget.label))\n-                results.append(\n-                    {\'id\': field.getName(),\n-                     \'title\': \'{0} ({1})\'.format(\n-                         translated_label,\n-                         field.getType()\n-                     ),\n-                     \'type\': field.getType()}\n-                )\n-        return results\n-\n-    def getFieldsForATTypeWithoutFTI(self, typename):\n-        """Returns a list of fields for archetypes-types without a fti.\n-           Instead of iterating over the schema in the fti it takes one\n-           instance and gets the schema from that.\n-        """\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        results = []\n-        brains = catalog(portal_type=typename, sort_limit=1)\n-        if not brains:\n-            return results\n-        try:\n-            obj = brains[0].getObject()\n-        except (KeyError, NotFound):\n-            return results\n-        for field_name in obj.schema._fields:\n-            field = obj.schema._fields[field_name]\n-            if not field.getName() in self.at_metadata_fields:\n-                translated_label = translate(field.widget.label)\n-                results.append(\n-                    {\'id\': field.getName(),\n-                     \'title\': \'{0} ({1})\'.format(\n-                         translated_label,\n-                         field.getType()\n-                     ),\n-                     \'type\': field.getType()}\n-                )\n-        return results\n-\n-    def getFieldsForDXType(self, typename):\n-        \'\'\'Returns schema fields (name and type) for the given DX typename.\'\'\'\n-        results = []\n-        typesTool = getToolByName(self.context, \'portal_types\')\n-        fti = typesTool.getTypeInfo(typename)\n-        if not fti:\n-            return results\n-\n-        for schemata in iterSchemataForType(typename):\n-            for fieldName, field in schemata.namesAndDescriptions():\n-                # ignore Dublin Core fields\n-                if fieldName in self.dx_metadata_fields:\n-                    continue\n-                translated_title = translate(field.title)\n-                class_name = field.__class__.__name__\n-                results.append(\n-                    {\'id\': fieldName,\n-                     \'title\': \'{0} ({1})\'.format(translated_title, class_name),\n-                     \'type\': class_name})\n-        return results\n-\n-    def getPossibleTargetField(self, fieldtype):\n-        \'\'\' a list of DX-field types\'\'\'\n-\n-    def isFolderish(self):\n-        \'\'\' decide which base-class we use for the migrator\'\'\'\n-\n-    def migrate(self, dry_run=False):\n-        \'\'\'Build data from the migration form. We will build a dict like :\n-           {\'MyATPortalType\':\n-                {\'MyDXPortalType\': (\n-                    {\'AT_field_name\': \'fieldname1\',\n-                     \'AT_field_type\': \'Products.Archetypes.Field.TextField\',\n-                     \'DX_field_name\': \'field_name1\',\n-                     \'DX_field_type\': \'RichText\'}, )}}\n-        Call the migrateCustomAT migrator for each AT content_type we choose\n-        to migrate.\n-        \'\'\'\n-        data = {}\n-        form = self.request.form\n-        patch_searchabletext = form.get(\'patch_searchabletext\')\n-        # manipulate what we receive in the form and build a useable data dict\n-        for k in self.request.form.keys():\n-            if k.startswith(\'dx_select_\'):\n-                # we found select where we choose a DX type regarding an AT\n-                # type the selelect name is like \'dx_select_MyATPortalType\'\n-                if not form[k] or (dry_run and k != form.get(\'tested_type\')):\n-                    # nothing selected in this select, continue\n-                    continue\n-                form_at_typename = k[10:]\n-                form_dx_typename = form[k]\n-                at_typename = form_at_typename.replace(\'_space_\', \' \')\n-                dx_typename = form_dx_typename.replace(\'_space_\', \' \')\n-\n-                data[at_typename] = {\'target_type\': dx_typename,\n-                                     \'field_mapping\': []}\n-                # now handle fields mapping for found DX/AT type migration\n-                # definition we have 2 keys with relevant mappings, first key\n-                # is the AT typename second key is a particular key like\n-                # \'dx_DXPortalType__for__MyATPortalType\n-                dx_key = \'dx_{0}__for__{1}\'.format(\n-                    form_dx_typename,\n-                    form_at_typename,\n-                )\n-                for at_field in form[form_at_typename]:\n-                    if form.get(dx_key) is None:\n-                        # No field-mappings\n-                        continue\n-                    dx_field = form[dx_key][form[form_at_typename].index(\n-                        at_field)]\n-                    if not dx_field:\n-                        # Do not migrate field\n-                        continue\n-                    at_field_name, at_field_type = at_field.split(\'__type__\')\n-                    dx_field_name, dx_field_type = dx_field.split(\'__type__\')\n-                    field_data = {\'AT_field_name\': at_field_name,\n-                                  \'AT_field_type\': at_field_type,\n-                                  \'DX_field_name\': dx_field_name,\n-                                  \'DX_field_type\': dx_field_type, }\n-                    data[at_typename][\'field_mapping\'].append(field_data)\n-\n-        # now that the data dict contains relevant information, we can call\n-        # the custom migrator\n-        migration_results = []\n-        for at_typename in data:\n-            fields_mapping = data[at_typename][\'field_mapping\']\n-            res = migrateCustomAT(\n-                fields_mapping=fields_mapping,\n-                src_type=at_typename,\n-                dst_type=data[at_typename][\'target_type\'],\n-                dry_run=dry_run,\n-                patch_searchabletext=patch_searchabletext,\n-                )\n-            migration_results.append({\'type\': at_typename,\n-                                      \'infos\': res})\n-        return migration_results\n-\n-\n-class DisplayDXFields(CustomMigrationForm):\n-\n-    template = ViewPageTemplateFile(\'custom_migration_display_dx_fields.pt\')\n-\n-    def __init__(self, context, request):\n-        CustomMigrationForm.__init__(self, context, request)\n-        self.at_typename = request.form.get(\'at_typename\')\n-        self.dx_typename = request.form.get(\'dx_typename\')\n-\n-    def __call__(self):\n-        \'\'\'\n-        \'\'\'\n-        return self.index()\n-\n-\n-class TestMigration(CustomMigrationForm):\n-\n-    def __call__(self):\n-        \'\'\'\n-        View that call migrate method with dry_run mode set.\n-        Returns a json response with the result.\n-        This view is called by a js.\n-        \'\'\'\n-        response = {}\n-        error_msg = _(u\'Migrating to this content type is impossible with \'\n-                      u\'this configuration\')\n-        try:\n-            results = self.migrate(dry_run=True)\n-        except Exception as e:\n-            trace = traceback.format_exc()\n-            msg = \'Test-Migration failed: {0}\\n{1}\\n\'.format(e, trace)\n-            logger.error(msg)\n-            response[\'status\'] = \'error\'\n-            response[\'message\'] = msg\n-            return json.dumps(response)\n-\n-        migration_result = results[0]\n-        res_infos = migration_result.get(\'infos\')\n-        if res_infos.get(\'errors\'):\n-            response[\'status\'] = \'error\'\n-            response[\'message\'] = error_msg\n-        else:\n-            response[\'status\'] = \'success\'\n-            response[\'message\'] = \'Testing migration succesful\'\n-        self.request.response.setHeader(\'Content-type\', \'application/json\')\n-        return json.dumps(response)\ndiff --git a/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt b/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt\ndeleted file mode 100644\nindex c8829ca3..00000000\n--- a/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt\n+++ /dev/null\n@@ -1,13 +0,0 @@\n-<tal:block tal:define="dx_typename view/dx_typename;\n-                       at_typename view/at_typename;\n-                       safe_dx_typename python:dx_typename.replace(\' \', \'_space_\');\n-                       safe_at_typename python:at_typename.replace(\' \', \'_space_\')">\n-<tal:loop repeat="at_field python: view.getFieldsForATTypeWithoutFTI(at_typename)">\n-    <select tal:attributes="name string:dx_${safe_dx_typename}__for__${safe_at_typename}:list;">\n-        <option value="">Do not migrate</option>\n-        <option tal:repeat="dx_field python: view.getFieldsForDXType(dx_typename)"\n-                tal:attributes="value string:${dx_field/id}__type__${dx_field/type};"\n-                tal:content="string:${dx_field/title}">DX field name</option>\n-    </select>\n-</tal:loop>\n-</tal:block>\n\\ No newline at end of file\ndiff --git a/plone/app/contenttypes/migration/dxmigration.py b/plone/app/contenttypes/migration/dxmigration.py\ndeleted file mode 100644\nindex b356ddbd..00000000\n--- a/plone/app/contenttypes/migration/dxmigration.py\n+++ /dev/null\n@@ -1,198 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.contenttypes.interfaces import IEvent\n-from plone.app.contenttypes.migration.field_migrators import datetime_fixer\n-from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.interfaces import IDexterityFTI\n-from plone.dexterity.schema import SCHEMA_CACHE\n-from plone.event.utils import default_timezone\n-from plone.folder.interfaces import IOrdering\n-from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base\n-from Products.CMFCore.utils import getToolByName\n-from Products.contentmigration.basemigrator.migrator import CMFItemMigrator\n-from Products.contentmigration.basemigrator.walker import CatalogWalker\n-from zExceptions import NotFound\n-from zope.annotation.interfaces import IAnnotations\n-from zope.component import queryUtility\n-from zope.component.hooks import getSite\n-from zope.interface import alsoProvides\n-\n-import importlib\n-import logging\n-\n-\n-logger = logging.getLogger(__name__)\n-\n-\n-def migrate(portal, migrator):\n-    """return a CatalogWalker instance in order\n-    to have its output after migration"""\n-    walker = CatalogWalker(portal, migrator)()\n-    return walker\n-\n-\n-class ContentMigrator(CMFItemMigrator):\n-    """Base for contentish DX\n-    """\n-\n-    def migrate_atctmetadata(self):\n-        self.new.exclude_from_nav = self.old.exclude_from_nav\n-\n-\n-def migrate_to_pa_event(context):\n-    # Install plone.app.event\n-    context.runAllImportStepsFromProfile(\'profile-plone.app.event:default\')\n-    # Re-import types to get newest Event type\n-    context.runImportStepFromProfile(\n-        \'profile-plone.app.contenttypes:default\',\n-        \'typeinfo\'\n-    )\n-    portal = getSite()\n-    migrate(portal, DXOldEventMigrator)\n-    SCHEMA_CACHE.clear()\n-\n-\n-class DXOldEventMigrator(ContentMigrator):\n-    """Migrator for 1.0 plone.app.contenttypes DX events"""\n-\n-    src_portal_type = \'Event\'\n-    src_meta_type = \'Dexterity Item\'\n-    dst_portal_type = \'Event\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate(self):\n-        # Only migrate items using old Schema\n-        if IEvent.providedBy(self.old) and hasattr(self.old, \'start_date\'):\n-            ContentMigrator.migrate(self)\n-\n-    def migrate_schema_fields(self):\n-        timezone = str(self.old.start_date.tzinfo) \\\n-            if self.old.start_date.tzinfo \\\n-            else default_timezone(fallback=\'UTC\')\n-\n-        self.new.start = datetime_fixer(self.old.start_date, timezone)\n-        self.new.end = datetime_fixer(self.old.end_date, timezone)\n-\n-        if hasattr(self.old, \'location\'):\n-            self.new.location = self.old.location\n-        if hasattr(self.old, \'attendees\'):\n-            self.new.attendees = tuple(self.old.attendees.splitlines())\n-        if hasattr(self.old, \'event_url\'):\n-            self.new.event_url = self.old.event_url\n-        if hasattr(self.old, \'contact_name\'):\n-            self.new.contact_name = self.old.contact_name\n-        if hasattr(self.old, \'contact_email\'):\n-            self.new.contact_email = self.old.contact_email\n-        if hasattr(self.old, \'contact_phone\'):\n-            self.new.contact_phone = self.old.contact_phone\n-        if hasattr(self.old, \'text\'):\n-            # Copy the entire richtext object, not just it\'s representation\n-            self.new.text = self.old.text\n-\n-\n-class DXEventMigrator(ContentMigrator):\n-    """Migrator for plone.app.event.dx events"""\n-\n-    src_portal_type = \'plone.app.event.dx.event\'\n-    src_meta_type = \'Dexterity Item\'\n-    dst_portal_type = \'Event\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        self.new.start = datetime_fixer(self.old.start, self.old.timezone)\n-        self.new.end = datetime_fixer(self.old.end, self.old.timezone)\n-        self.new.whole_day = self.old.whole_day\n-        self.new.open_end = self.old.open_end\n-        self.new.recurrence = self.old.recurrence\n-        self.new.location = self.old.location\n-        self.new.attendees = self.old.attendees\n-        self.new.event_url = self.old.event_url\n-        self.new.contact_name = self.old.contact_name\n-        self.new.contact_email = self.old.contact_email\n-        self.new.contact_phone = self.old.contact_phone\n-        # The old behavior for the rich text field does not exist an more.\n-        # Look up the old value directly from the Annotation storage\n-        # Copy the entire richtext object, not just it\'s representation\n-        annotations = IAnnotations(self.old)\n-        old_text = annotations.get(\n-            \'plone.app.event.dx.behaviors.IEventSummary.text\', None)\n-        self.new.text = old_text\n-\n-\n-def get_old_class_name_string(obj):\n-    """Returns the current class name string."""\n-    return \'{0}.{1}\'.format(obj.__module__, obj.__class__.__name__)\n-\n-\n-def get_portal_type_name_string(obj):\n-    """Returns the klass-attribute of the fti."""\n-    fti = queryUtility(IDexterityFTI, name=obj.portal_type)\n-    if not fti:\n-        return False\n-    return fti.klass\n-\n-\n-def migrate_base_class_to_new_class(obj,\n-                                    indexes=None,\n-                                    old_class_name=\'\',\n-                                    new_class_name=\'\',\n-                                    migrate_to_folderish=False,\n-                                    ):\n-    if indexes is None:\n-        indexes = [\'is_folderish\', \'object_provides\']\n-    if not old_class_name:\n-        old_class_name = get_old_class_name_string(obj)\n-    if not new_class_name:\n-        new_class_name = get_portal_type_name_string(obj)\n-        if not new_class_name:\n-            logger.warning(\n-                \'The type {0} has no fti!\'.format(obj.portal_type))\n-            return False\n-\n-    was_item = not isinstance(obj, BTreeFolder2Base)\n-    if old_class_name != new_class_name:\n-        obj_id = obj.getId()\n-        module_name, class_name = new_class_name.rsplit(\'.\', 1)\n-        module = importlib.import_module(module_name)\n-        new_class = getattr(module, class_name)\n-\n-        # update obj class\n-        parent = obj.__parent__\n-        parent._delOb(obj_id)\n-        obj.__class__ = new_class\n-        parent._setOb(obj_id, obj)\n-\n-    is_container = isinstance(obj, BTreeFolder2Base)\n-\n-    if was_item and is_container or migrate_to_folderish and is_container:\n-        alsoProvides(obj, IOrdering)\n-        #  If Itemish becomes Folderish we have to update obj _tree\n-        BTreeFolder2Base._initBTrees(obj)\n-\n-    # reindex\n-    obj.reindexObject(indexes)\n-\n-    return True\n-\n-\n-def list_of_objects_with_changed_base_class(context):\n-    catalog = getToolByName(context, \'portal_catalog\')\n-    for brain in catalog(object_provides=IDexterityContent.__identifier__):\n-        try:\n-            obj = brain.getObject()\n-        except (KeyError, NotFound):\n-            logger.warn(\'Object {0} not found\'.format(brain.getPath()))\n-            continue\n-        if get_portal_type_name_string(obj) != get_old_class_name_string(obj):\n-            yield obj\n-\n-\n-def list_of_changed_base_class_names(context):\n-    """Returns list of class names that are not longer in portal_types."""\n-    changed_base_class_names = {}\n-    for obj in list_of_objects_with_changed_base_class(context):\n-        changed_base_class_name = get_old_class_name_string(obj)\n-        if changed_base_class_name not in changed_base_class_names:\n-            changed_base_class_names[changed_base_class_name] = 1\n-        else:\n-            changed_base_class_names[changed_base_class_name] += 1\n-    return changed_base_class_names\ndiff --git a/plone/app/contenttypes/migration/field_migrators.py b/plone/app/contenttypes/migration/field_migrators.py\ndeleted file mode 100644\nindex d4be41ab..00000000\n--- a/plone/app/contenttypes/migration/field_migrators.py\n+++ /dev/null\n@@ -1,178 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.textfield.value import RichTextValue\n-from plone.event.utils import default_timezone\n-from plone.namedfile.file import NamedBlobFile\n-from plone.namedfile.file import NamedBlobImage\n-from Products.CMFPlone.utils import safe_hasattr\n-from Products.CMFPlone.utils import safe_unicode\n-\n-import logging\n-import pytz\n-\n-\n-logger = logging.getLogger(__name__)\n-\n-\n-def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """Migrate a generic simple field.\n-\n-    Copies the value of a Archetypes-object to a attribute of the same name\n-    to the target-object. The only transform is a safe_unicode of the value.\n-    """\n-    field = src_obj.getField(src_fieldname)\n-    if field:\n-        at_value = field.get(src_obj)\n-    else:\n-        at_value = getattr(src_obj, src_fieldname, None)\n-        if at_value and hasattr(at_value, \'__call__\'):\n-            at_value = at_value()\n-    if isinstance(at_value, tuple):\n-        at_value = tuple(safe_unicode(i) for i in at_value)\n-    if isinstance(at_value, list):\n-        at_value = [safe_unicode(i) for i in at_value]\n-    if at_value:\n-        setattr(dst_obj, dst_fieldname, safe_unicode(at_value))\n-\n-\n-def migrate_richtextfield(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """\n-    migrate a rich text field.\n-    This field needs some extra stuffs like keep the same mimetype.\n-    """\n-    field = src_obj.getField(src_fieldname)\n-    raw_text = \'\'\n-    if field:\n-        mime_type = field.getContentType(src_obj)\n-        raw_text = safe_unicode(field.getRaw(src_obj))\n-    else:\n-        at_value = getattr(src_obj, src_fieldname, None)\n-        if at_value:\n-            mime_type = at_value.mimetype\n-            raw_text = safe_unicode(at_value.raw)\n-\n-    if raw_text.strip() == \'\':\n-        return\n-    richtext = RichTextValue(raw=raw_text, mimeType=mime_type,\n-                             outputMimeType=\'text/x-html-safe\')\n-    setattr(dst_obj, dst_fieldname, richtext)\n-\n-\n-def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """\n-    migrate an image field.\n-    This field needs to be migrated with an NamedBlobImage instance.\n-    """\n-    # get old image data and filename\n-    field = src_obj.getField(src_fieldname)\n-    accessor = field.getAccessor(src_obj)\n-    old_image = accessor()\n-    if old_image == \'\':\n-        return\n-    filename = safe_unicode(old_image.filename)\n-    old_image_data = old_image.data\n-    if safe_hasattr(old_image_data, \'data\'):\n-        old_image_data = old_image_data.data\n-\n-    # create the new image field\n-    namedblobimage = NamedBlobImage(data=old_image_data,\n-                                    filename=filename)\n-\n-    # set new field on destination object\n-    setattr(dst_obj, dst_fieldname, namedblobimage)\n-\n-    # handle a possible image caption field\n-    # postulate is the old caption field name is ending by \'Caption\'\n-    # and the new field name is ending by \'_caption\'\n-    # is this postulate correct ?\n-    # should this field not be handle by itself because it will appear in the\n-    # old field list ?\n-    caption_field = src_obj.getField(\'{0}Caption\'.format(src_fieldname), None)\n-    if caption_field:\n-        setattr(dst_obj,\n-                (\'{0}_caption\'.format(dst_fieldname)),\n-                safe_unicode(caption_field.get(src_obj)))\n-\n-    logger.info(u\'Migrating image {0}\'.format(filename))\n-\n-\n-def migrate_blobimagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """\n-    migrate an image field.\n-    Actually this field needs only to copy the existing NamedBlobImage instance\n-    to the new dst_obj, but we do some more in detail and create new fields.\n-    """\n-    old_image = getattr(src_obj, src_fieldname)\n-    if old_image == \'\':\n-        return\n-    filename = safe_unicode(old_image.filename)\n-    old_image_data = old_image.data\n-    if safe_hasattr(old_image_data, \'data\'):\n-        old_image_data = old_image_data.data\n-    namedblobimage = NamedBlobImage(data=old_image_data,\n-                                    filename=filename)\n-\n-    # set new field on destination object\n-    setattr(dst_obj, dst_fieldname, namedblobimage)\n-\n-    # handle a possible image caption field\n-    field = \'{0}_caption\'.format(src_fieldname)\n-    old_image_caption = getattr(src_obj, field, None)\n-    if old_image_caption:\n-        setattr(dst_obj,\n-                (\'{0}_caption\'.format(dst_fieldname)),\n-                safe_unicode(old_image_caption))\n-\n-    logger.info(u\'Migrating image {0}\'.format(filename))\n-\n-\n-def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """\n-    migrate a file field.\n-    This field needs to be migrated with an NamedBlobFile instance.\n-    """\n-    old_file = src_obj.getField(src_fieldname).get(src_obj)\n-    if old_file == \'\':\n-        return\n-    filename = safe_unicode(old_file.filename)\n-    old_file_data = old_file.data\n-    if safe_hasattr(old_file_data, \'data\'):\n-        old_file_data = old_file_data.data\n-    namedblobfile = NamedBlobFile(\n-        contentType=old_file.content_type,\n-        data=old_file_data,\n-        filename=filename)\n-    setattr(dst_obj, dst_fieldname, namedblobfile)\n-    logger.info(u\'Migrating file {0}\'.format(filename))\n-\n-\n-def migrate_datetimefield(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """Migrate a datefield."""\n-    old_value = src_obj.getField(src_fieldname).get(src_obj)\n-    if old_value == \'\' or old_value is None:\n-        return\n-    if src_obj.getField(\'timezone\', None) is not None:\n-        old_timezone = src_obj.getField(\'timezone\').get(src_obj)\n-    else:\n-        old_timezone = default_timezone(fallback=\'UTC\')\n-    new_value = datetime_fixer(old_value.asdatetime(), old_timezone)\n-    setattr(dst_obj, dst_fieldname, new_value)\n-\n-\n-def datetime_fixer(dt, zone):\n-    timezone = pytz.timezone(zone)\n-    if dt.tzinfo is None:\n-        return timezone.localize(dt)\n-    else:\n-        return timezone.normalize(dt)\n-\n-\n-# This mapping is needed to get the right migration method\n-# we use the full field type path as it is retrieved from the target-field\n-# (field.getType()), to avoid conflict.\n-# TODO In the __future__ we should have a more dynamic way to configure this\n-# mapping\n-FIELDS_MAPPING = {\'RichText\': migrate_richtextfield,\n-                  \'NamedBlobFile\': migrate_filefield,\n-                  \'NamedBlobImage\': migrate_imagefield,\n-                  \'Datetime\': migrate_datetimefield,\n-                  \'Date\': migrate_datetimefield}\ndiff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py\ndeleted file mode 100644\nindex 050c75bb..00000000\n--- a/plone/app/contenttypes/migration/migration.py\n+++ /dev/null\n@@ -1,581 +0,0 @@\n-# -*- coding: utf-8 -*-\n-"""\n-Migrating ATContentTypes to plone.app.contenttypes objects.\n-\n-This module imports from Product.contentmigration on which we depend\n-only in the setuptools extra_requiers [migrate_atct]. Importing this\n-module will only work if Products.contentmigration is installed so make sure\n-you catch ImportErrors\n-"""\n-from plone.app.contenttypes.behaviors.collection import ICollection\n-from plone.app.contenttypes.migration.dxmigration import DXEventMigrator\n-from plone.app.contenttypes.migration.dxmigration import DXOldEventMigrator\n-from plone.app.contenttypes.migration.field_migrators import FIELDS_MAPPING\n-from plone.app.contenttypes.migration.field_migrators import migrate_blobimagefield  # noqa\n-from plone.app.contenttypes.migration.field_migrators import migrate_datetimefield  # noqa\n-from plone.app.contenttypes.migration.field_migrators import migrate_filefield\n-from plone.app.contenttypes.migration.field_migrators import migrate_imagefield\n-from plone.app.contenttypes.migration.field_migrators import migrate_richtextfield  # noqa\n-from plone.app.contenttypes.migration.field_migrators import migrate_simplefield  # noqa\n-from plone.app.contenttypes.migration.patches import patch_before_migration\n-from plone.app.contenttypes.migration.patches import undo_patch_after_migration\n-from plone.app.contenttypes.migration.utils import copy_contentrules\n-from plone.app.contenttypes.migration.utils import migrate_leadimage\n-from plone.app.contenttypes.migration.utils import migrate_portlets\n-from plone.app.contenttypes.migration.utils import move_comments\n-from plone.app.contenttypes.upgrades import LISTING_VIEW_MAPPING\n-from plone.app.dexterity.behaviors.nextprevious import INextPreviousToggle\n-from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.interfaces import IDexterityFTI\n-from Products.CMFCore.utils import getToolByName\n-from Products.contentmigration.basemigrator.migrator import CMFFolderMigrator\n-from Products.contentmigration.basemigrator.migrator import CMFItemMigrator\n-from Products.contentmigration.basemigrator.walker import CatalogWalker\n-from Products.contentmigration.walker import CustomQueryWalker\n-from Acquisition import aq_base\n-from zExceptions import NotFound\n-from zope.component import adapter\n-from zope.component import getAdapters\n-from zope.component import getMultiAdapter\n-from zope.component.hooks import getSite\n-from zope.interface import implementer\n-from zope.interface import Interface\n-\n-import logging\n-import transaction\n-\n-\n-logger = logging.getLogger(__name__)\n-\n-\n-def migrate(portal, migrator):\n-    """return a CatalogWalker instance in order\n-    to have its output after migration"""\n-    walker = CatalogWalker(portal, migrator)()\n-    return walker\n-\n-\n-class ICustomMigrator(Interface):\n-    """Adapter implementer interface for custom migrators.\n-    Please note that you have to register named adapters in order to be able to\n-    register multiple adapters to the same adaptee.\n-    """\n-    def migrate(old, new):\n-        """Start the custom migraton.\n-        :param old: The old content object.\n-        :param new: The new content object.\n-        """\n-\n-\n-@implementer(ICustomMigrator)\n-@adapter(Interface)\n-class BaseCustomMigator(object):\n-    """Base custom migration class. Does nothing.\n-\n-    You can use this as base class for your custom migrator adapters.\n-    You might register it to some specific orginal content interface.\n-    """\n-\n-    def __init__(self, context):\n-        self.context = context\n-\n-    def migrate(self, old, new):\n-        return\n-\n-\n-class ATCTContentMigrator(CMFItemMigrator):\n-    """Base for contentish ATCT\n-    """\n-\n-    def __init__(self, *args, **kwargs):\n-        super(ATCTContentMigrator, self).__init__(*args, **kwargs)\n-        logger.info(\n-            \'Migrating {0} {1}\'.format(\n-                self.old.portal_type,\n-                \'/\'.join(self.old.getPhysicalPath())\n-            )\n-        )\n-\n-    def beforeChange_store_default_page(self):\n-        """If the item is the default page store that info to set it again.\n-\n-        Products.CMFDynamicViewFTI.browserdefault.check_default_page\n-        would unset the default page during the migration.\n-        """\n-        context_state = getMultiAdapter(\n-            (self.old, self.old.REQUEST), name=u\'plone_context_state\')\n-        if context_state.is_default_page():\n-            setattr(self.old, \'_migration_is_default_page\', True)\n-\n-    def beforeChange_store_comments_on_portal(self):\n-        """Comments from plone.app.discussion are lost when the\n-           old object is renamed...\n-           We save the comments in a safe place..."""\n-        portal = getToolByName(self.old, \'portal_url\').getPortalObject()\n-        move_comments(self.old, portal)\n-\n-    def migrate_atctmetadata(self):\n-        field = self.old.getField(\'excludeFromNav\')\n-        if field:\n-            self.new.exclude_from_nav = field.get(self.old)\n-\n-    def migrate_custom(self):\n-        """Get all ICustomMigrator registered migrators and run the migration.\n-        """\n-        for _, migrator in getAdapters((self.old,), ICustomMigrator):\n-            migrator.migrate(self.old, self.new)\n-\n-    def migrate_portlets(self):\n-        migrate_portlets(self.old, self.new)\n-\n-    def migrate_contentrules(self):\n-        copy_contentrules(self.old, self.new)\n-\n-    def migrate_leadimage(self):\n-        migrate_leadimage(self.old, self.new)\n-\n-    def last_migrate_comments(self):\n-        """Migrate the plone.app.discussion comments.\n-           Comments were stored on the portal, get them and\n-           Copy the conversations from old to new object."""\n-        portal = getToolByName(self.old, \'portal_url\').getPortalObject()\n-        move_comments(portal, self.new)\n-\n-    def last_migrate_default_page(self):\n-        """If the item was the default page set it again."""\n-        if getattr(self.old, \'_migration_is_default_page\', False):\n-            parent = self.new.__parent__\n-            parent.setDefaultPage(self.new.id)\n-\n-\n-class ATCTFolderMigrator(CMFFolderMigrator):\n-    """Base for folderish ATCT\n-    """\n-\n-    def __init__(self, *args, **kwargs):\n-        super(ATCTFolderMigrator, self).__init__(*args, **kwargs)\n-        logger.info(\n-            \'Migrating {0} {1}\'.format(\n-                self.old.portal_type,\n-                \'/\'.join(self.old.getPhysicalPath()))\n-        )\n-\n-    def beforeChange_store_comments_on_portal(self):\n-        """Comments from plone.app.discussion are lost when the\n-           old object is renamed...\n-           We save the comments in a safe place..."""\n-        portal = getToolByName(self.old, \'portal_url\').getPortalObject()\n-        move_comments(self.old, portal)\n-\n-    def migrate_atctmetadata(self):\n-        field = self.old.getField(\'excludeFromNav\')\n-        if field:\n-            self.new.exclude_from_nav = field.get(self.old)\n-\n-    def migrate_custom(self):\n-        """Get all ICustomMigrator registered migrators and run the migration.\n-        """\n-        for _, migrator in getAdapters((self.old,), ICustomMigrator):\n-            migrator.migrate(self.old, self.new)\n-\n-    def migrate_portlets(self):\n-        migrate_portlets(self.old, self.new)\n-\n-    def migrate_contentrules(self):\n-        copy_contentrules(self.old, self.new)\n-\n-    def migrate_leadimage(self):\n-        migrate_leadimage(self.old, self.new)\n-\n-    def migrate_nextprevious(self):\n-        try:\n-            enabled = self.old.getNextPreviousEnabled()\n-        except AttributeError:\n-            # The old type may not have this.\n-            # https://github.com/plone/plone.app.contenttypes/issues/582\n-            return\n-        if enabled and INextPreviousToggle.providedBy(self.new):\n-            self.new.nextPreviousEnabled = True\n-\n-    def last_migrate_comments(self):\n-        """Migrate the plone.app.discussion comments.\n-           Comments were stored on the portal, get them and\n-           Copy the conversations from old to new object."""\n-        portal = getToolByName(self.old, \'portal_url\').getPortalObject()\n-        move_comments(portal, self.new)\n-\n-    def last_migrate_layout(self):\n-        """Migrate the layout (view method).\n-\n-        This needs to be done last, as otherwise our changes in\n-        migrate_criteria may get overriden by a later call to\n-        migrate_properties.\n-        """\n-        old_layout = getattr(aq_base(self.old), \'layout\', None)\n-        if old_layout:\n-            default_page = getattr(aq_base(self.old), \'default_page\', None)\n-            try:\n-                # Delete old-style layout attribute.\n-                del self.new.layout\n-            except AttributeError:\n-                pass\n-            # always copy over the layout, transform if necessary\n-            self.new.setLayout(LISTING_VIEW_MAPPING.get(old_layout, old_layout))  # noqa\n-            if default_page:\n-                # any defaultPage is switched of by setLayout\n-                # and needs to set again if it was directly on the object\n-                self.new.setDefaultPage(default_page)\n-\n-\n-class DocumentMigrator(ATCTContentMigrator):\n-\n-    src_portal_type = \'Document\'\n-    src_meta_type = \'ATDocument\'\n-    dst_portal_type = \'Document\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-\n-\n-def migrate_documents(portal):\n-    return migrate(portal, DocumentMigrator)\n-\n-\n-class FileMigrator(ATCTContentMigrator):\n-\n-    src_portal_type = \'File\'\n-    src_meta_type = \'ATFile\'\n-    dst_portal_type = \'File\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_filefield(self.old, self.new, \'file\', \'file\')\n-\n-\n-def migrate_files(portal):\n-    return migrate(portal, FileMigrator)\n-\n-\n-class BlobFileMigrator(FileMigrator):\n-\n-    src_portal_type = \'File\'\n-    src_meta_type = \'ATBlob\'\n-    dst_portal_type = \'File\'\n-    dst_meta_type = None  # not used\n-\n-\n-def migrate_blobfiles(portal):\n-    return migrate(portal, BlobFileMigrator)\n-\n-\n-class ImageMigrator(ATCTContentMigrator):\n-\n-    src_portal_type = \'Image\'\n-    src_meta_type = \'ATImage\'\n-    dst_portal_type = \'Image\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_imagefield(self.old, self.new, \'image\', \'image\')\n-\n-\n-def migrate_images(portal):\n-    return migrate(portal, ImageMigrator)\n-\n-\n-class BlobImageMigrator(ImageMigrator):\n-\n-    src_portal_type = \'Image\'\n-    src_meta_type = \'ATBlob\'\n-    dst_portal_type = \'Image\'\n-    dst_meta_type = None  # not used\n-\n-\n-def migrate_blobimages(portal):\n-    return migrate(portal, BlobImageMigrator)\n-\n-\n-class LinkMigrator(ATCTContentMigrator):\n-\n-    src_portal_type = \'Link\'\n-    src_meta_type = \'ATLink\'\n-    dst_portal_type = \'Link\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_simplefield(self.old, self.new, \'remoteUrl\', \'remoteUrl\')\n-\n-\n-def migrate_links(portal):\n-    return migrate(portal, LinkMigrator)\n-\n-\n-class NewsItemMigrator(ATCTContentMigrator):\n-\n-    src_portal_type = \'News Item\'\n-    src_meta_type = \'ATNewsItem\'\n-    dst_portal_type = \'News Item\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-        migrate_imagefield(self.old, self.new, \'image\', \'image\')\n-        migrate_simplefield(self.old, self.new, \'imageCaption\', \'imageCaption\')\n-\n-\n-def migrate_newsitems(portal):\n-    return migrate(portal, NewsItemMigrator)\n-\n-\n-class BlobNewsItemMigrator(ATCTContentMigrator):\n-    """ Migrator for NewsItems with blobs based on the implementation in\n-        https://github.com/plone/plone.app.blob/pull/2\n-    """\n-\n-    src_portal_type = \'News Item\'\n-    src_meta_type = \'ATBlobContent\'\n-    dst_portal_type = \'News Item\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-        migrate_blobimagefield(self.old, self.new, \'image\', \'image\')\n-        migrate_simplefield(self.old, self.new, \'imageCaption\', \'imageCaption\')\n-\n-\n-def migrate_blobnewsitems(portal):\n-    return migrate(portal, BlobNewsItemMigrator)\n-\n-\n-class FolderMigrator(ATCTFolderMigrator):\n-\n-    src_portal_type = \'Folder\'\n-    src_meta_type = \'ATFolder\'\n-    dst_portal_type = \'Folder\'\n-    dst_meta_type = None  # not used\n-\n-\n-def migrate_folders(portal):\n-    return migrate(portal, FolderMigrator)\n-\n-\n-class CollectionMigrator(ATCTContentMigrator):\n-    """Migrator for at-based collections provided by plone.app.collection\n-    to\n-    """\n-\n-    src_portal_type = \'Collection\'\n-    src_meta_type = \'Collection\'\n-    dst_portal_type = \'Collection\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-        wrapped_new = ICollection(self.new)\n-        # using migrate_simplefield on \'query\' returns the ContentListing obj\n-        wrapped_new.query = self.old.query\n-        migrate_simplefield(self.old, wrapped_new, \'sort_on\', \'sort_on\')\n-        migrate_simplefield(\n-            self.old, wrapped_new, \'sort_reversed\', \'sort_reversed\')\n-        migrate_simplefield(self.old, wrapped_new, \'limit\', \'limit\')\n-        migrate_simplefield(\n-            self.old, wrapped_new, \'customViewFields\', \'customViewFields\')\n-\n-    def last_migrate_layout(self):\n-        """Migrate the layout (view method).\n-\n-        This needs to be done last, as otherwise our changes may get overriden\n-        by a later call to migrate_properties.\n-        """\n-        old_layout = self.old.getLayout() or getattr(self.old, \'layout\', None)\n-        if old_layout:\n-            try:\n-                # Delete old-style layout attribute.\n-                del self.new.layout\n-            except AttributeError:\n-                pass\n-            self.new.setLayout(LISTING_VIEW_MAPPING.get(old_layout, old_layout))  # noqa\n-\n-\n-def migrate_collections(portal):\n-    return migrate(portal, CollectionMigrator)\n-\n-\n-class EventMigrator(ATCTContentMigrator):\n-    """Migrate both Products.ContentTypes & plone.app.event.at Events"""\n-\n-    src_portal_type = \'Event\'\n-    src_meta_type = \'ATEvent\'\n-    dst_portal_type = \'Event\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_datetimefield(self.old, self.new, \'startDate\', \'start\')\n-        migrate_datetimefield(self.old, self.new, \'endDate\', \'end\')\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-        migrate_simplefield(self.old, self.new, \'location\', \'location\')\n-        migrate_simplefield(self.old, self.new, \'attendees\', \'attendees\')\n-        migrate_simplefield(self.old, self.new, \'eventUrl\', \'event_url\')\n-        migrate_simplefield(self.old, self.new, \'contactName\', \'contact_name\')\n-        migrate_simplefield(\n-            self.old, self.new, \'contactEmail\', \'contact_email\')\n-        migrate_simplefield(\n-            self.old, self.new, \'contactPhone\', \'contact_phone\')\n-        migrate_simplefield(self.old, self.new, \'wholeDay\', \'whole_day\')\n-        migrate_simplefield(self.old, self.new, \'openEnd\', \'open_end\')\n-        migrate_simplefield(self.old, self.new, \'recurrence\', \'recurrence\')\n-\n-\n-def migrate_events(portal):\n-    migrate(portal, DXOldEventMigrator)\n-    migrate(portal, EventMigrator)\n-    migrate(portal, DXEventMigrator)\n-\n-\n-def makeCustomATMigrator(\n-    context,\n-    src_type,\n-    dst_type,\n-    fields_mapping,\n-    is_folderish=False,\n-    dry_run=False\n-):\n-    """ generate a migrator for the given at-based folderish portal type """\n-\n-    base_class = ATCTContentMigrator\n-    if is_folderish:\n-        base_class = ATCTFolderMigrator\n-\n-    class CustomATMigrator(base_class):\n-\n-        src_portal_type = src_type\n-        dst_portal_type = dst_type\n-        dry_run_mode = dry_run\n-\n-        def migrate_schema_fields(self):\n-            for fields_dict in fields_mapping:\n-                at_fieldname = fields_dict.get(\'AT_field_name\')\n-                dx_fieldname = fields_dict.get(\'DX_field_name\')\n-                dx_fieldtype = fields_dict.get(\'DX_field_type\')\n-                migration_field_method = fields_dict.get(\'field_migrator\')\n-                if not migration_field_method:\n-                    if dx_fieldtype in FIELDS_MAPPING:\n-                        # Richtext, Image and File have custom migraton_methods\n-                        migration_field_method = FIELDS_MAPPING[dx_fieldtype]\n-                    else:\n-                        migration_field_method = migrate_simplefield\n-                migration_field_method(src_obj=self.old,\n-                                       dst_obj=self.new,\n-                                       src_fieldname=at_fieldname,\n-                                       dst_fieldname=dx_fieldname)\n-\n-        def last_migrate_check(self):\n-            """\n-            BBB to be checked\n-            if there is an error with the fields, an exception will be raised.\n-            """\n-            if self.dry_run_mode:\n-                view = getMultiAdapter(\n-                    (self.new, self.new.REQUEST), name=\'view\')\n-                view()\n-\n-    return CustomATMigrator\n-\n-\n-def migrateCustomAT(fields_mapping,\n-                    src_type,\n-                    dst_type,\n-                    dry_run=False,\n-                    patch_linkintegrity=False,\n-                    patch_searchabletext=False,\n-                    query=None,\n-                    ):\n-    """\n-    Try to get types infos from archetype_tool, then set a migrator and pass it\n-    given values. There is a dry_run mode that allows to check the success of\n-    a migration without committing.\n-    """\n-    portal = getSite()\n-\n-    # Patch various things that make migration harder\n-    (link_integrity,\n-     queue_indexing,\n-     patch_searchabletext) = patch_before_migration(patch_searchabletext)\n-\n-    # if the type still exists get the src_meta_type from the portal_type\n-    portal_types = getToolByName(portal, \'portal_types\')\n-    fti = portal_types.get(src_type, None)\n-    # Check if the fti was removed or replaced by a DX-implementation\n-    if fti is None or IDexterityFTI.providedBy(fti):\n-        # Get the needed info from an instance of the type\n-        catalog = portal.portal_catalog\n-        brains = catalog(portal_type=src_type, sort_limit=1)\n-        if not brains:\n-            # no item? assume stuff\n-            is_folderish = False\n-            src_meta_type = src_type\n-        else:\n-            try:\n-                src_obj = brains[0].getObject()\n-            except (KeyError, NotFound):\n-                logger.error(\n-                    \'Could not find the object for brain at %s\',\n-                    brains[0].getURL())\n-                return\n-            if IDexterityContent.providedBy(src_obj):\n-                logger.error(\n-                    \'%s should not be dexterity object!\',\n-                    src_obj.absolute_url())\n-            is_folderish = getattr(src_obj, \'isPrincipiaFolderish\', False)\n-            src_meta_type = src_obj.meta_type\n-    else:\n-        # fallback\n-        is_folderish = False\n-        # Get info from at-fti\n-        src_meta_type = fti.content_meta_type\n-        archetype_tool = getToolByName(portal, \'archetype_tool\', None)\n-        for info in archetype_tool.listRegisteredTypes():\n-            # lookup registered type in archetype_tool with meta_type\n-            # because several portal_types can use same meta_type\n-            if info.get(\'meta_type\') == src_meta_type:\n-                klass = info.get(\'klass\', None)\n-                is_folderish = klass.isPrincipiaFolderish\n-                break\n-\n-    migrator = makeCustomATMigrator(context=portal,\n-                                    src_type=src_type,\n-                                    dst_type=dst_type,\n-                                    fields_mapping=fields_mapping,\n-                                    is_folderish=is_folderish,\n-                                    dry_run=dry_run)\n-    walker_infos = None\n-    if migrator:\n-        migrator.src_meta_type = src_meta_type\n-        migrator.dst_meta_type = \'\'\n-        walker_settings = {\'portal\': portal,\n-                           \'migrator\': migrator,\n-                           \'src_portal_type\': src_type,\n-                           \'dst_portal_type\': dst_type,\n-                           \'src_meta_type\': src_meta_type,\n-                           \'dst_meta_type\': \'\',\n-                           \'use_savepoint\': True}\n-        if query:\n-            walker_settings[\'query\'] = query\n-        if dry_run:\n-            walker_settings[\'limit\'] = 1\n-        walker = CustomQueryWalker(**walker_settings)\n-        walker.go()\n-        walker_infos = {\'errors\': walker.errors,\n-                        \'msg\': walker.getOutput().splitlines(),\n-                        \'counter\': walker.counter}\n-        for error in walker.errors:\n-            logger.error(error.get(\'message\'))\n-        if dry_run:\n-            transaction.abort()\n-\n-    # Revert to the original state\n-    undo_patch_after_migration(\n-        link_integrity, queue_indexing, patch_searchabletext)\n-\n-    return walker_infos\ndiff --git a/plone/app/contenttypes/migration/migrator.css b/plone/app/contenttypes/migration/migrator.css\ndeleted file mode 100644\nindex 53cdf518..00000000\n--- a/plone/app/contenttypes/migration/migrator.css\n+++ /dev/null\n@@ -1,88 +0,0 @@\n-div.important {\n-  padding: .9em 1.2em;\n-  border-radius: 10px;\n-  font-size: 100%;\n-}\n-.btn-danger {\n-  background-color: #DA4F49;\n-  background-image: linear-gradient(to bottom, #EE5F5B, #BD362F);\n-  background-repeat: repeat-x;\n-  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);\n-  color: #FFFFFF;\n-  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);\n-  border-radius: 4px 4px 4px 4px;\n-  border-style: solid;\n-  border-width: 1px;\n-  box-shadow: 0 1px 0 rgba(255, 255, 255, 0.2) inset, 0 1px 2px rgba(0, 0, 0, 0.05);    cursor: pointer;\n-  display: inline-block;\n-  font-size: 14px;\n-  line-height: 20px;\n-  margin-bottom: 0;\n-  padding: 4px 12px;\n-  text-align: center;\n-  vertical-align: middle;\n-}\n-\n-.btn-danger:hover, .btn-danger:focus,\n-.btn-danger:active, .btn-danger.active {\n-    color: rgb(255, 255, 255);\n-    background-color: rgb(189, 54, 47);\n-    text-decoration: none;\n-    background-position: 0px -15px;\n-    transition: background-position 0.1s linear 0s;\n-}\n-\n-.btn-danger:active {\n-    background-image: none;\n-    outline: 0px none;\n-    box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.15) inset, 0px 1px 2px rgba(0, 0, 0, 0.05);\n-}\n-#migration-form {\n-    border: 1px solid #DDDDDD;\n-    border-radius: 10px 10px 10px 10px;\n-    font-size: 110%;\n-    margin-bottom: 1em;\n-    padding: 1em 1.5em;\n-}\n-\n-#migration-form .formControls {\n-  margin-left: 0;\n-  margin-top: 4em;\n-}\n-#migration-options {\n-  margin-top: 3em;\n-}\n-\n-.strong {\n-  font-size: 150%;\n-  font-weight: bold;\n-}\n-\n-table td {\n-    border: 1px solid #ccc;\n-}\n-table td, table th  {\n-    padding: 0.2em 0.5em 0.2em;\n-}\n-table th {\n-    text-align: center;\n-    font-weight: normal;\n-}\n-\n-.testConfig.error {\n-    padding-right: 30px;\n-    background: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAClklEQVR42q3VX0gUQRwH8N/M3N7tnXe3Z4IiESc9FBaBWHg99VSET0F/HxIKKg1FK4gK8grUoB59UaEetKAwoojAsCgIIsw/ROSRhCFpecVpd7d6f/Zmd6fZJY2ebmHu97Asw373w/x2ZhaBg1IPH78JNRsuMxeGQoFCYmbh1raRZ1ecZFGxB3JHm/pJY+1Z5JcBGAOEMdB0BmIP3/XsGn0eFQa0S+0M1VUDFIz1MeJ2wfe3nyHcd7dovjhwsZWh2koAw1wfwy4CP8ZnITxwrwTAhVYGW8o5wP4DFqe+Qvj2fXEgf66FobACYHIAYd4fYrco/mkeNvUPlgBoPs3Q1hB/sQQs8QtYbBqIqsLYh/jKnmQ6KAzkzjSPoY0oYo6MAkuqAC4XuPlyfT2bHN+f0yLCQCayewoSs/VgfQJM7ISbIHgzn/q4N5evEwZUr/8FrvLtg3/fGGQO9M0tRTuY0SMMpH3BKAl5uqxNtlZejGAgnuxqM/XrpQA6id/dvQZYAcZX1FBKPd9m6L0lAJSdWMYTCJD9rHXN6CY8Wc3Uthh0RhhI+RQJS1jlL5bXAjnTLDzOZKs4kBIG7FkEQnO87TXWPeFSnNL0K00rbzYoK5Z1BPwuU3rdCHVY9xIHYlSbrs9ndzjJOgJ+likVfJkmKDNRlpkQM/SGg1SbKBkgUo6AJX/oDiLolJdgUHUK8wX9UUM+e6QkQNobPIED0iDmu9c+LXhCpyYMLasn2019SBhQQ6EuUilH7eP6b3k49vJbqrsxn78mDKTKlB73duUq45vLngJPyBKBB5OLN5oM2ineIjnYQDYH35Nqn/3bxPyoXl1QYfjLcqSV0XFhwKq4J3jAVeEZRgHJk0lq2uTSyrFDZuGpk+wfCfYGKNjXCTAAAAAASUVORK5CYII=\') no-repeat right center;\n-}\n-.testConfig.success {\n-    padding-right: 30px;\n-    background: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAC9ElEQVR42u2UW0gUURjH/7Pj7tIqhu5tvK/aRS3K7KGHepAQ7SJBEBaESmAXqAeJKDQQipKgEiPEiCAzLE2CLlCQREVvIhEopuaq7a6aI67rXp3ZnTnNDrZYupqXeuqDMwNzzvn95nznO4fCXw7qv+CfC5hXTEV+ek5116gZn3J7qVUVbHqbRrYnZuBq6g2UdB7BiG1q9VYwG37ZVgErZ8HXz+OrIwjCq3ecQ44qV4ZbuG9wu3lYexwrF/wOH/QNwc+LGOyaAK8VK1ckyGpLJQ931cFAm2S42TOAYN0Mddvh9vJgj7HL3+S4pwy5U1AV+vN+txk0TcPa78DkuA9sGSuz5Ufca4YIrChPZEvZRaVMM0MqC0pRFHUc5UMnMeL9DpUyAmNWt9RcIbgsYF4wpGBjDs4mnMFd9j5aP34IK2GeMZToEcWSvD04H3sJF63l6HH2Qq1Uwz4+jeE+B8ZOjP0yl8p4YyKnthSi3dmBC/FVONx5GvY+z7wSQ5OB5O3MRk1CPerY63jHvpfgKkw5eQx3T2K0bGzOHCqzLY1sSzFAE6GGN8CFlRhbjCRraxLXmNaoful4gsejLVDSEXA6/eBcfnQWmOddNcU8Z0iyPsa/2ahTTgt+BKSPu2P2ora/ISQxPDCQpGwtmjMb0OFqR72tHgqFAm5XAKzZCUvxSNh9o4J3B/yoXmfUwqRbC14UEZBavna/LEFw7xVAU85tTEx7cc1yReoX4PUIsNvcGCiyLVgUcqckIZSPQqZJD310JLhAQFqJiELdAVgjvuDgmqOwcz7cGq6Bk3fC5xXhtnPoKRxctOJCA4LVpPLTyEjXIVKjliUCEZCiScah2GLUDt+U4dNesmDOwwpmypCoBBqZ6/WglQoIgiilLABO4KCgVBJcSo2DR/e+gT8+oHMGMq0MiaSVSN+glZJEIIoEgtQ8Xv+S4fMKgmF8ZCQx0RokmqKlNBG4XPyy4GEFwTDcMxBdfNRMDWFZ8AUFPyXB9+y7ZanxA2o0cjyUQuVrAAAAAElFTkSuQmCC\') no-repeat right center;\n-}\n-\n-.testConfig.testing {\n-  background: #ffffff url(\'++plone++static/components//select2/select2-spinner.gif\') no-repeat 100% right center;\n-  background: url(\'++plone++static/components//select2/select2-spinner.gif\') no-repeat 100%, -webkit-gradient(linear, left bottom, left top, color-stop(0.85, #ffffff), color-stop(0.99, #eeeeee));\n-  background: url(\'++plone++static/components//select2/select2-spinner.gif\') no-repeat 100%, -webkit-linear-gradient(center bottom, #ffffff 85%, #eeeeee 99%);\n-  background: url(\'++plone++static/components//select2/select2-spinner.gif\') no-repeat 100%, -moz-linear-gradient(center bottom, #ffffff 85%, #eeeeee 99%);\n-  background: url(\'++plone++static/components//select2/select2-spinner.gif\') no-repeat 100%, linear-gradient(to bottom, #ffffff 85%, #eeeeee 99%) right center;\n-  padding-right: 30px;\n-}\ndiff --git a/plone/app/contenttypes/migration/pac_installer.pt b/plone/app/contenttypes/migration/pac_installer.pt\ndeleted file mode 100644\nindex fd6eaa84..00000000\n--- a/plone/app/contenttypes/migration/pac_installer.pt\n+++ /dev/null\n@@ -1,37 +0,0 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"\n-      xmlns:tal="http://xml.zope.org/namespaces/tal"\n-      xmlns:metal="http://xml.zope.org/namespaces/metal"\n-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-      metal:use-macro="context/@@main_template/macros/master"\n-      i18n:domain="plone">\n-\n-    <metal:block fill-slot="top_slot"\n-                 tal:define="dummy python:request.set(\'disable_border\',1)" />\n-\n-    <body>\n-\n-        <metal:main fill-slot="main">\n-\n-            <tal:installable tal:condition="view/pac_installable">\n-                <h1 class="documentFirstHeading"\n-                    i18n:translate="">\n-                    Install dexterity and proceed to the migration-form?\n-                </h1>\n-                <p i18n:translate="">After you do this you can\'t edit your existing content (you can still view it) unless you migrate them to Dexterity in the next step.</p>\n-                <div id="content-core">\n-                    <form metal:use-macro="context/@@ploneform-macros/titlelessform" />\n-                </div>\n-            </tal:installable>\n-\n-            <tal:installable tal:condition="view/pac_installed">\n-                <h1>\n-                    Dexterity is already installed\n-                </h1>\n-                <p>\n-                    <a href="@@atct_migrator">Proceed to migrating your existing content to dexterity.</a>\n-                </p>\n-            </tal:installable>\n-\n-        </metal:main>\n-    </body>\n-</html>\ndiff --git a/plone/app/contenttypes/migration/patches.py b/plone/app/contenttypes/migration/patches.py\ndeleted file mode 100644\nindex 7d57d8ac..00000000\n--- a/plone/app/contenttypes/migration/patches.py\n+++ /dev/null\n@@ -1,158 +0,0 @@\n-# -*- coding: utf-8 -*-\n-"""Patches used for migrations. These patches are applied before and removed\n-after running the migration.\n-"""\n-from plone.dexterity.content import DexterityContent\n-from plone.registry.interfaces import IRegistry\n-from Products.Archetypes.ExtensibleMetadata import ExtensibleMetadata\n-from Products.CMFCore.interfaces import IPropertiesTool\n-from Products.CMFPlone.DublinCore import DefaultDublinCoreImpl\n-from Products.CMFPlone.interfaces import IEditingSchema\n-from Products.contentmigration.utils import patch\n-from Products.contentmigration.utils import undoPatch\n-from Products.PluginIndexes.common.UnIndex import _marker\n-from Products.PluginIndexes.UUIDIndex.UUIDIndex import UUIDIndex\n-from zope.component import getUtility\n-from zope.component import queryUtility\n-\n-import os\n-\n-\n-def pass_fn(*args, **kwargs):\n-    """Empty function used for patching."""\n-    pass\n-\n-\n-def patched_index_object(*args, **kwargs):\n-    """Patched Products.ZCTextIndex.ZCTextIndex.ZCTextIndex.index_object"""\n-    return 0\n-\n-\n-# Prevent UUID Error-Messages when migrating folders.\n-# Products.PluginIndexes.UUIDIndex.UUIDIndex.UUIDIndex.insertForwardIndexEntry\n-def patched_insertForwardIndexEntry(self, entry, documentId):\n-    """Take the entry provided and put it in the correct place\n-    in the forward index.\n-    """\n-    if entry is None:\n-        return\n-\n-    old_docid = self._index.get(entry, _marker)\n-    if old_docid is _marker:\n-        self._index[entry] = documentId\n-        self._length.change(1)\n-\n-\n-def patch_before_migration(patch_searchabletext=False):\n-    """Patch various things that make migration harder."""\n-    # Switch linkintegrity off\n-    ptool = queryUtility(IPropertiesTool)\n-    site_props = getattr(ptool, \'site_properties\', None)\n-    if site_props and site_props.hasProperty(\n-            \'enable_link_integrity_checks\'):\n-        link_integrity = site_props.getProperty(\n-            \'enable_link_integrity_checks\', False)\n-        site_props.manage_changeProperties(\n-            enable_link_integrity_checks=False)\n-    else:\n-        # Plone 5\n-        registry = getUtility(IRegistry)\n-        editing_settings = registry.forInterface(\n-            IEditingSchema, prefix=\'plone\')\n-        link_integrity = editing_settings.enable_link_integrity_checks\n-        editing_settings.enable_link_integrity_checks = False\n-\n-    # Patch notifyModified to prevent setModificationDate() on changes\n-    # notifyModified lives in several places and is also used on folders\n-    # when their content changes.\n-    # So when we migrate Documents before Folders the folders\n-    # ModifiedDate gets changed\n-    PATCH_NOTIFY = [\n-        DexterityContent,\n-        DefaultDublinCoreImpl,\n-        ExtensibleMetadata\n-    ]\n-    for klass in PATCH_NOTIFY:\n-        patch(klass, \'notifyModified\', pass_fn)\n-\n-    # Disable queueing of indexing/reindexing/unindexing\n-    queue_indexing = os.environ.get(\'CATALOG_OPTIMIZATION_DISABLED\', None)\n-    os.environ[\'CATALOG_OPTIMIZATION_DISABLED\'] = \'1\'\n-\n-    # Patch UUIDIndex\n-    patch(\n-        UUIDIndex,\n-        \'insertForwardIndexEntry\',\n-        patched_insertForwardIndexEntry)\n-\n-    # Patch SearchableText index\n-    if patch_searchabletext:\n-        patch_indexing_at_blobs()\n-        patch_indexing_dx_blobs()\n-\n-    return link_integrity, queue_indexing, patch_searchabletext\n-\n-\n-def undo_patch_after_migration(link_integrity=True,\n-                               queue_indexing=None,\n-                               patch_searchabletext=False,\n-                               ):\n-    """Revert to the original state."""\n-\n-    # Switch linkintegrity back to what it was before migrating\n-    ptool = queryUtility(IPropertiesTool)\n-    site_props = getattr(ptool, \'site_properties\', None)\n-    if site_props and site_props.hasProperty(\n-            \'enable_link_integrity_checks\'):\n-        site_props.manage_changeProperties(\n-            enable_link_integrity_checks=link_integrity\n-        )\n-    else:\n-        # Plone 5\n-        registry = getUtility(IRegistry)\n-        editing_settings = registry.forInterface(\n-            IEditingSchema, prefix=\'plone\')\n-        editing_settings.enable_link_integrity_checks = link_integrity\n-\n-    # Switch on setModificationDate on changes\n-    PATCH_NOTIFY = [\n-        DexterityContent,\n-        DefaultDublinCoreImpl,\n-        ExtensibleMetadata\n-    ]\n-    for klass in PATCH_NOTIFY:\n-        undoPatch(klass, \'notifyModified\')\n-\n-    # Reset queueing of indexing/reindexing/unindexing\n-    if queue_indexing is not None:\n-        os.environ[\'CATALOG_OPTIMIZATION_DISABLED\'] = queue_indexing\n-    else:\n-        del os.environ[\'CATALOG_OPTIMIZATION_DISABLED\']\n-\n-    # Unpatch UUIDIndex\n-    undoPatch(UUIDIndex, \'insertForwardIndexEntry\')\n-\n-    # Unpatch SearchableText index\n-    if patch_searchabletext:\n-        unpatch_indexing_at_blobs()\n-        unpatch_indexing_dx_blobs()\n-\n-\n-def patch_indexing_at_blobs():\n-    from plone.app.blob.content import ATBlob\n-    patch(ATBlob, \'getIndexValue\', pass_fn)\n-\n-\n-def unpatch_indexing_at_blobs():\n-    from plone.app.blob.content import ATBlob\n-    undoPatch(ATBlob, \'getIndexValue\')\n-\n-\n-def patch_indexing_dx_blobs():\n-    from Products.ZCTextIndex.ZCTextIndex import ZCTextIndex\n-    patch(ZCTextIndex, \'index_object\', patched_index_object)\n-\n-\n-def unpatch_indexing_dx_blobs():\n-    from Products.ZCTextIndex.ZCTextIndex import ZCTextIndex\n-    undoPatch(ZCTextIndex, \'index_object\')\ndiff --git a/plone/app/contenttypes/migration/topics.py b/plone/app/contenttypes/migration/topics.py\ndeleted file mode 100644\nindex d843cde9..00000000\n--- a/plone/app/contenttypes/migration/topics.py\n+++ /dev/null\n@@ -1,727 +0,0 @@\n-# -*- coding: utf-8 -*-\n-""" Migrate Topic to DX-Collectons.\n-\n-Note on Subtopics:\n-When a migration of Subtopics is needed, you can replace the default itemish\n-Collection with a folderish Collection by creating a new type folderish\n-type \'Collection\' with the collection-behavior enabled. You can then use\n-the default migration to migrate Topics with Subtopics.\n-"""\n-\n-from DateTime import DateTime\n-from plone.app.contenttypes.behaviors.collection import ICollection\n-from plone.app.contenttypes.migration.field_migrators import migrate_richtextfield  # noqa: E501\n-from plone.app.contenttypes.upgrades import LISTING_VIEW_MAPPING\n-from plone.app.querystring.interfaces import IQuerystringRegistryReader\n-from plone.registry.interfaces import IRegistry\n-from plone.uuid.interfaces import IMutableUUID\n-from Products.CMFCore.utils import getToolByName\n-from Products.contentmigration.inplace import InplaceCMFFolderMigrator\n-from Products.contentmigration.inplace import InplaceCMFItemMigrator\n-from Products.contentmigration.walker import CustomQueryWalker\n-from zope.component import getUtility\n-from zope.component import queryAdapter\n-from zope.dottedname.resolve import resolve\n-\n-import logging\n-\n-\n-logger = logging.getLogger(__name__)\n-prefix = \'plone.app.querystring\'\n-\n-INVALID_OPERATION = \'Invalid operation %s for criterion: %s\'\n-\n-\n-# Converters\n-class CriterionConverter(object):\n-\n-    # Last part of the code for the dotted operation method,\n-    # e.g. \'string.contains\'.\n-    operator_code = \'\'\n-    # alternative code, possibly used if the first code does not work.\n-    alt_operator_code = \'\'\n-\n-    def get_query_value(self, value, index, criterion):\n-        # value may contain a query and some parameters, but in the\n-        # simple case it is simply a value.\n-        return value\n-\n-    def get_operation(self, value, index, criterion):\n-        # Get dotted operation method.  This may depend on value.\n-        return \'{0}.operation.{1}\'.format(prefix, self.operator_code)\n-\n-    def get_alt_operation(self, value, index, criterion):\n-        # Get dotted operation method.  This may depend on value.\n-        return \'{0}.operation.{1}\'.format(prefix, self.alt_operator_code)\n-\n-    def is_index_known(self, registry, index):\n-        # Is the index registered as criterion index?\n-        key = \'{0}.field.{1}\'.format(prefix, index)\n-        try:\n-            registry.get(key)\n-        except KeyError:\n-            logger.error(\n-                \'Index {0} is no criterion index. Registry gives \'\n-                \'KeyError: {1}\'.format(index, key)\n-            )\n-            return False\n-        return True\n-\n-    def is_index_enabled(self, registry, index):\n-        # Is the index enabled as criterion index?\n-        key = \'{0}.field.{1}\'.format(prefix, index)\n-        index_data = registry.get(key)\n-        if index_data.get(\'enabled\'):\n-            return True\n-        logger.warn(\'Index %s is not enabled as criterion index. \', index)\n-        return False\n-\n-    def switch_type_to_portal_type(self, value, criterion):\n-        # \'portal_type\' is the object id of the FTI in portal_types.\n-        # \'Type\' is the title of that object.\n-        # For example:\n-        # - portal_type \'Document\' has Type \'Page\'.\n-        # - portal_type \'Topic\' has Type \'Collection (old)\'.\n-        if isinstance(value, dict):\n-            values = value.get(\'query\', [])\n-        else:\n-            values = value\n-        if not values:\n-            return value\n-        new_values = []\n-        ttool = getToolByName(criterion, \'portal_types\')\n-        type_to_portal_type = {}\n-        portal_types = ttool.objectIds()\n-        for portal_type, Type in ttool.listTypeTitles().items():\n-            type_to_portal_type[Type] = portal_type\n-        for Type in values:\n-            portal_type = type_to_portal_type.get(Type)\n-            if not portal_type:\n-                if Type in portal_types:\n-                    portal_type = Type\n-                else:\n-                    logger.warn(\'Cannot switch Type %r to portal_type.\', Type)\n-                    continue\n-            new_values.append(portal_type)\n-        if isinstance(value, dict):\n-            value[\'query\'] = new_values\n-        else:\n-            value = new_values\n-        return value\n-\n-    def is_operation_valid(self, registry, operation):\n-        # Check that the operation exists.\n-        op_info = registry.get(operation)\n-        if op_info is None:\n-            logger.error(\'Operation %r is not defined.\', operation)\n-            return False\n-        op_function_name = op_info.get(\'operation\')\n-        try:\n-            resolve(op_function_name)\n-        except ImportError:\n-            logger.error(\n-                \'ImportError for operation %r: %s\',\n-                operation,\n-                op_function_name,\n-            )\n-            return False\n-        return True\n-\n-    def get_valid_operation(self, registry, index, value, criterion):\n-        key = \'{0}.field.{1}.operations\'.format(prefix, index)\n-        operations = registry.get(key)\n-        operation = self.get_operation(value, index, criterion)\n-        if operation not in operations:\n-            operation = self.get_alt_operation(value, index, criterion)\n-            if operation not in operations:\n-                return\n-        if self.is_operation_valid(registry, operation):\n-            return operation\n-\n-    def add_to_formquery(self, formquery, index, operation, query_value):\n-        row = {\'i\': index,\n-               \'o\': operation}\n-        if query_value is not None:\n-            row[\'v\'] = query_value\n-        formquery.append(row)\n-\n-    def __call__(self, formquery, criterion, registry):\n-        criteria = criterion.getCriteriaItems()\n-        if not criteria:\n-            logger.warn(\'Ignoring empty criterion %s.\', criterion)\n-            return\n-        for index, value in criteria:\n-            # Check if the index is known and enabled as criterion index.\n-            if index == \'Type\':\n-                # Try to replace Type by portal_type\n-                index = \'portal_type\'\n-                value = self.switch_type_to_portal_type(value, criterion)\n-            if not self.is_index_known(registry, index):\n-                logger.info(\'Index %s not known in registry.\', index)\n-                continue\n-            self.is_index_enabled(registry, index)\n-            # TODO: what do we do when this is False?  Raise an\n-            # Exception?  Continue processing the index and value\n-            # anyway, now that a warning is logged?  Continue with the\n-            # next criteria item?\n-\n-            # Get the operation method.\n-            operation = self.get_valid_operation(\n-                registry,\n-                index,\n-                value,\n-                criterion\n-            )\n-            if not operation:\n-                logger.error(INVALID_OPERATION % (operation, criterion))\n-                # TODO: raise an Exception?\n-                continue\n-\n-            # Get the value that we will query for.\n-            query_value = self.get_query_value(value, index, criterion)\n-\n-            # Add a row to the form query.\n-            self.add_to_formquery(formquery, index, operation, query_value)\n-\n-\n-class ATDateCriteriaConverter(CriterionConverter):\n-    """Handle date criteria.\n-\n-    Note that there is also ATDateRangeCriterion, which is much\n-    simpler as it just has two dates.\n-\n-    In our case we have these valid operations:\n-\n-    [\'plone.app.querystring.operation.date.lessThan\',\n-     \'plone.app.querystring.operation.date.largerThan\',\n-     \'plone.app.querystring.operation.date.between\',\n-     \'plone.app.querystring.operation.date.lessThanRelativeDate\',\n-     \'plone.app.querystring.operation.date.largerThanRelativeDate\',\n-     \'plone.app.querystring.operation.date.today\',\n-     \'plone.app.querystring.operation.date.beforeToday\',\n-     \'plone.app.querystring.operation.date.afterToday\']\n-\n-    This code is based on the getCriteriaItems method from\n-    Products/ATContentTypes/criteria/date.py.  We check the field\n-    values ourselves instead of translating the values back and forth.\n-    """\n-\n-    def __call__(self, formquery, criterion, registry):  # noqa\n-        if criterion.value is None:\n-            logger.warn(\'Ignoring empty criterion %s.\', criterion)\n-            return\n-        field = criterion.Field()\n-        value = criterion.Value()\n-\n-        # Check if the index is known and enabled as criterion index.\n-        if not self.is_index_known(registry, field):\n-            return\n-        self.is_index_enabled(registry, field)\n-\n-        # Negate the value for \'old\' days\n-        if criterion.getDateRange() == \'-\':\n-            value = -value\n-\n-        date = DateTime() + value\n-\n-        # Get the possible operation methods.\n-        key = \'{0}.field.{1}.operations\'.format(prefix, field)\n-        operations = registry.get(key)\n-\n-        def add_row(operation, value=None):\n-            if operation not in operations:\n-                # TODO just ignore it?\n-                raise ValueError(INVALID_OPERATION % (operation, criterion))\n-            if not self.is_operation_valid(registry, operation):\n-                # TODO just ignore it?\n-                raise ValueError(INVALID_OPERATION % (operation, criterion))\n-            # Add a row to the form query.\n-            row = {\'i\': field,\n-                   \'o\': operation}\n-            if value is not None:\n-                row[\'v\'] = value\n-            formquery.append(row)\n-\n-        operation = criterion.getOperation()\n-        if operation == \'within_day\':\n-            if date.isCurrentDay():\n-                new_operation = \'{0}.operation.date.today\'.format(prefix)\n-                add_row(new_operation)\n-                return\n-            date_range = (date.earliestTime(), date.latestTime())\n-            new_operation = \'{0}.operation.date.between\'.format(prefix)\n-            add_row(new_operation, date_range)\n-            return\n-        if operation == \'more\':\n-            if value != 0:\n-                new_operation = (\'{0}.operation.date.\'\n-                                 \'largerThanRelativeDate\'.format(prefix))\n-                add_row(new_operation, value)\n-                return\n-            else:\n-                new_operation = \'{0}.operation.date.afterToday\'.format(prefix)\n-                add_row(new_operation)\n-                return\n-        if operation == \'less\':\n-            if value != 0:\n-                new_operation = (\'{0}.operation.date.\'\n-                                 \'lessThanRelativeDate\'.format(prefix))\n-                add_row(new_operation, value)\n-                return\n-            else:\n-                new_operation = \'{0}.operation.date.beforeToday\'.format(prefix)\n-                add_row(new_operation)\n-                return\n-\n-\n-class ATSimpleStringCriterionConverter(CriterionConverter):\n-    operator_code = \'string.contains\'\n-    # review_state could be a string criterion, but should become a selection.\n-    alt_operator_code = \'selection.any\'\n-\n-\n-class ATCurrentAuthorCriterionConverter(CriterionConverter):\n-    operator_code = \'string.currentUser\'\n-\n-\n-class ATSelectionCriterionConverter(CriterionConverter):\n-    operator_code = \'selection.any\'\n-    alt_operator_code = \'selection.is\'\n-\n-    def get_operation(self, value, index, criterion):\n-        # Get dotted operation method.  This may depend on value.\n-        if index == \'Subject\':\n-            if value[\'operator\'] == \'and\':\n-                # Subject is currently the only index that supports\n-                # this, because for others it makes no sense.  See\n-                # allowed operations in registry.xml in\n-                # plone.app.querystring.\n-                suffix = \'all\'\n-            else:\n-                suffix = \'any\'\n-            return \'{0}.operation.selection.{1}\'.format(prefix, suffix)\n-        else:\n-            return \'{0}.operation.{1}\'.format(prefix, self.operator_code)\n-\n-    def get_query_value(self, value, index, criterion):\n-        values = value[\'query\']\n-        if value.get(\'operator\') == \'and\' and len(values) > 1 and \\\n-                index != \'Subject\':\n-            logger.warn("Cannot handle selection operator \'and\'. Using \'or\'. "\n-                        "%r", value)\n-\n-        # Special handling for portal_type=Topic.\n-        if index == \'portal_type\' and \'Topic\' in values:\n-            values = list(values)\n-            values[values.index(\'Topic\')] = \'Collection\'\n-            values = tuple(values)\n-        return values\n-\n-\n-class ATListCriterionConverter(ATSelectionCriterionConverter):\n-    pass\n-\n-\n-class ATReferenceCriterionConverter(ATSelectionCriterionConverter):\n-    # Note: the new criterion is disabled by default.  Also, it\n-    # needs the _referenceIs function in the plone.app.querystring\n-    # queryparser and that function is not defined.\n-    operator_code = \'reference.is\'\n-\n-\n-class ATPathCriterionConverter(CriterionConverter):\n-    operator_code = \'string.path\'\n-\n-    def get_query_value(self, value, index, criterion):\n-        raw = criterion.getRawValue()\n-        if not raw:\n-            return\n-        # Is this a recursive query?  Could check depth in the value\n-        # actually, but Recurse is the canonical way.  Also, the only\n-        # possible values for depth are -1 and 1.\n-        if not criterion.Recurse():\n-            for index, path in enumerate(raw):\n-                raw[index] = path + \'::1\'\n-        return raw\n-\n-    def add_to_formquery(self, formquery, index, operation, query_value):\n-        if query_value is None:\n-            return\n-        for value in query_value:\n-            row = {\'i\': index,\n-                   \'o\': operation,\n-                   \'v\': value}\n-            formquery.append(row)\n-\n-\n-class ATBooleanCriterionConverter(CriterionConverter):\n-\n-    def get_operation(self, value, index, criterion):\n-        # Get dotted operation method.\n-        # value is one of these beauties:\n-        # value = [1, True, \'1\', \'True\']\n-        # value = [0, \'\', False, \'0\', \'False\', None, (), [], {}, MV]\n-        if True in value:\n-            code = \'isTrue\'\n-        elif False in value:\n-            code = \'isFalse\'\n-        else:\n-            logger.warn(\n-                \'Unknown value for boolean criterion. \'\n-                \'Falling back to True. %r\',\n-                value,\n-            )\n-            code = \'isTrue\'\n-        return \'{0}.operation.boolean.{1}\'.format(prefix, code)\n-\n-    def __call__(self, formquery, criterion, registry):\n-        criteria = criterion.getCriteriaItems()\n-        if not criteria:\n-            return\n-        for index, value in criteria:\n-            if index == \'is_folderish\':\n-                fieldname = \'isFolderish\'\n-            elif index == \'is_default_page\':\n-                fieldname = \'isDefaultPage\'\n-            else:\n-                fieldname = index\n-            # Check if the index is known and enabled as criterion index.\n-            if not self.is_index_known(registry, fieldname):\n-                continue\n-            self.is_index_enabled(registry, fieldname)\n-            # Get the operation method.\n-            operation = self.get_valid_operation(\n-                registry, fieldname, value, criterion)\n-            if not operation:\n-                logger.error(INVALID_OPERATION % (operation, criterion))\n-                # TODO: raise an Exception?\n-                continue\n-            # Add a row to the form query.\n-            row = {\'i\': index,\n-                   \'o\': operation}\n-            formquery.append(row)\n-\n-\n-class ATDateRangeCriterionConverter(CriterionConverter):\n-    operator_code = \'date.between\'\n-\n-    def get_query_value(self, value, index, criterion):\n-        return value[\'query\']\n-\n-\n-class ATPortalTypeCriterionConverter(CriterionConverter):\n-    operator_code = \'selection.any\'\n-\n-    def get_query_value(self, value, index, criterion):\n-        # Special handling for portal_type=Topic.\n-        if \'Topic\' in value:\n-            value = list(value)\n-            value[value.index(\'Topic\')] = \'Collection\'\n-            value = tuple(value)\n-        return value\n-\n-\n-class ATRelativePathCriterionConverter(CriterionConverter):\n-    # We also have path.isWithinRelative, but its function is not defined.\n-    operator_code = \'string.relativePath\'\n-\n-    def get_query_value(self, value, index, criterion):\n-        if not criterion.Recurse():\n-            logger.warn(\n-                \'Cannot handle non-recursive path search. \'\n-                \'Allowing recursive search. %r\',\n-                value,\n-            )\n-        return criterion.getRelativePath()\n-\n-\n-class ATSimpleIntCriterionConverter(CriterionConverter):\n-    # Also available: int.lessThan, int.largerThan.\n-    operator_code = \'int.is\'\n-\n-    def get_operation(self, value, index, criterion):\n-        # Get dotted operation method.\n-        direction = value.get(\'range\')\n-        if not direction:\n-            code = \'is\'\n-        elif direction == \'min\':\n-            code = \'largerThan\'\n-        elif direction == \'max\':\n-            code = \'lessThan\'\n-        elif direction == \'min:max\':\n-            logger.warn(\n-                \'min:max direction not supported for integers. %r\',\n-                value,\n-            )\n-            return\n-        else:\n-            logger.warn(\'Unknown direction for integers. %r\', value)\n-            return\n-        return \'{0}.operation.int.{1}\'.format(prefix, code)\n-\n-    def get_query_value(self, value, index, criterion):\n-        if isinstance(value[\'query\'], tuple):\n-            logger.warn(\'More than one integer is not supported. %r\', value)\n-            return\n-        return value[\'query\']\n-\n-\n-class TopicMigrator(InplaceCMFItemMigrator):\n-    """Migrate Topics to Collections. Existing subtopics will be lost.\n-\n-    The only difference to the migration below is the base-class\n-    (InplaceCMFItemMigrator instead of InplaceCMFFolderMigrator).\n-    """\n-    src_portal_type = \'Topic\'\n-    src_meta_type = \'ATTopic\'\n-    dst_portal_type = dst_meta_type = \'Collection\'\n-\n-    @property\n-    def registry(self):\n-        return self.kwargs[\'registry\']\n-\n-    def beforeChange_criteria(self):\n-        """Store the criteria of the old Topic.\n-\n-        Store the info on the migrator and restore the values in the\n-        migrate_criteria method.\n-        """\n-        self._collection_sort_reversed = None\n-        self._collection_sort_on = None\n-        self._collection_query = None\n-        path = \'/\'.join(self.old.getPhysicalPath())\n-        logger.info(\'Migrating %s at %s\', self.src_portal_type, path)\n-        # Get the old criteria.\n-        # See also Products.ATContentTypes.content.topic.buildQuery\n-        criteria = self.old.listCriteria()\n-        logger.debug(\n-            \'Old criteria for %s: %r\',\n-            path,\n-            [(crit, crit.getCriteriaItems()) for crit in criteria],\n-        )\n-        formquery = []\n-        for criterion in criteria:\n-            type_ = criterion.__class__.__name__\n-            if type_ == \'ATSortCriterion\':\n-                # Sort order and direction are now stored in the Collection.\n-                self._collection_sort_reversed = criterion.getReversed()\n-                self._collection_sort_on = criterion.Field()\n-                logger.debug(\n-                    \'Sort on %r, reverse: %s.\',\n-                    self._collection_sort_on,\n-                    self._collection_sort_reversed,\n-                )\n-                continue\n-\n-            converter = CONVERTERS.get(type_)\n-            if converter is None:\n-                msg = \'Unsupported criterion {0}\'.format(type_)\n-                logger.error(msg)\n-                raise ValueError(msg)\n-            converter(formquery, criterion, self.registry)\n-\n-        logger.debug(\'New query for %s: %r\', path, formquery)\n-        self._collection_query = formquery\n-\n-    def migrate_criteria(self):\n-        """Migrate old style to new style criteria.\n-\n-        Plus handling for some special fields.\n-        """\n-        # The old Topic has boolean limitNumber and integer itemCount,\n-        # where the new Collection only has limit.\n-        adapted = ICollection(self.new)\n-        if self.old.getLimitNumber():\n-            adapted.limit = self.old.getItemCount()\n-        adapted.customViewFields = self.old.getCustomViewFields()\n-\n-        # Get the old data stored by the beforeChange_criteria method.\n-        if self._collection_sort_reversed is not None:\n-            adapted.sort_reversed = self._collection_sort_reversed\n-        if self._collection_sort_on is not None:\n-            adapted.sort_on = self._collection_sort_on\n-        if self._collection_query is not None:\n-            adapted.query = self._collection_query\n-\n-    def migrate_atctmetadata(self):\n-        field = self.old.getField(\'excludeFromNav\')\n-        self.new.exclude_from_nav = field.get(self.old)\n-\n-    def migrate_schema_fields(self):\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-\n-    def migrate_at_uuid(self):\n-        """Migrate AT universal uid\n-        """\n-        uid = self.UID\n-        if uid and queryAdapter(self.new, IMutableUUID):\n-            IMutableUUID(self.new).set(str(uid))\n-\n-    def last_migrate_layout(self):\n-        """Migrate the layout (view method).\n-\n-        This needs to be done last, as otherwise our changes in\n-        migrate_criteria may get overriden by a later call to\n-        migrate_properties.\n-        """\n-        if self.old.getCustomView():\n-            # Previously, the atct_topic_view had logic for showing\n-            # the results in a list or in tabular form.  If\n-            # getCustomView is True, this means the new object should\n-            # use the tabular view.\n-            self.new.setLayout(\'tabular_view\')\n-            return\n-\n-        old_layout = self.old.getLayout() or getattr(self.old, \'layout\', None)\n-        if old_layout in LISTING_VIEW_MAPPING:\n-            self.new.setLayout(LISTING_VIEW_MAPPING[old_layout])\n-\n-\n-class FolderishTopicMigrator(InplaceCMFFolderMigrator):\n-    """Migrate Topics and Subtopics to folderish collections.\n-\n-    The only difference to the migration above is the base-class\n-    (InplaceCMFFolderMigrator instead of InplaceCMFItemMigrator).\n-    """\n-    src_portal_type = \'Topic\'\n-    src_meta_type = \'ATTopic\'\n-    dst_portal_type = dst_meta_type = \'Collection\'\n-\n-    @property\n-    def registry(self):\n-        return self.kwargs[\'registry\']\n-\n-    def beforeChange_criteria(self):\n-        """Store the criteria of the old Topic.\n-\n-        Store the info on the migrator and restore the values in the\n-        migrate_criteria method.\n-        """\n-        self._collection_sort_reversed = None\n-        self._collection_sort_on = None\n-        self._collection_query = None\n-        path = \'/\'.join(self.old.getPhysicalPath())\n-        logger.info(\'Migrating %s at %s\', self.src_portal_type, path)\n-        # Get the old criteria.\n-        # See also Products.ATContentTypes.content.topic.buildQuery\n-        criteria = self.old.listCriteria()\n-        logger.debug(\'Old criteria for %s: %r\', path,\n-                     [(crit, crit.getCriteriaItems()) for crit in criteria])\n-        formquery = []\n-        for criterion in criteria:\n-            type_ = criterion.__class__.__name__\n-            if type_ == \'ATSortCriterion\':\n-                # Sort order and direction are now stored in the Collection.\n-                self._collection_sort_reversed = criterion.getReversed()\n-                self._collection_sort_on = criterion.Field()\n-                logger.debug(\n-                    \'Sort on %r, reverse: %s.\',\n-                    self._collection_sort_on,\n-                    self._collection_sort_reversed,\n-                )\n-                continue\n-\n-            converter = CONVERTERS.get(type_)\n-            if converter is None:\n-                msg = \'Unsupported criterion {0}\'.format(type_)\n-                logger.error(msg)\n-                raise ValueError(msg)\n-            converter(formquery, criterion, self.registry)\n-\n-        logger.debug(\'New query for %s: %r\', path, formquery)\n-        self._collection_query = formquery\n-\n-    def migrate_criteria(self):\n-        """Migrate old style to new style criteria.\n-\n-        Plus handling for some special fields.\n-        """\n-        # The old Topic has boolean limitNumber and integer itemCount,\n-        # where the new Collection only has limit.\n-        adapted = ICollection(self.new)\n-        if self.old.getLimitNumber():\n-            adapted.limit = self.old.getItemCount()\n-        adapted.customViewFields = self.old.getCustomViewFields()\n-\n-        # Get the old data stored by the beforeChange_criteria method.\n-        if self._collection_sort_reversed is not None:\n-            adapted.sort_reversed = self._collection_sort_reversed\n-        if self._collection_sort_on is not None:\n-            adapted.sort_on = self._collection_sort_on\n-        if self._collection_query is not None:\n-            adapted.query = self._collection_query\n-\n-    def migrate_atctmetadata(self):\n-        field = self.old.getField(\'excludeFromNav\')\n-        self.new.exclude_from_nav = field.get(self.old)\n-\n-    def migrate_schema_fields(self):\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-\n-    def migrate_at_uuid(self):\n-        """Migrate AT universal uid\n-        """\n-        uid = self.UID\n-        if uid and queryAdapter(self.new, IMutableUUID):\n-            IMutableUUID(self.new).set(str(uid))\n-\n-    def last_migrate_layout(self):\n-        """Migrate the layout (view method).\n-\n-        This needs to be done last, as otherwise our changes in\n-        migrate_criteria may get overriden by a later call to\n-        migrate_properties.\n-        """\n-        if self.old.getCustomView():\n-            # Previously, the atct_topic_view had logic for showing\n-            # the results in a list or in tabular form.  If\n-            # getCustomView is True, this means the new object should\n-            # use the tabular view.\n-            self.new.setLayout(\'tabular_view\')\n-            return\n-\n-        old_layout = self.old.getLayout() or getattr(self.old, \'layout\', None)\n-        if old_layout in LISTING_VIEW_MAPPING:\n-            default_page = self.old.getDefaultPage()\n-            self.new.setLayout(LISTING_VIEW_MAPPING[old_layout])\n-            if default_page:\n-                # any defaultPage is switched of by setLayout\n-                # and needs to set again\n-                self.new.setDefaultPage(default_page)\n-\n-\n-def migrate_topics(portal):\n-    """Migrate ATContentTypes Topics to plone.app.contenttypes Collections.\n-\n-    This could also be used as upgrade step.\n-    """\n-    # Parse the registry to get allowed operations and pass it to the\n-    # migrator.\n-    reg = getUtility(IRegistry)\n-    reader = IQuerystringRegistryReader(reg)\n-    registry = reader.parseRegistry()\n-    # select migrator based on the base-class of collections\n-    fti = portal.portal_types[\'Collection\']\n-    if fti.content_meta_type == \'Dexterity Item\':\n-        migrator = TopicMigrator\n-    elif fti.content_meta_type == \'Dexterity Container\':\n-        migrator = FolderishTopicMigrator\n-    walker = CustomQueryWalker(portal, migrator)(registry=registry)\n-    return walker\n-\n-\n-CONVERTERS = {\n-    # Create an instance of each converter.\n-    \'ATBooleanCriterion\': ATBooleanCriterionConverter(),\n-    \'ATCurrentAuthorCriterion\': ATCurrentAuthorCriterionConverter(),\n-    \'ATDateCriteria\': ATDateCriteriaConverter(),\n-    \'ATDateRangeCriterion\': ATDateRangeCriterionConverter(),\n-    \'ATListCriterion\': ATListCriterionConverter(),\n-    \'ATPathCriterion\': ATPathCriterionConverter(),\n-    \'ATPortalTypeCriterion\': ATPortalTypeCriterionConverter(),\n-    \'ATReferenceCriterion\': ATReferenceCriterionConverter(),\n-    \'ATRelativePathCriterion\': ATRelativePathCriterionConverter(),\n-    \'ATSelectionCriterion\': ATSelectionCriterionConverter(),\n-    \'ATSimpleIntCriterion\': ATSimpleIntCriterionConverter(),\n-    \'ATSimpleStringCriterion\': ATSimpleStringCriterionConverter(),\n-}\ndiff --git a/plone/app/contenttypes/migration/utils.py b/plone/app/contenttypes/migration/utils.py\ndeleted file mode 100644\nindex 16cd92a3..00000000\n--- a/plone/app/contenttypes/migration/utils.py\n+++ /dev/null\n@@ -1,573 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from Acquisition import aq_base\n-from archetypes.schemaextender.interfaces import IBrowserLayerAwareExtender\n-from archetypes.schemaextender.interfaces import IOrderableSchemaExtender\n-from archetypes.schemaextender.interfaces import ISchemaExtender\n-from archetypes.schemaextender.interfaces import ISchemaModifier\n-from copy import deepcopy\n-from plone.app.contentrules.api import assign_rule\n-from plone.app.contenttypes.behaviors.leadimage import ILeadImage\n-from plone.app.contenttypes.migration.field_migrators import migrate_imagefield\n-from plone.app.contenttypes.migration.field_migrators import migrate_simplefield  # noqa\n-from plone.app.contenttypes.utils import DEFAULT_TYPES\n-from plone.app.discussion.interfaces import IConversation\n-from plone.app.linkintegrity.handlers import modifiedArchetype\n-from plone.app.linkintegrity.handlers import modifiedDexterity\n-from plone.app.linkintegrity.handlers import referencedRelationship\n-from plone.app.uuid.utils import uuidToObject\n-from plone.dexterity.utils import iterSchemataForType\n-from plone.contentrules.engine.interfaces import IRuleAssignmentManager\n-from plone.contentrules.engine.interfaces import IRuleStorage\n-from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.interfaces import IDexterityFTI\n-from plone.portlets.constants import CONTEXT_BLACKLIST_STATUS_KEY\n-from plone.portlets.interfaces import ILocalPortletAssignable\n-from plone.portlets.interfaces import IPortletAssignmentMapping\n-from plone.portlets.interfaces import IPortletManager\n-from plone.uuid.interfaces import IUUID\n-from Products.Archetypes.config import REFERENCE_CATALOG\n-from Products.Archetypes.interfaces.referenceable import IReferenceable\n-from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone import DISCUSSION_ANNOTATION_KEY\n-from Products.CMFPlone.interfaces import IPloneSiteRoot\n-from Products.CMFPlone.utils import safe_hasattr\n-from Products.Five.browser import BrowserView\n-from Products.GenericSetup.context import DirectoryImportContext\n-from Products.GenericSetup.utils import importObjects\n-from z3c.relationfield import RelationValue\n-from z3c.relationfield.schema import Relation\n-from z3c.relationfield.schema import RelationChoice\n-from z3c.relationfield.schema import RelationList\n-from zc.relation.interfaces import ICatalog\n-from zExceptions import NotFound\n-from zope.annotation.interfaces import IAnnotations\n-from zope.component import getGlobalSiteManager\n-from zope.component import getMultiAdapter\n-from zope.component import getSiteManager\n-from zope.component import getUtility\n-from zope.component import queryUtility\n-from zope.component.hooks import getSite\n-from zope.intid.interfaces import IIntIds\n-from zope.lifecycleevent import modified\n-\n-import json\n-import logging\n-import os\n-\n-\n-logger = logging.getLogger(__name__)\n-\n-\n-def isSchemaExtended(iface):\n-    """Return a list of fields added by archetypes.schemaextender\n-    """\n-    fields = _compareSchemata(iface)\n-    fields2 = _checkForExtenderInterfaces(iface)\n-    fields.extend(fields2)\n-    return [i for i in set(fields)]\n-\n-\n-def _compareSchemata(interface):\n-    """Return a list of extended fields by archetypes.schemaextender\n-    by comparing the real and the default schemata.\n-    """\n-    portal = getSite()\n-    pc = portal.portal_catalog\n-    brains = pc(object_provides=interface.__identifier__)\n-    for brain in brains:\n-        if not brain.meta_type or \'dexterity\' in brain.meta_type.lower():\n-            # There might be DX types with same iface and meta_type than AT\n-            continue\n-        try:\n-            obj = brain.getObject()\n-        except (KeyError, NotFound):\n-            continue\n-        real_fields = set(obj.Schema()._names)\n-        orig_fields = set(obj.schema._names)\n-        diff = [i for i in real_fields.difference(orig_fields)]\n-        return diff\n-    return []\n-\n-\n-def _checkForExtenderInterfaces(interface):\n-    """Return whether a specific content type interface\n-    is extended by archetypes.schemaextender or not.\n-    """\n-    sm = getGlobalSiteManager()\n-    extender_interfaces = [\n-        ISchemaExtender,\n-        ISchemaModifier,\n-        IBrowserLayerAwareExtender,\n-        IOrderableSchemaExtender,\n-    ]\n-    # We have a few possible interfaces to test\n-    # here, so get all the interfaces that\n-    # are for the given content type first\n-    registrations = \\\n-        [a for a in sm.registeredAdapters() if interface in a.required]\n-    for adapter in registrations:\n-        if adapter.provided in extender_interfaces:\n-            fields = getattr(adapter.factory(None), \'fields\', [])\n-            return [field.getName() for field in fields]\n-    return []\n-\n-\n-def installTypeIfNeeded(type_name):\n-    """Make sure the dexterity-fti is already installed.\n-    If not we create a empty dexterity fti and load the\n-    information from the fti in the profile.\n-    """\n-    if type_name not in DEFAULT_TYPES:\n-        raise KeyError(\'{0} is not one of the default types\'.format(type_name))\n-    portal = getSite()\n-    tt = getToolByName(portal, \'portal_types\')\n-    fti = tt.getTypeInfo(type_name)\n-    if IDexterityFTI.providedBy(fti):\n-        # The dx-type is already installed, so keep it.  But this\n-        # might be an old dexterity type of Collection, in which case\n-        # it is better to replace it.\n-        if type_name != \'Collection\':\n-            return\n-        if fti.klass == \'plone.app.contenttypes.content.Collection\':\n-            # If the klass is fine, we are happy.\n-            return\n-    if fti:\n-        tt.manage_delObjects(type_name)\n-    tt.manage_addTypeInformation(\'Dexterity FTI\', id=type_name)\n-    dx_fti = tt.getTypeInfo(type_name)\n-    ps = getToolByName(portal, \'portal_setup\')\n-    profile_info = ps.getProfileInfo(\'profile-plone.app.contenttypes:default\')\n-    profile_path = os.path.join(profile_info[\'path\'])\n-    environ = DirectoryImportContext(ps, profile_path)\n-    parent_path = \'types/\'\n-    importObjects(dx_fti, parent_path, environ)\n-\n-\n-def add_portlet(context, assignment, portlet_key, columnName):\n-    column = getUtility(IPortletManager, columnName)\n-    assignmentmapping = getMultiAdapter((context, column),\n-                                        IPortletAssignmentMapping)\n-    assignmentmapping[portlet_key] = assignment\n-\n-\n-def move_comments(source_object, target_object):\n-    """Move comments by copying the annotation to the target\n-    and then removing the comments from the source (not the annotation).\n-    """\n-    source_annotations = IAnnotations(source_object)\n-    comments = source_annotations.get(DISCUSSION_ANNOTATION_KEY, None)\n-    if comments is not None:\n-        target_annotations = IAnnotations(target_object)\n-        if target_annotations.get(DISCUSSION_ANNOTATION_KEY, None) is not None:\n-            logger.error(\'Comments exist on {0}\').format(\n-                target_object.absolute_url())\n-        # reset the parent before copying\n-        del comments.__parent__\n-        copy_of_comments = deepcopy(comments)\n-        copy_of_comments.__parent__ = target_object\n-        target_annotations[DISCUSSION_ANNOTATION_KEY] = copy_of_comments\n-\n-        # Delete comments from the portal where whey were stored temporarily.\n-        # Comments on the old objects will be removed with the objects.\n-        if IPloneSiteRoot.providedBy(source_object):\n-            source_conversation = IConversation(source_object)\n-            for comment in source_conversation.getComments():\n-                del source_conversation[comment.comment_id]\n-            del source_annotations[DISCUSSION_ANNOTATION_KEY]\n-\n-\n-def copy_contentrules(source_object, target_object):\n-    """Copy contentrules.\n-    """\n-    source_assignable = IRuleAssignmentManager(source_object, None)\n-    if source_assignable is not None:\n-        try:\n-            IRuleAssignmentManager(target_object)\n-        except TypeError:\n-            logger.info(\n-                \'Cound not assign contentrules to {0}\'.format(\n-                    target_object.absolute_url()\n-                )\n-            )\n-            return\n-        rules_storage = getUtility(IRuleStorage)\n-        available_rules = [r for r in rules_storage]\n-        for rule_id in source_assignable:\n-            if rule_id not in available_rules:\n-                logger.info(\n-                    \'Contentrule {0} does not exist, skip assignment!\'.format(\n-                        rule_id\n-                    )\n-                )\n-                continue\n-            assign_rule(target_object, rule_id)\n-\n-\n-def migrate_leadimage(source_object, target_object):\n-    """ Migrate images added using collective.contentleadimage to the\n-    ILeadImage-behavior of plone.app.contenttypes if it is enabled.\n-    """\n-    OLD_LEADIMAGE_FIELD_NAME = \'leadImage\'\n-    OLD_CAPTION_FIELD_NAME = \'leadImage_caption\'\n-    NEW_LEADIMAGE_FIELD_NAME = \'image\'\n-    NEW_CAPTION_FIELD_NAME = \'image_caption\'\n-\n-    if not source_object.getField(OLD_LEADIMAGE_FIELD_NAME):\n-        # skip if old content has no field\n-        return\n-\n-    if ILeadImage(target_object, None) is None:\n-        # skip if new content does not have the LeadImage-behavior enabled\n-        logger.info(\'Target does not have the behavior "Lead Image" enabled. \'\n-                    \'Could not migrate collective.leadimage fields.\')\n-        return\n-\n-    acc = source_object.getField(\n-        OLD_LEADIMAGE_FIELD_NAME).getAccessor(source_object)()\n-    if getattr(acc, \'filename\', None) is None:\n-        # skip if old content has field but has no lead image in the field\n-        return\n-\n-    # handle image field\n-    migrate_imagefield(\n-        source_object,\n-        target_object,\n-        OLD_LEADIMAGE_FIELD_NAME,\n-        NEW_LEADIMAGE_FIELD_NAME)\n-\n-    # handle image caption field\n-    migrate_simplefield(\n-        source_object,\n-        target_object,\n-        OLD_CAPTION_FIELD_NAME,\n-        NEW_CAPTION_FIELD_NAME)\n-    logger.info(\'Migrating contentlead image for {0}.\'.format(\n-        target_object.absolute_url())\n-    )\n-\n-\n-def migrate_portlets(src_obj, dst_obj):\n-    """Copy portlets for all available portletmanagers from one object\n-    to another.\n-    Also takes blocked portlet settings into account, keeps hidden portlets\n-    hidden and skips broken assignments.\n-    """\n-    if not ILocalPortletAssignable.providedBy(src_obj) or \\\n-       not ILocalPortletAssignable.providedBy(dst_obj):\n-        return\n-\n-    # also take custom portlet managers into account\n-    managers = [reg.name for reg in getSiteManager().registeredUtilities()\n-                if reg.provided == IPortletManager]\n-    # faster, but no custom managers\n-    # managers = [u\'plone.leftcolumn\', u\'plone.rightcolumn\']\n-\n-    # copy information which categories are hidden for which manager\n-    blacklist_status = IAnnotations(src_obj).get(\n-        CONTEXT_BLACKLIST_STATUS_KEY, None)\n-    if blacklist_status is not None:\n-        IAnnotations(dst_obj)[CONTEXT_BLACKLIST_STATUS_KEY] = \\\n-            deepcopy(blacklist_status)\n-\n-    # copy all portlet assignments (visibilty is stored as annotation\n-    # on the assignments and gets copied here too)\n-    for manager in managers:\n-        column = getUtility(IPortletManager, manager)\n-        mappings = getMultiAdapter((src_obj, column),\n-                                   IPortletAssignmentMapping)\n-        for key, assignment in mappings.items():\n-            # skip possibly broken portlets here\n-            if not hasattr(assignment, \'__Broken_state__\'):\n-                add_portlet(dst_obj, assignment, key, manager)\n-            else:\n-                logger.warn(u\'skipping broken portlet assignment {0} \'\n-                            \'for manager {1}\'.format(key, manager))\n-\n-\n-def store_references(context):\n-    """Store all references in the portal as a annotation on the portal."""\n-    all_references = get_all_references(context)\n-    key = \'ALL_REFERENCES\'\n-    IAnnotations(context)[key] = all_references\n-    logger.info(\'Stored {0} relations for later restore.\'.format(\n-        len(all_references))\n-    )\n-\n-\n-class ExportAllReferences(BrowserView):\n-    """Returns all references in the portal as json.\n-    """\n-\n-    def __call__(self):\n-        data = get_all_references(self.context)\n-        self.request.response.setHeader(\'Content-type\', \'application/json\')\n-        return json.dumps(data)\n-\n-\n-def get_all_references(context):\n-    results = []\n-    # Archetypes\n-    # Get all data from the reference_catalog if it exists\n-    reference_catalog = getToolByName(context, REFERENCE_CATALOG, None)\n-    if reference_catalog is not None:\n-        for brain in reference_catalog.getAllBrains():\n-            results.append({\n-                \'from_uuid\': brain.sourceUID,\n-                \'to_uuid\': brain.targetUID,\n-                \'relationship\': brain.relationship,\n-            })\n-\n-    # Dexterity\n-    # Get all data from zc.relation (relation_catalog)\n-    portal_catalog = getToolByName(context, \'portal_catalog\')\n-    relation_catalog = queryUtility(ICatalog)\n-    for rel in relation_catalog.findRelations():\n-        if rel.from_path and rel.to_path:\n-            from_brain = portal_catalog(path=dict(query=rel.from_path,\n-                                                  depth=0))\n-            to_brain = portal_catalog(path=dict(query=rel.to_path, depth=0))\n-            if len(from_brain) > 0 and len(to_brain) > 0:\n-                results.append({\n-                    \'from_uuid\': from_brain[0].UID,\n-                    \'to_uuid\': to_brain[0].UID,\n-                    \'relationship\': rel.from_attribute,\n-                })\n-    return results\n-\n-\n-def restore_references(context, relationship_fieldname_mapping=None):\n-    """Recreate all references stored in an annotation on the context.\n-\n-    Iterate over the stored references and restore them all according to\n-    the content-types framework.\n-\n-    Accepts an optional relationship_fieldname_mapping argument.\n-    This must be a dictionary with a relationship name as key and fieldname as value.\n-    For example:\n-    relationship_fieldname_mapping =  {\n-        \'advisory_contact\': \'contact\',\n-        \'study_contact\': \'contact\',\n-    }\n-    In this case, old Archetypes content types Advisory and Study both had a\n-    reference field \'contact\' to a content type Contact.\n-    This relationship was stored under different names for the two contenttypes.\n-    After migration to Dexterity, the above mapping makes sure the relation is still\n-    stored on the \'contact\' field in both cases.\n-    The attribute_name of the RelationValue will be the same as this fieldname,\n-    which is what happens by default when setting relations.\n-\n-    By default we will also map the \'relatesTo\' relation to the \'relatedItems\' field.\n-    This is needed for ATContentTypes.\n-    """\n-    if relationship_fieldname_mapping is None:\n-        relationship_fieldname_mapping = {}\n-    if \'relatesTo\' not in relationship_fieldname_mapping:\n-        # ATContentTypes used this relation.\n-        relationship_fieldname_mapping[\'relatesTo\'] = \'relatedItems\'\n-    key = \'ALL_REFERENCES\'\n-    all_references = IAnnotations(context)[key]\n-    logger.info(\'Restoring {0} relations.\'.format(\n-        len(all_references))\n-    )\n-    for index, ref in enumerate(all_references, 1):\n-        source_obj = uuidToObject(ref[\'from_uuid\'])\n-        target_obj = uuidToObject(ref[\'to_uuid\'])\n-        relationship = ref[\'relationship\']\n-        if source_obj and target_obj:\n-            relationship = ref[\'relationship\']\n-            # By default use the relationship as fieldname.  Fall back to the relationship.\n-            fieldname = relationship_fieldname_mapping.get(relationship, relationship)\n-            link_items(context, source_obj, target_obj, relationship, fieldname)\n-        else:\n-            logger.warn(\n-                \'Could not restore reference from uid \'\n-                \'"{0}" to uid "{1}" on the context: {2}\'.format(\n-                    ref[\'from_uuid\'],\n-                    ref[\'to_uuid\'],\n-                    \'/\'.join(context.getPhysicalPath())\n-                )\n-            )\n-        if not index % 100:\n-            logger.info(\'Restoring relations: {}/{}\'.format(\n-                index, len(all_references)))\n-    del IAnnotations(context)[key]\n-\n-\n-def link_items(  # noqa\n-    context,\n-    source_obj,\n-    target_obj,\n-    relationship=None,\n-    fieldname=\'relatedItems\',\n-):\n-    """Add a relation between two content objects.\n-\n-    This uses the field \'relatedItems\' and works for Archetypes and Dexterity.\n-    By passing a fieldname and a relationship it can be used to create\n-    arbitrary relations.\n-\n-    Note: for the relatedItems field, Products.ATContentTypes uses \'relatesTo\'\n-    and plone.app.contenttypes uses \'relatedItems\'.\n-    We switch between these two, based on the source object.\n-    """\n-    # relations from AT to DX and from DX to AT are only possible through\n-    # the referenceable-behavior:\n-    # plone.app.referenceablebehavior.referenceable.IReferenceable\n-    drop_msg = """Dropping reference from %s to %s since\n-    plone.app.referenceablebehavior is not enabled!"""\n-\n-    if source_obj is target_obj:\n-        # Thou shalt not relate to yourself.\n-        return\n-\n-    if IDexterityContent.providedBy(source_obj):\n-        source_type = \'DX\'\n-    else:\n-        source_type = \'AT\'\n-\n-    if IDexterityContent.providedBy(target_obj):\n-        target_type = \'DX\'\n-    else:\n-        target_type = \'AT\'\n-\n-    if relationship == referencedRelationship:\n-        # \'isReferencing\' is the relationship for linkintegrity-relations.\n-        # Linkintegrity-relations should automatically be (re)created by\n-        # plone.app.linkintegrity.handlers.modifiedDexterity or\n-        # plone.app.linkintegrity.handlers.modifiedArchetype\n-        # when a ObjectModifiedEvent is thrown.\n-        # These relations are only created if the source has a richtext-field\n-        # with a link to the target and should not be created manually.\n-        if source_type == \'AT\':\n-            modifiedArchetype(source_obj, None)\n-        if source_type == \'DX\':\n-            modifiedDexterity(source_obj, None)\n-        return\n-\n-    if source_type == \'AT\':\n-        if relationship == \'relatedItems\':\n-            relationship = \'relatesTo\'\n-        # If there is any Archetypes-content there is also the\n-        # reference_catalog. For a site without AT content this\n-        # might not be there at all.\n-        reference_catalog = getToolByName(context, REFERENCE_CATALOG)\n-        uid_catalog = getToolByName(context, \'uid_catalog\')\n-        if target_type == \'DX\' and not is_referenceable(target_obj):\n-            logger.info(drop_msg % (\n-                source_obj.absolute_url(), target_obj.absolute_url()))\n-            return\n-\n-        # Make sure both objects are properly indexed and referenceable\n-        # Some objects that werde just created (migrated) are not yet\n-        # indexed properly.\n-        source_uid = IUUID(source_obj)\n-        target_uid = IUUID(target_obj)\n-        _catalog = uid_catalog._catalog\n-\n-        if not _catalog.indexes[\'UID\']._index.get(source_uid):\n-            uid_catalog.catalog_object(source_obj, source_uid)\n-            modified(source_obj)\n-\n-        if not _catalog.indexes[\'UID\']._index.get(target_uid):\n-            uid_catalog.catalog_object(target_obj, target_uid)\n-            modified(target_obj)\n-\n-        field = source_obj.getField(fieldname)\n-        if field is None:\n-            # we can\'t migrate if it doesn\'t actually have the field\n-            return\n-        accessor = field.getAccessor(source_obj)\n-        existing_at_relations = accessor()\n-\n-        if not isinstance(existing_at_relations, list):\n-            existing_at_relations = [i for i in existing_at_relations]\n-        if not existing_at_relations:\n-            existing_at_relations = []\n-        if target_obj in existing_at_relations:\n-            # don\'t do anything\n-            return\n-\n-        target_uid = IUUID(target_obj)\n-        targetUIDs = [ref.targetUID for ref in reference_catalog.getReferences(\n-            source_obj, relationship)]\n-        if target_uid in targetUIDs:\n-            # Drop relation since the old ones are most likely broken.\n-            reference_catalog.deleteReference(\n-                source_obj, target_uid, relationship)\n-\n-        existing_at_relations.append(target_obj)\n-        mutator = field.getMutator(source_obj)\n-        mutator(existing_at_relations)\n-        modified(source_obj)\n-        return\n-\n-    if source_type is \'DX\':\n-        if relationship == \'relatesTo\':\n-            relationship = \'relatedItems\'\n-        if target_type is \'AT\' and not is_referenceable(source_obj):\n-            logger.info(drop_msg % (\n-                source_obj.absolute_url(), target_obj.absolute_url()))\n-            return\n-        # handle dx-relation\n-        if relationship == \'translationOf\':\n-            # LinguaPlone relations make no sense for Dexterity\n-            return\n-\n-        intids = getUtility(IIntIds)\n-        to_id = intids.getId(target_obj)\n-        # Before we set the fieldname attribute on the source object,\n-        # we need to know if this should be a list or a single item.\n-        # Might be None at the moment.\n-        # We check the field definition.\n-        fti = getUtility(IDexterityFTI, name=source_obj.portal_type)\n-        field = None\n-        for schema in iterSchemataForType(fti):\n-            field = schema.get(fieldname, None)\n-            if field is not None:\n-                break\n-        if isinstance(field, RelationList):\n-            existing_relations = getattr(source_obj, fieldname, [])\n-            if existing_relations is None:\n-                existing_relations = []\n-            else:\n-                # purge broken relations\n-                existing_relations = [\n-                    i for i in existing_relations if i.to_id is not None]\n-            if to_id not in [i.to_id for i in existing_relations]:\n-                existing_relations.append(RelationValue(to_id))\n-                setattr(source_obj, fieldname, existing_relations)\n-                modified(source_obj)\n-                return\n-            return\n-        elif isinstance(field, (Relation, RelationChoice)):\n-            setattr(source_obj, fieldname, RelationValue(to_id))\n-            modified(source_obj)\n-            return\n-\n-        # We should never end up here!\n-        logger.warning(\'Ignoring unknown fieldname %s when restoring relation %s from %s to %s\',\n-            fieldname, relationship, source_obj.absolute_url(), target_obj.absolute_url())\n-\n-\n-def is_referenceable(obj):\n-    """Find out if this object (AT or DX) is referenceable.\n-\n-    Return True if a obj can be referenced using the reference_catalog used by\n-    Archetypes-Relations and Linkintegrity.\n-\n-    Relations using the relation_catalog (zc.relation.interfaces.ICatalog) are\n-    not covered by this test!\n-    """\n-    is_referenceable = False\n-    if IReferenceable.providedBy(obj) or \\\n-            safe_hasattr(aq_base(obj), \'isReferenceable\'):\n-        is_referenceable = True\n-    else:\n-        try:\n-            # This most likely the case when plone.app.referenceablebehavior\n-            # is enabled.\n-            obj = IReferenceable(obj)\n-            is_referenceable = True\n-        except TypeError:\n-            is_referenceable = False\n-    return is_referenceable\ndiff --git a/plone/app/contenttypes/migration/vocabularies.py b/plone/app/contenttypes/migration/vocabularies.py\ndeleted file mode 100644\nindex c1e76df4..00000000\n--- a/plone/app/contenttypes/migration/vocabularies.py\n+++ /dev/null\n@@ -1,235 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.blob.interfaces import IATBlobFile\n-from plone.app.blob.interfaces import IATBlobImage\n-from plone.app.contenttypes import _\n-from plone.app.contenttypes.migration import migration\n-from plone.app.contenttypes.migration.topics import migrate_topics\n-from plone.app.contenttypes.migration.utils import isSchemaExtended\n-from Products.ATContentTypes.interfaces.document import IATDocument\n-from Products.ATContentTypes.interfaces.event import IATEvent\n-from Products.ATContentTypes.interfaces.file import IATFile\n-from Products.ATContentTypes.interfaces.folder import IATFolder\n-from Products.ATContentTypes.interfaces.image import IATImage\n-from Products.ATContentTypes.interfaces.link import IATLink\n-from Products.ATContentTypes.interfaces.news import IATNewsItem\n-from Products.ATContentTypes.interfaces.topic import IATTopic\n-from Products.CMFCore.utils import getToolByName\n-from zope.interface import implementer\n-from zope.schema.interfaces import IVocabularyFactory\n-from zope.schema.vocabulary import SimpleVocabulary\n-\n-import pkg_resources\n-\n-\n-import six\n-\n-\n-try:\n-    pkg_resources.get_distribution(\'plone.app.collection\')\n-except pkg_resources.DistributionNotFound:\n-    ICollection = None\n-    HAS_APP_COLLECTION = False\n-else:\n-    HAS_APP_COLLECTION = True\n-    from plone.app.collection.interfaces import ICollection\n-\n-ATCT_LIST = {\n-    \'Folder\': {\n-        \'iface\': IATFolder,\n-        \'migrator\': migration.migrate_folders,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Folder\',\n-        \'old_meta_type\': \'ATFolder\',\n-    },\n-    \'Document\': {\n-        \'iface\': IATDocument,\n-        \'migrator\': migration.migrate_documents,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Document\',\n-        \'old_meta_type\': \'ATDocument\',\n-    },\n-    # File without blobs\n-    \'File\': {\n-        \'iface\': IATFile,\n-        \'migrator\': migration.migrate_files,\n-        \'extended_fields\': [],\n-        \'type_name\': \'File\',\n-        \'old_meta_type\': \'ATFile\',\n-    },\n-    # Image without blobs\n-    \'Image\': {\n-        \'iface\': IATImage,\n-        \'migrator\': migration.migrate_images,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Image\',\n-        \'old_meta_type\': \'ATImage\',\n-    },\n-    \'News Item\': {\n-        \'iface\': IATNewsItem,\n-        \'migrator\': migration.migrate_newsitems,\n-        \'extended_fields\': [],\n-        \'type_name\': \'News Item\',\n-        \'old_meta_type\': \'ATNewsItem\',\n-    },\n-    \'Link\': {\n-        \'iface\': IATLink,\n-        \'migrator\': migration.migrate_links,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Link\',\n-        \'old_meta_type\': \'ATLink\',\n-    },\n-    \'Event\': {\n-        \'iface\': IATEvent,\n-        \'migrator\': migration.migrate_events,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Event\',\n-        \'old_meta_type\': \'ATEvent\',\n-    },\n-    \'BlobImage\': {\n-        \'iface\': IATBlobImage,\n-        \'migrator\': migration.migrate_blobimages,\n-        \'extended_fields\': [\'image\'],\n-        \'type_name\': \'Image\',\n-        \'old_meta_type\': \'ATBlob\',\n-    },\n-    \'BlobFile\': {\n-        \'iface\': IATBlobFile,\n-        \'migrator\': migration.migrate_blobfiles,\n-        \'extended_fields\': [\'file\'],\n-        \'type_name\': \'File\',\n-        \'old_meta_type\': \'ATBlob\',\n-    },\n-    \'Topic\': {\n-        \'iface\': IATTopic,\n-        \'migrator\': migrate_topics,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Collection\',\n-        \'old_meta_type\': \'ATTopic\',\n-    },\n-}\n-\n-if HAS_APP_COLLECTION:\n-    ATCT_LIST[\'Collection\'] = {\n-        \'iface\': ICollection,\n-        \'migrator\': migration.migrate_collections,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Collection\',\n-        \'old_meta_type\': \'Collection\',\n-    }\n-\n-\n-def get_terms(context, counter, ext_dict, show_extended):\n-    """Takes dicts of types and their numbers and their extended fields\n-    Returns a list of SimpleVocabularyTerms:\n-    value = meta_type,\n-    token = meta_type,\n-    title = translated_meta_type (number_of_instances) - extended fields: list\n-    """\n-    results = []\n-    for k, v in six.iteritems(counter):\n-        if not show_extended:\n-            if k not in ext_dict:\n-                display = u\'{0} ({1})\'.format(context.translate(_(k)), v)\n-                term = SimpleVocabulary.createTerm(k, k, display)\n-                results.append(term)\n-        else:\n-            if k in ext_dict:\n-                ext = str(ext_dict[k][\'fields\']).\\\n-                    replace(\'[\', \'\').replace(\']\', \'\')\n-                display = u\'{0} ({1}) - extended fields: {2}\'.\\\n-                    format(context.translate(_(k)), v, ext)\n-                term = SimpleVocabulary.createTerm(k, k, display)\n-                results.append(term)\n-    results.sort(key=lambda x: x.title)\n-    return results\n-\n-\n-def count(brains):\n-    """Turns a list of brains into a dict {<meta_type>:<number_of_instances>,}\n-    Since Image and File both have the meta_type \'ATBlob\' they are handled\n-    differently.\n-    """\n-    counter = {}\n-    for brain in brains:\n-        pt = brain.portal_type\n-        if \'Blob\' in brain.meta_type:\n-            if pt == \'File\':\n-                pt = \'BlobFile\'\n-            else:\n-                pt = \'BlobImage\'\n-        if not counter.get(pt):\n-            counter[pt] = 0\n-        if not brain.meta_type or \'dexterity\' in brain.meta_type.lower():\n-            # There might be DX types with same iface and meta_type than AT\n-            continue\n-        counter[pt] += 1\n-    return counter\n-\n-\n-def results(context, show_extended=False):\n-    """Helper method to create the vocabularies used below.\n-    Searches the catalog for AT-meta_types to get all Archetypes content.\n-    If show_extended is true the returned SimpleVocabulary will include\n-    types that are extended beyond what is expected.\n-    """\n-    ext_dict = {}\n-    meta_types = []\n-    for k, v in ATCT_LIST.items():\n-        extendend_fields = isSchemaExtended(v[\'iface\'])\n-        expected = v[\'extended_fields\']\n-        is_extended = len(extendend_fields) > len(expected)\n-        if is_extended and show_extended:\n-            meta_types.append(v[\'old_meta_type\'])\n-            ext_dict[k] = {}\n-            if expected:\n-                extendend_fields.remove(expected[0])\n-            ext_dict[k][\'fields\'] = extendend_fields\n-\n-        elif not show_extended and not is_extended:\n-            meta_types.append(v[\'old_meta_type\'])\n-    catalog = getToolByName(context, \'portal_catalog\')\n-    brains = catalog.search({\'meta_type\': meta_types})\n-    counter = count(brains)\n-\n-    return SimpleVocabulary(get_terms(context,\n-                                      counter,\n-                                      ext_dict,\n-                                      show_extended))\n-\n-\n-@implementer(IVocabularyFactory)\n-class ATCTypesVocabulary(object):\n-\n-    def __call__(self, context):\n-        """Return a vocabulary with standard content types\n-        and, for each one, the number of occurrences.\n-        """\n-        return results(context, show_extended=False)\n-\n-\n-@implementer(IVocabularyFactory)\n-class ExtendedTypesVocabulary(object):\n-\n-    def __call__(self, context):\n-        """Return a vocabulary with all extended types\n-        and for each the number of occurences and a list of the\n-        extended fields.\n-        """\n-        return results(context, show_extended=True)\n-\n-\n-@implementer(IVocabularyFactory)\n-class ChangedBaseClasses(object):\n-\n-    def __call__(self, context):\n-        """Return a vocabulary with all changed base classes."""\n-        from plone.app.contenttypes.migration.dxmigration import \\\n-            list_of_changed_base_class_names\n-        list_of_class_names = list_of_changed_base_class_names(context) or {}\n-        return SimpleVocabulary(\n-            [SimpleVocabulary.createTerm(\n-                class_name, class_name,\n-                \'{0} ({1})\'.format(\n-                    class_name, list_of_class_names[class_name]))\n-             for class_name in list_of_class_names.keys()]\n-        )\ndiff --git a/plone/app/contenttypes/tests/test_content_profile.py b/plone/app/contenttypes/tests/test_content_profile.py\nindex b2f1c471..030d9f10 100644\n--- a/plone/app/contenttypes/tests/test_content_profile.py\n+++ b/plone/app/contenttypes/tests/test_content_profile.py\n@@ -66,15 +66,6 @@ def test_Members_was_created(self):\n         obj = self.portal[\'Members\']\n         self.assertEqual(obj.portal_type, \'Folder\')\n \n-    @unittest.skip(\'Replaced by new members-search-form\')\n-    def test_Members__index_html(self):\n-        # Was the index_html script created?\n-        obj = self.portal[\'Members\'][\'index_html\']\n-        self.assertTrue(isinstance(obj, PythonScript))\n-        # It\'s outside the scope of this test to verify the contents of\n-        # the script are correct. Simply checking for existence should\n-        # be enough.\n-\n     def test_Members_portlets(self):\n         # Have the right column portlet manager setting been added?\n         members = self.portal[\'Members\']\ndiff --git a/plone/app/contenttypes/tests/test_migration.py b/plone/app/contenttypes/tests/test_migration.py\ndeleted file mode 100644\nindex c4eeebb8..00000000\n--- a/plone/app/contenttypes/tests/test_migration.py\n+++ /dev/null\n@@ -1,2191 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-from plone.app.contenttypes.testing import TEST_MIGRATION\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING  # noqa\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_FUNCTIONAL_TESTING  # noqa\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_TESTING  # noqa\n-import unittest\n-\n-if TEST_MIGRATION:\n-    from lxml import etree\n-    from persistent.list import PersistentList\n-    from plone.app.contenttypes.migration.migration import migrate_documents\n-    from plone.app.contenttypes.migration.migration import migrate_folders\n-    from plone.app.contenttypes.migration.migration import migrate_newsitems\n-    from plone.app.contenttypes.migration.utils import add_portlet\n-    from plone.app.contenttypes.migration.utils import installTypeIfNeeded\n-    from plone.app.contenttypes.migration.utils import is_referenceable\n-    from plone.app.contenttypes.migration.utils import restore_references\n-    from plone.app.contenttypes.migration.utils import store_references\n-    from plone.app.contenttypes.testing import set_browserlayer\n-    from plone.app.testing import applyProfile\n-    from plone.app.testing import login\n-    from plone.app.testing import SITE_OWNER_NAME\n-    from plone.app.testing import SITE_OWNER_PASSWORD\n-    from plone.app.uuid.utils import uuidToObject\n-    from plone.app.z3cform.interfaces import IPloneFormLayer\n-    from plone.dexterity.content import Container\n-    from plone.dexterity.interfaces import IDexterityContent\n-    from plone.dexterity.interfaces import IDexterityFTI\n-    from plone.event.interfaces import IEventAccessor\n-    from plone.namedfile.file import NamedBlobImage\n-    from plone.testing.zope import Browser\n-    from Products.CMFCore.utils import getToolByName\n-    from Products.CMFPlone.utils import get_installer\n-    from z3c.relationfield import RelationValue\n-    from z3c.relationfield.index import dump\n-    from zc.relation.interfaces import ICatalog\n-    from zope.annotation.interfaces import IAnnotations\n-    from zope.component import getMultiAdapter\n-    from zope.component import getUtility\n-    from zope.component import queryUtility\n-    from zope.interface import alsoProvides\n-    from zope.intid.interfaces import IIntIds\n-    from zope.lifecycleevent import modified\n-    from zope.schema.interfaces import IVocabularyFactory\n-\n-    import json\n-    import os.path\n-    import time\n-    import transaction\n-\n-\n-class MigrateFromATContentTypesTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n-        self.request[\'URL\'] = self.portal.absolute_url()\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n-        self.portal.acl_users.userFolderAddUser(\n-            SITE_OWNER_NAME, SITE_OWNER_PASSWORD, [\'Manager\'], [])\n-\n-        login(self.portal, SITE_OWNER_NAME)\n-        self.portal.portal_workflow.setDefaultChain(\n-            \'simple_publication_workflow\')\n-\n-    def tearDown(self):\n-        try:\n-            applyProfile(self.portal, \'plone.app.contenttypes:uninstall\')\n-        except KeyError:\n-            pass\n-\n-    def get_test_image_data(self):\n-        test_image_path = os.path.join(os.path.dirname(__file__), \'image.png\')\n-        with open(test_image_path, \'rb\') as test_image_file:\n-            test_image_data = test_image_file.read()\n-        return test_image_data\n-\n-    def get_migrator(self, obj, migrator_class):\n-        src_portal_type = migrator_class.src_portal_type\n-        dst_portal_type = migrator_class.dst_portal_type\n-        migrator = migrator_class(obj, src_portal_type=src_portal_type,\n-                                  dst_portal_type=dst_portal_type)\n-        return migrator\n-\n-    def createATCTobject(self, klass, id, parent=None):\n-        \'\'\'Borrowed from ATCTFieldTestCase\'\'\'\n-        import transaction\n-        parent = parent if parent else self.portal\n-        obj = klass(oid=id)\n-        parent[id] = obj\n-        transaction.savepoint()\n-        # need to aq wrap after the savepoint. wrapped content can\'t be pickled\n-        obj = obj.__of__(parent)\n-        obj.initializeArchetype()\n-        return obj\n-\n-    def createATCTBlobNewsItem(self, id, parent=None):\n-        from Products.Archetypes.atapi import StringField, TextField\n-        from Products.ATContentTypes.interfaces import IATNewsItem\n-        from archetypes.schemaextender.interfaces import ISchemaExtender\n-        from archetypes.schemaextender.field import ExtensionField\n-        from plone.app.blob.subtypes.image import ExtensionBlobField\n-        from zope.component import getGlobalSiteManager\n-        from zope.interface import implementer\n-\n-        # create schema extension\n-        class ExtensionTextField(ExtensionField, TextField):\n-            """ derivative of text for extending schemas """\n-\n-        class ExtensionStringField(ExtensionField, StringField):\n-            """ derivative of text for extending schemas """\n-\n-        @implementer(ISchemaExtender)\n-        class SchemaExtender(object):\n-            fields = [\n-                ExtensionTextField(\'text\',\n-                                   primary=True,\n-                                   ),\n-                ExtensionBlobField(\'image\',\n-                                   accessor=\'getImage\',\n-                                   mutator=\'setImage\',\n-                                   ),\n-                ExtensionStringField(\'imageCaption\',\n-                                     ),\n-            ]\n-\n-            def __init__(self, context):\n-                self.context = context\n-\n-            def getFields(self):\n-                return self.fields\n-\n-        # register adapter\n-        gsm = getGlobalSiteManager()\n-        gsm.registerAdapter(SchemaExtender, (IATNewsItem,), ISchemaExtender)\n-\n-        # create content\n-        container = parent or self.portal\n-        container.invokeFactory(\'News Item\', id)\n-        at_newsitem = container[\'newsitem\']\n-\n-        # unregister adapter assure test isolation\n-        gsm.unregisterAdapter(required=[IATNewsItem], provided=ISchemaExtender)\n-\n-        return at_newsitem\n-\n-    def test_patct_event_is_migrated(self):\n-        """Can we migrate a Products.ATContentTypes event?"""\n-        from DateTime import DateTime\n-        from plone.app.contenttypes.migration.migration import migrate_events\n-\n-        # create an ATEvent\n-        self.portal.invokeFactory(\'Event\', \'event\')\n-        at_event = self.portal[\'event\']\n-\n-        # Date\n-        at_event.getField(\'startDate\') \\\n-                .set(at_event, DateTime(\'2013-02-03 12:00\'))\n-        at_event.getField(\'endDate\') \\\n-                .set(at_event, DateTime(\'2013-04-05 13:00\'))\n-\n-        # Contact\n-        at_event.getField(\'contactPhone\').set(at_event, \'123456789\')\n-        at_event.getField(\'contactEmail\').set(at_event, \'dummy@email.com\')\n-        at_event.getField(\'contactName\').set(at_event, \'Name\')\n-\n-        # URL\n-        at_event.getField(\'eventUrl\').set(at_event, \'http://www.plone.org\')\n-\n-        # Attendees\n-        at_event.getField(\'attendees\').set(at_event, (\'You\', \'Me\'))\n-\n-        # Text\n-        at_event.setText(\'T\xc3\xbctensuppe\')\n-        at_event.setContentType(\'text/plain\')\n-\n-        oldTZ = os.environ.get(\'TZ\', None)\n-        os.environ[\'TZ\'] = \'Asia/Tbilisi\'\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate_events(self.portal)\n-\n-        if oldTZ:\n-            os.environ[\'TZ\'] = oldTZ\n-        else:\n-            del os.environ[\'TZ\']\n-\n-        # assertions\n-        dx_event = self.portal[\'event\']\n-        self.assertEqual(\n-            "<class \'Products.ATContentTypes.content.event.ATEvent\'>",\n-            str(at_event.__class__),\n-        )\n-        self.assertEqual(\n-            "<class \'plone.app.contenttypes.content.Event\'>",\n-            str(dx_event.__class__),\n-        )\n-        self.assertEqual(2013, dx_event.start.year)\n-        self.assertEqual(2, dx_event.start.month)\n-        self.assertEqual(3, dx_event.start.day)\n-        self.assertEqual(12, dx_event.start.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(dx_event.start.tzinfo))\n-        self.assertEqual(2013, dx_event.end.year)\n-        self.assertEqual(4, dx_event.end.month)\n-        self.assertEqual(5, dx_event.end.day)\n-        self.assertEqual(13, dx_event.end.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(dx_event.end.tzinfo))\n-        self.assertEqual(\'123456789\', dx_event.contact_phone)\n-        self.assertEqual(\'dummy@email.com\', dx_event.contact_email)\n-        self.assertEqual(\'Name\', dx_event.contact_name)\n-        self.assertEqual(\'http://www.plone.org\', dx_event.event_url)\n-        self.assertEqual((\'You\', \'Me\'), dx_event.attendees)\n-        self.assertEqual(\'Event\', dx_event.__class__.__name__)\n-        self.assertEqual(u\'<p>T\\xfctensuppe</p>\', dx_event.text.output)\n-        self.assertEqual(u\'T\xc3\xbctensuppe\', dx_event.text.raw)\n-\n-    @unittest.skip(\'Skip this test, until old type is mocked\')\n-    def test_pae_atevent_is_migrated(self):\n-        """Can we migrate a plone.app.event AT event?"""\n-        from DateTime import DateTime\n-        from plone.testing import zope\n-        from plone.app.testing import applyProfile\n-        from plone.app.contenttypes.migration.migration import migrate_events\n-\n-        # Enable plone.app.event.at\n-        zope.installProduct(self.layer[\'app\'], \'plone.app.event.at\')\n-        applyProfile(self.portal, \'plone.app.event.at:default\')\n-\n-        self.portal.invokeFactory(\'Event\', \'pae-at-event\')\n-        old_event = self.portal[\'pae-at-event\']\n-\n-        # Date\n-        old_event.getField(\'startDate\') \\\n-                 .set(old_event, DateTime(\'2013-01-01 12:00\'))\n-        old_event.getField(\'endDate\') \\\n-                 .set(old_event, DateTime(\'2013-02-01 13:00\'))\n-        old_event.getField(\'wholeDay\').set(old_event, False)\n-        old_event.getField(\'timezone\').set(old_event, \'Asia/Tbilisi\')\n-\n-        # Contact\n-        old_event.getField(\'contactPhone\').set(old_event, \'123456789\')\n-        old_event.getField(\'contactEmail\').set(old_event, \'dummy@email.com\')\n-        old_event.getField(\'contactName\').set(old_event, \'Name\')\n-\n-        # URL\n-        old_event.getField(\'eventUrl\').set(old_event, \'http://www.plone.org\')\n-\n-        # Attendees\n-        old_event.getField(\'attendees\').set(old_event, (\'You\', \'Me\'))\n-\n-        # Text\n-        old_event.setText(\'T\xc3\xbctensuppe\')\n-        old_event.setContentType(\'text/plain\')\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate_events(self.portal)\n-\n-        # Compare new and old events\n-        new_event = self.portal[\'pae-at-event\']\n-        self.assertEqual(\n-            "<class \'plone.app.event.at.content.ATEvent\'>",\n-            str(old_event.__class__),\n-        )\n-        self.assertEqual(\n-            "<class \'plone.app.contenttypes.content.Event\'>",\n-            str(new_event.__class__),\n-        )\n-        self.assertEqual(\'Event\', new_event.portal_type)\n-        self.assertEqual(2013, new_event.start.year)\n-        self.assertEqual(1, new_event.start.month)\n-        self.assertEqual(1, new_event.start.day)\n-        self.assertEqual(12, new_event.start.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(new_event.start.tzinfo))\n-        self.assertEqual(2013, new_event.end.year)\n-        self.assertEqual(2, new_event.end.month)\n-        self.assertEqual(1, new_event.end.day)\n-        self.assertEqual(13, new_event.end.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(new_event.end.tzinfo))\n-        self.assertEqual(u\'Name\', new_event.contact_name)\n-        self.assertEqual(u\'dummy@email.com\', new_event.contact_email)\n-        self.assertEqual(u\'123456789\', new_event.contact_phone)\n-        self.assertEqual(u\'http://www.plone.org\', new_event.event_url)\n-        self.assertEqual(u\'<p>T\\xfctensuppe</p>\', new_event.text.output)\n-        self.assertEqual(u\'T\xc3\xbctensuppe\', new_event.text.raw)\n-\n-    @unittest.skip(\'Skip this test, until old type is mocked\')\n-    def test_pae_dxevent_is_migrated(self):\n-        from datetime import datetime\n-        from plone.app.contenttypes.migration.migration import migrate_events\n-        from plone.app.textfield.value import RichTextValue\n-\n-        # Enable plone.app.event.dx\n-        from plone.app.testing import applyProfile\n-        applyProfile(self.portal, \'plone.app.event:testing\')\n-\n-        old_event = self.portal[self.portal.invokeFactory(\n-            \'plone.app.event.dx.event\',\n-            \'dx-event\',\n-            start=datetime(2011, 11, 11, 11, 0),\n-            end=datetime(2011, 11, 11, 12, 0),\n-            timezone=\'Asia/Tbilisi\',\n-            whole_day=False,\n-        )]\n-        old_event_acc = IEventAccessor(old_event)\n-        old_event_acc.contact_name = \'George\'\n-        old_event_acc.contact_email = \'me@geor.ge\'\n-        old_event_acc.contact_phone = \'+99512345\'\n-        old_event_acc.event_url = \'http://geor.ge/event\'\n-        # We need to manually place the value of the \'text\' field into\n-        # annotation storage\n-        richtext = RichTextValue(\n-            raw=\'Woo, yeah\',\n-            mimeType=\'text/plain\',\n-            outputMimeType=\'text/x-html-safe\'\n-        )\n-        ann = IAnnotations(old_event)\n-        ann[\'plone.app.event.dx.behaviors.IEventSummary.text\'] = richtext\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate_events(self.portal)\n-\n-        # Compare new and old events\n-        new_event = self.portal[\'dx-event\']\n-        self.assertEqual(False, old_event.exclude_from_nav)\n-        self.assertEqual(\'Event\', new_event.portal_type)\n-        self.assertEqual(2011, new_event.start.year)\n-        self.assertEqual(11, new_event.start.month)\n-        self.assertEqual(11, new_event.start.day)\n-        self.assertEqual(11, new_event.start.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(new_event.start.tzinfo))\n-        self.assertEqual(2011, new_event.end.year)\n-        self.assertEqual(11, new_event.end.month)\n-        self.assertEqual(11, new_event.end.day)\n-        self.assertEqual(12, new_event.end.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(new_event.end.tzinfo))\n-        self.assertEqual(u\'George\', new_event.contact_name)\n-        self.assertEqual(u\'me@geor.ge\', new_event.contact_email)\n-        self.assertEqual(u\'+99512345\', new_event.contact_phone)\n-        self.assertEqual(u\'http://geor.ge/event\', new_event.event_url)\n-        self.assertEqual(u\'<p>Woo, yeah</p>\', new_event.text.output)\n-        self.assertEqual(\'Woo, yeah\', new_event.text.raw)\n-        self.assertEqual(False, new_event.exclude_from_nav)\n-\n-    def test_pact_1_0_dxevent_is_migrated(self):\n-        from datetime import datetime\n-        import pytz\n-        from plone.app.contenttypes.migration.migration import migrate_events\n-        from plone.app.textfield.value import RichTextValue\n-        from plone.app.contenttypes.tests.oldtypes import create1_0EventType\n-\n-        # Create a 1.0 Event object\n-        timezone = pytz.timezone(\'Asia/Tbilisi\')\n-        create1_0EventType(self.portal)\n-        old_event = self.portal[self.portal.invokeFactory(\n-            \'Event\',\n-            \'dx-event\',\n-            location=\'Newbraska\',\n-            start_date=timezone.localize(datetime(2019, 4, 2, 15, 20)),\n-            end_date=timezone.localize(datetime(2019, 4, 2, 16, 20)),\n-            attendees=\'Me & You\',\n-            event_url=\'http://woo.com\',\n-            contact_name=\'Frank\',\n-            contact_email=\'me@fra.nk\',\n-            contact_phone=\'+4412345\',\n-        )]\n-        old_event.text = RichTextValue(\n-            raw=u\'Awes\xc3\xbcme\',\n-            mimeType=\'text/plain\',\n-            outputMimeType=\'text/x-html-safe\'\n-        )\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate_events(self.portal)\n-\n-        # Compare new and old events\n-        new_event = self.portal[\'dx-event\']\n-        self.assertEqual(False, old_event.exclude_from_nav)\n-        self.assertEqual(\'Event\', new_event.portal_type)\n-        self.assertEqual(2019, new_event.start.year)\n-        self.assertEqual(4, new_event.start.month)\n-        self.assertEqual(2, new_event.start.day)\n-        self.assertEqual(15, new_event.start.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(new_event.start.tzinfo))\n-        self.assertEqual(2019, new_event.end.year)\n-        self.assertEqual(4, new_event.end.month)\n-        self.assertEqual(2, new_event.end.day)\n-        self.assertEqual(16, new_event.end.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(new_event.end.tzinfo))\n-        self.assertEqual(u\'Frank\', new_event.contact_name)\n-        self.assertEqual(u\'Newbraska\', new_event.location)\n-        self.assertEqual(u\'me@fra.nk\', new_event.contact_email)\n-        self.assertEqual(u\'+4412345\', new_event.contact_phone)\n-        self.assertEqual(u\'http://woo.com\', new_event.event_url)\n-        self.assertEqual(u\'<p>Awes\xc3\xbcme</p>\', new_event.text.output)\n-        self.assertEqual(u\'Awes\xc3\xbcme\', new_event.text.raw)\n-        self.assertEqual(False, new_event.exclude_from_nav)\n-\n-    def test_dx_excl_from_nav_is_migrated(self):\n-        from datetime import datetime\n-        from plone.app.contenttypes.migration.migration import DXEventMigrator\n-\n-        # Enable plone.app.event.dx\n-        from plone.app.testing import applyProfile\n-        applyProfile(self.portal, \'plone.app.event:testing\')\n-\n-        old_event = self.portal[self.portal.invokeFactory(\n-            \'plone.app.event.dx.event\',\n-            \'dx-event\',\n-            start=datetime(2011, 11, 11, 11, 0),\n-            end=datetime(2011, 11, 11, 12, 0),\n-            timezone=\'GMT\',\n-            whole_day=False,\n-            exclude_from_nav=True,\n-        )]\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(old_event, DXEventMigrator)\n-        migrator.migrate()\n-\n-        new_event = self.portal[\'dx-event\']\n-        self.assertEqual(True, old_event.exclude_from_nav)\n-        self.assertEqual(True, new_event.exclude_from_nav)\n-\n-    def test_assert_at_contenttypes(self):\n-        from plone.app.contenttypes.interfaces import IDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        self.assertEqual(\'ATDocument\', at_document.meta_type)\n-        self.assertFalse(IDocument.providedBy(at_document))\n-\n-    def test_dx_content_is_indexed(self):\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        from plone.app.contenttypes.interfaces import IDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-        brains = self.catalog(object_provides=IDocument.__identifier__)\n-        self.assertEqual(len(brains), 1)\n-        self.assertEqual(brains[0].getObject(), self.portal[\'document\'])\n-\n-    def test_old_content_is_removed(self):\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-        brains = self.catalog(portal_type=\'Document\')\n-        self.assertEqual(len(brains), 1)\n-\n-    def test_old_content_is_unindexed(self):\n-        from Products.ATContentTypes.interfaces import IATDocument\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        brains = self.catalog(object_provides=IATDocument.__identifier__)\n-        self.assertEqual(len(brains), 1)\n-        migrator.migrate()\n-        brains = self.catalog(object_provides=IATDocument.__identifier__)\n-        self.assertEqual(len(brains), 0)\n-\n-    def test_document_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        from plone.app.contenttypes.interfaces import IDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-        dx_document = self.portal[\'document\']\n-        self.assertTrue(IDocument.providedBy(dx_document))\n-        self.assertTrue(at_document is not dx_document)\n-\n-    def test_collection_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import \\\n-            migrate_collections\n-        from plone.app.contenttypes.behaviors.collection import \\\n-            ICollection as ICollectionBehavior\n-        from plone.app.contenttypes.interfaces import ICollection\n-        self.portal.invokeFactory(\'Collection\', \'collection\')\n-        at_collection = self.portal[\'collection\']\n-        at_collection.setText(\'<p>Whopee</p>\')\n-        query = [{\n-            \'i\': \'Type\',\n-            \'o\': \'plone.app.querystring.operation.string.is\',\n-            \'v\': \'Document\',\n-        }]\n-        at_collection.setQuery(query)\n-        at_collection.setLayout(\'folder_summary_view\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate_collections(self.portal)\n-        dx_collection = self.portal[\'collection\']\n-        self.assertTrue(ICollection.providedBy(dx_collection))\n-        self.assertTrue(at_collection is not dx_collection)\n-        wrapped = ICollectionBehavior(dx_collection)\n-        self.assertEqual(wrapped.query, query)\n-        self.assertEqual(dx_collection.text.output, \'<p>Whopee</p>\')\n-        at_collection.setLayout(\'summary_view\')\n-\n-    def test_document_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        from plone.app.textfield.interfaces import IRichTextValue\n-\n-        # create an ATDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        at_document.setText(\'T\xc3\xbctensuppe\')\n-        at_document.setContentType(\'chemical/x-gaussian-checkpoint\')\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-\n-        # assertions\n-        dx_document = self.portal[\'document\']\n-        self.assertTrue(IRichTextValue(dx_document.text))\n-        self.assertEqual(dx_document.text.raw, u\'T\xc3\xbctensuppe\')\n-        self.assertEqual(dx_document.text.mimeType,\n-                         \'chemical/x-gaussian-checkpoint\')\n-        self.assertEqual(dx_document.text.outputMimeType, \'text/x-html-safe\')\n-\n-    def test_document_excludefromnav_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-\n-        # create an ATDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        at_document.setExcludeFromNav(True)\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-\n-        # assertions\n-        dx_document = self.portal[\'document\']\n-        self.assertTrue(dx_document.exclude_from_nav)\n-\n-    def test_file_is_migrated(self):\n-        from Products.ATContentTypes.content.file import ATFile\n-        from plone.app.contenttypes.migration.migration import FileMigrator\n-        from plone.app.contenttypes.interfaces import IFile\n-        at_file = self.createATCTobject(ATFile, \'file\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_file, FileMigrator)\n-        migrator.migrate()\n-        dx_file = self.portal[\'file\']\n-        self.assertTrue(IFile.providedBy(dx_file))\n-        self.assertTrue(at_file is not dx_file)\n-\n-    def test_file_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import FileMigrator\n-        from plone.namedfile.interfaces import INamedBlobFile\n-        from Products.ATContentTypes.content.file import ATFile\n-        at_file = self.createATCTobject(ATFile, \'file\')\n-        field = at_file.getField(\'file\')\n-        field.set(at_file, \'dummydata\')\n-        field.setFilename(at_file, \'dummyfile.txt\')\n-        field.setContentType(at_file, \'text/dummy\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_file, FileMigrator)\n-        migrator.migrate()\n-        dx_file = self.portal[\'file\']\n-        self.assertTrue(INamedBlobFile.providedBy(dx_file.file))\n-        self.assertEqual(dx_file.file.filename, \'dummyfile.txt\')\n-        self.assertEqual(dx_file.file.contentType, \'text/dummy\')\n-        self.assertEqual(dx_file.file.data, \'dummydata\')\n-\n-    def test_image_is_migrated(self):\n-        from Products.ATContentTypes.content.image import ATImage\n-        from plone.app.contenttypes.migration.migration import ImageMigrator\n-        from plone.app.contenttypes.interfaces import IImage\n-        at_image = self.createATCTobject(ATImage, \'image\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_image, ImageMigrator)\n-        migrator.migrate()\n-        dx_image = self.portal[\'image\']\n-        self.assertTrue(IImage.providedBy(dx_image))\n-        self.assertTrue(at_image is not dx_image)\n-\n-    def test_empty_image_is_migrated(self):\n-        """\n-        This should not happened cause the image field is required,\n-        but this is a special case in AT\'s FileField.\n-        """\n-        from Products.ATContentTypes.content.image import ATImage\n-        from plone.app.contenttypes.migration.migration import ImageMigrator\n-        at_image = self.createATCTobject(ATImage, \'image\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_image, ImageMigrator)\n-        migrator.migrate()\n-        dx_image = self.portal[\'image\']\n-        self.assertEqual(dx_image.image, None)\n-\n-    def test_image_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import ImageMigrator\n-        from plone.namedfile.interfaces import INamedBlobImage\n-        from Products.ATContentTypes.content.image import ATImage\n-        at_image = self.createATCTobject(ATImage, \'image\')\n-        test_image_data = self.get_test_image_data()\n-        field = at_image.getField(\'image\')\n-        field.set(at_image, test_image_data)\n-        field.setFilename(at_image, \'testimage.png\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_image, ImageMigrator)\n-        migrator.migrate()\n-        dx_image = self.portal[\'image\']\n-        self.assertTrue(INamedBlobImage.providedBy(dx_image.image))\n-        self.assertEqual(dx_image.image.filename, \'testimage.png\')\n-        self.assertEqual(dx_image.image.contentType, \'image/png\')\n-        self.assertEqual(dx_image.image.data, test_image_data)\n-\n-    def test_blob_file_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import BlobFileMigrator\n-        from plone.app.contenttypes.interfaces import IFile\n-        self.portal.invokeFactory(\'File\', \'file\')\n-        at_file = self.portal[\'file\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_file, BlobFileMigrator)\n-        migrator.migrate()\n-        dx_file = self.portal[\'file\']\n-        self.assertTrue(IFile.providedBy(dx_file))\n-        self.assertTrue(at_file is not dx_file)\n-\n-    def test_blob_file_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import BlobFileMigrator\n-        from plone.namedfile.interfaces import INamedBlobFile\n-        self.portal.invokeFactory(\'File\', \'file\')\n-        at_file = self.portal[\'file\']\n-        at_file.setFile(\'dummydata\',\n-                        mimetype=\'text/dummy\',\n-                        filename=\'dummyfile.txt\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_file, BlobFileMigrator)\n-        migrator.migrate()\n-        dx_file = self.portal[\'file\']\n-        self.assertTrue(INamedBlobFile.providedBy(dx_file.file))\n-        self.assertEqual(dx_file.file.filename, \'dummyfile.txt\')\n-        self.assertEqual(dx_file.file.contentType, \'text/dummy\')\n-        self.assertEqual(dx_file.file.data, \'dummydata\')\n-\n-    def test_blob_image_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import\\\n-            BlobImageMigrator\n-        from plone.app.contenttypes.interfaces import IImage\n-        self.portal.invokeFactory(\'Image\', \'image\')\n-        at_image = self.portal[\'image\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_image, BlobImageMigrator)\n-        migrator.migrate()\n-        dx_image = self.portal[\'image\']\n-        self.assertTrue(IImage.providedBy(dx_image))\n-        self.assertTrue(at_image is not dx_image)\n-\n-    def test_empty_blob_image_is_migrated(self):\n-        """\n-        This should not happened cause the image field is required,\n-        but this is a special case in AT\'s FileField.\n-        """\n-        from plone.app.contenttypes.migration.migration import\\\n-            BlobImageMigrator\n-        self.portal.invokeFactory(\'Image\', \'image\')\n-        at_image = self.portal[\'image\']\n-        migrator = self.get_migrator(at_image, BlobImageMigrator)\n-        migrator.migrate()\n-        dx_image = self.portal[\'image\']\n-        self.assertEqual(dx_image.image.data, \'\')\n-\n-    def test_blob_image_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import\\\n-            BlobImageMigrator\n-        from plone.namedfile.interfaces import INamedBlobImage\n-        self.portal.invokeFactory(\'Image\', \'image\')\n-        at_image = self.portal[\'image\']\n-        test_image_data = self.get_test_image_data()\n-        at_image.setImage(test_image_data, filename=\'testimage.png\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_image, BlobImageMigrator)\n-        migrator.migrate()\n-        dx_image = self.portal[\'image\']\n-        self.assertTrue(INamedBlobImage.providedBy(dx_image.image))\n-        self.assertEqual(dx_image.image.filename, \'testimage.png\')\n-        self.assertEqual(dx_image.image.contentType, \'image/png\')\n-        self.assertEqual(dx_image.image.data, test_image_data)\n-\n-    def test_link_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import LinkMigrator\n-        from plone.app.contenttypes.interfaces import ILink\n-        self.portal.invokeFactory(\'Link\', \'link\')\n-        at_link = self.portal[\'link\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_link, LinkMigrator)\n-        migrator.migrate()\n-        dx_link = self.portal[\'link\']\n-        self.assertTrue(ILink.providedBy(dx_link))\n-        self.assertTrue(dx_link is not at_link)\n-\n-    def test_link_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import LinkMigrator\n-        from plone.app.contenttypes.interfaces import ILink\n-        self.portal.invokeFactory(\'Link\', \'link\')\n-        at_link = self.portal[\'link\']\n-        field = at_link.getField(\'remoteUrl\')\n-        field.set(at_link, \'http://plone.org\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_link, LinkMigrator)\n-        migrator.migrate()\n-        dx_link = self.portal[\'link\']\n-        self.assertTrue(ILink.providedBy(dx_link.link))\n-        self.assertEqual(dx_link.link.remoteUrl, u\'http://plone.org\')\n-\n-    def test_newsitem_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import NewsItemMigrator\n-        from plone.app.contenttypes.interfaces import INewsItem\n-        self.portal.invokeFactory(\'News Item\', \'newsitem\')\n-        at_newsitem = self.portal[\'newsitem\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_newsitem, NewsItemMigrator)\n-        migrator.migrate()\n-        dx_newsitem = self.portal[\'newsitem\']\n-        self.assertTrue(INewsItem.providedBy(dx_newsitem))\n-        self.assertTrue(at_newsitem is not dx_newsitem)\n-\n-    def test_newsitem_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import NewsItemMigrator\n-        from plone.app.textfield.interfaces import IRichTextValue\n-        from plone.namedfile.interfaces import INamedBlobImage\n-\n-        # create an ATNewsItem\n-        self.portal.invokeFactory(\'News Item\', \'newsitem\')\n-        at_newsitem = self.portal[\'newsitem\']\n-        at_newsitem.setText(\'T\xc3\xbctensuppe\')\n-        at_newsitem.setContentType(\'chemical/x-gaussian-checkpoint\')\n-        at_newsitem.setImageCaption(\'Daniel D\xc3\xbcsentrieb\')\n-        test_image_data = self.get_test_image_data()\n-        image_field = at_newsitem.getField(\'image\')\n-        image_field.set(at_newsitem, test_image_data)\n-        image_field.setFilename(at_newsitem, \'testimage.png\')\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_newsitem, NewsItemMigrator)\n-        migrator.migrate()\n-\n-        # assertions\n-        dx_newsitem = self.portal[\'newsitem\']\n-        self.assertTrue(INamedBlobImage.providedBy(dx_newsitem.image))\n-        self.assertEqual(dx_newsitem.image.filename, \'testimage.png\')\n-        self.assertEqual(dx_newsitem.image.contentType, \'image/png\')\n-        self.assertEqual(dx_newsitem.image.data, test_image_data)\n-\n-        self.assertEqual(dx_newsitem.image_caption, u\'Daniel D\xc3\xbcsentrieb\')\n-\n-        self.assertTrue(IRichTextValue(dx_newsitem.text))\n-        self.assertEqual(dx_newsitem.text.raw, u\'T\xc3\xbctensuppe\')\n-        self.assertEqual(dx_newsitem.text.mimeType,\n-                         \'chemical/x-gaussian-checkpoint\')\n-        self.assertEqual(dx_newsitem.text.outputMimeType, \'text/x-html-safe\')\n-\n-    def test_blob_newsitem_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import\\\n-            BlobNewsItemMigrator\n-        from plone.app.contenttypes.interfaces import INewsItem\n-        at_newsitem = self.createATCTBlobNewsItem(\'newsitem\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_newsitem, BlobNewsItemMigrator)\n-        migrator.migrate()\n-        dx_newsitem = self.portal[\'newsitem\']\n-        self.assertTrue(INewsItem.providedBy(dx_newsitem))\n-        self.assertTrue(at_newsitem is not dx_newsitem)\n-\n-    def test_blob_newsitem_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import \\\n-            BlobNewsItemMigrator\n-        from plone.app.textfield.interfaces import IRichTextValue\n-        from plone.namedfile.interfaces import INamedBlobImage\n-\n-        # create a BlobATNewsItem\n-        at_newsitem = self.createATCTBlobNewsItem(\'newsitem\')\n-        at_newsitem.setText(\'T\xc3\xbctensuppe\')\n-        at_newsitem.setContentType(\'chemical/x-gaussian-checkpoint\')\n-        test_image_data = self.get_test_image_data()\n-        namedblobimage = NamedBlobImage(\n-            data=test_image_data, filename=u\'testimage.png\')\n-        at_newsitem.image = namedblobimage\n-        at_newsitem.image_caption = u\'Daniel D\xc3\xbcsentrieb\'\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_newsitem, BlobNewsItemMigrator)\n-        migrator.migrate()\n-        dx_newsitem = self.portal[\'newsitem\']\n-\n-        # assertions\n-        self.assertTrue(INamedBlobImage.providedBy(dx_newsitem.image))\n-        self.assertEqual(dx_newsitem.image.filename, \'testimage.png\')\n-        self.assertEqual(dx_newsitem.image.contentType, \'image/png\')\n-        self.assertEqual(dx_newsitem.image.data, test_image_data)\n-\n-        # self.assertEqual(dx_newsitem.image_caption, u\'Daniel D\xc3\xbcsentrieb\')\n-\n-        self.assertTrue(IRichTextValue(dx_newsitem.text))\n-        self.assertEqual(dx_newsitem.text.raw, u\'T\xc3\xbctensuppe\')\n-        self.assertEqual(\n-            dx_newsitem.text.mimeType, \'chemical/x-gaussian-checkpoint\')\n-\n-    def test_modifield_date_is_unchanged(self):\n-        set_browserlayer(self.request)\n-\n-        # create folders\n-        self.portal.invokeFactory(\'Folder\', \'folder1\')\n-        at_folder1 = self.portal[\'folder1\']\n-        self.portal.invokeFactory(\'Folder\', \'folder2\')\n-        at_folder2 = self.portal[\'folder2\']\n-        self.portal.invokeFactory(\'Folder\', \'folder3\')\n-        at_folder3 = self.portal[\'folder3\']\n-        at_folder2.invokeFactory(\'Folder\', \'folder4\')\n-        at_folder4 = at_folder2[\'folder4\']\n-\n-        # create ATDocuments\n-        at_folder1.invokeFactory(\'Document\', \'doc1\')\n-        at_doc1 = at_folder1[\'doc1\']\n-        at_folder2.invokeFactory(\'Document\', \'doc2\')\n-        at_doc2 = at_folder2[\'doc2\']\n-        self.portal.invokeFactory(\'Document\', \'doc3\')\n-        at_doc3 = self.portal[\'doc3\']\n-        at_folder2.invokeFactory(\'News Item\', \'newsitem1\')\n-        at_newsitem1 = at_folder2[\'newsitem1\']\n-        at_folder4.invokeFactory(\'News Item\', \'newsitem2\')\n-        at_newsitem2 = at_folder4[\'newsitem2\']\n-\n-        # be 100% sure the migration-date is after the creation-date\n-        time.sleep(0.1)\n-\n-        # relate them - triggers modification date\n-        at_doc1.setRelatedItems([at_doc2])\n-        at_doc2.setRelatedItems([at_newsitem1, at_doc3, at_doc1])\n-        at_doc3.setRelatedItems(at_doc1)\n-        at_folder1.setRelatedItems([at_doc2])\n-        at_folder2.setRelatedItems([at_doc1])\n-\n-        at_folder1_date = at_folder1.ModificationDate()\n-        at_folder2_date = at_folder2.ModificationDate()\n-        at_folder3_date = at_folder3.ModificationDate()\n-        at_folder4_date = at_folder4.ModificationDate()\n-        at_doc1_date = at_doc1.ModificationDate()\n-        at_doc2_date = at_doc2.ModificationDate()\n-        at_doc3_date = at_doc3.ModificationDate()\n-        at_newsitem1_date = at_newsitem1.ModificationDate()\n-        at_newsitem2_date = at_newsitem2.ModificationDate()\n-\n-        # migrate content\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self._enable_referenceable_for(\'Document\')\n-        self._enable_referenceable_for(\'News Item\')\n-        self._enable_referenceable_for(\'Folder\')\n-\n-        # we use the migration-view instead of calling the migratons by hand\n-        # to make sure the patch for notifyModified is used.\n-        migration_view = getMultiAdapter(\n-            (self.portal, self.request),\n-            name=u\'migrate_from_atct\'\n-        )\n-\n-        # We call migration twice to make sure documents are migrated first.\n-        # This would result in changed modification-dates on the folders\n-        # unless this is patched in the migration-view.\n-        migration_view(\n-            migrate=True,\n-            content_types=[\'Document\'],\n-            migrate_schemaextended_content=True,\n-            migrate_references=True,\n-            from_form=False,\n-        )\n-        migration_view(\n-            migrate=True,\n-            content_types=[\'Folder\'],\n-            migrate_schemaextended_content=True,\n-            migrate_references=True,\n-            from_form=False,\n-        )\n-\n-        dx_folder1 = self.portal[\'folder1\']\n-        dx_folder2 = self.portal[\'folder2\']\n-        dx_folder3 = self.portal[\'folder3\']\n-        dx_folder4 = dx_folder2[\'folder4\']\n-\n-        dx_doc1 = dx_folder1[\'doc1\']\n-        dx_doc2 = dx_folder2[\'doc2\']\n-        dx_doc3 = self.portal[\'doc3\']\n-\n-        self.assertTrue(at_folder1 is not dx_folder1)\n-        self.assertTrue(at_folder2 is not dx_folder2)\n-\n-        # assert ModificationDates\n-        self.assertEqual(at_folder1_date, dx_folder1.ModificationDate())\n-        self.assertEqual(at_folder2_date, dx_folder2.ModificationDate())\n-        self.assertEqual(at_folder3_date, dx_folder3.ModificationDate())\n-        self.assertEqual(at_folder4_date, dx_folder4.ModificationDate())\n-        self.assertEqual(at_doc1_date, dx_doc1.ModificationDate())\n-        self.assertEqual(at_doc2_date, dx_doc2.ModificationDate())\n-        self.assertEqual(at_doc3_date, dx_doc3.ModificationDate())\n-        self.assertEqual(at_newsitem1_date, at_newsitem1.ModificationDate())\n-        self.assertEqual(at_newsitem2_date, at_newsitem2.ModificationDate())\n-\n-    def test_references_are_set_correctly(self):\n-        set_browserlayer(self.request)\n-\n-        # create folders\n-        self.portal.invokeFactory(\'Folder\', \'folder1\')\n-        at_folder1 = self.portal[\'folder1\']\n-        self.portal.invokeFactory(\'Folder\', \'folder2\')\n-        at_folder2 = self.portal[\'folder2\']\n-        self.portal.invokeFactory(\'Folder\', \'folder3\')\n-\n-        # create ATDocuments\n-        at_folder1.invokeFactory(\'Document\', \'doc1\')\n-        at_doc1 = at_folder1[\'doc1\']\n-        at_folder2.invokeFactory(\'Document\', \'doc2\')\n-        at_doc2 = at_folder2[\'doc2\']\n-        self.portal.invokeFactory(\'Document\', \'doc3\')\n-        at_doc3 = self.portal[\'doc3\']\n-        at_folder2.invokeFactory(\'News Item\', \'newsitem1\')\n-        at_newsitem1 = at_folder2[\'newsitem1\']\n-\n-        # be 100% sure the migration-date is after the creation-date\n-        time.sleep(0.1)\n-\n-        # relate them\n-        at_doc1.setRelatedItems([at_doc2])\n-        at_doc2.setRelatedItems([at_newsitem1, at_doc3, at_doc1])\n-        at_doc3.setRelatedItems(at_doc1)\n-        at_folder1.setRelatedItems([at_doc2])\n-        at_folder2.setRelatedItems([at_doc1])\n-\n-        # migrate content\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self._enable_referenceable_for(\'Document\')\n-        self._enable_referenceable_for(\'News Item\')\n-        self._enable_referenceable_for(\'Folder\')\n-\n-        # we use the migration-view instead of calling the migratons by hand\n-        # to make sure the patch for notifyModified is used.\n-        migration_view = getMultiAdapter(\n-            (self.portal, self.request),\n-            name=u\'migrate_from_atct\'\n-        )\n-\n-        # We call migration twice to make sure documents are migrated first.\n-        # This would result in changed modification-dates on the folders\n-        # unless this is patched in the migration-view.\n-        migration_view(\n-            migrate=True,\n-            content_types=[\'Document\'],\n-            migrate_schemaextended_content=True,\n-            migrate_references=True,\n-            from_form=False,\n-        )\n-        migration_view(\n-            migrate=True,\n-            content_types=[\'Folder\'],\n-            migrate_schemaextended_content=True,\n-            migrate_references=True,\n-            from_form=False,\n-        )\n-\n-        dx_folder1 = self.portal[\'folder1\']\n-        dx_folder2 = self.portal[\'folder2\']\n-\n-        dx_doc1 = dx_folder1[\'doc1\']\n-        dx_doc2 = dx_folder2[\'doc2\']\n-        dx_doc3 = self.portal[\'doc3\']\n-\n-        self.assertTrue(at_folder1 is not dx_folder1)\n-        self.assertTrue(at_folder2 is not dx_folder2)\n-\n-        # assert single references\n-        dx_doc1_related = [x.to_object for x in dx_doc1.relatedItems]\n-        self.assertEqual(dx_doc1_related, [dx_doc2])\n-\n-        dx_doc3_related = [x.to_object for x in dx_doc3.relatedItems]\n-        self.assertEqual(dx_doc3_related, [dx_doc1])\n-\n-        dx_folder1_related = [x.to_object for x in dx_folder1.relatedItems]\n-        self.assertEqual(dx_folder1_related, [dx_doc2])\n-        dx_folder2_related = [x.to_object for x in dx_folder2.relatedItems]\n-        self.assertEqual(dx_folder2_related, [dx_doc1])\n-\n-        # assert multi references, order is restored\n-        dx_doc2_related = [x.to_object for x in dx_doc2.relatedItems]\n-        self.assertEqual(dx_doc2_related, [at_newsitem1, dx_doc3, dx_doc1])\n-\n-    def test_folder_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import FolderMigrator\n-        from plone.app.contenttypes.interfaces import IFolder\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        at_folder.setLayout(\'atct_album_view\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_folder, FolderMigrator)\n-        migrator.migrate()\n-        dx_folder = self.portal[\'folder\']\n-        self.assertTrue(IFolder.providedBy(dx_folder))\n-        self.assertTrue(at_folder is not dx_folder)\n-        self.assertEqual(dx_folder.getLayout(), \'album_view\')\n-\n-    def test_folder_children_are_migrated(self):\n-        from plone.app.contenttypes.migration.migration import FolderMigrator\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        at_folder.invokeFactory(\'Document\', \'document\')\n-        at_child = at_folder[\'document\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_folder, FolderMigrator)\n-        migrator.migrate()\n-        dx_folder = self.portal[\'folder\']\n-        self.assertTrue(at_child in dx_folder.contentValues())\n-\n-    def test_relations_are_migrated(self):\n-        # create folders\n-        self.portal.invokeFactory(\'Folder\', \'folder1\')\n-        at_folder1 = self.portal[\'folder1\']\n-        self.portal.invokeFactory(\'Folder\', \'folder2\')\n-        at_folder2 = self.portal[\'folder2\']\n-\n-        # create ATDocuments\n-        at_folder1.invokeFactory(\'Document\', \'doc1\')\n-        at_doc1 = at_folder1[\'doc1\']\n-        at_folder2.invokeFactory(\'Document\', \'doc2\')\n-        at_doc2 = at_folder2[\'doc2\']\n-        self.portal.invokeFactory(\'Document\', \'doc3\')\n-        at_doc3 = self.portal[\'doc3\']\n-        at_folder1.invokeFactory(\'News Item\', \'newsitem\')\n-        at_newsitem = at_folder1[\'newsitem\']\n-\n-        # relate them\n-        at_doc1.setRelatedItems([at_doc2])\n-        at_doc2.setRelatedItems([at_newsitem, at_doc3, at_doc1])\n-        at_doc3.setRelatedItems(at_doc1)\n-        at_folder1.setRelatedItems([at_doc2])\n-        at_folder2.setRelatedItems([at_doc1])\n-        self.assertEqual([x for x in at_folder2.getRelatedItems()], [at_doc1])\n-        # migrate content\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self._enable_referenceable_for(\'Folder\')\n-        self._enable_referenceable_for(\'Document\')\n-        self._enable_referenceable_for(\'News Item\')\n-        store_references(self.portal)\n-        migrate_documents(self.portal)\n-        migrate_folders(self.portal)\n-\n-        # rebuild catalog\n-        self.portal.portal_catalog.clearFindAndRebuild()\n-\n-        dx_folder1 = self.portal[\'folder1\']\n-        dx_folder2 = self.portal[\'folder2\']\n-\n-        dx_doc1 = dx_folder1[\'doc1\']\n-        dx_doc2 = dx_folder2[\'doc2\']\n-        dx_doc3 = self.portal[\'doc3\']\n-\n-        self.assertEqual([x.to_object for x in dx_folder2.relatedItems], [])\n-\n-        # migrate references\n-        restore_references(self.portal)\n-\n-        self.assertEqual(\n-            [x.to_object for x in dx_folder2.relatedItems], [dx_doc1])\n-\n-        # assert single references\n-        dx_doc1_related = [x.to_object for x in dx_doc1.relatedItems]\n-        self.assertEqual(dx_doc1_related, [dx_doc2])\n-\n-        dx_doc3_related = [x.to_object for x in dx_doc3.relatedItems]\n-        self.assertEqual(dx_doc3_related, [dx_doc1])\n-\n-        dx_folder1_related = [x.to_object for x in dx_folder1.relatedItems]\n-        self.assertEqual(dx_folder1_related, [dx_doc2])\n-        dx_folder2_related = [x.to_object for x in dx_folder2.relatedItems]\n-        self.assertEqual(dx_folder2_related, [dx_doc1])\n-\n-        # assert multi references, order is restored\n-        dx_doc2_related = [x.to_object for x in dx_doc2.relatedItems]\n-        self.assertEqual(dx_doc2_related, [at_newsitem, dx_doc3, dx_doc1])\n-\n-    def test_backrelations_are_migrated_for_unnested_content(self):\n-        """relate a doc to a newsitem, migrate the newsitem but not the doc.\n-        check if the relations are still in place."""\n-\n-        # create ATFolder and ATDocument\n-        self.portal.invokeFactory(\'News Item\', \'news\')\n-        at_news = self.portal[\'news\']\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n-        at_doc = self.portal[\'doc\']\n-\n-        # relate them\n-        at_news.setRelatedItems([at_doc])\n-\n-        self.assertEqual(at_news.getRelatedItems(), [at_doc])\n-        self.assertEqual(at_news.getReferences(), [at_doc])\n-        self.assertEqual(at_news.getBackReferences(), [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [at_news])\n-\n-        # migrate content (stores references on new objects for later restore)\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            # blacklisted_steps=[\'typeinfo\']\n-        )\n-        # installTypeIfNeeded(\'News Item\')\n-        store_references(self.portal)\n-        migrate_newsitems(self.portal)\n-        migrate_documents(self.portal)\n-\n-        # rebuild catalog\n-        self.portal.portal_catalog.clearFindAndRebuild()\n-\n-        dx_news = self.portal[\'news\']\n-        dx_doc = self.portal[\'doc\']\n-\n-        # references are not restored yet\n-        self.assertEqual(dx_news.relatedItems, [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [])\n-\n-        # restore references\n-        restore_references(self.portal)\n-\n-        # references should be restored\n-        self.assertEqual([i.to_object for i in dx_news.relatedItems], [dx_doc])\n-        self.assertEqual([i.to_object for i in dx_doc.relatedItems], [])\n-        self.assertEqual(self._backrefs(dx_doc), [dx_news])\n-        self.assertEqual(self._backrefs(dx_news), [])\n-\n-    def test_dx_at_relations_migrated_for_partially_migrated_nested(self):\n-        """This fails if referenceablebehavior is not enabled\n-        """\n-        # create ATFolder and ATDocument\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        at_folder.invokeFactory(\'Document\', \'doc\')\n-        at_doc = at_folder[\'doc\']\n-\n-        # relate them\n-        at_folder.setRelatedItems([at_doc])\n-\n-        self.assertEqual(at_folder.getRelatedItems(), [at_doc])\n-        self.assertEqual(at_folder.getReferences(), [at_doc])\n-        self.assertEqual(at_folder.getBackReferences(), [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [at_folder])\n-\n-        # migrate content (stores references on new objects for later restore)\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'])\n-        installTypeIfNeeded(\'Folder\')\n-        self._enable_referenceable_for(\'Folder\')\n-\n-        store_references(self.portal)\n-        migrate_folders(self.portal)\n-\n-        # rebuild catalog\n-        self.portal.portal_catalog.clearFindAndRebuild()\n-\n-        dx_folder = self.portal[\'folder\']\n-        at_doc = dx_folder[\'doc\']\n-        # references are not restored yet\n-        self.assertEqual(dx_folder.relatedItems, [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [])\n-\n-        # restore references\n-        restore_references(self.portal)\n-\n-        # references should be restored\n-        self.assertEqual(\n-            [i.to_object for i in dx_folder.relatedItems], [at_doc])\n-        self.assertEqual(self._backrefs(at_doc), [dx_folder])\n-        self.assertEqual(self._backrefs(dx_folder), [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [])\n-\n-    def test_at_dx_relations_migrated_for_partialy_migrated_nested(self):\n-        """Fails if referenceablebehavior is not enabled"""\n-        # create ATFolder and ATDocument\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        at_folder.invokeFactory(\'Document\', \'doc\')\n-        at_doc = at_folder[\'doc\']\n-\n-        # relate them\n-        at_folder.setRelatedItems([at_doc])\n-\n-        self.assertEqual(at_folder.getRelatedItems(), [at_doc])\n-        self.assertEqual(at_folder.getReferences(), [at_doc])\n-        self.assertEqual(at_folder.getBackReferences(), [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [at_folder])\n-\n-        # migrate content (stores references on new objects for later restore)\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'])\n-        installTypeIfNeeded(\'Document\')\n-        store_references(self.portal)\n-        migrate_documents(self.portal)\n-        self._enable_referenceable_for(\'Document\')\n-\n-        # rebuild catalog\n-        self.portal.portal_catalog.clearFindAndRebuild()\n-\n-        at_folder = self.portal[\'folder\']\n-        dx_doc = at_folder[\'doc\']\n-        self.assertTrue(is_referenceable(dx_doc))\n-        self.assertTrue(is_referenceable(at_folder))\n-\n-        # references are not restored yet\n-        # the at-folder has a broken reference now\n-        # since at_doc is now <ATDocument at /plone/folder/doc_MIGRATION_>\n-        self.assertNotEqual(at_folder.getRelatedItems(), [at_doc])\n-        self.assertEqual(dx_doc.relatedItems, [])\n-        # the backref is found since the reference_catalog is not purged\n-        self.assertEqual(self._backrefs(dx_doc), [at_folder])\n-\n-        # restore references\n-        restore_references(self.portal)\n-\n-        # references should be restored\n-        self.assertEqual(at_folder.getRelatedItems(), [dx_doc])\n-        self.assertEqual(self._backrefs(dx_doc), [at_folder])\n-        self.assertEqual(dx_doc.relatedItems, [])\n-\n-    def _backrefs(self, obj):\n-        from Products.Archetypes.interfaces.referenceable import IReferenceable\n-        results = []\n-        relation_catalog = queryUtility(ICatalog)\n-        reference_catalog = getToolByName(obj, \'reference_catalog\')\n-        int_id = dump(obj, relation_catalog, {})\n-        if int_id:\n-            brels = relation_catalog.findRelations(dict(to_id=int_id))\n-            for brel in brels:\n-                if brel.isBroken():\n-                    results.append(\'broken\')\n-                else:\n-                    results.append(brel.from_object)\n-        if not results:\n-            if is_referenceable(obj):\n-                obj = IReferenceable(obj)\n-                for rel in reference_catalog.getBackReferences(obj):\n-                    results.append(uuidToObject(rel.sourceUID))\n-        return results\n-\n-    def _enable_referenceable_for(self, typename):\n-        behavior = \'plone.app.referenceablebehavior.referenceable.IReferenceable\'  # noqa\n-        fti = queryUtility(IDexterityFTI, name=typename)\n-        behaviors = list(fti.behaviors)\n-        behaviors.append(behavior)\n-        fti._updateProperty(\'behaviors\', tuple(behaviors))\n-\n-    def test_store_references(self):\n-        intids = getUtility(IIntIds)\n-\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'])\n-        installTypeIfNeeded(\'News Item\')\n-\n-        # create ATFolder and ATDocument\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n-        at_doc = self.portal[\'doc\']\n-        # relate them\n-        at_folder.setRelatedItems([at_doc])\n-\n-        # create DX News Items\n-        self.portal.invokeFactory(\'News Item\', \'news1\')\n-        dx_news1 = self.portal[\'news1\']\n-        self.portal.invokeFactory(\'News Item\', \'news2\')\n-        dx_news2 = self.portal[\'news2\']\n-        dx_news1.relatedItems = PersistentList()\n-        dx_news1.relatedItems.append(RelationValue(intids.getId(dx_news2)))\n-        modified(dx_news1)\n-        relation_catalog = queryUtility(ICatalog)\n-        all_rels = [i for i in relation_catalog.findRelations()]\n-        self.assertEqual(len(all_rels), 1)\n-\n-        self.assertEqual(at_folder.getRelatedItems(), [at_doc])\n-        self.assertEqual(at_folder.getReferences(), [at_doc])\n-        self.assertEqual(at_folder.getBackReferences(), [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [at_folder])\n-        self.assertEqual(\n-            [i.to_object for i in dx_news1.relatedItems], [dx_news2])\n-\n-        store_references(self.portal)\n-        key = \'ALL_REFERENCES\'\n-        self.assertEqual(len(IAnnotations(self.portal)[key]), 2)\n-\n-    def test_export_references(self):\n-        """Test the Browser-View @@export_all_references."""\n-        intids = getUtility(IIntIds)\n-        set_browserlayer(self.request)\n-\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'])\n-        installTypeIfNeeded(\'News Item\')\n-\n-        # create ATFolder and ATDocument\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n-        at_doc = self.portal[\'doc\']\n-        # relate them\n-        at_folder.setRelatedItems([at_doc])\n-\n-        # create DX News Items\n-        self.portal.invokeFactory(\'News Item\', \'news1\')\n-        dx_news1 = self.portal[\'news1\']\n-        self.portal.invokeFactory(\'News Item\', \'news2\')\n-        dx_news2 = self.portal[\'news2\']\n-\n-        # relate them\n-        dx_news1.relatedItems = PersistentList()\n-        dx_news1.relatedItems.append(RelationValue(intids.getId(dx_news2)))\n-        modified(dx_news1)\n-\n-        view = self.portal.restrictedTraverse(\'export_all_references\')\n-        result = view()\n-        data = json.loads(result)\n-        self.assertEqual(len(data), 2)\n-\n-    def test_migrate_references_with_storage_on_portal(self):\n-        set_browserlayer(self.request)\n-        intids = getUtility(IIntIds)\n-\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'])\n-        installTypeIfNeeded(\'News Item\')\n-        self._enable_referenceable_for(\'News Item\')\n-\n-        # create ATFolder and ATDocument\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n-        at_doc = self.portal[\'doc\']\n-\n-        # create DX News Items\n-        self.portal.invokeFactory(\'News Item\', \'news1\')\n-        dx_news1 = self.portal[\'news1\']\n-        self.portal.invokeFactory(\'News Item\', \'news2\')\n-        dx_news2 = self.portal[\'news2\']\n-\n-        # relate them\n-        at_folder.setRelatedItems([at_doc])\n-        dx_news1.relatedItems = PersistentList()\n-        dx_news1.relatedItems.append(RelationValue(intids.getId(dx_news2)))\n-        dx_news1.relatedItems.append(RelationValue(intids.getId(at_doc)))\n-        at_doc.setRelatedItems([dx_news2])\n-        modified(dx_news1)\n-        relation_catalog = queryUtility(ICatalog)\n-        all_rels = [i for i in relation_catalog.findRelations()]\n-        self.assertEqual(len(all_rels), 2)\n-\n-        store_references(self.portal)\n-        # migration_view = getMultiAdapter(\n-        #     (self.portal, self.request),\n-        #     name=u\'migrate_from_atct\'\n-        # )\n-        # migration_view(from_form=True, migrate_references=False)\n-\n-        # this is basically be the same as above\n-        installTypeIfNeeded(\'Document\')\n-        installTypeIfNeeded(\'Folder\')\n-        migrate_folders(self.portal)\n-        migrate_documents(self.portal)\n-        self.portal.portal_catalog.clearFindAndRebuild()\n-        restore_references(self.portal)\n-\n-        dx_folder = self.portal[\'folder\']\n-        dx_doc = self.portal[\'doc\']\n-        self.assertEqual(\n-            [i.to_object for i in dx_folder.relatedItems], [dx_doc])\n-        self.assertEqual(\n-            [i.to_object for i in dx_doc.relatedItems], [dx_news2])\n-        self.assertEqual(\n-            [i.to_object for i in dx_news1.relatedItems], [dx_news2, dx_doc])\n-\n-    def test_stats(self):\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        from plone.app.contenttypes.migration.browser import \\\n-            MigrateFromATContentTypes as MigrationView\n-\n-        self.portal.invokeFactory(\'Document\', \'doc1\')\n-        at_doc1 = self.portal[\'doc1\']\n-        self.portal.invokeFactory(\'Document\', \'doc2\')\n-        at_doc2 = self.portal[\'doc2\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrationview = MigrationView(self.portal, None)\n-        stats = migrationview.stats()\n-        self.assertEqual(str(stats), "{\'Document (ATDocument)\': 2}")\n-        migrator = self.get_migrator(at_doc1, DocumentMigrator)\n-        migrator.migrate()\n-        stats = migrationview.stats()\n-        self.assertEqual(str(stats), "{\'Document (ATDocument)\': 1, \'Document (Dexterity Item)\': 1}")  # noqa: E501\n-        migrator = self.get_migrator(at_doc2, DocumentMigrator)\n-        migrator.migrate()\n-        stats = migrationview.stats()\n-        self.assertEqual(str(stats), "{\'Document (Dexterity Item)\': 2}")\n-\n-    def test_migration_atctypes_vocabulary_registered(self):\n-        name = \'plone.app.contenttypes.migration.atctypes\'\n-        factory = getUtility(IVocabularyFactory, name)\n-        self.assertIsNotNone(\n-            factory,\n-            \'Vocabulary {0} does not exist\'.format(name),\n-        )\n-\n-        vocabulary = factory(self.portal)\n-        self.assertEqual((), tuple(vocabulary))\n-\n-    def test_migration_atctypes_vocabulary_result(self):\n-        from Products.ATContentTypes.content.document import ATDocument\n-        from Products.ATContentTypes.content.file import ATFile\n-        from Products.ATContentTypes.content.image import ATImage\n-        from Products.ATContentTypes.content.folder import ATFolder\n-        from Products.ATContentTypes.content.link import ATLink\n-\n-        name = \'plone.app.contenttypes.migration.atctypes\'\n-        factory = getUtility(IVocabularyFactory, name)\n-\n-        self.createATCTobject(ATDocument, \'doc1\')\n-        self.createATCTobject(ATDocument, \'doc2\')\n-        self.createATCTobject(ATFile, \'file\')\n-        self.createATCTobject(ATImage, \'image\')\n-        self.createATCTobject(ATFolder, \'folder\')\n-        self.createATCTobject(ATLink, \'link\')\n-\n-        vocabulary = factory(self.portal)\n-\n-        self.assertEqual(\n-            5,\n-            len(vocabulary),\n-            \'Expect 5 entries in vocab because there are 5 diffrent types\')\n-\n-        # Result format\n-        docs = [term for term in vocabulary if term.token == \'Document\'][0]\n-        self.assertEqual(\'Document\', docs.value)\n-        self.assertEqual(\'Document (2)\', docs.title)\n-\n-    def test_migration_extendedtypes_vocabulary_registered(self):\n-        name = \'plone.app.contenttypes.migration.extendedtypes\'\n-        factory = getUtility(IVocabularyFactory, name)\n-        self.assertIsNotNone(\n-            factory,\n-            \'Vocabulary {0} does not exist\'.format(name),\n-        )\n-\n-        vocabulary = factory(self.portal)\n-        self.assertEqual((), tuple(vocabulary))\n-\n-    @unittest.skip(\'Creates test-isolation-issues. See https://github.com/plone/plone.app.contenttypes/issues/251\')  # noqa\n-    def test_migration_extendedtypes_vocabulary_result(self):\n-        from archetypes.schemaextender.extender import CACHE_ENABLED\n-        from archetypes.schemaextender.extender import CACHE_KEY\n-        from archetypes.schemaextender.field import ExtensionField\n-        from archetypes.schemaextender.interfaces import ISchemaExtender\n-        from Products.Archetypes import atapi\n-        from Products.ATContentTypes.content.document import ATDocument\n-        from zope.component import adapter\n-        from zope.component import provideAdapter\n-        from zope.interface import classImplements\n-        from zope.interface import implementer\n-        from zope.interface import Interface\n-\n-        name = \'plone.app.contenttypes.migration.extendedtypes\'\n-        factory = getUtility(IVocabularyFactory, name)\n-\n-        class IDummy(Interface):\n-            """Taggable content\n-            """\n-\n-        classImplements(ATDocument, IDummy)\n-        doc = self.createATCTobject(ATDocument, \'doc\')\n-\n-        class DummyField(ExtensionField, atapi.StringField):\n-            """Dummy Field"""\n-\n-        @implementer(ISchemaExtender)\n-        @adapter(IDummy)\n-        class DummySchemaExtender(object):\n-\n-            _fields = [DummyField(\'dummy\')]\n-\n-            def __init__(self, context):\n-                self.context = context\n-\n-            def getFields(self):\n-                return self._fields\n-\n-        provideAdapter(DummySchemaExtender, name=u\'dummy.extender\')\n-\n-        # Clear cache\n-        if CACHE_ENABLED:\n-            delattr(self.request, CACHE_KEY)\n-        self.assertIn(\'dummy\', doc.Schema()._names)\n-\n-        vocabulary = factory(self.portal)\n-\n-        self.assertEqual(1, len(vocabulary), \'Expect one entry\')\n-\n-        self.assertEqual("Document (1) - extended fields: \'dummy\'",\n-                         tuple(vocabulary)[0].title)\n-\n-    def test_migrate_function(self):\n-        from plone.app.contenttypes.migration.migration import migrate\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate(self.portal, DocumentMigrator)\n-        dx_document = self.portal[\'document\']\n-        self.assertTrue(IDexterityContent.providedBy(dx_document))\n-\n-    def test_migrate_xx_functions(self):\n-        from Products.ATContentTypes.content.image import ATImage\n-        from Products.ATContentTypes.content.file import ATFile\n-        from plone.app.contenttypes.migration.migration import (\n-            migrate_documents,\n-            migrate_collections,\n-            migrate_images,\n-            migrate_blobimages,\n-            migrate_files,\n-            migrate_blobfiles,\n-            migrate_links,\n-            migrate_newsitems,\n-            migrate_blobnewsitems,\n-            migrate_folders,\n-            migrate_events,\n-        )\n-        from plone.app.contenttypes.migration.topics import migrate_topics\n-\n-        # create all content types\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        self.portal.invokeFactory(\'Image\', \'image\')\n-        self.createATCTobject(ATImage, \'blobimage\')\n-        self.portal.invokeFactory(\'File\', \'blobfile\')\n-        self.createATCTobject(ATFile, \'file\')\n-        self.portal.invokeFactory(\'Collection\', \'collection\')\n-        self.portal.invokeFactory(\'Link\', \'link\')\n-        self.portal.invokeFactory(\'News Item\', \'newsitem\')\n-        self.createATCTBlobNewsItem(\'blobnewsitem\')\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        self.portal.invokeFactory(\'Event\', \'event\')\n-        self.portal.invokeFactory(\'Topic\', \'topic\')\n-\n-        # migrate all\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate_documents(self.portal)\n-        migrate_collections(self.portal)\n-        migrate_images(self.portal)\n-        migrate_blobimages(self.portal)\n-        migrate_files(self.portal)\n-        migrate_blobfiles(self.portal)\n-        migrate_links(self.portal)\n-        migrate_newsitems(self.portal)\n-        migrate_blobnewsitems(self.portal)\n-        migrate_folders(self.portal)\n-        migrate_events(self.portal)\n-        migrate_topics(self.portal)\n-\n-        # assertions\n-        cat = self.catalog\n-        at_contents = cat(object_provides=\'Products.ATContentTypes\'\n-                          \'.interfaces.IATContentType\')\n-        dx_contents = cat(object_provides=\'plone.dexterity\'\n-                          \'.interfaces.IDexterityContent\')\n-        self.assertEqual(len(at_contents), 0)\n-        self.assertEqual(len(dx_contents), 12)\n-\n-    def test_warning_for_uneditable_content(self):\n-        set_browserlayer(self.request)\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        from plone.app.contenttypes.interfaces import IDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        self.portal.invokeFactory(\'News Item\', \'newsitem\')\n-        at_document = self.portal[\'document\']\n-        at_newsitem = self.portal[\'newsitem\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        # At this point plone.app.z3cform is installed including it\'s browser\n-        # layer. But we have to annotate the request to provide it, since the\n-        # request was constructed before. Otherwise, @@view cannot be render\n-        # it\'s IRichText widget.\n-        alsoProvides(self.request, IPloneFormLayer)\n-        at_document_view = at_document.restrictedTraverse(\'document_view\')\n-        self.assertTrue(\n-            \'http://nohost/plone/@@atct_migrator\' in at_document_view()\n-        )\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-        dx_document = self.portal[\'document\']\n-        self.assertTrue(IDocument.providedBy(dx_document))\n-        dx_document_view = dx_document.restrictedTraverse(\'@@view\')\n-        self.assertFalse(\'alert-box\' in dx_document_view())\n-        at_newsitem_view = at_newsitem.restrictedTraverse(\'newsitem_view\')\n-        self.assertTrue(\'alert-box\' in at_newsitem_view())\n-        self.assertTrue(\n-            \'http://nohost/plone/@@atct_migrator\' in at_newsitem_view()\n-        )\n-\n-    def test_aaa_migration_results_page(self):\n-        """We create dx-types with the same portal_type as other contenttypes\n-        before migration to make sure the stats are correct.\n-        """\n-        set_browserlayer(self.request)\n-        from plone.app.contenttypes.interfaces import IDocument\n-        from plone.app.contenttypes.interfaces import ICollection\n-\n-        # create folders\n-        self.portal.invokeFactory(\'Folder\', \'folder1\')\n-        at_folder1 = self.portal[\'folder1\']\n-        self.portal.invokeFactory(\'Folder\', \'folder2\')\n-        at_folder2 = self.portal[\'folder2\']\n-\n-        # create ATDocuments\n-        at_folder1.invokeFactory(\'Document\', \'doc1\')\n-        at_doc1 = at_folder1[\'doc1\']\n-        at_folder2.invokeFactory(\'Document\', \'doc2\')\n-        at_doc2 = at_folder2[\'doc2\']\n-\n-        # create AT-based collections\n-        self.portal.invokeFactory(\'Collection\', \'col1\')\n-        at_col1 = self.portal[\'col1\']\n-\n-        # migrate content\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-\n-        # create dx-content that will not be migrated\n-        at_folder1.invokeFactory(\'Document\', \'dx_doc\')\n-        dx_doc = at_folder1[\'dx_doc\']\n-        self.assertTrue(IDocument.providedBy(dx_doc))\n-\n-        # create dexterity-based collections\n-        self.portal.invokeFactory(\'Collection\', \'dx_col\')\n-        dx_col = self.portal[\'dx_col\']\n-        self.assertTrue(ICollection.providedBy(dx_col))\n-\n-        migration_view = getMultiAdapter(\n-            (self.portal, self.request),\n-            name=u\'migrate_from_atct\'\n-        )\n-\n-        results = migration_view(\n-            from_form=True,\n-        )\n-\n-        dx_folder1 = self.portal[\'folder1\']\n-        dx_folder2 = self.portal[\'folder2\']\n-        dx_doc1 = dx_folder1[\'doc1\']\n-        dx_doc2 = dx_folder2[\'doc2\']\n-        dx_col1 = self.portal[\'col1\']\n-\n-        self.assertTrue(at_folder1 is not dx_folder1)\n-        self.assertTrue(at_folder2 is not dx_folder2)\n-        self.assertTrue(at_doc1 is not dx_doc1)\n-        self.assertTrue(at_doc2 is not dx_doc2)\n-        self.assertTrue(at_col1 is not dx_col1)\n-\n-        # test the stats\n-        stats = results[\'migrated_types\']\n-        self.assertEqual(stats[\'Document\'][\'amount_migrated\'], 2)\n-        self.assertEqual(stats[\'Folder\'][\'amount_migrated\'], 2)\n-        self.assertEqual(stats[\'Collection\'][\'amount_migrated\'], 1)\n-\n-    def test_migration_view_confirmation(self):\n-        set_browserlayer(self.request)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migration_view = getMultiAdapter(\n-            (self.portal, self.request),\n-            name=u\'migrate_from_atct\'\n-        )\n-        results = migration_view()\n-        self.assertIn(\'@@migrate_from_atct?migrate=1\', results)\n-\n-    def test_portlets_are_migrated(self):\n-        """add portlets and see if they\'re still available on the migrated\n-        content including portlet settings.\n-        """\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        from plone.app.contenttypes.migration.migration import FolderMigrator\n-        from plone.portlet.static.static import Assignment as StaticAssignment\n-        from plone.portlets.constants import GROUP_CATEGORY\n-        from plone.portlets.interfaces import ILocalPortletAssignmentManager\n-        from plone.portlets.interfaces import IPortletAssignmentMapping\n-        from plone.portlets.interfaces import IPortletAssignmentSettings\n-        from plone.portlets.interfaces import IPortletManager\n-\n-        def get_portlets(context, columnName):\n-            column = getUtility(IPortletManager, columnName)\n-            mapping = getMultiAdapter((context, column),\n-                                      IPortletAssignmentMapping)\n-            return mapping\n-\n-        # create an ATDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        at_document.setText(u\'T\xc3\xbctensuppe with some portlet\')\n-        at_document.setContentType(\'chemical/x-gaussian-checkpoint\')\n-\n-        # add a portlet\n-        portlet = StaticAssignment(u\'Sample Portlet\',\n-                                   \'<p>Yay! I get migrated!</p>\')\n-        add_portlet(at_document, portlet, \'static-portlet\',\n-                    u\'plone.leftcolumn\')\n-\n-        # disable group portlets for right columns\n-        right_column = getUtility(IPortletManager, u\'plone.rightcolumn\')\n-        localsettings = getMultiAdapter((at_document, right_column),\n-                                        ILocalPortletAssignmentManager)\n-        localsettings.setBlacklistStatus(GROUP_CATEGORY, True)\n-\n-        # hide our portlet\n-        settings = IPortletAssignmentSettings(portlet)\n-        settings[\'visible\'] = False\n-\n-        # add another portlet type that is not available when doing the\n-        # migration and make sure it got ignored in the migration\n-        broken = StaticAssignment(u\'Fake broken portlet\',\n-                                  \'<p>Ouch! I am broken</p>\')\n-        # ZODB.broken will add an ___Broken_state__ attribute if a portlet\'s\n-        # module is no longer available\n-        broken.__Broken_state__ = True\n-        add_portlet(at_document, broken, \'broken-portlet\', u\'plone.leftcolumn\')\n-\n-        # add a folder\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-\n-        # add a portlet to the folder\n-        portlet2 = StaticAssignment(u\'Sample Folder Portlet\',\n-                                    \'<p>Do I get migrated?</p>\')\n-        add_portlet(at_folder, portlet2, \'static-portlet\',\n-                    u\'plone.rightcolumn\')\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-        folder_migrator = self.get_migrator(at_folder, FolderMigrator)\n-        folder_migrator.migrate()\n-\n-        # assertions\n-        dx_document = self.portal[\'document\']\n-\n-        # portlet is available\n-        self.assertIn(\n-            \'static-portlet\',\n-            get_portlets(dx_document, u\'plone.leftcolumn\')\n-        )\n-        # broken portlets don\'t get copied\n-        self.assertNotIn(\n-            \'broken-portlet\',\n-            get_portlets(dx_document, u\'plone.leftcolumn\')\n-        )\n-\n-        # block portlets settings copied\n-        right_column = getUtility(IPortletManager, u\'plone.rightcolumn\')\n-        localsettings = getMultiAdapter((dx_document, right_column),\n-                                        ILocalPortletAssignmentManager)\n-        self.assertTrue(localsettings.getBlacklistStatus(GROUP_CATEGORY))\n-\n-        # hide portlets settings survived\n-        assignment = get_portlets(dx_document,\n-                                  u\'plone.leftcolumn\')[\'static-portlet\']\n-        settings = IPortletAssignmentSettings(assignment)\n-        self.assertFalse(settings[\'visible\'])\n-\n-        dx_folder = self.portal[\'folder\']\n-        self.assertIn(\n-            \'static-portlet\',\n-            get_portlets(dx_folder, u\'plone.rightcolumn\')\n-        )\n-\n-    def test_comments_are_migrated(self):\n-        """add some comments and check that it is correctly migrated.\n-\n-        XXX fixme : original comment id is not kept, comments are created\n-        with new ids...\n-        """\n-        from zope.component import createObject\n-        from plone.app.discussion.interfaces import IConversation\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-\n-        # create an ATDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        at_document.setText(u\'Document with some comments\')\n-\n-        # add some comments to the document\n-        at_conversation = IConversation(at_document)\n-        new_comment = createObject(\'plone.Comment\')\n-        new_comment.text = u\'Hey Dude! \xc3\x84 is not ascii.\'\n-        at_conversation.addComment(new_comment)\n-        at_comments = at_conversation.getComments()\n-        at_comment = [i for i in at_comments][0]\n-        at_plone_uuid = getattr(at_comment, \'_plone.uuid\')\n-        at_comment_id = getattr(at_comment, \'comment_id\')\n-        self.assertEqual(at_conversation.__parent__, at_document)\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-\n-        dx_document = self.portal[\'document\']\n-\n-        # no more comments on the portal\n-        portal_conversation = IConversation(self.portal)\n-        self.assertFalse(portal_conversation)\n-        # comments were migrated\n-        dx_conversation = IConversation(dx_document)\n-        self.assertEqual(dx_conversation.__parent__, dx_document)\n-        self.assertEqual(\n-            len(dx_conversation),\n-            1\n-        )\n-        dx_comments = dx_conversation.getComments()\n-        dx_comment = [i for i in dx_comments][0]\n-        dx_comment_id = getattr(dx_comment, \'comment_id\')\n-        self.assertEqual(dx_comment_id, at_comment_id)\n-        dx_plone_uuid = getattr(dx_comment, \'_plone.uuid\')\n-        self.assertEqual(dx_plone_uuid, at_plone_uuid)\n-        self.assertEqual(\n-            dx_comment.getText(),\n-            \'<p>Hey Dude! \\xc3\\x84 is not ascii.</p>\')\n-\n-    def test_default_pages_are_kept_during_migration(self):\n-        """Check that the default pages are not lost when migrating."""\n-        set_browserlayer(self.request)\n-        # create some content and set default pages\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        at_document.setText(u\'Document with some comments\')\n-\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-\n-        at_folder.invokeFactory(\'Document\', \'subdocument\')\n-\n-        self.portal.setLayout(\'folder_summary_view\')\n-        self.portal.setDefaultPage(\'document\')\n-\n-        at_folder.setLayout(\'folder_tabular_view\')\n-        at_folder.setDefaultPage(\'subdocument\')\n-\n-        self.portal.invokeFactory(\'Folder\', \'folder2\')\n-        at_folder2 = self.portal[\'folder2\']\n-        at_folder2.invokeFactory(\'Document\', \'subdocument2\')\n-        at_folder2.setLayout(\'folder_listing\')\n-\n-        # migrate content\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-\n-        migration_view = getMultiAdapter(\n-            (self.portal, self.request),\n-            name=u\'migrate_from_atct\'\n-        )\n-        migration_view(from_form=True)\n-        dx_folder = self.portal[\'folder\']\n-        dx_folder2 = self.portal[\'folder2\']\n-\n-        # test that view-methods are updated\n-        self.assertTrue(self.portal.getLayout(), \'summary_view\')\n-        self.assertTrue(dx_folder.getLayout(), \'tabular_view\')\n-        self.assertTrue(dx_folder2.getLayout(), \'listing_view\')\n-        # test that defaultpage is kept\n-        self.assertTrue(self.portal.getDefaultPage(), \'document\')\n-        self.assertTrue(dx_folder.getDefaultPage(), \'subdocument\')\n-        self.assertIsNone(dx_folder2.getDefaultPage())\n-\n-\n-class MigrateDexterityBaseClassIntegrationTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        self.portal = self.layer[\'portal\']\n-\n-        applyProfile(self.portal, \'plone.app.dexterity:testing\')\n-\n-        self.portal.acl_users.userFolderAddUser(SITE_OWNER_NAME,\n-                                                SITE_OWNER_PASSWORD,\n-                                                [\'Manager\'],\n-                                                [])\n-        login(self.portal, SITE_OWNER_NAME)\n-\n-        # Add default content\n-        self.portal.invokeFactory(\'Document\', \'item\')\n-\n-        # Change Document conent type to folderish\n-        portal_types = getToolByName(self.portal, \'portal_types\')\n-        portal_types[\'Document\'].klass = \'plone.dexterity.content.Container\'\n-        portal_types[\'Document\'].allowed_content_types = (\'Document\',)\n-\n-    def test_dxmigration_migrate_item_to_container_class_is_changed(self):\n-        """Check that base class was changed."""\n-        from plone.app.contenttypes.migration.dxmigration import \\\n-            migrate_base_class_to_new_class\n-        migrate_base_class_to_new_class(self.portal.item)\n-        self.assertTrue(isinstance(self.portal.item, Container))\n-\n-    def test_dxmigration_migrate_item_to_container_add_object_inside(self):\n-        """Check that after migrate base class it can add items inside object.\n-        """\n-        from plone.app.contenttypes.migration.dxmigration import \\\n-            migrate_base_class_to_new_class\n-        migrate_base_class_to_new_class(self.portal.item)\n-        self.portal.item.invokeFactory(\'Document\', \'doc\')\n-        self.assertEqual(\n-            len(self.portal.item.folderlistingFolderContents()), 1)\n-\n-    def test_dxmigration_migrate_list_of_objects_with_changed_base_class(self):\n-        """Check list of objects with changed classes."""\n-        from plone.app.contenttypes.migration.dxmigration import \\\n-            list_of_objects_with_changed_base_class\n-        # We have already one changed object\n-        objects = [i for i in\n-                   list_of_objects_with_changed_base_class(self.portal)]\n-        self.assertEqual(len(objects), 1)\n-\n-    def test_dxmigration_migrate_list_of_changed_base_class_names(self):\n-        """Check list of changed base class names."""\n-        from plone.app.contenttypes.migration.dxmigration import \\\n-            list_of_changed_base_class_names\n-        # We have already one changed object\n-        names = [i for i in list_of_changed_base_class_names(self.portal)]\n-        self.assertEqual(len(names), 1)\n-\n-    def test_dxmigration_migrate_vocabulary_changed_base_classes(self):\n-        """Check vocabulary of changed base class names."""\n-        # We have already one changed object\n-        name = \'plone.app.contenttypes.migration.changed_base_classes\'\n-        factory = getUtility(IVocabularyFactory, name)\n-        vocabulary = factory(self.portal)\n-        self.assertEqual(len(vocabulary), 1)\n-\n-\n-class MigrateDexterityBaseClassFunctionalTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        app = self.layer[\'app\']\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.portal_url = self.portal.absolute_url()\n-        self.manage_document_url = \'{0}/{1}/{2}/{3}\'.format(\n-            self.portal_url,\n-            \'portal_types\',\n-            \'Document\',\n-            \'manage_propertiesForm\',\n-        )\n-\n-        self.browser = Browser(app)\n-        self.browser.handleErrors = False\n-        self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic {0}:{1}\'.format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD,)\n-        )\n-\n-        # Add default content\n-        self.browser.open(self.portal_url)\n-        self.browser.getLink(\'Page\').click()\n-        widget = \'form.widgets.IDublinCore.title\'\n-        self.browser.getControl(name=widget).value = \'My item\'\n-        widget = \'form.widgets.IShortName.id\'\n-        self.browser.getControl(name=widget).value = \'item\'\n-        self.browser.getControl(\'Save\').click()\n-\n-        # Change Document conent type to folderish\n-        self.browser.open(self.manage_document_url)\n-        try:\n-            klass_ctlr = self.browser.getControl(name=\'klass:UTF-8:string\')\n-        except LookupError:\n-            klass_ctlr = self.browser.getControl(name=\'klass:string\')\n-        klass_ctlr.value = \'plone.app.contenttypes.content.Collection\'\n-        self.browser.getControl(\'Save Changes\').click()\n-        self.browser.open(\n-            \'{0}/@@base_class_migrator_form\'.format(self.portal_url))\n-        self.good_info_message_template = \'There are {0} objects migrated.\'\n-\n-    def test_dxmigration_migrate_check_migration_form_view(self):\n-        """Check base class migrator view of changed base class names."""\n-        html = etree.HTML(self.browser.contents)\n-        checkboxes = html.xpath(\'//form//*[@name="{0}"]\'.format(\n-            \'form.widgets.changed_base_classes:list\'))\n-        self.assertEqual(len(checkboxes), 1)\n-\n-    def test_dxmigration_migrate_check_migration_successful_message(self):\n-        """Check base class migrator view of changed base class names."""\n-        self.browser.getControl(\n-            name=\'form.widgets.changed_base_classes:list\').value = [\n-                \'plone.app.contenttypes.content.Document\']\n-        self.browser.getControl(\'Update\').click()\n-        self.assertIn(\n-            self.good_info_message_template.format(1), self.browser.contents)\n-\n-\n-class MigrationFunctionalTests(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_FUNCTIONAL_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        app = self.layer[\'app\']\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n-        self.request[\'URL\'] = self.portal.absolute_url()\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n-        self.portal.acl_users.userFolderAddUser(SITE_OWNER_NAME,\n-                                                SITE_OWNER_PASSWORD,\n-                                                [\'Manager\'],\n-                                                [])\n-        login(self.portal, SITE_OWNER_NAME)\n-        self.portal.portal_workflow.setDefaultChain(\n-            \'simple_publication_workflow\'\n-        )\n-        self.portal_url = self.portal.absolute_url()\n-\n-        self.browser = Browser(app)\n-        self.browser.handleErrors = False\n-        self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic {0}:{1}\'.format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD,)\n-        )\n-\n-    def tearDown(self):\n-        try:\n-            applyProfile(self.portal, \'plone.app.contenttypes:uninstall\')\n-        except KeyError:\n-            pass\n-\n-    def test_pac_installer_cancel(self):\n-        qi = get_installer(self.portal)\n-        portal_types = self.portal.portal_types\n-        self.browser.open(\'{0}/@@pac_installer\'.format(self.portal_url))\n-        self.assertFalse(qi.is_product_installed(\'plone.app.contenttypes\'))\n-        self.browser.getControl(\'Cancel\').click()\n-        self.assertFalse(IDexterityFTI.providedBy(portal_types[\'Document\']))\n-        self.assertFalse(qi.is_product_installed(\'plone.app.contenttypes\'))\n-        self.assertEqual(self.browser.url, self.portal_url)\n-\n-    def test_pac_installer_without_content(self):\n-        qi = get_installer(self.portal)\n-        portal_types = self.portal.portal_types\n-        self.browser.open(\'{0}/@@pac_installer\'.format(self.portal_url))\n-        self.assertFalse(qi.is_product_installed(\'plone.app.contenttypes\'))\n-        self.assertFalse(IDexterityFTI.providedBy(portal_types[\'Document\']))\n-        self.assertIn(\'proceed to the migration-form?\', self.browser.contents)\n-        self.browser.getControl(\'Install\').click()\n-        self.assertTrue(IDexterityFTI.providedBy(portal_types[\'Document\']))\n-        self.assertTrue(IDexterityFTI.providedBy(portal_types[\'News Item\']))\n-        self.assertTrue(qi.is_product_installed(\'plone.app.contenttypes\'))\n-        self.assertIn(\'Migration control panel\', self.browser.contents)\n-        self.assertIn(\'No content to migrate.\', self.browser.contents)\n-\n-    def test_pac_installer_with_content(self):\n-        # add some at content:\n-        self.portal.invokeFactory(\'Document\', \'doc1\')\n-        transaction.commit()\n-        qi = get_installer(self.portal)\n-        portal_types = self.portal.portal_types\n-        self.browser.open(\'{0}/@@pac_installer\'.format(self.portal_url))\n-        self.assertFalse(IDexterityFTI.providedBy(portal_types[\'Document\']))\n-        self.assertFalse(qi.is_product_installed(\'plone.app.contenttypes\'))\n-        self.assertIn(\'proceed to the migration-form?\', self.browser.contents)\n-        self.browser.getControl(\'Install\').click()\n-        self.assertFalse(IDexterityFTI.providedBy(portal_types[\'Document\']))\n-        self.assertTrue(IDexterityFTI.providedBy(portal_types[\'News Item\']))\n-        self.assertTrue(qi.is_product_installed(\'plone.app.contenttypes\'))\n-        self.assertIn(\'Migration control panel\', self.browser.contents)\n-        self.assertIn(\'You currently have <span class="strong">1</span> archetypes objects to be migrated.\', self.browser.contents)  # noqa E501\n-\n-    def test_atct_migration_form(self):\n-        # add some at content:\n-        self.portal.invokeFactory(\'Document\', \'doc1\')\n-        self.portal.invokeFactory(\'News Item\', \'news1\')\n-        self.portal.invokeFactory(\'News Item\', \'news2\')\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        self.portal[\'folder\'].invokeFactory(\'Document\', \'doc2\')\n-        transaction.commit()\n-        from zExceptions import NotFound\n-        self.assertRaises(\n-            NotFound,\n-            self.browser.open,\n-            \'{0}/@@atct_migrator\'.format(self.portal_url)\n-        )\n-        self.browser.open(\'{0}/@@pac_installer\'.format(self.portal_url))\n-        self.browser.getControl(\'Install\').click()\n-        # check statistics before\n-        self.assertIn(\n-            \'You currently have <span class="strong">5</span> archetypes \'\n-            \'objects to be migrated.\',\n-            self.browser.contents,\n-        )\n-        widget = \'form.widgets.content_types:list\'\n-        ct_widget = self.browser.getControl(name=widget)\n-        self.assertEqual(\n-            ct_widget.options,\n-            [\'Document\', \'Folder\', \'News Item\'])\n-        # all types are auto-selected\n-        self.assertEqual(ct_widget.value, [\'Document\', \'Folder\', \'News Item\'])\n-        widget = \'form.widgets.content_types:list\'\n-        # we only migrate Documents\n-        self.browser.getControl(name=widget).value = [\'Document\']\n-        widget = \'form.widgets.migrate_references:list\'\n-        self.assertEqual(\n-            self.browser.getControl(name=widget).value,\n-            [\'selected\']\n-        )\n-        self.browser.getControl(name=\'form.buttons.migrate\').click()\n-        from plone.app.contenttypes.interfaces import IDocument\n-        from plone.app.contenttypes.interfaces import INewsItem\n-        from plone.app.contenttypes.interfaces import IFolder\n-        self.assertTrue(IDocument.providedBy(self.portal[\'doc1\']))\n-        self.assertFalse(INewsItem.providedBy(self.portal[\'news1\']))\n-        self.assertFalse(IFolder.providedBy(self.portal[\'folder\']))\n-        self.assertTrue(IDocument.providedBy(self.portal[\'folder\'][\'doc2\']))\n-        self.assertIn(\n-            \'Congratulations! You migrated from Archetypes to Dexterity.\',\n-            self.browser.contents\n-        )\n-        msg = \'<td>ATDocument</td>\\n      <td>Document</td>\\n      <td>2</td>\'\n-        self.assertIn(msg, self.browser.contents)\n-        msg = \'<td>Document (ATDocument)</td>\\n      <td>2</td>\'\n-        self.assertIn(msg, self.browser.contents)\n-        msg = \'<td>News Item (ATNewsItem)</td>\\n      <td>2</td>\'\n-        self.assertIn(msg, self.browser.contents)\n-        msg = \'<td>Document (Dexterity Item)</td>\\n      <td>2</td>\'\n-        self.assertIn(msg, self.browser.contents)\n-        msg = \'<td>News Item (Dexterity Item)</td>\\n      <td>2</td>\'\n-        self.assertNotIn(msg, self.browser.contents)\n-        msg = \'<td>Folder (Dexterity Container)</td>\\n      <td>1</td>\'\n-        self.assertNotIn(msg, self.browser.contents)\n-\n-        # we only migrated Document, now we migrate the rest\n-        self.browser.getLink(\'Back to the Migration-Form\').click()\n-        widget = \'form.widgets.content_types:list\'\n-        ct_widget = self.browser.getControl(name=widget)\n-        self.assertEqual(ct_widget.options, [\'Folder\', \'News Item\'])\n-        self.browser.getControl(name=\'form.buttons.migrate\').click()\n-        self.assertTrue(INewsItem.providedBy(self.portal[\'news1\']))\n-        self.assertTrue(IFolder.providedBy(self.portal[\'folder\']))\n-        msg = \'<td>News Item (Dexterity Item)</td>\\n      <td>2</td>\'\n-        self.assertIn(msg, self.browser.contents)\n-        msg = \'<td>Folder (Dexterity Container)</td>\\n      <td>1</td>\'\n-        self.assertIn(msg, self.browser.contents)\ndiff --git a/plone/app/contenttypes/tests/test_migration_browser.py b/plone/app/contenttypes/tests/test_migration_browser.py\ndeleted file mode 100644\nindex f9e4e1c3..00000000\n--- a/plone/app/contenttypes/tests/test_migration_browser.py\n+++ /dev/null\n@@ -1,129 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.contenttypes.testing import TEST_MIGRATION\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_INTEGRATION_TESTING  # noqa\n-import unittest\n-\n-if TEST_MIGRATION:\n-    from plone.app.contenttypes.interfaces import IDocument\n-    from plone.app.contenttypes.interfaces import IFile\n-    from plone.app.contenttypes.interfaces import IFolder\n-    from plone.app.contenttypes.interfaces import IImage\n-    from plone.app.contenttypes.interfaces import ILink\n-    from plone.app.contenttypes.interfaces import INewsItem\n-    from plone.app.contenttypes.interfaces import IPloneAppContenttypesLayer\n-    from plone.app.testing import applyProfile\n-    from plone.app.testing import setRoles\n-    from plone.app.testing import TEST_USER_ID\n-    from plone.dexterity.fti import DexterityFTI\n-    from plone.dexterity.interfaces import IDexterityFTI\n-    from plone.event.interfaces import IEvent\n-    from Products.CMFCore.utils import getToolByName\n-    from zope.interface import directlyProvides\n-\n-\n-class FixBaseclassesTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_INTEGRATION_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n-        self.request[\'URL\'] = self.portal.absolute_url()\n-        directlyProvides(self.request, IPloneAppContenttypesLayer)\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n-        fti = DexterityFTI(\'mockobject\')\n-        fti.klass = \'plone.dexterity.content.Item\'\n-        self.portal.portal_types._setObject(\'mockobject\', fti)\n-        self.portal.invokeFactory(\'mockobject\', \'obj1\')\n-        self.obj = self.portal.obj1\n-\n-    def test_view_is_registered(self):\n-        view = self.portal.restrictedTraverse(\'fix_base_classes\')\n-        self.assertTrue(isinstance(view(), str))\n-\n-    def test_fix_interface_for_document(self):\n-        self.obj.portal_type = \'Document\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(IDocument.providedBy(self.obj))\n-\n-    def test_fix_interface_for_event(self):\n-        self.obj.portal_type = \'Event\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(IEvent.providedBy(self.obj))\n-\n-    def test_fix_interface_for_file(self):\n-        self.obj.portal_type = \'File\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(IFile.providedBy(self.obj))\n-\n-    def test_fix_interface_for_folder(self):\n-        self.obj.portal_type = \'Folder\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(IFolder.providedBy(self.obj))\n-\n-    def test_fix_interface_for_image(self):\n-        self.obj.portal_type = \'Image\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(IImage.providedBy(self.obj))\n-\n-    def test_fix_interface_for_link(self):\n-        self.obj.portal_type = \'Link\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(ILink.providedBy(self.obj))\n-\n-    def test_fix_interface_for_news_item(self):\n-        self.obj.portal_type = \'News Item\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(INewsItem.providedBy(self.obj))\n-\n-    def test_install_dx_type_if_needed(self):\n-        from plone.app.contenttypes.migration.utils import installTypeIfNeeded\n-        tt = self.portal.portal_types\n-        tt.manage_delObjects(\'Document\')\n-        tt.manage_addTypeInformation(\n-            \'Factory-based Type Information with dynamic views\',\n-            id=\'Document\')\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'])\n-        fti = tt.getTypeInfo(\'Document\')\n-        self.assertFalse(IDexterityFTI.providedBy(fti))\n-        installTypeIfNeeded(\'Document\')\n-        fti = tt.getTypeInfo(\'Document\')\n-        self.assertTrue(IDexterityFTI.providedBy(fti))\n-\n-    def test_install_dx_type_if_needed_wrong_type_name(self):\n-        from plone.app.contenttypes.migration.utils import installTypeIfNeeded\n-        with self.assertRaises(KeyError) as e:\n-            installTypeIfNeeded(\'Unknown\')\n-        self.assertEqual(\n-            e.exception.args[0],\n-            \'Unknown is not one of the default types\'\n-        )\ndiff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py\ndeleted file mode 100644\nindex b353a722..00000000\n--- a/plone/app/contenttypes/tests/test_migration_custom.py\n+++ /dev/null\n@@ -1,611 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-from plone.app.contenttypes.testing import TEST_MIGRATION\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_FUNCTIONAL_TESTING  # noqa\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_TESTING  # noqa\n-import unittest\n-\n-if TEST_MIGRATION:\n-    from datetime import datetime\n-    from plone.app.contenttypes.migration.field_migrators import migrate_filefield  # noqa E501\n-    from plone.app.contenttypes.migration.field_migrators import migrate_imagefield  # noqa E501\n-    from plone.app.contenttypes.migration.field_migrators import migrate_simplefield  # noqa E501\n-    from plone.app.contenttypes.migration.utils import installTypeIfNeeded\n-    from plone.app.testing import applyProfile\n-    from plone.app.testing import login\n-    from plone.app.testing import setRoles\n-    from plone.app.testing import SITE_OWNER_NAME\n-    from plone.app.testing import SITE_OWNER_PASSWORD\n-    from plone.app.testing import TEST_USER_ID\n-    from plone.testing.zope import Browser\n-    from Products.CMFCore.utils import getToolByName\n-    from Products.CMFPlone.utils import safe_unicode\n-\n-    import os.path\n-    import pytz\n-    import transaction\n-\n-\n-class MigrateFieldsTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n-\n-    def tearDown(self):\n-        try:\n-            applyProfile(self.portal, \'plone.app.contenttypes:uninstall\')\n-        except KeyError:\n-            pass\n-\n-    def get_test_image_data(self):\n-        test_image_path = os.path.join(os.path.dirname(__file__), \'image.png\')\n-        with open(test_image_path, \'rb\') as test_image_file:\n-            test_image_data = test_image_file.read()\n-        return test_image_data\n-\n-    def get_test_file_data(self):\n-        test_file_path = os.path.join(os.path.dirname(__file__), \'file.pdf\')\n-        with open(test_file_path, \'rb\') as test_file:\n-            test_file_data = test_file.read()\n-        return test_file_data\n-\n-    def test_migrate_stringfield(self):\n-        # create content\n-        at_document_id = self.portal.invokeFactory(\n-            \'Document\',\n-            \'foo\',\n-            title=\'Foo document\',\n-        )\n-        # register p.a.contenttypes profile\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        dx_document_id = self.portal.invokeFactory(\n-            \'Document\',\n-            \'bar\',\n-            title=\'Bar document\',\n-        )\n-        at_document = self.portal[at_document_id]\n-        dx_document = self.portal[dx_document_id]\n-        migrate_simplefield(at_document, dx_document, \'title\', \'title\')\n-        self.assertEqual(dx_document.Title(), at_document.Title())\n-\n-    def test_migrate_richtextfield(self):\n-        # create content\n-        at_document_id = self.portal.invokeFactory(\n-            \'Document\',\n-            \'foo\',\n-            title=\'Foo document\',\n-            text=\'Some foo html text\',\n-        )\n-        # register p.a.contenttypes profile\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        dx_document_id = self.portal.invokeFactory(\n-            \'Document\',\n-            \'bar\',\n-            title=\'Bar document\',\n-        )\n-        at_document = self.portal[at_document_id]\n-        dx_document = self.portal[dx_document_id]\n-        self.assertEqual(dx_document.text, None)\n-        migrate_simplefield(at_document, dx_document, \'text\', \'text\')\n-        self.assertEqual(dx_document.text, at_document.getText())\n-\n-    def test_migrate_listfield(self):\n-        # create content\n-        at_document_id = self.portal.invokeFactory(\n-            \'Document\',\n-            \'foo\',\n-            title=\'Foo document\',\n-            subject=[\'aaa\', \'bbb\'],\n-        )\n-        # register p.a.contenttypes profile\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        dx_document_id = self.portal.invokeFactory(\n-            \'Document\',\n-            \'bar\',\n-            title=\'Bar document\',\n-        )\n-        at_document = self.portal[at_document_id]\n-        dx_document = self.portal[dx_document_id]\n-        migrate_simplefield(at_document, dx_document, \'subject\', \'subject\',)\n-        self.assertEqual(dx_document.Subject(), at_document.Subject())\n-\n-    def test_migrate_imagefield(self):\n-        test_image_data = self.get_test_image_data()\n-        at_newsitem_id = self.portal.invokeFactory(\n-            \'News Item\',\n-            \'foo\',\n-            title=\'Foo news\',\n-            image=test_image_data,\n-        )\n-        # register p.a.contenttypes profile\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        dx_newsitem_id = self.portal.invokeFactory(\n-            \'News Item\',\n-            \'bar\',\n-            title=\'Bar news\',\n-        )\n-        at_newsitem = self.portal[at_newsitem_id]\n-        dx_newsitem = self.portal[dx_newsitem_id]\n-        self.assertEqual(dx_newsitem.image, None)\n-        migrate_imagefield(at_newsitem, dx_newsitem, \'image\', \'image\')\n-        self.assertEqual(dx_newsitem.image.contentType, \'image/png\')\n-        self.assertEqual(dx_newsitem.image.data, test_image_data)\n-\n-    def test_migrate_filefield(self):\n-        test_file_data = self.get_test_file_data()\n-        at_file_id = self.portal.invokeFactory(\n-            \'File\',\n-            \'foo\',\n-            title=\'Foo file\',\n-            file=test_file_data,\n-        )\n-        # register p.a.contenttypes profile\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        dx_file_id = self.portal.invokeFactory(\n-            \'File\',\n-            \'bar\',\n-            title=\'Bar file\',\n-        )\n-        at_file = self.portal[at_file_id]\n-        dx_file = self.portal[dx_file_id]\n-        self.assertEqual(dx_file.file, None)\n-        migrate_filefield(at_file, dx_file, \'file\', \'file\')\n-        self.assertEqual(dx_file.file.data, test_file_data)\n-\n-\n-class MigrateCustomATTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n-\n-    def tearDown(self):\n-        try:\n-            applyProfile(self.portal, \'plone.app.contenttypes:uninstall\')\n-        except KeyError:\n-            pass\n-\n-    def createCustomATDocument(self, id, parent=None):\n-        from Products.Archetypes.atapi import StringField, TextField\n-        from Products.ATContentTypes.interfaces import IATDocument\n-        from archetypes.schemaextender.interfaces import ISchemaExtender\n-        from archetypes.schemaextender.field import ExtensionField\n-        from zope.component import getGlobalSiteManager\n-        from zope.interface import implementer\n-\n-        # create schema extension\n-        class ExtensionTextField(ExtensionField, TextField):\n-            """ derivative of text for extending schemas """\n-\n-        class ExtensionStringField(ExtensionField, StringField):\n-            """ derivative of text for extending schemas """\n-\n-        @implementer(ISchemaExtender)\n-        class SchemaExtender(object):\n-            fields = [\n-                ExtensionTextField(\'textExtended\',\n-                                   ),\n-                ExtensionStringField(\'stringExtended\',\n-                                     ),\n-            ]\n-\n-            def __init__(self, context):\n-                self.context = context\n-\n-            def getFields(self):\n-                return self.fields\n-\n-        # register adapter\n-        gsm = getGlobalSiteManager()\n-        gsm.registerAdapter(SchemaExtender, (IATDocument,), ISchemaExtender)\n-\n-        # create content\n-        container = parent or self.portal\n-        container.invokeFactory(\n-            \'Document\',\n-            id,\n-            title=\'Foo document\',\n-            stringExtended=\'foo text\',\n-            textExtended=\'foo extended rich text\',\n-        )\n-        at_document = container[id]\n-\n-        # unregister adapter assure test isolation\n-        gsm.unregisterAdapter(required=[IATDocument], provided=ISchemaExtender)\n-\n-        return at_document\n-\n-    def test_migrate_extended_document(self):\n-        from plone.app.contenttypes.migration.migration import migrateCustomAT\n-        from plone.app.contenttypes.interfaces import INewsItem\n-        at_document = self.createCustomATDocument(\'foo-document\')\n-        # install pac but only install News Items\n-        portal_setup = getToolByName(self.portal, \'portal_setup\')\n-        portal_setup.runAllImportStepsFromProfile(\n-            \'profile-plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'],\n-        )\n-        installTypeIfNeeded(\'News Item\')\n-        fields_mapping = (\n-            {\'AT_field_name\': \'textExtended\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.TextField\',\n-             \'DX_field_name\': \'text\',\n-             \'DX_field_type\': \'RichText\', },\n-            {\'AT_field_name\': \'stringExtended\',\n-             \'AT_field_type\': \'StringField\',\n-             \'DX_field_name\': \'title\',\n-             \'DX_field_type\': \'StringField\', },\n-        )\n-        # migrate extended AT Document to default DX News Item\n-        migrateCustomAT(\n-            fields_mapping, src_type=\'Document\', dst_type=\'News Item\')\n-        dx_newsitem = self.portal[\'foo-document\']\n-        self.assertTrue(INewsItem.providedBy(dx_newsitem))\n-        self.assertTrue(dx_newsitem is not at_document)\n-        self.assertEqual(at_document.textExtended(), dx_newsitem.text.raw)\n-        self.assertEqual(at_document.stringExtended, dx_newsitem.title)\n-\n-    def test_migrate_atevent_to_dxnewsitem(self):\n-        """Tests the custom migration by migrating a default type. It is not\n-        meant to be used this way but is a nice way to test the migrations.\n-        During this migration the old event fti is still present.\n-        """\n-        from DateTime import DateTime\n-        from plone.app.contenttypes.migration.migration import migrateCustomAT\n-        from plone.app.contenttypes.interfaces import INewsItem\n-\n-        # create an ATEvent\n-        self.portal.invokeFactory(\'Event\', \'event\')\n-        at_event = self.portal[\'event\']\n-\n-        # Date\n-        at_event.getField(\'startDate\') \\\n-                .set(at_event, DateTime(\'2013-02-03 12:00\'))\n-        at_event.getField(\'endDate\') \\\n-                .set(at_event, DateTime(\'2013-04-05 13:00\'))\n-\n-        # Contact\n-        at_event.getField(\'contactPhone\').set(at_event, \'123456789\')\n-        at_event.getField(\'contactEmail\').set(at_event, \'dummy@email.com\')\n-        at_event.getField(\'contactName\').set(at_event, u\'N\xc3\xa4me\')\n-\n-        # URL\n-        at_event.getField(\'eventUrl\').set(at_event, \'http://www.plone.org\')\n-\n-        # Attendees\n-        at_event.getField(\'attendees\').set(at_event, (\'You\', \'Me\'))\n-\n-        # Text\n-        at_event.setText(\'T\xc3\xbctensuppe\')\n-        at_event.setContentType(\'text/plain\')\n-\n-        oldTZ = os.environ.get(\'TZ\', None)\n-        os.environ[\'TZ\'] = \'Asia/Tbilisi\'\n-\n-        # install pac but only install News Items\n-        portal_setup = getToolByName(self.portal, \'portal_setup\')\n-        portal_setup.runAllImportStepsFromProfile(\n-            \'profile-plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'],\n-        )\n-        installTypeIfNeeded(\'News Item\')\n-        fields_mapping = (\n-            {\'AT_field_name\': \'text\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.TextField\',\n-             \'DX_field_name\': \'text\',\n-             \'DX_field_type\': \'RichText\', },\n-            {\'AT_field_name\': \'contactName\',\n-             \'AT_field_type\': \'StringField\',\n-             \'DX_field_name\': \'image_caption\',\n-             \'DX_field_type\': \'StringField\', },\n-        )\n-        # migrate ATCTEvent to default DX News Item\n-        migrateCustomAT(fields_mapping, src_type=\'Event\', dst_type=\'News Item\')\n-        if oldTZ:\n-            os.environ[\'TZ\'] = oldTZ\n-        else:\n-            del os.environ[\'TZ\']\n-\n-        dx_newsitem = self.portal[\'event\']\n-        self.assertTrue(INewsItem.providedBy(dx_newsitem))\n-        self.assertTrue(dx_newsitem is not at_event)\n-        self.assertEqual(\n-            safe_unicode(at_event.getText()),\n-            dx_newsitem.text.output)\n-        self.assertEqual(\n-            at_event.contactName,\n-            dx_newsitem.image_caption)\n-\n-    def test_migrate_atevent_to_dxevent(self):\n-        """Tests the custom migration by migrating a default type. It is not\n-        meant to be used this way but is a nice way to test the migrations.\n-        During this migration the event fti is already replaced by the dx one.\n-        """\n-        from DateTime import DateTime\n-        from plone.app.contenttypes.migration.migration import migrateCustomAT\n-        from plone.app.contenttypes.interfaces import IEvent\n-\n-        # create an ATEvent\n-        self.portal.invokeFactory(\'Event\', \'event\')\n-        at_event = self.portal[\'event\']\n-\n-        # Date\n-        FORMAT = \'%Y-%m-%d %H:%M\'\n-        start = \'2013-02-03 12:15\'\n-        end = \'2013-04-05 13:45\'\n-        at_event.getField(\'startDate\').set(at_event, DateTime(start))\n-        at_event.getField(\'endDate\').set(at_event, DateTime(end))\n-\n-        # Contact\n-        at_event.getField(\'contactPhone\').set(at_event, \'123456789\')\n-        at_event.getField(\'contactEmail\').set(at_event, \'dummy@email.com\')\n-        at_event.getField(\'contactName\').set(at_event, u\'N\xc3\xa4me\')\n-\n-        # URL\n-        at_event.getField(\'eventUrl\').set(at_event, \'http://www.plone.org\')\n-\n-        # Attendees\n-        at_event.getField(\'attendees\').set(at_event, (\'Y\xc3\xb6u\', \'Me\'))\n-\n-        # Text\n-        at_event.setText(\'T\xc3\xbctensuppe\')\n-        at_event.setContentType(\'text/plain\')\n-\n-        oldTZ = os.environ.get(\'TZ\', None)\n-        TZ = \'Asia/Tbilisi\'\n-        os.environ[\'TZ\'] = TZ\n-        timezone = pytz.timezone(TZ)\n-\n-        # install pac but only install Event\n-        portal_setup = getToolByName(self.portal, \'portal_setup\')\n-        portal_setup.runAllImportStepsFromProfile(\n-            \'profile-plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'],\n-        )\n-        installTypeIfNeeded(\'Event\')\n-        fields_mapping = (\n-            {\'AT_field_name\': \'startDate\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.DateTimeField\',\n-             \'DX_field_name\': \'start\',\n-             \'DX_field_type\': \'Datetime\', },\n-            {\'AT_field_name\': \'endDate\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.DateTimeField\',\n-             \'DX_field_name\': \'end\',\n-             \'DX_field_type\': \'Datetime\', },\n-            {\'AT_field_name\': \'text\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.TextField\',\n-             \'DX_field_name\': \'text\',\n-             \'DX_field_type\': \'RichText\', },\n-            {\'AT_field_name\': \'eventUrl\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.StringField\',\n-             \'DX_field_name\': \'event_url\',\n-             \'DX_field_type\': \'StringField\', },\n-            {\'AT_field_name\': \'contactEmail\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.StringField\',\n-             \'DX_field_name\': \'contact_email\',\n-             \'DX_field_type\': \'StringField\', },\n-            {\'AT_field_name\': \'contactName\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.StringField\',\n-             \'DX_field_name\': \'contact_name\',\n-             \'DX_field_type\': \'StringField\', },\n-            {\'AT_field_name\': \'contactPhone\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.StringField\',\n-             \'DX_field_name\': \'contact_phone\',\n-             \'DX_field_type\': \'StringField\', },\n-            {\'AT_field_name\': \'attendees\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.LinesField\',\n-             \'DX_field_name\': \'attendees\',\n-             \'DX_field_type\': \'Tuple\', },\n-        )\n-        # migrate ATEvent to new default Event\n-        migrateCustomAT(fields_mapping, src_type=\'Event\', dst_type=\'Event\')\n-        dx_event = self.portal[\'event\']\n-        self.assertTrue(IEvent.providedBy(dx_event))\n-        self.assertTrue(dx_event is not at_event)\n-        self.assertEqual(safe_unicode(\n-            at_event.getText()), dx_event.text.output)\n-        self.assertEqual(at_event.eventUrl, dx_event.event_url)\n-        self.assertEqual(at_event.contactEmail, dx_event.contact_email)\n-        self.assertEqual(at_event.contactName, dx_event.contact_name)\n-        self.assertEqual(at_event.contactPhone, dx_event.contact_phone)\n-        self.assertEqual(at_event.attendees, dx_event.attendees)\n-        self.assertEqual(\n-            dx_event.start,\n-            timezone.localize(datetime.strptime(start, FORMAT)))\n-        self.assertEqual(\n-            dx_event.end, timezone.localize(datetime.strptime(end, FORMAT)))\n-        if oldTZ:\n-            os.environ[\'TZ\'] = oldTZ\n-        else:\n-            del os.environ[\'TZ\']\n-\n-    def test_migration_with_custom_fieldmigrator(self):\n-        """Migrate a ATDocument to a DXNewsItem using a custom modifier"""\n-        from plone.app.contenttypes.interfaces import INewsItem\n-        from plone.app.contenttypes.migration.migration import migrateCustomAT\n-        at_document = self.createCustomATDocument(\'foo-document\')\n-        at_text = (\n-            u\'Some | field is | pipe-delimited | in the field\\n\'\n-        )\n-        at_document.setText(at_text)\n-        # install pac but only install News Items\n-        portal_setup = getToolByName(self.portal, \'portal_setup\')\n-        portal_setup.runAllImportStepsFromProfile(\n-            \'profile-plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'],\n-        )\n-        installTypeIfNeeded(\'News Item\')\n-        fields_mapping = (\n-            {\'AT_field_name\': \'text\',\n-             \'DX_field_name\': \'creators\',\n-             \'field_migrator\': some_field_migrator},\n-        )\n-        migrateCustomAT(\n-            fields_mapping, src_type=\'Document\', dst_type=\'News Item\')\n-\n-        dx_newsitem = self.portal[\'foo-document\']\n-        self.assertTrue(INewsItem.providedBy(dx_newsitem))\n-        self.assertTrue(dx_newsitem is not at_document)\n-        self.assertEqual(4, len(dx_newsitem.creators))\n-        self.assertEqual(at_document.Title(), dx_newsitem.title)\n-\n-\n-def some_field_migrator(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """Custom field_migrator\n-\n-    A simple example that transforms the value of a pipe-delimited richtext\n-    to a tuple.\n-    """\n-    field = src_obj.getField(src_fieldname)\n-    at_value = field.get(src_obj)\n-    at_value = at_value.replace(\'<p>\', \'\').replace(\'</p>\', \'\')\n-    dx_value = [safe_unicode(i) for i in at_value.split(\'|\')]\n-    setattr(dst_obj, dst_fieldname, tuple(dx_value))\n-\n-\n-class CustomMigrationFunctionalTests(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_FUNCTIONAL_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        app = self.layer[\'app\']\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n-        self.request[\'URL\'] = self.portal.absolute_url()\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n-        self.portal.acl_users.userFolderAddUser(\'admin\',\n-                                                \'secret\',\n-                                                [\'Manager\'],\n-                                                [])\n-        login(self.portal, \'admin\')\n-        self.portal.portal_workflow.setDefaultChain(\n-            \'simple_publication_workflow\')\n-        self.portal_url = self.portal.absolute_url()\n-\n-        self.browser = Browser(app)\n-        self.browser.handleErrors = False\n-        self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic {0}:{1}\'.format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD,)\n-        )\n-\n-    def tearDown(self):\n-        try:\n-            applyProfile(self.portal, \'plone.app.contenttypes:uninstall\')\n-        except KeyError:\n-            pass\n-\n-    def test_custom_migration_form(self):\n-        """Basic test for the custom_migration form.\n-        Field-mapping only works with javascript enabled so we migrate\n-        only the content but not the fields.\n-        """\n-        # add some at content\n-        self.portal.invokeFactory(\'Document\', \'doc1\')\n-        self.portal.invokeFactory(\'Event\', \'event1\')\n-        self.portal.event1.setTitle(u\'Ein T\xc3\xb6rmin\')\n-        self.portal.event1.setDescription(u\'W\xc3\xa4nn?\')\n-        self.portal.doc1.setTitle(u\'Ein D\xc3\xb6cument\')\n-        self.portal.doc1.setDescription(u\'S\xc3\xb6 was\')\n-        transaction.commit()\n-        self.browser.open(\'{0}/@@pac_installer\'.format(self.portal_url))\n-        self.browser.getControl(\'Install\').click()\n-        # open custom-migration-form\n-        self.browser.open(\'{0}/@@custom_migration\'.format(self.portal_url))\n-        results = self.browser.contents\n-        self.assertIn(\'Custom types migration control panel\', results)\n-        self.assertIn(\'<input type="hidden" name="Document:list" value="text__type__Products.Archetypes.Field.TextField" />\', results)  # noqa\n-        self.assertEqual(self.browser.getControl(name=\'dx_select_Document\').value, [\'\'])  # noqa\n-        # chose to migrate to Link\n-        self.browser.getControl(name=\'dx_select_Document\').value = [\'Link\']\n-        self.assertIn(\'<input type="hidden" name="Event:list" value="startDate__type__Products.Archetypes.Field.DateTimeField" />\', results)  # noqa\n-        # chose to migrate to Link\n-        self.browser.getControl(name=\'dx_select_Event\').value = [\'Link\']\n-        # run migration\n-        self.browser.getControl(name=\'form.button.Migrate\').click()\n-        results = self.browser.contents\n-        self.assertIn(\n-            \'Migration applied successfully for 1 "Document" items.\',\n-            results,\n-        )\n-        self.assertIn(\n-            \'Migration applied successfully for 1 "Event" items.\',\n-            results,\n-        )\n-        self.assertIn(\'No content to migrate.\', results)\n-        link1 = self.portal[\'doc1\']\n-        self.assertEqual(link1.portal_type, \'Link\')\n-        self.assertEqual(link1.title, u\'Ein D\\xf6cument\')\n-        self.assertEqual(link1.description, u\'S\\xf6 was\')\n-        self.assertEqual(self.portal[\'event1\'].portal_type, \'Link\')\n-        # we did not migrate the fields so lets find out if it is a real Link\n-        link1.remote_url = \'http://www.starzel.de\'\n-        view = link1()\n-        self.assertIn(u\'<h1 class="documentFirstHeading">Ein D\\xf6cument</h1>\', view)  # noqa\n-        self.assertIn(u\'The link address is:</span>\\n            <a href="http://www.starzel.de">http://www.starzel.de</a>\', view)  # noqa\n-\n-    def test_custom_migration_form_for_types_with_spaces(self):\n-        """Basic test for the custom_migration form.\n-        Field-mapping only works with javascript enabled so we migrate\n-        only the content but not the fields.\n-        """\n-        # add some at content\n-        self.portal.invokeFactory(\'News Item\', \'news1\')\n-        self.portal.invokeFactory(\'Event\', \'event1\')\n-        self.portal.event1.setTitle(u\'Ein T\xc3\xb6rmin\')\n-        self.portal.event1.setDescription(u\'W\xc3\xa4nn?\')\n-        self.portal.news1.setTitle(u\'Ein News Item\')\n-        self.portal.news1.setDescription(u\'S\xc3\xb6 was\')\n-        transaction.commit()\n-        self.browser.open(\'{0}/@@pac_installer\'.format(self.portal_url))\n-        self.browser.getControl(\'Install\').click()\n-        # open custom-migration-form\n-        self.browser.open(\'{0}/@@custom_migration\'.format(self.portal_url))\n-        results = self.browser.contents\n-        self.assertIn(\'Custom types migration control panel\', results)\n-        self.assertIn(\'<input type="hidden" name="News_space_Item:list" value="text__type__Products.Archetypes.Field.TextField" />\', results)  # noqa\n-        self.assertEqual(self.browser.getControl(name=\'dx_select_News_space_Item\').value, [\'\'])  # noqa\n-        # chose to migrate to Link\n-        self.browser.getControl(name=\'dx_select_News_space_Item\').value = [\'Link\']  # noqa\n-        self.assertIn(\'<input type="hidden" name="Event:list" value="startDate__type__Products.Archetypes.Field.DateTimeField" />\', results)  # noqa\n-        # chose to migrate to Link\n-        self.browser.getControl(name=\'dx_select_Event\').value = [\'Link\']\n-        # run migration\n-        self.browser.getControl(name=\'form.button.Migrate\').click()\n-        results = self.browser.contents\n-        self.assertIn(\n-            \'Migration applied successfully for 1 "News Item" items.\',\n-            results,\n-        )\n-        self.assertIn(\n-            \'Migration applied successfully for 1 "Event" items.\',\n-            results,\n-        )\n-        self.assertIn(\'No content to migrate.\', results)\n-        link1 = self.portal[\'news1\']\n-        self.assertEqual(link1.portal_type, \'Link\')\n-        self.assertEqual(link1.title, u\'Ein News Item\')\n-        self.assertEqual(link1.description, u\'S\\xf6 was\')\n-        self.assertEqual(self.portal[\'event1\'].portal_type, \'Link\')\n-        # we did not migrate the fields so lets find out if it is a real Link\n-        link1.remote_url = \'http://www.starzel.de\'\n-        view = link1()\n-        self.assertIn(u\'<h1 class="documentFirstHeading">Ein News Item</h1>\', view)  # noqa\n-        self.assertIn(u\'The link address is:</span>\\n            <a href="http://www.starzel.de">http://www.starzel.de</a>\', view)  # noqa\ndiff --git a/plone/app/contenttypes/tests/test_migration_topic.py b/plone/app/contenttypes/tests/test_migration_topic.py\ndeleted file mode 100644\nindex 44dcb513..00000000\n--- a/plone/app/contenttypes/tests/test_migration_topic.py\n+++ /dev/null\n@@ -1,762 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.contenttypes.testing import TEST_MIGRATION\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_TESTING  # noqa\n-import unittest\n-\n-if TEST_MIGRATION:\n-    from DateTime import DateTime\n-    from plone.app.contenttypes.behaviors.collection import ICollection\n-    from plone.app.contenttypes.migration.topics import migrate_topics\n-    from plone.app.querystring.queryparser import parseFormquery\n-    from plone.app.testing import applyProfile\n-    from plone.app.testing import login\n-    from plone.dexterity.content import Container\n-    from plone.dexterity.interfaces import IDexterityFTI\n-    from Products.CMFCore.utils import getToolByName\n-    from zope.component import queryUtility\n-    from zope.interface import implementer\n-\n-    @implementer(ICollection)\n-    class FolderishCollection(Container):\n-        """Test subclass for folderish ``Collections``.\n-        """\n-\n-\n-class MigrateTopicsIntegrationTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n-        self.request[\'URL\'] = self.portal.absolute_url()\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n-        self.portal.acl_users.userFolderAddUser(\'admin\',\n-                                                \'secret\',\n-                                                [\'Manager\'],\n-                                                [])\n-        login(self.portal, \'admin\')\n-        self.portal.portal_workflow.setDefaultChain(\n-            \'simple_publication_workflow\')\n-        self.portal.invokeFactory(\'Topic\', \'topic\', title=\'Topic\')\n-        self.portal.invokeFactory(\'Folder\', \'folder\', title=\'Folder\')\n-\n-    def run_migration(self):\n-        migrate_topics(self.portal)\n-\n-    def add_criterion(self, index, criterion, value=None):\n-        name = \'{0}_{1}\'.format(index, criterion)\n-        self.portal.topic.addCriterion(index, criterion)\n-        crit = self.portal.topic.getCriterion(name)\n-        if value is not None:\n-            crit.setValue(value)\n-        return crit\n-\n-    def test_migrate_simple_topic(self):\n-        self.assertEqual(self.portal.topic.portal_type, \'Topic\')\n-        self.assertEqual(self.portal.topic.getLayout(), \'atct_topic_view\')\n-        self.assertEqual(self.portal.topic.getLimitNumber(), False)\n-        self.assertEqual(self.portal.topic.getItemCount(), 0)\n-        self.assertEqual(self.portal.topic.getCustomViewFields(), (\'Title\',))\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        new = ICollection(self.portal.topic)\n-        self.assertEqual(self.portal.topic.portal_type, \'Collection\')\n-        self.assertEqual(self.portal.topic.getLayout(), \'listing_view\')\n-        self.assertEqual(new.sort_on, None)\n-        self.assertEqual(new.sort_reversed, None)\n-        self.assertEqual(new.limit, 1000)\n-        self.assertEqual(new.customViewFields, (\'Title\',))\n-\n-    def test_migrate_topic_fields(self):\n-        self.portal.topic.setText(\'<p>Hello</p>\')\n-        self.portal.topic.setLimitNumber(True)\n-        self.portal.topic.setItemCount(42)\n-        self.portal.topic.setCustomViewFields((\'Title\', \'Type\'))\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        new = ICollection(self.portal.topic)\n-        self.assertEqual(self.portal.topic.portal_type, \'Collection\')\n-        self.assertEqual(new.limit, 42)\n-        self.assertEqual(new.customViewFields, (\'Title\', \'Type\'))\n-        self.assertEqual(self.portal.topic.text.raw, u\'<p>Hello</p>\')\n-\n-    def test_migrate_layout(self):\n-        self.portal.topic.setLayout(\'folder_summary_view\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.getLayout(), \'summary_view\')\n-\n-    def test_migrate_customView(self):\n-        self.portal.topic.setCustomView(True)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.getLayout(), \'tabular_view\')\n-\n-    def test_migrate_nested_topic(self):\n-        self.portal.portal_types[\'Topic\'].filter_content_types = False\n-        self.portal.topic.invokeFactory(\'Topic\', \'subtopic\', title=\'Sub Topic\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        fti = queryUtility(IDexterityFTI, name=\'Collection\')\n-        # switch our a custom folderish base-class for collections\n-        # we need to use _updateProperty because this also refreshes\n-        # the content_meta_type attribute when klass has changed\n-        fti._updateProperty(\n-            \'klass\',\n-            \'plone.app.contenttypes.tests.test_migration_topic.\'\n-            \'FolderishCollection\')\n-        fti._updateProperty(\'allowed_content_types\', [\'Document\', \'Folder\'])\n-        fti._updateProperty(\'filter_content_types\', False)\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.portal_type, \'Collection\')\n-        self.assertEqual(self.portal.topic.subtopic.portal_type, \'Collection\')\n-\n-    def test_ATSimpleStringCriterion(self):\n-        self.add_criterion(\'SearchableText\', \'ATSimpleStringCriterion\', \'bar\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'SearchableText\',\n-              \'o\': \'plone.app.querystring.operation.string.contains\',\n-              \'v\': \'bar\'}]\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATSimpleStringCriterionToSelection(self):\n-        # Some string criterions really should be selection criterions.\n-        self.add_criterion(\n-            \'review_state\',\n-            \'ATSimpleStringCriterion\', \'published\'\n-        )\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'review_state\',\n-              \'o\': \'plone.app.querystring.operation.selection.any\',\n-              \'v\': \'published\'}]\n-        )\n-\n-    def test_ATDateCriteriaPast(self):\n-        # More than 5 days in the past:\n-        crit = self.add_criterion(\'created\', \'ATFriendlyDateCriteria\', 5)\n-        crit.setOperation(\'more\')\n-        crit.setDateRange(\'-\')\n-        # Less than 5 days in the past:\n-        crit = self.add_criterion(\'effective\', \'ATFriendlyDateCriteria\', 5)\n-        crit.setOperation(\'less\')\n-        crit.setDateRange(\'-\')\n-        # The next two are logically a bit weird.\n-        # More than 0 days in the past is historically interpreted as: after\n-        # today.\n-        crit = self.add_criterion(\'expires\', \'ATFriendlyDateCriteria\', 0)\n-        crit.setOperation(\'more\')\n-        crit.setDateRange(\'-\')\n-        # Less than 0 days in the past is historically interpreted as: before\n-        # today.\n-        crit = self.add_criterion(\'modified\', \'ATFriendlyDateCriteria\', 0)\n-        crit.setOperation(\'less\')\n-        crit.setDateRange(\'-\')\n-\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 4)\n-\n-        self.assertEqual(query[0][\'i\'], \'created\')\n-        self.assertEqual(\n-            query[0][\'o\'],\n-            \'plone.app.querystring.operation.date.largerThanRelativeDate\'\n-        )\n-        self.assertEqual(query[0][\'v\'], -5)\n-\n-        self.assertEqual(query[1][\'i\'], \'effective\')\n-        self.assertEqual(\n-            query[1][\'o\'],\n-            \'plone.app.querystring.operation.date.lessThanRelativeDate\'\n-        )\n-        self.assertEqual(query[1][\'v\'], -5)\n-\n-        self.assertEqual(query[2][\'i\'], \'expires\')\n-        self.assertEqual(\n-            query[2][\'o\'],\n-            \'plone.app.querystring.operation.date.afterToday\'\n-        )\n-        self.assertTrue(\'v\' not in query[2].keys())\n-\n-        self.assertEqual(query[3][\'i\'], \'modified\')\n-        self.assertEqual(\n-            query[3][\'o\'],\n-            \'plone.app.querystring.operation.date.beforeToday\'\n-        )\n-        self.assertTrue(\'v\' not in query[3].keys())\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATDateCriteriaFuture(self):\n-        # More than 5 days in the future:\n-        crit = self.add_criterion(\'created\', \'ATFriendlyDateCriteria\', 5)\n-        crit.setOperation(\'more\')\n-        crit.setDateRange(\'+\')\n-        # Less than 5 days in the future:\n-        crit = self.add_criterion(\'effective\', \'ATFriendlyDateCriteria\', 5)\n-        crit.setOperation(\'less\')\n-        crit.setDateRange(\'+\')\n-        # More than 0 days in the future: after today.\n-        crit = self.add_criterion(\'expires\', \'ATFriendlyDateCriteria\', 0)\n-        crit.setOperation(\'more\')\n-        crit.setDateRange(\'+\')\n-        # Less than 0 days in the future: before today.\n-        crit = self.add_criterion(\'modified\', \'ATFriendlyDateCriteria\', 0)\n-        crit.setOperation(\'less\')\n-        crit.setDateRange(\'+\')\n-\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 4)\n-\n-        self.assertEqual(query[0][\'i\'], \'created\')\n-        self.assertEqual(\n-            query[0][\'o\'],\n-            \'plone.app.querystring.operation.date.largerThanRelativeDate\'\n-        )\n-        self.assertEqual(query[0][\'v\'], 5)\n-\n-        self.assertEqual(query[1][\'i\'], \'effective\')\n-        self.assertEqual(\n-            query[1][\'o\'],\n-            \'plone.app.querystring.operation.date.lessThanRelativeDate\'\n-        )\n-        self.assertTrue(query[1][\'v\'], 5)\n-\n-        self.assertEqual(query[2][\'i\'], \'expires\')\n-        self.assertEqual(\n-            query[2][\'o\'],\n-            \'plone.app.querystring.operation.date.afterToday\'\n-        )\n-        self.assertTrue(\'v\' not in query[2].keys())\n-\n-        self.assertEqual(query[3][\'i\'], \'modified\')\n-        self.assertEqual(\n-            query[3][\'o\'],\n-            \'plone.app.querystring.operation.date.beforeToday\'\n-        )\n-        self.assertTrue(\'v\' not in query[3].keys())\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATDateCriteriaExactDay(self):\n-        # 5 days ago:\n-        crit = self.add_criterion(\'created\', \'ATFriendlyDateCriteria\', 5)\n-        crit.setOperation(\'within_day\')\n-        crit.setDateRange(\'-\')\n-        # 5 days from now:\n-        crit = self.add_criterion(\'effective\', \'ATFriendlyDateCriteria\', 5)\n-        crit.setOperation(\'within_day\')\n-        crit.setDateRange(\'+\')\n-        # past or future does not matter if the day is today.\n-        # today minus\n-        crit = self.add_criterion(\'expires\', \'ATFriendlyDateCriteria\', 0)\n-        crit.setOperation(\'within_day\')\n-        crit.setDateRange(\'-\')\n-        # today plus\n-        crit = self.add_criterion(\'modified\', \'ATFriendlyDateCriteria\', 0)\n-        crit.setOperation(\'within_day\')\n-        crit.setDateRange(\'+\')\n-\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        time2 = DateTime()\n-        self.assertEqual(len(query), 4)\n-\n-        self.assertEqual(query[0][\'i\'], \'created\')\n-        self.assertEqual(\n-            query[0][\'o\'],\n-            \'plone.app.querystring.operation.date.between\'\n-        )\n-        self.assertEqual(\n-            query[0][\'v\'],\n-            ((time2 - 5).earliestTime(), (time2 - 5).latestTime())\n-        )\n-\n-        self.assertEqual(query[1][\'i\'], \'effective\')\n-        self.assertEqual(\n-            query[1][\'o\'],\n-            \'plone.app.querystring.operation.date.between\'\n-        )\n-        self.assertEqual(\n-            query[1][\'v\'],\n-            ((time2 + 5).earliestTime(), (time2 + 5).latestTime())\n-        )\n-\n-        self.assertEqual(query[2][\'i\'], \'expires\')\n-        self.assertEqual(\n-            query[2][\'o\'],\n-            \'plone.app.querystring.operation.date.today\'\n-        )\n-        self.assertFalse(\'v\' in query[2].keys())\n-\n-        self.assertEqual(query[3][\'i\'], \'modified\')\n-        self.assertEqual(\n-            query[3][\'o\'],\n-            \'plone.app.querystring.operation.date.today\'\n-        )\n-        self.assertFalse(\'v\' in query[3].keys())\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATCurrentAuthorCriterion(self):\n-        self.add_criterion(\'Creator\', \'ATCurrentAuthorCriterion\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'Creator\',\n-              \'o\': \'plone.app.querystring.operation.string.currentUser\',\n-              \'v\': \'admin\'}]\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATListCriterion(self):\n-        # The new-style queries do not currently offer the possibility\n-        # to choose if the given values should be joined with \'or\' or\n-        # \'and\'.  Default is \'or\'.\n-        crit = self.add_criterion(\'Subject\', \'ATListCriterion\', (\'foo\', \'bar\'))\n-        crit.setOperator(\'or\')\n-        # Note: this could have been an ATPortalTypeCriterion too:\n-        crit = self.add_criterion(\n-            \'portal_type\',\n-            \'ATListCriterion\', (\'Document\', \'Folder\')\n-        )\n-        crit.setOperator(\'and\')\n-\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 2)\n-        self.assertEqual(query[0],\n-                         {\'i\': \'Subject\',\n-                          \'o\': \'plone.app.querystring.operation.selection.any\',\n-                          \'v\': (\'foo\', \'bar\')})\n-        self.assertEqual(query[1],\n-                         {\'i\': \'portal_type\',\n-                          \'o\': \'plone.app.querystring.operation.selection.any\',\n-                          \'v\': (\'Document\', \'Folder\')})\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATPathCriterion(self):\n-        crit = self.add_criterion(\n-            \'path\',\n-            \'ATPathCriterion\', self.portal.folder.UID())\n-        crit.setRecurse(True)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.query,\n-                         [{\'i\': \'path\',\n-                           \'o\': \'plone.app.querystring.operation.string.path\',\n-                           \'v\': self.portal.folder.UID()}])\n-        # check is the query is correct\n-        self.assertEqual(\n-            parseFormquery(self.portal, self.portal.topic.query),\n-            {\'path\': {\'query\': [\'/plone/folder\']}})\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATPathCriterionNonRecursive(self):\n-        # Topics supported non recursive search, so search at a\n-        # specific depth of 1.  At first, new Collections did not\n-        # support it.  But since plone.app.querystring 1.1.0 it works.\n-        crit = self.add_criterion(\n-            \'path\',\n-            \'ATPathCriterion\', self.portal.folder.UID()\n-        )\n-        crit.setRecurse(False)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 1)\n-        self.assertEqual(query,\n-                         [{\'i\': \'path\',\n-                           \'o\': \'plone.app.querystring.operation.string.path\',\n-                           \'v\': self.portal.folder.UID() + \'::1\'}])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATPathCriterionMultiRecursive(self):\n-        # Collections support multiple paths since\n-        # plone.app.querystring 1.2.0.\n-        login(self.portal, \'admin\')\n-        self.portal.invokeFactory(\'Folder\', \'folder2\', title=\'Folder 2\')\n-        crit = self.add_criterion(\n-            \'path\',\n-            \'ATPathCriterion\',\n-            [self.portal.folder.UID(), self.portal.folder2.UID()]\n-        )\n-        crit.setRecurse(True)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 2)\n-        self.assertEqual(query[0],\n-                         {\'i\': \'path\',\n-                          \'o\': \'plone.app.querystring.operation.string.path\',\n-                          \'v\': self.portal.folder.UID()})\n-        self.assertEqual(query[1],\n-                         {\'i\': \'path\',\n-                          \'o\': \'plone.app.querystring.operation.string.path\',\n-                          \'v\': self.portal.folder2.UID()})\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATPathCriterionMultiNonRecursive(self):\n-        # Collections support multiple paths since\n-        # plone.app.querystring 1.2.0.\n-        login(self.portal, \'admin\')\n-        self.portal.invokeFactory(\'Folder\', \'folder2\', title=\'Folder 2\')\n-        crit = self.add_criterion(\n-            \'path\',\n-            \'ATPathCriterion\',\n-            [self.portal.folder.UID(), self.portal.folder2.UID()]\n-        )\n-        crit.setRecurse(False)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 2)\n-        self.assertEqual(query[0],\n-                         {\'i\': \'path\',\n-                          \'o\': \'plone.app.querystring.operation.string.path\',\n-                          \'v\': self.portal.folder.UID() + \'::1\'})\n-        self.assertEqual(query[1],\n-                         {\'i\': \'path\',\n-                          \'o\': \'plone.app.querystring.operation.string.path\',\n-                          \'v\': self.portal.folder2.UID() + \'::1\'})\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATBooleanCriterion(self):\n-        # Note that in standard Plone the boolean criterion is only\n-        # defined for is_folderish and is_default_page.\n-        crit = self.add_criterion(\'is_folderish\', \'ATBooleanCriterion\')\n-        crit.setBool(True)\n-        crit = self.add_criterion(\'is_default_page\', \'ATBooleanCriterion\')\n-        crit.setBool(False)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 2)\n-        self.assertEqual(\n-            query[0],\n-            {\'i\': \'is_folderish\',\n-             \'o\': \'plone.app.querystring.operation.boolean.isTrue\'}\n-        )\n-        self.assertEqual(\n-            query[1],\n-            {\'i\': \'is_default_page\',\n-             \'o\': \'plone.app.querystring.operation.boolean.isFalse\'}\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATDateRangeCriteria(self):\n-        time1 = DateTime()\n-        # Days in the past:\n-        crit = self.add_criterion(\'created\', \'ATDateRangeCriterion\')\n-        crit.setStart(time1 - 5)\n-        crit.setEnd(time1 - 3)\n-        # Past and future:\n-        crit = self.add_criterion(\'effective\', \'ATDateRangeCriterion\')\n-        crit.setStart(time1 - 2)\n-        crit.setEnd(time1 + 2)\n-        # Days in the future:\n-        crit = self.add_criterion(\'expires\', \'ATDateRangeCriterion\')\n-        crit.setStart(time1 + 3)\n-        crit.setEnd(time1 + 5)\n-\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 3)\n-\n-        self.assertEqual(query[0][\'i\'], \'created\')\n-        self.assertEqual(\n-            query[0][\'o\'],\n-            \'plone.app.querystring.operation.date.between\'\n-        )\n-        self.assertEqual(query[0][\'v\'], (time1 - 5, time1 - 3))\n-\n-        self.assertEqual(query[1][\'i\'], \'effective\')\n-        self.assertEqual(\n-            query[1][\'o\'],\n-            \'plone.app.querystring.operation.date.between\'\n-        )\n-        self.assertEqual(query[1][\'v\'], (time1 - 2, time1 + 2))\n-\n-        self.assertEqual(query[2][\'i\'], \'expires\')\n-        self.assertEqual(\n-            query[2][\'o\'],\n-            \'plone.app.querystring.operation.date.between\'\n-        )\n-        self.assertEqual(query[2][\'v\'], (time1 + 3, time1 + 5))\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATPortalTypeCriterion(self):\n-        self.add_criterion(\n-            \'portal_type\',\n-            \'ATPortalTypeCriterion\', (\'Document\', \'Folder\')\n-        )\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(\n-            query,\n-            [{\'i\': \'portal_type\',\n-              \'o\': \'plone.app.querystring.operation.selection.any\',\n-              \'v\': (\'Document\', \'Folder\')}]\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATPortalTypeCriterionOfTopic(self):\n-        # We migrate Topics to Collections, so we should update\n-        # criterions that search for Topics.\n-        self.add_criterion(\n-            \'portal_type\',\n-            \'ATPortalTypeCriterion\', (\'Topic\',)\n-        )\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(\n-            query,\n-            [{\'i\': \'portal_type\',\n-              \'o\': \'plone.app.querystring.operation.selection.any\',\n-              \'v\': (\'Collection\',)}])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATSelectionCriterion(self):\n-        # The new-style queries do not currently offer the possibility\n-        # to choose if the given values should be joined with \'or\' or\n-        # \'and\'.  Default is \'or\'.\n-        crit = self.add_criterion(\n-            \'Subject\',\n-            \'ATSelectionCriterion\',\n-            (\'foo\', \'bar\')\n-        )\n-        crit.setOperator(\'or\')\n-        # Note: this could have been an ATPortalTypeCriterion too:\n-        # Note that we check that Topic is turned into Collection too.\n-        crit = self.add_criterion(\n-            \'portal_type\',\n-            \'ATSelectionCriterion\',\n-            (\'Document\', \'Topic\')\n-        )\n-        crit.setOperator(\'and\')\n-\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 2)\n-        self.assertEqual(query[0],\n-                         {\'i\': \'Subject\',\n-                          \'o\': \'plone.app.querystring.operation.selection.any\',\n-                          \'v\': (\'foo\', \'bar\')})\n-        self.assertEqual(query[1],\n-                         {\'i\': \'portal_type\',\n-                          \'o\': \'plone.app.querystring.operation.selection.any\',\n-                          \'v\': (\'Document\', \'Collection\')})\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATSelectionCriterionForTypeTitle(self):\n-        # \'portal_type\' is the object id of the FTI in portal_types.\n-        # \'Type\' is the title of that object.\n-        # For example:\n-        # - portal_type \'Document\' has Type \'Page\'.\n-        # - portal_type \'Topic\' has Type \'Collection (old)\'.\n-        # Type is not enabled as criterion index by default, so we\n-        # want to migrate to a portal_type criterion instead.\n-        self.add_criterion(\'Type\', \'ATSelectionCriterion\', (\'Page\', \'Folder\'))\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(\n-            query,\n-            [{\'i\': \'portal_type\',\n-              \'o\': \'plone.app.querystring.operation.selection.any\',\n-              \'v\': [\'Document\', \'Folder\']}])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATReferenceCriterion(self):\n-        # Note: the new criterion is disabled by default.  Also, it\n-        # needs the _referenceIs function in the plone.app.querystring\n-        # queryparser and that function is not defined.\n-        self.add_criterion(\n-            \'getRawRelatedItems\',\n-            \'ATReferenceCriterion\',\n-            self.portal.folder.UID()\n-        )\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        # TODO re-enable this check when the queryparser works.\n-        # self.assertEqual(\n-        #     self.portal.topic.query,\n-        #     [{\'i\': \'getRawRelatedItems\',\n-        #       \'o\': \'plone.app.querystring.operation.reference.is\',\n-        #       \'v\': (portal.folder.UID(),)}]\n-        # )\n-\n-        # Check that the resulting query does not give an error.\n-        # self.portal.topic.results\n-\n-    def test_ATRelativePathCriterion(self):\n-        crit = self.add_criterion(\n-            \'path\',\n-            \'ATRelativePathCriterion\'\n-        )\n-        crit.setRelativePath(\'../folder\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'path\',\n-              \'o\': \'plone.app.querystring.operation.string.relativePath\',\n-              \'v\': \'../folder\'}]\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATRelativePathCriterionNonRecursive(self):\n-        # Topics supported non recursive search, so search at a specific\n-        # depth.  New Collections do not support it.\n-        crit = self.add_criterion(\'path\', \'ATRelativePathCriterion\')\n-        crit.setRelativePath(\'../folder\')\n-        crit.setRecurse(True)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'path\',\n-              \'o\': \'plone.app.querystring.operation.string.relativePath\',\n-              \'v\': \'../folder\'}])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATSimpleIntCriterion(self):\n-        self.add_criterion(\'getObjPositionInParent\', \'ATSimpleIntCriterion\', 7)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.query,\n-                         [{\'i\': \'getObjPositionInParent\',\n-                           \'o\': \'plone.app.querystring.operation.int.is\',\n-                           \'v\': 7}])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATSimpleIntCriterionMinimum(self):\n-        crit = self.add_criterion(\n-            \'getObjPositionInParent\',\n-            \'ATSimpleIntCriterion\', 6\n-        )\n-        crit.setDirection(\'min\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'getObjPositionInParent\',\n-              \'o\': \'plone.app.querystring.operation.int.largerThan\',\n-              \'v\': 6}]\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATSimpleIntCriterionMaximum(self):\n-        crit = self.add_criterion(\n-            \'getObjPositionInParent\',\n-            \'ATSimpleIntCriterion\',\n-            5\n-        )\n-        crit.setDirection(\'max\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'getObjPositionInParent\',\n-              \'o\': \'plone.app.querystring.operation.int.lessThan\',\n-              \'v\': 5}]\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATSimpleIntCriterionBetween(self):\n-        # This is not supported.\n-        crit = self.add_criterion(\n-            \'getObjPositionInParent\',\n-            \'ATSimpleIntCriterion\',\n-            4\n-        )\n-        crit.setDirection(\'min:max\')\n-        crit.setValue2(8)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.query, [])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATSortCriterion(self):\n-        self.add_criterion(\'modified\', \'ATSortCriterion\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.sort_on, \'modified\')\n-        self.assertEqual(self.portal.topic.sort_reversed, False)\n-        self.assertEqual(self.portal.topic.query, [])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATSortCriterionReversed(self):\n-        crit = self.add_criterion(\'created\', \'ATSortCriterion\')\n-        crit.setReversed(True)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.sort_on, \'created\')\n-        self.assertEqual(self.portal.topic.sort_reversed, True)\n-        self.assertEqual(self.portal.topic.query, [])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\ndiff --git a/plone/app/contenttypes/tests/test_upgrades_migrate_to_pa_event.py b/plone/app/contenttypes/tests/test_upgrades_migrate_to_pa_event.py\ndeleted file mode 100644\nindex b494254b..00000000\n--- a/plone/app/contenttypes/tests/test_upgrades_migrate_to_pa_event.py\n+++ /dev/null\n@@ -1,123 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from datetime import datetime\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_TESTING  # noqa\n-from plone.app.contenttypes.testing import TEST_MIGRATION\n-from plone.app.contenttypes.tests.oldtypes import create1_0EventType\n-from plone.app.testing import applyProfile\n-from plone.app.testing import login\n-from plone.app.textfield.value import RichTextValue\n-from plone.event.interfaces import IEventAccessor\n-from Products.CMFCore.utils import getToolByName\n-\n-import unittest\n-\n-\n-class MigrateEventContentTypesTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING\n-\n-    def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n-        self.request[\'URL\'] = self.portal.absolute_url()\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n-        self.portal.acl_users.userFolderAddUser(\'admin\',\n-                                                \'secret\',\n-                                                [\'Manager\'],\n-                                                [])\n-        login(self.portal, \'admin\')\n-        self.portal.portal_workflow.setDefaultChain(\n-            \'simple_publication_workflow\')\n-\n-    def tearDown(self):\n-        try:\n-            applyProfile(self.portal, \'plone.app.contenttypes:uninstall\')\n-        except KeyError:\n-            pass\n-\n-    def doUpgradeStep(self, source, dest,\n-                      profile=\'plone.app.contenttypes:default\'):\n-        """Run upgrade step between 2 specified versions"""\n-        ps = getToolByName(self.portal, \'portal_setup\')\n-        upgrades = [\n-            u for u\n-            in ps.listUpgrades(profile, show_old=True)\n-            if u[\'ssource\'] == source and u[\'sdest\'] == dest\n-        ]\n-        self.assertEqual(len(upgrades), 1)\n-\n-        request = self.portal.REQUEST\n-        request.form = dict(\n-            profile_id=profile,\n-            upgrades=[upgrades[0][\'id\']],\n-        )\n-        ps.manage_doUpgrades(request=request)\n-\n-    def createOldEvent(self, container, id, start_date, end_date):\n-        """Create sample event"""\n-        old_event = container[container.invokeFactory(\n-            \'Event\',\n-            id,\n-            location=\'Newbraska\',\n-            start_date=start_date,\n-            end_date=end_date,\n-            attendees=\'Me\\r\\nYou\',\n-            event_url=\'http://woo.com\',\n-            contact_name=\'Frank\',\n-            contact_email=\'me@fra.nk\',\n-            contact_phone=\'+4412345\',\n-        )]\n-        old_event.text = RichTextValue(\n-            raw=u\'Awes\xc3\xbcme\',\n-            mimeType=\'text/plain\',\n-            outputMimeType=\'text/x-html-safe\'\n-        )\n-\n-    @unittest.skipUnless(\n-        TEST_MIGRATION,\n-        \'Migration tests require ATContentTypes\',\n-    )\n-    def test_pact_1_0_dxevent_is_migrated(self):\n-        def getNewEventDetail(obj):\n-            acc = IEventAccessor(obj)\n-            return [\n-                obj.id,\n-                [acc.start.year, acc.start.month, acc.start.day],\n-                [acc.end.year, acc.end.month, acc.end.day],\n-                acc.location,\n-                acc.attendees\n-            ]\n-\n-        # Create some 1.0 Event objects\n-        create1_0EventType(self.portal)\n-        self.portal.invokeFactory(\'Folder\', \'event-folder\')\n-        self.createOldEvent(\n-            self.portal, \'eventa\',\n-            start_date=datetime(2012, 1, 1, 15, 20),\n-            end_date=datetime(2015, 9, 2, 16, 20),\n-        )\n-        self.createOldEvent(\n-            self.portal[\'event-folder\'], \'eventb\',\n-            start_date=datetime(2013, 3, 3, 15, 20),\n-            end_date=datetime(2019, 5, 6, 16, 20),\n-        )\n-\n-        # IEventAccessor? What\'s that?\n-        with self.assertRaisesRegexp(TypeError, \'IEventAccessor\'):\n-            IEventAccessor(self.portal[\'eventa\'])\n-\n-        # Run upgrade step\n-        self.doUpgradeStep(\'1001\', \'1100\')\n-\n-        # Should be able to use IEventAccessor on events now\n-        self.assertEqual(\n-            getNewEventDetail(self.portal[\'eventa\']),\n-            [\'eventa\', [2012, 1, 1], [2015, 9, 2],\n-             u\'Newbraska\', (\'Me\', \'You\')],\n-        )\n-        self.assertEqual(\n-            getNewEventDetail(self.portal[\'event-folder\'][\'eventb\']),\n-            [\'eventb\', [2013, 3, 3], [2019, 5, 6],\n-             u\'Newbraska\', (\'Me\', \'You\')],\n-        )\ndiff --git a/plone/app/contenttypes/utils.py b/plone/app/contenttypes/utils.py\nindex 262fac81..e175c265 100644\n--- a/plone/app/contenttypes/utils.py\n+++ b/plone/app/contenttypes/utils.py\n@@ -1,4 +1,17 @@\n-# -*- coding: utf-8 -*-\n+from plone.dexterity.interfaces import IDexterityFTI\n+from zope.component import queryUtility\n+from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base\n+from zope.interface import alsoProvides\n+from plone.folder.interfaces import IOrdering\n+from Products.CMFCore.utils import getToolByName\n+from zExceptions import NotFound\n+from plone.dexterity.interfaces import IDexterityContent\n+\n+import importlib\n+import logging\n+\n+logger = logging.getLogger(__name__)\n+\n \n DEFAULT_TYPES = [\n     \'Collection\',\n@@ -42,3 +55,85 @@ def replace_link_variables_by_paths(context, url):\n def _replace_variable_by_path(url, variable, obj):\n     path = \'/\'.join(obj.getPhysicalPath())\n     return url.replace(variable, path)\n+\n+\n+def get_old_class_name_string(obj):\n+    """Returns the current class name string."""\n+    return \'{0}.{1}\'.format(obj.__module__, obj.__class__.__name__)\n+\n+\n+def get_portal_type_name_string(obj):\n+    """Returns the klass-attribute of the fti."""\n+    fti = queryUtility(IDexterityFTI, name=obj.portal_type)\n+    print(fti.klass)\n+    print(fti.id)\n+    if not fti:\n+        return False\n+    return fti.klass\n+\n+\n+def migrate_base_class_to_new_class(obj,\n+                                    indexes=None,\n+                                    old_class_name=\'\',\n+                                    new_class_name=\'\',\n+                                    migrate_to_folderish=False,\n+                                    ):\n+    if indexes is None:\n+        indexes = [\'is_folderish\', \'object_provides\']\n+    if not old_class_name:\n+        old_class_name = get_old_class_name_string(obj)\n+    if not new_class_name:\n+        new_class_name = get_portal_type_name_string(obj)\n+        if not new_class_name:\n+            logger.warning(\n+                \'The type {0} has no fti!\'.format(obj.portal_type))\n+            return False\n+\n+    was_item = not isinstance(obj, BTreeFolder2Base)\n+    if old_class_name != new_class_name:\n+        obj_id = obj.getId()\n+        module_name, class_name = new_class_name.rsplit(\'.\', 1)\n+        module = importlib.import_module(module_name)\n+        new_class = getattr(module, class_name)\n+\n+        # update obj class\n+        parent = obj.__parent__\n+        parent._delOb(obj_id)\n+        obj.__class__ = new_class\n+        parent._setOb(obj_id, obj)\n+\n+    is_container = isinstance(obj, BTreeFolder2Base)\n+\n+    if was_item and is_container or migrate_to_folderish and is_container:\n+        alsoProvides(obj, IOrdering)\n+        #  If Itemish becomes Folderish we have to update obj _tree\n+        BTreeFolder2Base._initBTrees(obj)\n+\n+    # reindex\n+    obj.reindexObject(indexes)\n+\n+    return True\n+\n+\n+def list_of_objects_with_changed_base_class(context):\n+    catalog = getToolByName(context, \'portal_catalog\')\n+    for brain in catalog(object_provides=IDexterityContent.__identifier__):\n+        try:\n+            obj = brain.getObject()\n+        except (KeyError, NotFound):\n+            logger.warn(\'Object {0} not found\'.format(brain.getPath()))\n+            continue\n+        if get_portal_type_name_string(obj) != get_old_class_name_string(obj):\n+            yield obj\n+\n+\n+def list_of_changed_base_class_names(context):\n+    """Returns list of class names that are not longer in portal_types."""\n+    changed_base_class_names = {}\n+    for obj in list_of_objects_with_changed_base_class(context):\n+        changed_base_class_name = get_old_class_name_string(obj)\n+        if changed_base_class_name not in changed_base_class_names:\n+            changed_base_class_names[changed_base_class_name] = 1\n+        else:\n+            changed_base_class_names[changed_base_class_name] += 1\n+    return changed_base_class_names\ndiff --git a/setup.py b/setup.py\nindex e318af9e..99c454cf 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -60,7 +60,6 @@ def read(*rnames):\n         "plone.behavior >= 1.3.0",\n         "pytz",\n         "plone.app.z3cform>=1.1.0.dev0",\n-        "six",\n         "zope.deprecation",\n     ],\n     extras_require={\n@@ -69,14 +68,5 @@ def read(*rnames):\n             "plone.app.robotframework [debug] > 0.9.8",  # create image and file content for Image, File and News Item if not given.  # noqa\n             "plone.app.testing [robot] >= 4.2.4",  # we need ROBOT_TEST_LEVEL\n         ],\n-        "archetypes": [\n-            "archetypes.schemaextender",\n-            "Products.ATContentTypes",\n-            "Products.contentmigration >= 2.1.8.dev0",\n-            "plone.app.referenceablebehavior",\n-        ],\n-        "atrefs": [\n-            "plone.app.referenceablebehavior",\n-        ],\n     },\n )\n'

Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2021-10-30T18:22:10+02:00
Author: Peter Holzer (agitator) <peter.holzer@agitator.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/6c0d82c1a1a03ee39510b612969be69af716064c

add news

Files changed:
A news/620.breaking

b'diff --git a/news/620.breaking b/news/620.breaking\nnew file mode 100644\nindex 00000000..67b33099\n--- /dev/null\n+++ b/news/620.breaking\n@@ -0,0 +1,2 @@\n+Remove atcontenttypes dependencies, migration, keep BaseClassMigratorForm.\n+[agitator]\n\\ No newline at end of file\n'

Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2021-10-31T19:09:52+01:00
Author: Peter Holzer (agitator) <peter.holzer@agitator.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/37f2f76fce37d9593082af064766a78ac6a56709

remove compatibility section, since it's core anyway

Files changed:
M docs/README.rst

b'diff --git a/docs/README.rst b/docs/README.rst\nindex 646a4ed3..c734665e 100644\n--- a/docs/README.rst\n+++ b/docs/README.rst\n@@ -36,14 +36,6 @@ It contains the following types:\n These types are editable and extendable through-the-web and you can add or remove fields and behaviors using the control-panel "Dexterity Content Types" (``/@@dexterity-types``).\n \n \n-Compatibility\n--------------\n-\n-Version 3 is build for Plone 6 only.\n-\n-Check previous major releases if you need to support older versions of Plone.\n-\n-\n Installation\n ------------\n \n'

Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2021-11-02T12:09:44+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.contenttypes/commit/b99bd34098b2d4b0fcdf02fd753cb238bbf83b47

Merge pull request #620 from plone/agttr-at-removal

Remove atcontenttypes dependencies and migration and keep BaseClassMigratorForm

Files changed:
A news/620.breaking
A plone/app/contenttypes/browser/migration.py
M docs/README.rst
M plone/app/contenttypes/browser/configure.zcml
M plone/app/contenttypes/configure.zcml
M plone/app/contenttypes/tests/test_content_profile.py
M plone/app/contenttypes/utils.py
M setup.py
D plone/app/contenttypes/migration/__init__.py
D plone/app/contenttypes/migration/atct_migrator.pt
D plone/app/contenttypes/migration/atct_migrator_results.pt
D plone/app/contenttypes/migration/browser.py
D plone/app/contenttypes/migration/configure.zcml
D plone/app/contenttypes/migration/custom_migration.pt
D plone/app/contenttypes/migration/custom_migration.py
D plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
D plone/app/contenttypes/migration/dxmigration.py
D plone/app/contenttypes/migration/field_migrators.py
D plone/app/contenttypes/migration/migration.py
D plone/app/contenttypes/migration/migrator.css
D plone/app/contenttypes/migration/pac_installer.pt
D plone/app/contenttypes/migration/patches.py
D plone/app/contenttypes/migration/topics.py
D plone/app/contenttypes/migration/utils.py
D plone/app/contenttypes/migration/vocabularies.py
D plone/app/contenttypes/tests/test_migration.py
D plone/app/contenttypes/tests/test_migration_browser.py
D plone/app/contenttypes/tests/test_migration_custom.py
D plone/app/contenttypes/tests/test_migration_topic.py
D plone/app/contenttypes/tests/test_upgrades_migrate_to_pa_event.py

b'diff --git a/docs/README.rst b/docs/README.rst\nindex 7a548698..c734665e 100644\n--- a/docs/README.rst\n+++ b/docs/README.rst\n@@ -20,7 +20,7 @@ plone.app.contenttypes documentation\n Introduction\n ------------\n \n-plone.app.contenttypes provides default content types for Plone based on Dexterity. It replaces ``Products.ATContentTypes`` and provides the default-types in Plone 5. It can be used as an add-on in Plone 4.x.\n+plone.app.contenttypes provides default content types for Plone based on Dexterity.\n \n It contains the following types:\n \n@@ -33,383 +33,13 @@ It contains the following types:\n * Link\n * News Item\n \n-The main difference from a users perspective is that these types are editable and extendable through-the-web. This means you can add or remove fields and behaviors using the control-panel "Dexterity Content Types" (``/@@dexterity-types``).\n-\n-**Warning: Using plone.app.contenttypes on a site with existing Archetypes-based content requires migrating the sites content. Please see the chapter "Migration".**\n-\n-\n-Compatibility\n--------------\n-\n-The versions 1.2.x (build from the master-branch) are used in Plone 5.\n-\n-Version 1.1b5 and later are tested with Plone 4.3.x. The versions build from the branch 1.1.x will stay compatible with Plone 4.3.x.\n-\n-For support of Plone 4.1 and 4.2 please use versions 1.0.x. Please note that they do not provide the full functionality.\n+These types are editable and extendable through-the-web and you can add or remove fields and behaviors using the control-panel "Dexterity Content Types" (``/@@dexterity-types``).\n \n \n Installation\n ------------\n \n-This package is included in Plone 5 and does not need installation.\n-\n-To use plone.app.contenttypes in Plone 4.x add this line in the eggs section of your ``buildout.cfg``\n-\n-.. code:: ini\n-\n-    eggs =\n-        ...\n-        plone.app.contenttypes\n-\n-If you have a Plone site with mixed Archetypes and Dexterity content use the extra requirement ``atrefs``.\n-\n-.. code:: ini\n-\n-    eggs =\n-        ...\n-        plone.app.contenttypes [atrefs]\n-\n-This will also install the package `plone.app.referenceablebehavior <https://pypi.python.org/pypi/plone.app.referenceablebehavior>`_ that allows you to reference dexterity-based content from archetypes-based content. You will have to enable the behavior ``plone.app.referenceablebehavior.referenceable.IReferenceable`` for all types that need to be referenced by Archetypes-content.\n-\n-\n-What happens to existing content?\n----------------------------------\n-\n-If you install plone.app.contenttypes in a existing site all Archetypes-based content of the default types still exists and can be viewed but can\'t be edited. On installation plone.app.contenttypes removes the type-definitions for the old default-types like this:\n-\n-.. code:: xml\n-\n-    <object name="Document" remove="True" />\n-\n-They are then replaced by new Definitions:\n-\n-.. code:: xml\n-\n-    <object meta_type="Dexterity FTI" name="Document" />\n-\n-To make the existing content editable again you need to migrate it to Dexterity (please see the section on migration) or uninstall plone.app.contenttypes (see the section on uninstalling).\n-\n-Archetypes-based content provided by add-ons (e.g. Products.PloneFormGen) will still work since only the default-types are replaced.\n-\n-If you install plone.app.contenttypes on a fresh site (i.e. when no content has been edited or added) the usual default-content (Events, News, Members...) will be created as dexterity-content.\n-\n-\n-Uninstalling\n-------------\n-\n-Uninstalling the default-types is not officially supported in Plone 5. If you really want to switch back to Archetypes-based types you have to to the following:\n-\n-* Go to the ZMI\n-* In portal_types delete the default-types\n-* In portal_setup navigate to the tab \'import\', select the profile \'Archetypes Content Types for Plone\' and install all steps including dependencies.\n-\n-Any content you created based on plone.app.contenttypes will no longer be editable until you reinstall plone.app.contenttypes.\n-\n-\n-Dependencies\n-------------\n-\n-* ``plone.app.dexterity >= 2.0.7``. Dexterity is shipped with Plone 4.3.x. Version pins for Dexterity are included in Plone 4.2.x. For Plone 4.1.x you need to pin the right version for Dexterity in your buildout. See `Installing Dexterity on older versions of Plone <http://docs.plone.org/external/plone.app.dexterity/docs/install.html#installing-dexterity-on-older-versions-of-plone>`_.\n-\n-* ``plone.dexterity >= 2.2.1``. Olders version of plone.dexterity break the rss-views because plone.app.contenttypes uses behaviors for the richtext-fields.\n-\n-* ``plone.app.event >= 1.1.4``. This provides the behaviors used for the event-type.\n-\n-* ``plone.app.portlets >= 2.5a1``. In older version the event-portlet will not work with the new event-type.\n-\n-These are the version-pins for Plone 4.3.4:\n-\n-.. code:: ini\n-\n-    [buildout]\n-    versions = versions\n-\n-    [versions]\n-    plone.app.event = 1.1.4\n-\n-Plone 4.3.3 also needs ``plone.app.portlets = 2.5.2``\n-\n-Plone-versions before 4.3.3 need to pin more packages:\n-\n-.. code:: ini\n-\n-    [buildout]\n-    versions = versions\n-\n-    [versions]\n-    plone.dexterity = 2.2.1\n-    plone.app.dexterity = 2.0.11\n-    plone.schemaeditor = 1.3.5\n-    plone.app.event = 1.1b1\n-    plone.app.portlets = 2.5.1\n-\n-For migrations to work you need at least ``Products.contentmigration = 2.1.9`` and ``plone.app.intid`` (part of Plone since Plone 4.1.0).\n-\n-\n-Migration\n----------\n-\n-\n-Migrating the default-types\n-^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-To migrate your existing content from Archetypes to Dexterity use the form at ``/@@atct_migrator``.\n-\n-\n-Migrating Archetypes-based default-types content to plone.app.contenttypes\n-``````````````````````````````````````````````````````````````````````````\n-\n-`plone.app.contenttypes <https://pypi.python.org/pypi/plone.app.contenttypes/>`_ can migrate the following archetypes-based default types:\n-\n-* Document\n-* Event\n-* File\n-* Folder\n-* Image\n-* Link\n-* News Item\n-* Collection\n-* Topic (old Collections)\n-\n-The following non-default types will also be migrated:\n-\n-* The AT-based Event-type provided by plone.app.event\n-* The DX-based Event-type provided by plone.app.event\n-* The Event-type provided by plone.app.contenttypes until version 1.0\n-* News Items with blobs (provided by https://github.com/plone/plone.app.blob/pull/2)\n-* Files and Images without blobs\n-\n-The migration tries to keep most features (including portlets, comments, contentrules, local roles and local workflows).\n-\n-**Warning:** Versions of content are not migrated. During migration you will lose all old revisions.\n-\n-\n-Migrating only certain types\n-````````````````````````````\n-\n-There is also a view ``/@@pac_installer`` that allows you to install plone.app.contenttypes without replacing those archetypes-types with the dexterity-types of which there are existing objects in the site. Afterwards it redirects to the migration-form and only the types that you chose to migrate are installed. This allows you to keep certain types as archetypes while migrating others to dexterity (for example if you did heavy customizations of these types and do not have the time to reimplement these features in dexterity).\n-\n-\n-Migrating Topics\n-````````````````\n-\n-Topics are migrated to Collections. However, the old type Topic had support for Subtopics, a feature that does not exit in Collections. Subtopics are nested Topics that inherited search terms from their parents. Since Collections are not folderish (i.e. they cannot contain content) Subtopics cannot be migrated unless Collections are made folderish (i.e. that they can contain content). Also the feature that search terms can be inherited from parents does not exist for Collections.\n-\n-The migration-form will warn you if you have subtopics in your site and your Collections are not folderish. You then have several options:\n-\n-1. You can delete all Subtopics before migrating and achieve their functionality in another way (e.g. using eea.facetednavigation).\n-2. You can choose to not migrate Topics by not selecting them. This will keep your old Topics functional. You can still add new Collections.\n-3. You can modify Collections to be folderish or create your own folderish content-type.   That type would need a base-class that inherits from ``plone.dexterity.content.Container`` instead of ``plone.dexterity.content.Item``:\n-\n-   .. code-block:: python\n-\n-      from plone.app.contenttypes.behaviors.collection import ICollection\n-      from plone.dexterity.content import Container\n-      from zope.interface import implementer\n-\n-      @implementer(ICollection)\n-      class FolderishCollection(Container):\n-          pass\n-\n-   You can either use a new Collection type or simply modify the default type to use this new base-class by overriding the klass-attribute of the default Collection. To override add a ``Collection.xml`` in your own package:\n-\n-   .. code-block:: xml\n-\n-      <?xml version="1.0"?>\n-      <object name="Collection" meta_type="Dexterity FTI">\n-       <property name="klass">my.package.content.FolderishCollection</property>\n-      </object>\n-\n-   If you really need it you could add the functionality to inherit search terms to your own folderish Collections by extending the behavior like in the example at https://github.com/plone/plone.app.contenttypes/commit/366cc1a911c81954645ec6aabce925df4a297c63\n-\n-\n-Migrating content that is translated with LinguaPlone\n-`````````````````````````````````````````````````````\n-\n-Since LinguaPlone does not support Dexterity you need to migrate from LinguaPlone to plone.app.multilingual (http://pypi.python.org/pypi/plone.app.multilingual). The migration from Products.LinguaPlone to plone.app.multilingual should happen **before** the migration from Archetypes to plone.app.contenttypes. For details on the migration see--\n-http://pypi.python.org/pypi/plone.app.multilingual#linguaplone-migration\n-\n-\n-Migrating default-content that was extended with archetypes.schemaextender\n-``````````````````````````````````````````````````````````````````````````\n-\n-\n-The migration-form warns you if any of your old types were extended with additional fields using `archetypes.schemaextender   <https://pypi.python.org/pypi/archetypes.schemaextender/>`_. The data contained in these fields will be lost during migration (with the exception of images added with collective.contentleadimage).\n-\n-To keep the data you would need to write a custom migration for your types dexterity-behaviors for the functionality provided by the schemaextenders. This is an advanced development task and beyond the scope of this documentation.\n-\n-\n-Migrating images created with collective.contentleadimage\n-`````````````````````````````````````````````````````````\n-\n-`collective.contentleadimage <https://pypi.python.org/pypi/collective.contentleadimage/>`_ was a popular addon that allows you to add images to any content in your site by extending the default types. To make sure these images are kept during migration you have to enable the behavior "Lead Image" on all those types where you want to migrate images added using collective.contentleadimage.\n-\n-The old types that use leadimages are listed in the navigation-form with the comment *"extended fields: \'leadImage\', \'leadImage_caption\'"*. The migration-form informs you which new types have the behavior enabled and which do not. Depending on the way you installed plone.app.contenttypes you might have to first install these types by (re-)installing plone.app.contenttypes.\n-\n-\n-Migrating in code (e.g. in a upgrade-step)\n-``````````````````````````````````````````\n-\n-You can run the migration in your own code by using the view `migrate_from_atct`. Here is an example of an upgrade-step that migrates all default content-types.\n-\n-.. code-block:: python\n-\n-    def migrate_to_pac(setup):\n-      portal = api.portal.get()\n-      request = getRequest()\n-      pac_migration = api.content.get_view(\'migrate_from_atct\', portal, request)\n-      pac_migration(\n-          migrate=True,\n-          content_types=\'all\',\n-          migrate_schemaextended_content=True,\n-          reindex_catalog=False)\n-\n-With `content_types` you can also pass a list of types to be migrated. Make sure to use the key from the dictionary `plone.app.contenttypes.migration.vocabularies.ATCT_LIST` to identify the types.\n-\n-\n-Migrating custom content\n-^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-During migrations of the default types any custom content-types will not be migrated and will continue to work as expected.\n-\n-\n-Using the migration-form to migrate custom content\n-``````````````````````````````````````````````````\n-\n-To help you migrating these types to Dexterity plone.app.contenttypes contains a migration form (``/@@custom_migration``) that allows you to migrate any (custom or default) Archetypes-type to any (custom or default) Dexterity-type. The only requirement is that the target-type (the Dexterity-type you want to migrate to) has to exist and that the class of the old type is still present. It makes no difference if the type you are migrating from is still registered in portal_types or is already removed or replaced by a dexterity-version using the same name.\n-\n-In the form ``/@@custom_migration`` you can select a Dexterity-type for any Archetypes-types that exists in the portal. You can then map the source-types fields to the targets fields. You can also choose to ignore fields. You have to take care that the values can be migrated (since there is no validation for that), e.g. it would make no sense to migrate a ImageField to a TextField. There are build-in methods for most field-types, custom or rarely used fields might not migrate properly (you can create a issue if you miss a migration that is not yet supported).\n-\n-After you map the fields you can test the configuration. During a test one item will be test-migrated and Plone checks if the migrated item will be accessible without throwing a errors. After the test any changes will be rolled back.\n-\n-Migrating custom types in your own code\n-```````````````````````````````````````\n-\n-It is recommended that you reuse the migration-code provided by plone.app.contenttypes in ``plone.app.contenttypes.migration.migration.migrateCustomAT`` for custom migrations.\n-\n-To do this you have to simply pass a mapping of source- to target-fields to a migration-method for each type.\n-\n-..  code-block:: python\n-\n-\n-    from plone.app.contenttypes.migration.migration import migrateCustomAT\n-\n-    def my_custom_migration():\n-        fields_mapping = (\n-                {\'AT_field_name\': \'some_field\',\n-                 \'DX_field_name\': \'description\',\n-                 },\n-\n-                # Migrate AT imagefield to DX imagefield using the mapping in\n-                # plone.app.contenttypes.migration.field_migrators.FIELDS_MAPPING\n-                {\'AT_field_name\': \'some_atimage\',\n-                 \'DX_field_name\': \'some_dximage\',\n-                 \'DX_field_type\': \'NamedBlobImage\',\n-                 },\n-        )\n-        migrateCustomAT(\n-            fields_mapping,\n-            src_type=\'SomeATType\',\n-            dst_type=\'SomeDXType\')\n-\n-A field-dict without a key ``DX_field_type`` from one of the migrators in ``plone.app.contenttypes.migration.field_migrators.FIELDS_MAPPING`` will always use ``plone.app.contenttypes.migration.field_migrators.migrate_simplefield`` as its migration-method. That can migrate most field-types where the value does not have to change (e.g. strings, lists, tuples, dicts etc.).\n-\n-``plone.app.contenttypes.migration.field_migrators`` has special field migrators for the following field-types: ``RichText``, ``NamedBlobFile``, ``NamedBlobImage``, ``Datetime``, ``Date``. They transform values from the Archetypes-version of such fields to their Dexterity counterparts.\n-\n-\n-Custom field-migrators\n-``````````````````````\n-\n-If you use rare or custom fields or want to apply special transforms to your data while migrating you can pass custom methods as ``field_migrator`` with the fields_mapping. This way you can migrate fields that are usually not migrateable.\n-\n-Here is an example where this method is used to migrate a Richtext-Field into a Tuple-Field by passing the custom field-migrator ``some_field_migrator``. In such a custom migrator you can do just about anything you wish.\n-\n-\n-..  code-block:: python\n-\n-    from plone.app.contenttypes.migration.migration import migrateCustomAT\n-\n-\n-    def some_field_migrator(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-        """A simple example that transforms pipe-delimited richtext to a tuple.\n-        """\n-        field = src_obj.getField(src_fieldname)\n-        at_value = field.get(src_obj)\n-        at_value = at_value.replace(\'<p>\', \'\').replace(\'</p>\', \'\')\n-        dx_value = [safe_unicode(i) for i in at_value.split(\'|\')]\n-        setattr(dst_obj, dst_fieldname, tuple(dx_value))\n-\n-\n-    def my_custom_migration():\n-        """\n-        """\n-        fields_mapping = (\n-                # Migrate using our custom migrator\n-                {\'AT_field_name\': \'some_richtext_field\',\n-                 \'DX_field_name\': \'some_tuple_field\',\n-                 \'field_migrator\': some_field_migrator},\n-        )\n-        migrateCustomAT(\n-            fields_mapping,\n-            src_type=\'SomeATType\',\n-            dst_type=\'SomeDXType\')\n-\n-Alternatively you could also extends the mapping from ``plone.app.contenttypes.migration.field_migrators.FIELDS_MAPPING`` to add new or replace existing migrators for specific field-types.\n-\n-\n-Migrating from old versions of plone.app.contenttypes\n-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-Before version 1.0a2 the content-items did not implement marker-interfaces. They will break in newer versions since the views are now registered for these interfaces (e.g. ``plone.app.contenttypes.interfaces.IDocument``). To fix this you can call the view ``/@@fix_base_classes`` on your site-root.\n-\n-Since plone.app.contenttypes 1.1a1, the Collection type uses the new Collection behavior and the Event type utilizes behaviors from `plone.app.event <http://pypi.python.org/pypi/plone.app.event>`_. In order to upgrade:\n-\n-1. First run the default profile (``plone.app.contenttypes:default``) or reinstall plone.app.contenttypes\n-2. Then run the upgrade steps.\n-\n-\n-\n-Widgets\n--------\n-\n-When used in Plone 4.x plone.app.contenttypes uses the default z3c.form widgets. All widgets work as they used to with Archetypes except for the keywords-widget for which a simple linesfield is used. Replacing that with a nicer implementation is explained below.\n-\n-It is also possible to use ``plone.app.widgets`` to switch to the widgets that are used in Plone 5.\n-\n-\n-How to override widgets\n-^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-To override the default keywords-widgets with a nicer widget you can use the package `collective.z3cform.widgets <https://pypi.python.org/pypi/collective.z3cform.widgets>`_.\n-\n-Add ``collective.z3cform.widgets`` to your ``buildout`` and in your own package register the override in your ``configure.zcml``:\n-\n-.. code:: xml\n-\n-    <adapter factory=".subjects.SubjectsFieldWidget" />\n-\n-Then add a file ``subjects.py``\n-\n-.. code:: python\n-\n-    # -*- coding: UTF-8 -*-\n-    from collective.z3cform.widgets.token_input_widget import TokenInputFieldWidget\n-    from plone.app.dexterity.behaviors.metadata import ICategorization\n-    from plone.app.z3cform.interfaces import IPloneFormLayer\n-    from z3c.form.interfaces import IFieldWidget\n-    from z3c.form.util import getSpecification\n-    from z3c.form.widget import FieldWidget\n-    from zope.component import adapter\n-    from zope.interface import implementer\n-\n-\n-    @adapter(getSpecification(ICategorization[\'subjects\']), IPloneFormLayer)\n-    @implementer(IFieldWidget)\n-    def SubjectsFieldWidget(field, request):\n-        widget = FieldWidget(field, TokenInputFieldWidget(field, request))\n-        return widget\n-\n-Once you install ``collective.z3cform.widgets`` in the quickinstaller, the new widget will then be used for all types.\n+This package is included in Plone 6 and does not need installation.\n \n \n Information for Addon-Developers\n@@ -418,43 +48,12 @@ Information for Addon-Developers\n Design decisions\n ^^^^^^^^^^^^^^^^\n \n-Schemata that are defined in XML-files using ``plone.supermodel`` allow editing those types\' schemata through the web. \n-This is the case for the default File, Image and Link content types. \n+Schemata that are defined in XML-files using ``plone.supermodel`` allow editing those types\' schemata through the web.\n+This is the case for the default File, Image and Link content types.\n Schemata coming from behaviors, on the other hand, are not editable through the web.\n The Document, News Item, Folder and Event default types, for example, have no schemata of their own at all, all their fields are provided by behaviors.\n \n \n-Installation as a dependency from another product\n-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-If you want to add plone.app.contenttypes as a dependency from another products use the profile ``plone-content`` in your ``metadata.xml`` to have Plone populate a new site with DX-based default-content.\n-\n-.. code:: xml\n-\n-    <metadata>\n-      <version>1</version>\n-        <dependencies>\n-            <dependency>profile-plone.app.contenttypes:plone-content</dependency>\n-        </dependencies>\n-    </metadata>\n-\n-If you use the profile ``default`` then the default-content in new sites will still be Archetypes-based. You\'ll then have to migrate that content using the migration-form ``@@atct_migrator`` or delete it by hand.\n-\n-\n-Using folderish types\n-^^^^^^^^^^^^^^^^^^^^^\n-\n-At some point all default types will probably be folderish. If you want the default types to be folderish before that happens please look at https://pypi.python.org/pypi/collective.folderishtypes.\n-\n-\n-Changing the base class for existing objects\n-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-If you changed the base-class of existing types (e.g. because you changed them to be folderish) you also need to upgrade the base-class of existing objects. You can use the following form for this: ``@@base_class_migrator_form``.\n-\n-This form lets you select classes to be updated and shows the number of objects for each class. This form can be used to change the base-class of any dexterity-types instances. The migration will also transform itemish content to folderish content if the new class is folderish. You might want to use the method ``plone.app.contenttypes.migration.dxmigration.migrate_base_class_to_new_class`` in your own upgrade-steps.\n-\n-\n Extending the types\n ^^^^^^^^^^^^^^^^^^^\n \n@@ -530,52 +129,20 @@ For more complex features you should always consider create custom behaviors and\n For more information on custom dexterity-types and custom behaviors please read the `dexterity documentation <http://docs.plone.org/external/plone.app.dexterity/docs/>`_.\n \n \n-Differences to Products.ATContentTypes\n---------------------------------------\n-\n-- The image of the News Item is not a field on the contenttype but a behavior that can add a image to any contenttypes (similar to http://pypi.python.org/pypi/collective.contentleadimage)\n-- All richtext-fields are also provided by a reuseable behavior.\n-- The functionality to transform (rotate and flip) images has been removed.\n-- There is no more field ``Location``. If you need georeferenceable consider using ``collective.geo.behaviour``\n-- The link on the image of the newsitem triggers an overlay\n-- The link-type now allows the of the variables ``${navigation_root_url}`` and ``${portal_url}`` to construct relative urls.\n-- The ``getQuery()`` function now returns a list of dict instead of a list of CatalogContentListingObject;\n-  use of ``getRawQuery()`` is deprecated.\n-- The views for Folders and Collections changed their names and now share a common implementation (since version 1.2a8):\n-\n-  - ``folder_listing_view`` (Folders) and ``collection_view`` (Collections) -> ``listing_view`` (Folders and Collections)\n-  - ``folder_summary_view`` (Folders) and ``summary_view`` (Collections) -> ``summary_view`` (Folders and Collections)\n-  - ``folder_tabular_view`` (Folders) and ``tabular_view`` (Collections) -> ``tabular_view`` (Folders and Collections)\n-  - ``folder_full_view`` (Folders) and ``all_content`` (Collections) -> ``full_view`` (Folders and Collections)\n-  - ``atct_album_view`` (Folders) and ``thumbnail_view`` (Collections) -> ``album_view`` (Folders and Collections)\n-\n-\n-\n-Toubleshooting\n---------------\n-\n-Please report issues in the bugtracker at https://github.com/plone/plone.app.contenttypes/issues.\n-\n-ValueError on installing\n-^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-When you try to install plone.app.contenttypes < 1.1a1 in a existing site you might get the following error::\n+Changing the base class for existing objects\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-      (...)\n-      Module Products.GenericSetup.utils, line 509, in _importBody\n-      Module Products.CMFCore.exportimport.typeinfo, line 60, in _importNode\n-      Module Products.GenericSetup.utils, line 730, in _initProperties\n-    ValueError: undefined property \'schema\'\n+If you changed the base-class of existing types (e.g. because you changed them to be folderish) you also need to upgrade the base-class of existing objects. You can use the following form for this: ``@@base_class_migrator_form``.\n \n-Before installing plone.app.contenttypes you have to reinstall plone.app.collection to update collections to the version that uses Dexterity.\n+This form lets you select classes to be updated and shows the number of objects for each class. This form can be used to change the base-class of any dexterity-types instances. The migration will also transform itemish content to folderish content if the new class is folderish. You might want to use the method ``plone.app.contenttypes.migration.dxmigration.migrate_base_class_to_new_class`` in your own upgrade-steps.\n \n \n-Branches\n---------\n+Source Code\n+===========\n \n-The master-branch supports Plone 5 only. From this 1.2.x-releases will be cut.\n+Contributors please read the document `Process for Plone core\'s development <https://docs.plone.org/develop/coredev/docs/index.html>`_\n \n-The 1.1.x-branch supports Plone 4.3.x. From this 1.1.x-releases will be cut.\n+Sources are at the `Plone code repository hosted at Github <https://github.com/plone/plone.app.contenttypes>`_.\n \n \n License\n@@ -590,7 +157,7 @@ Contributors\n * Philip Bauer <bauer@starzel.de>\n * Michael Mulich <michael.mulich@gmail.com>\n * Timo Stollenwerk <contact@timostollenwerk.net>\n-* Peter Holzer <hpeter@agitator.com>\n+* Peter Holzer <peter.holzer@agitator.com>\n * Patrick Gerken <gerken@starzel.de>\n * Steffen Lindner <lindner@starzel.de>\n * Daniel Widerin <daniel@widerin.net>\ndiff --git a/news/620.breaking b/news/620.breaking\nnew file mode 100644\nindex 00000000..67b33099\n--- /dev/null\n+++ b/news/620.breaking\n@@ -0,0 +1,2 @@\n+Remove atcontenttypes dependencies, migration, keep BaseClassMigratorForm.\n+[agitator]\n\\ No newline at end of file\ndiff --git a/plone/app/contenttypes/browser/configure.zcml b/plone/app/contenttypes/browser/configure.zcml\nindex 519254d4..35af72c9 100644\n--- a/plone/app/contenttypes/browser/configure.zcml\n+++ b/plone/app/contenttypes/browser/configure.zcml\n@@ -246,4 +246,17 @@\n     <browser:page name="thumbnail_view" template="templates/listing_album.pt"/>\n   </browser:pages>\n \n+  <utility\n+      factory=".migration.ChangedBaseClasses"\n+      name="plone.app.contenttypes.migration.changed_base_classes"\n+      provides="zope.schema.interfaces.IVocabularyFactory" />\n+\n+  <browser:page\n+    name="base_class_migrator_form"\n+    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+    class=".migration.BaseClassMigrator"\n+    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"\n+    permission="cmf.ManagePortal"\n+    />\n+\n </configure>\ndiff --git a/plone/app/contenttypes/browser/migration.py b/plone/app/contenttypes/browser/migration.py\nnew file mode 100644\nindex 00000000..3576b931\n--- /dev/null\n+++ b/plone/app/contenttypes/browser/migration.py\n@@ -0,0 +1,128 @@\n+from plone.app.contenttypes.content import Document\n+from plone.app.contenttypes.content import File\n+from plone.app.contenttypes.content import Folder\n+from plone.app.contenttypes.content import Image\n+from plone.app.contenttypes.content import Link\n+from plone.app.contenttypes.content import NewsItem\n+from plone.app.contenttypes.utils import DEFAULT_TYPES\n+from plone.app.contenttypes.utils import get_old_class_name_string\n+from plone.app.contenttypes.utils import migrate_base_class_to_new_class\n+from plone.app.contenttypes.utils import list_of_changed_base_class_names\n+from plone.browserlayer.interfaces import ILocalBrowserLayerType\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.dexterity.interfaces import IDexterityFTI\n+from plone.z3cform.layout import wrap_form\n+from Products.CMFCore.utils import getToolByName\n+from Products.CMFPlone import PloneMessageFactory as _\n+from Products.CMFPlone.utils import get_installer\n+from Products.Five.browser import BrowserView\n+from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n+from Products.statusmessages.interfaces import IStatusMessage\n+from z3c.form import button\n+from z3c.form import field\n+from z3c.form import form\n+from z3c.form.browser.checkbox import CheckBoxFieldWidget\n+from z3c.form.interfaces import HIDDEN_MODE\n+from zExceptions import NotFound\n+from zope import schema\n+from zope.component import getMultiAdapter\n+from zope.component import queryUtility\n+from zope.interface import Interface\n+from zope.schema.interfaces import IVocabularyFactory\n+from zope.schema.vocabulary import SimpleVocabulary\n+from zope.interface import implementer\n+\n+import logging\n+import pkg_resources\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+\n+@implementer(IVocabularyFactory)\n+class ChangedBaseClasses(object):\n+\n+    def __call__(self, context):\n+        """Return a vocabulary with all changed base classes."""\n+        list_of_class_names = list_of_changed_base_class_names(context) or {}\n+        return SimpleVocabulary(\n+            [SimpleVocabulary.createTerm(\n+                class_name, class_name,\n+                \'{0} ({1})\'.format(\n+                    class_name, list_of_class_names[class_name]))\n+             for class_name in list_of_class_names.keys()]\n+        )\n+\n+\n+class IBaseClassMigratorForm(Interface):\n+\n+    changed_base_classes = schema.List(\n+        title=u\'Changed base classes\',\n+        description=u\'Select changed base classes you want to migrate\',\n+        value_type=schema.Choice(\n+            vocabulary=\'plone.app.contenttypes.migration.changed_base_classes\',\n+        ),\n+        required=True,\n+    )\n+    migrate_to_folderish = schema.Bool(\n+        title=u\'Migrate to folderish type?\',\n+        description=(\n+            u\'Select this option if you changed a type from being \'\n+            u\'itemish to being folderish but the class of the type is still \'\n+            u\'the same.\'\n+        ),\n+        default=False,\n+    )\n+\n+\n+class BaseClassMigratorForm(form.Form):\n+\n+    fields = field.Fields(IBaseClassMigratorForm)\n+    fields[\'changed_base_classes\'].widgetFactory = CheckBoxFieldWidget\n+    ignoreContext = True\n+    enableCSRFProtection = True\n+\n+    @button.buttonAndHandler(u\'Update\', name=\'update\')\n+    def handle_migrate(self, action):\n+        data, errors = self.extractData()\n+\n+        if errors:\n+            return\n+\n+        changed_base_classes = data.get(\'changed_base_classes\', [])\n+        if not changed_base_classes:\n+            return\n+\n+        migrate_to_folderish = data.get(\'changed_base_classes\', False)\n+        catalog = getToolByName(self.context, \'portal_catalog\')\n+        migrated = []\n+        not_migrated = []\n+        for brain in catalog():\n+            try:\n+                obj = brain.getObject()\n+            except (KeyError, NotFound):\n+                continue\n+            old_class_name = get_old_class_name_string(obj)\n+            if old_class_name in changed_base_classes:\n+                if migrate_base_class_to_new_class(\n+                        obj, migrate_to_folderish=migrate_to_folderish):\n+                    migrated.append(obj)\n+                else:\n+                    not_migrated.append(obj)\n+\n+        messages = IStatusMessage(self.request)\n+        info_message_template = \'There are {0} objects migrated.\'\n+        warn_message_template = \'There are not {0} objects migrated.\'\n+        if migrated:\n+            msg = info_message_template.format(len(migrated))\n+            messages.addStatusMessage(msg, type=\'info\')\n+        if not_migrated:\n+            msg = warn_message_template.format(len(not_migrated))\n+            messages.addStatusMessage(msg, type=\'warn\')\n+        self.request.response.redirect(self.request[\'ACTUAL_URL\'])\n+\n+\n+BaseClassMigrator = wrap_form(\n+    BaseClassMigratorForm,\n+)\ndiff --git a/plone/app/contenttypes/configure.zcml b/plone/app/contenttypes/configure.zcml\nindex 3399fbc3..0b1131a4 100644\n--- a/plone/app/contenttypes/configure.zcml\n+++ b/plone/app/contenttypes/configure.zcml\n@@ -37,11 +37,6 @@\n   <include file="subscribers.zcml" />\n   <include file="upgrades.zcml" />\n \n-  <configure zcml:condition="installed Products.ATContentTypes">\n-  <include\n-    zcml:condition="installed archetypes.schemaextender"\n-    package=".migration" />\n-  </configure>\n \n   <utility\n       factory=".setuphandlers.HiddenProfiles"\ndiff --git a/plone/app/contenttypes/migration/__init__.py b/plone/app/contenttypes/migration/__init__.py\ndeleted file mode 100644\nindex 40a96afc..00000000\n--- a/plone/app/contenttypes/migration/__init__.py\n+++ /dev/null\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/contenttypes/migration/atct_migrator.pt b/plone/app/contenttypes/migration/atct_migrator.pt\ndeleted file mode 100644\nindex c6a49e54..00000000\n--- a/plone/app/contenttypes/migration/atct_migrator.pt\n+++ /dev/null\n@@ -1,124 +0,0 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"\n-      xmlns:tal="http://xml.zope.org/namespaces/tal"\n-      xmlns:metal="http://xml.zope.org/namespaces/metal"\n-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-      lang="en"\n-      metal:use-macro="context/@@main_template/macros/master"\n-      i18n:domain="plone">\n-\n-<metal:block fill-slot="top_slot"\n-    tal:define="dummy python:request.set(\'disable_border\', 1);\n-                disable_column_two python:request.set(\'disable_plone.rightcolumn\', 1);\n-                disable_column_two python:request.set(\'disable_plone.leftcolumn\', 1);\n-                portal_url portal_state/portal_url">\n-  <link rel="stylesheet" type="text/css" href="" media="screen" tal:attributes="href string:${portal_url}/++resource++pac_migrator.css">\n-</metal:block>\n-\n-<body>\n-\n-<metal:custom_title fill-slot="content-title">\n-  <h1 class="documentFirstHeading" i18n:translate="">Migration control panel</h1>\n-</metal:custom_title>\n-<metal:custom_desc fill-slot="content-description">\n-  <div class="documentDescription" i18n:translate="">Migrate Archetypes content types to respective Dexterity content types.</div>\n-</metal:custom_desc>\n-\n-<metal:content-core fill-slot="content-core">\n-<metal:block define-macro="content-core"\n-             tal:define="helpers context/@@atct_migrator_helpers;\n-                         linguaplone_installed helpers/linguaplone_installed;\n-                         object_number helpers/objects_to_be_migrated;\n-                         subtopics helpers/site_has_subtopics;\n-                         collections_are_folderish helpers/collections_are_folderish;\n-                         has_contentleadimage helpers/has_contentleadimage;\n-                         installed_types helpers/installed_types;">\n-  <div class="important">\n-    <h2 i18n:translate="">Important</h2>\n-    <p i18n:translate="">Before migrating your content please read the <a i18n:name="migrationsection" i18n:translate="" href="https://github.com/plone/plone.app.contenttypes#migration">migration-section in the documentation of plone.app.contenttypes</a></p>\n-    <h3 i18n:translate="">Migrating content that is translated with LinguaPlone</h3>\n-    <p i18n:translate="">Since LinguaPlone does not support Dexterity you need to migrate from LinguaPlone to <a i18n:name="multilingual" href="http://pypi.python.org/pypi/plone.app.multilingual">plone.app.multilingual</a>. The migration from Products.LinguaPlone to plone.app.multilingual should happen before the migration from Archetypes to plone.app.contenttypes. For details on the migration see the <a i18n:name="documentation" href="http://pypi.python.org/pypi/plone.app.multilingual#linguaplone-migration">documentation</a></p>\n-    <h3 i18n:translate="">Migrating default-content that was extended with archetypes.schemaextender</h3>\n-    <p i18n:translate="">The migration should warn you if any of your types are extended with <a i18n:name="schemaextender" href="https://pypi.python.org/pypi/archetypes.schemaextender">archetypes.schemaextender</a>. You can still migrate this content but the data contained in these fields will be lost.\n-    If you need to keep the data in these fields you need to write a custom migration for your types and dexterity-behaviors for the data stored in the extended fields.</p>\n-    <h3 i18n:translate="">Note about how long it might take</h3>\n-    <p i18n:translate="">Depending of the number of archetypes in your portal, it may take a <strong>really</strong> long time for the migration to be done.\n-    Stay calm, be patient and check your logs for progress-information.</p>\n-  </div>\n-  <tal:block condition="object_number">\n-    <tal:block condition="not:linguaplone_installed">\n-      <div class="important">\n-        <h2 i18n:translate="">Estimation</h2>\n-        <p i18n:translate="">You currently have <span class="strong" i18n:name="number_of_objects" tal:content="helpers/objects_to_be_migrated">23</span> archetypes objects to be migrated.</p>\n-        <p i18n:translate="" tal:define="time helpers/estimated_migration_time">The estimated time for the migration is around:\n-        <strong>\n-          <tal:block i18n:name="hours" content="time/hours">4</tal:block> hours\n-          <tal:block i18n:name="minutes" content="time/minutes">45</tal:block> minutes\n-          <tal:block i18n:name="seconds" content="time/seconds">23</tal:block> seconds\n-        </strong>\n-        </p>\n-        <p>\n-        <span i18n:translate="" tal:omit-tag="">Please note that migrating references will increase this time.</span>\n-        </p>\n-      </div>\n-      <div id="migration-options">\n-        <h2 i18n:translate="">Migrate contents</h2>\n-        <div class="documentDescription">\n-          <p i18n:translate="">You can select which content types you want to migrate and\n-            choose to migrate references or not.</p>\n-        </div>\n-        <tal:form metal:use-macro="context/@@ploneform-macros/titlelessform">\n-            This is the real migration form.\n-        </tal:form>\n-      </div>\n-    </tal:block>\n-    <tal:block condition="linguaplone_installed">\n-      <div class="important">\n-        <h2 i18n:translate="">Warning</h2>\n-        <p i18n:translate="" class="strong">Since you effectively have Products.LinguaPlone installed in your portal, you\'re not allowed to continue this migration.</p>\n-        <p i18n:translate="">Have a look above for more information.</p>\n-      </div>\n-    </tal:block>\n-    <tal:block condition="python: subtopics and not collections_are_folderish">\n-      <div class="important">\n-        <h2 i18n:translate="">Error</h2>\n-        <p i18n:translate="">Your site has <span i18n:name="n" tal:replace="python: len(subtopics)" /> subtopic(s). Before migrating them you have to either remove all subtopics or create folderish Collections to be able to migrate them. Inheriting criteria to sub-collections is not supported by the default types. You can still migrate other content.</p>\n-        <p><a i18n:translate="" href="https://pypi.python.org/pypi/plone.app.contenttypes#migration">See here for details.</a></p>\n-        <p i18n:translate="">Your subtopics:</p>\n-        <ul>\n-          <li tal:repeat="subtopic subtopics"><a href="" target="_new" tal:attributes="href subtopic" tal:content="subtopic"></a></li>\n-        </ul>\n-      </div>\n-    </tal:block>\n-    <tal:block condition="python: subtopics and collections_are_folderish">\n-      <div class="important">\n-        <h2 i18n:translate="">Warning</h2>\n-        <p i18n:translate="">Your site has <span i18n:name="n" tal:replace="python: len(subtopics)" /> subtopic(s). You can migrate them since you have folderish Collections but their functionality to inherit criteria will not work unless you.</p>\n-      </div>\n-    </tal:block>\n-    <tal:block condition="python: has_contentleadimage"\n-               tal:define="installed_with_behavior python:installed_types[\'installed_with_behavior\'];\n-                           installed_without_behavior python:installed_types[\'installed_without_behavior\'];\n-                           not_installed python:installed_types[\'not_installed\']">\n-      <div class="important">\n-        <h2 i18n:translate="">Warning</h2>\n-        <p i18n:translate="">\n-          Your site seems to use the addon <a i18n:name="contentleadimage" href="https://pypi.python.org/pypi/collective.contentleadimage/">collective.contentleadimage</a>.\n-          This addons allows you to add images to any content in your site. These images will <strong>not</strong> be migrated unless you enable the behavior "Lead Image" on all those types where you want to migrate images added using collective.contentleadimage. Depending on the way you installed plone.app.contenttypes you might have to first install these types by (re-)installing plone.app.contenttypes. The old types that use leadimages are listed in the navigation-form with the comment <em>"extended fields: \'leadImage\', \'leadImage_caption\'"</em>\n-        </p>\n-        <p tal:condition="python:installed_with_behavior" i18n:translate="">These types are installed and have the image-behavior: <span i18n:name="types" tal:content="python:\', \'.join(installed_with_behavior)">Document, Image</span></p>\n-        <p tal:condition="python:installed_without_behavior" i18n:translate="">These types are installed but do not have the behavior enabled: <span i18n:name="types" tal:content="python:\', \'.join(installed_without_behavior)">Link, File</span></p>\n-        <p tal:condition="python:not_installed" i18n:translate="">These types are not installed yet: <span i18n:name="types" tal:content="python:\', \'.join(not_installed)">News Item, Folder</span></p>\n-      </div>\n-    </tal:block>\n-\n-  </tal:block>\n-  <tal:block condition="not:object_number">\n-    <div class="important">\n-      <h2 i18n:translate="">Warning</h2>\n-      <p i18n:translate="" class="strong">No content to migrate.</p>\n-  </tal:block>\n-\n-</metal:block>\n-</metal:content-core>\n-</body>\n-</html>\ndiff --git a/plone/app/contenttypes/migration/atct_migrator_results.pt b/plone/app/contenttypes/migration/atct_migrator_results.pt\ndeleted file mode 100644\nindex 65875308..00000000\n--- a/plone/app/contenttypes/migration/atct_migrator_results.pt\n+++ /dev/null\n@@ -1,84 +0,0 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"\n-      xmlns:tal="http://xml.zope.org/namespaces/tal"\n-      xmlns:metal="http://xml.zope.org/namespaces/metal"\n-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-      lang="en"\n-      metal:use-macro="context/@@main_template/macros/master"\n-      i18n:domain="plone">\n-\n-<metal:block fill-slot="top_slot"\n-    tal:define="dummy python:request.set(\'disable_border\', 1);\n-                disable_column_two python:request.set(\'disable_plone.rightcolumn\', 1);\n-                disable_column_two python:request.set(\'disable_plone.leftcolumn\', 1);\n-                portal_url portal_state/portal_url">\n-  <link rel="stylesheet" type="text/css" href="" media="screen" tal:attributes="href string:${portal_url}/++resource++pac_migrator.css">\n-</metal:block>\n-\n-<body>\n-\n-<metal:custom_title fill-slot="content-title">\n-  <h1 class="documentFirstHeading" i18n:translate="">Congratulations! You migrated from Archetypes to Dexterity.</h1>\n-</metal:custom_title>\n-\n-<metal:content-core fill-slot="content-core">\n-<metal:block define-macro="content-core"\n-    tal:define="results view/results">\n-\n-  <tal:success tal:condition="results">\n-    <p>The migration finished within <span tal:replace="results/duration">20</span></p>\n-\n-    <h3>Migrated Content</h3>\n-    <table>\n-    <tr>\n-      <th>Old Type</th>\n-      <th>New Type</th>\n-      <th>Items</th>\n-    </tr>\n-    <tal:block tal:repeat="ct results/content_types">\n-    <tr>\n-      <td tal:content="python:results[\'migrated_types\'][ct][\'old_meta_type\']"></td>\n-      <td tal:content="python:results[\'migrated_types\'][ct][\'type_name\']"></td>\n-      <td tal:content="python:results[\'migrated_types\'][ct][\'amount_migrated\']"></td>\n-    </tr>\n-    </tal:block>\n-    </table>\n-\n-    <h3>Content before Migration</h3>\n-    <table>\n-    <tr>\n-      <th>Type</th>\n-      <th>Items</th>\n-    </tr>\n-    <tr tal:repeat="ct python:sorted(results[\'before\'].keys())">\n-      <td tal:content="ct"></td>\n-      <td tal:content="python:results[\'before\'][ct]"></td>\n-    </tr>\n-    </table>\n-\n-    <h3>Content after Migration</h3>\n-    <table>\n-    <tr>\n-      <th>Type</th>\n-      <th>Items</th>\n-    </tr>\n-    <tr tal:repeat="ct python:sorted(results[\'after\'].keys())">\n-      <td tal:content="ct"></td>\n-      <td tal:content="python:results[\'after\'][ct]"></td>\n-    </tr>\n-    </table>\n-  </tal:success>\n-\n-  <div class="links">\n-    <a href="atct_migrator" tal:attributes="href string:${portal_url}/@@atct_migrator">\n-      <span i18n:translate="">Back to the Migration-Form</span>\n-    </a>\n-    <br/>\n-    <a href="" tal:attributes="href portal_url">\n-      <span i18n:translate="">Back to Plone</span>\n-    </a>\n-  </div>\n-\n-</metal:block>\n-</metal:content-core>\n-</body>\n-</html>\ndiff --git a/plone/app/contenttypes/migration/browser.py b/plone/app/contenttypes/migration/browser.py\ndeleted file mode 100644\nindex b36cb9fc..00000000\n--- a/plone/app/contenttypes/migration/browser.py\n+++ /dev/null\n@@ -1,627 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from datetime import datetime\n-from datetime import timedelta\n-from plone.app.contenttypes.content import Document\n-from plone.app.contenttypes.content import File\n-from plone.app.contenttypes.content import Folder\n-from plone.app.contenttypes.content import Image\n-from plone.app.contenttypes.content import Link\n-from plone.app.contenttypes.content import NewsItem\n-from plone.app.contenttypes.migration import dxmigration\n-from plone.app.contenttypes.migration import migration\n-from plone.app.contenttypes.migration.patches import patch_before_migration\n-from plone.app.contenttypes.migration.patches import undo_patch_after_migration\n-from plone.app.contenttypes.migration.utils import installTypeIfNeeded\n-from plone.app.contenttypes.migration.utils import isSchemaExtended\n-from plone.app.contenttypes.migration.utils import restore_references\n-from plone.app.contenttypes.migration.utils import store_references\n-from plone.app.contenttypes.migration.vocabularies import ATCT_LIST\n-from plone.app.contenttypes.upgrades import use_new_view_names\n-from plone.app.contenttypes.utils import DEFAULT_TYPES\n-from plone.browserlayer.interfaces import ILocalBrowserLayerType\n-from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.interfaces import IDexterityFTI\n-from plone.z3cform.layout import wrap_form\n-from pprint import pformat\n-from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone import PloneMessageFactory as _\n-from Products.CMFPlone.utils import get_installer\n-from Products.Five.browser import BrowserView\n-from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n-from Products.statusmessages.interfaces import IStatusMessage\n-from z3c.form import button\n-from z3c.form import field\n-from z3c.form import form\n-from z3c.form.browser.checkbox import CheckBoxFieldWidget\n-from z3c.form.interfaces import HIDDEN_MODE\n-from zExceptions import NotFound\n-from zope import schema\n-from zope.component import getMultiAdapter\n-from zope.component import queryUtility\n-from zope.interface import Interface\n-\n-import logging\n-import pkg_resources\n-\n-\n-try:\n-    pkg_resources.get_distribution(\'collective.contentleadimage\')\n-except pkg_resources.DistributionNotFound:\n-    HAS_CONTENTLEADIMAGE = False\n-else:\n-    HAS_CONTENTLEADIMAGE = True\n-\n-logger = logging.getLogger(__name__)\n-\n-\n-# Average time to migrate one archetype object, in milliseconds.\n-# This very much depends on the size of the object and system-speed\n-ONE_OBJECT_MIGRATION_TIME = 500\n-\n-\n-class FixBaseClasses(BrowserView):\n-\n-    def __call__(self):\n-        """Make sure all content objects use the proper base classes.\n-        Instances before version 1.0b1 had no base-class.\n-        To update them call @@fix_base_classes on your site-root.\n-        """\n-        out = \'\'\n-        portal_types = [\n-            (\'Document\', Document),\n-            (\'File\', File),\n-            (\'Folder\', Folder),\n-            (\'Image\', Image),\n-            (\'Link\', Link),\n-            (\'News Item\', NewsItem),\n-        ]\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        query = {}\n-        for portal_type, portal_type_class in portal_types:\n-            query[\'portal_type\'] = portal_type\n-            results = catalog(query)\n-            for brain in results:\n-                try:\n-                    obj = brain.getObject()\n-                except (KeyError, NotFound):\n-                    logger.exception(\'Can not resolve object from brain.\')\n-                    continue\n-                if IDexterityContent.providedBy(obj):\n-                    object_class_name = obj.__class__.__name__\n-                    target_class_name = portal_type_class.__name__\n-                    if not object_class_name == target_class_name:\n-                        obj.__class__ = portal_type_class\n-                        out += \'Make {0} use {1}\\n as base class.\'.format(\n-                            obj.Title(),\n-                            portal_type_class.__name__,\n-                        )\n-        return out\n-\n-\n-class MigrateFromATContentTypes(BrowserView):\n-    """Migrate the default-types (except event and topic).\n-    This view can be called directly and it will migrate all content\n-    provided they were not schema-extended.\n-    This is also called by the migration-form below with some variables.\n-    """\n-\n-    def __call__(self,\n-                 migrate=False,\n-                 content_types=\'all\',\n-                 migrate_schemaextended_content=False,\n-                 migrate_references=True,\n-                 from_form=False,\n-                 reindex_catalog=True,\n-                 patch_searchabletext=False,\n-                 ):\n-\n-        portal = self.context\n-\n-        if not from_form and migrate not in [\'1\', \'True\', \'true\', 1]:\n-            url1 = \'{0}/@@migrate_from_atct?migrate=1\'.format(\n-                portal.absolute_url())\n-            url2 = \'{0}/@@atct_migrator\'.format(portal.absolute_url())\n-            msg = u\'Warning \\n\'\n-            msg += u\'-------\\n\'\n-            msg += u\'You are accessing "@@migrate_from_atct" directly. \'\n-            msg += u\'This will migrate all content to dexterity!\\n\\n\'\n-            msg += u\'Really migrate all content now: {0}\\n\\n\'.format(url1)\n-            msg += u\'First select what to migrate: {0}\'.format(url2)\n-            return msg\n-\n-        helpers = getMultiAdapter((portal, self.request),\n-                                  name=\'atct_migrator_helpers\')\n-        if helpers.linguaplone_installed():\n-            msg = \'Warning\\n\'\n-            msg += \'Migration aborted since Products.LinguaPlone is \'\n-            msg += \'installed. See \'\n-            msg += \'http://github.com/plone/plone.app.contenttypes#migration \'\n-            msg += \'for more information.\'\n-            return msg\n-\n-        stats_before = self.stats()\n-        starttime = datetime.now()\n-\n-        self.request[\'plone.app.contenttypes_migration_running\'] = True\n-\n-        msg = \'Starting Migration\\n\\n\'\n-        msg += \'\\n-----------------------------\\n\'\n-        msg += \'Content statictics:\\n\'\n-        msg += pformat(stats_before)\n-        msg += \'\\n-----------------------------\\n\'\n-        msg += \'Types to be migrated:\\n\'\n-        msg += pformat(content_types)\n-        msg += \'\\n-----------------------------\\n\'\n-        logger.info(msg)\n-\n-        # store references on the portal\n-        if migrate_references:\n-            store_references(portal)\n-        catalog = portal.portal_catalog\n-\n-        # Patch various things that make migration harder\n-        (link_integrity,\n-         queue_indexing,\n-         patch_searchabletext) = patch_before_migration(patch_searchabletext)\n-\n-        not_migrated = []\n-        migrated_types = {}\n-\n-        for (k, v) in ATCT_LIST.items():\n-            if content_types != \'all\' and k not in content_types:\n-                not_migrated.append(k)\n-                continue\n-            # test if the ct is extended beyond blobimage and blobfile\n-            if len(isSchemaExtended(v[\'iface\'])) > len(v[\'extended_fields\']) \\\n-                    and not migrate_schemaextended_content:\n-                not_migrated.append(k)\n-                continue\n-            query = {\n-                \'object_provides\': v[\'iface\'].__identifier__,\n-                \'meta_type\': v[\'old_meta_type\'],\n-            }\n-            amount_to_be_migrated = len(\n-                catalog.unrestrictedSearchResults(query))\n-            starttime_for_current = datetime.now()\n-            logger.info(\n-                \'Start migrating {0} objects from {1} to {2}\'.format(\n-                    amount_to_be_migrated,\n-                    v[\'old_meta_type\'],\n-                    v[\'type_name\'],\n-                )\n-            )\n-            installTypeIfNeeded(v[\'type_name\'])\n-\n-            # call the migrator\n-            v[\'migrator\'](portal)\n-\n-            # logging\n-            duration_current = datetime.now() - starttime_for_current\n-            duration_human = str(timedelta(seconds=duration_current.seconds))\n-            logger.info(\n-                \'Finished migrating {0} objects from {1} to {2} in {3}\'.format(\n-                    amount_to_be_migrated,\n-                    v[\'old_meta_type\'],\n-                    v[\'type_name\'],\n-                    duration_human),\n-            )\n-\n-            # some data for the results-page\n-            migrated_types[k] = {}\n-            migrated_types[k][\'amount_migrated\'] = amount_to_be_migrated\n-            migrated_types[k][\'old_meta_type\'] = v[\'old_meta_type\']\n-            migrated_types[k][\'type_name\'] = v[\'type_name\']\n-\n-        # if there are blobnewsitems we just migrate them silently.\n-        migration.migrate_blobnewsitems(portal)\n-\n-        # make sure the view-methods on the plone site are updated\n-        use_new_view_names(portal, types_to_fix=[\'Plone Site\'])\n-\n-        if reindex_catalog:\n-            logger.info(\'Rebuiling catalog. This may take a while...\')\n-            catalog.clearFindAndRebuild()\n-\n-        # restore references\n-        if migrate_references:\n-            restore_references(portal)\n-\n-        # Revert to the original state\n-        undo_patch_after_migration(\n-            link_integrity, queue_indexing, patch_searchabletext)\n-\n-        duration = str(timedelta(seconds=(datetime.now() - starttime).seconds))\n-        if not_migrated:\n-            msg = (\n-                \'The following types were not migrated: \\n {0}\'.format(\n-                    \'\\n\'.join(not_migrated)\n-                )\n-            )\n-        else:\n-            msg = \'Migration successful\\n\\n\'\n-        msg += \'\\n-----------------------------\\n\'\n-        msg += \'Migration finished in: {0}\'.format(duration)\n-        msg += \'\\n-----------------------------\\n\'\n-        msg += \'Migration statictics:\\n\'\n-        msg += pformat(migrated_types)\n-        msg += \'\\n-----------------------------\\n\'\n-        msg += \'State before:\\n\'\n-        msg += pformat(stats_before)\n-        msg += \'\\n-----------------------------\\n\'\n-        msg += \'Stats after:\\n\'\n-        msg += pformat(self.stats())\n-        msg += \'\\n-----------------------------\\n\'\n-        if not from_form:\n-            logger.info(msg)\n-            return msg\n-        else:\n-            stats = {\n-                \'duration\': duration,\n-                \'before\': stats_before,\n-                \'after\': self.stats(),\n-                \'content_types\': content_types,\n-                \'migrated_types\': migrated_types,\n-            }\n-            logger.info(msg)\n-            return stats\n-\n-    def stats(self):\n-        results = {}\n-        catalog = self.context.portal_catalog\n-        for brain in catalog():\n-            descriptor = \'{} ({})\'.format(brain.portal_type, brain.meta_type)\n-            results[descriptor] = results.get(descriptor, 0) + 1\n-        return results\n-\n-\n-class IATCTMigratorForm(Interface):\n-\n-    content_types = schema.List(\n-        title=u\'Existing content that can be migrated\',\n-        description=u\'Select which content types you want to migrate\',\n-        value_type=schema.Choice(\n-            vocabulary=\'plone.app.contenttypes.migration.atctypes\',\n-        ),\n-        required=False,\n-    )\n-\n-    migrate_references = schema.Bool(\n-        title=u\'Migrate references?\',\n-        description=(\n-            u\'Select this option to migrate references.\'\n-        ),\n-        default=True,\n-        required=False,\n-    )\n-\n-    extended_content = schema.List(\n-        title=(\n-            u\'Migrate content that was extended \'\n-            u\'using archetypes.schemaextender?\'\n-        ),\n-        description=(\n-            u\'Warning: You will loose all data in the extended fields!\'\n-        ),\n-        value_type=schema.Choice(\n-            vocabulary=\'plone.app.contenttypes.migration.extendedtypes\',\n-        ),\n-        required=False,\n-    )\n-\n-    reindex_catalog = schema.Bool(\n-        title=_(u\'Rebuild the catalog after the migration.\'),\n-        description=_(u\'This operation can take a very long time.\'),\n-        default=True,\n-        required=False,\n-    )\n-\n-    patch_searchabletext = schema.Bool(\n-        title=_(u\'Disable reindexing objects during migration?\'),\n-        description=_(\n-            u\'This can speed up your migration a lot if you have a lot of files with searchable text.\'  # noqa: E501\n-        ),\n-        default=False,\n-        required=False,\n-    )\n-\n-\n-class ATCTMigratorForm(form.Form):\n-    template = ViewPageTemplateFile(\'atct_migrator.pt\')\n-    results_template = ViewPageTemplateFile(\'atct_migrator_results.pt\')\n-\n-    fields = field.Fields(IATCTMigratorForm)\n-    fields[\'content_types\'].widgetFactory = CheckBoxFieldWidget\n-    fields[\'extended_content\'].widgetFactory = CheckBoxFieldWidget\n-    ignoreContext = True\n-    enableCSRFProtection = True\n-\n-    results = None\n-\n-    @button.buttonAndHandler(u\'Migrate\', name=\'migrate\')\n-    def handle_migrate(self, action):\n-        data, errors = self.extractData()\n-        context = self.context\n-\n-        if errors:\n-            return\n-\n-        content_types = data[\'content_types\'] or []\n-        content_types.extend(data[\'extended_content\'] or [])\n-\n-        migration_view = getMultiAdapter(\n-            (context, self.request),\n-            name=u\'migrate_from_atct\'\n-        )\n-        # store results where `render` can find them\n-        self.results = migration_view(\n-            content_types=content_types,\n-            migrate_schemaextended_content=True,\n-            migrate_references=data[\'migrate_references\'],\n-            from_form=True,\n-            reindex_catalog=data[\'reindex_catalog\'],\n-            patch_searchabletext=data[\'patch_searchabletext\'],\n-        )\n-\n-    def updateActions(self):\n-        super(ATCTMigratorForm, self).updateActions()\n-        self.actions[\'migrate\'].addClass(\'btn-danger\')\n-\n-    def updateWidgets(self):\n-        """ Overload to set defaults and hide empty widgets. """\n-        form.Form.updateWidgets(self)\n-        # 1. Select all items in the checkboxwidget\n-        ct_widget = self.widgets[\'content_types\']\n-        # Only override when rendering the form. When you unselect\n-        # everything the value will be [], not ())\n-        if ct_widget.value == ():\n-            ct_widget.value = list(ATCT_LIST)\n-            # Call update again since the list-items checked-states are\n-            # assigned in z3c.form.browser.checkbox.CheckBoxWidget.update\n-            # using the widget.value.\n-            ct_widget.update()\n-        # 2. Hide empty widget\n-        for title, widget in self.widgets.items():\n-            if title not in (\'content_types\', \'extended_content\'):\n-                continue\n-            if not len(widget.items):\n-                # the vocabulary is empty, we hide the widget\n-                widget.mode = HIDDEN_MODE\n-\n-    def render(self):\n-        if self.results:\n-            return self.results_template()\n-        else:\n-            return super(ATCTMigratorForm, self).render()\n-\n-\n-class IBaseClassMigratorForm(Interface):\n-\n-    changed_base_classes = schema.List(\n-        title=u\'Changed base classes\',\n-        description=u\'Select changed base classes you want to migrate\',\n-        value_type=schema.Choice(\n-            vocabulary=\'plone.app.contenttypes.migration.changed_base_classes\',\n-        ),\n-        required=True,\n-    )\n-    migrate_to_folderish = schema.Bool(\n-        title=u\'Migrate to folderish type?\',\n-        description=(\n-            u\'Select this option if you changed a type from being \'\n-            u\'itemish to being folderish but the class of the type is still \'\n-            u\'the same.\'\n-        ),\n-        default=False,\n-    )\n-\n-\n-class BaseClassMigratorForm(form.Form):\n-\n-    fields = field.Fields(IBaseClassMigratorForm)\n-    fields[\'changed_base_classes\'].widgetFactory = CheckBoxFieldWidget\n-    ignoreContext = True\n-    enableCSRFProtection = True\n-\n-    @button.buttonAndHandler(u\'Update\', name=\'update\')\n-    def handle_migrate(self, action):\n-        data, errors = self.extractData()\n-\n-        if errors:\n-            return\n-\n-        changed_base_classes = data.get(\'changed_base_classes\', [])\n-        if not changed_base_classes:\n-            return\n-\n-        migrate_to_folderish = data.get(\'changed_base_classes\', False)\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        migrated = []\n-        not_migrated = []\n-        for brain in catalog():\n-            try:\n-                obj = brain.getObject()\n-            except (KeyError, NotFound):\n-                continue\n-            old_class_name = dxmigration.get_old_class_name_string(obj)\n-            if old_class_name in changed_base_classes:\n-                if dxmigration.migrate_base_class_to_new_class(\n-                        obj, migrate_to_folderish=migrate_to_folderish):\n-                    migrated.append(obj)\n-                else:\n-                    not_migrated.append(obj)\n-\n-        messages = IStatusMessage(self.request)\n-        info_message_template = \'There are {0} objects migrated.\'\n-        warn_message_template = \'There are not {0} objects migrated.\'\n-        if migrated:\n-            msg = info_message_template.format(len(migrated))\n-            messages.addStatusMessage(msg, type=\'info\')\n-        if not_migrated:\n-            msg = warn_message_template.format(len(not_migrated))\n-            messages.addStatusMessage(msg, type=\'warn\')\n-        self.request.response.redirect(self.request[\'ACTUAL_URL\'])\n-\n-\n-BaseClassMigrator = wrap_form(\n-    BaseClassMigratorForm,\n-)\n-\n-\n-class ATCTMigratorHelpers(BrowserView):\n-\n-    def objects_to_be_migrated(self):\n-        """ Return the number of AT objects in the portal """\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        query = {\'meta_type\': [i[\'old_meta_type\'] for i in ATCT_LIST.values()]}\n-        brains = catalog(query)\n-        self._objects_to_be_migrated = len(brains)\n-        return self._objects_to_be_migrated\n-\n-    def estimated_migration_time(self):\n-        """ Return the estimated migration time """\n-        total_time = self.objects_to_be_migrated() * ONE_OBJECT_MIGRATION_TIME\n-        hours, remainder = divmod(total_time // 1000, 3600)\n-        minutes, seconds = divmod(remainder, 60)\n-        return {\n-            \'hours\': hours,\n-            \'minutes\': minutes,\n-            \'seconds\': seconds\n-        }\n-\n-    def linguaplone_installed(self):\n-        """Is Products.LinguaPlone installed?\n-        """\n-        existing = queryUtility(ILocalBrowserLayerType, name=\'LinguaPlone\')\n-        return bool(existing)\n-\n-    def site_has_subtopics(self):\n-        """Check if there are subtopics. Since Collections are itemish by\n-        default the migration of subtopics would fail Collections are changed\n-        to be folderish.\n-        """\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        query = {\'meta_type\': \'ATTopic\'}\n-        results = []\n-        brains = catalog(query)\n-        for brain in brains:\n-            for item in catalog(path={\'query\': brain.getPath(), \'depth\': 1}):\n-                results.append(item.getURL())\n-        if results:\n-            results = set(results)\n-            paths = \'\\n\'.join(results)\n-            logger.info(\'Found {0} subtopics at: \\n{1}\'.format(\n-                len(results), paths))\n-            return results\n-\n-    def collections_are_folderish(self):\n-        """Since Collections are itemish by default the migration would fail\n-        if there are any subtopics. As a workaround we allow to migrate to\n-        custom folderish Collections. The custom Collections have to fulfill\n-        the following criteria:\n-        1. The id if the type has to be Collection (not collection). You can\n-           change a type\'s id in portal_types\n-        2. The type has to have the collection-behavior.\n-\n-        This much can even be done ttw. For the views of collections\n-        to work the base-class of the Collections also has to implement the\n-        interface `plone.app.contenttypes.interfaces.ICollection`.\n-\n-        This is what such a class would look like:\n-\n-            from plone.app.contenttypes.behaviors.collection import ICollection\n-            from plone.dexterity.content import Container\n-            from zope.interface import implementer\n-\n-            @implementer(ICollection)\n-            class FolderishCollection(Container):\n-                pass\n-\n-        You can either use a completely new fti or overwrite the default fti\n-        like this:\n-\n-            <?xml version="1.0"?>\n-            <object name="Collection" meta_type="Dexterity FTI">\n-             <property name="klass">my.package.content.FolderishCollection\n-             </property>\n-            </object>\n-\n-        """\n-        fti = queryUtility(IDexterityFTI, name=\'Collection\')\n-        if fti and fti.content_meta_type == \'Dexterity Container\':\n-            return True\n-        # test for lowercase ttw-type\n-        fti = queryUtility(IDexterityFTI, name=\'collection\')\n-        behavior = \'plone.app.contenttypes.behaviors.collection.ICollection\'\n-        if fti and behavior in fti.behaviors:\n-            logger.warn("You are trying to migrate topic to collection. "\n-                        "Instead you need a type \'Collection\'.")\n-\n-    def has_contentleadimage(self):\n-        return HAS_CONTENTLEADIMAGE\n-\n-    def installed_types(self):\n-        """Which types are already Dexterity and which are not."""\n-        results = {}\n-        results[\'installed_with_behavior\'] = []\n-        results[\'installed_without_behavior\'] = []\n-        results[\'not_installed\'] = []\n-        behavior = \'plone.app.contenttypes.behaviors.leadimage.ILeadImage\'\n-        for type_name in DEFAULT_TYPES:\n-            fti = queryUtility(IDexterityFTI, name=type_name)\n-            if fti:\n-                if behavior in fti.behaviors:\n-                    results[\'installed_with_behavior\'].append(type_name)\n-                else:\n-                    results[\'installed_without_behavior\'].append(type_name)\n-            else:\n-                results[\'not_installed\'].append(type_name)\n-        return results\n-\n-\n-class PACInstaller(form.Form):\n-    """Install p.a.c and redirect to migration-form."""\n-\n-    fields = field.Fields()\n-    template = ViewPageTemplateFile(\'pac_installer.pt\')\n-    enableCSRFProtection = True\n-\n-    @property\n-    def pac_installable(self):\n-        qi = get_installer(self.context)\n-        pac_installed = qi.is_product_installed(\'plone.app.contenttypes\')\n-        pac_installable = qi.is_product_installable(\'plone.app.contenttypes\')\n-        return pac_installable and not pac_installed\n-\n-    @property\n-    def pac_installed(self):\n-        qi = get_installer(self.context)\n-        return qi.is_product_installed(\'plone.app.contenttypes\')\n-\n-    @button.buttonAndHandler(_(u\'Install\'), name=\'install\')\n-    def handle_install(self, action):\n-        """ install p.a.c\n-        """\n-        url = self.context.absolute_url()\n-        portal_setup = getToolByName(self.context, \'portal_setup\')\n-        portal_setup.runAllImportStepsFromProfile(\n-            \'profile-plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'],\n-        )\n-\n-        # For types without any instances we want to instantly\n-        # replace the AT-FTI\'s with DX-FTI\'s.\n-        self.installTypesWithoutItems()\n-\n-        url = url + \'/@@atct_migrator\'\n-        self.request.response.redirect(url)\n-\n-    def installTypesWithoutItems(self):\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        for types_name in DEFAULT_TYPES:\n-            if not catalog.unrestrictedSearchResults(portal_type=types_name):\n-                installTypeIfNeeded(types_name)\n-\n-    @button.buttonAndHandler(\n-        _(u\'label_cancel\', default=u\'Cancel\'), name=\'cancel\')\n-    def handle_cancel(self, action):\n-        self.request.response.redirect(self.context.absolute_url())\ndiff --git a/plone/app/contenttypes/migration/configure.zcml b/plone/app/contenttypes/migration/configure.zcml\ndeleted file mode 100644\nindex b4056f3c..00000000\n--- a/plone/app/contenttypes/migration/configure.zcml\n+++ /dev/null\n@@ -1,112 +0,0 @@\n-<configure\n-    xmlns="http://namespaces.zope.org/zope"\n-    xmlns:five="http://namespaces.zope.org/five"\n-    xmlns:i18n="http://namespaces.zope.org/i18n"\n-    xmlns:browser="http://namespaces.zope.org/browser"\n-    xmlns:plone="http://namespaces.plone.org/plone"\n-    i18n_domain="plone">\n-\n-  <browser:resource\n-      name="pac_migrator.css"\n-      file="migrator.css"\n-      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"/>\n-\n-  <browser:page\n-    name="fix_base_classes"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"\n-    class=".browser.FixBaseClasses"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="migrate_from_atct"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"\n-    class=".browser.MigrateFromATContentTypes"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="atct_migrator"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".browser.ATCTMigratorForm"\n-    layer="..interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="base_class_migrator_form"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".browser.BaseClassMigrator"\n-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="atct_migrator_helpers"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".browser.ATCTMigratorHelpers"\n-    layer="..interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="pac_installer"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".browser.PACInstaller"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="custom_migration"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".custom_migration.CustomMigrationForm"\n-    layer="..interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    template="custom_migration.pt"\n-    />\n-\n-  <browser:page\n-    name="display_dx_fields"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".custom_migration.DisplayDXFields"\n-    layer="..interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    template="custom_migration_display_dx_fields.pt"\n-    />\n-\n-  <browser:page\n-    name="test_migration"\n-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-    class=".custom_migration.TestMigration"\n-    layer="..interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <browser:page\n-    name="export_all_references"\n-    for="*"\n-    class=".utils.ExportAllReferences"\n-    layer="..interfaces.IPloneAppContenttypesLayer"\n-    permission="cmf.ManagePortal"\n-    />\n-\n-  <utility\n-      factory=".vocabularies.ATCTypesVocabulary"\n-      name="plone.app.contenttypes.migration.atctypes"\n-      provides="zope.schema.interfaces.IVocabularyFactory" />\n-\n-  <utility\n-      factory=".vocabularies.ExtendedTypesVocabulary"\n-      name="plone.app.contenttypes.migration.extendedtypes"\n-      provides="zope.schema.interfaces.IVocabularyFactory" />\n-\n-  <utility\n-      factory=".vocabularies.ChangedBaseClasses"\n-      name="plone.app.contenttypes.migration.changed_base_classes"\n-      provides="zope.schema.interfaces.IVocabularyFactory" />\n-\n-  <adapter name="nullmigrator" factory=".migration.BaseCustomMigator"/>\n-\n-</configure>\ndiff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt\ndeleted file mode 100644\nindex 7d19a2cb..00000000\n--- a/plone/app/contenttypes/migration/custom_migration.pt\n+++ /dev/null\n@@ -1,159 +0,0 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"\n-      xmlns:tal="http://xml.zope.org/namespaces/tal"\n-      xmlns:metal="http://xml.zope.org/namespaces/metal"\n-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-      lang="en"\n-      metal:use-macro="context/@@main_template/macros/master"\n-      i18n:domain="plone">\n-\n-<metal:block fill-slot="top_slot"\n-    tal:define="dummy python:request.set(\'disable_border\', 1);\n-                disable_column_two python:request.set(\'disable_plone.rightcolumn\', 1);\n-                disable_column_two python:request.set(\'disable_plone.leftcolumn\', 1);\n-                portal_state context/@@plone_portal_state;\n-                portal_url portal_state/portal_url">\n-  <link rel="stylesheet" type="text/css" href="" media="screen" tal:attributes="href string:${portal_url}/++resource++pac_migrator.css">\n-</metal:block>\n-\n-<body>\n-\n-<metal:custom_title fill-slot="content-title">\n-  <h1 class="documentFirstHeading" i18n:translate="">Custom types migration control panel</h1>\n-</metal:custom_title>\n-<metal:custom_desc fill-slot="content-description">\n-  <div class="documentDescription" i18n:translate="">Migrate custom Archetypes content types to any available Dexterity content types.</div>\n-</metal:custom_desc>\n-\n-<metal:content-core fill-slot="content-core">\n-<metal:block define-macro="content-core"\n-             tal:define="at_types view/getAllArchetypeTypes">\n-  <div class="important">\n-    <h2 i18n:translate="">Important</h2>\n-    <p i18n:translate="">Before migrating your content please read the <a href="https://github.com/plone/plone.app.contenttypes#migration" i18n:name="migrationsection" i18n:translate="">migration-section in the documentation of plone.app.contenttypes</a></p>\n-\n-\n-    <h3>Migrating content that is translated with LinguaPlone</h3>\n-    <p i18n:translate="">Since LinguaPlone does not support Dexterity you need to migrate from LinguaPlone to <a i18n:name="multilingual" href="http://pypi.python.org/pypi/plone.app.multilingual">plone.app.multilingual</a>. The migration from Products.LinguaPlone to plone.app.multilingual should happen before the migration from Archetypes to plone.app.contenttypes. For details on the migration see the <a i18n:name="documentation" i18n:translate="" href="http://pypi.python.org/pypi/plone.app.multilingual#linguaplone-migration">documentation</a></p>\n-    <h3 i18n:translate="">Note about how long it might take</h3>\n-    <p i18n:translate="">Depending of the number of archetypes in your portal, it may take a <strong>really</strong> long time for the migration to be done.\n-    Stay calm, be patient and check your logs for progress-information.</p>\n-    </div>\n-    <script type="text/javascript">\n-        // function that toggle an icon by calling the p_viewName view\n-        function getDXFields(at_typename, dx_typename) {\n-          at_safe = at_typename.replace(\' \', \'_space_\');\n-          $.ajax({\n-            url: \'@@display_dx_fields\',\n-            dataType: \'html\',\n-            data: {\'at_typename\': at_typename,\n-                   \'dx_typename\': dx_typename},\n-            cache: false,\n-            success: function(data) {\n-                var $div = $(\'#hook_at_fti_\' + at_safe);\n-                $div.empty();\n-                $div.html(data);\n-              },\n-            error: function(jqXHR, textStatus, errorThrown) {\n-              }\n-            });\n-        }\n-        $(document).ready(function () {\n-            $(\'input[name="form.button.Test"]\').on( "click", function(e) {\n-                e.preventDefault();\n-                var $this = $(this);\n-                var tested_type = $this.parent().siblings(\'select.selectedType\');\n-                $this.parent().removeClass(\'error\');\n-                $this.parent().siblings(\'.fieldsMapping\').removeClass(\'error\');\n-                $this.parent().removeClass(\'success\');\n-                $this.parent().addClass(\'testing\');\n-                $.ajax({\n-                    url: \'@@test_migration?\' + $(this).parents(\'form\').serialize() + \'&tested_type=\' + tested_type.attr(\'name\'),\n-                    dataType: \'json\',\n-                    success: function(data) {\n-                        $this.parent().removeClass(\'testing\');\n-                        if(data.status === \'error\') {\n-                            $this.parent().addClass(\'error\');\n-                            $this.parent().siblings(\'.fieldsMapping\').addClass(\'error\');\n-                        }\n-                        else\xc2\xa0{\n-                            $this.parent().addClass(\'success\');\n-                        }\n-                    },\n-                    error: function(jqXHR, textStatus, errorThrown) {\n-                        $this.parent().removeClass(\'testing\');\n-                        $this.parent().addClass(\'error\');\n-                        $this.parent().siblings(\'.fieldsMapping\').addClass(\'error\');\n-                    }\n-                });\n-            });\n-        });\n-    </script>\n-    <tal:block condition="at_types">\n-        <div id="migration-options">\n-          <h2 i18n:translate="">Migrate contents</h2>\n-          <div\n-            class="documentDescription">\n-            <p i18n:translate="">You can select which AT content type you want to migrate to an existing DX content type.</p>\n-            <form id="migrateCustomATForm" method="post"\n-                  tal:attributes="action python:context.absolute_url() + \'/@@custom_migration\'">\n-\n-            <input class="field" type="checkbox" name="patch_searchabletext" id="patch_searchabletext" />\n-            <label for="patch_searchabletext" i18n:translate="">Disable reindexing objects during migration</label>\n-            <span class="formHelp" id="patch_searchabletext_help" i18n:translate="">This can speed up your migration a lot if you have a lot of files with searchable text.</span>\n-\n-            <table>\n-                <tr tal:repeat="at_type at_types">\n-                  <tal:block tal:define="safe_at_id python:at_type[\'id\'].replace(\' \', \'_space_\')">\n-                    <td valign="top">\n-                        <p tal:content="at_type/title" style="font-weight: bold;">AT content type title</p>\n-                        <tal:block repeat="field python: view.getFieldsForATType(at_type)">\n-                            <p tal:content="field/title" i18n:translate="">Field name</p>\n-                            <input type="hidden" tal:attributes="name string:${safe_at_id}:list;\n-                                                                 value string:${field/id}__type__${field/type};" />\n-                        </tal:block>\n-                    </td>\n-                    <td valign="top">\n-                        <select tal:attributes="onChange string:javascript:getDXFields(at_typename=\'${at_type/id}\', this.value);\n-                                                name string:dx_select_${safe_at_id};"\n-                                class="selectedType">\n-                            <option value="" selected="selected" i18n:translate="">Do not migrate</option>\n-                            <option tal:repeat="dx_type view/getDXFTIs"\n-                                    tal:attributes="value dx_type/id"\n-                                    tal:content="dx_type/title"\n-                                    i18n:translate="">DX type name</option>\n-                        </select>\n-                        <div id="hook_at_fti_News_Item"\n-                             class="field fieldsMapping"\n-                             tal:attributes="id string:hook_at_fti_${safe_at_id}" />\n-                        <br />\n-                        <div class="testConfig">\n-                            <input type="submit"\n-                                   name="form.button.Test"\n-                                   class="btn btn-primary"\n-                                   value="Test configuration"\n-                                   i18n:attributes="value"\n-                                   i18n:domain="plone"/>&nbsp;\n-                        </div>\n-                    </td>\n-                  </tal:block>\n-                </tr>\n-            </table>\n-            <div>\n-              <br />\n-              <input type="submit" name="form.button.Migrate" class="btn btn-primary" value="Migrate" i18n:attributes="value" i18n:domain="plone"/>&nbsp;\n-              <input type="submit" name="form.button.Cancel" class="btn btn-secondary" value="Cancel" i18n:attributes="value" i18n:domain="plone"/>\n-            </div>\n-            </form>\n-          </div>\n-        </div>\n-    </tal:block>\n-  <tal:block condition="not:at_types">\n-    <div class="important">\n-      <h2 i18n:translate="">Warning</h2>\n-      <p i18n:translate="" class="strong">No content to migrate.</p>\n-  </tal:block>\n-\n-</metal:block>\n-</metal:content-core>\n-</body>\n-</html>\ndiff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py\ndeleted file mode 100644\nindex 2cfdabb1..00000000\n--- a/plone/app/contenttypes/migration/custom_migration.py\n+++ /dev/null\n@@ -1,350 +0,0 @@\n-# -*- coding: UTF-8 -*-\n-from plone.app.contenttypes import _\n-from plone.app.contenttypes.migration.migration import migrateCustomAT\n-from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.interfaces import IDexterityFTI\n-from plone.dexterity.utils import iterSchemataForType\n-from Products.Archetypes.interfaces import IBaseObject\n-from Products.ATContentTypes.content.schemata import ATContentTypeSchema\n-from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.utils import safe_unicode\n-from Products.Five.browser import BrowserView\n-from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n-from Products.statusmessages.interfaces import IStatusMessage\n-from zExceptions import NotFound\n-from zope.i18n import translate\n-\n-import json\n-import logging\n-import traceback\n-\n-\n-logger = logging.getLogger(__name__)\n-\n-HAS_EXTENDER = True\n-try:\n-    from archetypes.schemaextender.extender import instanceSchemaFactory\n-except ImportError:\n-    HAS_EXTENDER = False\n-\n-\n-class CustomMigrationForm(BrowserView):\n-\n-    template = ViewPageTemplateFile(\'custom_migration.pt\')\n-    at_metadata_fields = ATContentTypeSchema.keys()\n-    dx_metadata_fields = list(at_metadata_fields)\n-    # some metadata names are different between AT and DX...\n-    dx_metadata_fields.remove(\'allowDiscussion\')\n-    dx_metadata_fields.remove(\'excludeFromNav\')\n-    dx_metadata_fields.append(\'allow_discussion\')\n-    dx_metadata_fields.append(\'exclude_from_nav\')\n-\n-    def __call__(self):\n-        # check that we can actually access this form,\n-        # aka the current user has an advice to add or edit\n-        form = self.request.form\n-        cancelled = form.get(\'form.button.Cancel\', False)\n-        submitted = form.get(\'form.button.Migrate\', False)\n-        # test = form.get(\'form.button.Test\', False)\n-        if submitted:\n-            # proceed, call the migration methdd\n-            results = self.migrate()\n-            messages = IStatusMessage(self.request)\n-            for migration_result in results:\n-                res_type = migration_result.get(\'type\')\n-                res_infos = migration_result.get(\'infos\')\n-                if res_infos.get(\'errors\'):\n-                    messages.add(\n-                        u\'Error when migrating "{0}" type. Check the \'\n-                        u\'log for other informations.\'.format(res_type),\n-                        type=u\'error\',\n-                    )\n-                else:\n-                    raw_message = \'Migration applied successfully for {0} \' \\\n-                        \'"{1}" items.\'\n-                    msg = translate(\n-                        raw_message.format(res_infos.get(\'counter\'), res_type),\n-                        domain=\'plone.app.contenttypes\',\n-                    )\n-                    messages.add(msg, type=u\'info\')\n-        elif cancelled:\n-            self.request.response.redirect(form.get(\'form.HTTP_REFERER\'))\n-        return self.index()\n-\n-    def getAllArchetypeTypes(self):\n-        at_types = self.getATFTIs()\n-        at_types.extend(self.getATTypesWithoutFTI())\n-        return at_types\n-\n-    def getATFTIs(self):\n-        \'\'\'Returns a list of all AT types with existing instances\n-        (including default-types).\n-        \'\'\'\n-        results = []\n-        archetype_tool = getToolByName(self.context, \'archetype_tool\', None)\n-        # if we do not have archetype_tool, it means that we have\n-        # no registered AT types\n-        if not archetype_tool:\n-            return results\n-\n-        typesTool = getToolByName(self.context, \'portal_types\')\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        registeredTypeNames = [registered[\'name\'] for registered\n-                               in archetype_tool.listRegisteredTypes()]\n-        for fti in typesTool.listTypeInfo():\n-            ftiId = fti.getId()\n-            if hasattr(fti, \'content_meta_type\') and \\\n-               fti.content_meta_type in registeredTypeNames and \\\n-               catalog(portal_type=ftiId):\n-                results.append({\'id\': ftiId,\n-                                \'title\': fti.Title(),\n-                                \'removed\': False})\n-        return results\n-\n-    def getATTypesWithoutFTI(self):\n-        """Returns a list of the id\'s of archetypes-types that are\n-           not registered in portal_types but still have instances.\n-        """\n-        results = []\n-        all_registered_types = [i[\'id\'] for i in self.getATFTIs()]\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        for meta_type in catalog.uniqueValuesFor(\'meta_type\'):\n-            # querying for meta_type will only return at-types\n-            brain = catalog(meta_type=meta_type, sort_limit=1)[0]\n-            try:\n-                obj = brain.getObject()\n-            except (KeyError, NotFound):\n-                continue\n-            if IDexterityContent.providedBy(obj):\n-                continue\n-            if not IBaseObject.providedBy(obj):\n-                # Discussion items are neither AT not DX\n-                continue\n-            typename = brain.portal_type\n-            if typename not in all_registered_types:\n-                results.append({\'id\': typename,\n-                                \'title\': typename,\n-                                \'removed\': True})\n-        return results\n-\n-    def getDXFTIs(self):\n-        \'\'\'Returns the FTI\'s of all DX-Types (including default-types).\'\'\'\n-        results = []\n-        portal = self.context\n-        ttool = getToolByName(portal, \'portal_types\')\n-        for fti in ttool.listTypeInfo():\n-            if IDexterityFTI.providedBy(fti):\n-                results.append({\'id\': fti.getId(),\n-                                \'title\': fti.Title()})\n-        return results\n-\n-    def getFieldsForATType(self, typeinfo):\n-        \'\'\'Returns schema fields (name and type) for the given AT typename.\'\'\'\n-        if typeinfo[\'removed\']:\n-            return self.getFieldsForATTypeWithoutFTI(typeinfo[\'id\'])\n-        return self.getFieldsForATTypeWithFTI(typeinfo[\'id\'])\n-\n-    def getFieldsForATTypeWithFTI(self, typename):\n-        \'\'\'Returns schema fields (name and type) from the fti.\'\'\'\n-        results = []\n-        typesTool = getToolByName(self.context, \'portal_types\')\n-        fti = typesTool.getTypeInfo(typename)\n-        archetype_tool = getToolByName(self.context, \'archetype_tool\', None)\n-        if not fti or not archetype_tool:\n-            return results\n-        schema = None\n-        # a schema instance is stored in the archetype_tool\n-        for regType in archetype_tool.listRegisteredTypes():\n-            if regType[\'meta_type\'] == fti.content_meta_type:\n-                if HAS_EXTENDER:\n-                    schema = instanceSchemaFactory(regType[\'klass\'])\n-                else:\n-                    schema = regType[\'schema\']\n-                break\n-        if not schema:\n-            return results\n-        for field in schema.fields():\n-            if not field.getName() in self.at_metadata_fields:\n-                translated_label = translate(safe_unicode(field.widget.label))\n-                results.append(\n-                    {\'id\': field.getName(),\n-                     \'title\': \'{0} ({1})\'.format(\n-                         translated_label,\n-                         field.getType()\n-                     ),\n-                     \'type\': field.getType()}\n-                )\n-        return results\n-\n-    def getFieldsForATTypeWithoutFTI(self, typename):\n-        """Returns a list of fields for archetypes-types without a fti.\n-           Instead of iterating over the schema in the fti it takes one\n-           instance and gets the schema from that.\n-        """\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        results = []\n-        brains = catalog(portal_type=typename, sort_limit=1)\n-        if not brains:\n-            return results\n-        try:\n-            obj = brains[0].getObject()\n-        except (KeyError, NotFound):\n-            return results\n-        for field_name in obj.schema._fields:\n-            field = obj.schema._fields[field_name]\n-            if not field.getName() in self.at_metadata_fields:\n-                translated_label = translate(field.widget.label)\n-                results.append(\n-                    {\'id\': field.getName(),\n-                     \'title\': \'{0} ({1})\'.format(\n-                         translated_label,\n-                         field.getType()\n-                     ),\n-                     \'type\': field.getType()}\n-                )\n-        return results\n-\n-    def getFieldsForDXType(self, typename):\n-        \'\'\'Returns schema fields (name and type) for the given DX typename.\'\'\'\n-        results = []\n-        typesTool = getToolByName(self.context, \'portal_types\')\n-        fti = typesTool.getTypeInfo(typename)\n-        if not fti:\n-            return results\n-\n-        for schemata in iterSchemataForType(typename):\n-            for fieldName, field in schemata.namesAndDescriptions():\n-                # ignore Dublin Core fields\n-                if fieldName in self.dx_metadata_fields:\n-                    continue\n-                translated_title = translate(field.title)\n-                class_name = field.__class__.__name__\n-                results.append(\n-                    {\'id\': fieldName,\n-                     \'title\': \'{0} ({1})\'.format(translated_title, class_name),\n-                     \'type\': class_name})\n-        return results\n-\n-    def getPossibleTargetField(self, fieldtype):\n-        \'\'\' a list of DX-field types\'\'\'\n-\n-    def isFolderish(self):\n-        \'\'\' decide which base-class we use for the migrator\'\'\'\n-\n-    def migrate(self, dry_run=False):\n-        \'\'\'Build data from the migration form. We will build a dict like :\n-           {\'MyATPortalType\':\n-                {\'MyDXPortalType\': (\n-                    {\'AT_field_name\': \'fieldname1\',\n-                     \'AT_field_type\': \'Products.Archetypes.Field.TextField\',\n-                     \'DX_field_name\': \'field_name1\',\n-                     \'DX_field_type\': \'RichText\'}, )}}\n-        Call the migrateCustomAT migrator for each AT content_type we choose\n-        to migrate.\n-        \'\'\'\n-        data = {}\n-        form = self.request.form\n-        patch_searchabletext = form.get(\'patch_searchabletext\')\n-        # manipulate what we receive in the form and build a useable data dict\n-        for k in self.request.form.keys():\n-            if k.startswith(\'dx_select_\'):\n-                # we found select where we choose a DX type regarding an AT\n-                # type the selelect name is like \'dx_select_MyATPortalType\'\n-                if not form[k] or (dry_run and k != form.get(\'tested_type\')):\n-                    # nothing selected in this select, continue\n-                    continue\n-                form_at_typename = k[10:]\n-                form_dx_typename = form[k]\n-                at_typename = form_at_typename.replace(\'_space_\', \' \')\n-                dx_typename = form_dx_typename.replace(\'_space_\', \' \')\n-\n-                data[at_typename] = {\'target_type\': dx_typename,\n-                                     \'field_mapping\': []}\n-                # now handle fields mapping for found DX/AT type migration\n-                # definition we have 2 keys with relevant mappings, first key\n-                # is the AT typename second key is a particular key like\n-                # \'dx_DXPortalType__for__MyATPortalType\n-                dx_key = \'dx_{0}__for__{1}\'.format(\n-                    form_dx_typename,\n-                    form_at_typename,\n-                )\n-                for at_field in form[form_at_typename]:\n-                    if form.get(dx_key) is None:\n-                        # No field-mappings\n-                        continue\n-                    dx_field = form[dx_key][form[form_at_typename].index(\n-                        at_field)]\n-                    if not dx_field:\n-                        # Do not migrate field\n-                        continue\n-                    at_field_name, at_field_type = at_field.split(\'__type__\')\n-                    dx_field_name, dx_field_type = dx_field.split(\'__type__\')\n-                    field_data = {\'AT_field_name\': at_field_name,\n-                                  \'AT_field_type\': at_field_type,\n-                                  \'DX_field_name\': dx_field_name,\n-                                  \'DX_field_type\': dx_field_type, }\n-                    data[at_typename][\'field_mapping\'].append(field_data)\n-\n-        # now that the data dict contains relevant information, we can call\n-        # the custom migrator\n-        migration_results = []\n-        for at_typename in data:\n-            fields_mapping = data[at_typename][\'field_mapping\']\n-            res = migrateCustomAT(\n-                fields_mapping=fields_mapping,\n-                src_type=at_typename,\n-                dst_type=data[at_typename][\'target_type\'],\n-                dry_run=dry_run,\n-                patch_searchabletext=patch_searchabletext,\n-                )\n-            migration_results.append({\'type\': at_typename,\n-                                      \'infos\': res})\n-        return migration_results\n-\n-\n-class DisplayDXFields(CustomMigrationForm):\n-\n-    template = ViewPageTemplateFile(\'custom_migration_display_dx_fields.pt\')\n-\n-    def __init__(self, context, request):\n-        CustomMigrationForm.__init__(self, context, request)\n-        self.at_typename = request.form.get(\'at_typename\')\n-        self.dx_typename = request.form.get(\'dx_typename\')\n-\n-    def __call__(self):\n-        \'\'\'\n-        \'\'\'\n-        return self.index()\n-\n-\n-class TestMigration(CustomMigrationForm):\n-\n-    def __call__(self):\n-        \'\'\'\n-        View that call migrate method with dry_run mode set.\n-        Returns a json response with the result.\n-        This view is called by a js.\n-        \'\'\'\n-        response = {}\n-        error_msg = _(u\'Migrating to this content type is impossible with \'\n-                      u\'this configuration\')\n-        try:\n-            results = self.migrate(dry_run=True)\n-        except Exception as e:\n-            trace = traceback.format_exc()\n-            msg = \'Test-Migration failed: {0}\\n{1}\\n\'.format(e, trace)\n-            logger.error(msg)\n-            response[\'status\'] = \'error\'\n-            response[\'message\'] = msg\n-            return json.dumps(response)\n-\n-        migration_result = results[0]\n-        res_infos = migration_result.get(\'infos\')\n-        if res_infos.get(\'errors\'):\n-            response[\'status\'] = \'error\'\n-            response[\'message\'] = error_msg\n-        else:\n-            response[\'status\'] = \'success\'\n-            response[\'message\'] = \'Testing migration succesful\'\n-        self.request.response.setHeader(\'Content-type\', \'application/json\')\n-        return json.dumps(response)\ndiff --git a/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt b/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt\ndeleted file mode 100644\nindex c8829ca3..00000000\n--- a/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt\n+++ /dev/null\n@@ -1,13 +0,0 @@\n-<tal:block tal:define="dx_typename view/dx_typename;\n-                       at_typename view/at_typename;\n-                       safe_dx_typename python:dx_typename.replace(\' \', \'_space_\');\n-                       safe_at_typename python:at_typename.replace(\' \', \'_space_\')">\n-<tal:loop repeat="at_field python: view.getFieldsForATTypeWithoutFTI(at_typename)">\n-    <select tal:attributes="name string:dx_${safe_dx_typename}__for__${safe_at_typename}:list;">\n-        <option value="">Do not migrate</option>\n-        <option tal:repeat="dx_field python: view.getFieldsForDXType(dx_typename)"\n-                tal:attributes="value string:${dx_field/id}__type__${dx_field/type};"\n-                tal:content="string:${dx_field/title}">DX field name</option>\n-    </select>\n-</tal:loop>\n-</tal:block>\n\\ No newline at end of file\ndiff --git a/plone/app/contenttypes/migration/dxmigration.py b/plone/app/contenttypes/migration/dxmigration.py\ndeleted file mode 100644\nindex b356ddbd..00000000\n--- a/plone/app/contenttypes/migration/dxmigration.py\n+++ /dev/null\n@@ -1,198 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.contenttypes.interfaces import IEvent\n-from plone.app.contenttypes.migration.field_migrators import datetime_fixer\n-from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.interfaces import IDexterityFTI\n-from plone.dexterity.schema import SCHEMA_CACHE\n-from plone.event.utils import default_timezone\n-from plone.folder.interfaces import IOrdering\n-from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base\n-from Products.CMFCore.utils import getToolByName\n-from Products.contentmigration.basemigrator.migrator import CMFItemMigrator\n-from Products.contentmigration.basemigrator.walker import CatalogWalker\n-from zExceptions import NotFound\n-from zope.annotation.interfaces import IAnnotations\n-from zope.component import queryUtility\n-from zope.component.hooks import getSite\n-from zope.interface import alsoProvides\n-\n-import importlib\n-import logging\n-\n-\n-logger = logging.getLogger(__name__)\n-\n-\n-def migrate(portal, migrator):\n-    """return a CatalogWalker instance in order\n-    to have its output after migration"""\n-    walker = CatalogWalker(portal, migrator)()\n-    return walker\n-\n-\n-class ContentMigrator(CMFItemMigrator):\n-    """Base for contentish DX\n-    """\n-\n-    def migrate_atctmetadata(self):\n-        self.new.exclude_from_nav = self.old.exclude_from_nav\n-\n-\n-def migrate_to_pa_event(context):\n-    # Install plone.app.event\n-    context.runAllImportStepsFromProfile(\'profile-plone.app.event:default\')\n-    # Re-import types to get newest Event type\n-    context.runImportStepFromProfile(\n-        \'profile-plone.app.contenttypes:default\',\n-        \'typeinfo\'\n-    )\n-    portal = getSite()\n-    migrate(portal, DXOldEventMigrator)\n-    SCHEMA_CACHE.clear()\n-\n-\n-class DXOldEventMigrator(ContentMigrator):\n-    """Migrator for 1.0 plone.app.contenttypes DX events"""\n-\n-    src_portal_type = \'Event\'\n-    src_meta_type = \'Dexterity Item\'\n-    dst_portal_type = \'Event\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate(self):\n-        # Only migrate items using old Schema\n-        if IEvent.providedBy(self.old) and hasattr(self.old, \'start_date\'):\n-            ContentMigrator.migrate(self)\n-\n-    def migrate_schema_fields(self):\n-        timezone = str(self.old.start_date.tzinfo) \\\n-            if self.old.start_date.tzinfo \\\n-            else default_timezone(fallback=\'UTC\')\n-\n-        self.new.start = datetime_fixer(self.old.start_date, timezone)\n-        self.new.end = datetime_fixer(self.old.end_date, timezone)\n-\n-        if hasattr(self.old, \'location\'):\n-            self.new.location = self.old.location\n-        if hasattr(self.old, \'attendees\'):\n-            self.new.attendees = tuple(self.old.attendees.splitlines())\n-        if hasattr(self.old, \'event_url\'):\n-            self.new.event_url = self.old.event_url\n-        if hasattr(self.old, \'contact_name\'):\n-            self.new.contact_name = self.old.contact_name\n-        if hasattr(self.old, \'contact_email\'):\n-            self.new.contact_email = self.old.contact_email\n-        if hasattr(self.old, \'contact_phone\'):\n-            self.new.contact_phone = self.old.contact_phone\n-        if hasattr(self.old, \'text\'):\n-            # Copy the entire richtext object, not just it\'s representation\n-            self.new.text = self.old.text\n-\n-\n-class DXEventMigrator(ContentMigrator):\n-    """Migrator for plone.app.event.dx events"""\n-\n-    src_portal_type = \'plone.app.event.dx.event\'\n-    src_meta_type = \'Dexterity Item\'\n-    dst_portal_type = \'Event\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        self.new.start = datetime_fixer(self.old.start, self.old.timezone)\n-        self.new.end = datetime_fixer(self.old.end, self.old.timezone)\n-        self.new.whole_day = self.old.whole_day\n-        self.new.open_end = self.old.open_end\n-        self.new.recurrence = self.old.recurrence\n-        self.new.location = self.old.location\n-        self.new.attendees = self.old.attendees\n-        self.new.event_url = self.old.event_url\n-        self.new.contact_name = self.old.contact_name\n-        self.new.contact_email = self.old.contact_email\n-        self.new.contact_phone = self.old.contact_phone\n-        # The old behavior for the rich text field does not exist an more.\n-        # Look up the old value directly from the Annotation storage\n-        # Copy the entire richtext object, not just it\'s representation\n-        annotations = IAnnotations(self.old)\n-        old_text = annotations.get(\n-            \'plone.app.event.dx.behaviors.IEventSummary.text\', None)\n-        self.new.text = old_text\n-\n-\n-def get_old_class_name_string(obj):\n-    """Returns the current class name string."""\n-    return \'{0}.{1}\'.format(obj.__module__, obj.__class__.__name__)\n-\n-\n-def get_portal_type_name_string(obj):\n-    """Returns the klass-attribute of the fti."""\n-    fti = queryUtility(IDexterityFTI, name=obj.portal_type)\n-    if not fti:\n-        return False\n-    return fti.klass\n-\n-\n-def migrate_base_class_to_new_class(obj,\n-                                    indexes=None,\n-                                    old_class_name=\'\',\n-                                    new_class_name=\'\',\n-                                    migrate_to_folderish=False,\n-                                    ):\n-    if indexes is None:\n-        indexes = [\'is_folderish\', \'object_provides\']\n-    if not old_class_name:\n-        old_class_name = get_old_class_name_string(obj)\n-    if not new_class_name:\n-        new_class_name = get_portal_type_name_string(obj)\n-        if not new_class_name:\n-            logger.warning(\n-                \'The type {0} has no fti!\'.format(obj.portal_type))\n-            return False\n-\n-    was_item = not isinstance(obj, BTreeFolder2Base)\n-    if old_class_name != new_class_name:\n-        obj_id = obj.getId()\n-        module_name, class_name = new_class_name.rsplit(\'.\', 1)\n-        module = importlib.import_module(module_name)\n-        new_class = getattr(module, class_name)\n-\n-        # update obj class\n-        parent = obj.__parent__\n-        parent._delOb(obj_id)\n-        obj.__class__ = new_class\n-        parent._setOb(obj_id, obj)\n-\n-    is_container = isinstance(obj, BTreeFolder2Base)\n-\n-    if was_item and is_container or migrate_to_folderish and is_container:\n-        alsoProvides(obj, IOrdering)\n-        #  If Itemish becomes Folderish we have to update obj _tree\n-        BTreeFolder2Base._initBTrees(obj)\n-\n-    # reindex\n-    obj.reindexObject(indexes)\n-\n-    return True\n-\n-\n-def list_of_objects_with_changed_base_class(context):\n-    catalog = getToolByName(context, \'portal_catalog\')\n-    for brain in catalog(object_provides=IDexterityContent.__identifier__):\n-        try:\n-            obj = brain.getObject()\n-        except (KeyError, NotFound):\n-            logger.warn(\'Object {0} not found\'.format(brain.getPath()))\n-            continue\n-        if get_portal_type_name_string(obj) != get_old_class_name_string(obj):\n-            yield obj\n-\n-\n-def list_of_changed_base_class_names(context):\n-    """Returns list of class names that are not longer in portal_types."""\n-    changed_base_class_names = {}\n-    for obj in list_of_objects_with_changed_base_class(context):\n-        changed_base_class_name = get_old_class_name_string(obj)\n-        if changed_base_class_name not in changed_base_class_names:\n-            changed_base_class_names[changed_base_class_name] = 1\n-        else:\n-            changed_base_class_names[changed_base_class_name] += 1\n-    return changed_base_class_names\ndiff --git a/plone/app/contenttypes/migration/field_migrators.py b/plone/app/contenttypes/migration/field_migrators.py\ndeleted file mode 100644\nindex d4be41ab..00000000\n--- a/plone/app/contenttypes/migration/field_migrators.py\n+++ /dev/null\n@@ -1,178 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.textfield.value import RichTextValue\n-from plone.event.utils import default_timezone\n-from plone.namedfile.file import NamedBlobFile\n-from plone.namedfile.file import NamedBlobImage\n-from Products.CMFPlone.utils import safe_hasattr\n-from Products.CMFPlone.utils import safe_unicode\n-\n-import logging\n-import pytz\n-\n-\n-logger = logging.getLogger(__name__)\n-\n-\n-def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """Migrate a generic simple field.\n-\n-    Copies the value of a Archetypes-object to a attribute of the same name\n-    to the target-object. The only transform is a safe_unicode of the value.\n-    """\n-    field = src_obj.getField(src_fieldname)\n-    if field:\n-        at_value = field.get(src_obj)\n-    else:\n-        at_value = getattr(src_obj, src_fieldname, None)\n-        if at_value and hasattr(at_value, \'__call__\'):\n-            at_value = at_value()\n-    if isinstance(at_value, tuple):\n-        at_value = tuple(safe_unicode(i) for i in at_value)\n-    if isinstance(at_value, list):\n-        at_value = [safe_unicode(i) for i in at_value]\n-    if at_value:\n-        setattr(dst_obj, dst_fieldname, safe_unicode(at_value))\n-\n-\n-def migrate_richtextfield(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """\n-    migrate a rich text field.\n-    This field needs some extra stuffs like keep the same mimetype.\n-    """\n-    field = src_obj.getField(src_fieldname)\n-    raw_text = \'\'\n-    if field:\n-        mime_type = field.getContentType(src_obj)\n-        raw_text = safe_unicode(field.getRaw(src_obj))\n-    else:\n-        at_value = getattr(src_obj, src_fieldname, None)\n-        if at_value:\n-            mime_type = at_value.mimetype\n-            raw_text = safe_unicode(at_value.raw)\n-\n-    if raw_text.strip() == \'\':\n-        return\n-    richtext = RichTextValue(raw=raw_text, mimeType=mime_type,\n-                             outputMimeType=\'text/x-html-safe\')\n-    setattr(dst_obj, dst_fieldname, richtext)\n-\n-\n-def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """\n-    migrate an image field.\n-    This field needs to be migrated with an NamedBlobImage instance.\n-    """\n-    # get old image data and filename\n-    field = src_obj.getField(src_fieldname)\n-    accessor = field.getAccessor(src_obj)\n-    old_image = accessor()\n-    if old_image == \'\':\n-        return\n-    filename = safe_unicode(old_image.filename)\n-    old_image_data = old_image.data\n-    if safe_hasattr(old_image_data, \'data\'):\n-        old_image_data = old_image_data.data\n-\n-    # create the new image field\n-    namedblobimage = NamedBlobImage(data=old_image_data,\n-                                    filename=filename)\n-\n-    # set new field on destination object\n-    setattr(dst_obj, dst_fieldname, namedblobimage)\n-\n-    # handle a possible image caption field\n-    # postulate is the old caption field name is ending by \'Caption\'\n-    # and the new field name is ending by \'_caption\'\n-    # is this postulate correct ?\n-    # should this field not be handle by itself because it will appear in the\n-    # old field list ?\n-    caption_field = src_obj.getField(\'{0}Caption\'.format(src_fieldname), None)\n-    if caption_field:\n-        setattr(dst_obj,\n-                (\'{0}_caption\'.format(dst_fieldname)),\n-                safe_unicode(caption_field.get(src_obj)))\n-\n-    logger.info(u\'Migrating image {0}\'.format(filename))\n-\n-\n-def migrate_blobimagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """\n-    migrate an image field.\n-    Actually this field needs only to copy the existing NamedBlobImage instance\n-    to the new dst_obj, but we do some more in detail and create new fields.\n-    """\n-    old_image = getattr(src_obj, src_fieldname)\n-    if old_image == \'\':\n-        return\n-    filename = safe_unicode(old_image.filename)\n-    old_image_data = old_image.data\n-    if safe_hasattr(old_image_data, \'data\'):\n-        old_image_data = old_image_data.data\n-    namedblobimage = NamedBlobImage(data=old_image_data,\n-                                    filename=filename)\n-\n-    # set new field on destination object\n-    setattr(dst_obj, dst_fieldname, namedblobimage)\n-\n-    # handle a possible image caption field\n-    field = \'{0}_caption\'.format(src_fieldname)\n-    old_image_caption = getattr(src_obj, field, None)\n-    if old_image_caption:\n-        setattr(dst_obj,\n-                (\'{0}_caption\'.format(dst_fieldname)),\n-                safe_unicode(old_image_caption))\n-\n-    logger.info(u\'Migrating image {0}\'.format(filename))\n-\n-\n-def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """\n-    migrate a file field.\n-    This field needs to be migrated with an NamedBlobFile instance.\n-    """\n-    old_file = src_obj.getField(src_fieldname).get(src_obj)\n-    if old_file == \'\':\n-        return\n-    filename = safe_unicode(old_file.filename)\n-    old_file_data = old_file.data\n-    if safe_hasattr(old_file_data, \'data\'):\n-        old_file_data = old_file_data.data\n-    namedblobfile = NamedBlobFile(\n-        contentType=old_file.content_type,\n-        data=old_file_data,\n-        filename=filename)\n-    setattr(dst_obj, dst_fieldname, namedblobfile)\n-    logger.info(u\'Migrating file {0}\'.format(filename))\n-\n-\n-def migrate_datetimefield(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """Migrate a datefield."""\n-    old_value = src_obj.getField(src_fieldname).get(src_obj)\n-    if old_value == \'\' or old_value is None:\n-        return\n-    if src_obj.getField(\'timezone\', None) is not None:\n-        old_timezone = src_obj.getField(\'timezone\').get(src_obj)\n-    else:\n-        old_timezone = default_timezone(fallback=\'UTC\')\n-    new_value = datetime_fixer(old_value.asdatetime(), old_timezone)\n-    setattr(dst_obj, dst_fieldname, new_value)\n-\n-\n-def datetime_fixer(dt, zone):\n-    timezone = pytz.timezone(zone)\n-    if dt.tzinfo is None:\n-        return timezone.localize(dt)\n-    else:\n-        return timezone.normalize(dt)\n-\n-\n-# This mapping is needed to get the right migration method\n-# we use the full field type path as it is retrieved from the target-field\n-# (field.getType()), to avoid conflict.\n-# TODO In the __future__ we should have a more dynamic way to configure this\n-# mapping\n-FIELDS_MAPPING = {\'RichText\': migrate_richtextfield,\n-                  \'NamedBlobFile\': migrate_filefield,\n-                  \'NamedBlobImage\': migrate_imagefield,\n-                  \'Datetime\': migrate_datetimefield,\n-                  \'Date\': migrate_datetimefield}\ndiff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py\ndeleted file mode 100644\nindex 050c75bb..00000000\n--- a/plone/app/contenttypes/migration/migration.py\n+++ /dev/null\n@@ -1,581 +0,0 @@\n-# -*- coding: utf-8 -*-\n-"""\n-Migrating ATContentTypes to plone.app.contenttypes objects.\n-\n-This module imports from Product.contentmigration on which we depend\n-only in the setuptools extra_requiers [migrate_atct]. Importing this\n-module will only work if Products.contentmigration is installed so make sure\n-you catch ImportErrors\n-"""\n-from plone.app.contenttypes.behaviors.collection import ICollection\n-from plone.app.contenttypes.migration.dxmigration import DXEventMigrator\n-from plone.app.contenttypes.migration.dxmigration import DXOldEventMigrator\n-from plone.app.contenttypes.migration.field_migrators import FIELDS_MAPPING\n-from plone.app.contenttypes.migration.field_migrators import migrate_blobimagefield  # noqa\n-from plone.app.contenttypes.migration.field_migrators import migrate_datetimefield  # noqa\n-from plone.app.contenttypes.migration.field_migrators import migrate_filefield\n-from plone.app.contenttypes.migration.field_migrators import migrate_imagefield\n-from plone.app.contenttypes.migration.field_migrators import migrate_richtextfield  # noqa\n-from plone.app.contenttypes.migration.field_migrators import migrate_simplefield  # noqa\n-from plone.app.contenttypes.migration.patches import patch_before_migration\n-from plone.app.contenttypes.migration.patches import undo_patch_after_migration\n-from plone.app.contenttypes.migration.utils import copy_contentrules\n-from plone.app.contenttypes.migration.utils import migrate_leadimage\n-from plone.app.contenttypes.migration.utils import migrate_portlets\n-from plone.app.contenttypes.migration.utils import move_comments\n-from plone.app.contenttypes.upgrades import LISTING_VIEW_MAPPING\n-from plone.app.dexterity.behaviors.nextprevious import INextPreviousToggle\n-from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.interfaces import IDexterityFTI\n-from Products.CMFCore.utils import getToolByName\n-from Products.contentmigration.basemigrator.migrator import CMFFolderMigrator\n-from Products.contentmigration.basemigrator.migrator import CMFItemMigrator\n-from Products.contentmigration.basemigrator.walker import CatalogWalker\n-from Products.contentmigration.walker import CustomQueryWalker\n-from Acquisition import aq_base\n-from zExceptions import NotFound\n-from zope.component import adapter\n-from zope.component import getAdapters\n-from zope.component import getMultiAdapter\n-from zope.component.hooks import getSite\n-from zope.interface import implementer\n-from zope.interface import Interface\n-\n-import logging\n-import transaction\n-\n-\n-logger = logging.getLogger(__name__)\n-\n-\n-def migrate(portal, migrator):\n-    """return a CatalogWalker instance in order\n-    to have its output after migration"""\n-    walker = CatalogWalker(portal, migrator)()\n-    return walker\n-\n-\n-class ICustomMigrator(Interface):\n-    """Adapter implementer interface for custom migrators.\n-    Please note that you have to register named adapters in order to be able to\n-    register multiple adapters to the same adaptee.\n-    """\n-    def migrate(old, new):\n-        """Start the custom migraton.\n-        :param old: The old content object.\n-        :param new: The new content object.\n-        """\n-\n-\n-@implementer(ICustomMigrator)\n-@adapter(Interface)\n-class BaseCustomMigator(object):\n-    """Base custom migration class. Does nothing.\n-\n-    You can use this as base class for your custom migrator adapters.\n-    You might register it to some specific orginal content interface.\n-    """\n-\n-    def __init__(self, context):\n-        self.context = context\n-\n-    def migrate(self, old, new):\n-        return\n-\n-\n-class ATCTContentMigrator(CMFItemMigrator):\n-    """Base for contentish ATCT\n-    """\n-\n-    def __init__(self, *args, **kwargs):\n-        super(ATCTContentMigrator, self).__init__(*args, **kwargs)\n-        logger.info(\n-            \'Migrating {0} {1}\'.format(\n-                self.old.portal_type,\n-                \'/\'.join(self.old.getPhysicalPath())\n-            )\n-        )\n-\n-    def beforeChange_store_default_page(self):\n-        """If the item is the default page store that info to set it again.\n-\n-        Products.CMFDynamicViewFTI.browserdefault.check_default_page\n-        would unset the default page during the migration.\n-        """\n-        context_state = getMultiAdapter(\n-            (self.old, self.old.REQUEST), name=u\'plone_context_state\')\n-        if context_state.is_default_page():\n-            setattr(self.old, \'_migration_is_default_page\', True)\n-\n-    def beforeChange_store_comments_on_portal(self):\n-        """Comments from plone.app.discussion are lost when the\n-           old object is renamed...\n-           We save the comments in a safe place..."""\n-        portal = getToolByName(self.old, \'portal_url\').getPortalObject()\n-        move_comments(self.old, portal)\n-\n-    def migrate_atctmetadata(self):\n-        field = self.old.getField(\'excludeFromNav\')\n-        if field:\n-            self.new.exclude_from_nav = field.get(self.old)\n-\n-    def migrate_custom(self):\n-        """Get all ICustomMigrator registered migrators and run the migration.\n-        """\n-        for _, migrator in getAdapters((self.old,), ICustomMigrator):\n-            migrator.migrate(self.old, self.new)\n-\n-    def migrate_portlets(self):\n-        migrate_portlets(self.old, self.new)\n-\n-    def migrate_contentrules(self):\n-        copy_contentrules(self.old, self.new)\n-\n-    def migrate_leadimage(self):\n-        migrate_leadimage(self.old, self.new)\n-\n-    def last_migrate_comments(self):\n-        """Migrate the plone.app.discussion comments.\n-           Comments were stored on the portal, get them and\n-           Copy the conversations from old to new object."""\n-        portal = getToolByName(self.old, \'portal_url\').getPortalObject()\n-        move_comments(portal, self.new)\n-\n-    def last_migrate_default_page(self):\n-        """If the item was the default page set it again."""\n-        if getattr(self.old, \'_migration_is_default_page\', False):\n-            parent = self.new.__parent__\n-            parent.setDefaultPage(self.new.id)\n-\n-\n-class ATCTFolderMigrator(CMFFolderMigrator):\n-    """Base for folderish ATCT\n-    """\n-\n-    def __init__(self, *args, **kwargs):\n-        super(ATCTFolderMigrator, self).__init__(*args, **kwargs)\n-        logger.info(\n-            \'Migrating {0} {1}\'.format(\n-                self.old.portal_type,\n-                \'/\'.join(self.old.getPhysicalPath()))\n-        )\n-\n-    def beforeChange_store_comments_on_portal(self):\n-        """Comments from plone.app.discussion are lost when the\n-           old object is renamed...\n-           We save the comments in a safe place..."""\n-        portal = getToolByName(self.old, \'portal_url\').getPortalObject()\n-        move_comments(self.old, portal)\n-\n-    def migrate_atctmetadata(self):\n-        field = self.old.getField(\'excludeFromNav\')\n-        if field:\n-            self.new.exclude_from_nav = field.get(self.old)\n-\n-    def migrate_custom(self):\n-        """Get all ICustomMigrator registered migrators and run the migration.\n-        """\n-        for _, migrator in getAdapters((self.old,), ICustomMigrator):\n-            migrator.migrate(self.old, self.new)\n-\n-    def migrate_portlets(self):\n-        migrate_portlets(self.old, self.new)\n-\n-    def migrate_contentrules(self):\n-        copy_contentrules(self.old, self.new)\n-\n-    def migrate_leadimage(self):\n-        migrate_leadimage(self.old, self.new)\n-\n-    def migrate_nextprevious(self):\n-        try:\n-            enabled = self.old.getNextPreviousEnabled()\n-        except AttributeError:\n-            # The old type may not have this.\n-            # https://github.com/plone/plone.app.contenttypes/issues/582\n-            return\n-        if enabled and INextPreviousToggle.providedBy(self.new):\n-            self.new.nextPreviousEnabled = True\n-\n-    def last_migrate_comments(self):\n-        """Migrate the plone.app.discussion comments.\n-           Comments were stored on the portal, get them and\n-           Copy the conversations from old to new object."""\n-        portal = getToolByName(self.old, \'portal_url\').getPortalObject()\n-        move_comments(portal, self.new)\n-\n-    def last_migrate_layout(self):\n-        """Migrate the layout (view method).\n-\n-        This needs to be done last, as otherwise our changes in\n-        migrate_criteria may get overriden by a later call to\n-        migrate_properties.\n-        """\n-        old_layout = getattr(aq_base(self.old), \'layout\', None)\n-        if old_layout:\n-            default_page = getattr(aq_base(self.old), \'default_page\', None)\n-            try:\n-                # Delete old-style layout attribute.\n-                del self.new.layout\n-            except AttributeError:\n-                pass\n-            # always copy over the layout, transform if necessary\n-            self.new.setLayout(LISTING_VIEW_MAPPING.get(old_layout, old_layout))  # noqa\n-            if default_page:\n-                # any defaultPage is switched of by setLayout\n-                # and needs to set again if it was directly on the object\n-                self.new.setDefaultPage(default_page)\n-\n-\n-class DocumentMigrator(ATCTContentMigrator):\n-\n-    src_portal_type = \'Document\'\n-    src_meta_type = \'ATDocument\'\n-    dst_portal_type = \'Document\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-\n-\n-def migrate_documents(portal):\n-    return migrate(portal, DocumentMigrator)\n-\n-\n-class FileMigrator(ATCTContentMigrator):\n-\n-    src_portal_type = \'File\'\n-    src_meta_type = \'ATFile\'\n-    dst_portal_type = \'File\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_filefield(self.old, self.new, \'file\', \'file\')\n-\n-\n-def migrate_files(portal):\n-    return migrate(portal, FileMigrator)\n-\n-\n-class BlobFileMigrator(FileMigrator):\n-\n-    src_portal_type = \'File\'\n-    src_meta_type = \'ATBlob\'\n-    dst_portal_type = \'File\'\n-    dst_meta_type = None  # not used\n-\n-\n-def migrate_blobfiles(portal):\n-    return migrate(portal, BlobFileMigrator)\n-\n-\n-class ImageMigrator(ATCTContentMigrator):\n-\n-    src_portal_type = \'Image\'\n-    src_meta_type = \'ATImage\'\n-    dst_portal_type = \'Image\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_imagefield(self.old, self.new, \'image\', \'image\')\n-\n-\n-def migrate_images(portal):\n-    return migrate(portal, ImageMigrator)\n-\n-\n-class BlobImageMigrator(ImageMigrator):\n-\n-    src_portal_type = \'Image\'\n-    src_meta_type = \'ATBlob\'\n-    dst_portal_type = \'Image\'\n-    dst_meta_type = None  # not used\n-\n-\n-def migrate_blobimages(portal):\n-    return migrate(portal, BlobImageMigrator)\n-\n-\n-class LinkMigrator(ATCTContentMigrator):\n-\n-    src_portal_type = \'Link\'\n-    src_meta_type = \'ATLink\'\n-    dst_portal_type = \'Link\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_simplefield(self.old, self.new, \'remoteUrl\', \'remoteUrl\')\n-\n-\n-def migrate_links(portal):\n-    return migrate(portal, LinkMigrator)\n-\n-\n-class NewsItemMigrator(ATCTContentMigrator):\n-\n-    src_portal_type = \'News Item\'\n-    src_meta_type = \'ATNewsItem\'\n-    dst_portal_type = \'News Item\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-        migrate_imagefield(self.old, self.new, \'image\', \'image\')\n-        migrate_simplefield(self.old, self.new, \'imageCaption\', \'imageCaption\')\n-\n-\n-def migrate_newsitems(portal):\n-    return migrate(portal, NewsItemMigrator)\n-\n-\n-class BlobNewsItemMigrator(ATCTContentMigrator):\n-    """ Migrator for NewsItems with blobs based on the implementation in\n-        https://github.com/plone/plone.app.blob/pull/2\n-    """\n-\n-    src_portal_type = \'News Item\'\n-    src_meta_type = \'ATBlobContent\'\n-    dst_portal_type = \'News Item\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-        migrate_blobimagefield(self.old, self.new, \'image\', \'image\')\n-        migrate_simplefield(self.old, self.new, \'imageCaption\', \'imageCaption\')\n-\n-\n-def migrate_blobnewsitems(portal):\n-    return migrate(portal, BlobNewsItemMigrator)\n-\n-\n-class FolderMigrator(ATCTFolderMigrator):\n-\n-    src_portal_type = \'Folder\'\n-    src_meta_type = \'ATFolder\'\n-    dst_portal_type = \'Folder\'\n-    dst_meta_type = None  # not used\n-\n-\n-def migrate_folders(portal):\n-    return migrate(portal, FolderMigrator)\n-\n-\n-class CollectionMigrator(ATCTContentMigrator):\n-    """Migrator for at-based collections provided by plone.app.collection\n-    to\n-    """\n-\n-    src_portal_type = \'Collection\'\n-    src_meta_type = \'Collection\'\n-    dst_portal_type = \'Collection\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-        wrapped_new = ICollection(self.new)\n-        # using migrate_simplefield on \'query\' returns the ContentListing obj\n-        wrapped_new.query = self.old.query\n-        migrate_simplefield(self.old, wrapped_new, \'sort_on\', \'sort_on\')\n-        migrate_simplefield(\n-            self.old, wrapped_new, \'sort_reversed\', \'sort_reversed\')\n-        migrate_simplefield(self.old, wrapped_new, \'limit\', \'limit\')\n-        migrate_simplefield(\n-            self.old, wrapped_new, \'customViewFields\', \'customViewFields\')\n-\n-    def last_migrate_layout(self):\n-        """Migrate the layout (view method).\n-\n-        This needs to be done last, as otherwise our changes may get overriden\n-        by a later call to migrate_properties.\n-        """\n-        old_layout = self.old.getLayout() or getattr(self.old, \'layout\', None)\n-        if old_layout:\n-            try:\n-                # Delete old-style layout attribute.\n-                del self.new.layout\n-            except AttributeError:\n-                pass\n-            self.new.setLayout(LISTING_VIEW_MAPPING.get(old_layout, old_layout))  # noqa\n-\n-\n-def migrate_collections(portal):\n-    return migrate(portal, CollectionMigrator)\n-\n-\n-class EventMigrator(ATCTContentMigrator):\n-    """Migrate both Products.ContentTypes & plone.app.event.at Events"""\n-\n-    src_portal_type = \'Event\'\n-    src_meta_type = \'ATEvent\'\n-    dst_portal_type = \'Event\'\n-    dst_meta_type = None  # not used\n-\n-    def migrate_schema_fields(self):\n-        migrate_datetimefield(self.old, self.new, \'startDate\', \'start\')\n-        migrate_datetimefield(self.old, self.new, \'endDate\', \'end\')\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-        migrate_simplefield(self.old, self.new, \'location\', \'location\')\n-        migrate_simplefield(self.old, self.new, \'attendees\', \'attendees\')\n-        migrate_simplefield(self.old, self.new, \'eventUrl\', \'event_url\')\n-        migrate_simplefield(self.old, self.new, \'contactName\', \'contact_name\')\n-        migrate_simplefield(\n-            self.old, self.new, \'contactEmail\', \'contact_email\')\n-        migrate_simplefield(\n-            self.old, self.new, \'contactPhone\', \'contact_phone\')\n-        migrate_simplefield(self.old, self.new, \'wholeDay\', \'whole_day\')\n-        migrate_simplefield(self.old, self.new, \'openEnd\', \'open_end\')\n-        migrate_simplefield(self.old, self.new, \'recurrence\', \'recurrence\')\n-\n-\n-def migrate_events(portal):\n-    migrate(portal, DXOldEventMigrator)\n-    migrate(portal, EventMigrator)\n-    migrate(portal, DXEventMigrator)\n-\n-\n-def makeCustomATMigrator(\n-    context,\n-    src_type,\n-    dst_type,\n-    fields_mapping,\n-    is_folderish=False,\n-    dry_run=False\n-):\n-    """ generate a migrator for the given at-based folderish portal type """\n-\n-    base_class = ATCTContentMigrator\n-    if is_folderish:\n-        base_class = ATCTFolderMigrator\n-\n-    class CustomATMigrator(base_class):\n-\n-        src_portal_type = src_type\n-        dst_portal_type = dst_type\n-        dry_run_mode = dry_run\n-\n-        def migrate_schema_fields(self):\n-            for fields_dict in fields_mapping:\n-                at_fieldname = fields_dict.get(\'AT_field_name\')\n-                dx_fieldname = fields_dict.get(\'DX_field_name\')\n-                dx_fieldtype = fields_dict.get(\'DX_field_type\')\n-                migration_field_method = fields_dict.get(\'field_migrator\')\n-                if not migration_field_method:\n-                    if dx_fieldtype in FIELDS_MAPPING:\n-                        # Richtext, Image and File have custom migraton_methods\n-                        migration_field_method = FIELDS_MAPPING[dx_fieldtype]\n-                    else:\n-                        migration_field_method = migrate_simplefield\n-                migration_field_method(src_obj=self.old,\n-                                       dst_obj=self.new,\n-                                       src_fieldname=at_fieldname,\n-                                       dst_fieldname=dx_fieldname)\n-\n-        def last_migrate_check(self):\n-            """\n-            BBB to be checked\n-            if there is an error with the fields, an exception will be raised.\n-            """\n-            if self.dry_run_mode:\n-                view = getMultiAdapter(\n-                    (self.new, self.new.REQUEST), name=\'view\')\n-                view()\n-\n-    return CustomATMigrator\n-\n-\n-def migrateCustomAT(fields_mapping,\n-                    src_type,\n-                    dst_type,\n-                    dry_run=False,\n-                    patch_linkintegrity=False,\n-                    patch_searchabletext=False,\n-                    query=None,\n-                    ):\n-    """\n-    Try to get types infos from archetype_tool, then set a migrator and pass it\n-    given values. There is a dry_run mode that allows to check the success of\n-    a migration without committing.\n-    """\n-    portal = getSite()\n-\n-    # Patch various things that make migration harder\n-    (link_integrity,\n-     queue_indexing,\n-     patch_searchabletext) = patch_before_migration(patch_searchabletext)\n-\n-    # if the type still exists get the src_meta_type from the portal_type\n-    portal_types = getToolByName(portal, \'portal_types\')\n-    fti = portal_types.get(src_type, None)\n-    # Check if the fti was removed or replaced by a DX-implementation\n-    if fti is None or IDexterityFTI.providedBy(fti):\n-        # Get the needed info from an instance of the type\n-        catalog = portal.portal_catalog\n-        brains = catalog(portal_type=src_type, sort_limit=1)\n-        if not brains:\n-            # no item? assume stuff\n-            is_folderish = False\n-            src_meta_type = src_type\n-        else:\n-            try:\n-                src_obj = brains[0].getObject()\n-            except (KeyError, NotFound):\n-                logger.error(\n-                    \'Could not find the object for brain at %s\',\n-                    brains[0].getURL())\n-                return\n-            if IDexterityContent.providedBy(src_obj):\n-                logger.error(\n-                    \'%s should not be dexterity object!\',\n-                    src_obj.absolute_url())\n-            is_folderish = getattr(src_obj, \'isPrincipiaFolderish\', False)\n-            src_meta_type = src_obj.meta_type\n-    else:\n-        # fallback\n-        is_folderish = False\n-        # Get info from at-fti\n-        src_meta_type = fti.content_meta_type\n-        archetype_tool = getToolByName(portal, \'archetype_tool\', None)\n-        for info in archetype_tool.listRegisteredTypes():\n-            # lookup registered type in archetype_tool with meta_type\n-            # because several portal_types can use same meta_type\n-            if info.get(\'meta_type\') == src_meta_type:\n-                klass = info.get(\'klass\', None)\n-                is_folderish = klass.isPrincipiaFolderish\n-                break\n-\n-    migrator = makeCustomATMigrator(context=portal,\n-                                    src_type=src_type,\n-                                    dst_type=dst_type,\n-                                    fields_mapping=fields_mapping,\n-                                    is_folderish=is_folderish,\n-                                    dry_run=dry_run)\n-    walker_infos = None\n-    if migrator:\n-        migrator.src_meta_type = src_meta_type\n-        migrator.dst_meta_type = \'\'\n-        walker_settings = {\'portal\': portal,\n-                           \'migrator\': migrator,\n-                           \'src_portal_type\': src_type,\n-                           \'dst_portal_type\': dst_type,\n-                           \'src_meta_type\': src_meta_type,\n-                           \'dst_meta_type\': \'\',\n-                           \'use_savepoint\': True}\n-        if query:\n-            walker_settings[\'query\'] = query\n-        if dry_run:\n-            walker_settings[\'limit\'] = 1\n-        walker = CustomQueryWalker(**walker_settings)\n-        walker.go()\n-        walker_infos = {\'errors\': walker.errors,\n-                        \'msg\': walker.getOutput().splitlines(),\n-                        \'counter\': walker.counter}\n-        for error in walker.errors:\n-            logger.error(error.get(\'message\'))\n-        if dry_run:\n-            transaction.abort()\n-\n-    # Revert to the original state\n-    undo_patch_after_migration(\n-        link_integrity, queue_indexing, patch_searchabletext)\n-\n-    return walker_infos\ndiff --git a/plone/app/contenttypes/migration/migrator.css b/plone/app/contenttypes/migration/migrator.css\ndeleted file mode 100644\nindex 53cdf518..00000000\n--- a/plone/app/contenttypes/migration/migrator.css\n+++ /dev/null\n@@ -1,88 +0,0 @@\n-div.important {\n-  padding: .9em 1.2em;\n-  border-radius: 10px;\n-  font-size: 100%;\n-}\n-.btn-danger {\n-  background-color: #DA4F49;\n-  background-image: linear-gradient(to bottom, #EE5F5B, #BD362F);\n-  background-repeat: repeat-x;\n-  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);\n-  color: #FFFFFF;\n-  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);\n-  border-radius: 4px 4px 4px 4px;\n-  border-style: solid;\n-  border-width: 1px;\n-  box-shadow: 0 1px 0 rgba(255, 255, 255, 0.2) inset, 0 1px 2px rgba(0, 0, 0, 0.05);    cursor: pointer;\n-  display: inline-block;\n-  font-size: 14px;\n-  line-height: 20px;\n-  margin-bottom: 0;\n-  padding: 4px 12px;\n-  text-align: center;\n-  vertical-align: middle;\n-}\n-\n-.btn-danger:hover, .btn-danger:focus,\n-.btn-danger:active, .btn-danger.active {\n-    color: rgb(255, 255, 255);\n-    background-color: rgb(189, 54, 47);\n-    text-decoration: none;\n-    background-position: 0px -15px;\n-    transition: background-position 0.1s linear 0s;\n-}\n-\n-.btn-danger:active {\n-    background-image: none;\n-    outline: 0px none;\n-    box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.15) inset, 0px 1px 2px rgba(0, 0, 0, 0.05);\n-}\n-#migration-form {\n-    border: 1px solid #DDDDDD;\n-    border-radius: 10px 10px 10px 10px;\n-    font-size: 110%;\n-    margin-bottom: 1em;\n-    padding: 1em 1.5em;\n-}\n-\n-#migration-form .formControls {\n-  margin-left: 0;\n-  margin-top: 4em;\n-}\n-#migration-options {\n-  margin-top: 3em;\n-}\n-\n-.strong {\n-  font-size: 150%;\n-  font-weight: bold;\n-}\n-\n-table td {\n-    border: 1px solid #ccc;\n-}\n-table td, table th  {\n-    padding: 0.2em 0.5em 0.2em;\n-}\n-table th {\n-    text-align: center;\n-    font-weight: normal;\n-}\n-\n-.testConfig.error {\n-    padding-right: 30px;\n-    background: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAClklEQVR42q3VX0gUQRwH8N/M3N7tnXe3Z4IiESc9FBaBWHg99VSET0F/HxIKKg1FK4gK8grUoB59UaEetKAwoojAsCgIIsw/ROSRhCFpecVpd7d6f/Zmd6fZJY2ebmHu97Asw373w/x2ZhaBg1IPH78JNRsuMxeGQoFCYmbh1raRZ1ecZFGxB3JHm/pJY+1Z5JcBGAOEMdB0BmIP3/XsGn0eFQa0S+0M1VUDFIz1MeJ2wfe3nyHcd7dovjhwsZWh2koAw1wfwy4CP8ZnITxwrwTAhVYGW8o5wP4DFqe+Qvj2fXEgf66FobACYHIAYd4fYrco/mkeNvUPlgBoPs3Q1hB/sQQs8QtYbBqIqsLYh/jKnmQ6KAzkzjSPoY0oYo6MAkuqAC4XuPlyfT2bHN+f0yLCQCayewoSs/VgfQJM7ISbIHgzn/q4N5evEwZUr/8FrvLtg3/fGGQO9M0tRTuY0SMMpH3BKAl5uqxNtlZejGAgnuxqM/XrpQA6id/dvQZYAcZX1FBKPd9m6L0lAJSdWMYTCJD9rHXN6CY8Wc3Uthh0RhhI+RQJS1jlL5bXAjnTLDzOZKs4kBIG7FkEQnO87TXWPeFSnNL0K00rbzYoK5Z1BPwuU3rdCHVY9xIHYlSbrs9ndzjJOgJ+likVfJkmKDNRlpkQM/SGg1SbKBkgUo6AJX/oDiLolJdgUHUK8wX9UUM+e6QkQNobPIED0iDmu9c+LXhCpyYMLasn2019SBhQQ6EuUilH7eP6b3k49vJbqrsxn78mDKTKlB73duUq45vLngJPyBKBB5OLN5oM2ineIjnYQDYH35Nqn/3bxPyoXl1QYfjLcqSV0XFhwKq4J3jAVeEZRgHJk0lq2uTSyrFDZuGpk+wfCfYGKNjXCTAAAAAASUVORK5CYII=\') no-repeat right center;\n-}\n-.testConfig.success {\n-    padding-right: 30px;\n-    background: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAC9ElEQVR42u2UW0gUURjH/7Pj7tIqhu5tvK/aRS3K7KGHepAQ7SJBEBaESmAXqAeJKDQQipKgEiPEiCAzLE2CLlCQREVvIhEopuaq7a6aI67rXp3ZnTnNDrZYupqXeuqDMwNzzvn95nznO4fCXw7qv+CfC5hXTEV+ek5116gZn3J7qVUVbHqbRrYnZuBq6g2UdB7BiG1q9VYwG37ZVgErZ8HXz+OrIwjCq3ecQ44qV4ZbuG9wu3lYexwrF/wOH/QNwc+LGOyaAK8VK1ckyGpLJQ931cFAm2S42TOAYN0Mddvh9vJgj7HL3+S4pwy5U1AV+vN+txk0TcPa78DkuA9sGSuz5Ufca4YIrChPZEvZRaVMM0MqC0pRFHUc5UMnMeL9DpUyAmNWt9RcIbgsYF4wpGBjDs4mnMFd9j5aP34IK2GeMZToEcWSvD04H3sJF63l6HH2Qq1Uwz4+jeE+B8ZOjP0yl8p4YyKnthSi3dmBC/FVONx5GvY+z7wSQ5OB5O3MRk1CPerY63jHvpfgKkw5eQx3T2K0bGzOHCqzLY1sSzFAE6GGN8CFlRhbjCRraxLXmNaoful4gsejLVDSEXA6/eBcfnQWmOddNcU8Z0iyPsa/2ahTTgt+BKSPu2P2ora/ISQxPDCQpGwtmjMb0OFqR72tHgqFAm5XAKzZCUvxSNh9o4J3B/yoXmfUwqRbC14UEZBavna/LEFw7xVAU85tTEx7cc1yReoX4PUIsNvcGCiyLVgUcqckIZSPQqZJD310JLhAQFqJiELdAVgjvuDgmqOwcz7cGq6Bk3fC5xXhtnPoKRxctOJCA4LVpPLTyEjXIVKjliUCEZCiScah2GLUDt+U4dNesmDOwwpmypCoBBqZ6/WglQoIgiilLABO4KCgVBJcSo2DR/e+gT8+oHMGMq0MiaSVSN+glZJEIIoEgtQ8Xv+S4fMKgmF8ZCQx0RokmqKlNBG4XPyy4GEFwTDcMxBdfNRMDWFZ8AUFPyXB9+y7ZanxA2o0cjyUQuVrAAAAAElFTkSuQmCC\') no-repeat right center;\n-}\n-\n-.testConfig.testing {\n-  background: #ffffff url(\'++plone++static/components//select2/select2-spinner.gif\') no-repeat 100% right center;\n-  background: url(\'++plone++static/components//select2/select2-spinner.gif\') no-repeat 100%, -webkit-gradient(linear, left bottom, left top, color-stop(0.85, #ffffff), color-stop(0.99, #eeeeee));\n-  background: url(\'++plone++static/components//select2/select2-spinner.gif\') no-repeat 100%, -webkit-linear-gradient(center bottom, #ffffff 85%, #eeeeee 99%);\n-  background: url(\'++plone++static/components//select2/select2-spinner.gif\') no-repeat 100%, -moz-linear-gradient(center bottom, #ffffff 85%, #eeeeee 99%);\n-  background: url(\'++plone++static/components//select2/select2-spinner.gif\') no-repeat 100%, linear-gradient(to bottom, #ffffff 85%, #eeeeee 99%) right center;\n-  padding-right: 30px;\n-}\ndiff --git a/plone/app/contenttypes/migration/pac_installer.pt b/plone/app/contenttypes/migration/pac_installer.pt\ndeleted file mode 100644\nindex fd6eaa84..00000000\n--- a/plone/app/contenttypes/migration/pac_installer.pt\n+++ /dev/null\n@@ -1,37 +0,0 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"\n-      xmlns:tal="http://xml.zope.org/namespaces/tal"\n-      xmlns:metal="http://xml.zope.org/namespaces/metal"\n-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-      metal:use-macro="context/@@main_template/macros/master"\n-      i18n:domain="plone">\n-\n-    <metal:block fill-slot="top_slot"\n-                 tal:define="dummy python:request.set(\'disable_border\',1)" />\n-\n-    <body>\n-\n-        <metal:main fill-slot="main">\n-\n-            <tal:installable tal:condition="view/pac_installable">\n-                <h1 class="documentFirstHeading"\n-                    i18n:translate="">\n-                    Install dexterity and proceed to the migration-form?\n-                </h1>\n-                <p i18n:translate="">After you do this you can\'t edit your existing content (you can still view it) unless you migrate them to Dexterity in the next step.</p>\n-                <div id="content-core">\n-                    <form metal:use-macro="context/@@ploneform-macros/titlelessform" />\n-                </div>\n-            </tal:installable>\n-\n-            <tal:installable tal:condition="view/pac_installed">\n-                <h1>\n-                    Dexterity is already installed\n-                </h1>\n-                <p>\n-                    <a href="@@atct_migrator">Proceed to migrating your existing content to dexterity.</a>\n-                </p>\n-            </tal:installable>\n-\n-        </metal:main>\n-    </body>\n-</html>\ndiff --git a/plone/app/contenttypes/migration/patches.py b/plone/app/contenttypes/migration/patches.py\ndeleted file mode 100644\nindex 7d57d8ac..00000000\n--- a/plone/app/contenttypes/migration/patches.py\n+++ /dev/null\n@@ -1,158 +0,0 @@\n-# -*- coding: utf-8 -*-\n-"""Patches used for migrations. These patches are applied before and removed\n-after running the migration.\n-"""\n-from plone.dexterity.content import DexterityContent\n-from plone.registry.interfaces import IRegistry\n-from Products.Archetypes.ExtensibleMetadata import ExtensibleMetadata\n-from Products.CMFCore.interfaces import IPropertiesTool\n-from Products.CMFPlone.DublinCore import DefaultDublinCoreImpl\n-from Products.CMFPlone.interfaces import IEditingSchema\n-from Products.contentmigration.utils import patch\n-from Products.contentmigration.utils import undoPatch\n-from Products.PluginIndexes.common.UnIndex import _marker\n-from Products.PluginIndexes.UUIDIndex.UUIDIndex import UUIDIndex\n-from zope.component import getUtility\n-from zope.component import queryUtility\n-\n-import os\n-\n-\n-def pass_fn(*args, **kwargs):\n-    """Empty function used for patching."""\n-    pass\n-\n-\n-def patched_index_object(*args, **kwargs):\n-    """Patched Products.ZCTextIndex.ZCTextIndex.ZCTextIndex.index_object"""\n-    return 0\n-\n-\n-# Prevent UUID Error-Messages when migrating folders.\n-# Products.PluginIndexes.UUIDIndex.UUIDIndex.UUIDIndex.insertForwardIndexEntry\n-def patched_insertForwardIndexEntry(self, entry, documentId):\n-    """Take the entry provided and put it in the correct place\n-    in the forward index.\n-    """\n-    if entry is None:\n-        return\n-\n-    old_docid = self._index.get(entry, _marker)\n-    if old_docid is _marker:\n-        self._index[entry] = documentId\n-        self._length.change(1)\n-\n-\n-def patch_before_migration(patch_searchabletext=False):\n-    """Patch various things that make migration harder."""\n-    # Switch linkintegrity off\n-    ptool = queryUtility(IPropertiesTool)\n-    site_props = getattr(ptool, \'site_properties\', None)\n-    if site_props and site_props.hasProperty(\n-            \'enable_link_integrity_checks\'):\n-        link_integrity = site_props.getProperty(\n-            \'enable_link_integrity_checks\', False)\n-        site_props.manage_changeProperties(\n-            enable_link_integrity_checks=False)\n-    else:\n-        # Plone 5\n-        registry = getUtility(IRegistry)\n-        editing_settings = registry.forInterface(\n-            IEditingSchema, prefix=\'plone\')\n-        link_integrity = editing_settings.enable_link_integrity_checks\n-        editing_settings.enable_link_integrity_checks = False\n-\n-    # Patch notifyModified to prevent setModificationDate() on changes\n-    # notifyModified lives in several places and is also used on folders\n-    # when their content changes.\n-    # So when we migrate Documents before Folders the folders\n-    # ModifiedDate gets changed\n-    PATCH_NOTIFY = [\n-        DexterityContent,\n-        DefaultDublinCoreImpl,\n-        ExtensibleMetadata\n-    ]\n-    for klass in PATCH_NOTIFY:\n-        patch(klass, \'notifyModified\', pass_fn)\n-\n-    # Disable queueing of indexing/reindexing/unindexing\n-    queue_indexing = os.environ.get(\'CATALOG_OPTIMIZATION_DISABLED\', None)\n-    os.environ[\'CATALOG_OPTIMIZATION_DISABLED\'] = \'1\'\n-\n-    # Patch UUIDIndex\n-    patch(\n-        UUIDIndex,\n-        \'insertForwardIndexEntry\',\n-        patched_insertForwardIndexEntry)\n-\n-    # Patch SearchableText index\n-    if patch_searchabletext:\n-        patch_indexing_at_blobs()\n-        patch_indexing_dx_blobs()\n-\n-    return link_integrity, queue_indexing, patch_searchabletext\n-\n-\n-def undo_patch_after_migration(link_integrity=True,\n-                               queue_indexing=None,\n-                               patch_searchabletext=False,\n-                               ):\n-    """Revert to the original state."""\n-\n-    # Switch linkintegrity back to what it was before migrating\n-    ptool = queryUtility(IPropertiesTool)\n-    site_props = getattr(ptool, \'site_properties\', None)\n-    if site_props and site_props.hasProperty(\n-            \'enable_link_integrity_checks\'):\n-        site_props.manage_changeProperties(\n-            enable_link_integrity_checks=link_integrity\n-        )\n-    else:\n-        # Plone 5\n-        registry = getUtility(IRegistry)\n-        editing_settings = registry.forInterface(\n-            IEditingSchema, prefix=\'plone\')\n-        editing_settings.enable_link_integrity_checks = link_integrity\n-\n-    # Switch on setModificationDate on changes\n-    PATCH_NOTIFY = [\n-        DexterityContent,\n-        DefaultDublinCoreImpl,\n-        ExtensibleMetadata\n-    ]\n-    for klass in PATCH_NOTIFY:\n-        undoPatch(klass, \'notifyModified\')\n-\n-    # Reset queueing of indexing/reindexing/unindexing\n-    if queue_indexing is not None:\n-        os.environ[\'CATALOG_OPTIMIZATION_DISABLED\'] = queue_indexing\n-    else:\n-        del os.environ[\'CATALOG_OPTIMIZATION_DISABLED\']\n-\n-    # Unpatch UUIDIndex\n-    undoPatch(UUIDIndex, \'insertForwardIndexEntry\')\n-\n-    # Unpatch SearchableText index\n-    if patch_searchabletext:\n-        unpatch_indexing_at_blobs()\n-        unpatch_indexing_dx_blobs()\n-\n-\n-def patch_indexing_at_blobs():\n-    from plone.app.blob.content import ATBlob\n-    patch(ATBlob, \'getIndexValue\', pass_fn)\n-\n-\n-def unpatch_indexing_at_blobs():\n-    from plone.app.blob.content import ATBlob\n-    undoPatch(ATBlob, \'getIndexValue\')\n-\n-\n-def patch_indexing_dx_blobs():\n-    from Products.ZCTextIndex.ZCTextIndex import ZCTextIndex\n-    patch(ZCTextIndex, \'index_object\', patched_index_object)\n-\n-\n-def unpatch_indexing_dx_blobs():\n-    from Products.ZCTextIndex.ZCTextIndex import ZCTextIndex\n-    undoPatch(ZCTextIndex, \'index_object\')\ndiff --git a/plone/app/contenttypes/migration/topics.py b/plone/app/contenttypes/migration/topics.py\ndeleted file mode 100644\nindex d843cde9..00000000\n--- a/plone/app/contenttypes/migration/topics.py\n+++ /dev/null\n@@ -1,727 +0,0 @@\n-# -*- coding: utf-8 -*-\n-""" Migrate Topic to DX-Collectons.\n-\n-Note on Subtopics:\n-When a migration of Subtopics is needed, you can replace the default itemish\n-Collection with a folderish Collection by creating a new type folderish\n-type \'Collection\' with the collection-behavior enabled. You can then use\n-the default migration to migrate Topics with Subtopics.\n-"""\n-\n-from DateTime import DateTime\n-from plone.app.contenttypes.behaviors.collection import ICollection\n-from plone.app.contenttypes.migration.field_migrators import migrate_richtextfield  # noqa: E501\n-from plone.app.contenttypes.upgrades import LISTING_VIEW_MAPPING\n-from plone.app.querystring.interfaces import IQuerystringRegistryReader\n-from plone.registry.interfaces import IRegistry\n-from plone.uuid.interfaces import IMutableUUID\n-from Products.CMFCore.utils import getToolByName\n-from Products.contentmigration.inplace import InplaceCMFFolderMigrator\n-from Products.contentmigration.inplace import InplaceCMFItemMigrator\n-from Products.contentmigration.walker import CustomQueryWalker\n-from zope.component import getUtility\n-from zope.component import queryAdapter\n-from zope.dottedname.resolve import resolve\n-\n-import logging\n-\n-\n-logger = logging.getLogger(__name__)\n-prefix = \'plone.app.querystring\'\n-\n-INVALID_OPERATION = \'Invalid operation %s for criterion: %s\'\n-\n-\n-# Converters\n-class CriterionConverter(object):\n-\n-    # Last part of the code for the dotted operation method,\n-    # e.g. \'string.contains\'.\n-    operator_code = \'\'\n-    # alternative code, possibly used if the first code does not work.\n-    alt_operator_code = \'\'\n-\n-    def get_query_value(self, value, index, criterion):\n-        # value may contain a query and some parameters, but in the\n-        # simple case it is simply a value.\n-        return value\n-\n-    def get_operation(self, value, index, criterion):\n-        # Get dotted operation method.  This may depend on value.\n-        return \'{0}.operation.{1}\'.format(prefix, self.operator_code)\n-\n-    def get_alt_operation(self, value, index, criterion):\n-        # Get dotted operation method.  This may depend on value.\n-        return \'{0}.operation.{1}\'.format(prefix, self.alt_operator_code)\n-\n-    def is_index_known(self, registry, index):\n-        # Is the index registered as criterion index?\n-        key = \'{0}.field.{1}\'.format(prefix, index)\n-        try:\n-            registry.get(key)\n-        except KeyError:\n-            logger.error(\n-                \'Index {0} is no criterion index. Registry gives \'\n-                \'KeyError: {1}\'.format(index, key)\n-            )\n-            return False\n-        return True\n-\n-    def is_index_enabled(self, registry, index):\n-        # Is the index enabled as criterion index?\n-        key = \'{0}.field.{1}\'.format(prefix, index)\n-        index_data = registry.get(key)\n-        if index_data.get(\'enabled\'):\n-            return True\n-        logger.warn(\'Index %s is not enabled as criterion index. \', index)\n-        return False\n-\n-    def switch_type_to_portal_type(self, value, criterion):\n-        # \'portal_type\' is the object id of the FTI in portal_types.\n-        # \'Type\' is the title of that object.\n-        # For example:\n-        # - portal_type \'Document\' has Type \'Page\'.\n-        # - portal_type \'Topic\' has Type \'Collection (old)\'.\n-        if isinstance(value, dict):\n-            values = value.get(\'query\', [])\n-        else:\n-            values = value\n-        if not values:\n-            return value\n-        new_values = []\n-        ttool = getToolByName(criterion, \'portal_types\')\n-        type_to_portal_type = {}\n-        portal_types = ttool.objectIds()\n-        for portal_type, Type in ttool.listTypeTitles().items():\n-            type_to_portal_type[Type] = portal_type\n-        for Type in values:\n-            portal_type = type_to_portal_type.get(Type)\n-            if not portal_type:\n-                if Type in portal_types:\n-                    portal_type = Type\n-                else:\n-                    logger.warn(\'Cannot switch Type %r to portal_type.\', Type)\n-                    continue\n-            new_values.append(portal_type)\n-        if isinstance(value, dict):\n-            value[\'query\'] = new_values\n-        else:\n-            value = new_values\n-        return value\n-\n-    def is_operation_valid(self, registry, operation):\n-        # Check that the operation exists.\n-        op_info = registry.get(operation)\n-        if op_info is None:\n-            logger.error(\'Operation %r is not defined.\', operation)\n-            return False\n-        op_function_name = op_info.get(\'operation\')\n-        try:\n-            resolve(op_function_name)\n-        except ImportError:\n-            logger.error(\n-                \'ImportError for operation %r: %s\',\n-                operation,\n-                op_function_name,\n-            )\n-            return False\n-        return True\n-\n-    def get_valid_operation(self, registry, index, value, criterion):\n-        key = \'{0}.field.{1}.operations\'.format(prefix, index)\n-        operations = registry.get(key)\n-        operation = self.get_operation(value, index, criterion)\n-        if operation not in operations:\n-            operation = self.get_alt_operation(value, index, criterion)\n-            if operation not in operations:\n-                return\n-        if self.is_operation_valid(registry, operation):\n-            return operation\n-\n-    def add_to_formquery(self, formquery, index, operation, query_value):\n-        row = {\'i\': index,\n-               \'o\': operation}\n-        if query_value is not None:\n-            row[\'v\'] = query_value\n-        formquery.append(row)\n-\n-    def __call__(self, formquery, criterion, registry):\n-        criteria = criterion.getCriteriaItems()\n-        if not criteria:\n-            logger.warn(\'Ignoring empty criterion %s.\', criterion)\n-            return\n-        for index, value in criteria:\n-            # Check if the index is known and enabled as criterion index.\n-            if index == \'Type\':\n-                # Try to replace Type by portal_type\n-                index = \'portal_type\'\n-                value = self.switch_type_to_portal_type(value, criterion)\n-            if not self.is_index_known(registry, index):\n-                logger.info(\'Index %s not known in registry.\', index)\n-                continue\n-            self.is_index_enabled(registry, index)\n-            # TODO: what do we do when this is False?  Raise an\n-            # Exception?  Continue processing the index and value\n-            # anyway, now that a warning is logged?  Continue with the\n-            # next criteria item?\n-\n-            # Get the operation method.\n-            operation = self.get_valid_operation(\n-                registry,\n-                index,\n-                value,\n-                criterion\n-            )\n-            if not operation:\n-                logger.error(INVALID_OPERATION % (operation, criterion))\n-                # TODO: raise an Exception?\n-                continue\n-\n-            # Get the value that we will query for.\n-            query_value = self.get_query_value(value, index, criterion)\n-\n-            # Add a row to the form query.\n-            self.add_to_formquery(formquery, index, operation, query_value)\n-\n-\n-class ATDateCriteriaConverter(CriterionConverter):\n-    """Handle date criteria.\n-\n-    Note that there is also ATDateRangeCriterion, which is much\n-    simpler as it just has two dates.\n-\n-    In our case we have these valid operations:\n-\n-    [\'plone.app.querystring.operation.date.lessThan\',\n-     \'plone.app.querystring.operation.date.largerThan\',\n-     \'plone.app.querystring.operation.date.between\',\n-     \'plone.app.querystring.operation.date.lessThanRelativeDate\',\n-     \'plone.app.querystring.operation.date.largerThanRelativeDate\',\n-     \'plone.app.querystring.operation.date.today\',\n-     \'plone.app.querystring.operation.date.beforeToday\',\n-     \'plone.app.querystring.operation.date.afterToday\']\n-\n-    This code is based on the getCriteriaItems method from\n-    Products/ATContentTypes/criteria/date.py.  We check the field\n-    values ourselves instead of translating the values back and forth.\n-    """\n-\n-    def __call__(self, formquery, criterion, registry):  # noqa\n-        if criterion.value is None:\n-            logger.warn(\'Ignoring empty criterion %s.\', criterion)\n-            return\n-        field = criterion.Field()\n-        value = criterion.Value()\n-\n-        # Check if the index is known and enabled as criterion index.\n-        if not self.is_index_known(registry, field):\n-            return\n-        self.is_index_enabled(registry, field)\n-\n-        # Negate the value for \'old\' days\n-        if criterion.getDateRange() == \'-\':\n-            value = -value\n-\n-        date = DateTime() + value\n-\n-        # Get the possible operation methods.\n-        key = \'{0}.field.{1}.operations\'.format(prefix, field)\n-        operations = registry.get(key)\n-\n-        def add_row(operation, value=None):\n-            if operation not in operations:\n-                # TODO just ignore it?\n-                raise ValueError(INVALID_OPERATION % (operation, criterion))\n-            if not self.is_operation_valid(registry, operation):\n-                # TODO just ignore it?\n-                raise ValueError(INVALID_OPERATION % (operation, criterion))\n-            # Add a row to the form query.\n-            row = {\'i\': field,\n-                   \'o\': operation}\n-            if value is not None:\n-                row[\'v\'] = value\n-            formquery.append(row)\n-\n-        operation = criterion.getOperation()\n-        if operation == \'within_day\':\n-            if date.isCurrentDay():\n-                new_operation = \'{0}.operation.date.today\'.format(prefix)\n-                add_row(new_operation)\n-                return\n-            date_range = (date.earliestTime(), date.latestTime())\n-            new_operation = \'{0}.operation.date.between\'.format(prefix)\n-            add_row(new_operation, date_range)\n-            return\n-        if operation == \'more\':\n-            if value != 0:\n-                new_operation = (\'{0}.operation.date.\'\n-                                 \'largerThanRelativeDate\'.format(prefix))\n-                add_row(new_operation, value)\n-                return\n-            else:\n-                new_operation = \'{0}.operation.date.afterToday\'.format(prefix)\n-                add_row(new_operation)\n-                return\n-        if operation == \'less\':\n-            if value != 0:\n-                new_operation = (\'{0}.operation.date.\'\n-                                 \'lessThanRelativeDate\'.format(prefix))\n-                add_row(new_operation, value)\n-                return\n-            else:\n-                new_operation = \'{0}.operation.date.beforeToday\'.format(prefix)\n-                add_row(new_operation)\n-                return\n-\n-\n-class ATSimpleStringCriterionConverter(CriterionConverter):\n-    operator_code = \'string.contains\'\n-    # review_state could be a string criterion, but should become a selection.\n-    alt_operator_code = \'selection.any\'\n-\n-\n-class ATCurrentAuthorCriterionConverter(CriterionConverter):\n-    operator_code = \'string.currentUser\'\n-\n-\n-class ATSelectionCriterionConverter(CriterionConverter):\n-    operator_code = \'selection.any\'\n-    alt_operator_code = \'selection.is\'\n-\n-    def get_operation(self, value, index, criterion):\n-        # Get dotted operation method.  This may depend on value.\n-        if index == \'Subject\':\n-            if value[\'operator\'] == \'and\':\n-                # Subject is currently the only index that supports\n-                # this, because for others it makes no sense.  See\n-                # allowed operations in registry.xml in\n-                # plone.app.querystring.\n-                suffix = \'all\'\n-            else:\n-                suffix = \'any\'\n-            return \'{0}.operation.selection.{1}\'.format(prefix, suffix)\n-        else:\n-            return \'{0}.operation.{1}\'.format(prefix, self.operator_code)\n-\n-    def get_query_value(self, value, index, criterion):\n-        values = value[\'query\']\n-        if value.get(\'operator\') == \'and\' and len(values) > 1 and \\\n-                index != \'Subject\':\n-            logger.warn("Cannot handle selection operator \'and\'. Using \'or\'. "\n-                        "%r", value)\n-\n-        # Special handling for portal_type=Topic.\n-        if index == \'portal_type\' and \'Topic\' in values:\n-            values = list(values)\n-            values[values.index(\'Topic\')] = \'Collection\'\n-            values = tuple(values)\n-        return values\n-\n-\n-class ATListCriterionConverter(ATSelectionCriterionConverter):\n-    pass\n-\n-\n-class ATReferenceCriterionConverter(ATSelectionCriterionConverter):\n-    # Note: the new criterion is disabled by default.  Also, it\n-    # needs the _referenceIs function in the plone.app.querystring\n-    # queryparser and that function is not defined.\n-    operator_code = \'reference.is\'\n-\n-\n-class ATPathCriterionConverter(CriterionConverter):\n-    operator_code = \'string.path\'\n-\n-    def get_query_value(self, value, index, criterion):\n-        raw = criterion.getRawValue()\n-        if not raw:\n-            return\n-        # Is this a recursive query?  Could check depth in the value\n-        # actually, but Recurse is the canonical way.  Also, the only\n-        # possible values for depth are -1 and 1.\n-        if not criterion.Recurse():\n-            for index, path in enumerate(raw):\n-                raw[index] = path + \'::1\'\n-        return raw\n-\n-    def add_to_formquery(self, formquery, index, operation, query_value):\n-        if query_value is None:\n-            return\n-        for value in query_value:\n-            row = {\'i\': index,\n-                   \'o\': operation,\n-                   \'v\': value}\n-            formquery.append(row)\n-\n-\n-class ATBooleanCriterionConverter(CriterionConverter):\n-\n-    def get_operation(self, value, index, criterion):\n-        # Get dotted operation method.\n-        # value is one of these beauties:\n-        # value = [1, True, \'1\', \'True\']\n-        # value = [0, \'\', False, \'0\', \'False\', None, (), [], {}, MV]\n-        if True in value:\n-            code = \'isTrue\'\n-        elif False in value:\n-            code = \'isFalse\'\n-        else:\n-            logger.warn(\n-                \'Unknown value for boolean criterion. \'\n-                \'Falling back to True. %r\',\n-                value,\n-            )\n-            code = \'isTrue\'\n-        return \'{0}.operation.boolean.{1}\'.format(prefix, code)\n-\n-    def __call__(self, formquery, criterion, registry):\n-        criteria = criterion.getCriteriaItems()\n-        if not criteria:\n-            return\n-        for index, value in criteria:\n-            if index == \'is_folderish\':\n-                fieldname = \'isFolderish\'\n-            elif index == \'is_default_page\':\n-                fieldname = \'isDefaultPage\'\n-            else:\n-                fieldname = index\n-            # Check if the index is known and enabled as criterion index.\n-            if not self.is_index_known(registry, fieldname):\n-                continue\n-            self.is_index_enabled(registry, fieldname)\n-            # Get the operation method.\n-            operation = self.get_valid_operation(\n-                registry, fieldname, value, criterion)\n-            if not operation:\n-                logger.error(INVALID_OPERATION % (operation, criterion))\n-                # TODO: raise an Exception?\n-                continue\n-            # Add a row to the form query.\n-            row = {\'i\': index,\n-                   \'o\': operation}\n-            formquery.append(row)\n-\n-\n-class ATDateRangeCriterionConverter(CriterionConverter):\n-    operator_code = \'date.between\'\n-\n-    def get_query_value(self, value, index, criterion):\n-        return value[\'query\']\n-\n-\n-class ATPortalTypeCriterionConverter(CriterionConverter):\n-    operator_code = \'selection.any\'\n-\n-    def get_query_value(self, value, index, criterion):\n-        # Special handling for portal_type=Topic.\n-        if \'Topic\' in value:\n-            value = list(value)\n-            value[value.index(\'Topic\')] = \'Collection\'\n-            value = tuple(value)\n-        return value\n-\n-\n-class ATRelativePathCriterionConverter(CriterionConverter):\n-    # We also have path.isWithinRelative, but its function is not defined.\n-    operator_code = \'string.relativePath\'\n-\n-    def get_query_value(self, value, index, criterion):\n-        if not criterion.Recurse():\n-            logger.warn(\n-                \'Cannot handle non-recursive path search. \'\n-                \'Allowing recursive search. %r\',\n-                value,\n-            )\n-        return criterion.getRelativePath()\n-\n-\n-class ATSimpleIntCriterionConverter(CriterionConverter):\n-    # Also available: int.lessThan, int.largerThan.\n-    operator_code = \'int.is\'\n-\n-    def get_operation(self, value, index, criterion):\n-        # Get dotted operation method.\n-        direction = value.get(\'range\')\n-        if not direction:\n-            code = \'is\'\n-        elif direction == \'min\':\n-            code = \'largerThan\'\n-        elif direction == \'max\':\n-            code = \'lessThan\'\n-        elif direction == \'min:max\':\n-            logger.warn(\n-                \'min:max direction not supported for integers. %r\',\n-                value,\n-            )\n-            return\n-        else:\n-            logger.warn(\'Unknown direction for integers. %r\', value)\n-            return\n-        return \'{0}.operation.int.{1}\'.format(prefix, code)\n-\n-    def get_query_value(self, value, index, criterion):\n-        if isinstance(value[\'query\'], tuple):\n-            logger.warn(\'More than one integer is not supported. %r\', value)\n-            return\n-        return value[\'query\']\n-\n-\n-class TopicMigrator(InplaceCMFItemMigrator):\n-    """Migrate Topics to Collections. Existing subtopics will be lost.\n-\n-    The only difference to the migration below is the base-class\n-    (InplaceCMFItemMigrator instead of InplaceCMFFolderMigrator).\n-    """\n-    src_portal_type = \'Topic\'\n-    src_meta_type = \'ATTopic\'\n-    dst_portal_type = dst_meta_type = \'Collection\'\n-\n-    @property\n-    def registry(self):\n-        return self.kwargs[\'registry\']\n-\n-    def beforeChange_criteria(self):\n-        """Store the criteria of the old Topic.\n-\n-        Store the info on the migrator and restore the values in the\n-        migrate_criteria method.\n-        """\n-        self._collection_sort_reversed = None\n-        self._collection_sort_on = None\n-        self._collection_query = None\n-        path = \'/\'.join(self.old.getPhysicalPath())\n-        logger.info(\'Migrating %s at %s\', self.src_portal_type, path)\n-        # Get the old criteria.\n-        # See also Products.ATContentTypes.content.topic.buildQuery\n-        criteria = self.old.listCriteria()\n-        logger.debug(\n-            \'Old criteria for %s: %r\',\n-            path,\n-            [(crit, crit.getCriteriaItems()) for crit in criteria],\n-        )\n-        formquery = []\n-        for criterion in criteria:\n-            type_ = criterion.__class__.__name__\n-            if type_ == \'ATSortCriterion\':\n-                # Sort order and direction are now stored in the Collection.\n-                self._collection_sort_reversed = criterion.getReversed()\n-                self._collection_sort_on = criterion.Field()\n-                logger.debug(\n-                    \'Sort on %r, reverse: %s.\',\n-                    self._collection_sort_on,\n-                    self._collection_sort_reversed,\n-                )\n-                continue\n-\n-            converter = CONVERTERS.get(type_)\n-            if converter is None:\n-                msg = \'Unsupported criterion {0}\'.format(type_)\n-                logger.error(msg)\n-                raise ValueError(msg)\n-            converter(formquery, criterion, self.registry)\n-\n-        logger.debug(\'New query for %s: %r\', path, formquery)\n-        self._collection_query = formquery\n-\n-    def migrate_criteria(self):\n-        """Migrate old style to new style criteria.\n-\n-        Plus handling for some special fields.\n-        """\n-        # The old Topic has boolean limitNumber and integer itemCount,\n-        # where the new Collection only has limit.\n-        adapted = ICollection(self.new)\n-        if self.old.getLimitNumber():\n-            adapted.limit = self.old.getItemCount()\n-        adapted.customViewFields = self.old.getCustomViewFields()\n-\n-        # Get the old data stored by the beforeChange_criteria method.\n-        if self._collection_sort_reversed is not None:\n-            adapted.sort_reversed = self._collection_sort_reversed\n-        if self._collection_sort_on is not None:\n-            adapted.sort_on = self._collection_sort_on\n-        if self._collection_query is not None:\n-            adapted.query = self._collection_query\n-\n-    def migrate_atctmetadata(self):\n-        field = self.old.getField(\'excludeFromNav\')\n-        self.new.exclude_from_nav = field.get(self.old)\n-\n-    def migrate_schema_fields(self):\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-\n-    def migrate_at_uuid(self):\n-        """Migrate AT universal uid\n-        """\n-        uid = self.UID\n-        if uid and queryAdapter(self.new, IMutableUUID):\n-            IMutableUUID(self.new).set(str(uid))\n-\n-    def last_migrate_layout(self):\n-        """Migrate the layout (view method).\n-\n-        This needs to be done last, as otherwise our changes in\n-        migrate_criteria may get overriden by a later call to\n-        migrate_properties.\n-        """\n-        if self.old.getCustomView():\n-            # Previously, the atct_topic_view had logic for showing\n-            # the results in a list or in tabular form.  If\n-            # getCustomView is True, this means the new object should\n-            # use the tabular view.\n-            self.new.setLayout(\'tabular_view\')\n-            return\n-\n-        old_layout = self.old.getLayout() or getattr(self.old, \'layout\', None)\n-        if old_layout in LISTING_VIEW_MAPPING:\n-            self.new.setLayout(LISTING_VIEW_MAPPING[old_layout])\n-\n-\n-class FolderishTopicMigrator(InplaceCMFFolderMigrator):\n-    """Migrate Topics and Subtopics to folderish collections.\n-\n-    The only difference to the migration above is the base-class\n-    (InplaceCMFFolderMigrator instead of InplaceCMFItemMigrator).\n-    """\n-    src_portal_type = \'Topic\'\n-    src_meta_type = \'ATTopic\'\n-    dst_portal_type = dst_meta_type = \'Collection\'\n-\n-    @property\n-    def registry(self):\n-        return self.kwargs[\'registry\']\n-\n-    def beforeChange_criteria(self):\n-        """Store the criteria of the old Topic.\n-\n-        Store the info on the migrator and restore the values in the\n-        migrate_criteria method.\n-        """\n-        self._collection_sort_reversed = None\n-        self._collection_sort_on = None\n-        self._collection_query = None\n-        path = \'/\'.join(self.old.getPhysicalPath())\n-        logger.info(\'Migrating %s at %s\', self.src_portal_type, path)\n-        # Get the old criteria.\n-        # See also Products.ATContentTypes.content.topic.buildQuery\n-        criteria = self.old.listCriteria()\n-        logger.debug(\'Old criteria for %s: %r\', path,\n-                     [(crit, crit.getCriteriaItems()) for crit in criteria])\n-        formquery = []\n-        for criterion in criteria:\n-            type_ = criterion.__class__.__name__\n-            if type_ == \'ATSortCriterion\':\n-                # Sort order and direction are now stored in the Collection.\n-                self._collection_sort_reversed = criterion.getReversed()\n-                self._collection_sort_on = criterion.Field()\n-                logger.debug(\n-                    \'Sort on %r, reverse: %s.\',\n-                    self._collection_sort_on,\n-                    self._collection_sort_reversed,\n-                )\n-                continue\n-\n-            converter = CONVERTERS.get(type_)\n-            if converter is None:\n-                msg = \'Unsupported criterion {0}\'.format(type_)\n-                logger.error(msg)\n-                raise ValueError(msg)\n-            converter(formquery, criterion, self.registry)\n-\n-        logger.debug(\'New query for %s: %r\', path, formquery)\n-        self._collection_query = formquery\n-\n-    def migrate_criteria(self):\n-        """Migrate old style to new style criteria.\n-\n-        Plus handling for some special fields.\n-        """\n-        # The old Topic has boolean limitNumber and integer itemCount,\n-        # where the new Collection only has limit.\n-        adapted = ICollection(self.new)\n-        if self.old.getLimitNumber():\n-            adapted.limit = self.old.getItemCount()\n-        adapted.customViewFields = self.old.getCustomViewFields()\n-\n-        # Get the old data stored by the beforeChange_criteria method.\n-        if self._collection_sort_reversed is not None:\n-            adapted.sort_reversed = self._collection_sort_reversed\n-        if self._collection_sort_on is not None:\n-            adapted.sort_on = self._collection_sort_on\n-        if self._collection_query is not None:\n-            adapted.query = self._collection_query\n-\n-    def migrate_atctmetadata(self):\n-        field = self.old.getField(\'excludeFromNav\')\n-        self.new.exclude_from_nav = field.get(self.old)\n-\n-    def migrate_schema_fields(self):\n-        migrate_richtextfield(self.old, self.new, \'text\', \'text\')\n-\n-    def migrate_at_uuid(self):\n-        """Migrate AT universal uid\n-        """\n-        uid = self.UID\n-        if uid and queryAdapter(self.new, IMutableUUID):\n-            IMutableUUID(self.new).set(str(uid))\n-\n-    def last_migrate_layout(self):\n-        """Migrate the layout (view method).\n-\n-        This needs to be done last, as otherwise our changes in\n-        migrate_criteria may get overriden by a later call to\n-        migrate_properties.\n-        """\n-        if self.old.getCustomView():\n-            # Previously, the atct_topic_view had logic for showing\n-            # the results in a list or in tabular form.  If\n-            # getCustomView is True, this means the new object should\n-            # use the tabular view.\n-            self.new.setLayout(\'tabular_view\')\n-            return\n-\n-        old_layout = self.old.getLayout() or getattr(self.old, \'layout\', None)\n-        if old_layout in LISTING_VIEW_MAPPING:\n-            default_page = self.old.getDefaultPage()\n-            self.new.setLayout(LISTING_VIEW_MAPPING[old_layout])\n-            if default_page:\n-                # any defaultPage is switched of by setLayout\n-                # and needs to set again\n-                self.new.setDefaultPage(default_page)\n-\n-\n-def migrate_topics(portal):\n-    """Migrate ATContentTypes Topics to plone.app.contenttypes Collections.\n-\n-    This could also be used as upgrade step.\n-    """\n-    # Parse the registry to get allowed operations and pass it to the\n-    # migrator.\n-    reg = getUtility(IRegistry)\n-    reader = IQuerystringRegistryReader(reg)\n-    registry = reader.parseRegistry()\n-    # select migrator based on the base-class of collections\n-    fti = portal.portal_types[\'Collection\']\n-    if fti.content_meta_type == \'Dexterity Item\':\n-        migrator = TopicMigrator\n-    elif fti.content_meta_type == \'Dexterity Container\':\n-        migrator = FolderishTopicMigrator\n-    walker = CustomQueryWalker(portal, migrator)(registry=registry)\n-    return walker\n-\n-\n-CONVERTERS = {\n-    # Create an instance of each converter.\n-    \'ATBooleanCriterion\': ATBooleanCriterionConverter(),\n-    \'ATCurrentAuthorCriterion\': ATCurrentAuthorCriterionConverter(),\n-    \'ATDateCriteria\': ATDateCriteriaConverter(),\n-    \'ATDateRangeCriterion\': ATDateRangeCriterionConverter(),\n-    \'ATListCriterion\': ATListCriterionConverter(),\n-    \'ATPathCriterion\': ATPathCriterionConverter(),\n-    \'ATPortalTypeCriterion\': ATPortalTypeCriterionConverter(),\n-    \'ATReferenceCriterion\': ATReferenceCriterionConverter(),\n-    \'ATRelativePathCriterion\': ATRelativePathCriterionConverter(),\n-    \'ATSelectionCriterion\': ATSelectionCriterionConverter(),\n-    \'ATSimpleIntCriterion\': ATSimpleIntCriterionConverter(),\n-    \'ATSimpleStringCriterion\': ATSimpleStringCriterionConverter(),\n-}\ndiff --git a/plone/app/contenttypes/migration/utils.py b/plone/app/contenttypes/migration/utils.py\ndeleted file mode 100644\nindex 16cd92a3..00000000\n--- a/plone/app/contenttypes/migration/utils.py\n+++ /dev/null\n@@ -1,573 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from Acquisition import aq_base\n-from archetypes.schemaextender.interfaces import IBrowserLayerAwareExtender\n-from archetypes.schemaextender.interfaces import IOrderableSchemaExtender\n-from archetypes.schemaextender.interfaces import ISchemaExtender\n-from archetypes.schemaextender.interfaces import ISchemaModifier\n-from copy import deepcopy\n-from plone.app.contentrules.api import assign_rule\n-from plone.app.contenttypes.behaviors.leadimage import ILeadImage\n-from plone.app.contenttypes.migration.field_migrators import migrate_imagefield\n-from plone.app.contenttypes.migration.field_migrators import migrate_simplefield  # noqa\n-from plone.app.contenttypes.utils import DEFAULT_TYPES\n-from plone.app.discussion.interfaces import IConversation\n-from plone.app.linkintegrity.handlers import modifiedArchetype\n-from plone.app.linkintegrity.handlers import modifiedDexterity\n-from plone.app.linkintegrity.handlers import referencedRelationship\n-from plone.app.uuid.utils import uuidToObject\n-from plone.dexterity.utils import iterSchemataForType\n-from plone.contentrules.engine.interfaces import IRuleAssignmentManager\n-from plone.contentrules.engine.interfaces import IRuleStorage\n-from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.interfaces import IDexterityFTI\n-from plone.portlets.constants import CONTEXT_BLACKLIST_STATUS_KEY\n-from plone.portlets.interfaces import ILocalPortletAssignable\n-from plone.portlets.interfaces import IPortletAssignmentMapping\n-from plone.portlets.interfaces import IPortletManager\n-from plone.uuid.interfaces import IUUID\n-from Products.Archetypes.config import REFERENCE_CATALOG\n-from Products.Archetypes.interfaces.referenceable import IReferenceable\n-from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone import DISCUSSION_ANNOTATION_KEY\n-from Products.CMFPlone.interfaces import IPloneSiteRoot\n-from Products.CMFPlone.utils import safe_hasattr\n-from Products.Five.browser import BrowserView\n-from Products.GenericSetup.context import DirectoryImportContext\n-from Products.GenericSetup.utils import importObjects\n-from z3c.relationfield import RelationValue\n-from z3c.relationfield.schema import Relation\n-from z3c.relationfield.schema import RelationChoice\n-from z3c.relationfield.schema import RelationList\n-from zc.relation.interfaces import ICatalog\n-from zExceptions import NotFound\n-from zope.annotation.interfaces import IAnnotations\n-from zope.component import getGlobalSiteManager\n-from zope.component import getMultiAdapter\n-from zope.component import getSiteManager\n-from zope.component import getUtility\n-from zope.component import queryUtility\n-from zope.component.hooks import getSite\n-from zope.intid.interfaces import IIntIds\n-from zope.lifecycleevent import modified\n-\n-import json\n-import logging\n-import os\n-\n-\n-logger = logging.getLogger(__name__)\n-\n-\n-def isSchemaExtended(iface):\n-    """Return a list of fields added by archetypes.schemaextender\n-    """\n-    fields = _compareSchemata(iface)\n-    fields2 = _checkForExtenderInterfaces(iface)\n-    fields.extend(fields2)\n-    return [i for i in set(fields)]\n-\n-\n-def _compareSchemata(interface):\n-    """Return a list of extended fields by archetypes.schemaextender\n-    by comparing the real and the default schemata.\n-    """\n-    portal = getSite()\n-    pc = portal.portal_catalog\n-    brains = pc(object_provides=interface.__identifier__)\n-    for brain in brains:\n-        if not brain.meta_type or \'dexterity\' in brain.meta_type.lower():\n-            # There might be DX types with same iface and meta_type than AT\n-            continue\n-        try:\n-            obj = brain.getObject()\n-        except (KeyError, NotFound):\n-            continue\n-        real_fields = set(obj.Schema()._names)\n-        orig_fields = set(obj.schema._names)\n-        diff = [i for i in real_fields.difference(orig_fields)]\n-        return diff\n-    return []\n-\n-\n-def _checkForExtenderInterfaces(interface):\n-    """Return whether a specific content type interface\n-    is extended by archetypes.schemaextender or not.\n-    """\n-    sm = getGlobalSiteManager()\n-    extender_interfaces = [\n-        ISchemaExtender,\n-        ISchemaModifier,\n-        IBrowserLayerAwareExtender,\n-        IOrderableSchemaExtender,\n-    ]\n-    # We have a few possible interfaces to test\n-    # here, so get all the interfaces that\n-    # are for the given content type first\n-    registrations = \\\n-        [a for a in sm.registeredAdapters() if interface in a.required]\n-    for adapter in registrations:\n-        if adapter.provided in extender_interfaces:\n-            fields = getattr(adapter.factory(None), \'fields\', [])\n-            return [field.getName() for field in fields]\n-    return []\n-\n-\n-def installTypeIfNeeded(type_name):\n-    """Make sure the dexterity-fti is already installed.\n-    If not we create a empty dexterity fti and load the\n-    information from the fti in the profile.\n-    """\n-    if type_name not in DEFAULT_TYPES:\n-        raise KeyError(\'{0} is not one of the default types\'.format(type_name))\n-    portal = getSite()\n-    tt = getToolByName(portal, \'portal_types\')\n-    fti = tt.getTypeInfo(type_name)\n-    if IDexterityFTI.providedBy(fti):\n-        # The dx-type is already installed, so keep it.  But this\n-        # might be an old dexterity type of Collection, in which case\n-        # it is better to replace it.\n-        if type_name != \'Collection\':\n-            return\n-        if fti.klass == \'plone.app.contenttypes.content.Collection\':\n-            # If the klass is fine, we are happy.\n-            return\n-    if fti:\n-        tt.manage_delObjects(type_name)\n-    tt.manage_addTypeInformation(\'Dexterity FTI\', id=type_name)\n-    dx_fti = tt.getTypeInfo(type_name)\n-    ps = getToolByName(portal, \'portal_setup\')\n-    profile_info = ps.getProfileInfo(\'profile-plone.app.contenttypes:default\')\n-    profile_path = os.path.join(profile_info[\'path\'])\n-    environ = DirectoryImportContext(ps, profile_path)\n-    parent_path = \'types/\'\n-    importObjects(dx_fti, parent_path, environ)\n-\n-\n-def add_portlet(context, assignment, portlet_key, columnName):\n-    column = getUtility(IPortletManager, columnName)\n-    assignmentmapping = getMultiAdapter((context, column),\n-                                        IPortletAssignmentMapping)\n-    assignmentmapping[portlet_key] = assignment\n-\n-\n-def move_comments(source_object, target_object):\n-    """Move comments by copying the annotation to the target\n-    and then removing the comments from the source (not the annotation).\n-    """\n-    source_annotations = IAnnotations(source_object)\n-    comments = source_annotations.get(DISCUSSION_ANNOTATION_KEY, None)\n-    if comments is not None:\n-        target_annotations = IAnnotations(target_object)\n-        if target_annotations.get(DISCUSSION_ANNOTATION_KEY, None) is not None:\n-            logger.error(\'Comments exist on {0}\').format(\n-                target_object.absolute_url())\n-        # reset the parent before copying\n-        del comments.__parent__\n-        copy_of_comments = deepcopy(comments)\n-        copy_of_comments.__parent__ = target_object\n-        target_annotations[DISCUSSION_ANNOTATION_KEY] = copy_of_comments\n-\n-        # Delete comments from the portal where whey were stored temporarily.\n-        # Comments on the old objects will be removed with the objects.\n-        if IPloneSiteRoot.providedBy(source_object):\n-            source_conversation = IConversation(source_object)\n-            for comment in source_conversation.getComments():\n-                del source_conversation[comment.comment_id]\n-            del source_annotations[DISCUSSION_ANNOTATION_KEY]\n-\n-\n-def copy_contentrules(source_object, target_object):\n-    """Copy contentrules.\n-    """\n-    source_assignable = IRuleAssignmentManager(source_object, None)\n-    if source_assignable is not None:\n-        try:\n-            IRuleAssignmentManager(target_object)\n-        except TypeError:\n-            logger.info(\n-                \'Cound not assign contentrules to {0}\'.format(\n-                    target_object.absolute_url()\n-                )\n-            )\n-            return\n-        rules_storage = getUtility(IRuleStorage)\n-        available_rules = [r for r in rules_storage]\n-        for rule_id in source_assignable:\n-            if rule_id not in available_rules:\n-                logger.info(\n-                    \'Contentrule {0} does not exist, skip assignment!\'.format(\n-                        rule_id\n-                    )\n-                )\n-                continue\n-            assign_rule(target_object, rule_id)\n-\n-\n-def migrate_leadimage(source_object, target_object):\n-    """ Migrate images added using collective.contentleadimage to the\n-    ILeadImage-behavior of plone.app.contenttypes if it is enabled.\n-    """\n-    OLD_LEADIMAGE_FIELD_NAME = \'leadImage\'\n-    OLD_CAPTION_FIELD_NAME = \'leadImage_caption\'\n-    NEW_LEADIMAGE_FIELD_NAME = \'image\'\n-    NEW_CAPTION_FIELD_NAME = \'image_caption\'\n-\n-    if not source_object.getField(OLD_LEADIMAGE_FIELD_NAME):\n-        # skip if old content has no field\n-        return\n-\n-    if ILeadImage(target_object, None) is None:\n-        # skip if new content does not have the LeadImage-behavior enabled\n-        logger.info(\'Target does not have the behavior "Lead Image" enabled. \'\n-                    \'Could not migrate collective.leadimage fields.\')\n-        return\n-\n-    acc = source_object.getField(\n-        OLD_LEADIMAGE_FIELD_NAME).getAccessor(source_object)()\n-    if getattr(acc, \'filename\', None) is None:\n-        # skip if old content has field but has no lead image in the field\n-        return\n-\n-    # handle image field\n-    migrate_imagefield(\n-        source_object,\n-        target_object,\n-        OLD_LEADIMAGE_FIELD_NAME,\n-        NEW_LEADIMAGE_FIELD_NAME)\n-\n-    # handle image caption field\n-    migrate_simplefield(\n-        source_object,\n-        target_object,\n-        OLD_CAPTION_FIELD_NAME,\n-        NEW_CAPTION_FIELD_NAME)\n-    logger.info(\'Migrating contentlead image for {0}.\'.format(\n-        target_object.absolute_url())\n-    )\n-\n-\n-def migrate_portlets(src_obj, dst_obj):\n-    """Copy portlets for all available portletmanagers from one object\n-    to another.\n-    Also takes blocked portlet settings into account, keeps hidden portlets\n-    hidden and skips broken assignments.\n-    """\n-    if not ILocalPortletAssignable.providedBy(src_obj) or \\\n-       not ILocalPortletAssignable.providedBy(dst_obj):\n-        return\n-\n-    # also take custom portlet managers into account\n-    managers = [reg.name for reg in getSiteManager().registeredUtilities()\n-                if reg.provided == IPortletManager]\n-    # faster, but no custom managers\n-    # managers = [u\'plone.leftcolumn\', u\'plone.rightcolumn\']\n-\n-    # copy information which categories are hidden for which manager\n-    blacklist_status = IAnnotations(src_obj).get(\n-        CONTEXT_BLACKLIST_STATUS_KEY, None)\n-    if blacklist_status is not None:\n-        IAnnotations(dst_obj)[CONTEXT_BLACKLIST_STATUS_KEY] = \\\n-            deepcopy(blacklist_status)\n-\n-    # copy all portlet assignments (visibilty is stored as annotation\n-    # on the assignments and gets copied here too)\n-    for manager in managers:\n-        column = getUtility(IPortletManager, manager)\n-        mappings = getMultiAdapter((src_obj, column),\n-                                   IPortletAssignmentMapping)\n-        for key, assignment in mappings.items():\n-            # skip possibly broken portlets here\n-            if not hasattr(assignment, \'__Broken_state__\'):\n-                add_portlet(dst_obj, assignment, key, manager)\n-            else:\n-                logger.warn(u\'skipping broken portlet assignment {0} \'\n-                            \'for manager {1}\'.format(key, manager))\n-\n-\n-def store_references(context):\n-    """Store all references in the portal as a annotation on the portal."""\n-    all_references = get_all_references(context)\n-    key = \'ALL_REFERENCES\'\n-    IAnnotations(context)[key] = all_references\n-    logger.info(\'Stored {0} relations for later restore.\'.format(\n-        len(all_references))\n-    )\n-\n-\n-class ExportAllReferences(BrowserView):\n-    """Returns all references in the portal as json.\n-    """\n-\n-    def __call__(self):\n-        data = get_all_references(self.context)\n-        self.request.response.setHeader(\'Content-type\', \'application/json\')\n-        return json.dumps(data)\n-\n-\n-def get_all_references(context):\n-    results = []\n-    # Archetypes\n-    # Get all data from the reference_catalog if it exists\n-    reference_catalog = getToolByName(context, REFERENCE_CATALOG, None)\n-    if reference_catalog is not None:\n-        for brain in reference_catalog.getAllBrains():\n-            results.append({\n-                \'from_uuid\': brain.sourceUID,\n-                \'to_uuid\': brain.targetUID,\n-                \'relationship\': brain.relationship,\n-            })\n-\n-    # Dexterity\n-    # Get all data from zc.relation (relation_catalog)\n-    portal_catalog = getToolByName(context, \'portal_catalog\')\n-    relation_catalog = queryUtility(ICatalog)\n-    for rel in relation_catalog.findRelations():\n-        if rel.from_path and rel.to_path:\n-            from_brain = portal_catalog(path=dict(query=rel.from_path,\n-                                                  depth=0))\n-            to_brain = portal_catalog(path=dict(query=rel.to_path, depth=0))\n-            if len(from_brain) > 0 and len(to_brain) > 0:\n-                results.append({\n-                    \'from_uuid\': from_brain[0].UID,\n-                    \'to_uuid\': to_brain[0].UID,\n-                    \'relationship\': rel.from_attribute,\n-                })\n-    return results\n-\n-\n-def restore_references(context, relationship_fieldname_mapping=None):\n-    """Recreate all references stored in an annotation on the context.\n-\n-    Iterate over the stored references and restore them all according to\n-    the content-types framework.\n-\n-    Accepts an optional relationship_fieldname_mapping argument.\n-    This must be a dictionary with a relationship name as key and fieldname as value.\n-    For example:\n-    relationship_fieldname_mapping =  {\n-        \'advisory_contact\': \'contact\',\n-        \'study_contact\': \'contact\',\n-    }\n-    In this case, old Archetypes content types Advisory and Study both had a\n-    reference field \'contact\' to a content type Contact.\n-    This relationship was stored under different names for the two contenttypes.\n-    After migration to Dexterity, the above mapping makes sure the relation is still\n-    stored on the \'contact\' field in both cases.\n-    The attribute_name of the RelationValue will be the same as this fieldname,\n-    which is what happens by default when setting relations.\n-\n-    By default we will also map the \'relatesTo\' relation to the \'relatedItems\' field.\n-    This is needed for ATContentTypes.\n-    """\n-    if relationship_fieldname_mapping is None:\n-        relationship_fieldname_mapping = {}\n-    if \'relatesTo\' not in relationship_fieldname_mapping:\n-        # ATContentTypes used this relation.\n-        relationship_fieldname_mapping[\'relatesTo\'] = \'relatedItems\'\n-    key = \'ALL_REFERENCES\'\n-    all_references = IAnnotations(context)[key]\n-    logger.info(\'Restoring {0} relations.\'.format(\n-        len(all_references))\n-    )\n-    for index, ref in enumerate(all_references, 1):\n-        source_obj = uuidToObject(ref[\'from_uuid\'])\n-        target_obj = uuidToObject(ref[\'to_uuid\'])\n-        relationship = ref[\'relationship\']\n-        if source_obj and target_obj:\n-            relationship = ref[\'relationship\']\n-            # By default use the relationship as fieldname.  Fall back to the relationship.\n-            fieldname = relationship_fieldname_mapping.get(relationship, relationship)\n-            link_items(context, source_obj, target_obj, relationship, fieldname)\n-        else:\n-            logger.warn(\n-                \'Could not restore reference from uid \'\n-                \'"{0}" to uid "{1}" on the context: {2}\'.format(\n-                    ref[\'from_uuid\'],\n-                    ref[\'to_uuid\'],\n-                    \'/\'.join(context.getPhysicalPath())\n-                )\n-            )\n-        if not index % 100:\n-            logger.info(\'Restoring relations: {}/{}\'.format(\n-                index, len(all_references)))\n-    del IAnnotations(context)[key]\n-\n-\n-def link_items(  # noqa\n-    context,\n-    source_obj,\n-    target_obj,\n-    relationship=None,\n-    fieldname=\'relatedItems\',\n-):\n-    """Add a relation between two content objects.\n-\n-    This uses the field \'relatedItems\' and works for Archetypes and Dexterity.\n-    By passing a fieldname and a relationship it can be used to create\n-    arbitrary relations.\n-\n-    Note: for the relatedItems field, Products.ATContentTypes uses \'relatesTo\'\n-    and plone.app.contenttypes uses \'relatedItems\'.\n-    We switch between these two, based on the source object.\n-    """\n-    # relations from AT to DX and from DX to AT are only possible through\n-    # the referenceable-behavior:\n-    # plone.app.referenceablebehavior.referenceable.IReferenceable\n-    drop_msg = """Dropping reference from %s to %s since\n-    plone.app.referenceablebehavior is not enabled!"""\n-\n-    if source_obj is target_obj:\n-        # Thou shalt not relate to yourself.\n-        return\n-\n-    if IDexterityContent.providedBy(source_obj):\n-        source_type = \'DX\'\n-    else:\n-        source_type = \'AT\'\n-\n-    if IDexterityContent.providedBy(target_obj):\n-        target_type = \'DX\'\n-    else:\n-        target_type = \'AT\'\n-\n-    if relationship == referencedRelationship:\n-        # \'isReferencing\' is the relationship for linkintegrity-relations.\n-        # Linkintegrity-relations should automatically be (re)created by\n-        # plone.app.linkintegrity.handlers.modifiedDexterity or\n-        # plone.app.linkintegrity.handlers.modifiedArchetype\n-        # when a ObjectModifiedEvent is thrown.\n-        # These relations are only created if the source has a richtext-field\n-        # with a link to the target and should not be created manually.\n-        if source_type == \'AT\':\n-            modifiedArchetype(source_obj, None)\n-        if source_type == \'DX\':\n-            modifiedDexterity(source_obj, None)\n-        return\n-\n-    if source_type == \'AT\':\n-        if relationship == \'relatedItems\':\n-            relationship = \'relatesTo\'\n-        # If there is any Archetypes-content there is also the\n-        # reference_catalog. For a site without AT content this\n-        # might not be there at all.\n-        reference_catalog = getToolByName(context, REFERENCE_CATALOG)\n-        uid_catalog = getToolByName(context, \'uid_catalog\')\n-        if target_type == \'DX\' and not is_referenceable(target_obj):\n-            logger.info(drop_msg % (\n-                source_obj.absolute_url(), target_obj.absolute_url()))\n-            return\n-\n-        # Make sure both objects are properly indexed and referenceable\n-        # Some objects that werde just created (migrated) are not yet\n-        # indexed properly.\n-        source_uid = IUUID(source_obj)\n-        target_uid = IUUID(target_obj)\n-        _catalog = uid_catalog._catalog\n-\n-        if not _catalog.indexes[\'UID\']._index.get(source_uid):\n-            uid_catalog.catalog_object(source_obj, source_uid)\n-            modified(source_obj)\n-\n-        if not _catalog.indexes[\'UID\']._index.get(target_uid):\n-            uid_catalog.catalog_object(target_obj, target_uid)\n-            modified(target_obj)\n-\n-        field = source_obj.getField(fieldname)\n-        if field is None:\n-            # we can\'t migrate if it doesn\'t actually have the field\n-            return\n-        accessor = field.getAccessor(source_obj)\n-        existing_at_relations = accessor()\n-\n-        if not isinstance(existing_at_relations, list):\n-            existing_at_relations = [i for i in existing_at_relations]\n-        if not existing_at_relations:\n-            existing_at_relations = []\n-        if target_obj in existing_at_relations:\n-            # don\'t do anything\n-            return\n-\n-        target_uid = IUUID(target_obj)\n-        targetUIDs = [ref.targetUID for ref in reference_catalog.getReferences(\n-            source_obj, relationship)]\n-        if target_uid in targetUIDs:\n-            # Drop relation since the old ones are most likely broken.\n-            reference_catalog.deleteReference(\n-                source_obj, target_uid, relationship)\n-\n-        existing_at_relations.append(target_obj)\n-        mutator = field.getMutator(source_obj)\n-        mutator(existing_at_relations)\n-        modified(source_obj)\n-        return\n-\n-    if source_type is \'DX\':\n-        if relationship == \'relatesTo\':\n-            relationship = \'relatedItems\'\n-        if target_type is \'AT\' and not is_referenceable(source_obj):\n-            logger.info(drop_msg % (\n-                source_obj.absolute_url(), target_obj.absolute_url()))\n-            return\n-        # handle dx-relation\n-        if relationship == \'translationOf\':\n-            # LinguaPlone relations make no sense for Dexterity\n-            return\n-\n-        intids = getUtility(IIntIds)\n-        to_id = intids.getId(target_obj)\n-        # Before we set the fieldname attribute on the source object,\n-        # we need to know if this should be a list or a single item.\n-        # Might be None at the moment.\n-        # We check the field definition.\n-        fti = getUtility(IDexterityFTI, name=source_obj.portal_type)\n-        field = None\n-        for schema in iterSchemataForType(fti):\n-            field = schema.get(fieldname, None)\n-            if field is not None:\n-                break\n-        if isinstance(field, RelationList):\n-            existing_relations = getattr(source_obj, fieldname, [])\n-            if existing_relations is None:\n-                existing_relations = []\n-            else:\n-                # purge broken relations\n-                existing_relations = [\n-                    i for i in existing_relations if i.to_id is not None]\n-            if to_id not in [i.to_id for i in existing_relations]:\n-                existing_relations.append(RelationValue(to_id))\n-                setattr(source_obj, fieldname, existing_relations)\n-                modified(source_obj)\n-                return\n-            return\n-        elif isinstance(field, (Relation, RelationChoice)):\n-            setattr(source_obj, fieldname, RelationValue(to_id))\n-            modified(source_obj)\n-            return\n-\n-        # We should never end up here!\n-        logger.warning(\'Ignoring unknown fieldname %s when restoring relation %s from %s to %s\',\n-            fieldname, relationship, source_obj.absolute_url(), target_obj.absolute_url())\n-\n-\n-def is_referenceable(obj):\n-    """Find out if this object (AT or DX) is referenceable.\n-\n-    Return True if a obj can be referenced using the reference_catalog used by\n-    Archetypes-Relations and Linkintegrity.\n-\n-    Relations using the relation_catalog (zc.relation.interfaces.ICatalog) are\n-    not covered by this test!\n-    """\n-    is_referenceable = False\n-    if IReferenceable.providedBy(obj) or \\\n-            safe_hasattr(aq_base(obj), \'isReferenceable\'):\n-        is_referenceable = True\n-    else:\n-        try:\n-            # This most likely the case when plone.app.referenceablebehavior\n-            # is enabled.\n-            obj = IReferenceable(obj)\n-            is_referenceable = True\n-        except TypeError:\n-            is_referenceable = False\n-    return is_referenceable\ndiff --git a/plone/app/contenttypes/migration/vocabularies.py b/plone/app/contenttypes/migration/vocabularies.py\ndeleted file mode 100644\nindex c1e76df4..00000000\n--- a/plone/app/contenttypes/migration/vocabularies.py\n+++ /dev/null\n@@ -1,235 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.blob.interfaces import IATBlobFile\n-from plone.app.blob.interfaces import IATBlobImage\n-from plone.app.contenttypes import _\n-from plone.app.contenttypes.migration import migration\n-from plone.app.contenttypes.migration.topics import migrate_topics\n-from plone.app.contenttypes.migration.utils import isSchemaExtended\n-from Products.ATContentTypes.interfaces.document import IATDocument\n-from Products.ATContentTypes.interfaces.event import IATEvent\n-from Products.ATContentTypes.interfaces.file import IATFile\n-from Products.ATContentTypes.interfaces.folder import IATFolder\n-from Products.ATContentTypes.interfaces.image import IATImage\n-from Products.ATContentTypes.interfaces.link import IATLink\n-from Products.ATContentTypes.interfaces.news import IATNewsItem\n-from Products.ATContentTypes.interfaces.topic import IATTopic\n-from Products.CMFCore.utils import getToolByName\n-from zope.interface import implementer\n-from zope.schema.interfaces import IVocabularyFactory\n-from zope.schema.vocabulary import SimpleVocabulary\n-\n-import pkg_resources\n-\n-\n-import six\n-\n-\n-try:\n-    pkg_resources.get_distribution(\'plone.app.collection\')\n-except pkg_resources.DistributionNotFound:\n-    ICollection = None\n-    HAS_APP_COLLECTION = False\n-else:\n-    HAS_APP_COLLECTION = True\n-    from plone.app.collection.interfaces import ICollection\n-\n-ATCT_LIST = {\n-    \'Folder\': {\n-        \'iface\': IATFolder,\n-        \'migrator\': migration.migrate_folders,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Folder\',\n-        \'old_meta_type\': \'ATFolder\',\n-    },\n-    \'Document\': {\n-        \'iface\': IATDocument,\n-        \'migrator\': migration.migrate_documents,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Document\',\n-        \'old_meta_type\': \'ATDocument\',\n-    },\n-    # File without blobs\n-    \'File\': {\n-        \'iface\': IATFile,\n-        \'migrator\': migration.migrate_files,\n-        \'extended_fields\': [],\n-        \'type_name\': \'File\',\n-        \'old_meta_type\': \'ATFile\',\n-    },\n-    # Image without blobs\n-    \'Image\': {\n-        \'iface\': IATImage,\n-        \'migrator\': migration.migrate_images,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Image\',\n-        \'old_meta_type\': \'ATImage\',\n-    },\n-    \'News Item\': {\n-        \'iface\': IATNewsItem,\n-        \'migrator\': migration.migrate_newsitems,\n-        \'extended_fields\': [],\n-        \'type_name\': \'News Item\',\n-        \'old_meta_type\': \'ATNewsItem\',\n-    },\n-    \'Link\': {\n-        \'iface\': IATLink,\n-        \'migrator\': migration.migrate_links,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Link\',\n-        \'old_meta_type\': \'ATLink\',\n-    },\n-    \'Event\': {\n-        \'iface\': IATEvent,\n-        \'migrator\': migration.migrate_events,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Event\',\n-        \'old_meta_type\': \'ATEvent\',\n-    },\n-    \'BlobImage\': {\n-        \'iface\': IATBlobImage,\n-        \'migrator\': migration.migrate_blobimages,\n-        \'extended_fields\': [\'image\'],\n-        \'type_name\': \'Image\',\n-        \'old_meta_type\': \'ATBlob\',\n-    },\n-    \'BlobFile\': {\n-        \'iface\': IATBlobFile,\n-        \'migrator\': migration.migrate_blobfiles,\n-        \'extended_fields\': [\'file\'],\n-        \'type_name\': \'File\',\n-        \'old_meta_type\': \'ATBlob\',\n-    },\n-    \'Topic\': {\n-        \'iface\': IATTopic,\n-        \'migrator\': migrate_topics,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Collection\',\n-        \'old_meta_type\': \'ATTopic\',\n-    },\n-}\n-\n-if HAS_APP_COLLECTION:\n-    ATCT_LIST[\'Collection\'] = {\n-        \'iface\': ICollection,\n-        \'migrator\': migration.migrate_collections,\n-        \'extended_fields\': [],\n-        \'type_name\': \'Collection\',\n-        \'old_meta_type\': \'Collection\',\n-    }\n-\n-\n-def get_terms(context, counter, ext_dict, show_extended):\n-    """Takes dicts of types and their numbers and their extended fields\n-    Returns a list of SimpleVocabularyTerms:\n-    value = meta_type,\n-    token = meta_type,\n-    title = translated_meta_type (number_of_instances) - extended fields: list\n-    """\n-    results = []\n-    for k, v in six.iteritems(counter):\n-        if not show_extended:\n-            if k not in ext_dict:\n-                display = u\'{0} ({1})\'.format(context.translate(_(k)), v)\n-                term = SimpleVocabulary.createTerm(k, k, display)\n-                results.append(term)\n-        else:\n-            if k in ext_dict:\n-                ext = str(ext_dict[k][\'fields\']).\\\n-                    replace(\'[\', \'\').replace(\']\', \'\')\n-                display = u\'{0} ({1}) - extended fields: {2}\'.\\\n-                    format(context.translate(_(k)), v, ext)\n-                term = SimpleVocabulary.createTerm(k, k, display)\n-                results.append(term)\n-    results.sort(key=lambda x: x.title)\n-    return results\n-\n-\n-def count(brains):\n-    """Turns a list of brains into a dict {<meta_type>:<number_of_instances>,}\n-    Since Image and File both have the meta_type \'ATBlob\' they are handled\n-    differently.\n-    """\n-    counter = {}\n-    for brain in brains:\n-        pt = brain.portal_type\n-        if \'Blob\' in brain.meta_type:\n-            if pt == \'File\':\n-                pt = \'BlobFile\'\n-            else:\n-                pt = \'BlobImage\'\n-        if not counter.get(pt):\n-            counter[pt] = 0\n-        if not brain.meta_type or \'dexterity\' in brain.meta_type.lower():\n-            # There might be DX types with same iface and meta_type than AT\n-            continue\n-        counter[pt] += 1\n-    return counter\n-\n-\n-def results(context, show_extended=False):\n-    """Helper method to create the vocabularies used below.\n-    Searches the catalog for AT-meta_types to get all Archetypes content.\n-    If show_extended is true the returned SimpleVocabulary will include\n-    types that are extended beyond what is expected.\n-    """\n-    ext_dict = {}\n-    meta_types = []\n-    for k, v in ATCT_LIST.items():\n-        extendend_fields = isSchemaExtended(v[\'iface\'])\n-        expected = v[\'extended_fields\']\n-        is_extended = len(extendend_fields) > len(expected)\n-        if is_extended and show_extended:\n-            meta_types.append(v[\'old_meta_type\'])\n-            ext_dict[k] = {}\n-            if expected:\n-                extendend_fields.remove(expected[0])\n-            ext_dict[k][\'fields\'] = extendend_fields\n-\n-        elif not show_extended and not is_extended:\n-            meta_types.append(v[\'old_meta_type\'])\n-    catalog = getToolByName(context, \'portal_catalog\')\n-    brains = catalog.search({\'meta_type\': meta_types})\n-    counter = count(brains)\n-\n-    return SimpleVocabulary(get_terms(context,\n-                                      counter,\n-                                      ext_dict,\n-                                      show_extended))\n-\n-\n-@implementer(IVocabularyFactory)\n-class ATCTypesVocabulary(object):\n-\n-    def __call__(self, context):\n-        """Return a vocabulary with standard content types\n-        and, for each one, the number of occurrences.\n-        """\n-        return results(context, show_extended=False)\n-\n-\n-@implementer(IVocabularyFactory)\n-class ExtendedTypesVocabulary(object):\n-\n-    def __call__(self, context):\n-        """Return a vocabulary with all extended types\n-        and for each the number of occurences and a list of the\n-        extended fields.\n-        """\n-        return results(context, show_extended=True)\n-\n-\n-@implementer(IVocabularyFactory)\n-class ChangedBaseClasses(object):\n-\n-    def __call__(self, context):\n-        """Return a vocabulary with all changed base classes."""\n-        from plone.app.contenttypes.migration.dxmigration import \\\n-            list_of_changed_base_class_names\n-        list_of_class_names = list_of_changed_base_class_names(context) or {}\n-        return SimpleVocabulary(\n-            [SimpleVocabulary.createTerm(\n-                class_name, class_name,\n-                \'{0} ({1})\'.format(\n-                    class_name, list_of_class_names[class_name]))\n-             for class_name in list_of_class_names.keys()]\n-        )\ndiff --git a/plone/app/contenttypes/tests/test_content_profile.py b/plone/app/contenttypes/tests/test_content_profile.py\nindex b2f1c471..030d9f10 100644\n--- a/plone/app/contenttypes/tests/test_content_profile.py\n+++ b/plone/app/contenttypes/tests/test_content_profile.py\n@@ -66,15 +66,6 @@ def test_Members_was_created(self):\n         obj = self.portal[\'Members\']\n         self.assertEqual(obj.portal_type, \'Folder\')\n \n-    @unittest.skip(\'Replaced by new members-search-form\')\n-    def test_Members__index_html(self):\n-        # Was the index_html script created?\n-        obj = self.portal[\'Members\'][\'index_html\']\n-        self.assertTrue(isinstance(obj, PythonScript))\n-        # It\'s outside the scope of this test to verify the contents of\n-        # the script are correct. Simply checking for existence should\n-        # be enough.\n-\n     def test_Members_portlets(self):\n         # Have the right column portlet manager setting been added?\n         members = self.portal[\'Members\']\ndiff --git a/plone/app/contenttypes/tests/test_migration.py b/plone/app/contenttypes/tests/test_migration.py\ndeleted file mode 100644\nindex c4eeebb8..00000000\n--- a/plone/app/contenttypes/tests/test_migration.py\n+++ /dev/null\n@@ -1,2191 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-from plone.app.contenttypes.testing import TEST_MIGRATION\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING  # noqa\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_FUNCTIONAL_TESTING  # noqa\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_TESTING  # noqa\n-import unittest\n-\n-if TEST_MIGRATION:\n-    from lxml import etree\n-    from persistent.list import PersistentList\n-    from plone.app.contenttypes.migration.migration import migrate_documents\n-    from plone.app.contenttypes.migration.migration import migrate_folders\n-    from plone.app.contenttypes.migration.migration import migrate_newsitems\n-    from plone.app.contenttypes.migration.utils import add_portlet\n-    from plone.app.contenttypes.migration.utils import installTypeIfNeeded\n-    from plone.app.contenttypes.migration.utils import is_referenceable\n-    from plone.app.contenttypes.migration.utils import restore_references\n-    from plone.app.contenttypes.migration.utils import store_references\n-    from plone.app.contenttypes.testing import set_browserlayer\n-    from plone.app.testing import applyProfile\n-    from plone.app.testing import login\n-    from plone.app.testing import SITE_OWNER_NAME\n-    from plone.app.testing import SITE_OWNER_PASSWORD\n-    from plone.app.uuid.utils import uuidToObject\n-    from plone.app.z3cform.interfaces import IPloneFormLayer\n-    from plone.dexterity.content import Container\n-    from plone.dexterity.interfaces import IDexterityContent\n-    from plone.dexterity.interfaces import IDexterityFTI\n-    from plone.event.interfaces import IEventAccessor\n-    from plone.namedfile.file import NamedBlobImage\n-    from plone.testing.zope import Browser\n-    from Products.CMFCore.utils import getToolByName\n-    from Products.CMFPlone.utils import get_installer\n-    from z3c.relationfield import RelationValue\n-    from z3c.relationfield.index import dump\n-    from zc.relation.interfaces import ICatalog\n-    from zope.annotation.interfaces import IAnnotations\n-    from zope.component import getMultiAdapter\n-    from zope.component import getUtility\n-    from zope.component import queryUtility\n-    from zope.interface import alsoProvides\n-    from zope.intid.interfaces import IIntIds\n-    from zope.lifecycleevent import modified\n-    from zope.schema.interfaces import IVocabularyFactory\n-\n-    import json\n-    import os.path\n-    import time\n-    import transaction\n-\n-\n-class MigrateFromATContentTypesTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n-        self.request[\'URL\'] = self.portal.absolute_url()\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n-        self.portal.acl_users.userFolderAddUser(\n-            SITE_OWNER_NAME, SITE_OWNER_PASSWORD, [\'Manager\'], [])\n-\n-        login(self.portal, SITE_OWNER_NAME)\n-        self.portal.portal_workflow.setDefaultChain(\n-            \'simple_publication_workflow\')\n-\n-    def tearDown(self):\n-        try:\n-            applyProfile(self.portal, \'plone.app.contenttypes:uninstall\')\n-        except KeyError:\n-            pass\n-\n-    def get_test_image_data(self):\n-        test_image_path = os.path.join(os.path.dirname(__file__), \'image.png\')\n-        with open(test_image_path, \'rb\') as test_image_file:\n-            test_image_data = test_image_file.read()\n-        return test_image_data\n-\n-    def get_migrator(self, obj, migrator_class):\n-        src_portal_type = migrator_class.src_portal_type\n-        dst_portal_type = migrator_class.dst_portal_type\n-        migrator = migrator_class(obj, src_portal_type=src_portal_type,\n-                                  dst_portal_type=dst_portal_type)\n-        return migrator\n-\n-    def createATCTobject(self, klass, id, parent=None):\n-        \'\'\'Borrowed from ATCTFieldTestCase\'\'\'\n-        import transaction\n-        parent = parent if parent else self.portal\n-        obj = klass(oid=id)\n-        parent[id] = obj\n-        transaction.savepoint()\n-        # need to aq wrap after the savepoint. wrapped content can\'t be pickled\n-        obj = obj.__of__(parent)\n-        obj.initializeArchetype()\n-        return obj\n-\n-    def createATCTBlobNewsItem(self, id, parent=None):\n-        from Products.Archetypes.atapi import StringField, TextField\n-        from Products.ATContentTypes.interfaces import IATNewsItem\n-        from archetypes.schemaextender.interfaces import ISchemaExtender\n-        from archetypes.schemaextender.field import ExtensionField\n-        from plone.app.blob.subtypes.image import ExtensionBlobField\n-        from zope.component import getGlobalSiteManager\n-        from zope.interface import implementer\n-\n-        # create schema extension\n-        class ExtensionTextField(ExtensionField, TextField):\n-            """ derivative of text for extending schemas """\n-\n-        class ExtensionStringField(ExtensionField, StringField):\n-            """ derivative of text for extending schemas """\n-\n-        @implementer(ISchemaExtender)\n-        class SchemaExtender(object):\n-            fields = [\n-                ExtensionTextField(\'text\',\n-                                   primary=True,\n-                                   ),\n-                ExtensionBlobField(\'image\',\n-                                   accessor=\'getImage\',\n-                                   mutator=\'setImage\',\n-                                   ),\n-                ExtensionStringField(\'imageCaption\',\n-                                     ),\n-            ]\n-\n-            def __init__(self, context):\n-                self.context = context\n-\n-            def getFields(self):\n-                return self.fields\n-\n-        # register adapter\n-        gsm = getGlobalSiteManager()\n-        gsm.registerAdapter(SchemaExtender, (IATNewsItem,), ISchemaExtender)\n-\n-        # create content\n-        container = parent or self.portal\n-        container.invokeFactory(\'News Item\', id)\n-        at_newsitem = container[\'newsitem\']\n-\n-        # unregister adapter assure test isolation\n-        gsm.unregisterAdapter(required=[IATNewsItem], provided=ISchemaExtender)\n-\n-        return at_newsitem\n-\n-    def test_patct_event_is_migrated(self):\n-        """Can we migrate a Products.ATContentTypes event?"""\n-        from DateTime import DateTime\n-        from plone.app.contenttypes.migration.migration import migrate_events\n-\n-        # create an ATEvent\n-        self.portal.invokeFactory(\'Event\', \'event\')\n-        at_event = self.portal[\'event\']\n-\n-        # Date\n-        at_event.getField(\'startDate\') \\\n-                .set(at_event, DateTime(\'2013-02-03 12:00\'))\n-        at_event.getField(\'endDate\') \\\n-                .set(at_event, DateTime(\'2013-04-05 13:00\'))\n-\n-        # Contact\n-        at_event.getField(\'contactPhone\').set(at_event, \'123456789\')\n-        at_event.getField(\'contactEmail\').set(at_event, \'dummy@email.com\')\n-        at_event.getField(\'contactName\').set(at_event, \'Name\')\n-\n-        # URL\n-        at_event.getField(\'eventUrl\').set(at_event, \'http://www.plone.org\')\n-\n-        # Attendees\n-        at_event.getField(\'attendees\').set(at_event, (\'You\', \'Me\'))\n-\n-        # Text\n-        at_event.setText(\'T\xc3\xbctensuppe\')\n-        at_event.setContentType(\'text/plain\')\n-\n-        oldTZ = os.environ.get(\'TZ\', None)\n-        os.environ[\'TZ\'] = \'Asia/Tbilisi\'\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate_events(self.portal)\n-\n-        if oldTZ:\n-            os.environ[\'TZ\'] = oldTZ\n-        else:\n-            del os.environ[\'TZ\']\n-\n-        # assertions\n-        dx_event = self.portal[\'event\']\n-        self.assertEqual(\n-            "<class \'Products.ATContentTypes.content.event.ATEvent\'>",\n-            str(at_event.__class__),\n-        )\n-        self.assertEqual(\n-            "<class \'plone.app.contenttypes.content.Event\'>",\n-            str(dx_event.__class__),\n-        )\n-        self.assertEqual(2013, dx_event.start.year)\n-        self.assertEqual(2, dx_event.start.month)\n-        self.assertEqual(3, dx_event.start.day)\n-        self.assertEqual(12, dx_event.start.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(dx_event.start.tzinfo))\n-        self.assertEqual(2013, dx_event.end.year)\n-        self.assertEqual(4, dx_event.end.month)\n-        self.assertEqual(5, dx_event.end.day)\n-        self.assertEqual(13, dx_event.end.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(dx_event.end.tzinfo))\n-        self.assertEqual(\'123456789\', dx_event.contact_phone)\n-        self.assertEqual(\'dummy@email.com\', dx_event.contact_email)\n-        self.assertEqual(\'Name\', dx_event.contact_name)\n-        self.assertEqual(\'http://www.plone.org\', dx_event.event_url)\n-        self.assertEqual((\'You\', \'Me\'), dx_event.attendees)\n-        self.assertEqual(\'Event\', dx_event.__class__.__name__)\n-        self.assertEqual(u\'<p>T\\xfctensuppe</p>\', dx_event.text.output)\n-        self.assertEqual(u\'T\xc3\xbctensuppe\', dx_event.text.raw)\n-\n-    @unittest.skip(\'Skip this test, until old type is mocked\')\n-    def test_pae_atevent_is_migrated(self):\n-        """Can we migrate a plone.app.event AT event?"""\n-        from DateTime import DateTime\n-        from plone.testing import zope\n-        from plone.app.testing import applyProfile\n-        from plone.app.contenttypes.migration.migration import migrate_events\n-\n-        # Enable plone.app.event.at\n-        zope.installProduct(self.layer[\'app\'], \'plone.app.event.at\')\n-        applyProfile(self.portal, \'plone.app.event.at:default\')\n-\n-        self.portal.invokeFactory(\'Event\', \'pae-at-event\')\n-        old_event = self.portal[\'pae-at-event\']\n-\n-        # Date\n-        old_event.getField(\'startDate\') \\\n-                 .set(old_event, DateTime(\'2013-01-01 12:00\'))\n-        old_event.getField(\'endDate\') \\\n-                 .set(old_event, DateTime(\'2013-02-01 13:00\'))\n-        old_event.getField(\'wholeDay\').set(old_event, False)\n-        old_event.getField(\'timezone\').set(old_event, \'Asia/Tbilisi\')\n-\n-        # Contact\n-        old_event.getField(\'contactPhone\').set(old_event, \'123456789\')\n-        old_event.getField(\'contactEmail\').set(old_event, \'dummy@email.com\')\n-        old_event.getField(\'contactName\').set(old_event, \'Name\')\n-\n-        # URL\n-        old_event.getField(\'eventUrl\').set(old_event, \'http://www.plone.org\')\n-\n-        # Attendees\n-        old_event.getField(\'attendees\').set(old_event, (\'You\', \'Me\'))\n-\n-        # Text\n-        old_event.setText(\'T\xc3\xbctensuppe\')\n-        old_event.setContentType(\'text/plain\')\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate_events(self.portal)\n-\n-        # Compare new and old events\n-        new_event = self.portal[\'pae-at-event\']\n-        self.assertEqual(\n-            "<class \'plone.app.event.at.content.ATEvent\'>",\n-            str(old_event.__class__),\n-        )\n-        self.assertEqual(\n-            "<class \'plone.app.contenttypes.content.Event\'>",\n-            str(new_event.__class__),\n-        )\n-        self.assertEqual(\'Event\', new_event.portal_type)\n-        self.assertEqual(2013, new_event.start.year)\n-        self.assertEqual(1, new_event.start.month)\n-        self.assertEqual(1, new_event.start.day)\n-        self.assertEqual(12, new_event.start.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(new_event.start.tzinfo))\n-        self.assertEqual(2013, new_event.end.year)\n-        self.assertEqual(2, new_event.end.month)\n-        self.assertEqual(1, new_event.end.day)\n-        self.assertEqual(13, new_event.end.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(new_event.end.tzinfo))\n-        self.assertEqual(u\'Name\', new_event.contact_name)\n-        self.assertEqual(u\'dummy@email.com\', new_event.contact_email)\n-        self.assertEqual(u\'123456789\', new_event.contact_phone)\n-        self.assertEqual(u\'http://www.plone.org\', new_event.event_url)\n-        self.assertEqual(u\'<p>T\\xfctensuppe</p>\', new_event.text.output)\n-        self.assertEqual(u\'T\xc3\xbctensuppe\', new_event.text.raw)\n-\n-    @unittest.skip(\'Skip this test, until old type is mocked\')\n-    def test_pae_dxevent_is_migrated(self):\n-        from datetime import datetime\n-        from plone.app.contenttypes.migration.migration import migrate_events\n-        from plone.app.textfield.value import RichTextValue\n-\n-        # Enable plone.app.event.dx\n-        from plone.app.testing import applyProfile\n-        applyProfile(self.portal, \'plone.app.event:testing\')\n-\n-        old_event = self.portal[self.portal.invokeFactory(\n-            \'plone.app.event.dx.event\',\n-            \'dx-event\',\n-            start=datetime(2011, 11, 11, 11, 0),\n-            end=datetime(2011, 11, 11, 12, 0),\n-            timezone=\'Asia/Tbilisi\',\n-            whole_day=False,\n-        )]\n-        old_event_acc = IEventAccessor(old_event)\n-        old_event_acc.contact_name = \'George\'\n-        old_event_acc.contact_email = \'me@geor.ge\'\n-        old_event_acc.contact_phone = \'+99512345\'\n-        old_event_acc.event_url = \'http://geor.ge/event\'\n-        # We need to manually place the value of the \'text\' field into\n-        # annotation storage\n-        richtext = RichTextValue(\n-            raw=\'Woo, yeah\',\n-            mimeType=\'text/plain\',\n-            outputMimeType=\'text/x-html-safe\'\n-        )\n-        ann = IAnnotations(old_event)\n-        ann[\'plone.app.event.dx.behaviors.IEventSummary.text\'] = richtext\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate_events(self.portal)\n-\n-        # Compare new and old events\n-        new_event = self.portal[\'dx-event\']\n-        self.assertEqual(False, old_event.exclude_from_nav)\n-        self.assertEqual(\'Event\', new_event.portal_type)\n-        self.assertEqual(2011, new_event.start.year)\n-        self.assertEqual(11, new_event.start.month)\n-        self.assertEqual(11, new_event.start.day)\n-        self.assertEqual(11, new_event.start.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(new_event.start.tzinfo))\n-        self.assertEqual(2011, new_event.end.year)\n-        self.assertEqual(11, new_event.end.month)\n-        self.assertEqual(11, new_event.end.day)\n-        self.assertEqual(12, new_event.end.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(new_event.end.tzinfo))\n-        self.assertEqual(u\'George\', new_event.contact_name)\n-        self.assertEqual(u\'me@geor.ge\', new_event.contact_email)\n-        self.assertEqual(u\'+99512345\', new_event.contact_phone)\n-        self.assertEqual(u\'http://geor.ge/event\', new_event.event_url)\n-        self.assertEqual(u\'<p>Woo, yeah</p>\', new_event.text.output)\n-        self.assertEqual(\'Woo, yeah\', new_event.text.raw)\n-        self.assertEqual(False, new_event.exclude_from_nav)\n-\n-    def test_pact_1_0_dxevent_is_migrated(self):\n-        from datetime import datetime\n-        import pytz\n-        from plone.app.contenttypes.migration.migration import migrate_events\n-        from plone.app.textfield.value import RichTextValue\n-        from plone.app.contenttypes.tests.oldtypes import create1_0EventType\n-\n-        # Create a 1.0 Event object\n-        timezone = pytz.timezone(\'Asia/Tbilisi\')\n-        create1_0EventType(self.portal)\n-        old_event = self.portal[self.portal.invokeFactory(\n-            \'Event\',\n-            \'dx-event\',\n-            location=\'Newbraska\',\n-            start_date=timezone.localize(datetime(2019, 4, 2, 15, 20)),\n-            end_date=timezone.localize(datetime(2019, 4, 2, 16, 20)),\n-            attendees=\'Me & You\',\n-            event_url=\'http://woo.com\',\n-            contact_name=\'Frank\',\n-            contact_email=\'me@fra.nk\',\n-            contact_phone=\'+4412345\',\n-        )]\n-        old_event.text = RichTextValue(\n-            raw=u\'Awes\xc3\xbcme\',\n-            mimeType=\'text/plain\',\n-            outputMimeType=\'text/x-html-safe\'\n-        )\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate_events(self.portal)\n-\n-        # Compare new and old events\n-        new_event = self.portal[\'dx-event\']\n-        self.assertEqual(False, old_event.exclude_from_nav)\n-        self.assertEqual(\'Event\', new_event.portal_type)\n-        self.assertEqual(2019, new_event.start.year)\n-        self.assertEqual(4, new_event.start.month)\n-        self.assertEqual(2, new_event.start.day)\n-        self.assertEqual(15, new_event.start.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(new_event.start.tzinfo))\n-        self.assertEqual(2019, new_event.end.year)\n-        self.assertEqual(4, new_event.end.month)\n-        self.assertEqual(2, new_event.end.day)\n-        self.assertEqual(16, new_event.end.hour)\n-        self.assertEqual(\'Asia/Tbilisi\', str(new_event.end.tzinfo))\n-        self.assertEqual(u\'Frank\', new_event.contact_name)\n-        self.assertEqual(u\'Newbraska\', new_event.location)\n-        self.assertEqual(u\'me@fra.nk\', new_event.contact_email)\n-        self.assertEqual(u\'+4412345\', new_event.contact_phone)\n-        self.assertEqual(u\'http://woo.com\', new_event.event_url)\n-        self.assertEqual(u\'<p>Awes\xc3\xbcme</p>\', new_event.text.output)\n-        self.assertEqual(u\'Awes\xc3\xbcme\', new_event.text.raw)\n-        self.assertEqual(False, new_event.exclude_from_nav)\n-\n-    def test_dx_excl_from_nav_is_migrated(self):\n-        from datetime import datetime\n-        from plone.app.contenttypes.migration.migration import DXEventMigrator\n-\n-        # Enable plone.app.event.dx\n-        from plone.app.testing import applyProfile\n-        applyProfile(self.portal, \'plone.app.event:testing\')\n-\n-        old_event = self.portal[self.portal.invokeFactory(\n-            \'plone.app.event.dx.event\',\n-            \'dx-event\',\n-            start=datetime(2011, 11, 11, 11, 0),\n-            end=datetime(2011, 11, 11, 12, 0),\n-            timezone=\'GMT\',\n-            whole_day=False,\n-            exclude_from_nav=True,\n-        )]\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(old_event, DXEventMigrator)\n-        migrator.migrate()\n-\n-        new_event = self.portal[\'dx-event\']\n-        self.assertEqual(True, old_event.exclude_from_nav)\n-        self.assertEqual(True, new_event.exclude_from_nav)\n-\n-    def test_assert_at_contenttypes(self):\n-        from plone.app.contenttypes.interfaces import IDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        self.assertEqual(\'ATDocument\', at_document.meta_type)\n-        self.assertFalse(IDocument.providedBy(at_document))\n-\n-    def test_dx_content_is_indexed(self):\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        from plone.app.contenttypes.interfaces import IDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-        brains = self.catalog(object_provides=IDocument.__identifier__)\n-        self.assertEqual(len(brains), 1)\n-        self.assertEqual(brains[0].getObject(), self.portal[\'document\'])\n-\n-    def test_old_content_is_removed(self):\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-        brains = self.catalog(portal_type=\'Document\')\n-        self.assertEqual(len(brains), 1)\n-\n-    def test_old_content_is_unindexed(self):\n-        from Products.ATContentTypes.interfaces import IATDocument\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        brains = self.catalog(object_provides=IATDocument.__identifier__)\n-        self.assertEqual(len(brains), 1)\n-        migrator.migrate()\n-        brains = self.catalog(object_provides=IATDocument.__identifier__)\n-        self.assertEqual(len(brains), 0)\n-\n-    def test_document_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        from plone.app.contenttypes.interfaces import IDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-        dx_document = self.portal[\'document\']\n-        self.assertTrue(IDocument.providedBy(dx_document))\n-        self.assertTrue(at_document is not dx_document)\n-\n-    def test_collection_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import \\\n-            migrate_collections\n-        from plone.app.contenttypes.behaviors.collection import \\\n-            ICollection as ICollectionBehavior\n-        from plone.app.contenttypes.interfaces import ICollection\n-        self.portal.invokeFactory(\'Collection\', \'collection\')\n-        at_collection = self.portal[\'collection\']\n-        at_collection.setText(\'<p>Whopee</p>\')\n-        query = [{\n-            \'i\': \'Type\',\n-            \'o\': \'plone.app.querystring.operation.string.is\',\n-            \'v\': \'Document\',\n-        }]\n-        at_collection.setQuery(query)\n-        at_collection.setLayout(\'folder_summary_view\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate_collections(self.portal)\n-        dx_collection = self.portal[\'collection\']\n-        self.assertTrue(ICollection.providedBy(dx_collection))\n-        self.assertTrue(at_collection is not dx_collection)\n-        wrapped = ICollectionBehavior(dx_collection)\n-        self.assertEqual(wrapped.query, query)\n-        self.assertEqual(dx_collection.text.output, \'<p>Whopee</p>\')\n-        at_collection.setLayout(\'summary_view\')\n-\n-    def test_document_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        from plone.app.textfield.interfaces import IRichTextValue\n-\n-        # create an ATDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        at_document.setText(\'T\xc3\xbctensuppe\')\n-        at_document.setContentType(\'chemical/x-gaussian-checkpoint\')\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-\n-        # assertions\n-        dx_document = self.portal[\'document\']\n-        self.assertTrue(IRichTextValue(dx_document.text))\n-        self.assertEqual(dx_document.text.raw, u\'T\xc3\xbctensuppe\')\n-        self.assertEqual(dx_document.text.mimeType,\n-                         \'chemical/x-gaussian-checkpoint\')\n-        self.assertEqual(dx_document.text.outputMimeType, \'text/x-html-safe\')\n-\n-    def test_document_excludefromnav_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-\n-        # create an ATDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        at_document.setExcludeFromNav(True)\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-\n-        # assertions\n-        dx_document = self.portal[\'document\']\n-        self.assertTrue(dx_document.exclude_from_nav)\n-\n-    def test_file_is_migrated(self):\n-        from Products.ATContentTypes.content.file import ATFile\n-        from plone.app.contenttypes.migration.migration import FileMigrator\n-        from plone.app.contenttypes.interfaces import IFile\n-        at_file = self.createATCTobject(ATFile, \'file\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_file, FileMigrator)\n-        migrator.migrate()\n-        dx_file = self.portal[\'file\']\n-        self.assertTrue(IFile.providedBy(dx_file))\n-        self.assertTrue(at_file is not dx_file)\n-\n-    def test_file_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import FileMigrator\n-        from plone.namedfile.interfaces import INamedBlobFile\n-        from Products.ATContentTypes.content.file import ATFile\n-        at_file = self.createATCTobject(ATFile, \'file\')\n-        field = at_file.getField(\'file\')\n-        field.set(at_file, \'dummydata\')\n-        field.setFilename(at_file, \'dummyfile.txt\')\n-        field.setContentType(at_file, \'text/dummy\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_file, FileMigrator)\n-        migrator.migrate()\n-        dx_file = self.portal[\'file\']\n-        self.assertTrue(INamedBlobFile.providedBy(dx_file.file))\n-        self.assertEqual(dx_file.file.filename, \'dummyfile.txt\')\n-        self.assertEqual(dx_file.file.contentType, \'text/dummy\')\n-        self.assertEqual(dx_file.file.data, \'dummydata\')\n-\n-    def test_image_is_migrated(self):\n-        from Products.ATContentTypes.content.image import ATImage\n-        from plone.app.contenttypes.migration.migration import ImageMigrator\n-        from plone.app.contenttypes.interfaces import IImage\n-        at_image = self.createATCTobject(ATImage, \'image\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_image, ImageMigrator)\n-        migrator.migrate()\n-        dx_image = self.portal[\'image\']\n-        self.assertTrue(IImage.providedBy(dx_image))\n-        self.assertTrue(at_image is not dx_image)\n-\n-    def test_empty_image_is_migrated(self):\n-        """\n-        This should not happened cause the image field is required,\n-        but this is a special case in AT\'s FileField.\n-        """\n-        from Products.ATContentTypes.content.image import ATImage\n-        from plone.app.contenttypes.migration.migration import ImageMigrator\n-        at_image = self.createATCTobject(ATImage, \'image\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_image, ImageMigrator)\n-        migrator.migrate()\n-        dx_image = self.portal[\'image\']\n-        self.assertEqual(dx_image.image, None)\n-\n-    def test_image_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import ImageMigrator\n-        from plone.namedfile.interfaces import INamedBlobImage\n-        from Products.ATContentTypes.content.image import ATImage\n-        at_image = self.createATCTobject(ATImage, \'image\')\n-        test_image_data = self.get_test_image_data()\n-        field = at_image.getField(\'image\')\n-        field.set(at_image, test_image_data)\n-        field.setFilename(at_image, \'testimage.png\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_image, ImageMigrator)\n-        migrator.migrate()\n-        dx_image = self.portal[\'image\']\n-        self.assertTrue(INamedBlobImage.providedBy(dx_image.image))\n-        self.assertEqual(dx_image.image.filename, \'testimage.png\')\n-        self.assertEqual(dx_image.image.contentType, \'image/png\')\n-        self.assertEqual(dx_image.image.data, test_image_data)\n-\n-    def test_blob_file_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import BlobFileMigrator\n-        from plone.app.contenttypes.interfaces import IFile\n-        self.portal.invokeFactory(\'File\', \'file\')\n-        at_file = self.portal[\'file\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_file, BlobFileMigrator)\n-        migrator.migrate()\n-        dx_file = self.portal[\'file\']\n-        self.assertTrue(IFile.providedBy(dx_file))\n-        self.assertTrue(at_file is not dx_file)\n-\n-    def test_blob_file_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import BlobFileMigrator\n-        from plone.namedfile.interfaces import INamedBlobFile\n-        self.portal.invokeFactory(\'File\', \'file\')\n-        at_file = self.portal[\'file\']\n-        at_file.setFile(\'dummydata\',\n-                        mimetype=\'text/dummy\',\n-                        filename=\'dummyfile.txt\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_file, BlobFileMigrator)\n-        migrator.migrate()\n-        dx_file = self.portal[\'file\']\n-        self.assertTrue(INamedBlobFile.providedBy(dx_file.file))\n-        self.assertEqual(dx_file.file.filename, \'dummyfile.txt\')\n-        self.assertEqual(dx_file.file.contentType, \'text/dummy\')\n-        self.assertEqual(dx_file.file.data, \'dummydata\')\n-\n-    def test_blob_image_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import\\\n-            BlobImageMigrator\n-        from plone.app.contenttypes.interfaces import IImage\n-        self.portal.invokeFactory(\'Image\', \'image\')\n-        at_image = self.portal[\'image\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_image, BlobImageMigrator)\n-        migrator.migrate()\n-        dx_image = self.portal[\'image\']\n-        self.assertTrue(IImage.providedBy(dx_image))\n-        self.assertTrue(at_image is not dx_image)\n-\n-    def test_empty_blob_image_is_migrated(self):\n-        """\n-        This should not happened cause the image field is required,\n-        but this is a special case in AT\'s FileField.\n-        """\n-        from plone.app.contenttypes.migration.migration import\\\n-            BlobImageMigrator\n-        self.portal.invokeFactory(\'Image\', \'image\')\n-        at_image = self.portal[\'image\']\n-        migrator = self.get_migrator(at_image, BlobImageMigrator)\n-        migrator.migrate()\n-        dx_image = self.portal[\'image\']\n-        self.assertEqual(dx_image.image.data, \'\')\n-\n-    def test_blob_image_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import\\\n-            BlobImageMigrator\n-        from plone.namedfile.interfaces import INamedBlobImage\n-        self.portal.invokeFactory(\'Image\', \'image\')\n-        at_image = self.portal[\'image\']\n-        test_image_data = self.get_test_image_data()\n-        at_image.setImage(test_image_data, filename=\'testimage.png\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_image, BlobImageMigrator)\n-        migrator.migrate()\n-        dx_image = self.portal[\'image\']\n-        self.assertTrue(INamedBlobImage.providedBy(dx_image.image))\n-        self.assertEqual(dx_image.image.filename, \'testimage.png\')\n-        self.assertEqual(dx_image.image.contentType, \'image/png\')\n-        self.assertEqual(dx_image.image.data, test_image_data)\n-\n-    def test_link_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import LinkMigrator\n-        from plone.app.contenttypes.interfaces import ILink\n-        self.portal.invokeFactory(\'Link\', \'link\')\n-        at_link = self.portal[\'link\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_link, LinkMigrator)\n-        migrator.migrate()\n-        dx_link = self.portal[\'link\']\n-        self.assertTrue(ILink.providedBy(dx_link))\n-        self.assertTrue(dx_link is not at_link)\n-\n-    def test_link_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import LinkMigrator\n-        from plone.app.contenttypes.interfaces import ILink\n-        self.portal.invokeFactory(\'Link\', \'link\')\n-        at_link = self.portal[\'link\']\n-        field = at_link.getField(\'remoteUrl\')\n-        field.set(at_link, \'http://plone.org\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_link, LinkMigrator)\n-        migrator.migrate()\n-        dx_link = self.portal[\'link\']\n-        self.assertTrue(ILink.providedBy(dx_link.link))\n-        self.assertEqual(dx_link.link.remoteUrl, u\'http://plone.org\')\n-\n-    def test_newsitem_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import NewsItemMigrator\n-        from plone.app.contenttypes.interfaces import INewsItem\n-        self.portal.invokeFactory(\'News Item\', \'newsitem\')\n-        at_newsitem = self.portal[\'newsitem\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_newsitem, NewsItemMigrator)\n-        migrator.migrate()\n-        dx_newsitem = self.portal[\'newsitem\']\n-        self.assertTrue(INewsItem.providedBy(dx_newsitem))\n-        self.assertTrue(at_newsitem is not dx_newsitem)\n-\n-    def test_newsitem_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import NewsItemMigrator\n-        from plone.app.textfield.interfaces import IRichTextValue\n-        from plone.namedfile.interfaces import INamedBlobImage\n-\n-        # create an ATNewsItem\n-        self.portal.invokeFactory(\'News Item\', \'newsitem\')\n-        at_newsitem = self.portal[\'newsitem\']\n-        at_newsitem.setText(\'T\xc3\xbctensuppe\')\n-        at_newsitem.setContentType(\'chemical/x-gaussian-checkpoint\')\n-        at_newsitem.setImageCaption(\'Daniel D\xc3\xbcsentrieb\')\n-        test_image_data = self.get_test_image_data()\n-        image_field = at_newsitem.getField(\'image\')\n-        image_field.set(at_newsitem, test_image_data)\n-        image_field.setFilename(at_newsitem, \'testimage.png\')\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_newsitem, NewsItemMigrator)\n-        migrator.migrate()\n-\n-        # assertions\n-        dx_newsitem = self.portal[\'newsitem\']\n-        self.assertTrue(INamedBlobImage.providedBy(dx_newsitem.image))\n-        self.assertEqual(dx_newsitem.image.filename, \'testimage.png\')\n-        self.assertEqual(dx_newsitem.image.contentType, \'image/png\')\n-        self.assertEqual(dx_newsitem.image.data, test_image_data)\n-\n-        self.assertEqual(dx_newsitem.image_caption, u\'Daniel D\xc3\xbcsentrieb\')\n-\n-        self.assertTrue(IRichTextValue(dx_newsitem.text))\n-        self.assertEqual(dx_newsitem.text.raw, u\'T\xc3\xbctensuppe\')\n-        self.assertEqual(dx_newsitem.text.mimeType,\n-                         \'chemical/x-gaussian-checkpoint\')\n-        self.assertEqual(dx_newsitem.text.outputMimeType, \'text/x-html-safe\')\n-\n-    def test_blob_newsitem_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import\\\n-            BlobNewsItemMigrator\n-        from plone.app.contenttypes.interfaces import INewsItem\n-        at_newsitem = self.createATCTBlobNewsItem(\'newsitem\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_newsitem, BlobNewsItemMigrator)\n-        migrator.migrate()\n-        dx_newsitem = self.portal[\'newsitem\']\n-        self.assertTrue(INewsItem.providedBy(dx_newsitem))\n-        self.assertTrue(at_newsitem is not dx_newsitem)\n-\n-    def test_blob_newsitem_content_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import \\\n-            BlobNewsItemMigrator\n-        from plone.app.textfield.interfaces import IRichTextValue\n-        from plone.namedfile.interfaces import INamedBlobImage\n-\n-        # create a BlobATNewsItem\n-        at_newsitem = self.createATCTBlobNewsItem(\'newsitem\')\n-        at_newsitem.setText(\'T\xc3\xbctensuppe\')\n-        at_newsitem.setContentType(\'chemical/x-gaussian-checkpoint\')\n-        test_image_data = self.get_test_image_data()\n-        namedblobimage = NamedBlobImage(\n-            data=test_image_data, filename=u\'testimage.png\')\n-        at_newsitem.image = namedblobimage\n-        at_newsitem.image_caption = u\'Daniel D\xc3\xbcsentrieb\'\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_newsitem, BlobNewsItemMigrator)\n-        migrator.migrate()\n-        dx_newsitem = self.portal[\'newsitem\']\n-\n-        # assertions\n-        self.assertTrue(INamedBlobImage.providedBy(dx_newsitem.image))\n-        self.assertEqual(dx_newsitem.image.filename, \'testimage.png\')\n-        self.assertEqual(dx_newsitem.image.contentType, \'image/png\')\n-        self.assertEqual(dx_newsitem.image.data, test_image_data)\n-\n-        # self.assertEqual(dx_newsitem.image_caption, u\'Daniel D\xc3\xbcsentrieb\')\n-\n-        self.assertTrue(IRichTextValue(dx_newsitem.text))\n-        self.assertEqual(dx_newsitem.text.raw, u\'T\xc3\xbctensuppe\')\n-        self.assertEqual(\n-            dx_newsitem.text.mimeType, \'chemical/x-gaussian-checkpoint\')\n-\n-    def test_modifield_date_is_unchanged(self):\n-        set_browserlayer(self.request)\n-\n-        # create folders\n-        self.portal.invokeFactory(\'Folder\', \'folder1\')\n-        at_folder1 = self.portal[\'folder1\']\n-        self.portal.invokeFactory(\'Folder\', \'folder2\')\n-        at_folder2 = self.portal[\'folder2\']\n-        self.portal.invokeFactory(\'Folder\', \'folder3\')\n-        at_folder3 = self.portal[\'folder3\']\n-        at_folder2.invokeFactory(\'Folder\', \'folder4\')\n-        at_folder4 = at_folder2[\'folder4\']\n-\n-        # create ATDocuments\n-        at_folder1.invokeFactory(\'Document\', \'doc1\')\n-        at_doc1 = at_folder1[\'doc1\']\n-        at_folder2.invokeFactory(\'Document\', \'doc2\')\n-        at_doc2 = at_folder2[\'doc2\']\n-        self.portal.invokeFactory(\'Document\', \'doc3\')\n-        at_doc3 = self.portal[\'doc3\']\n-        at_folder2.invokeFactory(\'News Item\', \'newsitem1\')\n-        at_newsitem1 = at_folder2[\'newsitem1\']\n-        at_folder4.invokeFactory(\'News Item\', \'newsitem2\')\n-        at_newsitem2 = at_folder4[\'newsitem2\']\n-\n-        # be 100% sure the migration-date is after the creation-date\n-        time.sleep(0.1)\n-\n-        # relate them - triggers modification date\n-        at_doc1.setRelatedItems([at_doc2])\n-        at_doc2.setRelatedItems([at_newsitem1, at_doc3, at_doc1])\n-        at_doc3.setRelatedItems(at_doc1)\n-        at_folder1.setRelatedItems([at_doc2])\n-        at_folder2.setRelatedItems([at_doc1])\n-\n-        at_folder1_date = at_folder1.ModificationDate()\n-        at_folder2_date = at_folder2.ModificationDate()\n-        at_folder3_date = at_folder3.ModificationDate()\n-        at_folder4_date = at_folder4.ModificationDate()\n-        at_doc1_date = at_doc1.ModificationDate()\n-        at_doc2_date = at_doc2.ModificationDate()\n-        at_doc3_date = at_doc3.ModificationDate()\n-        at_newsitem1_date = at_newsitem1.ModificationDate()\n-        at_newsitem2_date = at_newsitem2.ModificationDate()\n-\n-        # migrate content\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self._enable_referenceable_for(\'Document\')\n-        self._enable_referenceable_for(\'News Item\')\n-        self._enable_referenceable_for(\'Folder\')\n-\n-        # we use the migration-view instead of calling the migratons by hand\n-        # to make sure the patch for notifyModified is used.\n-        migration_view = getMultiAdapter(\n-            (self.portal, self.request),\n-            name=u\'migrate_from_atct\'\n-        )\n-\n-        # We call migration twice to make sure documents are migrated first.\n-        # This would result in changed modification-dates on the folders\n-        # unless this is patched in the migration-view.\n-        migration_view(\n-            migrate=True,\n-            content_types=[\'Document\'],\n-            migrate_schemaextended_content=True,\n-            migrate_references=True,\n-            from_form=False,\n-        )\n-        migration_view(\n-            migrate=True,\n-            content_types=[\'Folder\'],\n-            migrate_schemaextended_content=True,\n-            migrate_references=True,\n-            from_form=False,\n-        )\n-\n-        dx_folder1 = self.portal[\'folder1\']\n-        dx_folder2 = self.portal[\'folder2\']\n-        dx_folder3 = self.portal[\'folder3\']\n-        dx_folder4 = dx_folder2[\'folder4\']\n-\n-        dx_doc1 = dx_folder1[\'doc1\']\n-        dx_doc2 = dx_folder2[\'doc2\']\n-        dx_doc3 = self.portal[\'doc3\']\n-\n-        self.assertTrue(at_folder1 is not dx_folder1)\n-        self.assertTrue(at_folder2 is not dx_folder2)\n-\n-        # assert ModificationDates\n-        self.assertEqual(at_folder1_date, dx_folder1.ModificationDate())\n-        self.assertEqual(at_folder2_date, dx_folder2.ModificationDate())\n-        self.assertEqual(at_folder3_date, dx_folder3.ModificationDate())\n-        self.assertEqual(at_folder4_date, dx_folder4.ModificationDate())\n-        self.assertEqual(at_doc1_date, dx_doc1.ModificationDate())\n-        self.assertEqual(at_doc2_date, dx_doc2.ModificationDate())\n-        self.assertEqual(at_doc3_date, dx_doc3.ModificationDate())\n-        self.assertEqual(at_newsitem1_date, at_newsitem1.ModificationDate())\n-        self.assertEqual(at_newsitem2_date, at_newsitem2.ModificationDate())\n-\n-    def test_references_are_set_correctly(self):\n-        set_browserlayer(self.request)\n-\n-        # create folders\n-        self.portal.invokeFactory(\'Folder\', \'folder1\')\n-        at_folder1 = self.portal[\'folder1\']\n-        self.portal.invokeFactory(\'Folder\', \'folder2\')\n-        at_folder2 = self.portal[\'folder2\']\n-        self.portal.invokeFactory(\'Folder\', \'folder3\')\n-\n-        # create ATDocuments\n-        at_folder1.invokeFactory(\'Document\', \'doc1\')\n-        at_doc1 = at_folder1[\'doc1\']\n-        at_folder2.invokeFactory(\'Document\', \'doc2\')\n-        at_doc2 = at_folder2[\'doc2\']\n-        self.portal.invokeFactory(\'Document\', \'doc3\')\n-        at_doc3 = self.portal[\'doc3\']\n-        at_folder2.invokeFactory(\'News Item\', \'newsitem1\')\n-        at_newsitem1 = at_folder2[\'newsitem1\']\n-\n-        # be 100% sure the migration-date is after the creation-date\n-        time.sleep(0.1)\n-\n-        # relate them\n-        at_doc1.setRelatedItems([at_doc2])\n-        at_doc2.setRelatedItems([at_newsitem1, at_doc3, at_doc1])\n-        at_doc3.setRelatedItems(at_doc1)\n-        at_folder1.setRelatedItems([at_doc2])\n-        at_folder2.setRelatedItems([at_doc1])\n-\n-        # migrate content\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self._enable_referenceable_for(\'Document\')\n-        self._enable_referenceable_for(\'News Item\')\n-        self._enable_referenceable_for(\'Folder\')\n-\n-        # we use the migration-view instead of calling the migratons by hand\n-        # to make sure the patch for notifyModified is used.\n-        migration_view = getMultiAdapter(\n-            (self.portal, self.request),\n-            name=u\'migrate_from_atct\'\n-        )\n-\n-        # We call migration twice to make sure documents are migrated first.\n-        # This would result in changed modification-dates on the folders\n-        # unless this is patched in the migration-view.\n-        migration_view(\n-            migrate=True,\n-            content_types=[\'Document\'],\n-            migrate_schemaextended_content=True,\n-            migrate_references=True,\n-            from_form=False,\n-        )\n-        migration_view(\n-            migrate=True,\n-            content_types=[\'Folder\'],\n-            migrate_schemaextended_content=True,\n-            migrate_references=True,\n-            from_form=False,\n-        )\n-\n-        dx_folder1 = self.portal[\'folder1\']\n-        dx_folder2 = self.portal[\'folder2\']\n-\n-        dx_doc1 = dx_folder1[\'doc1\']\n-        dx_doc2 = dx_folder2[\'doc2\']\n-        dx_doc3 = self.portal[\'doc3\']\n-\n-        self.assertTrue(at_folder1 is not dx_folder1)\n-        self.assertTrue(at_folder2 is not dx_folder2)\n-\n-        # assert single references\n-        dx_doc1_related = [x.to_object for x in dx_doc1.relatedItems]\n-        self.assertEqual(dx_doc1_related, [dx_doc2])\n-\n-        dx_doc3_related = [x.to_object for x in dx_doc3.relatedItems]\n-        self.assertEqual(dx_doc3_related, [dx_doc1])\n-\n-        dx_folder1_related = [x.to_object for x in dx_folder1.relatedItems]\n-        self.assertEqual(dx_folder1_related, [dx_doc2])\n-        dx_folder2_related = [x.to_object for x in dx_folder2.relatedItems]\n-        self.assertEqual(dx_folder2_related, [dx_doc1])\n-\n-        # assert multi references, order is restored\n-        dx_doc2_related = [x.to_object for x in dx_doc2.relatedItems]\n-        self.assertEqual(dx_doc2_related, [at_newsitem1, dx_doc3, dx_doc1])\n-\n-    def test_folder_is_migrated(self):\n-        from plone.app.contenttypes.migration.migration import FolderMigrator\n-        from plone.app.contenttypes.interfaces import IFolder\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        at_folder.setLayout(\'atct_album_view\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_folder, FolderMigrator)\n-        migrator.migrate()\n-        dx_folder = self.portal[\'folder\']\n-        self.assertTrue(IFolder.providedBy(dx_folder))\n-        self.assertTrue(at_folder is not dx_folder)\n-        self.assertEqual(dx_folder.getLayout(), \'album_view\')\n-\n-    def test_folder_children_are_migrated(self):\n-        from plone.app.contenttypes.migration.migration import FolderMigrator\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        at_folder.invokeFactory(\'Document\', \'document\')\n-        at_child = at_folder[\'document\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_folder, FolderMigrator)\n-        migrator.migrate()\n-        dx_folder = self.portal[\'folder\']\n-        self.assertTrue(at_child in dx_folder.contentValues())\n-\n-    def test_relations_are_migrated(self):\n-        # create folders\n-        self.portal.invokeFactory(\'Folder\', \'folder1\')\n-        at_folder1 = self.portal[\'folder1\']\n-        self.portal.invokeFactory(\'Folder\', \'folder2\')\n-        at_folder2 = self.portal[\'folder2\']\n-\n-        # create ATDocuments\n-        at_folder1.invokeFactory(\'Document\', \'doc1\')\n-        at_doc1 = at_folder1[\'doc1\']\n-        at_folder2.invokeFactory(\'Document\', \'doc2\')\n-        at_doc2 = at_folder2[\'doc2\']\n-        self.portal.invokeFactory(\'Document\', \'doc3\')\n-        at_doc3 = self.portal[\'doc3\']\n-        at_folder1.invokeFactory(\'News Item\', \'newsitem\')\n-        at_newsitem = at_folder1[\'newsitem\']\n-\n-        # relate them\n-        at_doc1.setRelatedItems([at_doc2])\n-        at_doc2.setRelatedItems([at_newsitem, at_doc3, at_doc1])\n-        at_doc3.setRelatedItems(at_doc1)\n-        at_folder1.setRelatedItems([at_doc2])\n-        at_folder2.setRelatedItems([at_doc1])\n-        self.assertEqual([x for x in at_folder2.getRelatedItems()], [at_doc1])\n-        # migrate content\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self._enable_referenceable_for(\'Folder\')\n-        self._enable_referenceable_for(\'Document\')\n-        self._enable_referenceable_for(\'News Item\')\n-        store_references(self.portal)\n-        migrate_documents(self.portal)\n-        migrate_folders(self.portal)\n-\n-        # rebuild catalog\n-        self.portal.portal_catalog.clearFindAndRebuild()\n-\n-        dx_folder1 = self.portal[\'folder1\']\n-        dx_folder2 = self.portal[\'folder2\']\n-\n-        dx_doc1 = dx_folder1[\'doc1\']\n-        dx_doc2 = dx_folder2[\'doc2\']\n-        dx_doc3 = self.portal[\'doc3\']\n-\n-        self.assertEqual([x.to_object for x in dx_folder2.relatedItems], [])\n-\n-        # migrate references\n-        restore_references(self.portal)\n-\n-        self.assertEqual(\n-            [x.to_object for x in dx_folder2.relatedItems], [dx_doc1])\n-\n-        # assert single references\n-        dx_doc1_related = [x.to_object for x in dx_doc1.relatedItems]\n-        self.assertEqual(dx_doc1_related, [dx_doc2])\n-\n-        dx_doc3_related = [x.to_object for x in dx_doc3.relatedItems]\n-        self.assertEqual(dx_doc3_related, [dx_doc1])\n-\n-        dx_folder1_related = [x.to_object for x in dx_folder1.relatedItems]\n-        self.assertEqual(dx_folder1_related, [dx_doc2])\n-        dx_folder2_related = [x.to_object for x in dx_folder2.relatedItems]\n-        self.assertEqual(dx_folder2_related, [dx_doc1])\n-\n-        # assert multi references, order is restored\n-        dx_doc2_related = [x.to_object for x in dx_doc2.relatedItems]\n-        self.assertEqual(dx_doc2_related, [at_newsitem, dx_doc3, dx_doc1])\n-\n-    def test_backrelations_are_migrated_for_unnested_content(self):\n-        """relate a doc to a newsitem, migrate the newsitem but not the doc.\n-        check if the relations are still in place."""\n-\n-        # create ATFolder and ATDocument\n-        self.portal.invokeFactory(\'News Item\', \'news\')\n-        at_news = self.portal[\'news\']\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n-        at_doc = self.portal[\'doc\']\n-\n-        # relate them\n-        at_news.setRelatedItems([at_doc])\n-\n-        self.assertEqual(at_news.getRelatedItems(), [at_doc])\n-        self.assertEqual(at_news.getReferences(), [at_doc])\n-        self.assertEqual(at_news.getBackReferences(), [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [at_news])\n-\n-        # migrate content (stores references on new objects for later restore)\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            # blacklisted_steps=[\'typeinfo\']\n-        )\n-        # installTypeIfNeeded(\'News Item\')\n-        store_references(self.portal)\n-        migrate_newsitems(self.portal)\n-        migrate_documents(self.portal)\n-\n-        # rebuild catalog\n-        self.portal.portal_catalog.clearFindAndRebuild()\n-\n-        dx_news = self.portal[\'news\']\n-        dx_doc = self.portal[\'doc\']\n-\n-        # references are not restored yet\n-        self.assertEqual(dx_news.relatedItems, [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [])\n-\n-        # restore references\n-        restore_references(self.portal)\n-\n-        # references should be restored\n-        self.assertEqual([i.to_object for i in dx_news.relatedItems], [dx_doc])\n-        self.assertEqual([i.to_object for i in dx_doc.relatedItems], [])\n-        self.assertEqual(self._backrefs(dx_doc), [dx_news])\n-        self.assertEqual(self._backrefs(dx_news), [])\n-\n-    def test_dx_at_relations_migrated_for_partially_migrated_nested(self):\n-        """This fails if referenceablebehavior is not enabled\n-        """\n-        # create ATFolder and ATDocument\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        at_folder.invokeFactory(\'Document\', \'doc\')\n-        at_doc = at_folder[\'doc\']\n-\n-        # relate them\n-        at_folder.setRelatedItems([at_doc])\n-\n-        self.assertEqual(at_folder.getRelatedItems(), [at_doc])\n-        self.assertEqual(at_folder.getReferences(), [at_doc])\n-        self.assertEqual(at_folder.getBackReferences(), [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [at_folder])\n-\n-        # migrate content (stores references on new objects for later restore)\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'])\n-        installTypeIfNeeded(\'Folder\')\n-        self._enable_referenceable_for(\'Folder\')\n-\n-        store_references(self.portal)\n-        migrate_folders(self.portal)\n-\n-        # rebuild catalog\n-        self.portal.portal_catalog.clearFindAndRebuild()\n-\n-        dx_folder = self.portal[\'folder\']\n-        at_doc = dx_folder[\'doc\']\n-        # references are not restored yet\n-        self.assertEqual(dx_folder.relatedItems, [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [])\n-\n-        # restore references\n-        restore_references(self.portal)\n-\n-        # references should be restored\n-        self.assertEqual(\n-            [i.to_object for i in dx_folder.relatedItems], [at_doc])\n-        self.assertEqual(self._backrefs(at_doc), [dx_folder])\n-        self.assertEqual(self._backrefs(dx_folder), [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [])\n-\n-    def test_at_dx_relations_migrated_for_partialy_migrated_nested(self):\n-        """Fails if referenceablebehavior is not enabled"""\n-        # create ATFolder and ATDocument\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        at_folder.invokeFactory(\'Document\', \'doc\')\n-        at_doc = at_folder[\'doc\']\n-\n-        # relate them\n-        at_folder.setRelatedItems([at_doc])\n-\n-        self.assertEqual(at_folder.getRelatedItems(), [at_doc])\n-        self.assertEqual(at_folder.getReferences(), [at_doc])\n-        self.assertEqual(at_folder.getBackReferences(), [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [at_folder])\n-\n-        # migrate content (stores references on new objects for later restore)\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'])\n-        installTypeIfNeeded(\'Document\')\n-        store_references(self.portal)\n-        migrate_documents(self.portal)\n-        self._enable_referenceable_for(\'Document\')\n-\n-        # rebuild catalog\n-        self.portal.portal_catalog.clearFindAndRebuild()\n-\n-        at_folder = self.portal[\'folder\']\n-        dx_doc = at_folder[\'doc\']\n-        self.assertTrue(is_referenceable(dx_doc))\n-        self.assertTrue(is_referenceable(at_folder))\n-\n-        # references are not restored yet\n-        # the at-folder has a broken reference now\n-        # since at_doc is now <ATDocument at /plone/folder/doc_MIGRATION_>\n-        self.assertNotEqual(at_folder.getRelatedItems(), [at_doc])\n-        self.assertEqual(dx_doc.relatedItems, [])\n-        # the backref is found since the reference_catalog is not purged\n-        self.assertEqual(self._backrefs(dx_doc), [at_folder])\n-\n-        # restore references\n-        restore_references(self.portal)\n-\n-        # references should be restored\n-        self.assertEqual(at_folder.getRelatedItems(), [dx_doc])\n-        self.assertEqual(self._backrefs(dx_doc), [at_folder])\n-        self.assertEqual(dx_doc.relatedItems, [])\n-\n-    def _backrefs(self, obj):\n-        from Products.Archetypes.interfaces.referenceable import IReferenceable\n-        results = []\n-        relation_catalog = queryUtility(ICatalog)\n-        reference_catalog = getToolByName(obj, \'reference_catalog\')\n-        int_id = dump(obj, relation_catalog, {})\n-        if int_id:\n-            brels = relation_catalog.findRelations(dict(to_id=int_id))\n-            for brel in brels:\n-                if brel.isBroken():\n-                    results.append(\'broken\')\n-                else:\n-                    results.append(brel.from_object)\n-        if not results:\n-            if is_referenceable(obj):\n-                obj = IReferenceable(obj)\n-                for rel in reference_catalog.getBackReferences(obj):\n-                    results.append(uuidToObject(rel.sourceUID))\n-        return results\n-\n-    def _enable_referenceable_for(self, typename):\n-        behavior = \'plone.app.referenceablebehavior.referenceable.IReferenceable\'  # noqa\n-        fti = queryUtility(IDexterityFTI, name=typename)\n-        behaviors = list(fti.behaviors)\n-        behaviors.append(behavior)\n-        fti._updateProperty(\'behaviors\', tuple(behaviors))\n-\n-    def test_store_references(self):\n-        intids = getUtility(IIntIds)\n-\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'])\n-        installTypeIfNeeded(\'News Item\')\n-\n-        # create ATFolder and ATDocument\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n-        at_doc = self.portal[\'doc\']\n-        # relate them\n-        at_folder.setRelatedItems([at_doc])\n-\n-        # create DX News Items\n-        self.portal.invokeFactory(\'News Item\', \'news1\')\n-        dx_news1 = self.portal[\'news1\']\n-        self.portal.invokeFactory(\'News Item\', \'news2\')\n-        dx_news2 = self.portal[\'news2\']\n-        dx_news1.relatedItems = PersistentList()\n-        dx_news1.relatedItems.append(RelationValue(intids.getId(dx_news2)))\n-        modified(dx_news1)\n-        relation_catalog = queryUtility(ICatalog)\n-        all_rels = [i for i in relation_catalog.findRelations()]\n-        self.assertEqual(len(all_rels), 1)\n-\n-        self.assertEqual(at_folder.getRelatedItems(), [at_doc])\n-        self.assertEqual(at_folder.getReferences(), [at_doc])\n-        self.assertEqual(at_folder.getBackReferences(), [])\n-        self.assertEqual(at_doc.getReferences(), [])\n-        self.assertEqual(at_doc.getBackReferences(), [at_folder])\n-        self.assertEqual(\n-            [i.to_object for i in dx_news1.relatedItems], [dx_news2])\n-\n-        store_references(self.portal)\n-        key = \'ALL_REFERENCES\'\n-        self.assertEqual(len(IAnnotations(self.portal)[key]), 2)\n-\n-    def test_export_references(self):\n-        """Test the Browser-View @@export_all_references."""\n-        intids = getUtility(IIntIds)\n-        set_browserlayer(self.request)\n-\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'])\n-        installTypeIfNeeded(\'News Item\')\n-\n-        # create ATFolder and ATDocument\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n-        at_doc = self.portal[\'doc\']\n-        # relate them\n-        at_folder.setRelatedItems([at_doc])\n-\n-        # create DX News Items\n-        self.portal.invokeFactory(\'News Item\', \'news1\')\n-        dx_news1 = self.portal[\'news1\']\n-        self.portal.invokeFactory(\'News Item\', \'news2\')\n-        dx_news2 = self.portal[\'news2\']\n-\n-        # relate them\n-        dx_news1.relatedItems = PersistentList()\n-        dx_news1.relatedItems.append(RelationValue(intids.getId(dx_news2)))\n-        modified(dx_news1)\n-\n-        view = self.portal.restrictedTraverse(\'export_all_references\')\n-        result = view()\n-        data = json.loads(result)\n-        self.assertEqual(len(data), 2)\n-\n-    def test_migrate_references_with_storage_on_portal(self):\n-        set_browserlayer(self.request)\n-        intids = getUtility(IIntIds)\n-\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'])\n-        installTypeIfNeeded(\'News Item\')\n-        self._enable_referenceable_for(\'News Item\')\n-\n-        # create ATFolder and ATDocument\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n-        at_doc = self.portal[\'doc\']\n-\n-        # create DX News Items\n-        self.portal.invokeFactory(\'News Item\', \'news1\')\n-        dx_news1 = self.portal[\'news1\']\n-        self.portal.invokeFactory(\'News Item\', \'news2\')\n-        dx_news2 = self.portal[\'news2\']\n-\n-        # relate them\n-        at_folder.setRelatedItems([at_doc])\n-        dx_news1.relatedItems = PersistentList()\n-        dx_news1.relatedItems.append(RelationValue(intids.getId(dx_news2)))\n-        dx_news1.relatedItems.append(RelationValue(intids.getId(at_doc)))\n-        at_doc.setRelatedItems([dx_news2])\n-        modified(dx_news1)\n-        relation_catalog = queryUtility(ICatalog)\n-        all_rels = [i for i in relation_catalog.findRelations()]\n-        self.assertEqual(len(all_rels), 2)\n-\n-        store_references(self.portal)\n-        # migration_view = getMultiAdapter(\n-        #     (self.portal, self.request),\n-        #     name=u\'migrate_from_atct\'\n-        # )\n-        # migration_view(from_form=True, migrate_references=False)\n-\n-        # this is basically be the same as above\n-        installTypeIfNeeded(\'Document\')\n-        installTypeIfNeeded(\'Folder\')\n-        migrate_folders(self.portal)\n-        migrate_documents(self.portal)\n-        self.portal.portal_catalog.clearFindAndRebuild()\n-        restore_references(self.portal)\n-\n-        dx_folder = self.portal[\'folder\']\n-        dx_doc = self.portal[\'doc\']\n-        self.assertEqual(\n-            [i.to_object for i in dx_folder.relatedItems], [dx_doc])\n-        self.assertEqual(\n-            [i.to_object for i in dx_doc.relatedItems], [dx_news2])\n-        self.assertEqual(\n-            [i.to_object for i in dx_news1.relatedItems], [dx_news2, dx_doc])\n-\n-    def test_stats(self):\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        from plone.app.contenttypes.migration.browser import \\\n-            MigrateFromATContentTypes as MigrationView\n-\n-        self.portal.invokeFactory(\'Document\', \'doc1\')\n-        at_doc1 = self.portal[\'doc1\']\n-        self.portal.invokeFactory(\'Document\', \'doc2\')\n-        at_doc2 = self.portal[\'doc2\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrationview = MigrationView(self.portal, None)\n-        stats = migrationview.stats()\n-        self.assertEqual(str(stats), "{\'Document (ATDocument)\': 2}")\n-        migrator = self.get_migrator(at_doc1, DocumentMigrator)\n-        migrator.migrate()\n-        stats = migrationview.stats()\n-        self.assertEqual(str(stats), "{\'Document (ATDocument)\': 1, \'Document (Dexterity Item)\': 1}")  # noqa: E501\n-        migrator = self.get_migrator(at_doc2, DocumentMigrator)\n-        migrator.migrate()\n-        stats = migrationview.stats()\n-        self.assertEqual(str(stats), "{\'Document (Dexterity Item)\': 2}")\n-\n-    def test_migration_atctypes_vocabulary_registered(self):\n-        name = \'plone.app.contenttypes.migration.atctypes\'\n-        factory = getUtility(IVocabularyFactory, name)\n-        self.assertIsNotNone(\n-            factory,\n-            \'Vocabulary {0} does not exist\'.format(name),\n-        )\n-\n-        vocabulary = factory(self.portal)\n-        self.assertEqual((), tuple(vocabulary))\n-\n-    def test_migration_atctypes_vocabulary_result(self):\n-        from Products.ATContentTypes.content.document import ATDocument\n-        from Products.ATContentTypes.content.file import ATFile\n-        from Products.ATContentTypes.content.image import ATImage\n-        from Products.ATContentTypes.content.folder import ATFolder\n-        from Products.ATContentTypes.content.link import ATLink\n-\n-        name = \'plone.app.contenttypes.migration.atctypes\'\n-        factory = getUtility(IVocabularyFactory, name)\n-\n-        self.createATCTobject(ATDocument, \'doc1\')\n-        self.createATCTobject(ATDocument, \'doc2\')\n-        self.createATCTobject(ATFile, \'file\')\n-        self.createATCTobject(ATImage, \'image\')\n-        self.createATCTobject(ATFolder, \'folder\')\n-        self.createATCTobject(ATLink, \'link\')\n-\n-        vocabulary = factory(self.portal)\n-\n-        self.assertEqual(\n-            5,\n-            len(vocabulary),\n-            \'Expect 5 entries in vocab because there are 5 diffrent types\')\n-\n-        # Result format\n-        docs = [term for term in vocabulary if term.token == \'Document\'][0]\n-        self.assertEqual(\'Document\', docs.value)\n-        self.assertEqual(\'Document (2)\', docs.title)\n-\n-    def test_migration_extendedtypes_vocabulary_registered(self):\n-        name = \'plone.app.contenttypes.migration.extendedtypes\'\n-        factory = getUtility(IVocabularyFactory, name)\n-        self.assertIsNotNone(\n-            factory,\n-            \'Vocabulary {0} does not exist\'.format(name),\n-        )\n-\n-        vocabulary = factory(self.portal)\n-        self.assertEqual((), tuple(vocabulary))\n-\n-    @unittest.skip(\'Creates test-isolation-issues. See https://github.com/plone/plone.app.contenttypes/issues/251\')  # noqa\n-    def test_migration_extendedtypes_vocabulary_result(self):\n-        from archetypes.schemaextender.extender import CACHE_ENABLED\n-        from archetypes.schemaextender.extender import CACHE_KEY\n-        from archetypes.schemaextender.field import ExtensionField\n-        from archetypes.schemaextender.interfaces import ISchemaExtender\n-        from Products.Archetypes import atapi\n-        from Products.ATContentTypes.content.document import ATDocument\n-        from zope.component import adapter\n-        from zope.component import provideAdapter\n-        from zope.interface import classImplements\n-        from zope.interface import implementer\n-        from zope.interface import Interface\n-\n-        name = \'plone.app.contenttypes.migration.extendedtypes\'\n-        factory = getUtility(IVocabularyFactory, name)\n-\n-        class IDummy(Interface):\n-            """Taggable content\n-            """\n-\n-        classImplements(ATDocument, IDummy)\n-        doc = self.createATCTobject(ATDocument, \'doc\')\n-\n-        class DummyField(ExtensionField, atapi.StringField):\n-            """Dummy Field"""\n-\n-        @implementer(ISchemaExtender)\n-        @adapter(IDummy)\n-        class DummySchemaExtender(object):\n-\n-            _fields = [DummyField(\'dummy\')]\n-\n-            def __init__(self, context):\n-                self.context = context\n-\n-            def getFields(self):\n-                return self._fields\n-\n-        provideAdapter(DummySchemaExtender, name=u\'dummy.extender\')\n-\n-        # Clear cache\n-        if CACHE_ENABLED:\n-            delattr(self.request, CACHE_KEY)\n-        self.assertIn(\'dummy\', doc.Schema()._names)\n-\n-        vocabulary = factory(self.portal)\n-\n-        self.assertEqual(1, len(vocabulary), \'Expect one entry\')\n-\n-        self.assertEqual("Document (1) - extended fields: \'dummy\'",\n-                         tuple(vocabulary)[0].title)\n-\n-    def test_migrate_function(self):\n-        from plone.app.contenttypes.migration.migration import migrate\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate(self.portal, DocumentMigrator)\n-        dx_document = self.portal[\'document\']\n-        self.assertTrue(IDexterityContent.providedBy(dx_document))\n-\n-    def test_migrate_xx_functions(self):\n-        from Products.ATContentTypes.content.image import ATImage\n-        from Products.ATContentTypes.content.file import ATFile\n-        from plone.app.contenttypes.migration.migration import (\n-            migrate_documents,\n-            migrate_collections,\n-            migrate_images,\n-            migrate_blobimages,\n-            migrate_files,\n-            migrate_blobfiles,\n-            migrate_links,\n-            migrate_newsitems,\n-            migrate_blobnewsitems,\n-            migrate_folders,\n-            migrate_events,\n-        )\n-        from plone.app.contenttypes.migration.topics import migrate_topics\n-\n-        # create all content types\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        self.portal.invokeFactory(\'Image\', \'image\')\n-        self.createATCTobject(ATImage, \'blobimage\')\n-        self.portal.invokeFactory(\'File\', \'blobfile\')\n-        self.createATCTobject(ATFile, \'file\')\n-        self.portal.invokeFactory(\'Collection\', \'collection\')\n-        self.portal.invokeFactory(\'Link\', \'link\')\n-        self.portal.invokeFactory(\'News Item\', \'newsitem\')\n-        self.createATCTBlobNewsItem(\'blobnewsitem\')\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        self.portal.invokeFactory(\'Event\', \'event\')\n-        self.portal.invokeFactory(\'Topic\', \'topic\')\n-\n-        # migrate all\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrate_documents(self.portal)\n-        migrate_collections(self.portal)\n-        migrate_images(self.portal)\n-        migrate_blobimages(self.portal)\n-        migrate_files(self.portal)\n-        migrate_blobfiles(self.portal)\n-        migrate_links(self.portal)\n-        migrate_newsitems(self.portal)\n-        migrate_blobnewsitems(self.portal)\n-        migrate_folders(self.portal)\n-        migrate_events(self.portal)\n-        migrate_topics(self.portal)\n-\n-        # assertions\n-        cat = self.catalog\n-        at_contents = cat(object_provides=\'Products.ATContentTypes\'\n-                          \'.interfaces.IATContentType\')\n-        dx_contents = cat(object_provides=\'plone.dexterity\'\n-                          \'.interfaces.IDexterityContent\')\n-        self.assertEqual(len(at_contents), 0)\n-        self.assertEqual(len(dx_contents), 12)\n-\n-    def test_warning_for_uneditable_content(self):\n-        set_browserlayer(self.request)\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        from plone.app.contenttypes.interfaces import IDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        self.portal.invokeFactory(\'News Item\', \'newsitem\')\n-        at_document = self.portal[\'document\']\n-        at_newsitem = self.portal[\'newsitem\']\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        # At this point plone.app.z3cform is installed including it\'s browser\n-        # layer. But we have to annotate the request to provide it, since the\n-        # request was constructed before. Otherwise, @@view cannot be render\n-        # it\'s IRichText widget.\n-        alsoProvides(self.request, IPloneFormLayer)\n-        at_document_view = at_document.restrictedTraverse(\'document_view\')\n-        self.assertTrue(\n-            \'http://nohost/plone/@@atct_migrator\' in at_document_view()\n-        )\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-        dx_document = self.portal[\'document\']\n-        self.assertTrue(IDocument.providedBy(dx_document))\n-        dx_document_view = dx_document.restrictedTraverse(\'@@view\')\n-        self.assertFalse(\'alert-box\' in dx_document_view())\n-        at_newsitem_view = at_newsitem.restrictedTraverse(\'newsitem_view\')\n-        self.assertTrue(\'alert-box\' in at_newsitem_view())\n-        self.assertTrue(\n-            \'http://nohost/plone/@@atct_migrator\' in at_newsitem_view()\n-        )\n-\n-    def test_aaa_migration_results_page(self):\n-        """We create dx-types with the same portal_type as other contenttypes\n-        before migration to make sure the stats are correct.\n-        """\n-        set_browserlayer(self.request)\n-        from plone.app.contenttypes.interfaces import IDocument\n-        from plone.app.contenttypes.interfaces import ICollection\n-\n-        # create folders\n-        self.portal.invokeFactory(\'Folder\', \'folder1\')\n-        at_folder1 = self.portal[\'folder1\']\n-        self.portal.invokeFactory(\'Folder\', \'folder2\')\n-        at_folder2 = self.portal[\'folder2\']\n-\n-        # create ATDocuments\n-        at_folder1.invokeFactory(\'Document\', \'doc1\')\n-        at_doc1 = at_folder1[\'doc1\']\n-        at_folder2.invokeFactory(\'Document\', \'doc2\')\n-        at_doc2 = at_folder2[\'doc2\']\n-\n-        # create AT-based collections\n-        self.portal.invokeFactory(\'Collection\', \'col1\')\n-        at_col1 = self.portal[\'col1\']\n-\n-        # migrate content\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-\n-        # create dx-content that will not be migrated\n-        at_folder1.invokeFactory(\'Document\', \'dx_doc\')\n-        dx_doc = at_folder1[\'dx_doc\']\n-        self.assertTrue(IDocument.providedBy(dx_doc))\n-\n-        # create dexterity-based collections\n-        self.portal.invokeFactory(\'Collection\', \'dx_col\')\n-        dx_col = self.portal[\'dx_col\']\n-        self.assertTrue(ICollection.providedBy(dx_col))\n-\n-        migration_view = getMultiAdapter(\n-            (self.portal, self.request),\n-            name=u\'migrate_from_atct\'\n-        )\n-\n-        results = migration_view(\n-            from_form=True,\n-        )\n-\n-        dx_folder1 = self.portal[\'folder1\']\n-        dx_folder2 = self.portal[\'folder2\']\n-        dx_doc1 = dx_folder1[\'doc1\']\n-        dx_doc2 = dx_folder2[\'doc2\']\n-        dx_col1 = self.portal[\'col1\']\n-\n-        self.assertTrue(at_folder1 is not dx_folder1)\n-        self.assertTrue(at_folder2 is not dx_folder2)\n-        self.assertTrue(at_doc1 is not dx_doc1)\n-        self.assertTrue(at_doc2 is not dx_doc2)\n-        self.assertTrue(at_col1 is not dx_col1)\n-\n-        # test the stats\n-        stats = results[\'migrated_types\']\n-        self.assertEqual(stats[\'Document\'][\'amount_migrated\'], 2)\n-        self.assertEqual(stats[\'Folder\'][\'amount_migrated\'], 2)\n-        self.assertEqual(stats[\'Collection\'][\'amount_migrated\'], 1)\n-\n-    def test_migration_view_confirmation(self):\n-        set_browserlayer(self.request)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migration_view = getMultiAdapter(\n-            (self.portal, self.request),\n-            name=u\'migrate_from_atct\'\n-        )\n-        results = migration_view()\n-        self.assertIn(\'@@migrate_from_atct?migrate=1\', results)\n-\n-    def test_portlets_are_migrated(self):\n-        """add portlets and see if they\'re still available on the migrated\n-        content including portlet settings.\n-        """\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-        from plone.app.contenttypes.migration.migration import FolderMigrator\n-        from plone.portlet.static.static import Assignment as StaticAssignment\n-        from plone.portlets.constants import GROUP_CATEGORY\n-        from plone.portlets.interfaces import ILocalPortletAssignmentManager\n-        from plone.portlets.interfaces import IPortletAssignmentMapping\n-        from plone.portlets.interfaces import IPortletAssignmentSettings\n-        from plone.portlets.interfaces import IPortletManager\n-\n-        def get_portlets(context, columnName):\n-            column = getUtility(IPortletManager, columnName)\n-            mapping = getMultiAdapter((context, column),\n-                                      IPortletAssignmentMapping)\n-            return mapping\n-\n-        # create an ATDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        at_document.setText(u\'T\xc3\xbctensuppe with some portlet\')\n-        at_document.setContentType(\'chemical/x-gaussian-checkpoint\')\n-\n-        # add a portlet\n-        portlet = StaticAssignment(u\'Sample Portlet\',\n-                                   \'<p>Yay! I get migrated!</p>\')\n-        add_portlet(at_document, portlet, \'static-portlet\',\n-                    u\'plone.leftcolumn\')\n-\n-        # disable group portlets for right columns\n-        right_column = getUtility(IPortletManager, u\'plone.rightcolumn\')\n-        localsettings = getMultiAdapter((at_document, right_column),\n-                                        ILocalPortletAssignmentManager)\n-        localsettings.setBlacklistStatus(GROUP_CATEGORY, True)\n-\n-        # hide our portlet\n-        settings = IPortletAssignmentSettings(portlet)\n-        settings[\'visible\'] = False\n-\n-        # add another portlet type that is not available when doing the\n-        # migration and make sure it got ignored in the migration\n-        broken = StaticAssignment(u\'Fake broken portlet\',\n-                                  \'<p>Ouch! I am broken</p>\')\n-        # ZODB.broken will add an ___Broken_state__ attribute if a portlet\'s\n-        # module is no longer available\n-        broken.__Broken_state__ = True\n-        add_portlet(at_document, broken, \'broken-portlet\', u\'plone.leftcolumn\')\n-\n-        # add a folder\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-\n-        # add a portlet to the folder\n-        portlet2 = StaticAssignment(u\'Sample Folder Portlet\',\n-                                    \'<p>Do I get migrated?</p>\')\n-        add_portlet(at_folder, portlet2, \'static-portlet\',\n-                    u\'plone.rightcolumn\')\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-        folder_migrator = self.get_migrator(at_folder, FolderMigrator)\n-        folder_migrator.migrate()\n-\n-        # assertions\n-        dx_document = self.portal[\'document\']\n-\n-        # portlet is available\n-        self.assertIn(\n-            \'static-portlet\',\n-            get_portlets(dx_document, u\'plone.leftcolumn\')\n-        )\n-        # broken portlets don\'t get copied\n-        self.assertNotIn(\n-            \'broken-portlet\',\n-            get_portlets(dx_document, u\'plone.leftcolumn\')\n-        )\n-\n-        # block portlets settings copied\n-        right_column = getUtility(IPortletManager, u\'plone.rightcolumn\')\n-        localsettings = getMultiAdapter((dx_document, right_column),\n-                                        ILocalPortletAssignmentManager)\n-        self.assertTrue(localsettings.getBlacklistStatus(GROUP_CATEGORY))\n-\n-        # hide portlets settings survived\n-        assignment = get_portlets(dx_document,\n-                                  u\'plone.leftcolumn\')[\'static-portlet\']\n-        settings = IPortletAssignmentSettings(assignment)\n-        self.assertFalse(settings[\'visible\'])\n-\n-        dx_folder = self.portal[\'folder\']\n-        self.assertIn(\n-            \'static-portlet\',\n-            get_portlets(dx_folder, u\'plone.rightcolumn\')\n-        )\n-\n-    def test_comments_are_migrated(self):\n-        """add some comments and check that it is correctly migrated.\n-\n-        XXX fixme : original comment id is not kept, comments are created\n-        with new ids...\n-        """\n-        from zope.component import createObject\n-        from plone.app.discussion.interfaces import IConversation\n-        from plone.app.contenttypes.migration.migration import DocumentMigrator\n-\n-        # create an ATDocument\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        at_document.setText(u\'Document with some comments\')\n-\n-        # add some comments to the document\n-        at_conversation = IConversation(at_document)\n-        new_comment = createObject(\'plone.Comment\')\n-        new_comment.text = u\'Hey Dude! \xc3\x84 is not ascii.\'\n-        at_conversation.addComment(new_comment)\n-        at_comments = at_conversation.getComments()\n-        at_comment = [i for i in at_comments][0]\n-        at_plone_uuid = getattr(at_comment, \'_plone.uuid\')\n-        at_comment_id = getattr(at_comment, \'comment_id\')\n-        self.assertEqual(at_conversation.__parent__, at_document)\n-\n-        # migrate\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        migrator = self.get_migrator(at_document, DocumentMigrator)\n-        migrator.migrate()\n-\n-        dx_document = self.portal[\'document\']\n-\n-        # no more comments on the portal\n-        portal_conversation = IConversation(self.portal)\n-        self.assertFalse(portal_conversation)\n-        # comments were migrated\n-        dx_conversation = IConversation(dx_document)\n-        self.assertEqual(dx_conversation.__parent__, dx_document)\n-        self.assertEqual(\n-            len(dx_conversation),\n-            1\n-        )\n-        dx_comments = dx_conversation.getComments()\n-        dx_comment = [i for i in dx_comments][0]\n-        dx_comment_id = getattr(dx_comment, \'comment_id\')\n-        self.assertEqual(dx_comment_id, at_comment_id)\n-        dx_plone_uuid = getattr(dx_comment, \'_plone.uuid\')\n-        self.assertEqual(dx_plone_uuid, at_plone_uuid)\n-        self.assertEqual(\n-            dx_comment.getText(),\n-            \'<p>Hey Dude! \\xc3\\x84 is not ascii.</p>\')\n-\n-    def test_default_pages_are_kept_during_migration(self):\n-        """Check that the default pages are not lost when migrating."""\n-        set_browserlayer(self.request)\n-        # create some content and set default pages\n-        self.portal.invokeFactory(\'Document\', \'document\')\n-        at_document = self.portal[\'document\']\n-        at_document.setText(u\'Document with some comments\')\n-\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        at_folder = self.portal[\'folder\']\n-\n-        at_folder.invokeFactory(\'Document\', \'subdocument\')\n-\n-        self.portal.setLayout(\'folder_summary_view\')\n-        self.portal.setDefaultPage(\'document\')\n-\n-        at_folder.setLayout(\'folder_tabular_view\')\n-        at_folder.setDefaultPage(\'subdocument\')\n-\n-        self.portal.invokeFactory(\'Folder\', \'folder2\')\n-        at_folder2 = self.portal[\'folder2\']\n-        at_folder2.invokeFactory(\'Document\', \'subdocument2\')\n-        at_folder2.setLayout(\'folder_listing\')\n-\n-        # migrate content\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-\n-        migration_view = getMultiAdapter(\n-            (self.portal, self.request),\n-            name=u\'migrate_from_atct\'\n-        )\n-        migration_view(from_form=True)\n-        dx_folder = self.portal[\'folder\']\n-        dx_folder2 = self.portal[\'folder2\']\n-\n-        # test that view-methods are updated\n-        self.assertTrue(self.portal.getLayout(), \'summary_view\')\n-        self.assertTrue(dx_folder.getLayout(), \'tabular_view\')\n-        self.assertTrue(dx_folder2.getLayout(), \'listing_view\')\n-        # test that defaultpage is kept\n-        self.assertTrue(self.portal.getDefaultPage(), \'document\')\n-        self.assertTrue(dx_folder.getDefaultPage(), \'subdocument\')\n-        self.assertIsNone(dx_folder2.getDefaultPage())\n-\n-\n-class MigrateDexterityBaseClassIntegrationTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        self.portal = self.layer[\'portal\']\n-\n-        applyProfile(self.portal, \'plone.app.dexterity:testing\')\n-\n-        self.portal.acl_users.userFolderAddUser(SITE_OWNER_NAME,\n-                                                SITE_OWNER_PASSWORD,\n-                                                [\'Manager\'],\n-                                                [])\n-        login(self.portal, SITE_OWNER_NAME)\n-\n-        # Add default content\n-        self.portal.invokeFactory(\'Document\', \'item\')\n-\n-        # Change Document conent type to folderish\n-        portal_types = getToolByName(self.portal, \'portal_types\')\n-        portal_types[\'Document\'].klass = \'plone.dexterity.content.Container\'\n-        portal_types[\'Document\'].allowed_content_types = (\'Document\',)\n-\n-    def test_dxmigration_migrate_item_to_container_class_is_changed(self):\n-        """Check that base class was changed."""\n-        from plone.app.contenttypes.migration.dxmigration import \\\n-            migrate_base_class_to_new_class\n-        migrate_base_class_to_new_class(self.portal.item)\n-        self.assertTrue(isinstance(self.portal.item, Container))\n-\n-    def test_dxmigration_migrate_item_to_container_add_object_inside(self):\n-        """Check that after migrate base class it can add items inside object.\n-        """\n-        from plone.app.contenttypes.migration.dxmigration import \\\n-            migrate_base_class_to_new_class\n-        migrate_base_class_to_new_class(self.portal.item)\n-        self.portal.item.invokeFactory(\'Document\', \'doc\')\n-        self.assertEqual(\n-            len(self.portal.item.folderlistingFolderContents()), 1)\n-\n-    def test_dxmigration_migrate_list_of_objects_with_changed_base_class(self):\n-        """Check list of objects with changed classes."""\n-        from plone.app.contenttypes.migration.dxmigration import \\\n-            list_of_objects_with_changed_base_class\n-        # We have already one changed object\n-        objects = [i for i in\n-                   list_of_objects_with_changed_base_class(self.portal)]\n-        self.assertEqual(len(objects), 1)\n-\n-    def test_dxmigration_migrate_list_of_changed_base_class_names(self):\n-        """Check list of changed base class names."""\n-        from plone.app.contenttypes.migration.dxmigration import \\\n-            list_of_changed_base_class_names\n-        # We have already one changed object\n-        names = [i for i in list_of_changed_base_class_names(self.portal)]\n-        self.assertEqual(len(names), 1)\n-\n-    def test_dxmigration_migrate_vocabulary_changed_base_classes(self):\n-        """Check vocabulary of changed base class names."""\n-        # We have already one changed object\n-        name = \'plone.app.contenttypes.migration.changed_base_classes\'\n-        factory = getUtility(IVocabularyFactory, name)\n-        vocabulary = factory(self.portal)\n-        self.assertEqual(len(vocabulary), 1)\n-\n-\n-class MigrateDexterityBaseClassFunctionalTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        app = self.layer[\'app\']\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.portal_url = self.portal.absolute_url()\n-        self.manage_document_url = \'{0}/{1}/{2}/{3}\'.format(\n-            self.portal_url,\n-            \'portal_types\',\n-            \'Document\',\n-            \'manage_propertiesForm\',\n-        )\n-\n-        self.browser = Browser(app)\n-        self.browser.handleErrors = False\n-        self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic {0}:{1}\'.format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD,)\n-        )\n-\n-        # Add default content\n-        self.browser.open(self.portal_url)\n-        self.browser.getLink(\'Page\').click()\n-        widget = \'form.widgets.IDublinCore.title\'\n-        self.browser.getControl(name=widget).value = \'My item\'\n-        widget = \'form.widgets.IShortName.id\'\n-        self.browser.getControl(name=widget).value = \'item\'\n-        self.browser.getControl(\'Save\').click()\n-\n-        # Change Document conent type to folderish\n-        self.browser.open(self.manage_document_url)\n-        try:\n-            klass_ctlr = self.browser.getControl(name=\'klass:UTF-8:string\')\n-        except LookupError:\n-            klass_ctlr = self.browser.getControl(name=\'klass:string\')\n-        klass_ctlr.value = \'plone.app.contenttypes.content.Collection\'\n-        self.browser.getControl(\'Save Changes\').click()\n-        self.browser.open(\n-            \'{0}/@@base_class_migrator_form\'.format(self.portal_url))\n-        self.good_info_message_template = \'There are {0} objects migrated.\'\n-\n-    def test_dxmigration_migrate_check_migration_form_view(self):\n-        """Check base class migrator view of changed base class names."""\n-        html = etree.HTML(self.browser.contents)\n-        checkboxes = html.xpath(\'//form//*[@name="{0}"]\'.format(\n-            \'form.widgets.changed_base_classes:list\'))\n-        self.assertEqual(len(checkboxes), 1)\n-\n-    def test_dxmigration_migrate_check_migration_successful_message(self):\n-        """Check base class migrator view of changed base class names."""\n-        self.browser.getControl(\n-            name=\'form.widgets.changed_base_classes:list\').value = [\n-                \'plone.app.contenttypes.content.Document\']\n-        self.browser.getControl(\'Update\').click()\n-        self.assertIn(\n-            self.good_info_message_template.format(1), self.browser.contents)\n-\n-\n-class MigrationFunctionalTests(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_FUNCTIONAL_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        app = self.layer[\'app\']\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n-        self.request[\'URL\'] = self.portal.absolute_url()\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n-        self.portal.acl_users.userFolderAddUser(SITE_OWNER_NAME,\n-                                                SITE_OWNER_PASSWORD,\n-                                                [\'Manager\'],\n-                                                [])\n-        login(self.portal, SITE_OWNER_NAME)\n-        self.portal.portal_workflow.setDefaultChain(\n-            \'simple_publication_workflow\'\n-        )\n-        self.portal_url = self.portal.absolute_url()\n-\n-        self.browser = Browser(app)\n-        self.browser.handleErrors = False\n-        self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic {0}:{1}\'.format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD,)\n-        )\n-\n-    def tearDown(self):\n-        try:\n-            applyProfile(self.portal, \'plone.app.contenttypes:uninstall\')\n-        except KeyError:\n-            pass\n-\n-    def test_pac_installer_cancel(self):\n-        qi = get_installer(self.portal)\n-        portal_types = self.portal.portal_types\n-        self.browser.open(\'{0}/@@pac_installer\'.format(self.portal_url))\n-        self.assertFalse(qi.is_product_installed(\'plone.app.contenttypes\'))\n-        self.browser.getControl(\'Cancel\').click()\n-        self.assertFalse(IDexterityFTI.providedBy(portal_types[\'Document\']))\n-        self.assertFalse(qi.is_product_installed(\'plone.app.contenttypes\'))\n-        self.assertEqual(self.browser.url, self.portal_url)\n-\n-    def test_pac_installer_without_content(self):\n-        qi = get_installer(self.portal)\n-        portal_types = self.portal.portal_types\n-        self.browser.open(\'{0}/@@pac_installer\'.format(self.portal_url))\n-        self.assertFalse(qi.is_product_installed(\'plone.app.contenttypes\'))\n-        self.assertFalse(IDexterityFTI.providedBy(portal_types[\'Document\']))\n-        self.assertIn(\'proceed to the migration-form?\', self.browser.contents)\n-        self.browser.getControl(\'Install\').click()\n-        self.assertTrue(IDexterityFTI.providedBy(portal_types[\'Document\']))\n-        self.assertTrue(IDexterityFTI.providedBy(portal_types[\'News Item\']))\n-        self.assertTrue(qi.is_product_installed(\'plone.app.contenttypes\'))\n-        self.assertIn(\'Migration control panel\', self.browser.contents)\n-        self.assertIn(\'No content to migrate.\', self.browser.contents)\n-\n-    def test_pac_installer_with_content(self):\n-        # add some at content:\n-        self.portal.invokeFactory(\'Document\', \'doc1\')\n-        transaction.commit()\n-        qi = get_installer(self.portal)\n-        portal_types = self.portal.portal_types\n-        self.browser.open(\'{0}/@@pac_installer\'.format(self.portal_url))\n-        self.assertFalse(IDexterityFTI.providedBy(portal_types[\'Document\']))\n-        self.assertFalse(qi.is_product_installed(\'plone.app.contenttypes\'))\n-        self.assertIn(\'proceed to the migration-form?\', self.browser.contents)\n-        self.browser.getControl(\'Install\').click()\n-        self.assertFalse(IDexterityFTI.providedBy(portal_types[\'Document\']))\n-        self.assertTrue(IDexterityFTI.providedBy(portal_types[\'News Item\']))\n-        self.assertTrue(qi.is_product_installed(\'plone.app.contenttypes\'))\n-        self.assertIn(\'Migration control panel\', self.browser.contents)\n-        self.assertIn(\'You currently have <span class="strong">1</span> archetypes objects to be migrated.\', self.browser.contents)  # noqa E501\n-\n-    def test_atct_migration_form(self):\n-        # add some at content:\n-        self.portal.invokeFactory(\'Document\', \'doc1\')\n-        self.portal.invokeFactory(\'News Item\', \'news1\')\n-        self.portal.invokeFactory(\'News Item\', \'news2\')\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n-        self.portal[\'folder\'].invokeFactory(\'Document\', \'doc2\')\n-        transaction.commit()\n-        from zExceptions import NotFound\n-        self.assertRaises(\n-            NotFound,\n-            self.browser.open,\n-            \'{0}/@@atct_migrator\'.format(self.portal_url)\n-        )\n-        self.browser.open(\'{0}/@@pac_installer\'.format(self.portal_url))\n-        self.browser.getControl(\'Install\').click()\n-        # check statistics before\n-        self.assertIn(\n-            \'You currently have <span class="strong">5</span> archetypes \'\n-            \'objects to be migrated.\',\n-            self.browser.contents,\n-        )\n-        widget = \'form.widgets.content_types:list\'\n-        ct_widget = self.browser.getControl(name=widget)\n-        self.assertEqual(\n-            ct_widget.options,\n-            [\'Document\', \'Folder\', \'News Item\'])\n-        # all types are auto-selected\n-        self.assertEqual(ct_widget.value, [\'Document\', \'Folder\', \'News Item\'])\n-        widget = \'form.widgets.content_types:list\'\n-        # we only migrate Documents\n-        self.browser.getControl(name=widget).value = [\'Document\']\n-        widget = \'form.widgets.migrate_references:list\'\n-        self.assertEqual(\n-            self.browser.getControl(name=widget).value,\n-            [\'selected\']\n-        )\n-        self.browser.getControl(name=\'form.buttons.migrate\').click()\n-        from plone.app.contenttypes.interfaces import IDocument\n-        from plone.app.contenttypes.interfaces import INewsItem\n-        from plone.app.contenttypes.interfaces import IFolder\n-        self.assertTrue(IDocument.providedBy(self.portal[\'doc1\']))\n-        self.assertFalse(INewsItem.providedBy(self.portal[\'news1\']))\n-        self.assertFalse(IFolder.providedBy(self.portal[\'folder\']))\n-        self.assertTrue(IDocument.providedBy(self.portal[\'folder\'][\'doc2\']))\n-        self.assertIn(\n-            \'Congratulations! You migrated from Archetypes to Dexterity.\',\n-            self.browser.contents\n-        )\n-        msg = \'<td>ATDocument</td>\\n      <td>Document</td>\\n      <td>2</td>\'\n-        self.assertIn(msg, self.browser.contents)\n-        msg = \'<td>Document (ATDocument)</td>\\n      <td>2</td>\'\n-        self.assertIn(msg, self.browser.contents)\n-        msg = \'<td>News Item (ATNewsItem)</td>\\n      <td>2</td>\'\n-        self.assertIn(msg, self.browser.contents)\n-        msg = \'<td>Document (Dexterity Item)</td>\\n      <td>2</td>\'\n-        self.assertIn(msg, self.browser.contents)\n-        msg = \'<td>News Item (Dexterity Item)</td>\\n      <td>2</td>\'\n-        self.assertNotIn(msg, self.browser.contents)\n-        msg = \'<td>Folder (Dexterity Container)</td>\\n      <td>1</td>\'\n-        self.assertNotIn(msg, self.browser.contents)\n-\n-        # we only migrated Document, now we migrate the rest\n-        self.browser.getLink(\'Back to the Migration-Form\').click()\n-        widget = \'form.widgets.content_types:list\'\n-        ct_widget = self.browser.getControl(name=widget)\n-        self.assertEqual(ct_widget.options, [\'Folder\', \'News Item\'])\n-        self.browser.getControl(name=\'form.buttons.migrate\').click()\n-        self.assertTrue(INewsItem.providedBy(self.portal[\'news1\']))\n-        self.assertTrue(IFolder.providedBy(self.portal[\'folder\']))\n-        msg = \'<td>News Item (Dexterity Item)</td>\\n      <td>2</td>\'\n-        self.assertIn(msg, self.browser.contents)\n-        msg = \'<td>Folder (Dexterity Container)</td>\\n      <td>1</td>\'\n-        self.assertIn(msg, self.browser.contents)\ndiff --git a/plone/app/contenttypes/tests/test_migration_browser.py b/plone/app/contenttypes/tests/test_migration_browser.py\ndeleted file mode 100644\nindex f9e4e1c3..00000000\n--- a/plone/app/contenttypes/tests/test_migration_browser.py\n+++ /dev/null\n@@ -1,129 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.contenttypes.testing import TEST_MIGRATION\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_INTEGRATION_TESTING  # noqa\n-import unittest\n-\n-if TEST_MIGRATION:\n-    from plone.app.contenttypes.interfaces import IDocument\n-    from plone.app.contenttypes.interfaces import IFile\n-    from plone.app.contenttypes.interfaces import IFolder\n-    from plone.app.contenttypes.interfaces import IImage\n-    from plone.app.contenttypes.interfaces import ILink\n-    from plone.app.contenttypes.interfaces import INewsItem\n-    from plone.app.contenttypes.interfaces import IPloneAppContenttypesLayer\n-    from plone.app.testing import applyProfile\n-    from plone.app.testing import setRoles\n-    from plone.app.testing import TEST_USER_ID\n-    from plone.dexterity.fti import DexterityFTI\n-    from plone.dexterity.interfaces import IDexterityFTI\n-    from plone.event.interfaces import IEvent\n-    from Products.CMFCore.utils import getToolByName\n-    from zope.interface import directlyProvides\n-\n-\n-class FixBaseclassesTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_INTEGRATION_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n-        self.request[\'URL\'] = self.portal.absolute_url()\n-        directlyProvides(self.request, IPloneAppContenttypesLayer)\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n-        fti = DexterityFTI(\'mockobject\')\n-        fti.klass = \'plone.dexterity.content.Item\'\n-        self.portal.portal_types._setObject(\'mockobject\', fti)\n-        self.portal.invokeFactory(\'mockobject\', \'obj1\')\n-        self.obj = self.portal.obj1\n-\n-    def test_view_is_registered(self):\n-        view = self.portal.restrictedTraverse(\'fix_base_classes\')\n-        self.assertTrue(isinstance(view(), str))\n-\n-    def test_fix_interface_for_document(self):\n-        self.obj.portal_type = \'Document\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(IDocument.providedBy(self.obj))\n-\n-    def test_fix_interface_for_event(self):\n-        self.obj.portal_type = \'Event\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(IEvent.providedBy(self.obj))\n-\n-    def test_fix_interface_for_file(self):\n-        self.obj.portal_type = \'File\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(IFile.providedBy(self.obj))\n-\n-    def test_fix_interface_for_folder(self):\n-        self.obj.portal_type = \'Folder\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(IFolder.providedBy(self.obj))\n-\n-    def test_fix_interface_for_image(self):\n-        self.obj.portal_type = \'Image\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(IImage.providedBy(self.obj))\n-\n-    def test_fix_interface_for_link(self):\n-        self.obj.portal_type = \'Link\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(ILink.providedBy(self.obj))\n-\n-    def test_fix_interface_for_news_item(self):\n-        self.obj.portal_type = \'News Item\'\n-        self.catalog.reindexObject(self.obj)\n-\n-        self.portal.restrictedTraverse(\'fix_base_classes\')()\n-\n-        self.assertTrue(INewsItem.providedBy(self.obj))\n-\n-    def test_install_dx_type_if_needed(self):\n-        from plone.app.contenttypes.migration.utils import installTypeIfNeeded\n-        tt = self.portal.portal_types\n-        tt.manage_delObjects(\'Document\')\n-        tt.manage_addTypeInformation(\n-            \'Factory-based Type Information with dynamic views\',\n-            id=\'Document\')\n-        applyProfile(\n-            self.portal,\n-            \'plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'])\n-        fti = tt.getTypeInfo(\'Document\')\n-        self.assertFalse(IDexterityFTI.providedBy(fti))\n-        installTypeIfNeeded(\'Document\')\n-        fti = tt.getTypeInfo(\'Document\')\n-        self.assertTrue(IDexterityFTI.providedBy(fti))\n-\n-    def test_install_dx_type_if_needed_wrong_type_name(self):\n-        from plone.app.contenttypes.migration.utils import installTypeIfNeeded\n-        with self.assertRaises(KeyError) as e:\n-            installTypeIfNeeded(\'Unknown\')\n-        self.assertEqual(\n-            e.exception.args[0],\n-            \'Unknown is not one of the default types\'\n-        )\ndiff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py\ndeleted file mode 100644\nindex b353a722..00000000\n--- a/plone/app/contenttypes/tests/test_migration_custom.py\n+++ /dev/null\n@@ -1,611 +0,0 @@\n-# -*- coding: utf-8 -*-\n-\n-from plone.app.contenttypes.testing import TEST_MIGRATION\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_FUNCTIONAL_TESTING  # noqa\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_TESTING  # noqa\n-import unittest\n-\n-if TEST_MIGRATION:\n-    from datetime import datetime\n-    from plone.app.contenttypes.migration.field_migrators import migrate_filefield  # noqa E501\n-    from plone.app.contenttypes.migration.field_migrators import migrate_imagefield  # noqa E501\n-    from plone.app.contenttypes.migration.field_migrators import migrate_simplefield  # noqa E501\n-    from plone.app.contenttypes.migration.utils import installTypeIfNeeded\n-    from plone.app.testing import applyProfile\n-    from plone.app.testing import login\n-    from plone.app.testing import setRoles\n-    from plone.app.testing import SITE_OWNER_NAME\n-    from plone.app.testing import SITE_OWNER_PASSWORD\n-    from plone.app.testing import TEST_USER_ID\n-    from plone.testing.zope import Browser\n-    from Products.CMFCore.utils import getToolByName\n-    from Products.CMFPlone.utils import safe_unicode\n-\n-    import os.path\n-    import pytz\n-    import transaction\n-\n-\n-class MigrateFieldsTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n-\n-    def tearDown(self):\n-        try:\n-            applyProfile(self.portal, \'plone.app.contenttypes:uninstall\')\n-        except KeyError:\n-            pass\n-\n-    def get_test_image_data(self):\n-        test_image_path = os.path.join(os.path.dirname(__file__), \'image.png\')\n-        with open(test_image_path, \'rb\') as test_image_file:\n-            test_image_data = test_image_file.read()\n-        return test_image_data\n-\n-    def get_test_file_data(self):\n-        test_file_path = os.path.join(os.path.dirname(__file__), \'file.pdf\')\n-        with open(test_file_path, \'rb\') as test_file:\n-            test_file_data = test_file.read()\n-        return test_file_data\n-\n-    def test_migrate_stringfield(self):\n-        # create content\n-        at_document_id = self.portal.invokeFactory(\n-            \'Document\',\n-            \'foo\',\n-            title=\'Foo document\',\n-        )\n-        # register p.a.contenttypes profile\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        dx_document_id = self.portal.invokeFactory(\n-            \'Document\',\n-            \'bar\',\n-            title=\'Bar document\',\n-        )\n-        at_document = self.portal[at_document_id]\n-        dx_document = self.portal[dx_document_id]\n-        migrate_simplefield(at_document, dx_document, \'title\', \'title\')\n-        self.assertEqual(dx_document.Title(), at_document.Title())\n-\n-    def test_migrate_richtextfield(self):\n-        # create content\n-        at_document_id = self.portal.invokeFactory(\n-            \'Document\',\n-            \'foo\',\n-            title=\'Foo document\',\n-            text=\'Some foo html text\',\n-        )\n-        # register p.a.contenttypes profile\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        dx_document_id = self.portal.invokeFactory(\n-            \'Document\',\n-            \'bar\',\n-            title=\'Bar document\',\n-        )\n-        at_document = self.portal[at_document_id]\n-        dx_document = self.portal[dx_document_id]\n-        self.assertEqual(dx_document.text, None)\n-        migrate_simplefield(at_document, dx_document, \'text\', \'text\')\n-        self.assertEqual(dx_document.text, at_document.getText())\n-\n-    def test_migrate_listfield(self):\n-        # create content\n-        at_document_id = self.portal.invokeFactory(\n-            \'Document\',\n-            \'foo\',\n-            title=\'Foo document\',\n-            subject=[\'aaa\', \'bbb\'],\n-        )\n-        # register p.a.contenttypes profile\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        dx_document_id = self.portal.invokeFactory(\n-            \'Document\',\n-            \'bar\',\n-            title=\'Bar document\',\n-        )\n-        at_document = self.portal[at_document_id]\n-        dx_document = self.portal[dx_document_id]\n-        migrate_simplefield(at_document, dx_document, \'subject\', \'subject\',)\n-        self.assertEqual(dx_document.Subject(), at_document.Subject())\n-\n-    def test_migrate_imagefield(self):\n-        test_image_data = self.get_test_image_data()\n-        at_newsitem_id = self.portal.invokeFactory(\n-            \'News Item\',\n-            \'foo\',\n-            title=\'Foo news\',\n-            image=test_image_data,\n-        )\n-        # register p.a.contenttypes profile\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        dx_newsitem_id = self.portal.invokeFactory(\n-            \'News Item\',\n-            \'bar\',\n-            title=\'Bar news\',\n-        )\n-        at_newsitem = self.portal[at_newsitem_id]\n-        dx_newsitem = self.portal[dx_newsitem_id]\n-        self.assertEqual(dx_newsitem.image, None)\n-        migrate_imagefield(at_newsitem, dx_newsitem, \'image\', \'image\')\n-        self.assertEqual(dx_newsitem.image.contentType, \'image/png\')\n-        self.assertEqual(dx_newsitem.image.data, test_image_data)\n-\n-    def test_migrate_filefield(self):\n-        test_file_data = self.get_test_file_data()\n-        at_file_id = self.portal.invokeFactory(\n-            \'File\',\n-            \'foo\',\n-            title=\'Foo file\',\n-            file=test_file_data,\n-        )\n-        # register p.a.contenttypes profile\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        dx_file_id = self.portal.invokeFactory(\n-            \'File\',\n-            \'bar\',\n-            title=\'Bar file\',\n-        )\n-        at_file = self.portal[at_file_id]\n-        dx_file = self.portal[dx_file_id]\n-        self.assertEqual(dx_file.file, None)\n-        migrate_filefield(at_file, dx_file, \'file\', \'file\')\n-        self.assertEqual(dx_file.file.data, test_file_data)\n-\n-\n-class MigrateCustomATTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n-\n-    def tearDown(self):\n-        try:\n-            applyProfile(self.portal, \'plone.app.contenttypes:uninstall\')\n-        except KeyError:\n-            pass\n-\n-    def createCustomATDocument(self, id, parent=None):\n-        from Products.Archetypes.atapi import StringField, TextField\n-        from Products.ATContentTypes.interfaces import IATDocument\n-        from archetypes.schemaextender.interfaces import ISchemaExtender\n-        from archetypes.schemaextender.field import ExtensionField\n-        from zope.component import getGlobalSiteManager\n-        from zope.interface import implementer\n-\n-        # create schema extension\n-        class ExtensionTextField(ExtensionField, TextField):\n-            """ derivative of text for extending schemas """\n-\n-        class ExtensionStringField(ExtensionField, StringField):\n-            """ derivative of text for extending schemas """\n-\n-        @implementer(ISchemaExtender)\n-        class SchemaExtender(object):\n-            fields = [\n-                ExtensionTextField(\'textExtended\',\n-                                   ),\n-                ExtensionStringField(\'stringExtended\',\n-                                     ),\n-            ]\n-\n-            def __init__(self, context):\n-                self.context = context\n-\n-            def getFields(self):\n-                return self.fields\n-\n-        # register adapter\n-        gsm = getGlobalSiteManager()\n-        gsm.registerAdapter(SchemaExtender, (IATDocument,), ISchemaExtender)\n-\n-        # create content\n-        container = parent or self.portal\n-        container.invokeFactory(\n-            \'Document\',\n-            id,\n-            title=\'Foo document\',\n-            stringExtended=\'foo text\',\n-            textExtended=\'foo extended rich text\',\n-        )\n-        at_document = container[id]\n-\n-        # unregister adapter assure test isolation\n-        gsm.unregisterAdapter(required=[IATDocument], provided=ISchemaExtender)\n-\n-        return at_document\n-\n-    def test_migrate_extended_document(self):\n-        from plone.app.contenttypes.migration.migration import migrateCustomAT\n-        from plone.app.contenttypes.interfaces import INewsItem\n-        at_document = self.createCustomATDocument(\'foo-document\')\n-        # install pac but only install News Items\n-        portal_setup = getToolByName(self.portal, \'portal_setup\')\n-        portal_setup.runAllImportStepsFromProfile(\n-            \'profile-plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'],\n-        )\n-        installTypeIfNeeded(\'News Item\')\n-        fields_mapping = (\n-            {\'AT_field_name\': \'textExtended\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.TextField\',\n-             \'DX_field_name\': \'text\',\n-             \'DX_field_type\': \'RichText\', },\n-            {\'AT_field_name\': \'stringExtended\',\n-             \'AT_field_type\': \'StringField\',\n-             \'DX_field_name\': \'title\',\n-             \'DX_field_type\': \'StringField\', },\n-        )\n-        # migrate extended AT Document to default DX News Item\n-        migrateCustomAT(\n-            fields_mapping, src_type=\'Document\', dst_type=\'News Item\')\n-        dx_newsitem = self.portal[\'foo-document\']\n-        self.assertTrue(INewsItem.providedBy(dx_newsitem))\n-        self.assertTrue(dx_newsitem is not at_document)\n-        self.assertEqual(at_document.textExtended(), dx_newsitem.text.raw)\n-        self.assertEqual(at_document.stringExtended, dx_newsitem.title)\n-\n-    def test_migrate_atevent_to_dxnewsitem(self):\n-        """Tests the custom migration by migrating a default type. It is not\n-        meant to be used this way but is a nice way to test the migrations.\n-        During this migration the old event fti is still present.\n-        """\n-        from DateTime import DateTime\n-        from plone.app.contenttypes.migration.migration import migrateCustomAT\n-        from plone.app.contenttypes.interfaces import INewsItem\n-\n-        # create an ATEvent\n-        self.portal.invokeFactory(\'Event\', \'event\')\n-        at_event = self.portal[\'event\']\n-\n-        # Date\n-        at_event.getField(\'startDate\') \\\n-                .set(at_event, DateTime(\'2013-02-03 12:00\'))\n-        at_event.getField(\'endDate\') \\\n-                .set(at_event, DateTime(\'2013-04-05 13:00\'))\n-\n-        # Contact\n-        at_event.getField(\'contactPhone\').set(at_event, \'123456789\')\n-        at_event.getField(\'contactEmail\').set(at_event, \'dummy@email.com\')\n-        at_event.getField(\'contactName\').set(at_event, u\'N\xc3\xa4me\')\n-\n-        # URL\n-        at_event.getField(\'eventUrl\').set(at_event, \'http://www.plone.org\')\n-\n-        # Attendees\n-        at_event.getField(\'attendees\').set(at_event, (\'You\', \'Me\'))\n-\n-        # Text\n-        at_event.setText(\'T\xc3\xbctensuppe\')\n-        at_event.setContentType(\'text/plain\')\n-\n-        oldTZ = os.environ.get(\'TZ\', None)\n-        os.environ[\'TZ\'] = \'Asia/Tbilisi\'\n-\n-        # install pac but only install News Items\n-        portal_setup = getToolByName(self.portal, \'portal_setup\')\n-        portal_setup.runAllImportStepsFromProfile(\n-            \'profile-plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'],\n-        )\n-        installTypeIfNeeded(\'News Item\')\n-        fields_mapping = (\n-            {\'AT_field_name\': \'text\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.TextField\',\n-             \'DX_field_name\': \'text\',\n-             \'DX_field_type\': \'RichText\', },\n-            {\'AT_field_name\': \'contactName\',\n-             \'AT_field_type\': \'StringField\',\n-             \'DX_field_name\': \'image_caption\',\n-             \'DX_field_type\': \'StringField\', },\n-        )\n-        # migrate ATCTEvent to default DX News Item\n-        migrateCustomAT(fields_mapping, src_type=\'Event\', dst_type=\'News Item\')\n-        if oldTZ:\n-            os.environ[\'TZ\'] = oldTZ\n-        else:\n-            del os.environ[\'TZ\']\n-\n-        dx_newsitem = self.portal[\'event\']\n-        self.assertTrue(INewsItem.providedBy(dx_newsitem))\n-        self.assertTrue(dx_newsitem is not at_event)\n-        self.assertEqual(\n-            safe_unicode(at_event.getText()),\n-            dx_newsitem.text.output)\n-        self.assertEqual(\n-            at_event.contactName,\n-            dx_newsitem.image_caption)\n-\n-    def test_migrate_atevent_to_dxevent(self):\n-        """Tests the custom migration by migrating a default type. It is not\n-        meant to be used this way but is a nice way to test the migrations.\n-        During this migration the event fti is already replaced by the dx one.\n-        """\n-        from DateTime import DateTime\n-        from plone.app.contenttypes.migration.migration import migrateCustomAT\n-        from plone.app.contenttypes.interfaces import IEvent\n-\n-        # create an ATEvent\n-        self.portal.invokeFactory(\'Event\', \'event\')\n-        at_event = self.portal[\'event\']\n-\n-        # Date\n-        FORMAT = \'%Y-%m-%d %H:%M\'\n-        start = \'2013-02-03 12:15\'\n-        end = \'2013-04-05 13:45\'\n-        at_event.getField(\'startDate\').set(at_event, DateTime(start))\n-        at_event.getField(\'endDate\').set(at_event, DateTime(end))\n-\n-        # Contact\n-        at_event.getField(\'contactPhone\').set(at_event, \'123456789\')\n-        at_event.getField(\'contactEmail\').set(at_event, \'dummy@email.com\')\n-        at_event.getField(\'contactName\').set(at_event, u\'N\xc3\xa4me\')\n-\n-        # URL\n-        at_event.getField(\'eventUrl\').set(at_event, \'http://www.plone.org\')\n-\n-        # Attendees\n-        at_event.getField(\'attendees\').set(at_event, (\'Y\xc3\xb6u\', \'Me\'))\n-\n-        # Text\n-        at_event.setText(\'T\xc3\xbctensuppe\')\n-        at_event.setContentType(\'text/plain\')\n-\n-        oldTZ = os.environ.get(\'TZ\', None)\n-        TZ = \'Asia/Tbilisi\'\n-        os.environ[\'TZ\'] = TZ\n-        timezone = pytz.timezone(TZ)\n-\n-        # install pac but only install Event\n-        portal_setup = getToolByName(self.portal, \'portal_setup\')\n-        portal_setup.runAllImportStepsFromProfile(\n-            \'profile-plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'],\n-        )\n-        installTypeIfNeeded(\'Event\')\n-        fields_mapping = (\n-            {\'AT_field_name\': \'startDate\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.DateTimeField\',\n-             \'DX_field_name\': \'start\',\n-             \'DX_field_type\': \'Datetime\', },\n-            {\'AT_field_name\': \'endDate\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.DateTimeField\',\n-             \'DX_field_name\': \'end\',\n-             \'DX_field_type\': \'Datetime\', },\n-            {\'AT_field_name\': \'text\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.TextField\',\n-             \'DX_field_name\': \'text\',\n-             \'DX_field_type\': \'RichText\', },\n-            {\'AT_field_name\': \'eventUrl\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.StringField\',\n-             \'DX_field_name\': \'event_url\',\n-             \'DX_field_type\': \'StringField\', },\n-            {\'AT_field_name\': \'contactEmail\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.StringField\',\n-             \'DX_field_name\': \'contact_email\',\n-             \'DX_field_type\': \'StringField\', },\n-            {\'AT_field_name\': \'contactName\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.StringField\',\n-             \'DX_field_name\': \'contact_name\',\n-             \'DX_field_type\': \'StringField\', },\n-            {\'AT_field_name\': \'contactPhone\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.StringField\',\n-             \'DX_field_name\': \'contact_phone\',\n-             \'DX_field_type\': \'StringField\', },\n-            {\'AT_field_name\': \'attendees\',\n-             \'AT_field_type\': \'Products.Archetypes.Field.LinesField\',\n-             \'DX_field_name\': \'attendees\',\n-             \'DX_field_type\': \'Tuple\', },\n-        )\n-        # migrate ATEvent to new default Event\n-        migrateCustomAT(fields_mapping, src_type=\'Event\', dst_type=\'Event\')\n-        dx_event = self.portal[\'event\']\n-        self.assertTrue(IEvent.providedBy(dx_event))\n-        self.assertTrue(dx_event is not at_event)\n-        self.assertEqual(safe_unicode(\n-            at_event.getText()), dx_event.text.output)\n-        self.assertEqual(at_event.eventUrl, dx_event.event_url)\n-        self.assertEqual(at_event.contactEmail, dx_event.contact_email)\n-        self.assertEqual(at_event.contactName, dx_event.contact_name)\n-        self.assertEqual(at_event.contactPhone, dx_event.contact_phone)\n-        self.assertEqual(at_event.attendees, dx_event.attendees)\n-        self.assertEqual(\n-            dx_event.start,\n-            timezone.localize(datetime.strptime(start, FORMAT)))\n-        self.assertEqual(\n-            dx_event.end, timezone.localize(datetime.strptime(end, FORMAT)))\n-        if oldTZ:\n-            os.environ[\'TZ\'] = oldTZ\n-        else:\n-            del os.environ[\'TZ\']\n-\n-    def test_migration_with_custom_fieldmigrator(self):\n-        """Migrate a ATDocument to a DXNewsItem using a custom modifier"""\n-        from plone.app.contenttypes.interfaces import INewsItem\n-        from plone.app.contenttypes.migration.migration import migrateCustomAT\n-        at_document = self.createCustomATDocument(\'foo-document\')\n-        at_text = (\n-            u\'Some | field is | pipe-delimited | in the field\\n\'\n-        )\n-        at_document.setText(at_text)\n-        # install pac but only install News Items\n-        portal_setup = getToolByName(self.portal, \'portal_setup\')\n-        portal_setup.runAllImportStepsFromProfile(\n-            \'profile-plone.app.contenttypes:default\',\n-            blacklisted_steps=[\'typeinfo\'],\n-        )\n-        installTypeIfNeeded(\'News Item\')\n-        fields_mapping = (\n-            {\'AT_field_name\': \'text\',\n-             \'DX_field_name\': \'creators\',\n-             \'field_migrator\': some_field_migrator},\n-        )\n-        migrateCustomAT(\n-            fields_mapping, src_type=\'Document\', dst_type=\'News Item\')\n-\n-        dx_newsitem = self.portal[\'foo-document\']\n-        self.assertTrue(INewsItem.providedBy(dx_newsitem))\n-        self.assertTrue(dx_newsitem is not at_document)\n-        self.assertEqual(4, len(dx_newsitem.creators))\n-        self.assertEqual(at_document.Title(), dx_newsitem.title)\n-\n-\n-def some_field_migrator(src_obj, dst_obj, src_fieldname, dst_fieldname):\n-    """Custom field_migrator\n-\n-    A simple example that transforms the value of a pipe-delimited richtext\n-    to a tuple.\n-    """\n-    field = src_obj.getField(src_fieldname)\n-    at_value = field.get(src_obj)\n-    at_value = at_value.replace(\'<p>\', \'\').replace(\'</p>\', \'\')\n-    dx_value = [safe_unicode(i) for i in at_value.split(\'|\')]\n-    setattr(dst_obj, dst_fieldname, tuple(dx_value))\n-\n-\n-class CustomMigrationFunctionalTests(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_FUNCTIONAL_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        app = self.layer[\'app\']\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n-        self.request[\'URL\'] = self.portal.absolute_url()\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n-        self.portal.acl_users.userFolderAddUser(\'admin\',\n-                                                \'secret\',\n-                                                [\'Manager\'],\n-                                                [])\n-        login(self.portal, \'admin\')\n-        self.portal.portal_workflow.setDefaultChain(\n-            \'simple_publication_workflow\')\n-        self.portal_url = self.portal.absolute_url()\n-\n-        self.browser = Browser(app)\n-        self.browser.handleErrors = False\n-        self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic {0}:{1}\'.format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD,)\n-        )\n-\n-    def tearDown(self):\n-        try:\n-            applyProfile(self.portal, \'plone.app.contenttypes:uninstall\')\n-        except KeyError:\n-            pass\n-\n-    def test_custom_migration_form(self):\n-        """Basic test for the custom_migration form.\n-        Field-mapping only works with javascript enabled so we migrate\n-        only the content but not the fields.\n-        """\n-        # add some at content\n-        self.portal.invokeFactory(\'Document\', \'doc1\')\n-        self.portal.invokeFactory(\'Event\', \'event1\')\n-        self.portal.event1.setTitle(u\'Ein T\xc3\xb6rmin\')\n-        self.portal.event1.setDescription(u\'W\xc3\xa4nn?\')\n-        self.portal.doc1.setTitle(u\'Ein D\xc3\xb6cument\')\n-        self.portal.doc1.setDescription(u\'S\xc3\xb6 was\')\n-        transaction.commit()\n-        self.browser.open(\'{0}/@@pac_installer\'.format(self.portal_url))\n-        self.browser.getControl(\'Install\').click()\n-        # open custom-migration-form\n-        self.browser.open(\'{0}/@@custom_migration\'.format(self.portal_url))\n-        results = self.browser.contents\n-        self.assertIn(\'Custom types migration control panel\', results)\n-        self.assertIn(\'<input type="hidden" name="Document:list" value="text__type__Products.Archetypes.Field.TextField" />\', results)  # noqa\n-        self.assertEqual(self.browser.getControl(name=\'dx_select_Document\').value, [\'\'])  # noqa\n-        # chose to migrate to Link\n-        self.browser.getControl(name=\'dx_select_Document\').value = [\'Link\']\n-        self.assertIn(\'<input type="hidden" name="Event:list" value="startDate__type__Products.Archetypes.Field.DateTimeField" />\', results)  # noqa\n-        # chose to migrate to Link\n-        self.browser.getControl(name=\'dx_select_Event\').value = [\'Link\']\n-        # run migration\n-        self.browser.getControl(name=\'form.button.Migrate\').click()\n-        results = self.browser.contents\n-        self.assertIn(\n-            \'Migration applied successfully for 1 "Document" items.\',\n-            results,\n-        )\n-        self.assertIn(\n-            \'Migration applied successfully for 1 "Event" items.\',\n-            results,\n-        )\n-        self.assertIn(\'No content to migrate.\', results)\n-        link1 = self.portal[\'doc1\']\n-        self.assertEqual(link1.portal_type, \'Link\')\n-        self.assertEqual(link1.title, u\'Ein D\\xf6cument\')\n-        self.assertEqual(link1.description, u\'S\\xf6 was\')\n-        self.assertEqual(self.portal[\'event1\'].portal_type, \'Link\')\n-        # we did not migrate the fields so lets find out if it is a real Link\n-        link1.remote_url = \'http://www.starzel.de\'\n-        view = link1()\n-        self.assertIn(u\'<h1 class="documentFirstHeading">Ein D\\xf6cument</h1>\', view)  # noqa\n-        self.assertIn(u\'The link address is:</span>\\n            <a href="http://www.starzel.de">http://www.starzel.de</a>\', view)  # noqa\n-\n-    def test_custom_migration_form_for_types_with_spaces(self):\n-        """Basic test for the custom_migration form.\n-        Field-mapping only works with javascript enabled so we migrate\n-        only the content but not the fields.\n-        """\n-        # add some at content\n-        self.portal.invokeFactory(\'News Item\', \'news1\')\n-        self.portal.invokeFactory(\'Event\', \'event1\')\n-        self.portal.event1.setTitle(u\'Ein T\xc3\xb6rmin\')\n-        self.portal.event1.setDescription(u\'W\xc3\xa4nn?\')\n-        self.portal.news1.setTitle(u\'Ein News Item\')\n-        self.portal.news1.setDescription(u\'S\xc3\xb6 was\')\n-        transaction.commit()\n-        self.browser.open(\'{0}/@@pac_installer\'.format(self.portal_url))\n-        self.browser.getControl(\'Install\').click()\n-        # open custom-migration-form\n-        self.browser.open(\'{0}/@@custom_migration\'.format(self.portal_url))\n-        results = self.browser.contents\n-        self.assertIn(\'Custom types migration control panel\', results)\n-        self.assertIn(\'<input type="hidden" name="News_space_Item:list" value="text__type__Products.Archetypes.Field.TextField" />\', results)  # noqa\n-        self.assertEqual(self.browser.getControl(name=\'dx_select_News_space_Item\').value, [\'\'])  # noqa\n-        # chose to migrate to Link\n-        self.browser.getControl(name=\'dx_select_News_space_Item\').value = [\'Link\']  # noqa\n-        self.assertIn(\'<input type="hidden" name="Event:list" value="startDate__type__Products.Archetypes.Field.DateTimeField" />\', results)  # noqa\n-        # chose to migrate to Link\n-        self.browser.getControl(name=\'dx_select_Event\').value = [\'Link\']\n-        # run migration\n-        self.browser.getControl(name=\'form.button.Migrate\').click()\n-        results = self.browser.contents\n-        self.assertIn(\n-            \'Migration applied successfully for 1 "News Item" items.\',\n-            results,\n-        )\n-        self.assertIn(\n-            \'Migration applied successfully for 1 "Event" items.\',\n-            results,\n-        )\n-        self.assertIn(\'No content to migrate.\', results)\n-        link1 = self.portal[\'news1\']\n-        self.assertEqual(link1.portal_type, \'Link\')\n-        self.assertEqual(link1.title, u\'Ein News Item\')\n-        self.assertEqual(link1.description, u\'S\\xf6 was\')\n-        self.assertEqual(self.portal[\'event1\'].portal_type, \'Link\')\n-        # we did not migrate the fields so lets find out if it is a real Link\n-        link1.remote_url = \'http://www.starzel.de\'\n-        view = link1()\n-        self.assertIn(u\'<h1 class="documentFirstHeading">Ein News Item</h1>\', view)  # noqa\n-        self.assertIn(u\'The link address is:</span>\\n            <a href="http://www.starzel.de">http://www.starzel.de</a>\', view)  # noqa\ndiff --git a/plone/app/contenttypes/tests/test_migration_topic.py b/plone/app/contenttypes/tests/test_migration_topic.py\ndeleted file mode 100644\nindex 44dcb513..00000000\n--- a/plone/app/contenttypes/tests/test_migration_topic.py\n+++ /dev/null\n@@ -1,762 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.contenttypes.testing import TEST_MIGRATION\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_TESTING  # noqa\n-import unittest\n-\n-if TEST_MIGRATION:\n-    from DateTime import DateTime\n-    from plone.app.contenttypes.behaviors.collection import ICollection\n-    from plone.app.contenttypes.migration.topics import migrate_topics\n-    from plone.app.querystring.queryparser import parseFormquery\n-    from plone.app.testing import applyProfile\n-    from plone.app.testing import login\n-    from plone.dexterity.content import Container\n-    from plone.dexterity.interfaces import IDexterityFTI\n-    from Products.CMFCore.utils import getToolByName\n-    from zope.component import queryUtility\n-    from zope.interface import implementer\n-\n-    @implementer(ICollection)\n-    class FolderishCollection(Container):\n-        """Test subclass for folderish ``Collections``.\n-        """\n-\n-\n-class MigrateTopicsIntegrationTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING\n-\n-    def setUp(self):\n-        if not TEST_MIGRATION:\n-            raise unittest.SkipTest(\'Migration tests require ATContentTypes\')\n-\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n-        self.request[\'URL\'] = self.portal.absolute_url()\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n-        self.portal.acl_users.userFolderAddUser(\'admin\',\n-                                                \'secret\',\n-                                                [\'Manager\'],\n-                                                [])\n-        login(self.portal, \'admin\')\n-        self.portal.portal_workflow.setDefaultChain(\n-            \'simple_publication_workflow\')\n-        self.portal.invokeFactory(\'Topic\', \'topic\', title=\'Topic\')\n-        self.portal.invokeFactory(\'Folder\', \'folder\', title=\'Folder\')\n-\n-    def run_migration(self):\n-        migrate_topics(self.portal)\n-\n-    def add_criterion(self, index, criterion, value=None):\n-        name = \'{0}_{1}\'.format(index, criterion)\n-        self.portal.topic.addCriterion(index, criterion)\n-        crit = self.portal.topic.getCriterion(name)\n-        if value is not None:\n-            crit.setValue(value)\n-        return crit\n-\n-    def test_migrate_simple_topic(self):\n-        self.assertEqual(self.portal.topic.portal_type, \'Topic\')\n-        self.assertEqual(self.portal.topic.getLayout(), \'atct_topic_view\')\n-        self.assertEqual(self.portal.topic.getLimitNumber(), False)\n-        self.assertEqual(self.portal.topic.getItemCount(), 0)\n-        self.assertEqual(self.portal.topic.getCustomViewFields(), (\'Title\',))\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        new = ICollection(self.portal.topic)\n-        self.assertEqual(self.portal.topic.portal_type, \'Collection\')\n-        self.assertEqual(self.portal.topic.getLayout(), \'listing_view\')\n-        self.assertEqual(new.sort_on, None)\n-        self.assertEqual(new.sort_reversed, None)\n-        self.assertEqual(new.limit, 1000)\n-        self.assertEqual(new.customViewFields, (\'Title\',))\n-\n-    def test_migrate_topic_fields(self):\n-        self.portal.topic.setText(\'<p>Hello</p>\')\n-        self.portal.topic.setLimitNumber(True)\n-        self.portal.topic.setItemCount(42)\n-        self.portal.topic.setCustomViewFields((\'Title\', \'Type\'))\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        new = ICollection(self.portal.topic)\n-        self.assertEqual(self.portal.topic.portal_type, \'Collection\')\n-        self.assertEqual(new.limit, 42)\n-        self.assertEqual(new.customViewFields, (\'Title\', \'Type\'))\n-        self.assertEqual(self.portal.topic.text.raw, u\'<p>Hello</p>\')\n-\n-    def test_migrate_layout(self):\n-        self.portal.topic.setLayout(\'folder_summary_view\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.getLayout(), \'summary_view\')\n-\n-    def test_migrate_customView(self):\n-        self.portal.topic.setCustomView(True)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.getLayout(), \'tabular_view\')\n-\n-    def test_migrate_nested_topic(self):\n-        self.portal.portal_types[\'Topic\'].filter_content_types = False\n-        self.portal.topic.invokeFactory(\'Topic\', \'subtopic\', title=\'Sub Topic\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        fti = queryUtility(IDexterityFTI, name=\'Collection\')\n-        # switch our a custom folderish base-class for collections\n-        # we need to use _updateProperty because this also refreshes\n-        # the content_meta_type attribute when klass has changed\n-        fti._updateProperty(\n-            \'klass\',\n-            \'plone.app.contenttypes.tests.test_migration_topic.\'\n-            \'FolderishCollection\')\n-        fti._updateProperty(\'allowed_content_types\', [\'Document\', \'Folder\'])\n-        fti._updateProperty(\'filter_content_types\', False)\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.portal_type, \'Collection\')\n-        self.assertEqual(self.portal.topic.subtopic.portal_type, \'Collection\')\n-\n-    def test_ATSimpleStringCriterion(self):\n-        self.add_criterion(\'SearchableText\', \'ATSimpleStringCriterion\', \'bar\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'SearchableText\',\n-              \'o\': \'plone.app.querystring.operation.string.contains\',\n-              \'v\': \'bar\'}]\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATSimpleStringCriterionToSelection(self):\n-        # Some string criterions really should be selection criterions.\n-        self.add_criterion(\n-            \'review_state\',\n-            \'ATSimpleStringCriterion\', \'published\'\n-        )\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'review_state\',\n-              \'o\': \'plone.app.querystring.operation.selection.any\',\n-              \'v\': \'published\'}]\n-        )\n-\n-    def test_ATDateCriteriaPast(self):\n-        # More than 5 days in the past:\n-        crit = self.add_criterion(\'created\', \'ATFriendlyDateCriteria\', 5)\n-        crit.setOperation(\'more\')\n-        crit.setDateRange(\'-\')\n-        # Less than 5 days in the past:\n-        crit = self.add_criterion(\'effective\', \'ATFriendlyDateCriteria\', 5)\n-        crit.setOperation(\'less\')\n-        crit.setDateRange(\'-\')\n-        # The next two are logically a bit weird.\n-        # More than 0 days in the past is historically interpreted as: after\n-        # today.\n-        crit = self.add_criterion(\'expires\', \'ATFriendlyDateCriteria\', 0)\n-        crit.setOperation(\'more\')\n-        crit.setDateRange(\'-\')\n-        # Less than 0 days in the past is historically interpreted as: before\n-        # today.\n-        crit = self.add_criterion(\'modified\', \'ATFriendlyDateCriteria\', 0)\n-        crit.setOperation(\'less\')\n-        crit.setDateRange(\'-\')\n-\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 4)\n-\n-        self.assertEqual(query[0][\'i\'], \'created\')\n-        self.assertEqual(\n-            query[0][\'o\'],\n-            \'plone.app.querystring.operation.date.largerThanRelativeDate\'\n-        )\n-        self.assertEqual(query[0][\'v\'], -5)\n-\n-        self.assertEqual(query[1][\'i\'], \'effective\')\n-        self.assertEqual(\n-            query[1][\'o\'],\n-            \'plone.app.querystring.operation.date.lessThanRelativeDate\'\n-        )\n-        self.assertEqual(query[1][\'v\'], -5)\n-\n-        self.assertEqual(query[2][\'i\'], \'expires\')\n-        self.assertEqual(\n-            query[2][\'o\'],\n-            \'plone.app.querystring.operation.date.afterToday\'\n-        )\n-        self.assertTrue(\'v\' not in query[2].keys())\n-\n-        self.assertEqual(query[3][\'i\'], \'modified\')\n-        self.assertEqual(\n-            query[3][\'o\'],\n-            \'plone.app.querystring.operation.date.beforeToday\'\n-        )\n-        self.assertTrue(\'v\' not in query[3].keys())\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATDateCriteriaFuture(self):\n-        # More than 5 days in the future:\n-        crit = self.add_criterion(\'created\', \'ATFriendlyDateCriteria\', 5)\n-        crit.setOperation(\'more\')\n-        crit.setDateRange(\'+\')\n-        # Less than 5 days in the future:\n-        crit = self.add_criterion(\'effective\', \'ATFriendlyDateCriteria\', 5)\n-        crit.setOperation(\'less\')\n-        crit.setDateRange(\'+\')\n-        # More than 0 days in the future: after today.\n-        crit = self.add_criterion(\'expires\', \'ATFriendlyDateCriteria\', 0)\n-        crit.setOperation(\'more\')\n-        crit.setDateRange(\'+\')\n-        # Less than 0 days in the future: before today.\n-        crit = self.add_criterion(\'modified\', \'ATFriendlyDateCriteria\', 0)\n-        crit.setOperation(\'less\')\n-        crit.setDateRange(\'+\')\n-\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 4)\n-\n-        self.assertEqual(query[0][\'i\'], \'created\')\n-        self.assertEqual(\n-            query[0][\'o\'],\n-            \'plone.app.querystring.operation.date.largerThanRelativeDate\'\n-        )\n-        self.assertEqual(query[0][\'v\'], 5)\n-\n-        self.assertEqual(query[1][\'i\'], \'effective\')\n-        self.assertEqual(\n-            query[1][\'o\'],\n-            \'plone.app.querystring.operation.date.lessThanRelativeDate\'\n-        )\n-        self.assertTrue(query[1][\'v\'], 5)\n-\n-        self.assertEqual(query[2][\'i\'], \'expires\')\n-        self.assertEqual(\n-            query[2][\'o\'],\n-            \'plone.app.querystring.operation.date.afterToday\'\n-        )\n-        self.assertTrue(\'v\' not in query[2].keys())\n-\n-        self.assertEqual(query[3][\'i\'], \'modified\')\n-        self.assertEqual(\n-            query[3][\'o\'],\n-            \'plone.app.querystring.operation.date.beforeToday\'\n-        )\n-        self.assertTrue(\'v\' not in query[3].keys())\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATDateCriteriaExactDay(self):\n-        # 5 days ago:\n-        crit = self.add_criterion(\'created\', \'ATFriendlyDateCriteria\', 5)\n-        crit.setOperation(\'within_day\')\n-        crit.setDateRange(\'-\')\n-        # 5 days from now:\n-        crit = self.add_criterion(\'effective\', \'ATFriendlyDateCriteria\', 5)\n-        crit.setOperation(\'within_day\')\n-        crit.setDateRange(\'+\')\n-        # past or future does not matter if the day is today.\n-        # today minus\n-        crit = self.add_criterion(\'expires\', \'ATFriendlyDateCriteria\', 0)\n-        crit.setOperation(\'within_day\')\n-        crit.setDateRange(\'-\')\n-        # today plus\n-        crit = self.add_criterion(\'modified\', \'ATFriendlyDateCriteria\', 0)\n-        crit.setOperation(\'within_day\')\n-        crit.setDateRange(\'+\')\n-\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        time2 = DateTime()\n-        self.assertEqual(len(query), 4)\n-\n-        self.assertEqual(query[0][\'i\'], \'created\')\n-        self.assertEqual(\n-            query[0][\'o\'],\n-            \'plone.app.querystring.operation.date.between\'\n-        )\n-        self.assertEqual(\n-            query[0][\'v\'],\n-            ((time2 - 5).earliestTime(), (time2 - 5).latestTime())\n-        )\n-\n-        self.assertEqual(query[1][\'i\'], \'effective\')\n-        self.assertEqual(\n-            query[1][\'o\'],\n-            \'plone.app.querystring.operation.date.between\'\n-        )\n-        self.assertEqual(\n-            query[1][\'v\'],\n-            ((time2 + 5).earliestTime(), (time2 + 5).latestTime())\n-        )\n-\n-        self.assertEqual(query[2][\'i\'], \'expires\')\n-        self.assertEqual(\n-            query[2][\'o\'],\n-            \'plone.app.querystring.operation.date.today\'\n-        )\n-        self.assertFalse(\'v\' in query[2].keys())\n-\n-        self.assertEqual(query[3][\'i\'], \'modified\')\n-        self.assertEqual(\n-            query[3][\'o\'],\n-            \'plone.app.querystring.operation.date.today\'\n-        )\n-        self.assertFalse(\'v\' in query[3].keys())\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATCurrentAuthorCriterion(self):\n-        self.add_criterion(\'Creator\', \'ATCurrentAuthorCriterion\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'Creator\',\n-              \'o\': \'plone.app.querystring.operation.string.currentUser\',\n-              \'v\': \'admin\'}]\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATListCriterion(self):\n-        # The new-style queries do not currently offer the possibility\n-        # to choose if the given values should be joined with \'or\' or\n-        # \'and\'.  Default is \'or\'.\n-        crit = self.add_criterion(\'Subject\', \'ATListCriterion\', (\'foo\', \'bar\'))\n-        crit.setOperator(\'or\')\n-        # Note: this could have been an ATPortalTypeCriterion too:\n-        crit = self.add_criterion(\n-            \'portal_type\',\n-            \'ATListCriterion\', (\'Document\', \'Folder\')\n-        )\n-        crit.setOperator(\'and\')\n-\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 2)\n-        self.assertEqual(query[0],\n-                         {\'i\': \'Subject\',\n-                          \'o\': \'plone.app.querystring.operation.selection.any\',\n-                          \'v\': (\'foo\', \'bar\')})\n-        self.assertEqual(query[1],\n-                         {\'i\': \'portal_type\',\n-                          \'o\': \'plone.app.querystring.operation.selection.any\',\n-                          \'v\': (\'Document\', \'Folder\')})\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATPathCriterion(self):\n-        crit = self.add_criterion(\n-            \'path\',\n-            \'ATPathCriterion\', self.portal.folder.UID())\n-        crit.setRecurse(True)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.query,\n-                         [{\'i\': \'path\',\n-                           \'o\': \'plone.app.querystring.operation.string.path\',\n-                           \'v\': self.portal.folder.UID()}])\n-        # check is the query is correct\n-        self.assertEqual(\n-            parseFormquery(self.portal, self.portal.topic.query),\n-            {\'path\': {\'query\': [\'/plone/folder\']}})\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATPathCriterionNonRecursive(self):\n-        # Topics supported non recursive search, so search at a\n-        # specific depth of 1.  At first, new Collections did not\n-        # support it.  But since plone.app.querystring 1.1.0 it works.\n-        crit = self.add_criterion(\n-            \'path\',\n-            \'ATPathCriterion\', self.portal.folder.UID()\n-        )\n-        crit.setRecurse(False)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 1)\n-        self.assertEqual(query,\n-                         [{\'i\': \'path\',\n-                           \'o\': \'plone.app.querystring.operation.string.path\',\n-                           \'v\': self.portal.folder.UID() + \'::1\'}])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATPathCriterionMultiRecursive(self):\n-        # Collections support multiple paths since\n-        # plone.app.querystring 1.2.0.\n-        login(self.portal, \'admin\')\n-        self.portal.invokeFactory(\'Folder\', \'folder2\', title=\'Folder 2\')\n-        crit = self.add_criterion(\n-            \'path\',\n-            \'ATPathCriterion\',\n-            [self.portal.folder.UID(), self.portal.folder2.UID()]\n-        )\n-        crit.setRecurse(True)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 2)\n-        self.assertEqual(query[0],\n-                         {\'i\': \'path\',\n-                          \'o\': \'plone.app.querystring.operation.string.path\',\n-                          \'v\': self.portal.folder.UID()})\n-        self.assertEqual(query[1],\n-                         {\'i\': \'path\',\n-                          \'o\': \'plone.app.querystring.operation.string.path\',\n-                          \'v\': self.portal.folder2.UID()})\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATPathCriterionMultiNonRecursive(self):\n-        # Collections support multiple paths since\n-        # plone.app.querystring 1.2.0.\n-        login(self.portal, \'admin\')\n-        self.portal.invokeFactory(\'Folder\', \'folder2\', title=\'Folder 2\')\n-        crit = self.add_criterion(\n-            \'path\',\n-            \'ATPathCriterion\',\n-            [self.portal.folder.UID(), self.portal.folder2.UID()]\n-        )\n-        crit.setRecurse(False)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 2)\n-        self.assertEqual(query[0],\n-                         {\'i\': \'path\',\n-                          \'o\': \'plone.app.querystring.operation.string.path\',\n-                          \'v\': self.portal.folder.UID() + \'::1\'})\n-        self.assertEqual(query[1],\n-                         {\'i\': \'path\',\n-                          \'o\': \'plone.app.querystring.operation.string.path\',\n-                          \'v\': self.portal.folder2.UID() + \'::1\'})\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATBooleanCriterion(self):\n-        # Note that in standard Plone the boolean criterion is only\n-        # defined for is_folderish and is_default_page.\n-        crit = self.add_criterion(\'is_folderish\', \'ATBooleanCriterion\')\n-        crit.setBool(True)\n-        crit = self.add_criterion(\'is_default_page\', \'ATBooleanCriterion\')\n-        crit.setBool(False)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 2)\n-        self.assertEqual(\n-            query[0],\n-            {\'i\': \'is_folderish\',\n-             \'o\': \'plone.app.querystring.operation.boolean.isTrue\'}\n-        )\n-        self.assertEqual(\n-            query[1],\n-            {\'i\': \'is_default_page\',\n-             \'o\': \'plone.app.querystring.operation.boolean.isFalse\'}\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATDateRangeCriteria(self):\n-        time1 = DateTime()\n-        # Days in the past:\n-        crit = self.add_criterion(\'created\', \'ATDateRangeCriterion\')\n-        crit.setStart(time1 - 5)\n-        crit.setEnd(time1 - 3)\n-        # Past and future:\n-        crit = self.add_criterion(\'effective\', \'ATDateRangeCriterion\')\n-        crit.setStart(time1 - 2)\n-        crit.setEnd(time1 + 2)\n-        # Days in the future:\n-        crit = self.add_criterion(\'expires\', \'ATDateRangeCriterion\')\n-        crit.setStart(time1 + 3)\n-        crit.setEnd(time1 + 5)\n-\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 3)\n-\n-        self.assertEqual(query[0][\'i\'], \'created\')\n-        self.assertEqual(\n-            query[0][\'o\'],\n-            \'plone.app.querystring.operation.date.between\'\n-        )\n-        self.assertEqual(query[0][\'v\'], (time1 - 5, time1 - 3))\n-\n-        self.assertEqual(query[1][\'i\'], \'effective\')\n-        self.assertEqual(\n-            query[1][\'o\'],\n-            \'plone.app.querystring.operation.date.between\'\n-        )\n-        self.assertEqual(query[1][\'v\'], (time1 - 2, time1 + 2))\n-\n-        self.assertEqual(query[2][\'i\'], \'expires\')\n-        self.assertEqual(\n-            query[2][\'o\'],\n-            \'plone.app.querystring.operation.date.between\'\n-        )\n-        self.assertEqual(query[2][\'v\'], (time1 + 3, time1 + 5))\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATPortalTypeCriterion(self):\n-        self.add_criterion(\n-            \'portal_type\',\n-            \'ATPortalTypeCriterion\', (\'Document\', \'Folder\')\n-        )\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(\n-            query,\n-            [{\'i\': \'portal_type\',\n-              \'o\': \'plone.app.querystring.operation.selection.any\',\n-              \'v\': (\'Document\', \'Folder\')}]\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATPortalTypeCriterionOfTopic(self):\n-        # We migrate Topics to Collections, so we should update\n-        # criterions that search for Topics.\n-        self.add_criterion(\n-            \'portal_type\',\n-            \'ATPortalTypeCriterion\', (\'Topic\',)\n-        )\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(\n-            query,\n-            [{\'i\': \'portal_type\',\n-              \'o\': \'plone.app.querystring.operation.selection.any\',\n-              \'v\': (\'Collection\',)}])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATSelectionCriterion(self):\n-        # The new-style queries do not currently offer the possibility\n-        # to choose if the given values should be joined with \'or\' or\n-        # \'and\'.  Default is \'or\'.\n-        crit = self.add_criterion(\n-            \'Subject\',\n-            \'ATSelectionCriterion\',\n-            (\'foo\', \'bar\')\n-        )\n-        crit.setOperator(\'or\')\n-        # Note: this could have been an ATPortalTypeCriterion too:\n-        # Note that we check that Topic is turned into Collection too.\n-        crit = self.add_criterion(\n-            \'portal_type\',\n-            \'ATSelectionCriterion\',\n-            (\'Document\', \'Topic\')\n-        )\n-        crit.setOperator(\'and\')\n-\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(len(query), 2)\n-        self.assertEqual(query[0],\n-                         {\'i\': \'Subject\',\n-                          \'o\': \'plone.app.querystring.operation.selection.any\',\n-                          \'v\': (\'foo\', \'bar\')})\n-        self.assertEqual(query[1],\n-                         {\'i\': \'portal_type\',\n-                          \'o\': \'plone.app.querystring.operation.selection.any\',\n-                          \'v\': (\'Document\', \'Collection\')})\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATSelectionCriterionForTypeTitle(self):\n-        # \'portal_type\' is the object id of the FTI in portal_types.\n-        # \'Type\' is the title of that object.\n-        # For example:\n-        # - portal_type \'Document\' has Type \'Page\'.\n-        # - portal_type \'Topic\' has Type \'Collection (old)\'.\n-        # Type is not enabled as criterion index by default, so we\n-        # want to migrate to a portal_type criterion instead.\n-        self.add_criterion(\'Type\', \'ATSelectionCriterion\', (\'Page\', \'Folder\'))\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        query = self.portal.topic.query\n-        self.assertEqual(\n-            query,\n-            [{\'i\': \'portal_type\',\n-              \'o\': \'plone.app.querystring.operation.selection.any\',\n-              \'v\': [\'Document\', \'Folder\']}])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATReferenceCriterion(self):\n-        # Note: the new criterion is disabled by default.  Also, it\n-        # needs the _referenceIs function in the plone.app.querystring\n-        # queryparser and that function is not defined.\n-        self.add_criterion(\n-            \'getRawRelatedItems\',\n-            \'ATReferenceCriterion\',\n-            self.portal.folder.UID()\n-        )\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        # TODO re-enable this check when the queryparser works.\n-        # self.assertEqual(\n-        #     self.portal.topic.query,\n-        #     [{\'i\': \'getRawRelatedItems\',\n-        #       \'o\': \'plone.app.querystring.operation.reference.is\',\n-        #       \'v\': (portal.folder.UID(),)}]\n-        # )\n-\n-        # Check that the resulting query does not give an error.\n-        # self.portal.topic.results\n-\n-    def test_ATRelativePathCriterion(self):\n-        crit = self.add_criterion(\n-            \'path\',\n-            \'ATRelativePathCriterion\'\n-        )\n-        crit.setRelativePath(\'../folder\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'path\',\n-              \'o\': \'plone.app.querystring.operation.string.relativePath\',\n-              \'v\': \'../folder\'}]\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATRelativePathCriterionNonRecursive(self):\n-        # Topics supported non recursive search, so search at a specific\n-        # depth.  New Collections do not support it.\n-        crit = self.add_criterion(\'path\', \'ATRelativePathCriterion\')\n-        crit.setRelativePath(\'../folder\')\n-        crit.setRecurse(True)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'path\',\n-              \'o\': \'plone.app.querystring.operation.string.relativePath\',\n-              \'v\': \'../folder\'}])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATSimpleIntCriterion(self):\n-        self.add_criterion(\'getObjPositionInParent\', \'ATSimpleIntCriterion\', 7)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.query,\n-                         [{\'i\': \'getObjPositionInParent\',\n-                           \'o\': \'plone.app.querystring.operation.int.is\',\n-                           \'v\': 7}])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.results\n-\n-    def test_ATSimpleIntCriterionMinimum(self):\n-        crit = self.add_criterion(\n-            \'getObjPositionInParent\',\n-            \'ATSimpleIntCriterion\', 6\n-        )\n-        crit.setDirection(\'min\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'getObjPositionInParent\',\n-              \'o\': \'plone.app.querystring.operation.int.largerThan\',\n-              \'v\': 6}]\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATSimpleIntCriterionMaximum(self):\n-        crit = self.add_criterion(\n-            \'getObjPositionInParent\',\n-            \'ATSimpleIntCriterion\',\n-            5\n-        )\n-        crit.setDirection(\'max\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(\n-            self.portal.topic.query,\n-            [{\'i\': \'getObjPositionInParent\',\n-              \'o\': \'plone.app.querystring.operation.int.lessThan\',\n-              \'v\': 5}]\n-        )\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATSimpleIntCriterionBetween(self):\n-        # This is not supported.\n-        crit = self.add_criterion(\n-            \'getObjPositionInParent\',\n-            \'ATSimpleIntCriterion\',\n-            4\n-        )\n-        crit.setDirection(\'min:max\')\n-        crit.setValue2(8)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.query, [])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATSortCriterion(self):\n-        self.add_criterion(\'modified\', \'ATSortCriterion\')\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.sort_on, \'modified\')\n-        self.assertEqual(self.portal.topic.sort_reversed, False)\n-        self.assertEqual(self.portal.topic.query, [])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\n-\n-    def test_ATSortCriterionReversed(self):\n-        crit = self.add_criterion(\'created\', \'ATSortCriterion\')\n-        crit.setReversed(True)\n-        applyProfile(self.portal, \'plone.app.contenttypes:default\')\n-        self.run_migration()\n-        self.assertEqual(self.portal.topic.sort_on, \'created\')\n-        self.assertEqual(self.portal.topic.sort_reversed, True)\n-        self.assertEqual(self.portal.topic.query, [])\n-\n-        # Check that the resulting query does not give an error.\n-        self.portal.topic.getQuery()\ndiff --git a/plone/app/contenttypes/tests/test_upgrades_migrate_to_pa_event.py b/plone/app/contenttypes/tests/test_upgrades_migrate_to_pa_event.py\ndeleted file mode 100644\nindex b494254b..00000000\n--- a/plone/app/contenttypes/tests/test_upgrades_migrate_to_pa_event.py\n+++ /dev/null\n@@ -1,123 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from datetime import datetime\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_TESTING  # noqa\n-from plone.app.contenttypes.testing import TEST_MIGRATION\n-from plone.app.contenttypes.tests.oldtypes import create1_0EventType\n-from plone.app.testing import applyProfile\n-from plone.app.testing import login\n-from plone.app.textfield.value import RichTextValue\n-from plone.event.interfaces import IEventAccessor\n-from Products.CMFCore.utils import getToolByName\n-\n-import unittest\n-\n-\n-class MigrateEventContentTypesTest(unittest.TestCase):\n-\n-    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING\n-\n-    def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        self.request[\'ACTUAL_URL\'] = self.portal.absolute_url()\n-        self.request[\'URL\'] = self.portal.absolute_url()\n-        self.catalog = getToolByName(self.portal, \'portal_catalog\')\n-        self.portal.acl_users.userFolderAddUser(\'admin\',\n-                                                \'secret\',\n-                                                [\'Manager\'],\n-                                                [])\n-        login(self.portal, \'admin\')\n-        self.portal.portal_workflow.setDefaultChain(\n-            \'simple_publication_workflow\')\n-\n-    def tearDown(self):\n-        try:\n-            applyProfile(self.portal, \'plone.app.contenttypes:uninstall\')\n-        except KeyError:\n-            pass\n-\n-    def doUpgradeStep(self, source, dest,\n-                      profile=\'plone.app.contenttypes:default\'):\n-        """Run upgrade step between 2 specified versions"""\n-        ps = getToolByName(self.portal, \'portal_setup\')\n-        upgrades = [\n-            u for u\n-            in ps.listUpgrades(profile, show_old=True)\n-            if u[\'ssource\'] == source and u[\'sdest\'] == dest\n-        ]\n-        self.assertEqual(len(upgrades), 1)\n-\n-        request = self.portal.REQUEST\n-        request.form = dict(\n-            profile_id=profile,\n-            upgrades=[upgrades[0][\'id\']],\n-        )\n-        ps.manage_doUpgrades(request=request)\n-\n-    def createOldEvent(self, container, id, start_date, end_date):\n-        """Create sample event"""\n-        old_event = container[container.invokeFactory(\n-            \'Event\',\n-            id,\n-            location=\'Newbraska\',\n-            start_date=start_date,\n-            end_date=end_date,\n-            attendees=\'Me\\r\\nYou\',\n-            event_url=\'http://woo.com\',\n-            contact_name=\'Frank\',\n-            contact_email=\'me@fra.nk\',\n-            contact_phone=\'+4412345\',\n-        )]\n-        old_event.text = RichTextValue(\n-            raw=u\'Awes\xc3\xbcme\',\n-            mimeType=\'text/plain\',\n-            outputMimeType=\'text/x-html-safe\'\n-        )\n-\n-    @unittest.skipUnless(\n-        TEST_MIGRATION,\n-        \'Migration tests require ATContentTypes\',\n-    )\n-    def test_pact_1_0_dxevent_is_migrated(self):\n-        def getNewEventDetail(obj):\n-            acc = IEventAccessor(obj)\n-            return [\n-                obj.id,\n-                [acc.start.year, acc.start.month, acc.start.day],\n-                [acc.end.year, acc.end.month, acc.end.day],\n-                acc.location,\n-                acc.attendees\n-            ]\n-\n-        # Create some 1.0 Event objects\n-        create1_0EventType(self.portal)\n-        self.portal.invokeFactory(\'Folder\', \'event-folder\')\n-        self.createOldEvent(\n-            self.portal, \'eventa\',\n-            start_date=datetime(2012, 1, 1, 15, 20),\n-            end_date=datetime(2015, 9, 2, 16, 20),\n-        )\n-        self.createOldEvent(\n-            self.portal[\'event-folder\'], \'eventb\',\n-            start_date=datetime(2013, 3, 3, 15, 20),\n-            end_date=datetime(2019, 5, 6, 16, 20),\n-        )\n-\n-        # IEventAccessor? What\'s that?\n-        with self.assertRaisesRegexp(TypeError, \'IEventAccessor\'):\n-            IEventAccessor(self.portal[\'eventa\'])\n-\n-        # Run upgrade step\n-        self.doUpgradeStep(\'1001\', \'1100\')\n-\n-        # Should be able to use IEventAccessor on events now\n-        self.assertEqual(\n-            getNewEventDetail(self.portal[\'eventa\']),\n-            [\'eventa\', [2012, 1, 1], [2015, 9, 2],\n-             u\'Newbraska\', (\'Me\', \'You\')],\n-        )\n-        self.assertEqual(\n-            getNewEventDetail(self.portal[\'event-folder\'][\'eventb\']),\n-            [\'eventb\', [2013, 3, 3], [2019, 5, 6],\n-             u\'Newbraska\', (\'Me\', \'You\')],\n-        )\ndiff --git a/plone/app/contenttypes/utils.py b/plone/app/contenttypes/utils.py\nindex 262fac81..e175c265 100644\n--- a/plone/app/contenttypes/utils.py\n+++ b/plone/app/contenttypes/utils.py\n@@ -1,4 +1,17 @@\n-# -*- coding: utf-8 -*-\n+from plone.dexterity.interfaces import IDexterityFTI\n+from zope.component import queryUtility\n+from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base\n+from zope.interface import alsoProvides\n+from plone.folder.interfaces import IOrdering\n+from Products.CMFCore.utils import getToolByName\n+from zExceptions import NotFound\n+from plone.dexterity.interfaces import IDexterityContent\n+\n+import importlib\n+import logging\n+\n+logger = logging.getLogger(__name__)\n+\n \n DEFAULT_TYPES = [\n     \'Collection\',\n@@ -42,3 +55,85 @@ def replace_link_variables_by_paths(context, url):\n def _replace_variable_by_path(url, variable, obj):\n     path = \'/\'.join(obj.getPhysicalPath())\n     return url.replace(variable, path)\n+\n+\n+def get_old_class_name_string(obj):\n+    """Returns the current class name string."""\n+    return \'{0}.{1}\'.format(obj.__module__, obj.__class__.__name__)\n+\n+\n+def get_portal_type_name_string(obj):\n+    """Returns the klass-attribute of the fti."""\n+    fti = queryUtility(IDexterityFTI, name=obj.portal_type)\n+    print(fti.klass)\n+    print(fti.id)\n+    if not fti:\n+        return False\n+    return fti.klass\n+\n+\n+def migrate_base_class_to_new_class(obj,\n+                                    indexes=None,\n+                                    old_class_name=\'\',\n+                                    new_class_name=\'\',\n+                                    migrate_to_folderish=False,\n+                                    ):\n+    if indexes is None:\n+        indexes = [\'is_folderish\', \'object_provides\']\n+    if not old_class_name:\n+        old_class_name = get_old_class_name_string(obj)\n+    if not new_class_name:\n+        new_class_name = get_portal_type_name_string(obj)\n+        if not new_class_name:\n+            logger.warning(\n+                \'The type {0} has no fti!\'.format(obj.portal_type))\n+            return False\n+\n+    was_item = not isinstance(obj, BTreeFolder2Base)\n+    if old_class_name != new_class_name:\n+        obj_id = obj.getId()\n+        module_name, class_name = new_class_name.rsplit(\'.\', 1)\n+        module = importlib.import_module(module_name)\n+        new_class = getattr(module, class_name)\n+\n+        # update obj class\n+        parent = obj.__parent__\n+        parent._delOb(obj_id)\n+        obj.__class__ = new_class\n+        parent._setOb(obj_id, obj)\n+\n+    is_container = isinstance(obj, BTreeFolder2Base)\n+\n+    if was_item and is_container or migrate_to_folderish and is_container:\n+        alsoProvides(obj, IOrdering)\n+        #  If Itemish becomes Folderish we have to update obj _tree\n+        BTreeFolder2Base._initBTrees(obj)\n+\n+    # reindex\n+    obj.reindexObject(indexes)\n+\n+    return True\n+\n+\n+def list_of_objects_with_changed_base_class(context):\n+    catalog = getToolByName(context, \'portal_catalog\')\n+    for brain in catalog(object_provides=IDexterityContent.__identifier__):\n+        try:\n+            obj = brain.getObject()\n+        except (KeyError, NotFound):\n+            logger.warn(\'Object {0} not found\'.format(brain.getPath()))\n+            continue\n+        if get_portal_type_name_string(obj) != get_old_class_name_string(obj):\n+            yield obj\n+\n+\n+def list_of_changed_base_class_names(context):\n+    """Returns list of class names that are not longer in portal_types."""\n+    changed_base_class_names = {}\n+    for obj in list_of_objects_with_changed_base_class(context):\n+        changed_base_class_name = get_old_class_name_string(obj)\n+        if changed_base_class_name not in changed_base_class_names:\n+            changed_base_class_names[changed_base_class_name] = 1\n+        else:\n+            changed_base_class_names[changed_base_class_name] += 1\n+    return changed_base_class_names\ndiff --git a/setup.py b/setup.py\nindex e318af9e..99c454cf 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -60,7 +60,6 @@ def read(*rnames):\n         "plone.behavior >= 1.3.0",\n         "pytz",\n         "plone.app.z3cform>=1.1.0.dev0",\n-        "six",\n         "zope.deprecation",\n     ],\n     extras_require={\n@@ -69,14 +68,5 @@ def read(*rnames):\n             "plone.app.robotframework [debug] > 0.9.8",  # create image and file content for Image, File and News Item if not given.  # noqa\n             "plone.app.testing [robot] >= 4.2.4",  # we need ROBOT_TEST_LEVEL\n         ],\n-        "archetypes": [\n-            "archetypes.schemaextender",\n-            "Products.ATContentTypes",\n-            "Products.contentmigration >= 2.1.8.dev0",\n-            "plone.app.referenceablebehavior",\n-        ],\n-        "atrefs": [\n-            "plone.app.referenceablebehavior",\n-        ],\n     },\n )\n'

