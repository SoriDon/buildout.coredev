Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2022-05-05T12:26:38+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.cachepurging/commit/42149081147a12047e25edfdb03d12cb6c6645b8

dependencies

Files changed:
M setup.py
D bootstrap.py
D bootstrap.sh
D buildout.cfg

b'diff --git a/bootstrap.py b/bootstrap.py\ndeleted file mode 100644\nindex 2294e35..0000000\n--- a/bootstrap.py\n+++ /dev/null\n@@ -1,217 +0,0 @@\n-##############################################################################\n-#\n-# Copyright (c) 2006 Zope Foundation and Contributors.\n-# All Rights Reserved.\n-#\n-# This software is subject to the provisions of the Zope Public License,\n-# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n-# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED\n-# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n-# FOR A PARTICULAR PURPOSE.\n-#\n-##############################################################################\n-"""Bootstrap a buildout-based project\n-\n-Simply run this script in a directory containing a buildout.cfg.\n-The script accepts buildout command-line options, so you can\n-use the -c option to specify an alternate configuration file.\n-"""\n-\n-import os\n-import shutil\n-import sys\n-import tempfile\n-\n-from optparse import OptionParser\n-\n-tmpeggs = tempfile.mkdtemp()\n-\n-usage = """\\\n-[DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]\n-\n-Bootstraps a buildout-based project.\n-\n-Simply run this script in a directory containing a buildout.cfg, using the\n-Python that you want bin/buildout to use.\n-\n-Note that by using --find-links to point to local resources, you can keep\n-this script from going over the network.\n-"""\n-\n-parser = OptionParser(usage=usage)\n-parser.add_option("-v", "--version", help="use a specific zc.buildout version")\n-\n-parser.add_option(\n-    "-t",\n-    "--accept-buildout-test-releases",\n-    dest="accept_buildout_test_releases",\n-    action="store_true",\n-    default=False,\n-    help=(\n-        "Normally, if you do not specify a --version, the "\n-        "bootstrap script and buildout gets the newest "\n-        "*final* versions of zc.buildout and its recipes and "\n-        "extensions for you.  If you use this flag, "\n-        "bootstrap and buildout will get the newest releases "\n-        "even if they are alphas or betas."\n-    ),\n-)\n-parser.add_option(\n-    "-c",\n-    "--config-file",\n-    help=(\n-        "Specify the path to the buildout configuration " "file to be used."\n-    ),\n-)\n-parser.add_option(\n-    "-f",\n-    "--find-links",\n-    help=("Specify a URL to search for buildout releases"),\n-)\n-parser.add_option(\n-    "--allow-site-packages",\n-    action="store_true",\n-    default=False,\n-    help=("Let bootstrap.py use existing site packages"),\n-)\n-parser.add_option(\n-    "--setuptools-version", help="use a specific setuptools version"\n-)\n-\n-\n-options, args = parser.parse_args()\n-\n-######################################################################\n-# load/install setuptools\n-\n-try:\n-    if options.allow_site_packages:\n-        import setuptools\n-        import pkg_resources\n-    from urllib.request import urlopen\n-except ImportError:\n-    from urllib2 import urlopen\n-\n-ez = {}\n-exec(urlopen("https://bootstrap.pypa.io/ez_setup.py").read(), ez)\n-\n-if not options.allow_site_packages:\n-    # ez_setup imports site, which adds site packages\n-    # this will remove them from the path to ensure that incompatible versions\n-    # of setuptools are not in the path\n-    import site\n-\n-    # inside a virtualenv, there is no \'getsitepackages\'.\n-    # We can\'t remove these reliably\n-    if hasattr(site, "getsitepackages"):\n-        for sitepackage_path in site.getsitepackages():\n-            sys.path[:] = [x for x in sys.path if sitepackage_path not in x]\n-\n-setup_args = dict(to_dir=tmpeggs, download_delay=0)\n-\n-if options.setuptools_version is not None:\n-    setup_args["version"] = options.setuptools_version\n-\n-ez["use_setuptools"](**setup_args)\n-import setuptools\n-import pkg_resources\n-\n-# This does not (always?) update the default working set.  We will\n-# do it.\n-for path in sys.path:\n-    if path not in pkg_resources.working_set.entries:\n-        pkg_resources.working_set.add_entry(path)\n-\n-######################################################################\n-# Install buildout\n-\n-ws = pkg_resources.working_set\n-\n-cmd = [\n-    sys.executable,\n-    "-c",\n-    "from setuptools.command.easy_install import main; main()",\n-    "-mZqNxd",\n-    tmpeggs,\n-]\n-\n-find_links = os.environ.get(\n-    "bootstrap-testing-find-links",\n-    options.find_links\n-    or (\n-        "http://downloads.buildout.org/"\n-        if options.accept_buildout_test_releases\n-        else None\n-    ),\n-)\n-if find_links:\n-    cmd.extend(["-f", find_links])\n-\n-setuptools_path = ws.find(\n-    pkg_resources.Requirement.parse("setuptools")\n-).location\n-\n-requirement = "zc.buildout"\n-version = options.version\n-if version is None and not options.accept_buildout_test_releases:\n-    # Figure out the most recent final version of zc.buildout.\n-    import setuptools.package_index\n-\n-    _final_parts = "*final-", "*final"\n-\n-    def _final_version(parsed_version):\n-        try:\n-            return not parsed_version.is_prerelease\n-        except AttributeError:\n-            # Older setuptools\n-            for part in parsed_version:\n-                if (part[:1] == "*") and (part not in _final_parts):\n-                    return False\n-            return True\n-\n-    index = setuptools.package_index.PackageIndex(\n-        search_path=[setuptools_path]\n-    )\n-    if find_links:\n-        index.add_find_links((find_links,))\n-    req = pkg_resources.Requirement.parse(requirement)\n-    if index.obtain(req) is not None:\n-        best = []\n-        bestv = None\n-        for dist in index[req.project_name]:\n-            distv = dist.parsed_version\n-            if _final_version(distv):\n-                if bestv is None or distv > bestv:\n-                    best = [dist]\n-                    bestv = distv\n-                elif distv == bestv:\n-                    best.append(dist)\n-        if best:\n-            best.sort()\n-            version = best[-1].version\n-if version:\n-    requirement = "==".join((requirement, version))\n-cmd.append(requirement)\n-\n-import subprocess\n-\n-if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:\n-    raise Exception("Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n-\n-######################################################################\n-# Import and run buildout\n-\n-ws.add_entry(tmpeggs)\n-ws.require(requirement)\n-import zc.buildout.buildout\n-\n-if not [a for a in args if "=" not in a]:\n-    args.append("bootstrap")\n-\n-# if -c was provided, we push it back into args for buildout\' main function\n-if options.config_file is not None:\n-    args[0:0] = ["-c", options.config_file]\n-\n-zc.buildout.buildout.main(args)\n-shutil.rmtree(tmpeggs)\ndiff --git a/bootstrap.sh b/bootstrap.sh\ndeleted file mode 100755\nindex d764997..0000000\n--- a/bootstrap.sh\n+++ /dev/null\n@@ -1,7 +0,0 @@\n-#!/bin/sh\n-\n-# see https://community.plone.org/t/not-using-bootstrap-py-as-default/620\n-rm -r ./lib ./include ./local ./bin\n-virtualenv --clear .\n-./bin/pip install --upgrade pip setuptools zc.buildout\n-./bin/buildout\ndiff --git a/buildout.cfg b/buildout.cfg\ndeleted file mode 100644\nindex 52c130a..0000000\n--- a/buildout.cfg\n+++ /dev/null\n@@ -1,18 +0,0 @@\n-[buildout]\n-parts = test\n-        omelette\n-versions = versions\n-\n-extends = http://dist.plone.org/release/5.1-latest/versions.cfg\n-develop = .\n-\n-[versions]\n-plone.cachepurging = \n-\n-[test]\n-recipe = zc.recipe.testrunner\n-eggs = plone.cachepurging [test]\n-\n-[omelette]\n-recipe = collective.recipe.omelette\n-eggs = ${test:eggs}\ndiff --git a/setup.py b/setup.py\nindex 5b587f3..f8ec5c3 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,6 +1,6 @@\n from setuptools import setup, find_packages\n \n-version = \'2.0.5.dev0\'\n+version = \'3.0.0a1.dev0\'\n \n setup(\n     name="plone.cachepurging",\n@@ -12,13 +12,10 @@\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Framework :: Plone",\n-        "Framework :: Plone :: 5.2",\n         "Framework :: Plone :: 6.0",\n         "Framework :: Plone :: Core",\n         "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n         "Programming Language :: Python",\n-        "Programming Language :: Python :: 2.7",\n-        "Programming Language :: Python :: 3.6",\n         "Programming Language :: Python :: 3.7",\n         "Programming Language :: Python :: 3.8",\n         "Programming Language :: Python :: 3.9",\n@@ -36,17 +33,8 @@\n         "setuptools",\n         "plone.registry",\n         "requests",\n-        "six",\n         "z3c.caching",\n-        "zope.annotation",\n-        "zope.component",\n-        "zope.event",\n-        "zope.i18nmessageid",\n-        "zope.interface",\n-        "zope.lifecycleevent",\n-        "zope.schema",\n-        "zope.testing",\n-        "Zope2",\n+        "Zope",\n     ],\n     extras_require={"test": ["plone.app.testing"]},\n )\n'

Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2022-05-05T12:27:05+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.cachepurging/commit/8e3803a9b665e8bf9b9a999f0049884603a0060e

improve isort rules

Files changed:
M setup.cfg
M setup.py

b"diff --git a/setup.cfg b/setup.cfg\nindex 7feabc9..957bc4d 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -5,13 +5,12 @@ ignore =\n     bootstrap.py\n \n [isort]\n-force_alphabetical_sort=True\n-force_single_line=True\n-lines_after_imports=2\n-line_length=200\n-not_skip=__init__.py\n-\n-\n+# black compatible Plone isort rules:\n+profile = black\n+force_alphabetical_sort = True\n+force_single_line = True\n+lines_after_imports = 2\n \n [bdist_wheel]\n universal = 1\n+\ndiff --git a/setup.py b/setup.py\nindex f8ec5c3..835c247 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,4 +1,6 @@\n-from setuptools import setup, find_packages\n+from setuptools import find_packages\n+from setuptools import setup\n+\n \n version = '3.0.0a1.dev0'\n \n"

Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2022-05-05T12:27:16+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.cachepurging/commit/0be1c605580a5ff2349a0e083c6109b007d4bb5f

black

Files changed:
M plone/cachepurging/browser.py
M plone/cachepurging/hooks.py
M plone/cachepurging/interfaces.py
M plone/cachepurging/paths.py
M plone/cachepurging/purger.py
M plone/cachepurging/rewrite.py
M plone/cachepurging/tests/test_hooks.py
M plone/cachepurging/tests/test_purger.py
M plone/cachepurging/tests/test_rewrite.py
M plone/cachepurging/tests/test_utils.py
M plone/cachepurging/tests/test_views.py
M plone/cachepurging/utils.py
M setup.py

b'diff --git a/plone/cachepurging/browser.py b/plone/cachepurging/browser.py\nindex dbd7628..fe5d853 100644\n--- a/plone/cachepurging/browser.py\n+++ b/plone/cachepurging/browser.py\n@@ -11,15 +11,14 @@\n \n \n class QueuePurge(object):\n-    """Manually initiate a purge\n-    """\n+    """Manually initiate a purge"""\n \n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n \n     def __call__(self):\n-        self.request.response.setHeader(\'Content-type\', \'text/plain\')\n+        self.request.response.setHeader("Content-type", "text/plain")\n         if not isCachePurgingEnabled():\n             return "Cache purging not enabled"\n \n@@ -30,8 +29,7 @@ def __call__(self):\n \n \n class PurgeImmediately(object):\n-    """Purge immediately\n-    """\n+    """Purge immediately"""\n \n     def __init__(self, context, request):\n         self.context = context\n@@ -43,7 +41,7 @@ def write(self, msg):\n         self.request.response.write(msg)\n \n     def __call__(self):\n-        self.request.response.setHeader(\'Content-type\', \'text/plain\')\n+        self.request.response.setHeader("Content-type", "text/plain")\n         if not isCachePurgingEnabled():\n             return "Cache purging not enabled"\n \n@@ -54,8 +52,10 @@ def __call__(self):\n         caching_proxies = settings.cachingProxies\n         traceback = self.request.form.get("traceback")\n         if not traceback:\n-            self.write("(hint: add \'?traceback\' to url to show full traceback in case of errors)\\n\\n")\n-        self.write("Proxies to purge: {0}\\n".format(\', \'.join(caching_proxies)))\n+            self.write(\n+                "(hint: add \'?traceback\' to url to show full traceback in case of errors)\\n\\n"\n+            )\n+        self.write("Proxies to purge: {0}\\n".format(", ".join(caching_proxies)))\n         for path in getPathsToPurge(self.context, self.request):\n             self.write("- process path: {0}\\n".format(path))\n             for url in getURLsToPurge(path, caching_proxies):\n@@ -63,8 +63,7 @@ def __call__(self):\n                 status, xcache, xerror = purger.purgeSync(url)\n                 self.write(\n                     "    response with status: {status}, X-Cache: {xcache}\\n".format(\n-                        status=status,\n-                        xcache=xcache\n+                        status=status, xcache=xcache\n                     )\n                 )\n                 if traceback and xerror:\ndiff --git a/plone/cachepurging/hooks.py b/plone/cachepurging/hooks.py\nindex 7253ed9..9eef7c4 100644\n--- a/plone/cachepurging/hooks.py\n+++ b/plone/cachepurging/hooks.py\n@@ -18,8 +18,7 @@\n \n @adapter(IPurgeEvent)\n def queuePurge(event):\n-    """Find URLs to purge and queue them for later\n-    """\n+    """Find URLs to purge and queue them for later"""\n \n     request = getRequest()\n     if request is None:\n@@ -38,8 +37,7 @@ def queuePurge(event):\n \n @adapter(IPubSuccess)\n def purge(event):\n-    """Asynchronously send PURGE requests\n-    """\n+    """Asynchronously send PURGE requests"""\n \n     request = event.request\n \ndiff --git a/plone/cachepurging/interfaces.py b/plone/cachepurging/interfaces.py\nindex 363eb71..0ef303e 100644\n--- a/plone/cachepurging/interfaces.py\n+++ b/plone/cachepurging/interfaces.py\n@@ -89,8 +89,7 @@ def __call__(path):\n \n \n class IPurger(Interface):\n-    """A utility used to manage the purging process.\n-    """\n+    """A utility used to manage the purging process."""\n \n     def purgeAsync(url, httpVerb="PURGE"):\n         """Send a PURGE request to a particular URL asynchronously in a\n@@ -121,6 +120,4 @@ def stopThreads(wait=False):\n         default=("x-squid-error",),\n     )\n \n-    http_1_1 = schema.Bool(\n-        title=u"Use HTTP 1.1 for PURGE request", default=True\n-    )\n+    http_1_1 = schema.Bool(title=u"Use HTTP 1.1 for PURGE request", default=True)\ndiff --git a/plone/cachepurging/paths.py b/plone/cachepurging/paths.py\nindex 1f4b0cf..0ab5e18 100644\n--- a/plone/cachepurging/paths.py\n+++ b/plone/cachepurging/paths.py\n@@ -8,8 +8,7 @@\n @implementer(IPurgePaths)\n @adapter(ITraversable)\n class TraversablePurgePaths(object):\n-    """Default purge for OFS.Traversable-style objects\n-    """\n+    """Default purge for OFS.Traversable-style objects"""\n \n     def __init__(self, context):\n         self.context = context\ndiff --git a/plone/cachepurging/purger.py b/plone/cachepurging/purger.py\nindex 7879e32..d47c359 100644\n--- a/plone/cachepurging/purger.py\n+++ b/plone/cachepurging/purger.py\n@@ -34,9 +34,7 @@\n \n @implementer(IPurger)\n class DefaultPurger(object):\n-    def __init__(\n-        self, timeout=(3, 27), backlog=0, errorHeaders=("x-squid-error",)\n-    ):\n+    def __init__(self, timeout=(3, 27), backlog=0, errorHeaders=("x-squid-error",)):\n         self.timeout = timeout\n         self.queues = {}\n         self.workers = {}\n@@ -62,9 +60,7 @@ def purge(self, session, url, httpVerb="PURGE"):\n             if xerror:\n                 # Break on first found.\n                 break\n-        logger.debug(\n-            "%s of %s: %s %s", httpVerb, url, resp.status_code, resp.reason\n-        )\n+        logger.debug("%s of %s: %s %s", httpVerb, url, resp.status_code, resp.reason)\n         return resp, xcache, xerror\n \n     def purgeSync(self, url, httpVerb="PURGE"):\n@@ -83,9 +79,7 @@ def purgeSync(self, url, httpVerb="PURGE"):\n             # Avoid leaking a ref to traceback.\n             del err, msg, tb\n             xcache = ""\n-        logger.debug(\n-            "Finished %s for %s: %s %s" % (httpVerb, url, status, xcache)\n-        )\n+        logger.debug("Finished %s for %s: %s %s" % (httpVerb, url, status, xcache))\n         if xerror:\n             logger.debug("Error while purging %s:\\n%s" % (url, xerror))\n         logger.debug("Completed synchronous purge of %s", url)\n@@ -123,10 +117,7 @@ def stopThreads(self, wait=False):\n             for worker in six.itervalues(self.workers):\n                 worker.join(5)\n                 if worker.is_alive():\n-                    logger.warning(\n-                        "Worker thread %s failed to terminate",\n-                        worker\n-                    )\n+                    logger.warning("Worker thread %s failed to terminate", worker)\n                     return False\n         return True\n \n@@ -141,17 +132,11 @@ def getQueueAndWorker(self, url):\n             self.queueLock.acquire()\n             try:\n                 if key not in self.queues:\n-                    logger.debug(\n-                        "Creating worker thread for %s://%s", scheme, host\n-                    )\n+                    logger.debug("Creating worker thread for %s://%s", scheme, host)\n                     if key in self.workers:\n-                        raise ValueError(\n-                            "Queue Key must not already exist in workers"\n-                        )\n+                        raise ValueError("Queue Key must not already exist in workers")\n                     self.queues[key] = queue_ = queue.Queue(self.backlog)\n-                    self.workers[key] = worker = Worker(\n-                        queue_, host, scheme, self\n-                    )\n+                    self.workers[key] = worker = Worker(queue_, host, scheme, self)\n                     worker.start()\n             finally:\n                 self.queueLock.release()\n@@ -163,8 +148,7 @@ def http_1_1(self):\n \n \n class Worker(threading.Thread):\n-    """Worker thread for purging.\n-    """\n+    """Worker thread for purging."""\n \n     def __init__(self, queue, host, scheme, producer):\n         self.host = host\n@@ -172,9 +156,7 @@ def __init__(self, queue, host, scheme, producer):\n         self.producer = producer\n         self.queue = queue\n         self.stopping = False\n-        super(Worker, self).__init__(\n-            name="PurgeThread for %s://%s" % (scheme, host)\n-        )\n+        super(Worker, self).__init__(name="PurgeThread for %s://%s" % (scheme, host))\n \n     def stop(self):\n         self.stopping = True\n@@ -204,16 +186,12 @@ def run(self):\n                             break\n                         # Got an item, purge it!\n                         try:\n-                            resp, msg, err = self.producer.purge(\n-                                session, url, httpVerb\n-                            )\n+                            resp, msg, err = self.producer.purge(session, url, httpVerb)\n                             if resp.status_code == requests.codes.ok:\n                                 break  # all done with this item!\n                             if resp.status_code == requests.codes.not_found:\n                                 # not found is valid\n-                                logger.debug(\n-                                    "Purge URL not found: {0}".format(url)\n-                                )\n+                                logger.debug("Purge URL not found: {0}".format(url))\n                                 break  # all done with this item!\n                         except Exception:\n                             # All other exceptions are evil - we just disard\n@@ -228,8 +206,7 @@ def run(self):\n \n         except Exception:\n             logger.exception(\n-                "Exception in worker thread "\n-                "for (%s, %s)" % (self.host, self.scheme)\n+                "Exception in worker thread " "for (%s, %s)" % (self.host, self.scheme)\n             )\n         logger.debug("%s terminating", self)\n \ndiff --git a/plone/cachepurging/rewrite.py b/plone/cachepurging/rewrite.py\nindex a3424f8..78207b8 100644\n--- a/plone/cachepurging/rewrite.py\n+++ b/plone/cachepurging/rewrite.py\n@@ -12,8 +12,7 @@\n @implementer(IPurgePathRewriter)\n @adapter(Interface)\n class DefaultRewriter(object):\n-    """Default rewriter, which is aware of virtual hosting\n-    """\n+    """Default rewriter, which is aware of virtual hosting"""\n \n     def __init__(self, request):\n         self.request = request\n@@ -65,9 +64,7 @@ def __call__(self, path):\n         # Prefix, e.g. /_vh_foo/_vh_bar. Clear if we don\'t have any.\n         pathPrefix = len(virtualUrlParts) == 3 and virtualUrlParts[1] or ""\n         if pathPrefix:\n-            pathPrefix = "/" + "/".join(\n-                ["_vh_%s" % p for p in pathPrefix.split("/")]\n-            )\n+            pathPrefix = "/" + "/".join(["_vh_%s" % p for p in pathPrefix.split("/")])\n \n         # Path, e.g. /front-page\n         if len(path) > 0 and not path.startswith("/"):\ndiff --git a/plone/cachepurging/tests/test_hooks.py b/plone/cachepurging/tests/test_hooks.py\nindex 8e7fb94..0eff841 100644\n--- a/plone/cachepurging/tests/test_hooks.py\n+++ b/plone/cachepurging/tests/test_hooks.py\n@@ -317,9 +317,7 @@ def test_no_registry(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)["plone.cachepurging.urls"] = set(\n-            ["/foo", "/bar"]\n-        )\n+        IAnnotations(request)["plone.cachepurging.urls"] = set(["/foo", "/bar"])\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n@@ -340,9 +338,7 @@ def test_caching_disabled(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)["plone.cachepurging.urls"] = set(\n-            ["/foo", "/bar"]\n-        )\n+        IAnnotations(request)["plone.cachepurging.urls"] = set(["/foo", "/bar"])\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -371,9 +367,7 @@ def test_no_purger(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)["plone.cachepurging.urls"] = set(\n-            ["/foo", "/bar"]\n-        )\n+        IAnnotations(request)["plone.cachepurging.urls"] = set(["/foo", "/bar"])\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -392,9 +386,7 @@ def test_purge(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)["plone.cachepurging.urls"] = set(\n-            ["/foo", "/bar"]\n-        )\n+        IAnnotations(request)["plone.cachepurging.urls"] = set(["/foo", "/bar"])\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\ndiff --git a/plone/cachepurging/tests/test_purger.py b/plone/cachepurging/tests/test_purger.py\nindex 246d18a..2ec044b 100644\n--- a/plone/cachepurging/tests/test_purger.py\n+++ b/plone/cachepurging/tests/test_purger.py\n@@ -173,7 +173,7 @@ def testAsyncError(self):\n         self.dispatchURL("/bar")  # will consume error, then retry\n         self.assertTrue(\n             self.httpd.response_queue.empty(),\n-            "Left items behind in HTTPD response queue."\n+            "Left items behind in HTTPD response queue.",\n         )\n \n     def testAsyncNotFOund(self):\n@@ -181,13 +181,12 @@ def testAsyncNotFOund(self):\n         self.httpd.queue_response(response=200)\n         self.dispatchURL("/foo")  # works\n         self.assertFalse(\n-            self.httpd.response_queue.empty(),\n-            "404 was retried instead of consumed."\n+            self.httpd.response_queue.empty(), "404 was retried instead of consumed."\n         )\n         self.dispatchURL("/foo")  # works\n         self.assertTrue(\n             self.httpd.response_queue.empty(),\n-            "Left items behind in HTTPD response queue."\n+            "Left items behind in HTTPD response queue.",\n         )\n \n \ndiff --git a/plone/cachepurging/tests/test_rewrite.py b/plone/cachepurging/tests/test_rewrite.py\nindex 49e5193..16ac002 100644\n--- a/plone/cachepurging/tests/test_rewrite.py\n+++ b/plone/cachepurging/tests/test_rewrite.py\n@@ -42,10 +42,14 @@ def _prepareVHMRequest(\n             path,\n         )\n         self.request["SERVER_URL"] = "%s://%s" % (protocol, domain)\n-        self.request["PATH_INFO"] = (\n-            "/VirtualHostBase/%s/%s:80%s/"\n-            "VirtualHostRoot%s%s"\n-            % (protocol, domain, root, translatedPrefix, path)\n+        self.request[\n+            "PATH_INFO"\n+        ] = "/VirtualHostBase/%s/%s:80%s/" "VirtualHostRoot%s%s" % (\n+            protocol,\n+            domain,\n+            root,\n+            translatedPrefix,\n+            path,\n         )\n         self.request["VIRTUAL_URL"] = "%s://%s%s" % (protocol, domain, path)\n \n@@ -189,10 +193,7 @@ def test_virtual_root_is_deep(self):\n         self._prepareVHMRequest("/foo", root="/bar/plone")\n \n         self.assertEqual(\n-            [\n-                "/VirtualHostBase/http/example.com/bar/plone/"\n-                "VirtualHostRoot/foo"\n-            ],\n+            ["/VirtualHostBase/http/example.com/bar/plone/" "VirtualHostRoot/foo"],\n             self.rewriter("/foo"),\n         )\n \n@@ -223,10 +224,7 @@ def test_inside_out_hosting_root_empty_path(self):\n         self._prepareVHMRequest("/", root="/plone", prefix="/plone")\n \n         self.assertEqual(\n-            [\n-                "/VirtualHostBase/http/example.com/plone/"\n-                "VirtualHostRoot/_vh_plone"\n-            ],\n+            ["/VirtualHostBase/http/example.com/plone/" "VirtualHostRoot/_vh_plone"],\n             self.rewriter(""),\n         )\n \n@@ -268,10 +266,7 @@ def test_virtual_path_is_deep(self):\n         self._prepareVHMRequest("/foo/bar", root="/plone")\n \n         self.assertEqual(\n-            [\n-                "/VirtualHostBase/http/example.com/plone/"\n-                "VirtualHostRoot/foo/bar"\n-            ],\n+            ["/VirtualHostBase/http/example.com/plone/" "VirtualHostRoot/foo/bar"],\n             self.rewriter("/foo/bar"),\n         )\n \n@@ -295,14 +290,9 @@ def test_https(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\n-            "/foo", domain="example.com:81", protocol="https"\n-        )\n+        self._prepareVHMRequest("/foo", domain="example.com:81", protocol="https")\n         self.assertEqual(\n-            [\n-                "/VirtualHostBase/https/example.com:81/plone/"\n-                "VirtualHostRoot/foo"\n-            ],\n+            ["/VirtualHostBase/https/example.com:81/plone/" "VirtualHostRoot/foo"],\n             self.rewriter("/foo"),\n         )\n \n@@ -314,15 +304,11 @@ def test_domains(self):\n         settings.virtualHosting = True\n         settings.domains = ("http://example.org:81", "https://example.com:82")\n \n-        self._prepareVHMRequest(\n-            "/foo", domain="example.com:81", protocol="https"\n-        )\n+        self._prepareVHMRequest("/foo", domain="example.com:81", protocol="https")\n         self.assertEqual(\n             [\n-                "/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/"\n-                "foo",\n-                "/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/"\n-                "foo",\n+                "/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/" "foo",\n+                "/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/" "foo",\n             ],\n             self.rewriter("/foo"),\n         )\n@@ -335,15 +321,11 @@ def test_domains_w_different_path_in_request(self):\n         settings.virtualHosting = True\n         settings.domains = ("http://example.org:81", "https://example.com:82")\n \n-        self._prepareVHMRequest(\n-            "/bar", domain="example.com:81", protocol="https"\n-        )\n+        self._prepareVHMRequest("/bar", domain="example.com:81", protocol="https")\n         self.assertEqual(\n             [\n-                "/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/"\n-                "foo",\n-                "/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/"\n-                "foo",\n+                "/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/" "foo",\n+                "/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/" "foo",\n             ],\n             self.rewriter("/foo"),\n         )\ndiff --git a/plone/cachepurging/tests/test_utils.py b/plone/cachepurging/tests/test_utils.py\nindex 73b3dfb..66b3198 100644\n--- a/plone/cachepurging/tests/test_utils.py\n+++ b/plone/cachepurging/tests/test_utils.py\n@@ -77,9 +77,7 @@ def tearDown(self):\n         zope.component.testing.tearDown()\n \n     def test_no_purge_paths(self):\n-        self.assertEqual(\n-            [], list(utils.getPathsToPurge(self.context, self.request))\n-        )\n+        self.assertEqual([], list(utils.getPathsToPurge(self.context, self.request)))\n \n     def test_empty_relative_paths(self):\n         @implementer(IPurgePaths)\n@@ -96,9 +94,7 @@ def getAbsolutePaths(self):\n \n         provideAdapter(FauxPurgePaths, name="test1")\n \n-        self.assertEqual(\n-            [], list(utils.getPathsToPurge(self.context, self.request))\n-        )\n+        self.assertEqual([], list(utils.getPathsToPurge(self.context, self.request)))\n \n     def test_no_rewriter(self):\n         @implementer(IPurgePaths)\ndiff --git a/plone/cachepurging/tests/test_views.py b/plone/cachepurging/tests/test_views.py\nindex acc487a..508689e 100644\n--- a/plone/cachepurging/tests/test_views.py\n+++ b/plone/cachepurging/tests/test_views.py\n@@ -23,7 +23,6 @@ class FauxContext(object):\n \n \n class FauxResponse(object):\n-\n     def __init__(self):\n         self.buffer = []\n \n@@ -43,7 +42,6 @@ def __init__(self, *args, **kw):\n         self.response = FauxResponse()\n \n \n-\n class Handler(object):\n     def __init__(self):\n         self.invocations = []\n@@ -132,16 +130,16 @@ def test_purge(self):\n         view = PurgeImmediately(FauxContext(), request)()\n         self.assertEqual(\n             [\n-                b\'Cache purging initiated...\\n\\n\',\n+                b"Cache purging initiated...\\n\\n",\n                 b"(hint: add \'?traceback\' to url to show full traceback in case of errors)\\n\\n",\n-                b\'Proxies to purge: http://localhost:1234\\n\',\n-                b\'- process path: /foo\\n\',\n-                b\'  - send to purge http://localhost:1234/foo\\n\',\n-                b\'    response with status: 200 OK, X-Cache: cached\\n\',\n-                b\'- process path: /bar\\n\',\n-                b\'  - send to purge http://localhost:1234/bar\\n\',\n-                b\'    response with status: 200 OK, X-Cache: cached\\n\',\n-                b\'Done.\\n\'\n+                b"Proxies to purge: http://localhost:1234\\n",\n+                b"- process path: /foo\\n",\n+                b"  - send to purge http://localhost:1234/foo\\n",\n+                b"    response with status: 200 OK, X-Cache: cached\\n",\n+                b"- process path: /bar\\n",\n+                b"  - send to purge http://localhost:1234/bar\\n",\n+                b"    response with status: 200 OK, X-Cache: cached\\n",\n+                b"Done.\\n",\n             ],\n             request.response.buffer,\n         )\ndiff --git a/plone/cachepurging/utils.py b/plone/cachepurging/utils.py\nindex 73d67ec..60a33de 100644\n--- a/plone/cachepurging/utils.py\n+++ b/plone/cachepurging/utils.py\n@@ -8,8 +8,7 @@\n \n \n def isCachePurgingEnabled(registry=None):\n-    """Return True if caching is enabled\n-    """\n+    """Return True if caching is enabled"""\n \n     if registry is None:\n         registry = queryUtility(IRegistry)\ndiff --git a/setup.py b/setup.py\nindex 835c247..bb2c57f 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -2,15 +2,13 @@\n from setuptools import setup\n \n \n-version = \'3.0.0a1.dev0\'\n+version = "3.0.0a1.dev0"\n \n setup(\n     name="plone.cachepurging",\n     version=version,\n     description="Cache purging support for Zope 2 applications",\n-    long_description=(\n-        open("README.rst").read() + "\\n" + open("CHANGES.rst").read()\n-    ),\n+    long_description=(open("README.rst").read() + "\\n" + open("CHANGES.rst").read()),\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Framework :: Plone",\n'

Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2022-05-05T12:27:42+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.cachepurging/commit/e02551391a09369b496343d772fc86ea8c7e064d

find  -name "*.py" -exec pyupgrade  --py3-only --py37-plus {} +

Files changed:
M plone/__init__.py
M plone/cachepurging/browser.py
M plone/cachepurging/hooks.py
M plone/cachepurging/interfaces.py
M plone/cachepurging/paths.py
M plone/cachepurging/purger.py
M plone/cachepurging/rewrite.py
M plone/cachepurging/tests/test_hooks.py
M plone/cachepurging/tests/test_purger.py
M plone/cachepurging/tests/test_rewrite.py
M plone/cachepurging/tests/test_traversable_paths.py
M plone/cachepurging/tests/test_utils.py
M plone/cachepurging/tests/test_views.py
M plone/cachepurging/utils.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex 03d08ff..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n __import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/cachepurging/browser.py b/plone/cachepurging/browser.py\nindex fe5d853..a5bcc7e 100644\n--- a/plone/cachepurging/browser.py\n+++ b/plone/cachepurging/browser.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.interfaces import ICachePurgingSettings\n from plone.cachepurging.interfaces import IPurger\n from plone.cachepurging.utils import getPathsToPurge\n@@ -10,7 +9,7 @@\n from zope.event import notify\n \n \n-class QueuePurge(object):\n+class QueuePurge:\n     """Manually initiate a purge"""\n \n     def __init__(self, context, request):\n@@ -25,10 +24,10 @@ def __call__(self):\n         paths = getPathsToPurge(self.context, self.request)\n \n         notify(Purge(self.context))\n-        return "Queued:\\n\\n{0}".format("\\n".join(paths))\n+        return "Queued:\\n\\n{}".format("\\n".join(paths))\n \n \n-class PurgeImmediately(object):\n+class PurgeImmediately:\n     """Purge immediately"""\n \n     def __init__(self, context, request):\n@@ -55,11 +54,11 @@ def __call__(self):\n             self.write(\n                 "(hint: add \'?traceback\' to url to show full traceback in case of errors)\\n\\n"\n             )\n-        self.write("Proxies to purge: {0}\\n".format(", ".join(caching_proxies)))\n+        self.write("Proxies to purge: {}\\n".format(", ".join(caching_proxies)))\n         for path in getPathsToPurge(self.context, self.request):\n-            self.write("- process path: {0}\\n".format(path))\n+            self.write(f"- process path: {path}\\n")\n             for url in getURLsToPurge(path, caching_proxies):\n-                self.write("  - send to purge {0}\\n".format(url).encode("utf-8"))\n+                self.write(f"  - send to purge {url}\\n".encode("utf-8"))\n                 status, xcache, xerror = purger.purgeSync(url)\n                 self.write(\n                     "    response with status: {status}, X-Cache: {xcache}\\n".format(\ndiff --git a/plone/cachepurging/hooks.py b/plone/cachepurging/hooks.py\nindex 9eef7c4..c3ed297 100644\n--- a/plone/cachepurging/hooks.py\n+++ b/plone/cachepurging/hooks.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.interfaces import ICachePurgingSettings\n from plone.cachepurging.interfaces import IPurger\n from plone.cachepurging.utils import getPathsToPurge\ndiff --git a/plone/cachepurging/interfaces.py b/plone/cachepurging/interfaces.py\nindex 0ef303e..e2e93d4 100644\n--- a/plone/cachepurging/interfaces.py\n+++ b/plone/cachepurging/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope import schema\n from zope.i18nmessageid import MessageFactory\n from zope.interface import Interface\n@@ -14,57 +13,57 @@ class ICachePurgingSettings(Interface):\n     """\n \n     enabled = schema.Bool(\n-        title=_(u"Enable purging"),\n-        description=_(u"If disabled, no purging will take place"),\n+        title=_("Enable purging"),\n+        description=_("If disabled, no purging will take place"),\n         default=True,\n     )\n \n     cachingProxies = schema.Tuple(\n-        title=_(u"Caching proxies"),\n+        title=_("Caching proxies"),\n         description=_(\n-            u"Provide the URLs of each proxy to which PURGE "\n-            u"requests should be sent."\n+            "Provide the URLs of each proxy to which PURGE "\n+            "requests should be sent."\n         ),\n         value_type=schema.URI(),\n     )\n \n     virtualHosting = schema.Bool(\n-        title=_(u"Send PURGE requests with virtual hosting paths"),\n+        title=_("Send PURGE requests with virtual hosting paths"),\n         description=_(\n-            u"This option is only relevant if you are using "\n-            u"virtual hosting with Zope\'s VirtualHostMonster. "\n-            u"This relies on special tokens (VirtualHostBase "\n-            u"and VirtualHostRoot) in the URL to instruct "\n-            u"Zope about the types of URLs that the user sees. "\n-            u"If virtual host URLs are in use and this option "\n-            u"is set, PURGE requests will be sent to the "\n-            u"caching proxy with the virtual hosting tokens "\n-            u"in place. This makes sense if there is a web "\n-            u"server in front of your caching proxy performing "\n-            u"the rewrites necessary to translate a user-"\n-            u"facing URL into a virtual hosting URL, so that "\n-            u"the requests the caching proxy sees have the "\n-            u"rewrite information in them. Conversely, if the "\n-            u"rewrite is done in or behind the caching proxy, "\n-            u"you want to disable this option, so that the "\n-            u"PURGE requests use URLs that match those seen "\n-            u"by the caching proxy as they come from the "\n-            u"client."\n+            "This option is only relevant if you are using "\n+            "virtual hosting with Zope\'s VirtualHostMonster. "\n+            "This relies on special tokens (VirtualHostBase "\n+            "and VirtualHostRoot) in the URL to instruct "\n+            "Zope about the types of URLs that the user sees. "\n+            "If virtual host URLs are in use and this option "\n+            "is set, PURGE requests will be sent to the "\n+            "caching proxy with the virtual hosting tokens "\n+            "in place. This makes sense if there is a web "\n+            "server in front of your caching proxy performing "\n+            "the rewrites necessary to translate a user-"\n+            "facing URL into a virtual hosting URL, so that "\n+            "the requests the caching proxy sees have the "\n+            "rewrite information in them. Conversely, if the "\n+            "rewrite is done in or behind the caching proxy, "\n+            "you want to disable this option, so that the "\n+            "PURGE requests use URLs that match those seen "\n+            "by the caching proxy as they come from the "\n+            "client."\n         ),\n         required=True,\n         default=False,\n     )\n \n     domains = schema.Tuple(\n-        title=_(u"Domains"),\n+        title=_("Domains"),\n         description=_(\n-            u"This option is only relevant if you are using "\n-            u"virtual hosting and you have enabled the option "\n-            u"to send PURGE requests with virtual hosting URLs "\n-            u"above. If you your site is served on multiple "\n-            u"domains e.g. http://example.org and "\n-            u"http://www.example.org you may wish to purge "\n-            u"both. If so, list all your domains here"\n+            "This option is only relevant if you are using "\n+            "virtual hosting and you have enabled the option "\n+            "to send PURGE requests with virtual hosting URLs "\n+            "above. If you your site is served on multiple "\n+            "domains e.g. http://example.org and "\n+            "http://www.example.org you may wish to purge "\n+            "both. If so, list all your domains here"\n         ),\n         required=False,\n         default=(),\n@@ -115,9 +114,9 @@ def stopThreads(wait=False):\n         """\n \n     errorHeaders = schema.Tuple(\n-        title=u"Error header names",\n+        title="Error header names",\n         value_type=schema.ASCIILine(),\n         default=("x-squid-error",),\n     )\n \n-    http_1_1 = schema.Bool(title=u"Use HTTP 1.1 for PURGE request", default=True)\n+    http_1_1 = schema.Bool(title="Use HTTP 1.1 for PURGE request", default=True)\ndiff --git a/plone/cachepurging/paths.py b/plone/cachepurging/paths.py\nindex 0ab5e18..0866b45 100644\n--- a/plone/cachepurging/paths.py\n+++ b/plone/cachepurging/paths.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from OFS.interfaces import ITraversable\n from z3c.caching.interfaces import IPurgePaths\n from zope.component import adapter\n@@ -7,7 +6,7 @@\n \n @implementer(IPurgePaths)\n @adapter(ITraversable)\n-class TraversablePurgePaths(object):\n+class TraversablePurgePaths:\n     """Default purge for OFS.Traversable-style objects"""\n \n     def __init__(self, context):\ndiff --git a/plone/cachepurging/purger.py b/plone/cachepurging/purger.py\nindex d47c359..2d30980 100644\n--- a/plone/cachepurging/purger.py\n+++ b/plone/cachepurging/purger.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """The following is borrowed heavily from Products.CMFSquidTool. That code\n is ZPL licensed.\n \n@@ -15,7 +14,6 @@\n from App.config import getConfiguration\n from plone.cachepurging.interfaces import IPurger\n from six.moves import queue\n-from six.moves import range\n from six.moves.urllib.parse import urlparse\n from traceback import format_exception\n from zope.interface import implementer\n@@ -33,7 +31,7 @@\n \n \n @implementer(IPurger)\n-class DefaultPurger(object):\n+class DefaultPurger:\n     def __init__(self, timeout=(3, 27), backlog=0, errorHeaders=("x-squid-error",)):\n         self.timeout = timeout\n         self.queues = {}\n@@ -79,9 +77,9 @@ def purgeSync(self, url, httpVerb="PURGE"):\n             # Avoid leaking a ref to traceback.\n             del err, msg, tb\n             xcache = ""\n-        logger.debug("Finished %s for %s: %s %s" % (httpVerb, url, status, xcache))\n+        logger.debug(f"Finished {httpVerb} for {url}: {status} {xcache}")\n         if xerror:\n-            logger.debug("Error while purging %s:\\n%s" % (url, xerror))\n+            logger.debug(f"Error while purging {url}:\\n{xerror}")\n         logger.debug("Completed synchronous purge of %s", url)\n         return status, xcache, xerror\n \n@@ -104,7 +102,7 @@ def purgeAsync(self, url, httpVerb="PURGE"):\n                 )\n \n     def stopThreads(self, wait=False):\n-        for worker in six.itervalues(self.workers):\n+        for worker in self.workers.values():\n             worker.stop()\n         # in case the queue is empty, wake it up so the .stopping flag is seen\n         for q in self.queues.values():\n@@ -114,7 +112,7 @@ def stopThreads(self, wait=False):\n                 # no problem - self.stopping should be seen.\n                 pass\n         if wait:\n-            for worker in six.itervalues(self.workers):\n+            for worker in self.workers.values():\n                 worker.join(5)\n                 if worker.is_alive():\n                     logger.warning("Worker thread %s failed to terminate", worker)\n@@ -156,7 +154,7 @@ def __init__(self, queue, host, scheme, producer):\n         self.producer = producer\n         self.queue = queue\n         self.stopping = False\n-        super(Worker, self).__init__(name="PurgeThread for %s://%s" % (scheme, host))\n+        super().__init__(name=f"PurgeThread for {scheme}://{host}")\n \n     def stop(self):\n         self.stopping = True\n@@ -191,17 +189,17 @@ def run(self):\n                                 break  # all done with this item!\n                             if resp.status_code == requests.codes.not_found:\n                                 # not found is valid\n-                                logger.debug("Purge URL not found: {0}".format(url))\n+                                logger.debug(f"Purge URL not found: {url}")\n                                 break  # all done with this item!\n                         except Exception:\n                             # All other exceptions are evil - we just disard\n                             # the item.  This prevents other logic failures etc\n                             # being retried.\n-                            logger.exception("Failed to purge {0}".format(url))\n+                            logger.exception(f"Failed to purge {url}")\n                             break\n                         logger.debug(\n-                            "Transient failure on {0} for {1}, "\n-                            "retrying: {2}".format(httpVerb, url, i)\n+                            "Transient failure on {} for {}, "\n+                            "retrying: {}".format(httpVerb, url, i)\n                         )\n \n         except Exception:\ndiff --git a/plone/cachepurging/rewrite.py b/plone/cachepurging/rewrite.py\nindex 78207b8..72d6d04 100644\n--- a/plone/cachepurging/rewrite.py\n+++ b/plone/cachepurging/rewrite.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.interfaces import ICachePurgingSettings\n from plone.cachepurging.interfaces import IPurgePathRewriter\n from plone.registry.interfaces import IRegistry\n@@ -11,7 +10,7 @@\n \n @implementer(IPurgePathRewriter)\n @adapter(Interface)\n-class DefaultRewriter(object):\n+class DefaultRewriter:\n     """Default rewriter, which is aware of virtual hosting"""\n \n     def __init__(self, request):\ndiff --git a/plone/cachepurging/tests/test_hooks.py b/plone/cachepurging/tests/test_hooks.py\nindex 0eff841..7c36d07 100644\n--- a/plone/cachepurging/tests/test_hooks.py\n+++ b/plone/cachepurging/tests/test_hooks.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.hooks import purge\n from plone.cachepurging.hooks import queuePurge\n from plone.cachepurging.interfaces import ICachePurgingSettings\n@@ -56,7 +55,7 @@ def test_no_request(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -89,7 +88,7 @@ def test_request_not_annotatable(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -115,7 +114,7 @@ def test_no_registry(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -148,7 +147,7 @@ def test_caching_disabled(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -202,7 +201,7 @@ def test_enabled(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -217,7 +216,7 @@ def getAbsolutePaths(self):\n         notify(Purge(context))\n \n         self.assertEqual(\n-            {"plone.cachepurging.urls": set(["/foo", "/bar"])},\n+            {"plone.cachepurging.urls": {"/foo", "/bar"}},\n             dict(IAnnotations(request)),\n         )\n \n@@ -243,7 +242,7 @@ def test_request_not_annotatable(self):\n         settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def __init__(self):\n                 self.purged = []\n \n@@ -270,7 +269,7 @@ def test_no_path_key(self):\n         settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def __init__(self):\n                 self.purged = []\n \n@@ -299,7 +298,7 @@ def test_no_paths(self):\n         settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def __init__(self):\n                 self.purged = []\n \n@@ -317,10 +316,10 @@ def test_no_registry(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)["plone.cachepurging.urls"] = set(["/foo", "/bar"])\n+        IAnnotations(request)["plone.cachepurging.urls"] = {"/foo", "/bar"}\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def __init__(self):\n                 self.purged = []\n \n@@ -338,7 +337,7 @@ def test_caching_disabled(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)["plone.cachepurging.urls"] = set(["/foo", "/bar"])\n+        IAnnotations(request)["plone.cachepurging.urls"] = {"/foo", "/bar"}\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -349,7 +348,7 @@ def test_caching_disabled(self):\n         settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def __init__(self):\n                 self.purged = []\n \n@@ -367,7 +366,7 @@ def test_no_purger(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)["plone.cachepurging.urls"] = set(["/foo", "/bar"])\n+        IAnnotations(request)["plone.cachepurging.urls"] = {"/foo", "/bar"}\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -386,7 +385,7 @@ def test_purge(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)["plone.cachepurging.urls"] = set(["/foo", "/bar"])\n+        IAnnotations(request)["plone.cachepurging.urls"] = {"/foo", "/bar"}\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -397,7 +396,7 @@ def test_purge(self):\n         settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def __init__(self):\n                 self.purged = []\n \ndiff --git a/plone/cachepurging/tests/test_purger.py b/plone/cachepurging/tests/test_purger.py\nindex 2ec044b..8f52ef2 100644\n--- a/plone/cachepurging/tests/test_purger.py\n+++ b/plone/cachepurging/tests/test_purger.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """This test is borrwed heavily from Products.CMFSquidTool. That code is ZPL\n licensed.\n """\n@@ -23,7 +22,7 @@ def do_PURGE(self):\n             print("Unexpected connection from the purge tool")\n             print(self.command, self.path, self.protocol_version)\n             for h, v in self.headers.items():\n-                print("%s: %s" % (h, v))\n+                print(f"{h}: {v}")\n             raise RuntimeError("Unexpected connection")\n \n         # We may have a function to call to check things.\n@@ -113,14 +112,14 @@ def startServer(self, start=True):\n \n class TestSync(TestCase):\n     def setUp(self):\n-        super(TestSync, self).setUp()\n+        super().setUp()\n         self.maxDiff = None\n \n     def tearDown(self):\n-        super(TestSync, self).tearDown()\n+        super().tearDown()\n \n     def dispatchURL(self, path, method="PURGE"):\n-        url = "http://localhost:%s%s" % (self.port, path)\n+        url = f"http://localhost:{self.port}{path}"\n         return self.purger.purgeSync(url, method)\n \n     def testSimpleSync(self):\n@@ -144,7 +143,7 @@ def testError(self):\n \n class TestAsync(TestCase):\n     def dispatchURL(self, path, method="PURGE"):\n-        url = "http://localhost:%s%s" % (self.port, path)\n+        url = f"http://localhost:{self.port}{path}"\n         self.purger.purgeAsync(url, method)\n \n         # Item should now be in the queue!\n@@ -197,7 +196,7 @@ def setUp(self):\n         self.httpd, self.httpt, self.port = self.startServer(start=False)\n \n     def dispatchURL(self, path, method="PURGE"):\n-        url = "http://localhost:%s%s" % (self.port, path)\n+        url = f"http://localhost:{self.port}{path}"\n         self.purger.purgeAsync(url, method)\n \n         # Item should now be in the queue!\ndiff --git a/plone/cachepurging/tests/test_rewrite.py b/plone/cachepurging/tests/test_rewrite.py\nindex 16ac002..8261438 100644\n--- a/plone/cachepurging/tests/test_rewrite.py\n+++ b/plone/cachepurging/tests/test_rewrite.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.interfaces import ICachePurgingSettings\n from plone.cachepurging.rewrite import DefaultRewriter\n from plone.registry import Registry\n@@ -34,14 +33,14 @@ def _prepareVHMRequest(\n     ):\n         translatedPrefix = "/".join(["_vh_%s" % p for p in prefix.split("/")])\n \n-        self.request["URL"] = "%s://%s%s%s" % (protocol, domain, prefix, path)\n-        self.request["ACTUAL_URL"] = "%s://%s%s%s" % (\n+        self.request["URL"] = f"{protocol}://{domain}{prefix}{path}"\n+        self.request["ACTUAL_URL"] = "{}://{}{}{}".format(\n             protocol,\n             domain,\n             prefix,\n             path,\n         )\n-        self.request["SERVER_URL"] = "%s://%s" % (protocol, domain)\n+        self.request["SERVER_URL"] = f"{protocol}://{domain}"\n         self.request[\n             "PATH_INFO"\n         ] = "/VirtualHostBase/%s/%s:80%s/" "VirtualHostRoot%s%s" % (\n@@ -51,17 +50,17 @@ def _prepareVHMRequest(\n             translatedPrefix,\n             path,\n         )\n-        self.request["VIRTUAL_URL"] = "%s://%s%s" % (protocol, domain, path)\n+        self.request["VIRTUAL_URL"] = f"{protocol}://{domain}{path}"\n \n         if prefix:\n             self.request["VIRTUAL_URL_PARTS"] = (\n-                "%s://%s" % (protocol, domain),\n+                f"{protocol}://{domain}",\n                 prefix[1:],\n                 path[1:],\n             )\n         else:\n             self.request["VIRTUAL_URL_PARTS"] = (\n-                "%s://%s" % (protocol, domain),\n+                f"{protocol}://{domain}",\n                 path[1:],\n             )\n \ndiff --git a/plone/cachepurging/tests/test_traversable_paths.py b/plone/cachepurging/tests/test_traversable_paths.py\nindex 06fd19a..637aa8a 100644\n--- a/plone/cachepurging/tests/test_traversable_paths.py\n+++ b/plone/cachepurging/tests/test_traversable_paths.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from OFS.interfaces import ITraversable\n from plone.cachepurging.paths import TraversablePurgePaths\n from zope.interface import implementer\n@@ -7,7 +6,7 @@\n \n \n @implementer(ITraversable)\n-class FauxTraversable(object):\n+class FauxTraversable:\n     def virtual_url_path(self):\n         return "foo"\n \ndiff --git a/plone/cachepurging/tests/test_utils.py b/plone/cachepurging/tests/test_utils.py\nindex 66b3198..2a96336 100644\n--- a/plone/cachepurging/tests/test_utils.py\n+++ b/plone/cachepurging/tests/test_utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging import utils\n from plone.cachepurging.interfaces import ICachePurgingSettings\n from plone.cachepurging.interfaces import IPurgePathRewriter\n@@ -15,7 +14,7 @@\n import zope.component.testing\n \n \n-class FauxContext(object):\n+class FauxContext:\n     pass\n \n \n@@ -82,7 +81,7 @@ def test_no_purge_paths(self):\n     def test_empty_relative_paths(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -99,7 +98,7 @@ def getAbsolutePaths(self):\n     def test_no_rewriter(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -119,7 +118,7 @@ def getAbsolutePaths(self):\n     def test_test_rewriter(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -133,7 +132,7 @@ def getAbsolutePaths(self):\n \n         @implementer(IPurgePathRewriter)\n         @adapter(FauxRequest)\n-        class DefaultRewriter(object):\n+        class DefaultRewriter:\n             def __init__(self, request):\n                 self.request = request\n \n@@ -150,7 +149,7 @@ def __call__(self, path):\n     def test_multiple_purge_paths(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths1(object):\n+        class FauxPurgePaths1:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -164,7 +163,7 @@ def getAbsolutePaths(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths2(object):\n+        class FauxPurgePaths2:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -178,7 +177,7 @@ def getAbsolutePaths(self):\n \n         @implementer(IPurgePathRewriter)\n         @adapter(FauxRequest)\n-        class DefaultRewriter(object):\n+        class DefaultRewriter:\n             def __init__(self, request):\n                 self.request = request\n \n@@ -204,7 +203,7 @@ def __call__(self, path):\n     def test_rewriter_abort(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths1(object):\n+        class FauxPurgePaths1:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -218,7 +217,7 @@ def getAbsolutePaths(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths2(object):\n+        class FauxPurgePaths2:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -232,7 +231,7 @@ def getAbsolutePaths(self):\n \n         @implementer(IPurgePathRewriter)\n         @adapter(FauxRequest)\n-        class DefaultRewriter(object):\n+        class DefaultRewriter:\n             def __init__(self, request):\n                 self.request = request\n \ndiff --git a/plone/cachepurging/tests/test_views.py b/plone/cachepurging/tests/test_views.py\nindex 508689e..6523760 100644\n--- a/plone/cachepurging/tests/test_views.py\n+++ b/plone/cachepurging/tests/test_views.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.browser import PurgeImmediately\n from plone.cachepurging.browser import QueuePurge\n from plone.cachepurging.interfaces import ICachePurgingSettings\n@@ -18,11 +17,11 @@\n import zope.component.testing\n \n \n-class FauxContext(object):\n+class FauxContext:\n     pass\n \n \n-class FauxResponse(object):\n+class FauxResponse:\n     def __init__(self):\n         self.buffer = []\n \n@@ -38,11 +37,11 @@ class FauxRequest(dict):\n     form = dict()\n \n     def __init__(self, *args, **kw):\n-        super(FauxRequest, self).__init__(*args, **kw)\n+        super().__init__(*args, **kw)\n         self.response = FauxResponse()\n \n \n-class Handler(object):\n+class Handler:\n     def __init__(self):\n         self.invocations = []\n \n@@ -98,7 +97,7 @@ def setUp(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -111,7 +110,7 @@ def getAbsolutePaths(self):\n         provideAdapter(FauxPurgePaths, name="test1")\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def purgeSync(self, url, httpVerb="PURGE"):\n                 return "200 OK", "cached", None\n \ndiff --git a/plone/cachepurging/utils.py b/plone/cachepurging/utils.py\nindex 60a33de..4f53eb0 100644\n--- a/plone/cachepurging/utils.py\n+++ b/plone/cachepurging/utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.interfaces import ICachePurgingSettings\n from plone.cachepurging.interfaces import IPurgePathRewriter\n from plone.registry.interfaces import IRegistry\n@@ -36,14 +35,12 @@ def getPathsToPurge(context, request):\n                     yield relativePath\n                 else:\n                     rewrittenPaths = rewriter(relativePath) or []  # None -> []\n-                    for rewrittenPath in rewrittenPaths:\n-                        yield rewrittenPath\n+                    yield from rewrittenPaths\n \n         # add absoute paths, which are not\n         absolutePaths = pathProvider.getAbsolutePaths()\n         if absolutePaths:\n-            for absolutePath in absolutePaths:\n-                yield absolutePath\n+            yield from absolutePaths\n \n \n def getURLsToPurge(path, proxies):\n'

Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2022-05-05T12:36:33+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.cachepurging/commit/4a5e656e1652333a0952b4255969a5c3ed18da6c

add newsfile

Files changed:
A news/26.breaking

b'diff --git a/news/26.breaking b/news/26.breaking\nnew file mode 100644\nindex 0000000..9c58baf\n--- /dev/null\n+++ b/news/26.breaking\n@@ -0,0 +1,2 @@\n+Drop Python 2 support. Code style. \n+[jensens]\n'

Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2022-05-05T14:49:38+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.cachepurging/commit/7ec00fb254bad2c5c142d922f70f7aa80a01035b

Merge pull request #26 from plone/overhaul

Overhaul: py3/black/...

Files changed:
A news/26.breaking
M plone/__init__.py
M plone/cachepurging/browser.py
M plone/cachepurging/hooks.py
M plone/cachepurging/interfaces.py
M plone/cachepurging/paths.py
M plone/cachepurging/purger.py
M plone/cachepurging/rewrite.py
M plone/cachepurging/tests/test_hooks.py
M plone/cachepurging/tests/test_purger.py
M plone/cachepurging/tests/test_rewrite.py
M plone/cachepurging/tests/test_traversable_paths.py
M plone/cachepurging/tests/test_utils.py
M plone/cachepurging/tests/test_views.py
M plone/cachepurging/utils.py
M setup.cfg
M setup.py
D bootstrap.py
D bootstrap.sh
D buildout.cfg

b'diff --git a/bootstrap.py b/bootstrap.py\ndeleted file mode 100644\nindex 2294e35..0000000\n--- a/bootstrap.py\n+++ /dev/null\n@@ -1,217 +0,0 @@\n-##############################################################################\n-#\n-# Copyright (c) 2006 Zope Foundation and Contributors.\n-# All Rights Reserved.\n-#\n-# This software is subject to the provisions of the Zope Public License,\n-# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n-# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED\n-# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n-# FOR A PARTICULAR PURPOSE.\n-#\n-##############################################################################\n-"""Bootstrap a buildout-based project\n-\n-Simply run this script in a directory containing a buildout.cfg.\n-The script accepts buildout command-line options, so you can\n-use the -c option to specify an alternate configuration file.\n-"""\n-\n-import os\n-import shutil\n-import sys\n-import tempfile\n-\n-from optparse import OptionParser\n-\n-tmpeggs = tempfile.mkdtemp()\n-\n-usage = """\\\n-[DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]\n-\n-Bootstraps a buildout-based project.\n-\n-Simply run this script in a directory containing a buildout.cfg, using the\n-Python that you want bin/buildout to use.\n-\n-Note that by using --find-links to point to local resources, you can keep\n-this script from going over the network.\n-"""\n-\n-parser = OptionParser(usage=usage)\n-parser.add_option("-v", "--version", help="use a specific zc.buildout version")\n-\n-parser.add_option(\n-    "-t",\n-    "--accept-buildout-test-releases",\n-    dest="accept_buildout_test_releases",\n-    action="store_true",\n-    default=False,\n-    help=(\n-        "Normally, if you do not specify a --version, the "\n-        "bootstrap script and buildout gets the newest "\n-        "*final* versions of zc.buildout and its recipes and "\n-        "extensions for you.  If you use this flag, "\n-        "bootstrap and buildout will get the newest releases "\n-        "even if they are alphas or betas."\n-    ),\n-)\n-parser.add_option(\n-    "-c",\n-    "--config-file",\n-    help=(\n-        "Specify the path to the buildout configuration " "file to be used."\n-    ),\n-)\n-parser.add_option(\n-    "-f",\n-    "--find-links",\n-    help=("Specify a URL to search for buildout releases"),\n-)\n-parser.add_option(\n-    "--allow-site-packages",\n-    action="store_true",\n-    default=False,\n-    help=("Let bootstrap.py use existing site packages"),\n-)\n-parser.add_option(\n-    "--setuptools-version", help="use a specific setuptools version"\n-)\n-\n-\n-options, args = parser.parse_args()\n-\n-######################################################################\n-# load/install setuptools\n-\n-try:\n-    if options.allow_site_packages:\n-        import setuptools\n-        import pkg_resources\n-    from urllib.request import urlopen\n-except ImportError:\n-    from urllib2 import urlopen\n-\n-ez = {}\n-exec(urlopen("https://bootstrap.pypa.io/ez_setup.py").read(), ez)\n-\n-if not options.allow_site_packages:\n-    # ez_setup imports site, which adds site packages\n-    # this will remove them from the path to ensure that incompatible versions\n-    # of setuptools are not in the path\n-    import site\n-\n-    # inside a virtualenv, there is no \'getsitepackages\'.\n-    # We can\'t remove these reliably\n-    if hasattr(site, "getsitepackages"):\n-        for sitepackage_path in site.getsitepackages():\n-            sys.path[:] = [x for x in sys.path if sitepackage_path not in x]\n-\n-setup_args = dict(to_dir=tmpeggs, download_delay=0)\n-\n-if options.setuptools_version is not None:\n-    setup_args["version"] = options.setuptools_version\n-\n-ez["use_setuptools"](**setup_args)\n-import setuptools\n-import pkg_resources\n-\n-# This does not (always?) update the default working set.  We will\n-# do it.\n-for path in sys.path:\n-    if path not in pkg_resources.working_set.entries:\n-        pkg_resources.working_set.add_entry(path)\n-\n-######################################################################\n-# Install buildout\n-\n-ws = pkg_resources.working_set\n-\n-cmd = [\n-    sys.executable,\n-    "-c",\n-    "from setuptools.command.easy_install import main; main()",\n-    "-mZqNxd",\n-    tmpeggs,\n-]\n-\n-find_links = os.environ.get(\n-    "bootstrap-testing-find-links",\n-    options.find_links\n-    or (\n-        "http://downloads.buildout.org/"\n-        if options.accept_buildout_test_releases\n-        else None\n-    ),\n-)\n-if find_links:\n-    cmd.extend(["-f", find_links])\n-\n-setuptools_path = ws.find(\n-    pkg_resources.Requirement.parse("setuptools")\n-).location\n-\n-requirement = "zc.buildout"\n-version = options.version\n-if version is None and not options.accept_buildout_test_releases:\n-    # Figure out the most recent final version of zc.buildout.\n-    import setuptools.package_index\n-\n-    _final_parts = "*final-", "*final"\n-\n-    def _final_version(parsed_version):\n-        try:\n-            return not parsed_version.is_prerelease\n-        except AttributeError:\n-            # Older setuptools\n-            for part in parsed_version:\n-                if (part[:1] == "*") and (part not in _final_parts):\n-                    return False\n-            return True\n-\n-    index = setuptools.package_index.PackageIndex(\n-        search_path=[setuptools_path]\n-    )\n-    if find_links:\n-        index.add_find_links((find_links,))\n-    req = pkg_resources.Requirement.parse(requirement)\n-    if index.obtain(req) is not None:\n-        best = []\n-        bestv = None\n-        for dist in index[req.project_name]:\n-            distv = dist.parsed_version\n-            if _final_version(distv):\n-                if bestv is None or distv > bestv:\n-                    best = [dist]\n-                    bestv = distv\n-                elif distv == bestv:\n-                    best.append(dist)\n-        if best:\n-            best.sort()\n-            version = best[-1].version\n-if version:\n-    requirement = "==".join((requirement, version))\n-cmd.append(requirement)\n-\n-import subprocess\n-\n-if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:\n-    raise Exception("Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n-\n-######################################################################\n-# Import and run buildout\n-\n-ws.add_entry(tmpeggs)\n-ws.require(requirement)\n-import zc.buildout.buildout\n-\n-if not [a for a in args if "=" not in a]:\n-    args.append("bootstrap")\n-\n-# if -c was provided, we push it back into args for buildout\' main function\n-if options.config_file is not None:\n-    args[0:0] = ["-c", options.config_file]\n-\n-zc.buildout.buildout.main(args)\n-shutil.rmtree(tmpeggs)\ndiff --git a/bootstrap.sh b/bootstrap.sh\ndeleted file mode 100755\nindex d764997..0000000\n--- a/bootstrap.sh\n+++ /dev/null\n@@ -1,7 +0,0 @@\n-#!/bin/sh\n-\n-# see https://community.plone.org/t/not-using-bootstrap-py-as-default/620\n-rm -r ./lib ./include ./local ./bin\n-virtualenv --clear .\n-./bin/pip install --upgrade pip setuptools zc.buildout\n-./bin/buildout\ndiff --git a/buildout.cfg b/buildout.cfg\ndeleted file mode 100644\nindex 52c130a..0000000\n--- a/buildout.cfg\n+++ /dev/null\n@@ -1,18 +0,0 @@\n-[buildout]\n-parts = test\n-        omelette\n-versions = versions\n-\n-extends = http://dist.plone.org/release/5.1-latest/versions.cfg\n-develop = .\n-\n-[versions]\n-plone.cachepurging = \n-\n-[test]\n-recipe = zc.recipe.testrunner\n-eggs = plone.cachepurging [test]\n-\n-[omelette]\n-recipe = collective.recipe.omelette\n-eggs = ${test:eggs}\ndiff --git a/news/26.breaking b/news/26.breaking\nnew file mode 100644\nindex 0000000..9c58baf\n--- /dev/null\n+++ b/news/26.breaking\n@@ -0,0 +1,2 @@\n+Drop Python 2 support. Code style. \n+[jensens]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 03d08ff..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n __import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/cachepurging/browser.py b/plone/cachepurging/browser.py\nindex dbd7628..a5bcc7e 100644\n--- a/plone/cachepurging/browser.py\n+++ b/plone/cachepurging/browser.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.interfaces import ICachePurgingSettings\n from plone.cachepurging.interfaces import IPurger\n from plone.cachepurging.utils import getPathsToPurge\n@@ -10,28 +9,26 @@\n from zope.event import notify\n \n \n-class QueuePurge(object):\n-    """Manually initiate a purge\n-    """\n+class QueuePurge:\n+    """Manually initiate a purge"""\n \n     def __init__(self, context, request):\n         self.context = context\n         self.request = request\n \n     def __call__(self):\n-        self.request.response.setHeader(\'Content-type\', \'text/plain\')\n+        self.request.response.setHeader("Content-type", "text/plain")\n         if not isCachePurgingEnabled():\n             return "Cache purging not enabled"\n \n         paths = getPathsToPurge(self.context, self.request)\n \n         notify(Purge(self.context))\n-        return "Queued:\\n\\n{0}".format("\\n".join(paths))\n+        return "Queued:\\n\\n{}".format("\\n".join(paths))\n \n \n-class PurgeImmediately(object):\n-    """Purge immediately\n-    """\n+class PurgeImmediately:\n+    """Purge immediately"""\n \n     def __init__(self, context, request):\n         self.context = context\n@@ -43,7 +40,7 @@ def write(self, msg):\n         self.request.response.write(msg)\n \n     def __call__(self):\n-        self.request.response.setHeader(\'Content-type\', \'text/plain\')\n+        self.request.response.setHeader("Content-type", "text/plain")\n         if not isCachePurgingEnabled():\n             return "Cache purging not enabled"\n \n@@ -54,17 +51,18 @@ def __call__(self):\n         caching_proxies = settings.cachingProxies\n         traceback = self.request.form.get("traceback")\n         if not traceback:\n-            self.write("(hint: add \'?traceback\' to url to show full traceback in case of errors)\\n\\n")\n-        self.write("Proxies to purge: {0}\\n".format(\', \'.join(caching_proxies)))\n+            self.write(\n+                "(hint: add \'?traceback\' to url to show full traceback in case of errors)\\n\\n"\n+            )\n+        self.write("Proxies to purge: {}\\n".format(", ".join(caching_proxies)))\n         for path in getPathsToPurge(self.context, self.request):\n-            self.write("- process path: {0}\\n".format(path))\n+            self.write(f"- process path: {path}\\n")\n             for url in getURLsToPurge(path, caching_proxies):\n-                self.write("  - send to purge {0}\\n".format(url).encode("utf-8"))\n+                self.write(f"  - send to purge {url}\\n".encode("utf-8"))\n                 status, xcache, xerror = purger.purgeSync(url)\n                 self.write(\n                     "    response with status: {status}, X-Cache: {xcache}\\n".format(\n-                        status=status,\n-                        xcache=xcache\n+                        status=status, xcache=xcache\n                     )\n                 )\n                 if traceback and xerror:\ndiff --git a/plone/cachepurging/hooks.py b/plone/cachepurging/hooks.py\nindex 7253ed9..c3ed297 100644\n--- a/plone/cachepurging/hooks.py\n+++ b/plone/cachepurging/hooks.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.interfaces import ICachePurgingSettings\n from plone.cachepurging.interfaces import IPurger\n from plone.cachepurging.utils import getPathsToPurge\n@@ -18,8 +17,7 @@\n \n @adapter(IPurgeEvent)\n def queuePurge(event):\n-    """Find URLs to purge and queue them for later\n-    """\n+    """Find URLs to purge and queue them for later"""\n \n     request = getRequest()\n     if request is None:\n@@ -38,8 +36,7 @@ def queuePurge(event):\n \n @adapter(IPubSuccess)\n def purge(event):\n-    """Asynchronously send PURGE requests\n-    """\n+    """Asynchronously send PURGE requests"""\n \n     request = event.request\n \ndiff --git a/plone/cachepurging/interfaces.py b/plone/cachepurging/interfaces.py\nindex 363eb71..e2e93d4 100644\n--- a/plone/cachepurging/interfaces.py\n+++ b/plone/cachepurging/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope import schema\n from zope.i18nmessageid import MessageFactory\n from zope.interface import Interface\n@@ -14,57 +13,57 @@ class ICachePurgingSettings(Interface):\n     """\n \n     enabled = schema.Bool(\n-        title=_(u"Enable purging"),\n-        description=_(u"If disabled, no purging will take place"),\n+        title=_("Enable purging"),\n+        description=_("If disabled, no purging will take place"),\n         default=True,\n     )\n \n     cachingProxies = schema.Tuple(\n-        title=_(u"Caching proxies"),\n+        title=_("Caching proxies"),\n         description=_(\n-            u"Provide the URLs of each proxy to which PURGE "\n-            u"requests should be sent."\n+            "Provide the URLs of each proxy to which PURGE "\n+            "requests should be sent."\n         ),\n         value_type=schema.URI(),\n     )\n \n     virtualHosting = schema.Bool(\n-        title=_(u"Send PURGE requests with virtual hosting paths"),\n+        title=_("Send PURGE requests with virtual hosting paths"),\n         description=_(\n-            u"This option is only relevant if you are using "\n-            u"virtual hosting with Zope\'s VirtualHostMonster. "\n-            u"This relies on special tokens (VirtualHostBase "\n-            u"and VirtualHostRoot) in the URL to instruct "\n-            u"Zope about the types of URLs that the user sees. "\n-            u"If virtual host URLs are in use and this option "\n-            u"is set, PURGE requests will be sent to the "\n-            u"caching proxy with the virtual hosting tokens "\n-            u"in place. This makes sense if there is a web "\n-            u"server in front of your caching proxy performing "\n-            u"the rewrites necessary to translate a user-"\n-            u"facing URL into a virtual hosting URL, so that "\n-            u"the requests the caching proxy sees have the "\n-            u"rewrite information in them. Conversely, if the "\n-            u"rewrite is done in or behind the caching proxy, "\n-            u"you want to disable this option, so that the "\n-            u"PURGE requests use URLs that match those seen "\n-            u"by the caching proxy as they come from the "\n-            u"client."\n+            "This option is only relevant if you are using "\n+            "virtual hosting with Zope\'s VirtualHostMonster. "\n+            "This relies on special tokens (VirtualHostBase "\n+            "and VirtualHostRoot) in the URL to instruct "\n+            "Zope about the types of URLs that the user sees. "\n+            "If virtual host URLs are in use and this option "\n+            "is set, PURGE requests will be sent to the "\n+            "caching proxy with the virtual hosting tokens "\n+            "in place. This makes sense if there is a web "\n+            "server in front of your caching proxy performing "\n+            "the rewrites necessary to translate a user-"\n+            "facing URL into a virtual hosting URL, so that "\n+            "the requests the caching proxy sees have the "\n+            "rewrite information in them. Conversely, if the "\n+            "rewrite is done in or behind the caching proxy, "\n+            "you want to disable this option, so that the "\n+            "PURGE requests use URLs that match those seen "\n+            "by the caching proxy as they come from the "\n+            "client."\n         ),\n         required=True,\n         default=False,\n     )\n \n     domains = schema.Tuple(\n-        title=_(u"Domains"),\n+        title=_("Domains"),\n         description=_(\n-            u"This option is only relevant if you are using "\n-            u"virtual hosting and you have enabled the option "\n-            u"to send PURGE requests with virtual hosting URLs "\n-            u"above. If you your site is served on multiple "\n-            u"domains e.g. http://example.org and "\n-            u"http://www.example.org you may wish to purge "\n-            u"both. If so, list all your domains here"\n+            "This option is only relevant if you are using "\n+            "virtual hosting and you have enabled the option "\n+            "to send PURGE requests with virtual hosting URLs "\n+            "above. If you your site is served on multiple "\n+            "domains e.g. http://example.org and "\n+            "http://www.example.org you may wish to purge "\n+            "both. If so, list all your domains here"\n         ),\n         required=False,\n         default=(),\n@@ -89,8 +88,7 @@ def __call__(path):\n \n \n class IPurger(Interface):\n-    """A utility used to manage the purging process.\n-    """\n+    """A utility used to manage the purging process."""\n \n     def purgeAsync(url, httpVerb="PURGE"):\n         """Send a PURGE request to a particular URL asynchronously in a\n@@ -116,11 +114,9 @@ def stopThreads(wait=False):\n         """\n \n     errorHeaders = schema.Tuple(\n-        title=u"Error header names",\n+        title="Error header names",\n         value_type=schema.ASCIILine(),\n         default=("x-squid-error",),\n     )\n \n-    http_1_1 = schema.Bool(\n-        title=u"Use HTTP 1.1 for PURGE request", default=True\n-    )\n+    http_1_1 = schema.Bool(title="Use HTTP 1.1 for PURGE request", default=True)\ndiff --git a/plone/cachepurging/paths.py b/plone/cachepurging/paths.py\nindex 1f4b0cf..0866b45 100644\n--- a/plone/cachepurging/paths.py\n+++ b/plone/cachepurging/paths.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from OFS.interfaces import ITraversable\n from z3c.caching.interfaces import IPurgePaths\n from zope.component import adapter\n@@ -7,9 +6,8 @@\n \n @implementer(IPurgePaths)\n @adapter(ITraversable)\n-class TraversablePurgePaths(object):\n-    """Default purge for OFS.Traversable-style objects\n-    """\n+class TraversablePurgePaths:\n+    """Default purge for OFS.Traversable-style objects"""\n \n     def __init__(self, context):\n         self.context = context\ndiff --git a/plone/cachepurging/purger.py b/plone/cachepurging/purger.py\nindex 7879e32..2d30980 100644\n--- a/plone/cachepurging/purger.py\n+++ b/plone/cachepurging/purger.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """The following is borrowed heavily from Products.CMFSquidTool. That code\n is ZPL licensed.\n \n@@ -15,7 +14,6 @@\n from App.config import getConfiguration\n from plone.cachepurging.interfaces import IPurger\n from six.moves import queue\n-from six.moves import range\n from six.moves.urllib.parse import urlparse\n from traceback import format_exception\n from zope.interface import implementer\n@@ -33,10 +31,8 @@\n \n \n @implementer(IPurger)\n-class DefaultPurger(object):\n-    def __init__(\n-        self, timeout=(3, 27), backlog=0, errorHeaders=("x-squid-error",)\n-    ):\n+class DefaultPurger:\n+    def __init__(self, timeout=(3, 27), backlog=0, errorHeaders=("x-squid-error",)):\n         self.timeout = timeout\n         self.queues = {}\n         self.workers = {}\n@@ -62,9 +58,7 @@ def purge(self, session, url, httpVerb="PURGE"):\n             if xerror:\n                 # Break on first found.\n                 break\n-        logger.debug(\n-            "%s of %s: %s %s", httpVerb, url, resp.status_code, resp.reason\n-        )\n+        logger.debug("%s of %s: %s %s", httpVerb, url, resp.status_code, resp.reason)\n         return resp, xcache, xerror\n \n     def purgeSync(self, url, httpVerb="PURGE"):\n@@ -83,11 +77,9 @@ def purgeSync(self, url, httpVerb="PURGE"):\n             # Avoid leaking a ref to traceback.\n             del err, msg, tb\n             xcache = ""\n-        logger.debug(\n-            "Finished %s for %s: %s %s" % (httpVerb, url, status, xcache)\n-        )\n+        logger.debug(f"Finished {httpVerb} for {url}: {status} {xcache}")\n         if xerror:\n-            logger.debug("Error while purging %s:\\n%s" % (url, xerror))\n+            logger.debug(f"Error while purging {url}:\\n{xerror}")\n         logger.debug("Completed synchronous purge of %s", url)\n         return status, xcache, xerror\n \n@@ -110,7 +102,7 @@ def purgeAsync(self, url, httpVerb="PURGE"):\n                 )\n \n     def stopThreads(self, wait=False):\n-        for worker in six.itervalues(self.workers):\n+        for worker in self.workers.values():\n             worker.stop()\n         # in case the queue is empty, wake it up so the .stopping flag is seen\n         for q in self.queues.values():\n@@ -120,13 +112,10 @@ def stopThreads(self, wait=False):\n                 # no problem - self.stopping should be seen.\n                 pass\n         if wait:\n-            for worker in six.itervalues(self.workers):\n+            for worker in self.workers.values():\n                 worker.join(5)\n                 if worker.is_alive():\n-                    logger.warning(\n-                        "Worker thread %s failed to terminate",\n-                        worker\n-                    )\n+                    logger.warning("Worker thread %s failed to terminate", worker)\n                     return False\n         return True\n \n@@ -141,17 +130,11 @@ def getQueueAndWorker(self, url):\n             self.queueLock.acquire()\n             try:\n                 if key not in self.queues:\n-                    logger.debug(\n-                        "Creating worker thread for %s://%s", scheme, host\n-                    )\n+                    logger.debug("Creating worker thread for %s://%s", scheme, host)\n                     if key in self.workers:\n-                        raise ValueError(\n-                            "Queue Key must not already exist in workers"\n-                        )\n+                        raise ValueError("Queue Key must not already exist in workers")\n                     self.queues[key] = queue_ = queue.Queue(self.backlog)\n-                    self.workers[key] = worker = Worker(\n-                        queue_, host, scheme, self\n-                    )\n+                    self.workers[key] = worker = Worker(queue_, host, scheme, self)\n                     worker.start()\n             finally:\n                 self.queueLock.release()\n@@ -163,8 +146,7 @@ def http_1_1(self):\n \n \n class Worker(threading.Thread):\n-    """Worker thread for purging.\n-    """\n+    """Worker thread for purging."""\n \n     def __init__(self, queue, host, scheme, producer):\n         self.host = host\n@@ -172,9 +154,7 @@ def __init__(self, queue, host, scheme, producer):\n         self.producer = producer\n         self.queue = queue\n         self.stopping = False\n-        super(Worker, self).__init__(\n-            name="PurgeThread for %s://%s" % (scheme, host)\n-        )\n+        super().__init__(name=f"PurgeThread for {scheme}://{host}")\n \n     def stop(self):\n         self.stopping = True\n@@ -204,32 +184,27 @@ def run(self):\n                             break\n                         # Got an item, purge it!\n                         try:\n-                            resp, msg, err = self.producer.purge(\n-                                session, url, httpVerb\n-                            )\n+                            resp, msg, err = self.producer.purge(session, url, httpVerb)\n                             if resp.status_code == requests.codes.ok:\n                                 break  # all done with this item!\n                             if resp.status_code == requests.codes.not_found:\n                                 # not found is valid\n-                                logger.debug(\n-                                    "Purge URL not found: {0}".format(url)\n-                                )\n+                                logger.debug(f"Purge URL not found: {url}")\n                                 break  # all done with this item!\n                         except Exception:\n                             # All other exceptions are evil - we just disard\n                             # the item.  This prevents other logic failures etc\n                             # being retried.\n-                            logger.exception("Failed to purge {0}".format(url))\n+                            logger.exception(f"Failed to purge {url}")\n                             break\n                         logger.debug(\n-                            "Transient failure on {0} for {1}, "\n-                            "retrying: {2}".format(httpVerb, url, i)\n+                            "Transient failure on {} for {}, "\n+                            "retrying: {}".format(httpVerb, url, i)\n                         )\n \n         except Exception:\n             logger.exception(\n-                "Exception in worker thread "\n-                "for (%s, %s)" % (self.host, self.scheme)\n+                "Exception in worker thread " "for (%s, %s)" % (self.host, self.scheme)\n             )\n         logger.debug("%s terminating", self)\n \ndiff --git a/plone/cachepurging/rewrite.py b/plone/cachepurging/rewrite.py\nindex a3424f8..72d6d04 100644\n--- a/plone/cachepurging/rewrite.py\n+++ b/plone/cachepurging/rewrite.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.interfaces import ICachePurgingSettings\n from plone.cachepurging.interfaces import IPurgePathRewriter\n from plone.registry.interfaces import IRegistry\n@@ -11,9 +10,8 @@\n \n @implementer(IPurgePathRewriter)\n @adapter(Interface)\n-class DefaultRewriter(object):\n-    """Default rewriter, which is aware of virtual hosting\n-    """\n+class DefaultRewriter:\n+    """Default rewriter, which is aware of virtual hosting"""\n \n     def __init__(self, request):\n         self.request = request\n@@ -65,9 +63,7 @@ def __call__(self, path):\n         # Prefix, e.g. /_vh_foo/_vh_bar. Clear if we don\'t have any.\n         pathPrefix = len(virtualUrlParts) == 3 and virtualUrlParts[1] or ""\n         if pathPrefix:\n-            pathPrefix = "/" + "/".join(\n-                ["_vh_%s" % p for p in pathPrefix.split("/")]\n-            )\n+            pathPrefix = "/" + "/".join(["_vh_%s" % p for p in pathPrefix.split("/")])\n \n         # Path, e.g. /front-page\n         if len(path) > 0 and not path.startswith("/"):\ndiff --git a/plone/cachepurging/tests/test_hooks.py b/plone/cachepurging/tests/test_hooks.py\nindex 8e7fb94..7c36d07 100644\n--- a/plone/cachepurging/tests/test_hooks.py\n+++ b/plone/cachepurging/tests/test_hooks.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.hooks import purge\n from plone.cachepurging.hooks import queuePurge\n from plone.cachepurging.interfaces import ICachePurgingSettings\n@@ -56,7 +55,7 @@ def test_no_request(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -89,7 +88,7 @@ def test_request_not_annotatable(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -115,7 +114,7 @@ def test_no_registry(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -148,7 +147,7 @@ def test_caching_disabled(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -202,7 +201,7 @@ def test_enabled(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -217,7 +216,7 @@ def getAbsolutePaths(self):\n         notify(Purge(context))\n \n         self.assertEqual(\n-            {"plone.cachepurging.urls": set(["/foo", "/bar"])},\n+            {"plone.cachepurging.urls": {"/foo", "/bar"}},\n             dict(IAnnotations(request)),\n         )\n \n@@ -243,7 +242,7 @@ def test_request_not_annotatable(self):\n         settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def __init__(self):\n                 self.purged = []\n \n@@ -270,7 +269,7 @@ def test_no_path_key(self):\n         settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def __init__(self):\n                 self.purged = []\n \n@@ -299,7 +298,7 @@ def test_no_paths(self):\n         settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def __init__(self):\n                 self.purged = []\n \n@@ -317,12 +316,10 @@ def test_no_registry(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)["plone.cachepurging.urls"] = set(\n-            ["/foo", "/bar"]\n-        )\n+        IAnnotations(request)["plone.cachepurging.urls"] = {"/foo", "/bar"}\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def __init__(self):\n                 self.purged = []\n \n@@ -340,9 +337,7 @@ def test_caching_disabled(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)["plone.cachepurging.urls"] = set(\n-            ["/foo", "/bar"]\n-        )\n+        IAnnotations(request)["plone.cachepurging.urls"] = {"/foo", "/bar"}\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -353,7 +348,7 @@ def test_caching_disabled(self):\n         settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def __init__(self):\n                 self.purged = []\n \n@@ -371,9 +366,7 @@ def test_no_purger(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)["plone.cachepurging.urls"] = set(\n-            ["/foo", "/bar"]\n-        )\n+        IAnnotations(request)["plone.cachepurging.urls"] = {"/foo", "/bar"}\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -392,9 +385,7 @@ def test_purge(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)["plone.cachepurging.urls"] = set(\n-            ["/foo", "/bar"]\n-        )\n+        IAnnotations(request)["plone.cachepurging.urls"] = {"/foo", "/bar"}\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -405,7 +396,7 @@ def test_purge(self):\n         settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def __init__(self):\n                 self.purged = []\n \ndiff --git a/plone/cachepurging/tests/test_purger.py b/plone/cachepurging/tests/test_purger.py\nindex 246d18a..8f52ef2 100644\n--- a/plone/cachepurging/tests/test_purger.py\n+++ b/plone/cachepurging/tests/test_purger.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """This test is borrwed heavily from Products.CMFSquidTool. That code is ZPL\n licensed.\n """\n@@ -23,7 +22,7 @@ def do_PURGE(self):\n             print("Unexpected connection from the purge tool")\n             print(self.command, self.path, self.protocol_version)\n             for h, v in self.headers.items():\n-                print("%s: %s" % (h, v))\n+                print(f"{h}: {v}")\n             raise RuntimeError("Unexpected connection")\n \n         # We may have a function to call to check things.\n@@ -113,14 +112,14 @@ def startServer(self, start=True):\n \n class TestSync(TestCase):\n     def setUp(self):\n-        super(TestSync, self).setUp()\n+        super().setUp()\n         self.maxDiff = None\n \n     def tearDown(self):\n-        super(TestSync, self).tearDown()\n+        super().tearDown()\n \n     def dispatchURL(self, path, method="PURGE"):\n-        url = "http://localhost:%s%s" % (self.port, path)\n+        url = f"http://localhost:{self.port}{path}"\n         return self.purger.purgeSync(url, method)\n \n     def testSimpleSync(self):\n@@ -144,7 +143,7 @@ def testError(self):\n \n class TestAsync(TestCase):\n     def dispatchURL(self, path, method="PURGE"):\n-        url = "http://localhost:%s%s" % (self.port, path)\n+        url = f"http://localhost:{self.port}{path}"\n         self.purger.purgeAsync(url, method)\n \n         # Item should now be in the queue!\n@@ -173,7 +172,7 @@ def testAsyncError(self):\n         self.dispatchURL("/bar")  # will consume error, then retry\n         self.assertTrue(\n             self.httpd.response_queue.empty(),\n-            "Left items behind in HTTPD response queue."\n+            "Left items behind in HTTPD response queue.",\n         )\n \n     def testAsyncNotFOund(self):\n@@ -181,13 +180,12 @@ def testAsyncNotFOund(self):\n         self.httpd.queue_response(response=200)\n         self.dispatchURL("/foo")  # works\n         self.assertFalse(\n-            self.httpd.response_queue.empty(),\n-            "404 was retried instead of consumed."\n+            self.httpd.response_queue.empty(), "404 was retried instead of consumed."\n         )\n         self.dispatchURL("/foo")  # works\n         self.assertTrue(\n             self.httpd.response_queue.empty(),\n-            "Left items behind in HTTPD response queue."\n+            "Left items behind in HTTPD response queue.",\n         )\n \n \n@@ -198,7 +196,7 @@ def setUp(self):\n         self.httpd, self.httpt, self.port = self.startServer(start=False)\n \n     def dispatchURL(self, path, method="PURGE"):\n-        url = "http://localhost:%s%s" % (self.port, path)\n+        url = f"http://localhost:{self.port}{path}"\n         self.purger.purgeAsync(url, method)\n \n         # Item should now be in the queue!\ndiff --git a/plone/cachepurging/tests/test_rewrite.py b/plone/cachepurging/tests/test_rewrite.py\nindex 49e5193..8261438 100644\n--- a/plone/cachepurging/tests/test_rewrite.py\n+++ b/plone/cachepurging/tests/test_rewrite.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.interfaces import ICachePurgingSettings\n from plone.cachepurging.rewrite import DefaultRewriter\n from plone.registry import Registry\n@@ -34,30 +33,34 @@ def _prepareVHMRequest(\n     ):\n         translatedPrefix = "/".join(["_vh_%s" % p for p in prefix.split("/")])\n \n-        self.request["URL"] = "%s://%s%s%s" % (protocol, domain, prefix, path)\n-        self.request["ACTUAL_URL"] = "%s://%s%s%s" % (\n+        self.request["URL"] = f"{protocol}://{domain}{prefix}{path}"\n+        self.request["ACTUAL_URL"] = "{}://{}{}{}".format(\n             protocol,\n             domain,\n             prefix,\n             path,\n         )\n-        self.request["SERVER_URL"] = "%s://%s" % (protocol, domain)\n-        self.request["PATH_INFO"] = (\n-            "/VirtualHostBase/%s/%s:80%s/"\n-            "VirtualHostRoot%s%s"\n-            % (protocol, domain, root, translatedPrefix, path)\n+        self.request["SERVER_URL"] = f"{protocol}://{domain}"\n+        self.request[\n+            "PATH_INFO"\n+        ] = "/VirtualHostBase/%s/%s:80%s/" "VirtualHostRoot%s%s" % (\n+            protocol,\n+            domain,\n+            root,\n+            translatedPrefix,\n+            path,\n         )\n-        self.request["VIRTUAL_URL"] = "%s://%s%s" % (protocol, domain, path)\n+        self.request["VIRTUAL_URL"] = f"{protocol}://{domain}{path}"\n \n         if prefix:\n             self.request["VIRTUAL_URL_PARTS"] = (\n-                "%s://%s" % (protocol, domain),\n+                f"{protocol}://{domain}",\n                 prefix[1:],\n                 path[1:],\n             )\n         else:\n             self.request["VIRTUAL_URL_PARTS"] = (\n-                "%s://%s" % (protocol, domain),\n+                f"{protocol}://{domain}",\n                 path[1:],\n             )\n \n@@ -189,10 +192,7 @@ def test_virtual_root_is_deep(self):\n         self._prepareVHMRequest("/foo", root="/bar/plone")\n \n         self.assertEqual(\n-            [\n-                "/VirtualHostBase/http/example.com/bar/plone/"\n-                "VirtualHostRoot/foo"\n-            ],\n+            ["/VirtualHostBase/http/example.com/bar/plone/" "VirtualHostRoot/foo"],\n             self.rewriter("/foo"),\n         )\n \n@@ -223,10 +223,7 @@ def test_inside_out_hosting_root_empty_path(self):\n         self._prepareVHMRequest("/", root="/plone", prefix="/plone")\n \n         self.assertEqual(\n-            [\n-                "/VirtualHostBase/http/example.com/plone/"\n-                "VirtualHostRoot/_vh_plone"\n-            ],\n+            ["/VirtualHostBase/http/example.com/plone/" "VirtualHostRoot/_vh_plone"],\n             self.rewriter(""),\n         )\n \n@@ -268,10 +265,7 @@ def test_virtual_path_is_deep(self):\n         self._prepareVHMRequest("/foo/bar", root="/plone")\n \n         self.assertEqual(\n-            [\n-                "/VirtualHostBase/http/example.com/plone/"\n-                "VirtualHostRoot/foo/bar"\n-            ],\n+            ["/VirtualHostBase/http/example.com/plone/" "VirtualHostRoot/foo/bar"],\n             self.rewriter("/foo/bar"),\n         )\n \n@@ -295,14 +289,9 @@ def test_https(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\n-            "/foo", domain="example.com:81", protocol="https"\n-        )\n+        self._prepareVHMRequest("/foo", domain="example.com:81", protocol="https")\n         self.assertEqual(\n-            [\n-                "/VirtualHostBase/https/example.com:81/plone/"\n-                "VirtualHostRoot/foo"\n-            ],\n+            ["/VirtualHostBase/https/example.com:81/plone/" "VirtualHostRoot/foo"],\n             self.rewriter("/foo"),\n         )\n \n@@ -314,15 +303,11 @@ def test_domains(self):\n         settings.virtualHosting = True\n         settings.domains = ("http://example.org:81", "https://example.com:82")\n \n-        self._prepareVHMRequest(\n-            "/foo", domain="example.com:81", protocol="https"\n-        )\n+        self._prepareVHMRequest("/foo", domain="example.com:81", protocol="https")\n         self.assertEqual(\n             [\n-                "/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/"\n-                "foo",\n-                "/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/"\n-                "foo",\n+                "/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/" "foo",\n+                "/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/" "foo",\n             ],\n             self.rewriter("/foo"),\n         )\n@@ -335,15 +320,11 @@ def test_domains_w_different_path_in_request(self):\n         settings.virtualHosting = True\n         settings.domains = ("http://example.org:81", "https://example.com:82")\n \n-        self._prepareVHMRequest(\n-            "/bar", domain="example.com:81", protocol="https"\n-        )\n+        self._prepareVHMRequest("/bar", domain="example.com:81", protocol="https")\n         self.assertEqual(\n             [\n-                "/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/"\n-                "foo",\n-                "/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/"\n-                "foo",\n+                "/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/" "foo",\n+                "/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/" "foo",\n             ],\n             self.rewriter("/foo"),\n         )\ndiff --git a/plone/cachepurging/tests/test_traversable_paths.py b/plone/cachepurging/tests/test_traversable_paths.py\nindex 06fd19a..637aa8a 100644\n--- a/plone/cachepurging/tests/test_traversable_paths.py\n+++ b/plone/cachepurging/tests/test_traversable_paths.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from OFS.interfaces import ITraversable\n from plone.cachepurging.paths import TraversablePurgePaths\n from zope.interface import implementer\n@@ -7,7 +6,7 @@\n \n \n @implementer(ITraversable)\n-class FauxTraversable(object):\n+class FauxTraversable:\n     def virtual_url_path(self):\n         return "foo"\n \ndiff --git a/plone/cachepurging/tests/test_utils.py b/plone/cachepurging/tests/test_utils.py\nindex 73b3dfb..2a96336 100644\n--- a/plone/cachepurging/tests/test_utils.py\n+++ b/plone/cachepurging/tests/test_utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging import utils\n from plone.cachepurging.interfaces import ICachePurgingSettings\n from plone.cachepurging.interfaces import IPurgePathRewriter\n@@ -15,7 +14,7 @@\n import zope.component.testing\n \n \n-class FauxContext(object):\n+class FauxContext:\n     pass\n \n \n@@ -77,14 +76,12 @@ def tearDown(self):\n         zope.component.testing.tearDown()\n \n     def test_no_purge_paths(self):\n-        self.assertEqual(\n-            [], list(utils.getPathsToPurge(self.context, self.request))\n-        )\n+        self.assertEqual([], list(utils.getPathsToPurge(self.context, self.request)))\n \n     def test_empty_relative_paths(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -96,14 +93,12 @@ def getAbsolutePaths(self):\n \n         provideAdapter(FauxPurgePaths, name="test1")\n \n-        self.assertEqual(\n-            [], list(utils.getPathsToPurge(self.context, self.request))\n-        )\n+        self.assertEqual([], list(utils.getPathsToPurge(self.context, self.request)))\n \n     def test_no_rewriter(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -123,7 +118,7 @@ def getAbsolutePaths(self):\n     def test_test_rewriter(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -137,7 +132,7 @@ def getAbsolutePaths(self):\n \n         @implementer(IPurgePathRewriter)\n         @adapter(FauxRequest)\n-        class DefaultRewriter(object):\n+        class DefaultRewriter:\n             def __init__(self, request):\n                 self.request = request\n \n@@ -154,7 +149,7 @@ def __call__(self, path):\n     def test_multiple_purge_paths(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths1(object):\n+        class FauxPurgePaths1:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -168,7 +163,7 @@ def getAbsolutePaths(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths2(object):\n+        class FauxPurgePaths2:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -182,7 +177,7 @@ def getAbsolutePaths(self):\n \n         @implementer(IPurgePathRewriter)\n         @adapter(FauxRequest)\n-        class DefaultRewriter(object):\n+        class DefaultRewriter:\n             def __init__(self, request):\n                 self.request = request\n \n@@ -208,7 +203,7 @@ def __call__(self, path):\n     def test_rewriter_abort(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths1(object):\n+        class FauxPurgePaths1:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -222,7 +217,7 @@ def getAbsolutePaths(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths2(object):\n+        class FauxPurgePaths2:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -236,7 +231,7 @@ def getAbsolutePaths(self):\n \n         @implementer(IPurgePathRewriter)\n         @adapter(FauxRequest)\n-        class DefaultRewriter(object):\n+        class DefaultRewriter:\n             def __init__(self, request):\n                 self.request = request\n \ndiff --git a/plone/cachepurging/tests/test_views.py b/plone/cachepurging/tests/test_views.py\nindex acc487a..6523760 100644\n--- a/plone/cachepurging/tests/test_views.py\n+++ b/plone/cachepurging/tests/test_views.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.browser import PurgeImmediately\n from plone.cachepurging.browser import QueuePurge\n from plone.cachepurging.interfaces import ICachePurgingSettings\n@@ -18,12 +17,11 @@\n import zope.component.testing\n \n \n-class FauxContext(object):\n+class FauxContext:\n     pass\n \n \n-class FauxResponse(object):\n-\n+class FauxResponse:\n     def __init__(self):\n         self.buffer = []\n \n@@ -39,12 +37,11 @@ class FauxRequest(dict):\n     form = dict()\n \n     def __init__(self, *args, **kw):\n-        super(FauxRequest, self).__init__(*args, **kw)\n+        super().__init__(*args, **kw)\n         self.response = FauxResponse()\n \n \n-\n-class Handler(object):\n+class Handler:\n     def __init__(self):\n         self.invocations = []\n \n@@ -100,7 +97,7 @@ def setUp(self):\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n-        class FauxPurgePaths(object):\n+        class FauxPurgePaths:\n             def __init__(self, context):\n                 self.context = context\n \n@@ -113,7 +110,7 @@ def getAbsolutePaths(self):\n         provideAdapter(FauxPurgePaths, name="test1")\n \n         @implementer(IPurger)\n-        class FauxPurger(object):\n+        class FauxPurger:\n             def purgeSync(self, url, httpVerb="PURGE"):\n                 return "200 OK", "cached", None\n \n@@ -132,16 +129,16 @@ def test_purge(self):\n         view = PurgeImmediately(FauxContext(), request)()\n         self.assertEqual(\n             [\n-                b\'Cache purging initiated...\\n\\n\',\n+                b"Cache purging initiated...\\n\\n",\n                 b"(hint: add \'?traceback\' to url to show full traceback in case of errors)\\n\\n",\n-                b\'Proxies to purge: http://localhost:1234\\n\',\n-                b\'- process path: /foo\\n\',\n-                b\'  - send to purge http://localhost:1234/foo\\n\',\n-                b\'    response with status: 200 OK, X-Cache: cached\\n\',\n-                b\'- process path: /bar\\n\',\n-                b\'  - send to purge http://localhost:1234/bar\\n\',\n-                b\'    response with status: 200 OK, X-Cache: cached\\n\',\n-                b\'Done.\\n\'\n+                b"Proxies to purge: http://localhost:1234\\n",\n+                b"- process path: /foo\\n",\n+                b"  - send to purge http://localhost:1234/foo\\n",\n+                b"    response with status: 200 OK, X-Cache: cached\\n",\n+                b"- process path: /bar\\n",\n+                b"  - send to purge http://localhost:1234/bar\\n",\n+                b"    response with status: 200 OK, X-Cache: cached\\n",\n+                b"Done.\\n",\n             ],\n             request.response.buffer,\n         )\ndiff --git a/plone/cachepurging/utils.py b/plone/cachepurging/utils.py\nindex 73d67ec..4f53eb0 100644\n--- a/plone/cachepurging/utils.py\n+++ b/plone/cachepurging/utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.cachepurging.interfaces import ICachePurgingSettings\n from plone.cachepurging.interfaces import IPurgePathRewriter\n from plone.registry.interfaces import IRegistry\n@@ -8,8 +7,7 @@\n \n \n def isCachePurgingEnabled(registry=None):\n-    """Return True if caching is enabled\n-    """\n+    """Return True if caching is enabled"""\n \n     if registry is None:\n         registry = queryUtility(IRegistry)\n@@ -37,14 +35,12 @@ def getPathsToPurge(context, request):\n                     yield relativePath\n                 else:\n                     rewrittenPaths = rewriter(relativePath) or []  # None -> []\n-                    for rewrittenPath in rewrittenPaths:\n-                        yield rewrittenPath\n+                    yield from rewrittenPaths\n \n         # add absoute paths, which are not\n         absolutePaths = pathProvider.getAbsolutePaths()\n         if absolutePaths:\n-            for absolutePath in absolutePaths:\n-                yield absolutePath\n+            yield from absolutePaths\n \n \n def getURLsToPurge(path, proxies):\ndiff --git a/setup.cfg b/setup.cfg\nindex 7feabc9..957bc4d 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -5,13 +5,12 @@ ignore =\n     bootstrap.py\n \n [isort]\n-force_alphabetical_sort=True\n-force_single_line=True\n-lines_after_imports=2\n-line_length=200\n-not_skip=__init__.py\n-\n-\n+# black compatible Plone isort rules:\n+profile = black\n+force_alphabetical_sort = True\n+force_single_line = True\n+lines_after_imports = 2\n \n [bdist_wheel]\n universal = 1\n+\ndiff --git a/setup.py b/setup.py\nindex 5b587f3..bb2c57f 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,24 +1,21 @@\n-from setuptools import setup, find_packages\n+from setuptools import find_packages\n+from setuptools import setup\n \n-version = \'2.0.5.dev0\'\n+\n+version = "3.0.0a1.dev0"\n \n setup(\n     name="plone.cachepurging",\n     version=version,\n     description="Cache purging support for Zope 2 applications",\n-    long_description=(\n-        open("README.rst").read() + "\\n" + open("CHANGES.rst").read()\n-    ),\n+    long_description=(open("README.rst").read() + "\\n" + open("CHANGES.rst").read()),\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Framework :: Plone",\n-        "Framework :: Plone :: 5.2",\n         "Framework :: Plone :: 6.0",\n         "Framework :: Plone :: Core",\n         "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n         "Programming Language :: Python",\n-        "Programming Language :: Python :: 2.7",\n-        "Programming Language :: Python :: 3.6",\n         "Programming Language :: Python :: 3.7",\n         "Programming Language :: Python :: 3.8",\n         "Programming Language :: Python :: 3.9",\n@@ -36,17 +33,8 @@\n         "setuptools",\n         "plone.registry",\n         "requests",\n-        "six",\n         "z3c.caching",\n-        "zope.annotation",\n-        "zope.component",\n-        "zope.event",\n-        "zope.i18nmessageid",\n-        "zope.interface",\n-        "zope.lifecycleevent",\n-        "zope.schema",\n-        "zope.testing",\n-        "Zope2",\n+        "Zope",\n     ],\n     extras_require={"test": ["plone.app.testing"]},\n )\n'

