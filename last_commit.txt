Repository: plone.i18n


Branch: refs/heads/master
Date: 2018-01-30T18:36:20+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.i18n/commit/5b4e43ef9821f4d571b35ba87e98836e2fa510ef

moved negotator code from PTS over here

Files changed:
A plone/i18n/negotiate/ptsnegotiator.py
A plone/i18n/overrides.zcml
M CHANGES.rst
M plone/i18n/negotiate/negotiate.py
M plone/i18n/normalizer/tests/test_normalizer.py
M plone/i18n/utility.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 2912e75..4a9971a 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -6,7 +6,8 @@ Changelog
 
 Breaking changes:
 
-- *add item here*
+- Move PTS Negotiator over form PlacelessTranslationService over to here in order to get rid of PTS itself.
+  [jensens, ksuess]
 
 New features:
 
diff --git a/plone/i18n/negotiate/negotiate.py b/plone/i18n/negotiate/negotiate.py
index 6c5d626..a74d986 100644
--- a/plone/i18n/negotiate/negotiate.py
+++ b/plone/i18n/negotiate/negotiate.py
@@ -21,10 +21,11 @@ def __init__(self, site, request):
         setCookieEverywhere = tool.settings.set_cookie_always
         authOnly = tool.settings.authenticated_users_only
         useRequest = tool.settings.use_request_negotiation
-        useDefault = 1 # This should never be disabled
+        useDefault = 1  # This should never be disabled
         langsCookie = None
         if usePath:
-            # This one is set if there is an allowed language in the current path
+            # This one is set if there is an allowed language in the current
+            # path
             langs.append(tool.getPathLanguage(request))
 
         if useContent:
@@ -34,7 +35,10 @@ def __init__(self, site, request):
             # If we are using the cookie stuff we provide the setter here
             set_language = request.get('set_language', None)
             if set_language:
-                langsCookie = tool.setLanguageCookie(set_language, request=request)
+                langsCookie = tool.setLanguageCookie(
+                    set_language,
+                    request=request
+                )
             else:
                 # Get from cookie
                 langsCookie = tool.getLanguageCookie(request)
@@ -58,7 +62,7 @@ def __init__(self, site, request):
         langs = [lang for lang in langs if lang is not None]
 
         # Set cookie language to language
-        if setCookieEverywhere  and langs[0] != langsCookie:
+        if setCookieEverywhere and langs[0] != langsCookie:
             # We need to make sure its not a subrequest otherwise we are going
             # To change the language of the main request
             from plone.subrequest import ISubRequest
diff --git a/plone/i18n/negotiate/ptsnegotiator.py b/plone/i18n/negotiate/ptsnegotiator.py
new file mode 100644
index 0000000..c887469
--- /dev/null
+++ b/plone/i18n/negotiate/ptsnegotiator.py
@@ -0,0 +1,260 @@
+# -*- coding: utf-8 -*-
+from zope.i18n.interfaces import IUserPreferredLanguages
+from zope.interface import implementer
+
+
+# this is the negotiator from old PlacelessTranslationService
+# may be cleaned up in future
+
+_langPrefsRegistry = {}
+
+
+def getAcceptedHelper(self, request, kind='language'):
+    """this is patched on prefs classes which don't define the getAccepted
+    classes but define the deprecated getPreferredLanguages method"""
+    return self.getPreferredLanguages()
+
+
+def registerLangPrefsMethod(prefs, kind='language'):
+    # check for correct format of prefs
+    if not  isinstance(prefs, dict):
+        prefs = {'klass': prefs, 'priority': 0}
+    # add chain for kind
+    if kind not in _langPrefsRegistry:
+        _langPrefsRegistry[kind] = []
+    # backwards compatibilty monkey patch
+    if not hasattr(prefs['klass'], 'getAccepted'):
+        prefs['klass'].getAccepted = getAcceptedHelper
+    # add this pref helper
+    _langPrefsRegistry[kind].append(prefs)
+    # sort by priority
+    _langPrefsRegistry[kind].sort(
+        lambda x, y: cmp(y['priority'], x['priority'])
+    )
+
+
+def getLangPrefs(env, kind='language'):
+    """get higest prio method for kind"""
+    for pref in _langPrefsRegistry[kind]:
+        handler = pref['klass'](env)
+        accepted = handler.getAccepted(env, kind)
+        if accepted:
+            return accepted
+    return ()
+
+
+def lang_normalize(lang):
+    """filter"""
+    return lang.replace('_', '-')
+
+
+def str_lower(aString):
+    """filter"""
+    return aString.lower()
+
+
+def str_strip(aString):
+    """filter"""
+    return aString.strip()
+
+
+def type_accepted(available, preferred):
+    # ex: preferred is text/* and available is text/html
+    av = available.split('/')
+    pr = preferred.split('/')
+    if len(av) < 2 or len(pr) < 2:
+        return False
+    return pr[1] == '*' and pr[0] == av[0]
+
+
+def lang_accepted(available, preferred):
+    # ex: available is pt, preferred is pt-br
+    return available.startswith(preferred)
+
+
+def _false(*a, **kw):
+    pass
+
+
+class BrowserAccept(object):
+
+    filters = {
+        'content-type': (str_lower,),
+        'language': (str_lower, lang_normalize, str_strip),
+    }
+
+    def __init__(self, request):
+        pass
+
+    def getAccepted(self, request, kind='content-type'):
+        custom_name = ('user_%s' % kind).lower()
+        if kind == 'content-type':
+            header_name = ('HTTP_ACCEPT').upper()
+        else:
+            header_name = ('HTTP_ACCEPT_%s' % kind).upper()
+
+        user_accepts = request.get(custom_name, '')
+        http_accepts = request.get(header_name, '')
+
+        if (
+            user_accepts and
+            http_accepts and
+            user_accepts == request.cookies.get('custom_name')
+        ):
+            user_accepts = [a.strip() for a in user_accepts.split(',')]
+            http_accepts = [a.strip() for a in http_accepts.split(',')]
+            for l in user_accepts:
+                if l not in http_accepts:
+                    req_accepts = user_accepts + http_accepts
+                    break
+                else:
+                    # user_accepts is a subset of http_accepts
+                    request.RESPONSE.expireCookie('custom_name', path='/')
+                    req_accepts = http_accepts
+        else:
+            req_accepts = (user_accepts + ',' + http_accepts).split(',')
+
+        accepts = []
+        i = 0
+        length = len(req_accepts)
+        filters = self.filters.get(kind, ())
+
+        # parse quality strings and build a tuple like
+        # ((float(quality), lang), (float(quality), lang))
+        # which is sorted afterwards if no quality string is given then the
+        # list order is used as quality indicator
+        for accept in req_accepts:
+            for normalizer in filters:
+                accept = normalizer(accept)
+            if accept:
+                ll = accept.split(';', 2)
+                quality = []
+
+                if len(ll) == 2:
+                    try:
+                        q = l[1]
+                        if q.startswith('q='):
+                            q = q.split('=', 2)[1]
+                            quality = float(q)
+                    except Exception:
+                        pass
+
+                if quality == []:
+                    quality = float(length - i)
+
+                accepts.append((quality, l[0]))
+                i += 1
+
+        # sort and reverse it
+        accepts.sort()
+        accepts.reverse()
+
+        return [a[1] for a in accepts]
+
+
+class CookieAccept(object):
+    filters = (str_lower, lang_normalize, str_strip)
+
+    def __init__(self, request):
+        pass
+
+    def getAccepted(self, request, kind='language'):
+        if not hasattr(request, 'cookies'):
+            return ()
+        language = request.cookies.get('pts_language', None)
+        if language:
+            if isinstance(language, tuple):
+                return language
+            else:
+                # filter
+                for filter in self.filters:
+                    language = filter(language)
+                return (language,)
+        else:
+            return ()
+
+
+def setCookieLanguage(request, lang, REQUEST=None):
+    """sets the language to a cookie
+
+    request - the request object
+    lang - language as string like de or pt_BR (it's normalizd)
+    """
+    if isinstance(lang, tuple):
+        lang = lang[1]
+    lang = str_lower(lang_normalize(lang))
+    request.RESPONSE.setCookie('pts_language', lang)
+    if REQUEST:
+        REQUEST.RESPONSE.redirect(REQUEST.URL0)
+    else:
+        return lang
+
+
+# higher number = higher priority
+# if a acceptor returns a false value (() or None) then the next acceptor
+# in the chain is queried
+registerLangPrefsMethod(
+    {'klass': BrowserAccept, 'priority': 10},
+    'language'
+)
+registerLangPrefsMethod(
+    {'klass': CookieAccept, 'priority': 40},
+    'language'
+)
+registerLangPrefsMethod(
+    {'klass': BrowserAccept, 'priority': 10},
+    'content-type'
+)
+
+
+class Negotiator(object):
+
+    tests = {
+        'content-type': type_accepted,
+        'language': lang_accepted,
+    }
+
+    def negotiate(self, choices, request, kind='content-type'):
+        choices = tuple(choices)
+        return self._negotiate(choices, request, kind)
+
+    def _negotiate(self, choices, request, kind):
+        userchoices = getLangPrefs(request, kind)
+        # Prioritize on the user preferred choices. Return the first user
+        # preferred choice that the object has available.
+        test = self.tests.get(kind, _false)
+        for choice in userchoices:
+            if choice in choices:
+                return choice
+            for l_avail in choices:
+                if test(l_avail, choice):
+                    return l_avail
+        return None
+
+    # backwards compatibility... should be deprecated
+    def getLanguage(self, langs, request):
+        return self.negotiate(langs, request, 'language')
+
+    def getLanguages(self, request):
+        return getLangPrefs(request, 'language')
+
+
+negotiator = Negotiator()
+
+
+def negotiate(langs, request):
+    return negotiator.negotiate(langs, request, 'language')
+
+
+@implementer(IUserPreferredLanguages)
+class PTSLanguages(object):
+    """Languages adapter that chooses languages for the zope.i18n machinery.
+
+    This used to be part of Products.Five.i18n.
+    """
+
+    def __init__(self, context):
+        self.context = context
+
+    def getPreferredLanguages(self):
+        return getLangPrefs(self.context)
diff --git a/plone/i18n/normalizer/tests/test_normalizer.py b/plone/i18n/normalizer/tests/test_normalizer.py
index 4216196..132393f 100644
--- a/plone/i18n/normalizer/tests/test_normalizer.py
+++ b/plone/i18n/normalizer/tests/test_normalizer.py
@@ -13,7 +13,6 @@
 import unittest
 
 
-
 def testIDNormalizer():
     """
       >>> util = queryUtility(IIDNormalizer)
diff --git a/plone/i18n/overrides.zcml b/plone/i18n/overrides.zcml
new file mode 100644
index 0000000..cbc0507
--- /dev/null
+++ b/plone/i18n/overrides.zcml
@@ -0,0 +1,9 @@
+<configure xmlns="http://namespaces.zope.org/zope">
+
+  <adapter
+    for="zope.publisher.interfaces.http.IHTTPRequest"
+    provides="zope.i18n.interfaces.IUserPreferredLanguages"
+    factory=".negotiate.ptsnegotiator.PTSLanguages"
+    />
+
+</configure>
diff --git a/plone/i18n/utility.py b/plone/i18n/utility.py
index 3ab94a2..d22214e 100644
--- a/plone/i18n/utility.py
+++ b/plone/i18n/utility.py
@@ -6,6 +6,7 @@
 from plone.i18n.locales.interfaces import ICcTLDInformation
 from plone.i18n.locales.interfaces import IContentLanguageAvailability
 from plone.i18n.locales.interfaces import ICountryAvailability
+from plone.i18n.negotiate.ptsnegotiator import registerLangPrefsMethod
 from plone.registry.interfaces import IRegistry
 from Products.CMFCore.interfaces import IDublinCore
 from Products.CMFPlone.interfaces import ILanguageSchema
@@ -18,12 +19,6 @@
 from zope.globalrequest import getRequest
 from zope.interface import implementer
 
-try:
-    from Products.PlacelessTranslationService.Negotiator import registerLangPrefsMethod  # noqa
-    _hasPTS = 1
-except ImportError:
-    _hasPTS = 0
-
 
 class LanguageBinding(object):
     """Helper which holding language infos in request."""
@@ -481,5 +476,4 @@ def getPreferredLanguages(self):
         return self.languages
 
 
-if _hasPTS:
-    registerLangPrefsMethod({'klass': PrefsForPTS, 'priority': 100})
+registerLangPrefsMethod({'klass': PrefsForPTS, 'priority': 100})


Repository: plone.i18n


Branch: refs/heads/master
Date: 2018-01-31T11:03:25+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.i18n/commit/34e4e557a2542fc819b8135cffc8934d9b894923

Merge pull request #22 from plone/move-pts-negotiator

Moved negotiator code from PTS over here

Files changed:
A plone/i18n/negotiate/ptsnegotiator.py
A plone/i18n/overrides.zcml
M CHANGES.rst
M plone/i18n/negotiate/negotiate.py
M plone/i18n/normalizer/tests/test_normalizer.py
M plone/i18n/utility.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 2912e75..4a9971a 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -6,7 +6,8 @@ Changelog
 
 Breaking changes:
 
-- *add item here*
+- Move PTS Negotiator over form PlacelessTranslationService over to here in order to get rid of PTS itself.
+  [jensens, ksuess]
 
 New features:
 
diff --git a/plone/i18n/negotiate/negotiate.py b/plone/i18n/negotiate/negotiate.py
index 6c5d626..a74d986 100644
--- a/plone/i18n/negotiate/negotiate.py
+++ b/plone/i18n/negotiate/negotiate.py
@@ -21,10 +21,11 @@ def __init__(self, site, request):
         setCookieEverywhere = tool.settings.set_cookie_always
         authOnly = tool.settings.authenticated_users_only
         useRequest = tool.settings.use_request_negotiation
-        useDefault = 1 # This should never be disabled
+        useDefault = 1  # This should never be disabled
         langsCookie = None
         if usePath:
-            # This one is set if there is an allowed language in the current path
+            # This one is set if there is an allowed language in the current
+            # path
             langs.append(tool.getPathLanguage(request))
 
         if useContent:
@@ -34,7 +35,10 @@ def __init__(self, site, request):
             # If we are using the cookie stuff we provide the setter here
             set_language = request.get('set_language', None)
             if set_language:
-                langsCookie = tool.setLanguageCookie(set_language, request=request)
+                langsCookie = tool.setLanguageCookie(
+                    set_language,
+                    request=request
+                )
             else:
                 # Get from cookie
                 langsCookie = tool.getLanguageCookie(request)
@@ -58,7 +62,7 @@ def __init__(self, site, request):
         langs = [lang for lang in langs if lang is not None]
 
         # Set cookie language to language
-        if setCookieEverywhere  and langs[0] != langsCookie:
+        if setCookieEverywhere and langs[0] != langsCookie:
             # We need to make sure its not a subrequest otherwise we are going
             # To change the language of the main request
             from plone.subrequest import ISubRequest
diff --git a/plone/i18n/negotiate/ptsnegotiator.py b/plone/i18n/negotiate/ptsnegotiator.py
new file mode 100644
index 0000000..c887469
--- /dev/null
+++ b/plone/i18n/negotiate/ptsnegotiator.py
@@ -0,0 +1,260 @@
+# -*- coding: utf-8 -*-
+from zope.i18n.interfaces import IUserPreferredLanguages
+from zope.interface import implementer
+
+
+# this is the negotiator from old PlacelessTranslationService
+# may be cleaned up in future
+
+_langPrefsRegistry = {}
+
+
+def getAcceptedHelper(self, request, kind='language'):
+    """this is patched on prefs classes which don't define the getAccepted
+    classes but define the deprecated getPreferredLanguages method"""
+    return self.getPreferredLanguages()
+
+
+def registerLangPrefsMethod(prefs, kind='language'):
+    # check for correct format of prefs
+    if not  isinstance(prefs, dict):
+        prefs = {'klass': prefs, 'priority': 0}
+    # add chain for kind
+    if kind not in _langPrefsRegistry:
+        _langPrefsRegistry[kind] = []
+    # backwards compatibilty monkey patch
+    if not hasattr(prefs['klass'], 'getAccepted'):
+        prefs['klass'].getAccepted = getAcceptedHelper
+    # add this pref helper
+    _langPrefsRegistry[kind].append(prefs)
+    # sort by priority
+    _langPrefsRegistry[kind].sort(
+        lambda x, y: cmp(y['priority'], x['priority'])
+    )
+
+
+def getLangPrefs(env, kind='language'):
+    """get higest prio method for kind"""
+    for pref in _langPrefsRegistry[kind]:
+        handler = pref['klass'](env)
+        accepted = handler.getAccepted(env, kind)
+        if accepted:
+            return accepted
+    return ()
+
+
+def lang_normalize(lang):
+    """filter"""
+    return lang.replace('_', '-')
+
+
+def str_lower(aString):
+    """filter"""
+    return aString.lower()
+
+
+def str_strip(aString):
+    """filter"""
+    return aString.strip()
+
+
+def type_accepted(available, preferred):
+    # ex: preferred is text/* and available is text/html
+    av = available.split('/')
+    pr = preferred.split('/')
+    if len(av) < 2 or len(pr) < 2:
+        return False
+    return pr[1] == '*' and pr[0] == av[0]
+
+
+def lang_accepted(available, preferred):
+    # ex: available is pt, preferred is pt-br
+    return available.startswith(preferred)
+
+
+def _false(*a, **kw):
+    pass
+
+
+class BrowserAccept(object):
+
+    filters = {
+        'content-type': (str_lower,),
+        'language': (str_lower, lang_normalize, str_strip),
+    }
+
+    def __init__(self, request):
+        pass
+
+    def getAccepted(self, request, kind='content-type'):
+        custom_name = ('user_%s' % kind).lower()
+        if kind == 'content-type':
+            header_name = ('HTTP_ACCEPT').upper()
+        else:
+            header_name = ('HTTP_ACCEPT_%s' % kind).upper()
+
+        user_accepts = request.get(custom_name, '')
+        http_accepts = request.get(header_name, '')
+
+        if (
+            user_accepts and
+            http_accepts and
+            user_accepts == request.cookies.get('custom_name')
+        ):
+            user_accepts = [a.strip() for a in user_accepts.split(',')]
+            http_accepts = [a.strip() for a in http_accepts.split(',')]
+            for l in user_accepts:
+                if l not in http_accepts:
+                    req_accepts = user_accepts + http_accepts
+                    break
+                else:
+                    # user_accepts is a subset of http_accepts
+                    request.RESPONSE.expireCookie('custom_name', path='/')
+                    req_accepts = http_accepts
+        else:
+            req_accepts = (user_accepts + ',' + http_accepts).split(',')
+
+        accepts = []
+        i = 0
+        length = len(req_accepts)
+        filters = self.filters.get(kind, ())
+
+        # parse quality strings and build a tuple like
+        # ((float(quality), lang), (float(quality), lang))
+        # which is sorted afterwards if no quality string is given then the
+        # list order is used as quality indicator
+        for accept in req_accepts:
+            for normalizer in filters:
+                accept = normalizer(accept)
+            if accept:
+                ll = accept.split(';', 2)
+                quality = []
+
+                if len(ll) == 2:
+                    try:
+                        q = l[1]
+                        if q.startswith('q='):
+                            q = q.split('=', 2)[1]
+                            quality = float(q)
+                    except Exception:
+                        pass
+
+                if quality == []:
+                    quality = float(length - i)
+
+                accepts.append((quality, l[0]))
+                i += 1
+
+        # sort and reverse it
+        accepts.sort()
+        accepts.reverse()
+
+        return [a[1] for a in accepts]
+
+
+class CookieAccept(object):
+    filters = (str_lower, lang_normalize, str_strip)
+
+    def __init__(self, request):
+        pass
+
+    def getAccepted(self, request, kind='language'):
+        if not hasattr(request, 'cookies'):
+            return ()
+        language = request.cookies.get('pts_language', None)
+        if language:
+            if isinstance(language, tuple):
+                return language
+            else:
+                # filter
+                for filter in self.filters:
+                    language = filter(language)
+                return (language,)
+        else:
+            return ()
+
+
+def setCookieLanguage(request, lang, REQUEST=None):
+    """sets the language to a cookie
+
+    request - the request object
+    lang - language as string like de or pt_BR (it's normalizd)
+    """
+    if isinstance(lang, tuple):
+        lang = lang[1]
+    lang = str_lower(lang_normalize(lang))
+    request.RESPONSE.setCookie('pts_language', lang)
+    if REQUEST:
+        REQUEST.RESPONSE.redirect(REQUEST.URL0)
+    else:
+        return lang
+
+
+# higher number = higher priority
+# if a acceptor returns a false value (() or None) then the next acceptor
+# in the chain is queried
+registerLangPrefsMethod(
+    {'klass': BrowserAccept, 'priority': 10},
+    'language'
+)
+registerLangPrefsMethod(
+    {'klass': CookieAccept, 'priority': 40},
+    'language'
+)
+registerLangPrefsMethod(
+    {'klass': BrowserAccept, 'priority': 10},
+    'content-type'
+)
+
+
+class Negotiator(object):
+
+    tests = {
+        'content-type': type_accepted,
+        'language': lang_accepted,
+    }
+
+    def negotiate(self, choices, request, kind='content-type'):
+        choices = tuple(choices)
+        return self._negotiate(choices, request, kind)
+
+    def _negotiate(self, choices, request, kind):
+        userchoices = getLangPrefs(request, kind)
+        # Prioritize on the user preferred choices. Return the first user
+        # preferred choice that the object has available.
+        test = self.tests.get(kind, _false)
+        for choice in userchoices:
+            if choice in choices:
+                return choice
+            for l_avail in choices:
+                if test(l_avail, choice):
+                    return l_avail
+        return None
+
+    # backwards compatibility... should be deprecated
+    def getLanguage(self, langs, request):
+        return self.negotiate(langs, request, 'language')
+
+    def getLanguages(self, request):
+        return getLangPrefs(request, 'language')
+
+
+negotiator = Negotiator()
+
+
+def negotiate(langs, request):
+    return negotiator.negotiate(langs, request, 'language')
+
+
+@implementer(IUserPreferredLanguages)
+class PTSLanguages(object):
+    """Languages adapter that chooses languages for the zope.i18n machinery.
+
+    This used to be part of Products.Five.i18n.
+    """
+
+    def __init__(self, context):
+        self.context = context
+
+    def getPreferredLanguages(self):
+        return getLangPrefs(self.context)
diff --git a/plone/i18n/normalizer/tests/test_normalizer.py b/plone/i18n/normalizer/tests/test_normalizer.py
index 4216196..132393f 100644
--- a/plone/i18n/normalizer/tests/test_normalizer.py
+++ b/plone/i18n/normalizer/tests/test_normalizer.py
@@ -13,7 +13,6 @@
 import unittest
 
 
-
 def testIDNormalizer():
     """
       >>> util = queryUtility(IIDNormalizer)
diff --git a/plone/i18n/overrides.zcml b/plone/i18n/overrides.zcml
new file mode 100644
index 0000000..cbc0507
--- /dev/null
+++ b/plone/i18n/overrides.zcml
@@ -0,0 +1,9 @@
+<configure xmlns="http://namespaces.zope.org/zope">
+
+  <adapter
+    for="zope.publisher.interfaces.http.IHTTPRequest"
+    provides="zope.i18n.interfaces.IUserPreferredLanguages"
+    factory=".negotiate.ptsnegotiator.PTSLanguages"
+    />
+
+</configure>
diff --git a/plone/i18n/utility.py b/plone/i18n/utility.py
index 3ab94a2..d22214e 100644
--- a/plone/i18n/utility.py
+++ b/plone/i18n/utility.py
@@ -6,6 +6,7 @@
 from plone.i18n.locales.interfaces import ICcTLDInformation
 from plone.i18n.locales.interfaces import IContentLanguageAvailability
 from plone.i18n.locales.interfaces import ICountryAvailability
+from plone.i18n.negotiate.ptsnegotiator import registerLangPrefsMethod
 from plone.registry.interfaces import IRegistry
 from Products.CMFCore.interfaces import IDublinCore
 from Products.CMFPlone.interfaces import ILanguageSchema
@@ -18,12 +19,6 @@
 from zope.globalrequest import getRequest
 from zope.interface import implementer
 
-try:
-    from Products.PlacelessTranslationService.Negotiator import registerLangPrefsMethod  # noqa
-    _hasPTS = 1
-except ImportError:
-    _hasPTS = 0
-
 
 class LanguageBinding(object):
     """Helper which holding language infos in request."""
@@ -481,5 +476,4 @@ def getPreferredLanguages(self):
         return self.languages
 
 
-if _hasPTS:
-    registerLangPrefsMethod({'klass': PrefsForPTS, 'priority': 100})
+registerLangPrefsMethod({'klass': PrefsForPTS, 'priority': 100})


