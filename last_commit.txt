Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-04-23T22:50:24+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.app.testing/commit/5f0b64fc5ce23adebd73280dd3b51f695b44eeca

start porting to py3

Files changed:
A .editorconfig
A .travis.yml
A tox.ini
M buildout.cfg
M setup.cfg
M setup.py
D plone/__init__.py
D plone/app/__init__.py
D plone/app/testing/__init__.py
D plone/app/testing/bbb.py
D plone/app/testing/cleanup.py
D plone/app/testing/cleanup.rst
D plone/app/testing/helpers.py
D plone/app/testing/helpers.rst
D plone/app/testing/interfaces.py
D plone/app/testing/layers.py
D plone/app/testing/layers.rst
D plone/app/testing/profile/metadata.xml
D plone/app/testing/selenium.rst
D plone/app/testing/selenium_layers.py
D plone/app/testing/tests.py
D plone/app/testing/utils.py

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..512361c\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,36 @@\n+# EditorConfig Configurtaion file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.travis.yml b/.travis.yml\nnew file mode 100644\nindex 0000000..f55fe5f\n--- /dev/null\n+++ b/.travis.yml\n@@ -0,0 +1,38 @@\n+language: python\n+sudo: false\n+\n+matrix:\n+    include:\n+        - python: "2.7"\n+          env: TOXENV=lint-py27\n+        - python: "3.6"\n+          env: TOXENV=lint-py36\n+        - python: "2.7"\n+          env: TOXENV=py27\n+        - python: "3.4"\n+          env: TOXENV=py34\n+        - python: "3.5"\n+          env: TOXENV=py35\n+        - python: "3.6"\n+          env: TOXENV=py36\n+        - python: "3.7-dev"\n+          env: TOXENV=py37\n+    allow_failures:\n+        - python: "3.7-dev"\n+          env: TOXENV=py37\n+\n+install:\n+    - travis_retry pip install -U pip setuptools\n+    - travis_retry pip install -U tox coveralls coverage\n+\n+script:\n+    - travis_retry tox\n+\n+after_success:\n+    - coverage combine\n+    - coveralls\n+\n+notifications:\n+    email: false\n+cache:\n+    pip: true\ndiff --git a/buildout.cfg b/buildout.cfg\nindex e61bc5b..be1924a 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -1,24 +1,43 @@\n [buildout]\n extends = https://raw.githubusercontent.com/collective/buildout.plonetest/master/test-5.x.cfg\n-parts = coverage test test-chrome test-ie report report-xml\n+\n+parts =\n+    coverage\n+    test\n+    test-chrome\n+    test-ie\n+    report\n+    report-xml\n+\n extensions = mr.developer\n+\n sources = sources\n+versions = versions\n+\n auto-checkout =\n     plone.testing\n     Products.GenericSetup\n \n+sources-dir = src-mrd\n+\n+develop =\n+    src-mrd/plone.testing\n+    src-mrd/Products.GenericSetup\n+\n [remotes]\n plone = git://github.com/plone\n plone_push = git@github.com:plone\n-zope = svn://svn.zope.org/repos/main/\n+#zope = svn://svn.zope.org/repos/main/\n+zope = git://github.com/zopefoundation\n+zope_push = git@github.com:zopefoundation\n \n [versions]\n plone.app.testing =\n Products.GenericSetup =\n \n [sources]\n-plone.testing         = git ${remotes:plone}/plone.testing.git pushurl=${remotes:plone_push}/plone.testing.git branch=master\n-Products.GenericSetup = svn ${remotes:zope}/Products.GenericSetup/trunk\n+plone.testing         = git ${remotes:plone}/plone.testing.git pushurl=${remotes:plone_push}/plone.testing.git branch=py3\n+Products.GenericSetup = git ${remotes:zope}/Products.GenericSetup.git pushurl=${remotes:plone_push}/Products.GenericSetup branch=master\n \n [test]\n recipe = collective.xmltestreport\ndiff --git a/plone/__init__.py b/plone/__init__.py\ndeleted file mode 100644\nindex 68c04af..0000000\n--- a/plone/__init__.py\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\ndeleted file mode 100644\nindex 68c04af..0000000\n--- a/plone/app/__init__.py\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\ndiff --git a/plone/app/testing/__init__.py b/plone/app/testing/__init__.py\ndeleted file mode 100644\nindex 05bb224..0000000\n--- a/plone/app/testing/__init__.py\n+++ /dev/null\n@@ -1,34 +0,0 @@\n-# -*- coding: utf-8 -*-\n-# flake8: noqa\n-from plone.app.testing.cleanup import cleanUpMultiPlugins\n-from plone.app.testing.helpers import applyProfile\n-from plone.app.testing.helpers import login\n-from plone.app.testing.helpers import logout\n-from plone.app.testing.helpers import PloneSandboxLayer\n-from plone.app.testing.helpers import ploneSite\n-from plone.app.testing.helpers import PloneWithPackageLayer\n-from plone.app.testing.helpers import popGlobalRegistry\n-from plone.app.testing.helpers import pushGlobalRegistry\n-from plone.app.testing.helpers import quickInstallProduct\n-from plone.app.testing.helpers import setRoles\n-from plone.app.testing.helpers import tearDownMultiPluginRegistration\n-from plone.app.testing.interfaces import DEFAULT_LANGUAGE\n-from plone.app.testing.interfaces import PLONE_SITE_ID\n-from plone.app.testing.interfaces import PLONE_SITE_TITLE\n-from plone.app.testing.interfaces import ROBOT_TEST_LEVEL\n-from plone.app.testing.interfaces import SITE_OWNER_NAME\n-from plone.app.testing.interfaces import SITE_OWNER_PASSWORD\n-from plone.app.testing.interfaces import TEST_USER_ID\n-from plone.app.testing.interfaces import TEST_USER_NAME\n-from plone.app.testing.interfaces import TEST_USER_PASSWORD\n-from plone.app.testing.interfaces import TEST_USER_ROLES\n-from plone.app.testing.layers import FunctionalTesting\n-from plone.app.testing.layers import IntegrationTesting\n-from plone.app.testing.layers import MOCK_MAILHOST_FIXTURE\n-from plone.app.testing.layers import PLONE_FIXTURE\n-from plone.app.testing.layers import PLONE_FTP_SERVER\n-from plone.app.testing.layers import PLONE_FUNCTIONAL_TESTING\n-from plone.app.testing.layers import PLONE_INTEGRATION_TESTING\n-from plone.app.testing.layers import PLONE_ZSERVER\n-from plone.app.testing.layers import PloneFixture\n-from plone.app.testing.layers import PloneTestLifecycle\ndiff --git a/plone/app/testing/bbb.py b/plone/app/testing/bbb.py\ndeleted file mode 100644\nindex 8d29412..0000000\n--- a/plone/app/testing/bbb.py\n+++ /dev/null\n@@ -1,124 +0,0 @@\n-# -*- coding: utf-8 -*-\n-"""Backwards-compatibility test class for PloneTestCase."""\n-\n-from AccessControl import getSecurityManager\n-from plone.app import testing\n-from plone.testing import z2\n-from Products.CMFPlone.utils import _createObjectByType\n-from Testing.ZopeTestCase.functional import Functional\n-\n-import transaction\n-import unittest\n-\n-\n-def _createMemberarea(portal, user_id):\n-    mtool = portal.portal_membership\n-    members = mtool.getMembersFolder()\n-    if members is None:\n-        _createObjectByType(\'Folder\', portal, id=\'Members\')\n-    if not mtool.getMemberareaCreationFlag():\n-        mtool.setMemberareaCreationFlag()\n-    mtool.createMemberArea(user_id)\n-    if mtool.getMemberareaCreationFlag():\n-        mtool.setMemberareaCreationFlag()\n-\n-\n-class PloneTestCaseFixture(testing.PloneSandboxLayer):\n-\n-    defaultBases = (testing.PLONE_FIXTURE,)\n-\n-    def setUpZope(self, app, configurationContext):\n-        import Products.ATContentTypes\n-        self.loadZCML(package=Products.ATContentTypes)\n-\n-        z2.installProduct(app, \'Products.Archetypes\')\n-        z2.installProduct(app, \'Products.ATContentTypes\')\n-        z2.installProduct(app, \'plone.app.blob\')\n-        z2.installProduct(app, \'plone.app.collection\')\n-\n-    def setUpPloneSite(self, portal):\n-        # restore default workflow\n-        testing.applyProfile(portal, \'Products.CMFPlone:testfixture\')\n-\n-        # add default content\n-        testing.applyProfile(portal, \'Products.ATContentTypes:content\')\n-\n-        # add home folder for default test user\n-        _createMemberarea(portal, testing.TEST_USER_ID)\n-\n-    def tearDownZope(self, app):\n-        z2.uninstallProduct(app, \'plone.app.collection\')\n-        z2.uninstallProduct(app, \'plone.app.blob\')\n-        z2.uninstallProduct(app, \'Products.ATContentTypes\')\n-        z2.uninstallProduct(app, \'Products.Archetypes\')\n-\n-PTC_FIXTURE = PloneTestCaseFixture()\n-PTC_FUNCTIONAL_TESTING = testing.FunctionalTesting(\n-    bases=(PTC_FIXTURE,), name=\'PloneTestCase:Functional\')\n-\n-\n-class PloneTestCase(Functional, unittest.TestCase):\n-\n-    layer = PTC_FUNCTIONAL_TESTING\n-\n-    def setUp(self):\n-        """Set up before each test."""\n-        self.beforeSetUp()\n-        self.app = self.layer[\'app\']\n-        self.portal = self.layer[\'portal\']\n-        self.folder = self.portal.portal_membership.getHomeFolder(\n-            testing.TEST_USER_ID)\n-        transaction.commit()\n-        self.afterSetUp()\n-\n-    def beforeSetUp(self):\n-        """Hook to do setup before the portal is created."""\n-        pass\n-\n-    def afterSetUp(self):\n-        """Hook to do setup after the portal is created."""\n-\n-    def tearDown(self):\n-        """Tear down after each test."""\n-        self.beforeTearDown()\n-        transaction.abort()\n-        super(PloneTestCase, self).tearDown()\n-        self.afterTearDown()\n-\n-    def beforeTearDown(self):\n-        """Hook to do teardown before the portal is removed."""\n-\n-    def afterTearDown(self):\n-        """Hook to do teardown after the portal is removed."""\n-\n-    def setRoles(self, roles, name=testing.TEST_USER_ID):\n-        """Set the effective roles of a user."""\n-        testing.setRoles(self.portal, name, roles)\n-\n-    def setGroups(self, groups, name=testing.TEST_USER_ID):\n-        \'\'\'Changes the user\'s groups.\'\'\'\n-        uf = self.portal[\'acl_users\']\n-        uf.userSetGroups(name, list(groups))\n-        user = getSecurityManager().getUser()\n-        if name == user.getId():\n-            self.login(user.getUserName())\n-\n-    def setPermissions(self, permissions, role=\'Member\'):\n-        """Changes the permissions assigned to role."""\n-        self.portal.manage_role(role, list(permissions))\n-\n-    def login(self, userName=testing.TEST_USER_NAME):\n-        """Log in to the portal as the given user."""\n-        testing.login(self.portal, userName)\n-\n-    def loginAsPortalOwner(self, userName=testing.SITE_OWNER_NAME):\n-        """Log in to the portal as the user who created it."""\n-        z2.login(self.app[\'acl_users\'], userName)\n-\n-    def logout(self):\n-        """Log out, i.e. become anonymous."""\n-        testing.logout()\n-\n-    def createMemberarea(self, name):\n-        """Create a minimal memberarea."""\n-        _createMemberarea(self.portal, name)\ndiff --git a/plone/app/testing/cleanup.py b/plone/app/testing/cleanup.py\ndeleted file mode 100644\nindex 0dadf3d..0000000\n--- a/plone/app/testing/cleanup.py\n+++ /dev/null\n@@ -1,40 +0,0 @@\n-# -*- coding: utf-8 -*-\n-"""Cleanup handlers for various global registries\n-"""\n-\n-from zope.testing.cleanup import addCleanUp\n-\n-\n-# Make sure cleanup handlers from GenericSetup are registered\n-try:\n-    import Products.GenericSetup.zcml\n-except ImportError:\n-    pass\n-\n-# Make sure cleanup handlers from PAS are registered\n-try:\n-    import Products.PluggableAuthService.zcml  # noqa\n-except ImportError:\n-    pass\n-\n-\n-def cleanUpMultiPlugins():\n-    try:\n-        from Products.PluggableAuthService.PluggableAuthService import MultiPlugins  # noqa\n-    except ImportError:\n-        pass\n-    else:\n-\n-        zap = []\n-\n-        # Don\'t stomp on the things the other cleanup handler will deal with\n-        from Products.PluggableAuthService import zcml\n-        for plugin in MultiPlugins:\n-            if plugin not in zcml._mt_regs:\n-                zap.append(plugin)\n-\n-        for plugin in zap:\n-            MultiPlugins.remove(plugin)\n-\n-addCleanUp(cleanUpMultiPlugins)\n-del addCleanUp\ndiff --git a/plone/app/testing/cleanup.rst b/plone/app/testing/cleanup.rst\ndeleted file mode 100644\nindex a391753..0000000\n--- a/plone/app/testing/cleanup.rst\n+++ /dev/null\n@@ -1,32 +0,0 @@\n-Cleanup functions\n------------------\n-\n-When imported, this package will register a few cleanup handlers with\n-``zope.testing.cleanup`` to clean up global state left by various Zope, CMF\n-and Plone packages.\n-\n-    >>> import zope.testing.cleanup\n-    >>> zope.testing.cleanup.cleanUp()\n-\n-PluggableAuthService MultiPlugins list\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-The ``PluggableAuthService`` package maintains a global list of so-called\n-multi-plugins.\n-\n-    >>> from Products.PluggableAuthService import PluggableAuthService\n-    >>> PluggableAuthService.MultiPlugins\n-    []\n-\n-A new plugin can be registered using the ``registerPlugin()`` API.\n-\n-    >>> PluggableAuthService.registerMultiPlugin("dummy_plugin")\n-    >>> PluggableAuthService.MultiPlugins\n-    [\'dummy_plugin\']\n-\n-On cleanup, this list is emptied.\n-\n-    >>> zope.testing.cleanup.cleanUp()\n-\n-    >>> PluggableAuthService.MultiPlugins\n-    []\ndiff --git a/plone/app/testing/helpers.py b/plone/app/testing/helpers.py\ndeleted file mode 100644\nindex 1a60080..0000000\n--- a/plone/app/testing/helpers.py\n+++ /dev/null\n@@ -1,505 +0,0 @@\n-# -*- coding: utf-8 -*-\n-# Helper functions for Plone testing. Also importable from plone.app.testing\n-# directly\n-\n-from plone.app.testing import layers\n-from plone.app.testing.interfaces import PLONE_SITE_ID\n-from plone.app.testing.interfaces import SITE_OWNER_NAME\n-from plone.app.testing.interfaces import TEST_USER_NAME\n-from plone.testing import Layer\n-from plone.testing import security\n-from plone.testing import z2\n-from plone.testing import zca\n-from plone.testing import zodb\n-from zope.component import getGlobalSiteManager\n-from zope.component.hooks import getSite\n-from zope.component.hooks import setHooks\n-from zope.component.hooks import setSite\n-from zope.configuration import xmlconfig\n-\n-import contextlib\n-\n-\n-# User management\n-\n-\n-def login(portal, userName):\n-    """Log in as the given user in the given Plone site\n-    """\n-\n-    z2.login(portal[\'acl_users\'], userName)\n-\n-\n-def logout():\n-    """Log out, i.e. become anonymous\n-    """\n-\n-    z2.logout()\n-\n-\n-def setRoles(portal, userId, roles):\n-    """Set the given user\'s roles to a tuple of roles.\n-    """\n-\n-    userFolder = portal[\'acl_users\']\n-    z2.setRoles(userFolder, userId, roles)\n-\n-\n-def tearDownMultiPluginRegistration(pluginName):\n-    """Remove the given PAS MultiPlugin name from the global PAS registry.\n-    Does nothing if the plugin name is not registered.\n-\n-    This helper is useful during tear-down if a product has explicitly added\n-    a MultiPlugin registraton to the PluggableAuthService using the\n-    ``<pas:registerMultiPlugin />`` ZCML directive.\n-    """\n-\n-    from Products.PluggableAuthService import PluggableAuthService\n-    from Products.PluggableAuthService import zcml\n-\n-    if pluginName in PluggableAuthService.MultiPlugins:\n-        PluggableAuthService.MultiPlugins.remove(pluginName)\n-\n-    if pluginName in zcml._mt_regs:\n-        zcml._mt_regs.remove(pluginName)\n-\n-\n-# Product management - local site\n-\n-\n-def quickInstallProduct(portal, productName, reinstall=False):\n-    """Install a product using the ``portal_quickinstaller`` tool. If\n-    ``reinstall`` is false and the product is already installed, do nothing.\n-    If ``reinstall`` is true, perform an explicit reinstall if the product\n-    is installed already.\n-    """\n-\n-    from Acquisition import aq_parent\n-    from AccessControl import getSecurityManager\n-    from AccessControl.SecurityManagement import setSecurityManager\n-\n-    sm = getSecurityManager()\n-    app = aq_parent(portal)\n-\n-    z2.login(app[\'acl_users\'], SITE_OWNER_NAME)\n-\n-    try:\n-        from Products.CMFPlone.utils import get_installer\n-    except ImportError:\n-        # BBB For Plone 5.0 and lower.\n-        qi = portal[\'portal_quickinstaller\']\n-        old_qi = True\n-    else:\n-        qi = get_installer(portal)\n-        old_qi = False\n-\n-    try:\n-        if old_qi:\n-            if not qi.isProductInstalled(productName):\n-                qi.installProduct(productName)\n-            elif reinstall:\n-                qi.reinstallProducts([productName])\n-        else:\n-            if not qi.is_product_installed(productName):\n-                qi.install_product(productName, allow_hidden=True)\n-            elif reinstall:\n-                qi.uninstall_product(productName)\n-                qi.install_product(productName, allow_hidden=True)\n-\n-        portal.clearCurrentSkin()\n-        portal.setupCurrentSkin(portal.REQUEST)\n-\n-    finally:\n-        setSecurityManager(sm)\n-\n-\n-def applyProfile(portal, profileName, purge_old=None,\n-                 ignore_dependencies=False, archive=None,\n-                 blacklisted_steps=None):\n-    """Install an extension profile into the portal. The profile name\n-    should be a package name and a profile name, e.g. \'my.product:default\'.\n-    """\n-\n-    from Acquisition import aq_parent\n-    from AccessControl import getSecurityManager\n-    from AccessControl.SecurityManagement import setSecurityManager\n-\n-    sm = getSecurityManager()\n-    app = aq_parent(portal)\n-\n-    z2.login(app[\'acl_users\'], SITE_OWNER_NAME)\n-\n-    try:\n-        setupTool = portal[\'portal_setup\']\n-        profileId = \'profile-{0}\'.format(profileName)\n-        setupTool.runAllImportStepsFromProfile(\n-            profileId,\n-            purge_old=purge_old,\n-            ignore_dependencies=ignore_dependencies,\n-            archive=archive,\n-            blacklisted_steps=blacklisted_steps)\n-\n-        portal.clearCurrentSkin()\n-        portal.setupCurrentSkin(portal.REQUEST)\n-\n-    finally:\n-        setSecurityManager(sm)\n-\n-\n-# Component architecture\n-\n-\n-def pushGlobalRegistry(portal, new=None, name=None):\n-    """Set a new global component registry that uses the current registry as\n-    a base. If you use this, you *must* call ``popGlobalRegistry()`` to\n-    restore the original state.\n-\n-    If ``new`` is not given, a new registry is created. If given, you must\n-    provide a ``zope.component.globalregistry.BaseGlobalComponents`` object.\n-\n-    Returns the new registry.\n-\n-    Also ensure that the persistent component registry at ``portal`` has the\n-    new global registry as its base.\n-    """\n-    site = getSite()\n-\n-    localSiteManager = portal.getSiteManager()\n-\n-    current = zca.pushGlobalRegistry(new=new)\n-\n-    if current not in localSiteManager.__bases__:\n-        localSiteManager.__bases__ = (current, )\n-\n-    if site is not None:\n-        setHooks()\n-        setSite(site)\n-\n-    return current\n-\n-\n-def popGlobalRegistry(portal):\n-    """Restore the global component registry form the top of the stack, as\n-    set with ``pushGlobalRegistry()``.\n-\n-    Also ensure that the persistent component registry at ``portal`` has the\n-    new global registry as its base.\n-    """\n-\n-    # First, check if the component site has the global site manager in its\n-    # bases. If so, that site manager is about to disappear, so set its\n-    # base(s) as the new base(s) for the local site manager.\n-    globalSiteManager = getGlobalSiteManager()\n-    gsmBases = globalSiteManager.__bases__\n-    site = getSite()\n-    localSiteManager = portal.getSiteManager()\n-\n-    bases = []\n-    changed = False\n-    for base in localSiteManager.__bases__:\n-        if base is globalSiteManager:\n-            bases.extend(gsmBases)\n-            changed = True\n-        else:\n-            bases.append(base)\n-\n-    if changed:\n-        localSiteManager.__bases__ = tuple(bases)\n-\n-    # Now pop the registry. We need to do it in this somewhat convoluted way\n-    # to avoid the risk of unpickling errors\n-\n-    previous = zca.popGlobalRegistry()\n-\n-    if site is not None:\n-        setHooks()\n-        setSite(site)\n-\n-    return previous\n-\n-\n-def persist_profile_upgrade_versions(portal):\n-    """Persist the profile_upgrade_versions of portal_setup.\n-\n-    Until at least Products.GenericSetup 1.8.3 this is a standard\n-    non-persistent dictionary, which means a transaction rollback does\n-    not rollback changes to this dictionary.  So we make it a persistent\n-    mapping.  Call this once in layer setup and you have easy rollback.\n-    """\n-    from persistent.mapping import PersistentMapping\n-    puv = portal.portal_setup._profile_upgrade_versions\n-    if isinstance(puv, PersistentMapping):\n-        return\n-    portal.portal_setup._profile_upgrade_versions = PersistentMapping(puv)\n-\n-\n-@contextlib.contextmanager\n-def ploneSite(db=None, connection=None, environ=None):\n-    """Context manager for working with the Plone portal during layer setup::\n-\n-        with ploneSite() as portal:\n-            ...\n-\n-    This is based on the ``z2.zopeApp()`` context manager. See the module\n-     ``plone.testing.z2`` for details.\n-\n-    Do not use this in a test. Use the \'portal\' resource from the PloneFixture\n-    layer instead!\n-\n-    Pass a ZODB handle as ``db`` to use a specificdatabase. Alternatively,\n-    pass an open connection as ``connection`` (the connection will not be\n-    closed).\n-    """\n-    setHooks()\n-    site = getSite()\n-\n-    with z2.zopeApp(db, connection, environ) as app:\n-        portal = app[PLONE_SITE_ID]\n-\n-        setSite(portal)\n-        login(portal, TEST_USER_NAME)\n-\n-        try:\n-            yield portal\n-        finally:\n-            logout()\n-            if site is not portal:\n-                setSite(site)\n-\n-\n-# Layer base class\n-\n-\n-class PloneSandboxLayer(Layer):\n-    """Layer base class managing the common pattern of having a stacked ZODB\n-    ``DemoStorage`` and a stacked global component registry for the layer.\n-\n-    Base classes must override and implemented ``setUpPloneSite()``. They\n-    may also implement ``tearDownPloneSite()``, and can optionally change\n-    the ``defaultBases`` tuple.\n-    """\n-\n-    # The default list of bases.\n-\n-    defaultBases = (layers.PLONE_FIXTURE, )\n-\n-    # Hooks\n-\n-    def setUpZope(self, app, configurationContext):\n-        """Set up Zope.\n-\n-        ``app`` is the Zope application root.\n-\n-        ``configurationContext`` is the ZCML configuration context.\n-\n-        This is the most appropriate place to load ZCML or install Zope 2-\n-        style products, using the ``plone.testing.z2.installProduct`` helper.\n-        """\n-        pass\n-\n-    def tearDownZope(self, app):\n-        """Tear down Zope.\n-\n-        ``app`` is the Zope application root.\n-\n-        This is the most appropriate place to uninstall Zope 2-style products\n-        using the ``plone.testing.z2.uninstallProduct`` helper.\n-        """\n-        pass\n-\n-    def setUpPloneSite(self, portal):\n-        """Set up the Plone site.\n-\n-        ``portal`` is the Plone site. Provided no exception is raised, changes\n-        to this site will be committed (into a newly stacked ``DemoStorage``).\n-\n-        Concrete layer classes should implement this method at a minimum.\n-        """\n-        pass\n-\n-    def tearDownPloneSite(self, portal):\n-        """Tear down the Plone site.\n-\n-        Implementing this is optional. If the changes made during the\n-        ``setUpPloneSite()`` method were confined to the ZODB and the global\n-        component regsitry, those changes will be torn down automatically.\n-        """\n-\n-        pass\n-\n-    # Boilerplate\n-\n-    def setUp(self):\n-        try:\n-            # Push a new database storage so that database changes\n-            # commited during layer setup can be easily torn down\n-            self[\'zodbDB\'] = zodb.stackDemoStorage(self.get(\'zodbDB\'),\n-                                                   name=self.__name__)\n-\n-            # Push a new configuration context so that it\'s possible to\n-            # re-import ZCML files after tear-down\n-            name = self.__name__ if self.__name__ is not None else \'not-named\'\n-            contextName = \'PloneSandboxLayer-{0}\'.format(name)\n-            self[\'configurationContext\'] = configurationContext = (\n-                zca.stackConfigurationContext(self.get(\'configurationContext\'),\n-                                              name=contextName))\n-\n-            with ploneSite() as portal:\n-                setHooks()\n-\n-                # Make sure there\'s no local site manager while we load ZCML\n-                setSite(None)\n-\n-                # Push a new component registry so that ZCML registations\n-                # and other global component registry changes are sandboxed\n-                pushGlobalRegistry(portal)\n-\n-                # Persist GenericSetup profile upgrade versions for easy\n-                # rollback.\n-                persist_profile_upgrade_versions(portal)\n-\n-                # Make sure zope.security checkers can be set up and torn down\n-                # reliably\n-\n-                security.pushCheckers()\n-\n-                from Products.PluggableAuthService.PluggableAuthService import MultiPlugins  # noqa\n-\n-                preSetupMultiPlugins = MultiPlugins[:]\n-\n-                # Allow subclass to load ZCML and products\n-                self.setUpZope(portal.getPhysicalRoot(), configurationContext)\n-\n-                # Allow subclass to configure a persistent fixture\n-                setSite(portal)\n-                self.setUpPloneSite(portal)\n-                setSite(None)\n-\n-            # Keep track of PAS plugins that were added during setup\n-            self.snapshotMultiPlugins(preSetupMultiPlugins)\n-        except Exception:\n-            del self[\'configurationContext\']\n-            self[\'zodbDB\'].close()\n-            del self[\'zodbDB\']\n-            raise\n-\n-    def tearDown(self):\n-\n-        with z2.zopeApp() as app:\n-\n-            portal = app[PLONE_SITE_ID]\n-            setHooks()\n-            setSite(portal)\n-\n-            # Allow subclass to tear down persistent fixture\n-            self.tearDownPloneSite(portal)\n-\n-            setSite(None)\n-\n-            # Make sure zope.security checkers can be set up and torn down\n-            # reliably\n-\n-            security.popCheckers()\n-\n-            # Pop the component registry, thus removing component\n-            # architecture registrations\n-            popGlobalRegistry(portal)\n-\n-            # Remove PAS plugins\n-            self.tearDownMultiPlugins()\n-\n-            # Allow subclass to tear down products\n-            self.tearDownZope(app)\n-\n-        # Zap the configuration context\n-        del self[\'configurationContext\']\n-\n-        # Pop the demo storage, thus restoring the database to the\n-        # previous state\n-        self[\'zodbDB\'].close()\n-        del self[\'zodbDB\']\n-\n-    # Helpers\n-    def applyProfile(self, portal, profileName, purge_old=None,\n-                     ignore_dependencies=False, archive=None,\n-                     blacklisted_steps=None):\n-        return applyProfile(portal, profileName, purge_old,\n-                            ignore_dependencies, archive,\n-                            blacklisted_steps)\n-\n-    def loadZCML(self, name=\'configure.zcml\', **kw):\n-        kw.setdefault(\'context\', self[\'configurationContext\'])\n-        return xmlconfig.file(name, **kw)\n-\n-    def snapshotMultiPlugins(self, preSetupMultiPlugins):\n-        """Save a snapshot of all PAS multi plugins that were added during\n-        setup, by comparing to the list of plugins passed in.\n-        """\n-\n-        self._addedMultiPlugins = set()\n-\n-        from Products.PluggableAuthService.PluggableAuthService import (\n-            MultiPlugins\n-        )\n-\n-        for plugin in MultiPlugins:\n-            if plugin not in preSetupMultiPlugins:\n-                self._addedMultiPlugins.add(plugin)\n-\n-    def tearDownMultiPlugins(self):\n-        """Delete all PAS multi plugins that were added during setup, as\n-        stored by ``snapshotMultiPlugins()``.\n-        """\n-\n-        for pluginName in self._addedMultiPlugins:\n-            tearDownMultiPluginRegistration(pluginName)\n-\n-\n-class PloneWithPackageLayer(PloneSandboxLayer):\n-\n-    def __init__(self, bases=None, name=None, module=None, zcml_filename=None,\n-                 zcml_package=None, gs_profile_id=None,\n-                 additional_z2_products=()):\n-        super(PloneWithPackageLayer, self).__init__(bases, name, module)\n-        self.zcml_filename = zcml_filename\n-        self.zcml_package = zcml_package\n-        self.gs_profile_id = gs_profile_id\n-        self.additional_z2_products = additional_z2_products\n-\n-    def setUpZope(self, app, configurationContext):\n-        """Set up Zope.\n-\n-        Only load ZCML files.\n-        """\n-        self.setUpZCMLFiles()\n-        for z2Product in self.additional_z2_products:\n-            z2.installProduct(app, z2Product)\n-\n-    def setUpZCMLFiles(self):\n-        """Load default ZCML.\n-\n-        Can be overridden to load more ZCML.\n-        """\n-        if self.zcml_filename is None:\n-            raise ValueError(\'ZCML file name has not been provided.\')\n-        if self.zcml_package is None:\n-            raise ValueError(\n-                \'The package that contains the ZCML file \'\n-                \'has not been provided.\'\n-            )\n-        self.loadZCML(self.zcml_filename, package=self.zcml_package)\n-\n-    def setUpPloneSite(self, portal):\n-        """Set up the Plone site.\n-\n-        Only install GenericSetup profiles\n-        """\n-        self.applyProfiles(portal)\n-\n-    def applyProfiles(self, portal):\n-        """Install default profile.\n-\n-        Can be overridden to install more profiles.\n-        """\n-        if self.gs_profile_id is not None:\n-            self.applyProfile(portal, self.gs_profile_id)\ndiff --git a/plone/app/testing/helpers.rst b/plone/app/testing/helpers.rst\ndeleted file mode 100644\nindex a67bd2f..0000000\n--- a/plone/app/testing/helpers.rst\n+++ /dev/null\n@@ -1,482 +0,0 @@\n-Plone testing helpers\n----------------------\n-\n-This package contains various test helpers that are useful for writing custom\n-layers using layers that are based on the ``PLONE_FIXTURE`` layer, and for\n-writing tests using such layers.\n-\n-The helpers are all importable from ``plone.app.testing`` directly, or from\n-their canonical locations at ``plone.app.testing.helpers``.\n-\n-    >>> from plone.app.testing import helpers\n-\n-For testing, we need a testrunner\n-\n-    >>> from zope.testrunner import runner\n-\n-Let\'s create a custom fixture layer that exercises these helpers. In this\n-layer, we will perform the following setup:\n-\n-1. Stack a new ``DemoStorage`` on top of the one from the base layer. This\n-   ensures that any persistent changes performed in this layer can be torn\n-   down completely, simply by popping the demo storage.\n-\n-2. Stack a new ZCML configuration context. This keeps separate the information\n-   about which ZCML files were loaded, in case other, independent layers want\n-   to load those same files after this layer has been torn down.\n-\n-3. Push a new global component registry. This allows us to register components\n-   (e.g. by loading ZCML or using the test API from ``zope.component``) and\n-   tear down those registration easily by popping the component registry.\n-   We pass the portal so that the local component site manager can be\n-   configured appropriately.\n-\n-   *Note:* We obtain the portal from the ``ploneSite()`` context manager,\n-   which will ensure that the portal is properly set up and commit our changes\n-   on exiting the ``with`` block.\n-\n-4. Make some persistent changes, to illustrate how these are torn down when\n-   we pop the ZODB ``DemoStorage``.\n-\n-5. Install a product using the ``get_installer`` view (or the old ``portal_quickinstaller`` tool).\n-\n-6. Apply a named extension profile.\n-\n-On tear-down, we only need to pop the ``DemoStorage`` (to roll back all\n-persistent changes), the configuration context (to "forget" which files were\n-loaded and so allow them to be loaded again in other layers), and the stacked\n-component registry (to roll back all global component registrations). Of\n-course, if our setup had changed any other global or external state, we would\n-need to tear that down as well.\n-\n-    >>> def is_installed(portal, product_name):\n-    ...     try:\n-    ...         from Products.CMFPlone.utils import get_installer\n-    ...     except ImportError:\n-    ...         # BBB For Plone 5.0 and lower.\n-    ...         qi = portal[\'portal_quickinstaller\']\n-    ...         return qi.isProductInstalled(product_name)\n-    ...     else:\n-    ...         qi = get_installer(portal)\n-    ...         return qi.is_product_installed(product_name)\n-\n-    >>> from plone.testing import Layer\n-    >>> from plone.testing import zca, z2, zodb\n-\n-    >>> from plone.app.testing import PLONE_FIXTURE\n-    >>> from plone.app.testing import IntegrationTesting\n-\n-    >>> class HelperDemos(Layer):\n-    ...     defaultBases = (PLONE_FIXTURE,)\n-    ...\n-    ...     def setUp(self):\n-    ...\n-    ...         # Push a new database storage so that database changes\n-    ...         # commited during layer setup can be easily torn down\n-    ...         self[\'zodbDB\'] = zodb.stackDemoStorage(self.get(\'zodbDB\'), name=\'HelperDemos\')\n-    ...\n-    ...         # Push a new configuration context so that it\'s possible to re-import\n-    ...         # ZCML files after tear-down\n-    ...         self[\'configurationContext\'] = zca.stackConfigurationContext(self.get(\'configurationContext\'))\n-    ...\n-    ...         with helpers.ploneSite() as portal:\n-    ...\n-    ...             # Persist GenericSetup profile upgrade versions for easy rollback.\n-    ...             helpers.persist_profile_upgrade_versions(portal)\n-    ...\n-    ...             # First register dummy default and uninstall profiles for plone.app.testing.\n-    ...             # We will use this to test that after teardown the installed profile versions get reset.\n-    ...             # We used to test this with plone.resource, but that is already installed by default,\n-    ...             # which makes it a pain to test with.\n-    ...             from Products.GenericSetup.registry import _profile_registry\n-    ...             from Products.GenericSetup.interfaces import EXTENSION\n-    ...             # \'profile\' points to a path with a metadata.xml so we can have a version.\n-    ...             _profile_registry.registerProfile(\'default\', u"Testing", u"", "profile", \'plone.app.testing\', EXTENSION)\n-    ...             _profile_registry.registerProfile(\'uninstall\', u"Testing uninstall", u"", "profile", \'plone.app.testing\', EXTENSION)\n-    ...\n-    ...             # Push a new component registry so that ZCML registations\n-    ...             # and other global component registry changes are sandboxed\n-    ...             helpers.pushGlobalRegistry(portal)\n-    ...\n-    ...             # Register some components\n-    ...             from zope.component import provideUtility\n-    ...             from zope.interface import Interface\n-    ...             provideUtility(object(), Interface, name=u"dummy1")\n-    ...\n-    ...             # Make some persistent changes\n-    ...             portal.title = u"New title"\n-    ...\n-    ...             # Install a product using portal_quickinstaller\n-    ...             helpers.quickInstallProduct(portal, \'plone.app.testing\')\n-    ...             assert is_installed(portal, \'plone.app.testing\')\n-    ...\n-    ...     def tearDown(self):\n-    ...\n-    ...         # Pop the component registry, thus removing component\n-    ...         # architecture registrations\n-    ...         with helpers.ploneSite() as portal:\n-    ...             helpers.popGlobalRegistry(portal)\n-    ...\n-    ...         # Pop the configuration context\n-    ...         del self[\'configurationContext\']\n-    ...\n-    ...         # Pop the demo storage, thus restoring the database to the\n-    ...         # previous state\n-    ...         self[\'zodbDB\'].close()\n-    ...         del self[\'zodbDB\']\n-\n-With the layer class defined, we can instantiate a fixture base layer, and\n-an "end user" layer with test lifecycle management. Here, we will use the\n-``IntegrationTesting`` layer class from ``plone.app.testing``.\n-\n-    >>> HELPER_DEMOS_FIXTURE = HelperDemos()\n-    >>> HELPER_DEMOS_INTEGRATION_TESTING = IntegrationTesting(bases=(HELPER_DEMOS_FIXTURE,), name="HelperDemos:Integration")\n-\n-Let\'s now simulate layer setup:\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, HELPER_DEMOS_INTEGRATION_TESTING, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-      Set up plone.testing.z2.Startup in ... seconds.\n-      Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-      Set up HelperDemos in ... seconds.\n-      Set up plone.app.testing.layers.HelperDemos:Integration in ... seconds.\n-\n-We should see the newly registered components and the persistent changes\n-having taken effect.\n-\n-    >>> from zope.component import queryUtility\n-    >>> from zope.interface import Interface\n-    >>> queryUtility(Interface, name="dummy1")\n-    <object object at ...>\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n-    New title\n-\n-We should also see our product installation in the quickinstaller tool\n-and the results of the profile having been applied.\n-\n-    >>> from Products.GenericSetup.tool import UNKNOWN\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print is_installed(portal, \'plone.app.testing\')\n-    ...     portal.portal_setup.getLastVersionForProfile(\'plone.app.testing:default\') == UNKNOWN\n-    True\n-    False\n-\n-Let\'s now simulate a test.\n-\n-    >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n-    >>> PLONE_FIXTURE.testSetUp()\n-    >>> HELPER_DEMOS_FIXTURE.testSetUp()\n-    >>> HELPER_DEMOS_INTEGRATION_TESTING.testSetUp()\n-\n-In a test, we can use helpers to simulate login, logging out and changing a\n-user\'s roles. These may also be used during layer setup if required, using\n-the ``ploneSite()`` context manager as shown above.\n-\n-    >>> from AccessControl import getSecurityManager\n-    >>> from plone.app.testing import TEST_USER_NAME\n-    >>> from plone.app.testing import TEST_USER_ID\n-\n-    >>> portal = HELPER_DEMOS_INTEGRATION_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n-\n-    >>> getSecurityManager().getUser().getRolesInContext(portal)\n-    [\'Member\', \'Authenticated\']\n-\n-    >>> getSecurityManager().getUser().getUserName() == TEST_USER_NAME\n-    True\n-    >>> getSecurityManager().getUser().getId() == TEST_USER_ID\n-    True\n-    >>> sm_repr = repr(getSecurityManager())\n-    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-    >>> repr(getSecurityManager()) != sm_repr\n-    True\n-    >>> getSecurityManager().getUser().getRolesInContext(portal)\n-    [\'Manager\', \'Authenticated\']\n-\n-    >>> helpers.logout()\n-    >>> getSecurityManager().getUser()\n-    <SpecialUser \'Anonymous User\'>\n-\n-    >>> helpers.login(portal, TEST_USER_NAME)\n-    >>> getSecurityManager().getUser().getUserName() == TEST_USER_NAME\n-    True\n-\n-    >>> from OFS.Folder import Folder\n-    >>> portal._setObject(\'folder1\', Folder(\'folder1\'))\n-    \'folder1\'\n-\n-Let\'s now tear down the test.\n-\n-    >>> HELPER_DEMOS_INTEGRATION_TESTING.testTearDown()\n-    >>> HELPER_DEMOS_FIXTURE.testTearDown()\n-    >>> PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n-    >>> zca.LAYER_CLEANUP.testTearDown()\n-\n-Our persistent changes from the layer should remain, but those made in a test\n-should not.\n-\n-    >>> queryUtility(Interface, name="dummy1")\n-    <object object at ...>\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n-    ...     print is_installed(portal, \'plone.app.testing\')\n-    ...     \'folder1\' in portal.objectIds()\n-    ...     portal.portal_setup.getLastVersionForProfile(\'plone.app.testing:default\') == UNKNOWN\n-    New title\n-    True\n-    False\n-    False\n-\n-We\'ll now tear down just the ``HELPER_DEMOS_INTEGRATION_TESTING`` layer. At this\n-point, we should still have a Plone site, but none of the persistent or\n-component architecture changes from our layer.\n-\n-    >>> runner.tear_down_unneeded(options, [l for l in setupLayers if l not in (HELPER_DEMOS_INTEGRATION_TESTING, HELPER_DEMOS_FIXTURE,)], setupLayers)\n-    Tear down plone.app.testing.layers.HelperDemos:Integration in ... seconds.\n-    Tear down HelperDemos in ... seconds.\n-\n-    >>> queryUtility(Interface, name="dummy1") is None\n-    True\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n-    ...     print is_installed(portal, \'plone.app.testing\')\n-    ...     portal.portal_setup.getLastVersionForProfile(\'plone.app.testing:default\') == UNKNOWN\n-    Plone site\n-    False\n-    True\n-\n-Let\'s tear down the rest of the layers too.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-Plone sandbox layer helper\n---------------------------\n-\n-The pattern above of setting up a stacked ZODB ``DemoStorage``, configuration\n-context and global component registry is very common. In fact, there is a\n-layer base class which helps implement this pattern.\n-\n-    >>> someGlobal = {}\n-\n-    >>> class MyLayer(helpers.PloneSandboxLayer):\n-    ...\n-    ...     def setUpZope(self, app, configurationContext):\n-    ...\n-    ...         # We\'d often load ZCML here, using the passed-in\n-    ...         # configurationContext as the configuration context.\n-    ...\n-    ...         # Of course, we can also register some components using the\n-    ...         # zope.component API directly\n-    ...         from zope.component import provideUtility\n-    ...         from zope.interface import Interface\n-    ...         provideUtility(object(), Interface, name=u"dummy1")\n-    ...\n-    ...         # We\'ll also add some entries to the GenericSetup global\n-    ...         # registries.\n-    ...         from Products.GenericSetup.registry import _profile_registry\n-    ...         from Products.GenericSetup.registry import _import_step_registry\n-    ...         from Products.GenericSetup.registry import _export_step_registry\n-    ...         from Products.GenericSetup import upgrade\n-    ...\n-    ...         _profile_registry.registerProfile(\'dummy1\', u"My package", u"", ".", \'plone.app.testing\')\n-    ...         _import_step_registry.registerStep(\'import1\', version=1, handler=\'plone.app.testing.tests.dummy\', title=u"Dummy import step", description=u"")\n-    ...         _export_step_registry.registerStep(\'export1\', handler=\'plone.app.testing.tests.dummy\', title=u"Dummy import step", description=u"")\n-    ...         upgrade_step = upgrade.UpgradeStep(u\'Dummy upgrade step\', \'plone.app.testing:default\', \'1000\', \'1001\', \'\', \'plone.app.testing.tests.dummy\')\n-    ...         upgrade._registerUpgradeStep(upgrade_step)\n-    ...\n-    ...         # And then pretend to register a PAS multi-plugin\n-    ...         from Products.PluggableAuthService import PluggableAuthService\n-    ...         PluggableAuthService.registerMultiPlugin("dummy_plugin1")\n-    ...\n-    ...         # Finally, this is a good place to load Zope products,\n-    ...         # using the plone.testing.z2.installProduct() helper.\n-    ...         # Make some other global changes not stored in the ZODB or\n-    ...         # the global component registry\n-    ...         someGlobal[\'test\'] = 1\n-    ...\n-    ...     def tearDownZope(self, app):\n-    ...         # Illustrate tear-down of some global state\n-    ...         del someGlobal[\'test\']\n-    ...\n-    ...     def setUpPloneSite(self, portal):\n-    ...\n-    ...         # We can make persistent changes here\n-    ...         portal.title = u"New title"\n-\n-    >>> MY_FIXTURE = MyLayer()\n-    >>> MY_INTEGRATION_TESTING = IntegrationTesting(bases=(MY_FIXTURE,), name="MyLayer:Integration")\n-\n-Here, we have derived from ``PloneSandboxLayer`` instead of the more usual\n-``Layer`` base class. This layer implements the sandboxing of the ZODB, global\n-component registry, and GenericSetup profile and import/export step registries\n-for us, and delegates to four template methods, all of them optional:\n-\n-* ``setUpZope()``, called with the Zope app root and the ZCML configuration\n-  context as arguments. This is a good place to load ZCML, manipulate global\n-  registries, or install Zope 2-style products using the ``installProduct()``\n-  helper method.\n-* ``setUpPloneSite()``, called with the Plone site object as an argument. This\n-  is a good place to set up persistent aspects of the test fixture, such as\n-  installing products into Plone using the ``quickInstallProduct`` helper or\n-  adding default content.\n-* ``tearDownZope()``, called with the Zope app root as an argument. This is\n-  a good place to tear down global state and uninstall products using the\n-  ``uninstallProduct()`` helper. Note that global components (e.g. loaded via\n-  ZCML) are torn down automatically, as are changes to the global GenericSetup\n-  registries.\n-* ``tearDownPloneSite()``, called with the Plone site object as an argument.\n-  This is not very commonly needed, because persistent changes to the Plone\n-  site are torn down automatically by popping ZODB ``DemoStorage`` created\n-  during set-up. However, it is there if you need it.\n-\n-You may also wish to change the ``defaultBases`` argument. The default is to\n-use ``PLONE_FIXTURE`` as the single default base layer for the fixture class.\n-\n-    >>> MY_FIXTURE.__bases__\n-    (<Layer \'plone.app.testing.layers.PloneFixture\'>,)\n-\n-Let\'s now simulate layer setup:\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, MY_INTEGRATION_TESTING, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up MyLayer in ... seconds.\n-    Set up plone.app.testing.layers.MyLayer:Integration in ... seconds.\n-\n-Again, our state should now be available.\n-\n-    >>> queryUtility(Interface, name="dummy1")\n-    <object object at ...>\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n-    New title\n-\n-    >>> someGlobal[\'test\']\n-    1\n-\n-    >>> from Products.GenericSetup.registry import _profile_registry\n-    >>> from Products.GenericSetup.registry import _import_step_registry\n-    >>> from Products.GenericSetup.registry import _export_step_registry\n-    >>> from Products.GenericSetup.upgrade import _upgrade_registry\n-\n-    >>> numProfiles = len(_profile_registry.listProfiles())\n-    >>> \'plone.app.testing:dummy1\' in _profile_registry.listProfiles()\n-    True\n-\n-    >>> numImportSteps = len(_import_step_registry.listSteps())\n-    >>> \'import1\' in _import_step_registry.listSteps()\n-    True\n-\n-    >>> numExportSteps = len(_export_step_registry.listSteps())\n-    >>> \'export1\' in _export_step_registry.listSteps()\n-    True\n-\n-    >>> from Products.PluggableAuthService import PluggableAuthService\n-    >>> \'dummy_plugin1\' in PluggableAuthService.MultiPlugins\n-    True\n-\n-    >>> numUpgrades = len(_upgrade_registry.keys())\n-    >>> len(_upgrade_registry.getUpgradeStepsForProfile(\'plone.app.testing:default\'))\n-    1\n-\n-We\'ll now tear down just the ``MY_INTEGRATION_TESTING`` layer. At this\n-point, we should still have a Plone site, but none of the changes from our\n-layer.\n-\n-    >>> runner.tear_down_unneeded(options, [l for l in setupLayers if l not in (MY_INTEGRATION_TESTING, MY_FIXTURE)], setupLayers)\n-    Tear down plone.app.testing.layers.MyLayer:Integration in ... seconds.\n-\n-    >>> queryUtility(Interface, name="dummy1") is None\n-    True\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n-    Plone site\n-\n-    >>> \'test\' in someGlobal\n-    False\n-\n-    >>> len(_profile_registry.listProfiles()) == numProfiles - 1\n-    True\n-    >>> \'plone.app.testing:dummy1\' in _profile_registry.listProfiles()\n-    False\n-\n-    >>> len(_import_step_registry.listSteps()) == numImportSteps - 1\n-    True\n-    >>> \'import1\' in _import_step_registry.listSteps()\n-    False\n-\n-    >>> len(_export_step_registry.listSteps()) == numExportSteps - 1\n-    True\n-    >>> \'export1\' in _export_step_registry.listSteps()\n-    False\n-\n-    >>> len(_upgrade_registry.keys()) == numUpgrades - 1\n-    True\n-    >>> len(_upgrade_registry.getUpgradeStepsForProfile(\'plone.app.testing:default\'))\n-    0\n-\n-    >>> from Products.PluggableAuthService import PluggableAuthService\n-    >>> \'dummy_plugin1\' in PluggableAuthService.MultiPlugins\n-    False\n-\n-Let\'s tear down the rest of the layers too.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-Other helpers\n--------------\n-\n-There are some further helpers that apply only to special cases.\n-\n-Some product that uses the ``<pas:registerMultiPlugin />`` or the\n-``registerMultiPlugin()`` API from ``PluggableAuthService`` may leave global\n-state that needs to be cleaned up. You can use the helper\n-``tearDownMultiPluginRegistration()`` for this purpose.\n-\n-Let\'s simulate registering some plugins:\n-\n-    >>> from Products.PluggableAuthService import PluggableAuthService\n-    >>> PluggableAuthService.registerMultiPlugin("dummy_plugin1")\n-    >>> PluggableAuthService.registerMultiPlugin("dummy_plugin2")\n-\n-    >>> PluggableAuthService.MultiPlugins\n-    [\'dummy_plugin1\', \'dummy_plugin2\']\n-\n-If we register plugins with ZCML, they end up in a clean-up list - let\'s\n-simulate that too.\n-\n-    >>> from Products.PluggableAuthService import zcml\n-    >>> zcml._mt_regs.append(\'dummy_plugin1\')\n-    >>> zcml._mt_regs.append(\'dummy_plugin2\')\n-\n-The tear down helper takes a plugin meta-type as an argument:\n-\n-    >>> helpers.tearDownMultiPluginRegistration(\'dummy_plugin1\')\n-\n-    >>> PluggableAuthService.MultiPlugins\n-    [\'dummy_plugin2\']\n-\n-    >>> zcml._mt_regs\n-    [\'dummy_plugin2\']\n-\n-Let\'s clean up the registry completely.\n-\n-    >>> helpers.tearDownMultiPluginRegistration(\'dummy_plugin2\')\ndiff --git a/plone/app/testing/interfaces.py b/plone/app/testing/interfaces.py\ndeleted file mode 100644\nindex 781e70b..0000000\n--- a/plone/app/testing/interfaces.py\n+++ /dev/null\n@@ -1,17 +0,0 @@\n-# -*- coding: utf-8 -*-\n-# Constants for names used in layer setup - also importable from\n-# plone.app.testing directly\n-\n-PLONE_SITE_ID = \'plone\'\n-PLONE_SITE_TITLE = u\'Plone site\'\n-DEFAULT_LANGUAGE = \'en\'\n-\n-TEST_USER_NAME = \'test-user\'\n-TEST_USER_ID = \'test_user_1_\'\n-TEST_USER_PASSWORD = \'secret\'\n-TEST_USER_ROLES = [\'Member\', ]\n-\n-SITE_OWNER_NAME = \'admin\'\n-SITE_OWNER_PASSWORD = \'secret\'\n-\n-ROBOT_TEST_LEVEL = 5\ndiff --git a/plone/app/testing/layers.py b/plone/app/testing/layers.py\ndeleted file mode 100644\nindex fee631d..0000000\n--- a/plone/app/testing/layers.py\n+++ /dev/null\n@@ -1,396 +0,0 @@\n-# -*- coding: utf-8 -*-\n-# Layers setting up fixtures with a Plone site. Also importable from\n-# plone.app.testing directly\n-\n-from Acquisition import aq_base\n-from plone.app.testing.interfaces import DEFAULT_LANGUAGE\n-from plone.app.testing.interfaces import PLONE_SITE_ID\n-from plone.app.testing.interfaces import PLONE_SITE_TITLE\n-from plone.app.testing.interfaces import SITE_OWNER_NAME\n-from plone.app.testing.interfaces import SITE_OWNER_PASSWORD\n-from plone.app.testing.interfaces import TEST_USER_ID\n-from plone.app.testing.interfaces import TEST_USER_NAME\n-from plone.app.testing.interfaces import TEST_USER_PASSWORD\n-from plone.app.testing.interfaces import TEST_USER_ROLES\n-from plone.app.testing.utils import MockMailHost\n-from plone.testing import Layer\n-from plone.testing import z2\n-from plone.testing import zca\n-from plone.testing import zodb\n-from Products.MailHost.interfaces import IMailHost\n-from zope.component import getSiteManager\n-from zope.component.hooks import setSite\n-from zope.event import notify\n-from zope.traversing.interfaces import BeforeTraverseEvent\n-\n-\n-class PloneFixture(Layer):\n-    """This layer sets up a basic Plone site, with:\n-\n-    * No content\n-    * No default workflow\n-    * One user, as found in the constant ``TEST_USER_ID``, with login name\n-      ``TEST_USER_NAME``, the password ``TEST_USER_PASSWORD``, and a single\n-      role, ``Member``.\n-    """\n-\n-    defaultBases = (z2.STARTUP,)\n-\n-    # Products that will be installed, plus options\n-    products = (\n-        (\'Products.GenericSetup\',                {\'loadZCML\': True}, ),\n-        (\'Products.DCWorkflow\',                  {\'loadZCML\': True}, ),\n-        (\'Products.ZCTextIndex\',                 {\'loadZCML\': True}, ),\n-        (\'Products.DateRecurringIndex\',          {\'loadZCML\': False},),\n-        (\'Products.PageTemplates\',               {\'loadZCML\': True},),\n-\n-        (\'Products.CMFUid\',                      {\'loadZCML\': True}, ),\n-        (\'Products.CMFCore\',                     {\'loadZCML\': True}, ),\n-\n-        (\'Products.PluggableAuthService\',        {\'loadZCML\': True}, ),\n-        (\'Products.PluginRegistry\',              {\'loadZCML\': True}, ),\n-        (\'Products.PlonePAS\',                    {\'loadZCML\': True}, ),\n-\n-        (\'Products.CMFFormController\',           {\'loadZCML\': True}, ),\n-        (\'Products.CMFDynamicViewFTI\',           {\'loadZCML\': True}, ),\n-        (\'Products.CMFPlacefulWorkflow\',         {\'loadZCML\': True}, ),\n-\n-        (\'Products.MimetypesRegistry\',           {\'loadZCML\': True}, ),\n-        (\'Products.PortalTransforms\',            {\'loadZCML\': True}, ),\n-\n-        (\'Products.ExternalEditor\',              {\'loadZCML\': True}, ),\n-        (\'Products.ExtendedPathIndex\',           {\'loadZCML\': True}, ),\n-        (\'Products.ResourceRegistries\',          {\'loadZCML\': True}, ),\n-        (\'Products.SiteAccess\',                  {\'loadZCML\': False}, ),\n-\n-        (\'Products.CMFEditions\',                 {\'loadZCML\': True}, ),\n-        (\'Products.CMFDiffTool\',                 {\'loadZCML\': True}, ),\n-\n-        (\'plone.i18n\',                           {\'loadZCML\': True,\n-                                                  \'install\': False}, ),\n-\n-        (\'plonetheme.barceloneta\',               {\'loadZCML\': True,\n-                                                  \'install\': False}, ),\n-\n-        (\'plone.app.folder\',                     {\'loadZCML\': True}, ),\n-        (\'Products.CMFPlone\',                    {\'loadZCML\': True}, ),\n-        (\'Products.PythonScripts\',               {\'loadZCML\': False}, ),\n-\n-    )\n-\n-    try:\n-        import Products.PasswordResetTool  # noqa\n-        products = products + (\n-            (\'Products.PasswordResetTool\', {\'loadZCML\': True}, ),)\n-    except ImportError:\n-        pass\n-    try:\n-        import Products.CMFQuickInstallerTool  # noqa\n-        products = products + (\n-            (\'Products.CMFQuickInstallerTool\', {\'loadZCML\': True}, ),)\n-    except ImportError:\n-        pass\n-\n-    # Extension profiles to be installed with site setup\n-    extensionProfiles = (\n-        \'plonetheme.barceloneta:default\',\n-    )\n-\n-    # Layer lifecycle\n-\n-    def setUp(self):\n-\n-        # Stack a new DemoStorage on top of the one from z2.STARTUP.\n-        self[\'zodbDB\'] = zodb.stackDemoStorage(\n-            self.get(\'zodbDB\'),\n-            name=\'PloneFixture\'\n-        )\n-\n-        self.setUpZCML()\n-\n-        # Set up products and the default content\n-        with z2.zopeApp() as app:\n-            self.setUpProducts(app)\n-            self.setUpDefaultContent(app)\n-\n-    def tearDown(self):\n-\n-        # Tear down products\n-        with z2.zopeApp() as app:\n-            # note: content tear-down happens by squashing the ZODB\n-            self.tearDownProducts(app)\n-\n-        self.tearDownZCML()\n-\n-        # Zap the stacked ZODB\n-        self[\'zodbDB\'].close()\n-        del self[\'zodbDB\']\n-\n-    def setUpZCML(self):\n-        """Stack a new global registry and load ZCML configuration of Plone\n-        and the core set of add-on products into it. Also set the\n-        ``disable-autoinclude`` ZCML feature so that Plone does not attempt to\n-        auto-load ZCML using ``z3c.autoinclude``.\n-        """\n-\n-        # Create a new global registry\n-        zca.pushGlobalRegistry()\n-\n-        from zope.configuration import xmlconfig\n-        self[\'configurationContext\'] = context = zca.stackConfigurationContext(\n-            self.get(\'configurationContext\')\n-        )\n-\n-        # Turn off z3c.autoinclude\n-\n-        xmlconfig.string("""\\\n-<configure xmlns="http://namespaces.zope.org/zope"\n-           xmlns:meta="http://namespaces.zope.org/meta">\n-    <meta:provides feature="disable-autoinclude" />\n-</configure>\n-""", context=context)\n-\n-        # Load dependent products\'s ZCML - Plone doesn\'t specify dependencies\n-        # on Products.* packages fully\n-\n-        from zope.dottedname.resolve import resolve\n-\n-        def loadAll(filename):\n-            for p, config in self.products:\n-                if not config[\'loadZCML\']:\n-                    continue\n-                try:\n-                    package = resolve(p)\n-                except ImportError:\n-                    continue\n-                try:\n-                    xmlconfig.file(filename, package, context=context)\n-                except IOError:\n-                    pass\n-\n-        loadAll(\'meta.zcml\')\n-        loadAll(\'configure.zcml\')\n-        loadAll(\'overrides.zcml\')\n-\n-    def tearDownZCML(self):\n-        """Pop the global component registry stack, effectively unregistering\n-        all global components registered during layer setup.\n-        """\n-        # Pop the global registry\n-        zca.popGlobalRegistry()\n-\n-        # Zap the stacked configuration context\n-        del self[\'configurationContext\']\n-\n-    def setUpProducts(self, app):\n-        """Install all old-style products listed in the the ``products`` tuple\n-        of this class.\n-        """\n-\n-        for p, config in self.products:\n-            if config.get(\'install\', True):\n-                z2.installProduct(app, p)\n-\n-    def tearDownProducts(self, app):\n-        """Uninstall all old-style products listed in the the ``products``\n-        tuple of this class.\n-        """\n-        for p, config in reversed(self.products):\n-            if config.get(\'install\', True):\n-                z2.uninstallProduct(app, p)\n-\n-        # Clean up Wicked turds\n-        # XXX: This may tear down too much state\n-        try:\n-            from wicked.fieldevent import meta\n-            meta.cleanUp()\n-        except ImportError:\n-            pass\n-\n-    def setUpDefaultContent(self, app):\n-        """Add the site owner user to the root user folder and log in as that\n-        user. Create the Plone site, installing the extension profiles listed\n-        in the ``extensionProfiles`` layer class variable. Create the test\n-        user inside the site, and disable the default workflow.\n-\n-        Note: There is no explicit tear-down of this setup operation, because\n-        all persistent changes are torn down when the stacked ZODB\n-        ``DemoStorage`` is popped.\n-        """\n-\n-        # Create the owner user and "log in" so that the site object gets\n-        # the right ownership information\n-        app[\'acl_users\'].userFolderAddUser(\n-            SITE_OWNER_NAME,\n-            SITE_OWNER_PASSWORD,\n-            [\'Manager\'],\n-            []\n-        )\n-\n-        z2.login(app[\'acl_users\'], SITE_OWNER_NAME)\n-\n-        # Create the site with the default set of extension profiles\n-        from Products.CMFPlone.factory import addPloneSite\n-        addPloneSite(\n-            app,\n-            PLONE_SITE_ID,\n-            title=PLONE_SITE_TITLE,\n-            setup_content=False,\n-            default_language=DEFAULT_LANGUAGE,\n-            extension_ids=self.extensionProfiles,\n-        )\n-\n-        # Turn off default workflow\n-        app[PLONE_SITE_ID][\'portal_workflow\'].setDefaultChain(\'\')\n-\n-        # Create the test user. (Plone)PAS does not have an API to create a\n-        # user with different userid and login name, so we call the plugin\n-        # directly.\n-        pas = app[PLONE_SITE_ID][\'acl_users\']\n-        pas.source_users.addUser(\n-            TEST_USER_ID,\n-            TEST_USER_NAME,\n-            TEST_USER_PASSWORD\n-        )\n-        for role in TEST_USER_ROLES:\n-            pas.portal_role_manager.doAssignRoleToPrincipal(TEST_USER_ID, role)\n-\n-        # Log out again\n-        z2.logout()\n-\n-# Plone fixture layer instance. Should not be used on its own, but as a base\n-# for other layers.\n-\n-PLONE_FIXTURE = PloneFixture()\n-\n-\n-class PloneTestLifecycle(object):\n-    """Mixin class for Plone test lifecycle. This exposes the ``portal``\n-    resource and resets the environment between each test.\n-\n-    This class is used as a mixing for the IntegrationTesting and\n-    FunctionalTesting classes below, which also mix in the z2 versions of\n-    the same.\n-    """\n-\n-    defaultBases = (PLONE_FIXTURE,)\n-\n-    def testSetUp(self):\n-        super(PloneTestLifecycle, self).testSetUp()\n-\n-        self[\'portal\'] = portal = self[\'app\'][PLONE_SITE_ID]\n-        self.setUpEnvironment(portal)\n-\n-    def testTearDown(self):\n-        self.tearDownEnvironment(self[\'portal\'])\n-        del self[\'portal\']\n-\n-        super(PloneTestLifecycle, self).testTearDown()\n-\n-    def setUpEnvironment(self, portal):\n-        """Set up the local component site, reset skin data and log in as\n-        the test user.\n-        """\n-\n-        # Set up the local site manager\n-        setSite(portal)\n-\n-        # Reset skin data\n-        portal.clearCurrentSkin()\n-        portal.setupCurrentSkin(portal.REQUEST)\n-        notify(BeforeTraverseEvent(portal, portal.REQUEST))\n-\n-        # Pseudo-login as the test user\n-        from plone.app.testing import helpers\n-        helpers.login(portal, TEST_USER_NAME)\n-\n-    def tearDownEnvironment(self, portal):\n-        """Log out, invalidate standard RAM caches, and unset the local\n-        component site to clean up after tests.\n-        """\n-\n-        # Clear the security manager\n-        from plone.app.testing import helpers\n-        helpers.logout()\n-\n-        # Clear any cached data using plone.memoize\'s RAM caches\n-        from plone.memoize.ram import global_cache\n-        global_cache.invalidateAll()\n-\n-        from zope.component import queryUtility\n-        from plone.memoize.ram import IRAMCache\n-        cache = queryUtility(IRAMCache)\n-        if cache and getattr(cache, \'_cacheId\', None):\n-            cache.invalidateAll()\n-\n-        # Unset the local component site\n-        setSite(None)\n-\n-\n-class MockMailHostLayer(Layer):\n-    """Layer for setting up a MockMailHost to store all sent messages as\n-    strings into a list at portal.MailHost.messages\n-    """\n-    defaultBases = (PLONE_FIXTURE,)\n-\n-    def setUp(self):\n-        with z2.zopeApp() as app:\n-            portal = app[PLONE_SITE_ID]\n-            portal.email_from_address = \'noreply@example.com\'\n-            portal.email_from_name = \'Plone Site\'\n-            portal._original_MailHost = portal.MailHost\n-            portal.MailHost = mailhost = MockMailHost(\'MailHost\')\n-            portal.MailHost.smtp_host = \'localhost\'\n-            sm = getSiteManager(context=portal)\n-            sm.unregisterUtility(provided=IMailHost)\n-            sm.registerUtility(mailhost, provided=IMailHost)\n-\n-    def tearDown(self):\n-        with z2.zopeApp() as app:\n-            portal = app[PLONE_SITE_ID]\n-            _o_mailhost = getattr(portal, \'_original_MailHost\', None)\n-            if _o_mailhost:\n-                portal.MailHost = portal._original_MailHost\n-                sm = getSiteManager(context=portal)\n-                sm.unregisterUtility(provided=IMailHost)\n-                sm.registerUtility(\n-                    aq_base(portal._original_MailHost),\n-                    provided=IMailHost\n-                )\n-\n-\n-MOCK_MAILHOST_FIXTURE = MockMailHostLayer()\n-\n-\n-class IntegrationTesting(PloneTestLifecycle, z2.IntegrationTesting):\n-    """Plone version of the integration testing layer\n-    """\n-\n-\n-class FunctionalTesting(PloneTestLifecycle, z2.FunctionalTesting):\n-    """Plone version of the functional testing layer\n-    """\n-\n-#\n-# Layer instances\n-#\n-\n-# Note: PLONE_FIXTURE is defined above\n-\n-PLONE_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(PLONE_FIXTURE,),\n-    name=\'Plone:Integration\'\n-)\n-PLONE_FUNCTIONAL_TESTING = FunctionalTesting(\n-    bases=(PLONE_FIXTURE,),\n-    name=\'Plone:Functional\'\n-)\n-\n-PLONE_ZSERVER = FunctionalTesting(\n-    bases=(PLONE_FIXTURE, z2.ZSERVER_FIXTURE),\n-    name=\'Plone:ZServer\'\n-)\n-PLONE_FTP_SERVER = FunctionalTesting(\n-    bases=(PLONE_FIXTURE, z2.FTP_SERVER_FIXTURE),\n-    name=\'Plone:FTPServer\'\n-)\ndiff --git a/plone/app/testing/layers.rst b/plone/app/testing/layers.rst\ndeleted file mode 100644\nindex 9e65987..0000000\n--- a/plone/app/testing/layers.rst\n+++ /dev/null\n@@ -1,495 +0,0 @@\n-Plone testing layers\n---------------------\n-\n-There are various layers used to set up test fixtures containing a Plone\n-site. They are all importable from ``plone.app.testing`` directly, or from\n-their canonical locations at ``plone.app.testing.layers``.\n-\n-    >>> from plone.app.testing import layers\n-\n-For testing, we need a testrunner\n-\n-    >>> from zope.testrunner import runner\n-\n-\n-Plone site fixture\n-~~~~~~~~~~~~~~~~~~\n-\n-The ``PLONE_FIXTURE`` layer extends ``STARTUP`` from ``plone.testing.z2`` to\n-set up a Plone site.\n-\n-**Note:** This layer should only be used as a base layer, and not directly in\n-tests, since it does not manage the test lifecycle. To run a simple\n-integration test with this fixture, use the ``PLONE_INTEGRATION_TESTING``\n-layer described below. To run a simple functional test, use the\n-``PLONE_FUNCTIONAL_TESTING`` layer. Both of these have ``PLONE_FIXTURE`` as\n-a base. You can also extend ``PLONE_FIXTURE`` with your own fixture layer,\n-instantiating the ``IntegrationTesting`` or ``FunctionalTesting``classes\n-as appropriate. See this package\'s ``README`` file for details.\n-\n-On layer setup, a new ``DemoStorage`` is stacked on top of the ``zodbDB``\n-resource (see ``plone.testing.zodb``). A fresh Plone with no default content\n-is created and added to the application root in this storage. The various\n-old-style products that Plone depends on are loaded, as is Plone\'s ZCML and\n-that of its direct dependencies. Before loading any ZCML, a new global\n-component registry is stacked on top of the default one (see\n-``plone.testing.zca``).\n-\n-**Note**: A ZCML feature ``disable-autoinclude`` is set before Plone\'s ZCML is\n-loaded. This means that Plone will *not* automatically load the ZCML of\n-installed packages that use the ``z3c.autoinclude.plugin`` entry point. If you\n-want to use such packages, you should load their configuration explicitly.\n-\n-Let\'s set up the fixture layer and inspect the state of the site.\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_FIXTURE, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-\n-The application root\'s ``acl_users`` folder will have one user, whose name and\n-password are found in the constants ``SITE_OWNER_NAME`` and\n-``SITE_OWNER_PASSWORD``, in ``plone.app.testing.interfaces``. This user\n-has the ``Manager`` role, and is the owner of the site object. You should not\n-normally use this for testing, unless you need to manipulate the site itself.\n-\n-    >>> from plone.testing import z2, zca\n-    >>> from plone.app.testing.interfaces import SITE_OWNER_NAME\n-\n-    >>> with z2.zopeApp() as app:\n-    ...     print app[\'acl_users\'].getUser(SITE_OWNER_NAME)\n-    ...     print app[\'acl_users\'].getUser(SITE_OWNER_NAME).getRolesInContext(app)\n-    admin\n-    [\'Manager\', \'Authenticated\']\n-\n-Inside the Plone site, the default theme is installed\n-\n-    >>> from plone.app.testing import helpers\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print portal[\'portal_registry\'][\'plone.app.theming.interfaces.IThemeSettings.rules\']\n-    /++theme++barceloneta/rules.xml\n-\n-**Note:** Here, we have used the ``ploneSite`` context manager to get hold of\n-the Plone site root. Like ``z2.zopeApp()``, this is intended for use during\n-layer setup and tear-down, and will automatically commit any changes unless an\n-error is raised.\n-\n-There is one user, whose user id, login name name and password are found in the\n-constants ``TEST_USER_ID``, ``TEST_USER_NAME`` and ``TEST_USER_PASSWORD`` in\n-the module ``plone.app.testing.interfaces``.\n-\n-    >>> from plone.app.testing.interfaces import TEST_USER_NAME\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getId()\n-    ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getUserName()\n-    ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getRolesInContext(portal)\n-    test_user_1_\n-    test-user\n-    [\'Member\', \'Authenticated\']\n-\n-There is no default workflow or content:\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print portal[\'portal_workflow\'].getDefaultChain()\n-    ()\n-\n-Layer tear-down resets the environment.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-Integration testing\n-~~~~~~~~~~~~~~~~~~~\n-\n-``PLONE_INTEGRATION_TESTING`` can be used to run integration tests against the\n-fixture set up by the ``PLONE_FIXTURE`` layer.\n-\n-    >>> "%s.%s" % (layers.PLONE_INTEGRATION_TESTING.__module__, layers.PLONE_INTEGRATION_TESTING.__name__,)\n-    \'plone.app.testing.layers.Plone:Integration\'\n-\n-    >>> layers.PLONE_INTEGRATION_TESTING.__bases__\n-    (<Layer \'plone.app.testing.layers.PloneFixture\'>,)\n-\n-Let\'s set up the layers and attempt to run a test.\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_INTEGRATION_TESTING, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up plone.app.testing.layers.Plone:Integration in ... seconds.\n-\n-Let\'s now simulate a test\n-\n-    >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n-    >>> layers.PLONE_FIXTURE.testSetUp()\n-    >>> layers.PLONE_INTEGRATION_TESTING.testSetUp()\n-\n-The portal is available as the resource ``portal``:\n-\n-    >>> layers.PLONE_INTEGRATION_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n-    <PloneSite at /plone>\n-\n-The local component site is set to the Plone site for the test:\n-\n-    >>> from zope.component import getSiteManager\n-    >>> getSiteManager()\n-    <PersistentComponents /plone>\n-\n-During the test, we are logged in as the test user:\n-\n-    >>> from AccessControl import getSecurityManager\n-    >>> getSecurityManager().getUser()\n-    <PloneUser \'test-user\'>\n-\n-A new transaction is begun and aborted for each test, so we can create\n-content safely (so long as we don\'t commit):\n-\n-    >>> from plone.app.testing.interfaces import TEST_USER_ID\n-    >>> portal = layers.PLONE_INTEGRATION_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n-    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-    >>> from OFS.SimpleItem import SimpleItem\n-    >>> portal._setObject(\'d1\', SimpleItem(\'d1\'))\n-    \'d1\'\n-    >>> \'d1\' in portal.objectIds()\n-    True\n-\n-Let\'s now simulate test tear-down.\n-\n-    >>> layers.PLONE_INTEGRATION_TESTING.testTearDown()\n-    >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n-    >>> zca.LAYER_CLEANUP.testTearDown()\n-\n-At this point, our transaction has been rolled back:\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     \'d1\' in portal.objectIds()\n-    False\n-\n-We are also logged out again:\n-\n-    >>> getSecurityManager().getUser()\n-    <SpecialUser \'Anonymous User\'>\n-\n-And the component site has been reset:\n-\n-    >>> getSiteManager()\n-    <BaseGlobalComponents test-stack-2>\n-\n-Layer tear-down resets the environment.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.Plone:Integration in ... seconds.\n-    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-Functional testing\n-~~~~~~~~~~~~~~~~~~\n-\n-``PLONE_FUNCTIONAL_TESTING`` can be used to run functional tests against the\n-fixture set up by the ``PLONE_FIXTURE`` layer.\n-\n-    >>> "%s.%s" % (layers.PLONE_FUNCTIONAL_TESTING.__module__, layers.PLONE_FUNCTIONAL_TESTING.__name__,)\n-    \'plone.app.testing.layers.Plone:Functional\'\n-\n-    >>> layers.PLONE_FUNCTIONAL_TESTING.__bases__\n-    (<Layer \'plone.app.testing.layers.PloneFixture\'>,)\n-\n-Let\'s set up the layers and attempt to run a test.\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_FUNCTIONAL_TESTING, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up plone.app.testing.layers.Plone:Functional in ... seconds.\n-\n-Let\'s now simulate a test\n-\n-    >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n-    >>> layers.PLONE_FIXTURE.testSetUp()\n-    >>> layers.PLONE_FUNCTIONAL_TESTING.testSetUp()\n-\n-    >>> layers.PLONE_FUNCTIONAL_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n-    <PloneSite at /plone>\n-\n-    >>> from zope.component import getSiteManager\n-    >>> getSiteManager()\n-    <PersistentComponents /plone>\n-\n-    >>> from AccessControl import getSecurityManager\n-    >>> getSecurityManager().getUser()\n-    <PloneUser \'test-user\'>\n-\n-A new ``DemoStorage`` is stacked for each test, so we can safely commit during\n-test execution.\n-\n-    >>> portal = layers.PLONE_FUNCTIONAL_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n-    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-    >>> portal._setObject(\'d1\', SimpleItem(\'d1\'))\n-    \'d1\'\n-    >>> import transaction; transaction.commit()\n-    >>> \'d1\' in portal.objectIds()\n-    True\n-\n-Let\'s now simulate test tear-down.\n-\n-    >>> layers.PLONE_FUNCTIONAL_TESTING.testTearDown()\n-    >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n-    >>> zca.LAYER_CLEANUP.testTearDown()\n-\n-The previous database state should have been restored.\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     \'d1\' in portal.objectIds()\n-    False\n-\n-Along with the rest of the state:\n-\n-    >>> getSecurityManager().getUser()\n-    <SpecialUser \'Anonymous User\'>\n-\n-    >>> getSiteManager()\n-    <BaseGlobalComponents test-stack-2>\n-\n-Layer tear-down resets the environment.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.Plone:Functional in ... seconds.\n-    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-HTTP server\n-~~~~~~~~~~~\n-\n-The ``PLONE_ZSERVER`` layer instantiates the ``FunctionalTesting`` class with\n-two bases: ``PLONE_FIXTURE``, as shown above, and ``ZSERVER_FIXTURE`` from\n-``plone.testing``, which starts up a ZServer thread.\n-\n-    >>> "%s.%s" % (layers.PLONE_ZSERVER.__module__, layers.PLONE_ZSERVER.__name__,)\n-    \'plone.app.testing.layers.Plone:ZServer\'\n-\n-    >>> layers.PLONE_ZSERVER.__bases__\n-    (<Layer \'plone.app.testing.layers.PloneFixture\'>, <Layer \'plone.testing.z2.ZServer\'>)\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_ZSERVER, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up plone.testing.z2.ZServer in ... seconds.\n-    Set up plone.app.testing.layers.Plone:ZServer in ... seconds.\n-\n-After layer setup, the resources ``host`` and ``port`` are available, and\n-indicate where Zope is running.\n-\n-    >>> host = layers.PLONE_ZSERVER[\'host\']\n-    >>> host\n-    \'localhost\'\n-\n-    >>> port = layers.PLONE_ZSERVER[\'port\']\n-    >>> import os\n-    >>> port == int(os.environ.get(\'ZSERVER_PORT\', 55001))\n-    True\n-\n-Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n-do.\n-\n-    >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n-    >>> layers.PLONE_FIXTURE.testSetUp()\n-    >>> z2.ZSERVER_FIXTURE.testSetUp()\n-    >>> layers.PLONE_ZSERVER.testSetUp()\n-\n-It is common in a test to use the Python API to change the state of the server\n-(e.g. create some content or change a setting) and then use the HTTP protocol\n-to look at the results. Bear in mind that the server is running in a separate\n-thread, with a separate security manager, so calls to ``helpers.login()`` and\n-``helpers.logout()``, for instance, do not affect the server thread.\n-\n-    >>> portal = layers.PLONE_ZSERVER[\'portal\'] # would normally be self.layer[\'portal\']\n-    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-    >>> portal.title = \'Fancy Portal\'\n-\n-Note that we need to commit the transaction before it will show up in the\n-other thread.\n-\n-    >>> import transaction; transaction.commit()\n-\n-We can now look for this new object through the server.\n-\n-    >>> portal_url = portal.absolute_url()\n-    >>> portal_url.split(\':\')[:-1]\n-    [\'http\', \'//localhost\']\n-\n-    >>> import urllib2\n-    >>> conn = urllib2.urlopen(portal_url + \'/Title\', timeout=10)\n-    >>> responseBody = conn.read()\n-    >>> "Fancy Portal" in responseBody\n-    True\n-    >>> conn.close()\n-\n-Test tear-down does nothing beyond what the base layers do.\n-\n-    >>> layers.PLONE_ZSERVER.testTearDown()\n-    >>> z2.ZSERVER_FIXTURE.testTearDown()\n-    >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n-    >>> zca.LAYER_CLEANUP.testTearDown()\n-\n-    >>> \'portal\' in layers.PLONE_ZSERVER\n-    False\n-\n-    >>> \'app\' in layers.PLONE_ZSERVER\n-    False\n-\n-    >>> \'request\' in layers.PLONE_ZSERVER\n-    False\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print \'folder1\' in portal.objectIds()\n-    False\n-\n-When the server is torn down, the ZServer thread is stopped.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.Plone:ZServer in ... seconds.\n-    ...Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    ...Tear down plone.testing.z2.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-    >>> conn = urllib2.urlopen(portal_url + \'/folder1\', timeout=5)\n-    Traceback (most recent call last):\n-    ...\n-    URLError: <urlopen error [Errno ...] Connection refused>\n-\n-FTP server with Plone site\n-~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-The ``PLONE_FTP_SERVER`` layer instantiates the ``FunctionalTesting`` class\n-with two bases: ``PLONE_FIXTURE``, as shown above, and ``FTP_SERVER_FIXTURE``\n-from ``plone.testing``, which starts up an FTP server thread.\n-\n-    >>> "%s.%s" % (layers.PLONE_FTP_SERVER.__module__, layers.PLONE_FTP_SERVER.__name__,)\n-    \'plone.app.testing.layers.Plone:FTPServer\'\n-\n-    >>> layers.PLONE_FTP_SERVER.__bases__\n-    (<Layer \'plone.app.testing.layers.PloneFixture\'>, <Layer \'plone.testing.z2.FTPServer\'>)\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_FTP_SERVER, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up plone.testing.z2.FTPServer in ... seconds.\n-    Set up plone.app.testing.layers.Plone:FTPServer in ... seconds.\n-\n-After layer setup, the resources ``host`` and ``port`` are available, and\n-indicate where Zope is running.\n-\n-    >>> host = layers.PLONE_FTP_SERVER[\'host\']\n-    >>> host\n-    \'localhost\'\n-\n-    >>> port = layers.PLONE_FTP_SERVER[\'port\']\n-    >>> import os\n-    >>> port == int(os.environ.get(\'FTPSERVER_PORT\', 55002))\n-    True\n-\n-Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n-do.\n-\n-    >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n-    >>> layers.PLONE_FIXTURE.testSetUp()\n-    >>> z2.FTP_SERVER_FIXTURE.testSetUp()\n-    >>> layers.PLONE_FTP_SERVER.testSetUp()\n-\n-It is common in a test to use the Python API to change the state of the server\n-(e.g. create some content or change a setting) and then use the FTP protocol\n-to look at the results. Bear in mind that the server is running in a separate\n-thread, with a separate security manager, so calls to ``helpers.login()`` and\n-``helpers.logout()``, for instance, do not affect the server thread.\n-\n-    >>> portal = layers.PLONE_FTP_SERVER[\'portal\'] # would normally be self.layer[\'portal\']\n-    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-    >>> from OFS.Folder import Folder\n-    >>> portal._setObject(\'folder1\', Folder(\'folder1\'))\n-    \'folder1\'\n-\n-Note that we need to commit the transaction before it will show up in the\n-other thread.\n-\n-    >>> import transaction; transaction.commit()\n-\n-    >>> folder_path = portal.absolute_url_path() + \'/folder1\'\n-\n-    >>> import ftplib\n-    >>> ftpClient = ftplib.FTP()\n-    >>> ftpClient.connect(host, port, timeout=5)\n-    \'220 ... FTP server (...) ready.\'\n-\n-    >>> from plone.app.testing.interfaces import SITE_OWNER_NAME\n-    >>> from plone.app.testing.interfaces import SITE_OWNER_PASSWORD\n-\n-    >>> ftpClient.login(SITE_OWNER_NAME, SITE_OWNER_PASSWORD)\n-    \'230 Login successful.\'\n-\n-    >>> ftpClient.cwd(folder_path)\n-    \'250 CWD command successful.\'\n-\n-    >>> ftpClient.retrlines(\'LIST\')\n-    drwxrwx---   1 test_user_1_ Zope            0 ... .\n-    d---------   1 admin        Zope            0 ... ..\n-    \'226 Transfer complete\'\n-\n-    >>> ftpClient.quit()\n-    \'221 Goodbye.\'\n-\n-Test tear-down does nothing beyond what the base layers do.\n-\n-    >>> layers.PLONE_FTP_SERVER.testTearDown()\n-    >>> z2.FTP_SERVER_FIXTURE.testTearDown()\n-    >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n-    >>> zca.LAYER_CLEANUP.testTearDown()\n-\n-    >>> \'portal\' in layers.PLONE_FTP_SERVER\n-    False\n-\n-    >>> \'app\' in layers.PLONE_FTP_SERVER\n-    False\n-\n-    >>> \'request\' in layers.PLONE_FTP_SERVER\n-    False\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print \'folder1\' in portal.objectIds()\n-    False\n-\n-When the server is torn down, the FTP server thread is stopped.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.Plone:FTPServer in ... seconds.\n-    ...Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    ...Tear down plone.testing.z2.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-    >>> ftpClient.connect(host, port, timeout=5)\n-    Traceback (most recent call last):\n-    ...\n-    error: [Errno ...] Connection refused\ndiff --git a/plone/app/testing/profile/metadata.xml b/plone/app/testing/profile/metadata.xml\ndeleted file mode 100644\nindex 6ce5b66..0000000\n--- a/plone/app/testing/profile/metadata.xml\n+++ /dev/null\n@@ -1,5 +0,0 @@\n-<?xml version="1.0"?>\n-<metadata>\n-  <!-- This is used in the helpers.rst tests. -->\n-  <version>1000</version>\n-</metadata>\ndiff --git a/plone/app/testing/selenium.rst b/plone/app/testing/selenium.rst\ndeleted file mode 100644\nindex f03719a..0000000\n--- a/plone/app/testing/selenium.rst\n+++ /dev/null\n@@ -1,187 +0,0 @@\n-Selenium testing layer\n-----------------------\n-\n-Introduction\n-============\n-\n-There is a layer used to set up test fixtures for running\n-`Selenium <code.google.com/p/selenium/>`_\n-tests against a Plone site. It is importable from\n-``plone.app.testing.selenium_layers``.\n-\n-With Selenium you get\n-\n-* Any real web browser, installed on your computer, accessing your unit test site\n-\n-* Real Javascript support and AJAX support\n-\n-* Real visibility test: is any element visible on the screen according to CSS\n-\n-* Scrape your page content with CSS selectors\n-\n-* Execute Javascript test snippets against loaded pages to see if your JS code is sane\n-\n-* Ability to take screenshots of web pages\n-\n-Selenium provides a ``WebDriver`` class which has a subclass for each\n-browser (Chrome, Firefox, IE...) for running the tests on this specific browser.\n-\n-`More info about available WebDriver API <http://code.google.com/p/selenium/source/browse/trunk/py/selenium/webdriver/remote/webdriver.py>`_.\n-\n-`Selenium element matching options <http://code.google.com/p/selenium/source/browse/trunk/py/selenium/webdriver/common/by.py>`_\n-\n-`Extracting data from matched elements <http://code.google.com/p/selenium/source/browse/trunk/py/selenium/webdriver/remote/webelement.py>`_\n-\n-Using Selenium with plone.app.testing\n-=======================================\n-\n-Note that if using the "-D" pdb debugger testrunner flag for failures\n-in this test before the layer is torn down, the testrunner process\n-will not exit even with interrupt. Exit by backgrounding the process\n-and then kill the backgrouned process.\n-\n-    >>> from plone.app.testing import selenium_layers as layers\n-\n-For testing, we need a testrunner\n-\n-    >>> from zope.testrunner import runner\n-\n-The ``SELENIUM_PLONE_FUNCTIONAL_TESTING`` layer instantiates the\n-``FunctionalTesting`` class with two bases: ``SELENIUM_FIXTURE``, as\n-shown above, and ``PLONE_FIXTURE``.\n-\n-    >>> "%s.%s" % (\n-    ...     layers.SELENIUM_PLONE_FUNCTIONAL_TESTING.__module__,\n-    ...     layers.SELENIUM_PLONE_FUNCTIONAL_TESTING.__name__,)\n-    \'plone.app.testing.selenium_layers.SeleniumTesting:Functional\'\n-\n-    >>> layers.SELENIUM_PLONE_FUNCTIONAL_TESTING.__bases__\n-    (<Layer \'plone.app.testing.selenium_layers.SeleniumLayer\'>, <Layer \'plone.app.testing.layers.PloneFixture\'>)\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(\n-    ...     options, layers.SELENIUM_PLONE_FUNCTIONAL_TESTING, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.testing.z2.ZServer in ... seconds.\n-    Set up plone.app.testing.selenium_layers.SeleniumLayer in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up plone.app.testing.selenium_layers.SeleniumTesting:Functional in ... seconds.\n-\n-After layer setup, the resources ``host`` and ``port`` are available, and\n-indicate where Zope is running.\n-\n-    >>> host = layers.SELENIUM_PLONE_FUNCTIONAL_TESTING[\'host\']\n-    >>> host\n-    \'localhost\'\n-\n-    >>> port = layers.SELENIUM_PLONE_FUNCTIONAL_TESTING[\'port\']\n-    >>> import os\n-    >>> port == int(os.environ.get(\'ZSERVER_PORT\', 55001))\n-    True\n-\n-Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n-do.\n-\n-    >>> from plone.testing import z2, zca\n-    >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n-    >>> layers.SELENIUM_FIXTURE.testSetUp()\n-    >>> layers.SELENIUM_PLONE_FUNCTIONAL_TESTING.testSetUp()\n-\n-It is common in a test to use the Python API to change the state of\n-the server (e.g. create some content or change a setting) and then use\n-the Selenium browser to look at the results. Bear in mind that the\n-server is running in a separate thread, with a separate security\n-manager, so calls to ``helpers.login()`` and ``helpers.logout()``, for\n-instance, do not affect the server thread.\n-\n-    >>> from plone.app.testing import helpers\n-    >>> from plone.app.testing.interfaces import TEST_USER_ID\n-    >>> portal = layers.SELENIUM_PLONE_FUNCTIONAL_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n-    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-    >>> portal.title = \'Ploney times\'\n-\n-    >>> from plone.app.testing.selenium_layers import open\n-    >>> selenium = layers.SELENIUM_PLONE_FUNCTIONAL_TESTING[\'selenium\']\n-    >>> open(selenium, portal.absolute_url())\n-    >>> selenium.title\n-    u\'Ploney times\'\n-\n-Now we also test logging-in to Plone.\n-\n-    >>> from plone.app.testing.selenium_layers import login\n-    >>> login(selenium, portal)\n-    >>> selenium.find_element_by_tag_name(\'h1\').text\n-    u\'You are now logged in\'\n-\n-Test tear-down does nothing beyond what the base layers do.\n-\n-    >>> layers.SELENIUM_PLONE_FUNCTIONAL_TESTING.testTearDown()\n-    >>> layers.SELENIUM_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n-    >>> zca.LAYER_CLEANUP.testTearDown()\n-\n-    >>> \'portal\' in layers.SELENIUM_PLONE_FUNCTIONAL_TESTING\n-    False\n-\n-    >>> \'app\' in layers.SELENIUM_PLONE_FUNCTIONAL_TESTING\n-    False\n-\n-    >>> \'request\' in layers.SELENIUM_PLONE_FUNCTIONAL_TESTING\n-    False\n-\n-When the layer is torn down, the Selenium browser is closed.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.selenium_layers.SeleniumTesting:Functional in ... seconds.\n-    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-    >>> if getattr(selenium, \'_server\', None) is None:\n-    ...     import urllib2\n-    ...     urllib2.urlopen(\'http://XXX\')\n-    ... else:\n-    ...     from selenium.remote.webdriver import WebDriver\n-    ...     WebDriver._execute(selenium, \'quit\')\n-    Traceback (most recent call last):\n-    URLError: ...\n-\n-Selenium and transactions\n-==========================\n-\n-Selenium WebDriver runs in a different thread than your plone.app.testing Python code.\n-Both threads have their own ZODB transactions. If you modify the data in Selenium thread\n-(e.g. your virtual user modifies something) you cannot directly access this data\n-in the test thread.\n-\n-This is important whenever your interactions with the\n-Selenium browser are going to require retrieving content from the\n-server when that content needs to reflect changes you\'ve made in your\n-test. For example, if some browser action invokes some AJAX code which\n-refreshes a part of the page from ZODB content, that refreshed content\n-will only reflect recent changes if you did transaction.commit()\n-before executing the browser action that triggered the AJAX.  The\n-plone.app.testing.selenium_layers.open() method does this for you when\n-opening a new URL, but there are many more ways to cause content\n-changes that pull from the ZODB when doing JavaScript testing so in\n-all other cases you are responsible to call transaction.commit()\n-yourself.\n-\n-Here is an example how we force the test thread to get a fresh copy of the object\n-after Selenium has poked it.\n-\n-Example::\n-\n-    import transaction\n-\n-    def test_something():\n-        # ... Selenium modifies the site here ...\n-\n-        # Make sure that the test thread and the selenium thread ZODB are synced\n-        transaction.commit()\n-        text = self.page.getText()\n-\n-        self.assertEqual(text, NEW_TEXT)\ndiff --git a/plone/app/testing/selenium_layers.py b/plone/app/testing/selenium_layers.py\ndeleted file mode 100644\nindex 57fdf69..0000000\n--- a/plone/app/testing/selenium_layers.py\n+++ /dev/null\n@@ -1,124 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.testing import FunctionalTesting\n-from plone.app.testing import PLONE_FIXTURE\n-from plone.app.testing import TEST_USER_NAME\n-from plone.app.testing import TEST_USER_PASSWORD\n-from plone.testing import Layer\n-from plone.testing import z2\n-\n-import os\n-import transaction\n-\n-\n-class SeleniumLayer(Layer):\n-    defaultBases = (z2.ZSERVER_FIXTURE, )\n-\n-    def testSetUp(self):\n-        # Start up Selenium\n-        driver = os.environ.get(\'SELENIUM_DRIVER\', \'\').lower() or \'firefox\'\n-        webdriver = __import__(\n-            \'selenium.webdriver.{0}.webdriver\'.format(driver),\n-            fromlist=[\'WebDriver\']\n-        )\n-        args = [arg.strip() for arg in\n-                os.environ.get(\'SELENIUM_ARGS\', \'\').split()\n-                if arg.strip()]\n-        self[\'selenium\'] = webdriver.WebDriver(*args)\n-\n-    def testTearDown(self):\n-        self[\'selenium\'].quit()\n-        del self[\'selenium\']\n-\n-SELENIUM_FIXTURE = SeleniumLayer()\n-SELENIUM_FUNCTIONAL_TESTING = FunctionalTesting(\n-    bases=(SELENIUM_FIXTURE, ),\n-    name=\'SeleniumTesting:Functional\')\n-SELENIUM_PLONE_FUNCTIONAL_TESTING = FunctionalTesting(\n-    bases=(SELENIUM_FIXTURE, PLONE_FIXTURE),\n-    name=\'SeleniumTesting:Functional\')\n-\n-\n-# Helper functions\n-\n-\n-def open(selenium, url):\n-    # ensure we have a clean starting point\n-    transaction.commit()\n-    selenium.get(url)\n-\n-\n-def login(selenium, portal, username=False, password=False):\n-\n-    if not username:\n-        username = TEST_USER_NAME\n-    if not password:\n-        password = TEST_USER_PASSWORD\n-\n-    open(selenium, portal.absolute_url() + \'/login_form\')\n-    selenium.find_element_by_name(\'__ac_name\').send_keys(username)\n-    selenium.find_element_by_name(\'__ac_password\').send_keys(password)\n-    selenium.find_element_by_name(\'submit\').click()\n-\n-\n-def click(selenium, xpath):\n-    if xpath.count(\'link=\'):\n-        link = xpath.split(\'link=\')[-1]\n-        element = selenium.find_element_by_partial_link_text(link)\n-    elif xpath.count(\'//\'):\n-        element = selenium.find_element_by_xpath(xpath)\n-    elif xpath.count(\'#\'):\n-        eleName = xpath.split(\'#\')[-1]\n-        element = selenium.find_element_by_id(eleName)\n-    else:\n-        element = selenium.find_element_by_name(xpath)\n-\n-    element.click()\n-\n-\n-def type(selenium, name, value):\n-    selenium.find_element_by_name(name).send_keys(value)\n-\n-\n-def typeMce(selenium, value):\n-    """\n-    Text fields with mce are different.\n-    We need to go into the frame and update the p element to make this work.\n-    Unfortunately the code to get out of the frame is not implemented in python\n-    yet.\n-    The workaround is to use this handle trick,\n-    which is currently unsupported in chrome.\n-    See issue #405 for more.\n-    In general there are still a lot of open issues on frame support so if\n-    this breaks it won\'t be a surprise.\n-    """\n-    handle = selenium.current_window_handle\n-    selenium.switch_to_frame(\'form.text_ifr\')\n-    ele = selenium.find_element_by_xpath(\'//p\')\n-    ele.send_keys(value)\n-    selenium.switch_to_window(handle)\n-\n-\n-def clear(selenium, name):\n-    selenium.find_element_by_name(name).clear()\n-\n-\n-def select(selenium, xpath1, xpath2=\'\'):\n-    xpath = xpath1\n-    if xpath2:\n-        xpath = "{0}[\'{1}\']".format(xpath1, xpath2)\n-        xpath = xpath.replace("select[\'label=", "select/option[\'text()=")\n-    selenium.find_element_by_xpath(xpath).click()\n-\n-\n-def waitForPageToLoad(selenium, foo):\n-    # this does nothing but make us lazy folks happy\n-    pass\n-\n-\n-def publish(selenium):\n-    click(selenium, "//dl[@id=\'plone-contentmenu-workflow\']/dt/a")\n-    click(selenium, \'#workflow-transition-publish\')\n-\n-\n-def submit(selenium, formId):\n-    selenium.find_element_by_id(formId).submit()\ndiff --git a/plone/app/testing/tests.py b/plone/app/testing/tests.py\ndeleted file mode 100644\nindex 3f0c844..0000000\n--- a/plone/app/testing/tests.py\n+++ /dev/null\n@@ -1,26 +0,0 @@\n-# -*- coding: utf-8 -*-\n-import doctest\n-import unittest\n-\n-\n-OPTIONFLAGS = doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE\n-\n-\n-# Dummy handler used in tests\n-def dummy(context):\n-    pass\n-\n-\n-def test_suite():\n-    suite = unittest.TestSuite()\n-    # seltest = doctest.DocFileSuite(\'selenium.rst\', optionflags=OPTIONFLAGS)\n-    # Run selenium tests on level 2, as it requires a correctly configured\n-    # Firefox browser\n-    # seltest.level = 2\n-    suite.addTests([\n-        doctest.DocFileSuite(\'cleanup.rst\', optionflags=OPTIONFLAGS),\n-        doctest.DocFileSuite(\'layers.rst\', optionflags=OPTIONFLAGS),\n-        doctest.DocFileSuite(\'helpers.rst\', optionflags=OPTIONFLAGS),\n-        # seltest,\n-    ])\n-    return suite\ndiff --git a/plone/app/testing/utils.py b/plone/app/testing/utils.py\ndeleted file mode 100644\nindex 0771372..0000000\n--- a/plone/app/testing/utils.py\n+++ /dev/null\n@@ -1,27 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from persistent.list import PersistentList\n-from Products.MailHost.MailHost import _mungeHeaders\n-from Products.MailHost.MailHost import MailBase\n-\n-\n-class MockMailHost(MailBase):\n-    """A MailHost that collects messages instead of sending them.\n-    """\n-\n-    def __init__(self, id):\n-        self.reset()\n-\n-    def reset(self):\n-        self.messages = PersistentList()\n-\n-    def _send(self, mfrom, mto, messageText, immediate=False):\n-        """ Send the message """\n-        self.messages.append(messageText)\n-\n-    def send(self, messageText, mto=None, mfrom=None, subject=None,\n-             encode=None, immediate=False, charset=None, msg_type=None):\n-        messageText, mto, mfrom = _mungeHeaders(messageText,\n-                                                mto, mfrom, subject,\n-                                                charset=charset,\n-                                                msg_type=msg_type)\n-        self.messages.append(messageText)\ndiff --git a/setup.cfg b/setup.cfg\nindex ce96d1d..2bce1d9 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,11 +1,60 @@\n+[build_sphinx]\n+source-dir = docs/source\n+build-dir  = _build/docs\n+all_files  = 1\n+\n+[upload_sphinx]\n+upload-dir = _build/docs/html\n+\n [check-manifest]\n ignore =\n-    *.cfg\n     bootstrap.py\n+    buildout.cfg\n+    tox.ini\n+\n+[coverage:run]\n+branch = True\n+\n+source =\n+    src\n+\n+omit =\n+\n+[coverage:report]\n+precision = 2\n+\n+[coverage:html]\n+directory = _build/reports/coverage\n+\n+\n+[isort]\n+# for details see\n+# http://docs.plone.org/develop/styleguide/python.html#grouping-and-sorting\n+force_alphabetical_sort = True\n+force_single_line = True\n+lines_after_imports = 2\n+line_length = 200\n+not_skip = __init__.py\n+\n+[flake8]\n+exclude =\n+    bootstrap.py,\n+\n+include =\n+    src\n+\n+ignore =\n+    N801,\n+    N802,\n+    N803,\n+    N805,\n+    N806,\n+    N812,\n+    T000,\n+    T003,\n \n [zest.releaser]\n create-wheel = yes\n \n-# When Python 2-3 compatible:\n-# [bdist_wheel]\n-# universal = 1\n+[bdist_wheel]\n+universal = 1\ndiff --git a/setup.py b/setup.py\nindex e356eff..36c0bda 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,48 +1,63 @@\n-from setuptools import setup, find_packages\n+# -*- coding: utf-8 -*-\n+from setuptools import find_packages\n+from setuptools import setup\n+\n import os\n \n+\n version = \'6.0.0.dev0\'\n \n-tests_require = [\'Products.CMFCore\',\n-                 \'Products.CMFPlone\',\n-                 \'Products.PluggableAuthService\',\n-                 \'Products.ATContentTypes\',  # XXX unspecified dependency of plone.app.upgrade XXX\n-                 \'Products.CMFPlacefulWorkflow\',\n-                 \'selenium\',\n-                 \'transaction\',\n-                 \'zope.interface\',\n-                 \'zope.publisher\',\n-                 \'zope.testrunner\',\n-                 ]\n+tests_require = [\n+    \'Products.CMFCore\',\n+    \'Products.CMFPlone\',\n+    \'Products.PluggableAuthService\',\n+    \'Products.CMFPlacefulWorkflow\',\n+    \'selenium\',\n+    \'transaction\',\n+    \'zope.interface\',\n+    \'zope.publisher\',\n+    \'zope.testrunner\',\n+    # XXX unspecified dependency of plone.app.upgrade XXX\n+    # \'Products.ATContentTypes\',\n+]\n+\n+robot_require = [\n+    \'robotsuite>=1.4.0\',\n+    \'robotframework-selenium2library\',\n+    \'decorator\',\n+    \'selenium\',\n+]\n \n-robot_require = [\'robotsuite>=1.4.0\',\n-                 \'robotframework-selenium2library\',\n-                 \'decorator\',\n-                 \'selenium\']\n \n def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n+\n long_description = \\\n-    read(\'docs\', \'source\',\'README.rst\') + \\\n+    read(\'docs\', \'source\', \'README.rst\') + \\\n     \'\\n\\n\' +\\\n     read(\'CHANGES.rst\')\n \n+\n setup(\n     name=\'plone.app.testing\',\n     version=version,\n-    description="Testing tools for Plone-the-application, based on plone.testing.",\n+    description="Testing tools for Plone-the-application, based on plone.testing.",  # NOQA: E501\n     long_description=long_description,\n     classifiers=[\n         "Environment :: Web Environment",\n         "Framework :: Plone",\n         "Framework :: Plone :: 5.0",\n         "Framework :: Plone :: 5.1",\n+        "Framework :: Plone :: 5.2",\n         "Framework :: Zope2",\n         "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n         "Operating System :: OS Independent",\n         "Programming Language :: Python",\n         "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.5",\n+        "Programming Language :: Python :: 3.6",\n+        "Programming Language :: Python :: 3.7",\n         "Topic :: Internet :: WWW/HTTP :: Dynamic Content",\n     ],\n     keywords=\'plone tests\',\n@@ -50,7 +65,8 @@ def read(*rnames):\n     author_email=\'plone-developers@lists.sourceforge.net\',\n     url=\'https://pypi.python.org/pypi/plone.app.testing\',\n     license=\'GPL version 2\',\n-    packages=find_packages(exclude=[\'ez_setup\']),\n+    packages=find_packages(\'src\'),\n+    package_dir={\'\': \'src\'},\n     namespace_packages=[\'plone\', \'plone.app\'],\n     include_package_data=True,\n     zip_safe=False,\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..9534c20\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,156 @@\n+[tox]\n+envlist =\n+    py27,\n+    py36,\n+#    py36-zserver,\n+    coverage-report,\n+#    docs,\n+    lint-py27,\n+    lint-py36,\n+\n+minversion = 1.9\n+\n+[testenv]\n+usedevelop = True\n+\n+pip_pre = True\n+\n+extras =\n+    test\n+\n+deps =\n+     coverage\n+\n+commands =\n+    python -V\n+    coverage run {envbindir}/zope-testrunner --path=src --all {posargs:-vc}\n+\n+setenv =\n+    COVERAGE_FILE=.coverage.{envname}\n+\n+passenv =\n+    WSGI_REQUEST_LOGGING\n+\n+[testenv:coverage-report]\n+skip_install = true\n+basepython = python2.7\n+\n+deps = coverage\n+\n+setenv =\n+    COVERAGE_FILE=.coverage\n+\n+commands =\n+    coverage erase\n+    coverage combine\n+    coverage html -i\n+    coverage xml -i\n+    coverage report -i --fail-under=85\n+\n+\n+[lint]\n+skip_install = true\n+\n+deps =\n+    isort\n+    flake8\n+    # helper to generate HTML reports:\n+    flake8-html\n+    # Useful flake8 plugins that are Python and Plone specific:\n+    flake8-coding\n+    flake8-debugger\n+    flake8-deprecated\n+    flake8-print\n+    flake8-pytest\n+    flake8-todo\n+    flake8-isort\n+    mccabe\n+    # Potential flake8 plugins that should be used:  # TBD\n+    #flake8-blind-except\n+    #flake8-commas\n+    #flake8-docstrings\n+    #flake8-mypy\n+    #flake8-pep3101\n+    #flake8-plone-hasattr\n+    #flake8-string-format\n+    #flake8_strict\n+    #flake8-quotes\n+    #flake8-polyfill\n+\n+commands =\n+    mkdir -p {toxinidir}/_build/reports/flake8\n+    - flake8 --format=html --htmldir={toxinidir}/_build/reports/flake8 --doctests src setup.py\n+    flake8 --doctests src tests setup.py\n+    isort --check-only --recursive {toxinidir}/src\n+\n+whitelist_externals =\n+    mkdir\n+\n+[testenv:isort-apply]\n+skip_install = true\n+\n+deps =\n+    isort\n+\n+commands =\n+    isort --apply --recursive {toxinidir}/src\n+\n+[testenv:lint-py27]\n+basepython = python2.7\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:lint-py34]\n+basepython = python3.4\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:lint-py35]\n+basepython = python3.5\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:lint-py36]\n+basepython = python3.6\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:docs]\n+skip_install = true\n+\n+deps =\n+    Sphinx\n+\n+commands =\n+    sphinx-build -b html -d _build/docs/doctrees docs _build/docs/html\n+    sphinx-build -b doctest docs _build/docs/doctrees\n+\n+[testenv:update_translation]\n+skip_install = true\n+\n+deps =\n+    i18ndude\n+\n+commands =\n+    i18ndude find-untranslated\n+    i18ndude rebuild-pot\n+    i18ndude merge\n+    i18ndude sync\n+    i18ndude list\n+\n+[testenv:release]\n+skip_install = true\n+\n+deps =\n+    zest.releaser[recommended]\n+\n+commands =\n+    fullrelease --no-input -v\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-04-23T23:59:17+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.app.testing/commit/b8b12dc76c8f5fc37fee8290cd41efc352228a15

git ignore

Files changed:
M .gitignore

b'diff --git a/.gitignore b/.gitignore\nindex e9a4787..8704b96 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -10,16 +10,20 @@\n /local.cfg\n /*.egg-info\n /.installed.cfg\n-*.pyc\n+*.py[cod]\n /.Python\n+/pip-selfcheck.json\n /include\n /lib\n /src\n /.project\n /.pydevproject\n /.mr.developer.cfg\n-/src/plone*\n-/src/collective*\n+/src-mrd/\n+/.tox/\n+/_build/\n+coverage.xml\n+.coverage*\n *.mo\n docs/Makefile\n docs/make.bat\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-04-24T00:03:52+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.app.testing/commit/acb94b0f20848eb7c12492f1786660060beb0243

move docs

Files changed:
A docs/README.rst
A docs/conf.py
A docs/index.rst
A docs/isolation.rst
A docs/views.rst
A docs/zope-testbrowser.rst
M README.rst
D docs/source/README.rst
D docs/source/conf.py
D docs/source/index.rst
D docs/source/isolation.rst
D docs/source/views.rst
D docs/source/zope-testbrowser.rst

b'diff --git a/README.rst b/README.rst\nindex dd7a278..cffceba 120000\n--- a/README.rst\n+++ b/README.rst\n@@ -1 +1 @@\n-docs/source/README.rst\n\\ No newline at end of file\n+docs/README.rst\n\\ No newline at end of file\ndiff --git a/docs/source/README.rst b/docs/README.rst\nsimilarity index 100%\nrename from docs/source/README.rst\nrename to docs/README.rst\ndiff --git a/docs/source/conf.py b/docs/conf.py\nsimilarity index 100%\nrename from docs/source/conf.py\nrename to docs/conf.py\ndiff --git a/docs/source/index.rst b/docs/index.rst\nsimilarity index 100%\nrename from docs/source/index.rst\nrename to docs/index.rst\ndiff --git a/docs/source/isolation.rst b/docs/isolation.rst\nsimilarity index 100%\nrename from docs/source/isolation.rst\nrename to docs/isolation.rst\ndiff --git a/docs/source/views.rst b/docs/views.rst\nsimilarity index 100%\nrename from docs/source/views.rst\nrename to docs/views.rst\ndiff --git a/docs/source/zope-testbrowser.rst b/docs/zope-testbrowser.rst\nsimilarity index 100%\nrename from docs/source/zope-testbrowser.rst\nrename to docs/zope-testbrowser.rst\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-04-24T00:22:43+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.app.testing/commit/ea9c4f1695cca9bdf57cbd2a86935e2ee46415f1

config

Files changed:
A src/plone.app.testing.egg-info/PKG-INFO
A src/plone.app.testing.egg-info/SOURCES.txt
A src/plone.app.testing.egg-info/dependency_links.txt
A src/plone.app.testing.egg-info/namespace_packages.txt
A src/plone.app.testing.egg-info/not-zip-safe
A src/plone.app.testing.egg-info/requires.txt
A src/plone.app.testing.egg-info/top_level.txt
A src/plone/__init__.py
A src/plone/app/__init__.py
A src/plone/app/testing/__init__.py
A src/plone/app/testing/bbb.py
A src/plone/app/testing/cleanup.py
A src/plone/app/testing/cleanup.rst
A src/plone/app/testing/helpers.py
A src/plone/app/testing/helpers.rst
A src/plone/app/testing/interfaces.py
A src/plone/app/testing/layers.py
A src/plone/app/testing/layers.rst
A src/plone/app/testing/profile/metadata.xml
A src/plone/app/testing/selenium.rst
A src/plone/app/testing/selenium_layers.py
A src/plone/app/testing/tests.py
A src/plone/app/testing/utils.py
M .gitignore
M buildout.cfg
M docs/conf.py
M setup.py
M tox.ini

b'diff --git a/.gitignore b/.gitignore\nindex 8704b96..ac88fde 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -15,7 +15,6 @@\n /pip-selfcheck.json\n /include\n /lib\n-/src\n /.project\n /.pydevproject\n /.mr.developer.cfg\ndiff --git a/buildout.cfg b/buildout.cfg\nindex be1924a..2f81926 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -16,13 +16,13 @@ versions = versions\n \n auto-checkout =\n     plone.testing\n-    Products.GenericSetup\n+#    Products.GenericSetup\n \n sources-dir = src-mrd\n \n develop =\n     src-mrd/plone.testing\n-    src-mrd/Products.GenericSetup\n+#    src-mrd/Products.GenericSetup\n \n [remotes]\n plone = git://github.com/plone\n@@ -37,7 +37,7 @@ Products.GenericSetup =\n \n [sources]\n plone.testing         = git ${remotes:plone}/plone.testing.git pushurl=${remotes:plone_push}/plone.testing.git branch=py3\n-Products.GenericSetup = git ${remotes:zope}/Products.GenericSetup.git pushurl=${remotes:plone_push}/Products.GenericSetup branch=master\n+#Products.GenericSetup = git ${remotes:zope}/Products.GenericSetup.git pushurl=${remotes:plone_push}/Products.GenericSetup branch=master\n \n [test]\n recipe = collective.xmltestreport\ndiff --git a/docs/conf.py b/docs/conf.py\nindex ff35066..ba460d1 100644\n--- a/docs/conf.py\n+++ b/docs/conf.py\n@@ -41,7 +41,7 @@\n \n # General information about the project.\n project = u\'plone.app.testing\'\n-copyright = u\'2015, Plone Foundation\'\n+copyright = u\'2018, Plone Foundation\'\n \n # The version info for the project you\'re documenting, acts as replacement for\n # |version| and |release|, also used in various other places throughout the\ndiff --git a/setup.py b/setup.py\nindex 36c0bda..bba07d6 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -17,6 +17,7 @@\n     \'zope.interface\',\n     \'zope.publisher\',\n     \'zope.testrunner\',\n+    \'zope.testing\',\n     # XXX unspecified dependency of plone.app.upgrade XXX\n     # \'Products.ATContentTypes\',\n ]\n@@ -34,7 +35,7 @@ def read(*rnames):\n \n \n long_description = \\\n-    read(\'docs\', \'source\', \'README.rst\') + \\\n+    read(\'docs\', \'README.rst\') + \\\n     \'\\n\\n\' +\\\n     read(\'CHANGES.rst\')\n \ndiff --git a/src/plone.app.testing.egg-info/PKG-INFO b/src/plone.app.testing.egg-info/PKG-INFO\nnew file mode 100644\nindex 0000000..f5bce6b\n--- /dev/null\n+++ b/src/plone.app.testing.egg-info/PKG-INFO\n@@ -0,0 +1,1979 @@\n+Metadata-Version: 2.1\n+Name: plone.app.testing\n+Version: 6.0.0.dev0\n+Summary: Testing tools for Plone-the-application, based on plone.testing.\n+Home-page: https://pypi.python.org/pypi/plone.app.testing\n+Author: Plone Foundation\n+Author-email: plone-developers@lists.sourceforge.net\n+License: GPL version 2\n+Description: Introduction\n+        ============\n+        \n+        .. contents:: Table of contents\n+        \n+        ``plone.app.testing`` provides tools for writing integration and functional\n+        tests for code that runs on top of Plone. It is based on `plone.testing`_.\n+        If you are unfamiliar with ``plone.testing``, the concept of layers, or the\n+        `zope.testing`_ testrunner, please take a look at the the ``plone.testing``\n+        documentation. In fact, even if you are working exclusively with Plone, you\n+        are likely to want to use some of its features for unit testing.\n+        \n+        In short, ``plone.app.testing`` includes:\n+        \n+        * A set of layers that set up fixtures containing a Plone site, intended for\n+          writing integration and functional tests.\n+        * A collection of helper functions, some useful for writing your own layers\n+          and some applicable to tests themselves.\n+        * A convenient layer base class, extending ``plone.testing.Layer``, which\n+          makes it easier to write custom layers extending the Plone site fixture,\n+          with proper isolation and tear-down.\n+        * Cleanup hooks for ``zope.testing.cleanup`` to clean up global state found\n+          in a Plone installation. This is useful for unit testing.\n+        \n+        Compatibility\n+        -------------\n+        \n+        ``plone.app.testing`` 5.x works with Plone 5.\n+        ``plone.app.testing`` 4.x works with Plone 4 and Zope 2.12. It may work with\n+        newer versions. It will not work with earlier versions. Use\n+        ``plone.app.testing`` 3.x for Plone 3 and Zope 2.10.\n+        \n+        Installation and usage\n+        ======================\n+        \n+        To use ``plone.app.testing`` in your own package, you need to add it as a\n+        dependency. Most people prefer to keep test-only dependencies separate, so\n+        that they do not need to be installed in scenarios (such as on a production\n+        server) where the tests will not be run. This can be achieved using a\n+        ``test`` extra.\n+        \n+        In ``setup.py``, add or modify the ``extras_require`` option, like so::\n+        \n+            extras_require = {\n+                \'test\': [\n+                        \'plone.app.testing\',\n+                    ]\n+            },\n+        \n+        This will also include ``plone.testing``, with the ``[z2]``, ``[zca]`` and\n+        ``[zodb]`` extras (which ``plone.app.testing`` itself relies on).\n+        \n+        Please see the `plone.testing`_ documentation for more details about how to\n+        add a test runner to your buildout, and how to write and run tests.\n+        \n+        Layer reference\n+        ===============\n+        \n+        This package contains a layer class,\n+        ``plone.app.testing.layers.PloneFixture``, which sets up a Plone site fixture.\n+        It is combined with other layers from `plone.testing`_ to provide a number of\n+        layer instances. It is important to realise that these layers all have the\n+        same fundamental fixture: they just manage test setup and tear-down\n+        differently.\n+        \n+        When set up, the fixture will:\n+        \n+        * Create a ZODB sandbox, via a stacked ``DemoStorage``. This ensures\n+          persistent changes made during layer setup can be cleanly torn down.\n+        * Configure a global component registry sandbox. This ensures that global\n+          component registrations (e.g. as a result of loading ZCML configuration)\n+          can be cleanly torn down.\n+        * Create a configuration context with the ``disable-autoinclude`` feature\n+          set. This has the effect of stopping Plone from automatically loading the\n+          configuration of any installed package that uses the\n+          ``z3c.autoinclude.plugin:plone`` entry point via `z3c.autoinclude`_. (This\n+          is to avoid accidentally polluting the test fixture - custom layers should\n+          load packages\' ZCML configuration explicitly if required).\n+        * Install a number of Zope 2-style products on which Plone depends.\n+        * Load the ZCML for these products, and for ``Products.CMFPlone``, which in\n+          turn pulls in the configuration for the core of Plone.\n+        * Create a default Plone site, with the default theme enabled, but with no\n+          default content.\n+        * Add a user to the root user folder with the ``Manager`` role.\n+        * Add a test user to this instance with the ``Member`` role.\n+        \n+        For each test:\n+        \n+        * The test user is logged in\n+        * The local component site is set\n+        * Various global caches are cleaned up\n+        \n+        Various constants in the module ``plone.app.testing.interfaces`` are defined\n+        to describe this environment:\n+        \n+        +----------------------+--------------------------------------------------+\n+        | **Constant**         | **Purpose**                                      |\n+        +----------------------+--------------------------------------------------+\n+        | PLONE_SITE_ID        | The id of the Plone site object inside the Zope  |\n+        |                      | application root.                                |\n+        +----------------------+--------------------------------------------------+\n+        | PLONE_SITE_TITLE     | The title of the Plone site                      |\n+        +----------------------+--------------------------------------------------+\n+        | DEFAULT_LANGUAGE     | The default language of the Plone site (\'en\')    |\n+        +----------------------+--------------------------------------------------+\n+        | TEST_USER_ID         | The id of the test user                          |\n+        +----------------------+--------------------------------------------------+\n+        | TEST_USER_NAME       | The username of the test user                    |\n+        +----------------------+--------------------------------------------------+\n+        | TEST_USER_PASSWORD   | The password of the test user                    |\n+        +----------------------+--------------------------------------------------+\n+        | TEST_USER_ROLES      | The default global roles of the test user -      |\n+        |                      | (\'Member\',)                                      |\n+        +----------------------+--------------------------------------------------+\n+        | SITE_OWNER_NAME      | The username of the user owning the Plone site.  |\n+        +----------------------+--------------------------------------------------+\n+        | SITE_OWNER_PASSWORD  | The password of the user owning the Plone site.  |\n+        +----------------------+--------------------------------------------------+\n+        \n+        All the layers also expose a resource in addition to those from their\n+        base layers, made available during tests:\n+        \n+        ``portal``\n+           The Plone site root.\n+        \n+        Plone site fixture\n+        ------------------\n+        \n+        +------------+--------------------------------------------------+\n+        | Layer:     | ``plone.app.testing.PLONE_FIXTURE``              |\n+        +------------+--------------------------------------------------+\n+        | Class:     | ``plone.app.testing.layers.PloneFixture``        |\n+        +------------+--------------------------------------------------+\n+        | Bases:     | ``plone.testing.z2.STARTUP``                     |\n+        +------------+--------------------------------------------------+\n+        | Resources: |                                                  |\n+        +------------+--------------------------------------------------+\n+        \n+        This layer sets up the Plone site fixture on top of the ``z2.STARTUP``\n+        fixture.\n+        \n+        You should not use this layer directly, as it does not provide any test\n+        lifecycle or transaction management. Instead, you should use a layer\n+        created with either the ``IntegrationTesting`` or ``FunctionalTesting``\n+        classes, as outlined below.\n+        \n+        Mock MailHost\n+        -------------\n+        \n+        +------------+--------------------------------------------------+\n+        | Layer:     | ``plone.app.testing.MOCK_MAILHOST_FIXTURE``      |\n+        +------------+--------------------------------------------------+\n+        | Class:     | ``plone.app.testing.layers.MockMailHostLayer``   |\n+        +------------+--------------------------------------------------+\n+        | Bases:     | ``plone.app.testing.layers.PLONE_FIXTURE``       |\n+        +------------+--------------------------------------------------+\n+        | Resources: |                                                  |\n+        +------------+--------------------------------------------------+\n+        \n+        This layer builds on top of ``PLONE_FIXTURE`` to patch Plone\'s MailHost implementation.\n+        \n+        With it,\n+        any attempt to send an email will instead store each of them as a string in a list in ``portal.MailHost.messages``.\n+        \n+        You should not use this layer directly, as it does not provide any test\n+        lifecycle or transaction management. Instead, you should use a layer\n+        created with either the ``IntegrationTesting`` or ``FunctionalTesting``\n+        classes, like::\n+        \n+            from plone.app.testing import MOCK_MAILHOST_FIXTURE\n+        \n+            MY_INTEGRATION_TESTING = IntegrationTesting(\n+                bases=(\n+                    MY_FIXTURE,\n+                    MOCK_MAILHOST_FIXTURE,\n+                ),\n+                name="MyFixture:Integration"\n+            )\n+        \n+        \n+        PloneWithPackageLayer class\n+        ---------------------------\n+        \n+        Most add-ons do not need more setup than loading a ZCML file and\n+        running a GenericSetup profile.\n+        \n+        With this helper class, a fixture can easily be instantiated::\n+        \n+            from plone.app.testing import PloneWithPackageLayer\n+            import my.addon\n+        \n+            FIXTURE = PloneWithPackageLayer(\n+                zcml_package=my.addon,\n+                zcml_filename=\'configure.zcml\',\n+                gs_profile_id=\'my.addon:default\',\n+                name="MyAddonFixture"\n+            )\n+        \n+        PloneWithPackageLayer constructor takes two other keyword arguments:\n+        ``bases`` and ``additional_z2_products``.\n+        \n+        The ``bases`` argument takes a sequence of base layer fixtures.\n+        It is useful, among other reasons,\n+        to pass a fixture which makes other calls to plone.app.testing API.\n+        The need could arise in the development process.\n+        \n+        ``additional_z2_products`` argument takes a sequence of package names\n+        that need to be installed as Zope2 Products and are dependencies of the tested add-on.\n+        \n+        Integration and functional testing test lifecycles\n+        --------------------------------------------------\n+        \n+        ``plone.app.testing`` comes with two layer classes, ``IntegrationTesting``\n+        and ``FunctionalTesting``, which derive from the corresponding layer classes\n+        in ``plone.testing.z2``.\n+        \n+        These classes set up the ``app``, ``request`` and ``portal`` resources, and\n+        reset the fixture (including various global caches) between each test run.\n+        \n+        As with the classes in ``plone.testing``, the ``IntegrationTesting`` class\n+        will create a new transaction for each test and roll it back on test tear-\n+        down, which is efficient for integration testing, whilst ``FunctionalTesting``\n+        will create a stacked ``DemoStorage`` for each test and pop it on test tear-\n+        down, making it possible to exercise code that performs an explicit commit\n+        (e.g. via tests that use ``zope.testbrowser``).\n+        \n+        When creating a custom fixture, the usual pattern is to create a new layer\n+        class that has ``PLONE_FIXTURE`` as its default base, instantiating that as a\n+        separate "fixture" layer. This layer is not to be used in tests directly,\n+        since it won\'t have test/transaction lifecycle management, but represents a\n+        shared fixture, potentially for both functional and integration testing. It\n+        is also the point of extension for other layers that follow the same pattern.\n+        \n+        Once this fixture has been defined, "end-user" layers can be defined using\n+        the ``IntegrationTesting`` and ``FunctionalTesting`` classes. For example::\n+        \n+            from plone.testing import Layer\n+            from plone.app.testing import PLONE_FIXTURE\n+            from plone.app.testing import IntegrationTesting, FunctionalTesting\n+        \n+            class MyFixture(Layer):\n+                defaultBases = (PLONE_FIXTURE,)\n+        \n+                ...\n+        \n+            MY_FIXTURE = MyFixture()\n+        \n+            MY_INTEGRATION_TESTING = IntegrationTesting(bases=(MY_FIXTURE,), name="MyFixture:Integration")\n+            MY_FUNCTIONAL_TESTING = FunctionalTesting(bases=(MY_FIXTURE,), name="MyFixture:Functional")\n+        \n+        See the ``PloneSandboxLayer`` layer below for a more comprehensive example.\n+        \n+        Plone integration testing\n+        -------------------------\n+        \n+        +------------+--------------------------------------------------+\n+        | Layer:     | ``plone.app.testing.PLONE_INTEGRATION_TESTING``  |\n+        +------------+--------------------------------------------------+\n+        | Class:     | ``plone.app.testing.layers.IntegrationTesting``  |\n+        +------------+--------------------------------------------------+\n+        | Bases:     | ``plone.app.testing.PLONE_FIXTURE``              |\n+        +------------+--------------------------------------------------+\n+        | Resources: | ``portal`` (test setup only)                     |\n+        +------------+--------------------------------------------------+\n+        \n+        This layer can be used for integration testing against the basic\n+        ``PLONE_FIXTURE`` layer.\n+        \n+        You can use this directly in your tests if you do not need to set up any\n+        other shared fixture.\n+        \n+        However, you would normally not extend this layer - see above.\n+        \n+        \n+        Plone functional testing\n+        ------------------------\n+        \n+        +------------+--------------------------------------------------+\n+        | Layer:     | ``plone.app.testing.PLONE_FUNCTIONAL_TESTING``   |\n+        +------------+--------------------------------------------------+\n+        | Class:     | ``plone.app.testing.layers.FunctionalTesting``   |\n+        +------------+--------------------------------------------------+\n+        | Bases:     | ``plone.app.testing.PLONE_FIXTURE``              |\n+        +------------+--------------------------------------------------+\n+        | Resources: | ``portal`` (test setup only)                     |\n+        +------------+--------------------------------------------------+\n+        \n+        This layer can be used for functional testing against the basic\n+        ``PLONE_FIXTURE`` layer, for example using ``zope.testbrowser``.\n+        \n+        You can use this directly in your tests if you do not need to set up any\n+        other shared fixture.\n+        \n+        Again, you would normally not extend this layer - see above.\n+        \n+        Plone ZServer\n+        -------------\n+        \n+        +------------+--------------------------------------------------+\n+        | Layer:     | ``plone.app.testing.PLONE_ZSERVER``              |\n+        +------------+--------------------------------------------------+\n+        | Class:     | ``plone.testing.z2.ZServer``                     |\n+        +------------+--------------------------------------------------+\n+        | Bases:     | ``plone.app.testing.PLONE_FUNCTIONAL_TESTING``   |\n+        +------------+--------------------------------------------------+\n+        | Resources: | ``portal`` (test setup only)                     |\n+        +------------+--------------------------------------------------+\n+        \n+        This is layer is intended for functional testing using a live, running HTTP\n+        server, e.g. using Selenium or Windmill.\n+        \n+        Again, you would not normally extend this layer. To create a custom layer\n+        that has a running ZServer, you can use the same pattern as this one, e.g.::\n+        \n+            from plone.testing import Layer\n+            from plone.testing import z2\n+            from plone.app.testing import PLONE_FIXTURE\n+            from plone.app.testing import FunctionalTesting\n+        \n+            class MyFixture(Layer):\n+                defaultBases = (PLONE_FIXTURE,)\n+        \n+                ...\n+        \n+            MY_FIXTURE = MyFixture()\n+            MY_ZSERVER = FunctionalTesting(bases=(MY_FIXTURE, z2.ZSERVER_FIXTURE), name=\'MyFixture:ZServer\')\n+        \n+        See the description of the ``z2.ZSERVER`` layer in `plone.testing`_\n+        for further details.\n+        \n+        Plone FTP server\n+        ----------------\n+        \n+        +------------+--------------------------------------------------+\n+        | Layer:     | ``plone.app.testing.PLONE_FTP_SERVER``           |\n+        +------------+--------------------------------------------------+\n+        | Class:     | ``plone.app.testing.layers.FunctionalTesting``   |\n+        +------------+--------------------------------------------------+\n+        | Bases:     | ``plone.app.testing.PLONE_FIXTURE``              |\n+        |            | ``plone.testing.z2.ZSERVER_FIXTURE``             |\n+        +------------+--------------------------------------------------+\n+        | Resources: | ``portal`` (test setup only)                     |\n+        +------------+--------------------------------------------------+\n+        \n+        This is layer is intended for functional testing using a live FTP server.\n+        \n+        It is semantically equivalent to the ``PLONE_ZSERVER`` layer.\n+        \n+        See the description of the ``z2.FTP_SERVER`` layer in `plone.testing`_\n+        for further details.\n+        \n+        Helper functions\n+        ================\n+        \n+        A number of helper functions are provided for use in tests and custom layers.\n+        \n+        Plone site context manager\n+        --------------------------\n+        \n+        ``ploneSite(db=None, connection=None, environ=None)``\n+            Use this context manager to access and make changes to the Plone site\n+            during layer setup. In most cases, you will use it without arguments,\n+            but if you have special needs, you can tie it to a particular database\n+            instance. See the description of the ``zopeApp()`` context manager in\n+            `plone.testing`_ (which this context manager uses internally) for details.\n+        \n+            The usual pattern is to call it during ``setUp()`` or ``tearDown()`` in\n+            your own layers::\n+        \n+                from plone.testing import Layer\n+                from plone.app.testing import ploneSite\n+        \n+                class MyLayer(Layer):\n+        \n+                    def setUp(self):\n+        \n+                        ...\n+        \n+                        with ploneSite() as portal:\n+        \n+                            # perform operations on the portal, e.g.\n+                            portal.title = u"New title"\n+        \n+            Here, ``portal`` is the Plone site root. A transaction is begun before\n+            entering the ``with`` block, and will be committed upon exiting the block,\n+            unless an exception is raised, in which case it will be rolled back.\n+        \n+            Inside the block, the local component site is set to the Plone site root,\n+            so that local component lookups should work.\n+        \n+            **Warning:** Do not attempt to load ZCML files inside a ``ploneSite``\n+            block. Because the local site is set to the Plone site, you may end up\n+            accidentally registering components in the local site manager, which can\n+            cause pickling errors later.\n+        \n+            **Note:** You should not use this in a test, or in a ``testSetUp()`` or\n+            ``testTearDown()`` method of a layer based on one of the layer in this\n+            package. Use the ``portal`` resource instead.\n+        \n+            **Also note:** If you are writing a layer setting up a Plone site fixture,\n+            you may want to use the ``PloneSandboxLayer`` layer base class, and\n+            implement the ``setUpZope()``, ``setUpPloneSite()``, ``tearDownZope()``\n+            and/or ``tearDownPloneSite()`` methods instead. See below.\n+        \n+        User management\n+        ---------------\n+        \n+        ``login(portal, userName)``\n+            Simulate login as the given user. This is based on the ``z2.login()``\n+            helper in `plone.testing`_, but instead of passing a specific user folder,\n+            you pass the portal (e.g. as obtained via the ``portal`` layer resource).\n+        \n+            For example::\n+        \n+                import unittest2 as unittest\n+        \n+                from plone.app.testing import PLONE_INTEGRATION_TESTING\n+                from plone.app.testing import TEST_USER_NAME\n+                from plone.app.testing import login\n+        \n+                ...\n+        \n+                class MyTest(unittest.TestCase):\n+        \n+                    layer = PLONE_INTEGRATION_TESTING\n+        \n+                    def test_something(self):\n+                        portal = self.layer[\'portal\']\n+                        login(portal, TEST_USER_NAME)\n+        \n+                        ...\n+        \n+        ``logout()``\n+            Simulate logging out, i.e. becoming the anonymous user. This is equivalent\n+            to the ``z2.logout()`` helper in `plone.testing`_.\n+        \n+            For example::\n+        \n+                import unittest2 as unittest\n+        \n+                from plone.app.testing import PLONE_INTEGRATION_TESTING\n+                from plone.app.testing import logout\n+        \n+                ...\n+        \n+                class MyTest(unittest.TestCase):\n+        \n+                    layer = PLONE_INTEGRATION_TESTING\n+        \n+                    def test_something(self):\n+                        portal = self.layer[\'portal\']\n+                        logout()\n+        \n+                        ...\n+        \n+        ``setRoles(portal, userId, roles)``\n+            Set the roles for the given user. ``roles`` is a list of roles.\n+        \n+            For example::\n+        \n+                import unittest2 as unittest\n+        \n+                from plone.app.testing import PLONE_INTEGRATION_TESTING\n+                from plone.app.testing import TEST_USER_ID\n+                from plone.app.testing import setRoles\n+        \n+                ...\n+        \n+                class MyTest(unittest.TestCase):\n+        \n+                    layer = PLONE_INTEGRATION_TESTING\n+        \n+                    def test_something(self):\n+                        portal = self.layer[\'portal\']\n+                        setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+        \n+        Product and profile installation\n+        --------------------------------\n+        \n+        ``applyProfile(portal, profileName, blacklisted_steps=None)``\n+            Install a GenericSetup profile (usually an extension profile) by name,\n+            using the ``portal_setup`` tool. The name is normally made up of a package\n+            name and a profile name. Do not use the ``profile-`` prefix.\n+        \n+            For example::\n+        \n+                from plone.testing import Layer\n+        \n+                from plone.app.testing import ploneSite\n+                from plone.app.testing import applyProfile\n+        \n+                ...\n+        \n+                class MyLayer(Layer):\n+        \n+                    ...\n+        \n+                    def setUp(self):\n+        \n+                        ...\n+        \n+                        with ploneSite() as portal:\n+                            applyProfile(portal, \'my.product:default\')\n+        \n+                            ...\n+        \n+        ``quickInstallProduct(portal, productName, reinstall=False)``\n+            Use this function to install a particular product into the given Plone\n+            site, using the ``portal_quickinstaller`` tool. If ``reinstall`` is\n+            ``False`` and the product is already installed, nothing will happen; if\n+            ``reinstall`` is ``True``, the product will be reinstalled. The\n+            ``productName`` should be a full dotted name, e.g. ``Products.MyProduct``,\n+            or ``my.product``.\n+        \n+            For example::\n+        \n+                from plone.testing import Layer\n+        \n+                from plone.app.testing import ploneSite\n+                from plone.app.testing import quickInstallProduct\n+        \n+                ...\n+        \n+                class MyLayer(Layer):\n+        \n+                    ...\n+        \n+                    def setUp(self):\n+        \n+                        ...\n+        \n+                        with ploneSite() as portal:\n+                            quickInstallProduct(portal, \'my.product\')\n+        \n+                            ...\n+        \n+        Component architecture sandboxing\n+        ---------------------------------\n+        \n+        ``pushGlobalRegistry(portal, new=None, name=None)``\n+            Create or obtain a stack of global component registries, and push a new\n+            registry to the top of the stack. This allows Zope Component Architecture\n+            registrations (e.g. loaded via ZCML) to be effectively torn down.\n+        \n+            If you are going to use this function, please read the corresponding\n+            documentation for ``zca.pushGlobalRegistry()`` in `plone.testing`_. In\n+            particular, note that you *must* reciprocally call ``popGlobalRegistry()``\n+            (see below).\n+        \n+            This helper is based on ``zca.pushGlobalRegistry()``, but will also fix\n+            up the local component registry in the Plone site ``portal`` so that it\n+            has the correct bases.\n+        \n+            For example::\n+        \n+                from plone.testing import Layer\n+        \n+                from plone.app.testing import ploneSite\n+                from plone.app.testing import pushGlobalRegistry\n+                from plone.app.testing import popGlobalRegistry\n+        \n+                ...\n+        \n+                class MyLayer(Layer):\n+        \n+                    ...\n+        \n+                    def setUp(self):\n+        \n+                        ...\n+        \n+                        with ploneSite() as portal:\n+                            pushGlobalRegistry(portal)\n+        \n+                            ...\n+        \n+        ``popGlobalRegistry(portal)``\n+            Tear down the top of the component architecture stack, as created with\n+            ``pushGlobalRegistry()``\n+        \n+            For example::\n+        \n+                ...\n+        \n+                    def tearDown(self):\n+        \n+                        with ploneSite() as portal:\n+                            popGlobalRegistry(portal)\n+        \n+        Global state cleanup\n+        --------------------\n+        \n+        ``tearDownMultiPluginRegistration(pluginName)``\n+            PluggableAuthService "MultiPlugins" are kept in a global registry. If\n+            you have registered a plugin, e.g. using the ``registerMultiPlugin()``\n+            API, you should tear that registration down in your layer\'s ``tearDown()``\n+            method. You can use this helper, passing a plugin name.\n+        \n+            For example::\n+        \n+                from plone.testing import Layer\n+        \n+                from plone.app.testing import ploneSite\n+                from plone.app.testing import tearDownMultiPluginRegistration\n+        \n+                ...\n+        \n+                class MyLayer(Layer):\n+        \n+                    ...\n+        \n+                    def tearDown(self):\n+        \n+                        tearDownMultiPluginRegistration(\'MyPlugin\')\n+        \n+                        ...\n+        \n+        Layer base class\n+        ================\n+        \n+        If you are writing a custom layer to test your own Plone add-on product, you\n+        will often want to do the following on setup:\n+        \n+        1. Stack a new ``DemoStorage`` on top of the one from the base layer. This\n+           ensures that any persistent changes performed during layer setup can be\n+           torn down completely, simply by popping the demo storage.\n+        \n+        2. Stack a new ZCML configuration context. This keeps separate the information\n+           about which ZCML files were loaded, in case other, independent layers want\n+           to load those same files after this layer has been torn down.\n+        \n+        3. Push a new global component registry. This allows you to register\n+           components (e.g. by loading ZCML or using the test API from\n+           ``zope.component``) and tear down those registration easily by popping the\n+           component registry.\n+        \n+        4. Load your product\'s ZCML configuration\n+        \n+        5. Install the product into the test fixture Plone site\n+        \n+        Of course, you may wish to make other changes too, such as creating some base\n+        content or changing some settings.\n+        \n+        On tear-down, you will then want to:\n+        \n+        1. Remove any Pluggable Authentication Service "multi-plugins" that were added\n+           to the global registry during setup.\n+        \n+        2. Pop the global component registry to unregister components loaded via ZCML.\n+        \n+        3. Pop the configuration context resource to restore its state.\n+        \n+        4. Pop the ``DemoStorage`` to undo any persistent changes.\n+        \n+        If you have made other changes on setup that are not covered by this broad\n+        tear-down, you\'ll also want to tear those down explicitly here.\n+        \n+        Stacking a demo storage and component registry is the safest way to avoid\n+        fixtures bleeding between tests. However, it can be tricky to ensure that\n+        everything happens in the right order.\n+        \n+        To make things easier, you can use the ``PloneSandboxLayer`` layer base class.\n+        This extends ``plone.testing.Layer`` and implements ``setUp()`` and\n+        ``tearDown()`` for you. You simply have to override one or more of the\n+        following methods:\n+        \n+        ``setUpZope(self, app, configurationContext)``\n+            This is called during setup. ``app`` is the Zope application root.\n+            ``configurationContext`` is a newly stacked ZCML configuration context.\n+            Use this to load ZCML, install products using the helper\n+            ``plone.testing.z2.installProduct()``, or manipulate other global state.\n+        \n+        ``setUpPloneSite(self, portal)``\n+            This is called during setup. ``portal`` is the Plone site root as\n+            configured by the ``ploneSite()`` context manager. Use this to make\n+            persistent changes inside the Plone site, such as installing products\n+            using the ``applyProfile()`` or ``quickInstallProduct()`` helpers, or\n+            setting up default content.\n+        \n+        ``tearDownZope(self, app)``\n+            This is called during tear-down, before the global component registry and\n+            stacked ``DemoStorage`` are popped. Use this to tear down any additional\n+            global state.\n+        \n+            **Note:** Global component registrations PAS multi-plugin registrations are\n+            automatically torn down. Product installations are not, so you should use\n+            the ``uninstallProduct()`` helper if any products were installed during\n+            ``setUpZope()``.\n+        \n+        ``tearDownPloneSite(self, portal)``\n+            This is called during tear-down, before the global component registry and\n+            stacked ``DemoStorage`` are popped. During this method, the local\n+            component site hook is set, giving you access to local components.\n+        \n+            **Note:** Persistent changes to the ZODB are automatically torn down by\n+            virtue of a stacked ``DemoStorage``. Thus, this method is less commonly\n+            used than the others described here.\n+        \n+        Let\'s show a more comprehensive example of what such a layer may look like.\n+        Imagine we have a product ``my.product``. It has a ``configure.zcml`` file\n+        that loads some components and registers a ``GenericSetup`` profile, making it\n+        installable in the Plone site. On layer setup, we want to load the product\'s\n+        configuration and install it into the Plone site.\n+        \n+        The layer would conventionally live in a module ``testing.py`` at the root of\n+        the package, i.e. ``my.product.testing``::\n+        \n+            from plone.app.testing import PloneSandboxLayer\n+            from plone.app.testing import PLONE_FIXTURE\n+            from plone.app.testing import IntegrationTesting\n+        \n+            from plone.testing import z2\n+        \n+            class MyProduct(PloneSandboxLayer):\n+        \n+                defaultBases = (PLONE_FIXTURE,)\n+        \n+                def setUpZope(self, app, configurationContext):\n+                    # Load ZCML\n+                    import my.product\n+                    self.loadZCML(package=my.product)\n+        \n+                    # Install product and call its initialize() function\n+                    z2.installProduct(app, \'my.product\')\n+        \n+                    # Note: you can skip this if my.product is not a Zope 2-style\n+                    # product, i.e. it is not in the Products.* namespace and it\n+                    # does not have a <five:registerPackage /> directive in its\n+                    # configure.zcml.\n+        \n+                def setUpPloneSite(self, portal):\n+                    # Install into Plone site using portal_setup\n+                    self.applyProfile(portal, \'my.product:default\')\n+        \n+                def tearDownZope(self, app):\n+                    # Uninstall product\n+                    z2.uninstallProduct(app, \'my.product\')\n+        \n+                    # Note: Again, you can skip this if my.product is not a Zope 2-\n+                    # style product\n+        \n+            MY_PRODUCT_FIXTURE = MyProduct()\n+            MY_PRODUCT_INTEGRATION_TESTING = IntegrationTesting(bases=(MY_PRODUCT_FIXTURE,), name="MyProduct:Integration")\n+        \n+        Here, ``MY_PRODUCT_FIXTURE`` is the "fixture" base layer. Other layers can\n+        use this as a base if they want to build on this fixture, but it would not\n+        be used in tests directly. For that, we have created an ``IntegrationTesting``\n+        instance, ``MY_PRODUCT_INTEGRATION_TESTING``.\n+        \n+        Of course, we could have created a ``FunctionalTesting`` instance as\n+        well, e.g.::\n+        \n+            MY_PRODUCT_FUNCTIONAL_TESTING = FunctionalTesting(bases=(MY_PRODUCT_FIXTURE,), name="MyProduct:Functional")\n+        \n+        Of course, we could do a lot more in the layer setup. For example, let\'s say\n+        the product had a content type \'my.product.page\' and we wanted to create some\n+        test content. We could do that with::\n+        \n+            from plone.app.testing import TEST_USER_ID\n+            from plone.app.testing import TEST_USER_NAME\n+            from plone.app.testing import login\n+            from plone.app.testing import setRoles\n+        \n+            ...\n+        \n+                def setUpPloneSite(self, portal):\n+        \n+                    ...\n+        \n+                    setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+                    login(portal, TEST_USER_NAME)\n+                    portal.invokeFactory(\'my.product.page\', \'page-1\', title=u"Page 1")\n+                    setRoles(portal, TEST_USER_ID, [\'Member\'])\n+        \n+            ...\n+        \n+        Note that unlike in a test, there is no user logged in at layer setup time,\n+        so we have to explicitly log in as the test user. Here, we also grant the test\n+        user the ``Manager`` role temporarily, to allow object construction (which\n+        performs an explicit permission check).\n+        \n+            **Note:** Automatic tear down suffices for all the test setup above. If\n+            the only changes made during layer setup are to persistent, in-ZODB data,\n+            or the global component registry then no additional tear-down is required.\n+            For any other global state being managed, you should write a\n+            ``tearDownPloneSite()`` method to perform the necessary cleanup.\n+        \n+        Given this layer, we could write a test (e.g. in ``tests.py``) like::\n+        \n+            import unittest2 as unittest\n+            from my.product.testing import MY_PRODUCT_INTEGRATION_TESTING\n+        \n+            class IntegrationTest(unittest.TestCase):\n+        \n+                layer = MY_PRODUCT_INTEGRATION_TESTING\n+        \n+                def test_page_dublin_core_title(self):\n+                    portal = self.layer[\'portal\']\n+        \n+                    page1 = portal[\'page-1\']\n+                    page1.title = u"Some title"\n+        \n+                    self.assertEqual(page1.Title(), u"Some title")\n+        \n+        Please see `plone.testing`_ for more information about how to write and run\n+        tests and assertions.\n+        \n+        Common test patterns\n+        ====================\n+        \n+        `plone.testing`_\'s documentation contains details about the fundamental\n+        techniques for writing tests of various kinds. In a Plone context, however,\n+        some patterns tend to crop up time and again. Below, we will attempt to\n+        catalogue some of the more commonly used patterns via short code samples.\n+        \n+        The examples in this section are all intended to be used in tests. Some may\n+        also be useful in layer set-up/tear-down. We have used ``unittest`` syntax\n+        here, although most of these examples could equally be adopted to doctests.\n+        \n+        We will assume that you are using a layer that has ``PLONE_FIXTURE`` as a base\n+        (whether directly or indirectly) and uses the ``IntegrationTesting`` or\n+        ``FunctionalTesting`` classes as shown above.\n+        \n+        We will also assume that the variables ``app``, ``portal`` and ``request`` are\n+        defined from the relative layer resources, e.g. with::\n+        \n+            app = self.layer[\'app\']\n+            portal = self.layer[\'portal\']\n+            request = self.layer[\'request\']\n+        \n+        Note that in a doctest set up using the ``layered()`` function from\n+        ``plone.testing``, ``layer`` is in the global namespace, so you would do e.g.\n+        ``portal = layer[\'portal\']``.\n+        \n+        Where imports are required, they are shown alongside the code example. If\n+        a given import or variable is used more than once in the same section, it\n+        will only be shown once.\n+        \n+        Basic content management\n+        ------------------------\n+        \n+        To create a content item of type \'Folder\' with the id \'f1\' in the root of\n+        the portal::\n+        \n+            portal.invokeFactory(\'Folder\', \'f1\', title=u"Folder 1")\n+        \n+        The ``title`` argument is optional. Other basic properties, like\n+        ``description``, can be set as well.\n+        \n+        Note that this may fail with an ``Unauthorized`` exception, since the test\n+        user won\'t normally have permissions to add content in the portal root, and\n+        the ``invokeFactory()`` method performs an explicit security check. You can\n+        set the roles of the test user to ensure that he has the necessary\n+        permissions::\n+        \n+            from plone.app.testing import setRoles\n+            from plone.app.testing import TEST_USER_ID\n+        \n+            setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+            portal.invokeFactory(\'Folder\', \'f1\', title=u"Folder 1")\n+        \n+        To obtain this object, acquisition-wrapped in its parent::\n+        \n+            f1 = portal[\'f1\']\n+        \n+        To make an assertion against an attribute or method of this object::\n+        \n+            self.assertEqual(f1.Title(), u"Folder 1")\n+        \n+        To modify the object::\n+        \n+            f1.setTitle(u"Some title")\n+        \n+        To add another item inside the folder f1::\n+        \n+            f1.invokeFactory(\'Document\', \'d1\', title=u"Document 1")\n+            d1 = f1[\'d1\']\n+        \n+        To check if an object is in a container::\n+        \n+            self.assertTrue(\'f1\' in portal)\n+        \n+        To delete an object from a container:\n+        \n+            del portal[\'f1\']\n+        \n+        There is no content or workflows installed by default. You can enable workflows::\n+        \n+            portal.portal_workflow.setDefaultChain("simple_publication_workflow")\n+        \n+        Searching\n+        ---------\n+        \n+        To obtain the ``portal_catalog`` tool::\n+        \n+            from Products.CMFCore.utils import getToolByName\n+        \n+            catalog = getToolByName(portal, \'portal_catalog\')\n+        \n+        To search the catalog::\n+        \n+            results = catalog(portal_type="Document")\n+        \n+        Keyword arguments are search parameters. The result is a lazy list. You can\n+        call ``len()`` on it to get the number of search results, or iterate through\n+        it. The items in the list are catalog brains. They have attributes that\n+        correspond to the "metadata" columns configured for the catalog, e.g.\n+        ``Title``, ``Description``, etc. Note that these are simple attributes (not\n+        methods), and contain the value of the corresponding attribute or method from\n+        the source object at the time the object was cataloged (i.e. they are not\n+        necessarily up to date).\n+        \n+        To make assertions against the search results::\n+        \n+            self.assertEqual(len(results), 1)\n+        \n+            # Copy the list into memory so that we can use [] notation\n+            results = list(results)\n+        \n+            # Check the first (and in this case only) result in the list\n+            self.assertEqual(results[0].Title, u"Document 1")\n+        \n+        To get the path of a given item in the search results::\n+        \n+            self.assertEqual(resuls[0].getPath(), portal.absolute_url_path() + \'/f1/d1\')\n+        \n+        To get an absolute URL::\n+        \n+            self.assertEqual(resuls[0].getURL(), portal.absolute_url() + \'/f1/d1\')\n+        \n+        To get the original object::\n+        \n+            obj = results[0].getObject()\n+        \n+        To re-index an object d1 so that its catalog information is up to date::\n+        \n+            d1.reindexObject()\n+        \n+        User management\n+        ---------------\n+        \n+        To create a new user::\n+        \n+            from Products.CMFCore.utils import getToolByName\n+        \n+            acl_users = getToolByName(portal, \'acl_users\')\n+        \n+            acl_users.userFolderAddUser(\'user1\', \'secret\', [\'Member\'], [])\n+        \n+        The arguments are the username (which will also be the user id), the password,\n+        a list of roles, and a list of domains (rarely used).\n+        \n+        To make a particular user active ("logged in") in the integration testing\n+        environment use the ``login`` method and pass it the username::\n+        \n+            from plone.app.testing import login\n+        \n+            login(portal, \'user1\')\n+        \n+        To log out (become anonymous)::\n+        \n+            from plone.app.testing import logout\n+        \n+            logout()\n+        \n+        To obtain the current user::\n+        \n+            from AccessControl import getSecurityManager\n+        \n+            user = getSecurityManager().getUser()\n+        \n+        To obtain a user by name::\n+        \n+            user = acl_users.getUser(\'user1\')\n+        \n+        Or by user id (id and username are often the same, but can differ in real-world\n+        scenarios)::\n+        \n+            user = acl_users.getUserById(\'user1\')\n+        \n+        To get the user\'s user name::\n+        \n+            userName = user.getUserName()\n+        \n+        To get the user\'s id::\n+        \n+            userId = user.getId()\n+        \n+        Permissions and roles\n+        ---------------------\n+        \n+        To get a user\'s roles in a particular context (taking local roles into\n+        account)::\n+        \n+            from AccessControl import getSecurityManager\n+        \n+            user = getSecurityManager().getUser()\n+        \n+            self.assertEqual(user.getRolesInContext(portal), [\'Member\'])\n+        \n+        To change the test user\'s roles::\n+        \n+            from plone.app.testing import setRoles\n+            from plone.app.testing import TEST_USER_ID\n+        \n+            setRoles(portal, TEST_USER_ID, [\'Member\', \'Manager\'])\n+        \n+        Pass a different user name to change the roles of another user.\n+        \n+        To grant local roles to a user in the folder f1::\n+        \n+            f1.manage_setLocalRoles(TEST_USER_ID, (\'Reviewer\',))\n+        \n+        To check the local roles of a given user in the folder \'f1\'::\n+        \n+            self.assertEqual(f1.get_local_roles_for_userid(TEST_USER_ID), (\'Reviewer\',))\n+        \n+        To grant the \'View\' permission to the roles \'Member\' and \'Manager\' in the\n+        portal root without acquiring additional roles from its parents::\n+        \n+            portal.manage_permission(\'View\', [\'Member\', \'Manager\'], acquire=False)\n+        \n+        This method can also be invoked on a folder or individual content item.\n+        \n+        To assert which roles have the permission \'View\' in the context of the\n+        portal::\n+        \n+            roles = [r[\'name\'] for r in portal.rolesOfPermission(\'View\') if r[\'selected\']]\n+            self.assertEqual(roles, [\'Member\', \'Manager\'])\n+        \n+        To assert which permissions have been granted to the \'Reviewer\' role in the\n+        context of the portal::\n+        \n+            permissions = [p[\'name\'] for p in portal.permissionsOfRole(\'Reviewer\') if p[\'selected\']]\n+            self.assertTrue(\'Review portal content\' in permissions)\n+        \n+        To add a new role::\n+        \n+            portal._addRole(\'Tester\')\n+        \n+        This can now be assigned to users globally (using the ``setRoles`` helper)\n+        or locally (using ``manage_setLocalRoles()``).\n+        \n+        To assert which roles are available in a given context::\n+        \n+            self.assertTrue(\'Tester\' in portal.valid_roles())\n+        \n+        Workflow\n+        --------\n+        \n+        To set the default workflow chain::\n+        \n+            from Products.CMFCore.utils import getToolByName\n+        \n+            workflowTool = getToolByName(portal, \'portal_workflow\')\n+        \n+            workflowTool.setDefaultChain(\'my_workflow\')\n+        \n+        In Plone, most chains contain only one workflow, but the ``portal_workflow``\n+        tool supports longer chains, where an item is subject to more than one\n+        workflow simultaneously.\n+        \n+        To set a multi-workflow chain, separate workflow names by commas.\n+        \n+        To get the default workflow chain::\n+        \n+            self.assertEqual(workflowTool.getDefaultChain(), (\'my_workflow\',))\n+        \n+        To set the workflow chain for the \'Document\' type::\n+        \n+            workflowTool.setChainForPortalTypes((\'Document\',), \'my_workflow\')\n+        \n+        You can pass multiple type names to set multiple chains at once. To set a\n+        multi-workflow chain, separate workflow names by commas. To indicate that a\n+        type should use the default workflow, use the special chain name \'(Default)\'.\n+        \n+        To get the workflow chain for the portal type \'Document\'::\n+        \n+            chains = dict(workflowTool.listChainOverrides())\n+            defaultChain = workflowTool.getDefaultChain()\n+            documentChain = chains.get(\'Document\', defaultChain)\n+        \n+            self.assertEqual(documentChain, (\'my_other_workflow\',))\n+        \n+        To get the current workflow chain for the content object f1::\n+        \n+            self.assertEqual(workflowTool.getChainFor(f1), (\'my_workflow\',))\n+        \n+        To update all permissions after changing the workflow::\n+        \n+            workflowTool.updateRoleMappings()\n+        \n+        To change the workflow state of the content object f1 by invoking the\n+        transaction \'publish\'::\n+        \n+            workflowTool.doActionFor(f1, \'publish\')\n+        \n+        Note that this performs an explicit permission check, so if the current user\n+        doesn\'t have permission to perform this workflow action, you may get an error\n+        indicating the action is not available. If so, use ``login()`` or\n+        ``setRoles()`` to ensure the current user is able to change the workflow\n+        state.\n+        \n+        To check the current workflow state of the content object f1::\n+        \n+            self.assertEqual(workflowTool.getInfoFor(f1, \'review_state\'), \'published\')\n+        \n+        Properties\n+        ----------\n+        \n+        To set the value of a property on the portal root::\n+        \n+            portal._setPropValue(\'title\', u"My title")\n+        \n+        To assert the value of a property on the portal root::\n+        \n+            self.assertEqual(portal.getProperty(\'title\'), u"My title")\n+        \n+        To change the value of a property in a property sheet in the\n+        ``portal_properties`` tool::\n+        \n+            from Products.CMFCore.utils import getToolByName\n+        \n+            propertiesTool = getToolByName(portal, \'portal_properties\')\n+            siteProperties = propertiesTool[\'site_properties\']\n+        \n+            siteProperties._setPropValue(\'many_users\', True)\n+        \n+        To assert the value of a property in a property sheet in the\n+        ``portal_properties`` tool::\n+        \n+            self.assertEqual(siteProperties.getProperty(\'many_users\'), True)\n+        \n+        Installing products and extension profiles\n+        ------------------------------------------\n+        \n+        To apply a particular extension profile::\n+        \n+            from plone.app.testing import applyProfile\n+        \n+            applyProfile(portal, \'my.product:default\')\n+        \n+        This is the preferred method of installing a product\'s configuration.\n+        \n+        To install an add-on product into the Plone site using the\n+        ``portal_quickinstaller`` tool::\n+        \n+            from plone.app.testing import quickInstallProduct\n+        \n+            quickInstallProduct(portal, \'my.product\')\n+        \n+        To re-install a product using the quick-installer::\n+        \n+            quickInstallProduct(portal, \'my.product\', reinstall=True)\n+        \n+        Note that both of these assume the product\'s ZCML has been loaded, which is\n+        usually done during layer setup. See the layer examples above for more details\n+        on how to do that.\n+        \n+        When writing a product that has an installation extension profile, it is often\n+        desirable to write tests that inspect the state of the site after the profile\n+        has been applied. Some of the more common such tests are shown below.\n+        \n+        To verify that a product has been installed (e.g. as a dependency via\n+        ``metadata.xml``)::\n+        \n+            from Products.CMFCore.utils import getToolByName\n+        \n+            quickinstaller = getToolByName(portal, \'portal_quickinstaller\')\n+            self.assertTrue(quickinstaller.isProductInstalled(\'my.product\'))\n+        \n+        To verify that a particular content type has been installed (e.g. via\n+        ``types.xml``)::\n+        \n+            typesTool = getToolByName(portal, \'portal_types\')\n+        \n+            self.assertNotEqual(typesTool.getTypeInfo(\'mytype\'), None)\n+        \n+        To verify that a new catalog index has been installed (e.g. via\n+        ``catalog.xml``)::\n+        \n+            catalog = getToolByName(portal, \'portal_catalog\')\n+        \n+            self.assertTrue(\'myindex\' in catalog.indexes())\n+        \n+        To verify that a new catalog metadata column has been added (e.g. via\n+        ``catalog.xml``)::\n+        \n+            self.assertTrue(\'myattr\' in catalog.schema())\n+        \n+        To verify that a new workflow has been installed (e.g. via\n+        ``workflows.xml``)::\n+        \n+            workflowTool = getToolByName(portal, \'portal_workflow\')\n+        \n+            self.assertNotEqual(workflowTool.getWorkflowById(\'my_workflow\'), None)\n+        \n+        To verify that a new workflow has been assigned to a type (e.g. via\n+        ``workflows.xml``)::\n+        \n+            self.assertEqual(dict(workflowTool.listChainOverrides())[\'mytype\'], (\'my_workflow\',))\n+        \n+        To verify that a new workflow has been set as the default (e.g. via\n+        ``workflows.xml``)::\n+        \n+            self.assertEqual(workflowTool.getDefaultChain(), (\'my_workflow\',))\n+        \n+        To test the value of a property in the ``portal_properties`` tool (e.g. set\n+        via ``propertiestool.xml``):::\n+        \n+            propertiesTool = getToolByName(portal, \'portal_properties\')\n+            siteProperties = propertiesTool[\'site_properties\']\n+        \n+            self.assertEqual(siteProperties.getProperty(\'some_property\'), "some value")\n+        \n+        To verify that a stylesheet has been installed in the ``portal_css`` tool\n+        (e.g. via ``cssregistry.xml``)::\n+        \n+            cssRegistry = getToolByName(portal, \'portal_css\')\n+        \n+            self.assertTrue(\'mystyles.css\' in cssRegistry.getResourceIds())\n+        \n+        To verify that a JavaScript resource has been installed in the\n+        ``portal_javascripts`` tool (e.g. via ``jsregistry.xml``)::\n+        \n+            jsRegistry = getToolByName(portal, \'portal_javascripts\')\n+        \n+            self.assertTrue(\'myscript.js\' in jsRegistry.getResourceIds())\n+        \n+        To verify that a new role has been added (e.g. via ``rolemap.xml``)::\n+        \n+            self.assertTrue(\'NewRole\' in portal.valid_roles())\n+        \n+        To verify that a permission has been granted to a given set of roles (e.g. via\n+        ``rolemap.xml``)::\n+        \n+            roles = [r[\'name\'] for r in portal.rolesOfPermission(\'My Permission\') if r[\'selected\']]\n+            self.assertEqual(roles, [\'Member\', \'Manager\'])\n+        \n+        Traversal\n+        ---------\n+        \n+        To traverse to a view, page template or other resource, use\n+        ``restrictedTraverse()`` with a relative path::\n+        \n+            resource = portal.restrictedTraverse(\'f1/@@folder_contents\')\n+        \n+        The return value is a view object, page template object, or other resource.\n+        It may be invoked to obtain an actual response (see below).\n+        \n+        ``restrictedTraverse()`` performs an explicit security check, and so may\n+        raise ``Unauthorized`` if the current test user does not have permission to\n+        view the given resource. If you don\'t want that, you can use::\n+        \n+            resource = portal.unrestrictedTraverse(\'f1/@@folder_contents\')\n+        \n+        You can call this on a folder or other content item as well, to traverse from\n+        that starting point, e.g. this is equivalent to the first example above::\n+        \n+            f1 = portal[\'f1\']\n+            resource = f1.restrictedTraverse(\'@@folder_contents\')\n+        \n+        Note that this traversal will not take ``IPublishTraverse`` adapters into\n+        account, and you cannot pass query string parameters. In fact,\n+        ``restrictedTraverse()`` and ``unrestrictedTraverse()`` implement the type of\n+        traversal that happens with path expressions in TAL, which is similar, but not\n+        identical to URL traversal.\n+        \n+        To look up a view manually::\n+        \n+            from zope.component import getMultiAdapter\n+        \n+            view = getMultiAdapter((f1, request), name=u"folder_contents")\n+        \n+        Note that the name here should not include the ``@@`` prefix.\n+        \n+        To simulate an ``IPublishTraverse`` adapter call, presuming the view\n+        implements ``IPublishTraverse``::\n+        \n+            next = view.IPublishTraverse(request, u"some-name")\n+        \n+        Or, if the ``IPublishTraverse`` adapter is separate from the view::\n+        \n+            from zope.publisher.interfaces import IPublishTraverse\n+        \n+            publishTraverse = getMultiAdapter((f1, request), IPublishTraverse)\n+            next = view.IPublishTraverse(request, u"some-name")\n+        \n+        To simulate a form submission or query string parameters::\n+        \n+            request.form.update({\n+                    \'name\': "John Smith",\n+                    \'age\':  23\n+                })\n+        \n+        The ``form`` dictionary contains the marshalled request. That is, if you are\n+        simulating a query string parameter or posted form variable that uses a\n+        marshaller like ``:int`` (e.g. ``age:int`` in the example above), the value\n+        in the ``form`` dictionary should be marshalled (an int instead of a string,\n+        in the example above), and the name should be the base name (``age`` instead\n+        of ``age:int``).\n+        \n+        To invoke a view and obtain the response body as a string::\n+        \n+            view = f1.restrictedTraverse(\'@@folder_contents\')\n+            body = view()\n+        \n+            self.assertFalse(u"An unexpected error occurred" in body)\n+        \n+        Please note that this approach is not perfect. In particular, the request\n+        is will not have the right URL or path information. If your view depends on\n+        this, you can fake it by setting the relevant keys in the request, e.g.::\n+        \n+            request.set(\'URL\', f1.absolute_url() + \'/@@folder_contents\')\n+            request.set(\'ACTUAL_URL\', f1.absolute_url() + \'/@@folder_contents\')\n+        \n+        To inspect the state of the request (e.g. after a view has been invoked)::\n+        \n+            self.assertEqual(request.get(\'disable_border\'), True)\n+        \n+        To inspect response headers (e.g. after a view has been invoked)::\n+        \n+            response = request.response\n+        \n+            self.assertEqual(response.getHeader(\'content-type\'), \'text/plain\')\n+        \n+        Simulating browser interaction\n+        ------------------------------\n+        \n+        End-to-end functional tests can use `zope.testbrowser`_ to simulate user\n+        interaction. This acts as a web browser, connecting to Zope via a special\n+        channel, making requests and obtaining responses.\n+        \n+          **Note:** zope.testbrowser runs entirely in Python, and does not simulate\n+          a JavaScript engine.\n+        \n+        Note that to use ``zope.testbrowser``, you need to use one of the functional\n+        testing layers, e.g. ``PLONE_FUNCTIONAL_TESTING``, or another layer\n+        instantiated with the ``FunctionalTesting`` class.\n+        \n+        If you want to create some initial content, you can do so either in a layer,\n+        or in the test itself, before invoking the test browser client. In the latter\n+        case, you need to commit the transaction before it becomes available, e.g.::\n+        \n+            from plone.app.testing import setRoles\n+            from plone.app.testing import TEST_USER_ID\n+        \n+            # Make some changes\n+            setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+            portal.invokeFactory(\'Folder\', \'f1\', title=u"Folder 1")\n+            setRoles(portal, TEST_USER_ID, [\'Member\'])\n+        \n+            # Commit so that the test browser sees these changes\n+            import transaction\n+            transaction.commit()\n+        \n+        To obtain a new test browser client::\n+        \n+            from plone.testing.z2 import Browser\n+        \n+            # This is usually self.app (Zope root) or site.portal (test Plone site root)\n+            browser = Browser(app)\n+        \n+        To open a given URL::\n+        \n+            portalURL = portal.absolute_url()\n+            browser.open(portalURL)\n+        \n+        To inspect the response::\n+        \n+            self.assertTrue(u"Welcome" in browser.contents)\n+        \n+        To inspect response headers::\n+        \n+            self.assertEqual(browser.headers[\'content-type\'], \'text/html; charset=utf-8\')\n+        \n+        To follow a link::\n+        \n+            browser.getLink(\'Edit\').click()\n+        \n+        This gets a link by its text. To get a link by HTML id::\n+        \n+            browser.getLink(id=\'edit-link\').click()\n+        \n+        To verify the current URL::\n+        \n+            self.assertEqual(portalURL + \'/edit\', browser.url)\n+        \n+        To set a form control value::\n+        \n+            browser.getControl(\'Age\').value = u"30"\n+        \n+        This gets the control by its associated label. To get a control by its form\n+        variable name::\n+        \n+            browser.getControl(name=\'age:int\').value = u"30"\n+        \n+        See the `zope.testbrowser`_ documentation for more details on how to select\n+        and manipulate various types of controls.\n+        \n+        To submit a form by clicking a button::\n+        \n+            browser.getControl(\'Save\').click()\n+        \n+        Again, this uses the label to find the control. To use the form variable\n+        name::\n+        \n+            browser.getControl(name=\'form.button.Save\').click()\n+        \n+        To simulate HTTP BASIC authentication and remain logged in for all\n+        requests::\n+        \n+            from plone.app.testing import TEST_USER_NAME, TEST_USER_PASSWORD\n+        \n+            browser.addHeader(\'Authorization\', \'Basic %s:%s\' % (TEST_USER_NAME, TEST_USER_PASSWORD,))\n+        \n+        To simulate logging in via the login form::\n+        \n+            browser.open(portalURL + \'/login_form\')\n+            browser.getControl(name=\'__ac_name\').value = TEST_USER_NAME\n+            browser.getControl(name=\'__ac_password\').value = TEST_USER_PASSWORD\n+            browser.getControl(name=\'submit\').click()\n+        \n+        To simulate logging out::\n+        \n+            browser.open(portalURL + \'/logout\')\n+        \n+        Debugging tips\n+        ~~~~~~~~~~~~~~\n+        \n+        By default, only HTTP error codes (e.g. 500 Server Side Error) are shown when\n+        an error occurs on the server. To see more details, set ``handleErrors`` to\n+        False::\n+        \n+            browser.handleErrors = False\n+        \n+        To inspect the error log and obtain a full traceback of the latest entry::\n+        \n+            from Products.CMFCore.utils import getToolByName\n+        \n+            errorLog = getToolByName(portal, \'error_log\')\n+            print errorLog.getLogEntries()[-1][\'tb_text\']\n+        \n+        To save the current response to an HTML file::\n+        \n+            open(\'/tmp/testbrowser.html\', \'w\').write(browser.contents)\n+        \n+        You can now open this file and use tools like Firebug to inspect the structure\n+        of the page. You should remove the file afterwards.\n+        \n+        Comparison with ZopeTestCase/PloneTestCase\n+        ==========================================\n+        \n+        `plone.testing`_ and ``plone.app.testing`` have in part evolved from\n+        ``ZopeTestCase``, which ships with Zope 2 in the ``Testing`` package, and\n+        `Products.PloneTestCase`_, which ships with Plone and is used by Plone itself\n+        as well as numerous add-on products.\n+        \n+        If you are familiar with ``ZopeTestCase`` and ``PloneTestCase``, the concepts\n+        of these package should be familiar to you. However, there are some important\n+        differences to bear in mind.\n+        \n+        * ``plone.testing`` and ``plone.app.testing`` are unburdened by the legacy\n+          support that ``ZopeTestCase`` and ``PloneTestCase`` have to include. This\n+          makes them smaller and easier to understand and maintain.\n+        \n+        * Conversely, ``plone.testing`` only works with Python 2.6 and Zope 2.12 and\n+          later. ``plone.app.testing`` only works with Plone 4 and later. If you need\n+          to write tests that run against older versions of Plone, you\'ll need to use\n+          ``PloneTestCase``.\n+        \n+        * ``ZopeTestCase``/``PloneTestCase`` were written before layers were available\n+          as a setup mechanism. ``plone.testing`` is very layer-oriented.\n+        \n+        * ``PloneTestCase`` provides a base class, also called ``PloneTestCase``,\n+          which you must use, as it performs setup and tear-down. ``plone.testing``\n+          moves shared state to layers and layer resources, and does not impose any\n+          particular base class for tests. This does sometimes mean a little more\n+          typing (e.g. ``self.layer[\'portal\']`` vs. ``self.portal``), but it makes\n+          it much easier to control and re-use test fixtures. It also makes your\n+          test code simpler and more explicit.\n+        \n+        * ``ZopeTestCase`` has an ``installProduct()`` function and a corresponding\n+          ``installPackage()`` function. `plone.testing`_ has only an\n+          ``installProduct()``, which can configure any kind of Zope 2 product (i.e.\n+          packages in the ``Products.*`` namespace, old-style products in a special\n+          ``Products`` folder, or packages in any namespace that have had their ZCML\n+          loaded and which include a ``<five:registerPackage />`` directive in their\n+          configuration). Note that you must pass a full dotted name to this function,\n+          even for "old-style" products in the ``Products.*`` namespace, e.g.\n+          ``Products.LinguaPlone`` instead of ``LinguaPlone``.\n+        \n+        * On setup, ``PloneTestCase`` will load Zope 2\'s default ``site.zcml``. This\n+          in turn will load all ZCML for all packages in the ``Products.*`` namespace.\n+          ``plone.testing`` does not do this (and you are strongly encouraged from\n+          doing it yourself), because it is easy to accidentally include packages in\n+          your fixture that you didn\'t intend to be there (and which can actually\n+          change the fixture substantially). You should load your package\'s ZCML\n+          explicitly. See the `plone.testing`_ documentation for details.\n+        \n+        * When using ``PloneTestCase``, any package that has been loaded onto\n+          ``sys.path`` and which defines the ``z3c.autoinclude.plugin:plone`` entry\n+          point will be loaded via `z3c.autoinclude`_\'s plugin mechanism. This loading\n+          is explicitly disabled, for the same reasons that the ``Products.*`` auto-\n+          loading is. You should load your packages\' configuration explicitly.\n+        \n+        * ``PloneTestCase`` sets up a basic fixture that has member folder enabled,\n+          and in which the test user\'s member folder is available as ``self.folder``.\n+          The ``plone_workflow`` workflow is also installed as the default.\n+          ``plone.app.testing`` takes a more minimalist approach. To create a test\n+          folder owned by the test user that is similar to ``self.folder`` in a\n+          ``PloneTestCase``, you can do::\n+        \n+                import unittest2 as unittest\n+                from plone.app.testing import TEST_USER_ID, setRoles\n+                from plone.app.testing import PLONE_INTEGRATION_TESTING\n+        \n+                class MyTest(unitest.TestCase):\n+        \n+                    layer = PLONE_INTEGRATION_TESTING\n+        \n+                    def setUp(self):\n+                        self.portal = self.layer[\'portal\']\n+        \n+                        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+                        self.portal.invokeFactory(\'Folder\', \'test-folder\')\n+                        setRoles(self.portal, TEST_USER_ID, [\'Member\'])\n+        \n+                        self.folder = self.portal[\'test-folder\']\n+        \n+          You could of course do this type of setup in your own layer and expose it\n+          as a resource instead.\n+        \n+        * To use `zope.testbrowser`_ with ``PloneTestCase``, you should use its\n+          ``FunctionalTestCase`` as a base class, and then use the following pattern::\n+        \n+                from Products.Five.testbrowser import Browser\n+                browser = Browser()\n+        \n+          The equivalent pattern in ``plone.app.testing`` is to use the\n+          ``FunctionalTesting`` test lifecycle layer (see example above), and then\n+          use::\n+        \n+                from plone.testing.z2 import Browser\n+                browser = Browser(self.layer[\'app\'])\n+        \n+          Also note that if you have made changes to the fixture prior to calling\n+          ``browser.open()``, they will *not* be visible until you perform an\n+          explicit commit. See the ``zope.testbrowser`` examples above for details.\n+        \n+        .. _plone.testing: http://pypi.python.org/pypi/plone.testing\n+        .. _zope.testing: http://pypi.python.org/pypi/zope.testing\n+        .. _z3c.autoinclude: http://pypi.python.org/pypi/z3c.autoinclude\n+        .. _zope.testbrowser: http://pypi.python.org/pypi/zope.testbrowser\n+        .. _Products.PloneTestCase: http://pypi.python.org/pypi/Products.PloneTestCase\n+        \n+        \n+        Changelog\n+        =========\n+        \n+        6.0.0 (unreleased)\n+        ------------------\n+        \n+        Breaking changes:\n+        \n+        - *add item here*\n+        \n+        New features:\n+        \n+        - Install and load zcml of CMFQuickInstallerTool only when importable.\n+          [maurits]\n+        \n+        - Load negotiator from plone.i18n (PTS removed).\n+          [jensens, ksuess]\n+        \n+        Bug fixes:\n+        \n+        - *add item here*\n+        \n+        \n+        5.0.8 (2017-10-25)\n+        ------------------\n+        \n+        Bug fixes:\n+        \n+        - Load Products.PageTemplates ZCML.  [tschorr]\n+        \n+        \n+        5.0.7 (2017-07-03)\n+        ------------------\n+        \n+        Bug fixes:\n+        \n+        - Remove deprecated __of__ calls on BrowserViews\n+          [MrTango]\n+        \n+        - Remove unittest2 dependency\n+          [kakshay21]\n+        \n+        \n+        5.0.6 (2016-12-19)\n+        ------------------\n+        \n+        Bug fixes:\n+        \n+        - No longer try to load `Products.SecureMailHost` and its zcml.\n+          This is not shipped with Plone 5.0 or higher.  [maurits]\n+        \n+        \n+        5.0.5 (2016-11-19)\n+        ------------------\n+        \n+        Bug fixes:\n+        \n+        - Do not use install Products.PasswordResetTool in the PloneFixture if it isn\'t available.\n+          [thet]\n+        \n+        \n+        5.0.4 (2016-09-23)\n+        ------------------\n+        \n+        New features:\n+        \n+        - Use get_installer instead of portal_quickinstaller when available, for\n+          Plone 5.1 and higher.  [maurits]\n+        \n+        - In PloneSandboxLayer make profile upgrade versions persistent.  This\n+          way installed profile versions get reset in teardown.  [maurits]\n+        \n+        \n+        5.0.3 (2016-09-07)\n+        ------------------\n+        \n+        Bug fixes:\n+        \n+        - Load Products.CMFFormController in tests.  It is still used by core\n+          Plone, also without Archetypes.  This makes the CMFFormController\n+          tests pass.  [maurits]\n+        \n+        \n+        5.0.2 (2016-06-07)\n+        ------------------\n+        \n+        Fixes:\n+        \n+        - Do not use install Products.SecureMailHost in the PloneFixture if it isn\'t available\n+          [vangheem]\n+        \n+        \n+        5.0.1 (2016-02-26)\n+        ------------------\n+        \n+        Fixes:\n+        \n+        - Replace deprecated ``zope.site.hooks`` import with ``zope.component.hooks``.\n+          [thet]\n+        \n+        \n+        5.0.0 (2016-02-20)\n+        ------------------\n+        \n+        New:\n+        \n+        - Add a MOCK_MAILHOST_FIXTURE fixture that integration and functional tests layers can depend on.\n+          This allows to easily check how mails are sent from Plone.\n+          [gforcada]\n+        \n+        Fixes:\n+        \n+        - Fix ``layers.rst`` doctest to be compatible with older and newer zope.testrunner layer ordering.\n+          [thet]\n+        \n+        - Depend on ``zope.testrunner`` and fix deprecated usage of ``zope.testing.testrunner``.\n+          [thet]\n+        \n+        - Cleanup code, flake8, sort imports, etc.\n+          [gforcada]\n+        \n+        - Fix RAM cache error with bbb.PloneTestCase.\n+          [ebrehault]\n+        \n+        \n+        5.0b6 (2015-08-22)\n+        ------------------\n+        \n+        - No need for unittest2.\n+          [gforcada]\n+        \n+        \n+        5.0b5 (2015-07-18)\n+        ------------------\n+        \n+        - Do not install CMFDefault.\n+          [tomgross]\n+        \n+        - Document PloneWithPackageLayer.\n+          [gotcha]\n+        \n+        \n+        5.0b4 (2015-05-04)\n+        ------------------\n+        \n+        - Do not install CMFFormController.\n+          [timo]\n+        \n+        - Do not install CMFDefault\n+          [tomgross]\n+        \n+        5.0b3 (2015-03-26)\n+        ------------------\n+        \n+        - Remove PloneLanguageTool from PloneFixture.\n+          [timo]\n+        \n+        \n+        5.0b2 (2015-03-13)\n+        ------------------\n+        \n+        - remove test of applying an extension profile, we don\'t have a good one to\n+          test now.\n+          [davidagli]\n+        \n+        - fix test, plone.app.theming does not get recorded as installed .\n+          [davisagli]\n+        \n+        - fix: ``Products.CMFPlone`` needs the ``gopip`` index from\n+          ``plone.app.folder``. So latter has to be initialized before CMFPlones\n+          profile is applied (which installs the index to catalog). At the moment\n+          CMFPlone therefore registers the index itself, but plone.app.folder\n+          registers it too, which resulted in plone/Products.CMFPlone#313\n+          "GopipIndex registered twice" In tests the registration does not succedd,\n+          because plone.app.folder was never initialized as z2 products. In order to\n+          remove the misleading regisatration from CMFPlone we must take care that the\n+          index is available, which is achieved with this change. Also minor pep8\n+          optimizations in the file touched.\n+          [jensens]\n+        \n+        - create memberfolder, if it is not there for testing.\n+          [tomgross]\n+        \n+        \n+        5.0b1 (2014-10-23)\n+        ------------------\n+        \n+        - Allow applyProfile to skip steps and all other options supported by\n+          runAllImportStepsFromProfile of portal_setup-tool.\n+          [pbauer, tomgross]\n+        \n+        \n+        5.0a2 (2014-04-19)\n+        ------------------\n+        \n+        - Install Products.DateRecurringIndex for the PLONE_FIXTURE Layer.\n+          [thet]\n+        \n+        \n+        5.0a1 (2014-02-22)\n+        ------------------\n+        \n+        - Add \'ROBOT_TEST_LEVEL\' to interfaces, so other packages can import it. This\n+          makes things easier if we decide to change the value.\n+          [timo]\n+        \n+        - Replace deprecated test assert statements.\n+          [timo]\n+        \n+        - plonetheme.classic no longer ships with Plone, don\'t use it for\n+          testing.\n+          [esteele]\n+        \n+        - Clean up the zodbDB and configurationContext resources if there\n+          is an error during the PloneSandboxLayer setUp.\n+          [davisagli]\n+        \n+        - Make PLONE_FIXTURE not install a content type system.\n+          Packages that need content types to run their tests should\n+          pick the appropriate fixture from plone.app.contenttypes\n+          or Products.ATContentTypes.\n+          [davisagli]\n+        \n+        - Pin [robot] extra to ``robotsuite>=1.4.0``.\n+          [saily]\n+        \n+        - Fix wrong spelling of ``reinstallProducts`` method in quickInstallProduct.\n+          [saily]\n+        \n+        - Sync bbb PloneTestCase class with original one.\n+          [tomgross]\n+        \n+        \n+        4.2.2 (2013-02-09)\n+        ------------------\n+        \n+        - Add [robot] extras for requiring dependnecies for Robot Framework\n+          tests with Selenium2Library\n+          [datakurre]\n+        \n+        - Install PythonScripts as zope product\n+          [mikejmets]\n+        \n+        \n+        4.2.1 (2012-12-15)\n+        ------------------\n+        \n+        - Allow testing with non standard port. Allows running multiple test suites\n+          in parallel.\n+          [do3cc]\n+        \n+        - Documentation updates.\n+          [moo]\n+        \n+        \n+        4.2 (2012-04-15)\n+        ----------------\n+        \n+        - Branch as 4.2 as the plone.app.collection addition breaks backwards\n+          compatibility.\n+          [esteele]\n+        \n+        - Fixed spurious failure in our own tests by using a longer timeout.\n+          [maurits]\n+        \n+        - plone.app.collection added to PloneFixture.\n+          [timo]\n+        \n+        \n+        4.0.2 (2011-08-31)\n+        ------------------\n+        \n+        - Load ZCML before installing Zope products in ``PloneWithPackageLayer``;\n+          it enables package registration.\n+          [gotcha]\n+        \n+        \n+        4.0.1 (2011-07-14)\n+        ------------------\n+        \n+        - Add ``additional_z2_products`` parameter to ``PloneWithPackageLayer``\n+          helper class to install additional Zope 2 products.\n+          [jfroche]\n+        \n+        \n+        4.0 - 2011-05-13\n+        ------------------\n+        \n+        - 4.0 Final release.\n+          [esteele]\n+        \n+        - Add MANIFEST.in.\n+          [WouterVH]\n+        \n+        \n+        4.0a6 - 2011-04-06\n+        ------------------\n+        \n+        - Added helper functions for selenium layer. (Copied from SeleniumTestCase\n+          within Products.CMFPlone/Products/CMFPlone/tests/selenium/base.py)\n+          [emanlove]\n+        \n+        - Rework layer setup of SeleniumLayer so that z2.ZSERVER_FIXTURE is a\n+          default_base.\n+          [esteele]\n+        \n+        - Convert the passed-in selenium webdriver name to lowercase before doing a\n+          module lookup.\n+          [esteele]\n+        \n+        - Moved selenium start up and tear down to testSetUp and testTearDown,\n+          respectively.  This was done to help further isolate individual tests.\n+          For example, logging in under one test would require either logging out\n+          or shutting down the browser, which is what the selenium_layer will now\n+          do under testTearDown, in order to have a "clean" state within the next\n+          test.\n+          [emanlove]\n+        \n+        - Corrected module path for the various selenium webdrivers using\n+          selenium 2.0b2.\n+          [emanlove]\n+        \n+        \n+        4.0a5 - 2011-03-02\n+        ------------------\n+        \n+        - Use the new ``plone.testing.security`` module to ensure isolation of\n+          security checkers when setting up and tearing down layers based on the\n+          ``PloneSandboxLayer`` helper base class. This would cause problems when\n+          running multiple test suites in the same test run, in particular if one of\n+          those suites were setting up ZCML that used ``five.grok``.\n+          [optilude]\n+        \n+        \n+        4.0a4 - 2011-01-11\n+        ------------------\n+        \n+        - Automatically tear down PAS registrations via snapshotting when using\n+          ``PloneSandboxLayer``. It\'s too difficult to do this manually when you\n+          consider that plugins may be registered in ZCML via transitive dependencies.\n+          There should be no backwards compatibility concern - using\n+          ``tearDownMultiPlugin()`` is still supported, and it\'s generally safe to\n+          call it once.\n+          [optilude]\n+        \n+        - Try to make sure ``tearDownMultiPlugin()`` and the generic PAS plugin\n+          cleanup handler do not interfere with the cleanup handler from the PAS\n+          ZCML directive.\n+          [optilude]\n+        \n+        - Do not install ``Products.kupu`` or ``Products.CMFPlacefulWorkflow``.\n+          [elro]\n+        \n+        - Depend on ``Products.CMFPlone`` instead of ``Plone``.\n+          [elro]\n+        \n+        \n+        4.0a3 - 2010-12-14\n+        ------------------\n+        \n+        - Allow top-level import of PloneTestLifecycle.\n+          [stefan]\n+        \n+        - Added a warning not to use \'default\' Firefox profile for selenium tests.\n+          [zupo]\n+        \n+        - Fixed distribution dependency declarations.\n+          [hannosch]\n+        \n+        - Correct license to GPL version 2 only.\n+          [hannosch]\n+        \n+        - Make some module imports helper methods on the already policy-heavy\n+          helper class per optilude\'s suggestion.\n+          [rossp]\n+        \n+        - Add a layer and test case for running selenium tests.\n+          [rossp]\n+        \n+        - Give the default test user differing user id and login name. This helps reveal\n+          problems with userid vs login name errors, an overly common error.\n+          [wichert]\n+        \n+        \n+        1.0a2 - 2010-09-05\n+        ------------------\n+        \n+        - Make sure plone.app.imaging is installed properly during layer setup.\n+          [optilude]\n+        \n+        \n+        1.0a1 - 2010-08-01\n+        ------------------\n+        \n+        - Initial release\n+        \n+Keywords: plone tests\n+Platform: UNKNOWN\n+Classifier: Environment :: Web Environment\n+Classifier: Framework :: Plone\n+Classifier: Framework :: Plone :: 5.0\n+Classifier: Framework :: Plone :: 5.1\n+Classifier: Framework :: Plone :: 5.2\n+Classifier: Framework :: Zope2\n+Classifier: License :: OSI Approved :: GNU General Public License v2 (GPLv2)\n+Classifier: Operating System :: OS Independent\n+Classifier: Programming Language :: Python\n+Classifier: Programming Language :: Python :: 2.7\n+Classifier: Programming Language :: Python :: 3.5\n+Classifier: Programming Language :: Python :: 3.6\n+Classifier: Programming Language :: Python :: 3.7\n+Classifier: Topic :: Internet :: WWW/HTTP :: Dynamic Content\n+Provides-Extra: test\n+Provides-Extra: robot\ndiff --git a/src/plone.app.testing.egg-info/SOURCES.txt b/src/plone.app.testing.egg-info/SOURCES.txt\nnew file mode 100644\nindex 0000000..5deb4a0\n--- /dev/null\n+++ b/src/plone.app.testing.egg-info/SOURCES.txt\n@@ -0,0 +1,32 @@\n+CHANGES.rst\n+CONTRIBUTING.rst\n+MANIFEST.in\n+README.rst\n+setup.cfg\n+setup.py\n+docs/LICENSE.GPL\n+docs/LICENSE.txt\n+docs/README.rst\n+docs/conf.py\n+docs/index.rst\n+docs/isolation.rst\n+docs/views.rst\n+docs/zope-testbrowser.rst\n+src/plone/__init__.py\n+src/plone.app.testing.egg-info/PKG-INFO\n+src/plone.app.testing.egg-info/SOURCES.txt\n+src/plone.app.testing.egg-info/dependency_links.txt\n+src/plone.app.testing.egg-info/namespace_packages.txt\n+src/plone.app.testing.egg-info/not-zip-safe\n+src/plone.app.testing.egg-info/requires.txt\n+src/plone.app.testing.egg-info/top_level.txt\n+src/plone/app/__init__.py\n+src/plone/app/testing/__init__.py\n+src/plone/app/testing/bbb.py\n+src/plone/app/testing/cleanup.py\n+src/plone/app/testing/helpers.py\n+src/plone/app/testing/interfaces.py\n+src/plone/app/testing/layers.py\n+src/plone/app/testing/selenium_layers.py\n+src/plone/app/testing/tests.py\n+src/plone/app/testing/utils.py\n\\ No newline at end of file\ndiff --git a/src/plone.app.testing.egg-info/dependency_links.txt b/src/plone.app.testing.egg-info/dependency_links.txt\nnew file mode 100644\nindex 0000000..8b13789\n--- /dev/null\n+++ b/src/plone.app.testing.egg-info/dependency_links.txt\n@@ -0,0 +1 @@\n+\ndiff --git a/src/plone.app.testing.egg-info/namespace_packages.txt b/src/plone.app.testing.egg-info/namespace_packages.txt\nnew file mode 100644\nindex 0000000..003a209\n--- /dev/null\n+++ b/src/plone.app.testing.egg-info/namespace_packages.txt\n@@ -0,0 +1,2 @@\n+plone\n+plone.app\ndiff --git a/src/plone.app.testing.egg-info/not-zip-safe b/src/plone.app.testing.egg-info/not-zip-safe\nnew file mode 100644\nindex 0000000..8b13789\n--- /dev/null\n+++ b/src/plone.app.testing.egg-info/not-zip-safe\n@@ -0,0 +1 @@\n+\ndiff --git a/src/plone.app.testing.egg-info/requires.txt b/src/plone.app.testing.egg-info/requires.txt\nnew file mode 100644\nindex 0000000..d0388dd\n--- /dev/null\n+++ b/src/plone.app.testing.egg-info/requires.txt\n@@ -0,0 +1,29 @@\n+setuptools\n+zope.configuration\n+zope.component\n+zope.dottedname\n+zope.testing\n+five.localsitemanager\n+plone.memoize\n+plone.testing[security,z2,zca,zodb]\n+Products.CMFPlone\n+Products.GenericSetup\n+Zope2\n+\n+[robot]\n+robotsuite>=1.4.0\n+robotframework-selenium2library\n+decorator\n+selenium\n+\n+[test]\n+Products.CMFCore\n+Products.CMFPlone\n+Products.PluggableAuthService\n+Products.CMFPlacefulWorkflow\n+selenium\n+transaction\n+zope.interface\n+zope.publisher\n+zope.testrunner\n+zope.testing\ndiff --git a/src/plone.app.testing.egg-info/top_level.txt b/src/plone.app.testing.egg-info/top_level.txt\nnew file mode 100644\nindex 0000000..1d2c38d\n--- /dev/null\n+++ b/src/plone.app.testing.egg-info/top_level.txt\n@@ -0,0 +1 @@\n+plone\ndiff --git a/src/plone/__init__.py b/src/plone/__init__.py\nnew file mode 100644\nindex 0000000..68c04af\n--- /dev/null\n+++ b/src/plone/__init__.py\n@@ -0,0 +1,2 @@\n+# -*- coding: utf-8 -*-\n+__import__(\'pkg_resources\').declare_namespace(__name__)\ndiff --git a/src/plone/app/__init__.py b/src/plone/app/__init__.py\nnew file mode 100644\nindex 0000000..68c04af\n--- /dev/null\n+++ b/src/plone/app/__init__.py\n@@ -0,0 +1,2 @@\n+# -*- coding: utf-8 -*-\n+__import__(\'pkg_resources\').declare_namespace(__name__)\ndiff --git a/src/plone/app/testing/__init__.py b/src/plone/app/testing/__init__.py\nnew file mode 100644\nindex 0000000..44bafc4\n--- /dev/null\n+++ b/src/plone/app/testing/__init__.py\n@@ -0,0 +1,34 @@\n+# -*- coding: utf-8 -*-\n+# flake8: NOQA: F401\n+from plone.app.testing.cleanup import cleanUpMultiPlugins\n+from plone.app.testing.helpers import applyProfile\n+from plone.app.testing.helpers import login\n+from plone.app.testing.helpers import logout\n+from plone.app.testing.helpers import PloneSandboxLayer\n+from plone.app.testing.helpers import ploneSite\n+from plone.app.testing.helpers import PloneWithPackageLayer\n+from plone.app.testing.helpers import popGlobalRegistry\n+from plone.app.testing.helpers import pushGlobalRegistry\n+from plone.app.testing.helpers import quickInstallProduct\n+from plone.app.testing.helpers import setRoles\n+from plone.app.testing.helpers import tearDownMultiPluginRegistration\n+from plone.app.testing.interfaces import DEFAULT_LANGUAGE\n+from plone.app.testing.interfaces import PLONE_SITE_ID\n+from plone.app.testing.interfaces import PLONE_SITE_TITLE\n+from plone.app.testing.interfaces import ROBOT_TEST_LEVEL\n+from plone.app.testing.interfaces import SITE_OWNER_NAME\n+from plone.app.testing.interfaces import SITE_OWNER_PASSWORD\n+from plone.app.testing.interfaces import TEST_USER_ID\n+from plone.app.testing.interfaces import TEST_USER_NAME\n+from plone.app.testing.interfaces import TEST_USER_PASSWORD\n+from plone.app.testing.interfaces import TEST_USER_ROLES\n+from plone.app.testing.layers import FunctionalTesting\n+from plone.app.testing.layers import IntegrationTesting\n+from plone.app.testing.layers import MOCK_MAILHOST_FIXTURE\n+from plone.app.testing.layers import PLONE_FIXTURE\n+from plone.app.testing.layers import PLONE_FTP_SERVER\n+from plone.app.testing.layers import PLONE_FUNCTIONAL_TESTING\n+from plone.app.testing.layers import PLONE_INTEGRATION_TESTING\n+from plone.app.testing.layers import PLONE_ZSERVER\n+from plone.app.testing.layers import PloneFixture\n+from plone.app.testing.layers import PloneTestLifecycle\ndiff --git a/src/plone/app/testing/bbb.py b/src/plone/app/testing/bbb.py\nnew file mode 100644\nindex 0000000..d07b92e\n--- /dev/null\n+++ b/src/plone/app/testing/bbb.py\n@@ -0,0 +1,125 @@\n+# -*- coding: utf-8 -*-\n+"""Backwards-compatibility test class for PloneTestCase."""\n+\n+from AccessControl import getSecurityManager\n+from plone.app import testing\n+from plone.testing import z2\n+from Products.CMFPlone.utils import _createObjectByType\n+from Testing.ZopeTestCase.functional import Functional\n+\n+import transaction\n+import unittest\n+\n+\n+def _createMemberarea(portal, user_id):\n+    mtool = portal.portal_membership\n+    members = mtool.getMembersFolder()\n+    if members is None:\n+        _createObjectByType(\'Folder\', portal, id=\'Members\')\n+    if not mtool.getMemberareaCreationFlag():\n+        mtool.setMemberareaCreationFlag()\n+    mtool.createMemberArea(user_id)\n+    if mtool.getMemberareaCreationFlag():\n+        mtool.setMemberareaCreationFlag()\n+\n+\n+class PloneTestCaseFixture(testing.PloneSandboxLayer):\n+\n+    defaultBases = (testing.PLONE_FIXTURE,)\n+\n+    def setUpZope(self, app, configurationContext):\n+        import Products.ATContentTypes\n+        self.loadZCML(package=Products.ATContentTypes)\n+\n+        z2.installProduct(app, \'Products.Archetypes\')\n+        z2.installProduct(app, \'Products.ATContentTypes\')\n+        z2.installProduct(app, \'plone.app.blob\')\n+        z2.installProduct(app, \'plone.app.collection\')\n+\n+    def setUpPloneSite(self, portal):\n+        # restore default workflow\n+        testing.applyProfile(portal, \'Products.CMFPlone:testfixture\')\n+\n+        # add default content\n+        testing.applyProfile(portal, \'Products.ATContentTypes:content\')\n+\n+        # add home folder for default test user\n+        _createMemberarea(portal, testing.TEST_USER_ID)\n+\n+    def tearDownZope(self, app):\n+        z2.uninstallProduct(app, \'plone.app.collection\')\n+        z2.uninstallProduct(app, \'plone.app.blob\')\n+        z2.uninstallProduct(app, \'Products.ATContentTypes\')\n+        z2.uninstallProduct(app, \'Products.Archetypes\')\n+\n+\n+PTC_FIXTURE = PloneTestCaseFixture()\n+PTC_FUNCTIONAL_TESTING = testing.FunctionalTesting(\n+    bases=(PTC_FIXTURE,), name=\'PloneTestCase:Functional\')\n+\n+\n+class PloneTestCase(Functional, unittest.TestCase):\n+\n+    layer = PTC_FUNCTIONAL_TESTING\n+\n+    def setUp(self):\n+        """Set up before each test."""\n+        self.beforeSetUp()\n+        self.app = self.layer[\'app\']\n+        self.portal = self.layer[\'portal\']\n+        self.folder = self.portal.portal_membership.getHomeFolder(\n+            testing.TEST_USER_ID)\n+        transaction.commit()\n+        self.afterSetUp()\n+\n+    def beforeSetUp(self):\n+        """Hook to do setup before the portal is created."""\n+        pass\n+\n+    def afterSetUp(self):\n+        """Hook to do setup after the portal is created."""\n+\n+    def tearDown(self):\n+        """Tear down after each test."""\n+        self.beforeTearDown()\n+        transaction.abort()\n+        super(PloneTestCase, self).tearDown()\n+        self.afterTearDown()\n+\n+    def beforeTearDown(self):\n+        """Hook to do teardown before the portal is removed."""\n+\n+    def afterTearDown(self):\n+        """Hook to do teardown after the portal is removed."""\n+\n+    def setRoles(self, roles, name=testing.TEST_USER_ID):\n+        """Set the effective roles of a user."""\n+        testing.setRoles(self.portal, name, roles)\n+\n+    def setGroups(self, groups, name=testing.TEST_USER_ID):\n+        \'\'\'Changes the user\'s groups.\'\'\'\n+        uf = self.portal[\'acl_users\']\n+        uf.userSetGroups(name, list(groups))\n+        user = getSecurityManager().getUser()\n+        if name == user.getId():\n+            self.login(user.getUserName())\n+\n+    def setPermissions(self, permissions, role=\'Member\'):\n+        """Changes the permissions assigned to role."""\n+        self.portal.manage_role(role, list(permissions))\n+\n+    def login(self, userName=testing.TEST_USER_NAME):\n+        """Log in to the portal as the given user."""\n+        testing.login(self.portal, userName)\n+\n+    def loginAsPortalOwner(self, userName=testing.SITE_OWNER_NAME):\n+        """Log in to the portal as the user who created it."""\n+        z2.login(self.app[\'acl_users\'], userName)\n+\n+    def logout(self):\n+        """Log out, i.e. become anonymous."""\n+        testing.logout()\n+\n+    def createMemberarea(self, name):\n+        """Create a minimal memberarea."""\n+        _createMemberarea(self.portal, name)\ndiff --git a/src/plone/app/testing/cleanup.py b/src/plone/app/testing/cleanup.py\nnew file mode 100644\nindex 0000000..eb227a4\n--- /dev/null\n+++ b/src/plone/app/testing/cleanup.py\n@@ -0,0 +1,41 @@\n+# -*- coding: utf-8 -*-\n+"""Cleanup handlers for various global registries\n+"""\n+\n+from zope.testing.cleanup import addCleanUp\n+\n+\n+# Make sure cleanup handlers from GenericSetup are registered\n+try:\n+    import Products.GenericSetup.zcml\n+except ImportError:\n+    pass\n+\n+# Make sure cleanup handlers from PAS are registered\n+try:\n+    import Products.PluggableAuthService.zcml\n+except ImportError:\n+    pass\n+\n+\n+def cleanUpMultiPlugins():\n+    try:\n+        from Products.PluggableAuthService.PluggableAuthService import MultiPlugins  # NOQA: E501\n+    except ImportError:\n+        pass\n+    else:\n+\n+        zap = []\n+\n+        # Don\'t stomp on the things the other cleanup handler will deal with\n+        from Products.PluggableAuthService import zcml\n+        for plugin in MultiPlugins:\n+            if plugin not in zcml._mt_regs:\n+                zap.append(plugin)\n+\n+        for plugin in zap:\n+            MultiPlugins.remove(plugin)\n+\n+\n+addCleanUp(cleanUpMultiPlugins)\n+del addCleanUp\ndiff --git a/src/plone/app/testing/cleanup.rst b/src/plone/app/testing/cleanup.rst\nnew file mode 100644\nindex 0000000..141df6f\n--- /dev/null\n+++ b/src/plone/app/testing/cleanup.rst\n@@ -0,0 +1,31 @@\n+Cleanup functions\n+-----------------\n+\n+When imported, this package will register a few cleanup handlers with\n+``zope.testing.cleanup`` to clean up global state left by various Zope, CMF\n+and Plone packages.\n+\n+    >>> import zope.testing.cleanup\n+    >>> zope.testing.cleanup.cleanUp()\n+\n+PluggableAuthService MultiPlugins list\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The ``PluggableAuthService`` package maintains a global list of so-called multi-plugins.\n+\n+    >>> from Products.PluggableAuthService import PluggableAuthService\n+    >>> PluggableAuthService.MultiPlugins\n+    []\n+\n+A new plugin can be registered using the ``registerPlugin()`` API.\n+\n+    >>> PluggableAuthService.registerMultiPlugin("dummy_plugin")\n+    >>> PluggableAuthService.MultiPlugins\n+    [\'dummy_plugin\']\n+\n+On cleanup, this list is emptied.\n+\n+    >>> zope.testing.cleanup.cleanUp()\n+\n+    >>> PluggableAuthService.MultiPlugins\n+    []\ndiff --git a/src/plone/app/testing/helpers.py b/src/plone/app/testing/helpers.py\nnew file mode 100644\nindex 0000000..1a60080\n--- /dev/null\n+++ b/src/plone/app/testing/helpers.py\n@@ -0,0 +1,505 @@\n+# -*- coding: utf-8 -*-\n+# Helper functions for Plone testing. Also importable from plone.app.testing\n+# directly\n+\n+from plone.app.testing import layers\n+from plone.app.testing.interfaces import PLONE_SITE_ID\n+from plone.app.testing.interfaces import SITE_OWNER_NAME\n+from plone.app.testing.interfaces import TEST_USER_NAME\n+from plone.testing import Layer\n+from plone.testing import security\n+from plone.testing import z2\n+from plone.testing import zca\n+from plone.testing import zodb\n+from zope.component import getGlobalSiteManager\n+from zope.component.hooks import getSite\n+from zope.component.hooks import setHooks\n+from zope.component.hooks import setSite\n+from zope.configuration import xmlconfig\n+\n+import contextlib\n+\n+\n+# User management\n+\n+\n+def login(portal, userName):\n+    """Log in as the given user in the given Plone site\n+    """\n+\n+    z2.login(portal[\'acl_users\'], userName)\n+\n+\n+def logout():\n+    """Log out, i.e. become anonymous\n+    """\n+\n+    z2.logout()\n+\n+\n+def setRoles(portal, userId, roles):\n+    """Set the given user\'s roles to a tuple of roles.\n+    """\n+\n+    userFolder = portal[\'acl_users\']\n+    z2.setRoles(userFolder, userId, roles)\n+\n+\n+def tearDownMultiPluginRegistration(pluginName):\n+    """Remove the given PAS MultiPlugin name from the global PAS registry.\n+    Does nothing if the plugin name is not registered.\n+\n+    This helper is useful during tear-down if a product has explicitly added\n+    a MultiPlugin registraton to the PluggableAuthService using the\n+    ``<pas:registerMultiPlugin />`` ZCML directive.\n+    """\n+\n+    from Products.PluggableAuthService import PluggableAuthService\n+    from Products.PluggableAuthService import zcml\n+\n+    if pluginName in PluggableAuthService.MultiPlugins:\n+        PluggableAuthService.MultiPlugins.remove(pluginName)\n+\n+    if pluginName in zcml._mt_regs:\n+        zcml._mt_regs.remove(pluginName)\n+\n+\n+# Product management - local site\n+\n+\n+def quickInstallProduct(portal, productName, reinstall=False):\n+    """Install a product using the ``portal_quickinstaller`` tool. If\n+    ``reinstall`` is false and the product is already installed, do nothing.\n+    If ``reinstall`` is true, perform an explicit reinstall if the product\n+    is installed already.\n+    """\n+\n+    from Acquisition import aq_parent\n+    from AccessControl import getSecurityManager\n+    from AccessControl.SecurityManagement import setSecurityManager\n+\n+    sm = getSecurityManager()\n+    app = aq_parent(portal)\n+\n+    z2.login(app[\'acl_users\'], SITE_OWNER_NAME)\n+\n+    try:\n+        from Products.CMFPlone.utils import get_installer\n+    except ImportError:\n+        # BBB For Plone 5.0 and lower.\n+        qi = portal[\'portal_quickinstaller\']\n+        old_qi = True\n+    else:\n+        qi = get_installer(portal)\n+        old_qi = False\n+\n+    try:\n+        if old_qi:\n+            if not qi.isProductInstalled(productName):\n+                qi.installProduct(productName)\n+            elif reinstall:\n+                qi.reinstallProducts([productName])\n+        else:\n+            if not qi.is_product_installed(productName):\n+                qi.install_product(productName, allow_hidden=True)\n+            elif reinstall:\n+                qi.uninstall_product(productName)\n+                qi.install_product(productName, allow_hidden=True)\n+\n+        portal.clearCurrentSkin()\n+        portal.setupCurrentSkin(portal.REQUEST)\n+\n+    finally:\n+        setSecurityManager(sm)\n+\n+\n+def applyProfile(portal, profileName, purge_old=None,\n+                 ignore_dependencies=False, archive=None,\n+                 blacklisted_steps=None):\n+    """Install an extension profile into the portal. The profile name\n+    should be a package name and a profile name, e.g. \'my.product:default\'.\n+    """\n+\n+    from Acquisition import aq_parent\n+    from AccessControl import getSecurityManager\n+    from AccessControl.SecurityManagement import setSecurityManager\n+\n+    sm = getSecurityManager()\n+    app = aq_parent(portal)\n+\n+    z2.login(app[\'acl_users\'], SITE_OWNER_NAME)\n+\n+    try:\n+        setupTool = portal[\'portal_setup\']\n+        profileId = \'profile-{0}\'.format(profileName)\n+        setupTool.runAllImportStepsFromProfile(\n+            profileId,\n+            purge_old=purge_old,\n+            ignore_dependencies=ignore_dependencies,\n+            archive=archive,\n+            blacklisted_steps=blacklisted_steps)\n+\n+        portal.clearCurrentSkin()\n+        portal.setupCurrentSkin(portal.REQUEST)\n+\n+    finally:\n+        setSecurityManager(sm)\n+\n+\n+# Component architecture\n+\n+\n+def pushGlobalRegistry(portal, new=None, name=None):\n+    """Set a new global component registry that uses the current registry as\n+    a base. If you use this, you *must* call ``popGlobalRegistry()`` to\n+    restore the original state.\n+\n+    If ``new`` is not given, a new registry is created. If given, you must\n+    provide a ``zope.component.globalregistry.BaseGlobalComponents`` object.\n+\n+    Returns the new registry.\n+\n+    Also ensure that the persistent component registry at ``portal`` has the\n+    new global registry as its base.\n+    """\n+    site = getSite()\n+\n+    localSiteManager = portal.getSiteManager()\n+\n+    current = zca.pushGlobalRegistry(new=new)\n+\n+    if current not in localSiteManager.__bases__:\n+        localSiteManager.__bases__ = (current, )\n+\n+    if site is not None:\n+        setHooks()\n+        setSite(site)\n+\n+    return current\n+\n+\n+def popGlobalRegistry(portal):\n+    """Restore the global component registry form the top of the stack, as\n+    set with ``pushGlobalRegistry()``.\n+\n+    Also ensure that the persistent component registry at ``portal`` has the\n+    new global registry as its base.\n+    """\n+\n+    # First, check if the component site has the global site manager in its\n+    # bases. If so, that site manager is about to disappear, so set its\n+    # base(s) as the new base(s) for the local site manager.\n+    globalSiteManager = getGlobalSiteManager()\n+    gsmBases = globalSiteManager.__bases__\n+    site = getSite()\n+    localSiteManager = portal.getSiteManager()\n+\n+    bases = []\n+    changed = False\n+    for base in localSiteManager.__bases__:\n+        if base is globalSiteManager:\n+            bases.extend(gsmBases)\n+            changed = True\n+        else:\n+            bases.append(base)\n+\n+    if changed:\n+        localSiteManager.__bases__ = tuple(bases)\n+\n+    # Now pop the registry. We need to do it in this somewhat convoluted way\n+    # to avoid the risk of unpickling errors\n+\n+    previous = zca.popGlobalRegistry()\n+\n+    if site is not None:\n+        setHooks()\n+        setSite(site)\n+\n+    return previous\n+\n+\n+def persist_profile_upgrade_versions(portal):\n+    """Persist the profile_upgrade_versions of portal_setup.\n+\n+    Until at least Products.GenericSetup 1.8.3 this is a standard\n+    non-persistent dictionary, which means a transaction rollback does\n+    not rollback changes to this dictionary.  So we make it a persistent\n+    mapping.  Call this once in layer setup and you have easy rollback.\n+    """\n+    from persistent.mapping import PersistentMapping\n+    puv = portal.portal_setup._profile_upgrade_versions\n+    if isinstance(puv, PersistentMapping):\n+        return\n+    portal.portal_setup._profile_upgrade_versions = PersistentMapping(puv)\n+\n+\n+@contextlib.contextmanager\n+def ploneSite(db=None, connection=None, environ=None):\n+    """Context manager for working with the Plone portal during layer setup::\n+\n+        with ploneSite() as portal:\n+            ...\n+\n+    This is based on the ``z2.zopeApp()`` context manager. See the module\n+     ``plone.testing.z2`` for details.\n+\n+    Do not use this in a test. Use the \'portal\' resource from the PloneFixture\n+    layer instead!\n+\n+    Pass a ZODB handle as ``db`` to use a specificdatabase. Alternatively,\n+    pass an open connection as ``connection`` (the connection will not be\n+    closed).\n+    """\n+    setHooks()\n+    site = getSite()\n+\n+    with z2.zopeApp(db, connection, environ) as app:\n+        portal = app[PLONE_SITE_ID]\n+\n+        setSite(portal)\n+        login(portal, TEST_USER_NAME)\n+\n+        try:\n+            yield portal\n+        finally:\n+            logout()\n+            if site is not portal:\n+                setSite(site)\n+\n+\n+# Layer base class\n+\n+\n+class PloneSandboxLayer(Layer):\n+    """Layer base class managing the common pattern of having a stacked ZODB\n+    ``DemoStorage`` and a stacked global component registry for the layer.\n+\n+    Base classes must override and implemented ``setUpPloneSite()``. They\n+    may also implement ``tearDownPloneSite()``, and can optionally change\n+    the ``defaultBases`` tuple.\n+    """\n+\n+    # The default list of bases.\n+\n+    defaultBases = (layers.PLONE_FIXTURE, )\n+\n+    # Hooks\n+\n+    def setUpZope(self, app, configurationContext):\n+        """Set up Zope.\n+\n+        ``app`` is the Zope application root.\n+\n+        ``configurationContext`` is the ZCML configuration context.\n+\n+        This is the most appropriate place to load ZCML or install Zope 2-\n+        style products, using the ``plone.testing.z2.installProduct`` helper.\n+        """\n+        pass\n+\n+    def tearDownZope(self, app):\n+        """Tear down Zope.\n+\n+        ``app`` is the Zope application root.\n+\n+        This is the most appropriate place to uninstall Zope 2-style products\n+        using the ``plone.testing.z2.uninstallProduct`` helper.\n+        """\n+        pass\n+\n+    def setUpPloneSite(self, portal):\n+        """Set up the Plone site.\n+\n+        ``portal`` is the Plone site. Provided no exception is raised, changes\n+        to this site will be committed (into a newly stacked ``DemoStorage``).\n+\n+        Concrete layer classes should implement this method at a minimum.\n+        """\n+        pass\n+\n+    def tearDownPloneSite(self, portal):\n+        """Tear down the Plone site.\n+\n+        Implementing this is optional. If the changes made during the\n+        ``setUpPloneSite()`` method were confined to the ZODB and the global\n+        component regsitry, those changes will be torn down automatically.\n+        """\n+\n+        pass\n+\n+    # Boilerplate\n+\n+    def setUp(self):\n+        try:\n+            # Push a new database storage so that database changes\n+            # commited during layer setup can be easily torn down\n+            self[\'zodbDB\'] = zodb.stackDemoStorage(self.get(\'zodbDB\'),\n+                                                   name=self.__name__)\n+\n+            # Push a new configuration context so that it\'s possible to\n+            # re-import ZCML files after tear-down\n+            name = self.__name__ if self.__name__ is not None else \'not-named\'\n+            contextName = \'PloneSandboxLayer-{0}\'.format(name)\n+            self[\'configurationContext\'] = configurationContext = (\n+                zca.stackConfigurationContext(self.get(\'configurationContext\'),\n+                                              name=contextName))\n+\n+            with ploneSite() as portal:\n+                setHooks()\n+\n+                # Make sure there\'s no local site manager while we load ZCML\n+                setSite(None)\n+\n+                # Push a new component registry so that ZCML registations\n+                # and other global component registry changes are sandboxed\n+                pushGlobalRegistry(portal)\n+\n+                # Persist GenericSetup profile upgrade versions for easy\n+                # rollback.\n+                persist_profile_upgrade_versions(portal)\n+\n+                # Make sure zope.security checkers can be set up and torn down\n+                # reliably\n+\n+                security.pushCheckers()\n+\n+                from Products.PluggableAuthService.PluggableAuthService import MultiPlugins  # noqa\n+\n+                preSetupMultiPlugins = MultiPlugins[:]\n+\n+                # Allow subclass to load ZCML and products\n+                self.setUpZope(portal.getPhysicalRoot(), configurationContext)\n+\n+                # Allow subclass to configure a persistent fixture\n+                setSite(portal)\n+                self.setUpPloneSite(portal)\n+                setSite(None)\n+\n+            # Keep track of PAS plugins that were added during setup\n+            self.snapshotMultiPlugins(preSetupMultiPlugins)\n+        except Exception:\n+            del self[\'configurationContext\']\n+            self[\'zodbDB\'].close()\n+            del self[\'zodbDB\']\n+            raise\n+\n+    def tearDown(self):\n+\n+        with z2.zopeApp() as app:\n+\n+            portal = app[PLONE_SITE_ID]\n+            setHooks()\n+            setSite(portal)\n+\n+            # Allow subclass to tear down persistent fixture\n+            self.tearDownPloneSite(portal)\n+\n+            setSite(None)\n+\n+            # Make sure zope.security checkers can be set up and torn down\n+            # reliably\n+\n+            security.popCheckers()\n+\n+            # Pop the component registry, thus removing component\n+            # architecture registrations\n+            popGlobalRegistry(portal)\n+\n+            # Remove PAS plugins\n+            self.tearDownMultiPlugins()\n+\n+            # Allow subclass to tear down products\n+            self.tearDownZope(app)\n+\n+        # Zap the configuration context\n+        del self[\'configurationContext\']\n+\n+        # Pop the demo storage, thus restoring the database to the\n+        # previous state\n+        self[\'zodbDB\'].close()\n+        del self[\'zodbDB\']\n+\n+    # Helpers\n+    def applyProfile(self, portal, profileName, purge_old=None,\n+                     ignore_dependencies=False, archive=None,\n+                     blacklisted_steps=None):\n+        return applyProfile(portal, profileName, purge_old,\n+                            ignore_dependencies, archive,\n+                            blacklisted_steps)\n+\n+    def loadZCML(self, name=\'configure.zcml\', **kw):\n+        kw.setdefault(\'context\', self[\'configurationContext\'])\n+        return xmlconfig.file(name, **kw)\n+\n+    def snapshotMultiPlugins(self, preSetupMultiPlugins):\n+        """Save a snapshot of all PAS multi plugins that were added during\n+        setup, by comparing to the list of plugins passed in.\n+        """\n+\n+        self._addedMultiPlugins = set()\n+\n+        from Products.PluggableAuthService.PluggableAuthService import (\n+            MultiPlugins\n+        )\n+\n+        for plugin in MultiPlugins:\n+            if plugin not in preSetupMultiPlugins:\n+                self._addedMultiPlugins.add(plugin)\n+\n+    def tearDownMultiPlugins(self):\n+        """Delete all PAS multi plugins that were added during setup, as\n+        stored by ``snapshotMultiPlugins()``.\n+        """\n+\n+        for pluginName in self._addedMultiPlugins:\n+            tearDownMultiPluginRegistration(pluginName)\n+\n+\n+class PloneWithPackageLayer(PloneSandboxLayer):\n+\n+    def __init__(self, bases=None, name=None, module=None, zcml_filename=None,\n+                 zcml_package=None, gs_profile_id=None,\n+                 additional_z2_products=()):\n+        super(PloneWithPackageLayer, self).__init__(bases, name, module)\n+        self.zcml_filename = zcml_filename\n+        self.zcml_package = zcml_package\n+        self.gs_profile_id = gs_profile_id\n+        self.additional_z2_products = additional_z2_products\n+\n+    def setUpZope(self, app, configurationContext):\n+        """Set up Zope.\n+\n+        Only load ZCML files.\n+        """\n+        self.setUpZCMLFiles()\n+        for z2Product in self.additional_z2_products:\n+            z2.installProduct(app, z2Product)\n+\n+    def setUpZCMLFiles(self):\n+        """Load default ZCML.\n+\n+        Can be overridden to load more ZCML.\n+        """\n+        if self.zcml_filename is None:\n+            raise ValueError(\'ZCML file name has not been provided.\')\n+        if self.zcml_package is None:\n+            raise ValueError(\n+                \'The package that contains the ZCML file \'\n+                \'has not been provided.\'\n+            )\n+        self.loadZCML(self.zcml_filename, package=self.zcml_package)\n+\n+    def setUpPloneSite(self, portal):\n+        """Set up the Plone site.\n+\n+        Only install GenericSetup profiles\n+        """\n+        self.applyProfiles(portal)\n+\n+    def applyProfiles(self, portal):\n+        """Install default profile.\n+\n+        Can be overridden to install more profiles.\n+        """\n+        if self.gs_profile_id is not None:\n+            self.applyProfile(portal, self.gs_profile_id)\ndiff --git a/src/plone/app/testing/helpers.rst b/src/plone/app/testing/helpers.rst\nnew file mode 100644\nindex 0000000..a67bd2f\n--- /dev/null\n+++ b/src/plone/app/testing/helpers.rst\n@@ -0,0 +1,482 @@\n+Plone testing helpers\n+---------------------\n+\n+This package contains various test helpers that are useful for writing custom\n+layers using layers that are based on the ``PLONE_FIXTURE`` layer, and for\n+writing tests using such layers.\n+\n+The helpers are all importable from ``plone.app.testing`` directly, or from\n+their canonical locations at ``plone.app.testing.helpers``.\n+\n+    >>> from plone.app.testing import helpers\n+\n+For testing, we need a testrunner\n+\n+    >>> from zope.testrunner import runner\n+\n+Let\'s create a custom fixture layer that exercises these helpers. In this\n+layer, we will perform the following setup:\n+\n+1. Stack a new ``DemoStorage`` on top of the one from the base layer. This\n+   ensures that any persistent changes performed in this layer can be torn\n+   down completely, simply by popping the demo storage.\n+\n+2. Stack a new ZCML configuration context. This keeps separate the information\n+   about which ZCML files were loaded, in case other, independent layers want\n+   to load those same files after this layer has been torn down.\n+\n+3. Push a new global component registry. This allows us to register components\n+   (e.g. by loading ZCML or using the test API from ``zope.component``) and\n+   tear down those registration easily by popping the component registry.\n+   We pass the portal so that the local component site manager can be\n+   configured appropriately.\n+\n+   *Note:* We obtain the portal from the ``ploneSite()`` context manager,\n+   which will ensure that the portal is properly set up and commit our changes\n+   on exiting the ``with`` block.\n+\n+4. Make some persistent changes, to illustrate how these are torn down when\n+   we pop the ZODB ``DemoStorage``.\n+\n+5. Install a product using the ``get_installer`` view (or the old ``portal_quickinstaller`` tool).\n+\n+6. Apply a named extension profile.\n+\n+On tear-down, we only need to pop the ``DemoStorage`` (to roll back all\n+persistent changes), the configuration context (to "forget" which files were\n+loaded and so allow them to be loaded again in other layers), and the stacked\n+component registry (to roll back all global component registrations). Of\n+course, if our setup had changed any other global or external state, we would\n+need to tear that down as well.\n+\n+    >>> def is_installed(portal, product_name):\n+    ...     try:\n+    ...         from Products.CMFPlone.utils import get_installer\n+    ...     except ImportError:\n+    ...         # BBB For Plone 5.0 and lower.\n+    ...         qi = portal[\'portal_quickinstaller\']\n+    ...         return qi.isProductInstalled(product_name)\n+    ...     else:\n+    ...         qi = get_installer(portal)\n+    ...         return qi.is_product_installed(product_name)\n+\n+    >>> from plone.testing import Layer\n+    >>> from plone.testing import zca, z2, zodb\n+\n+    >>> from plone.app.testing import PLONE_FIXTURE\n+    >>> from plone.app.testing import IntegrationTesting\n+\n+    >>> class HelperDemos(Layer):\n+    ...     defaultBases = (PLONE_FIXTURE,)\n+    ...\n+    ...     def setUp(self):\n+    ...\n+    ...         # Push a new database storage so that database changes\n+    ...         # commited during layer setup can be easily torn down\n+    ...         self[\'zodbDB\'] = zodb.stackDemoStorage(self.get(\'zodbDB\'), name=\'HelperDemos\')\n+    ...\n+    ...         # Push a new configuration context so that it\'s possible to re-import\n+    ...         # ZCML files after tear-down\n+    ...         self[\'configurationContext\'] = zca.stackConfigurationContext(self.get(\'configurationContext\'))\n+    ...\n+    ...         with helpers.ploneSite() as portal:\n+    ...\n+    ...             # Persist GenericSetup profile upgrade versions for easy rollback.\n+    ...             helpers.persist_profile_upgrade_versions(portal)\n+    ...\n+    ...             # First register dummy default and uninstall profiles for plone.app.testing.\n+    ...             # We will use this to test that after teardown the installed profile versions get reset.\n+    ...             # We used to test this with plone.resource, but that is already installed by default,\n+    ...             # which makes it a pain to test with.\n+    ...             from Products.GenericSetup.registry import _profile_registry\n+    ...             from Products.GenericSetup.interfaces import EXTENSION\n+    ...             # \'profile\' points to a path with a metadata.xml so we can have a version.\n+    ...             _profile_registry.registerProfile(\'default\', u"Testing", u"", "profile", \'plone.app.testing\', EXTENSION)\n+    ...             _profile_registry.registerProfile(\'uninstall\', u"Testing uninstall", u"", "profile", \'plone.app.testing\', EXTENSION)\n+    ...\n+    ...             # Push a new component registry so that ZCML registations\n+    ...             # and other global component registry changes are sandboxed\n+    ...             helpers.pushGlobalRegistry(portal)\n+    ...\n+    ...             # Register some components\n+    ...             from zope.component import provideUtility\n+    ...             from zope.interface import Interface\n+    ...             provideUtility(object(), Interface, name=u"dummy1")\n+    ...\n+    ...             # Make some persistent changes\n+    ...             portal.title = u"New title"\n+    ...\n+    ...             # Install a product using portal_quickinstaller\n+    ...             helpers.quickInstallProduct(portal, \'plone.app.testing\')\n+    ...             assert is_installed(portal, \'plone.app.testing\')\n+    ...\n+    ...     def tearDown(self):\n+    ...\n+    ...         # Pop the component registry, thus removing component\n+    ...         # architecture registrations\n+    ...         with helpers.ploneSite() as portal:\n+    ...             helpers.popGlobalRegistry(portal)\n+    ...\n+    ...         # Pop the configuration context\n+    ...         del self[\'configurationContext\']\n+    ...\n+    ...         # Pop the demo storage, thus restoring the database to the\n+    ...         # previous state\n+    ...         self[\'zodbDB\'].close()\n+    ...         del self[\'zodbDB\']\n+\n+With the layer class defined, we can instantiate a fixture base layer, and\n+an "end user" layer with test lifecycle management. Here, we will use the\n+``IntegrationTesting`` layer class from ``plone.app.testing``.\n+\n+    >>> HELPER_DEMOS_FIXTURE = HelperDemos()\n+    >>> HELPER_DEMOS_INTEGRATION_TESTING = IntegrationTesting(bases=(HELPER_DEMOS_FIXTURE,), name="HelperDemos:Integration")\n+\n+Let\'s now simulate layer setup:\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, HELPER_DEMOS_INTEGRATION_TESTING, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+      Set up plone.testing.z2.Startup in ... seconds.\n+      Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+      Set up HelperDemos in ... seconds.\n+      Set up plone.app.testing.layers.HelperDemos:Integration in ... seconds.\n+\n+We should see the newly registered components and the persistent changes\n+having taken effect.\n+\n+    >>> from zope.component import queryUtility\n+    >>> from zope.interface import Interface\n+    >>> queryUtility(Interface, name="dummy1")\n+    <object object at ...>\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print portal.title\n+    New title\n+\n+We should also see our product installation in the quickinstaller tool\n+and the results of the profile having been applied.\n+\n+    >>> from Products.GenericSetup.tool import UNKNOWN\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print is_installed(portal, \'plone.app.testing\')\n+    ...     portal.portal_setup.getLastVersionForProfile(\'plone.app.testing:default\') == UNKNOWN\n+    True\n+    False\n+\n+Let\'s now simulate a test.\n+\n+    >>> zca.LAYER_CLEANUP.testSetUp()\n+    >>> z2.STARTUP.testSetUp()\n+    >>> PLONE_FIXTURE.testSetUp()\n+    >>> HELPER_DEMOS_FIXTURE.testSetUp()\n+    >>> HELPER_DEMOS_INTEGRATION_TESTING.testSetUp()\n+\n+In a test, we can use helpers to simulate login, logging out and changing a\n+user\'s roles. These may also be used during layer setup if required, using\n+the ``ploneSite()`` context manager as shown above.\n+\n+    >>> from AccessControl import getSecurityManager\n+    >>> from plone.app.testing import TEST_USER_NAME\n+    >>> from plone.app.testing import TEST_USER_ID\n+\n+    >>> portal = HELPER_DEMOS_INTEGRATION_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n+\n+    >>> getSecurityManager().getUser().getRolesInContext(portal)\n+    [\'Member\', \'Authenticated\']\n+\n+    >>> getSecurityManager().getUser().getUserName() == TEST_USER_NAME\n+    True\n+    >>> getSecurityManager().getUser().getId() == TEST_USER_ID\n+    True\n+    >>> sm_repr = repr(getSecurityManager())\n+    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+    >>> repr(getSecurityManager()) != sm_repr\n+    True\n+    >>> getSecurityManager().getUser().getRolesInContext(portal)\n+    [\'Manager\', \'Authenticated\']\n+\n+    >>> helpers.logout()\n+    >>> getSecurityManager().getUser()\n+    <SpecialUser \'Anonymous User\'>\n+\n+    >>> helpers.login(portal, TEST_USER_NAME)\n+    >>> getSecurityManager().getUser().getUserName() == TEST_USER_NAME\n+    True\n+\n+    >>> from OFS.Folder import Folder\n+    >>> portal._setObject(\'folder1\', Folder(\'folder1\'))\n+    \'folder1\'\n+\n+Let\'s now tear down the test.\n+\n+    >>> HELPER_DEMOS_INTEGRATION_TESTING.testTearDown()\n+    >>> HELPER_DEMOS_FIXTURE.testTearDown()\n+    >>> PLONE_FIXTURE.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+    >>> zca.LAYER_CLEANUP.testTearDown()\n+\n+Our persistent changes from the layer should remain, but those made in a test\n+should not.\n+\n+    >>> queryUtility(Interface, name="dummy1")\n+    <object object at ...>\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print portal.title\n+    ...     print is_installed(portal, \'plone.app.testing\')\n+    ...     \'folder1\' in portal.objectIds()\n+    ...     portal.portal_setup.getLastVersionForProfile(\'plone.app.testing:default\') == UNKNOWN\n+    New title\n+    True\n+    False\n+    False\n+\n+We\'ll now tear down just the ``HELPER_DEMOS_INTEGRATION_TESTING`` layer. At this\n+point, we should still have a Plone site, but none of the persistent or\n+component architecture changes from our layer.\n+\n+    >>> runner.tear_down_unneeded(options, [l for l in setupLayers if l not in (HELPER_DEMOS_INTEGRATION_TESTING, HELPER_DEMOS_FIXTURE,)], setupLayers)\n+    Tear down plone.app.testing.layers.HelperDemos:Integration in ... seconds.\n+    Tear down HelperDemos in ... seconds.\n+\n+    >>> queryUtility(Interface, name="dummy1") is None\n+    True\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print portal.title\n+    ...     print is_installed(portal, \'plone.app.testing\')\n+    ...     portal.portal_setup.getLastVersionForProfile(\'plone.app.testing:default\') == UNKNOWN\n+    Plone site\n+    False\n+    True\n+\n+Let\'s tear down the rest of the layers too.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+Plone sandbox layer helper\n+--------------------------\n+\n+The pattern above of setting up a stacked ZODB ``DemoStorage``, configuration\n+context and global component registry is very common. In fact, there is a\n+layer base class which helps implement this pattern.\n+\n+    >>> someGlobal = {}\n+\n+    >>> class MyLayer(helpers.PloneSandboxLayer):\n+    ...\n+    ...     def setUpZope(self, app, configurationContext):\n+    ...\n+    ...         # We\'d often load ZCML here, using the passed-in\n+    ...         # configurationContext as the configuration context.\n+    ...\n+    ...         # Of course, we can also register some components using the\n+    ...         # zope.component API directly\n+    ...         from zope.component import provideUtility\n+    ...         from zope.interface import Interface\n+    ...         provideUtility(object(), Interface, name=u"dummy1")\n+    ...\n+    ...         # We\'ll also add some entries to the GenericSetup global\n+    ...         # registries.\n+    ...         from Products.GenericSetup.registry import _profile_registry\n+    ...         from Products.GenericSetup.registry import _import_step_registry\n+    ...         from Products.GenericSetup.registry import _export_step_registry\n+    ...         from Products.GenericSetup import upgrade\n+    ...\n+    ...         _profile_registry.registerProfile(\'dummy1\', u"My package", u"", ".", \'plone.app.testing\')\n+    ...         _import_step_registry.registerStep(\'import1\', version=1, handler=\'plone.app.testing.tests.dummy\', title=u"Dummy import step", description=u"")\n+    ...         _export_step_registry.registerStep(\'export1\', handler=\'plone.app.testing.tests.dummy\', title=u"Dummy import step", description=u"")\n+    ...         upgrade_step = upgrade.UpgradeStep(u\'Dummy upgrade step\', \'plone.app.testing:default\', \'1000\', \'1001\', \'\', \'plone.app.testing.tests.dummy\')\n+    ...         upgrade._registerUpgradeStep(upgrade_step)\n+    ...\n+    ...         # And then pretend to register a PAS multi-plugin\n+    ...         from Products.PluggableAuthService import PluggableAuthService\n+    ...         PluggableAuthService.registerMultiPlugin("dummy_plugin1")\n+    ...\n+    ...         # Finally, this is a good place to load Zope products,\n+    ...         # using the plone.testing.z2.installProduct() helper.\n+    ...         # Make some other global changes not stored in the ZODB or\n+    ...         # the global component registry\n+    ...         someGlobal[\'test\'] = 1\n+    ...\n+    ...     def tearDownZope(self, app):\n+    ...         # Illustrate tear-down of some global state\n+    ...         del someGlobal[\'test\']\n+    ...\n+    ...     def setUpPloneSite(self, portal):\n+    ...\n+    ...         # We can make persistent changes here\n+    ...         portal.title = u"New title"\n+\n+    >>> MY_FIXTURE = MyLayer()\n+    >>> MY_INTEGRATION_TESTING = IntegrationTesting(bases=(MY_FIXTURE,), name="MyLayer:Integration")\n+\n+Here, we have derived from ``PloneSandboxLayer`` instead of the more usual\n+``Layer`` base class. This layer implements the sandboxing of the ZODB, global\n+component registry, and GenericSetup profile and import/export step registries\n+for us, and delegates to four template methods, all of them optional:\n+\n+* ``setUpZope()``, called with the Zope app root and the ZCML configuration\n+  context as arguments. This is a good place to load ZCML, manipulate global\n+  registries, or install Zope 2-style products using the ``installProduct()``\n+  helper method.\n+* ``setUpPloneSite()``, called with the Plone site object as an argument. This\n+  is a good place to set up persistent aspects of the test fixture, such as\n+  installing products into Plone using the ``quickInstallProduct`` helper or\n+  adding default content.\n+* ``tearDownZope()``, called with the Zope app root as an argument. This is\n+  a good place to tear down global state and uninstall products using the\n+  ``uninstallProduct()`` helper. Note that global components (e.g. loaded via\n+  ZCML) are torn down automatically, as are changes to the global GenericSetup\n+  registries.\n+* ``tearDownPloneSite()``, called with the Plone site object as an argument.\n+  This is not very commonly needed, because persistent changes to the Plone\n+  site are torn down automatically by popping ZODB ``DemoStorage`` created\n+  during set-up. However, it is there if you need it.\n+\n+You may also wish to change the ``defaultBases`` argument. The default is to\n+use ``PLONE_FIXTURE`` as the single default base layer for the fixture class.\n+\n+    >>> MY_FIXTURE.__bases__\n+    (<Layer \'plone.app.testing.layers.PloneFixture\'>,)\n+\n+Let\'s now simulate layer setup:\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, MY_INTEGRATION_TESTING, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+    Set up MyLayer in ... seconds.\n+    Set up plone.app.testing.layers.MyLayer:Integration in ... seconds.\n+\n+Again, our state should now be available.\n+\n+    >>> queryUtility(Interface, name="dummy1")\n+    <object object at ...>\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print portal.title\n+    New title\n+\n+    >>> someGlobal[\'test\']\n+    1\n+\n+    >>> from Products.GenericSetup.registry import _profile_registry\n+    >>> from Products.GenericSetup.registry import _import_step_registry\n+    >>> from Products.GenericSetup.registry import _export_step_registry\n+    >>> from Products.GenericSetup.upgrade import _upgrade_registry\n+\n+    >>> numProfiles = len(_profile_registry.listProfiles())\n+    >>> \'plone.app.testing:dummy1\' in _profile_registry.listProfiles()\n+    True\n+\n+    >>> numImportSteps = len(_import_step_registry.listSteps())\n+    >>> \'import1\' in _import_step_registry.listSteps()\n+    True\n+\n+    >>> numExportSteps = len(_export_step_registry.listSteps())\n+    >>> \'export1\' in _export_step_registry.listSteps()\n+    True\n+\n+    >>> from Products.PluggableAuthService import PluggableAuthService\n+    >>> \'dummy_plugin1\' in PluggableAuthService.MultiPlugins\n+    True\n+\n+    >>> numUpgrades = len(_upgrade_registry.keys())\n+    >>> len(_upgrade_registry.getUpgradeStepsForProfile(\'plone.app.testing:default\'))\n+    1\n+\n+We\'ll now tear down just the ``MY_INTEGRATION_TESTING`` layer. At this\n+point, we should still have a Plone site, but none of the changes from our\n+layer.\n+\n+    >>> runner.tear_down_unneeded(options, [l for l in setupLayers if l not in (MY_INTEGRATION_TESTING, MY_FIXTURE)], setupLayers)\n+    Tear down plone.app.testing.layers.MyLayer:Integration in ... seconds.\n+\n+    >>> queryUtility(Interface, name="dummy1") is None\n+    True\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print portal.title\n+    Plone site\n+\n+    >>> \'test\' in someGlobal\n+    False\n+\n+    >>> len(_profile_registry.listProfiles()) == numProfiles - 1\n+    True\n+    >>> \'plone.app.testing:dummy1\' in _profile_registry.listProfiles()\n+    False\n+\n+    >>> len(_import_step_registry.listSteps()) == numImportSteps - 1\n+    True\n+    >>> \'import1\' in _import_step_registry.listSteps()\n+    False\n+\n+    >>> len(_export_step_registry.listSteps()) == numExportSteps - 1\n+    True\n+    >>> \'export1\' in _export_step_registry.listSteps()\n+    False\n+\n+    >>> len(_upgrade_registry.keys()) == numUpgrades - 1\n+    True\n+    >>> len(_upgrade_registry.getUpgradeStepsForProfile(\'plone.app.testing:default\'))\n+    0\n+\n+    >>> from Products.PluggableAuthService import PluggableAuthService\n+    >>> \'dummy_plugin1\' in PluggableAuthService.MultiPlugins\n+    False\n+\n+Let\'s tear down the rest of the layers too.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+Other helpers\n+-------------\n+\n+There are some further helpers that apply only to special cases.\n+\n+Some product that uses the ``<pas:registerMultiPlugin />`` or the\n+``registerMultiPlugin()`` API from ``PluggableAuthService`` may leave global\n+state that needs to be cleaned up. You can use the helper\n+``tearDownMultiPluginRegistration()`` for this purpose.\n+\n+Let\'s simulate registering some plugins:\n+\n+    >>> from Products.PluggableAuthService import PluggableAuthService\n+    >>> PluggableAuthService.registerMultiPlugin("dummy_plugin1")\n+    >>> PluggableAuthService.registerMultiPlugin("dummy_plugin2")\n+\n+    >>> PluggableAuthService.MultiPlugins\n+    [\'dummy_plugin1\', \'dummy_plugin2\']\n+\n+If we register plugins with ZCML, they end up in a clean-up list - let\'s\n+simulate that too.\n+\n+    >>> from Products.PluggableAuthService import zcml\n+    >>> zcml._mt_regs.append(\'dummy_plugin1\')\n+    >>> zcml._mt_regs.append(\'dummy_plugin2\')\n+\n+The tear down helper takes a plugin meta-type as an argument:\n+\n+    >>> helpers.tearDownMultiPluginRegistration(\'dummy_plugin1\')\n+\n+    >>> PluggableAuthService.MultiPlugins\n+    [\'dummy_plugin2\']\n+\n+    >>> zcml._mt_regs\n+    [\'dummy_plugin2\']\n+\n+Let\'s clean up the registry completely.\n+\n+    >>> helpers.tearDownMultiPluginRegistration(\'dummy_plugin2\')\ndiff --git a/src/plone/app/testing/interfaces.py b/src/plone/app/testing/interfaces.py\nnew file mode 100644\nindex 0000000..781e70b\n--- /dev/null\n+++ b/src/plone/app/testing/interfaces.py\n@@ -0,0 +1,17 @@\n+# -*- coding: utf-8 -*-\n+# Constants for names used in layer setup - also importable from\n+# plone.app.testing directly\n+\n+PLONE_SITE_ID = \'plone\'\n+PLONE_SITE_TITLE = u\'Plone site\'\n+DEFAULT_LANGUAGE = \'en\'\n+\n+TEST_USER_NAME = \'test-user\'\n+TEST_USER_ID = \'test_user_1_\'\n+TEST_USER_PASSWORD = \'secret\'\n+TEST_USER_ROLES = [\'Member\', ]\n+\n+SITE_OWNER_NAME = \'admin\'\n+SITE_OWNER_PASSWORD = \'secret\'\n+\n+ROBOT_TEST_LEVEL = 5\ndiff --git a/src/plone/app/testing/layers.py b/src/plone/app/testing/layers.py\nnew file mode 100644\nindex 0000000..cdc0e81\n--- /dev/null\n+++ b/src/plone/app/testing/layers.py\n@@ -0,0 +1,386 @@\n+# -*- coding: utf-8 -*-\n+# Layers setting up fixtures with a Plone site. Also importable from\n+# plone.app.testing directly\n+\n+from Acquisition import aq_base\n+from plone.app.testing.interfaces import DEFAULT_LANGUAGE\n+from plone.app.testing.interfaces import PLONE_SITE_ID\n+from plone.app.testing.interfaces import PLONE_SITE_TITLE\n+from plone.app.testing.interfaces import SITE_OWNER_NAME\n+from plone.app.testing.interfaces import SITE_OWNER_PASSWORD\n+from plone.app.testing.interfaces import TEST_USER_ID\n+from plone.app.testing.interfaces import TEST_USER_NAME\n+from plone.app.testing.interfaces import TEST_USER_PASSWORD\n+from plone.app.testing.interfaces import TEST_USER_ROLES\n+from plone.app.testing.utils import MockMailHost\n+from plone.testing import Layer\n+from plone.testing import z2\n+from plone.testing import zca\n+from plone.testing import zodb\n+from Products.MailHost.interfaces import IMailHost\n+from zope.component import getSiteManager\n+from zope.component.hooks import setSite\n+from zope.event import notify\n+from zope.traversing.interfaces import BeforeTraverseEvent\n+\n+\n+class PloneFixture(Layer):\n+    """This layer sets up a basic Plone site, with:\n+\n+    * No content\n+    * No default workflow\n+    * One user, as found in the constant ``TEST_USER_ID``, with login name\n+      ``TEST_USER_NAME``, the password ``TEST_USER_PASSWORD``, and a single\n+      role, ``Member``.\n+    """\n+\n+    defaultBases = (z2.STARTUP,)\n+\n+    # Products that will be installed, plus options\n+    products = (\n+        (\'Products.GenericSetup\', {\'loadZCML\': True}, ),\n+        (\'Products.DCWorkflow\', {\'loadZCML\': True}, ),\n+        (\'Products.ZCTextIndex\', {\'loadZCML\': True}, ),\n+        (\'Products.DateRecurringIndex\', {\'loadZCML\': False}, ),\n+        (\'Products.PageTemplates\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFUid\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFCore\', {\'loadZCML\': True}, ),\n+        (\'Products.PluggableAuthService\', {\'loadZCML\': True}, ),\n+        (\'Products.PluginRegistry\', {\'loadZCML\': True}, ),\n+        (\'Products.PlonePAS\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFFormController\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFDynamicViewFTI\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFPlacefulWorkflow\', {\'loadZCML\': True}, ),\n+        (\'Products.MimetypesRegistry\', {\'loadZCML\': True}, ),\n+        (\'Products.PortalTransforms\', {\'loadZCML\': True}, ),\n+        (\'Products.ExternalEditor\', {\'loadZCML\': True}, ),\n+        (\'Products.ExtendedPathIndex\', {\'loadZCML\': True}, ),\n+        (\'Products.ResourceRegistries\', {\'loadZCML\': True}, ),\n+        (\'Products.SiteAccess\', {\'loadZCML\': False}, ),\n+        (\'Products.CMFEditions\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFDiffTool\', {\'loadZCML\': True}, ),\n+        (\'plone.i18n\', {\'loadZCML\': True, \'install\': False}, ),\n+        (\'plonetheme.barceloneta\', {\'loadZCML\': True, \'install\': False}, ),\n+        (\'plone.app.folder\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFPlone\', {\'loadZCML\': True}, ),\n+        (\'Products.PythonScripts\', {\'loadZCML\': False}, ),\n+    )\n+\n+    #try:\n+    #    import Products.PasswordResetTool\n+    #    products = products + (\n+    #        (\'Products.PasswordResetTool\', {\'loadZCML\': True}, ),)\n+    #except ImportError:\n+    #    pass\n+    #try:\n+    #    import Products.CMFQuickInstallerTool\n+    #    products = products + (\n+    #        (\'Products.CMFQuickInstallerTool\', {\'loadZCML\': True}, ),)\n+    #except ImportError:\n+    #    pass\n+\n+    # Extension profiles to be installed with site setup\n+    extensionProfiles = (\n+        \'plonetheme.barceloneta:default\',\n+    )\n+\n+    # Layer lifecycle\n+\n+    def setUp(self):\n+\n+        # Stack a new DemoStorage on top of the one from z2.STARTUP.\n+        self[\'zodbDB\'] = zodb.stackDemoStorage(\n+            self.get(\'zodbDB\'),\n+            name=\'PloneFixture\'\n+        )\n+\n+        self.setUpZCML()\n+\n+        # Set up products and the default content\n+        with z2.zopeApp() as app:\n+            self.setUpProducts(app)\n+            self.setUpDefaultContent(app)\n+\n+    def tearDown(self):\n+\n+        # Tear down products\n+        with z2.zopeApp() as app:\n+            # note: content tear-down happens by squashing the ZODB\n+            self.tearDownProducts(app)\n+\n+        self.tearDownZCML()\n+\n+        # Zap the stacked ZODB\n+        self[\'zodbDB\'].close()\n+        del self[\'zodbDB\']\n+\n+    def setUpZCML(self):\n+        """Stack a new global registry and load ZCML configuration of Plone\n+        and the core set of add-on products into it. Also set the\n+        ``disable-autoinclude`` ZCML feature so that Plone does not attempt to\n+        auto-load ZCML using ``z3c.autoinclude``.\n+        """\n+\n+        # Create a new global registry\n+        zca.pushGlobalRegistry()\n+\n+        from zope.configuration import xmlconfig\n+        self[\'configurationContext\'] = context = zca.stackConfigurationContext(\n+            self.get(\'configurationContext\')\n+        )\n+\n+        # Turn off z3c.autoinclude\n+\n+        xmlconfig.string("""\\\n+<configure xmlns="http://namespaces.zope.org/zope"\n+           xmlns:meta="http://namespaces.zope.org/meta">\n+    <meta:provides feature="disable-autoinclude" />\n+</configure>\n+""", context=context)\n+\n+        # Load dependent products\'s ZCML - Plone doesn\'t specify dependencies\n+        # on Products.* packages fully\n+\n+        from zope.dottedname.resolve import resolve\n+\n+        def loadAll(filename):\n+            for p, config in self.products:\n+                if not config[\'loadZCML\']:\n+                    continue\n+                try:\n+                    package = resolve(p)\n+                except ImportError:\n+                    continue\n+                try:\n+                    xmlconfig.file(filename, package, context=context)\n+                except IOError:\n+                    pass\n+\n+        loadAll(\'meta.zcml\')\n+        loadAll(\'configure.zcml\')\n+        loadAll(\'overrides.zcml\')\n+\n+    def tearDownZCML(self):\n+        """Pop the global component registry stack, effectively unregistering\n+        all global components registered during layer setup.\n+        """\n+        # Pop the global registry\n+        zca.popGlobalRegistry()\n+\n+        # Zap the stacked configuration context\n+        del self[\'configurationContext\']\n+\n+    def setUpProducts(self, app):\n+        """Install all old-style products listed in the the ``products`` tuple\n+        of this class.\n+        """\n+\n+        for p, config in self.products:\n+            if config.get(\'install\', True):\n+                z2.installProduct(app, p)\n+\n+    def tearDownProducts(self, app):\n+        """Uninstall all old-style products listed in the the ``products``\n+        tuple of this class.\n+        """\n+        for p, config in reversed(self.products):\n+            if config.get(\'install\', True):\n+                z2.uninstallProduct(app, p)\n+\n+        # Clean up Wicked turds\n+        # XXX: This may tear down too much state\n+        try:\n+            from wicked.fieldevent import meta\n+            meta.cleanUp()\n+        except ImportError:\n+            pass\n+\n+    def setUpDefaultContent(self, app):\n+        """Add the site owner user to the root user folder and log in as that\n+        user. Create the Plone site, installing the extension profiles listed\n+        in the ``extensionProfiles`` layer class variable. Create the test\n+        user inside the site, and disable the default workflow.\n+\n+        Note: There is no explicit tear-down of this setup operation, because\n+        all persistent changes are torn down when the stacked ZODB\n+        ``DemoStorage`` is popped.\n+        """\n+\n+        # Create the owner user and "log in" so that the site object gets\n+        # the right ownership information\n+        app[\'acl_users\'].userFolderAddUser(\n+            SITE_OWNER_NAME,\n+            SITE_OWNER_PASSWORD,\n+            [\'Manager\'],\n+            []\n+        )\n+\n+        z2.login(app[\'acl_users\'], SITE_OWNER_NAME)\n+\n+        # Create the site with the default set of extension profiles\n+        from Products.CMFPlone.factory import addPloneSite\n+        addPloneSite(\n+            app,\n+            PLONE_SITE_ID,\n+            title=PLONE_SITE_TITLE,\n+            setup_content=False,\n+            default_language=DEFAULT_LANGUAGE,\n+            extension_ids=self.extensionProfiles,\n+        )\n+\n+        # Turn off default workflow\n+        app[PLONE_SITE_ID][\'portal_workflow\'].setDefaultChain(\'\')\n+\n+        # Create the test user. (Plone)PAS does not have an API to create a\n+        # user with different userid and login name, so we call the plugin\n+        # directly.\n+        pas = app[PLONE_SITE_ID][\'acl_users\']\n+        pas.source_users.addUser(\n+            TEST_USER_ID,\n+            TEST_USER_NAME,\n+            TEST_USER_PASSWORD\n+        )\n+        for role in TEST_USER_ROLES:\n+            pas.portal_role_manager.doAssignRoleToPrincipal(TEST_USER_ID, role)\n+\n+        # Log out again\n+        z2.logout()\n+\n+\n+# Plone fixture layer instance. Should not be used on its own, but as a base\n+# for other layers.\n+PLONE_FIXTURE = PloneFixture()\n+\n+\n+class PloneTestLifecycle(object):\n+    """Mixin class for Plone test lifecycle. This exposes the ``portal``\n+    resource and resets the environment between each test.\n+\n+    This class is used as a mixing for the IntegrationTesting and\n+    FunctionalTesting classes below, which also mix in the z2 versions of\n+    the same.\n+    """\n+\n+    defaultBases = (PLONE_FIXTURE,)\n+\n+    def testSetUp(self):\n+        super(PloneTestLifecycle, self).testSetUp()\n+\n+        self[\'portal\'] = portal = self[\'app\'][PLONE_SITE_ID]\n+        self.setUpEnvironment(portal)\n+\n+    def testTearDown(self):\n+        self.tearDownEnvironment(self[\'portal\'])\n+        del self[\'portal\']\n+\n+        super(PloneTestLifecycle, self).testTearDown()\n+\n+    def setUpEnvironment(self, portal):\n+        """Set up the local component site, reset skin data and log in as\n+        the test user.\n+        """\n+\n+        # Set up the local site manager\n+        setSite(portal)\n+\n+        # Reset skin data\n+        portal.clearCurrentSkin()\n+        portal.setupCurrentSkin(portal.REQUEST)\n+        notify(BeforeTraverseEvent(portal, portal.REQUEST))\n+\n+        # Pseudo-login as the test user\n+        from plone.app.testing import helpers\n+        helpers.login(portal, TEST_USER_NAME)\n+\n+    def tearDownEnvironment(self, portal):\n+        """Log out, invalidate standard RAM caches, and unset the local\n+        component site to clean up after tests.\n+        """\n+\n+        # Clear the security manager\n+        from plone.app.testing import helpers\n+        helpers.logout()\n+\n+        # Clear any cached data using plone.memoize\'s RAM caches\n+        from plone.memoize.ram import global_cache\n+        global_cache.invalidateAll()\n+\n+        from zope.component import queryUtility\n+        from plone.memoize.ram import IRAMCache\n+        cache = queryUtility(IRAMCache)\n+        if cache and getattr(cache, \'_cacheId\', None):\n+            cache.invalidateAll()\n+\n+        # Unset the local component site\n+        setSite(None)\n+\n+\n+class MockMailHostLayer(Layer):\n+    """Layer for setting up a MockMailHost to store all sent messages as\n+    strings into a list at portal.MailHost.messages\n+    """\n+    defaultBases = (PLONE_FIXTURE,)\n+\n+    def setUp(self):\n+        with z2.zopeApp() as app:\n+            portal = app[PLONE_SITE_ID]\n+            portal.email_from_address = \'noreply@example.com\'\n+            portal.email_from_name = \'Plone Site\'\n+            portal._original_MailHost = portal.MailHost\n+            portal.MailHost = mailhost = MockMailHost(\'MailHost\')\n+            portal.MailHost.smtp_host = \'localhost\'\n+            sm = getSiteManager(context=portal)\n+            sm.unregisterUtility(provided=IMailHost)\n+            sm.registerUtility(mailhost, provided=IMailHost)\n+\n+    def tearDown(self):\n+        with z2.zopeApp() as app:\n+            portal = app[PLONE_SITE_ID]\n+            _o_mailhost = getattr(portal, \'_original_MailHost\', None)\n+            if _o_mailhost:\n+                portal.MailHost = portal._original_MailHost\n+                sm = getSiteManager(context=portal)\n+                sm.unregisterUtility(provided=IMailHost)\n+                sm.registerUtility(\n+                    aq_base(portal._original_MailHost),\n+                    provided=IMailHost\n+                )\n+\n+\n+MOCK_MAILHOST_FIXTURE = MockMailHostLayer()\n+\n+\n+class IntegrationTesting(PloneTestLifecycle, z2.IntegrationTesting):\n+    """Plone version of the integration testing layer\n+    """\n+\n+\n+class FunctionalTesting(PloneTestLifecycle, z2.FunctionalTesting):\n+    """Plone version of the functional testing layer\n+    """\n+\n+#\n+# Layer instances\n+#\n+# Note: PLONE_FIXTURE is defined above\n+\n+\n+PLONE_INTEGRATION_TESTING = IntegrationTesting(\n+    bases=(PLONE_FIXTURE, ),\n+    name=\'Plone:Integration\'\n+)\n+\n+PLONE_FUNCTIONAL_TESTING = FunctionalTesting(\n+    bases=(PLONE_FIXTURE, ),\n+    name=\'Plone:Functional\'\n+)\n+\n+PLONE_ZSERVER = FunctionalTesting(\n+    bases=(PLONE_FIXTURE, z2.ZSERVER_FIXTURE),\n+    name=\'Plone:ZServer\'\n+)\n+\n+PLONE_FTP_SERVER = FunctionalTesting(\n+    bases=(PLONE_FIXTURE, z2.FTP_SERVER_FIXTURE),\n+    name=\'Plone:FTPServer\'\n+)\ndiff --git a/src/plone/app/testing/layers.rst b/src/plone/app/testing/layers.rst\nnew file mode 100644\nindex 0000000..9e65987\n--- /dev/null\n+++ b/src/plone/app/testing/layers.rst\n@@ -0,0 +1,495 @@\n+Plone testing layers\n+--------------------\n+\n+There are various layers used to set up test fixtures containing a Plone\n+site. They are all importable from ``plone.app.testing`` directly, or from\n+their canonical locations at ``plone.app.testing.layers``.\n+\n+    >>> from plone.app.testing import layers\n+\n+For testing, we need a testrunner\n+\n+    >>> from zope.testrunner import runner\n+\n+\n+Plone site fixture\n+~~~~~~~~~~~~~~~~~~\n+\n+The ``PLONE_FIXTURE`` layer extends ``STARTUP`` from ``plone.testing.z2`` to\n+set up a Plone site.\n+\n+**Note:** This layer should only be used as a base layer, and not directly in\n+tests, since it does not manage the test lifecycle. To run a simple\n+integration test with this fixture, use the ``PLONE_INTEGRATION_TESTING``\n+layer described below. To run a simple functional test, use the\n+``PLONE_FUNCTIONAL_TESTING`` layer. Both of these have ``PLONE_FIXTURE`` as\n+a base. You can also extend ``PLONE_FIXTURE`` with your own fixture layer,\n+instantiating the ``IntegrationTesting`` or ``FunctionalTesting``classes\n+as appropriate. See this package\'s ``README`` file for details.\n+\n+On layer setup, a new ``DemoStorage`` is stacked on top of the ``zodbDB``\n+resource (see ``plone.testing.zodb``). A fresh Plone with no default content\n+is created and added to the application root in this storage. The various\n+old-style products that Plone depends on are loaded, as is Plone\'s ZCML and\n+that of its direct dependencies. Before loading any ZCML, a new global\n+component registry is stacked on top of the default one (see\n+``plone.testing.zca``).\n+\n+**Note**: A ZCML feature ``disable-autoinclude`` is set before Plone\'s ZCML is\n+loaded. This means that Plone will *not* automatically load the ZCML of\n+installed packages that use the ``z3c.autoinclude.plugin`` entry point. If you\n+want to use such packages, you should load their configuration explicitly.\n+\n+Let\'s set up the fixture layer and inspect the state of the site.\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, layers.PLONE_FIXTURE, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+\n+The application root\'s ``acl_users`` folder will have one user, whose name and\n+password are found in the constants ``SITE_OWNER_NAME`` and\n+``SITE_OWNER_PASSWORD``, in ``plone.app.testing.interfaces``. This user\n+has the ``Manager`` role, and is the owner of the site object. You should not\n+normally use this for testing, unless you need to manipulate the site itself.\n+\n+    >>> from plone.testing import z2, zca\n+    >>> from plone.app.testing.interfaces import SITE_OWNER_NAME\n+\n+    >>> with z2.zopeApp() as app:\n+    ...     print app[\'acl_users\'].getUser(SITE_OWNER_NAME)\n+    ...     print app[\'acl_users\'].getUser(SITE_OWNER_NAME).getRolesInContext(app)\n+    admin\n+    [\'Manager\', \'Authenticated\']\n+\n+Inside the Plone site, the default theme is installed\n+\n+    >>> from plone.app.testing import helpers\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print portal[\'portal_registry\'][\'plone.app.theming.interfaces.IThemeSettings.rules\']\n+    /++theme++barceloneta/rules.xml\n+\n+**Note:** Here, we have used the ``ploneSite`` context manager to get hold of\n+the Plone site root. Like ``z2.zopeApp()``, this is intended for use during\n+layer setup and tear-down, and will automatically commit any changes unless an\n+error is raised.\n+\n+There is one user, whose user id, login name name and password are found in the\n+constants ``TEST_USER_ID``, ``TEST_USER_NAME`` and ``TEST_USER_PASSWORD`` in\n+the module ``plone.app.testing.interfaces``.\n+\n+    >>> from plone.app.testing.interfaces import TEST_USER_NAME\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getId()\n+    ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getUserName()\n+    ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getRolesInContext(portal)\n+    test_user_1_\n+    test-user\n+    [\'Member\', \'Authenticated\']\n+\n+There is no default workflow or content:\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print portal[\'portal_workflow\'].getDefaultChain()\n+    ()\n+\n+Layer tear-down resets the environment.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+Integration testing\n+~~~~~~~~~~~~~~~~~~~\n+\n+``PLONE_INTEGRATION_TESTING`` can be used to run integration tests against the\n+fixture set up by the ``PLONE_FIXTURE`` layer.\n+\n+    >>> "%s.%s" % (layers.PLONE_INTEGRATION_TESTING.__module__, layers.PLONE_INTEGRATION_TESTING.__name__,)\n+    \'plone.app.testing.layers.Plone:Integration\'\n+\n+    >>> layers.PLONE_INTEGRATION_TESTING.__bases__\n+    (<Layer \'plone.app.testing.layers.PloneFixture\'>,)\n+\n+Let\'s set up the layers and attempt to run a test.\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, layers.PLONE_INTEGRATION_TESTING, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+    Set up plone.app.testing.layers.Plone:Integration in ... seconds.\n+\n+Let\'s now simulate a test\n+\n+    >>> zca.LAYER_CLEANUP.testSetUp()\n+    >>> z2.STARTUP.testSetUp()\n+    >>> layers.PLONE_FIXTURE.testSetUp()\n+    >>> layers.PLONE_INTEGRATION_TESTING.testSetUp()\n+\n+The portal is available as the resource ``portal``:\n+\n+    >>> layers.PLONE_INTEGRATION_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n+    <PloneSite at /plone>\n+\n+The local component site is set to the Plone site for the test:\n+\n+    >>> from zope.component import getSiteManager\n+    >>> getSiteManager()\n+    <PersistentComponents /plone>\n+\n+During the test, we are logged in as the test user:\n+\n+    >>> from AccessControl import getSecurityManager\n+    >>> getSecurityManager().getUser()\n+    <PloneUser \'test-user\'>\n+\n+A new transaction is begun and aborted for each test, so we can create\n+content safely (so long as we don\'t commit):\n+\n+    >>> from plone.app.testing.interfaces import TEST_USER_ID\n+    >>> portal = layers.PLONE_INTEGRATION_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n+    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+    >>> from OFS.SimpleItem import SimpleItem\n+    >>> portal._setObject(\'d1\', SimpleItem(\'d1\'))\n+    \'d1\'\n+    >>> \'d1\' in portal.objectIds()\n+    True\n+\n+Let\'s now simulate test tear-down.\n+\n+    >>> layers.PLONE_INTEGRATION_TESTING.testTearDown()\n+    >>> layers.PLONE_FIXTURE.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+    >>> zca.LAYER_CLEANUP.testTearDown()\n+\n+At this point, our transaction has been rolled back:\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     \'d1\' in portal.objectIds()\n+    False\n+\n+We are also logged out again:\n+\n+    >>> getSecurityManager().getUser()\n+    <SpecialUser \'Anonymous User\'>\n+\n+And the component site has been reset:\n+\n+    >>> getSiteManager()\n+    <BaseGlobalComponents test-stack-2>\n+\n+Layer tear-down resets the environment.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.layers.Plone:Integration in ... seconds.\n+    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+Functional testing\n+~~~~~~~~~~~~~~~~~~\n+\n+``PLONE_FUNCTIONAL_TESTING`` can be used to run functional tests against the\n+fixture set up by the ``PLONE_FIXTURE`` layer.\n+\n+    >>> "%s.%s" % (layers.PLONE_FUNCTIONAL_TESTING.__module__, layers.PLONE_FUNCTIONAL_TESTING.__name__,)\n+    \'plone.app.testing.layers.Plone:Functional\'\n+\n+    >>> layers.PLONE_FUNCTIONAL_TESTING.__bases__\n+    (<Layer \'plone.app.testing.layers.PloneFixture\'>,)\n+\n+Let\'s set up the layers and attempt to run a test.\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, layers.PLONE_FUNCTIONAL_TESTING, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+    Set up plone.app.testing.layers.Plone:Functional in ... seconds.\n+\n+Let\'s now simulate a test\n+\n+    >>> zca.LAYER_CLEANUP.testSetUp()\n+    >>> z2.STARTUP.testSetUp()\n+    >>> layers.PLONE_FIXTURE.testSetUp()\n+    >>> layers.PLONE_FUNCTIONAL_TESTING.testSetUp()\n+\n+    >>> layers.PLONE_FUNCTIONAL_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n+    <PloneSite at /plone>\n+\n+    >>> from zope.component import getSiteManager\n+    >>> getSiteManager()\n+    <PersistentComponents /plone>\n+\n+    >>> from AccessControl import getSecurityManager\n+    >>> getSecurityManager().getUser()\n+    <PloneUser \'test-user\'>\n+\n+A new ``DemoStorage`` is stacked for each test, so we can safely commit during\n+test execution.\n+\n+    >>> portal = layers.PLONE_FUNCTIONAL_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n+    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+    >>> portal._setObject(\'d1\', SimpleItem(\'d1\'))\n+    \'d1\'\n+    >>> import transaction; transaction.commit()\n+    >>> \'d1\' in portal.objectIds()\n+    True\n+\n+Let\'s now simulate test tear-down.\n+\n+    >>> layers.PLONE_FUNCTIONAL_TESTING.testTearDown()\n+    >>> layers.PLONE_FIXTURE.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+    >>> zca.LAYER_CLEANUP.testTearDown()\n+\n+The previous database state should have been restored.\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     \'d1\' in portal.objectIds()\n+    False\n+\n+Along with the rest of the state:\n+\n+    >>> getSecurityManager().getUser()\n+    <SpecialUser \'Anonymous User\'>\n+\n+    >>> getSiteManager()\n+    <BaseGlobalComponents test-stack-2>\n+\n+Layer tear-down resets the environment.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.layers.Plone:Functional in ... seconds.\n+    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+HTTP server\n+~~~~~~~~~~~\n+\n+The ``PLONE_ZSERVER`` layer instantiates the ``FunctionalTesting`` class with\n+two bases: ``PLONE_FIXTURE``, as shown above, and ``ZSERVER_FIXTURE`` from\n+``plone.testing``, which starts up a ZServer thread.\n+\n+    >>> "%s.%s" % (layers.PLONE_ZSERVER.__module__, layers.PLONE_ZSERVER.__name__,)\n+    \'plone.app.testing.layers.Plone:ZServer\'\n+\n+    >>> layers.PLONE_ZSERVER.__bases__\n+    (<Layer \'plone.app.testing.layers.PloneFixture\'>, <Layer \'plone.testing.z2.ZServer\'>)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, layers.PLONE_ZSERVER, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+    Set up plone.testing.z2.ZServer in ... seconds.\n+    Set up plone.app.testing.layers.Plone:ZServer in ... seconds.\n+\n+After layer setup, the resources ``host`` and ``port`` are available, and\n+indicate where Zope is running.\n+\n+    >>> host = layers.PLONE_ZSERVER[\'host\']\n+    >>> host\n+    \'localhost\'\n+\n+    >>> port = layers.PLONE_ZSERVER[\'port\']\n+    >>> import os\n+    >>> port == int(os.environ.get(\'ZSERVER_PORT\', 55001))\n+    True\n+\n+Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n+do.\n+\n+    >>> zca.LAYER_CLEANUP.testSetUp()\n+    >>> z2.STARTUP.testSetUp()\n+    >>> layers.PLONE_FIXTURE.testSetUp()\n+    >>> z2.ZSERVER_FIXTURE.testSetUp()\n+    >>> layers.PLONE_ZSERVER.testSetUp()\n+\n+It is common in a test to use the Python API to change the state of the server\n+(e.g. create some content or change a setting) and then use the HTTP protocol\n+to look at the results. Bear in mind that the server is running in a separate\n+thread, with a separate security manager, so calls to ``helpers.login()`` and\n+``helpers.logout()``, for instance, do not affect the server thread.\n+\n+    >>> portal = layers.PLONE_ZSERVER[\'portal\'] # would normally be self.layer[\'portal\']\n+    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+    >>> portal.title = \'Fancy Portal\'\n+\n+Note that we need to commit the transaction before it will show up in the\n+other thread.\n+\n+    >>> import transaction; transaction.commit()\n+\n+We can now look for this new object through the server.\n+\n+    >>> portal_url = portal.absolute_url()\n+    >>> portal_url.split(\':\')[:-1]\n+    [\'http\', \'//localhost\']\n+\n+    >>> import urllib2\n+    >>> conn = urllib2.urlopen(portal_url + \'/Title\', timeout=10)\n+    >>> responseBody = conn.read()\n+    >>> "Fancy Portal" in responseBody\n+    True\n+    >>> conn.close()\n+\n+Test tear-down does nothing beyond what the base layers do.\n+\n+    >>> layers.PLONE_ZSERVER.testTearDown()\n+    >>> z2.ZSERVER_FIXTURE.testTearDown()\n+    >>> layers.PLONE_FIXTURE.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+    >>> zca.LAYER_CLEANUP.testTearDown()\n+\n+    >>> \'portal\' in layers.PLONE_ZSERVER\n+    False\n+\n+    >>> \'app\' in layers.PLONE_ZSERVER\n+    False\n+\n+    >>> \'request\' in layers.PLONE_ZSERVER\n+    False\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print \'folder1\' in portal.objectIds()\n+    False\n+\n+When the server is torn down, the ZServer thread is stopped.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.layers.Plone:ZServer in ... seconds.\n+    ...Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    ...Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+    >>> conn = urllib2.urlopen(portal_url + \'/folder1\', timeout=5)\n+    Traceback (most recent call last):\n+    ...\n+    URLError: <urlopen error [Errno ...] Connection refused>\n+\n+FTP server with Plone site\n+~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The ``PLONE_FTP_SERVER`` layer instantiates the ``FunctionalTesting`` class\n+with two bases: ``PLONE_FIXTURE``, as shown above, and ``FTP_SERVER_FIXTURE``\n+from ``plone.testing``, which starts up an FTP server thread.\n+\n+    >>> "%s.%s" % (layers.PLONE_FTP_SERVER.__module__, layers.PLONE_FTP_SERVER.__name__,)\n+    \'plone.app.testing.layers.Plone:FTPServer\'\n+\n+    >>> layers.PLONE_FTP_SERVER.__bases__\n+    (<Layer \'plone.app.testing.layers.PloneFixture\'>, <Layer \'plone.testing.z2.FTPServer\'>)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, layers.PLONE_FTP_SERVER, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+    Set up plone.testing.z2.FTPServer in ... seconds.\n+    Set up plone.app.testing.layers.Plone:FTPServer in ... seconds.\n+\n+After layer setup, the resources ``host`` and ``port`` are available, and\n+indicate where Zope is running.\n+\n+    >>> host = layers.PLONE_FTP_SERVER[\'host\']\n+    >>> host\n+    \'localhost\'\n+\n+    >>> port = layers.PLONE_FTP_SERVER[\'port\']\n+    >>> import os\n+    >>> port == int(os.environ.get(\'FTPSERVER_PORT\', 55002))\n+    True\n+\n+Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n+do.\n+\n+    >>> zca.LAYER_CLEANUP.testSetUp()\n+    >>> z2.STARTUP.testSetUp()\n+    >>> layers.PLONE_FIXTURE.testSetUp()\n+    >>> z2.FTP_SERVER_FIXTURE.testSetUp()\n+    >>> layers.PLONE_FTP_SERVER.testSetUp()\n+\n+It is common in a test to use the Python API to change the state of the server\n+(e.g. create some content or change a setting) and then use the FTP protocol\n+to look at the results. Bear in mind that the server is running in a separate\n+thread, with a separate security manager, so calls to ``helpers.login()`` and\n+``helpers.logout()``, for instance, do not affect the server thread.\n+\n+    >>> portal = layers.PLONE_FTP_SERVER[\'portal\'] # would normally be self.layer[\'portal\']\n+    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+    >>> from OFS.Folder import Folder\n+    >>> portal._setObject(\'folder1\', Folder(\'folder1\'))\n+    \'folder1\'\n+\n+Note that we need to commit the transaction before it will show up in the\n+other thread.\n+\n+    >>> import transaction; transaction.commit()\n+\n+    >>> folder_path = portal.absolute_url_path() + \'/folder1\'\n+\n+    >>> import ftplib\n+    >>> ftpClient = ftplib.FTP()\n+    >>> ftpClient.connect(host, port, timeout=5)\n+    \'220 ... FTP server (...) ready.\'\n+\n+    >>> from plone.app.testing.interfaces import SITE_OWNER_NAME\n+    >>> from plone.app.testing.interfaces import SITE_OWNER_PASSWORD\n+\n+    >>> ftpClient.login(SITE_OWNER_NAME, SITE_OWNER_PASSWORD)\n+    \'230 Login successful.\'\n+\n+    >>> ftpClient.cwd(folder_path)\n+    \'250 CWD command successful.\'\n+\n+    >>> ftpClient.retrlines(\'LIST\')\n+    drwxrwx---   1 test_user_1_ Zope            0 ... .\n+    d---------   1 admin        Zope            0 ... ..\n+    \'226 Transfer complete\'\n+\n+    >>> ftpClient.quit()\n+    \'221 Goodbye.\'\n+\n+Test tear-down does nothing beyond what the base layers do.\n+\n+    >>> layers.PLONE_FTP_SERVER.testTearDown()\n+    >>> z2.FTP_SERVER_FIXTURE.testTearDown()\n+    >>> layers.PLONE_FIXTURE.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+    >>> zca.LAYER_CLEANUP.testTearDown()\n+\n+    >>> \'portal\' in layers.PLONE_FTP_SERVER\n+    False\n+\n+    >>> \'app\' in layers.PLONE_FTP_SERVER\n+    False\n+\n+    >>> \'request\' in layers.PLONE_FTP_SERVER\n+    False\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print \'folder1\' in portal.objectIds()\n+    False\n+\n+When the server is torn down, the FTP server thread is stopped.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.layers.Plone:FTPServer in ... seconds.\n+    ...Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    ...Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+    >>> ftpClient.connect(host, port, timeout=5)\n+    Traceback (most recent call last):\n+    ...\n+    error: [Errno ...] Connection refused\ndiff --git a/src/plone/app/testing/profile/metadata.xml b/src/plone/app/testing/profile/metadata.xml\nnew file mode 100644\nindex 0000000..6ce5b66\n--- /dev/null\n+++ b/src/plone/app/testing/profile/metadata.xml\n@@ -0,0 +1,5 @@\n+<?xml version="1.0"?>\n+<metadata>\n+  <!-- This is used in the helpers.rst tests. -->\n+  <version>1000</version>\n+</metadata>\ndiff --git a/src/plone/app/testing/selenium.rst b/src/plone/app/testing/selenium.rst\nnew file mode 100644\nindex 0000000..f03719a\n--- /dev/null\n+++ b/src/plone/app/testing/selenium.rst\n@@ -0,0 +1,187 @@\n+Selenium testing layer\n+----------------------\n+\n+Introduction\n+============\n+\n+There is a layer used to set up test fixtures for running\n+`Selenium <code.google.com/p/selenium/>`_\n+tests against a Plone site. It is importable from\n+``plone.app.testing.selenium_layers``.\n+\n+With Selenium you get\n+\n+* Any real web browser, installed on your computer, accessing your unit test site\n+\n+* Real Javascript support and AJAX support\n+\n+* Real visibility test: is any element visible on the screen according to CSS\n+\n+* Scrape your page content with CSS selectors\n+\n+* Execute Javascript test snippets against loaded pages to see if your JS code is sane\n+\n+* Ability to take screenshots of web pages\n+\n+Selenium provides a ``WebDriver`` class which has a subclass for each\n+browser (Chrome, Firefox, IE...) for running the tests on this specific browser.\n+\n+`More info about available WebDriver API <http://code.google.com/p/selenium/source/browse/trunk/py/selenium/webdriver/remote/webdriver.py>`_.\n+\n+`Selenium element matching options <http://code.google.com/p/selenium/source/browse/trunk/py/selenium/webdriver/common/by.py>`_\n+\n+`Extracting data from matched elements <http://code.google.com/p/selenium/source/browse/trunk/py/selenium/webdriver/remote/webelement.py>`_\n+\n+Using Selenium with plone.app.testing\n+=======================================\n+\n+Note that if using the "-D" pdb debugger testrunner flag for failures\n+in this test before the layer is torn down, the testrunner process\n+will not exit even with interrupt. Exit by backgrounding the process\n+and then kill the backgrouned process.\n+\n+    >>> from plone.app.testing import selenium_layers as layers\n+\n+For testing, we need a testrunner\n+\n+    >>> from zope.testrunner import runner\n+\n+The ``SELENIUM_PLONE_FUNCTIONAL_TESTING`` layer instantiates the\n+``FunctionalTesting`` class with two bases: ``SELENIUM_FIXTURE``, as\n+shown above, and ``PLONE_FIXTURE``.\n+\n+    >>> "%s.%s" % (\n+    ...     layers.SELENIUM_PLONE_FUNCTIONAL_TESTING.__module__,\n+    ...     layers.SELENIUM_PLONE_FUNCTIONAL_TESTING.__name__,)\n+    \'plone.app.testing.selenium_layers.SeleniumTesting:Functional\'\n+\n+    >>> layers.SELENIUM_PLONE_FUNCTIONAL_TESTING.__bases__\n+    (<Layer \'plone.app.testing.selenium_layers.SeleniumLayer\'>, <Layer \'plone.app.testing.layers.PloneFixture\'>)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(\n+    ...     options, layers.SELENIUM_PLONE_FUNCTIONAL_TESTING, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.z2.ZServer in ... seconds.\n+    Set up plone.app.testing.selenium_layers.SeleniumLayer in ... seconds.\n+    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+    Set up plone.app.testing.selenium_layers.SeleniumTesting:Functional in ... seconds.\n+\n+After layer setup, the resources ``host`` and ``port`` are available, and\n+indicate where Zope is running.\n+\n+    >>> host = layers.SELENIUM_PLONE_FUNCTIONAL_TESTING[\'host\']\n+    >>> host\n+    \'localhost\'\n+\n+    >>> port = layers.SELENIUM_PLONE_FUNCTIONAL_TESTING[\'port\']\n+    >>> import os\n+    >>> port == int(os.environ.get(\'ZSERVER_PORT\', 55001))\n+    True\n+\n+Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n+do.\n+\n+    >>> from plone.testing import z2, zca\n+    >>> zca.LAYER_CLEANUP.testSetUp()\n+    >>> z2.STARTUP.testSetUp()\n+    >>> layers.SELENIUM_FIXTURE.testSetUp()\n+    >>> layers.SELENIUM_PLONE_FUNCTIONAL_TESTING.testSetUp()\n+\n+It is common in a test to use the Python API to change the state of\n+the server (e.g. create some content or change a setting) and then use\n+the Selenium browser to look at the results. Bear in mind that the\n+server is running in a separate thread, with a separate security\n+manager, so calls to ``helpers.login()`` and ``helpers.logout()``, for\n+instance, do not affect the server thread.\n+\n+    >>> from plone.app.testing import helpers\n+    >>> from plone.app.testing.interfaces import TEST_USER_ID\n+    >>> portal = layers.SELENIUM_PLONE_FUNCTIONAL_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n+    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+    >>> portal.title = \'Ploney times\'\n+\n+    >>> from plone.app.testing.selenium_layers import open\n+    >>> selenium = layers.SELENIUM_PLONE_FUNCTIONAL_TESTING[\'selenium\']\n+    >>> open(selenium, portal.absolute_url())\n+    >>> selenium.title\n+    u\'Ploney times\'\n+\n+Now we also test logging-in to Plone.\n+\n+    >>> from plone.app.testing.selenium_layers import login\n+    >>> login(selenium, portal)\n+    >>> selenium.find_element_by_tag_name(\'h1\').text\n+    u\'You are now logged in\'\n+\n+Test tear-down does nothing beyond what the base layers do.\n+\n+    >>> layers.SELENIUM_PLONE_FUNCTIONAL_TESTING.testTearDown()\n+    >>> layers.SELENIUM_FIXTURE.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+    >>> zca.LAYER_CLEANUP.testTearDown()\n+\n+    >>> \'portal\' in layers.SELENIUM_PLONE_FUNCTIONAL_TESTING\n+    False\n+\n+    >>> \'app\' in layers.SELENIUM_PLONE_FUNCTIONAL_TESTING\n+    False\n+\n+    >>> \'request\' in layers.SELENIUM_PLONE_FUNCTIONAL_TESTING\n+    False\n+\n+When the layer is torn down, the Selenium browser is closed.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.selenium_layers.SeleniumTesting:Functional in ... seconds.\n+    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+    >>> if getattr(selenium, \'_server\', None) is None:\n+    ...     import urllib2\n+    ...     urllib2.urlopen(\'http://XXX\')\n+    ... else:\n+    ...     from selenium.remote.webdriver import WebDriver\n+    ...     WebDriver._execute(selenium, \'quit\')\n+    Traceback (most recent call last):\n+    URLError: ...\n+\n+Selenium and transactions\n+==========================\n+\n+Selenium WebDriver runs in a different thread than your plone.app.testing Python code.\n+Both threads have their own ZODB transactions. If you modify the data in Selenium thread\n+(e.g. your virtual user modifies something) you cannot directly access this data\n+in the test thread.\n+\n+This is important whenever your interactions with the\n+Selenium browser are going to require retrieving content from the\n+server when that content needs to reflect changes you\'ve made in your\n+test. For example, if some browser action invokes some AJAX code which\n+refreshes a part of the page from ZODB content, that refreshed content\n+will only reflect recent changes if you did transaction.commit()\n+before executing the browser action that triggered the AJAX.  The\n+plone.app.testing.selenium_layers.open() method does this for you when\n+opening a new URL, but there are many more ways to cause content\n+changes that pull from the ZODB when doing JavaScript testing so in\n+all other cases you are responsible to call transaction.commit()\n+yourself.\n+\n+Here is an example how we force the test thread to get a fresh copy of the object\n+after Selenium has poked it.\n+\n+Example::\n+\n+    import transaction\n+\n+    def test_something():\n+        # ... Selenium modifies the site here ...\n+\n+        # Make sure that the test thread and the selenium thread ZODB are synced\n+        transaction.commit()\n+        text = self.page.getText()\n+\n+        self.assertEqual(text, NEW_TEXT)\ndiff --git a/src/plone/app/testing/selenium_layers.py b/src/plone/app/testing/selenium_layers.py\nnew file mode 100644\nindex 0000000..3804f75\n--- /dev/null\n+++ b/src/plone/app/testing/selenium_layers.py\n@@ -0,0 +1,125 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.testing import FunctionalTesting\n+from plone.app.testing import PLONE_FIXTURE\n+from plone.app.testing import TEST_USER_NAME\n+from plone.app.testing import TEST_USER_PASSWORD\n+from plone.testing import Layer\n+from plone.testing import z2\n+\n+import os\n+import transaction\n+\n+\n+class SeleniumLayer(Layer):\n+    defaultBases = (z2.ZSERVER_FIXTURE, )\n+\n+    def testSetUp(self):\n+        # Start up Selenium\n+        driver = os.environ.get(\'SELENIUM_DRIVER\', \'\').lower() or \'firefox\'\n+        webdriver = __import__(\n+            \'selenium.webdriver.{0}.webdriver\'.format(driver),\n+            fromlist=[\'WebDriver\']\n+        )\n+        args = [arg.strip() for arg in\n+                os.environ.get(\'SELENIUM_ARGS\', \'\').split()\n+                if arg.strip()]\n+        self[\'selenium\'] = webdriver.WebDriver(*args)\n+\n+    def testTearDown(self):\n+        self[\'selenium\'].quit()\n+        del self[\'selenium\']\n+\n+\n+SELENIUM_FIXTURE = SeleniumLayer()\n+SELENIUM_FUNCTIONAL_TESTING = FunctionalTesting(\n+    bases=(SELENIUM_FIXTURE, ),\n+    name=\'SeleniumTesting:Functional\')\n+SELENIUM_PLONE_FUNCTIONAL_TESTING = FunctionalTesting(\n+    bases=(SELENIUM_FIXTURE, PLONE_FIXTURE),\n+    name=\'SeleniumTesting:Functional\')\n+\n+\n+# Helper functions\n+\n+\n+def open(selenium, url):\n+    # ensure we have a clean starting point\n+    transaction.commit()\n+    selenium.get(url)\n+\n+\n+def login(selenium, portal, username=False, password=False):\n+\n+    if not username:\n+        username = TEST_USER_NAME\n+    if not password:\n+        password = TEST_USER_PASSWORD\n+\n+    open(selenium, portal.absolute_url() + \'/login_form\')\n+    selenium.find_element_by_name(\'__ac_name\').send_keys(username)\n+    selenium.find_element_by_name(\'__ac_password\').send_keys(password)\n+    selenium.find_element_by_name(\'submit\').click()\n+\n+\n+def click(selenium, xpath):\n+    if xpath.count(\'link=\'):\n+        link = xpath.split(\'link=\')[-1]\n+        element = selenium.find_element_by_partial_link_text(link)\n+    elif xpath.count(\'//\'):\n+        element = selenium.find_element_by_xpath(xpath)\n+    elif xpath.count(\'#\'):\n+        eleName = xpath.split(\'#\')[-1]\n+        element = selenium.find_element_by_id(eleName)\n+    else:\n+        element = selenium.find_element_by_name(xpath)\n+\n+    element.click()\n+\n+\n+def type(selenium, name, value):\n+    selenium.find_element_by_name(name).send_keys(value)\n+\n+\n+def typeMce(selenium, value):\n+    """\n+    Text fields with mce are different.\n+    We need to go into the frame and update the p element to make this work.\n+    Unfortunately the code to get out of the frame is not implemented in python\n+    yet.\n+    The workaround is to use this handle trick,\n+    which is currently unsupported in chrome.\n+    See issue #405 for more.\n+    In general there are still a lot of open issues on frame support so if\n+    this breaks it won\'t be a surprise.\n+    """\n+    handle = selenium.current_window_handle\n+    selenium.switch_to_frame(\'form.text_ifr\')\n+    ele = selenium.find_element_by_xpath(\'//p\')\n+    ele.send_keys(value)\n+    selenium.switch_to_window(handle)\n+\n+\n+def clear(selenium, name):\n+    selenium.find_element_by_name(name).clear()\n+\n+\n+def select(selenium, xpath1, xpath2=\'\'):\n+    xpath = xpath1\n+    if xpath2:\n+        xpath = "{0}[\'{1}\']".format(xpath1, xpath2)\n+        xpath = xpath.replace("select[\'label=", "select/option[\'text()=")\n+    selenium.find_element_by_xpath(xpath).click()\n+\n+\n+def waitForPageToLoad(selenium, foo):\n+    # this does nothing but make us lazy folks happy\n+    pass\n+\n+\n+def publish(selenium):\n+    click(selenium, "//dl[@id=\'plone-contentmenu-workflow\']/dt/a")\n+    click(selenium, \'#workflow-transition-publish\')\n+\n+\n+def submit(selenium, formId):\n+    selenium.find_element_by_id(formId).submit()\ndiff --git a/src/plone/app/testing/tests.py b/src/plone/app/testing/tests.py\nnew file mode 100644\nindex 0000000..3f0c844\n--- /dev/null\n+++ b/src/plone/app/testing/tests.py\n@@ -0,0 +1,26 @@\n+# -*- coding: utf-8 -*-\n+import doctest\n+import unittest\n+\n+\n+OPTIONFLAGS = doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE\n+\n+\n+# Dummy handler used in tests\n+def dummy(context):\n+    pass\n+\n+\n+def test_suite():\n+    suite = unittest.TestSuite()\n+    # seltest = doctest.DocFileSuite(\'selenium.rst\', optionflags=OPTIONFLAGS)\n+    # Run selenium tests on level 2, as it requires a correctly configured\n+    # Firefox browser\n+    # seltest.level = 2\n+    suite.addTests([\n+        doctest.DocFileSuite(\'cleanup.rst\', optionflags=OPTIONFLAGS),\n+        doctest.DocFileSuite(\'layers.rst\', optionflags=OPTIONFLAGS),\n+        doctest.DocFileSuite(\'helpers.rst\', optionflags=OPTIONFLAGS),\n+        # seltest,\n+    ])\n+    return suite\ndiff --git a/src/plone/app/testing/utils.py b/src/plone/app/testing/utils.py\nnew file mode 100644\nindex 0000000..0771372\n--- /dev/null\n+++ b/src/plone/app/testing/utils.py\n@@ -0,0 +1,27 @@\n+# -*- coding: utf-8 -*-\n+from persistent.list import PersistentList\n+from Products.MailHost.MailHost import _mungeHeaders\n+from Products.MailHost.MailHost import MailBase\n+\n+\n+class MockMailHost(MailBase):\n+    """A MailHost that collects messages instead of sending them.\n+    """\n+\n+    def __init__(self, id):\n+        self.reset()\n+\n+    def reset(self):\n+        self.messages = PersistentList()\n+\n+    def _send(self, mfrom, mto, messageText, immediate=False):\n+        """ Send the message """\n+        self.messages.append(messageText)\n+\n+    def send(self, messageText, mto=None, mfrom=None, subject=None,\n+             encode=None, immediate=False, charset=None, msg_type=None):\n+        messageText, mto, mfrom = _mungeHeaders(messageText,\n+                                                mto, mfrom, subject,\n+                                                charset=charset,\n+                                                msg_type=msg_type)\n+        self.messages.append(messageText)\ndiff --git a/tox.ini b/tox.ini\nindex 9534c20..6adab4d 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -2,9 +2,8 @@\n envlist =\n     py27,\n     py36,\n-#    py36-zserver,\n     coverage-report,\n-#    docs,\n+    docs,\n     lint-py27,\n     lint-py36,\n \n@@ -131,7 +130,7 @@ deps =\n \n commands =\n     sphinx-build -b html -d _build/docs/doctrees docs _build/docs/html\n-    sphinx-build -b doctest docs _build/docs/doctrees\n+#    sphinx-build -b doctest docs _build/docs/doctrees\n \n [testenv:update_translation]\n skip_install = true\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-04-24T11:01:14+02:00
Author: Alexander Loechel (loechel) <Alexander.Loechel@lmu.de>
Commit: https://github.com/plone/plone.app.testing/commit/a0927b05da359dc7b1a141397d8030ba712df970

git ignore and flake8

Files changed:
M .gitignore
M src/plone/app/testing/cleanup.py
M src/plone/app/testing/layers.py
D src/plone.app.testing.egg-info/PKG-INFO
D src/plone.app.testing.egg-info/SOURCES.txt
D src/plone.app.testing.egg-info/dependency_links.txt
D src/plone.app.testing.egg-info/namespace_packages.txt
D src/plone.app.testing.egg-info/not-zip-safe
D src/plone.app.testing.egg-info/requires.txt
D src/plone.app.testing.egg-info/top_level.txt

b'diff --git a/.gitignore b/.gitignore\nindex ac88fde..306cacf 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -8,7 +8,7 @@\n /build\n /dist\n /local.cfg\n-/*.egg-info\n+*.egg-info\n /.installed.cfg\n *.py[cod]\n /.Python\ndiff --git a/src/plone.app.testing.egg-info/PKG-INFO b/src/plone.app.testing.egg-info/PKG-INFO\ndeleted file mode 100644\nindex f5bce6b..0000000\n--- a/src/plone.app.testing.egg-info/PKG-INFO\n+++ /dev/null\n@@ -1,1979 +0,0 @@\n-Metadata-Version: 2.1\n-Name: plone.app.testing\n-Version: 6.0.0.dev0\n-Summary: Testing tools for Plone-the-application, based on plone.testing.\n-Home-page: https://pypi.python.org/pypi/plone.app.testing\n-Author: Plone Foundation\n-Author-email: plone-developers@lists.sourceforge.net\n-License: GPL version 2\n-Description: Introduction\n-        ============\n-        \n-        .. contents:: Table of contents\n-        \n-        ``plone.app.testing`` provides tools for writing integration and functional\n-        tests for code that runs on top of Plone. It is based on `plone.testing`_.\n-        If you are unfamiliar with ``plone.testing``, the concept of layers, or the\n-        `zope.testing`_ testrunner, please take a look at the the ``plone.testing``\n-        documentation. In fact, even if you are working exclusively with Plone, you\n-        are likely to want to use some of its features for unit testing.\n-        \n-        In short, ``plone.app.testing`` includes:\n-        \n-        * A set of layers that set up fixtures containing a Plone site, intended for\n-          writing integration and functional tests.\n-        * A collection of helper functions, some useful for writing your own layers\n-          and some applicable to tests themselves.\n-        * A convenient layer base class, extending ``plone.testing.Layer``, which\n-          makes it easier to write custom layers extending the Plone site fixture,\n-          with proper isolation and tear-down.\n-        * Cleanup hooks for ``zope.testing.cleanup`` to clean up global state found\n-          in a Plone installation. This is useful for unit testing.\n-        \n-        Compatibility\n-        -------------\n-        \n-        ``plone.app.testing`` 5.x works with Plone 5.\n-        ``plone.app.testing`` 4.x works with Plone 4 and Zope 2.12. It may work with\n-        newer versions. It will not work with earlier versions. Use\n-        ``plone.app.testing`` 3.x for Plone 3 and Zope 2.10.\n-        \n-        Installation and usage\n-        ======================\n-        \n-        To use ``plone.app.testing`` in your own package, you need to add it as a\n-        dependency. Most people prefer to keep test-only dependencies separate, so\n-        that they do not need to be installed in scenarios (such as on a production\n-        server) where the tests will not be run. This can be achieved using a\n-        ``test`` extra.\n-        \n-        In ``setup.py``, add or modify the ``extras_require`` option, like so::\n-        \n-            extras_require = {\n-                \'test\': [\n-                        \'plone.app.testing\',\n-                    ]\n-            },\n-        \n-        This will also include ``plone.testing``, with the ``[z2]``, ``[zca]`` and\n-        ``[zodb]`` extras (which ``plone.app.testing`` itself relies on).\n-        \n-        Please see the `plone.testing`_ documentation for more details about how to\n-        add a test runner to your buildout, and how to write and run tests.\n-        \n-        Layer reference\n-        ===============\n-        \n-        This package contains a layer class,\n-        ``plone.app.testing.layers.PloneFixture``, which sets up a Plone site fixture.\n-        It is combined with other layers from `plone.testing`_ to provide a number of\n-        layer instances. It is important to realise that these layers all have the\n-        same fundamental fixture: they just manage test setup and tear-down\n-        differently.\n-        \n-        When set up, the fixture will:\n-        \n-        * Create a ZODB sandbox, via a stacked ``DemoStorage``. This ensures\n-          persistent changes made during layer setup can be cleanly torn down.\n-        * Configure a global component registry sandbox. This ensures that global\n-          component registrations (e.g. as a result of loading ZCML configuration)\n-          can be cleanly torn down.\n-        * Create a configuration context with the ``disable-autoinclude`` feature\n-          set. This has the effect of stopping Plone from automatically loading the\n-          configuration of any installed package that uses the\n-          ``z3c.autoinclude.plugin:plone`` entry point via `z3c.autoinclude`_. (This\n-          is to avoid accidentally polluting the test fixture - custom layers should\n-          load packages\' ZCML configuration explicitly if required).\n-        * Install a number of Zope 2-style products on which Plone depends.\n-        * Load the ZCML for these products, and for ``Products.CMFPlone``, which in\n-          turn pulls in the configuration for the core of Plone.\n-        * Create a default Plone site, with the default theme enabled, but with no\n-          default content.\n-        * Add a user to the root user folder with the ``Manager`` role.\n-        * Add a test user to this instance with the ``Member`` role.\n-        \n-        For each test:\n-        \n-        * The test user is logged in\n-        * The local component site is set\n-        * Various global caches are cleaned up\n-        \n-        Various constants in the module ``plone.app.testing.interfaces`` are defined\n-        to describe this environment:\n-        \n-        +----------------------+--------------------------------------------------+\n-        | **Constant**         | **Purpose**                                      |\n-        +----------------------+--------------------------------------------------+\n-        | PLONE_SITE_ID        | The id of the Plone site object inside the Zope  |\n-        |                      | application root.                                |\n-        +----------------------+--------------------------------------------------+\n-        | PLONE_SITE_TITLE     | The title of the Plone site                      |\n-        +----------------------+--------------------------------------------------+\n-        | DEFAULT_LANGUAGE     | The default language of the Plone site (\'en\')    |\n-        +----------------------+--------------------------------------------------+\n-        | TEST_USER_ID         | The id of the test user                          |\n-        +----------------------+--------------------------------------------------+\n-        | TEST_USER_NAME       | The username of the test user                    |\n-        +----------------------+--------------------------------------------------+\n-        | TEST_USER_PASSWORD   | The password of the test user                    |\n-        +----------------------+--------------------------------------------------+\n-        | TEST_USER_ROLES      | The default global roles of the test user -      |\n-        |                      | (\'Member\',)                                      |\n-        +----------------------+--------------------------------------------------+\n-        | SITE_OWNER_NAME      | The username of the user owning the Plone site.  |\n-        +----------------------+--------------------------------------------------+\n-        | SITE_OWNER_PASSWORD  | The password of the user owning the Plone site.  |\n-        +----------------------+--------------------------------------------------+\n-        \n-        All the layers also expose a resource in addition to those from their\n-        base layers, made available during tests:\n-        \n-        ``portal``\n-           The Plone site root.\n-        \n-        Plone site fixture\n-        ------------------\n-        \n-        +------------+--------------------------------------------------+\n-        | Layer:     | ``plone.app.testing.PLONE_FIXTURE``              |\n-        +------------+--------------------------------------------------+\n-        | Class:     | ``plone.app.testing.layers.PloneFixture``        |\n-        +------------+--------------------------------------------------+\n-        | Bases:     | ``plone.testing.z2.STARTUP``                     |\n-        +------------+--------------------------------------------------+\n-        | Resources: |                                                  |\n-        +------------+--------------------------------------------------+\n-        \n-        This layer sets up the Plone site fixture on top of the ``z2.STARTUP``\n-        fixture.\n-        \n-        You should not use this layer directly, as it does not provide any test\n-        lifecycle or transaction management. Instead, you should use a layer\n-        created with either the ``IntegrationTesting`` or ``FunctionalTesting``\n-        classes, as outlined below.\n-        \n-        Mock MailHost\n-        -------------\n-        \n-        +------------+--------------------------------------------------+\n-        | Layer:     | ``plone.app.testing.MOCK_MAILHOST_FIXTURE``      |\n-        +------------+--------------------------------------------------+\n-        | Class:     | ``plone.app.testing.layers.MockMailHostLayer``   |\n-        +------------+--------------------------------------------------+\n-        | Bases:     | ``plone.app.testing.layers.PLONE_FIXTURE``       |\n-        +------------+--------------------------------------------------+\n-        | Resources: |                                                  |\n-        +------------+--------------------------------------------------+\n-        \n-        This layer builds on top of ``PLONE_FIXTURE`` to patch Plone\'s MailHost implementation.\n-        \n-        With it,\n-        any attempt to send an email will instead store each of them as a string in a list in ``portal.MailHost.messages``.\n-        \n-        You should not use this layer directly, as it does not provide any test\n-        lifecycle or transaction management. Instead, you should use a layer\n-        created with either the ``IntegrationTesting`` or ``FunctionalTesting``\n-        classes, like::\n-        \n-            from plone.app.testing import MOCK_MAILHOST_FIXTURE\n-        \n-            MY_INTEGRATION_TESTING = IntegrationTesting(\n-                bases=(\n-                    MY_FIXTURE,\n-                    MOCK_MAILHOST_FIXTURE,\n-                ),\n-                name="MyFixture:Integration"\n-            )\n-        \n-        \n-        PloneWithPackageLayer class\n-        ---------------------------\n-        \n-        Most add-ons do not need more setup than loading a ZCML file and\n-        running a GenericSetup profile.\n-        \n-        With this helper class, a fixture can easily be instantiated::\n-        \n-            from plone.app.testing import PloneWithPackageLayer\n-            import my.addon\n-        \n-            FIXTURE = PloneWithPackageLayer(\n-                zcml_package=my.addon,\n-                zcml_filename=\'configure.zcml\',\n-                gs_profile_id=\'my.addon:default\',\n-                name="MyAddonFixture"\n-            )\n-        \n-        PloneWithPackageLayer constructor takes two other keyword arguments:\n-        ``bases`` and ``additional_z2_products``.\n-        \n-        The ``bases`` argument takes a sequence of base layer fixtures.\n-        It is useful, among other reasons,\n-        to pass a fixture which makes other calls to plone.app.testing API.\n-        The need could arise in the development process.\n-        \n-        ``additional_z2_products`` argument takes a sequence of package names\n-        that need to be installed as Zope2 Products and are dependencies of the tested add-on.\n-        \n-        Integration and functional testing test lifecycles\n-        --------------------------------------------------\n-        \n-        ``plone.app.testing`` comes with two layer classes, ``IntegrationTesting``\n-        and ``FunctionalTesting``, which derive from the corresponding layer classes\n-        in ``plone.testing.z2``.\n-        \n-        These classes set up the ``app``, ``request`` and ``portal`` resources, and\n-        reset the fixture (including various global caches) between each test run.\n-        \n-        As with the classes in ``plone.testing``, the ``IntegrationTesting`` class\n-        will create a new transaction for each test and roll it back on test tear-\n-        down, which is efficient for integration testing, whilst ``FunctionalTesting``\n-        will create a stacked ``DemoStorage`` for each test and pop it on test tear-\n-        down, making it possible to exercise code that performs an explicit commit\n-        (e.g. via tests that use ``zope.testbrowser``).\n-        \n-        When creating a custom fixture, the usual pattern is to create a new layer\n-        class that has ``PLONE_FIXTURE`` as its default base, instantiating that as a\n-        separate "fixture" layer. This layer is not to be used in tests directly,\n-        since it won\'t have test/transaction lifecycle management, but represents a\n-        shared fixture, potentially for both functional and integration testing. It\n-        is also the point of extension for other layers that follow the same pattern.\n-        \n-        Once this fixture has been defined, "end-user" layers can be defined using\n-        the ``IntegrationTesting`` and ``FunctionalTesting`` classes. For example::\n-        \n-            from plone.testing import Layer\n-            from plone.app.testing import PLONE_FIXTURE\n-            from plone.app.testing import IntegrationTesting, FunctionalTesting\n-        \n-            class MyFixture(Layer):\n-                defaultBases = (PLONE_FIXTURE,)\n-        \n-                ...\n-        \n-            MY_FIXTURE = MyFixture()\n-        \n-            MY_INTEGRATION_TESTING = IntegrationTesting(bases=(MY_FIXTURE,), name="MyFixture:Integration")\n-            MY_FUNCTIONAL_TESTING = FunctionalTesting(bases=(MY_FIXTURE,), name="MyFixture:Functional")\n-        \n-        See the ``PloneSandboxLayer`` layer below for a more comprehensive example.\n-        \n-        Plone integration testing\n-        -------------------------\n-        \n-        +------------+--------------------------------------------------+\n-        | Layer:     | ``plone.app.testing.PLONE_INTEGRATION_TESTING``  |\n-        +------------+--------------------------------------------------+\n-        | Class:     | ``plone.app.testing.layers.IntegrationTesting``  |\n-        +------------+--------------------------------------------------+\n-        | Bases:     | ``plone.app.testing.PLONE_FIXTURE``              |\n-        +------------+--------------------------------------------------+\n-        | Resources: | ``portal`` (test setup only)                     |\n-        +------------+--------------------------------------------------+\n-        \n-        This layer can be used for integration testing against the basic\n-        ``PLONE_FIXTURE`` layer.\n-        \n-        You can use this directly in your tests if you do not need to set up any\n-        other shared fixture.\n-        \n-        However, you would normally not extend this layer - see above.\n-        \n-        \n-        Plone functional testing\n-        ------------------------\n-        \n-        +------------+--------------------------------------------------+\n-        | Layer:     | ``plone.app.testing.PLONE_FUNCTIONAL_TESTING``   |\n-        +------------+--------------------------------------------------+\n-        | Class:     | ``plone.app.testing.layers.FunctionalTesting``   |\n-        +------------+--------------------------------------------------+\n-        | Bases:     | ``plone.app.testing.PLONE_FIXTURE``              |\n-        +------------+--------------------------------------------------+\n-        | Resources: | ``portal`` (test setup only)                     |\n-        +------------+--------------------------------------------------+\n-        \n-        This layer can be used for functional testing against the basic\n-        ``PLONE_FIXTURE`` layer, for example using ``zope.testbrowser``.\n-        \n-        You can use this directly in your tests if you do not need to set up any\n-        other shared fixture.\n-        \n-        Again, you would normally not extend this layer - see above.\n-        \n-        Plone ZServer\n-        -------------\n-        \n-        +------------+--------------------------------------------------+\n-        | Layer:     | ``plone.app.testing.PLONE_ZSERVER``              |\n-        +------------+--------------------------------------------------+\n-        | Class:     | ``plone.testing.z2.ZServer``                     |\n-        +------------+--------------------------------------------------+\n-        | Bases:     | ``plone.app.testing.PLONE_FUNCTIONAL_TESTING``   |\n-        +------------+--------------------------------------------------+\n-        | Resources: | ``portal`` (test setup only)                     |\n-        +------------+--------------------------------------------------+\n-        \n-        This is layer is intended for functional testing using a live, running HTTP\n-        server, e.g. using Selenium or Windmill.\n-        \n-        Again, you would not normally extend this layer. To create a custom layer\n-        that has a running ZServer, you can use the same pattern as this one, e.g.::\n-        \n-            from plone.testing import Layer\n-            from plone.testing import z2\n-            from plone.app.testing import PLONE_FIXTURE\n-            from plone.app.testing import FunctionalTesting\n-        \n-            class MyFixture(Layer):\n-                defaultBases = (PLONE_FIXTURE,)\n-        \n-                ...\n-        \n-            MY_FIXTURE = MyFixture()\n-            MY_ZSERVER = FunctionalTesting(bases=(MY_FIXTURE, z2.ZSERVER_FIXTURE), name=\'MyFixture:ZServer\')\n-        \n-        See the description of the ``z2.ZSERVER`` layer in `plone.testing`_\n-        for further details.\n-        \n-        Plone FTP server\n-        ----------------\n-        \n-        +------------+--------------------------------------------------+\n-        | Layer:     | ``plone.app.testing.PLONE_FTP_SERVER``           |\n-        +------------+--------------------------------------------------+\n-        | Class:     | ``plone.app.testing.layers.FunctionalTesting``   |\n-        +------------+--------------------------------------------------+\n-        | Bases:     | ``plone.app.testing.PLONE_FIXTURE``              |\n-        |            | ``plone.testing.z2.ZSERVER_FIXTURE``             |\n-        +------------+--------------------------------------------------+\n-        | Resources: | ``portal`` (test setup only)                     |\n-        +------------+--------------------------------------------------+\n-        \n-        This is layer is intended for functional testing using a live FTP server.\n-        \n-        It is semantically equivalent to the ``PLONE_ZSERVER`` layer.\n-        \n-        See the description of the ``z2.FTP_SERVER`` layer in `plone.testing`_\n-        for further details.\n-        \n-        Helper functions\n-        ================\n-        \n-        A number of helper functions are provided for use in tests and custom layers.\n-        \n-        Plone site context manager\n-        --------------------------\n-        \n-        ``ploneSite(db=None, connection=None, environ=None)``\n-            Use this context manager to access and make changes to the Plone site\n-            during layer setup. In most cases, you will use it without arguments,\n-            but if you have special needs, you can tie it to a particular database\n-            instance. See the description of the ``zopeApp()`` context manager in\n-            `plone.testing`_ (which this context manager uses internally) for details.\n-        \n-            The usual pattern is to call it during ``setUp()`` or ``tearDown()`` in\n-            your own layers::\n-        \n-                from plone.testing import Layer\n-                from plone.app.testing import ploneSite\n-        \n-                class MyLayer(Layer):\n-        \n-                    def setUp(self):\n-        \n-                        ...\n-        \n-                        with ploneSite() as portal:\n-        \n-                            # perform operations on the portal, e.g.\n-                            portal.title = u"New title"\n-        \n-            Here, ``portal`` is the Plone site root. A transaction is begun before\n-            entering the ``with`` block, and will be committed upon exiting the block,\n-            unless an exception is raised, in which case it will be rolled back.\n-        \n-            Inside the block, the local component site is set to the Plone site root,\n-            so that local component lookups should work.\n-        \n-            **Warning:** Do not attempt to load ZCML files inside a ``ploneSite``\n-            block. Because the local site is set to the Plone site, you may end up\n-            accidentally registering components in the local site manager, which can\n-            cause pickling errors later.\n-        \n-            **Note:** You should not use this in a test, or in a ``testSetUp()`` or\n-            ``testTearDown()`` method of a layer based on one of the layer in this\n-            package. Use the ``portal`` resource instead.\n-        \n-            **Also note:** If you are writing a layer setting up a Plone site fixture,\n-            you may want to use the ``PloneSandboxLayer`` layer base class, and\n-            implement the ``setUpZope()``, ``setUpPloneSite()``, ``tearDownZope()``\n-            and/or ``tearDownPloneSite()`` methods instead. See below.\n-        \n-        User management\n-        ---------------\n-        \n-        ``login(portal, userName)``\n-            Simulate login as the given user. This is based on the ``z2.login()``\n-            helper in `plone.testing`_, but instead of passing a specific user folder,\n-            you pass the portal (e.g. as obtained via the ``portal`` layer resource).\n-        \n-            For example::\n-        \n-                import unittest2 as unittest\n-        \n-                from plone.app.testing import PLONE_INTEGRATION_TESTING\n-                from plone.app.testing import TEST_USER_NAME\n-                from plone.app.testing import login\n-        \n-                ...\n-        \n-                class MyTest(unittest.TestCase):\n-        \n-                    layer = PLONE_INTEGRATION_TESTING\n-        \n-                    def test_something(self):\n-                        portal = self.layer[\'portal\']\n-                        login(portal, TEST_USER_NAME)\n-        \n-                        ...\n-        \n-        ``logout()``\n-            Simulate logging out, i.e. becoming the anonymous user. This is equivalent\n-            to the ``z2.logout()`` helper in `plone.testing`_.\n-        \n-            For example::\n-        \n-                import unittest2 as unittest\n-        \n-                from plone.app.testing import PLONE_INTEGRATION_TESTING\n-                from plone.app.testing import logout\n-        \n-                ...\n-        \n-                class MyTest(unittest.TestCase):\n-        \n-                    layer = PLONE_INTEGRATION_TESTING\n-        \n-                    def test_something(self):\n-                        portal = self.layer[\'portal\']\n-                        logout()\n-        \n-                        ...\n-        \n-        ``setRoles(portal, userId, roles)``\n-            Set the roles for the given user. ``roles`` is a list of roles.\n-        \n-            For example::\n-        \n-                import unittest2 as unittest\n-        \n-                from plone.app.testing import PLONE_INTEGRATION_TESTING\n-                from plone.app.testing import TEST_USER_ID\n-                from plone.app.testing import setRoles\n-        \n-                ...\n-        \n-                class MyTest(unittest.TestCase):\n-        \n-                    layer = PLONE_INTEGRATION_TESTING\n-        \n-                    def test_something(self):\n-                        portal = self.layer[\'portal\']\n-                        setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-        \n-        Product and profile installation\n-        --------------------------------\n-        \n-        ``applyProfile(portal, profileName, blacklisted_steps=None)``\n-            Install a GenericSetup profile (usually an extension profile) by name,\n-            using the ``portal_setup`` tool. The name is normally made up of a package\n-            name and a profile name. Do not use the ``profile-`` prefix.\n-        \n-            For example::\n-        \n-                from plone.testing import Layer\n-        \n-                from plone.app.testing import ploneSite\n-                from plone.app.testing import applyProfile\n-        \n-                ...\n-        \n-                class MyLayer(Layer):\n-        \n-                    ...\n-        \n-                    def setUp(self):\n-        \n-                        ...\n-        \n-                        with ploneSite() as portal:\n-                            applyProfile(portal, \'my.product:default\')\n-        \n-                            ...\n-        \n-        ``quickInstallProduct(portal, productName, reinstall=False)``\n-            Use this function to install a particular product into the given Plone\n-            site, using the ``portal_quickinstaller`` tool. If ``reinstall`` is\n-            ``False`` and the product is already installed, nothing will happen; if\n-            ``reinstall`` is ``True``, the product will be reinstalled. The\n-            ``productName`` should be a full dotted name, e.g. ``Products.MyProduct``,\n-            or ``my.product``.\n-        \n-            For example::\n-        \n-                from plone.testing import Layer\n-        \n-                from plone.app.testing import ploneSite\n-                from plone.app.testing import quickInstallProduct\n-        \n-                ...\n-        \n-                class MyLayer(Layer):\n-        \n-                    ...\n-        \n-                    def setUp(self):\n-        \n-                        ...\n-        \n-                        with ploneSite() as portal:\n-                            quickInstallProduct(portal, \'my.product\')\n-        \n-                            ...\n-        \n-        Component architecture sandboxing\n-        ---------------------------------\n-        \n-        ``pushGlobalRegistry(portal, new=None, name=None)``\n-            Create or obtain a stack of global component registries, and push a new\n-            registry to the top of the stack. This allows Zope Component Architecture\n-            registrations (e.g. loaded via ZCML) to be effectively torn down.\n-        \n-            If you are going to use this function, please read the corresponding\n-            documentation for ``zca.pushGlobalRegistry()`` in `plone.testing`_. In\n-            particular, note that you *must* reciprocally call ``popGlobalRegistry()``\n-            (see below).\n-        \n-            This helper is based on ``zca.pushGlobalRegistry()``, but will also fix\n-            up the local component registry in the Plone site ``portal`` so that it\n-            has the correct bases.\n-        \n-            For example::\n-        \n-                from plone.testing import Layer\n-        \n-                from plone.app.testing import ploneSite\n-                from plone.app.testing import pushGlobalRegistry\n-                from plone.app.testing import popGlobalRegistry\n-        \n-                ...\n-        \n-                class MyLayer(Layer):\n-        \n-                    ...\n-        \n-                    def setUp(self):\n-        \n-                        ...\n-        \n-                        with ploneSite() as portal:\n-                            pushGlobalRegistry(portal)\n-        \n-                            ...\n-        \n-        ``popGlobalRegistry(portal)``\n-            Tear down the top of the component architecture stack, as created with\n-            ``pushGlobalRegistry()``\n-        \n-            For example::\n-        \n-                ...\n-        \n-                    def tearDown(self):\n-        \n-                        with ploneSite() as portal:\n-                            popGlobalRegistry(portal)\n-        \n-        Global state cleanup\n-        --------------------\n-        \n-        ``tearDownMultiPluginRegistration(pluginName)``\n-            PluggableAuthService "MultiPlugins" are kept in a global registry. If\n-            you have registered a plugin, e.g. using the ``registerMultiPlugin()``\n-            API, you should tear that registration down in your layer\'s ``tearDown()``\n-            method. You can use this helper, passing a plugin name.\n-        \n-            For example::\n-        \n-                from plone.testing import Layer\n-        \n-                from plone.app.testing import ploneSite\n-                from plone.app.testing import tearDownMultiPluginRegistration\n-        \n-                ...\n-        \n-                class MyLayer(Layer):\n-        \n-                    ...\n-        \n-                    def tearDown(self):\n-        \n-                        tearDownMultiPluginRegistration(\'MyPlugin\')\n-        \n-                        ...\n-        \n-        Layer base class\n-        ================\n-        \n-        If you are writing a custom layer to test your own Plone add-on product, you\n-        will often want to do the following on setup:\n-        \n-        1. Stack a new ``DemoStorage`` on top of the one from the base layer. This\n-           ensures that any persistent changes performed during layer setup can be\n-           torn down completely, simply by popping the demo storage.\n-        \n-        2. Stack a new ZCML configuration context. This keeps separate the information\n-           about which ZCML files were loaded, in case other, independent layers want\n-           to load those same files after this layer has been torn down.\n-        \n-        3. Push a new global component registry. This allows you to register\n-           components (e.g. by loading ZCML or using the test API from\n-           ``zope.component``) and tear down those registration easily by popping the\n-           component registry.\n-        \n-        4. Load your product\'s ZCML configuration\n-        \n-        5. Install the product into the test fixture Plone site\n-        \n-        Of course, you may wish to make other changes too, such as creating some base\n-        content or changing some settings.\n-        \n-        On tear-down, you will then want to:\n-        \n-        1. Remove any Pluggable Authentication Service "multi-plugins" that were added\n-           to the global registry during setup.\n-        \n-        2. Pop the global component registry to unregister components loaded via ZCML.\n-        \n-        3. Pop the configuration context resource to restore its state.\n-        \n-        4. Pop the ``DemoStorage`` to undo any persistent changes.\n-        \n-        If you have made other changes on setup that are not covered by this broad\n-        tear-down, you\'ll also want to tear those down explicitly here.\n-        \n-        Stacking a demo storage and component registry is the safest way to avoid\n-        fixtures bleeding between tests. However, it can be tricky to ensure that\n-        everything happens in the right order.\n-        \n-        To make things easier, you can use the ``PloneSandboxLayer`` layer base class.\n-        This extends ``plone.testing.Layer`` and implements ``setUp()`` and\n-        ``tearDown()`` for you. You simply have to override one or more of the\n-        following methods:\n-        \n-        ``setUpZope(self, app, configurationContext)``\n-            This is called during setup. ``app`` is the Zope application root.\n-            ``configurationContext`` is a newly stacked ZCML configuration context.\n-            Use this to load ZCML, install products using the helper\n-            ``plone.testing.z2.installProduct()``, or manipulate other global state.\n-        \n-        ``setUpPloneSite(self, portal)``\n-            This is called during setup. ``portal`` is the Plone site root as\n-            configured by the ``ploneSite()`` context manager. Use this to make\n-            persistent changes inside the Plone site, such as installing products\n-            using the ``applyProfile()`` or ``quickInstallProduct()`` helpers, or\n-            setting up default content.\n-        \n-        ``tearDownZope(self, app)``\n-            This is called during tear-down, before the global component registry and\n-            stacked ``DemoStorage`` are popped. Use this to tear down any additional\n-            global state.\n-        \n-            **Note:** Global component registrations PAS multi-plugin registrations are\n-            automatically torn down. Product installations are not, so you should use\n-            the ``uninstallProduct()`` helper if any products were installed during\n-            ``setUpZope()``.\n-        \n-        ``tearDownPloneSite(self, portal)``\n-            This is called during tear-down, before the global component registry and\n-            stacked ``DemoStorage`` are popped. During this method, the local\n-            component site hook is set, giving you access to local components.\n-        \n-            **Note:** Persistent changes to the ZODB are automatically torn down by\n-            virtue of a stacked ``DemoStorage``. Thus, this method is less commonly\n-            used than the others described here.\n-        \n-        Let\'s show a more comprehensive example of what such a layer may look like.\n-        Imagine we have a product ``my.product``. It has a ``configure.zcml`` file\n-        that loads some components and registers a ``GenericSetup`` profile, making it\n-        installable in the Plone site. On layer setup, we want to load the product\'s\n-        configuration and install it into the Plone site.\n-        \n-        The layer would conventionally live in a module ``testing.py`` at the root of\n-        the package, i.e. ``my.product.testing``::\n-        \n-            from plone.app.testing import PloneSandboxLayer\n-            from plone.app.testing import PLONE_FIXTURE\n-            from plone.app.testing import IntegrationTesting\n-        \n-            from plone.testing import z2\n-        \n-            class MyProduct(PloneSandboxLayer):\n-        \n-                defaultBases = (PLONE_FIXTURE,)\n-        \n-                def setUpZope(self, app, configurationContext):\n-                    # Load ZCML\n-                    import my.product\n-                    self.loadZCML(package=my.product)\n-        \n-                    # Install product and call its initialize() function\n-                    z2.installProduct(app, \'my.product\')\n-        \n-                    # Note: you can skip this if my.product is not a Zope 2-style\n-                    # product, i.e. it is not in the Products.* namespace and it\n-                    # does not have a <five:registerPackage /> directive in its\n-                    # configure.zcml.\n-        \n-                def setUpPloneSite(self, portal):\n-                    # Install into Plone site using portal_setup\n-                    self.applyProfile(portal, \'my.product:default\')\n-        \n-                def tearDownZope(self, app):\n-                    # Uninstall product\n-                    z2.uninstallProduct(app, \'my.product\')\n-        \n-                    # Note: Again, you can skip this if my.product is not a Zope 2-\n-                    # style product\n-        \n-            MY_PRODUCT_FIXTURE = MyProduct()\n-            MY_PRODUCT_INTEGRATION_TESTING = IntegrationTesting(bases=(MY_PRODUCT_FIXTURE,), name="MyProduct:Integration")\n-        \n-        Here, ``MY_PRODUCT_FIXTURE`` is the "fixture" base layer. Other layers can\n-        use this as a base if they want to build on this fixture, but it would not\n-        be used in tests directly. For that, we have created an ``IntegrationTesting``\n-        instance, ``MY_PRODUCT_INTEGRATION_TESTING``.\n-        \n-        Of course, we could have created a ``FunctionalTesting`` instance as\n-        well, e.g.::\n-        \n-            MY_PRODUCT_FUNCTIONAL_TESTING = FunctionalTesting(bases=(MY_PRODUCT_FIXTURE,), name="MyProduct:Functional")\n-        \n-        Of course, we could do a lot more in the layer setup. For example, let\'s say\n-        the product had a content type \'my.product.page\' and we wanted to create some\n-        test content. We could do that with::\n-        \n-            from plone.app.testing import TEST_USER_ID\n-            from plone.app.testing import TEST_USER_NAME\n-            from plone.app.testing import login\n-            from plone.app.testing import setRoles\n-        \n-            ...\n-        \n-                def setUpPloneSite(self, portal):\n-        \n-                    ...\n-        \n-                    setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-                    login(portal, TEST_USER_NAME)\n-                    portal.invokeFactory(\'my.product.page\', \'page-1\', title=u"Page 1")\n-                    setRoles(portal, TEST_USER_ID, [\'Member\'])\n-        \n-            ...\n-        \n-        Note that unlike in a test, there is no user logged in at layer setup time,\n-        so we have to explicitly log in as the test user. Here, we also grant the test\n-        user the ``Manager`` role temporarily, to allow object construction (which\n-        performs an explicit permission check).\n-        \n-            **Note:** Automatic tear down suffices for all the test setup above. If\n-            the only changes made during layer setup are to persistent, in-ZODB data,\n-            or the global component registry then no additional tear-down is required.\n-            For any other global state being managed, you should write a\n-            ``tearDownPloneSite()`` method to perform the necessary cleanup.\n-        \n-        Given this layer, we could write a test (e.g. in ``tests.py``) like::\n-        \n-            import unittest2 as unittest\n-            from my.product.testing import MY_PRODUCT_INTEGRATION_TESTING\n-        \n-            class IntegrationTest(unittest.TestCase):\n-        \n-                layer = MY_PRODUCT_INTEGRATION_TESTING\n-        \n-                def test_page_dublin_core_title(self):\n-                    portal = self.layer[\'portal\']\n-        \n-                    page1 = portal[\'page-1\']\n-                    page1.title = u"Some title"\n-        \n-                    self.assertEqual(page1.Title(), u"Some title")\n-        \n-        Please see `plone.testing`_ for more information about how to write and run\n-        tests and assertions.\n-        \n-        Common test patterns\n-        ====================\n-        \n-        `plone.testing`_\'s documentation contains details about the fundamental\n-        techniques for writing tests of various kinds. In a Plone context, however,\n-        some patterns tend to crop up time and again. Below, we will attempt to\n-        catalogue some of the more commonly used patterns via short code samples.\n-        \n-        The examples in this section are all intended to be used in tests. Some may\n-        also be useful in layer set-up/tear-down. We have used ``unittest`` syntax\n-        here, although most of these examples could equally be adopted to doctests.\n-        \n-        We will assume that you are using a layer that has ``PLONE_FIXTURE`` as a base\n-        (whether directly or indirectly) and uses the ``IntegrationTesting`` or\n-        ``FunctionalTesting`` classes as shown above.\n-        \n-        We will also assume that the variables ``app``, ``portal`` and ``request`` are\n-        defined from the relative layer resources, e.g. with::\n-        \n-            app = self.layer[\'app\']\n-            portal = self.layer[\'portal\']\n-            request = self.layer[\'request\']\n-        \n-        Note that in a doctest set up using the ``layered()`` function from\n-        ``plone.testing``, ``layer`` is in the global namespace, so you would do e.g.\n-        ``portal = layer[\'portal\']``.\n-        \n-        Where imports are required, they are shown alongside the code example. If\n-        a given import or variable is used more than once in the same section, it\n-        will only be shown once.\n-        \n-        Basic content management\n-        ------------------------\n-        \n-        To create a content item of type \'Folder\' with the id \'f1\' in the root of\n-        the portal::\n-        \n-            portal.invokeFactory(\'Folder\', \'f1\', title=u"Folder 1")\n-        \n-        The ``title`` argument is optional. Other basic properties, like\n-        ``description``, can be set as well.\n-        \n-        Note that this may fail with an ``Unauthorized`` exception, since the test\n-        user won\'t normally have permissions to add content in the portal root, and\n-        the ``invokeFactory()`` method performs an explicit security check. You can\n-        set the roles of the test user to ensure that he has the necessary\n-        permissions::\n-        \n-            from plone.app.testing import setRoles\n-            from plone.app.testing import TEST_USER_ID\n-        \n-            setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-            portal.invokeFactory(\'Folder\', \'f1\', title=u"Folder 1")\n-        \n-        To obtain this object, acquisition-wrapped in its parent::\n-        \n-            f1 = portal[\'f1\']\n-        \n-        To make an assertion against an attribute or method of this object::\n-        \n-            self.assertEqual(f1.Title(), u"Folder 1")\n-        \n-        To modify the object::\n-        \n-            f1.setTitle(u"Some title")\n-        \n-        To add another item inside the folder f1::\n-        \n-            f1.invokeFactory(\'Document\', \'d1\', title=u"Document 1")\n-            d1 = f1[\'d1\']\n-        \n-        To check if an object is in a container::\n-        \n-            self.assertTrue(\'f1\' in portal)\n-        \n-        To delete an object from a container:\n-        \n-            del portal[\'f1\']\n-        \n-        There is no content or workflows installed by default. You can enable workflows::\n-        \n-            portal.portal_workflow.setDefaultChain("simple_publication_workflow")\n-        \n-        Searching\n-        ---------\n-        \n-        To obtain the ``portal_catalog`` tool::\n-        \n-            from Products.CMFCore.utils import getToolByName\n-        \n-            catalog = getToolByName(portal, \'portal_catalog\')\n-        \n-        To search the catalog::\n-        \n-            results = catalog(portal_type="Document")\n-        \n-        Keyword arguments are search parameters. The result is a lazy list. You can\n-        call ``len()`` on it to get the number of search results, or iterate through\n-        it. The items in the list are catalog brains. They have attributes that\n-        correspond to the "metadata" columns configured for the catalog, e.g.\n-        ``Title``, ``Description``, etc. Note that these are simple attributes (not\n-        methods), and contain the value of the corresponding attribute or method from\n-        the source object at the time the object was cataloged (i.e. they are not\n-        necessarily up to date).\n-        \n-        To make assertions against the search results::\n-        \n-            self.assertEqual(len(results), 1)\n-        \n-            # Copy the list into memory so that we can use [] notation\n-            results = list(results)\n-        \n-            # Check the first (and in this case only) result in the list\n-            self.assertEqual(results[0].Title, u"Document 1")\n-        \n-        To get the path of a given item in the search results::\n-        \n-            self.assertEqual(resuls[0].getPath(), portal.absolute_url_path() + \'/f1/d1\')\n-        \n-        To get an absolute URL::\n-        \n-            self.assertEqual(resuls[0].getURL(), portal.absolute_url() + \'/f1/d1\')\n-        \n-        To get the original object::\n-        \n-            obj = results[0].getObject()\n-        \n-        To re-index an object d1 so that its catalog information is up to date::\n-        \n-            d1.reindexObject()\n-        \n-        User management\n-        ---------------\n-        \n-        To create a new user::\n-        \n-            from Products.CMFCore.utils import getToolByName\n-        \n-            acl_users = getToolByName(portal, \'acl_users\')\n-        \n-            acl_users.userFolderAddUser(\'user1\', \'secret\', [\'Member\'], [])\n-        \n-        The arguments are the username (which will also be the user id), the password,\n-        a list of roles, and a list of domains (rarely used).\n-        \n-        To make a particular user active ("logged in") in the integration testing\n-        environment use the ``login`` method and pass it the username::\n-        \n-            from plone.app.testing import login\n-        \n-            login(portal, \'user1\')\n-        \n-        To log out (become anonymous)::\n-        \n-            from plone.app.testing import logout\n-        \n-            logout()\n-        \n-        To obtain the current user::\n-        \n-            from AccessControl import getSecurityManager\n-        \n-            user = getSecurityManager().getUser()\n-        \n-        To obtain a user by name::\n-        \n-            user = acl_users.getUser(\'user1\')\n-        \n-        Or by user id (id and username are often the same, but can differ in real-world\n-        scenarios)::\n-        \n-            user = acl_users.getUserById(\'user1\')\n-        \n-        To get the user\'s user name::\n-        \n-            userName = user.getUserName()\n-        \n-        To get the user\'s id::\n-        \n-            userId = user.getId()\n-        \n-        Permissions and roles\n-        ---------------------\n-        \n-        To get a user\'s roles in a particular context (taking local roles into\n-        account)::\n-        \n-            from AccessControl import getSecurityManager\n-        \n-            user = getSecurityManager().getUser()\n-        \n-            self.assertEqual(user.getRolesInContext(portal), [\'Member\'])\n-        \n-        To change the test user\'s roles::\n-        \n-            from plone.app.testing import setRoles\n-            from plone.app.testing import TEST_USER_ID\n-        \n-            setRoles(portal, TEST_USER_ID, [\'Member\', \'Manager\'])\n-        \n-        Pass a different user name to change the roles of another user.\n-        \n-        To grant local roles to a user in the folder f1::\n-        \n-            f1.manage_setLocalRoles(TEST_USER_ID, (\'Reviewer\',))\n-        \n-        To check the local roles of a given user in the folder \'f1\'::\n-        \n-            self.assertEqual(f1.get_local_roles_for_userid(TEST_USER_ID), (\'Reviewer\',))\n-        \n-        To grant the \'View\' permission to the roles \'Member\' and \'Manager\' in the\n-        portal root without acquiring additional roles from its parents::\n-        \n-            portal.manage_permission(\'View\', [\'Member\', \'Manager\'], acquire=False)\n-        \n-        This method can also be invoked on a folder or individual content item.\n-        \n-        To assert which roles have the permission \'View\' in the context of the\n-        portal::\n-        \n-            roles = [r[\'name\'] for r in portal.rolesOfPermission(\'View\') if r[\'selected\']]\n-            self.assertEqual(roles, [\'Member\', \'Manager\'])\n-        \n-        To assert which permissions have been granted to the \'Reviewer\' role in the\n-        context of the portal::\n-        \n-            permissions = [p[\'name\'] for p in portal.permissionsOfRole(\'Reviewer\') if p[\'selected\']]\n-            self.assertTrue(\'Review portal content\' in permissions)\n-        \n-        To add a new role::\n-        \n-            portal._addRole(\'Tester\')\n-        \n-        This can now be assigned to users globally (using the ``setRoles`` helper)\n-        or locally (using ``manage_setLocalRoles()``).\n-        \n-        To assert which roles are available in a given context::\n-        \n-            self.assertTrue(\'Tester\' in portal.valid_roles())\n-        \n-        Workflow\n-        --------\n-        \n-        To set the default workflow chain::\n-        \n-            from Products.CMFCore.utils import getToolByName\n-        \n-            workflowTool = getToolByName(portal, \'portal_workflow\')\n-        \n-            workflowTool.setDefaultChain(\'my_workflow\')\n-        \n-        In Plone, most chains contain only one workflow, but the ``portal_workflow``\n-        tool supports longer chains, where an item is subject to more than one\n-        workflow simultaneously.\n-        \n-        To set a multi-workflow chain, separate workflow names by commas.\n-        \n-        To get the default workflow chain::\n-        \n-            self.assertEqual(workflowTool.getDefaultChain(), (\'my_workflow\',))\n-        \n-        To set the workflow chain for the \'Document\' type::\n-        \n-            workflowTool.setChainForPortalTypes((\'Document\',), \'my_workflow\')\n-        \n-        You can pass multiple type names to set multiple chains at once. To set a\n-        multi-workflow chain, separate workflow names by commas. To indicate that a\n-        type should use the default workflow, use the special chain name \'(Default)\'.\n-        \n-        To get the workflow chain for the portal type \'Document\'::\n-        \n-            chains = dict(workflowTool.listChainOverrides())\n-            defaultChain = workflowTool.getDefaultChain()\n-            documentChain = chains.get(\'Document\', defaultChain)\n-        \n-            self.assertEqual(documentChain, (\'my_other_workflow\',))\n-        \n-        To get the current workflow chain for the content object f1::\n-        \n-            self.assertEqual(workflowTool.getChainFor(f1), (\'my_workflow\',))\n-        \n-        To update all permissions after changing the workflow::\n-        \n-            workflowTool.updateRoleMappings()\n-        \n-        To change the workflow state of the content object f1 by invoking the\n-        transaction \'publish\'::\n-        \n-            workflowTool.doActionFor(f1, \'publish\')\n-        \n-        Note that this performs an explicit permission check, so if the current user\n-        doesn\'t have permission to perform this workflow action, you may get an error\n-        indicating the action is not available. If so, use ``login()`` or\n-        ``setRoles()`` to ensure the current user is able to change the workflow\n-        state.\n-        \n-        To check the current workflow state of the content object f1::\n-        \n-            self.assertEqual(workflowTool.getInfoFor(f1, \'review_state\'), \'published\')\n-        \n-        Properties\n-        ----------\n-        \n-        To set the value of a property on the portal root::\n-        \n-            portal._setPropValue(\'title\', u"My title")\n-        \n-        To assert the value of a property on the portal root::\n-        \n-            self.assertEqual(portal.getProperty(\'title\'), u"My title")\n-        \n-        To change the value of a property in a property sheet in the\n-        ``portal_properties`` tool::\n-        \n-            from Products.CMFCore.utils import getToolByName\n-        \n-            propertiesTool = getToolByName(portal, \'portal_properties\')\n-            siteProperties = propertiesTool[\'site_properties\']\n-        \n-            siteProperties._setPropValue(\'many_users\', True)\n-        \n-        To assert the value of a property in a property sheet in the\n-        ``portal_properties`` tool::\n-        \n-            self.assertEqual(siteProperties.getProperty(\'many_users\'), True)\n-        \n-        Installing products and extension profiles\n-        ------------------------------------------\n-        \n-        To apply a particular extension profile::\n-        \n-            from plone.app.testing import applyProfile\n-        \n-            applyProfile(portal, \'my.product:default\')\n-        \n-        This is the preferred method of installing a product\'s configuration.\n-        \n-        To install an add-on product into the Plone site using the\n-        ``portal_quickinstaller`` tool::\n-        \n-            from plone.app.testing import quickInstallProduct\n-        \n-            quickInstallProduct(portal, \'my.product\')\n-        \n-        To re-install a product using the quick-installer::\n-        \n-            quickInstallProduct(portal, \'my.product\', reinstall=True)\n-        \n-        Note that both of these assume the product\'s ZCML has been loaded, which is\n-        usually done during layer setup. See the layer examples above for more details\n-        on how to do that.\n-        \n-        When writing a product that has an installation extension profile, it is often\n-        desirable to write tests that inspect the state of the site after the profile\n-        has been applied. Some of the more common such tests are shown below.\n-        \n-        To verify that a product has been installed (e.g. as a dependency via\n-        ``metadata.xml``)::\n-        \n-            from Products.CMFCore.utils import getToolByName\n-        \n-            quickinstaller = getToolByName(portal, \'portal_quickinstaller\')\n-            self.assertTrue(quickinstaller.isProductInstalled(\'my.product\'))\n-        \n-        To verify that a particular content type has been installed (e.g. via\n-        ``types.xml``)::\n-        \n-            typesTool = getToolByName(portal, \'portal_types\')\n-        \n-            self.assertNotEqual(typesTool.getTypeInfo(\'mytype\'), None)\n-        \n-        To verify that a new catalog index has been installed (e.g. via\n-        ``catalog.xml``)::\n-        \n-            catalog = getToolByName(portal, \'portal_catalog\')\n-        \n-            self.assertTrue(\'myindex\' in catalog.indexes())\n-        \n-        To verify that a new catalog metadata column has been added (e.g. via\n-        ``catalog.xml``)::\n-        \n-            self.assertTrue(\'myattr\' in catalog.schema())\n-        \n-        To verify that a new workflow has been installed (e.g. via\n-        ``workflows.xml``)::\n-        \n-            workflowTool = getToolByName(portal, \'portal_workflow\')\n-        \n-            self.assertNotEqual(workflowTool.getWorkflowById(\'my_workflow\'), None)\n-        \n-        To verify that a new workflow has been assigned to a type (e.g. via\n-        ``workflows.xml``)::\n-        \n-            self.assertEqual(dict(workflowTool.listChainOverrides())[\'mytype\'], (\'my_workflow\',))\n-        \n-        To verify that a new workflow has been set as the default (e.g. via\n-        ``workflows.xml``)::\n-        \n-            self.assertEqual(workflowTool.getDefaultChain(), (\'my_workflow\',))\n-        \n-        To test the value of a property in the ``portal_properties`` tool (e.g. set\n-        via ``propertiestool.xml``):::\n-        \n-            propertiesTool = getToolByName(portal, \'portal_properties\')\n-            siteProperties = propertiesTool[\'site_properties\']\n-        \n-            self.assertEqual(siteProperties.getProperty(\'some_property\'), "some value")\n-        \n-        To verify that a stylesheet has been installed in the ``portal_css`` tool\n-        (e.g. via ``cssregistry.xml``)::\n-        \n-            cssRegistry = getToolByName(portal, \'portal_css\')\n-        \n-            self.assertTrue(\'mystyles.css\' in cssRegistry.getResourceIds())\n-        \n-        To verify that a JavaScript resource has been installed in the\n-        ``portal_javascripts`` tool (e.g. via ``jsregistry.xml``)::\n-        \n-            jsRegistry = getToolByName(portal, \'portal_javascripts\')\n-        \n-            self.assertTrue(\'myscript.js\' in jsRegistry.getResourceIds())\n-        \n-        To verify that a new role has been added (e.g. via ``rolemap.xml``)::\n-        \n-            self.assertTrue(\'NewRole\' in portal.valid_roles())\n-        \n-        To verify that a permission has been granted to a given set of roles (e.g. via\n-        ``rolemap.xml``)::\n-        \n-            roles = [r[\'name\'] for r in portal.rolesOfPermission(\'My Permission\') if r[\'selected\']]\n-            self.assertEqual(roles, [\'Member\', \'Manager\'])\n-        \n-        Traversal\n-        ---------\n-        \n-        To traverse to a view, page template or other resource, use\n-        ``restrictedTraverse()`` with a relative path::\n-        \n-            resource = portal.restrictedTraverse(\'f1/@@folder_contents\')\n-        \n-        The return value is a view object, page template object, or other resource.\n-        It may be invoked to obtain an actual response (see below).\n-        \n-        ``restrictedTraverse()`` performs an explicit security check, and so may\n-        raise ``Unauthorized`` if the current test user does not have permission to\n-        view the given resource. If you don\'t want that, you can use::\n-        \n-            resource = portal.unrestrictedTraverse(\'f1/@@folder_contents\')\n-        \n-        You can call this on a folder or other content item as well, to traverse from\n-        that starting point, e.g. this is equivalent to the first example above::\n-        \n-            f1 = portal[\'f1\']\n-            resource = f1.restrictedTraverse(\'@@folder_contents\')\n-        \n-        Note that this traversal will not take ``IPublishTraverse`` adapters into\n-        account, and you cannot pass query string parameters. In fact,\n-        ``restrictedTraverse()`` and ``unrestrictedTraverse()`` implement the type of\n-        traversal that happens with path expressions in TAL, which is similar, but not\n-        identical to URL traversal.\n-        \n-        To look up a view manually::\n-        \n-            from zope.component import getMultiAdapter\n-        \n-            view = getMultiAdapter((f1, request), name=u"folder_contents")\n-        \n-        Note that the name here should not include the ``@@`` prefix.\n-        \n-        To simulate an ``IPublishTraverse`` adapter call, presuming the view\n-        implements ``IPublishTraverse``::\n-        \n-            next = view.IPublishTraverse(request, u"some-name")\n-        \n-        Or, if the ``IPublishTraverse`` adapter is separate from the view::\n-        \n-            from zope.publisher.interfaces import IPublishTraverse\n-        \n-            publishTraverse = getMultiAdapter((f1, request), IPublishTraverse)\n-            next = view.IPublishTraverse(request, u"some-name")\n-        \n-        To simulate a form submission or query string parameters::\n-        \n-            request.form.update({\n-                    \'name\': "John Smith",\n-                    \'age\':  23\n-                })\n-        \n-        The ``form`` dictionary contains the marshalled request. That is, if you are\n-        simulating a query string parameter or posted form variable that uses a\n-        marshaller like ``:int`` (e.g. ``age:int`` in the example above), the value\n-        in the ``form`` dictionary should be marshalled (an int instead of a string,\n-        in the example above), and the name should be the base name (``age`` instead\n-        of ``age:int``).\n-        \n-        To invoke a view and obtain the response body as a string::\n-        \n-            view = f1.restrictedTraverse(\'@@folder_contents\')\n-            body = view()\n-        \n-            self.assertFalse(u"An unexpected error occurred" in body)\n-        \n-        Please note that this approach is not perfect. In particular, the request\n-        is will not have the right URL or path information. If your view depends on\n-        this, you can fake it by setting the relevant keys in the request, e.g.::\n-        \n-            request.set(\'URL\', f1.absolute_url() + \'/@@folder_contents\')\n-            request.set(\'ACTUAL_URL\', f1.absolute_url() + \'/@@folder_contents\')\n-        \n-        To inspect the state of the request (e.g. after a view has been invoked)::\n-        \n-            self.assertEqual(request.get(\'disable_border\'), True)\n-        \n-        To inspect response headers (e.g. after a view has been invoked)::\n-        \n-            response = request.response\n-        \n-            self.assertEqual(response.getHeader(\'content-type\'), \'text/plain\')\n-        \n-        Simulating browser interaction\n-        ------------------------------\n-        \n-        End-to-end functional tests can use `zope.testbrowser`_ to simulate user\n-        interaction. This acts as a web browser, connecting to Zope via a special\n-        channel, making requests and obtaining responses.\n-        \n-          **Note:** zope.testbrowser runs entirely in Python, and does not simulate\n-          a JavaScript engine.\n-        \n-        Note that to use ``zope.testbrowser``, you need to use one of the functional\n-        testing layers, e.g. ``PLONE_FUNCTIONAL_TESTING``, or another layer\n-        instantiated with the ``FunctionalTesting`` class.\n-        \n-        If you want to create some initial content, you can do so either in a layer,\n-        or in the test itself, before invoking the test browser client. In the latter\n-        case, you need to commit the transaction before it becomes available, e.g.::\n-        \n-            from plone.app.testing import setRoles\n-            from plone.app.testing import TEST_USER_ID\n-        \n-            # Make some changes\n-            setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-            portal.invokeFactory(\'Folder\', \'f1\', title=u"Folder 1")\n-            setRoles(portal, TEST_USER_ID, [\'Member\'])\n-        \n-            # Commit so that the test browser sees these changes\n-            import transaction\n-            transaction.commit()\n-        \n-        To obtain a new test browser client::\n-        \n-            from plone.testing.z2 import Browser\n-        \n-            # This is usually self.app (Zope root) or site.portal (test Plone site root)\n-            browser = Browser(app)\n-        \n-        To open a given URL::\n-        \n-            portalURL = portal.absolute_url()\n-            browser.open(portalURL)\n-        \n-        To inspect the response::\n-        \n-            self.assertTrue(u"Welcome" in browser.contents)\n-        \n-        To inspect response headers::\n-        \n-            self.assertEqual(browser.headers[\'content-type\'], \'text/html; charset=utf-8\')\n-        \n-        To follow a link::\n-        \n-            browser.getLink(\'Edit\').click()\n-        \n-        This gets a link by its text. To get a link by HTML id::\n-        \n-            browser.getLink(id=\'edit-link\').click()\n-        \n-        To verify the current URL::\n-        \n-            self.assertEqual(portalURL + \'/edit\', browser.url)\n-        \n-        To set a form control value::\n-        \n-            browser.getControl(\'Age\').value = u"30"\n-        \n-        This gets the control by its associated label. To get a control by its form\n-        variable name::\n-        \n-            browser.getControl(name=\'age:int\').value = u"30"\n-        \n-        See the `zope.testbrowser`_ documentation for more details on how to select\n-        and manipulate various types of controls.\n-        \n-        To submit a form by clicking a button::\n-        \n-            browser.getControl(\'Save\').click()\n-        \n-        Again, this uses the label to find the control. To use the form variable\n-        name::\n-        \n-            browser.getControl(name=\'form.button.Save\').click()\n-        \n-        To simulate HTTP BASIC authentication and remain logged in for all\n-        requests::\n-        \n-            from plone.app.testing import TEST_USER_NAME, TEST_USER_PASSWORD\n-        \n-            browser.addHeader(\'Authorization\', \'Basic %s:%s\' % (TEST_USER_NAME, TEST_USER_PASSWORD,))\n-        \n-        To simulate logging in via the login form::\n-        \n-            browser.open(portalURL + \'/login_form\')\n-            browser.getControl(name=\'__ac_name\').value = TEST_USER_NAME\n-            browser.getControl(name=\'__ac_password\').value = TEST_USER_PASSWORD\n-            browser.getControl(name=\'submit\').click()\n-        \n-        To simulate logging out::\n-        \n-            browser.open(portalURL + \'/logout\')\n-        \n-        Debugging tips\n-        ~~~~~~~~~~~~~~\n-        \n-        By default, only HTTP error codes (e.g. 500 Server Side Error) are shown when\n-        an error occurs on the server. To see more details, set ``handleErrors`` to\n-        False::\n-        \n-            browser.handleErrors = False\n-        \n-        To inspect the error log and obtain a full traceback of the latest entry::\n-        \n-            from Products.CMFCore.utils import getToolByName\n-        \n-            errorLog = getToolByName(portal, \'error_log\')\n-            print errorLog.getLogEntries()[-1][\'tb_text\']\n-        \n-        To save the current response to an HTML file::\n-        \n-            open(\'/tmp/testbrowser.html\', \'w\').write(browser.contents)\n-        \n-        You can now open this file and use tools like Firebug to inspect the structure\n-        of the page. You should remove the file afterwards.\n-        \n-        Comparison with ZopeTestCase/PloneTestCase\n-        ==========================================\n-        \n-        `plone.testing`_ and ``plone.app.testing`` have in part evolved from\n-        ``ZopeTestCase``, which ships with Zope 2 in the ``Testing`` package, and\n-        `Products.PloneTestCase`_, which ships with Plone and is used by Plone itself\n-        as well as numerous add-on products.\n-        \n-        If you are familiar with ``ZopeTestCase`` and ``PloneTestCase``, the concepts\n-        of these package should be familiar to you. However, there are some important\n-        differences to bear in mind.\n-        \n-        * ``plone.testing`` and ``plone.app.testing`` are unburdened by the legacy\n-          support that ``ZopeTestCase`` and ``PloneTestCase`` have to include. This\n-          makes them smaller and easier to understand and maintain.\n-        \n-        * Conversely, ``plone.testing`` only works with Python 2.6 and Zope 2.12 and\n-          later. ``plone.app.testing`` only works with Plone 4 and later. If you need\n-          to write tests that run against older versions of Plone, you\'ll need to use\n-          ``PloneTestCase``.\n-        \n-        * ``ZopeTestCase``/``PloneTestCase`` were written before layers were available\n-          as a setup mechanism. ``plone.testing`` is very layer-oriented.\n-        \n-        * ``PloneTestCase`` provides a base class, also called ``PloneTestCase``,\n-          which you must use, as it performs setup and tear-down. ``plone.testing``\n-          moves shared state to layers and layer resources, and does not impose any\n-          particular base class for tests. This does sometimes mean a little more\n-          typing (e.g. ``self.layer[\'portal\']`` vs. ``self.portal``), but it makes\n-          it much easier to control and re-use test fixtures. It also makes your\n-          test code simpler and more explicit.\n-        \n-        * ``ZopeTestCase`` has an ``installProduct()`` function and a corresponding\n-          ``installPackage()`` function. `plone.testing`_ has only an\n-          ``installProduct()``, which can configure any kind of Zope 2 product (i.e.\n-          packages in the ``Products.*`` namespace, old-style products in a special\n-          ``Products`` folder, or packages in any namespace that have had their ZCML\n-          loaded and which include a ``<five:registerPackage />`` directive in their\n-          configuration). Note that you must pass a full dotted name to this function,\n-          even for "old-style" products in the ``Products.*`` namespace, e.g.\n-          ``Products.LinguaPlone`` instead of ``LinguaPlone``.\n-        \n-        * On setup, ``PloneTestCase`` will load Zope 2\'s default ``site.zcml``. This\n-          in turn will load all ZCML for all packages in the ``Products.*`` namespace.\n-          ``plone.testing`` does not do this (and you are strongly encouraged from\n-          doing it yourself), because it is easy to accidentally include packages in\n-          your fixture that you didn\'t intend to be there (and which can actually\n-          change the fixture substantially). You should load your package\'s ZCML\n-          explicitly. See the `plone.testing`_ documentation for details.\n-        \n-        * When using ``PloneTestCase``, any package that has been loaded onto\n-          ``sys.path`` and which defines the ``z3c.autoinclude.plugin:plone`` entry\n-          point will be loaded via `z3c.autoinclude`_\'s plugin mechanism. This loading\n-          is explicitly disabled, for the same reasons that the ``Products.*`` auto-\n-          loading is. You should load your packages\' configuration explicitly.\n-        \n-        * ``PloneTestCase`` sets up a basic fixture that has member folder enabled,\n-          and in which the test user\'s member folder is available as ``self.folder``.\n-          The ``plone_workflow`` workflow is also installed as the default.\n-          ``plone.app.testing`` takes a more minimalist approach. To create a test\n-          folder owned by the test user that is similar to ``self.folder`` in a\n-          ``PloneTestCase``, you can do::\n-        \n-                import unittest2 as unittest\n-                from plone.app.testing import TEST_USER_ID, setRoles\n-                from plone.app.testing import PLONE_INTEGRATION_TESTING\n-        \n-                class MyTest(unitest.TestCase):\n-        \n-                    layer = PLONE_INTEGRATION_TESTING\n-        \n-                    def setUp(self):\n-                        self.portal = self.layer[\'portal\']\n-        \n-                        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n-                        self.portal.invokeFactory(\'Folder\', \'test-folder\')\n-                        setRoles(self.portal, TEST_USER_ID, [\'Member\'])\n-        \n-                        self.folder = self.portal[\'test-folder\']\n-        \n-          You could of course do this type of setup in your own layer and expose it\n-          as a resource instead.\n-        \n-        * To use `zope.testbrowser`_ with ``PloneTestCase``, you should use its\n-          ``FunctionalTestCase`` as a base class, and then use the following pattern::\n-        \n-                from Products.Five.testbrowser import Browser\n-                browser = Browser()\n-        \n-          The equivalent pattern in ``plone.app.testing`` is to use the\n-          ``FunctionalTesting`` test lifecycle layer (see example above), and then\n-          use::\n-        \n-                from plone.testing.z2 import Browser\n-                browser = Browser(self.layer[\'app\'])\n-        \n-          Also note that if you have made changes to the fixture prior to calling\n-          ``browser.open()``, they will *not* be visible until you perform an\n-          explicit commit. See the ``zope.testbrowser`` examples above for details.\n-        \n-        .. _plone.testing: http://pypi.python.org/pypi/plone.testing\n-        .. _zope.testing: http://pypi.python.org/pypi/zope.testing\n-        .. _z3c.autoinclude: http://pypi.python.org/pypi/z3c.autoinclude\n-        .. _zope.testbrowser: http://pypi.python.org/pypi/zope.testbrowser\n-        .. _Products.PloneTestCase: http://pypi.python.org/pypi/Products.PloneTestCase\n-        \n-        \n-        Changelog\n-        =========\n-        \n-        6.0.0 (unreleased)\n-        ------------------\n-        \n-        Breaking changes:\n-        \n-        - *add item here*\n-        \n-        New features:\n-        \n-        - Install and load zcml of CMFQuickInstallerTool only when importable.\n-          [maurits]\n-        \n-        - Load negotiator from plone.i18n (PTS removed).\n-          [jensens, ksuess]\n-        \n-        Bug fixes:\n-        \n-        - *add item here*\n-        \n-        \n-        5.0.8 (2017-10-25)\n-        ------------------\n-        \n-        Bug fixes:\n-        \n-        - Load Products.PageTemplates ZCML.  [tschorr]\n-        \n-        \n-        5.0.7 (2017-07-03)\n-        ------------------\n-        \n-        Bug fixes:\n-        \n-        - Remove deprecated __of__ calls on BrowserViews\n-          [MrTango]\n-        \n-        - Remove unittest2 dependency\n-          [kakshay21]\n-        \n-        \n-        5.0.6 (2016-12-19)\n-        ------------------\n-        \n-        Bug fixes:\n-        \n-        - No longer try to load `Products.SecureMailHost` and its zcml.\n-          This is not shipped with Plone 5.0 or higher.  [maurits]\n-        \n-        \n-        5.0.5 (2016-11-19)\n-        ------------------\n-        \n-        Bug fixes:\n-        \n-        - Do not use install Products.PasswordResetTool in the PloneFixture if it isn\'t available.\n-          [thet]\n-        \n-        \n-        5.0.4 (2016-09-23)\n-        ------------------\n-        \n-        New features:\n-        \n-        - Use get_installer instead of portal_quickinstaller when available, for\n-          Plone 5.1 and higher.  [maurits]\n-        \n-        - In PloneSandboxLayer make profile upgrade versions persistent.  This\n-          way installed profile versions get reset in teardown.  [maurits]\n-        \n-        \n-        5.0.3 (2016-09-07)\n-        ------------------\n-        \n-        Bug fixes:\n-        \n-        - Load Products.CMFFormController in tests.  It is still used by core\n-          Plone, also without Archetypes.  This makes the CMFFormController\n-          tests pass.  [maurits]\n-        \n-        \n-        5.0.2 (2016-06-07)\n-        ------------------\n-        \n-        Fixes:\n-        \n-        - Do not use install Products.SecureMailHost in the PloneFixture if it isn\'t available\n-          [vangheem]\n-        \n-        \n-        5.0.1 (2016-02-26)\n-        ------------------\n-        \n-        Fixes:\n-        \n-        - Replace deprecated ``zope.site.hooks`` import with ``zope.component.hooks``.\n-          [thet]\n-        \n-        \n-        5.0.0 (2016-02-20)\n-        ------------------\n-        \n-        New:\n-        \n-        - Add a MOCK_MAILHOST_FIXTURE fixture that integration and functional tests layers can depend on.\n-          This allows to easily check how mails are sent from Plone.\n-          [gforcada]\n-        \n-        Fixes:\n-        \n-        - Fix ``layers.rst`` doctest to be compatible with older and newer zope.testrunner layer ordering.\n-          [thet]\n-        \n-        - Depend on ``zope.testrunner`` and fix deprecated usage of ``zope.testing.testrunner``.\n-          [thet]\n-        \n-        - Cleanup code, flake8, sort imports, etc.\n-          [gforcada]\n-        \n-        - Fix RAM cache error with bbb.PloneTestCase.\n-          [ebrehault]\n-        \n-        \n-        5.0b6 (2015-08-22)\n-        ------------------\n-        \n-        - No need for unittest2.\n-          [gforcada]\n-        \n-        \n-        5.0b5 (2015-07-18)\n-        ------------------\n-        \n-        - Do not install CMFDefault.\n-          [tomgross]\n-        \n-        - Document PloneWithPackageLayer.\n-          [gotcha]\n-        \n-        \n-        5.0b4 (2015-05-04)\n-        ------------------\n-        \n-        - Do not install CMFFormController.\n-          [timo]\n-        \n-        - Do not install CMFDefault\n-          [tomgross]\n-        \n-        5.0b3 (2015-03-26)\n-        ------------------\n-        \n-        - Remove PloneLanguageTool from PloneFixture.\n-          [timo]\n-        \n-        \n-        5.0b2 (2015-03-13)\n-        ------------------\n-        \n-        - remove test of applying an extension profile, we don\'t have a good one to\n-          test now.\n-          [davidagli]\n-        \n-        - fix test, plone.app.theming does not get recorded as installed .\n-          [davisagli]\n-        \n-        - fix: ``Products.CMFPlone`` needs the ``gopip`` index from\n-          ``plone.app.folder``. So latter has to be initialized before CMFPlones\n-          profile is applied (which installs the index to catalog). At the moment\n-          CMFPlone therefore registers the index itself, but plone.app.folder\n-          registers it too, which resulted in plone/Products.CMFPlone#313\n-          "GopipIndex registered twice" In tests the registration does not succedd,\n-          because plone.app.folder was never initialized as z2 products. In order to\n-          remove the misleading regisatration from CMFPlone we must take care that the\n-          index is available, which is achieved with this change. Also minor pep8\n-          optimizations in the file touched.\n-          [jensens]\n-        \n-        - create memberfolder, if it is not there for testing.\n-          [tomgross]\n-        \n-        \n-        5.0b1 (2014-10-23)\n-        ------------------\n-        \n-        - Allow applyProfile to skip steps and all other options supported by\n-          runAllImportStepsFromProfile of portal_setup-tool.\n-          [pbauer, tomgross]\n-        \n-        \n-        5.0a2 (2014-04-19)\n-        ------------------\n-        \n-        - Install Products.DateRecurringIndex for the PLONE_FIXTURE Layer.\n-          [thet]\n-        \n-        \n-        5.0a1 (2014-02-22)\n-        ------------------\n-        \n-        - Add \'ROBOT_TEST_LEVEL\' to interfaces, so other packages can import it. This\n-          makes things easier if we decide to change the value.\n-          [timo]\n-        \n-        - Replace deprecated test assert statements.\n-          [timo]\n-        \n-        - plonetheme.classic no longer ships with Plone, don\'t use it for\n-          testing.\n-          [esteele]\n-        \n-        - Clean up the zodbDB and configurationContext resources if there\n-          is an error during the PloneSandboxLayer setUp.\n-          [davisagli]\n-        \n-        - Make PLONE_FIXTURE not install a content type system.\n-          Packages that need content types to run their tests should\n-          pick the appropriate fixture from plone.app.contenttypes\n-          or Products.ATContentTypes.\n-          [davisagli]\n-        \n-        - Pin [robot] extra to ``robotsuite>=1.4.0``.\n-          [saily]\n-        \n-        - Fix wrong spelling of ``reinstallProducts`` method in quickInstallProduct.\n-          [saily]\n-        \n-        - Sync bbb PloneTestCase class with original one.\n-          [tomgross]\n-        \n-        \n-        4.2.2 (2013-02-09)\n-        ------------------\n-        \n-        - Add [robot] extras for requiring dependnecies for Robot Framework\n-          tests with Selenium2Library\n-          [datakurre]\n-        \n-        - Install PythonScripts as zope product\n-          [mikejmets]\n-        \n-        \n-        4.2.1 (2012-12-15)\n-        ------------------\n-        \n-        - Allow testing with non standard port. Allows running multiple test suites\n-          in parallel.\n-          [do3cc]\n-        \n-        - Documentation updates.\n-          [moo]\n-        \n-        \n-        4.2 (2012-04-15)\n-        ----------------\n-        \n-        - Branch as 4.2 as the plone.app.collection addition breaks backwards\n-          compatibility.\n-          [esteele]\n-        \n-        - Fixed spurious failure in our own tests by using a longer timeout.\n-          [maurits]\n-        \n-        - plone.app.collection added to PloneFixture.\n-          [timo]\n-        \n-        \n-        4.0.2 (2011-08-31)\n-        ------------------\n-        \n-        - Load ZCML before installing Zope products in ``PloneWithPackageLayer``;\n-          it enables package registration.\n-          [gotcha]\n-        \n-        \n-        4.0.1 (2011-07-14)\n-        ------------------\n-        \n-        - Add ``additional_z2_products`` parameter to ``PloneWithPackageLayer``\n-          helper class to install additional Zope 2 products.\n-          [jfroche]\n-        \n-        \n-        4.0 - 2011-05-13\n-        ------------------\n-        \n-        - 4.0 Final release.\n-          [esteele]\n-        \n-        - Add MANIFEST.in.\n-          [WouterVH]\n-        \n-        \n-        4.0a6 - 2011-04-06\n-        ------------------\n-        \n-        - Added helper functions for selenium layer. (Copied from SeleniumTestCase\n-          within Products.CMFPlone/Products/CMFPlone/tests/selenium/base.py)\n-          [emanlove]\n-        \n-        - Rework layer setup of SeleniumLayer so that z2.ZSERVER_FIXTURE is a\n-          default_base.\n-          [esteele]\n-        \n-        - Convert the passed-in selenium webdriver name to lowercase before doing a\n-          module lookup.\n-          [esteele]\n-        \n-        - Moved selenium start up and tear down to testSetUp and testTearDown,\n-          respectively.  This was done to help further isolate individual tests.\n-          For example, logging in under one test would require either logging out\n-          or shutting down the browser, which is what the selenium_layer will now\n-          do under testTearDown, in order to have a "clean" state within the next\n-          test.\n-          [emanlove]\n-        \n-        - Corrected module path for the various selenium webdrivers using\n-          selenium 2.0b2.\n-          [emanlove]\n-        \n-        \n-        4.0a5 - 2011-03-02\n-        ------------------\n-        \n-        - Use the new ``plone.testing.security`` module to ensure isolation of\n-          security checkers when setting up and tearing down layers based on the\n-          ``PloneSandboxLayer`` helper base class. This would cause problems when\n-          running multiple test suites in the same test run, in particular if one of\n-          those suites were setting up ZCML that used ``five.grok``.\n-          [optilude]\n-        \n-        \n-        4.0a4 - 2011-01-11\n-        ------------------\n-        \n-        - Automatically tear down PAS registrations via snapshotting when using\n-          ``PloneSandboxLayer``. It\'s too difficult to do this manually when you\n-          consider that plugins may be registered in ZCML via transitive dependencies.\n-          There should be no backwards compatibility concern - using\n-          ``tearDownMultiPlugin()`` is still supported, and it\'s generally safe to\n-          call it once.\n-          [optilude]\n-        \n-        - Try to make sure ``tearDownMultiPlugin()`` and the generic PAS plugin\n-          cleanup handler do not interfere with the cleanup handler from the PAS\n-          ZCML directive.\n-          [optilude]\n-        \n-        - Do not install ``Products.kupu`` or ``Products.CMFPlacefulWorkflow``.\n-          [elro]\n-        \n-        - Depend on ``Products.CMFPlone`` instead of ``Plone``.\n-          [elro]\n-        \n-        \n-        4.0a3 - 2010-12-14\n-        ------------------\n-        \n-        - Allow top-level import of PloneTestLifecycle.\n-          [stefan]\n-        \n-        - Added a warning not to use \'default\' Firefox profile for selenium tests.\n-          [zupo]\n-        \n-        - Fixed distribution dependency declarations.\n-          [hannosch]\n-        \n-        - Correct license to GPL version 2 only.\n-          [hannosch]\n-        \n-        - Make some module imports helper methods on the already policy-heavy\n-          helper class per optilude\'s suggestion.\n-          [rossp]\n-        \n-        - Add a layer and test case for running selenium tests.\n-          [rossp]\n-        \n-        - Give the default test user differing user id and login name. This helps reveal\n-          problems with userid vs login name errors, an overly common error.\n-          [wichert]\n-        \n-        \n-        1.0a2 - 2010-09-05\n-        ------------------\n-        \n-        - Make sure plone.app.imaging is installed properly during layer setup.\n-          [optilude]\n-        \n-        \n-        1.0a1 - 2010-08-01\n-        ------------------\n-        \n-        - Initial release\n-        \n-Keywords: plone tests\n-Platform: UNKNOWN\n-Classifier: Environment :: Web Environment\n-Classifier: Framework :: Plone\n-Classifier: Framework :: Plone :: 5.0\n-Classifier: Framework :: Plone :: 5.1\n-Classifier: Framework :: Plone :: 5.2\n-Classifier: Framework :: Zope2\n-Classifier: License :: OSI Approved :: GNU General Public License v2 (GPLv2)\n-Classifier: Operating System :: OS Independent\n-Classifier: Programming Language :: Python\n-Classifier: Programming Language :: Python :: 2.7\n-Classifier: Programming Language :: Python :: 3.5\n-Classifier: Programming Language :: Python :: 3.6\n-Classifier: Programming Language :: Python :: 3.7\n-Classifier: Topic :: Internet :: WWW/HTTP :: Dynamic Content\n-Provides-Extra: test\n-Provides-Extra: robot\ndiff --git a/src/plone.app.testing.egg-info/SOURCES.txt b/src/plone.app.testing.egg-info/SOURCES.txt\ndeleted file mode 100644\nindex 5deb4a0..0000000\n--- a/src/plone.app.testing.egg-info/SOURCES.txt\n+++ /dev/null\n@@ -1,32 +0,0 @@\n-CHANGES.rst\n-CONTRIBUTING.rst\n-MANIFEST.in\n-README.rst\n-setup.cfg\n-setup.py\n-docs/LICENSE.GPL\n-docs/LICENSE.txt\n-docs/README.rst\n-docs/conf.py\n-docs/index.rst\n-docs/isolation.rst\n-docs/views.rst\n-docs/zope-testbrowser.rst\n-src/plone/__init__.py\n-src/plone.app.testing.egg-info/PKG-INFO\n-src/plone.app.testing.egg-info/SOURCES.txt\n-src/plone.app.testing.egg-info/dependency_links.txt\n-src/plone.app.testing.egg-info/namespace_packages.txt\n-src/plone.app.testing.egg-info/not-zip-safe\n-src/plone.app.testing.egg-info/requires.txt\n-src/plone.app.testing.egg-info/top_level.txt\n-src/plone/app/__init__.py\n-src/plone/app/testing/__init__.py\n-src/plone/app/testing/bbb.py\n-src/plone/app/testing/cleanup.py\n-src/plone/app/testing/helpers.py\n-src/plone/app/testing/interfaces.py\n-src/plone/app/testing/layers.py\n-src/plone/app/testing/selenium_layers.py\n-src/plone/app/testing/tests.py\n-src/plone/app/testing/utils.py\n\\ No newline at end of file\ndiff --git a/src/plone.app.testing.egg-info/dependency_links.txt b/src/plone.app.testing.egg-info/dependency_links.txt\ndeleted file mode 100644\nindex 8b13789..0000000\n--- a/src/plone.app.testing.egg-info/dependency_links.txt\n+++ /dev/null\n@@ -1 +0,0 @@\n-\ndiff --git a/src/plone.app.testing.egg-info/namespace_packages.txt b/src/plone.app.testing.egg-info/namespace_packages.txt\ndeleted file mode 100644\nindex 003a209..0000000\n--- a/src/plone.app.testing.egg-info/namespace_packages.txt\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-plone\n-plone.app\ndiff --git a/src/plone.app.testing.egg-info/not-zip-safe b/src/plone.app.testing.egg-info/not-zip-safe\ndeleted file mode 100644\nindex 8b13789..0000000\n--- a/src/plone.app.testing.egg-info/not-zip-safe\n+++ /dev/null\n@@ -1 +0,0 @@\n-\ndiff --git a/src/plone.app.testing.egg-info/requires.txt b/src/plone.app.testing.egg-info/requires.txt\ndeleted file mode 100644\nindex d0388dd..0000000\n--- a/src/plone.app.testing.egg-info/requires.txt\n+++ /dev/null\n@@ -1,29 +0,0 @@\n-setuptools\n-zope.configuration\n-zope.component\n-zope.dottedname\n-zope.testing\n-five.localsitemanager\n-plone.memoize\n-plone.testing[security,z2,zca,zodb]\n-Products.CMFPlone\n-Products.GenericSetup\n-Zope2\n-\n-[robot]\n-robotsuite>=1.4.0\n-robotframework-selenium2library\n-decorator\n-selenium\n-\n-[test]\n-Products.CMFCore\n-Products.CMFPlone\n-Products.PluggableAuthService\n-Products.CMFPlacefulWorkflow\n-selenium\n-transaction\n-zope.interface\n-zope.publisher\n-zope.testrunner\n-zope.testing\ndiff --git a/src/plone.app.testing.egg-info/top_level.txt b/src/plone.app.testing.egg-info/top_level.txt\ndeleted file mode 100644\nindex 1d2c38d..0000000\n--- a/src/plone.app.testing.egg-info/top_level.txt\n+++ /dev/null\n@@ -1 +0,0 @@\n-plone\ndiff --git a/src/plone/app/testing/cleanup.py b/src/plone/app/testing/cleanup.py\nindex eb227a4..b6eaeca 100644\n--- a/src/plone/app/testing/cleanup.py\n+++ b/src/plone/app/testing/cleanup.py\n@@ -13,7 +13,7 @@\n \n # Make sure cleanup handlers from PAS are registered\n try:\n-    import Products.PluggableAuthService.zcml\n+    import Products.PluggableAuthService.zcml  # NOQA: F401\n except ImportError:\n     pass\n \ndiff --git a/src/plone/app/testing/layers.py b/src/plone/app/testing/layers.py\nindex cdc0e81..8257351 100644\n--- a/src/plone/app/testing/layers.py\n+++ b/src/plone/app/testing/layers.py\n@@ -66,17 +66,17 @@ class PloneFixture(Layer):\n         (\'Products.PythonScripts\', {\'loadZCML\': False}, ),\n     )\n \n-    #try:\n+    # try:\n     #    import Products.PasswordResetTool\n     #    products = products + (\n     #        (\'Products.PasswordResetTool\', {\'loadZCML\': True}, ),)\n-    #except ImportError:\n+    # except ImportError:\n     #    pass\n-    #try:\n+    # try:\n     #    import Products.CMFQuickInstallerTool\n     #    products = products + (\n     #        (\'Products.CMFQuickInstallerTool\', {\'loadZCML\': True}, ),)\n-    #except ImportError:\n+    # except ImportError:\n     #    pass\n \n     # Extension profiles to be installed with site setup\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-05-05T15:27:03+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.app.testing/commit/6a1c38acec854f1d79c8fc6bad961ad19063f974

Fix typo

Files changed:
M .editorconfig

b'diff --git a/.editorconfig b/.editorconfig\nindex 512361c..626f406 100644\n--- a/.editorconfig\n+++ b/.editorconfig\n@@ -1,4 +1,4 @@\n-# EditorConfig Configurtaion file, for more details see:\n+# EditorConfig Configuration file, for more details see:\n # http://EditorConfig.org\n # EditorConfig is a convention description, that could be interpreted\n # by multiple editors to enforce common coding conventions for specific\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-05-05T16:05:28+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.app.testing/commit/ddbc331f2a72842d6b5f7d99d818efa93cd102a8

Fix some tests

Files changed:
M CHANGES.rst
M src/plone/app/testing/helpers.rst
M src/plone/app/testing/layers.rst

b"diff --git a/CHANGES.rst b/CHANGES.rst\nindex 2057fee..e55a0b4 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -18,8 +18,8 @@ New features:\n \n Bug fixes:\n \n-- *add item here*\n-\n+- Improve compatibility with Python3\n+  [loechel, ale-rt]\n \n 5.0.8 (2017-10-25)\n ------------------\ndiff --git a/src/plone/app/testing/helpers.rst b/src/plone/app/testing/helpers.rst\nindex a67bd2f..eb7bf5c 100644\n--- a/src/plone/app/testing/helpers.rst\n+++ b/src/plone/app/testing/helpers.rst\n@@ -138,7 +138,7 @@ Let's now simulate layer setup:\n     >>> setupLayers = {}\n     >>> runner.setup_layer(options, HELPER_DEMOS_INTEGRATION_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-      Set up plone.testing.z2.Startup in ... seconds.\n+      Set up plone.testing.zope.Startup in ... seconds.\n       Set up plone.app.testing.layers.PloneFixture in ... seconds.\n       Set up HelperDemos in ... seconds.\n       Set up plone.app.testing.layers.HelperDemos:Integration in ... seconds.\n@@ -256,7 +256,7 @@ Let's tear down the rest of the layers too.\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n     Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n Plone sandbox layer helper\n@@ -351,7 +351,7 @@ Let's now simulate layer setup:\n     >>> setupLayers = {}\n     >>> runner.setup_layer(options, MY_INTEGRATION_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n     Set up plone.app.testing.layers.PloneFixture in ... seconds.\n     Set up MyLayer in ... seconds.\n     Set up plone.app.testing.layers.MyLayer:Integration in ... seconds.\n@@ -438,7 +438,7 @@ Let's tear down the rest of the layers too.\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n     Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n Other helpers\ndiff --git a/src/plone/app/testing/layers.rst b/src/plone/app/testing/layers.rst\nindex 9e65987..2f92111 100644\n--- a/src/plone/app/testing/layers.rst\n+++ b/src/plone/app/testing/layers.rst\n@@ -44,10 +44,11 @@ Let's set up the fixture layer and inspect the state of the site.\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_FIXTURE, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+    >>> runner.setup_layer(options, layers.PLONE_FIXTURE, setupLayers)  # doctest: +ELLIPSIS\n+      Set up plone.testing.zca.LayerCleanup in ... seconds.\n+      Set up plone.testing.zope.Startup in ... seconds.\n+      Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+\n \n The application root's ``acl_users`` folder will have one user, whose name and\n password are found in the constants ``SITE_OWNER_NAME`` and\n@@ -99,7 +100,7 @@ Layer tear-down resets the environment.\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n     Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n Integration testing\n@@ -120,7 +121,7 @@ Let's set up the layers and attempt to run a test.\n     >>> setupLayers = {}\n     >>> runner.setup_layer(options, layers.PLONE_INTEGRATION_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n     Set up plone.app.testing.layers.PloneFixture in ... seconds.\n     Set up plone.app.testing.layers.Plone:Integration in ... seconds.\n \n@@ -188,7 +189,7 @@ Layer tear-down resets the environment.\n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n     Tear down plone.app.testing.layers.Plone:Integration in ... seconds.\n     Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n Functional testing\n@@ -209,7 +210,7 @@ Let's set up the layers and attempt to run a test.\n     >>> setupLayers = {}\n     >>> runner.setup_layer(options, layers.PLONE_FUNCTIONAL_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n     Set up plone.app.testing.layers.PloneFixture in ... seconds.\n     Set up plone.app.testing.layers.Plone:Functional in ... seconds.\n \n@@ -268,7 +269,7 @@ Layer tear-down resets the environment.\n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n     Tear down plone.app.testing.layers.Plone:Functional in ... seconds.\n     Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n HTTP server\n@@ -288,7 +289,7 @@ two bases: ``PLONE_FIXTURE``, as shown above, and ``ZSERVER_FIXTURE`` from\n     >>> setupLayers = {}\n     >>> runner.setup_layer(options, layers.PLONE_ZSERVER, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n     Set up plone.app.testing.layers.PloneFixture in ... seconds.\n     Set up plone.testing.z2.ZServer in ... seconds.\n     Set up plone.app.testing.layers.Plone:ZServer in ... seconds.\n@@ -368,7 +369,7 @@ When the server is torn down, the ZServer thread is stopped.\n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n     Tear down plone.app.testing.layers.Plone:ZServer in ... seconds.\n     ...Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    ...Tear down plone.testing.z2.Startup in ... seconds.\n+    ...Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n     >>> conn = urllib2.urlopen(portal_url + '/folder1', timeout=5)\n@@ -393,7 +394,7 @@ from ``plone.testing``, which starts up an FTP server thread.\n     >>> setupLayers = {}\n     >>> runner.setup_layer(options, layers.PLONE_FTP_SERVER, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n     Set up plone.app.testing.layers.PloneFixture in ... seconds.\n     Set up plone.testing.z2.FTPServer in ... seconds.\n     Set up plone.app.testing.layers.Plone:FTPServer in ... seconds.\n@@ -486,10 +487,10 @@ When the server is torn down, the FTP server thread is stopped.\n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n     Tear down plone.app.testing.layers.Plone:FTPServer in ... seconds.\n     ...Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    ...Tear down plone.testing.z2.Startup in ... seconds.\n+    ...Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n     >>> ftpClient.connect(host, port, timeout=5)\n     Traceback (most recent call last):\n     ...\n-    error: [Errno ...] Connection refused\n+    ... [Errno ...] Connection refused\n"

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-05-17T15:54:49+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.app.testing/commit/329ffc4da5ef83ba5ea2e97c8fa59cdefcf3b9fc

Fix tests so they run successfully on Python 2 against the py3 branch of plone.testing.

Files changed:
M buildout.cfg
M src/plone/app/testing/helpers.py
M src/plone/app/testing/helpers.rst
M src/plone/app/testing/layers.py
M src/plone/app/testing/layers.rst
M tox.ini

b'diff --git a/buildout.cfg b/buildout.cfg\nindex 2f81926..b41368c 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -1,5 +1,6 @@\n [buildout]\n extends = https://raw.githubusercontent.com/collective/buildout.plonetest/master/test-5.x.cfg\n+          https://raw.githubusercontent.com/plone/buildout.coredev/5.2/versions.cfg\n \n parts =\n     coverage\n@@ -14,15 +15,11 @@ extensions = mr.developer\n sources = sources\n versions = versions\n \n-auto-checkout =\n-    plone.testing\n-#    Products.GenericSetup\n+auto-checkout = *\n \n sources-dir = src-mrd\n \n-develop =\n-    src-mrd/plone.testing\n-#    src-mrd/Products.GenericSetup\n+develop = .\n \n [remotes]\n plone = git://github.com/plone\n@@ -33,19 +30,22 @@ zope_push = git@github.com:zopefoundation\n \n [versions]\n plone.app.testing =\n-Products.GenericSetup =\n+Products.GenericSetup = >= 2.0b1\n+Products.PluginRegistry = >= 1.6\n \n [sources]\n plone.testing         = git ${remotes:plone}/plone.testing.git pushurl=${remotes:plone_push}/plone.testing.git branch=py3\n-#Products.GenericSetup = git ${remotes:zope}/Products.GenericSetup.git pushurl=${remotes:plone_push}/Products.GenericSetup branch=master\n+Products.PluggableAuthService = git ${remotes:zope}/Products.PluggableAuthService.git pushurl=${remotes:zope_push}/Products.PluggableAuthService.git branch=master\n+Products.CMFPlone = git ${remotes:plone}/Products.CMFPlone.git pushurl=${remotes:plone_push}/Products.CMFPlone.git branch=master\n+Products.PlonePAS = git ${remotes:plone}/Products.PlonePAS.git pushurl=${remotes:plone_push}/Products.PlonePAS.git branch=master\n \n [test]\n-recipe = collective.xmltestreport\n+recipe = zc.recipe.testrunner\n eggs =\n     Pillow\n     plone.testing [test]\n     plone.app.testing [test]\n-defaults = [\'--auto-color\', \'--auto-progress\']\n+defaults = [\'--auto-color\']\n selenium-driver =\n environment = testenv\n \ndiff --git a/src/plone/app/testing/helpers.py b/src/plone/app/testing/helpers.py\nindex 1a60080..6401d0d 100644\n--- a/src/plone/app/testing/helpers.py\n+++ b/src/plone/app/testing/helpers.py\n@@ -234,7 +234,7 @@ def persist_profile_upgrade_versions(portal):\n \n \n @contextlib.contextmanager\n-def ploneSite(db=None, connection=None, environ=None):\n+def ploneSite(db=None, connection=None, environ=None, flavour=z2):\n     """Context manager for working with the Plone portal during layer setup::\n \n         with ploneSite() as portal:\n@@ -249,11 +249,14 @@ def ploneSite(db=None, connection=None, environ=None):\n     Pass a ZODB handle as ``db`` to use a specificdatabase. Alternatively,\n     pass an open connection as ``connection`` (the connection will not be\n     closed).\n+\n+    flavour ... either `plone.testing.z2` resp. `plone.testing.zope` for WSGI\n+                or `plone.testing.zserver` for ZServer\n     """\n     setHooks()\n     site = getSite()\n \n-    with z2.zopeApp(db, connection, environ) as app:\n+    with getattr(flavour, \'zopeApp\')(db, connection, environ) as app:\n         portal = app[PLONE_SITE_ID]\n \n         setSite(portal)\ndiff --git a/src/plone/app/testing/helpers.rst b/src/plone/app/testing/helpers.rst\nindex eb7bf5c..9027d49 100644\n--- a/src/plone/app/testing/helpers.rst\n+++ b/src/plone/app/testing/helpers.rst\n@@ -183,8 +183,8 @@ the ``ploneSite()`` context manager as shown above.\n \n     >>> portal = HELPER_DEMOS_INTEGRATION_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n \n-    >>> getSecurityManager().getUser().getRolesInContext(portal)\n-    [\'Member\', \'Authenticated\']\n+    >>> sorted(getSecurityManager().getUser().getRolesInContext(portal))\n+    [\'Authenticated\', \'Member\']\n \n     >>> getSecurityManager().getUser().getUserName() == TEST_USER_NAME\n     True\ndiff --git a/src/plone/app/testing/layers.py b/src/plone/app/testing/layers.py\nindex 8257351..3dd3b20 100644\n--- a/src/plone/app/testing/layers.py\n+++ b/src/plone/app/testing/layers.py\n@@ -17,6 +17,8 @@\n from plone.testing import z2\n from plone.testing import zca\n from plone.testing import zodb\n+from plone.testing import zope\n+from plone.testing import zserver\n from Products.MailHost.interfaces import IMailHost\n from zope.component import getSiteManager\n from zope.component.hooks import setSite\n@@ -252,6 +254,47 @@ def setUpDefaultContent(self, app):\n PLONE_FIXTURE = PloneFixture()\n \n \n+class PloneZServerFixture(PloneFixture):\n+    """PloneFixture using ZServer if you really have to.\n+\n+    e. g. to use the FTP server.\n+\n+    """\n+\n+    defaultBases = (zserver.STARTUP,)\n+\n+    def setUp(self):\n+\n+        # Stack a new DemoStorage on top of the one from zserver.STARTUP.\n+        self[\'zodbDB\'] = zodb.stackDemoStorage(\n+            self.get(\'zodbDB\'),\n+            name=\'PloneZServerFixture\'\n+        )\n+\n+        self.setUpZCML()\n+\n+        # Set up products and the default content\n+        with zserver.zopeApp() as app:\n+            self.setUpProducts(app)\n+            self.setUpDefaultContent(app)\n+\n+    def tearDown(self):\n+\n+        # Tear down products\n+        with zserver.zopeApp() as app:\n+            # note: content tear-down happens by squashing the ZODB\n+            self.tearDownProducts(app)\n+\n+        self.tearDownZCML()\n+\n+        # Zap the stacked ZODB\n+        self[\'zodbDB\'].close()\n+        del self[\'zodbDB\']\n+\n+\n+PLONE_ZSERVER_FIXTURE = PloneZServerFixture()\n+\n+\n class PloneTestLifecycle(object):\n     """Mixin class for Plone test lifecycle. This exposes the ``portal``\n     resource and resets the environment between each test.\n@@ -315,6 +358,12 @@ def tearDownEnvironment(self, portal):\n         setSite(None)\n \n \n+class PloneZServerTestLifecycle(PloneTestLifecycle):\n+    """PloneTestLifecycle if you have to use ZServer."""\n+\n+    defaultBases = (PLONE_ZSERVER_FIXTURE,)\n+\n+\n class MockMailHostLayer(Layer):\n     """Layer for setting up a MockMailHost to store all sent messages as\n     strings into a list at portal.MailHost.messages\n@@ -359,6 +408,12 @@ class FunctionalTesting(PloneTestLifecycle, z2.FunctionalTesting):\n     """Plone version of the functional testing layer\n     """\n \n+\n+class ZServerFunctionalTesting(\n+        PloneZServerTestLifecycle, zserver.FunctionalTesting):\n+    """Plone version of the functional testing layer using ZServer.\n+    """\n+\n #\n # Layer instances\n #\n@@ -375,12 +430,12 @@ class FunctionalTesting(PloneTestLifecycle, z2.FunctionalTesting):\n     name=\'Plone:Functional\'\n )\n \n-PLONE_ZSERVER = FunctionalTesting(\n-    bases=(PLONE_FIXTURE, z2.ZSERVER_FIXTURE),\n-    name=\'Plone:ZServer\'\n+PLONE_WSGISERVER = PLONE_ZSERVER = FunctionalTesting(\n+    bases=(PLONE_FIXTURE, zope.WSGI_SERVER_FIXTURE),\n+    name=\'Plone:WSGIServer\'\n )\n \n-PLONE_FTP_SERVER = FunctionalTesting(\n-    bases=(PLONE_FIXTURE, z2.FTP_SERVER_FIXTURE),\n+PLONE_FTP_SERVER = ZServerFunctionalTesting(\n+    bases=(PLONE_ZSERVER_FIXTURE, zserver.FTP_SERVER_FIXTURE),\n     name=\'Plone:FTPServer\'\n )\ndiff --git a/src/plone/app/testing/layers.rst b/src/plone/app/testing/layers.rst\nindex 2f92111..1de247b 100644\n--- a/src/plone/app/testing/layers.rst\n+++ b/src/plone/app/testing/layers.rst\n@@ -85,10 +85,10 @@ the module ``plone.app.testing.interfaces``.\n     >>> with helpers.ploneSite() as portal:\n     ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getId()\n     ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getUserName()\n-    ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getRolesInContext(portal)\n+    ...     print sorted(portal[\'acl_users\'].getUser(TEST_USER_NAME).getRolesInContext(portal))\n     test_user_1_\n     test-user\n-    [\'Member\', \'Authenticated\']\n+    [\'Authenticated\', \'Member\']\n \n There is no default workflow or content:\n \n@@ -275,35 +275,36 @@ Layer tear-down resets the environment.\n HTTP server\n ~~~~~~~~~~~\n \n-The ``PLONE_ZSERVER`` layer instantiates the ``FunctionalTesting`` class with\n-two bases: ``PLONE_FIXTURE``, as shown above, and ``ZSERVER_FIXTURE`` from\n-``plone.testing``, which starts up a ZServer thread.\n+The ``PLONE_WSGISERVER`` layer instantiates the ``FunctionalTesting`` class with\n+two bases: ``PLONE_FIXTURE``, as shown above, and ``WSGI_SERVER_FIXTURE`` from\n+``plone.testing``, which starts up a WSGI server. (There also the name\n+``PLONE_ZSERVER`` in place which is a BBB alias.)\n \n-    >>> "%s.%s" % (layers.PLONE_ZSERVER.__module__, layers.PLONE_ZSERVER.__name__,)\n-    \'plone.app.testing.layers.Plone:ZServer\'\n+    >>> "%s.%s" % (layers.PLONE_WSGISERVER.__module__, layers.PLONE_WSGISERVER.__name__,)\n+    \'plone.app.testing.layers.Plone:WSGIServer\'\n \n-    >>> layers.PLONE_ZSERVER.__bases__\n-    (<Layer \'plone.app.testing.layers.PloneFixture\'>, <Layer \'plone.testing.z2.ZServer\'>)\n+    >>> layers.PLONE_WSGISERVER.__bases__\n+    (<Layer \'plone.app.testing.layers.PloneFixture\'>, <Layer \'plone.testing.zope.WSGIServer\'>)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_ZSERVER, setupLayers)\n+    >>> runner.setup_layer(options, layers.PLONE_WSGISERVER, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n     Set up plone.testing.zope.Startup in ... seconds.\n     Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up plone.testing.z2.ZServer in ... seconds.\n-    Set up plone.app.testing.layers.Plone:ZServer in ... seconds.\n+    Set up plone.testing.zope.WSGIServer in ... seconds.\n+    Set up plone.app.testing.layers.Plone:WSGIServer in ... seconds.\n \n After layer setup, the resources ``host`` and ``port`` are available, and\n indicate where Zope is running.\n \n-    >>> host = layers.PLONE_ZSERVER[\'host\']\n+    >>> host = layers.PLONE_WSGISERVER[\'host\']\n     >>> host\n     \'localhost\'\n \n-    >>> port = layers.PLONE_ZSERVER[\'port\']\n+    >>> port = layers.PLONE_WSGISERVER[\'port\']\n     >>> import os\n-    >>> port == int(os.environ.get(\'ZSERVER_PORT\', 55001))\n+    >>> port == int(os.environ.get(\'WSGI_SERVER_PORT\', 55001))\n     True\n \n Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n@@ -367,9 +368,10 @@ Test tear-down does nothing beyond what the base layers do.\n When the server is torn down, the ZServer thread is stopped.\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.Plone:ZServer in ... seconds.\n-    ...Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    ...Tear down plone.testing.zope.Startup in ... seconds.\n+    Tear down plone.app.testing.layers.Plone:WSGIServer in ... seconds.\n+    Tear down plone.testing.zope.WSGIServer in ... seconds.\n+    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n     >>> conn = urllib2.urlopen(portal_url + \'/folder1\', timeout=5)\n@@ -388,15 +390,15 @@ from ``plone.testing``, which starts up an FTP server thread.\n     \'plone.app.testing.layers.Plone:FTPServer\'\n \n     >>> layers.PLONE_FTP_SERVER.__bases__\n-    (<Layer \'plone.app.testing.layers.PloneFixture\'>, <Layer \'plone.testing.z2.FTPServer\'>)\n+    (<Layer \'plone.app.testing.layers.PloneZServerFixture\'>, <Layer \'plone.testing.zserver.FTPServer\'>)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_FTP_SERVER, setupLayers)\n+    >>> runner.setup_layer(options, layers.PLONE_FTP_SERVER, setupLayers)  # here!\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.zope.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up plone.testing.z2.FTPServer in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n+    Set up plone.app.testing.layers.PloneZServerFixture in ... seconds.\n+    Set up plone.testing.zserver.FTPServer in ... seconds.\n     Set up plone.app.testing.layers.Plone:FTPServer in ... seconds.\n \n After layer setup, the resources ``host`` and ``port`` are available, and\n@@ -478,7 +480,8 @@ Test tear-down does nothing beyond what the base layers do.\n     >>> \'request\' in layers.PLONE_FTP_SERVER\n     False\n \n-    >>> with helpers.ploneSite() as portal:\n+    >>> import plone.testing.zserver\n+    >>> with helpers.ploneSite(flavour=plone.testing.zserver) as portal:\n     ...     print \'folder1\' in portal.objectIds()\n     False\n \n@@ -486,11 +489,11 @@ When the server is torn down, the FTP server thread is stopped.\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n     Tear down plone.app.testing.layers.Plone:FTPServer in ... seconds.\n-    ...Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    ...Tear down plone.testing.zope.Startup in ... seconds.\n+    Tear down plone.testing.zserver.FTPServer in ... seconds.\n+    Tear down plone.app.testing.layers.PloneZServerFixture in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n     >>> ftpClient.connect(host, port, timeout=5)\n     Traceback (most recent call last):\n-    ...\n-    ... [Errno ...] Connection refused\n+    error: [Errno 61] Connection refused\ndiff --git a/tox.ini b/tox.ini\nindex 6adab4d..bfc9cd8 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -10,6 +10,7 @@ envlist =\n minversion = 1.9\n \n [testenv]\n+skip_install = true\n usedevelop = True\n \n pip_pre = True\n@@ -19,10 +20,14 @@ extras =\n \n deps =\n      coverage\n+     setuptools==33.1.1\n+     zc.buildout\n \n commands =\n     python -V\n-    coverage run {envbindir}/zope-testrunner --path=src --all {posargs:-vc}\n+    {envbindir}/buildout -c {toxinidir}/buildout.cfg buildout:directory={envdir} buildout:develop={toxinidir} bootstrap\n+    {envbindir}/buildout -c {toxinidir}/buildout.cfg buildout:directory={envdir} buildout:develop={toxinidir} install test\n+    coverage run {envbindir}/test --all {posargs:-vc}\n \n setenv =\n     COVERAGE_FILE=.coverage.{envname}\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-05-17T17:26:04+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.app.testing/commit/6a1c57770d44fef4ab19d27fcc7c65e60179a118

Fix tests to run on Python 3 minus the ones needing ZServer.

Files changed:
M buildout.cfg
M src/plone/app/testing/helpers.rst
M src/plone/app/testing/layers.rst

b'diff --git a/buildout.cfg b/buildout.cfg\nindex b41368c..f033151 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -24,9 +24,10 @@ develop = .\n [remotes]\n plone = git://github.com/plone\n plone_push = git@github.com:plone\n-#zope = svn://svn.zope.org/repos/main/\n zope = git://github.com/zopefoundation\n zope_push = git@github.com:zopefoundation\n+collective = https://github.com/collective\n+collective_push = git@github.com:collective\n \n [versions]\n plone.app.testing =\n@@ -34,10 +35,97 @@ Products.GenericSetup = >= 2.0b1\n Products.PluginRegistry = >= 1.6\n \n [sources]\n-plone.testing         = git ${remotes:plone}/plone.testing.git pushurl=${remotes:plone_push}/plone.testing.git branch=py3\n-Products.PluggableAuthService = git ${remotes:zope}/Products.PluggableAuthService.git pushurl=${remotes:zope_push}/Products.PluggableAuthService.git branch=master\n-Products.CMFPlone = git ${remotes:plone}/Products.CMFPlone.git pushurl=${remotes:plone_push}/Products.CMFPlone.git branch=master\n-Products.PlonePAS = git ${remotes:plone}/Products.PlonePAS.git pushurl=${remotes:plone_push}/Products.PlonePAS.git branch=master\n+AccessControl                 = git ${remotes:zope}/AccessControl.git                   pushurl=${remotes:zope_push}/AccessControl.git                  branch=master\n+Chameleon                     = git https://github.com/malthe/chameleon.git             branch=master\n+DocumentTemplate              = git ${remotes:zope}/DocumentTemplate.git                pushurl=${remotes:zope_push}/DocumentTemplate.git               branch=master\n+Products.CMFCore              = git ${remotes:zope}/Products.CMFCore.git                pushurl=${remotes:zope_push}/Products.CMFCore.git               branch=master\n+Products.CMFEditions          = git ${remotes:plone}/Products.CMFEditions.git           pushurl=${remotes:plone_push}/Products.CMFEditions.git          branch=master\n+Products.CMFFormController    = git ${remotes:plone}/Products.CMFFormController.git     pushurl=${remotes:plone_push}/Products.CMFFormController.git    branch=python3\n+Products.CMFPlacefulWorkflow  = git ${remotes:plone}/Products.CMFPlacefulWorkflow.git   pushurl=${remotes:plone_push}/Products.CMFPlacefulWorkflow.git  branch=master\n+Products.CMFPlone             = git ${remotes:plone}/Products.CMFPlone.git              pushurl=${remotes:plone_push}/Products.CMFPlone.git             branch=python3\n+Products.CMFDynamicViewFTI    = git ${remotes:plone}/Products.CMFDynamicViewFTI.git     pushurl=${remotes:plone_push}/Products.CMFDynamicViewFTI.git    branch=python3\n+Products.CMFQuickInstallerTool= git ${remotes:plone}/Products.CMFQuickInstallerTool.git pushurl=${remotes:plone_push}/Products.CMFQuickInstallerTool.git branch=master\n+Products.CMFUid               = git ${remotes:zope}/Products.CMFUid.git                 pushurl=${remotes:plone_push}/Products.CMFUid.git               branch=py3-vs-zcatalog-branch\n+Products.DCWorkflow           = git ${remotes:zope}/Products.DCWorkflow.git             pushurl=${remotes:plone_push}/Products.DCWorkflow.git           branch=python3\n+Products.DateRecurringIndex   = git ${remotes:collective}/Products.DateRecurringIndex.git pushurl=${remotes:collective_push}/Products.DateRecurringIndex.git branch=python3\n+Products.GenericSetup         = git ${remotes:zope}/Products.GenericSetup.git           pushurl=${remotes:zope_push}/Products.GenericSetup.git          branch=pbauer-python3\n+Products.MimetypesRegistry    = git ${remotes:plone}/Products.MimetypesRegistry.git     pushurl=${remotes:plone_push}/Products.MimetypesRegistry.git    branch=master\n+Products.PDBDebugMode         = git ${remotes:collective}/Products.PDBDebugMode.git     pushurl=${remotes:collective_push}/Products.PDBDebugMode.git    branch=zope4\n+Products.PlonePAS             = git ${remotes:plone}/Products.PlonePAS.git              pushurl=${remotes:plone_push}/Products.PlonePAS.git             branch=python3\n+Products.PluggableAuthService = git ${remotes:zope}/Products.PluggableAuthService.git   pushurl=${remotes:zope_push}/Products.PluggableAuthService.git  branch=python3\n+Products.PluginRegistry       = git ${remotes:zope}/Products.PluginRegistry.git         pushurl=${remotes:plone_push}/Products.PluginRegistry.git       branch=master\n+Products.PortalTransforms     = git ${remotes:plone}/Products.PortalTransforms.git      pushurl=${remotes:plone_push}/Products.PortalTransforms.git     branch=python3\n+Products.ResourceRegistries   = git ${remotes:plone}/Products.ResourceRegistries.git    pushurl=${remotes:zope_push}/Products.ResourceRegistries.git    branch=master\n+Products.Sessions             = git ${remotes:zope}/Products.Sessions.git               pushurl=${remotes:zope_push}/Products.Sessions.git              branch=python3\n+Products.SiteErrorLog         = git ${remotes:zope}/Products.SiteErrorLog.git           pushurl=${remotes:zope_push}/Products.SiteErrorLog.git          branch=python3\n+Products.TemporaryFolder      = git ${remotes:zope}/Products.TemporaryFolder.git        pushurl=${remotes:zope_push}/Products.TemporaryFolder.git       branch=master\n+Products.ZCatalog             = git ${remotes:zope}/Products.ZCatalog.git pushurl=${remotes:zope_push}/Products.ZCatalog.git branch=master\n+Products.ZopeVersionControl   = git ${remotes:zope}/Products.ZopeVersionControl.git     pushurl=${remotes:zope_push}/Products.ZopeVersionControl.git    branch=py3_imports\n+Products.statusmessages       = git ${remotes:plone}/Products.statusmessages.git        pushurl=${remotes:plone_push}/Products.statusmessages.git       branch=master\n+ZConfig                       = git ${remotes:zope}/ZConfig.git pushurl=${remotes:zope_push}/ZConfig.git branch=master\n+ZServer                       = git ${remotes:zope}/ZServer.git pushurl=${remotes:zope_push}/ZServer.git branch=master\n+Zope                          = git ${remotes:zope}/Zope.git                            pushurl=${remotes:zope_push}/Zope.git                           branch=fix_cookie_setting\n+collective.monkeypatcher      = git ${remotes:plone}/collective.monkeypatcher.git       pushurl=${remotes:plone_push}/collective.monkeypatcher.git      branch=master\n+collective.xmltestreport      = git ${remotes:collective}/collective.xmltestreport.git  pushurl=${remotes:collective_push}/collective.xmltestreport.git branch=gforcada-python3\n+five.customerize              = git ${remotes:zope}/five.customerize.git                pushurl=${remotes:zope_push}/five.customerize.git               branch=master\n+plone.app.caching             = git ${remotes:plone}/plone.app.caching.git              pushurl=${remotes:plone_push}/plone.app.caching.git             branch=python3\n+plone.app.content             = git ${remotes:plone}/plone.app.content.git              pushurl=${remotes:plone_push}/plone.app.content.git             branch=python3\n+plone.app.contentmenu         = git ${remotes:plone}/plone.app.contentmenu.git          pushurl=${remotes:plone_push}/plone.app.contentmenu.git         branch=python3\n+plone.app.contenttypes        = git ${remotes:plone}/plone.app.contenttypes.git         pushurl=${remotes:plone_push}/plone.app.contenttypes.git        branch=python3\n+plone.app.dexterity           = git ${remotes:plone}/plone.app.dexterity.git            pushurl=${remotes:plone_push}/plone.app.dexterity.git           branch=python3\n+plone.app.discussion          = git ${remotes:plone}/plone.app.discussion.git           pushurl=${remotes:plone_push}/plone.app.discussion.git          branch=python3\n+plone.app.event               = git ${remotes:plone}/plone.app.event.git                pushurl=${remotes:plone_push}/plone.app.event.git               branch=master\n+plone.app.folder              = git ${remotes:plone}/plone.app.folder.git               pushurl=${remotes:plone_push}/plone.app.folder.git              branch=python3\n+plone.app.iterate             = git ${remotes:plone}/plone.app.iterate.git              pushurl=${remotes:plone_push}/plone.app.iterate.git             branch=python3\n+plone.app.layout              = git ${remotes:plone}/plone.app.layout.git               pushurl=${remotes:plone_push}/plone.app.layout.git              branch=python3\n+plone.app.linkintegrity       = git ${remotes:plone}/plone.app.linkintegrity.git        pushurl=${remotes:plone_push}/plone.app.linkintegrity.git       branch=python3\n+plone.app.multilingual        = git ${remotes:plone}/plone.app.multilingual.git         pushurl=${remotes:plone_push}/plone.app.multilingual.git        branch=master\n+plone.app.portlets            = git ${remotes:plone}/plone.app.portlets.git             pushurl=${remotes:plone_push}/plone.app.portlets.git            branch=python3\n+plone.app.registry            = git ${remotes:plone}/plone.app.registry.git             pushurl=${remotes:plone_push}/plone.app.registry.git            branch=master\n+plone.app.relationfield       = git ${remotes:plone}/plone.app.relationfield.git        pushurl=${remotes:plone_push}/plone.app.relationfield.git       branch=master\n+plone.app.textfield           = git ${remotes:plone}/plone.app.textfield.git            pushurl=${remotes:plone_push}/plone.app.textfield.git           branch=python3\n+plone.app.theming             = git ${remotes:plone}/plone.app.theming.git              pushurl=${remotes:plone_push}/plone.app.theming.git             branch=master\n+plone.app.users               = git ${remotes:plone}/plone.app.users.git                pushurl=${remotes:plone_push}/plone.app.users.git               branch=python3\n+plone.app.versioningbehavior  = git ${remotes:plone}/plone.app.versioningbehavior.git   pushurl=${remotes:plone_push}/plone.app.versioningbehavior.git  branch=python3\n+plone.app.viewletmanager      = git ${remotes:plone}/plone.app.viewletmanager.git       pushurl=${remotes:plone_push}/plone.app.viewletmanager.git      branch=master\n+plone.app.vocabularies        = git ${remotes:plone}/plone.app.vocabularies.git         pushurl=${remotes:plone_push}/plone.app.vocabularies.git        branch=python3\n+plone.app.widgets             = git ${remotes:plone}/plone.app.widgets.git              pushurl=${remotes:plone_push}/plone.app.widgets.git             branch=python3\n+plone.app.workflow            = git ${remotes:plone}/plone.app.workflow.git             pushurl=${remotes:plone_push}/plone.app.workflow.git            branch=python3\n+plone.app.z3cform             = git ${remotes:plone}/plone.app.z3cform.git              pushurl=${remotes:plone_push}/plone.app.z3cform.git             branch=master\n+plone.autoform                = git ${remotes:plone}/plone.autoform.git                 pushurl=${remotes:plone_push}/plone.autoform.git                branch=python3\n+plone.cachepurging            = git ${remotes:plone}/plone.cachepurging.git             pushurl=${remotes:plone_push}/plone.cachepurging.git            branch=python3\n+plone.dexterity               = git ${remotes:plone}/plone.dexterity.git                pushurl=${remotes:plone_push}/plone.dexterity.git               branch=python3\n+plone.folder                  = git ${remotes:plone}/plone.folder.git                   pushurl=${remotes:plone_push}/plone.folder.git                  branch=master\n+plone.formwidget.namedfile    = git ${remotes:plone}/plone.formwidget.namedfile.git     pushurl=${remotes:plone_push}/plone.formwidget.namedfile.git    branch=python3\n+plone.i18n                    = git ${remotes:plone}/plone.i18n.git                     pushurl=${remotes:plone_push}/plone.i18n.git                    branch=python3\n+plone.locking                 = git ${remotes:plone}/plone.locking.git                  pushurl=${remotes:plone_push}/plone.locking.git                 branch=python3\n+plone.namedfile               = git ${remotes:plone}/plone.namedfile.git                pushurl=${remotes:plone_push}/plone.namedfile.git               branch=python3\n+plone.outputfilters           = git ${remotes:plone}/plone.outputfilters.git            pushurl=${remotes:plone_push}/plone.outputfilters.git           branch=python3\n+plone.protect                 = git ${remotes:plone}/plone.protect.git                  pushurl=${remotes:plone_push}/plone.protect.git                 branch=python3\n+plone.recipe.zope2instance    = git ${remotes:plone}/plone.recipe.zope2instance.git     pushurl=${remotes:plone_push}/plone.recipe.zope2instance.git    branch=master\n+plone.reload                  = git ${remotes:plone}/plone.reload.git                   pushurl=${remotes:plone_push}/plone.reload.git                  branch=master\n+plone.resource                = git ${remotes:plone}/plone.resource.git                 pushurl=${remotes:plone_push}/plone.resource.git                branch=python3\n+plone.rfc822                  = git ${remotes:plone}/plone.rfc822.git                   pushurl=${remotes:plone_push}/plone.rfc822.git                  branch=master\n+plone.schemaeditor            = git ${remotes:plone}/plone.schemaeditor.git             pushurl=${remotes:plone_push}/plone.schemaeditor.git            branch=master\n+plone.session                 = git ${remotes:plone}/plone.session.git                  pushurl=${remotes:plone_push}/plone.session.git                 branch=python3\n+plone.stringinterp            = git ${remotes:plone}/plone.stringinterp.git             pushurl=${remotes:plone_push}/plone.stringinterp.git            branch=python3\n+plone.subrequest              = git ${remotes:plone}/plone.subrequest.git               pushurl=${remotes:plone_push}/plone.subrequest.git              branch=python3\n+plone.supermodel              = git ${remotes:plone}/plone.supermodel.git               pushurl=${remotes:plone_push}/plone.supermodel.git              branch=python3\n+plone.testing                 = git ${remotes:plone}/plone.testing.git                  pushurl=${remotes:plone_push}/plone.testing.git                 branch=py3\n+plone.transformchain          = git ${remotes:plone}/plone.transformchain.git           pushurl=${remotes:plone_push}/plone.transformchain.git          branch=master\n+plone.z3cform                 = git ${remotes:zope}/plone.z3cform.git                   pushurl=${remotes:zope_push}/plone.z3cform.git                  branch=python3\n+z3c.autoinclude               = git ${remotes:zope}/z3c.autoinclude.git                 pushurl=${remotes:zope_push}/z3c.autoinclude.git                branch=python3\n+z3c.caching                   = git ${remotes:zope}/z3c.caching.git                     pushurl=${remotes:zope_push}/z3c.caching.git                    branch=master\n+z3c.jbot                      = git ${remotes:zope}/z3c.jbot.git                        pushurl=${remotes:zope_push}/z3c.jbot.git                       branch=python3\n+z3c.objpath                   = git ${remotes:zope}/z3c.objpath.git                     pushurl=${remotes:zope_push}/z3c.objpath.git                    branch=master\n+z3c.relationfield             = git ${remotes:zope}/z3c.relationfield.git               pushurl=${remotes:zope_push}/z3c.relationfield.git              branch=master\n+zc.relation                   = git ${remotes:zope}/zc.relation.git                     pushurl=${remotes:zope_push}/zc.relation.git                    branch=master\n+zc.relationship               = git ${remotes:zope}/zc.relationship.git                 pushurl=${remotes:zope_push}/zc.relationship.git                branch=master\n+zope.interface                = git ${remotes:zope}/zope.interface.git                  pushurl=${remotes:zope_push}/zope.interface.git                 branch=plone-py3\n+zope.publisher                = git ${remotes:zope}/zope.publisher.git                  pushurl=${remotes:zope_push}/zope.publisher.git                 branch=master\n+zope.schema                   = git ${remotes:zope}/zope.schema.git                     pushurl=${remotes:zope_push}/zope.schema.git                    branch=re36-fields-hashable\n+\n+diazo                               = git ${remotes:plone}/diazo.git pushurl=${remotes:plone_push}/diazo.git branch=master\n \n [test]\n recipe = zc.recipe.testrunner\ndiff --git a/src/plone/app/testing/helpers.rst b/src/plone/app/testing/helpers.rst\nindex 9027d49..071ac7a 100644\n--- a/src/plone/app/testing/helpers.rst\n+++ b/src/plone/app/testing/helpers.rst\n@@ -140,7 +140,7 @@ Let\'s now simulate layer setup:\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n       Set up plone.testing.zope.Startup in ... seconds.\n       Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-      Set up HelperDemos in ... seconds.\n+      Set up...HelperDemos in ... seconds.\n       Set up plone.app.testing.layers.HelperDemos:Integration in ... seconds.\n \n We should see the newly registered components and the persistent changes\n@@ -152,7 +152,7 @@ having taken effect.\n     <object object at ...>\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n+    ...     print(portal.title)\n     New title\n \n We should also see our product installation in the quickinstaller tool\n@@ -160,7 +160,7 @@ and the results of the profile having been applied.\n \n     >>> from Products.GenericSetup.tool import UNKNOWN\n     >>> with helpers.ploneSite() as portal:\n-    ...     print is_installed(portal, \'plone.app.testing\')\n+    ...     print(is_installed(portal, \'plone.app.testing\'))\n     ...     portal.portal_setup.getLastVersionForProfile(\'plone.app.testing:default\') == UNKNOWN\n     True\n     False\n@@ -224,8 +224,8 @@ should not.\n     <object object at ...>\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n-    ...     print is_installed(portal, \'plone.app.testing\')\n+    ...     print(portal.title)\n+    ...     print(is_installed(portal, \'plone.app.testing\'))\n     ...     \'folder1\' in portal.objectIds()\n     ...     portal.portal_setup.getLastVersionForProfile(\'plone.app.testing:default\') == UNKNOWN\n     New title\n@@ -239,14 +239,14 @@ component architecture changes from our layer.\n \n     >>> runner.tear_down_unneeded(options, [l for l in setupLayers if l not in (HELPER_DEMOS_INTEGRATION_TESTING, HELPER_DEMOS_FIXTURE,)], setupLayers)\n     Tear down plone.app.testing.layers.HelperDemos:Integration in ... seconds.\n-    Tear down HelperDemos in ... seconds.\n+    Tear down...HelperDemos in ... seconds.\n \n     >>> queryUtility(Interface, name="dummy1") is None\n     True\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n-    ...     print is_installed(portal, \'plone.app.testing\')\n+    ...     print(portal.title)\n+    ...     print(is_installed(portal, \'plone.app.testing\'))\n     ...     portal.portal_setup.getLastVersionForProfile(\'plone.app.testing:default\') == UNKNOWN\n     Plone site\n     False\n@@ -353,7 +353,7 @@ Let\'s now simulate layer setup:\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n     Set up plone.testing.zope.Startup in ... seconds.\n     Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up MyLayer in ... seconds.\n+    Set up...MyLayer in ... seconds.\n     Set up plone.app.testing.layers.MyLayer:Integration in ... seconds.\n \n Again, our state should now be available.\n@@ -362,7 +362,7 @@ Again, our state should now be available.\n     <object object at ...>\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n+    ...     print(portal.title)\n     New title\n \n     >>> someGlobal[\'test\']\n@@ -404,7 +404,7 @@ layer.\n     True\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n+    ...     print(portal.title)\n     Plone site\n \n     >>> \'test\' in someGlobal\ndiff --git a/src/plone/app/testing/layers.rst b/src/plone/app/testing/layers.rst\nindex 1de247b..56343aa 100644\n--- a/src/plone/app/testing/layers.rst\n+++ b/src/plone/app/testing/layers.rst\n@@ -60,8 +60,8 @@ normally use this for testing, unless you need to manipulate the site itself.\n     >>> from plone.app.testing.interfaces import SITE_OWNER_NAME\n \n     >>> with z2.zopeApp() as app:\n-    ...     print app[\'acl_users\'].getUser(SITE_OWNER_NAME)\n-    ...     print app[\'acl_users\'].getUser(SITE_OWNER_NAME).getRolesInContext(app)\n+    ...     print(app[\'acl_users\'].getUser(SITE_OWNER_NAME))\n+    ...     print(app[\'acl_users\'].getUser(SITE_OWNER_NAME).getRolesInContext(app))\n     admin\n     [\'Manager\', \'Authenticated\']\n \n@@ -69,7 +69,7 @@ Inside the Plone site, the default theme is installed\n \n     >>> from plone.app.testing import helpers\n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal[\'portal_registry\'][\'plone.app.theming.interfaces.IThemeSettings.rules\']\n+    ...     print(portal[\'portal_registry\'][\'plone.app.theming.interfaces.IThemeSettings.rules\'])\n     /++theme++barceloneta/rules.xml\n \n **Note:** Here, we have used the ``ploneSite`` context manager to get hold of\n@@ -83,9 +83,9 @@ the module ``plone.app.testing.interfaces``.\n \n     >>> from plone.app.testing.interfaces import TEST_USER_NAME\n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getId()\n-    ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getUserName()\n-    ...     print sorted(portal[\'acl_users\'].getUser(TEST_USER_NAME).getRolesInContext(portal))\n+    ...     print(portal[\'acl_users\'].getUser(TEST_USER_NAME).getId())\n+    ...     print(portal[\'acl_users\'].getUser(TEST_USER_NAME).getUserName())\n+    ...     print(sorted(portal[\'acl_users\'].getUser(TEST_USER_NAME).getRolesInContext(portal)))\n     test_user_1_\n     test-user\n     [\'Authenticated\', \'Member\']\n@@ -93,7 +93,7 @@ the module ``plone.app.testing.interfaces``.\n There is no default workflow or content:\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal[\'portal_workflow\'].getDefaultChain()\n+    ...     print(portal[\'portal_workflow\'].getDefaultChain())\n     ()\n \n Layer tear-down resets the environment.\n@@ -337,10 +337,10 @@ We can now look for this new object through the server.\n     >>> portal_url.split(\':\')[:-1]\n     [\'http\', \'//localhost\']\n \n-    >>> import urllib2\n-    >>> conn = urllib2.urlopen(portal_url + \'/Title\', timeout=10)\n+    >>> from six.moves.urllib.request import urlopen\n+    >>> conn = urlopen(portal_url + \'/Title\', timeout=10)\n     >>> responseBody = conn.read()\n-    >>> "Fancy Portal" in responseBody\n+    >>> b"Fancy Portal" in responseBody\n     True\n     >>> conn.close()\n \n@@ -362,7 +362,7 @@ Test tear-down does nothing beyond what the base layers do.\n     False\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print \'folder1\' in portal.objectIds()\n+    ...     print(\'folder1\' in portal.objectIds())\n     False\n \n When the server is torn down, the ZServer thread is stopped.\n@@ -374,10 +374,9 @@ When the server is torn down, the ZServer thread is stopped.\n     Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n-    >>> conn = urllib2.urlopen(portal_url + \'/folder1\', timeout=5)\n+    >>> conn = urlopen(portal_url + \'/folder1\', timeout=5)\n     Traceback (most recent call last):\n-    ...\n-    URLError: <urlopen error [Errno ...] Connection refused>\n+    ...URLError: <urlopen error [Errno ...] Connection refused>\n \n FTP server with Plone site\n ~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -482,7 +481,7 @@ Test tear-down does nothing beyond what the base layers do.\n \n     >>> import plone.testing.zserver\n     >>> with helpers.ploneSite(flavour=plone.testing.zserver) as portal:\n-    ...     print \'folder1\' in portal.objectIds()\n+    ...     print(\'folder1\' in portal.objectIds())\n     False\n \n When the server is torn down, the FTP server thread is stopped.\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-05-17T17:27:04+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.app.testing/commit/556281771e7e1056289bd53e2b7029481d871d0f

Prepare copy.

Files changed:
A src/plone/app/testing/layers_zserver.rst
D src/plone/app/testing/layers.rst

b'diff --git a/src/plone/app/testing/layers.rst b/src/plone/app/testing/layers_zserver.rst\nsimilarity index 100%\nrename from src/plone/app/testing/layers.rst\nrename to src/plone/app/testing/layers_zserver.rst\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-05-17T17:28:09+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.app.testing/commit/96141f4e0d716b9a9cb752415204dbaaa71b50cf

Prepare copy.

Files changed:
A src/plone/app/testing/layers2.rst
D src/plone/app/testing/layers.rst

b'diff --git a/src/plone/app/testing/layers.rst b/src/plone/app/testing/layers2.rst\nsimilarity index 100%\nrename from src/plone/app/testing/layers.rst\nrename to src/plone/app/testing/layers2.rst\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-05-17T17:28:33+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.app.testing/commit/3da2541d7ee2267b976c6f433ccebbaed75efc75

Merge commit '556281771e7e1056289bd53e2b7029481d871d0f' into py3

Files changed:
A src/plone/app/testing/layers_zserver.rst

b'diff --git a/src/plone/app/testing/layers_zserver.rst b/src/plone/app/testing/layers_zserver.rst\nnew file mode 100644\nindex 0000000..56343aa\n--- /dev/null\n+++ b/src/plone/app/testing/layers_zserver.rst\n@@ -0,0 +1,498 @@\n+Plone testing layers\n+--------------------\n+\n+There are various layers used to set up test fixtures containing a Plone\n+site. They are all importable from ``plone.app.testing`` directly, or from\n+their canonical locations at ``plone.app.testing.layers``.\n+\n+    >>> from plone.app.testing import layers\n+\n+For testing, we need a testrunner\n+\n+    >>> from zope.testrunner import runner\n+\n+\n+Plone site fixture\n+~~~~~~~~~~~~~~~~~~\n+\n+The ``PLONE_FIXTURE`` layer extends ``STARTUP`` from ``plone.testing.z2`` to\n+set up a Plone site.\n+\n+**Note:** This layer should only be used as a base layer, and not directly in\n+tests, since it does not manage the test lifecycle. To run a simple\n+integration test with this fixture, use the ``PLONE_INTEGRATION_TESTING``\n+layer described below. To run a simple functional test, use the\n+``PLONE_FUNCTIONAL_TESTING`` layer. Both of these have ``PLONE_FIXTURE`` as\n+a base. You can also extend ``PLONE_FIXTURE`` with your own fixture layer,\n+instantiating the ``IntegrationTesting`` or ``FunctionalTesting``classes\n+as appropriate. See this package\'s ``README`` file for details.\n+\n+On layer setup, a new ``DemoStorage`` is stacked on top of the ``zodbDB``\n+resource (see ``plone.testing.zodb``). A fresh Plone with no default content\n+is created and added to the application root in this storage. The various\n+old-style products that Plone depends on are loaded, as is Plone\'s ZCML and\n+that of its direct dependencies. Before loading any ZCML, a new global\n+component registry is stacked on top of the default one (see\n+``plone.testing.zca``).\n+\n+**Note**: A ZCML feature ``disable-autoinclude`` is set before Plone\'s ZCML is\n+loaded. This means that Plone will *not* automatically load the ZCML of\n+installed packages that use the ``z3c.autoinclude.plugin`` entry point. If you\n+want to use such packages, you should load their configuration explicitly.\n+\n+Let\'s set up the fixture layer and inspect the state of the site.\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, layers.PLONE_FIXTURE, setupLayers)  # doctest: +ELLIPSIS\n+      Set up plone.testing.zca.LayerCleanup in ... seconds.\n+      Set up plone.testing.zope.Startup in ... seconds.\n+      Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+\n+\n+The application root\'s ``acl_users`` folder will have one user, whose name and\n+password are found in the constants ``SITE_OWNER_NAME`` and\n+``SITE_OWNER_PASSWORD``, in ``plone.app.testing.interfaces``. This user\n+has the ``Manager`` role, and is the owner of the site object. You should not\n+normally use this for testing, unless you need to manipulate the site itself.\n+\n+    >>> from plone.testing import z2, zca\n+    >>> from plone.app.testing.interfaces import SITE_OWNER_NAME\n+\n+    >>> with z2.zopeApp() as app:\n+    ...     print(app[\'acl_users\'].getUser(SITE_OWNER_NAME))\n+    ...     print(app[\'acl_users\'].getUser(SITE_OWNER_NAME).getRolesInContext(app))\n+    admin\n+    [\'Manager\', \'Authenticated\']\n+\n+Inside the Plone site, the default theme is installed\n+\n+    >>> from plone.app.testing import helpers\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print(portal[\'portal_registry\'][\'plone.app.theming.interfaces.IThemeSettings.rules\'])\n+    /++theme++barceloneta/rules.xml\n+\n+**Note:** Here, we have used the ``ploneSite`` context manager to get hold of\n+the Plone site root. Like ``z2.zopeApp()``, this is intended for use during\n+layer setup and tear-down, and will automatically commit any changes unless an\n+error is raised.\n+\n+There is one user, whose user id, login name name and password are found in the\n+constants ``TEST_USER_ID``, ``TEST_USER_NAME`` and ``TEST_USER_PASSWORD`` in\n+the module ``plone.app.testing.interfaces``.\n+\n+    >>> from plone.app.testing.interfaces import TEST_USER_NAME\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print(portal[\'acl_users\'].getUser(TEST_USER_NAME).getId())\n+    ...     print(portal[\'acl_users\'].getUser(TEST_USER_NAME).getUserName())\n+    ...     print(sorted(portal[\'acl_users\'].getUser(TEST_USER_NAME).getRolesInContext(portal)))\n+    test_user_1_\n+    test-user\n+    [\'Authenticated\', \'Member\']\n+\n+There is no default workflow or content:\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print(portal[\'portal_workflow\'].getDefaultChain())\n+    ()\n+\n+Layer tear-down resets the environment.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+Integration testing\n+~~~~~~~~~~~~~~~~~~~\n+\n+``PLONE_INTEGRATION_TESTING`` can be used to run integration tests against the\n+fixture set up by the ``PLONE_FIXTURE`` layer.\n+\n+    >>> "%s.%s" % (layers.PLONE_INTEGRATION_TESTING.__module__, layers.PLONE_INTEGRATION_TESTING.__name__,)\n+    \'plone.app.testing.layers.Plone:Integration\'\n+\n+    >>> layers.PLONE_INTEGRATION_TESTING.__bases__\n+    (<Layer \'plone.app.testing.layers.PloneFixture\'>,)\n+\n+Let\'s set up the layers and attempt to run a test.\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, layers.PLONE_INTEGRATION_TESTING, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n+    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+    Set up plone.app.testing.layers.Plone:Integration in ... seconds.\n+\n+Let\'s now simulate a test\n+\n+    >>> zca.LAYER_CLEANUP.testSetUp()\n+    >>> z2.STARTUP.testSetUp()\n+    >>> layers.PLONE_FIXTURE.testSetUp()\n+    >>> layers.PLONE_INTEGRATION_TESTING.testSetUp()\n+\n+The portal is available as the resource ``portal``:\n+\n+    >>> layers.PLONE_INTEGRATION_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n+    <PloneSite at /plone>\n+\n+The local component site is set to the Plone site for the test:\n+\n+    >>> from zope.component import getSiteManager\n+    >>> getSiteManager()\n+    <PersistentComponents /plone>\n+\n+During the test, we are logged in as the test user:\n+\n+    >>> from AccessControl import getSecurityManager\n+    >>> getSecurityManager().getUser()\n+    <PloneUser \'test-user\'>\n+\n+A new transaction is begun and aborted for each test, so we can create\n+content safely (so long as we don\'t commit):\n+\n+    >>> from plone.app.testing.interfaces import TEST_USER_ID\n+    >>> portal = layers.PLONE_INTEGRATION_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n+    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+    >>> from OFS.SimpleItem import SimpleItem\n+    >>> portal._setObject(\'d1\', SimpleItem(\'d1\'))\n+    \'d1\'\n+    >>> \'d1\' in portal.objectIds()\n+    True\n+\n+Let\'s now simulate test tear-down.\n+\n+    >>> layers.PLONE_INTEGRATION_TESTING.testTearDown()\n+    >>> layers.PLONE_FIXTURE.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+    >>> zca.LAYER_CLEANUP.testTearDown()\n+\n+At this point, our transaction has been rolled back:\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     \'d1\' in portal.objectIds()\n+    False\n+\n+We are also logged out again:\n+\n+    >>> getSecurityManager().getUser()\n+    <SpecialUser \'Anonymous User\'>\n+\n+And the component site has been reset:\n+\n+    >>> getSiteManager()\n+    <BaseGlobalComponents test-stack-2>\n+\n+Layer tear-down resets the environment.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.layers.Plone:Integration in ... seconds.\n+    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+Functional testing\n+~~~~~~~~~~~~~~~~~~\n+\n+``PLONE_FUNCTIONAL_TESTING`` can be used to run functional tests against the\n+fixture set up by the ``PLONE_FIXTURE`` layer.\n+\n+    >>> "%s.%s" % (layers.PLONE_FUNCTIONAL_TESTING.__module__, layers.PLONE_FUNCTIONAL_TESTING.__name__,)\n+    \'plone.app.testing.layers.Plone:Functional\'\n+\n+    >>> layers.PLONE_FUNCTIONAL_TESTING.__bases__\n+    (<Layer \'plone.app.testing.layers.PloneFixture\'>,)\n+\n+Let\'s set up the layers and attempt to run a test.\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, layers.PLONE_FUNCTIONAL_TESTING, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n+    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+    Set up plone.app.testing.layers.Plone:Functional in ... seconds.\n+\n+Let\'s now simulate a test\n+\n+    >>> zca.LAYER_CLEANUP.testSetUp()\n+    >>> z2.STARTUP.testSetUp()\n+    >>> layers.PLONE_FIXTURE.testSetUp()\n+    >>> layers.PLONE_FUNCTIONAL_TESTING.testSetUp()\n+\n+    >>> layers.PLONE_FUNCTIONAL_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n+    <PloneSite at /plone>\n+\n+    >>> from zope.component import getSiteManager\n+    >>> getSiteManager()\n+    <PersistentComponents /plone>\n+\n+    >>> from AccessControl import getSecurityManager\n+    >>> getSecurityManager().getUser()\n+    <PloneUser \'test-user\'>\n+\n+A new ``DemoStorage`` is stacked for each test, so we can safely commit during\n+test execution.\n+\n+    >>> portal = layers.PLONE_FUNCTIONAL_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n+    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+    >>> portal._setObject(\'d1\', SimpleItem(\'d1\'))\n+    \'d1\'\n+    >>> import transaction; transaction.commit()\n+    >>> \'d1\' in portal.objectIds()\n+    True\n+\n+Let\'s now simulate test tear-down.\n+\n+    >>> layers.PLONE_FUNCTIONAL_TESTING.testTearDown()\n+    >>> layers.PLONE_FIXTURE.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+    >>> zca.LAYER_CLEANUP.testTearDown()\n+\n+The previous database state should have been restored.\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     \'d1\' in portal.objectIds()\n+    False\n+\n+Along with the rest of the state:\n+\n+    >>> getSecurityManager().getUser()\n+    <SpecialUser \'Anonymous User\'>\n+\n+    >>> getSiteManager()\n+    <BaseGlobalComponents test-stack-2>\n+\n+Layer tear-down resets the environment.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.layers.Plone:Functional in ... seconds.\n+    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+HTTP server\n+~~~~~~~~~~~\n+\n+The ``PLONE_WSGISERVER`` layer instantiates the ``FunctionalTesting`` class with\n+two bases: ``PLONE_FIXTURE``, as shown above, and ``WSGI_SERVER_FIXTURE`` from\n+``plone.testing``, which starts up a WSGI server. (There also the name\n+``PLONE_ZSERVER`` in place which is a BBB alias.)\n+\n+    >>> "%s.%s" % (layers.PLONE_WSGISERVER.__module__, layers.PLONE_WSGISERVER.__name__,)\n+    \'plone.app.testing.layers.Plone:WSGIServer\'\n+\n+    >>> layers.PLONE_WSGISERVER.__bases__\n+    (<Layer \'plone.app.testing.layers.PloneFixture\'>, <Layer \'plone.testing.zope.WSGIServer\'>)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, layers.PLONE_WSGISERVER, setupLayers)\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n+    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+    Set up plone.testing.zope.WSGIServer in ... seconds.\n+    Set up plone.app.testing.layers.Plone:WSGIServer in ... seconds.\n+\n+After layer setup, the resources ``host`` and ``port`` are available, and\n+indicate where Zope is running.\n+\n+    >>> host = layers.PLONE_WSGISERVER[\'host\']\n+    >>> host\n+    \'localhost\'\n+\n+    >>> port = layers.PLONE_WSGISERVER[\'port\']\n+    >>> import os\n+    >>> port == int(os.environ.get(\'WSGI_SERVER_PORT\', 55001))\n+    True\n+\n+Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n+do.\n+\n+    >>> zca.LAYER_CLEANUP.testSetUp()\n+    >>> z2.STARTUP.testSetUp()\n+    >>> layers.PLONE_FIXTURE.testSetUp()\n+    >>> z2.ZSERVER_FIXTURE.testSetUp()\n+    >>> layers.PLONE_ZSERVER.testSetUp()\n+\n+It is common in a test to use the Python API to change the state of the server\n+(e.g. create some content or change a setting) and then use the HTTP protocol\n+to look at the results. Bear in mind that the server is running in a separate\n+thread, with a separate security manager, so calls to ``helpers.login()`` and\n+``helpers.logout()``, for instance, do not affect the server thread.\n+\n+    >>> portal = layers.PLONE_ZSERVER[\'portal\'] # would normally be self.layer[\'portal\']\n+    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+    >>> portal.title = \'Fancy Portal\'\n+\n+Note that we need to commit the transaction before it will show up in the\n+other thread.\n+\n+    >>> import transaction; transaction.commit()\n+\n+We can now look for this new object through the server.\n+\n+    >>> portal_url = portal.absolute_url()\n+    >>> portal_url.split(\':\')[:-1]\n+    [\'http\', \'//localhost\']\n+\n+    >>> from six.moves.urllib.request import urlopen\n+    >>> conn = urlopen(portal_url + \'/Title\', timeout=10)\n+    >>> responseBody = conn.read()\n+    >>> b"Fancy Portal" in responseBody\n+    True\n+    >>> conn.close()\n+\n+Test tear-down does nothing beyond what the base layers do.\n+\n+    >>> layers.PLONE_ZSERVER.testTearDown()\n+    >>> z2.ZSERVER_FIXTURE.testTearDown()\n+    >>> layers.PLONE_FIXTURE.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+    >>> zca.LAYER_CLEANUP.testTearDown()\n+\n+    >>> \'portal\' in layers.PLONE_ZSERVER\n+    False\n+\n+    >>> \'app\' in layers.PLONE_ZSERVER\n+    False\n+\n+    >>> \'request\' in layers.PLONE_ZSERVER\n+    False\n+\n+    >>> with helpers.ploneSite() as portal:\n+    ...     print(\'folder1\' in portal.objectIds())\n+    False\n+\n+When the server is torn down, the ZServer thread is stopped.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.layers.Plone:WSGIServer in ... seconds.\n+    Tear down plone.testing.zope.WSGIServer in ... seconds.\n+    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+    >>> conn = urlopen(portal_url + \'/folder1\', timeout=5)\n+    Traceback (most recent call last):\n+    ...URLError: <urlopen error [Errno ...] Connection refused>\n+\n+FTP server with Plone site\n+~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The ``PLONE_FTP_SERVER`` layer instantiates the ``FunctionalTesting`` class\n+with two bases: ``PLONE_FIXTURE``, as shown above, and ``FTP_SERVER_FIXTURE``\n+from ``plone.testing``, which starts up an FTP server thread.\n+\n+    >>> "%s.%s" % (layers.PLONE_FTP_SERVER.__module__, layers.PLONE_FTP_SERVER.__name__,)\n+    \'plone.app.testing.layers.Plone:FTPServer\'\n+\n+    >>> layers.PLONE_FTP_SERVER.__bases__\n+    (<Layer \'plone.app.testing.layers.PloneZServerFixture\'>, <Layer \'plone.testing.zserver.FTPServer\'>)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, layers.PLONE_FTP_SERVER, setupLayers)  # here!\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n+    Set up plone.app.testing.layers.PloneZServerFixture in ... seconds.\n+    Set up plone.testing.zserver.FTPServer in ... seconds.\n+    Set up plone.app.testing.layers.Plone:FTPServer in ... seconds.\n+\n+After layer setup, the resources ``host`` and ``port`` are available, and\n+indicate where Zope is running.\n+\n+    >>> host = layers.PLONE_FTP_SERVER[\'host\']\n+    >>> host\n+    \'localhost\'\n+\n+    >>> port = layers.PLONE_FTP_SERVER[\'port\']\n+    >>> import os\n+    >>> port == int(os.environ.get(\'FTPSERVER_PORT\', 55002))\n+    True\n+\n+Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n+do.\n+\n+    >>> zca.LAYER_CLEANUP.testSetUp()\n+    >>> z2.STARTUP.testSetUp()\n+    >>> layers.PLONE_FIXTURE.testSetUp()\n+    >>> z2.FTP_SERVER_FIXTURE.testSetUp()\n+    >>> layers.PLONE_FTP_SERVER.testSetUp()\n+\n+It is common in a test to use the Python API to change the state of the server\n+(e.g. create some content or change a setting) and then use the FTP protocol\n+to look at the results. Bear in mind that the server is running in a separate\n+thread, with a separate security manager, so calls to ``helpers.login()`` and\n+``helpers.logout()``, for instance, do not affect the server thread.\n+\n+    >>> portal = layers.PLONE_FTP_SERVER[\'portal\'] # would normally be self.layer[\'portal\']\n+    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+    >>> from OFS.Folder import Folder\n+    >>> portal._setObject(\'folder1\', Folder(\'folder1\'))\n+    \'folder1\'\n+\n+Note that we need to commit the transaction before it will show up in the\n+other thread.\n+\n+    >>> import transaction; transaction.commit()\n+\n+    >>> folder_path = portal.absolute_url_path() + \'/folder1\'\n+\n+    >>> import ftplib\n+    >>> ftpClient = ftplib.FTP()\n+    >>> ftpClient.connect(host, port, timeout=5)\n+    \'220 ... FTP server (...) ready.\'\n+\n+    >>> from plone.app.testing.interfaces import SITE_OWNER_NAME\n+    >>> from plone.app.testing.interfaces import SITE_OWNER_PASSWORD\n+\n+    >>> ftpClient.login(SITE_OWNER_NAME, SITE_OWNER_PASSWORD)\n+    \'230 Login successful.\'\n+\n+    >>> ftpClient.cwd(folder_path)\n+    \'250 CWD command successful.\'\n+\n+    >>> ftpClient.retrlines(\'LIST\')\n+    drwxrwx---   1 test_user_1_ Zope            0 ... .\n+    d---------   1 admin        Zope            0 ... ..\n+    \'226 Transfer complete\'\n+\n+    >>> ftpClient.quit()\n+    \'221 Goodbye.\'\n+\n+Test tear-down does nothing beyond what the base layers do.\n+\n+    >>> layers.PLONE_FTP_SERVER.testTearDown()\n+    >>> z2.FTP_SERVER_FIXTURE.testTearDown()\n+    >>> layers.PLONE_FIXTURE.testTearDown()\n+    >>> z2.STARTUP.testTearDown()\n+    >>> zca.LAYER_CLEANUP.testTearDown()\n+\n+    >>> \'portal\' in layers.PLONE_FTP_SERVER\n+    False\n+\n+    >>> \'app\' in layers.PLONE_FTP_SERVER\n+    False\n+\n+    >>> \'request\' in layers.PLONE_FTP_SERVER\n+    False\n+\n+    >>> import plone.testing.zserver\n+    >>> with helpers.ploneSite(flavour=plone.testing.zserver) as portal:\n+    ...     print(\'folder1\' in portal.objectIds())\n+    False\n+\n+When the server is torn down, the FTP server thread is stopped.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.layers.Plone:FTPServer in ... seconds.\n+    Tear down plone.testing.zserver.FTPServer in ... seconds.\n+    Tear down plone.app.testing.layers.PloneZServerFixture in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+    >>> ftpClient.connect(host, port, timeout=5)\n+    Traceback (most recent call last):\n+    error: [Errno 61] Connection refused\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-05-17T17:28:58+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.app.testing/commit/24f63d81a4577f4f077ec65b19202d748753dfd7

Finish copy.

Files changed:
A src/plone/app/testing/layers.rst
D src/plone/app/testing/layers2.rst

b'diff --git a/src/plone/app/testing/layers2.rst b/src/plone/app/testing/layers.rst\nsimilarity index 100%\nrename from src/plone/app/testing/layers2.rst\nrename to src/plone/app/testing/layers.rst\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-05-17T18:05:51+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.app.testing/commit/d6bdc6d949f3e45437e79d044d9a46b5dd12ffcd

Fix ZServer tests: They now run only on Python 2.

Files changed:
M buildout.cfg
M setup.py
M src/plone/app/testing/helpers.rst
M src/plone/app/testing/layers.rst
M src/plone/app/testing/layers_zserver.rst
M src/plone/app/testing/tests.py

b'diff --git a/buildout.cfg b/buildout.cfg\nindex f033151..b8dba71 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -52,7 +52,7 @@ Products.GenericSetup         = git ${remotes:zope}/Products.GenericSetup.git\n Products.MimetypesRegistry    = git ${remotes:plone}/Products.MimetypesRegistry.git     pushurl=${remotes:plone_push}/Products.MimetypesRegistry.git    branch=master\n Products.PDBDebugMode         = git ${remotes:collective}/Products.PDBDebugMode.git     pushurl=${remotes:collective_push}/Products.PDBDebugMode.git    branch=zope4\n Products.PlonePAS             = git ${remotes:plone}/Products.PlonePAS.git              pushurl=${remotes:plone_push}/Products.PlonePAS.git             branch=python3\n-Products.PluggableAuthService = git ${remotes:zope}/Products.PluggableAuthService.git   pushurl=${remotes:zope_push}/Products.PluggableAuthService.git  branch=python3\n+Products.PluggableAuthService = git ${remotes:zope}/Products.PluggableAuthService.git   pushurl=${remotes:zope_push}/Products.PluggableAuthService.git  branch=master\n Products.PluginRegistry       = git ${remotes:zope}/Products.PluginRegistry.git         pushurl=${remotes:plone_push}/Products.PluginRegistry.git       branch=master\n Products.PortalTransforms     = git ${remotes:plone}/Products.PortalTransforms.git      pushurl=${remotes:plone_push}/Products.PortalTransforms.git     branch=python3\n Products.ResourceRegistries   = git ${remotes:plone}/Products.ResourceRegistries.git    pushurl=${remotes:zope_push}/Products.ResourceRegistries.git    branch=master\n@@ -64,7 +64,7 @@ Products.ZopeVersionControl   = git ${remotes:zope}/Products.ZopeVersionControl.\n Products.statusmessages       = git ${remotes:plone}/Products.statusmessages.git        pushurl=${remotes:plone_push}/Products.statusmessages.git       branch=master\n ZConfig                       = git ${remotes:zope}/ZConfig.git pushurl=${remotes:zope_push}/ZConfig.git branch=master\n ZServer                       = git ${remotes:zope}/ZServer.git pushurl=${remotes:zope_push}/ZServer.git branch=master\n-Zope                          = git ${remotes:zope}/Zope.git                            pushurl=${remotes:zope_push}/Zope.git                           branch=fix_cookie_setting\n+Zope                          = git ${remotes:zope}/Zope.git                            pushurl=${remotes:zope_push}/Zope.git                           branch=master\n collective.monkeypatcher      = git ${remotes:plone}/collective.monkeypatcher.git       pushurl=${remotes:plone_push}/collective.monkeypatcher.git      branch=master\n collective.xmltestreport      = git ${remotes:collective}/collective.xmltestreport.git  pushurl=${remotes:collective_push}/collective.xmltestreport.git branch=gforcada-python3\n five.customerize              = git ${remotes:zope}/five.customerize.git                pushurl=${remotes:zope_push}/five.customerize.git               branch=master\n@@ -125,7 +125,7 @@ zope.interface                = git ${remotes:zope}/zope.interface.git\n zope.publisher                = git ${remotes:zope}/zope.publisher.git                  pushurl=${remotes:zope_push}/zope.publisher.git                 branch=master\n zope.schema                   = git ${remotes:zope}/zope.schema.git                     pushurl=${remotes:zope_push}/zope.schema.git                    branch=re36-fields-hashable\n \n-diazo                               = git ${remotes:plone}/diazo.git pushurl=${remotes:plone_push}/diazo.git branch=master\n+diazo                         = git ${remotes:plone}/diazo.git pushurl=${remotes:plone_push}/diazo.git branch=plone.app.testing-py3\n \n [test]\n recipe = zc.recipe.testrunner\ndiff --git a/setup.py b/setup.py\nindex bba07d6..409705e 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -73,6 +73,7 @@ def read(*rnames):\n     zip_safe=False,\n     install_requires=[\n         \'setuptools\',\n+        \'six\',\n         \'zope.configuration\',\n         \'zope.component\',\n         \'zope.dottedname\',\ndiff --git a/src/plone/app/testing/helpers.rst b/src/plone/app/testing/helpers.rst\nindex 071ac7a..f1b6431 100644\n--- a/src/plone/app/testing/helpers.rst\n+++ b/src/plone/app/testing/helpers.rst\n@@ -194,8 +194,8 @@ the ``ploneSite()`` context manager as shown above.\n     >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n     >>> repr(getSecurityManager()) != sm_repr\n     True\n-    >>> getSecurityManager().getUser().getRolesInContext(portal)\n-    [\'Manager\', \'Authenticated\']\n+    >>> sorted(getSecurityManager().getUser().getRolesInContext(portal))\n+    [\'Authenticated\', \'Manager\']\n \n     >>> helpers.logout()\n     >>> getSecurityManager().getUser()\ndiff --git a/src/plone/app/testing/layers.rst b/src/plone/app/testing/layers.rst\nindex 56343aa..d6bf179 100644\n--- a/src/plone/app/testing/layers.rst\n+++ b/src/plone/app/testing/layers.rst\n@@ -374,125 +374,7 @@ When the server is torn down, the ZServer thread is stopped.\n     Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n-    >>> conn = urlopen(portal_url + \'/folder1\', timeout=5)\n+    >>> conn = urlopen(portal_url + \'/folder1\', timeout=5) # doctest: +IGNORE_EXCEPTION_DETAIL\n     Traceback (most recent call last):\n-    ...URLError: <urlopen error [Errno ...] Connection refused>\n-\n-FTP server with Plone site\n-~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-The ``PLONE_FTP_SERVER`` layer instantiates the ``FunctionalTesting`` class\n-with two bases: ``PLONE_FIXTURE``, as shown above, and ``FTP_SERVER_FIXTURE``\n-from ``plone.testing``, which starts up an FTP server thread.\n-\n-    >>> "%s.%s" % (layers.PLONE_FTP_SERVER.__module__, layers.PLONE_FTP_SERVER.__name__,)\n-    \'plone.app.testing.layers.Plone:FTPServer\'\n-\n-    >>> layers.PLONE_FTP_SERVER.__bases__\n-    (<Layer \'plone.app.testing.layers.PloneZServerFixture\'>, <Layer \'plone.testing.zserver.FTPServer\'>)\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_FTP_SERVER, setupLayers)  # here!\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.zserver.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneZServerFixture in ... seconds.\n-    Set up plone.testing.zserver.FTPServer in ... seconds.\n-    Set up plone.app.testing.layers.Plone:FTPServer in ... seconds.\n-\n-After layer setup, the resources ``host`` and ``port`` are available, and\n-indicate where Zope is running.\n-\n-    >>> host = layers.PLONE_FTP_SERVER[\'host\']\n-    >>> host\n-    \'localhost\'\n-\n-    >>> port = layers.PLONE_FTP_SERVER[\'port\']\n-    >>> import os\n-    >>> port == int(os.environ.get(\'FTPSERVER_PORT\', 55002))\n-    True\n-\n-Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n-do.\n-\n-    >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n-    >>> layers.PLONE_FIXTURE.testSetUp()\n-    >>> z2.FTP_SERVER_FIXTURE.testSetUp()\n-    >>> layers.PLONE_FTP_SERVER.testSetUp()\n-\n-It is common in a test to use the Python API to change the state of the server\n-(e.g. create some content or change a setting) and then use the FTP protocol\n-to look at the results. Bear in mind that the server is running in a separate\n-thread, with a separate security manager, so calls to ``helpers.login()`` and\n-``helpers.logout()``, for instance, do not affect the server thread.\n-\n-    >>> portal = layers.PLONE_FTP_SERVER[\'portal\'] # would normally be self.layer[\'portal\']\n-    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-    >>> from OFS.Folder import Folder\n-    >>> portal._setObject(\'folder1\', Folder(\'folder1\'))\n-    \'folder1\'\n-\n-Note that we need to commit the transaction before it will show up in the\n-other thread.\n-\n-    >>> import transaction; transaction.commit()\n-\n-    >>> folder_path = portal.absolute_url_path() + \'/folder1\'\n-\n-    >>> import ftplib\n-    >>> ftpClient = ftplib.FTP()\n-    >>> ftpClient.connect(host, port, timeout=5)\n-    \'220 ... FTP server (...) ready.\'\n-\n-    >>> from plone.app.testing.interfaces import SITE_OWNER_NAME\n-    >>> from plone.app.testing.interfaces import SITE_OWNER_PASSWORD\n-\n-    >>> ftpClient.login(SITE_OWNER_NAME, SITE_OWNER_PASSWORD)\n-    \'230 Login successful.\'\n-\n-    >>> ftpClient.cwd(folder_path)\n-    \'250 CWD command successful.\'\n-\n-    >>> ftpClient.retrlines(\'LIST\')\n-    drwxrwx---   1 test_user_1_ Zope            0 ... .\n-    d---------   1 admin        Zope            0 ... ..\n-    \'226 Transfer complete\'\n-\n-    >>> ftpClient.quit()\n-    \'221 Goodbye.\'\n-\n-Test tear-down does nothing beyond what the base layers do.\n-\n-    >>> layers.PLONE_FTP_SERVER.testTearDown()\n-    >>> z2.FTP_SERVER_FIXTURE.testTearDown()\n-    >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n-    >>> zca.LAYER_CLEANUP.testTearDown()\n-\n-    >>> \'portal\' in layers.PLONE_FTP_SERVER\n-    False\n-\n-    >>> \'app\' in layers.PLONE_FTP_SERVER\n-    False\n-\n-    >>> \'request\' in layers.PLONE_FTP_SERVER\n-    False\n-\n-    >>> import plone.testing.zserver\n-    >>> with helpers.ploneSite(flavour=plone.testing.zserver) as portal:\n-    ...     print(\'folder1\' in portal.objectIds())\n-    False\n-\n-When the server is torn down, the FTP server thread is stopped.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.Plone:FTPServer in ... seconds.\n-    Tear down plone.testing.zserver.FTPServer in ... seconds.\n-    Tear down plone.app.testing.layers.PloneZServerFixture in ... seconds.\n-    Tear down plone.testing.zserver.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-    >>> ftpClient.connect(host, port, timeout=5)\n-    Traceback (most recent call last):\n-    error: [Errno 61] Connection refused\n+    ...\n+    urllib.error.URLError: <urlopen error [Errno 61] Connection refused>\ndiff --git a/src/plone/app/testing/layers_zserver.rst b/src/plone/app/testing/layers_zserver.rst\nindex 56343aa..3715fb4 100644\n--- a/src/plone/app/testing/layers_zserver.rst\n+++ b/src/plone/app/testing/layers_zserver.rst\n@@ -1,9 +1,9 @@\n-Plone testing layers\n---------------------\n+Plone testing ZServer layers\n+----------------------------\n \n-There are various layers used to set up test fixtures containing a Plone\n-site. They are all importable from ``plone.app.testing`` directly, or from\n-their canonical locations at ``plone.app.testing.layers``.\n+There are some ZServer layers used to set up test fixtures containing a Plone\n+site running with ZServer. They are all importable from ``plone.app.testing``\n+directly, or from their canonical locations at ``plone.app.testing.layers``.\n \n     >>> from plone.app.testing import layers\n \n@@ -11,373 +11,6 @@ For testing, we need a testrunner\n \n     >>> from zope.testrunner import runner\n \n-\n-Plone site fixture\n-~~~~~~~~~~~~~~~~~~\n-\n-The ``PLONE_FIXTURE`` layer extends ``STARTUP`` from ``plone.testing.z2`` to\n-set up a Plone site.\n-\n-**Note:** This layer should only be used as a base layer, and not directly in\n-tests, since it does not manage the test lifecycle. To run a simple\n-integration test with this fixture, use the ``PLONE_INTEGRATION_TESTING``\n-layer described below. To run a simple functional test, use the\n-``PLONE_FUNCTIONAL_TESTING`` layer. Both of these have ``PLONE_FIXTURE`` as\n-a base. You can also extend ``PLONE_FIXTURE`` with your own fixture layer,\n-instantiating the ``IntegrationTesting`` or ``FunctionalTesting``classes\n-as appropriate. See this package\'s ``README`` file for details.\n-\n-On layer setup, a new ``DemoStorage`` is stacked on top of the ``zodbDB``\n-resource (see ``plone.testing.zodb``). A fresh Plone with no default content\n-is created and added to the application root in this storage. The various\n-old-style products that Plone depends on are loaded, as is Plone\'s ZCML and\n-that of its direct dependencies. Before loading any ZCML, a new global\n-component registry is stacked on top of the default one (see\n-``plone.testing.zca``).\n-\n-**Note**: A ZCML feature ``disable-autoinclude`` is set before Plone\'s ZCML is\n-loaded. This means that Plone will *not* automatically load the ZCML of\n-installed packages that use the ``z3c.autoinclude.plugin`` entry point. If you\n-want to use such packages, you should load their configuration explicitly.\n-\n-Let\'s set up the fixture layer and inspect the state of the site.\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_FIXTURE, setupLayers)  # doctest: +ELLIPSIS\n-      Set up plone.testing.zca.LayerCleanup in ... seconds.\n-      Set up plone.testing.zope.Startup in ... seconds.\n-      Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-\n-\n-The application root\'s ``acl_users`` folder will have one user, whose name and\n-password are found in the constants ``SITE_OWNER_NAME`` and\n-``SITE_OWNER_PASSWORD``, in ``plone.app.testing.interfaces``. This user\n-has the ``Manager`` role, and is the owner of the site object. You should not\n-normally use this for testing, unless you need to manipulate the site itself.\n-\n-    >>> from plone.testing import z2, zca\n-    >>> from plone.app.testing.interfaces import SITE_OWNER_NAME\n-\n-    >>> with z2.zopeApp() as app:\n-    ...     print(app[\'acl_users\'].getUser(SITE_OWNER_NAME))\n-    ...     print(app[\'acl_users\'].getUser(SITE_OWNER_NAME).getRolesInContext(app))\n-    admin\n-    [\'Manager\', \'Authenticated\']\n-\n-Inside the Plone site, the default theme is installed\n-\n-    >>> from plone.app.testing import helpers\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print(portal[\'portal_registry\'][\'plone.app.theming.interfaces.IThemeSettings.rules\'])\n-    /++theme++barceloneta/rules.xml\n-\n-**Note:** Here, we have used the ``ploneSite`` context manager to get hold of\n-the Plone site root. Like ``z2.zopeApp()``, this is intended for use during\n-layer setup and tear-down, and will automatically commit any changes unless an\n-error is raised.\n-\n-There is one user, whose user id, login name name and password are found in the\n-constants ``TEST_USER_ID``, ``TEST_USER_NAME`` and ``TEST_USER_PASSWORD`` in\n-the module ``plone.app.testing.interfaces``.\n-\n-    >>> from plone.app.testing.interfaces import TEST_USER_NAME\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print(portal[\'acl_users\'].getUser(TEST_USER_NAME).getId())\n-    ...     print(portal[\'acl_users\'].getUser(TEST_USER_NAME).getUserName())\n-    ...     print(sorted(portal[\'acl_users\'].getUser(TEST_USER_NAME).getRolesInContext(portal)))\n-    test_user_1_\n-    test-user\n-    [\'Authenticated\', \'Member\']\n-\n-There is no default workflow or content:\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print(portal[\'portal_workflow\'].getDefaultChain())\n-    ()\n-\n-Layer tear-down resets the environment.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.zope.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-Integration testing\n-~~~~~~~~~~~~~~~~~~~\n-\n-``PLONE_INTEGRATION_TESTING`` can be used to run integration tests against the\n-fixture set up by the ``PLONE_FIXTURE`` layer.\n-\n-    >>> "%s.%s" % (layers.PLONE_INTEGRATION_TESTING.__module__, layers.PLONE_INTEGRATION_TESTING.__name__,)\n-    \'plone.app.testing.layers.Plone:Integration\'\n-\n-    >>> layers.PLONE_INTEGRATION_TESTING.__bases__\n-    (<Layer \'plone.app.testing.layers.PloneFixture\'>,)\n-\n-Let\'s set up the layers and attempt to run a test.\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_INTEGRATION_TESTING, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.zope.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up plone.app.testing.layers.Plone:Integration in ... seconds.\n-\n-Let\'s now simulate a test\n-\n-    >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n-    >>> layers.PLONE_FIXTURE.testSetUp()\n-    >>> layers.PLONE_INTEGRATION_TESTING.testSetUp()\n-\n-The portal is available as the resource ``portal``:\n-\n-    >>> layers.PLONE_INTEGRATION_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n-    <PloneSite at /plone>\n-\n-The local component site is set to the Plone site for the test:\n-\n-    >>> from zope.component import getSiteManager\n-    >>> getSiteManager()\n-    <PersistentComponents /plone>\n-\n-During the test, we are logged in as the test user:\n-\n-    >>> from AccessControl import getSecurityManager\n-    >>> getSecurityManager().getUser()\n-    <PloneUser \'test-user\'>\n-\n-A new transaction is begun and aborted for each test, so we can create\n-content safely (so long as we don\'t commit):\n-\n-    >>> from plone.app.testing.interfaces import TEST_USER_ID\n-    >>> portal = layers.PLONE_INTEGRATION_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n-    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-    >>> from OFS.SimpleItem import SimpleItem\n-    >>> portal._setObject(\'d1\', SimpleItem(\'d1\'))\n-    \'d1\'\n-    >>> \'d1\' in portal.objectIds()\n-    True\n-\n-Let\'s now simulate test tear-down.\n-\n-    >>> layers.PLONE_INTEGRATION_TESTING.testTearDown()\n-    >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n-    >>> zca.LAYER_CLEANUP.testTearDown()\n-\n-At this point, our transaction has been rolled back:\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     \'d1\' in portal.objectIds()\n-    False\n-\n-We are also logged out again:\n-\n-    >>> getSecurityManager().getUser()\n-    <SpecialUser \'Anonymous User\'>\n-\n-And the component site has been reset:\n-\n-    >>> getSiteManager()\n-    <BaseGlobalComponents test-stack-2>\n-\n-Layer tear-down resets the environment.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.Plone:Integration in ... seconds.\n-    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.zope.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-Functional testing\n-~~~~~~~~~~~~~~~~~~\n-\n-``PLONE_FUNCTIONAL_TESTING`` can be used to run functional tests against the\n-fixture set up by the ``PLONE_FIXTURE`` layer.\n-\n-    >>> "%s.%s" % (layers.PLONE_FUNCTIONAL_TESTING.__module__, layers.PLONE_FUNCTIONAL_TESTING.__name__,)\n-    \'plone.app.testing.layers.Plone:Functional\'\n-\n-    >>> layers.PLONE_FUNCTIONAL_TESTING.__bases__\n-    (<Layer \'plone.app.testing.layers.PloneFixture\'>,)\n-\n-Let\'s set up the layers and attempt to run a test.\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_FUNCTIONAL_TESTING, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.zope.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up plone.app.testing.layers.Plone:Functional in ... seconds.\n-\n-Let\'s now simulate a test\n-\n-    >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n-    >>> layers.PLONE_FIXTURE.testSetUp()\n-    >>> layers.PLONE_FUNCTIONAL_TESTING.testSetUp()\n-\n-    >>> layers.PLONE_FUNCTIONAL_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n-    <PloneSite at /plone>\n-\n-    >>> from zope.component import getSiteManager\n-    >>> getSiteManager()\n-    <PersistentComponents /plone>\n-\n-    >>> from AccessControl import getSecurityManager\n-    >>> getSecurityManager().getUser()\n-    <PloneUser \'test-user\'>\n-\n-A new ``DemoStorage`` is stacked for each test, so we can safely commit during\n-test execution.\n-\n-    >>> portal = layers.PLONE_FUNCTIONAL_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n-    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-    >>> portal._setObject(\'d1\', SimpleItem(\'d1\'))\n-    \'d1\'\n-    >>> import transaction; transaction.commit()\n-    >>> \'d1\' in portal.objectIds()\n-    True\n-\n-Let\'s now simulate test tear-down.\n-\n-    >>> layers.PLONE_FUNCTIONAL_TESTING.testTearDown()\n-    >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n-    >>> zca.LAYER_CLEANUP.testTearDown()\n-\n-The previous database state should have been restored.\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     \'d1\' in portal.objectIds()\n-    False\n-\n-Along with the rest of the state:\n-\n-    >>> getSecurityManager().getUser()\n-    <SpecialUser \'Anonymous User\'>\n-\n-    >>> getSiteManager()\n-    <BaseGlobalComponents test-stack-2>\n-\n-Layer tear-down resets the environment.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.Plone:Functional in ... seconds.\n-    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.zope.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-HTTP server\n-~~~~~~~~~~~\n-\n-The ``PLONE_WSGISERVER`` layer instantiates the ``FunctionalTesting`` class with\n-two bases: ``PLONE_FIXTURE``, as shown above, and ``WSGI_SERVER_FIXTURE`` from\n-``plone.testing``, which starts up a WSGI server. (There also the name\n-``PLONE_ZSERVER`` in place which is a BBB alias.)\n-\n-    >>> "%s.%s" % (layers.PLONE_WSGISERVER.__module__, layers.PLONE_WSGISERVER.__name__,)\n-    \'plone.app.testing.layers.Plone:WSGIServer\'\n-\n-    >>> layers.PLONE_WSGISERVER.__bases__\n-    (<Layer \'plone.app.testing.layers.PloneFixture\'>, <Layer \'plone.testing.zope.WSGIServer\'>)\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_WSGISERVER, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.zope.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up plone.testing.zope.WSGIServer in ... seconds.\n-    Set up plone.app.testing.layers.Plone:WSGIServer in ... seconds.\n-\n-After layer setup, the resources ``host`` and ``port`` are available, and\n-indicate where Zope is running.\n-\n-    >>> host = layers.PLONE_WSGISERVER[\'host\']\n-    >>> host\n-    \'localhost\'\n-\n-    >>> port = layers.PLONE_WSGISERVER[\'port\']\n-    >>> import os\n-    >>> port == int(os.environ.get(\'WSGI_SERVER_PORT\', 55001))\n-    True\n-\n-Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n-do.\n-\n-    >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n-    >>> layers.PLONE_FIXTURE.testSetUp()\n-    >>> z2.ZSERVER_FIXTURE.testSetUp()\n-    >>> layers.PLONE_ZSERVER.testSetUp()\n-\n-It is common in a test to use the Python API to change the state of the server\n-(e.g. create some content or change a setting) and then use the HTTP protocol\n-to look at the results. Bear in mind that the server is running in a separate\n-thread, with a separate security manager, so calls to ``helpers.login()`` and\n-``helpers.logout()``, for instance, do not affect the server thread.\n-\n-    >>> portal = layers.PLONE_ZSERVER[\'portal\'] # would normally be self.layer[\'portal\']\n-    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-    >>> portal.title = \'Fancy Portal\'\n-\n-Note that we need to commit the transaction before it will show up in the\n-other thread.\n-\n-    >>> import transaction; transaction.commit()\n-\n-We can now look for this new object through the server.\n-\n-    >>> portal_url = portal.absolute_url()\n-    >>> portal_url.split(\':\')[:-1]\n-    [\'http\', \'//localhost\']\n-\n-    >>> from six.moves.urllib.request import urlopen\n-    >>> conn = urlopen(portal_url + \'/Title\', timeout=10)\n-    >>> responseBody = conn.read()\n-    >>> b"Fancy Portal" in responseBody\n-    True\n-    >>> conn.close()\n-\n-Test tear-down does nothing beyond what the base layers do.\n-\n-    >>> layers.PLONE_ZSERVER.testTearDown()\n-    >>> z2.ZSERVER_FIXTURE.testTearDown()\n-    >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n-    >>> zca.LAYER_CLEANUP.testTearDown()\n-\n-    >>> \'portal\' in layers.PLONE_ZSERVER\n-    False\n-\n-    >>> \'app\' in layers.PLONE_ZSERVER\n-    False\n-\n-    >>> \'request\' in layers.PLONE_ZSERVER\n-    False\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print(\'folder1\' in portal.objectIds())\n-    False\n-\n-When the server is torn down, the ZServer thread is stopped.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.Plone:WSGIServer in ... seconds.\n-    Tear down plone.testing.zope.WSGIServer in ... seconds.\n-    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.zope.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-    >>> conn = urlopen(portal_url + \'/folder1\', timeout=5)\n-    Traceback (most recent call last):\n-    ...URLError: <urlopen error [Errno ...] Connection refused>\n-\n FTP server with Plone site\n ~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n@@ -415,10 +48,11 @@ indicate where Zope is running.\n Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n do.\n \n+    >>> from plone.testing import zca, zserver\n     >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n+    >>> zserver.STARTUP.testSetUp()\n     >>> layers.PLONE_FIXTURE.testSetUp()\n-    >>> z2.FTP_SERVER_FIXTURE.testSetUp()\n+    >>> zserver.FTP_SERVER_FIXTURE.testSetUp()\n     >>> layers.PLONE_FTP_SERVER.testSetUp()\n \n It is common in a test to use the Python API to change the state of the server\n@@ -427,6 +61,8 @@ to look at the results. Bear in mind that the server is running in a separate\n thread, with a separate security manager, so calls to ``helpers.login()`` and\n ``helpers.logout()``, for instance, do not affect the server thread.\n \n+    >>> from plone.app.testing import helpers\n+    >>> from plone.app.testing.interfaces import TEST_USER_ID\n     >>> portal = layers.PLONE_FTP_SERVER[\'portal\'] # would normally be self.layer[\'portal\']\n     >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n     >>> from OFS.Folder import Folder\n@@ -465,9 +101,9 @@ other thread.\n Test tear-down does nothing beyond what the base layers do.\n \n     >>> layers.PLONE_FTP_SERVER.testTearDown()\n-    >>> z2.FTP_SERVER_FIXTURE.testTearDown()\n+    >>> zserver.FTP_SERVER_FIXTURE.testTearDown()\n     >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zserver.STARTUP.testTearDown()\n     >>> zca.LAYER_CLEANUP.testTearDown()\n \n     >>> \'portal\' in layers.PLONE_FTP_SERVER\ndiff --git a/src/plone/app/testing/tests.py b/src/plone/app/testing/tests.py\nindex 3f0c844..22763e1 100644\n--- a/src/plone/app/testing/tests.py\n+++ b/src/plone/app/testing/tests.py\n@@ -1,5 +1,6 @@\n # -*- coding: utf-8 -*-\n import doctest\n+import six\n import unittest\n \n \n@@ -23,4 +24,9 @@ def test_suite():\n         doctest.DocFileSuite(\'helpers.rst\', optionflags=OPTIONFLAGS),\n         # seltest,\n     ])\n+    if six.PY2:\n+        suite.addTests([\n+            doctest.DocFileSuite(\n+                \'layers_zserver.rst\', optionflags=OPTIONFLAGS),\n+        ])\n     return suite\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-05-18T06:47:06+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.app.testing/commit/fc2d4401acb2a18dfa5f6c8e75be6a7d88dadf01

Use the correct setuptools version.

Files changed:
M tox.ini

b'diff --git a/tox.ini b/tox.ini\nindex bfc9cd8..d43856f 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -20,7 +20,7 @@ extras =\n \n deps =\n      coverage\n-     setuptools==33.1.1\n+     setuptools==39.1.0\n      zc.buildout\n \n commands =\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-05-18T08:42:22+02:00
Author: Michael Howitz (icemac) <mh@gocept.com>
Commit: https://github.com/plone/plone.app.testing/commit/e0f028450474147b45d3cb4a18e4732daea0a059

Clean-up + stabialise tests.

Files changed:
M .travis.yml
M CHANGES.rst
M setup.py
M src/plone/app/testing/layers.rst
M src/plone/app/testing/layers_zserver.rst
M tox.ini

b'diff --git a/.travis.yml b/.travis.yml\nindex f55fe5f..960122c 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -9,8 +9,6 @@ matrix:\n           env: TOXENV=lint-py36\n         - python: "2.7"\n           env: TOXENV=py27\n-        - python: "3.4"\n-          env: TOXENV=py34\n         - python: "3.5"\n           env: TOXENV=py35\n         - python: "3.6"\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex e55a0b4..8a05542 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -6,7 +6,7 @@ Changelog\n \n Breaking changes:\n \n-- *add item here*\n+- Require `plone.testing >= 7.0`.\n \n New features:\n \n@@ -16,10 +16,13 @@ New features:\n - Load negotiator from plone.i18n (PTS removed).\n   [jensens, ksuess]\n \n+- Add support for Python 3.5 and 3.6.\n+  [loechel, ale-rt, icemac]\n+\n Bug fixes:\n \n-- Improve compatibility with Python3\n-  [loechel, ale-rt]\n+- *none yet*\n+\n \n 5.0.8 (2017-10-25)\n ------------------\ndiff --git a/setup.py b/setup.py\nindex 409705e..ecda2e4 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -48,23 +48,21 @@ def read(*rnames):\n     classifiers=[\n         "Environment :: Web Environment",\n         "Framework :: Plone",\n-        "Framework :: Plone :: 5.0",\n-        "Framework :: Plone :: 5.1",\n         "Framework :: Plone :: 5.2",\n-        "Framework :: Zope2",\n+        "Framework :: Zope :: 4",\n         "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n         "Operating System :: OS Independent",\n         "Programming Language :: Python",\n         "Programming Language :: Python :: 2.7",\n         "Programming Language :: Python :: 3.5",\n         "Programming Language :: Python :: 3.6",\n-        "Programming Language :: Python :: 3.7",\n+        # "Programming Language :: Python :: 3.7",\n         "Topic :: Internet :: WWW/HTTP :: Dynamic Content",\n     ],\n     keywords=\'plone tests\',\n     author=\'Plone Foundation\',\n     author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://pypi.python.org/pypi/plone.app.testing\',\n+    url=\'https://github.com/plone/plone.app.testing\',\n     license=\'GPL version 2\',\n     packages=find_packages(\'src\'),\n     package_dir={\'\': \'src\'},\n@@ -85,7 +83,7 @@ def read(*rnames):\n         # \'AccessControl\', # Zope 2.13+\n         \'Products.CMFPlone\',\n         \'Products.GenericSetup\',\n-        \'Zope2\',\n+        \'Zope\',\n     ],\n     tests_require=tests_require,\n     extras_require={\ndiff --git a/src/plone/app/testing/layers.rst b/src/plone/app/testing/layers.rst\nindex d6bf179..fa966b4 100644\n--- a/src/plone/app/testing/layers.rst\n+++ b/src/plone/app/testing/layers.rst\n@@ -61,9 +61,9 @@ normally use this for testing, unless you need to manipulate the site itself.\n \n     >>> with z2.zopeApp() as app:\n     ...     print(app[\'acl_users\'].getUser(SITE_OWNER_NAME))\n-    ...     print(app[\'acl_users\'].getUser(SITE_OWNER_NAME).getRolesInContext(app))\n+    ...     print(sorted(app[\'acl_users\'].getUser(SITE_OWNER_NAME).getRolesInContext(app)))\n     admin\n-    [\'Manager\', \'Authenticated\']\n+    [\'Authenticated\', \'Manager\']\n \n Inside the Plone site, the default theme is installed\n \ndiff --git a/src/plone/app/testing/layers_zserver.rst b/src/plone/app/testing/layers_zserver.rst\nindex 3715fb4..123be72 100644\n--- a/src/plone/app/testing/layers_zserver.rst\n+++ b/src/plone/app/testing/layers_zserver.rst\n@@ -129,6 +129,6 @@ When the server is torn down, the FTP server thread is stopped.\n     Tear down plone.testing.zserver.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n-    >>> ftpClient.connect(host, port, timeout=5)\n+    >>> ftpClient.connect(host, port, timeout=5) # doctest: +IGNORE_EXCEPTION_DETAIL\n     Traceback (most recent call last):\n     error: [Errno 61] Connection refused\ndiff --git a/tox.ini b/tox.ini\nindex d43856f..c9e8bea 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -1,6 +1,7 @@\n [tox]\n envlist =\n     py27,\n+    py35,\n     py36,\n     coverage-report,\n     docs,\n@@ -27,7 +28,7 @@ commands =\n     python -V\n     {envbindir}/buildout -c {toxinidir}/buildout.cfg buildout:directory={envdir} buildout:develop={toxinidir} bootstrap\n     {envbindir}/buildout -c {toxinidir}/buildout.cfg buildout:directory={envdir} buildout:develop={toxinidir} install test\n-    coverage run {envbindir}/test --all {posargs:-vc}\n+    coverage run {envbindir}/test --all {posargs:-vvc}\n \n setenv =\n     COVERAGE_FILE=.coverage.{envname}\n@@ -49,7 +50,7 @@ commands =\n     coverage combine\n     coverage html -i\n     coverage xml -i\n-    coverage report -i --fail-under=85\n+    coverage report -i --fail-under=60\n \n \n [lint]\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-06-26T23:49:29+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.testing/commit/7d5eb0fec2179549fcaa08b830db5b95bf72d2ea

reduce deprecated imports

Files changed:
M src/plone/app/testing/bbb.py
M src/plone/app/testing/helpers.py
M src/plone/app/testing/helpers.rst
M src/plone/app/testing/layers.py
M src/plone/app/testing/layers.rst
M src/plone/app/testing/selenium_layers.py

b'diff --git a/src/plone/app/testing/bbb.py b/src/plone/app/testing/bbb.py\nindex d07b92e..b185db8 100644\n--- a/src/plone/app/testing/bbb.py\n+++ b/src/plone/app/testing/bbb.py\n@@ -3,7 +3,7 @@\n \n from AccessControl import getSecurityManager\n from plone.app import testing\n-from plone.testing import z2\n+from plone.testing import zope\n from Products.CMFPlone.utils import _createObjectByType\n from Testing.ZopeTestCase.functional import Functional\n \n@@ -31,10 +31,10 @@ def setUpZope(self, app, configurationContext):\n         import Products.ATContentTypes\n         self.loadZCML(package=Products.ATContentTypes)\n \n-        z2.installProduct(app, \'Products.Archetypes\')\n-        z2.installProduct(app, \'Products.ATContentTypes\')\n-        z2.installProduct(app, \'plone.app.blob\')\n-        z2.installProduct(app, \'plone.app.collection\')\n+        zope.installProduct(app, \'Products.Archetypes\')\n+        zope.installProduct(app, \'Products.ATContentTypes\')\n+        zope.installProduct(app, \'plone.app.blob\')\n+        zope.installProduct(app, \'plone.app.collection\')\n \n     def setUpPloneSite(self, portal):\n         # restore default workflow\n@@ -47,10 +47,10 @@ def setUpPloneSite(self, portal):\n         _createMemberarea(portal, testing.TEST_USER_ID)\n \n     def tearDownZope(self, app):\n-        z2.uninstallProduct(app, \'plone.app.collection\')\n-        z2.uninstallProduct(app, \'plone.app.blob\')\n-        z2.uninstallProduct(app, \'Products.ATContentTypes\')\n-        z2.uninstallProduct(app, \'Products.Archetypes\')\n+        zope.uninstallProduct(app, \'plone.app.collection\')\n+        zope.uninstallProduct(app, \'plone.app.blob\')\n+        zope.uninstallProduct(app, \'Products.ATContentTypes\')\n+        zope.uninstallProduct(app, \'Products.Archetypes\')\n \n \n PTC_FIXTURE = PloneTestCaseFixture()\n@@ -114,7 +114,7 @@ def login(self, userName=testing.TEST_USER_NAME):\n \n     def loginAsPortalOwner(self, userName=testing.SITE_OWNER_NAME):\n         """Log in to the portal as the user who created it."""\n-        z2.login(self.app[\'acl_users\'], userName)\n+        zope.login(self.app[\'acl_users\'], userName)\n \n     def logout(self):\n         """Log out, i.e. become anonymous."""\ndiff --git a/src/plone/app/testing/helpers.py b/src/plone/app/testing/helpers.py\nindex 6401d0d..7a31c40 100644\n--- a/src/plone/app/testing/helpers.py\n+++ b/src/plone/app/testing/helpers.py\n@@ -8,9 +8,9 @@\n from plone.app.testing.interfaces import TEST_USER_NAME\n from plone.testing import Layer\n from plone.testing import security\n-from plone.testing import z2\n from plone.testing import zca\n from plone.testing import zodb\n+from plone.testing import zope\n from zope.component import getGlobalSiteManager\n from zope.component.hooks import getSite\n from zope.component.hooks import setHooks\n@@ -27,14 +27,14 @@ def login(portal, userName):\n     """Log in as the given user in the given Plone site\n     """\n \n-    z2.login(portal[\'acl_users\'], userName)\n+    zope.login(portal[\'acl_users\'], userName)\n \n \n def logout():\n     """Log out, i.e. become anonymous\n     """\n \n-    z2.logout()\n+    zope.logout()\n \n \n def setRoles(portal, userId, roles):\n@@ -42,7 +42,7 @@ def setRoles(portal, userId, roles):\n     """\n \n     userFolder = portal[\'acl_users\']\n-    z2.setRoles(userFolder, userId, roles)\n+    zope.setRoles(userFolder, userId, roles)\n \n \n def tearDownMultiPluginRegistration(pluginName):\n@@ -81,7 +81,7 @@ def quickInstallProduct(portal, productName, reinstall=False):\n     sm = getSecurityManager()\n     app = aq_parent(portal)\n \n-    z2.login(app[\'acl_users\'], SITE_OWNER_NAME)\n+    zope.login(app[\'acl_users\'], SITE_OWNER_NAME)\n \n     try:\n         from Products.CMFPlone.utils import get_installer\n@@ -127,7 +127,7 @@ def applyProfile(portal, profileName, purge_old=None,\n     sm = getSecurityManager()\n     app = aq_parent(portal)\n \n-    z2.login(app[\'acl_users\'], SITE_OWNER_NAME)\n+    zope.login(app[\'acl_users\'], SITE_OWNER_NAME)\n \n     try:\n         setupTool = portal[\'portal_setup\']\n@@ -234,13 +234,13 @@ def persist_profile_upgrade_versions(portal):\n \n \n @contextlib.contextmanager\n-def ploneSite(db=None, connection=None, environ=None, flavour=z2):\n+def ploneSite(db=None, connection=None, environ=None, flavour=zope):\n     """Context manager for working with the Plone portal during layer setup::\n \n         with ploneSite() as portal:\n             ...\n \n-    This is based on the ``z2.zopeApp()`` context manager. See the module\n+    This is based on the ``zope.zopeApp()`` context manager. See the module\n      ``plone.testing.z2`` for details.\n \n     Do not use this in a test. Use the \'portal\' resource from the PloneFixture\n@@ -296,7 +296,7 @@ def setUpZope(self, app, configurationContext):\n         ``configurationContext`` is the ZCML configuration context.\n \n         This is the most appropriate place to load ZCML or install Zope 2-\n-        style products, using the ``plone.testing.z2.installProduct`` helper.\n+        style products, using the ``plone.testing.zope.installProduct`` helper.\n         """\n         pass\n \n@@ -306,7 +306,7 @@ def tearDownZope(self, app):\n         ``app`` is the Zope application root.\n \n         This is the most appropriate place to uninstall Zope 2-style products\n-        using the ``plone.testing.z2.uninstallProduct`` helper.\n+        using the ``plone.testing.zope.uninstallProduct`` helper.\n         """\n         pass\n \n@@ -388,7 +388,7 @@ def setUp(self):\n \n     def tearDown(self):\n \n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n \n             portal = app[PLONE_SITE_ID]\n             setHooks()\n@@ -476,7 +476,7 @@ def setUpZope(self, app, configurationContext):\n         """\n         self.setUpZCMLFiles()\n         for z2Product in self.additional_z2_products:\n-            z2.installProduct(app, z2Product)\n+            zope.installProduct(app, z2Product)\n \n     def setUpZCMLFiles(self):\n         """Load default ZCML.\ndiff --git a/src/plone/app/testing/helpers.rst b/src/plone/app/testing/helpers.rst\nindex f1b6431..b4742ec 100644\n--- a/src/plone/app/testing/helpers.rst\n+++ b/src/plone/app/testing/helpers.rst\n@@ -61,7 +61,7 @@ need to tear that down as well.\n     ...         return qi.is_product_installed(product_name)\n \n     >>> from plone.testing import Layer\n-    >>> from plone.testing import zca, z2, zodb\n+    >>> from plone.testing import zca, zope, zodb\n \n     >>> from plone.app.testing import PLONE_FIXTURE\n     >>> from plone.app.testing import IntegrationTesting\n@@ -168,7 +168,7 @@ and the results of the profile having been applied.\n Let\'s now simulate a test.\n \n     >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n+    >>> zope.STARTUP.testSetUp()\n     >>> PLONE_FIXTURE.testSetUp()\n     >>> HELPER_DEMOS_FIXTURE.testSetUp()\n     >>> HELPER_DEMOS_INTEGRATION_TESTING.testSetUp()\n@@ -214,7 +214,7 @@ Let\'s now tear down the test.\n     >>> HELPER_DEMOS_INTEGRATION_TESTING.testTearDown()\n     >>> HELPER_DEMOS_FIXTURE.testTearDown()\n     >>> PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n     >>> zca.LAYER_CLEANUP.testTearDown()\n \n Our persistent changes from the layer should remain, but those made in a test\n@@ -299,7 +299,7 @@ layer base class which helps implement this pattern.\n     ...         PluggableAuthService.registerMultiPlugin("dummy_plugin1")\n     ...\n     ...         # Finally, this is a good place to load Zope products,\n-    ...         # using the plone.testing.z2.installProduct() helper.\n+    ...         # using the plone.testing.zope.installProduct() helper.\n     ...         # Make some other global changes not stored in the ZODB or\n     ...         # the global component registry\n     ...         someGlobal[\'test\'] = 1\ndiff --git a/src/plone/app/testing/layers.py b/src/plone/app/testing/layers.py\nindex 3dd3b20..8167f5c 100644\n--- a/src/plone/app/testing/layers.py\n+++ b/src/plone/app/testing/layers.py\n@@ -14,7 +14,6 @@\n from plone.app.testing.interfaces import TEST_USER_ROLES\n from plone.app.testing.utils import MockMailHost\n from plone.testing import Layer\n-from plone.testing import z2\n from plone.testing import zca\n from plone.testing import zodb\n from plone.testing import zope\n@@ -36,7 +35,7 @@ class PloneFixture(Layer):\n       role, ``Member``.\n     """\n \n-    defaultBases = (z2.STARTUP,)\n+    defaultBases = (zope.STARTUP,)\n \n     # Products that will be installed, plus options\n     products = (\n@@ -90,7 +89,7 @@ class PloneFixture(Layer):\n \n     def setUp(self):\n \n-        # Stack a new DemoStorage on top of the one from z2.STARTUP.\n+        # Stack a new DemoStorage on top of the one from zope.STARTUP.\n         self[\'zodbDB\'] = zodb.stackDemoStorage(\n             self.get(\'zodbDB\'),\n             name=\'PloneFixture\'\n@@ -99,14 +98,14 @@ def setUp(self):\n         self.setUpZCML()\n \n         # Set up products and the default content\n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n             self.setUpProducts(app)\n             self.setUpDefaultContent(app)\n \n     def tearDown(self):\n \n         # Tear down products\n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n             # note: content tear-down happens by squashing the ZODB\n             self.tearDownProducts(app)\n \n@@ -179,7 +178,7 @@ def setUpProducts(self, app):\n \n         for p, config in self.products:\n             if config.get(\'install\', True):\n-                z2.installProduct(app, p)\n+                zope.installProduct(app, p)\n \n     def tearDownProducts(self, app):\n         """Uninstall all old-style products listed in the the ``products``\n@@ -187,7 +186,7 @@ def tearDownProducts(self, app):\n         """\n         for p, config in reversed(self.products):\n             if config.get(\'install\', True):\n-                z2.uninstallProduct(app, p)\n+                zope.uninstallProduct(app, p)\n \n         # Clean up Wicked turds\n         # XXX: This may tear down too much state\n@@ -217,7 +216,7 @@ def setUpDefaultContent(self, app):\n             []\n         )\n \n-        z2.login(app[\'acl_users\'], SITE_OWNER_NAME)\n+        zope.login(app[\'acl_users\'], SITE_OWNER_NAME)\n \n         # Create the site with the default set of extension profiles\n         from Products.CMFPlone.factory import addPloneSite\n@@ -246,7 +245,7 @@ def setUpDefaultContent(self, app):\n             pas.portal_role_manager.doAssignRoleToPrincipal(TEST_USER_ID, role)\n \n         # Log out again\n-        z2.logout()\n+        zope.logout()\n \n \n # Plone fixture layer instance. Should not be used on its own, but as a base\n@@ -371,7 +370,7 @@ class MockMailHostLayer(Layer):\n     defaultBases = (PLONE_FIXTURE,)\n \n     def setUp(self):\n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n             portal = app[PLONE_SITE_ID]\n             portal.email_from_address = \'noreply@example.com\'\n             portal.email_from_name = \'Plone Site\'\n@@ -383,7 +382,7 @@ def setUp(self):\n             sm.registerUtility(mailhost, provided=IMailHost)\n \n     def tearDown(self):\n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n             portal = app[PLONE_SITE_ID]\n             _o_mailhost = getattr(portal, \'_original_MailHost\', None)\n             if _o_mailhost:\n@@ -399,12 +398,12 @@ def tearDown(self):\n MOCK_MAILHOST_FIXTURE = MockMailHostLayer()\n \n \n-class IntegrationTesting(PloneTestLifecycle, z2.IntegrationTesting):\n+class IntegrationTesting(PloneTestLifecycle, zope.IntegrationTesting):\n     """Plone version of the integration testing layer\n     """\n \n \n-class FunctionalTesting(PloneTestLifecycle, z2.FunctionalTesting):\n+class FunctionalTesting(PloneTestLifecycle, zope.FunctionalTesting):\n     """Plone version of the functional testing layer\n     """\n \ndiff --git a/src/plone/app/testing/layers.rst b/src/plone/app/testing/layers.rst\nindex fa966b4..cd21cff 100644\n--- a/src/plone/app/testing/layers.rst\n+++ b/src/plone/app/testing/layers.rst\n@@ -15,7 +15,7 @@ For testing, we need a testrunner\n Plone site fixture\n ~~~~~~~~~~~~~~~~~~\n \n-The ``PLONE_FIXTURE`` layer extends ``STARTUP`` from ``plone.testing.z2`` to\n+The ``PLONE_FIXTURE`` layer extends ``STARTUP`` from ``plone.testing.zope`` to\n set up a Plone site.\n \n **Note:** This layer should only be used as a base layer, and not directly in\n@@ -56,10 +56,10 @@ password are found in the constants ``SITE_OWNER_NAME`` and\n has the ``Manager`` role, and is the owner of the site object. You should not\n normally use this for testing, unless you need to manipulate the site itself.\n \n-    >>> from plone.testing import z2, zca\n+    >>> from plone.testing import zope, zca\n     >>> from plone.app.testing.interfaces import SITE_OWNER_NAME\n \n-    >>> with z2.zopeApp() as app:\n+    >>> with zope.zopeApp() as app:\n     ...     print(app[\'acl_users\'].getUser(SITE_OWNER_NAME))\n     ...     print(sorted(app[\'acl_users\'].getUser(SITE_OWNER_NAME).getRolesInContext(app)))\n     admin\n@@ -73,7 +73,7 @@ Inside the Plone site, the default theme is installed\n     /++theme++barceloneta/rules.xml\n \n **Note:** Here, we have used the ``ploneSite`` context manager to get hold of\n-the Plone site root. Like ``z2.zopeApp()``, this is intended for use during\n+the Plone site root. Like ``zope.zopeApp()``, this is intended for use during\n layer setup and tear-down, and will automatically commit any changes unless an\n error is raised.\n \n@@ -128,7 +128,7 @@ Let\'s set up the layers and attempt to run a test.\n Let\'s now simulate a test\n \n     >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n+    >>> zope.STARTUP.testSetUp()\n     >>> layers.PLONE_FIXTURE.testSetUp()\n     >>> layers.PLONE_INTEGRATION_TESTING.testSetUp()\n \n@@ -165,7 +165,7 @@ Let\'s now simulate test tear-down.\n \n     >>> layers.PLONE_INTEGRATION_TESTING.testTearDown()\n     >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n     >>> zca.LAYER_CLEANUP.testTearDown()\n \n At this point, our transaction has been rolled back:\n@@ -217,7 +217,7 @@ Let\'s set up the layers and attempt to run a test.\n Let\'s now simulate a test\n \n     >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n+    >>> zope.STARTUP.testSetUp()\n     >>> layers.PLONE_FIXTURE.testSetUp()\n     >>> layers.PLONE_FUNCTIONAL_TESTING.testSetUp()\n \n@@ -247,7 +247,7 @@ Let\'s now simulate test tear-down.\n \n     >>> layers.PLONE_FUNCTIONAL_TESTING.testTearDown()\n     >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n     >>> zca.LAYER_CLEANUP.testTearDown()\n \n The previous database state should have been restored.\n@@ -311,9 +311,9 @@ Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n do.\n \n     >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n+    >>> zope.STARTUP.testSetUp()\n     >>> layers.PLONE_FIXTURE.testSetUp()\n-    >>> z2.ZSERVER_FIXTURE.testSetUp()\n+    >>> zope.WSGI_SERVER_FIXTURE.testSetUp()\n     >>> layers.PLONE_ZSERVER.testSetUp()\n \n It is common in a test to use the Python API to change the state of the server\n@@ -347,9 +347,9 @@ We can now look for this new object through the server.\n Test tear-down does nothing beyond what the base layers do.\n \n     >>> layers.PLONE_ZSERVER.testTearDown()\n-    >>> z2.ZSERVER_FIXTURE.testTearDown()\n+    >>> zope.WSGI_SERVER_FIXTURE.testTearDown()\n     >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n     >>> zca.LAYER_CLEANUP.testTearDown()\n \n     >>> \'portal\' in layers.PLONE_ZSERVER\ndiff --git a/src/plone/app/testing/selenium_layers.py b/src/plone/app/testing/selenium_layers.py\nindex 3804f75..965f2df 100644\n--- a/src/plone/app/testing/selenium_layers.py\n+++ b/src/plone/app/testing/selenium_layers.py\n@@ -4,14 +4,14 @@\n from plone.app.testing import TEST_USER_NAME\n from plone.app.testing import TEST_USER_PASSWORD\n from plone.testing import Layer\n-from plone.testing import z2\n+from plone.testing import zope\n \n import os\n import transaction\n \n \n class SeleniumLayer(Layer):\n-    defaultBases = (z2.ZSERVER_FIXTURE, )\n+    defaultBases = (zope.ZSERVER_FIXTURE, )\n \n     def testSetUp(self):\n         # Start up Selenium\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-07-01T11:22:17+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.testing/commit/7a750eea58dc13074376072b8dc5f7fb9d6f68fe

Remove dependency of PloneTestCase on Archetypes and use p.a.c instead. Porting all tests away from PloneTestCase seems less work that migrating the layer and fixing the tests.

Files changed:
M src/plone/app/testing/bbb.py

b"diff --git a/src/plone/app/testing/bbb.py b/src/plone/app/testing/bbb.py\nindex b185db8..4d68621 100644\n--- a/src/plone/app/testing/bbb.py\n+++ b/src/plone/app/testing/bbb.py\n@@ -28,30 +28,19 @@ class PloneTestCaseFixture(testing.PloneSandboxLayer):\n     defaultBases = (testing.PLONE_FIXTURE,)\n \n     def setUpZope(self, app, configurationContext):\n-        import Products.ATContentTypes\n-        self.loadZCML(package=Products.ATContentTypes)\n-\n-        zope.installProduct(app, 'Products.Archetypes')\n-        zope.installProduct(app, 'Products.ATContentTypes')\n-        zope.installProduct(app, 'plone.app.blob')\n-        zope.installProduct(app, 'plone.app.collection')\n+        import plone.app.contenttypes\n+        self.loadZCML(package=plone.app.contenttypes)\n \n     def setUpPloneSite(self, portal):\n         # restore default workflow\n         testing.applyProfile(portal, 'Products.CMFPlone:testfixture')\n \n         # add default content\n-        testing.applyProfile(portal, 'Products.ATContentTypes:content')\n+        testing.applyProfile(portal, 'plone.app.contenttypes:default')\n \n         # add home folder for default test user\n         _createMemberarea(portal, testing.TEST_USER_ID)\n \n-    def tearDownZope(self, app):\n-        zope.uninstallProduct(app, 'plone.app.collection')\n-        zope.uninstallProduct(app, 'plone.app.blob')\n-        zope.uninstallProduct(app, 'Products.ATContentTypes')\n-        zope.uninstallProduct(app, 'Products.Archetypes')\n-\n \n PTC_FIXTURE = PloneTestCaseFixture()\n PTC_FUNCTIONAL_TESTING = testing.FunctionalTesting(\n"

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-07-01T15:55:35+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.testing/commit/a0d77f9e9c1b28c54c4ed976199169e1b99e1456

install dx default content

Files changed:
M src/plone/app/testing/bbb.py

b"diff --git a/src/plone/app/testing/bbb.py b/src/plone/app/testing/bbb.py\nindex 4d68621..9cf5a10 100644\n--- a/src/plone/app/testing/bbb.py\n+++ b/src/plone/app/testing/bbb.py\n@@ -36,7 +36,7 @@ def setUpPloneSite(self, portal):\n         testing.applyProfile(portal, 'Products.CMFPlone:testfixture')\n \n         # add default content\n-        testing.applyProfile(portal, 'plone.app.contenttypes:default')\n+        testing.applyProfile(portal, 'plone.app.contenttypes:plone-content')\n \n         # add home folder for default test user\n         _createMemberarea(portal, testing.TEST_USER_ID)\n"

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-07-03T16:22:51+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.testing/commit/4ed6b7314b3e18b52c3b8ed39b37e265fc2285e0

fix travis

Files changed:
M buildout.cfg

b"diff --git a/buildout.cfg b/buildout.cfg\nindex b8dba71..2d668da 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -1,6 +1,8 @@\n [buildout]\n extends = https://raw.githubusercontent.com/collective/buildout.plonetest/master/test-5.x.cfg\n           https://raw.githubusercontent.com/plone/buildout.coredev/5.2/versions.cfg\n+          https://raw.githubusercontent.com/plone/buildout.coredev/5.2/sources.cfg\n+          https://raw.githubusercontent.com/plone/buildout.coredev/5.2/checkouts.cfg\n \n parts =\n     coverage\n@@ -21,116 +23,15 @@ sources-dir = src-mrd\n \n develop = .\n \n-[remotes]\n-plone = git://github.com/plone\n-plone_push = git@github.com:plone\n-zope = git://github.com/zopefoundation\n-zope_push = git@github.com:zopefoundation\n-collective = https://github.com/collective\n-collective_push = git@github.com:collective\n-\n [versions]\n plone.app.testing =\n-Products.GenericSetup = >= 2.0b1\n-Products.PluginRegistry = >= 1.6\n \n [sources]\n-AccessControl                 = git ${remotes:zope}/AccessControl.git                   pushurl=${remotes:zope_push}/AccessControl.git                  branch=master\n-Chameleon                     = git https://github.com/malthe/chameleon.git             branch=master\n-DocumentTemplate              = git ${remotes:zope}/DocumentTemplate.git                pushurl=${remotes:zope_push}/DocumentTemplate.git               branch=master\n-Products.CMFCore              = git ${remotes:zope}/Products.CMFCore.git                pushurl=${remotes:zope_push}/Products.CMFCore.git               branch=master\n-Products.CMFEditions          = git ${remotes:plone}/Products.CMFEditions.git           pushurl=${remotes:plone_push}/Products.CMFEditions.git          branch=master\n-Products.CMFFormController    = git ${remotes:plone}/Products.CMFFormController.git     pushurl=${remotes:plone_push}/Products.CMFFormController.git    branch=python3\n-Products.CMFPlacefulWorkflow  = git ${remotes:plone}/Products.CMFPlacefulWorkflow.git   pushurl=${remotes:plone_push}/Products.CMFPlacefulWorkflow.git  branch=master\n-Products.CMFPlone             = git ${remotes:plone}/Products.CMFPlone.git              pushurl=${remotes:plone_push}/Products.CMFPlone.git             branch=python3\n-Products.CMFDynamicViewFTI    = git ${remotes:plone}/Products.CMFDynamicViewFTI.git     pushurl=${remotes:plone_push}/Products.CMFDynamicViewFTI.git    branch=python3\n-Products.CMFQuickInstallerTool= git ${remotes:plone}/Products.CMFQuickInstallerTool.git pushurl=${remotes:plone_push}/Products.CMFQuickInstallerTool.git branch=master\n-Products.CMFUid               = git ${remotes:zope}/Products.CMFUid.git                 pushurl=${remotes:plone_push}/Products.CMFUid.git               branch=py3-vs-zcatalog-branch\n-Products.DCWorkflow           = git ${remotes:zope}/Products.DCWorkflow.git             pushurl=${remotes:plone_push}/Products.DCWorkflow.git           branch=python3\n-Products.DateRecurringIndex   = git ${remotes:collective}/Products.DateRecurringIndex.git pushurl=${remotes:collective_push}/Products.DateRecurringIndex.git branch=python3\n-Products.GenericSetup         = git ${remotes:zope}/Products.GenericSetup.git           pushurl=${remotes:zope_push}/Products.GenericSetup.git          branch=pbauer-python3\n-Products.MimetypesRegistry    = git ${remotes:plone}/Products.MimetypesRegistry.git     pushurl=${remotes:plone_push}/Products.MimetypesRegistry.git    branch=master\n-Products.PDBDebugMode         = git ${remotes:collective}/Products.PDBDebugMode.git     pushurl=${remotes:collective_push}/Products.PDBDebugMode.git    branch=zope4\n-Products.PlonePAS             = git ${remotes:plone}/Products.PlonePAS.git              pushurl=${remotes:plone_push}/Products.PlonePAS.git             branch=python3\n-Products.PluggableAuthService = git ${remotes:zope}/Products.PluggableAuthService.git   pushurl=${remotes:zope_push}/Products.PluggableAuthService.git  branch=master\n-Products.PluginRegistry       = git ${remotes:zope}/Products.PluginRegistry.git         pushurl=${remotes:plone_push}/Products.PluginRegistry.git       branch=master\n-Products.PortalTransforms     = git ${remotes:plone}/Products.PortalTransforms.git      pushurl=${remotes:plone_push}/Products.PortalTransforms.git     branch=python3\n-Products.ResourceRegistries   = git ${remotes:plone}/Products.ResourceRegistries.git    pushurl=${remotes:zope_push}/Products.ResourceRegistries.git    branch=master\n-Products.Sessions             = git ${remotes:zope}/Products.Sessions.git               pushurl=${remotes:zope_push}/Products.Sessions.git              branch=python3\n-Products.SiteErrorLog         = git ${remotes:zope}/Products.SiteErrorLog.git           pushurl=${remotes:zope_push}/Products.SiteErrorLog.git          branch=python3\n-Products.TemporaryFolder      = git ${remotes:zope}/Products.TemporaryFolder.git        pushurl=${remotes:zope_push}/Products.TemporaryFolder.git       branch=master\n-Products.ZCatalog             = git ${remotes:zope}/Products.ZCatalog.git pushurl=${remotes:zope_push}/Products.ZCatalog.git branch=master\n-Products.ZopeVersionControl   = git ${remotes:zope}/Products.ZopeVersionControl.git     pushurl=${remotes:zope_push}/Products.ZopeVersionControl.git    branch=py3_imports\n-Products.statusmessages       = git ${remotes:plone}/Products.statusmessages.git        pushurl=${remotes:plone_push}/Products.statusmessages.git       branch=master\n-ZConfig                       = git ${remotes:zope}/ZConfig.git pushurl=${remotes:zope_push}/ZConfig.git branch=master\n-ZServer                       = git ${remotes:zope}/ZServer.git pushurl=${remotes:zope_push}/ZServer.git branch=master\n-Zope                          = git ${remotes:zope}/Zope.git                            pushurl=${remotes:zope_push}/Zope.git                           branch=master\n-collective.monkeypatcher      = git ${remotes:plone}/collective.monkeypatcher.git       pushurl=${remotes:plone_push}/collective.monkeypatcher.git      branch=master\n-collective.xmltestreport      = git ${remotes:collective}/collective.xmltestreport.git  pushurl=${remotes:collective_push}/collective.xmltestreport.git branch=gforcada-python3\n-five.customerize              = git ${remotes:zope}/five.customerize.git                pushurl=${remotes:zope_push}/five.customerize.git               branch=master\n-plone.app.caching             = git ${remotes:plone}/plone.app.caching.git              pushurl=${remotes:plone_push}/plone.app.caching.git             branch=python3\n-plone.app.content             = git ${remotes:plone}/plone.app.content.git              pushurl=${remotes:plone_push}/plone.app.content.git             branch=python3\n-plone.app.contentmenu         = git ${remotes:plone}/plone.app.contentmenu.git          pushurl=${remotes:plone_push}/plone.app.contentmenu.git         branch=python3\n-plone.app.contenttypes        = git ${remotes:plone}/plone.app.contenttypes.git         pushurl=${remotes:plone_push}/plone.app.contenttypes.git        branch=python3\n-plone.app.dexterity           = git ${remotes:plone}/plone.app.dexterity.git            pushurl=${remotes:plone_push}/plone.app.dexterity.git           branch=python3\n-plone.app.discussion          = git ${remotes:plone}/plone.app.discussion.git           pushurl=${remotes:plone_push}/plone.app.discussion.git          branch=python3\n-plone.app.event               = git ${remotes:plone}/plone.app.event.git                pushurl=${remotes:plone_push}/plone.app.event.git               branch=master\n-plone.app.folder              = git ${remotes:plone}/plone.app.folder.git               pushurl=${remotes:plone_push}/plone.app.folder.git              branch=python3\n-plone.app.iterate             = git ${remotes:plone}/plone.app.iterate.git              pushurl=${remotes:plone_push}/plone.app.iterate.git             branch=python3\n-plone.app.layout              = git ${remotes:plone}/plone.app.layout.git               pushurl=${remotes:plone_push}/plone.app.layout.git              branch=python3\n-plone.app.linkintegrity       = git ${remotes:plone}/plone.app.linkintegrity.git        pushurl=${remotes:plone_push}/plone.app.linkintegrity.git       branch=python3\n-plone.app.multilingual        = git ${remotes:plone}/plone.app.multilingual.git         pushurl=${remotes:plone_push}/plone.app.multilingual.git        branch=master\n-plone.app.portlets            = git ${remotes:plone}/plone.app.portlets.git             pushurl=${remotes:plone_push}/plone.app.portlets.git            branch=python3\n-plone.app.registry            = git ${remotes:plone}/plone.app.registry.git             pushurl=${remotes:plone_push}/plone.app.registry.git            branch=master\n-plone.app.relationfield       = git ${remotes:plone}/plone.app.relationfield.git        pushurl=${remotes:plone_push}/plone.app.relationfield.git       branch=master\n-plone.app.textfield           = git ${remotes:plone}/plone.app.textfield.git            pushurl=${remotes:plone_push}/plone.app.textfield.git           branch=python3\n-plone.app.theming             = git ${remotes:plone}/plone.app.theming.git              pushurl=${remotes:plone_push}/plone.app.theming.git             branch=master\n-plone.app.users               = git ${remotes:plone}/plone.app.users.git                pushurl=${remotes:plone_push}/plone.app.users.git               branch=python3\n-plone.app.versioningbehavior  = git ${remotes:plone}/plone.app.versioningbehavior.git   pushurl=${remotes:plone_push}/plone.app.versioningbehavior.git  branch=python3\n-plone.app.viewletmanager      = git ${remotes:plone}/plone.app.viewletmanager.git       pushurl=${remotes:plone_push}/plone.app.viewletmanager.git      branch=master\n-plone.app.vocabularies        = git ${remotes:plone}/plone.app.vocabularies.git         pushurl=${remotes:plone_push}/plone.app.vocabularies.git        branch=python3\n-plone.app.widgets             = git ${remotes:plone}/plone.app.widgets.git              pushurl=${remotes:plone_push}/plone.app.widgets.git             branch=python3\n-plone.app.workflow            = git ${remotes:plone}/plone.app.workflow.git             pushurl=${remotes:plone_push}/plone.app.workflow.git            branch=python3\n-plone.app.z3cform             = git ${remotes:plone}/plone.app.z3cform.git              pushurl=${remotes:plone_push}/plone.app.z3cform.git             branch=master\n-plone.autoform                = git ${remotes:plone}/plone.autoform.git                 pushurl=${remotes:plone_push}/plone.autoform.git                branch=python3\n-plone.cachepurging            = git ${remotes:plone}/plone.cachepurging.git             pushurl=${remotes:plone_push}/plone.cachepurging.git            branch=python3\n-plone.dexterity               = git ${remotes:plone}/plone.dexterity.git                pushurl=${remotes:plone_push}/plone.dexterity.git               branch=python3\n-plone.folder                  = git ${remotes:plone}/plone.folder.git                   pushurl=${remotes:plone_push}/plone.folder.git                  branch=master\n-plone.formwidget.namedfile    = git ${remotes:plone}/plone.formwidget.namedfile.git     pushurl=${remotes:plone_push}/plone.formwidget.namedfile.git    branch=python3\n-plone.i18n                    = git ${remotes:plone}/plone.i18n.git                     pushurl=${remotes:plone_push}/plone.i18n.git                    branch=python3\n-plone.locking                 = git ${remotes:plone}/plone.locking.git                  pushurl=${remotes:plone_push}/plone.locking.git                 branch=python3\n-plone.namedfile               = git ${remotes:plone}/plone.namedfile.git                pushurl=${remotes:plone_push}/plone.namedfile.git               branch=python3\n-plone.outputfilters           = git ${remotes:plone}/plone.outputfilters.git            pushurl=${remotes:plone_push}/plone.outputfilters.git           branch=python3\n-plone.protect                 = git ${remotes:plone}/plone.protect.git                  pushurl=${remotes:plone_push}/plone.protect.git                 branch=python3\n-plone.recipe.zope2instance    = git ${remotes:plone}/plone.recipe.zope2instance.git     pushurl=${remotes:plone_push}/plone.recipe.zope2instance.git    branch=master\n-plone.reload                  = git ${remotes:plone}/plone.reload.git                   pushurl=${remotes:plone_push}/plone.reload.git                  branch=master\n-plone.resource                = git ${remotes:plone}/plone.resource.git                 pushurl=${remotes:plone_push}/plone.resource.git                branch=python3\n-plone.rfc822                  = git ${remotes:plone}/plone.rfc822.git                   pushurl=${remotes:plone_push}/plone.rfc822.git                  branch=master\n-plone.schemaeditor            = git ${remotes:plone}/plone.schemaeditor.git             pushurl=${remotes:plone_push}/plone.schemaeditor.git            branch=master\n-plone.session                 = git ${remotes:plone}/plone.session.git                  pushurl=${remotes:plone_push}/plone.session.git                 branch=python3\n-plone.stringinterp            = git ${remotes:plone}/plone.stringinterp.git             pushurl=${remotes:plone_push}/plone.stringinterp.git            branch=python3\n-plone.subrequest              = git ${remotes:plone}/plone.subrequest.git               pushurl=${remotes:plone_push}/plone.subrequest.git              branch=python3\n-plone.supermodel              = git ${remotes:plone}/plone.supermodel.git               pushurl=${remotes:plone_push}/plone.supermodel.git              branch=python3\n-plone.testing                 = git ${remotes:plone}/plone.testing.git                  pushurl=${remotes:plone_push}/plone.testing.git                 branch=py3\n-plone.transformchain          = git ${remotes:plone}/plone.transformchain.git           pushurl=${remotes:plone_push}/plone.transformchain.git          branch=master\n-plone.z3cform                 = git ${remotes:zope}/plone.z3cform.git                   pushurl=${remotes:zope_push}/plone.z3cform.git                  branch=python3\n-z3c.autoinclude               = git ${remotes:zope}/z3c.autoinclude.git                 pushurl=${remotes:zope_push}/z3c.autoinclude.git                branch=python3\n-z3c.caching                   = git ${remotes:zope}/z3c.caching.git                     pushurl=${remotes:zope_push}/z3c.caching.git                    branch=master\n-z3c.jbot                      = git ${remotes:zope}/z3c.jbot.git                        pushurl=${remotes:zope_push}/z3c.jbot.git                       branch=python3\n-z3c.objpath                   = git ${remotes:zope}/z3c.objpath.git                     pushurl=${remotes:zope_push}/z3c.objpath.git                    branch=master\n-z3c.relationfield             = git ${remotes:zope}/z3c.relationfield.git               pushurl=${remotes:zope_push}/z3c.relationfield.git              branch=master\n-zc.relation                   = git ${remotes:zope}/zc.relation.git                     pushurl=${remotes:zope_push}/zc.relation.git                    branch=master\n-zc.relationship               = git ${remotes:zope}/zc.relationship.git                 pushurl=${remotes:zope_push}/zc.relationship.git                branch=master\n-zope.interface                = git ${remotes:zope}/zope.interface.git                  pushurl=${remotes:zope_push}/zope.interface.git                 branch=plone-py3\n-zope.publisher                = git ${remotes:zope}/zope.publisher.git                  pushurl=${remotes:zope_push}/zope.publisher.git                 branch=master\n-zope.schema                   = git ${remotes:zope}/zope.schema.git                     pushurl=${remotes:zope_push}/zope.schema.git                    branch=re36-fields-hashable\n-\n-diazo                         = git ${remotes:plone}/diazo.git pushurl=${remotes:plone_push}/diazo.git branch=plone.app.testing-py3\n+plone.testing                 = git ${remotes:plone}/plone.testing.git pushurl=${remotes:plone_push}/plone.testing.git branch=py3_disallow_commits\n \n [test]\n recipe = zc.recipe.testrunner\n eggs =\n-    Pillow\n     plone.testing [test]\n     plone.app.testing [test]\n defaults = ['--auto-color']\n"

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-07-03T17:42:35+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.testing/commit/163595314e02424321c50c1cbd0600ea1888a7c5

use coredevs requirements

Files changed:
M .travis.yml
M tox.ini

b'diff --git a/.travis.yml b/.travis.yml\nindex 960122c..b0a0826 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -20,7 +20,7 @@ matrix:\n           env: TOXENV=py37\n \n install:\n-    - travis_retry pip install -U pip setuptools\n+    - travis_retry pip install -r https://raw.githubusercontent.com/plone/buildout.coredev/5.2/requirements.txt\n     - travis_retry pip install -U tox coveralls coverage\n \n script:\ndiff --git a/tox.ini b/tox.ini\nindex c9e8bea..b144ca7 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -20,8 +20,8 @@ extras =\n     test\n \n deps =\n-     coverage\n-     setuptools==39.1.0\n+     pip\n+     setuptools\n      zc.buildout\n \n commands =\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-07-04T09:12:13+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.testing/commit/dcada50b49cadaf9ccfe715e8157086861adf537

correctly declare test dependencies in setup.py

Files changed:
M buildout.cfg
M setup.py

b"diff --git a/buildout.cfg b/buildout.cfg\nindex 2d668da..ff4400a 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -32,8 +32,7 @@ plone.testing                 = git ${remotes:plone}/plone.testing.git pushurl=$\n [test]\n recipe = zc.recipe.testrunner\n eggs =\n-    plone.testing [test]\n-    plone.app.testing [test]\n+    plone.app.testing[test]\n defaults = ['--auto-color']\n selenium-driver =\n environment = testenv\ndiff --git a/setup.py b/setup.py\nindex ecda2e4..7bf7091 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -8,16 +8,17 @@\n version = '6.0.0.dev0'\n \n tests_require = [\n+    'plone.testing[test]'\n     'Products.CMFCore',\n+    'Products.CMFPlacefulWorkflow',\n     'Products.CMFPlone',\n     'Products.PluggableAuthService',\n-    'Products.CMFPlacefulWorkflow',\n     'selenium',\n     'transaction',\n     'zope.interface',\n     'zope.publisher',\n-    'zope.testrunner',\n     'zope.testing',\n+    'zope.testrunner',\n     # XXX unspecified dependency of plone.app.upgrade XXX\n     # 'Products.ATContentTypes',\n ]\n"

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-07-04T09:21:53+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.testing/commit/f0c949d880c772db04f99960693f65589699a7e8

some debug information, dont retry while debugging

Files changed:
M .travis.yml
M setup.py
M tox.ini

b"diff --git a/.travis.yml b/.travis.yml\nindex b0a0826..c6c5213 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -24,7 +24,7 @@ install:\n     - travis_retry pip install -U tox coveralls coverage\n \n script:\n-    - travis_retry tox\n+    - tox\n \n after_success:\n     - coverage combine\ndiff --git a/setup.py b/setup.py\nindex 7bf7091..16b13b5 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -8,7 +8,7 @@\n version = '6.0.0.dev0'\n \n tests_require = [\n-    'plone.testing[test]'\n+    'plone.testing[test]',\n     'Products.CMFCore',\n     'Products.CMFPlacefulWorkflow',\n     'Products.CMFPlone',\ndiff --git a/tox.ini b/tox.ini\nindex b144ca7..5063798 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -28,6 +28,7 @@ commands =\n     python -V\n     {envbindir}/buildout -c {toxinidir}/buildout.cfg buildout:directory={envdir} buildout:develop={toxinidir} bootstrap\n     {envbindir}/buildout -c {toxinidir}/buildout.cfg buildout:directory={envdir} buildout:develop={toxinidir} install test\n+    ls -la {envbindir}\n     coverage run {envbindir}/test --all {posargs:-vvc}\n \n setenv =\n"

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-07-04T09:33:20+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.testing/commit/394b6a4c985becd6189b922de85cda14eff36eff

install requirements via pip

Files changed:
M .travis.yml
M tox.ini

b'diff --git a/.travis.yml b/.travis.yml\nindex c6c5213..54a35b0 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -20,7 +20,6 @@ matrix:\n           env: TOXENV=py37\n \n install:\n-    - travis_retry pip install -r https://raw.githubusercontent.com/plone/buildout.coredev/5.2/requirements.txt\n     - travis_retry pip install -U tox coveralls coverage\n \n script:\ndiff --git a/tox.ini b/tox.ini\nindex 5063798..042641f 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -20,9 +20,7 @@ extras =\n     test\n \n deps =\n-     pip\n-     setuptools\n-     zc.buildout\n+     -rhttps://raw.githubusercontent.com/plone/buildout.coredev/5.2/requirements.txt\n \n commands =\n     python -V\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-07-04T09:38:37+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.testing/commit/76d01dafc70d98b419fdeca659f2ac515ee03e19

whiteliste external commands

Files changed:
M tox.ini

b'diff --git a/tox.ini b/tox.ini\nindex 042641f..88fceee 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -11,6 +11,7 @@ envlist =\n minversion = 1.9\n \n [testenv]\n+whitelist_externals = test coverage\n skip_install = true\n usedevelop = True\n \n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-09-22T16:48:53+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.testing/commit/7e5ada9cc0347affef243a8540c2c2e349e6b24f

add new bbb layer for Archetypes

Files changed:
A src/plone/app/testing/bbb_at.py
M src/plone/app/testing/bbb.py

b'diff --git a/src/plone/app/testing/bbb.py b/src/plone/app/testing/bbb.py\nindex 9cf5a10..3103192 100644\n--- a/src/plone/app/testing/bbb.py\n+++ b/src/plone/app/testing/bbb.py\n@@ -1,5 +1,5 @@\n # -*- coding: utf-8 -*-\n-"""Backwards-compatibility test class for PloneTestCase."""\n+"""Backwards-compatibility test class for PloneTestCase for Dexterity."""\n \n from AccessControl import getSecurityManager\n from plone.app import testing\ndiff --git a/src/plone/app/testing/bbb_at.py b/src/plone/app/testing/bbb_at.py\nnew file mode 100644\nindex 0000000..d91e37f\n--- /dev/null\n+++ b/src/plone/app/testing/bbb_at.py\n@@ -0,0 +1,124 @@\n+# -*- coding: utf-8 -*-\n+"""Backwards-compatibility test class for PloneTestCase for Archetypes."""\n+\n+from AccessControl import getSecurityManager\n+from plone.app import testing\n+from plone.testing import z2\n+from Products.CMFPlone.utils import _createObjectByType\n+from Testing.ZopeTestCase.functional import Functional\n+\n+import transaction\n+import unittest\n+\n+\n+def _createMemberarea(portal, user_id):\n+    mtool = portal.portal_membership\n+    members = mtool.getMembersFolder()\n+    if members is None:\n+        _createObjectByType(\'Folder\', portal, id=\'Members\')\n+    if not mtool.getMemberareaCreationFlag():\n+        mtool.setMemberareaCreationFlag()\n+    mtool.createMemberArea(user_id)\n+    if mtool.getMemberareaCreationFlag():\n+        mtool.setMemberareaCreationFlag()\n+\n+\n+class PloneTestCaseFixture(testing.PloneSandboxLayer):\n+\n+    defaultBases = (testing.PLONE_FIXTURE,)\n+\n+    def setUpZope(self, app, configurationContext):\n+        import Products.ATContentTypes\n+        self.loadZCML(package=Products.ATContentTypes)\n+\n+        z2.installProduct(app, \'Products.Archetypes\')\n+        z2.installProduct(app, \'Products.ATContentTypes\')\n+        z2.installProduct(app, \'plone.app.blob\')\n+        z2.installProduct(app, \'plone.app.collection\')\n+\n+    def setUpPloneSite(self, portal):\n+        # restore default workflow\n+        testing.applyProfile(portal, \'Products.CMFPlone:testfixture\')\n+\n+        # add default content\n+        testing.applyProfile(portal, \'Products.ATContentTypes:content\')\n+\n+        # add home folder for default test user\n+        _createMemberarea(portal, testing.TEST_USER_ID)\n+\n+    def tearDownZope(self, app):\n+        z2.uninstallProduct(app, \'plone.app.collection\')\n+        z2.uninstallProduct(app, \'plone.app.blob\')\n+        z2.uninstallProduct(app, \'Products.ATContentTypes\')\n+        z2.uninstallProduct(app, \'Products.Archetypes\')\n+\n+PTC_FIXTURE = PloneTestCaseFixture()\n+PTC_FUNCTIONAL_TESTING = testing.FunctionalTesting(\n+    bases=(PTC_FIXTURE,), name=\'PloneTestCase:Functional\')\n+\n+\n+class PloneTestCase(Functional, unittest.TestCase):\n+\n+    layer = PTC_FUNCTIONAL_TESTING\n+\n+    def setUp(self):\n+        """Set up before each test."""\n+        self.beforeSetUp()\n+        self.app = self.layer[\'app\']\n+        self.portal = self.layer[\'portal\']\n+        self.folder = self.portal.portal_membership.getHomeFolder(\n+            testing.TEST_USER_ID)\n+        transaction.commit()\n+        self.afterSetUp()\n+\n+    def beforeSetUp(self):\n+        """Hook to do setup before the portal is created."""\n+        pass\n+\n+    def afterSetUp(self):\n+        """Hook to do setup after the portal is created."""\n+\n+    def tearDown(self):\n+        """Tear down after each test."""\n+        self.beforeTearDown()\n+        transaction.abort()\n+        super(PloneTestCase, self).tearDown()\n+        self.afterTearDown()\n+\n+    def beforeTearDown(self):\n+        """Hook to do teardown before the portal is removed."""\n+\n+    def afterTearDown(self):\n+        """Hook to do teardown after the portal is removed."""\n+\n+    def setRoles(self, roles, name=testing.TEST_USER_ID):\n+        """Set the effective roles of a user."""\n+        testing.setRoles(self.portal, name, roles)\n+\n+    def setGroups(self, groups, name=testing.TEST_USER_ID):\n+        \'\'\'Changes the user\'s groups.\'\'\'\n+        uf = self.portal[\'acl_users\']\n+        uf.userSetGroups(name, list(groups))\n+        user = getSecurityManager().getUser()\n+        if name == user.getId():\n+            self.login(user.getUserName())\n+\n+    def setPermissions(self, permissions, role=\'Member\'):\n+        """Changes the permissions assigned to role."""\n+        self.portal.manage_role(role, list(permissions))\n+\n+    def login(self, userName=testing.TEST_USER_NAME):\n+        """Log in to the portal as the given user."""\n+        testing.login(self.portal, userName)\n+\n+    def loginAsPortalOwner(self, userName=testing.SITE_OWNER_NAME):\n+        """Log in to the portal as the user who created it."""\n+        z2.login(self.app[\'acl_users\'], userName)\n+\n+    def logout(self):\n+        """Log out, i.e. become anonymous."""\n+        testing.logout()\n+\n+    def createMemberarea(self, name):\n+        """Create a minimal memberarea."""\n+        _createMemberarea(self.portal, name)\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-09-27T11:53:40+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.testing/commit/aafe82379d18b5dec2e292081865721a7bfc6975

merge aftermath

Files changed:
M CHANGES.rst
M src/plone/app/testing/bbb_at.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 8a05542..a026d00 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -19,6 +19,12 @@ New features:\n - Add support for Python 3.5 and 3.6.\n   [loechel, ale-rt, icemac]\n \n+- Add copy of bbb.PloneTestCase. \n+  For Plone 5.2 the bbb.PloneTestCase will uses Dexterity instead of Archetypes. \n+  Adding bbb_at.PloneTestCase for them to use allows to keep the AT tests working. \n+  See https://github.com/plone/plone.app.testing/pull/51\n+  [pbauer]\n+\n Bug fixes:\n \n - *none yet*\ndiff --git a/src/plone/app/testing/bbb_at.py b/src/plone/app/testing/bbb_at.py\nindex d91e37f..700caa4 100644\n--- a/src/plone/app/testing/bbb_at.py\n+++ b/src/plone/app/testing/bbb_at.py\n@@ -1,5 +1,9 @@\n # -*- coding: utf-8 -*-\n+<<<<<<< HEAD:src/plone/app/testing/bbb_at.py:src/plone/app/testing/bbb_at.py\n """Backwards-compatibility test class for PloneTestCase for Archetypes."""\n+=======\n+"""Backwards-compatibility test class for PloneTestCase for Dexterity."""\n+>>>>>>> master:plone/app/testing/bbb.py:plone/app/testing/bbb.py\n \n from AccessControl import getSecurityManager\n from plone.app import testing\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-09-27T12:48:23+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.testing/commit/a79e162d413ce25da6775498d8fc58f8ca325430

fix conflict trace

Files changed:
M src/plone/app/testing/bbb_at.py

b'diff --git a/src/plone/app/testing/bbb_at.py b/src/plone/app/testing/bbb_at.py\nindex 700caa4..d91e37f 100644\n--- a/src/plone/app/testing/bbb_at.py\n+++ b/src/plone/app/testing/bbb_at.py\n@@ -1,9 +1,5 @@\n # -*- coding: utf-8 -*-\n-<<<<<<< HEAD:src/plone/app/testing/bbb_at.py:src/plone/app/testing/bbb_at.py\n """Backwards-compatibility test class for PloneTestCase for Archetypes."""\n-=======\n-"""Backwards-compatibility test class for PloneTestCase for Dexterity."""\n->>>>>>> master:plone/app/testing/bbb.py:plone/app/testing/bbb.py\n \n from AccessControl import getSecurityManager\n from plone.app import testing\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-09-30T11:56:52-04:00
Author: David Glick (davisagli) <david@glicksoftware.com>
Commit: https://github.com/plone/plone.app.testing/commit/dbc99221c4ab4e64d067aaf662fbcf290b9bebaf

Fix check for port

Files changed:
M src/plone/app/testing/layers.rst

b"diff --git a/src/plone/app/testing/layers.rst b/src/plone/app/testing/layers.rst\nindex cd21cff..47e48d8 100644\n--- a/src/plone/app/testing/layers.rst\n+++ b/src/plone/app/testing/layers.rst\n@@ -304,7 +304,7 @@ indicate where Zope is running.\n \n     >>> port = layers.PLONE_WSGISERVER['port']\n     >>> import os\n-    >>> port == int(os.environ.get('WSGI_SERVER_PORT', 55001))\n+    >>> port == int(os.environ.get('WSGI_SERVER_PORT', os.environ.get('ZSERVER_PORT', 55001)))\n     True\n \n Let's now simulate a test. Test setup does nothing beyond what the base layers\n"

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-10-03T20:01:39-04:00
Author: David Glick (davisagli) <david@glicksoftware.com>
Commit: https://github.com/plone/plone.app.testing/commit/44bd8f08fcee95e6645ebedea839d0ecf690f8fb

Now we just get a free port

Files changed:
M src/plone/app/testing/layers.rst

b"diff --git a/src/plone/app/testing/layers.rst b/src/plone/app/testing/layers.rst\nindex 47e48d8..23c7d9c 100644\n--- a/src/plone/app/testing/layers.rst\n+++ b/src/plone/app/testing/layers.rst\n@@ -304,7 +304,7 @@ indicate where Zope is running.\n \n     >>> port = layers.PLONE_WSGISERVER['port']\n     >>> import os\n-    >>> port == int(os.environ.get('WSGI_SERVER_PORT', os.environ.get('ZSERVER_PORT', 55001)))\n+    >>> port > 0\n     True\n \n Let's now simulate a test. Test setup does nothing beyond what the base layers\n"

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-10-04T16:54:32+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.testing/commit/8b943dfb6ee650cb524f70302f13c3fa5bdf3d24

fix doctest

Files changed:
M src/plone/app/testing/layers_zserver.rst

b"diff --git a/src/plone/app/testing/layers_zserver.rst b/src/plone/app/testing/layers_zserver.rst\nindex 123be72..8bb05a3 100644\n--- a/src/plone/app/testing/layers_zserver.rst\n+++ b/src/plone/app/testing/layers_zserver.rst\n@@ -40,9 +40,10 @@ indicate where Zope is running.\n     >>> host\n     'localhost'\n \n+The port is auto-allocated\n+\n     >>> port = layers.PLONE_FTP_SERVER['port']\n-    >>> import os\n-    >>> port == int(os.environ.get('FTPSERVER_PORT', 55002))\n+    >>> bool(port)\n     True\n \n Let's now simulate a test. Test setup does nothing beyond what the base layers\n"

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-10-05T00:57:09-04:00
Author: David Glick (davisagli) <david@glicksoftware.com>
Commit: https://github.com/plone/plone.app.testing/commit/0760b81009fbb667a76547b804be95fd2e5cd6d5

clean up generated Dexterity schemas in PloneSandboxLayer

Files changed:
M src/plone/app/testing/helpers.py

b'diff --git a/src/plone/app/testing/helpers.py b/src/plone/app/testing/helpers.py\nindex 7a31c40..506a46a 100644\n--- a/src/plone/app/testing/helpers.py\n+++ b/src/plone/app/testing/helpers.py\n@@ -373,6 +373,9 @@ def setUp(self):\n                 # Allow subclass to load ZCML and products\n                 self.setUpZope(portal.getPhysicalRoot(), configurationContext)\n \n+                # Snapshot Dexterity schemas\n+                self.snapshotGeneratedSchemas()\n+\n                 # Allow subclass to configure a persistent fixture\n                 setSite(portal)\n                 self.setUpPloneSite(portal)\n@@ -399,6 +402,9 @@ def tearDown(self):\n \n             setSite(None)\n \n+            # Reset Dexterity schemas\n+            self.tearDownGeneratedSchemas()\n+\n             # Make sure zope.security checkers can be set up and torn down\n             # reliably\n \n@@ -457,6 +463,23 @@ def tearDownMultiPlugins(self):\n         for pluginName in self._addedMultiPlugins:\n             tearDownMultiPluginRegistration(pluginName)\n \n+    def snapshotGeneratedSchemas(self):\n+        """Save a snapshot of the plone.dexterity.schema.generated module"""\n+        from plone.dexterity.schema import generated\n+        self._generatedSchemas = generated.__dict__.copy()\n+        todelete = []\n+        for k in generated.__dict__:\n+            if not k.startswith(\'_\'):\n+                todelete.append(k)\n+        for k in todelete:\n+            del generated.__dict__[k]\n+\n+    def tearDownGeneratedSchemas(self):\n+        """Reset plone.dexterity.schema.generated to its previous state"""\n+        from plone.dexterity.schema import generated\n+        generated.__dict__.clear()\n+        generated.__dict__.update(self._generatedSchemas)\n+\n \n class PloneWithPackageLayer(PloneSandboxLayer):\n \n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-10-06T00:44:18-04:00
Author: David Glick (davisagli) <david@glicksoftware.com>
Commit: https://github.com/plone/plone.app.testing/commit/d49627027255a47feab3d37b5657ee4cd9f697b3

Avoid test setup errors when AT is missing

Files changed:
M src/plone/app/testing/bbb_at.py

b'diff --git a/src/plone/app/testing/bbb_at.py b/src/plone/app/testing/bbb_at.py\nindex d91e37f..6103c60 100644\n--- a/src/plone/app/testing/bbb_at.py\n+++ b/src/plone/app/testing/bbb_at.py\n@@ -10,6 +10,13 @@\n import transaction\n import unittest\n \n+try:\n+    import Products.Archetypes\n+except ImportError:\n+    HAS_AT = False\n+else:\n+    HAS_AT = True\n+\n \n def _createMemberarea(portal, user_id):\n     mtool = portal.portal_membership\n@@ -28,6 +35,9 @@ class PloneTestCaseFixture(testing.PloneSandboxLayer):\n     defaultBases = (testing.PLONE_FIXTURE,)\n \n     def setUpZope(self, app, configurationContext):\n+        if not HAS_AT:\n+            return\n+\n         import Products.ATContentTypes\n         self.loadZCML(package=Products.ATContentTypes)\n \n@@ -37,6 +47,9 @@ def setUpZope(self, app, configurationContext):\n         z2.installProduct(app, \'plone.app.collection\')\n \n     def setUpPloneSite(self, portal):\n+        if not HAS_AT:\n+            return\n+\n         # restore default workflow\n         testing.applyProfile(portal, \'Products.CMFPlone:testfixture\')\n \n@@ -47,11 +60,15 @@ def setUpPloneSite(self, portal):\n         _createMemberarea(portal, testing.TEST_USER_ID)\n \n     def tearDownZope(self, app):\n+        if not HAS_AT:\n+            return\n+\n         z2.uninstallProduct(app, \'plone.app.collection\')\n         z2.uninstallProduct(app, \'plone.app.blob\')\n         z2.uninstallProduct(app, \'Products.ATContentTypes\')\n         z2.uninstallProduct(app, \'Products.Archetypes\')\n \n+\n PTC_FIXTURE = PloneTestCaseFixture()\n PTC_FUNCTIONAL_TESTING = testing.FunctionalTesting(\n     bases=(PTC_FIXTURE,), name=\'PloneTestCase:Functional\')\n@@ -63,6 +80,8 @@ class PloneTestCase(Functional, unittest.TestCase):\n \n     def setUp(self):\n         """Set up before each test."""\n+        if not HAS_AT:\n+            raise unittest.SkipTest(\'PloneTestCase requires Archetypes\')\n         self.beforeSetUp()\n         self.app = self.layer[\'app\']\n         self.portal = self.layer[\'portal\']\n'

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-10-17T11:01:13+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.testing/commit/e526fc0a032c06cd374a11bc4cf7cfb4dc3f7c4f

Merge branch 'master' into py3

Files changed:
M CHANGES.rst
M setup.py

b"diff --git a/CHANGES.rst b/CHANGES.rst\nindex a026d00..bf98a80 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -1,7 +1,7 @@\n Changelog\n =========\n \n-6.0.0 (unreleased)\n+6.0.1 (unreleased)\n ------------------\n \n Breaking changes:\n@@ -10,24 +10,35 @@ Breaking changes:\n \n New features:\n \n+- Add support for Python 3.5 and 3.6.\n+  [loechel, ale-rt, icemac, davisagli, pbauer]\n+\n+Bug fixes:\n+\n+- *add item here*\n+\n+\n+6.0.0 (2018-10-05)\n+------------------\n+\n+New features:\n+\n - Install and load zcml of CMFQuickInstallerTool only when importable.\n   [maurits]\n \n - Load negotiator from plone.i18n (PTS removed).\n   [jensens, ksuess]\n \n-- Add support for Python 3.5 and 3.6.\n-  [loechel, ale-rt, icemac]\n-\n-- Add copy of bbb.PloneTestCase. \n-  For Plone 5.2 the bbb.PloneTestCase will uses Dexterity instead of Archetypes. \n-  Adding bbb_at.PloneTestCase for them to use allows to keep the AT tests working. \n+- Add copy of bbb.PloneTestCase.\n+  For Plone 5.2 the bbb.PloneTestCase will uses Dexterity instead of Archetypes.\n+  Adding bbb_at.PloneTestCase for them to use allows to keep the AT tests working.\n   See https://github.com/plone/plone.app.testing/pull/51\n   [pbauer]\n \n Bug fixes:\n \n-- *none yet*\n+- Amended the doctests to work with automatical layer port picking from plone.testing.\n+  [Rotonen]\n \n \n 5.0.8 (2017-10-25)\ndiff --git a/setup.py b/setup.py\nindex 16b13b5..8d7e3f8 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -4,8 +4,7 @@\n \n import os\n \n-\n-version = '6.0.0.dev0'\n+version = '6.0.1.dev0'\n \n tests_require = [\n     'plone.testing[test]',\n@@ -63,10 +62,9 @@ def read(*rnames):\n     keywords='plone tests',\n     author='Plone Foundation',\n     author_email='plone-developers@lists.sourceforge.net',\n-    url='https://github.com/plone/plone.app.testing',\n+    url='https://pypi.org/project/plone.app.testing',\n     license='GPL version 2',\n-    packages=find_packages('src'),\n-    package_dir={'': 'src'},\n+    packages=find_packages(),\n     namespace_packages=['plone', 'plone.app'],\n     include_package_data=True,\n     zip_safe=False,\n"

Repository: plone.app.testing


Branch: refs/heads/master
Date: 2018-10-17T11:01:39+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.testing/commit/11c2d9f6902d59b52fad6b3d01d5f4d6a468110d

Merge pull request #49 from plone/py3

Port to Python 3

Files changed:
A .editorconfig
A .travis.yml
A docs/README.rst
A docs/conf.py
A docs/index.rst
A docs/isolation.rst
A docs/views.rst
A docs/zope-testbrowser.rst
A src/plone/__init__.py
A src/plone/app/__init__.py
A src/plone/app/testing/__init__.py
A src/plone/app/testing/bbb.py
A src/plone/app/testing/bbb_at.py
A src/plone/app/testing/cleanup.py
A src/plone/app/testing/cleanup.rst
A src/plone/app/testing/helpers.py
A src/plone/app/testing/helpers.rst
A src/plone/app/testing/interfaces.py
A src/plone/app/testing/layers.py
A src/plone/app/testing/layers.rst
A src/plone/app/testing/layers_zserver.rst
A src/plone/app/testing/profile/metadata.xml
A src/plone/app/testing/selenium.rst
A src/plone/app/testing/selenium_layers.py
A src/plone/app/testing/tests.py
A src/plone/app/testing/utils.py
A tox.ini
M .gitignore
M CHANGES.rst
M README.rst
M buildout.cfg
M setup.cfg
M setup.py
D docs/source/README.rst
D docs/source/conf.py
D docs/source/index.rst
D docs/source/isolation.rst
D docs/source/views.rst
D docs/source/zope-testbrowser.rst
D plone/__init__.py
D plone/app/__init__.py
D plone/app/testing/__init__.py
D plone/app/testing/bbb.py
D plone/app/testing/bbb_at.py
D plone/app/testing/cleanup.py
D plone/app/testing/cleanup.rst
D plone/app/testing/helpers.py
D plone/app/testing/helpers.rst
D plone/app/testing/interfaces.py
D plone/app/testing/layers.py
D plone/app/testing/layers.rst
D plone/app/testing/profile/metadata.xml
D plone/app/testing/selenium.rst
D plone/app/testing/selenium_layers.py
D plone/app/testing/tests.py
D plone/app/testing/utils.py

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..626f406\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,36 @@\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.gitignore b/.gitignore\nindex e9a4787..306cacf 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -8,18 +8,21 @@\n /build\n /dist\n /local.cfg\n-/*.egg-info\n+*.egg-info\n /.installed.cfg\n-*.pyc\n+*.py[cod]\n /.Python\n+/pip-selfcheck.json\n /include\n /lib\n-/src\n /.project\n /.pydevproject\n /.mr.developer.cfg\n-/src/plone*\n-/src/collective*\n+/src-mrd/\n+/.tox/\n+/_build/\n+coverage.xml\n+.coverage*\n *.mo\n docs/Makefile\n docs/make.bat\ndiff --git a/.travis.yml b/.travis.yml\nnew file mode 100644\nindex 0000000..54a35b0\n--- /dev/null\n+++ b/.travis.yml\n@@ -0,0 +1,35 @@\n+language: python\n+sudo: false\n+\n+matrix:\n+    include:\n+        - python: "2.7"\n+          env: TOXENV=lint-py27\n+        - python: "3.6"\n+          env: TOXENV=lint-py36\n+        - python: "2.7"\n+          env: TOXENV=py27\n+        - python: "3.5"\n+          env: TOXENV=py35\n+        - python: "3.6"\n+          env: TOXENV=py36\n+        - python: "3.7-dev"\n+          env: TOXENV=py37\n+    allow_failures:\n+        - python: "3.7-dev"\n+          env: TOXENV=py37\n+\n+install:\n+    - travis_retry pip install -U tox coveralls coverage\n+\n+script:\n+    - tox\n+\n+after_success:\n+    - coverage combine\n+    - coveralls\n+\n+notifications:\n+    email: false\n+cache:\n+    pip: true\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex 8fc1d24..bf98a80 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -6,11 +6,12 @@ Changelog\n \n Breaking changes:\n \n-- *add item here*\n+- Require `plone.testing >= 7.0`.\n \n New features:\n \n-- *add item here*\n+- Add support for Python 3.5 and 3.6.\n+  [loechel, ale-rt, icemac, davisagli, pbauer]\n \n Bug fixes:\n \n@@ -28,7 +29,10 @@ New features:\n - Load negotiator from plone.i18n (PTS removed).\n   [jensens, ksuess]\n \n-- Add copy of bbb.PloneTestCase. For Plone 5.2 the bbb.PloneTestCase will uses Dexterity instead of Archetypes. Adding bbb_at.PloneTestCase for them to use allows to keep the AT tests working. See https://github.com/plone/plone.app.testing/pull/51\n+- Add copy of bbb.PloneTestCase.\n+  For Plone 5.2 the bbb.PloneTestCase will uses Dexterity instead of Archetypes.\n+  Adding bbb_at.PloneTestCase for them to use allows to keep the AT tests working.\n+  See https://github.com/plone/plone.app.testing/pull/51\n   [pbauer]\n \n Bug fixes:\ndiff --git a/README.rst b/README.rst\nindex dd7a278..cffceba 120000\n--- a/README.rst\n+++ b/README.rst\n@@ -1 +1 @@\n-docs/source/README.rst\n\\ No newline at end of file\n+docs/README.rst\n\\ No newline at end of file\ndiff --git a/buildout.cfg b/buildout.cfg\nindex e61bc5b..ff4400a 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -1,32 +1,39 @@\n [buildout]\n extends = https://raw.githubusercontent.com/collective/buildout.plonetest/master/test-5.x.cfg\n-parts = coverage test test-chrome test-ie report report-xml\n+          https://raw.githubusercontent.com/plone/buildout.coredev/5.2/versions.cfg\n+          https://raw.githubusercontent.com/plone/buildout.coredev/5.2/sources.cfg\n+          https://raw.githubusercontent.com/plone/buildout.coredev/5.2/checkouts.cfg\n+\n+parts =\n+    coverage\n+    test\n+    test-chrome\n+    test-ie\n+    report\n+    report-xml\n+\n extensions = mr.developer\n+\n sources = sources\n-auto-checkout =\n-    plone.testing\n-    Products.GenericSetup\n+versions = versions\n+\n+auto-checkout = *\n+\n+sources-dir = src-mrd\n \n-[remotes]\n-plone = git://github.com/plone\n-plone_push = git@github.com:plone\n-zope = svn://svn.zope.org/repos/main/\n+develop = .\n \n [versions]\n plone.app.testing =\n-Products.GenericSetup =\n \n [sources]\n-plone.testing         = git ${remotes:plone}/plone.testing.git pushurl=${remotes:plone_push}/plone.testing.git branch=master\n-Products.GenericSetup = svn ${remotes:zope}/Products.GenericSetup/trunk\n+plone.testing                 = git ${remotes:plone}/plone.testing.git pushurl=${remotes:plone_push}/plone.testing.git branch=py3_disallow_commits\n \n [test]\n-recipe = collective.xmltestreport\n+recipe = zc.recipe.testrunner\n eggs =\n-    Pillow\n-    plone.testing [test]\n-    plone.app.testing [test]\n-defaults = [\'--auto-color\', \'--auto-progress\']\n+    plone.app.testing[test]\n+defaults = [\'--auto-color\']\n selenium-driver =\n environment = testenv\n \ndiff --git a/docs/source/README.rst b/docs/README.rst\nsimilarity index 100%\nrename from docs/source/README.rst\nrename to docs/README.rst\ndiff --git a/docs/source/conf.py b/docs/conf.py\nsimilarity index 99%\nrename from docs/source/conf.py\nrename to docs/conf.py\nindex ff35066..ba460d1 100644\n--- a/docs/source/conf.py\n+++ b/docs/conf.py\n@@ -41,7 +41,7 @@\n \n # General information about the project.\n project = u\'plone.app.testing\'\n-copyright = u\'2015, Plone Foundation\'\n+copyright = u\'2018, Plone Foundation\'\n \n # The version info for the project you\'re documenting, acts as replacement for\n # |version| and |release|, also used in various other places throughout the\ndiff --git a/docs/source/index.rst b/docs/index.rst\nsimilarity index 100%\nrename from docs/source/index.rst\nrename to docs/index.rst\ndiff --git a/docs/source/isolation.rst b/docs/isolation.rst\nsimilarity index 100%\nrename from docs/source/isolation.rst\nrename to docs/isolation.rst\ndiff --git a/docs/source/views.rst b/docs/views.rst\nsimilarity index 100%\nrename from docs/source/views.rst\nrename to docs/views.rst\ndiff --git a/docs/source/zope-testbrowser.rst b/docs/zope-testbrowser.rst\nsimilarity index 100%\nrename from docs/source/zope-testbrowser.rst\nrename to docs/zope-testbrowser.rst\ndiff --git a/setup.cfg b/setup.cfg\nindex ce96d1d..2bce1d9 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,11 +1,60 @@\n+[build_sphinx]\n+source-dir = docs/source\n+build-dir  = _build/docs\n+all_files  = 1\n+\n+[upload_sphinx]\n+upload-dir = _build/docs/html\n+\n [check-manifest]\n ignore =\n-    *.cfg\n     bootstrap.py\n+    buildout.cfg\n+    tox.ini\n+\n+[coverage:run]\n+branch = True\n+\n+source =\n+    src\n+\n+omit =\n+\n+[coverage:report]\n+precision = 2\n+\n+[coverage:html]\n+directory = _build/reports/coverage\n+\n+\n+[isort]\n+# for details see\n+# http://docs.plone.org/develop/styleguide/python.html#grouping-and-sorting\n+force_alphabetical_sort = True\n+force_single_line = True\n+lines_after_imports = 2\n+line_length = 200\n+not_skip = __init__.py\n+\n+[flake8]\n+exclude =\n+    bootstrap.py,\n+\n+include =\n+    src\n+\n+ignore =\n+    N801,\n+    N802,\n+    N803,\n+    N805,\n+    N806,\n+    N812,\n+    T000,\n+    T003,\n \n [zest.releaser]\n create-wheel = yes\n \n-# When Python 2-3 compatible:\n-# [bdist_wheel]\n-# universal = 1\n+[bdist_wheel]\n+universal = 1\ndiff --git a/setup.py b/setup.py\nindex 98d6b95..8d7e3f8 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,49 +1,62 @@\n-from setuptools import setup, find_packages\n+# -*- coding: utf-8 -*-\n+from setuptools import find_packages\n+from setuptools import setup\n+\n import os\n \n version = \'6.0.1.dev0\'\n \n-tests_require = [\'Products.CMFCore\',\n-                 \'Products.CMFPlone\',\n-                 \'Products.PluggableAuthService\',\n-                 \'Products.ATContentTypes\',  # XXX unspecified dependency of plone.app.upgrade XXX\n-                 \'Products.CMFPlacefulWorkflow\',\n-                 \'selenium\',\n-                 \'transaction\',\n-                 \'zope.interface\',\n-                 \'zope.publisher\',\n-                 \'zope.testrunner\',\n-                 ]\n+tests_require = [\n+    \'plone.testing[test]\',\n+    \'Products.CMFCore\',\n+    \'Products.CMFPlacefulWorkflow\',\n+    \'Products.CMFPlone\',\n+    \'Products.PluggableAuthService\',\n+    \'selenium\',\n+    \'transaction\',\n+    \'zope.interface\',\n+    \'zope.publisher\',\n+    \'zope.testing\',\n+    \'zope.testrunner\',\n+    # XXX unspecified dependency of plone.app.upgrade XXX\n+    # \'Products.ATContentTypes\',\n+]\n+\n+robot_require = [\n+    \'robotsuite>=1.4.0\',\n+    \'robotframework-selenium2library\',\n+    \'decorator\',\n+    \'selenium\',\n+]\n \n-robot_require = [\'robotsuite>=1.4.0\',\n-                 \'robotframework-selenium2library\',\n-                 \'decorator\',\n-                 \'selenium\']\n \n def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n+\n long_description = \\\n-    read(\'docs\', \'source\',\'README.rst\') + \\\n+    read(\'docs\', \'README.rst\') + \\\n     \'\\n\\n\' +\\\n     read(\'CHANGES.rst\')\n \n+\n setup(\n     name=\'plone.app.testing\',\n     version=version,\n-    description="Testing tools for Plone-the-application, based on plone.testing.",\n+    description="Testing tools for Plone-the-application, based on plone.testing.",  # NOQA: E501\n     long_description=long_description,\n     classifiers=[\n         "Environment :: Web Environment",\n         "Framework :: Plone",\n-        "Framework :: Plone :: 5.0",\n-        "Framework :: Plone :: 5.1",\n         "Framework :: Plone :: 5.2",\n-        "Framework :: Zope2",\n+        "Framework :: Zope :: 4",\n         "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n         "Operating System :: OS Independent",\n         "Programming Language :: Python",\n         "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.5",\n+        "Programming Language :: Python :: 3.6",\n+        # "Programming Language :: Python :: 3.7",\n         "Topic :: Internet :: WWW/HTTP :: Dynamic Content",\n     ],\n     keywords=\'plone tests\',\n@@ -57,6 +70,7 @@ def read(*rnames):\n     zip_safe=False,\n     install_requires=[\n         \'setuptools\',\n+        \'six\',\n         \'zope.configuration\',\n         \'zope.component\',\n         \'zope.dottedname\',\n@@ -68,7 +82,7 @@ def read(*rnames):\n         # \'AccessControl\', # Zope 2.13+\n         \'Products.CMFPlone\',\n         \'Products.GenericSetup\',\n-        \'Zope2\',\n+        \'Zope\',\n     ],\n     tests_require=tests_require,\n     extras_require={\ndiff --git a/plone/__init__.py b/src/plone/__init__.py\nsimilarity index 100%\nrename from plone/__init__.py\nrename to src/plone/__init__.py\ndiff --git a/plone/app/__init__.py b/src/plone/app/__init__.py\nsimilarity index 100%\nrename from plone/app/__init__.py\nrename to src/plone/app/__init__.py\ndiff --git a/plone/app/testing/__init__.py b/src/plone/app/testing/__init__.py\nsimilarity index 98%\nrename from plone/app/testing/__init__.py\nrename to src/plone/app/testing/__init__.py\nindex 05bb224..44bafc4 100644\n--- a/plone/app/testing/__init__.py\n+++ b/src/plone/app/testing/__init__.py\n@@ -1,5 +1,5 @@\n # -*- coding: utf-8 -*-\n-# flake8: noqa\n+# flake8: NOQA: F401\n from plone.app.testing.cleanup import cleanUpMultiPlugins\n from plone.app.testing.helpers import applyProfile\n from plone.app.testing.helpers import login\ndiff --git a/plone/app/testing/bbb.py b/src/plone/app/testing/bbb.py\nsimilarity index 82%\nrename from plone/app/testing/bbb.py\nrename to src/plone/app/testing/bbb.py\nindex 17fc721..3103192 100644\n--- a/plone/app/testing/bbb.py\n+++ b/src/plone/app/testing/bbb.py\n@@ -3,7 +3,7 @@\n \n from AccessControl import getSecurityManager\n from plone.app import testing\n-from plone.testing import z2\n+from plone.testing import zope\n from Products.CMFPlone.utils import _createObjectByType\n from Testing.ZopeTestCase.functional import Functional\n \n@@ -28,29 +28,19 @@ class PloneTestCaseFixture(testing.PloneSandboxLayer):\n     defaultBases = (testing.PLONE_FIXTURE,)\n \n     def setUpZope(self, app, configurationContext):\n-        import Products.ATContentTypes\n-        self.loadZCML(package=Products.ATContentTypes)\n-\n-        z2.installProduct(app, \'Products.Archetypes\')\n-        z2.installProduct(app, \'Products.ATContentTypes\')\n-        z2.installProduct(app, \'plone.app.blob\')\n-        z2.installProduct(app, \'plone.app.collection\')\n+        import plone.app.contenttypes\n+        self.loadZCML(package=plone.app.contenttypes)\n \n     def setUpPloneSite(self, portal):\n         # restore default workflow\n         testing.applyProfile(portal, \'Products.CMFPlone:testfixture\')\n \n         # add default content\n-        testing.applyProfile(portal, \'Products.ATContentTypes:content\')\n+        testing.applyProfile(portal, \'plone.app.contenttypes:plone-content\')\n \n         # add home folder for default test user\n         _createMemberarea(portal, testing.TEST_USER_ID)\n \n-    def tearDownZope(self, app):\n-        z2.uninstallProduct(app, \'plone.app.collection\')\n-        z2.uninstallProduct(app, \'plone.app.blob\')\n-        z2.uninstallProduct(app, \'Products.ATContentTypes\')\n-        z2.uninstallProduct(app, \'Products.Archetypes\')\n \n PTC_FIXTURE = PloneTestCaseFixture()\n PTC_FUNCTIONAL_TESTING = testing.FunctionalTesting(\n@@ -113,7 +103,7 @@ def login(self, userName=testing.TEST_USER_NAME):\n \n     def loginAsPortalOwner(self, userName=testing.SITE_OWNER_NAME):\n         """Log in to the portal as the user who created it."""\n-        z2.login(self.app[\'acl_users\'], userName)\n+        zope.login(self.app[\'acl_users\'], userName)\n \n     def logout(self):\n         """Log out, i.e. become anonymous."""\ndiff --git a/plone/app/testing/bbb_at.py b/src/plone/app/testing/bbb_at.py\nsimilarity index 92%\nrename from plone/app/testing/bbb_at.py\nrename to src/plone/app/testing/bbb_at.py\nindex d91e37f..6103c60 100644\n--- a/plone/app/testing/bbb_at.py\n+++ b/src/plone/app/testing/bbb_at.py\n@@ -10,6 +10,13 @@\n import transaction\n import unittest\n \n+try:\n+    import Products.Archetypes\n+except ImportError:\n+    HAS_AT = False\n+else:\n+    HAS_AT = True\n+\n \n def _createMemberarea(portal, user_id):\n     mtool = portal.portal_membership\n@@ -28,6 +35,9 @@ class PloneTestCaseFixture(testing.PloneSandboxLayer):\n     defaultBases = (testing.PLONE_FIXTURE,)\n \n     def setUpZope(self, app, configurationContext):\n+        if not HAS_AT:\n+            return\n+\n         import Products.ATContentTypes\n         self.loadZCML(package=Products.ATContentTypes)\n \n@@ -37,6 +47,9 @@ def setUpZope(self, app, configurationContext):\n         z2.installProduct(app, \'plone.app.collection\')\n \n     def setUpPloneSite(self, portal):\n+        if not HAS_AT:\n+            return\n+\n         # restore default workflow\n         testing.applyProfile(portal, \'Products.CMFPlone:testfixture\')\n \n@@ -47,11 +60,15 @@ def setUpPloneSite(self, portal):\n         _createMemberarea(portal, testing.TEST_USER_ID)\n \n     def tearDownZope(self, app):\n+        if not HAS_AT:\n+            return\n+\n         z2.uninstallProduct(app, \'plone.app.collection\')\n         z2.uninstallProduct(app, \'plone.app.blob\')\n         z2.uninstallProduct(app, \'Products.ATContentTypes\')\n         z2.uninstallProduct(app, \'Products.Archetypes\')\n \n+\n PTC_FIXTURE = PloneTestCaseFixture()\n PTC_FUNCTIONAL_TESTING = testing.FunctionalTesting(\n     bases=(PTC_FIXTURE,), name=\'PloneTestCase:Functional\')\n@@ -63,6 +80,8 @@ class PloneTestCase(Functional, unittest.TestCase):\n \n     def setUp(self):\n         """Set up before each test."""\n+        if not HAS_AT:\n+            raise unittest.SkipTest(\'PloneTestCase requires Archetypes\')\n         self.beforeSetUp()\n         self.app = self.layer[\'app\']\n         self.portal = self.layer[\'portal\']\ndiff --git a/plone/app/testing/cleanup.py b/src/plone/app/testing/cleanup.py\nsimilarity index 90%\nrename from plone/app/testing/cleanup.py\nrename to src/plone/app/testing/cleanup.py\nindex 0dadf3d..b6eaeca 100644\n--- a/plone/app/testing/cleanup.py\n+++ b/src/plone/app/testing/cleanup.py\n@@ -13,14 +13,14 @@\n \n # Make sure cleanup handlers from PAS are registered\n try:\n-    import Products.PluggableAuthService.zcml  # noqa\n+    import Products.PluggableAuthService.zcml  # NOQA: F401\n except ImportError:\n     pass\n \n \n def cleanUpMultiPlugins():\n     try:\n-        from Products.PluggableAuthService.PluggableAuthService import MultiPlugins  # noqa\n+        from Products.PluggableAuthService.PluggableAuthService import MultiPlugins  # NOQA: E501\n     except ImportError:\n         pass\n     else:\n@@ -36,5 +36,6 @@ def cleanUpMultiPlugins():\n         for plugin in zap:\n             MultiPlugins.remove(plugin)\n \n+\n addCleanUp(cleanUpMultiPlugins)\n del addCleanUp\ndiff --git a/plone/app/testing/cleanup.rst b/src/plone/app/testing/cleanup.rst\nsimilarity index 97%\nrename from plone/app/testing/cleanup.rst\nrename to src/plone/app/testing/cleanup.rst\nindex a391753..141df6f 100644\n--- a/plone/app/testing/cleanup.rst\n+++ b/src/plone/app/testing/cleanup.rst\n@@ -11,8 +11,7 @@ and Plone packages.\n PluggableAuthService MultiPlugins list\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-The ``PluggableAuthService`` package maintains a global list of so-called\n-multi-plugins.\n+The ``PluggableAuthService`` package maintains a global list of so-called multi-plugins.\n \n     >>> from Products.PluggableAuthService import PluggableAuthService\n     >>> PluggableAuthService.MultiPlugins\ndiff --git a/plone/app/testing/helpers.py b/src/plone/app/testing/helpers.py\nsimilarity index 90%\nrename from plone/app/testing/helpers.py\nrename to src/plone/app/testing/helpers.py\nindex 1a60080..506a46a 100644\n--- a/plone/app/testing/helpers.py\n+++ b/src/plone/app/testing/helpers.py\n@@ -8,9 +8,9 @@\n from plone.app.testing.interfaces import TEST_USER_NAME\n from plone.testing import Layer\n from plone.testing import security\n-from plone.testing import z2\n from plone.testing import zca\n from plone.testing import zodb\n+from plone.testing import zope\n from zope.component import getGlobalSiteManager\n from zope.component.hooks import getSite\n from zope.component.hooks import setHooks\n@@ -27,14 +27,14 @@ def login(portal, userName):\n     """Log in as the given user in the given Plone site\n     """\n \n-    z2.login(portal[\'acl_users\'], userName)\n+    zope.login(portal[\'acl_users\'], userName)\n \n \n def logout():\n     """Log out, i.e. become anonymous\n     """\n \n-    z2.logout()\n+    zope.logout()\n \n \n def setRoles(portal, userId, roles):\n@@ -42,7 +42,7 @@ def setRoles(portal, userId, roles):\n     """\n \n     userFolder = portal[\'acl_users\']\n-    z2.setRoles(userFolder, userId, roles)\n+    zope.setRoles(userFolder, userId, roles)\n \n \n def tearDownMultiPluginRegistration(pluginName):\n@@ -81,7 +81,7 @@ def quickInstallProduct(portal, productName, reinstall=False):\n     sm = getSecurityManager()\n     app = aq_parent(portal)\n \n-    z2.login(app[\'acl_users\'], SITE_OWNER_NAME)\n+    zope.login(app[\'acl_users\'], SITE_OWNER_NAME)\n \n     try:\n         from Products.CMFPlone.utils import get_installer\n@@ -127,7 +127,7 @@ def applyProfile(portal, profileName, purge_old=None,\n     sm = getSecurityManager()\n     app = aq_parent(portal)\n \n-    z2.login(app[\'acl_users\'], SITE_OWNER_NAME)\n+    zope.login(app[\'acl_users\'], SITE_OWNER_NAME)\n \n     try:\n         setupTool = portal[\'portal_setup\']\n@@ -234,13 +234,13 @@ def persist_profile_upgrade_versions(portal):\n \n \n @contextlib.contextmanager\n-def ploneSite(db=None, connection=None, environ=None):\n+def ploneSite(db=None, connection=None, environ=None, flavour=zope):\n     """Context manager for working with the Plone portal during layer setup::\n \n         with ploneSite() as portal:\n             ...\n \n-    This is based on the ``z2.zopeApp()`` context manager. See the module\n+    This is based on the ``zope.zopeApp()`` context manager. See the module\n      ``plone.testing.z2`` for details.\n \n     Do not use this in a test. Use the \'portal\' resource from the PloneFixture\n@@ -249,11 +249,14 @@ def ploneSite(db=None, connection=None, environ=None):\n     Pass a ZODB handle as ``db`` to use a specificdatabase. Alternatively,\n     pass an open connection as ``connection`` (the connection will not be\n     closed).\n+\n+    flavour ... either `plone.testing.z2` resp. `plone.testing.zope` for WSGI\n+                or `plone.testing.zserver` for ZServer\n     """\n     setHooks()\n     site = getSite()\n \n-    with z2.zopeApp(db, connection, environ) as app:\n+    with getattr(flavour, \'zopeApp\')(db, connection, environ) as app:\n         portal = app[PLONE_SITE_ID]\n \n         setSite(portal)\n@@ -293,7 +296,7 @@ def setUpZope(self, app, configurationContext):\n         ``configurationContext`` is the ZCML configuration context.\n \n         This is the most appropriate place to load ZCML or install Zope 2-\n-        style products, using the ``plone.testing.z2.installProduct`` helper.\n+        style products, using the ``plone.testing.zope.installProduct`` helper.\n         """\n         pass\n \n@@ -303,7 +306,7 @@ def tearDownZope(self, app):\n         ``app`` is the Zope application root.\n \n         This is the most appropriate place to uninstall Zope 2-style products\n-        using the ``plone.testing.z2.uninstallProduct`` helper.\n+        using the ``plone.testing.zope.uninstallProduct`` helper.\n         """\n         pass\n \n@@ -370,6 +373,9 @@ def setUp(self):\n                 # Allow subclass to load ZCML and products\n                 self.setUpZope(portal.getPhysicalRoot(), configurationContext)\n \n+                # Snapshot Dexterity schemas\n+                self.snapshotGeneratedSchemas()\n+\n                 # Allow subclass to configure a persistent fixture\n                 setSite(portal)\n                 self.setUpPloneSite(portal)\n@@ -385,7 +391,7 @@ def setUp(self):\n \n     def tearDown(self):\n \n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n \n             portal = app[PLONE_SITE_ID]\n             setHooks()\n@@ -396,6 +402,9 @@ def tearDown(self):\n \n             setSite(None)\n \n+            # Reset Dexterity schemas\n+            self.tearDownGeneratedSchemas()\n+\n             # Make sure zope.security checkers can be set up and torn down\n             # reliably\n \n@@ -454,6 +463,23 @@ def tearDownMultiPlugins(self):\n         for pluginName in self._addedMultiPlugins:\n             tearDownMultiPluginRegistration(pluginName)\n \n+    def snapshotGeneratedSchemas(self):\n+        """Save a snapshot of the plone.dexterity.schema.generated module"""\n+        from plone.dexterity.schema import generated\n+        self._generatedSchemas = generated.__dict__.copy()\n+        todelete = []\n+        for k in generated.__dict__:\n+            if not k.startswith(\'_\'):\n+                todelete.append(k)\n+        for k in todelete:\n+            del generated.__dict__[k]\n+\n+    def tearDownGeneratedSchemas(self):\n+        """Reset plone.dexterity.schema.generated to its previous state"""\n+        from plone.dexterity.schema import generated\n+        generated.__dict__.clear()\n+        generated.__dict__.update(self._generatedSchemas)\n+\n \n class PloneWithPackageLayer(PloneSandboxLayer):\n \n@@ -473,7 +499,7 @@ def setUpZope(self, app, configurationContext):\n         """\n         self.setUpZCMLFiles()\n         for z2Product in self.additional_z2_products:\n-            z2.installProduct(app, z2Product)\n+            zope.installProduct(app, z2Product)\n \n     def setUpZCMLFiles(self):\n         """Load default ZCML.\ndiff --git a/plone/app/testing/helpers.rst b/src/plone/app/testing/helpers.rst\nsimilarity index 94%\nrename from plone/app/testing/helpers.rst\nrename to src/plone/app/testing/helpers.rst\nindex a67bd2f..b4742ec 100644\n--- a/plone/app/testing/helpers.rst\n+++ b/src/plone/app/testing/helpers.rst\n@@ -61,7 +61,7 @@ need to tear that down as well.\n     ...         return qi.is_product_installed(product_name)\n \n     >>> from plone.testing import Layer\n-    >>> from plone.testing import zca, z2, zodb\n+    >>> from plone.testing import zca, zope, zodb\n \n     >>> from plone.app.testing import PLONE_FIXTURE\n     >>> from plone.app.testing import IntegrationTesting\n@@ -138,9 +138,9 @@ Let\'s now simulate layer setup:\n     >>> setupLayers = {}\n     >>> runner.setup_layer(options, HELPER_DEMOS_INTEGRATION_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-      Set up plone.testing.z2.Startup in ... seconds.\n+      Set up plone.testing.zope.Startup in ... seconds.\n       Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-      Set up HelperDemos in ... seconds.\n+      Set up...HelperDemos in ... seconds.\n       Set up plone.app.testing.layers.HelperDemos:Integration in ... seconds.\n \n We should see the newly registered components and the persistent changes\n@@ -152,7 +152,7 @@ having taken effect.\n     <object object at ...>\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n+    ...     print(portal.title)\n     New title\n \n We should also see our product installation in the quickinstaller tool\n@@ -160,7 +160,7 @@ and the results of the profile having been applied.\n \n     >>> from Products.GenericSetup.tool import UNKNOWN\n     >>> with helpers.ploneSite() as portal:\n-    ...     print is_installed(portal, \'plone.app.testing\')\n+    ...     print(is_installed(portal, \'plone.app.testing\'))\n     ...     portal.portal_setup.getLastVersionForProfile(\'plone.app.testing:default\') == UNKNOWN\n     True\n     False\n@@ -168,7 +168,7 @@ and the results of the profile having been applied.\n Let\'s now simulate a test.\n \n     >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n+    >>> zope.STARTUP.testSetUp()\n     >>> PLONE_FIXTURE.testSetUp()\n     >>> HELPER_DEMOS_FIXTURE.testSetUp()\n     >>> HELPER_DEMOS_INTEGRATION_TESTING.testSetUp()\n@@ -183,8 +183,8 @@ the ``ploneSite()`` context manager as shown above.\n \n     >>> portal = HELPER_DEMOS_INTEGRATION_TESTING[\'portal\'] # would normally be self.layer[\'portal\']\n \n-    >>> getSecurityManager().getUser().getRolesInContext(portal)\n-    [\'Member\', \'Authenticated\']\n+    >>> sorted(getSecurityManager().getUser().getRolesInContext(portal))\n+    [\'Authenticated\', \'Member\']\n \n     >>> getSecurityManager().getUser().getUserName() == TEST_USER_NAME\n     True\n@@ -194,8 +194,8 @@ the ``ploneSite()`` context manager as shown above.\n     >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n     >>> repr(getSecurityManager()) != sm_repr\n     True\n-    >>> getSecurityManager().getUser().getRolesInContext(portal)\n-    [\'Manager\', \'Authenticated\']\n+    >>> sorted(getSecurityManager().getUser().getRolesInContext(portal))\n+    [\'Authenticated\', \'Manager\']\n \n     >>> helpers.logout()\n     >>> getSecurityManager().getUser()\n@@ -214,7 +214,7 @@ Let\'s now tear down the test.\n     >>> HELPER_DEMOS_INTEGRATION_TESTING.testTearDown()\n     >>> HELPER_DEMOS_FIXTURE.testTearDown()\n     >>> PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n     >>> zca.LAYER_CLEANUP.testTearDown()\n \n Our persistent changes from the layer should remain, but those made in a test\n@@ -224,8 +224,8 @@ should not.\n     <object object at ...>\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n-    ...     print is_installed(portal, \'plone.app.testing\')\n+    ...     print(portal.title)\n+    ...     print(is_installed(portal, \'plone.app.testing\'))\n     ...     \'folder1\' in portal.objectIds()\n     ...     portal.portal_setup.getLastVersionForProfile(\'plone.app.testing:default\') == UNKNOWN\n     New title\n@@ -239,14 +239,14 @@ component architecture changes from our layer.\n \n     >>> runner.tear_down_unneeded(options, [l for l in setupLayers if l not in (HELPER_DEMOS_INTEGRATION_TESTING, HELPER_DEMOS_FIXTURE,)], setupLayers)\n     Tear down plone.app.testing.layers.HelperDemos:Integration in ... seconds.\n-    Tear down HelperDemos in ... seconds.\n+    Tear down...HelperDemos in ... seconds.\n \n     >>> queryUtility(Interface, name="dummy1") is None\n     True\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n-    ...     print is_installed(portal, \'plone.app.testing\')\n+    ...     print(portal.title)\n+    ...     print(is_installed(portal, \'plone.app.testing\'))\n     ...     portal.portal_setup.getLastVersionForProfile(\'plone.app.testing:default\') == UNKNOWN\n     Plone site\n     False\n@@ -256,7 +256,7 @@ Let\'s tear down the rest of the layers too.\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n     Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n Plone sandbox layer helper\n@@ -299,7 +299,7 @@ layer base class which helps implement this pattern.\n     ...         PluggableAuthService.registerMultiPlugin("dummy_plugin1")\n     ...\n     ...         # Finally, this is a good place to load Zope products,\n-    ...         # using the plone.testing.z2.installProduct() helper.\n+    ...         # using the plone.testing.zope.installProduct() helper.\n     ...         # Make some other global changes not stored in the ZODB or\n     ...         # the global component registry\n     ...         someGlobal[\'test\'] = 1\n@@ -351,9 +351,9 @@ Let\'s now simulate layer setup:\n     >>> setupLayers = {}\n     >>> runner.setup_layer(options, MY_INTEGRATION_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n     Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up MyLayer in ... seconds.\n+    Set up...MyLayer in ... seconds.\n     Set up plone.app.testing.layers.MyLayer:Integration in ... seconds.\n \n Again, our state should now be available.\n@@ -362,7 +362,7 @@ Again, our state should now be available.\n     <object object at ...>\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n+    ...     print(portal.title)\n     New title\n \n     >>> someGlobal[\'test\']\n@@ -404,7 +404,7 @@ layer.\n     True\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal.title\n+    ...     print(portal.title)\n     Plone site\n \n     >>> \'test\' in someGlobal\n@@ -438,7 +438,7 @@ Let\'s tear down the rest of the layers too.\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n     Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n Other helpers\ndiff --git a/plone/app/testing/interfaces.py b/src/plone/app/testing/interfaces.py\nsimilarity index 100%\nrename from plone/app/testing/interfaces.py\nrename to src/plone/app/testing/interfaces.py\ndiff --git a/plone/app/testing/layers.py b/src/plone/app/testing/layers.py\nsimilarity index 71%\nrename from plone/app/testing/layers.py\nrename to src/plone/app/testing/layers.py\nindex fee631d..8167f5c 100644\n--- a/plone/app/testing/layers.py\n+++ b/src/plone/app/testing/layers.py\n@@ -14,9 +14,10 @@\n from plone.app.testing.interfaces import TEST_USER_ROLES\n from plone.app.testing.utils import MockMailHost\n from plone.testing import Layer\n-from plone.testing import z2\n from plone.testing import zca\n from plone.testing import zodb\n+from plone.testing import zope\n+from plone.testing import zserver\n from Products.MailHost.interfaces import IMailHost\n from zope.component import getSiteManager\n from zope.component.hooks import setSite\n@@ -34,62 +35,50 @@ class PloneFixture(Layer):\n       role, ``Member``.\n     """\n \n-    defaultBases = (z2.STARTUP,)\n+    defaultBases = (zope.STARTUP,)\n \n     # Products that will be installed, plus options\n     products = (\n-        (\'Products.GenericSetup\',                {\'loadZCML\': True}, ),\n-        (\'Products.DCWorkflow\',                  {\'loadZCML\': True}, ),\n-        (\'Products.ZCTextIndex\',                 {\'loadZCML\': True}, ),\n-        (\'Products.DateRecurringIndex\',          {\'loadZCML\': False},),\n-        (\'Products.PageTemplates\',               {\'loadZCML\': True},),\n-\n-        (\'Products.CMFUid\',                      {\'loadZCML\': True}, ),\n-        (\'Products.CMFCore\',                     {\'loadZCML\': True}, ),\n-\n-        (\'Products.PluggableAuthService\',        {\'loadZCML\': True}, ),\n-        (\'Products.PluginRegistry\',              {\'loadZCML\': True}, ),\n-        (\'Products.PlonePAS\',                    {\'loadZCML\': True}, ),\n-\n-        (\'Products.CMFFormController\',           {\'loadZCML\': True}, ),\n-        (\'Products.CMFDynamicViewFTI\',           {\'loadZCML\': True}, ),\n-        (\'Products.CMFPlacefulWorkflow\',         {\'loadZCML\': True}, ),\n-\n-        (\'Products.MimetypesRegistry\',           {\'loadZCML\': True}, ),\n-        (\'Products.PortalTransforms\',            {\'loadZCML\': True}, ),\n-\n-        (\'Products.ExternalEditor\',              {\'loadZCML\': True}, ),\n-        (\'Products.ExtendedPathIndex\',           {\'loadZCML\': True}, ),\n-        (\'Products.ResourceRegistries\',          {\'loadZCML\': True}, ),\n-        (\'Products.SiteAccess\',                  {\'loadZCML\': False}, ),\n-\n-        (\'Products.CMFEditions\',                 {\'loadZCML\': True}, ),\n-        (\'Products.CMFDiffTool\',                 {\'loadZCML\': True}, ),\n-\n-        (\'plone.i18n\',                           {\'loadZCML\': True,\n-                                                  \'install\': False}, ),\n-\n-        (\'plonetheme.barceloneta\',               {\'loadZCML\': True,\n-                                                  \'install\': False}, ),\n-\n-        (\'plone.app.folder\',                     {\'loadZCML\': True}, ),\n-        (\'Products.CMFPlone\',                    {\'loadZCML\': True}, ),\n-        (\'Products.PythonScripts\',               {\'loadZCML\': False}, ),\n-\n+        (\'Products.GenericSetup\', {\'loadZCML\': True}, ),\n+        (\'Products.DCWorkflow\', {\'loadZCML\': True}, ),\n+        (\'Products.ZCTextIndex\', {\'loadZCML\': True}, ),\n+        (\'Products.DateRecurringIndex\', {\'loadZCML\': False}, ),\n+        (\'Products.PageTemplates\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFUid\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFCore\', {\'loadZCML\': True}, ),\n+        (\'Products.PluggableAuthService\', {\'loadZCML\': True}, ),\n+        (\'Products.PluginRegistry\', {\'loadZCML\': True}, ),\n+        (\'Products.PlonePAS\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFFormController\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFDynamicViewFTI\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFPlacefulWorkflow\', {\'loadZCML\': True}, ),\n+        (\'Products.MimetypesRegistry\', {\'loadZCML\': True}, ),\n+        (\'Products.PortalTransforms\', {\'loadZCML\': True}, ),\n+        (\'Products.ExternalEditor\', {\'loadZCML\': True}, ),\n+        (\'Products.ExtendedPathIndex\', {\'loadZCML\': True}, ),\n+        (\'Products.ResourceRegistries\', {\'loadZCML\': True}, ),\n+        (\'Products.SiteAccess\', {\'loadZCML\': False}, ),\n+        (\'Products.CMFEditions\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFDiffTool\', {\'loadZCML\': True}, ),\n+        (\'plone.i18n\', {\'loadZCML\': True, \'install\': False}, ),\n+        (\'plonetheme.barceloneta\', {\'loadZCML\': True, \'install\': False}, ),\n+        (\'plone.app.folder\', {\'loadZCML\': True}, ),\n+        (\'Products.CMFPlone\', {\'loadZCML\': True}, ),\n+        (\'Products.PythonScripts\', {\'loadZCML\': False}, ),\n     )\n \n-    try:\n-        import Products.PasswordResetTool  # noqa\n-        products = products + (\n-            (\'Products.PasswordResetTool\', {\'loadZCML\': True}, ),)\n-    except ImportError:\n-        pass\n-    try:\n-        import Products.CMFQuickInstallerTool  # noqa\n-        products = products + (\n-            (\'Products.CMFQuickInstallerTool\', {\'loadZCML\': True}, ),)\n-    except ImportError:\n-        pass\n+    # try:\n+    #    import Products.PasswordResetTool\n+    #    products = products + (\n+    #        (\'Products.PasswordResetTool\', {\'loadZCML\': True}, ),)\n+    # except ImportError:\n+    #    pass\n+    # try:\n+    #    import Products.CMFQuickInstallerTool\n+    #    products = products + (\n+    #        (\'Products.CMFQuickInstallerTool\', {\'loadZCML\': True}, ),)\n+    # except ImportError:\n+    #    pass\n \n     # Extension profiles to be installed with site setup\n     extensionProfiles = (\n@@ -100,7 +89,7 @@ class PloneFixture(Layer):\n \n     def setUp(self):\n \n-        # Stack a new DemoStorage on top of the one from z2.STARTUP.\n+        # Stack a new DemoStorage on top of the one from zope.STARTUP.\n         self[\'zodbDB\'] = zodb.stackDemoStorage(\n             self.get(\'zodbDB\'),\n             name=\'PloneFixture\'\n@@ -109,14 +98,14 @@ def setUp(self):\n         self.setUpZCML()\n \n         # Set up products and the default content\n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n             self.setUpProducts(app)\n             self.setUpDefaultContent(app)\n \n     def tearDown(self):\n \n         # Tear down products\n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n             # note: content tear-down happens by squashing the ZODB\n             self.tearDownProducts(app)\n \n@@ -189,7 +178,7 @@ def setUpProducts(self, app):\n \n         for p, config in self.products:\n             if config.get(\'install\', True):\n-                z2.installProduct(app, p)\n+                zope.installProduct(app, p)\n \n     def tearDownProducts(self, app):\n         """Uninstall all old-style products listed in the the ``products``\n@@ -197,7 +186,7 @@ def tearDownProducts(self, app):\n         """\n         for p, config in reversed(self.products):\n             if config.get(\'install\', True):\n-                z2.uninstallProduct(app, p)\n+                zope.uninstallProduct(app, p)\n \n         # Clean up Wicked turds\n         # XXX: This may tear down too much state\n@@ -227,7 +216,7 @@ def setUpDefaultContent(self, app):\n             []\n         )\n \n-        z2.login(app[\'acl_users\'], SITE_OWNER_NAME)\n+        zope.login(app[\'acl_users\'], SITE_OWNER_NAME)\n \n         # Create the site with the default set of extension profiles\n         from Products.CMFPlone.factory import addPloneSite\n@@ -256,14 +245,55 @@ def setUpDefaultContent(self, app):\n             pas.portal_role_manager.doAssignRoleToPrincipal(TEST_USER_ID, role)\n \n         # Log out again\n-        z2.logout()\n+        zope.logout()\n+\n \n # Plone fixture layer instance. Should not be used on its own, but as a base\n # for other layers.\n-\n PLONE_FIXTURE = PloneFixture()\n \n \n+class PloneZServerFixture(PloneFixture):\n+    """PloneFixture using ZServer if you really have to.\n+\n+    e. g. to use the FTP server.\n+\n+    """\n+\n+    defaultBases = (zserver.STARTUP,)\n+\n+    def setUp(self):\n+\n+        # Stack a new DemoStorage on top of the one from zserver.STARTUP.\n+        self[\'zodbDB\'] = zodb.stackDemoStorage(\n+            self.get(\'zodbDB\'),\n+            name=\'PloneZServerFixture\'\n+        )\n+\n+        self.setUpZCML()\n+\n+        # Set up products and the default content\n+        with zserver.zopeApp() as app:\n+            self.setUpProducts(app)\n+            self.setUpDefaultContent(app)\n+\n+    def tearDown(self):\n+\n+        # Tear down products\n+        with zserver.zopeApp() as app:\n+            # note: content tear-down happens by squashing the ZODB\n+            self.tearDownProducts(app)\n+\n+        self.tearDownZCML()\n+\n+        # Zap the stacked ZODB\n+        self[\'zodbDB\'].close()\n+        del self[\'zodbDB\']\n+\n+\n+PLONE_ZSERVER_FIXTURE = PloneZServerFixture()\n+\n+\n class PloneTestLifecycle(object):\n     """Mixin class for Plone test lifecycle. This exposes the ``portal``\n     resource and resets the environment between each test.\n@@ -327,6 +357,12 @@ def tearDownEnvironment(self, portal):\n         setSite(None)\n \n \n+class PloneZServerTestLifecycle(PloneTestLifecycle):\n+    """PloneTestLifecycle if you have to use ZServer."""\n+\n+    defaultBases = (PLONE_ZSERVER_FIXTURE,)\n+\n+\n class MockMailHostLayer(Layer):\n     """Layer for setting up a MockMailHost to store all sent messages as\n     strings into a list at portal.MailHost.messages\n@@ -334,7 +370,7 @@ class MockMailHostLayer(Layer):\n     defaultBases = (PLONE_FIXTURE,)\n \n     def setUp(self):\n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n             portal = app[PLONE_SITE_ID]\n             portal.email_from_address = \'noreply@example.com\'\n             portal.email_from_name = \'Plone Site\'\n@@ -346,7 +382,7 @@ def setUp(self):\n             sm.registerUtility(mailhost, provided=IMailHost)\n \n     def tearDown(self):\n-        with z2.zopeApp() as app:\n+        with zope.zopeApp() as app:\n             portal = app[PLONE_SITE_ID]\n             _o_mailhost = getattr(portal, \'_original_MailHost\', None)\n             if _o_mailhost:\n@@ -362,35 +398,43 @@ def tearDown(self):\n MOCK_MAILHOST_FIXTURE = MockMailHostLayer()\n \n \n-class IntegrationTesting(PloneTestLifecycle, z2.IntegrationTesting):\n+class IntegrationTesting(PloneTestLifecycle, zope.IntegrationTesting):\n     """Plone version of the integration testing layer\n     """\n \n \n-class FunctionalTesting(PloneTestLifecycle, z2.FunctionalTesting):\n+class FunctionalTesting(PloneTestLifecycle, zope.FunctionalTesting):\n     """Plone version of the functional testing layer\n     """\n \n+\n+class ZServerFunctionalTesting(\n+        PloneZServerTestLifecycle, zserver.FunctionalTesting):\n+    """Plone version of the functional testing layer using ZServer.\n+    """\n+\n #\n # Layer instances\n #\n-\n # Note: PLONE_FIXTURE is defined above\n \n+\n PLONE_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(PLONE_FIXTURE,),\n+    bases=(PLONE_FIXTURE, ),\n     name=\'Plone:Integration\'\n )\n+\n PLONE_FUNCTIONAL_TESTING = FunctionalTesting(\n-    bases=(PLONE_FIXTURE,),\n+    bases=(PLONE_FIXTURE, ),\n     name=\'Plone:Functional\'\n )\n \n-PLONE_ZSERVER = FunctionalTesting(\n-    bases=(PLONE_FIXTURE, z2.ZSERVER_FIXTURE),\n-    name=\'Plone:ZServer\'\n+PLONE_WSGISERVER = PLONE_ZSERVER = FunctionalTesting(\n+    bases=(PLONE_FIXTURE, zope.WSGI_SERVER_FIXTURE),\n+    name=\'Plone:WSGIServer\'\n )\n-PLONE_FTP_SERVER = FunctionalTesting(\n-    bases=(PLONE_FIXTURE, z2.FTP_SERVER_FIXTURE),\n+\n+PLONE_FTP_SERVER = ZServerFunctionalTesting(\n+    bases=(PLONE_ZSERVER_FIXTURE, zserver.FTP_SERVER_FIXTURE),\n     name=\'Plone:FTPServer\'\n )\ndiff --git a/plone/app/testing/layers.rst b/src/plone/app/testing/layers.rst\nsimilarity index 61%\nrename from plone/app/testing/layers.rst\nrename to src/plone/app/testing/layers.rst\nindex 713a7dd..23c7d9c 100644\n--- a/plone/app/testing/layers.rst\n+++ b/src/plone/app/testing/layers.rst\n@@ -15,7 +15,7 @@ For testing, we need a testrunner\n Plone site fixture\n ~~~~~~~~~~~~~~~~~~\n \n-The ``PLONE_FIXTURE`` layer extends ``STARTUP`` from ``plone.testing.z2`` to\n+The ``PLONE_FIXTURE`` layer extends ``STARTUP`` from ``plone.testing.zope`` to\n set up a Plone site.\n \n **Note:** This layer should only be used as a base layer, and not directly in\n@@ -44,10 +44,11 @@ Let\'s set up the fixture layer and inspect the state of the site.\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_FIXTURE, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+    >>> runner.setup_layer(options, layers.PLONE_FIXTURE, setupLayers)  # doctest: +ELLIPSIS\n+      Set up plone.testing.zca.LayerCleanup in ... seconds.\n+      Set up plone.testing.zope.Startup in ... seconds.\n+      Set up plone.app.testing.layers.PloneFixture in ... seconds.\n+\n \n The application root\'s ``acl_users`` folder will have one user, whose name and\n password are found in the constants ``SITE_OWNER_NAME`` and\n@@ -55,24 +56,24 @@ password are found in the constants ``SITE_OWNER_NAME`` and\n has the ``Manager`` role, and is the owner of the site object. You should not\n normally use this for testing, unless you need to manipulate the site itself.\n \n-    >>> from plone.testing import z2, zca\n+    >>> from plone.testing import zope, zca\n     >>> from plone.app.testing.interfaces import SITE_OWNER_NAME\n \n-    >>> with z2.zopeApp() as app:\n-    ...     print app[\'acl_users\'].getUser(SITE_OWNER_NAME)\n-    ...     print app[\'acl_users\'].getUser(SITE_OWNER_NAME).getRolesInContext(app)\n+    >>> with zope.zopeApp() as app:\n+    ...     print(app[\'acl_users\'].getUser(SITE_OWNER_NAME))\n+    ...     print(sorted(app[\'acl_users\'].getUser(SITE_OWNER_NAME).getRolesInContext(app)))\n     admin\n-    [\'Manager\', \'Authenticated\']\n+    [\'Authenticated\', \'Manager\']\n \n Inside the Plone site, the default theme is installed\n \n     >>> from plone.app.testing import helpers\n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal[\'portal_registry\'][\'plone.app.theming.interfaces.IThemeSettings.rules\']\n+    ...     print(portal[\'portal_registry\'][\'plone.app.theming.interfaces.IThemeSettings.rules\'])\n     /++theme++barceloneta/rules.xml\n \n **Note:** Here, we have used the ``ploneSite`` context manager to get hold of\n-the Plone site root. Like ``z2.zopeApp()``, this is intended for use during\n+the Plone site root. Like ``zope.zopeApp()``, this is intended for use during\n layer setup and tear-down, and will automatically commit any changes unless an\n error is raised.\n \n@@ -82,24 +83,24 @@ the module ``plone.app.testing.interfaces``.\n \n     >>> from plone.app.testing.interfaces import TEST_USER_NAME\n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getId()\n-    ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getUserName()\n-    ...     print portal[\'acl_users\'].getUser(TEST_USER_NAME).getRolesInContext(portal)\n+    ...     print(portal[\'acl_users\'].getUser(TEST_USER_NAME).getId())\n+    ...     print(portal[\'acl_users\'].getUser(TEST_USER_NAME).getUserName())\n+    ...     print(sorted(portal[\'acl_users\'].getUser(TEST_USER_NAME).getRolesInContext(portal)))\n     test_user_1_\n     test-user\n-    [\'Member\', \'Authenticated\']\n+    [\'Authenticated\', \'Member\']\n \n There is no default workflow or content:\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print portal[\'portal_workflow\'].getDefaultChain()\n+    ...     print(portal[\'portal_workflow\'].getDefaultChain())\n     ()\n \n Layer tear-down resets the environment.\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n     Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n Integration testing\n@@ -120,14 +121,14 @@ Let\'s set up the layers and attempt to run a test.\n     >>> setupLayers = {}\n     >>> runner.setup_layer(options, layers.PLONE_INTEGRATION_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n     Set up plone.app.testing.layers.PloneFixture in ... seconds.\n     Set up plone.app.testing.layers.Plone:Integration in ... seconds.\n \n Let\'s now simulate a test\n \n     >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n+    >>> zope.STARTUP.testSetUp()\n     >>> layers.PLONE_FIXTURE.testSetUp()\n     >>> layers.PLONE_INTEGRATION_TESTING.testSetUp()\n \n@@ -164,7 +165,7 @@ Let\'s now simulate test tear-down.\n \n     >>> layers.PLONE_INTEGRATION_TESTING.testTearDown()\n     >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n     >>> zca.LAYER_CLEANUP.testTearDown()\n \n At this point, our transaction has been rolled back:\n@@ -188,7 +189,7 @@ Layer tear-down resets the environment.\n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n     Tear down plone.app.testing.layers.Plone:Integration in ... seconds.\n     Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n Functional testing\n@@ -209,14 +210,14 @@ Let\'s set up the layers and attempt to run a test.\n     >>> setupLayers = {}\n     >>> runner.setup_layer(options, layers.PLONE_FUNCTIONAL_TESTING, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n     Set up plone.app.testing.layers.PloneFixture in ... seconds.\n     Set up plone.app.testing.layers.Plone:Functional in ... seconds.\n \n Let\'s now simulate a test\n \n     >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n+    >>> zope.STARTUP.testSetUp()\n     >>> layers.PLONE_FIXTURE.testSetUp()\n     >>> layers.PLONE_FUNCTIONAL_TESTING.testSetUp()\n \n@@ -246,7 +247,7 @@ Let\'s now simulate test tear-down.\n \n     >>> layers.PLONE_FUNCTIONAL_TESTING.testTearDown()\n     >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n     >>> zca.LAYER_CLEANUP.testTearDown()\n \n The previous database state should have been restored.\n@@ -268,49 +269,51 @@ Layer tear-down resets the environment.\n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n     Tear down plone.app.testing.layers.Plone:Functional in ... seconds.\n     Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n HTTP server\n ~~~~~~~~~~~\n \n-The ``PLONE_ZSERVER`` layer instantiates the ``FunctionalTesting`` class with\n-two bases: ``PLONE_FIXTURE``, as shown above, and ``ZSERVER_FIXTURE`` from\n-``plone.testing``, which starts up a ZServer thread.\n+The ``PLONE_WSGISERVER`` layer instantiates the ``FunctionalTesting`` class with\n+two bases: ``PLONE_FIXTURE``, as shown above, and ``WSGI_SERVER_FIXTURE`` from\n+``plone.testing``, which starts up a WSGI server. (There also the name\n+``PLONE_ZSERVER`` in place which is a BBB alias.)\n \n-    >>> "%s.%s" % (layers.PLONE_ZSERVER.__module__, layers.PLONE_ZSERVER.__name__,)\n-    \'plone.app.testing.layers.Plone:ZServer\'\n+    >>> "%s.%s" % (layers.PLONE_WSGISERVER.__module__, layers.PLONE_WSGISERVER.__name__,)\n+    \'plone.app.testing.layers.Plone:WSGIServer\'\n \n-    >>> layers.PLONE_ZSERVER.__bases__\n-    (<Layer \'plone.app.testing.layers.PloneFixture\'>, <Layer \'plone.testing.z2.ZServer\'>)\n+    >>> layers.PLONE_WSGISERVER.__bases__\n+    (<Layer \'plone.app.testing.layers.PloneFixture\'>, <Layer \'plone.testing.zope.WSGIServer\'>)\n \n     >>> options = runner.get_options([], [])\n     >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_ZSERVER, setupLayers)\n+    >>> runner.setup_layer(options, layers.PLONE_WSGISERVER, setupLayers)\n     Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n+    Set up plone.testing.zope.Startup in ... seconds.\n     Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up plone.testing.z2.ZServer in ... seconds.\n-    Set up plone.app.testing.layers.Plone:ZServer in ... seconds.\n+    Set up plone.testing.zope.WSGIServer in ... seconds.\n+    Set up plone.app.testing.layers.Plone:WSGIServer in ... seconds.\n \n After layer setup, the resources ``host`` and ``port`` are available, and\n indicate where Zope is running.\n \n-    >>> host = layers.PLONE_ZSERVER[\'host\']\n+    >>> host = layers.PLONE_WSGISERVER[\'host\']\n     >>> host\n     \'localhost\'\n \n-    >>> port = layers.PLONE_ZSERVER[\'port\']\n+    >>> port = layers.PLONE_WSGISERVER[\'port\']\n     >>> import os\n-    >>> # port == int(os.environ.get(\'ZSERVER_PORT\', 0))\n+    >>> port > 0\n+    True\n \n Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n do.\n \n     >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n+    >>> zope.STARTUP.testSetUp()\n     >>> layers.PLONE_FIXTURE.testSetUp()\n-    >>> z2.ZSERVER_FIXTURE.testSetUp()\n+    >>> zope.WSGI_SERVER_FIXTURE.testSetUp()\n     >>> layers.PLONE_ZSERVER.testSetUp()\n \n It is common in a test to use the Python API to change the state of the server\n@@ -334,19 +337,19 @@ We can now look for this new object through the server.\n     >>> portal_url.split(\':\')[:-1]\n     [\'http\', \'//localhost\']\n \n-    >>> import urllib2\n-    >>> conn = urllib2.urlopen(portal_url + \'/Title\', timeout=10)\n+    >>> from six.moves.urllib.request import urlopen\n+    >>> conn = urlopen(portal_url + \'/Title\', timeout=10)\n     >>> responseBody = conn.read()\n-    >>> "Fancy Portal" in responseBody\n+    >>> b"Fancy Portal" in responseBody\n     True\n     >>> conn.close()\n \n Test tear-down does nothing beyond what the base layers do.\n \n     >>> layers.PLONE_ZSERVER.testTearDown()\n-    >>> z2.ZSERVER_FIXTURE.testTearDown()\n+    >>> zope.WSGI_SERVER_FIXTURE.testTearDown()\n     >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n+    >>> zope.STARTUP.testTearDown()\n     >>> zca.LAYER_CLEANUP.testTearDown()\n \n     >>> \'portal\' in layers.PLONE_ZSERVER\n@@ -359,135 +362,19 @@ Test tear-down does nothing beyond what the base layers do.\n     False\n \n     >>> with helpers.ploneSite() as portal:\n-    ...     print \'folder1\' in portal.objectIds()\n+    ...     print(\'folder1\' in portal.objectIds())\n     False\n \n When the server is torn down, the ZServer thread is stopped.\n \n     >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.Plone:ZServer in ... seconds.\n-    ...Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    ...Tear down plone.testing.z2.Startup in ... seconds.\n-    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n-\n-    >>> conn = urllib2.urlopen(portal_url + \'/folder1\', timeout=5)\n-    Traceback (most recent call last):\n-    ...\n-    URLError: <urlopen error [Errno ...] Connection refused>\n-\n-FTP server with Plone site\n-~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-The ``PLONE_FTP_SERVER`` layer instantiates the ``FunctionalTesting`` class\n-with two bases: ``PLONE_FIXTURE``, as shown above, and ``FTP_SERVER_FIXTURE``\n-from ``plone.testing``, which starts up an FTP server thread.\n-\n-    >>> "%s.%s" % (layers.PLONE_FTP_SERVER.__module__, layers.PLONE_FTP_SERVER.__name__,)\n-    \'plone.app.testing.layers.Plone:FTPServer\'\n-\n-    >>> layers.PLONE_FTP_SERVER.__bases__\n-    (<Layer \'plone.app.testing.layers.PloneFixture\'>, <Layer \'plone.testing.z2.FTPServer\'>)\n-\n-    >>> options = runner.get_options([], [])\n-    >>> setupLayers = {}\n-    >>> runner.setup_layer(options, layers.PLONE_FTP_SERVER, setupLayers)\n-    Set up plone.testing.zca.LayerCleanup in ... seconds.\n-    Set up plone.testing.z2.Startup in ... seconds.\n-    Set up plone.app.testing.layers.PloneFixture in ... seconds.\n-    Set up plone.testing.z2.FTPServer in ... seconds.\n-    Set up plone.app.testing.layers.Plone:FTPServer in ... seconds.\n-\n-After layer setup, the resources ``host`` and ``port`` are available, and\n-indicate where Zope is running.\n-\n-    >>> host = layers.PLONE_FTP_SERVER[\'host\']\n-    >>> host\n-    \'localhost\'\n-\n-    >>> port = layers.PLONE_FTP_SERVER[\'port\']\n-    >>> import os\n-    >>> # port == int(os.environ.get(\'FTPSERVER_PORT\', 0))\n-\n-Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n-do.\n-\n-    >>> zca.LAYER_CLEANUP.testSetUp()\n-    >>> z2.STARTUP.testSetUp()\n-    >>> layers.PLONE_FIXTURE.testSetUp()\n-    >>> z2.FTP_SERVER_FIXTURE.testSetUp()\n-    >>> layers.PLONE_FTP_SERVER.testSetUp()\n-\n-It is common in a test to use the Python API to change the state of the server\n-(e.g. create some content or change a setting) and then use the FTP protocol\n-to look at the results. Bear in mind that the server is running in a separate\n-thread, with a separate security manager, so calls to ``helpers.login()`` and\n-``helpers.logout()``, for instance, do not affect the server thread.\n-\n-    >>> portal = layers.PLONE_FTP_SERVER[\'portal\'] # would normally be self.layer[\'portal\']\n-    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n-    >>> from OFS.Folder import Folder\n-    >>> portal._setObject(\'folder1\', Folder(\'folder1\'))\n-    \'folder1\'\n-\n-Note that we need to commit the transaction before it will show up in the\n-other thread.\n-\n-    >>> import transaction; transaction.commit()\n-\n-    >>> folder_path = portal.absolute_url_path() + \'/folder1\'\n-\n-    >>> import ftplib\n-    >>> ftpClient = ftplib.FTP()\n-    >>> ftpClient.connect(host, port, timeout=5)\n-    \'220 ... FTP server (...) ready.\'\n-\n-    >>> from plone.app.testing.interfaces import SITE_OWNER_NAME\n-    >>> from plone.app.testing.interfaces import SITE_OWNER_PASSWORD\n-\n-    >>> ftpClient.login(SITE_OWNER_NAME, SITE_OWNER_PASSWORD)\n-    \'230 Login successful.\'\n-\n-    >>> ftpClient.cwd(folder_path)\n-    \'250 CWD command successful.\'\n-\n-    >>> ftpClient.retrlines(\'LIST\')\n-    drwxrwx---   1 test_user_1_ Zope            0 ... .\n-    d---------   1 admin        Zope            0 ... ..\n-    \'226 Transfer complete\'\n-\n-    >>> ftpClient.quit()\n-    \'221 Goodbye.\'\n-\n-Test tear-down does nothing beyond what the base layers do.\n-\n-    >>> layers.PLONE_FTP_SERVER.testTearDown()\n-    >>> z2.FTP_SERVER_FIXTURE.testTearDown()\n-    >>> layers.PLONE_FIXTURE.testTearDown()\n-    >>> z2.STARTUP.testTearDown()\n-    >>> zca.LAYER_CLEANUP.testTearDown()\n-\n-    >>> \'portal\' in layers.PLONE_FTP_SERVER\n-    False\n-\n-    >>> \'app\' in layers.PLONE_FTP_SERVER\n-    False\n-\n-    >>> \'request\' in layers.PLONE_FTP_SERVER\n-    False\n-\n-    >>> with helpers.ploneSite() as portal:\n-    ...     print \'folder1\' in portal.objectIds()\n-    False\n-\n-When the server is torn down, the FTP server thread is stopped.\n-\n-    >>> runner.tear_down_unneeded(options, [], setupLayers)\n-    Tear down plone.app.testing.layers.Plone:FTPServer in ... seconds.\n-    ...Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n-    ...Tear down plone.testing.z2.Startup in ... seconds.\n+    Tear down plone.app.testing.layers.Plone:WSGIServer in ... seconds.\n+    Tear down plone.testing.zope.WSGIServer in ... seconds.\n+    Tear down plone.app.testing.layers.PloneFixture in ... seconds.\n+    Tear down plone.testing.zope.Startup in ... seconds.\n     Tear down plone.testing.zca.LayerCleanup in ... seconds.\n \n-    >>> ftpClient.connect(host, port, timeout=5)\n+    >>> conn = urlopen(portal_url + \'/folder1\', timeout=5) # doctest: +IGNORE_EXCEPTION_DETAIL\n     Traceback (most recent call last):\n     ...\n-    error: [Errno ...] Connection refused\n+    urllib.error.URLError: <urlopen error [Errno 61] Connection refused>\ndiff --git a/src/plone/app/testing/layers_zserver.rst b/src/plone/app/testing/layers_zserver.rst\nnew file mode 100644\nindex 0000000..8bb05a3\n--- /dev/null\n+++ b/src/plone/app/testing/layers_zserver.rst\n@@ -0,0 +1,135 @@\n+Plone testing ZServer layers\n+----------------------------\n+\n+There are some ZServer layers used to set up test fixtures containing a Plone\n+site running with ZServer. They are all importable from ``plone.app.testing``\n+directly, or from their canonical locations at ``plone.app.testing.layers``.\n+\n+    >>> from plone.app.testing import layers\n+\n+For testing, we need a testrunner\n+\n+    >>> from zope.testrunner import runner\n+\n+FTP server with Plone site\n+~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The ``PLONE_FTP_SERVER`` layer instantiates the ``FunctionalTesting`` class\n+with two bases: ``PLONE_FIXTURE``, as shown above, and ``FTP_SERVER_FIXTURE``\n+from ``plone.testing``, which starts up an FTP server thread.\n+\n+    >>> "%s.%s" % (layers.PLONE_FTP_SERVER.__module__, layers.PLONE_FTP_SERVER.__name__,)\n+    \'plone.app.testing.layers.Plone:FTPServer\'\n+\n+    >>> layers.PLONE_FTP_SERVER.__bases__\n+    (<Layer \'plone.app.testing.layers.PloneZServerFixture\'>, <Layer \'plone.testing.zserver.FTPServer\'>)\n+\n+    >>> options = runner.get_options([], [])\n+    >>> setupLayers = {}\n+    >>> runner.setup_layer(options, layers.PLONE_FTP_SERVER, setupLayers)  # here!\n+    Set up plone.testing.zca.LayerCleanup in ... seconds.\n+    Set up plone.testing.zserver.Startup in ... seconds.\n+    Set up plone.app.testing.layers.PloneZServerFixture in ... seconds.\n+    Set up plone.testing.zserver.FTPServer in ... seconds.\n+    Set up plone.app.testing.layers.Plone:FTPServer in ... seconds.\n+\n+After layer setup, the resources ``host`` and ``port`` are available, and\n+indicate where Zope is running.\n+\n+    >>> host = layers.PLONE_FTP_SERVER[\'host\']\n+    >>> host\n+    \'localhost\'\n+\n+The port is auto-allocated\n+\n+    >>> port = layers.PLONE_FTP_SERVER[\'port\']\n+    >>> bool(port)\n+    True\n+\n+Let\'s now simulate a test. Test setup does nothing beyond what the base layers\n+do.\n+\n+    >>> from plone.testing import zca, zserver\n+    >>> zca.LAYER_CLEANUP.testSetUp()\n+    >>> zserver.STARTUP.testSetUp()\n+    >>> layers.PLONE_FIXTURE.testSetUp()\n+    >>> zserver.FTP_SERVER_FIXTURE.testSetUp()\n+    >>> layers.PLONE_FTP_SERVER.testSetUp()\n+\n+It is common in a test to use the Python API to change the state of the server\n+(e.g. create some content or change a setting) and then use the FTP protocol\n+to look at the results. Bear in mind that the server is running in a separate\n+thread, with a separate security manager, so calls to ``helpers.login()`` and\n+``helpers.logout()``, for instance, do not affect the server thread.\n+\n+    >>> from plone.app.testing import helpers\n+    >>> from plone.app.testing.interfaces import TEST_USER_ID\n+    >>> portal = layers.PLONE_FTP_SERVER[\'portal\'] # would normally be self.layer[\'portal\']\n+    >>> helpers.setRoles(portal, TEST_USER_ID, [\'Manager\'])\n+    >>> from OFS.Folder import Folder\n+    >>> portal._setObject(\'folder1\', Folder(\'folder1\'))\n+    \'folder1\'\n+\n+Note that we need to commit the transaction before it will show up in the\n+other thread.\n+\n+    >>> import transaction; transaction.commit()\n+\n+    >>> folder_path = portal.absolute_url_path() + \'/folder1\'\n+\n+    >>> import ftplib\n+    >>> ftpClient = ftplib.FTP()\n+    >>> ftpClient.connect(host, port, timeout=5)\n+    \'220 ... FTP server (...) ready.\'\n+\n+    >>> from plone.app.testing.interfaces import SITE_OWNER_NAME\n+    >>> from plone.app.testing.interfaces import SITE_OWNER_PASSWORD\n+\n+    >>> ftpClient.login(SITE_OWNER_NAME, SITE_OWNER_PASSWORD)\n+    \'230 Login successful.\'\n+\n+    >>> ftpClient.cwd(folder_path)\n+    \'250 CWD command successful.\'\n+\n+    >>> ftpClient.retrlines(\'LIST\')\n+    drwxrwx---   1 test_user_1_ Zope            0 ... .\n+    d---------   1 admin        Zope            0 ... ..\n+    \'226 Transfer complete\'\n+\n+    >>> ftpClient.quit()\n+    \'221 Goodbye.\'\n+\n+Test tear-down does nothing beyond what the base layers do.\n+\n+    >>> layers.PLONE_FTP_SERVER.testTearDown()\n+    >>> zserver.FTP_SERVER_FIXTURE.testTearDown()\n+    >>> layers.PLONE_FIXTURE.testTearDown()\n+    >>> zserver.STARTUP.testTearDown()\n+    >>> zca.LAYER_CLEANUP.testTearDown()\n+\n+    >>> \'portal\' in layers.PLONE_FTP_SERVER\n+    False\n+\n+    >>> \'app\' in layers.PLONE_FTP_SERVER\n+    False\n+\n+    >>> \'request\' in layers.PLONE_FTP_SERVER\n+    False\n+\n+    >>> import plone.testing.zserver\n+    >>> with helpers.ploneSite(flavour=plone.testing.zserver) as portal:\n+    ...     print(\'folder1\' in portal.objectIds())\n+    False\n+\n+When the server is torn down, the FTP server thread is stopped.\n+\n+    >>> runner.tear_down_unneeded(options, [], setupLayers)\n+    Tear down plone.app.testing.layers.Plone:FTPServer in ... seconds.\n+    Tear down plone.testing.zserver.FTPServer in ... seconds.\n+    Tear down plone.app.testing.layers.PloneZServerFixture in ... seconds.\n+    Tear down plone.testing.zserver.Startup in ... seconds.\n+    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n+\n+    >>> ftpClient.connect(host, port, timeout=5) # doctest: +IGNORE_EXCEPTION_DETAIL\n+    Traceback (most recent call last):\n+    error: [Errno 61] Connection refused\ndiff --git a/plone/app/testing/profile/metadata.xml b/src/plone/app/testing/profile/metadata.xml\nsimilarity index 100%\nrename from plone/app/testing/profile/metadata.xml\nrename to src/plone/app/testing/profile/metadata.xml\ndiff --git a/plone/app/testing/selenium.rst b/src/plone/app/testing/selenium.rst\nsimilarity index 100%\nrename from plone/app/testing/selenium.rst\nrename to src/plone/app/testing/selenium.rst\ndiff --git a/plone/app/testing/selenium_layers.py b/src/plone/app/testing/selenium_layers.py\nsimilarity index 97%\nrename from plone/app/testing/selenium_layers.py\nrename to src/plone/app/testing/selenium_layers.py\nindex 57fdf69..965f2df 100644\n--- a/plone/app/testing/selenium_layers.py\n+++ b/src/plone/app/testing/selenium_layers.py\n@@ -4,14 +4,14 @@\n from plone.app.testing import TEST_USER_NAME\n from plone.app.testing import TEST_USER_PASSWORD\n from plone.testing import Layer\n-from plone.testing import z2\n+from plone.testing import zope\n \n import os\n import transaction\n \n \n class SeleniumLayer(Layer):\n-    defaultBases = (z2.ZSERVER_FIXTURE, )\n+    defaultBases = (zope.ZSERVER_FIXTURE, )\n \n     def testSetUp(self):\n         # Start up Selenium\n@@ -29,6 +29,7 @@ def testTearDown(self):\n         self[\'selenium\'].quit()\n         del self[\'selenium\']\n \n+\n SELENIUM_FIXTURE = SeleniumLayer()\n SELENIUM_FUNCTIONAL_TESTING = FunctionalTesting(\n     bases=(SELENIUM_FIXTURE, ),\ndiff --git a/plone/app/testing/tests.py b/src/plone/app/testing/tests.py\nsimilarity index 81%\nrename from plone/app/testing/tests.py\nrename to src/plone/app/testing/tests.py\nindex 3f0c844..22763e1 100644\n--- a/plone/app/testing/tests.py\n+++ b/src/plone/app/testing/tests.py\n@@ -1,5 +1,6 @@\n # -*- coding: utf-8 -*-\n import doctest\n+import six\n import unittest\n \n \n@@ -23,4 +24,9 @@ def test_suite():\n         doctest.DocFileSuite(\'helpers.rst\', optionflags=OPTIONFLAGS),\n         # seltest,\n     ])\n+    if six.PY2:\n+        suite.addTests([\n+            doctest.DocFileSuite(\n+                \'layers_zserver.rst\', optionflags=OPTIONFLAGS),\n+        ])\n     return suite\ndiff --git a/plone/app/testing/utils.py b/src/plone/app/testing/utils.py\nsimilarity index 100%\nrename from plone/app/testing/utils.py\nrename to src/plone/app/testing/utils.py\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..88fceee\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,161 @@\n+[tox]\n+envlist =\n+    py27,\n+    py35,\n+    py36,\n+    coverage-report,\n+    docs,\n+    lint-py27,\n+    lint-py36,\n+\n+minversion = 1.9\n+\n+[testenv]\n+whitelist_externals = test coverage\n+skip_install = true\n+usedevelop = True\n+\n+pip_pre = True\n+\n+extras =\n+    test\n+\n+deps =\n+     -rhttps://raw.githubusercontent.com/plone/buildout.coredev/5.2/requirements.txt\n+\n+commands =\n+    python -V\n+    {envbindir}/buildout -c {toxinidir}/buildout.cfg buildout:directory={envdir} buildout:develop={toxinidir} bootstrap\n+    {envbindir}/buildout -c {toxinidir}/buildout.cfg buildout:directory={envdir} buildout:develop={toxinidir} install test\n+    ls -la {envbindir}\n+    coverage run {envbindir}/test --all {posargs:-vvc}\n+\n+setenv =\n+    COVERAGE_FILE=.coverage.{envname}\n+\n+passenv =\n+    WSGI_REQUEST_LOGGING\n+\n+[testenv:coverage-report]\n+skip_install = true\n+basepython = python2.7\n+\n+deps = coverage\n+\n+setenv =\n+    COVERAGE_FILE=.coverage\n+\n+commands =\n+    coverage erase\n+    coverage combine\n+    coverage html -i\n+    coverage xml -i\n+    coverage report -i --fail-under=60\n+\n+\n+[lint]\n+skip_install = true\n+\n+deps =\n+    isort\n+    flake8\n+    # helper to generate HTML reports:\n+    flake8-html\n+    # Useful flake8 plugins that are Python and Plone specific:\n+    flake8-coding\n+    flake8-debugger\n+    flake8-deprecated\n+    flake8-print\n+    flake8-pytest\n+    flake8-todo\n+    flake8-isort\n+    mccabe\n+    # Potential flake8 plugins that should be used:  # TBD\n+    #flake8-blind-except\n+    #flake8-commas\n+    #flake8-docstrings\n+    #flake8-mypy\n+    #flake8-pep3101\n+    #flake8-plone-hasattr\n+    #flake8-string-format\n+    #flake8_strict\n+    #flake8-quotes\n+    #flake8-polyfill\n+\n+commands =\n+    mkdir -p {toxinidir}/_build/reports/flake8\n+    - flake8 --format=html --htmldir={toxinidir}/_build/reports/flake8 --doctests src setup.py\n+    flake8 --doctests src tests setup.py\n+    isort --check-only --recursive {toxinidir}/src\n+\n+whitelist_externals =\n+    mkdir\n+\n+[testenv:isort-apply]\n+skip_install = true\n+\n+deps =\n+    isort\n+\n+commands =\n+    isort --apply --recursive {toxinidir}/src\n+\n+[testenv:lint-py27]\n+basepython = python2.7\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:lint-py34]\n+basepython = python3.4\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:lint-py35]\n+basepython = python3.5\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:lint-py36]\n+basepython = python3.6\n+skip_install = true\n+deps = {[lint]deps}\n+commands = {[lint]commands}\n+whitelist_externals = {[lint]whitelist_externals}\n+\n+[testenv:docs]\n+skip_install = true\n+\n+deps =\n+    Sphinx\n+\n+commands =\n+    sphinx-build -b html -d _build/docs/doctrees docs _build/docs/html\n+#    sphinx-build -b doctest docs _build/docs/doctrees\n+\n+[testenv:update_translation]\n+skip_install = true\n+\n+deps =\n+    i18ndude\n+\n+commands =\n+    i18ndude find-untranslated\n+    i18ndude rebuild-pot\n+    i18ndude merge\n+    i18ndude sync\n+    i18ndude list\n+\n+[testenv:release]\n+skip_install = true\n+\n+deps =\n+    zest.releaser[recommended]\n+\n+commands =\n+    fullrelease --no-input -v\n'

