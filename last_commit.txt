Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2018-08-07T16:18:15+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.cachepurging/commit/effd841cc50b34184bdd5b9f244e2115f6fd6db8

refactor to use requests instead of own connection-foo

Files changed:
M CHANGES.rst
M bootstrap.py
M plone/__init__.py
M plone/cachepurging/browser.py
M plone/cachepurging/interfaces.py
M plone/cachepurging/paths.py
M plone/cachepurging/purger.py
M plone/cachepurging/rewrite.py
M plone/cachepurging/tests/test_hooks.py
M plone/cachepurging/tests/test_purger.py
M plone/cachepurging/tests/test_rewrite.py
M plone/cachepurging/tests/test_traversable_paths.py
M plone/cachepurging/tests/test_utils.py
M plone/cachepurging/tests/test_views.py
M plone/cachepurging/utils.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex b38b26f..694c5d6 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -6,7 +6,11 @@ Changelog\n \n Breaking changes:\n \n-- *add item here*\n+- Use `requests <http://docs.python-requests.org/>`_ library instead of handcrafting connection and requests on our own.\n+  This avoids strange problems in real-world customers environments.\n+  We do not need to reinvent the wheel here.\n+  Requests always uses HTTP 1.1 and drops support for HTTP 1.0 only caches.\n+  [jensens]\n \n New features:\n \ndiff --git a/bootstrap.py b/bootstrap.py\nindex a629566..2294e35 100644\n--- a/bootstrap.py\n+++ b/bootstrap.py\n@@ -27,7 +27,7 @@\n \n tmpeggs = tempfile.mkdtemp()\n \n-usage = \'\'\'\\\n+usage = """\\\n [DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]\n \n Bootstraps a buildout-based project.\n@@ -37,30 +37,47 @@\n \n Note that by using --find-links to point to local resources, you can keep\n this script from going over the network.\n-\'\'\'\n+"""\n \n parser = OptionParser(usage=usage)\n parser.add_option("-v", "--version", help="use a specific zc.buildout version")\n \n-parser.add_option("-t", "--accept-buildout-test-releases",\n-                  dest=\'accept_buildout_test_releases\',\n-                  action="store_true", default=False,\n-                  help=("Normally, if you do not specify a --version, the "\n-                        "bootstrap script and buildout gets the newest "\n-                        "*final* versions of zc.buildout and its recipes and "\n-                        "extensions for you.  If you use this flag, "\n-                        "bootstrap and buildout will get the newest releases "\n-                        "even if they are alphas or betas."))\n-parser.add_option("-c", "--config-file",\n-                  help=("Specify the path to the buildout configuration "\n-                        "file to be used."))\n-parser.add_option("-f", "--find-links",\n-                  help=("Specify a URL to search for buildout releases"))\n-parser.add_option("--allow-site-packages",\n-                  action="store_true", default=False,\n-                  help=("Let bootstrap.py use existing site packages"))\n-parser.add_option("--setuptools-version",\n-                  help="use a specific setuptools version")\n+parser.add_option(\n+    "-t",\n+    "--accept-buildout-test-releases",\n+    dest="accept_buildout_test_releases",\n+    action="store_true",\n+    default=False,\n+    help=(\n+        "Normally, if you do not specify a --version, the "\n+        "bootstrap script and buildout gets the newest "\n+        "*final* versions of zc.buildout and its recipes and "\n+        "extensions for you.  If you use this flag, "\n+        "bootstrap and buildout will get the newest releases "\n+        "even if they are alphas or betas."\n+    ),\n+)\n+parser.add_option(\n+    "-c",\n+    "--config-file",\n+    help=(\n+        "Specify the path to the buildout configuration " "file to be used."\n+    ),\n+)\n+parser.add_option(\n+    "-f",\n+    "--find-links",\n+    help=("Specify a URL to search for buildout releases"),\n+)\n+parser.add_option(\n+    "--allow-site-packages",\n+    action="store_true",\n+    default=False,\n+    help=("Let bootstrap.py use existing site packages"),\n+)\n+parser.add_option(\n+    "--setuptools-version", help="use a specific setuptools version"\n+)\n \n \n options, args = parser.parse_args()\n@@ -77,25 +94,26 @@\n     from urllib2 import urlopen\n \n ez = {}\n-exec(urlopen(\'https://bootstrap.pypa.io/ez_setup.py\').read(), ez)\n+exec(urlopen("https://bootstrap.pypa.io/ez_setup.py").read(), ez)\n \n if not options.allow_site_packages:\n     # ez_setup imports site, which adds site packages\n     # this will remove them from the path to ensure that incompatible versions\n     # of setuptools are not in the path\n     import site\n+\n     # inside a virtualenv, there is no \'getsitepackages\'.\n     # We can\'t remove these reliably\n-    if hasattr(site, \'getsitepackages\'):\n+    if hasattr(site, "getsitepackages"):\n         for sitepackage_path in site.getsitepackages():\n             sys.path[:] = [x for x in sys.path if sitepackage_path not in x]\n \n setup_args = dict(to_dir=tmpeggs, download_delay=0)\n \n if options.setuptools_version is not None:\n-    setup_args[\'version\'] = options.setuptools_version\n+    setup_args["version"] = options.setuptools_version\n \n-ez[\'use_setuptools\'](**setup_args)\n+ez["use_setuptools"](**setup_args)\n import setuptools\n import pkg_resources\n \n@@ -110,28 +128,37 @@\n \n ws = pkg_resources.working_set\n \n-cmd = [sys.executable, \'-c\',\n-       \'from setuptools.command.easy_install import main; main()\',\n-       \'-mZqNxd\', tmpeggs]\n+cmd = [\n+    sys.executable,\n+    "-c",\n+    "from setuptools.command.easy_install import main; main()",\n+    "-mZqNxd",\n+    tmpeggs,\n+]\n \n find_links = os.environ.get(\n-    \'bootstrap-testing-find-links\',\n-    options.find_links or\n-    (\'http://downloads.buildout.org/\'\n-     if options.accept_buildout_test_releases else None)\n-    )\n+    "bootstrap-testing-find-links",\n+    options.find_links\n+    or (\n+        "http://downloads.buildout.org/"\n+        if options.accept_buildout_test_releases\n+        else None\n+    ),\n+)\n if find_links:\n-    cmd.extend([\'-f\', find_links])\n+    cmd.extend(["-f", find_links])\n \n setuptools_path = ws.find(\n-    pkg_resources.Requirement.parse(\'setuptools\')).location\n+    pkg_resources.Requirement.parse("setuptools")\n+).location\n \n-requirement = \'zc.buildout\'\n+requirement = "zc.buildout"\n version = options.version\n if version is None and not options.accept_buildout_test_releases:\n     # Figure out the most recent final version of zc.buildout.\n     import setuptools.package_index\n-    _final_parts = \'*final-\', \'*final\'\n+\n+    _final_parts = "*final-", "*final"\n \n     def _final_version(parsed_version):\n         try:\n@@ -139,12 +166,13 @@ def _final_version(parsed_version):\n         except AttributeError:\n             # Older setuptools\n             for part in parsed_version:\n-                if (part[:1] == \'*\') and (part not in _final_parts):\n+                if (part[:1] == "*") and (part not in _final_parts):\n                     return False\n             return True\n \n     index = setuptools.package_index.PackageIndex(\n-        search_path=[setuptools_path])\n+        search_path=[setuptools_path]\n+    )\n     if find_links:\n         index.add_find_links((find_links,))\n     req = pkg_resources.Requirement.parse(requirement)\n@@ -163,13 +191,13 @@ def _final_version(parsed_version):\n             best.sort()\n             version = best[-1].version\n if version:\n-    requirement = \'==\'.join((requirement, version))\n+    requirement = "==".join((requirement, version))\n cmd.append(requirement)\n \n import subprocess\n+\n if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:\n-    raise Exception(\n-        "Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n+    raise Exception("Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n \n ######################################################################\n # Import and run buildout\n@@ -178,12 +206,12 @@ def _final_version(parsed_version):\n ws.require(requirement)\n import zc.buildout.buildout\n \n-if not [a for a in args if \'=\' not in a]:\n-    args.append(\'bootstrap\')\n+if not [a for a in args if "=" not in a]:\n+    args.append("bootstrap")\n \n # if -c was provided, we push it back into args for buildout\' main function\n if options.config_file is not None:\n-    args[0:0] = [\'-c\', options.config_file]\n+    args[0:0] = ["-c", options.config_file]\n \n zc.buildout.buildout.main(args)\n shutil.rmtree(tmpeggs)\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..03d08ff 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1,2 @@\n # -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/cachepurging/browser.py b/plone/cachepurging/browser.py\nindex 8a0809d..4c20c42 100644\n--- a/plone/cachepurging/browser.py\n+++ b/plone/cachepurging/browser.py\n@@ -26,10 +26,10 @@ def __init__(self, context, request):\n     def __call__(self):\n \n         if not isCachePurgingEnabled():\n-            return \'Caching not enabled\'\n+            return "Caching not enabled"\n \n         notify(Purge(self.context))\n-        return \'Queued\'\n+        return "Queued"\n \n \n class PurgeImmediately(object):\n@@ -42,7 +42,7 @@ def __init__(self, context, request):\n \n     def __call__(self):\n         if not isCachePurgingEnabled():\n-            return \'Caching not enabled\'\n+            return "Caching not enabled"\n \n         registry = getUtility(IRegistry)\n         settings = registry.forInterface(ICachePurgingSettings)\n@@ -54,10 +54,7 @@ def __call__(self):\n                 status, xcache, xerror = purger.purgeSync(url)\n                 out.write(\n                     RESULT_TPL.format(\n-                        url=url,\n-                        status=status,\n-                        xcache=xcache,\n-                        xerror=xerror,\n+                        url=url, status=status, xcache=xcache, xerror=xerror\n                     )\n                 )\n         return out.getvalue()\ndiff --git a/plone/cachepurging/interfaces.py b/plone/cachepurging/interfaces.py\nindex b65bab1..363eb71 100644\n--- a/plone/cachepurging/interfaces.py\n+++ b/plone/cachepurging/interfaces.py\n@@ -4,7 +4,7 @@\n from zope.interface import Interface\n \n \n-_ = MessageFactory(\'plone\')\n+_ = MessageFactory("plone")\n \n \n class ICachePurgingSettings(Interface):\n@@ -21,45 +21,51 @@ class ICachePurgingSettings(Interface):\n \n     cachingProxies = schema.Tuple(\n         title=_(u"Caching proxies"),\n-        description=_(u"Provide the URLs of each proxy to which PURGE "\n-                      u"requests should be sent."),\n+        description=_(\n+            u"Provide the URLs of each proxy to which PURGE "\n+            u"requests should be sent."\n+        ),\n         value_type=schema.URI(),\n     )\n \n     virtualHosting = schema.Bool(\n         title=_(u"Send PURGE requests with virtual hosting paths"),\n-        description=_(u"This option is only relevant if you are using "\n-                      u"virtual hosting with Zope\'s VirtualHostMonster. "\n-                      u"This relies on special tokens (VirtualHostBase "\n-                      u"and VirtualHostRoot) in the URL to instruct "\n-                      u"Zope about the types of URLs that the user sees. "\n-                      u"If virtual host URLs are in use and this option "\n-                      u"is set, PURGE requests will be sent to the "\n-                      u"caching proxy with the virtual hosting tokens "\n-                      u"in place. This makes sense if there is a web "\n-                      u"server in front of your caching proxy performing "\n-                      u"the rewrites necessary to translate a user-"\n-                      u"facing URL into a virtual hosting URL, so that "\n-                      u"the requests the caching proxy sees have the "\n-                      u"rewrite information in them. Conversely, if the "\n-                      u"rewrite is done in or behind the caching proxy, "\n-                      u"you want to disable this option, so that the "\n-                      u"PURGE requests use URLs that match those seen "\n-                      u"by the caching proxy as they come from the "\n-                      u"client."),\n+        description=_(\n+            u"This option is only relevant if you are using "\n+            u"virtual hosting with Zope\'s VirtualHostMonster. "\n+            u"This relies on special tokens (VirtualHostBase "\n+            u"and VirtualHostRoot) in the URL to instruct "\n+            u"Zope about the types of URLs that the user sees. "\n+            u"If virtual host URLs are in use and this option "\n+            u"is set, PURGE requests will be sent to the "\n+            u"caching proxy with the virtual hosting tokens "\n+            u"in place. This makes sense if there is a web "\n+            u"server in front of your caching proxy performing "\n+            u"the rewrites necessary to translate a user-"\n+            u"facing URL into a virtual hosting URL, so that "\n+            u"the requests the caching proxy sees have the "\n+            u"rewrite information in them. Conversely, if the "\n+            u"rewrite is done in or behind the caching proxy, "\n+            u"you want to disable this option, so that the "\n+            u"PURGE requests use URLs that match those seen "\n+            u"by the caching proxy as they come from the "\n+            u"client."\n+        ),\n         required=True,\n         default=False,\n     )\n \n     domains = schema.Tuple(\n         title=_(u"Domains"),\n-        description=_(u"This option is only relevant if you are using "\n-                      u"virtual hosting and you have enabled the option "\n-                      u"to send PURGE requests with virtual hosting URLs "\n-                      u"above. If you your site is served on multiple "\n-                      u"domains e.g. http://example.org and "\n-                      u"http://www.example.org you may wish to purge "\n-                      u"both. If so, list all your domains here"),\n+        description=_(\n+            u"This option is only relevant if you are using "\n+            u"virtual hosting and you have enabled the option "\n+            u"to send PURGE requests with virtual hosting URLs "\n+            u"above. If you your site is served on multiple "\n+            u"domains e.g. http://example.org and "\n+            u"http://www.example.org you may wish to purge "\n+            u"both. If so, list all your domains here"\n+        ),\n         required=False,\n         default=(),\n         missing_value=(),\n@@ -86,12 +92,12 @@ class IPurger(Interface):\n     """A utility used to manage the purging process.\n     """\n \n-    def purgeAsync(url, httpVerb=\'PURGE\'):\n+    def purgeAsync(url, httpVerb="PURGE"):\n         """Send a PURGE request to a particular URL asynchronously in a\n         worker thread.\n         """\n \n-    def purgeSync(url, httpVerb=\'PURGE\'):\n+    def purgeSync(url, httpVerb="PURGE"):\n         """Send a PURGE request to a particular URL synchronosly.\n \n         Returns a triple ``(status, xcache, xerror)`` where ``status`` is\n@@ -112,10 +118,9 @@ def stopThreads(wait=False):\n     errorHeaders = schema.Tuple(\n         title=u"Error header names",\n         value_type=schema.ASCIILine(),\n-        default=(\'x-squid-error\',)\n+        default=("x-squid-error",),\n     )\n \n     http_1_1 = schema.Bool(\n-        title=u"Use HTTP 1.1 for PURGE request",\n-        default=True,\n+        title=u"Use HTTP 1.1 for PURGE request", default=True\n     )\ndiff --git a/plone/cachepurging/paths.py b/plone/cachepurging/paths.py\nindex b67c583..1f4b0cf 100644\n--- a/plone/cachepurging/paths.py\n+++ b/plone/cachepurging/paths.py\n@@ -15,7 +15,7 @@ def __init__(self, context):\n         self.context = context\n \n     def getRelativePaths(self):\n-        return [\'/\' + self.context.virtual_url_path()]\n+        return ["/" + self.context.virtual_url_path()]\n \n     def getAbsolutePaths(self):\n         return []\ndiff --git a/plone/cachepurging/purger.py b/plone/cachepurging/purger.py\nindex d80a316..fb11a37 100644\n--- a/plone/cachepurging/purger.py\n+++ b/plone/cachepurging/purger.py\n@@ -14,113 +14,104 @@\n \n from App.config import getConfiguration\n from plone.cachepurging.interfaces import IPurger\n-from six.moves import http_client\n from six.moves import queue\n from six.moves import range\n-from six.moves import urllib\n+from six.moves.urllib.parse import urlparse\n+from traceback import format_exception\n from zope.interface import implementer\n from zope.testing.cleanup import addCleanUp\n \n import atexit\n import logging\n+import requests\n import six\n-import socket\n import sys\n import threading\n-import time\n \n \n-logger = logging.getLogger(\'plone.cachepurging\')\n-\n-\n-class Connection(http_client.HTTPConnection):\n-    """A connection that can handle either HTTP or HTTPS\n-    """\n-\n-    def __init__(self, host, port=None, scheme="http", timeout=5):\n-        self.scheme = scheme\n-        if scheme == "http":\n-            self.default_port = http_client.HTTP_PORT\n-        elif scheme == "https":\n-            self.default_port = http_client.HTTPS_PORT\n-        else:\n-            raise ValueError("Invalid scheme \'%s\'" % scheme)\n-        http_client.HTTPConnection.__init__(self, host, port, timeout=timeout)\n-        self.timeout = timeout\n-\n-    def connect(self):\n-        if self.scheme == "http":\n-            http_client.HTTPConnection.connect(self)\n-        elif self.scheme == "https":\n-            import ssl  # import here in case python has no ssl support\n-            # Clone of http_client.HTTPSConnection.connect\n-            sock = socket.create_connection((self.host, self.port),\n-                                            timeout=self.timeout)\n-            key_file = cert_file = None\n-            self.sock = ssl.wrap_socket(sock, key_file, cert_file)\n-        else:\n-            raise ValueError("Invalid scheme \'%s\'" % self.scheme)\n+logger = logging.getLogger(__name__)\n \n \n @implementer(IPurger)\n class DefaultPurger(object):\n-\n-    def __init__(self, factory=Connection, timeout=30, backlog=0,\n-                 errorHeaders=(\'x-squid-error\', ), http_1_1=True):\n-        self.factory = factory\n+    def __init__(\n+        self, timeout=(3, 27), backlog=0, errorHeaders=("x-squid-error",)\n+    ):\n         self.timeout = timeout\n         self.queues = {}\n         self.workers = {}\n         self.backlog = backlog\n         self.queueLock = threading.Lock()\n         self.errorHeaders = errorHeaders\n-        self.http_1_1 = http_1_1\n \n-    def purgeAsync(self, url, httpVerb=\'PURGE\'):\n-        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)  # noqa: E501\n-        __traceback_info__ = (url, httpVerb, scheme, host,\n-                              path, params, query, fragment)\n+    def purge(self, session, url, httpVerb="PURGE"):\n+        """Perform the single purge request.\n \n-        q, w = self.getQueueAndWorker(url)\n-        try:\n-            q.put((url, httpVerb), block=False)\n-            logger.debug(\'Queued %s\' % url)\n-        except queue.Full:\n-            # Make a loud noise. Ideally the queue size would be\n-            # user-configurable - but the more likely case is that the purge\n-            # host is down.\n-            if not getConfiguration().debug_mode:\n-                logger.warning("The purge queue for the URL %s is full - the "\n-                               "request will be discarded.  Please check the "\n-                               "server is reachable, or disable this purge "\n-                               "host", url)\n+        Returns a triple ``(resp, xcache, xerror)`` where ``resp`` is the\n+        response object for the connection, ``xcache`` is the contents of the\n+        X-Cache header, and ``xerror`` is the contents of the first header\n+        found of the header list in ``self.errorHeaders``.\n+        """\n+        __traceback_info__ = url\n+        logger.debug("making %s request to %s", httpVerb, url)\n+        resp = session.request(httpVerb, url, timeout=self.timeout)\n+        xcache = resp.headers.get("x-cache", "")\n+        xerror = ""\n+        for header in self.errorHeaders:\n+            xerror = resp.headers.get(header, "")\n+            if xerror:\n+                # Break on first found.\n+                break\n+        logger.debug(\n+            "%s of %s: %s %s", httpVerb, url, resp.status_code, resp.reason\n+        )\n+        return resp, xcache, xerror\n+\n+    def purgeSync(self, url, httpVerb="PURGE"):\n+        """Purge synchronous.\n \n-    def purgeSync(self, url, httpVerb=\'PURGE\'):\n+        Fails if requests to cache fails.\n+        """\n         try:\n-            conn = self.getConnection(url)\n-            try:\n-                resp, xcache, xerror = self._purgeSync(conn, url, httpVerb)\n-                status = resp.status\n-            finally:\n-                conn.close()\n-        except:\n+            with requests.Session() as session:\n+                resp, xcache, xerror = self.purge(session, url, httpVerb)\n+                status = str(resp.status_code)\n+        except Exception:\n             status = "ERROR"\n             err, msg, tb = sys.exc_info()\n-            from traceback import format_exception\n-            xerror = \'\\n\'.join(format_exception(err, msg, tb))\n+            xerror = "\\n".join(format_exception(err, msg, tb))\n             # Avoid leaking a ref to traceback.\n             del err, msg, tb\n-            xcache = \'\'\n-        logger.debug(\'Finished %s for %s: %s %s\'\n-                     % (httpVerb, url, status, xcache))\n+            xcache = ""\n+        logger.debug(\n+            "Finished %s for %s: %s %s" % (httpVerb, url, status, xcache)\n+        )\n         if xerror:\n-            logger.debug(\'Error while purging %s:\\n%s\' % (url, xerror))\n+            logger.debug("Error while purging %s:\\n%s" % (url, xerror))\n         logger.debug("Completed synchronous purge of %s", url)\n         return status, xcache, xerror\n \n+    def purgeAsync(self, url, httpVerb="PURGE"):\n+        current_queue, worker = self.getQueueAndWorker(url)\n+        try:\n+            current_queue.put((url, httpVerb), block=False)\n+            logger.debug("Queued %s" % url)\n+        except queue.Full:\n+            # Make a loud noise. Ideally the queue size would be\n+            # user-configurable - but the more likely case is that the purge\n+            # host is down.\n+            if not getConfiguration().debug_mode:\n+                logger.warning(\n+                    "The purge queue for the URL %s is full - the "\n+                    "request will be discarded.  Please check the "\n+                    "server is reachable, or disable this purge "\n+                    "host",\n+                    url,\n+                )\n+\n     def stopThreads(self, wait=False):\n-        for w in six.itervalues(self.workers):\n-            w.stopping = True\n+        for worker in six.itervalues(self.workers):\n+            worker.stop()\n         # in case the queue is empty, wake it up so the .stopping flag is seen\n         for q in self.queues.values():\n             try:\n@@ -137,84 +128,36 @@ def stopThreads(self, wait=False):\n                     ok = False\n         return ok\n \n-    def getConnection(self, url):\n-        """Creates a new connection - returns a connection object that is\n-        already connected. Exceptions raised by that connection are not\n-        trapped.\n-        """\n-\n-        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)\n-        #\n-        # process.\n-        conn = self.factory(host, scheme=scheme, timeout=self.timeout)\n-        conn.connect()\n-        logger.debug("established connection to %s", host)\n-        return conn\n-\n     def getQueueAndWorker(self, url):\n         """Create or retrieve a queue and a worker thread instance for the\n         given URL.\n         """\n \n-        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)\n+        (scheme, host, path, params, query, fragment) = urlparse(url)\n         key = (host, scheme)\n         if key not in self.queues:\n             self.queueLock.acquire()\n             try:\n                 if key not in self.queues:\n-                    logger.debug("Creating worker thread for %s://%s",\n-                                 scheme, host)\n-                    assert key not in self.workers\n+                    logger.debug(\n+                        "Creating worker thread for %s://%s", scheme, host\n+                    )\n+                    if key in self.workers:\n+                        raise ValueError(\n+                            "Queue Key must not already exist in workers"\n+                        )\n                     self.queues[key] = queue_ = queue.Queue(self.backlog)\n                     self.workers[key] = worker = Worker(\n-                        queue_, host, scheme, self)\n+                        queue_, host, scheme, self\n+                    )\n                     worker.start()\n             finally:\n                 self.queueLock.release()\n         return self.queues[key], self.workers[key]\n \n-    def _purgeSync(self, conn, url, httpVerb):\n-        """Perform the purge request. Returns a triple\n-        ``(resp, xcache, xerror)`` where ``resp`` is the response object for\n-        the connection, ``xcache`` is the contents of the X-Cache header,\n-        and ``xerror`` is the contents of the first header found of the\n-        header list in ``self.errorHeaders``.\n-        """\n-\n-        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)  # noqa: E501\n-        __traceback_info__ = (url, httpVerb, scheme, host,\n-                              path, params, query, fragment)\n-\n-        if self.http_1_1:\n-            conn._http_vsn = 11\n-            conn._http_vsn_str = \'HTTP/1.1\'\n-        else:\n-            conn._http_vsn = 10\n-            conn._http_vsn_str = \'HTTP/1.0\'\n-            # When using HTTP 1.0, to make up for the lack of a \'Host\' header\n-            # we use the full url as the purge path, to allow for virtual\n-            # hosting in squid\n-            path = url\n-\n-        purge_path = urllib.parse.urlunparse(\n-            (\'\', \'\', path, params, query, fragment))\n-        logger.debug(\'making %s request to %s for %s.\',\n-                     httpVerb, host, purge_path)\n-        conn.putrequest(httpVerb, purge_path, skip_accept_encoding=True)\n-        conn.endheaders()\n-        resp = conn.getresponse()\n-\n-        xcache = resp.getheader(\'x-cache\', \'\')\n-        xerror = \'\'\n-        for header in self.errorHeaders:\n-            xerror = resp.getheader(header, \'\')\n-            if xerror:\n-                # Break on first found.\n-                break\n-        resp.read()\n-        logger.debug("%s of %s: %s %s",\n-                     httpVerb, url, resp.status, resp.reason)\n-        return resp, xcache, xerror\n+    @property\n+    def http_1_1(self):\n+        return True\n \n \n class Worker(threading.Thread):\n@@ -228,7 +171,8 @@ def __init__(self, queue, host, scheme, producer):\n         self.queue = queue\n         self.stopping = False\n         super(Worker, self).__init__(\n-            name="PurgeThread for %s://%s" % (scheme, host))\n+            name="PurgeThread for %s://%s" % (scheme, host)\n+        )\n \n     def stop(self):\n         self.stopping = True\n@@ -236,100 +180,53 @@ def stop(self):\n     def run(self):\n         logger.debug("%s starting", self)\n         # queue should always exist!\n-        q = self.producer.queues[(self.host, self.scheme)]\n-        connection = None\n+        current_queue = self.producer.queues[(self.host, self.scheme)]\n         atexit.register(self.stop)\n         try:\n-            while not self.stopping:\n-                item = q.get()\n-                if self.stopping or item is None:  # Shut down thread signal\n-                    logger.debug(\'Stopping worker thread for \'\n-                                 \'(%s, %s).\' % (self.host, self.scheme))\n-                    break\n-                url, httpVerb = item\n-\n-                # Loop handling errors (other than connection errors) doing\n-                # the actual purge.\n-                for i in range(5):\n-                    if self.stopping:\n+            with requests.Session() as session:\n+                while not self.stopping:\n+                    item = current_queue.get()\n+                    if self.stopping or item is None:\n+                        # Shut down thread signal\n+                        logger.debug(\n+                            "Stopping worker thread for "\n+                            "(%s, %s)." % (self.host, self.scheme)\n+                        )\n                         break\n-                    # Get a connection.\n-                    if connection is None:\n-                        connection = self.getConnection(url)\n-                        if connection is None:  # stopping\n+                    url, httpVerb = item\n+\n+                    # Loop handling errors (other than connection errors) doing\n+                    # the actual purge.\n+                    for i in range(5):\n+                        if self.stopping:\n+                            break\n+                        # Got an item, purge it!\n+                        try:\n+                            resp, msg, err = self.producer.purge(\n+                                session, url, httpVerb\n+                            )\n+                            # TODO: Check resp for errors,\n+                            # if all fine:\n+                            if resp.status_code == requests.codes.ok:\n+                                break  # all done with this item!\n+                        except Exception:\n+                            # All other exceptions are evil - we just disard\n+                            # the item.  This prevents other logic failures etc\n+                            # being retried.\n+                            logger.exception("Failed to purge %s", url)\n                             break\n-                    # Got an item, purge it!\n-                    try:\n-                        resp, msg, err = self.producer._purgeSync(\n-                            connection,\n-                            url,\n-                            httpVerb\n+                        logger.debug(\n+                            "Transient failure on %s for %s, "\n+                            "retrying: %s" % (httpVerb, url)\n                         )\n-                        # worked! See if we can leave the connection open for\n-                        # the next item we need to process\n-                        # NOTE: If we make a HTTP 1.0 request to IIS, it\n-                        # returns a HTTP 1.1 request and closes the\n-                        # connection.  It is not clear if IIS is evil for\n-                        # not returning a "connection: close" header in this\n-                        # case (ie, assuming HTTP 1.0 close semantics), or\n-                        # if http_client.py is evil for not detecting this\n-                        # situation and flagging will_close.\n-                        if not self.producer.http_1_1 or resp.will_close:\n-                            connection.close()\n-                            connection = None\n-                        break  # all done with this item!\n \n-                    except (http_client.HTTPException, socket.error) as e:\n-                        # All errors \'connection\' related errors are treated\n-                        # the same - simply drop the connection and retry.\n-                        # the process for establishing the connection handles\n-                        # other bad things that go wrong.\n-                        logger.debug(\'Transient failure on %s for %s, \'\n-                                     \'re-establishing connection and \'\n-                                     \'retrying: %s\' % (httpVerb, url, e))\n-                        connection.close()\n-                        connection = None\n-                    except Exception:\n-                        # All other exceptions are evil - we just disard the\n-                        # item.  This prevents other logic failures etc being\n-                        # retried.\n-                        connection.close()\n-                        connection = None\n-                        logger.exception(\'Failed to purge %s\', url)\n-                        break\n-        except:\n-            logger.exception(\'Exception in worker thread \'\n-                             \'for (%s, %s)\' % (self.host, self.scheme))\n+        except Exception:\n+            logger.exception(\n+                "Exception in worker thread "\n+                "for (%s, %s)" % (self.host, self.scheme)\n+            )\n         logger.debug("%s terminating", self)\n \n-    def getConnection(self, url):\n-        """Get a connection to the given URL.\n-\n-        Blocks until either a connection is established, or we are asked to\n-        shut-down. Includes a simple strategy for slowing down the retry rate,\n-        retrying from 5 seconds to 20 seconds until the connection appears or\n-        we waited a full minute.\n-        """\n-        wait_time = 2.5\n-        while not self.stopping:\n-            try:\n-                return self.producer.getConnection(url)\n-            except socket.error as e:\n-                wait_time = int(min(wait_time * 2, 21))\n-                if wait_time > 20:\n-                    # we waited a full minute, we assume a permanent failure\n-                    logger.debug("Error %s connecting to %s - reconnect "\n-                                 "failed.", e, url)\n-                    self.stopping = True\n-                    break\n-                logger.debug("Error %s connecting to %s - will "\n-                             "retry in %d second(s)", e, url, wait_time)\n-                for i in range(wait_time):\n-                    if self.stopping:\n-                        break\n-                    time.sleep(1)\n-        return None  # must be stopping!\n-\n \n DEFAULT_PURGER = DefaultPurger()\n \ndiff --git a/plone/cachepurging/rewrite.py b/plone/cachepurging/rewrite.py\nindex 0be3121..a3424f8 100644\n--- a/plone/cachepurging/rewrite.py\n+++ b/plone/cachepurging/rewrite.py\n@@ -22,7 +22,7 @@ def __call__(self, path):\n         request = self.request\n \n         # No rewriting necessary\n-        virtualURL = request.get(\'VIRTUAL_URL\', None)\n+        virtualURL = request.get("VIRTUAL_URL", None)\n         if virtualURL is None:\n             return [path]\n \n@@ -39,17 +39,17 @@ def __call__(self, path):\n             return [path]\n \n         # We need to reconstruct VHM URLs for each of the domains\n-        virtualUrlParts = request.get(\'VIRTUAL_URL_PARTS\')\n-        virtualRootPhysicalPath = request.get(\'VirtualRootPhysicalPath\')\n+        virtualUrlParts = request.get("VIRTUAL_URL_PARTS")\n+        virtualRootPhysicalPath = request.get("VirtualRootPhysicalPath")\n \n         # Make sure request is compliant\n         if (\n-            not virtualUrlParts or\n-            not virtualRootPhysicalPath or\n-            not isinstance(virtualUrlParts, (list, tuple,)) or\n-            not isinstance(virtualRootPhysicalPath, (list, tuple,)) or\n-            len(virtualUrlParts) < 2 or\n-            len(virtualUrlParts) > 3\n+            not virtualUrlParts\n+            or not virtualRootPhysicalPath\n+            or not isinstance(virtualUrlParts, (list, tuple))\n+            or not isinstance(virtualRootPhysicalPath, (list, tuple))\n+            or len(virtualUrlParts) < 2\n+            or len(virtualUrlParts) > 3\n         ):\n             return [path]\n \n@@ -58,31 +58,33 @@ def __call__(self, path):\n             domains = [virtualUrlParts[0]]\n \n         # Virtual root, e.g. /Plone. Clear if we don\'t have any virtual root\n-        virtualRoot = \'/\'.join(virtualRootPhysicalPath)\n-        if virtualRoot == \'/\':\n-            virtualRoot = \'\'\n+        virtualRoot = "/".join(virtualRootPhysicalPath)\n+        if virtualRoot == "/":\n+            virtualRoot = ""\n \n         # Prefix, e.g. /_vh_foo/_vh_bar. Clear if we don\'t have any.\n-        pathPrefix = len(virtualUrlParts) == 3 and virtualUrlParts[1] or \'\'\n+        pathPrefix = len(virtualUrlParts) == 3 and virtualUrlParts[1] or ""\n         if pathPrefix:\n-            pathPrefix = \'/\' + \\\n-                \'/\'.join([\'_vh_%s\' % p for p in pathPrefix.split(\'/\')])\n+            pathPrefix = "/" + "/".join(\n+                ["_vh_%s" % p for p in pathPrefix.split("/")]\n+            )\n \n         # Path, e.g. /front-page\n-        if len(path) > 0 and not path.startswith(\'/\'):\n-            path = \'/\' + path\n+        if len(path) > 0 and not path.startswith("/"):\n+            path = "/" + path\n \n         paths = []\n         for domain in domains:\n             scheme, host = urllib.parse.urlparse(domain)[:2]\n             paths.append(\n-                \'/VirtualHostBase/%(scheme)s/%(host)s%(root)s/\'\n-                \'VirtualHostRoot%(prefix)s%(path)s\' % {\n-                    \'scheme\': scheme,\n-                    \'host\': host,\n-                    \'root\': virtualRoot,\n-                    \'prefix\': pathPrefix,\n-                    \'path\': path\n+                "/VirtualHostBase/%(scheme)s/%(host)s%(root)s/"\n+                "VirtualHostRoot%(prefix)s%(path)s"\n+                % {\n+                    "scheme": scheme,\n+                    "host": host,\n+                    "root": virtualRoot,\n+                    "prefix": pathPrefix,\n+                    "path": path,\n                 }\n             )\n         return paths\ndiff --git a/plone/cachepurging/tests/test_hooks.py b/plone/cachepurging/tests/test_hooks.py\nindex 13fdc8f..8e7fb94 100644\n--- a/plone/cachepurging/tests/test_hooks.py\n+++ b/plone/cachepurging/tests/test_hooks.py\n@@ -34,7 +34,6 @@ class FauxRequest(dict):\n \n \n class TestQueueHandler(unittest.TestCase):\n-\n     def setUp(self):\n         provideAdapter(AttributeAnnotations)\n         provideAdapter(persistentFieldAdapter)\n@@ -53,17 +52,16 @@ def test_no_request(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n                 return []\n@@ -87,17 +85,16 @@ def test_request_not_annotatable(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n                 return []\n@@ -119,12 +116,11 @@ def test_no_registry(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n                 return []\n@@ -148,17 +144,16 @@ def test_caching_disabled(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = False\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n                 return []\n@@ -182,12 +177,13 @@ def test_enabled_no_paths(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         notify(Purge(context))\n \n-        self.assertEqual({\'plone.cachepurging.urls\': set()},\n-                         dict(IAnnotations(request)))\n+        self.assertEqual(\n+            {"plone.cachepurging.urls": set()}, dict(IAnnotations(request))\n+        )\n \n     def test_enabled(self):\n         context = FauxContext()\n@@ -202,17 +198,16 @@ def test_enabled(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n                 return []\n@@ -221,12 +216,13 @@ def getAbsolutePaths(self):\n \n         notify(Purge(context))\n \n-        self.assertEqual({\'plone.cachepurging.urls\': set([\'/foo\', \'/bar\'])},\n-                         dict(IAnnotations(request)))\n+        self.assertEqual(\n+            {"plone.cachepurging.urls": set(["/foo", "/bar"])},\n+            dict(IAnnotations(request)),\n+        )\n \n \n class TestPurgeHandler(unittest.TestCase):\n-\n     def setUp(self):\n         provideAdapter(AttributeAnnotations)\n         provideAdapter(persistentFieldAdapter)\n@@ -244,15 +240,14 @@ def test_request_not_annotatable(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n             def __init__(self):\n                 self.purged = []\n \n-            def purgeAsync(self, url, httpVerb=\'PURGE\'):\n+            def purgeAsync(self, url, httpVerb="PURGE"):\n                 self.purged.append(url)\n \n         purger = FauxPurger()\n@@ -272,15 +267,14 @@ def test_no_path_key(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n             def __init__(self):\n                 self.purged = []\n \n-            def purgeAsync(self, url, httpVerb=\'PURGE\'):\n+            def purgeAsync(self, url, httpVerb="PURGE"):\n                 self.purged.append(url)\n \n         purger = FauxPurger()\n@@ -294,7 +288,7 @@ def test_no_paths(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)[\'plone.cachepurging.urls\'] = set()\n+        IAnnotations(request)["plone.cachepurging.urls"] = set()\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -302,15 +296,14 @@ def test_no_paths(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n             def __init__(self):\n                 self.purged = []\n \n-            def purgeAsync(self, url, httpVerb=\'PURGE\'):\n+            def purgeAsync(self, url, httpVerb="PURGE"):\n                 self.purged.append(url)\n \n         purger = FauxPurger()\n@@ -324,16 +317,16 @@ def test_no_registry(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)[\'plone.cachepurging.urls\'] = set(\n-            [\'/foo\', \'/bar\'])\n+        IAnnotations(request)["plone.cachepurging.urls"] = set(\n+            ["/foo", "/bar"]\n+        )\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n             def __init__(self):\n                 self.purged = []\n \n-            def purgeAsync(self, url, httpVerb=\'PURGE\'):\n+            def purgeAsync(self, url, httpVerb="PURGE"):\n                 self.purged.append(url)\n \n         purger = FauxPurger()\n@@ -347,8 +340,9 @@ def test_caching_disabled(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)[\'plone.cachepurging.urls\'] = set(\n-            [\'/foo\', \'/bar\'])\n+        IAnnotations(request)["plone.cachepurging.urls"] = set(\n+            ["/foo", "/bar"]\n+        )\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -356,15 +350,14 @@ def test_caching_disabled(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = False\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n             def __init__(self):\n                 self.purged = []\n \n-            def purgeAsync(self, url, httpVerb=\'PURGE\'):\n+            def purgeAsync(self, url, httpVerb="PURGE"):\n                 self.purged.append(url)\n \n         purger = FauxPurger()\n@@ -378,8 +371,9 @@ def test_no_purger(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)[\'plone.cachepurging.urls\'] = set(\n-            [\'/foo\', \'/bar\'])\n+        IAnnotations(request)["plone.cachepurging.urls"] = set(\n+            ["/foo", "/bar"]\n+        )\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -387,7 +381,7 @@ def test_no_purger(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         try:\n             notify(PubSuccess(request))\n@@ -398,8 +392,9 @@ def test_purge(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)[\'plone.cachepurging.urls\'] = set(\n-            [\'/foo\', \'/bar\'])\n+        IAnnotations(request)["plone.cachepurging.urls"] = set(\n+            ["/foo", "/bar"]\n+        )\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -407,15 +402,14 @@ def test_purge(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n             def __init__(self):\n                 self.purged = []\n \n-            def purgeAsync(self, url, httpVerb=\'PURGE\'):\n+            def purgeAsync(self, url, httpVerb="PURGE"):\n                 self.purged.append(url)\n \n         purger = FauxPurger()\n@@ -423,7 +417,7 @@ def purgeAsync(self, url, httpVerb=\'PURGE\'):\n \n         notify(PubSuccess(request))\n         self.assertSetEqual(\n-            {\'http://localhost:1234/foo\', \'http://localhost:1234/bar\'},\n+            {"http://localhost:1234/foo", "http://localhost:1234/bar"},\n             set(purger.purged),\n         )\n \ndiff --git a/plone/cachepurging/tests/test_purger.py b/plone/cachepurging/tests/test_purger.py\nindex aec27d2..0be4ea4 100644\n--- a/plone/cachepurging/tests/test_purger.py\n+++ b/plone/cachepurging/tests/test_purger.py\n@@ -16,14 +16,10 @@\n \n # Define a test HTTP server that returns canned responses\n \n-SERVER_PORT = int(os.environ.get(\'ZSERVER_PORT\', 8765))\n+SERVER_PORT = int(os.environ.get("ZSERVER_PORT", 8765))\n \n \n class TestHandler(BaseHTTPRequestHandler):\n-\n-    def log_message(self, format, *args):\n-        pass\n-\n     def do_PURGE(self):\n         # Get the pre-defined response from the server\'s queue.\n         try:\n@@ -33,39 +29,38 @@ def do_PURGE(self):\n             print(self.command, self.path, self.protocol_version)\n             for h, v in self.headers.items():\n                 print("%s: %s" % (h, v))\n-            raise RuntimeError(\'Unexpected connection\')\n+            raise RuntimeError("Unexpected connection")\n \n         # We may have a function to call to check things.\n-        validator = nr.get(\'validator\')\n+        validator = nr.get("validator")\n         if validator:\n             validator(self)\n \n         # We may have to wake up some other code now the test connection\n         # has been made, but before the response is sent.\n-        waiter = nr.get(\'waiter\')\n+        waiter = nr.get("waiter")\n         if waiter:\n             waiter.acquire()\n             waiter.release()\n \n         # for now, response=None means simulate an unexpected error.\n-        if nr[\'response\'] is None:\n+        if nr["response"] is None:\n             self.rfile.close()\n             return\n \n         # Send the response.\n-        self.send_response(nr[\'response\'])\n-        headers = nr.get(\'headers\', None)\n+        self.send_response(nr["response"])\n+        headers = nr.get("headers", None)\n         if headers:\n             for h, v in headers.items():\n                 self.send_header(h, v)\n-        data = nr.get(\'data\', b\'\')\n+        data = nr.get("data", b"")\n         self.send_header("Content-Length", len(data))\n         self.end_headers()\n         self.wfile.write(data)\n \n \n class TestHTTPServer(HTTPServer):\n-\n     def __init__(self, address, handler):\n         HTTPServer.__init__(self, address, handler)\n         self.response_queue = queue.Queue()\n@@ -73,11 +68,11 @@ def __init__(self, address, handler):\n     def queue_response(self, **kw):\n         self.response_queue.put(kw)\n \n+\n # Finally the test suites.\n \n \n class TestCase(unittest.TestCase):\n-\n     def setUp(self):\n         self.purger = DefaultPurger()\n         self.httpd, self.httpt = self.startServer()\n@@ -91,8 +86,10 @@ def tearDown(self):\n                     if self.httpd.response_queue.empty():\n                         break\n                     time.sleep(0.1)\n-                self.assertTrue(self.httpd.response_queue.empty(),\n-                                "response queue not consumed")\n+                self.assertTrue(\n+                    self.httpd.response_queue.empty(),\n+                    "response queue not consumed",\n+                )\n             if not self.purger.stopThreads(wait=True):\n                 self.fail("The purge threads did not stop")\n         finally:\n@@ -112,7 +109,7 @@ def startServer(self, port=SERVER_PORT, start=True):\n         """Start a TestHTTPServer in a separate thread, returning a tuple\n         (server, thread). If start is true, the thread is started.\n         """\n-        server_address = (\'localhost\', port)\n+        server_address = ("localhost", port)\n         httpd = TestHTTPServer(server_address, TestHandler)\n         t = threading.Thread(target=httpd.serve_forever)\n         if start:\n@@ -121,7 +118,6 @@ def startServer(self, port=SERVER_PORT, start=True):\n \n \n class TestSync(TestCase):\n-\n     def setUp(self):\n         super(TestSync, self).setUp()\n         self.purger.http_1_1 = True\n@@ -137,33 +133,29 @@ def dispatchURL(self, path, method="PURGE", port=SERVER_PORT):\n     def testSimpleSync(self):\n         self.httpd.queue_response(response=200)\n         resp = self.dispatchURL("/foo")\n-        self.assertEqual((200, \'\', \'\'), resp)\n+        self.assertEqual((200, "", ""), resp)\n \n     def testHeaders(self):\n-        headers = {\'X-Squid-Error\': \'error text\',\n-                   \'X-Cache\': \'a message\',\n-                   }\n+        headers = {"X-Squid-Error": "error text", "X-Cache": "a message"}\n         self.httpd.queue_response(response=200, headers=headers)\n         status, msg, err = self.dispatchURL("/foo")\n-        self.assertEqual(msg, \'a message\')\n-        self.assertEqual(err, \'error text\')\n+        self.assertEqual(msg, "a message")\n+        self.assertEqual(err, "error text")\n         self.assertEqual(status, 200)\n \n     def testError(self):\n         self.httpd.queue_response(response=None)\n         status, msg, err = self.dispatchURL("/foo")\n-        self.assertEqual(status, \'ERROR\')\n+        self.assertEqual(status, "ERROR")\n \n \n class TestSyncHTTP10(TestSync):\n-\n     def setUp(self):\n         super(TestSync, self).setUp()\n         self.purger.http_1_1 = False\n \n \n class TestAsync(TestCase):\n-\n     def dispatchURL(self, path, method="PURGE", port=SERVER_PORT):\n         url = "http://localhost:%s%s" % (port, path)\n         self.purger.purgeAsync(url, method)\n@@ -195,7 +187,6 @@ def testAsyncError(self):\n \n \n class TestAsyncConnectionFailure(TestCase):\n-\n     def setUp(self):\n         # Override setup to not start the server immediately\n         self.purger = DefaultPurger()\ndiff --git a/plone/cachepurging/tests/test_rewrite.py b/plone/cachepurging/tests/test_rewrite.py\nindex 238bc26..49e5193 100644\n--- a/plone/cachepurging/tests/test_rewrite.py\n+++ b/plone/cachepurging/tests/test_rewrite.py\n@@ -16,7 +16,6 @@ class FauxRequest(dict):\n \n \n class TestRewrite(unittest.TestCase):\n-\n     def setUp(self):\n         self.request = FauxRequest()\n         self.rewriter = DefaultRewriter(self.request)\n@@ -28,43 +27,51 @@ def tearDown(self):\n     def _prepareVHMRequest(\n         self,\n         path,\n-        domain=\'example.com\',\n-        root=\'/plone\',\n-        prefix=\'\',\n-        protocol=\'http\'\n+        domain="example.com",\n+        root="/plone",\n+        prefix="",\n+        protocol="http",\n     ):\n-        translatedPrefix = \'/\'.join([\'_vh_%s\' % p for p in prefix.split(\'/\')])\n-\n-        self.request[\'URL\'] = \'%s://%s%s%s\' % (protocol, domain, prefix, path,)\n-        self.request[\n-            \'ACTUAL_URL\'] = \'%s://%s%s%s\' % (protocol, domain, prefix, path,)\n-        self.request[\'SERVER_URL\'] = \'%s://%s\' % (protocol, domain,)\n-        self.request[\'PATH_INFO\'] = (\n-            \'/VirtualHostBase/%s/%s:80%s/\'\n-            \'VirtualHostRoot%s%s\' % (\n-                protocol, domain, root, translatedPrefix, path,\n-            )\n+        translatedPrefix = "/".join(["_vh_%s" % p for p in prefix.split("/")])\n+\n+        self.request["URL"] = "%s://%s%s%s" % (protocol, domain, prefix, path)\n+        self.request["ACTUAL_URL"] = "%s://%s%s%s" % (\n+            protocol,\n+            domain,\n+            prefix,\n+            path,\n+        )\n+        self.request["SERVER_URL"] = "%s://%s" % (protocol, domain)\n+        self.request["PATH_INFO"] = (\n+            "/VirtualHostBase/%s/%s:80%s/"\n+            "VirtualHostRoot%s%s"\n+            % (protocol, domain, root, translatedPrefix, path)\n         )\n-        self.request[\'VIRTUAL_URL\'] = \'%s://%s%s\' % (protocol, domain, path)\n+        self.request["VIRTUAL_URL"] = "%s://%s%s" % (protocol, domain, path)\n \n         if prefix:\n-            self.request[\'VIRTUAL_URL_PARTS\'] = (\n-                \'%s://%s\' % (protocol, domain,), prefix[1:], path[1:])\n+            self.request["VIRTUAL_URL_PARTS"] = (\n+                "%s://%s" % (protocol, domain),\n+                prefix[1:],\n+                path[1:],\n+            )\n         else:\n-            self.request[\'VIRTUAL_URL_PARTS\'] = (\n-                \'%s://%s\' % (protocol, domain,), path[1:])\n+            self.request["VIRTUAL_URL_PARTS"] = (\n+                "%s://%s" % (protocol, domain),\n+                path[1:],\n+            )\n \n-        self.request[\'VirtualRootPhysicalPath\'] = tuple(root.split(\'/\'))\n+        self.request["VirtualRootPhysicalPath"] = tuple(root.split("/"))\n \n     def test_no_registry(self):\n-        self._prepareVHMRequest(\'/foo\')\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self._prepareVHMRequest("/foo")\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_no_settings(self):\n         registry = Registry()\n         provideUtility(registry, IRegistry)\n-        self._prepareVHMRequest(\'/foo\')\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self._prepareVHMRequest("/foo")\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_virtual_hosting_disabled(self):\n         registry = Registry()\n@@ -73,8 +80,8 @@ def test_virtual_hosting_disabled(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = False\n \n-        self._prepareVHMRequest(\'/foo\')\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self._prepareVHMRequest("/foo")\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_empty_request(self):\n         registry = Registry()\n@@ -84,7 +91,7 @@ def test_empty_request(self):\n         settings.virtualHosting = True\n \n         self.request.clear()\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_no_virtual_url(self):\n         registry = Registry()\n@@ -93,9 +100,9 @@ def test_no_virtual_url(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\')\n-        del self.request[\'VIRTUAL_URL\']\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self._prepareVHMRequest("/foo")\n+        del self.request["VIRTUAL_URL"]\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_no_virtual_url_parts(self):\n         registry = Registry()\n@@ -104,9 +111,9 @@ def test_no_virtual_url_parts(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\')\n-        del self.request[\'VIRTUAL_URL_PARTS\']\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self._prepareVHMRequest("/foo")\n+        del self.request["VIRTUAL_URL_PARTS"]\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_no_virtual_root_physical_path(self):\n         registry = Registry()\n@@ -115,9 +122,9 @@ def test_no_virtual_root_physical_path(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\')\n-        del self.request[\'VirtualRootPhysicalPath\']\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self._prepareVHMRequest("/foo")\n+        del self.request["VirtualRootPhysicalPath"]\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_malformed_virtual_url_parts(self):\n         registry = Registry()\n@@ -126,20 +133,24 @@ def test_malformed_virtual_url_parts(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\')\n+        self._prepareVHMRequest("/foo")\n \n-        self.request[\'VIRTUAL_URL_PARTS\'] = (\'foo\',)\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self.request["VIRTUAL_URL_PARTS"] = ("foo",)\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n-        self.request[\'VIRTUAL_URL_PARTS\'] = ()\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self.request["VIRTUAL_URL_PARTS"] = ()\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n-        self.request[\'VIRTUAL_URL_PARTS\'] = (\n-            \'http://example.com\', \'\', \'/foo\', \'x\')\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self.request["VIRTUAL_URL_PARTS"] = (\n+            "http://example.com",\n+            "",\n+            "/foo",\n+            "x",\n+        )\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n-        self.request[\'VIRTUAL_URL_PARTS\'] = \'foo\'\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self.request["VIRTUAL_URL_PARTS"] = "foo"\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_standard_vhm(self):\n         registry = Registry()\n@@ -148,10 +159,10 @@ def test_standard_vhm(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\')\n+        self._prepareVHMRequest("/foo")\n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/plone/VirtualHostRoot/foo\'],\n-            self.rewriter(\'/foo\')\n+            ["/VirtualHostBase/http/example.com/plone/VirtualHostRoot/foo"],\n+            self.rewriter("/foo"),\n         )\n \n     def test_virtual_root_is_app_root(self):\n@@ -161,11 +172,11 @@ def test_virtual_root_is_app_root(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\', root=\'/\')\n+        self._prepareVHMRequest("/foo", root="/")\n \n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/VirtualHostRoot/foo\'],\n-            self.rewriter(\'/foo\')\n+            ["/VirtualHostBase/http/example.com/VirtualHostRoot/foo"],\n+            self.rewriter("/foo"),\n         )\n \n     def test_virtual_root_is_deep(self):\n@@ -175,12 +186,14 @@ def test_virtual_root_is_deep(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\', root=\'/bar/plone\')\n+        self._prepareVHMRequest("/foo", root="/bar/plone")\n \n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/bar/plone/\'\n-             \'VirtualHostRoot/foo\'],\n-            self.rewriter(\'/foo\')\n+            [\n+                "/VirtualHostBase/http/example.com/bar/plone/"\n+                "VirtualHostRoot/foo"\n+            ],\n+            self.rewriter("/foo"),\n         )\n \n     def test_inside_out_hosting(self):\n@@ -190,12 +203,15 @@ def test_inside_out_hosting(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\', root=\'/bar/plone\', prefix=\'/foo/bar\')\n+        self._prepareVHMRequest("/foo", root="/bar/plone", prefix="/foo/bar")\n \n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/bar/plone/\'\n-             \'VirtualHostRoot/_vh_foo/_vh_bar/foo\'],\n-            self.rewriter(\'/foo\'))\n+            [\n+                "/VirtualHostBase/http/example.com/bar/plone/"\n+                "VirtualHostRoot/_vh_foo/_vh_bar/foo"\n+            ],\n+            self.rewriter("/foo"),\n+        )\n \n     def test_inside_out_hosting_root_empty_path(self):\n         registry = Registry()\n@@ -204,12 +220,15 @@ def test_inside_out_hosting_root_empty_path(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/\', root=\'/plone\', prefix=\'/plone\')\n+        self._prepareVHMRequest("/", root="/plone", prefix="/plone")\n \n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/plone/\'\n-             \'VirtualHostRoot/_vh_plone\'],\n-            self.rewriter(\'\'))\n+            [\n+                "/VirtualHostBase/http/example.com/plone/"\n+                "VirtualHostRoot/_vh_plone"\n+            ],\n+            self.rewriter(""),\n+        )\n \n     def test_virtual_path_is_root(self):\n         registry = Registry()\n@@ -218,11 +237,11 @@ def test_virtual_path_is_root(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/\', root=\'/plone\')\n+        self._prepareVHMRequest("/", root="/plone")\n \n-        self.assertEqual([\n-            \'/VirtualHostBase/http/example.com/plone/VirtualHostRoot/\'],\n-            self.rewriter(\'/\')\n+        self.assertEqual(\n+            ["/VirtualHostBase/http/example.com/plone/VirtualHostRoot/"],\n+            self.rewriter("/"),\n         )\n \n     def test_virtual_path_is_empty(self):\n@@ -232,11 +251,11 @@ def test_virtual_path_is_empty(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'\', root=\'/plone\')\n+        self._prepareVHMRequest("", root="/plone")\n \n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/plone/VirtualHostRoot\'],\n-            self.rewriter(\'\')\n+            ["/VirtualHostBase/http/example.com/plone/VirtualHostRoot"],\n+            self.rewriter(""),\n         )\n \n     def test_virtual_path_is_deep(self):\n@@ -246,12 +265,14 @@ def test_virtual_path_is_deep(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo/bar\', root=\'/plone\')\n+        self._prepareVHMRequest("/foo/bar", root="/plone")\n \n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/plone/\'\n-             \'VirtualHostRoot/foo/bar\'],\n-            self.rewriter(\'/foo/bar\')\n+            [\n+                "/VirtualHostBase/http/example.com/plone/"\n+                "VirtualHostRoot/foo/bar"\n+            ],\n+            self.rewriter("/foo/bar"),\n         )\n \n     def test_nonstandard_port(self):\n@@ -261,10 +282,10 @@ def test_nonstandard_port(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\', domain=\'example.com:81\')\n+        self._prepareVHMRequest("/foo", domain="example.com:81")\n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com:81/plone/VirtualHostRoot/foo\'],\n-            self.rewriter(\'/foo\')\n+            ["/VirtualHostBase/http/example.com:81/plone/VirtualHostRoot/foo"],\n+            self.rewriter("/foo"),\n         )\n \n     def test_https(self):\n@@ -275,11 +296,14 @@ def test_https(self):\n         settings.virtualHosting = True\n \n         self._prepareVHMRequest(\n-            \'/foo\', domain=\'example.com:81\', protocol=\'https\')\n+            "/foo", domain="example.com:81", protocol="https"\n+        )\n         self.assertEqual(\n-            [\'/VirtualHostBase/https/example.com:81/plone/\'\n-             \'VirtualHostRoot/foo\'],\n-            self.rewriter(\'/foo\')\n+            [\n+                "/VirtualHostBase/https/example.com:81/plone/"\n+                "VirtualHostRoot/foo"\n+            ],\n+            self.rewriter("/foo"),\n         )\n \n     def test_domains(self):\n@@ -288,18 +312,19 @@ def test_domains(self):\n         registry.registerInterface(ICachePurgingSettings)\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n-        settings.domains = (\'http://example.org:81\', \'https://example.com:82\')\n+        settings.domains = ("http://example.org:81", "https://example.com:82")\n \n         self._prepareVHMRequest(\n-            \'/foo\', domain=\'example.com:81\', protocol=\'https\')\n+            "/foo", domain="example.com:81", protocol="https"\n+        )\n         self.assertEqual(\n             [\n-                \'/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/\'\n-                \'foo\',\n-                \'/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/\'\n-                \'foo\'\n+                "/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/"\n+                "foo",\n+                "/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/"\n+                "foo",\n             ],\n-            self.rewriter(\'/foo\')\n+            self.rewriter("/foo"),\n         )\n \n     def test_domains_w_different_path_in_request(self):\n@@ -308,18 +333,19 @@ def test_domains_w_different_path_in_request(self):\n         registry.registerInterface(ICachePurgingSettings)\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n-        settings.domains = (\'http://example.org:81\', \'https://example.com:82\')\n+        settings.domains = ("http://example.org:81", "https://example.com:82")\n \n         self._prepareVHMRequest(\n-            \'/bar\', domain=\'example.com:81\', protocol=\'https\')\n+            "/bar", domain="example.com:81", protocol="https"\n+        )\n         self.assertEqual(\n             [\n-                \'/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/\'\n-                \'foo\',\n-                \'/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/\'\n-                \'foo\'\n+                "/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/"\n+                "foo",\n+                "/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/"\n+                "foo",\n             ],\n-            self.rewriter(\'/foo\')\n+            self.rewriter("/foo"),\n         )\n \n \ndiff --git a/plone/cachepurging/tests/test_traversable_paths.py b/plone/cachepurging/tests/test_traversable_paths.py\nindex cb5fcec..06fd19a 100644\n--- a/plone/cachepurging/tests/test_traversable_paths.py\n+++ b/plone/cachepurging/tests/test_traversable_paths.py\n@@ -8,19 +8,17 @@\n \n @implementer(ITraversable)\n class FauxTraversable(object):\n-\n     def virtual_url_path(self):\n-        return \'foo\'\n+        return "foo"\n \n \n class TestTraversablePaths(unittest.TestCase):\n-\n     def test_traversable_paths(self):\n \n         context = FauxTraversable()\n         paths = TraversablePurgePaths(context)\n \n-        self.assertEqual([\'/foo\'], paths.getRelativePaths())\n+        self.assertEqual(["/foo"], paths.getRelativePaths())\n         self.assertEqual([], paths.getAbsolutePaths())\n \n \ndiff --git a/plone/cachepurging/tests/test_utils.py b/plone/cachepurging/tests/test_utils.py\nindex 89a3ce3..73b3dfb 100644\n--- a/plone/cachepurging/tests/test_utils.py\n+++ b/plone/cachepurging/tests/test_utils.py\n@@ -24,7 +24,6 @@ class FauxRequest(dict):\n \n \n class TestIsCachingEnabled(unittest.TestCase):\n-\n     def setUp(self):\n         provideAdapter(persistentFieldAdapter)\n \n@@ -70,7 +69,6 @@ def test_passed_registry(self):\n \n \n class TestGetPathsToPurge(unittest.TestCase):\n-\n     def setUp(self):\n         self.context = FauxContext()\n         self.request = FauxRequest()\n@@ -80,14 +78,13 @@ def tearDown(self):\n \n     def test_no_purge_paths(self):\n         self.assertEqual(\n-            [], list(utils.getPathsToPurge(self.context, self.request)))\n+            [], list(utils.getPathsToPurge(self.context, self.request))\n+        )\n \n     def test_empty_relative_paths(self):\n-\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n@@ -100,153 +97,146 @@ def getAbsolutePaths(self):\n         provideAdapter(FauxPurgePaths, name="test1")\n \n         self.assertEqual(\n-            [], list(utils.getPathsToPurge(self.context, self.request)))\n+            [], list(utils.getPathsToPurge(self.context, self.request))\n+        )\n \n     def test_no_rewriter(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n-                return [\'/baz\']\n+                return ["/baz"]\n \n         provideAdapter(FauxPurgePaths, name="test1")\n \n-        self.assertEqual([\'/foo\', \'/bar\', \'/baz\'],\n-                         list(utils.getPathsToPurge(self.context, self.request)))\n+        self.assertEqual(\n+            ["/foo", "/bar", "/baz"],\n+            list(utils.getPathsToPurge(self.context, self.request)),\n+        )\n \n     def test_test_rewriter(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n-                return [\'/baz\']\n+                return ["/baz"]\n \n         provideAdapter(FauxPurgePaths, name="test1")\n \n         @implementer(IPurgePathRewriter)\n         @adapter(FauxRequest)\n         class DefaultRewriter(object):\n-\n             def __init__(self, request):\n                 self.request = request\n \n             def __call__(self, path):\n-                return [\'/vhm1\' + path, \'/vhm2\' + path]\n+                return ["/vhm1" + path, "/vhm2" + path]\n \n         provideAdapter(DefaultRewriter)\n \n-        self.assertEqual([\'/vhm1/foo\', \'/vhm2/foo\',\n-                          \'/vhm1/bar\', \'/vhm2/bar\',\n-                          \'/baz\'],\n-                         list(utils.getPathsToPurge(self.context, self.request)))\n+        self.assertEqual(\n+            ["/vhm1/foo", "/vhm2/foo", "/vhm1/bar", "/vhm2/bar", "/baz"],\n+            list(utils.getPathsToPurge(self.context, self.request)),\n+        )\n \n     def test_multiple_purge_paths(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths1(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n-                return [\'/baz\']\n+                return ["/baz"]\n \n         provideAdapter(FauxPurgePaths1, name="test1")\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths2(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo/view\']\n+                return ["/foo/view"]\n \n             def getAbsolutePaths(self):\n-                return [\'/quux\']\n+                return ["/quux"]\n \n         provideAdapter(FauxPurgePaths2, name="test2")\n \n         @implementer(IPurgePathRewriter)\n         @adapter(FauxRequest)\n         class DefaultRewriter(object):\n-\n             def __init__(self, request):\n                 self.request = request\n \n             def __call__(self, path):\n-                return [\'/vhm1\' + path, \'/vhm2\' + path]\n+                return ["/vhm1" + path, "/vhm2" + path]\n \n         provideAdapter(DefaultRewriter)\n \n         self.assertEqual(\n             [\n-                \'/vhm1/foo\',\n-                \'/vhm2/foo\',\n-                \'/vhm1/bar\',\n-                \'/vhm2/bar\',\n-                \'/baz\',\n-                \'/vhm1/foo/view\',\n-                \'/vhm2/foo/view\',\n-                \'/quux\'\n+                "/vhm1/foo",\n+                "/vhm2/foo",\n+                "/vhm1/bar",\n+                "/vhm2/bar",\n+                "/baz",\n+                "/vhm1/foo/view",\n+                "/vhm2/foo/view",\n+                "/quux",\n             ],\n-            list(utils.getPathsToPurge(self.context, self.request))\n+            list(utils.getPathsToPurge(self.context, self.request)),\n         )\n \n     def test_rewriter_abort(self):\n-\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths1(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n-                return [\'/baz\']\n+                return ["/baz"]\n \n         provideAdapter(FauxPurgePaths1, name="test1")\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths2(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo/view\']\n+                return ["/foo/view"]\n \n             def getAbsolutePaths(self):\n-                return [\'/quux\']\n+                return ["/quux"]\n \n         provideAdapter(FauxPurgePaths2, name="test2")\n \n         @implementer(IPurgePathRewriter)\n         @adapter(FauxRequest)\n         class DefaultRewriter(object):\n-\n             def __init__(self, request):\n                 self.request = request\n \n@@ -256,36 +246,35 @@ def __call__(self, path):\n         provideAdapter(DefaultRewriter)\n \n         self.assertEqual(\n-            [\'/baz\', \'/quux\'],\n-            list(utils.getPathsToPurge(self.context, self.request))\n+            ["/baz", "/quux"],\n+            list(utils.getPathsToPurge(self.context, self.request)),\n         )\n \n \n class TestGetURLsToPurge(unittest.TestCase):\n-\n     def test_no_proxies(self):\n-        self.assertEqual([], list(utils.getURLsToPurge(\'/foo\', [])))\n+        self.assertEqual([], list(utils.getURLsToPurge("/foo", [])))\n \n     def test_absolute_path(self):\n         self.assertEqual(\n-            [\'http://localhost:1234/foo/bar\', \'http://localhost:2345/foo/bar\'],\n+            ["http://localhost:1234/foo/bar", "http://localhost:2345/foo/bar"],\n             list(\n                 utils.getURLsToPurge(\n-                    \'/foo/bar\',\n-                    [\'http://localhost:1234\', \'http://localhost:2345/\']\n+                    "/foo/bar",\n+                    ["http://localhost:1234", "http://localhost:2345/"],\n                 )\n-            )\n+            ),\n         )\n \n     def test_relative_path(self):\n         self.assertEqual(\n-            [\'http://localhost:1234/foo/bar\', \'http://localhost:2345/foo/bar\'],\n+            ["http://localhost:1234/foo/bar", "http://localhost:2345/foo/bar"],\n             list(\n                 utils.getURLsToPurge(\n-                    \'foo/bar\',\n-                    [\'http://localhost:1234\', \'http://localhost:2345/\']\n+                    "foo/bar",\n+                    ["http://localhost:1234", "http://localhost:2345/"],\n                 )\n-            )\n+            ),\n         )\n \n \ndiff --git a/plone/cachepurging/tests/test_views.py b/plone/cachepurging/tests/test_views.py\nindex 53baf3b..894276c 100644\n--- a/plone/cachepurging/tests/test_views.py\n+++ b/plone/cachepurging/tests/test_views.py\n@@ -27,7 +27,6 @@ class FauxRequest(dict):\n \n \n class Handler(object):\n-\n     def __init__(self):\n         self.invocations = []\n \n@@ -37,7 +36,6 @@ def handler(self, event):\n \n \n class TestQueuePurge(unittest.TestCase):\n-\n     def setUp(self):\n         provideAdapter(persistentFieldAdapter)\n         self.registry = Registry()\n@@ -46,7 +44,7 @@ def setUp(self):\n \n         self.settings = self.registry.forInterface(ICachePurgingSettings)\n         self.settings.enabled = True\n-        self.settings.cachingProxies = (\'http://localhost:1234\',)\n+        self.settings.cachingProxies = ("http://localhost:1234",)\n \n         self.handler = Handler()\n         provideHandler(self.handler.handler)\n@@ -58,7 +56,7 @@ def test_disabled(self):\n         self.settings.enabled = False\n \n         view = QueuePurge(FauxContext(), FauxRequest())\n-        self.assertEqual(\'Caching not enabled\', view())\n+        self.assertEqual("Caching not enabled", view())\n         self.assertEqual([], self.handler.invocations)\n \n     def test_enabled(self):\n@@ -66,13 +64,12 @@ def test_enabled(self):\n \n         context = FauxContext()\n         view = QueuePurge(context, FauxRequest)\n-        self.assertEqual(\'Queued\', view())\n+        self.assertEqual("Queued", view())\n         self.assertEqual(1, len(self.handler.invocations))\n         self.assertTrue(self.handler.invocations[0].object is context)\n \n \n class TestPurgeImmediately(unittest.TestCase):\n-\n     def setUp(self):\n         provideAdapter(persistentFieldAdapter)\n         self.registry = Registry()\n@@ -81,17 +78,16 @@ def setUp(self):\n \n         self.settings = self.registry.forInterface(ICachePurgingSettings)\n         self.settings.enabled = True\n-        self.settings.cachingProxies = (\'http://localhost:1234\',)\n+        self.settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n                 return []\n@@ -100,8 +96,7 @@ def getAbsolutePaths(self):\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n-            def purgeSync(self, url, httpVerb=\'PURGE\'):\n+            def purgeSync(self, url, httpVerb="PURGE"):\n                 return "200 OK", "cached", None\n \n         provideUtility(FauxPurger())\n@@ -112,20 +107,20 @@ def tearDown(self):\n     def test_disabled(self):\n         self.settings.enabled = False\n         view = PurgeImmediately(FauxContext(), FauxRequest())\n-        self.assertEqual(\'Caching not enabled\', view())\n+        self.assertEqual("Caching not enabled", view())\n \n     def test_purge(self):\n         view = PurgeImmediately(FauxContext(), FauxRequest())\n         self.assertEqual(\n-            \'Purged: http://localhost:1234/foo, \'\n-            \'Status: 200 OK, \'\n-            \'X-Cache: cached, \'\n-            \'Error: None\\n\'\n-            \'Purged: http://localhost:1234/bar, \'\n-            \'Status: 200 OK, \'\n-            \'X-Cache: cached, \'\n-            \'Error: None\\n\',\n-            view()\n+            "Purged: http://localhost:1234/foo, "\n+            "Status: 200 OK, "\n+            "X-Cache: cached, "\n+            "Error: None\\n"\n+            "Purged: http://localhost:1234/bar, "\n+            "Status: 200 OK, "\n+            "X-Cache: cached, "\n+            "Error: None\\n",\n+            view(),\n         )\n \n \ndiff --git a/plone/cachepurging/utils.py b/plone/cachepurging/utils.py\nindex 7f2a5c5..73d67ec 100644\n--- a/plone/cachepurging/utils.py\n+++ b/plone/cachepurging/utils.py\n@@ -52,10 +52,10 @@ def getURLsToPurge(path, proxies):\n     listed in the registry into account.\n     """\n \n-    if not path.startswith(\'/\'):\n-        path = \'/\' + path\n+    if not path.startswith("/"):\n+        path = "/" + path\n \n     for proxy in proxies:\n-        if proxy.endswith(\'/\'):\n+        if proxy.endswith("/"):\n             proxy = proxy[:-1]\n         yield proxy + path\ndiff --git a/setup.py b/setup.py\nindex f49b2fb..8a3700a 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,49 +1,47 @@\n from setuptools import setup, find_packages\n \n-version = \'1.0.16.dev0\'\n+version = "2.0.dev0"\n \n setup(\n-    name=\'plone.cachepurging\',\n+    name="plone.cachepurging",\n     version=version,\n     description="Cache purging support for Zope 2 applications",\n-    long_description=(open(\'README.rst\').read() + \'\\n\' +\n-                      open(\'CHANGES.rst\').read()),\n+    long_description=(\n+        open("README.rst").read() + "\\n" + open("CHANGES.rst").read()\n+    ),\n     classifiers=[\n-        \'Framework :: Plone\',\n-        \'Framework :: Plone :: 4.3\',\n-        \'Framework :: Plone :: 5.0\',\n-        \'Framework :: Plone :: 5.1\',\n-        \'License :: OSI Approved :: GNU General Public License v2 (GPLv2)\',\n-        \'Programming Language :: Python\',\n-        \'Programming Language :: Python :: 2.7\',\n-        \'Programming Language :: Python :: 3.6\',\n+        "Framework :: Plone",\n+        "Framework :: Plone :: 5.1",\n+        "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n+        "Programming Language :: Python",\n+        "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.6",\n     ],\n-    keywords=\'plone cache purge\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://pypi.python.org/pypi/plone.cachepurging\',\n-    license=\'GPL version 2\',\n-    packages=find_packages(exclude=[\'ez_setup\']),\n-    namespace_packages=[\'plone\'],\n+    keywords="plone cache purge",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://pypi.python.org/pypi/plone.cachepurging",\n+    license="GPL version 2",\n+    packages=find_packages(exclude=["ez_setup"]),\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n-        \'five.globalrequest\',\n-        \'plone.registry\',\n-        \'six\',\n-        \'z3c.caching\',\n-        \'zope.annotation\',\n-        \'zope.component\',\n-        \'zope.event\',\n-        \'zope.i18nmessageid\',\n-        \'zope.interface\',\n-        \'zope.lifecycleevent\',\n-        \'zope.schema\',\n-        \'zope.testing\',\n-        \'Zope2\'\n+        "setuptools",\n+        "five.globalrequest",\n+        "plone.registry",\n+        "requests",\n+        "six",\n+        "z3c.caching",\n+        "zope.annotation",\n+        "zope.component",\n+        "zope.event",\n+        "zope.i18nmessageid",\n+        "zope.interface",\n+        "zope.lifecycleevent",\n+        "zope.schema",\n+        "zope.testing",\n+        "Zope2",\n     ],\n-    extras_require={\n-        \'test\': [\'plone.app.testing\'],\n-    },\n+    extras_require={"test": ["plone.app.testing"]},\n )\n'

Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2018-08-07T16:26:44+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.cachepurging/commit/e5f374511e3248acb0c2c7e80e7a4b2bcfb3e7bf

fix logging

Files changed:
M plone/cachepurging/purger.py

b'diff --git a/plone/cachepurging/purger.py b/plone/cachepurging/purger.py\nindex fb11a37..f7cda9a 100644\n--- a/plone/cachepurging/purger.py\n+++ b/plone/cachepurging/purger.py\n@@ -213,11 +213,11 @@ def run(self):\n                             # All other exceptions are evil - we just disard\n                             # the item.  This prevents other logic failures etc\n                             # being retried.\n-                            logger.exception("Failed to purge %s", url)\n+                            logger.exception("Failed to purge {0}".format(url))\n                             break\n                         logger.debug(\n-                            "Transient failure on %s for %s, "\n-                            "retrying: %s" % (httpVerb, url)\n+                            "Transient failure on {0} for {1}, "\n+                            "retrying: {2}".format(httpVerb, url, i)\n                         )\n \n         except Exception:\n'

Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2018-08-07T17:55:31+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.cachepurging/commit/28c14c50c1e70df194a4a6ae02150ceded496dcb

fix tests

Files changed:
M plone/cachepurging/purger.py
M plone/cachepurging/tests/test_purger.py

b'diff --git a/plone/cachepurging/purger.py b/plone/cachepurging/purger.py\nindex f7cda9a..f5670b2 100644\n--- a/plone/cachepurging/purger.py\n+++ b/plone/cachepurging/purger.py\n@@ -75,7 +75,7 @@ def purgeSync(self, url, httpVerb="PURGE"):\n         try:\n             with requests.Session() as session:\n                 resp, xcache, xerror = self.purge(session, url, httpVerb)\n-                status = str(resp.status_code)\n+                status = resp.status_code\n         except Exception:\n             status = "ERROR"\n             err, msg, tb = sys.exc_info()\n@@ -119,14 +119,16 @@ def stopThreads(self, wait=False):\n             except queue.Full:\n                 # no problem - self.stopping should be seen.\n                 pass\n-        ok = True\n         if wait:\n-            for w in six.itervalues(self.workers):\n-                w.join(5)\n-                if w.isAlive():\n-                    logger.warning("Worker thread %s failed to terminate", w)\n-                    ok = False\n-        return ok\n+            for worker in six.itervalues(self.workers):\n+                worker.join(5)\n+                if worker.isAlive():\n+                    logger.warning(\n+                        "Worker thread %s failed to terminate",\n+                        worker\n+                    )\n+                    return False\n+        return True\n \n     def getQueueAndWorker(self, url):\n         """Create or retrieve a queue and a worker thread instance for the\n@@ -205,10 +207,14 @@ def run(self):\n                             resp, msg, err = self.producer.purge(\n                                 session, url, httpVerb\n                             )\n-                            # TODO: Check resp for errors,\n-                            # if all fine:\n                             if resp.status_code == requests.codes.ok:\n                                 break  # all done with this item!\n+                            if resp.status_code == requests.codes.not_found:\n+                                # not found is valid\n+                                logger.debug(\n+                                    "Purge URL not found: {0}".format(url)\n+                                )\n+                                break  # all done with this item!\n                         except Exception:\n                             # All other exceptions are evil - we just disard\n                             # the item.  This prevents other logic failures etc\ndiff --git a/plone/cachepurging/tests/test_purger.py b/plone/cachepurging/tests/test_purger.py\nindex 0be4ea4..cff450a 100644\n--- a/plone/cachepurging/tests/test_purger.py\n+++ b/plone/cachepurging/tests/test_purger.py\n@@ -86,10 +86,6 @@ def tearDown(self):\n                     if self.httpd.response_queue.empty():\n                         break\n                     time.sleep(0.1)\n-                self.assertTrue(\n-                    self.httpd.response_queue.empty(),\n-                    "response queue not consumed",\n-                )\n             if not self.purger.stopThreads(wait=True):\n                 self.fail("The purge threads did not stop")\n         finally:\n@@ -120,7 +116,6 @@ def startServer(self, port=SERVER_PORT, start=True):\n class TestSync(TestCase):\n     def setUp(self):\n         super(TestSync, self).setUp()\n-        self.purger.http_1_1 = True\n         self.maxDiff = None\n \n     def tearDown(self):\n@@ -149,12 +144,6 @@ def testError(self):\n         self.assertEqual(status, "ERROR")\n \n \n-class TestSyncHTTP10(TestSync):\n-    def setUp(self):\n-        super(TestSync, self).setUp()\n-        self.purger.http_1_1 = False\n-\n-\n class TestAsync(TestCase):\n     def dispatchURL(self, path, method="PURGE", port=SERVER_PORT):\n         url = "http://localhost:%s%s" % (port, path)\n@@ -180,10 +169,28 @@ def testAsyncError(self):\n         # In this test we arrange for an error condition in the middle\n         # of 2 items - this forces the server into its retry condition.\n         self.httpd.queue_response(response=200)\n-        self.httpd.queue_response(response=None)\n+        self.httpd.queue_response(response=500)\n         self.httpd.queue_response(response=200)\n         self.dispatchURL("/foo")  # will consume first.\n         self.dispatchURL("/bar")  # will consume error, then retry\n+        self.assertTrue(\n+            self.httpd.response_queue.empty(),\n+            "Left items behind in HTTPD response queue."\n+        )\n+\n+    def testAsyncNotFOund(self):\n+        self.httpd.queue_response(response=404)\n+        self.httpd.queue_response(response=200)\n+        self.dispatchURL("/foo")  # works\n+        self.assertFalse(\n+            self.httpd.response_queue.empty(),\n+            "404 was retried instead of consumed."\n+        )\n+        self.dispatchURL("/foo")  # works\n+        self.assertTrue(\n+            self.httpd.response_queue.empty(),\n+            "Left items behind in HTTPD response queue."\n+        )\n \n \n class TestAsyncConnectionFailure(TestCase):\n'

Repository: plone.cachepurging


Branch: refs/heads/master
Date: 2018-08-07T21:55:25+02:00
Author: agitator (agitator) <agitator@users.noreply.github.com>
Commit: https://github.com/plone/plone.cachepurging/commit/edcded4f204c3555020a44ee22389b2bcb566e06

Merge pull request #14 from plone/refactor-with-requests

Refactor using requests

Files changed:
M CHANGES.rst
M bootstrap.py
M plone/__init__.py
M plone/cachepurging/browser.py
M plone/cachepurging/interfaces.py
M plone/cachepurging/paths.py
M plone/cachepurging/purger.py
M plone/cachepurging/rewrite.py
M plone/cachepurging/tests/test_hooks.py
M plone/cachepurging/tests/test_purger.py
M plone/cachepurging/tests/test_rewrite.py
M plone/cachepurging/tests/test_traversable_paths.py
M plone/cachepurging/tests/test_utils.py
M plone/cachepurging/tests/test_views.py
M plone/cachepurging/utils.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex b38b26f..694c5d6 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -6,7 +6,11 @@ Changelog\n \n Breaking changes:\n \n-- *add item here*\n+- Use `requests <http://docs.python-requests.org/>`_ library instead of handcrafting connection and requests on our own.\n+  This avoids strange problems in real-world customers environments.\n+  We do not need to reinvent the wheel here.\n+  Requests always uses HTTP 1.1 and drops support for HTTP 1.0 only caches.\n+  [jensens]\n \n New features:\n \ndiff --git a/bootstrap.py b/bootstrap.py\nindex a629566..2294e35 100644\n--- a/bootstrap.py\n+++ b/bootstrap.py\n@@ -27,7 +27,7 @@\n \n tmpeggs = tempfile.mkdtemp()\n \n-usage = \'\'\'\\\n+usage = """\\\n [DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]\n \n Bootstraps a buildout-based project.\n@@ -37,30 +37,47 @@\n \n Note that by using --find-links to point to local resources, you can keep\n this script from going over the network.\n-\'\'\'\n+"""\n \n parser = OptionParser(usage=usage)\n parser.add_option("-v", "--version", help="use a specific zc.buildout version")\n \n-parser.add_option("-t", "--accept-buildout-test-releases",\n-                  dest=\'accept_buildout_test_releases\',\n-                  action="store_true", default=False,\n-                  help=("Normally, if you do not specify a --version, the "\n-                        "bootstrap script and buildout gets the newest "\n-                        "*final* versions of zc.buildout and its recipes and "\n-                        "extensions for you.  If you use this flag, "\n-                        "bootstrap and buildout will get the newest releases "\n-                        "even if they are alphas or betas."))\n-parser.add_option("-c", "--config-file",\n-                  help=("Specify the path to the buildout configuration "\n-                        "file to be used."))\n-parser.add_option("-f", "--find-links",\n-                  help=("Specify a URL to search for buildout releases"))\n-parser.add_option("--allow-site-packages",\n-                  action="store_true", default=False,\n-                  help=("Let bootstrap.py use existing site packages"))\n-parser.add_option("--setuptools-version",\n-                  help="use a specific setuptools version")\n+parser.add_option(\n+    "-t",\n+    "--accept-buildout-test-releases",\n+    dest="accept_buildout_test_releases",\n+    action="store_true",\n+    default=False,\n+    help=(\n+        "Normally, if you do not specify a --version, the "\n+        "bootstrap script and buildout gets the newest "\n+        "*final* versions of zc.buildout and its recipes and "\n+        "extensions for you.  If you use this flag, "\n+        "bootstrap and buildout will get the newest releases "\n+        "even if they are alphas or betas."\n+    ),\n+)\n+parser.add_option(\n+    "-c",\n+    "--config-file",\n+    help=(\n+        "Specify the path to the buildout configuration " "file to be used."\n+    ),\n+)\n+parser.add_option(\n+    "-f",\n+    "--find-links",\n+    help=("Specify a URL to search for buildout releases"),\n+)\n+parser.add_option(\n+    "--allow-site-packages",\n+    action="store_true",\n+    default=False,\n+    help=("Let bootstrap.py use existing site packages"),\n+)\n+parser.add_option(\n+    "--setuptools-version", help="use a specific setuptools version"\n+)\n \n \n options, args = parser.parse_args()\n@@ -77,25 +94,26 @@\n     from urllib2 import urlopen\n \n ez = {}\n-exec(urlopen(\'https://bootstrap.pypa.io/ez_setup.py\').read(), ez)\n+exec(urlopen("https://bootstrap.pypa.io/ez_setup.py").read(), ez)\n \n if not options.allow_site_packages:\n     # ez_setup imports site, which adds site packages\n     # this will remove them from the path to ensure that incompatible versions\n     # of setuptools are not in the path\n     import site\n+\n     # inside a virtualenv, there is no \'getsitepackages\'.\n     # We can\'t remove these reliably\n-    if hasattr(site, \'getsitepackages\'):\n+    if hasattr(site, "getsitepackages"):\n         for sitepackage_path in site.getsitepackages():\n             sys.path[:] = [x for x in sys.path if sitepackage_path not in x]\n \n setup_args = dict(to_dir=tmpeggs, download_delay=0)\n \n if options.setuptools_version is not None:\n-    setup_args[\'version\'] = options.setuptools_version\n+    setup_args["version"] = options.setuptools_version\n \n-ez[\'use_setuptools\'](**setup_args)\n+ez["use_setuptools"](**setup_args)\n import setuptools\n import pkg_resources\n \n@@ -110,28 +128,37 @@\n \n ws = pkg_resources.working_set\n \n-cmd = [sys.executable, \'-c\',\n-       \'from setuptools.command.easy_install import main; main()\',\n-       \'-mZqNxd\', tmpeggs]\n+cmd = [\n+    sys.executable,\n+    "-c",\n+    "from setuptools.command.easy_install import main; main()",\n+    "-mZqNxd",\n+    tmpeggs,\n+]\n \n find_links = os.environ.get(\n-    \'bootstrap-testing-find-links\',\n-    options.find_links or\n-    (\'http://downloads.buildout.org/\'\n-     if options.accept_buildout_test_releases else None)\n-    )\n+    "bootstrap-testing-find-links",\n+    options.find_links\n+    or (\n+        "http://downloads.buildout.org/"\n+        if options.accept_buildout_test_releases\n+        else None\n+    ),\n+)\n if find_links:\n-    cmd.extend([\'-f\', find_links])\n+    cmd.extend(["-f", find_links])\n \n setuptools_path = ws.find(\n-    pkg_resources.Requirement.parse(\'setuptools\')).location\n+    pkg_resources.Requirement.parse("setuptools")\n+).location\n \n-requirement = \'zc.buildout\'\n+requirement = "zc.buildout"\n version = options.version\n if version is None and not options.accept_buildout_test_releases:\n     # Figure out the most recent final version of zc.buildout.\n     import setuptools.package_index\n-    _final_parts = \'*final-\', \'*final\'\n+\n+    _final_parts = "*final-", "*final"\n \n     def _final_version(parsed_version):\n         try:\n@@ -139,12 +166,13 @@ def _final_version(parsed_version):\n         except AttributeError:\n             # Older setuptools\n             for part in parsed_version:\n-                if (part[:1] == \'*\') and (part not in _final_parts):\n+                if (part[:1] == "*") and (part not in _final_parts):\n                     return False\n             return True\n \n     index = setuptools.package_index.PackageIndex(\n-        search_path=[setuptools_path])\n+        search_path=[setuptools_path]\n+    )\n     if find_links:\n         index.add_find_links((find_links,))\n     req = pkg_resources.Requirement.parse(requirement)\n@@ -163,13 +191,13 @@ def _final_version(parsed_version):\n             best.sort()\n             version = best[-1].version\n if version:\n-    requirement = \'==\'.join((requirement, version))\n+    requirement = "==".join((requirement, version))\n cmd.append(requirement)\n \n import subprocess\n+\n if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:\n-    raise Exception(\n-        "Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n+    raise Exception("Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n \n ######################################################################\n # Import and run buildout\n@@ -178,12 +206,12 @@ def _final_version(parsed_version):\n ws.require(requirement)\n import zc.buildout.buildout\n \n-if not [a for a in args if \'=\' not in a]:\n-    args.append(\'bootstrap\')\n+if not [a for a in args if "=" not in a]:\n+    args.append("bootstrap")\n \n # if -c was provided, we push it back into args for buildout\' main function\n if options.config_file is not None:\n-    args[0:0] = [\'-c\', options.config_file]\n+    args[0:0] = ["-c", options.config_file]\n \n zc.buildout.buildout.main(args)\n shutil.rmtree(tmpeggs)\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..03d08ff 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1,2 @@\n # -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/cachepurging/browser.py b/plone/cachepurging/browser.py\nindex 8a0809d..4c20c42 100644\n--- a/plone/cachepurging/browser.py\n+++ b/plone/cachepurging/browser.py\n@@ -26,10 +26,10 @@ def __init__(self, context, request):\n     def __call__(self):\n \n         if not isCachePurgingEnabled():\n-            return \'Caching not enabled\'\n+            return "Caching not enabled"\n \n         notify(Purge(self.context))\n-        return \'Queued\'\n+        return "Queued"\n \n \n class PurgeImmediately(object):\n@@ -42,7 +42,7 @@ def __init__(self, context, request):\n \n     def __call__(self):\n         if not isCachePurgingEnabled():\n-            return \'Caching not enabled\'\n+            return "Caching not enabled"\n \n         registry = getUtility(IRegistry)\n         settings = registry.forInterface(ICachePurgingSettings)\n@@ -54,10 +54,7 @@ def __call__(self):\n                 status, xcache, xerror = purger.purgeSync(url)\n                 out.write(\n                     RESULT_TPL.format(\n-                        url=url,\n-                        status=status,\n-                        xcache=xcache,\n-                        xerror=xerror,\n+                        url=url, status=status, xcache=xcache, xerror=xerror\n                     )\n                 )\n         return out.getvalue()\ndiff --git a/plone/cachepurging/interfaces.py b/plone/cachepurging/interfaces.py\nindex b65bab1..363eb71 100644\n--- a/plone/cachepurging/interfaces.py\n+++ b/plone/cachepurging/interfaces.py\n@@ -4,7 +4,7 @@\n from zope.interface import Interface\n \n \n-_ = MessageFactory(\'plone\')\n+_ = MessageFactory("plone")\n \n \n class ICachePurgingSettings(Interface):\n@@ -21,45 +21,51 @@ class ICachePurgingSettings(Interface):\n \n     cachingProxies = schema.Tuple(\n         title=_(u"Caching proxies"),\n-        description=_(u"Provide the URLs of each proxy to which PURGE "\n-                      u"requests should be sent."),\n+        description=_(\n+            u"Provide the URLs of each proxy to which PURGE "\n+            u"requests should be sent."\n+        ),\n         value_type=schema.URI(),\n     )\n \n     virtualHosting = schema.Bool(\n         title=_(u"Send PURGE requests with virtual hosting paths"),\n-        description=_(u"This option is only relevant if you are using "\n-                      u"virtual hosting with Zope\'s VirtualHostMonster. "\n-                      u"This relies on special tokens (VirtualHostBase "\n-                      u"and VirtualHostRoot) in the URL to instruct "\n-                      u"Zope about the types of URLs that the user sees. "\n-                      u"If virtual host URLs are in use and this option "\n-                      u"is set, PURGE requests will be sent to the "\n-                      u"caching proxy with the virtual hosting tokens "\n-                      u"in place. This makes sense if there is a web "\n-                      u"server in front of your caching proxy performing "\n-                      u"the rewrites necessary to translate a user-"\n-                      u"facing URL into a virtual hosting URL, so that "\n-                      u"the requests the caching proxy sees have the "\n-                      u"rewrite information in them. Conversely, if the "\n-                      u"rewrite is done in or behind the caching proxy, "\n-                      u"you want to disable this option, so that the "\n-                      u"PURGE requests use URLs that match those seen "\n-                      u"by the caching proxy as they come from the "\n-                      u"client."),\n+        description=_(\n+            u"This option is only relevant if you are using "\n+            u"virtual hosting with Zope\'s VirtualHostMonster. "\n+            u"This relies on special tokens (VirtualHostBase "\n+            u"and VirtualHostRoot) in the URL to instruct "\n+            u"Zope about the types of URLs that the user sees. "\n+            u"If virtual host URLs are in use and this option "\n+            u"is set, PURGE requests will be sent to the "\n+            u"caching proxy with the virtual hosting tokens "\n+            u"in place. This makes sense if there is a web "\n+            u"server in front of your caching proxy performing "\n+            u"the rewrites necessary to translate a user-"\n+            u"facing URL into a virtual hosting URL, so that "\n+            u"the requests the caching proxy sees have the "\n+            u"rewrite information in them. Conversely, if the "\n+            u"rewrite is done in or behind the caching proxy, "\n+            u"you want to disable this option, so that the "\n+            u"PURGE requests use URLs that match those seen "\n+            u"by the caching proxy as they come from the "\n+            u"client."\n+        ),\n         required=True,\n         default=False,\n     )\n \n     domains = schema.Tuple(\n         title=_(u"Domains"),\n-        description=_(u"This option is only relevant if you are using "\n-                      u"virtual hosting and you have enabled the option "\n-                      u"to send PURGE requests with virtual hosting URLs "\n-                      u"above. If you your site is served on multiple "\n-                      u"domains e.g. http://example.org and "\n-                      u"http://www.example.org you may wish to purge "\n-                      u"both. If so, list all your domains here"),\n+        description=_(\n+            u"This option is only relevant if you are using "\n+            u"virtual hosting and you have enabled the option "\n+            u"to send PURGE requests with virtual hosting URLs "\n+            u"above. If you your site is served on multiple "\n+            u"domains e.g. http://example.org and "\n+            u"http://www.example.org you may wish to purge "\n+            u"both. If so, list all your domains here"\n+        ),\n         required=False,\n         default=(),\n         missing_value=(),\n@@ -86,12 +92,12 @@ class IPurger(Interface):\n     """A utility used to manage the purging process.\n     """\n \n-    def purgeAsync(url, httpVerb=\'PURGE\'):\n+    def purgeAsync(url, httpVerb="PURGE"):\n         """Send a PURGE request to a particular URL asynchronously in a\n         worker thread.\n         """\n \n-    def purgeSync(url, httpVerb=\'PURGE\'):\n+    def purgeSync(url, httpVerb="PURGE"):\n         """Send a PURGE request to a particular URL synchronosly.\n \n         Returns a triple ``(status, xcache, xerror)`` where ``status`` is\n@@ -112,10 +118,9 @@ def stopThreads(wait=False):\n     errorHeaders = schema.Tuple(\n         title=u"Error header names",\n         value_type=schema.ASCIILine(),\n-        default=(\'x-squid-error\',)\n+        default=("x-squid-error",),\n     )\n \n     http_1_1 = schema.Bool(\n-        title=u"Use HTTP 1.1 for PURGE request",\n-        default=True,\n+        title=u"Use HTTP 1.1 for PURGE request", default=True\n     )\ndiff --git a/plone/cachepurging/paths.py b/plone/cachepurging/paths.py\nindex b67c583..1f4b0cf 100644\n--- a/plone/cachepurging/paths.py\n+++ b/plone/cachepurging/paths.py\n@@ -15,7 +15,7 @@ def __init__(self, context):\n         self.context = context\n \n     def getRelativePaths(self):\n-        return [\'/\' + self.context.virtual_url_path()]\n+        return ["/" + self.context.virtual_url_path()]\n \n     def getAbsolutePaths(self):\n         return []\ndiff --git a/plone/cachepurging/purger.py b/plone/cachepurging/purger.py\nindex d80a316..f5670b2 100644\n--- a/plone/cachepurging/purger.py\n+++ b/plone/cachepurging/purger.py\n@@ -14,113 +14,104 @@\n \n from App.config import getConfiguration\n from plone.cachepurging.interfaces import IPurger\n-from six.moves import http_client\n from six.moves import queue\n from six.moves import range\n-from six.moves import urllib\n+from six.moves.urllib.parse import urlparse\n+from traceback import format_exception\n from zope.interface import implementer\n from zope.testing.cleanup import addCleanUp\n \n import atexit\n import logging\n+import requests\n import six\n-import socket\n import sys\n import threading\n-import time\n \n \n-logger = logging.getLogger(\'plone.cachepurging\')\n-\n-\n-class Connection(http_client.HTTPConnection):\n-    """A connection that can handle either HTTP or HTTPS\n-    """\n-\n-    def __init__(self, host, port=None, scheme="http", timeout=5):\n-        self.scheme = scheme\n-        if scheme == "http":\n-            self.default_port = http_client.HTTP_PORT\n-        elif scheme == "https":\n-            self.default_port = http_client.HTTPS_PORT\n-        else:\n-            raise ValueError("Invalid scheme \'%s\'" % scheme)\n-        http_client.HTTPConnection.__init__(self, host, port, timeout=timeout)\n-        self.timeout = timeout\n-\n-    def connect(self):\n-        if self.scheme == "http":\n-            http_client.HTTPConnection.connect(self)\n-        elif self.scheme == "https":\n-            import ssl  # import here in case python has no ssl support\n-            # Clone of http_client.HTTPSConnection.connect\n-            sock = socket.create_connection((self.host, self.port),\n-                                            timeout=self.timeout)\n-            key_file = cert_file = None\n-            self.sock = ssl.wrap_socket(sock, key_file, cert_file)\n-        else:\n-            raise ValueError("Invalid scheme \'%s\'" % self.scheme)\n+logger = logging.getLogger(__name__)\n \n \n @implementer(IPurger)\n class DefaultPurger(object):\n-\n-    def __init__(self, factory=Connection, timeout=30, backlog=0,\n-                 errorHeaders=(\'x-squid-error\', ), http_1_1=True):\n-        self.factory = factory\n+    def __init__(\n+        self, timeout=(3, 27), backlog=0, errorHeaders=("x-squid-error",)\n+    ):\n         self.timeout = timeout\n         self.queues = {}\n         self.workers = {}\n         self.backlog = backlog\n         self.queueLock = threading.Lock()\n         self.errorHeaders = errorHeaders\n-        self.http_1_1 = http_1_1\n \n-    def purgeAsync(self, url, httpVerb=\'PURGE\'):\n-        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)  # noqa: E501\n-        __traceback_info__ = (url, httpVerb, scheme, host,\n-                              path, params, query, fragment)\n+    def purge(self, session, url, httpVerb="PURGE"):\n+        """Perform the single purge request.\n \n-        q, w = self.getQueueAndWorker(url)\n-        try:\n-            q.put((url, httpVerb), block=False)\n-            logger.debug(\'Queued %s\' % url)\n-        except queue.Full:\n-            # Make a loud noise. Ideally the queue size would be\n-            # user-configurable - but the more likely case is that the purge\n-            # host is down.\n-            if not getConfiguration().debug_mode:\n-                logger.warning("The purge queue for the URL %s is full - the "\n-                               "request will be discarded.  Please check the "\n-                               "server is reachable, or disable this purge "\n-                               "host", url)\n+        Returns a triple ``(resp, xcache, xerror)`` where ``resp`` is the\n+        response object for the connection, ``xcache`` is the contents of the\n+        X-Cache header, and ``xerror`` is the contents of the first header\n+        found of the header list in ``self.errorHeaders``.\n+        """\n+        __traceback_info__ = url\n+        logger.debug("making %s request to %s", httpVerb, url)\n+        resp = session.request(httpVerb, url, timeout=self.timeout)\n+        xcache = resp.headers.get("x-cache", "")\n+        xerror = ""\n+        for header in self.errorHeaders:\n+            xerror = resp.headers.get(header, "")\n+            if xerror:\n+                # Break on first found.\n+                break\n+        logger.debug(\n+            "%s of %s: %s %s", httpVerb, url, resp.status_code, resp.reason\n+        )\n+        return resp, xcache, xerror\n+\n+    def purgeSync(self, url, httpVerb="PURGE"):\n+        """Purge synchronous.\n \n-    def purgeSync(self, url, httpVerb=\'PURGE\'):\n+        Fails if requests to cache fails.\n+        """\n         try:\n-            conn = self.getConnection(url)\n-            try:\n-                resp, xcache, xerror = self._purgeSync(conn, url, httpVerb)\n-                status = resp.status\n-            finally:\n-                conn.close()\n-        except:\n+            with requests.Session() as session:\n+                resp, xcache, xerror = self.purge(session, url, httpVerb)\n+                status = resp.status_code\n+        except Exception:\n             status = "ERROR"\n             err, msg, tb = sys.exc_info()\n-            from traceback import format_exception\n-            xerror = \'\\n\'.join(format_exception(err, msg, tb))\n+            xerror = "\\n".join(format_exception(err, msg, tb))\n             # Avoid leaking a ref to traceback.\n             del err, msg, tb\n-            xcache = \'\'\n-        logger.debug(\'Finished %s for %s: %s %s\'\n-                     % (httpVerb, url, status, xcache))\n+            xcache = ""\n+        logger.debug(\n+            "Finished %s for %s: %s %s" % (httpVerb, url, status, xcache)\n+        )\n         if xerror:\n-            logger.debug(\'Error while purging %s:\\n%s\' % (url, xerror))\n+            logger.debug("Error while purging %s:\\n%s" % (url, xerror))\n         logger.debug("Completed synchronous purge of %s", url)\n         return status, xcache, xerror\n \n+    def purgeAsync(self, url, httpVerb="PURGE"):\n+        current_queue, worker = self.getQueueAndWorker(url)\n+        try:\n+            current_queue.put((url, httpVerb), block=False)\n+            logger.debug("Queued %s" % url)\n+        except queue.Full:\n+            # Make a loud noise. Ideally the queue size would be\n+            # user-configurable - but the more likely case is that the purge\n+            # host is down.\n+            if not getConfiguration().debug_mode:\n+                logger.warning(\n+                    "The purge queue for the URL %s is full - the "\n+                    "request will be discarded.  Please check the "\n+                    "server is reachable, or disable this purge "\n+                    "host",\n+                    url,\n+                )\n+\n     def stopThreads(self, wait=False):\n-        for w in six.itervalues(self.workers):\n-            w.stopping = True\n+        for worker in six.itervalues(self.workers):\n+            worker.stop()\n         # in case the queue is empty, wake it up so the .stopping flag is seen\n         for q in self.queues.values():\n             try:\n@@ -128,93 +119,47 @@ def stopThreads(self, wait=False):\n             except queue.Full:\n                 # no problem - self.stopping should be seen.\n                 pass\n-        ok = True\n         if wait:\n-            for w in six.itervalues(self.workers):\n-                w.join(5)\n-                if w.isAlive():\n-                    logger.warning("Worker thread %s failed to terminate", w)\n-                    ok = False\n-        return ok\n-\n-    def getConnection(self, url):\n-        """Creates a new connection - returns a connection object that is\n-        already connected. Exceptions raised by that connection are not\n-        trapped.\n-        """\n-\n-        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)\n-        #\n-        # process.\n-        conn = self.factory(host, scheme=scheme, timeout=self.timeout)\n-        conn.connect()\n-        logger.debug("established connection to %s", host)\n-        return conn\n+            for worker in six.itervalues(self.workers):\n+                worker.join(5)\n+                if worker.isAlive():\n+                    logger.warning(\n+                        "Worker thread %s failed to terminate",\n+                        worker\n+                    )\n+                    return False\n+        return True\n \n     def getQueueAndWorker(self, url):\n         """Create or retrieve a queue and a worker thread instance for the\n         given URL.\n         """\n \n-        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)\n+        (scheme, host, path, params, query, fragment) = urlparse(url)\n         key = (host, scheme)\n         if key not in self.queues:\n             self.queueLock.acquire()\n             try:\n                 if key not in self.queues:\n-                    logger.debug("Creating worker thread for %s://%s",\n-                                 scheme, host)\n-                    assert key not in self.workers\n+                    logger.debug(\n+                        "Creating worker thread for %s://%s", scheme, host\n+                    )\n+                    if key in self.workers:\n+                        raise ValueError(\n+                            "Queue Key must not already exist in workers"\n+                        )\n                     self.queues[key] = queue_ = queue.Queue(self.backlog)\n                     self.workers[key] = worker = Worker(\n-                        queue_, host, scheme, self)\n+                        queue_, host, scheme, self\n+                    )\n                     worker.start()\n             finally:\n                 self.queueLock.release()\n         return self.queues[key], self.workers[key]\n \n-    def _purgeSync(self, conn, url, httpVerb):\n-        """Perform the purge request. Returns a triple\n-        ``(resp, xcache, xerror)`` where ``resp`` is the response object for\n-        the connection, ``xcache`` is the contents of the X-Cache header,\n-        and ``xerror`` is the contents of the first header found of the\n-        header list in ``self.errorHeaders``.\n-        """\n-\n-        (scheme, host, path, params, query, fragment) = urllib.parse.urlparse(url)  # noqa: E501\n-        __traceback_info__ = (url, httpVerb, scheme, host,\n-                              path, params, query, fragment)\n-\n-        if self.http_1_1:\n-            conn._http_vsn = 11\n-            conn._http_vsn_str = \'HTTP/1.1\'\n-        else:\n-            conn._http_vsn = 10\n-            conn._http_vsn_str = \'HTTP/1.0\'\n-            # When using HTTP 1.0, to make up for the lack of a \'Host\' header\n-            # we use the full url as the purge path, to allow for virtual\n-            # hosting in squid\n-            path = url\n-\n-        purge_path = urllib.parse.urlunparse(\n-            (\'\', \'\', path, params, query, fragment))\n-        logger.debug(\'making %s request to %s for %s.\',\n-                     httpVerb, host, purge_path)\n-        conn.putrequest(httpVerb, purge_path, skip_accept_encoding=True)\n-        conn.endheaders()\n-        resp = conn.getresponse()\n-\n-        xcache = resp.getheader(\'x-cache\', \'\')\n-        xerror = \'\'\n-        for header in self.errorHeaders:\n-            xerror = resp.getheader(header, \'\')\n-            if xerror:\n-                # Break on first found.\n-                break\n-        resp.read()\n-        logger.debug("%s of %s: %s %s",\n-                     httpVerb, url, resp.status, resp.reason)\n-        return resp, xcache, xerror\n+    @property\n+    def http_1_1(self):\n+        return True\n \n \n class Worker(threading.Thread):\n@@ -228,7 +173,8 @@ def __init__(self, queue, host, scheme, producer):\n         self.queue = queue\n         self.stopping = False\n         super(Worker, self).__init__(\n-            name="PurgeThread for %s://%s" % (scheme, host))\n+            name="PurgeThread for %s://%s" % (scheme, host)\n+        )\n \n     def stop(self):\n         self.stopping = True\n@@ -236,100 +182,57 @@ def stop(self):\n     def run(self):\n         logger.debug("%s starting", self)\n         # queue should always exist!\n-        q = self.producer.queues[(self.host, self.scheme)]\n-        connection = None\n+        current_queue = self.producer.queues[(self.host, self.scheme)]\n         atexit.register(self.stop)\n         try:\n-            while not self.stopping:\n-                item = q.get()\n-                if self.stopping or item is None:  # Shut down thread signal\n-                    logger.debug(\'Stopping worker thread for \'\n-                                 \'(%s, %s).\' % (self.host, self.scheme))\n-                    break\n-                url, httpVerb = item\n-\n-                # Loop handling errors (other than connection errors) doing\n-                # the actual purge.\n-                for i in range(5):\n-                    if self.stopping:\n+            with requests.Session() as session:\n+                while not self.stopping:\n+                    item = current_queue.get()\n+                    if self.stopping or item is None:\n+                        # Shut down thread signal\n+                        logger.debug(\n+                            "Stopping worker thread for "\n+                            "(%s, %s)." % (self.host, self.scheme)\n+                        )\n                         break\n-                    # Get a connection.\n-                    if connection is None:\n-                        connection = self.getConnection(url)\n-                        if connection is None:  # stopping\n+                    url, httpVerb = item\n+\n+                    # Loop handling errors (other than connection errors) doing\n+                    # the actual purge.\n+                    for i in range(5):\n+                        if self.stopping:\n+                            break\n+                        # Got an item, purge it!\n+                        try:\n+                            resp, msg, err = self.producer.purge(\n+                                session, url, httpVerb\n+                            )\n+                            if resp.status_code == requests.codes.ok:\n+                                break  # all done with this item!\n+                            if resp.status_code == requests.codes.not_found:\n+                                # not found is valid\n+                                logger.debug(\n+                                    "Purge URL not found: {0}".format(url)\n+                                )\n+                                break  # all done with this item!\n+                        except Exception:\n+                            # All other exceptions are evil - we just disard\n+                            # the item.  This prevents other logic failures etc\n+                            # being retried.\n+                            logger.exception("Failed to purge {0}".format(url))\n                             break\n-                    # Got an item, purge it!\n-                    try:\n-                        resp, msg, err = self.producer._purgeSync(\n-                            connection,\n-                            url,\n-                            httpVerb\n+                        logger.debug(\n+                            "Transient failure on {0} for {1}, "\n+                            "retrying: {2}".format(httpVerb, url, i)\n                         )\n-                        # worked! See if we can leave the connection open for\n-                        # the next item we need to process\n-                        # NOTE: If we make a HTTP 1.0 request to IIS, it\n-                        # returns a HTTP 1.1 request and closes the\n-                        # connection.  It is not clear if IIS is evil for\n-                        # not returning a "connection: close" header in this\n-                        # case (ie, assuming HTTP 1.0 close semantics), or\n-                        # if http_client.py is evil for not detecting this\n-                        # situation and flagging will_close.\n-                        if not self.producer.http_1_1 or resp.will_close:\n-                            connection.close()\n-                            connection = None\n-                        break  # all done with this item!\n \n-                    except (http_client.HTTPException, socket.error) as e:\n-                        # All errors \'connection\' related errors are treated\n-                        # the same - simply drop the connection and retry.\n-                        # the process for establishing the connection handles\n-                        # other bad things that go wrong.\n-                        logger.debug(\'Transient failure on %s for %s, \'\n-                                     \'re-establishing connection and \'\n-                                     \'retrying: %s\' % (httpVerb, url, e))\n-                        connection.close()\n-                        connection = None\n-                    except Exception:\n-                        # All other exceptions are evil - we just disard the\n-                        # item.  This prevents other logic failures etc being\n-                        # retried.\n-                        connection.close()\n-                        connection = None\n-                        logger.exception(\'Failed to purge %s\', url)\n-                        break\n-        except:\n-            logger.exception(\'Exception in worker thread \'\n-                             \'for (%s, %s)\' % (self.host, self.scheme))\n+        except Exception:\n+            logger.exception(\n+                "Exception in worker thread "\n+                "for (%s, %s)" % (self.host, self.scheme)\n+            )\n         logger.debug("%s terminating", self)\n \n-    def getConnection(self, url):\n-        """Get a connection to the given URL.\n-\n-        Blocks until either a connection is established, or we are asked to\n-        shut-down. Includes a simple strategy for slowing down the retry rate,\n-        retrying from 5 seconds to 20 seconds until the connection appears or\n-        we waited a full minute.\n-        """\n-        wait_time = 2.5\n-        while not self.stopping:\n-            try:\n-                return self.producer.getConnection(url)\n-            except socket.error as e:\n-                wait_time = int(min(wait_time * 2, 21))\n-                if wait_time > 20:\n-                    # we waited a full minute, we assume a permanent failure\n-                    logger.debug("Error %s connecting to %s - reconnect "\n-                                 "failed.", e, url)\n-                    self.stopping = True\n-                    break\n-                logger.debug("Error %s connecting to %s - will "\n-                             "retry in %d second(s)", e, url, wait_time)\n-                for i in range(wait_time):\n-                    if self.stopping:\n-                        break\n-                    time.sleep(1)\n-        return None  # must be stopping!\n-\n \n DEFAULT_PURGER = DefaultPurger()\n \ndiff --git a/plone/cachepurging/rewrite.py b/plone/cachepurging/rewrite.py\nindex 0be3121..a3424f8 100644\n--- a/plone/cachepurging/rewrite.py\n+++ b/plone/cachepurging/rewrite.py\n@@ -22,7 +22,7 @@ def __call__(self, path):\n         request = self.request\n \n         # No rewriting necessary\n-        virtualURL = request.get(\'VIRTUAL_URL\', None)\n+        virtualURL = request.get("VIRTUAL_URL", None)\n         if virtualURL is None:\n             return [path]\n \n@@ -39,17 +39,17 @@ def __call__(self, path):\n             return [path]\n \n         # We need to reconstruct VHM URLs for each of the domains\n-        virtualUrlParts = request.get(\'VIRTUAL_URL_PARTS\')\n-        virtualRootPhysicalPath = request.get(\'VirtualRootPhysicalPath\')\n+        virtualUrlParts = request.get("VIRTUAL_URL_PARTS")\n+        virtualRootPhysicalPath = request.get("VirtualRootPhysicalPath")\n \n         # Make sure request is compliant\n         if (\n-            not virtualUrlParts or\n-            not virtualRootPhysicalPath or\n-            not isinstance(virtualUrlParts, (list, tuple,)) or\n-            not isinstance(virtualRootPhysicalPath, (list, tuple,)) or\n-            len(virtualUrlParts) < 2 or\n-            len(virtualUrlParts) > 3\n+            not virtualUrlParts\n+            or not virtualRootPhysicalPath\n+            or not isinstance(virtualUrlParts, (list, tuple))\n+            or not isinstance(virtualRootPhysicalPath, (list, tuple))\n+            or len(virtualUrlParts) < 2\n+            or len(virtualUrlParts) > 3\n         ):\n             return [path]\n \n@@ -58,31 +58,33 @@ def __call__(self, path):\n             domains = [virtualUrlParts[0]]\n \n         # Virtual root, e.g. /Plone. Clear if we don\'t have any virtual root\n-        virtualRoot = \'/\'.join(virtualRootPhysicalPath)\n-        if virtualRoot == \'/\':\n-            virtualRoot = \'\'\n+        virtualRoot = "/".join(virtualRootPhysicalPath)\n+        if virtualRoot == "/":\n+            virtualRoot = ""\n \n         # Prefix, e.g. /_vh_foo/_vh_bar. Clear if we don\'t have any.\n-        pathPrefix = len(virtualUrlParts) == 3 and virtualUrlParts[1] or \'\'\n+        pathPrefix = len(virtualUrlParts) == 3 and virtualUrlParts[1] or ""\n         if pathPrefix:\n-            pathPrefix = \'/\' + \\\n-                \'/\'.join([\'_vh_%s\' % p for p in pathPrefix.split(\'/\')])\n+            pathPrefix = "/" + "/".join(\n+                ["_vh_%s" % p for p in pathPrefix.split("/")]\n+            )\n \n         # Path, e.g. /front-page\n-        if len(path) > 0 and not path.startswith(\'/\'):\n-            path = \'/\' + path\n+        if len(path) > 0 and not path.startswith("/"):\n+            path = "/" + path\n \n         paths = []\n         for domain in domains:\n             scheme, host = urllib.parse.urlparse(domain)[:2]\n             paths.append(\n-                \'/VirtualHostBase/%(scheme)s/%(host)s%(root)s/\'\n-                \'VirtualHostRoot%(prefix)s%(path)s\' % {\n-                    \'scheme\': scheme,\n-                    \'host\': host,\n-                    \'root\': virtualRoot,\n-                    \'prefix\': pathPrefix,\n-                    \'path\': path\n+                "/VirtualHostBase/%(scheme)s/%(host)s%(root)s/"\n+                "VirtualHostRoot%(prefix)s%(path)s"\n+                % {\n+                    "scheme": scheme,\n+                    "host": host,\n+                    "root": virtualRoot,\n+                    "prefix": pathPrefix,\n+                    "path": path,\n                 }\n             )\n         return paths\ndiff --git a/plone/cachepurging/tests/test_hooks.py b/plone/cachepurging/tests/test_hooks.py\nindex 13fdc8f..8e7fb94 100644\n--- a/plone/cachepurging/tests/test_hooks.py\n+++ b/plone/cachepurging/tests/test_hooks.py\n@@ -34,7 +34,6 @@ class FauxRequest(dict):\n \n \n class TestQueueHandler(unittest.TestCase):\n-\n     def setUp(self):\n         provideAdapter(AttributeAnnotations)\n         provideAdapter(persistentFieldAdapter)\n@@ -53,17 +52,16 @@ def test_no_request(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n                 return []\n@@ -87,17 +85,16 @@ def test_request_not_annotatable(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n                 return []\n@@ -119,12 +116,11 @@ def test_no_registry(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n                 return []\n@@ -148,17 +144,16 @@ def test_caching_disabled(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = False\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n                 return []\n@@ -182,12 +177,13 @@ def test_enabled_no_paths(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         notify(Purge(context))\n \n-        self.assertEqual({\'plone.cachepurging.urls\': set()},\n-                         dict(IAnnotations(request)))\n+        self.assertEqual(\n+            {"plone.cachepurging.urls": set()}, dict(IAnnotations(request))\n+        )\n \n     def test_enabled(self):\n         context = FauxContext()\n@@ -202,17 +198,16 @@ def test_enabled(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n                 return []\n@@ -221,12 +216,13 @@ def getAbsolutePaths(self):\n \n         notify(Purge(context))\n \n-        self.assertEqual({\'plone.cachepurging.urls\': set([\'/foo\', \'/bar\'])},\n-                         dict(IAnnotations(request)))\n+        self.assertEqual(\n+            {"plone.cachepurging.urls": set(["/foo", "/bar"])},\n+            dict(IAnnotations(request)),\n+        )\n \n \n class TestPurgeHandler(unittest.TestCase):\n-\n     def setUp(self):\n         provideAdapter(AttributeAnnotations)\n         provideAdapter(persistentFieldAdapter)\n@@ -244,15 +240,14 @@ def test_request_not_annotatable(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n             def __init__(self):\n                 self.purged = []\n \n-            def purgeAsync(self, url, httpVerb=\'PURGE\'):\n+            def purgeAsync(self, url, httpVerb="PURGE"):\n                 self.purged.append(url)\n \n         purger = FauxPurger()\n@@ -272,15 +267,14 @@ def test_no_path_key(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n             def __init__(self):\n                 self.purged = []\n \n-            def purgeAsync(self, url, httpVerb=\'PURGE\'):\n+            def purgeAsync(self, url, httpVerb="PURGE"):\n                 self.purged.append(url)\n \n         purger = FauxPurger()\n@@ -294,7 +288,7 @@ def test_no_paths(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)[\'plone.cachepurging.urls\'] = set()\n+        IAnnotations(request)["plone.cachepurging.urls"] = set()\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -302,15 +296,14 @@ def test_no_paths(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n             def __init__(self):\n                 self.purged = []\n \n-            def purgeAsync(self, url, httpVerb=\'PURGE\'):\n+            def purgeAsync(self, url, httpVerb="PURGE"):\n                 self.purged.append(url)\n \n         purger = FauxPurger()\n@@ -324,16 +317,16 @@ def test_no_registry(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)[\'plone.cachepurging.urls\'] = set(\n-            [\'/foo\', \'/bar\'])\n+        IAnnotations(request)["plone.cachepurging.urls"] = set(\n+            ["/foo", "/bar"]\n+        )\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n             def __init__(self):\n                 self.purged = []\n \n-            def purgeAsync(self, url, httpVerb=\'PURGE\'):\n+            def purgeAsync(self, url, httpVerb="PURGE"):\n                 self.purged.append(url)\n \n         purger = FauxPurger()\n@@ -347,8 +340,9 @@ def test_caching_disabled(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)[\'plone.cachepurging.urls\'] = set(\n-            [\'/foo\', \'/bar\'])\n+        IAnnotations(request)["plone.cachepurging.urls"] = set(\n+            ["/foo", "/bar"]\n+        )\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -356,15 +350,14 @@ def test_caching_disabled(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = False\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n             def __init__(self):\n                 self.purged = []\n \n-            def purgeAsync(self, url, httpVerb=\'PURGE\'):\n+            def purgeAsync(self, url, httpVerb="PURGE"):\n                 self.purged.append(url)\n \n         purger = FauxPurger()\n@@ -378,8 +371,9 @@ def test_no_purger(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)[\'plone.cachepurging.urls\'] = set(\n-            [\'/foo\', \'/bar\'])\n+        IAnnotations(request)["plone.cachepurging.urls"] = set(\n+            ["/foo", "/bar"]\n+        )\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -387,7 +381,7 @@ def test_no_purger(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         try:\n             notify(PubSuccess(request))\n@@ -398,8 +392,9 @@ def test_purge(self):\n         request = FauxRequest()\n         alsoProvides(request, IAttributeAnnotatable)\n \n-        IAnnotations(request)[\'plone.cachepurging.urls\'] = set(\n-            [\'/foo\', \'/bar\'])\n+        IAnnotations(request)["plone.cachepurging.urls"] = set(\n+            ["/foo", "/bar"]\n+        )\n \n         registry = Registry()\n         registry.registerInterface(ICachePurgingSettings)\n@@ -407,15 +402,14 @@ def test_purge(self):\n \n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.enabled = True\n-        settings.cachingProxies = (\'http://localhost:1234\',)\n+        settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n             def __init__(self):\n                 self.purged = []\n \n-            def purgeAsync(self, url, httpVerb=\'PURGE\'):\n+            def purgeAsync(self, url, httpVerb="PURGE"):\n                 self.purged.append(url)\n \n         purger = FauxPurger()\n@@ -423,7 +417,7 @@ def purgeAsync(self, url, httpVerb=\'PURGE\'):\n \n         notify(PubSuccess(request))\n         self.assertSetEqual(\n-            {\'http://localhost:1234/foo\', \'http://localhost:1234/bar\'},\n+            {"http://localhost:1234/foo", "http://localhost:1234/bar"},\n             set(purger.purged),\n         )\n \ndiff --git a/plone/cachepurging/tests/test_purger.py b/plone/cachepurging/tests/test_purger.py\nindex aec27d2..cff450a 100644\n--- a/plone/cachepurging/tests/test_purger.py\n+++ b/plone/cachepurging/tests/test_purger.py\n@@ -16,14 +16,10 @@\n \n # Define a test HTTP server that returns canned responses\n \n-SERVER_PORT = int(os.environ.get(\'ZSERVER_PORT\', 8765))\n+SERVER_PORT = int(os.environ.get("ZSERVER_PORT", 8765))\n \n \n class TestHandler(BaseHTTPRequestHandler):\n-\n-    def log_message(self, format, *args):\n-        pass\n-\n     def do_PURGE(self):\n         # Get the pre-defined response from the server\'s queue.\n         try:\n@@ -33,39 +29,38 @@ def do_PURGE(self):\n             print(self.command, self.path, self.protocol_version)\n             for h, v in self.headers.items():\n                 print("%s: %s" % (h, v))\n-            raise RuntimeError(\'Unexpected connection\')\n+            raise RuntimeError("Unexpected connection")\n \n         # We may have a function to call to check things.\n-        validator = nr.get(\'validator\')\n+        validator = nr.get("validator")\n         if validator:\n             validator(self)\n \n         # We may have to wake up some other code now the test connection\n         # has been made, but before the response is sent.\n-        waiter = nr.get(\'waiter\')\n+        waiter = nr.get("waiter")\n         if waiter:\n             waiter.acquire()\n             waiter.release()\n \n         # for now, response=None means simulate an unexpected error.\n-        if nr[\'response\'] is None:\n+        if nr["response"] is None:\n             self.rfile.close()\n             return\n \n         # Send the response.\n-        self.send_response(nr[\'response\'])\n-        headers = nr.get(\'headers\', None)\n+        self.send_response(nr["response"])\n+        headers = nr.get("headers", None)\n         if headers:\n             for h, v in headers.items():\n                 self.send_header(h, v)\n-        data = nr.get(\'data\', b\'\')\n+        data = nr.get("data", b"")\n         self.send_header("Content-Length", len(data))\n         self.end_headers()\n         self.wfile.write(data)\n \n \n class TestHTTPServer(HTTPServer):\n-\n     def __init__(self, address, handler):\n         HTTPServer.__init__(self, address, handler)\n         self.response_queue = queue.Queue()\n@@ -73,11 +68,11 @@ def __init__(self, address, handler):\n     def queue_response(self, **kw):\n         self.response_queue.put(kw)\n \n+\n # Finally the test suites.\n \n \n class TestCase(unittest.TestCase):\n-\n     def setUp(self):\n         self.purger = DefaultPurger()\n         self.httpd, self.httpt = self.startServer()\n@@ -91,8 +86,6 @@ def tearDown(self):\n                     if self.httpd.response_queue.empty():\n                         break\n                     time.sleep(0.1)\n-                self.assertTrue(self.httpd.response_queue.empty(),\n-                                "response queue not consumed")\n             if not self.purger.stopThreads(wait=True):\n                 self.fail("The purge threads did not stop")\n         finally:\n@@ -112,7 +105,7 @@ def startServer(self, port=SERVER_PORT, start=True):\n         """Start a TestHTTPServer in a separate thread, returning a tuple\n         (server, thread). If start is true, the thread is started.\n         """\n-        server_address = (\'localhost\', port)\n+        server_address = ("localhost", port)\n         httpd = TestHTTPServer(server_address, TestHandler)\n         t = threading.Thread(target=httpd.serve_forever)\n         if start:\n@@ -121,10 +114,8 @@ def startServer(self, port=SERVER_PORT, start=True):\n \n \n class TestSync(TestCase):\n-\n     def setUp(self):\n         super(TestSync, self).setUp()\n-        self.purger.http_1_1 = True\n         self.maxDiff = None\n \n     def tearDown(self):\n@@ -137,33 +128,23 @@ def dispatchURL(self, path, method="PURGE", port=SERVER_PORT):\n     def testSimpleSync(self):\n         self.httpd.queue_response(response=200)\n         resp = self.dispatchURL("/foo")\n-        self.assertEqual((200, \'\', \'\'), resp)\n+        self.assertEqual((200, "", ""), resp)\n \n     def testHeaders(self):\n-        headers = {\'X-Squid-Error\': \'error text\',\n-                   \'X-Cache\': \'a message\',\n-                   }\n+        headers = {"X-Squid-Error": "error text", "X-Cache": "a message"}\n         self.httpd.queue_response(response=200, headers=headers)\n         status, msg, err = self.dispatchURL("/foo")\n-        self.assertEqual(msg, \'a message\')\n-        self.assertEqual(err, \'error text\')\n+        self.assertEqual(msg, "a message")\n+        self.assertEqual(err, "error text")\n         self.assertEqual(status, 200)\n \n     def testError(self):\n         self.httpd.queue_response(response=None)\n         status, msg, err = self.dispatchURL("/foo")\n-        self.assertEqual(status, \'ERROR\')\n-\n-\n-class TestSyncHTTP10(TestSync):\n-\n-    def setUp(self):\n-        super(TestSync, self).setUp()\n-        self.purger.http_1_1 = False\n+        self.assertEqual(status, "ERROR")\n \n \n class TestAsync(TestCase):\n-\n     def dispatchURL(self, path, method="PURGE", port=SERVER_PORT):\n         url = "http://localhost:%s%s" % (port, path)\n         self.purger.purgeAsync(url, method)\n@@ -188,14 +169,31 @@ def testAsyncError(self):\n         # In this test we arrange for an error condition in the middle\n         # of 2 items - this forces the server into its retry condition.\n         self.httpd.queue_response(response=200)\n-        self.httpd.queue_response(response=None)\n+        self.httpd.queue_response(response=500)\n         self.httpd.queue_response(response=200)\n         self.dispatchURL("/foo")  # will consume first.\n         self.dispatchURL("/bar")  # will consume error, then retry\n+        self.assertTrue(\n+            self.httpd.response_queue.empty(),\n+            "Left items behind in HTTPD response queue."\n+        )\n+\n+    def testAsyncNotFOund(self):\n+        self.httpd.queue_response(response=404)\n+        self.httpd.queue_response(response=200)\n+        self.dispatchURL("/foo")  # works\n+        self.assertFalse(\n+            self.httpd.response_queue.empty(),\n+            "404 was retried instead of consumed."\n+        )\n+        self.dispatchURL("/foo")  # works\n+        self.assertTrue(\n+            self.httpd.response_queue.empty(),\n+            "Left items behind in HTTPD response queue."\n+        )\n \n \n class TestAsyncConnectionFailure(TestCase):\n-\n     def setUp(self):\n         # Override setup to not start the server immediately\n         self.purger = DefaultPurger()\ndiff --git a/plone/cachepurging/tests/test_rewrite.py b/plone/cachepurging/tests/test_rewrite.py\nindex 238bc26..49e5193 100644\n--- a/plone/cachepurging/tests/test_rewrite.py\n+++ b/plone/cachepurging/tests/test_rewrite.py\n@@ -16,7 +16,6 @@ class FauxRequest(dict):\n \n \n class TestRewrite(unittest.TestCase):\n-\n     def setUp(self):\n         self.request = FauxRequest()\n         self.rewriter = DefaultRewriter(self.request)\n@@ -28,43 +27,51 @@ def tearDown(self):\n     def _prepareVHMRequest(\n         self,\n         path,\n-        domain=\'example.com\',\n-        root=\'/plone\',\n-        prefix=\'\',\n-        protocol=\'http\'\n+        domain="example.com",\n+        root="/plone",\n+        prefix="",\n+        protocol="http",\n     ):\n-        translatedPrefix = \'/\'.join([\'_vh_%s\' % p for p in prefix.split(\'/\')])\n-\n-        self.request[\'URL\'] = \'%s://%s%s%s\' % (protocol, domain, prefix, path,)\n-        self.request[\n-            \'ACTUAL_URL\'] = \'%s://%s%s%s\' % (protocol, domain, prefix, path,)\n-        self.request[\'SERVER_URL\'] = \'%s://%s\' % (protocol, domain,)\n-        self.request[\'PATH_INFO\'] = (\n-            \'/VirtualHostBase/%s/%s:80%s/\'\n-            \'VirtualHostRoot%s%s\' % (\n-                protocol, domain, root, translatedPrefix, path,\n-            )\n+        translatedPrefix = "/".join(["_vh_%s" % p for p in prefix.split("/")])\n+\n+        self.request["URL"] = "%s://%s%s%s" % (protocol, domain, prefix, path)\n+        self.request["ACTUAL_URL"] = "%s://%s%s%s" % (\n+            protocol,\n+            domain,\n+            prefix,\n+            path,\n+        )\n+        self.request["SERVER_URL"] = "%s://%s" % (protocol, domain)\n+        self.request["PATH_INFO"] = (\n+            "/VirtualHostBase/%s/%s:80%s/"\n+            "VirtualHostRoot%s%s"\n+            % (protocol, domain, root, translatedPrefix, path)\n         )\n-        self.request[\'VIRTUAL_URL\'] = \'%s://%s%s\' % (protocol, domain, path)\n+        self.request["VIRTUAL_URL"] = "%s://%s%s" % (protocol, domain, path)\n \n         if prefix:\n-            self.request[\'VIRTUAL_URL_PARTS\'] = (\n-                \'%s://%s\' % (protocol, domain,), prefix[1:], path[1:])\n+            self.request["VIRTUAL_URL_PARTS"] = (\n+                "%s://%s" % (protocol, domain),\n+                prefix[1:],\n+                path[1:],\n+            )\n         else:\n-            self.request[\'VIRTUAL_URL_PARTS\'] = (\n-                \'%s://%s\' % (protocol, domain,), path[1:])\n+            self.request["VIRTUAL_URL_PARTS"] = (\n+                "%s://%s" % (protocol, domain),\n+                path[1:],\n+            )\n \n-        self.request[\'VirtualRootPhysicalPath\'] = tuple(root.split(\'/\'))\n+        self.request["VirtualRootPhysicalPath"] = tuple(root.split("/"))\n \n     def test_no_registry(self):\n-        self._prepareVHMRequest(\'/foo\')\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self._prepareVHMRequest("/foo")\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_no_settings(self):\n         registry = Registry()\n         provideUtility(registry, IRegistry)\n-        self._prepareVHMRequest(\'/foo\')\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self._prepareVHMRequest("/foo")\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_virtual_hosting_disabled(self):\n         registry = Registry()\n@@ -73,8 +80,8 @@ def test_virtual_hosting_disabled(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = False\n \n-        self._prepareVHMRequest(\'/foo\')\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self._prepareVHMRequest("/foo")\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_empty_request(self):\n         registry = Registry()\n@@ -84,7 +91,7 @@ def test_empty_request(self):\n         settings.virtualHosting = True\n \n         self.request.clear()\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_no_virtual_url(self):\n         registry = Registry()\n@@ -93,9 +100,9 @@ def test_no_virtual_url(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\')\n-        del self.request[\'VIRTUAL_URL\']\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self._prepareVHMRequest("/foo")\n+        del self.request["VIRTUAL_URL"]\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_no_virtual_url_parts(self):\n         registry = Registry()\n@@ -104,9 +111,9 @@ def test_no_virtual_url_parts(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\')\n-        del self.request[\'VIRTUAL_URL_PARTS\']\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self._prepareVHMRequest("/foo")\n+        del self.request["VIRTUAL_URL_PARTS"]\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_no_virtual_root_physical_path(self):\n         registry = Registry()\n@@ -115,9 +122,9 @@ def test_no_virtual_root_physical_path(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\')\n-        del self.request[\'VirtualRootPhysicalPath\']\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self._prepareVHMRequest("/foo")\n+        del self.request["VirtualRootPhysicalPath"]\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_malformed_virtual_url_parts(self):\n         registry = Registry()\n@@ -126,20 +133,24 @@ def test_malformed_virtual_url_parts(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\')\n+        self._prepareVHMRequest("/foo")\n \n-        self.request[\'VIRTUAL_URL_PARTS\'] = (\'foo\',)\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self.request["VIRTUAL_URL_PARTS"] = ("foo",)\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n-        self.request[\'VIRTUAL_URL_PARTS\'] = ()\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self.request["VIRTUAL_URL_PARTS"] = ()\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n-        self.request[\'VIRTUAL_URL_PARTS\'] = (\n-            \'http://example.com\', \'\', \'/foo\', \'x\')\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self.request["VIRTUAL_URL_PARTS"] = (\n+            "http://example.com",\n+            "",\n+            "/foo",\n+            "x",\n+        )\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n-        self.request[\'VIRTUAL_URL_PARTS\'] = \'foo\'\n-        self.assertEqual([\'/foo\'], self.rewriter(\'/foo\'))\n+        self.request["VIRTUAL_URL_PARTS"] = "foo"\n+        self.assertEqual(["/foo"], self.rewriter("/foo"))\n \n     def test_standard_vhm(self):\n         registry = Registry()\n@@ -148,10 +159,10 @@ def test_standard_vhm(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\')\n+        self._prepareVHMRequest("/foo")\n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/plone/VirtualHostRoot/foo\'],\n-            self.rewriter(\'/foo\')\n+            ["/VirtualHostBase/http/example.com/plone/VirtualHostRoot/foo"],\n+            self.rewriter("/foo"),\n         )\n \n     def test_virtual_root_is_app_root(self):\n@@ -161,11 +172,11 @@ def test_virtual_root_is_app_root(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\', root=\'/\')\n+        self._prepareVHMRequest("/foo", root="/")\n \n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/VirtualHostRoot/foo\'],\n-            self.rewriter(\'/foo\')\n+            ["/VirtualHostBase/http/example.com/VirtualHostRoot/foo"],\n+            self.rewriter("/foo"),\n         )\n \n     def test_virtual_root_is_deep(self):\n@@ -175,12 +186,14 @@ def test_virtual_root_is_deep(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\', root=\'/bar/plone\')\n+        self._prepareVHMRequest("/foo", root="/bar/plone")\n \n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/bar/plone/\'\n-             \'VirtualHostRoot/foo\'],\n-            self.rewriter(\'/foo\')\n+            [\n+                "/VirtualHostBase/http/example.com/bar/plone/"\n+                "VirtualHostRoot/foo"\n+            ],\n+            self.rewriter("/foo"),\n         )\n \n     def test_inside_out_hosting(self):\n@@ -190,12 +203,15 @@ def test_inside_out_hosting(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\', root=\'/bar/plone\', prefix=\'/foo/bar\')\n+        self._prepareVHMRequest("/foo", root="/bar/plone", prefix="/foo/bar")\n \n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/bar/plone/\'\n-             \'VirtualHostRoot/_vh_foo/_vh_bar/foo\'],\n-            self.rewriter(\'/foo\'))\n+            [\n+                "/VirtualHostBase/http/example.com/bar/plone/"\n+                "VirtualHostRoot/_vh_foo/_vh_bar/foo"\n+            ],\n+            self.rewriter("/foo"),\n+        )\n \n     def test_inside_out_hosting_root_empty_path(self):\n         registry = Registry()\n@@ -204,12 +220,15 @@ def test_inside_out_hosting_root_empty_path(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/\', root=\'/plone\', prefix=\'/plone\')\n+        self._prepareVHMRequest("/", root="/plone", prefix="/plone")\n \n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/plone/\'\n-             \'VirtualHostRoot/_vh_plone\'],\n-            self.rewriter(\'\'))\n+            [\n+                "/VirtualHostBase/http/example.com/plone/"\n+                "VirtualHostRoot/_vh_plone"\n+            ],\n+            self.rewriter(""),\n+        )\n \n     def test_virtual_path_is_root(self):\n         registry = Registry()\n@@ -218,11 +237,11 @@ def test_virtual_path_is_root(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/\', root=\'/plone\')\n+        self._prepareVHMRequest("/", root="/plone")\n \n-        self.assertEqual([\n-            \'/VirtualHostBase/http/example.com/plone/VirtualHostRoot/\'],\n-            self.rewriter(\'/\')\n+        self.assertEqual(\n+            ["/VirtualHostBase/http/example.com/plone/VirtualHostRoot/"],\n+            self.rewriter("/"),\n         )\n \n     def test_virtual_path_is_empty(self):\n@@ -232,11 +251,11 @@ def test_virtual_path_is_empty(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'\', root=\'/plone\')\n+        self._prepareVHMRequest("", root="/plone")\n \n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/plone/VirtualHostRoot\'],\n-            self.rewriter(\'\')\n+            ["/VirtualHostBase/http/example.com/plone/VirtualHostRoot"],\n+            self.rewriter(""),\n         )\n \n     def test_virtual_path_is_deep(self):\n@@ -246,12 +265,14 @@ def test_virtual_path_is_deep(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo/bar\', root=\'/plone\')\n+        self._prepareVHMRequest("/foo/bar", root="/plone")\n \n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com/plone/\'\n-             \'VirtualHostRoot/foo/bar\'],\n-            self.rewriter(\'/foo/bar\')\n+            [\n+                "/VirtualHostBase/http/example.com/plone/"\n+                "VirtualHostRoot/foo/bar"\n+            ],\n+            self.rewriter("/foo/bar"),\n         )\n \n     def test_nonstandard_port(self):\n@@ -261,10 +282,10 @@ def test_nonstandard_port(self):\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n \n-        self._prepareVHMRequest(\'/foo\', domain=\'example.com:81\')\n+        self._prepareVHMRequest("/foo", domain="example.com:81")\n         self.assertEqual(\n-            [\'/VirtualHostBase/http/example.com:81/plone/VirtualHostRoot/foo\'],\n-            self.rewriter(\'/foo\')\n+            ["/VirtualHostBase/http/example.com:81/plone/VirtualHostRoot/foo"],\n+            self.rewriter("/foo"),\n         )\n \n     def test_https(self):\n@@ -275,11 +296,14 @@ def test_https(self):\n         settings.virtualHosting = True\n \n         self._prepareVHMRequest(\n-            \'/foo\', domain=\'example.com:81\', protocol=\'https\')\n+            "/foo", domain="example.com:81", protocol="https"\n+        )\n         self.assertEqual(\n-            [\'/VirtualHostBase/https/example.com:81/plone/\'\n-             \'VirtualHostRoot/foo\'],\n-            self.rewriter(\'/foo\')\n+            [\n+                "/VirtualHostBase/https/example.com:81/plone/"\n+                "VirtualHostRoot/foo"\n+            ],\n+            self.rewriter("/foo"),\n         )\n \n     def test_domains(self):\n@@ -288,18 +312,19 @@ def test_domains(self):\n         registry.registerInterface(ICachePurgingSettings)\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n-        settings.domains = (\'http://example.org:81\', \'https://example.com:82\')\n+        settings.domains = ("http://example.org:81", "https://example.com:82")\n \n         self._prepareVHMRequest(\n-            \'/foo\', domain=\'example.com:81\', protocol=\'https\')\n+            "/foo", domain="example.com:81", protocol="https"\n+        )\n         self.assertEqual(\n             [\n-                \'/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/\'\n-                \'foo\',\n-                \'/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/\'\n-                \'foo\'\n+                "/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/"\n+                "foo",\n+                "/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/"\n+                "foo",\n             ],\n-            self.rewriter(\'/foo\')\n+            self.rewriter("/foo"),\n         )\n \n     def test_domains_w_different_path_in_request(self):\n@@ -308,18 +333,19 @@ def test_domains_w_different_path_in_request(self):\n         registry.registerInterface(ICachePurgingSettings)\n         settings = registry.forInterface(ICachePurgingSettings)\n         settings.virtualHosting = True\n-        settings.domains = (\'http://example.org:81\', \'https://example.com:82\')\n+        settings.domains = ("http://example.org:81", "https://example.com:82")\n \n         self._prepareVHMRequest(\n-            \'/bar\', domain=\'example.com:81\', protocol=\'https\')\n+            "/bar", domain="example.com:81", protocol="https"\n+        )\n         self.assertEqual(\n             [\n-                \'/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/\'\n-                \'foo\',\n-                \'/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/\'\n-                \'foo\'\n+                "/VirtualHostBase/http/example.org:81/plone/VirtualHostRoot/"\n+                "foo",\n+                "/VirtualHostBase/https/example.com:82/plone/VirtualHostRoot/"\n+                "foo",\n             ],\n-            self.rewriter(\'/foo\')\n+            self.rewriter("/foo"),\n         )\n \n \ndiff --git a/plone/cachepurging/tests/test_traversable_paths.py b/plone/cachepurging/tests/test_traversable_paths.py\nindex cb5fcec..06fd19a 100644\n--- a/plone/cachepurging/tests/test_traversable_paths.py\n+++ b/plone/cachepurging/tests/test_traversable_paths.py\n@@ -8,19 +8,17 @@\n \n @implementer(ITraversable)\n class FauxTraversable(object):\n-\n     def virtual_url_path(self):\n-        return \'foo\'\n+        return "foo"\n \n \n class TestTraversablePaths(unittest.TestCase):\n-\n     def test_traversable_paths(self):\n \n         context = FauxTraversable()\n         paths = TraversablePurgePaths(context)\n \n-        self.assertEqual([\'/foo\'], paths.getRelativePaths())\n+        self.assertEqual(["/foo"], paths.getRelativePaths())\n         self.assertEqual([], paths.getAbsolutePaths())\n \n \ndiff --git a/plone/cachepurging/tests/test_utils.py b/plone/cachepurging/tests/test_utils.py\nindex 89a3ce3..73b3dfb 100644\n--- a/plone/cachepurging/tests/test_utils.py\n+++ b/plone/cachepurging/tests/test_utils.py\n@@ -24,7 +24,6 @@ class FauxRequest(dict):\n \n \n class TestIsCachingEnabled(unittest.TestCase):\n-\n     def setUp(self):\n         provideAdapter(persistentFieldAdapter)\n \n@@ -70,7 +69,6 @@ def test_passed_registry(self):\n \n \n class TestGetPathsToPurge(unittest.TestCase):\n-\n     def setUp(self):\n         self.context = FauxContext()\n         self.request = FauxRequest()\n@@ -80,14 +78,13 @@ def tearDown(self):\n \n     def test_no_purge_paths(self):\n         self.assertEqual(\n-            [], list(utils.getPathsToPurge(self.context, self.request)))\n+            [], list(utils.getPathsToPurge(self.context, self.request))\n+        )\n \n     def test_empty_relative_paths(self):\n-\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n@@ -100,153 +97,146 @@ def getAbsolutePaths(self):\n         provideAdapter(FauxPurgePaths, name="test1")\n \n         self.assertEqual(\n-            [], list(utils.getPathsToPurge(self.context, self.request)))\n+            [], list(utils.getPathsToPurge(self.context, self.request))\n+        )\n \n     def test_no_rewriter(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n-                return [\'/baz\']\n+                return ["/baz"]\n \n         provideAdapter(FauxPurgePaths, name="test1")\n \n-        self.assertEqual([\'/foo\', \'/bar\', \'/baz\'],\n-                         list(utils.getPathsToPurge(self.context, self.request)))\n+        self.assertEqual(\n+            ["/foo", "/bar", "/baz"],\n+            list(utils.getPathsToPurge(self.context, self.request)),\n+        )\n \n     def test_test_rewriter(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n-                return [\'/baz\']\n+                return ["/baz"]\n \n         provideAdapter(FauxPurgePaths, name="test1")\n \n         @implementer(IPurgePathRewriter)\n         @adapter(FauxRequest)\n         class DefaultRewriter(object):\n-\n             def __init__(self, request):\n                 self.request = request\n \n             def __call__(self, path):\n-                return [\'/vhm1\' + path, \'/vhm2\' + path]\n+                return ["/vhm1" + path, "/vhm2" + path]\n \n         provideAdapter(DefaultRewriter)\n \n-        self.assertEqual([\'/vhm1/foo\', \'/vhm2/foo\',\n-                          \'/vhm1/bar\', \'/vhm2/bar\',\n-                          \'/baz\'],\n-                         list(utils.getPathsToPurge(self.context, self.request)))\n+        self.assertEqual(\n+            ["/vhm1/foo", "/vhm2/foo", "/vhm1/bar", "/vhm2/bar", "/baz"],\n+            list(utils.getPathsToPurge(self.context, self.request)),\n+        )\n \n     def test_multiple_purge_paths(self):\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths1(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n-                return [\'/baz\']\n+                return ["/baz"]\n \n         provideAdapter(FauxPurgePaths1, name="test1")\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths2(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo/view\']\n+                return ["/foo/view"]\n \n             def getAbsolutePaths(self):\n-                return [\'/quux\']\n+                return ["/quux"]\n \n         provideAdapter(FauxPurgePaths2, name="test2")\n \n         @implementer(IPurgePathRewriter)\n         @adapter(FauxRequest)\n         class DefaultRewriter(object):\n-\n             def __init__(self, request):\n                 self.request = request\n \n             def __call__(self, path):\n-                return [\'/vhm1\' + path, \'/vhm2\' + path]\n+                return ["/vhm1" + path, "/vhm2" + path]\n \n         provideAdapter(DefaultRewriter)\n \n         self.assertEqual(\n             [\n-                \'/vhm1/foo\',\n-                \'/vhm2/foo\',\n-                \'/vhm1/bar\',\n-                \'/vhm2/bar\',\n-                \'/baz\',\n-                \'/vhm1/foo/view\',\n-                \'/vhm2/foo/view\',\n-                \'/quux\'\n+                "/vhm1/foo",\n+                "/vhm2/foo",\n+                "/vhm1/bar",\n+                "/vhm2/bar",\n+                "/baz",\n+                "/vhm1/foo/view",\n+                "/vhm2/foo/view",\n+                "/quux",\n             ],\n-            list(utils.getPathsToPurge(self.context, self.request))\n+            list(utils.getPathsToPurge(self.context, self.request)),\n         )\n \n     def test_rewriter_abort(self):\n-\n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths1(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n-                return [\'/baz\']\n+                return ["/baz"]\n \n         provideAdapter(FauxPurgePaths1, name="test1")\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths2(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo/view\']\n+                return ["/foo/view"]\n \n             def getAbsolutePaths(self):\n-                return [\'/quux\']\n+                return ["/quux"]\n \n         provideAdapter(FauxPurgePaths2, name="test2")\n \n         @implementer(IPurgePathRewriter)\n         @adapter(FauxRequest)\n         class DefaultRewriter(object):\n-\n             def __init__(self, request):\n                 self.request = request\n \n@@ -256,36 +246,35 @@ def __call__(self, path):\n         provideAdapter(DefaultRewriter)\n \n         self.assertEqual(\n-            [\'/baz\', \'/quux\'],\n-            list(utils.getPathsToPurge(self.context, self.request))\n+            ["/baz", "/quux"],\n+            list(utils.getPathsToPurge(self.context, self.request)),\n         )\n \n \n class TestGetURLsToPurge(unittest.TestCase):\n-\n     def test_no_proxies(self):\n-        self.assertEqual([], list(utils.getURLsToPurge(\'/foo\', [])))\n+        self.assertEqual([], list(utils.getURLsToPurge("/foo", [])))\n \n     def test_absolute_path(self):\n         self.assertEqual(\n-            [\'http://localhost:1234/foo/bar\', \'http://localhost:2345/foo/bar\'],\n+            ["http://localhost:1234/foo/bar", "http://localhost:2345/foo/bar"],\n             list(\n                 utils.getURLsToPurge(\n-                    \'/foo/bar\',\n-                    [\'http://localhost:1234\', \'http://localhost:2345/\']\n+                    "/foo/bar",\n+                    ["http://localhost:1234", "http://localhost:2345/"],\n                 )\n-            )\n+            ),\n         )\n \n     def test_relative_path(self):\n         self.assertEqual(\n-            [\'http://localhost:1234/foo/bar\', \'http://localhost:2345/foo/bar\'],\n+            ["http://localhost:1234/foo/bar", "http://localhost:2345/foo/bar"],\n             list(\n                 utils.getURLsToPurge(\n-                    \'foo/bar\',\n-                    [\'http://localhost:1234\', \'http://localhost:2345/\']\n+                    "foo/bar",\n+                    ["http://localhost:1234", "http://localhost:2345/"],\n                 )\n-            )\n+            ),\n         )\n \n \ndiff --git a/plone/cachepurging/tests/test_views.py b/plone/cachepurging/tests/test_views.py\nindex 53baf3b..894276c 100644\n--- a/plone/cachepurging/tests/test_views.py\n+++ b/plone/cachepurging/tests/test_views.py\n@@ -27,7 +27,6 @@ class FauxRequest(dict):\n \n \n class Handler(object):\n-\n     def __init__(self):\n         self.invocations = []\n \n@@ -37,7 +36,6 @@ def handler(self, event):\n \n \n class TestQueuePurge(unittest.TestCase):\n-\n     def setUp(self):\n         provideAdapter(persistentFieldAdapter)\n         self.registry = Registry()\n@@ -46,7 +44,7 @@ def setUp(self):\n \n         self.settings = self.registry.forInterface(ICachePurgingSettings)\n         self.settings.enabled = True\n-        self.settings.cachingProxies = (\'http://localhost:1234\',)\n+        self.settings.cachingProxies = ("http://localhost:1234",)\n \n         self.handler = Handler()\n         provideHandler(self.handler.handler)\n@@ -58,7 +56,7 @@ def test_disabled(self):\n         self.settings.enabled = False\n \n         view = QueuePurge(FauxContext(), FauxRequest())\n-        self.assertEqual(\'Caching not enabled\', view())\n+        self.assertEqual("Caching not enabled", view())\n         self.assertEqual([], self.handler.invocations)\n \n     def test_enabled(self):\n@@ -66,13 +64,12 @@ def test_enabled(self):\n \n         context = FauxContext()\n         view = QueuePurge(context, FauxRequest)\n-        self.assertEqual(\'Queued\', view())\n+        self.assertEqual("Queued", view())\n         self.assertEqual(1, len(self.handler.invocations))\n         self.assertTrue(self.handler.invocations[0].object is context)\n \n \n class TestPurgeImmediately(unittest.TestCase):\n-\n     def setUp(self):\n         provideAdapter(persistentFieldAdapter)\n         self.registry = Registry()\n@@ -81,17 +78,16 @@ def setUp(self):\n \n         self.settings = self.registry.forInterface(ICachePurgingSettings)\n         self.settings.enabled = True\n-        self.settings.cachingProxies = (\'http://localhost:1234\',)\n+        self.settings.cachingProxies = ("http://localhost:1234",)\n \n         @implementer(IPurgePaths)\n         @adapter(FauxContext)\n         class FauxPurgePaths(object):\n-\n             def __init__(self, context):\n                 self.context = context\n \n             def getRelativePaths(self):\n-                return [\'/foo\', \'/bar\']\n+                return ["/foo", "/bar"]\n \n             def getAbsolutePaths(self):\n                 return []\n@@ -100,8 +96,7 @@ def getAbsolutePaths(self):\n \n         @implementer(IPurger)\n         class FauxPurger(object):\n-\n-            def purgeSync(self, url, httpVerb=\'PURGE\'):\n+            def purgeSync(self, url, httpVerb="PURGE"):\n                 return "200 OK", "cached", None\n \n         provideUtility(FauxPurger())\n@@ -112,20 +107,20 @@ def tearDown(self):\n     def test_disabled(self):\n         self.settings.enabled = False\n         view = PurgeImmediately(FauxContext(), FauxRequest())\n-        self.assertEqual(\'Caching not enabled\', view())\n+        self.assertEqual("Caching not enabled", view())\n \n     def test_purge(self):\n         view = PurgeImmediately(FauxContext(), FauxRequest())\n         self.assertEqual(\n-            \'Purged: http://localhost:1234/foo, \'\n-            \'Status: 200 OK, \'\n-            \'X-Cache: cached, \'\n-            \'Error: None\\n\'\n-            \'Purged: http://localhost:1234/bar, \'\n-            \'Status: 200 OK, \'\n-            \'X-Cache: cached, \'\n-            \'Error: None\\n\',\n-            view()\n+            "Purged: http://localhost:1234/foo, "\n+            "Status: 200 OK, "\n+            "X-Cache: cached, "\n+            "Error: None\\n"\n+            "Purged: http://localhost:1234/bar, "\n+            "Status: 200 OK, "\n+            "X-Cache: cached, "\n+            "Error: None\\n",\n+            view(),\n         )\n \n \ndiff --git a/plone/cachepurging/utils.py b/plone/cachepurging/utils.py\nindex 7f2a5c5..73d67ec 100644\n--- a/plone/cachepurging/utils.py\n+++ b/plone/cachepurging/utils.py\n@@ -52,10 +52,10 @@ def getURLsToPurge(path, proxies):\n     listed in the registry into account.\n     """\n \n-    if not path.startswith(\'/\'):\n-        path = \'/\' + path\n+    if not path.startswith("/"):\n+        path = "/" + path\n \n     for proxy in proxies:\n-        if proxy.endswith(\'/\'):\n+        if proxy.endswith("/"):\n             proxy = proxy[:-1]\n         yield proxy + path\ndiff --git a/setup.py b/setup.py\nindex f49b2fb..8a3700a 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,49 +1,47 @@\n from setuptools import setup, find_packages\n \n-version = \'1.0.16.dev0\'\n+version = "2.0.dev0"\n \n setup(\n-    name=\'plone.cachepurging\',\n+    name="plone.cachepurging",\n     version=version,\n     description="Cache purging support for Zope 2 applications",\n-    long_description=(open(\'README.rst\').read() + \'\\n\' +\n-                      open(\'CHANGES.rst\').read()),\n+    long_description=(\n+        open("README.rst").read() + "\\n" + open("CHANGES.rst").read()\n+    ),\n     classifiers=[\n-        \'Framework :: Plone\',\n-        \'Framework :: Plone :: 4.3\',\n-        \'Framework :: Plone :: 5.0\',\n-        \'Framework :: Plone :: 5.1\',\n-        \'License :: OSI Approved :: GNU General Public License v2 (GPLv2)\',\n-        \'Programming Language :: Python\',\n-        \'Programming Language :: Python :: 2.7\',\n-        \'Programming Language :: Python :: 3.6\',\n+        "Framework :: Plone",\n+        "Framework :: Plone :: 5.1",\n+        "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n+        "Programming Language :: Python",\n+        "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.6",\n     ],\n-    keywords=\'plone cache purge\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://pypi.python.org/pypi/plone.cachepurging\',\n-    license=\'GPL version 2\',\n-    packages=find_packages(exclude=[\'ez_setup\']),\n-    namespace_packages=[\'plone\'],\n+    keywords="plone cache purge",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://pypi.python.org/pypi/plone.cachepurging",\n+    license="GPL version 2",\n+    packages=find_packages(exclude=["ez_setup"]),\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n-        \'five.globalrequest\',\n-        \'plone.registry\',\n-        \'six\',\n-        \'z3c.caching\',\n-        \'zope.annotation\',\n-        \'zope.component\',\n-        \'zope.event\',\n-        \'zope.i18nmessageid\',\n-        \'zope.interface\',\n-        \'zope.lifecycleevent\',\n-        \'zope.schema\',\n-        \'zope.testing\',\n-        \'Zope2\'\n+        "setuptools",\n+        "five.globalrequest",\n+        "plone.registry",\n+        "requests",\n+        "six",\n+        "z3c.caching",\n+        "zope.annotation",\n+        "zope.component",\n+        "zope.event",\n+        "zope.i18nmessageid",\n+        "zope.interface",\n+        "zope.lifecycleevent",\n+        "zope.schema",\n+        "zope.testing",\n+        "Zope2",\n     ],\n-    extras_require={\n-        \'test\': [\'plone.app.testing\'],\n-    },\n+    extras_require={"test": ["plone.app.testing"]},\n )\n'

