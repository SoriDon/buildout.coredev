Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2022-08-17T19:19:42+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.vocabularies/commit/7ca3b3943a86f4476078c3671cda4f200b8f651c

fix deprecation warnings

Files changed:
M plone/app/vocabularies/actions.py
M plone/app/vocabularies/editors.py
M plone/app/vocabularies/syndication.py

b"diff --git a/plone/app/vocabularies/actions.py b/plone/app/vocabularies/actions.py\nindex c2b3f10..c7de971 100644\n--- a/plone/app/vocabularies/actions.py\n+++ b/plone/app/vocabularies/actions.py\n@@ -1,6 +1,5 @@\n-# -*- coding:utf-8 -*-\n+from plone.base import PloneMessageFactory as _\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone import PloneMessageFactory as _\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\ndiff --git a/plone/app/vocabularies/editors.py b/plone/app/vocabularies/editors.py\nindex 673b5c4..4743b83 100644\n--- a/plone/app/vocabularies/editors.py\n+++ b/plone/app/vocabularies/editors.py\n@@ -1,6 +1,5 @@\n-# -*- coding: utf-8 -*-\n+from plone.base.interfaces import IEditingSchema\n from plone.registry.interfaces import IRegistry\n-from Products.CMFPlone.interfaces import IEditingSchema\n from zope.component import getUtility\n from zope.i18nmessageid import MessageFactory\n from zope.interface import implementer\ndiff --git a/plone/app/vocabularies/syndication.py b/plone/app/vocabularies/syndication.py\nindex 218b9bc..3753015 100644\n--- a/plone/app/vocabularies/syndication.py\n+++ b/plone/app/vocabularies/syndication.py\n@@ -1,4 +1,5 @@\n-# -*- coding: utf-8 -*-\n+from plone.base.interfaces import ISiteSyndicationSettings\n+from plone.base import MessageFactory as _\n from plone.registry.interfaces import IRegistry\n from Products.CMFCore.utils import getToolByName\n from zope.component import getUtility\n@@ -9,26 +10,11 @@\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n-import six\n-\n-\n-try:\n-    # XXX: this is a circular dependency (not declared in setup.py)\n-    from Products.CMFPlone.interfaces.syndication import ISiteSyndicationSettings  # noqa\n-    HAS_SYNDICATION = True\n-except ImportError:\n-    # new syndication not available\n-    HAS_SYNDICATION = False\n-\n-_ = MessageFactory('plone')\n-\n \n @implementer(IVocabularyFactory)\n class SyndicationFeedTypesVocabulary(object):\n \n     def __call__(self, context):\n-        if not HAS_SYNDICATION:\n-            return SimpleVocabulary([])\n         registry = getUtility(IRegistry)\n         try:\n             settings = registry.forInterface(ISiteSyndicationSettings)\n@@ -61,7 +47,7 @@ def __call__(self, context):\n         for brain in catalog(**query):\n             uid = brain.UID\n             title = brain.Title\n-            if isinstance(title, six.binary_type):\n+            if isinstance(title, bytes):\n                 title = title.decode('utf8')\n             title = u'{0}({1})'.format(\n                 title,\n"

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2022-08-17T19:40:08+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.vocabularies/commit/7150a7f445a5f61899a64c1b8198017c42e142bd

cleanup dependencies and metadata, bump to version 5.0

Files changed:
M setup.cfg
M setup.py

b"diff --git a/setup.cfg b/setup.cfg\nindex 9cd9d89..fe8b457 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -2,10 +2,7 @@\n universal = 1\n \n [isort]\n-force_alphabetical_sort = True\n-force_single_line = True\n-lines_after_imports = 2\n-line_length = 79\n-not_skip = __init__.py\n-use_parentheses = True\n-multi_line_output = 3\n\\ No newline at end of file\n+profile = black\n+force_alphabetical_sort=True\n+force_single_line=True\n+lines_after_imports=2\n\\ No newline at end of file\ndiff --git a/setup.py b/setup.py\nindex 88f1bfb..d357204 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,32 +1,26 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n \n-version = '4.3.1.dev0'\n+version = '5.0.0.dev0'\n \n setup(\n     name='plone.app.vocabularies',\n     version=version,\n     description='Collection of generally useful vocabularies for Plone.',\n     long_description='{0}\\n{1}'.format(\n-        open('README.rst').read(),\n-        open('CHANGES.rst').read()\n+        open('README.rst').read(), open('CHANGES.rst').read()\n     ),\n     classifiers=[\n         'Development Status :: 6 - Mature',\n         'Environment :: Web Environment',\n         'Framework :: Plone',\n         'Framework :: Plone :: Core',\n-        'Framework :: Plone :: 5.2',\n         'Framework :: Plone :: 6.0',\n-        'Framework :: Zope2',\n-        'Framework :: Zope :: 4',\n+        'Framework :: Zope :: 5',\n         'License :: OSI Approved :: GNU General Public License v2 (GPLv2)',\n         'Operating System :: OS Independent',\n         'Programming Language :: Python',\n-        'Programming Language :: Python :: 2.7',\n-        'Programming Language :: Python :: 3.6',\n         'Programming Language :: Python :: 3.7',\n         'Programming Language :: Python :: 3.8',\n         'Programming Language :: Python :: 3.9',\n@@ -41,20 +35,10 @@\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        'Acquisition',\n         'plone.app.querystring',\n-        'Products.CMFCore',\n+        'plone.base',\n         'pytz',\n         'setuptools',\n-        'six',\n-        'zope.browser',\n-        'zope.component',\n-        'zope.i18n',\n-        'zope.i18nmessageid',\n-        'zope.interface',\n-        'zope.schema',\n-        'zope.site',\n-        'Zope2',\n     ],\n     extras_require=dict(\n         test=[\n"

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2022-08-18T08:25:30+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.vocabularies/commit/f0daefb44b84bb0b192afcc5e594a42d80e7a658

update to use plone.base and along with it isort/balck on those files

Files changed:
M plone/app/vocabularies/catalog.py
M plone/app/vocabularies/metadatafields.py
M plone/app/vocabularies/terms.py
M plone/app/vocabularies/tests/test_editors.py
M plone/app/vocabularies/workflow.py
M pyproject.toml
M setup.py

b'diff --git a/plone/app/vocabularies/catalog.py b/plone/app/vocabularies/catalog.py\nindex a006e9e..1c48da8 100644\n--- a/plone/app/vocabularies/catalog.py\n+++ b/plone/app/vocabularies/catalog.py\n@@ -1,9 +1,7 @@\n-# -*- coding: utf-8 -*-\n from BTrees.IIBTree import intersection\n from plone.app.layout.navigation.root import getNavigationRootObject\n from plone.app.vocabularies import SlicableVocabulary\n from plone.app.vocabularies.terms import BrowsableTerm\n-from plone.app.vocabularies.terms import safe_encode\n from plone.app.vocabularies.terms import safe_simplevocabulary_from_values\n from plone.app.vocabularies.utils import parseQueryString\n from plone.memoize.instance import memoize\n@@ -11,7 +9,7 @@\n from plone.registry.interfaces import IRegistry\n from plone.uuid.interfaces import IUUID\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.utils import safe_unicode\n+from plone.base.utils import safe_text\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n from Products.ZCTextIndex.ParseTree import ParseError\n from z3c.formwidget.query.interfaces import IQuerySource\n@@ -25,12 +23,7 @@\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n from zope.component.hooks import getSite\n-\n-try:\n-    from zope.globalrequest import getRequest\n-except ImportError:\n-    def getRequest():\n-        return None\n+from zope.globalrequest import getRequest\n \n import itertools\n import json\n@@ -48,78 +41,78 @@ class ISourceQueryView(Interface):\n         pass\n \n \n-def parse_query(query, path_prefix=\'\'):\n-    """ Parse the query string and turn it into a dictionary for querying the\n-        catalog.\n+def parse_query(query, path_prefix=""):\n+    """Parse the query string and turn it into a dictionary for querying the\n+    catalog.\n \n-        We want to find anything which starts with the given string, so we add\n-        a * at the end of words.\n+    We want to find anything which starts with the given string, so we add\n+    a * at the end of words.\n \n-        >>> parse_query(\'foo\')\n-        {\'SearchableText\': \'foo*\'}\n+    >>> parse_query(\'foo\')\n+    {\'SearchableText\': \'foo*\'}\n \n-        If we have more than one word, each of them should have the * and\n-        they should be combined with the AND operator.\n+    If we have more than one word, each of them should have the * and\n+    they should be combined with the AND operator.\n \n-        >>> parse_query(\'foo bar\')\n-        {\'SearchableText\': \'foo* AND bar*\'}\n+    >>> parse_query(\'foo bar\')\n+    {\'SearchableText\': \'foo* AND bar*\'}\n \n-        We also filter out some special characters. They are handled like\n-        spaces and seperate words from each other.\n+    We also filter out some special characters. They are handled like\n+    spaces and seperate words from each other.\n \n-        >>> parse_query(\'foo +bar some-thing\')\n-        {\'SearchableText\': \'foo* AND bar* AND some* AND thing*\'}\n+    >>> parse_query(\'foo +bar some-thing\')\n+    {\'SearchableText\': \'foo* AND bar* AND some* AND thing*\'}\n \n-        >>> parse_query(\'what? (spam) *ham\')\n-        {\'SearchableText\': \'what* AND spam* AND ham*\'}\n+    >>> parse_query(\'what? (spam) *ham\')\n+    {\'SearchableText\': \'what* AND spam* AND ham*\'}\n \n-        You can also limit searches to paths, if you only supply the path,\n-        then all contents of that folder will be searched. If you supply\n-        additional search words, then all subfolders are searched as well.\n+    You can also limit searches to paths, if you only supply the path,\n+    then all contents of that folder will be searched. If you supply\n+    additional search words, then all subfolders are searched as well.\n \n-        >>> expected = {\'path\': {\'query\': \'/dummy\', \'depth\': 1}}\n-        >>> parse_query(\'path:/dummy\') == expected\n-        True\n+    >>> expected = {\'path\': {\'query\': \'/dummy\', \'depth\': 1}}\n+    >>> parse_query(\'path:/dummy\') == expected\n+    True\n \n-        >>> expected = {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'bar*\'}\n-        >>> parse_query(\'bar path:/dummy\') == expected\n-        True\n+    >>> expected = {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'bar*\'}\n+    >>> parse_query(\'bar path:/dummy\') == expected\n+    True\n \n-        >>> expected = {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'foo*\'}\n-        >>> parse_query(\'path:/dummy foo\') == expected\n-        True\n+    >>> expected = {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'foo*\'}\n+    >>> parse_query(\'path:/dummy foo\') == expected\n+    True\n \n-        If you supply more then one path, then only the last one is used.\n+    If you supply more then one path, then only the last one is used.\n \n-        >>> expected = {\'path\': {\'query\': \'/spam\', \'depth\': 1}}\n-        >>> parse_query(\'path:/dummy path:/spam\') == expected\n-        True\n+    >>> expected = {\'path\': {\'query\': \'/spam\', \'depth\': 1}}\n+    >>> parse_query(\'path:/dummy path:/spam\') == expected\n+    True\n \n-        You can also provide a prefix for the path. This is useful for virtual\n-        hosting.\n+    You can also provide a prefix for the path. This is useful for virtual\n+    hosting.\n \n-        >>> expected = {\'path\': {\'query\': \'/portal/dummy\', \'depth\': 1}}\n-        >>> parse_query(\'path:/dummy\', path_prefix=\'/portal\') == expected\n-        True\n+    >>> expected = {\'path\': {\'query\': \'/portal/dummy\', \'depth\': 1}}\n+    >>> parse_query(\'path:/dummy\', path_prefix=\'/portal\') == expected\n+    True\n \n     """\n     query_parts = query.split()\n-    query = {\'SearchableText\': []}\n+    query = {"SearchableText": []}\n     for part in query_parts:\n-        if part.startswith(\'path:\'):\n+        if part.startswith("path:"):\n             path = part[5:]\n-            query[\'path\'] = {\'query\': path}\n+            query["path"] = {"query": path}\n         else:\n-            query[\'SearchableText\'].append(part)\n-    text = \' \'.join(query[\'SearchableText\'])\n-    for char in \'?-+*()\':\n-        text = text.replace(char, \' \')\n-    query[\'SearchableText\'] = \' AND \'.join(x + \'*\' for x in text.split())\n-    if \'path\' in query:\n-        if query[\'SearchableText\'] == \'\':\n-            del query[\'SearchableText\']\n-            query[\'path\'][\'depth\'] = 1\n-        query[\'path\'][\'query\'] = path_prefix + query[\'path\'][\'query\']\n+            query["SearchableText"].append(part)\n+    text = " ".join(query["SearchableText"])\n+    for char in "?-+*()":\n+        text = text.replace(char, " ")\n+    query["SearchableText"] = " AND ".join(x + "*" for x in text.split())\n+    if "path" in query:\n+        if query["SearchableText"] == "":\n+            del query["SearchableText"]\n+            query["path"]["depth"] = 1\n+        query["path"]["query"] = path_prefix + query["path"]["query"]\n     return query\n \n \n@@ -127,64 +120,63 @@ def parse_query(query, path_prefix=\'\'):\n @provider(IContextSourceBinder)\n class SearchableTextSource(object):\n     """\n-      >>> from plone.app.vocabularies.tests.base import Brain\n-      >>> from plone.app.vocabularies.tests.base import DummyCatalog\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import Brain\n+    >>> from plone.app.vocabularies.tests.base import DummyCatalog\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n \n-      >>> context = create_context()\n+    >>> context = create_context()\n \n-      >>> catalog = DummyCatalog((\'/1234\', \'/2345\'))\n-      >>> context.portal_catalog = catalog\n+    >>> catalog = DummyCatalog((\'/1234\', \'/2345\'))\n+    >>> context.portal_catalog = catalog\n \n-      >>> tool = DummyTool(\'portal_url\')\n-      >>> def getPortalPath():\n-      ...     return \'/\'\n-      >>> tool.getPortalPath = getPortalPath\n-      >>> context.portal_url = tool\n+    >>> tool = DummyTool(\'portal_url\')\n+    >>> def getPortalPath():\n+    ...     return \'/\'\n+    >>> tool.getPortalPath = getPortalPath\n+    >>> context.portal_url = tool\n \n-      >>> source = SearchableTextSource(context)\n-      >>> source\n-      <plone.app.vocabularies.catalog.SearchableTextSource object at ...>\n+    >>> source = SearchableTextSource(context)\n+    >>> source\n+    <plone.app.vocabularies.catalog.SearchableTextSource object at ...>\n \n-      >>> \'1234\' in source, \'1\' in source\n-      (True, False)\n+    >>> \'1234\' in source, \'1\' in source\n+    (True, False)\n \n-      >>> source.search(\'\')\n-      []\n+    >>> source.search(\'\')\n+    []\n \n-      >>> source.search(\'error\')\n-      []\n+    >>> source.search(\'error\')\n+    []\n \n-      >>> source.search(\'foo\')\n-      <generator object ...>\n+    >>> source.search(\'foo\')\n+    <generator object ...>\n \n-      >>> list(source.search(\'foo\'))\n-      [\'1234\', \'2345\']\n+    >>> list(source.search(\'foo\'))\n+    [\'1234\', \'2345\']\n \n-      >>> list(source.search(\'bar path:/dummy\'))\n-      [\'/dummy\', \'1234\', \'2345\']\n+    >>> list(source.search(\'bar path:/dummy\'))\n+    [\'/dummy\', \'1234\', \'2345\']\n \n-      >>> u\'\' in source\n-      True\n+    >>> u\'\' in source\n+    True\n \n-      >>> source = SearchableTextSource(context, default_query=\'default\')\n-      >>> list(source.search(\'\'))\n-      [\'1234\', \'2345\']\n+    >>> source = SearchableTextSource(context, default_query=\'default\')\n+    >>> list(source.search(\'\'))\n+    [\'1234\', \'2345\']\n     """\n \n     def __init__(self, context, base_query={}, default_query=None):\n         self.context = context\n         self.base_query = base_query\n         self.default_query = default_query\n-        self.catalog = getToolByName(context, \'portal_catalog\')\n-        self.portal_tool = getToolByName(context, \'portal_url\')\n+        self.catalog = getToolByName(context, "portal_catalog")\n+        self.portal_tool = getToolByName(context, "portal_url")\n         self.portal_path = self.portal_tool.getPortalPath()\n-        self.encoding = \'utf-8\'\n+        self.encoding = "utf-8"\n \n     def __contains__(self, value):\n-        """Return whether the value is available in this source\n-        """\n+        """Return whether the value is available in this source"""\n         if not value:\n             return True\n         elif self.catalog.getrid(self.portal_path + value) is None:\n@@ -193,7 +185,7 @@ def __contains__(self, value):\n \n     def search(self, query_string):\n         query = self.base_query.copy()\n-        if query_string == \'\':\n+        if query_string == "":\n             if self.default_query is not None:\n                 query.update(parse_query(self.default_query, self.portal_path))\n             else:\n@@ -203,16 +195,15 @@ def search(self, query_string):\n \n         try:\n             results = (\n-                x.getPath()[len(self.portal_path):]\n-                for x in self.catalog(**query)\n+                x.getPath()[len(self.portal_path) :] for x in self.catalog(**query)\n             )\n         except ParseError:\n             return []\n \n-        if \'path\' in query:\n-            path = query[\'path\'][\'query\'][len(self.portal_path):]\n-            if path != \'\':\n-                return itertools.chain((path, ), results)\n+        if "path" in query:\n+            path = query["path"]["query"][len(self.portal_path) :]\n+            if path != "":\n+                return itertools.chain((path,), results)\n         return results\n \n \n@@ -267,83 +258,86 @@ def __init__(self, query, default_query=None):\n         self.default_query = default_query\n \n     def __call__(self, context):\n-        return SearchableTextSource(context, base_query=self.query.copy(),\n-                                    default_query=self.default_query)\n+        return SearchableTextSource(\n+            context, base_query=self.query.copy(), default_query=self.default_query\n+        )\n \n \n @implementer(ITerms, ISourceQueryView)\n class QuerySearchableTextSourceView(object):\n     """\n-      >>> from plone.app.vocabularies.tests.base import DummyCatalog\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> from plone.app.vocabularies.tests.base import Request\n+    >>> from plone.app.vocabularies.tests.base import DummyCatalog\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import Request\n \n-      >>> context = create_context()\n+    >>> context = create_context()\n \n-      >>> rids = (\'/1234\', \'/2345\', \'/dummy/1234\')\n-      >>> tool = DummyCatalog(rids)\n-      >>> context.portal_catalog = tool\n+    >>> rids = (\'/1234\', \'/2345\', \'/dummy/1234\')\n+    >>> tool = DummyCatalog(rids)\n+    >>> context.portal_catalog = tool\n \n-      >>> tool = DummyTool(\'portal_url\')\n-      >>> def getPortalPath():\n-      ...     return \'/dummy\'\n-      >>> tool.getPortalPath = getPortalPath\n-      >>> context.portal_url = tool\n+    >>> tool = DummyTool(\'portal_url\')\n+    >>> def getPortalPath():\n+    ...     return \'/dummy\'\n+    >>> tool.getPortalPath = getPortalPath\n+    >>> context.portal_url = tool\n \n-      >>> source = SearchableTextSource(context)\n-      >>> source\n-      <plone.app.vocabularies.catalog.SearchableTextSource object at ...>\n+    >>> source = SearchableTextSource(context)\n+    >>> source\n+    <plone.app.vocabularies.catalog.SearchableTextSource object at ...>\n \n-      >>> view = QuerySearchableTextSourceView(source, Request())\n-      >>> view\n-      <plone.app.vocabularies.catalog.QuerySearchableTextSourceView object ...>\n+    >>> view = QuerySearchableTextSourceView(source, Request())\n+    >>> view\n+    <plone.app.vocabularies.catalog.QuerySearchableTextSourceView object ...>\n \n-      >>> view.getValue(\'a\')\n-      Traceback (most recent call last):\n-      ...\n-      LookupError: a\n+    >>> view.getValue(\'a\')\n+    Traceback (most recent call last):\n+    ...\n+    LookupError: a\n \n-      >>> view.getValue(\'/1234\')\n-      \'/1234\'\n+    >>> view.getValue(\'/1234\')\n+    \'/1234\'\n \n-      >>> view.getTerm(None) is None\n-      True\n+    >>> view.getTerm(None) is None\n+    True\n \n-      >>> view.getTerm(\'1234\')\n-      <plone.app.vocabularies.terms.BrowsableTerm object at ...>\n+    >>> view.getTerm(\'1234\')\n+    <plone.app.vocabularies.terms.BrowsableTerm object at ...>\n \n-      >>> view.getTerm(\'/1234\')\n-      <plone.app.vocabularies.terms.BrowsableTerm object at ...>\n+    >>> view.getTerm(\'/1234\')\n+    <plone.app.vocabularies.terms.BrowsableTerm object at ...>\n \n-      >>> template = view.render(name=\'t\')\n-      >>> u\'<input type="text" name="t.query" value="" />\' in template\n-      True\n+    >>> template = view.render(name=\'t\')\n+    >>> u\'<input type="text" name="t.query" value="" />\' in template\n+    True\n \n-      >>> u\'<input type="submit" name="t.search" value="Search" />\' in template\n-      True\n+    >>> u\'<input type="submit" name="t.search" value="Search" />\' in template\n+    True\n \n-      >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n-      >>> view = QuerySearchableTextSourceView(source, request)\n-      >>> sorted(view.results(\'t\'))\n-      [\'\', \'\', \'/1234\']\n+    >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n+    >>> view = QuerySearchableTextSourceView(source, request)\n+    >>> sorted(view.results(\'t\'))\n+    [\'\', \'\', \'/1234\']\n \n-      >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\',\n-      ...                         \'t.browse.foo\' : \'/foo\'})\n-      >>> view = QuerySearchableTextSourceView(source, request)\n-      >>> sorted(view.results(\'t\'))\n-      [\'\', \'\', \'/1234\', \'foo\']\n+    >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\',\n+    ...                         \'t.browse.foo\' : \'/foo\'})\n+    >>> view = QuerySearchableTextSourceView(source, request)\n+    >>> sorted(view.results(\'t\'))\n+    [\'\', \'\', \'/1234\', \'foo\']\n \n-      Titles need to be unicode:\n-      >>> view.getTerm(list(view.results(\'t\'))[0]).title\n-      u\'/foo\'\n+    Titles need to be unicode:\n+    >>> view.getTerm(list(view.results(\'t\'))[0]).title\n+    u\'/foo\'\n     """\n \n-    template = ViewPageTemplateFile(\'searchabletextsource.pt\')\n+    template = ViewPageTemplateFile("searchabletextsource.pt")\n \n     def __init__(self, context, request):\n-        msg = \'QuerySearchableTextSourceView is deprecated and will be \' \\\n-              \'removed on Plone 6\'\n+        msg = (\n+            "QuerySearchableTextSourceView is deprecated and will be "\n+            "removed on Plone 6"\n+        )\n         warnings.warn(msg, DeprecationWarning)\n         self.context = context\n         self.request = request\n@@ -351,9 +345,8 @@ def __init__(self, context, request):\n     def getTerm(self, value):\n         if not value:\n             return None\n-        if (not self.context.portal_path.endswith(\'/\')) \\\n-                and (not value.startswith(\'/\')):\n-            value = \'/\' + value\n+        if (not self.context.portal_path.endswith("/")) and (not value.startswith("/")):\n+            value = "/" + value\n         # get rid for path\n         rid = self.context.catalog.getrid(self.context.portal_path + value)\n         # first some defaults\n@@ -368,14 +361,17 @@ def getTerm(self, value):\n             # title = brain.Title\n             if brain.is_folderish:\n                 browse_token = value\n-            parent_token = \'/\'.join(value.split(\'/\')[:-1])\n+            parent_token = "/".join(value.split("/")[:-1])\n         if six.PY2 and isinstance(title, six.binary_type):\n             title = title.decode(self.context.encoding)\n-        return BrowsableTerm(value, token=token,\n-                             title=title,\n-                             description=value,\n-                             browse_token=browse_token,\n-                             parent_token=parent_token)\n+        return BrowsableTerm(\n+            value,\n+            token=token,\n+            title=title,\n+            description=value,\n+            browse_token=browse_token,\n+            parent_token=parent_token,\n+        )\n \n     def getValue(self, token):\n         if token not in self.context:\n@@ -386,23 +382,22 @@ def render(self, name):\n         return self.template(name=name)\n \n     def results(self, name):\n-        query = \'\'\n+        query = ""\n \n         # check whether the normal search button was pressed\n-        if name + \'.search\' in self.request.form:\n-            query_fieldname = name + \'.query\'\n+        if name + ".search" in self.request.form:\n+            query_fieldname = name + ".query"\n             if query_fieldname in self.request.form:\n                 query = self.request.form[query_fieldname]\n \n         # check whether a browse button was pressed\n-        browse_prefix = name + \'.browse.\'\n-        browse = tuple(x for x in self.request.form\n-                       if x.startswith(browse_prefix))\n+        browse_prefix = name + ".browse."\n+        browse = tuple(x for x in self.request.form if x.startswith(browse_prefix))\n         if len(browse) == 1:\n-            path = browse[0][len(browse_prefix):]\n-            query = \'path:\' + path\n+            path = browse[0][len(browse_prefix) :]\n+            query = "path:" + path\n             results = self.context.search(query)\n-            if name + \'.omitbrowsedfolder\' in self.request.form:\n+            if name + ".omitbrowsedfolder" in self.request.form:\n                 results = six.moves.filter(lambda x: x != path, results)\n         else:\n             results = self.context.search(query)\n@@ -412,96 +407,95 @@ def results(self, name):\n \n @implementer(IVocabularyFactory)\n class KeywordsVocabulary(object):\n-    u"""Vocabulary factory listing all catalog keywords from the \'Subject\' index\n-\n-        >>> from plone.app.vocabularies.tests.base import DummyCatalog\n-        >>> from plone.app.vocabularies.tests.base import create_context\n-        >>> from plone.app.vocabularies.tests.base import DummyContent\n-        >>> from plone.app.vocabularies.tests.base import Request\n-        >>> from Products.PluginIndexes.KeywordIndex.KeywordIndex import KeywordIndex  # noqa\n-\n-        >>> context = create_context()\n-\n-        First test bytes vocabularies\n-        >>> rids = (\'/1234\', \'/2345\', \'/dummy/1234\')\n-        >>> tool = DummyCatalog(rids)\n-        >>> context.portal_catalog = tool\n-        >>> index = KeywordIndex(\'Subject\')\n-        >>> done = index._index_object(\n-        ...     1,\n-        ...     DummyContent(\'ob1\', [b\'foo\', b\'bar\', b\'baz\']), attr=\'Subject\'\n-        ... )\n-        >>> done = index._index_object(\n-        ...     2,\n-        ...     DummyContent(\n-        ...         \'ob2\',\n-        ...         [b\'blee\', b\'bar\', u\'non-\xc3\xa5scii\'.encode(\'utf8\')]),\n-        ...         attr=\'Subject\',\n-        ... )\n-        >>> tool.indexes[\'Subject\'] = index\n-        >>> vocab = KeywordsVocabulary()\n-        >>> result = vocab(context)\n-\n-        Value type is kept ...\n-        >>> expected = [b\'bar\', b\'baz\', b\'blee\', b\'foo\', u\'non-\xc3\xa5scii\'.encode(\'utf8\')]\n-        >>> sorted(result.by_value) == expected\n-        True\n-\n-        but tokens are base64 encoded text\n-        >>> expected = [\'YmF6\', \'YmFy\', \'YmxlZQ==\', \'Zm9v\', \'bm9uLcOlc2NpaQ==\']\n-        >>> sorted(result.by_token) == expected\n-        True\n-\n-        >>> result.getTermByToken(expected[-1]).title == u\'non-\xc3\xa5scii\'\n-        True\n-\n-        Testing unicode vocabularies\n-        First clear the index. Comparing non-six.text_type to six.text_type objects fails.\n-        >>> index.clear()\n-        >>> done = index._index_object(\n-        ...     1,\n-        ...     DummyContent(\'obj1\', [u\'\xc3\xa4\xc3\xbc\xc3\xb6\', u\'nix\']), attr=\'Subject\'\n-        ... )\n-        >>> tool.indexes[\'Subject\'] = index\n-        >>> vocab = KeywordsVocabulary()\n-        >>> result = vocab(context)\n-        >>> expected = [\'bml4\', \'w6TDvMO2\']\n-        >>> sorted(result.by_token) == expected\n-        True\n-        >>> set(result.by_value) == {u\'nix\', u\'\xc3\xa4\xc3\xbc\xc3\xb6\'}\n-        True\n-        >>> result.getTermByToken(expected[0]).title == u\'nix\'\n-        True\n+    """Vocabulary factory listing all catalog keywords from the \'Subject\' index\n+\n+    >>> from plone.app.vocabularies.tests.base import DummyCatalog\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyContent\n+    >>> from plone.app.vocabularies.tests.base import Request\n+    >>> from Products.PluginIndexes.KeywordIndex.KeywordIndex import KeywordIndex  # noqa\n+\n+    >>> context = create_context()\n+\n+    First test bytes vocabularies\n+    >>> rids = (\'/1234\', \'/2345\', \'/dummy/1234\')\n+    >>> tool = DummyCatalog(rids)\n+    >>> context.portal_catalog = tool\n+    >>> index = KeywordIndex(\'Subject\')\n+    >>> done = index._index_object(\n+    ...     1,\n+    ...     DummyContent(\'ob1\', [b\'foo\', b\'bar\', b\'baz\']), attr=\'Subject\'\n+    ... )\n+    >>> done = index._index_object(\n+    ...     2,\n+    ...     DummyContent(\n+    ...         \'ob2\',\n+    ...         [b\'blee\', b\'bar\', u\'non-\xc3\xa5scii\'.encode(\'utf8\')]),\n+    ...         attr=\'Subject\',\n+    ... )\n+    >>> tool.indexes[\'Subject\'] = index\n+    >>> vocab = KeywordsVocabulary()\n+    >>> result = vocab(context)\n+\n+    Value type is kept ...\n+    >>> expected = [b\'bar\', b\'baz\', b\'blee\', b\'foo\', u\'non-\xc3\xa5scii\'.encode(\'utf8\')]\n+    >>> sorted(result.by_value) == expected\n+    True\n+\n+    but tokens are base64 encoded text\n+    >>> expected = [\'YmF6\', \'YmFy\', \'YmxlZQ==\', \'Zm9v\', \'bm9uLcOlc2NpaQ==\']\n+    >>> sorted(result.by_token) == expected\n+    True\n+\n+    >>> result.getTermByToken(expected[-1]).title == u\'non-\xc3\xa5scii\'\n+    True\n+\n+    Testing unicode vocabularies\n+    First clear the index. Comparing non-six.text_type to six.text_type objects fails.\n+    >>> index.clear()\n+    >>> done = index._index_object(\n+    ...     1,\n+    ...     DummyContent(\'obj1\', [u\'\xc3\xa4\xc3\xbc\xc3\xb6\', u\'nix\']), attr=\'Subject\'\n+    ... )\n+    >>> tool.indexes[\'Subject\'] = index\n+    >>> vocab = KeywordsVocabulary()\n+    >>> result = vocab(context)\n+    >>> expected = [\'bml4\', \'w6TDvMO2\']\n+    >>> sorted(result.by_token) == expected\n+    True\n+    >>> set(result.by_value) == {u\'nix\', u\'\xc3\xa4\xc3\xbc\xc3\xb6\'}\n+    True\n+    >>> result.getTermByToken(expected[0]).title == u\'nix\'\n+    True\n \n     """\n+\n     # Allow users to customize the index to easily create\n     # KeywordVocabularies for other keyword indexes\n-    keyword_index = \'Subject\'\n-    path_index = \'path\'\n+    keyword_index = "Subject"\n+    path_index = "path"\n \n     def section(self, context):\n-        """gets section from which subjects are used.\n-        """\n+        """gets section from which subjects are used."""\n         registry = queryUtility(IRegistry)\n         if registry is None:\n             return None\n-        if registry.get(\'plone.subjects_of_navigation_root\', False):\n-            portal = getToolByName(context, \'portal_url\').getPortalObject()\n+        if registry.get("plone.subjects_of_navigation_root", False):\n+            portal = getToolByName(context, "portal_url").getPortalObject()\n             return getNavigationRootObject(context, portal)\n         return None\n \n     def all_keywords(self, kwfilter):\n         site = getSite()\n-        self.catalog = getToolByName(site, \'portal_catalog\', None)\n+        self.catalog = getToolByName(site, "portal_catalog", None)\n         if self.catalog is None:\n             return SimpleVocabulary([])\n         index = self.catalog._catalog.getIndex(self.keyword_index)\n         return safe_simplevocabulary_from_values(index._index, query=kwfilter)\n \n     def keywords_of_section(self, section, kwfilter):\n-        """Valid keywords under the given section.\n-        """\n-        pcat = getToolByName(section, \'portal_catalog\')\n+        """Valid keywords under the given section."""\n+        pcat = getToolByName(section, "portal_catalog")\n         cat = pcat._catalog\n         path_idx = cat.indexes[self.path_index]\n         tags_idx = cat.indexes[self.keyword_index]\n@@ -509,15 +503,15 @@ def keywords_of_section(self, section, kwfilter):\n         # query all oids of path - low level\n         pquery = {\n             self.path_index: {\n-                \'query\': \'/\'.join(section.getPhysicalPath()),\n-                \'depth\': -1,\n+                "query": "/".join(section.getPhysicalPath()),\n+                "depth": -1,\n             }\n         }\n-        kwfilter = safe_encode(kwfilter)\n+        kwfilter = safe_text(kwfilter)\n         # uses internal zcatalog specific details to quickly get the values.\n         path_result, info = path_idx._apply_index(pquery)\n         for tag in tags_idx.uniqueValues():\n-            if kwfilter and kwfilter not in safe_encode(tag):\n+            if kwfilter and kwfilter not in safe_text(tag):\n                 continue\n             tquery = {self.keyword_index: tag}\n             tags_result, info = tags_idx._apply_index(tquery)\n@@ -544,6 +538,7 @@ class CatalogVocabulary(SlicableVocabulary):\n     @classmethod\n     def fromItems(cls, query, context, *interfaces):\n         return cls(query)\n+\n     fromValues = fromItems\n \n     @classmethod\n@@ -556,7 +551,7 @@ def __init__(self, query, *interfaces):\n     @property\n     @memoize\n     def catalog(self):\n-        return getToolByName(getSite(), \'portal_catalog\')\n+        return getToolByName(getSite(), "portal_catalog")\n \n     @property\n     @memoize\n@@ -566,8 +561,8 @@ def brains(self):\n         except ParseError:\n             # a parseError: Query contains only common words may happen,\n             # semantically this means we want all result w/o SearchableText\n-            if \'SearchableText\' in self.query:\n-                del self.query[\'SearchableText\']\n+            if "SearchableText" in self.query:\n+                del self.query["SearchableText"]\n                 return self.catalog(**self.query)\n             raise\n \n@@ -582,7 +577,7 @@ def __contains__(self, value):\n         else:\n             uid = IUUID(value)\n         query = self.query.copy()\n-        query[\'UID\'] = uid\n+        query["UID"] = uid\n         return len(self.catalog(**query)) > 0\n \n     def __len__(self):\n@@ -593,8 +588,7 @@ def __getitem__(self, index):\n             slice_inst = index\n             start = slice_inst.start\n             stop = slice_inst.stop\n-            return [self.createTerm(brain, None)\n-                    for brain in self.brains[start:stop]]\n+            return [self.createTerm(brain, None) for brain in self.brains[start:stop]]\n         else:\n             return self.createTerm(self.brains[index], None)\n \n@@ -602,7 +596,7 @@ def getTerm(self, value):\n         if not isinstance(value, six.string_types):\n             # here we have a content and fetch the uuid as hex value\n             value = IUUID(value)\n-        query = {\'UID\': value}\n+        query = {"UID": value}\n         brains = self.catalog(**query)\n         for b in brains:\n             return self.createTerm(b, None)\n@@ -640,6 +634,7 @@ class CatalogVocabularyFactory(object):\n       [\'/dummy/sub-site\', \'/dummy/sub-site/ghij\']\n \n     """\n+\n     # We want to get rid of this and use CatalogSource instead,\n     # but we can\'t in Plone versions that support\n     # plone.app.widgets < 1.6.0\n@@ -647,30 +642,28 @@ class CatalogVocabularyFactory(object):\n     def __call__(self, context, query=None):\n         parsed = {}\n         if query:\n-            parsed = parseQueryString(context, query[\'criteria\'])\n-            if \'sort_on\' in query:\n-                parsed[\'sort_on\'] = query[\'sort_on\']\n-            if \'sort_order\' in query:\n-                parsed[\'sort_order\'] = str(query[\'sort_order\'])\n+            parsed = parseQueryString(context, query["criteria"])\n+            if "sort_on" in query:\n+                parsed["sort_on"] = query["sort_on"]\n+            if "sort_order" in query:\n+                parsed["sort_order"] = str(query["sort_order"])\n \n         # If no path is specified check if we are in a sub-site and use that\n         # as the path root for catalog searches\n-        if \'path\' not in parsed:\n+        if "path" not in parsed:\n             site = getSite()\n             nav_root = getNavigationRootObject(context, site)\n             site_path = site.getPhysicalPath()\n             if nav_root and nav_root.getPhysicalPath() != site_path:\n-                parsed[\'path\'] = {\n-                    \'query\': \'/\'.join(nav_root.getPhysicalPath()),\n-                    \'depth\': -1\n+                parsed["path"] = {\n+                    "query": "/".join(nav_root.getPhysicalPath()),\n+                    "depth": -1,\n                 }\n         return CatalogVocabulary.fromItems(parsed, context)\n \n \n def request_query_cache_key(func, vocab):\n-    return json.dumps([\n-        vocab.query, vocab.text_search_index, vocab.title_template\n-    ])\n+    return json.dumps([vocab.query, vocab.text_search_index, vocab.title_template])\n \n \n @implementer(IQuerySource, IVocabularyFactory)\n@@ -793,11 +786,11 @@ def my_vocab_factory(context):\n        (u\'proto:/site/2345 /site/2345 - BrainTitle /2345\', \'/site/2345\')]\n \n     """\n+\n     title_template = "{brain.Title} ({path})"\n     text_search_index = "SearchableText"\n \n-    def __init__(self, query, text_search_index=None,\n-                 title_template=None):\n+    def __init__(self, query, text_search_index=None, title_template=None):\n         self.query = query\n         if text_search_index:\n             self.text_search_index = text_search_index\n@@ -809,13 +802,13 @@ def __init__(self, query, text_search_index=None,\n     def nav_root_path(self):\n         site = getSite()\n         nav_root = getNavigationRootObject(site, site)\n-        return \'/\'.join(nav_root.getPhysicalPath())\n+        return "/".join(nav_root.getPhysicalPath())\n \n     def get_brain_path(self, brain):\n         nav_root_path = self.nav_root_path\n         path = brain.getPath()\n         if path.startswith(nav_root_path):\n-            path = path[len(nav_root_path):]\n+            path = path[len(nav_root_path) :]\n         return path\n \n     @staticmethod\n@@ -829,11 +822,15 @@ def brains(self):\n \n     def createTerm(self, brain, context=None):\n         return SimpleTerm(\n-            value=brain.UID, token=brain.UID,\n-            title=safe_unicode(self.title_template.format(\n-                brain=brain, path=self.get_brain_path(brain),\n-                url=brain.getURL(),\n-            ))\n+            value=brain.UID,\n+            token=brain.UID,\n+            title=safe_text(\n+                self.title_template.format(\n+                    brain=brain,\n+                    path=self.get_brain_path(brain),\n+                    url=brain.getURL(),\n+                )\n+            ),\n         )\n \n     def search(self, query):\n@@ -847,9 +844,7 @@ def search(self, query):\n         query = {self.text_search_index: query}\n         query.update(self.query)\n         brains = self.catalog(**query)\n-        return SimpleVocabulary([\n-            self.createTerm(b) for b in brains\n-        ])\n+        return SimpleVocabulary([self.createTerm(b) for b in brains])\n \n \n @implementer(ISource)\n@@ -910,19 +905,19 @@ def __contains__(self, value):\n             value = IUUID(value)\n         # else we have uuid hex value or path\n \n-        if value.startswith(\'/\'):\n+        if value.startswith("/"):\n             # it is a path query\n             site = getSite()\n-            site_path = \'/\'.join(site.getPhysicalPath())\n-            path = os.path.join(site_path, value.lstrip(\'/\'))\n-            query = {\'path\': {\'query\': path, \'depth\': 0}}\n+            site_path = "/".join(site.getPhysicalPath())\n+            path = os.path.join(site_path, value.lstrip("/"))\n+            query = {"path": {"query": path, "depth": 0}}\n         else:\n             # its a uuid\n-            query = {\'UID\': value}\n+            query = {"UID": value}\n         return bool(self.search_catalog(query))\n \n     def search_catalog(self, user_query):\n         query = user_query.copy()\n         query.update(self.query)\n-        catalog = getToolByName(getSite(), \'portal_catalog\')\n+        catalog = getToolByName(getSite(), "portal_catalog")\n         return catalog(query)\ndiff --git a/plone/app/vocabularies/metadatafields.py b/plone/app/vocabularies/metadatafields.py\nindex 508a17e..fc29cdf 100644\n--- a/plone/app/vocabularies/metadatafields.py\n+++ b/plone/app/vocabularies/metadatafields.py\n@@ -1,6 +1,5 @@\n-# -*- coding: utf-8 -*-\n+from plone.base import PloneMessageFactory as _\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone import PloneMessageFactory as _\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n@@ -8,62 +7,66 @@\n \n \n _FIELD_LABEL = {\n-    \'CreationDate\': _(\'Created on\'),\n-    \'Creator\': _(\'Creator\'),\n-    \'Description\': _(\'Description\'),\n-    \'EffectiveDate\': _(\'Publication date\'),\n-    \'end\': _(\'End Date\'),\n-    \'exclude_from_nav\': _(\'Excluded from navigation\'),\n-    \'ExpirationDate\': _(\'Expiration date\'),\n-    \'getObjSize\': _(\'Object Size\'),\n-    \'id\': _(\'ID\'),\n-    \'is_folderish\': _(\'Folder\'),\n-    \'last_comment_date\': _(\'Last comment date\'),\n-    \'location\': _(\'Location\'),\n-    \'ModificationDate\': _(\'Last modified\'),\n-    \'review_state\': _(\'Review state\'),\n-    \'start\': _(\'Start Date\'),\n-    \'Subject\': _(\'Tags\'),\n-    \'Type\': _(\'Type\'),\n-    \'total_comments\': _(\'Total comments\'),\n-    \'mime_type\': _(\'MIME type\'),\n+    "CreationDate": _("Created on"),\n+    "Creator": _("Creator"),\n+    "Description": _("Description"),\n+    "EffectiveDate": _("Publication date"),\n+    "end": _("End Date"),\n+    "exclude_from_nav": _("Excluded from navigation"),\n+    "ExpirationDate": _("Expiration date"),\n+    "getObjSize": _("Object Size"),\n+    "id": _("ID"),\n+    "is_folderish": _("Folder"),\n+    "last_comment_date": _("Last comment date"),\n+    "location": _("Location"),\n+    "ModificationDate": _("Last modified"),\n+    "review_state": _("Review state"),\n+    "start": _("Start Date"),\n+    "Subject": _("Tags"),\n+    "Type": _("Type"),\n+    "total_comments": _("Total comments"),\n+    "mime_type": _("MIME type"),\n }\n \n \n @implementer(IVocabularyFactory)\n-class MetaDataFieldsVocabulary(object):\n+class MetaDataFieldsVocabulary:\n     """Vocabulary factory for metadata fields\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import DummyCatalog\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import DummyCatalog\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import create_context\n \n-      >>> context = create_context()\n+    >>> context = create_context()\n \n-      >>> catalog = DummyCatalog(())\n-      >>> catalog.schema = lambda: [\'ModificationDate\', \'review_state\', \'SomethingNew\']\n-      >>> context.portal_catalog = catalog\n+    >>> catalog = DummyCatalog(())\n+    >>> catalog.schema = lambda: [\'ModificationDate\', \'review_state\', \'SomethingNew\']\n+    >>> context.portal_catalog = catalog\n \n-      >>> name = \'plone.app.vocabularies.MetadataFields\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> name = \'plone.app.vocabularies.MetadataFields\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n \n-      >>> fields = util(context)\n-      >>> fields\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+    >>> fields = util(context)\n+    >>> fields\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n \n-      >>> len(fields.by_token)\n-      3\n+    >>> len(fields.by_token)\n+    3\n \n-      >>> modification_date = fields.by_token[\'ModificationDate\']\n-      >>> modification_date.title, modification_date.token, modification_date.value\n-      (u\'Last modified\', \'ModificationDate\', \'ModificationDate\')\n+    >>> modification_date = fields.by_token[\'ModificationDate\']\n+    >>> modification_date.title, modification_date.token, modification_date.value\n+    (u\'Last modified\', \'ModificationDate\', \'ModificationDate\')\n     """\n \n     def __call__(self, context):\n-        cat = getToolByName(context, \'portal_catalog\')\n+        cat = getToolByName(context, "portal_catalog")\n         items = [\n-            SimpleTerm(column, column, _FIELD_LABEL[column] if column in _FIELD_LABEL else _(column))\n+            SimpleTerm(\n+                column,\n+                column,\n+                _FIELD_LABEL[column] if column in _FIELD_LABEL else _(column),\n+            )\n             for column in cat.schema()\n         ]\n         return SimpleVocabulary(items)\ndiff --git a/plone/app/vocabularies/terms.py b/plone/app/vocabularies/terms.py\nindex 7251da8..06d714f 100644\n--- a/plone/app/vocabularies/terms.py\n+++ b/plone/app/vocabularies/terms.py\n@@ -1,21 +1,21 @@\n-# -*- coding: utf-8 -*-\n from base64 import urlsafe_b64encode\n from plone.app.vocabularies.interfaces import IBrowsableTerm\n from plone.app.vocabularies.interfaces import ITermWithDescription\n-from Products.CMFPlone.utils import safe_unicode\n+from plone.base.utils import safe_bytes\n+from plone.base.utils import safe_text\n+from zope.deprecation import deprecate\n from zope.interface import alsoProvides\n from zope.interface import implementer\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n-import six\n-\n \n+@deprecate("Use plone.base.utils.safe_bytes instead. Will be removed with version 6.")\n def safe_encode(value):\n-    if isinstance(value, six.text_type):\n+    if isinstance(value, str):\n         # no need to use portal encoding for transitional encoding from\n         # unicode to ascii. utf-8 should be fine.\n-        value = value.encode(\'utf-8\')\n+        value = value.encode("utf-8")\n     return value\n \n \n@@ -26,12 +26,11 @@ def safe_simpleterm_from_value(value):\n     - tokens cannot contain newlines\n     - anything for display has to be cleaned up, titles *must* be unicode\n     """\n-    return SimpleTerm(value, urlsafe_b64encode(safe_encode(value)), safe_unicode(value))\n+    return SimpleTerm(value, urlsafe_b64encode(safe_bytes(value)), safe_text(value))\n \n \n def safe_simplevocabulary_from_values(values, query=None):\n-    """Creates (filtered) SimpleVocabulary from iterable of untrusted values.\n-    """\n+    """Creates (filtered) SimpleVocabulary from iterable of untrusted values."""\n     items = [\n         safe_simpleterm_from_value(i)\n         for i in values\n@@ -43,52 +42,52 @@ def safe_simplevocabulary_from_values(values, query=None):\n @implementer(ITermWithDescription)\n class TermWithDescription(SimpleTerm):\n     """\n-      >>> term = TermWithDescription(\'value\', \'token\', \'title\')\n-      >>> term.value, term.token, term.title, term.description\n-      (\'value\', \'token\', \'title\', None)\n-\n-      >>> term = TermWithDescription(\'value\', \'token\', \'title\',\n-      ...                            description=\'description\')\n-      >>> term.value, term.token, term.title, term.description\n-      (\'value\', \'token\', \'title\', \'description\')\n+    >>> term = TermWithDescription(\'value\', \'token\', \'title\')\n+    >>> term.value, term.token, term.title, term.description\n+    (\'value\', \'token\', \'title\', None)\n+\n+    >>> term = TermWithDescription(\'value\', \'token\', \'title\',\n+    ...                            description=\'description\')\n+    >>> term.value, term.token, term.title, term.description\n+    (\'value\', \'token\', \'title\', \'description\')\n     """\n \n     def __init__(self, value, token, title, description=None):\n-        super(TermWithDescription, self).__init__(\n-            value,\n-            token=token,\n-            title=title\n-        )\n+        super(TermWithDescription, self).__init__(value, token=token, title=title)\n         self.description = description\n \n \n class BrowsableTerm(TermWithDescription):\n     """\n-      >>> term = BrowsableTerm(\'value\')\n-      >>> term.value, term.token, term.title, term.description\n-      (\'value\', \'value\', None, None)\n-      >>> IBrowsableTerm.providedBy(term)\n-      False\n-\n-      >>> term = BrowsableTerm(\'value\', \'token\', \'title\',\n-      ...                      description=\'description\',\n-      ...                      browse_token=\'browse_token\',\n-      ...                      parent_token=\'parent_token\')\n-      >>> term.value, term.token, term.title, term.description\n-      (\'value\', \'token\', \'title\', \'description\')\n-      >>> term.browse_token, term.parent_token\n-      (\'browse_token\', \'parent_token\')\n-      >>> IBrowsableTerm.providedBy(term)\n-      True\n+    >>> term = BrowsableTerm(\'value\')\n+    >>> term.value, term.token, term.title, term.description\n+    (\'value\', \'value\', None, None)\n+    >>> IBrowsableTerm.providedBy(term)\n+    False\n+\n+    >>> term = BrowsableTerm(\'value\', \'token\', \'title\',\n+    ...                      description=\'description\',\n+    ...                      browse_token=\'browse_token\',\n+    ...                      parent_token=\'parent_token\')\n+    >>> term.value, term.token, term.title, term.description\n+    (\'value\', \'token\', \'title\', \'description\')\n+    >>> term.browse_token, term.parent_token\n+    (\'browse_token\', \'parent_token\')\n+    >>> IBrowsableTerm.providedBy(term)\n+    True\n     """\n \n-    def __init__(self, value, token=None, title=None, description=None,\n-                 browse_token=None, parent_token=None):\n+    def __init__(\n+        self,\n+        value,\n+        token=None,\n+        title=None,\n+        description=None,\n+        browse_token=None,\n+        parent_token=None,\n+    ):\n         super(BrowsableTerm, self).__init__(\n-            value,\n-            token=token,\n-            title=title,\n-            description=description\n+            value, token=token, title=title, description=description\n         )\n         self.browse_token = browse_token\n         self.parent_token = parent_token\ndiff --git a/plone/app/vocabularies/tests/test_editors.py b/plone/app/vocabularies/tests/test_editors.py\nindex 7fa119d..85a273e 100644\n--- a/plone/app/vocabularies/tests/test_editors.py\n+++ b/plone/app/vocabularies/tests/test_editors.py\n@@ -11,19 +11,20 @@ class AvailableEditorsTest(unittest.TestCase):\n     layer = PAVocabularies_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def test_editors(self):\n         from plone.registry import Registry\n+\n         registry = Registry()\n-        from Products.CMFPlone.interfaces import IEditingSchema\n-        registry.registerInterface(IEditingSchema, prefix=\'plone\')\n-        registry.records[\'plone.available_editors\']\n+        from plone.base.interfaces import IEditingSchema\n+\n+        registry.registerInterface(IEditingSchema, prefix="plone")\n+        registry.records["plone.available_editors"]\n         vocab_util = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.AvailableEditors\'\n+            IVocabularyFactory, "plone.app.vocabularies.AvailableEditors"\n         )\n         editors = vocab_util(self.portal)\n         self.assertEqual(2, len(editors.by_token))\n-        self.assertTrue(\'None\' in [x for x in editors.by_token])\n-        self.assertTrue(\'TinyMCE\' in [x for x in editors.by_token])\n+        self.assertTrue("None" in [x for x in editors.by_token])\n+        self.assertTrue("TinyMCE" in [x for x in editors.by_token])\ndiff --git a/plone/app/vocabularies/workflow.py b/plone/app/vocabularies/workflow.py\nindex 198b77a..695df34 100644\n--- a/plone/app/vocabularies/workflow.py\n+++ b/plone/app/vocabularies/workflow.py\n@@ -1,78 +1,75 @@\n-# -*- coding:utf-8 -*-\n from Acquisition import aq_get\n from operator import itemgetter\n+from plone.base.utils import safe_text\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.utils import safe_unicode\n+from zope.component.hooks import getSite\n from zope.i18n import translate\n from zope.i18nmessageid import MessageFactory\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n-from zope.component.hooks import getSite\n \n \n-_ = MessageFactory(\'plone\')\n+_ = MessageFactory("plone")\n \n \n @implementer(IVocabularyFactory)\n class WorkflowsVocabulary(object):\n     """Vocabulary factory for workflows.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> import six\n-\n-      >>> name = \'plone.app.vocabularies.Workflows\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n-\n-      >>> class Workflow(object):\n-      ...     def __init__(self, id, title):\n-      ...         self.id = id\n-      ...         self.title = title\n-\n-      >>> tool = DummyTool(\'portal_workflow\')\n-      >>> def values():\n-      ...     return (Workflow(\'default\', \'Default Workflow\'),\n-      ...             Workflow(\'intranet\', \'Intranet Workflow\'),\n-      ...             Workflow(\'noticias\', \'Workflow de Not\xc3\xadcias\'),)\n-      >>> tool.values = values\n-      >>> context.portal_workflow = tool\n-\n-      >>> workflows = util(context)\n-      >>> workflows\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n-\n-      >>> len(workflows.by_token)\n-      3\n-\n-      >>> intranet = workflows.by_token[\'intranet\']\n-      >>> intranet.title, intranet.token, intranet.value\n-      (u\'Intranet Workflow\', \'intranet\', \'intranet\')\n-\n-      >>> noticias = workflows.by_token[\'noticias\']\n-      >>> title = \'Workflow de Not\xc3\xadcias\'\n-      >>> title = title.decode(\'utf-8\') if six.PY2 else title\n-      >>> noticias.title == title\n-      True\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> import six\n+\n+    >>> name = \'plone.app.vocabularies.Workflows\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n+\n+    >>> class Workflow(object):\n+    ...     def __init__(self, id, title):\n+    ...         self.id = id\n+    ...         self.title = title\n+\n+    >>> tool = DummyTool(\'portal_workflow\')\n+    >>> def values():\n+    ...     return (Workflow(\'default\', \'Default Workflow\'),\n+    ...             Workflow(\'intranet\', \'Intranet Workflow\'),\n+    ...             Workflow(\'noticias\', \'Workflow de Not\xc3\xadcias\'),)\n+    >>> tool.values = values\n+    >>> context.portal_workflow = tool\n+\n+    >>> workflows = util(context)\n+    >>> workflows\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+\n+    >>> len(workflows.by_token)\n+    3\n+\n+    >>> intranet = workflows.by_token[\'intranet\']\n+    >>> intranet.title, intranet.token, intranet.value\n+    (u\'Intranet Workflow\', \'intranet\', \'intranet\')\n+\n+    >>> noticias = workflows.by_token[\'noticias\']\n+    >>> title = \'Workflow de Not\xc3\xadcias\'\n+    >>> title = title.decode(\'utf-8\') if six.PY2 else title\n+    >>> noticias.title == title\n+    True\n     """\n \n     def __call__(self, context):\n         items = []\n         site = getSite()\n-        wtool = getToolByName(site, \'portal_workflow\', None)\n+        wtool = getToolByName(site, "portal_workflow", None)\n         if wtool is not None:\n             items = [(w.title, w.id) for w in wtool.values()]\n             items.sort()\n-            # All vocabularies return theirs term title as unicode\n-            items = [\n-                SimpleTerm(i[1], i[1], safe_unicode(i[0]))\n-                for i in items\n-            ]\n+            # All vocabularies return theirs term title as str\n+            items = [SimpleTerm(i[1], i[1], safe_text(i[0])) for i in items]\n         return SimpleVocabulary(items)\n \n+\n WorkflowsVocabularyFactory = WorkflowsVocabulary()\n \n \n@@ -80,44 +77,44 @@ def __call__(self, context):\n class WorkflowStatesVocabulary(object):\n     """Vocabulary factory for workflow states.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> import six\n-\n-      >>> name = \'plone.app.vocabularies.WorkflowStates\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n-\n-      >>> tool = DummyTool(\'portal_workflow\')\n-      >>> def listWFStatesByTitle(filter_similar=None):\n-      ...     return ((\'Private\', \'private\'),\n-      ...             (\'Revis\xc3\xa3o\', \'revisao\'),\n-      ...             (\'Published\', \'published\'))\n-      >>> tool.listWFStatesByTitle = listWFStatesByTitle\n-      >>> context.portal_workflow = tool\n-\n-      >>> states = util(context)\n-      >>> states\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n-\n-      >>> len(states.by_token)\n-      3\n-\n-      >>> pub = states.by_token[\'published\']\n-      >>> pub.title, pub.token, pub.value\n-      (u\'Published [published]\', \'published\', \'published\')\n-\n-      >>> rev = states.by_token[\'revisao\']\n-      >>> title = \'Revis\xc3\xa3o [revisao]\'\n-      >>> title = title.decode(\'utf-8\') if six.PY2 else title\n-      >>> rev.title == title\n-      True\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> import six\n+\n+    >>> name = \'plone.app.vocabularies.WorkflowStates\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n+\n+    >>> tool = DummyTool(\'portal_workflow\')\n+    >>> def listWFStatesByTitle(filter_similar=None):\n+    ...     return ((\'Private\', \'private\'),\n+    ...             (\'Revis\xc3\xa3o\', \'revisao\'),\n+    ...             (\'Published\', \'published\'))\n+    >>> tool.listWFStatesByTitle = listWFStatesByTitle\n+    >>> context.portal_workflow = tool\n+\n+    >>> states = util(context)\n+    >>> states\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+\n+    >>> len(states.by_token)\n+    3\n+\n+    >>> pub = states.by_token[\'published\']\n+    >>> pub.title, pub.token, pub.value\n+    (u\'Published [published]\', \'published\', \'published\')\n+\n+    >>> rev = states.by_token[\'revisao\']\n+    >>> title = \'Revis\xc3\xa3o [revisao]\'\n+    >>> title = title.decode(\'utf-8\') if six.PY2 else title\n+    >>> rev.title == title\n+    True\n     """\n \n     def __call__(self, context):\n         site = getSite()\n-        wtool = getToolByName(site, \'portal_workflow\', None)\n+        wtool = getToolByName(site, "portal_workflow", None)\n         if wtool is None:\n             return SimpleVocabulary([])\n \n@@ -125,23 +122,20 @@ def __call__(self, context):\n         # The sorting should go into a separate widget.\n \n         # we get REQUEST from wtool because context may be an adapter\n-        request = aq_get(wtool, \'REQUEST\', None)\n+        request = aq_get(wtool, "REQUEST", None)\n \n         items = wtool.listWFStatesByTitle(filter_similar=True)\n-        items = [(safe_unicode(i[0]), i[1]) for i in items]\n+        items = [(safe_text(i[0]), i[1]) for i in items]\n         items_dict = dict(  # no dict comprehension in py 2.6\n-            [\n-                (i[1], translate(_(i[0]), context=request))\n-                for i in items\n-            ]\n+            [(i[1], translate(_(i[0]), context=request)) for i in items]\n         )\n-        items_list = [(k, v) for k, v in items_dict.items()]\n         terms = [\n-            SimpleTerm(k, title=u\'{0} [{1}]\'.format(v, k))\n-            for k, v in sorted(items_list, key=itemgetter(1))\n+            SimpleTerm(k, title=f"{v} [{k}]")\n+            for k, v in sorted(items_dict.items(), key=itemgetter(1))\n         ]\n         return SimpleVocabulary(terms)\n \n+\n WorkflowStatesVocabularyFactory = WorkflowStatesVocabulary()\n \n \n@@ -149,70 +143,70 @@ def __call__(self, context):\n class WorkflowTransitionsVocabulary(object):\n     """Vocabulary factory for workflow transitions\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-\n-      >>> name = \'plone.app.vocabularies.WorkflowTransitions\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n-\n-      >>> class Transition(object):\n-      ...     def __init__(self, id, actbox_name):\n-      ...         self.id = id\n-      ...         self.actbox_name = actbox_name\n-\n-      >>> class TransitionsFolder(object):\n-      ...     def __init__(self, values):\n-      ...         self._values = values\n-      ...     def values(self):\n-      ...         return self._values\n-\n-      >>> class Workflow(object):\n-      ...     def __init__(self, id, title, values):\n-      ...         self.id = id\n-      ...         self.title = title\n-      ...         self.transitions = TransitionsFolder(values)\n-\n-      >>> tool = DummyTool(\'portal_workflow\')\n-      >>> t1 = Transition(\'publish\', \'Publish\')\n-      >>> t2 = Transition(\'reject\', \'Reject\')\n-      >>> t3 = Transition(\'publicacao\', u\'Publica\xc3\xa7\xc3\xa3o\')\n-\n-      >>> wf1 = Workflow(\'default\', \'Default Workflow\', (t1, t2))\n-      >>> wf2 = Workflow(\'intranet\', \'Intranet Workflow\', (t1, ))\n-      >>> wf3 = Workflow(\'noticias\', \'Workflow de Not\xc3\xadcias\', (t2, t3))\n-\n-      >>> def values():\n-      ...     return  wf1, wf2, wf3\n-      >>> tool.values = values\n-      >>> context.portal_workflow = tool\n-\n-      >>> transitions = util(context)\n-      >>> transitions\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n-\n-      >>> len(transitions.by_token)\n-      3\n-\n-      >>> pub = transitions.by_token[\'publish\']\n-      >>> pub.title, pub.token, pub.value\n-      (u\'Publish [publish]\', \'publish\', \'publish\')\n-\n-      >>> publ = transitions.by_token[\'publicacao\']\n-      >>> publ.title == u\'Publica\xc3\xa7\xc3\xa3o [publicacao]\'\n-      True\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+\n+    >>> name = \'plone.app.vocabularies.WorkflowTransitions\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n+\n+    >>> class Transition(object):\n+    ...     def __init__(self, id, actbox_name):\n+    ...         self.id = id\n+    ...         self.actbox_name = actbox_name\n+\n+    >>> class TransitionsFolder(object):\n+    ...     def __init__(self, values):\n+    ...         self._values = values\n+    ...     def values(self):\n+    ...         return self._values\n+\n+    >>> class Workflow(object):\n+    ...     def __init__(self, id, title, values):\n+    ...         self.id = id\n+    ...         self.title = title\n+    ...         self.transitions = TransitionsFolder(values)\n+\n+    >>> tool = DummyTool(\'portal_workflow\')\n+    >>> t1 = Transition(\'publish\', \'Publish\')\n+    >>> t2 = Transition(\'reject\', \'Reject\')\n+    >>> t3 = Transition(\'publicacao\', u\'Publica\xc3\xa7\xc3\xa3o\')\n+\n+    >>> wf1 = Workflow(\'default\', \'Default Workflow\', (t1, t2))\n+    >>> wf2 = Workflow(\'intranet\', \'Intranet Workflow\', (t1, ))\n+    >>> wf3 = Workflow(\'noticias\', \'Workflow de Not\xc3\xadcias\', (t2, t3))\n+\n+    >>> def values():\n+    ...     return  wf1, wf2, wf3\n+    >>> tool.values = values\n+    >>> context.portal_workflow = tool\n+\n+    >>> transitions = util(context)\n+    >>> transitions\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+\n+    >>> len(transitions.by_token)\n+    3\n+\n+    >>> pub = transitions.by_token[\'publish\']\n+    >>> pub.title, pub.token, pub.value\n+    (u\'Publish [publish]\', \'publish\', \'publish\')\n+\n+    >>> publ = transitions.by_token[\'publicacao\']\n+    >>> publ.title == u\'Publica\xc3\xa7\xc3\xa3o [publicacao]\'\n+    True\n     """\n \n     def __call__(self, context):\n         site = getSite()\n-        wtool = getToolByName(site, \'portal_workflow\', None)\n+        wtool = getToolByName(site, "portal_workflow", None)\n         if wtool is None:\n             return SimpleVocabulary([])\n \n         transitions = {}\n         for wf in wtool.values():\n-            transition_folder = getattr(wf, \'transitions\', None)\n+            transition_folder = getattr(wf, "transitions", None)\n             wf_name = wf.title or wf.id\n             if transition_folder is not None:\n \n@@ -224,21 +218,23 @@ def __call__(self, context):\n                     # where transition names are in local language.\n                     # This may break overlying functionality even\n                     # if the terms themselves are never used\n-                    name = safe_unicode(transition.actbox_name)\n+                    name = safe_text(transition.actbox_name)\n \n                     transition_title = translate(\n-                        _(name),\n-                        context=aq_get(wtool, \'REQUEST\', None))\n+                        _(name), context=aq_get(wtool, "REQUEST", None)\n+                    )\n                     transitions.setdefault(transition.id, []).append(\n-                        dict(title=transition_title, wf_name=wf_name))\n+                        dict(title=transition_title, wf_name=wf_name)\n+                    )\n         items = []\n         transition_items = transitions.items()\n         for transition_id, info in sorted(transition_items, key=itemgetter(0)):\n-            titles = set([i[\'title\'] for i in info])\n-            item_title = \' // \'.join(sorted(titles))\n-            item_title = u\'{0} [{1}]\'.format(item_title, transition_id)\n+            titles = set([i["title"] for i in info])\n+            item_title = " // ".join(sorted(titles))\n+            item_title = "{0} [{1}]".format(item_title, transition_id)\n             items.append(SimpleTerm(transition_id, transition_id, item_title))\n \n         return SimpleVocabulary(items)\n \n+\n WorkflowTransitionsVocabularyFactory = WorkflowTransitionsVocabulary()\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 450b1d8..05b615d 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -18,7 +18,3 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n-\n-[tool.black]\n-line-length = 79\n-skip-string-normalization = true\ndiff --git a/setup.py b/setup.py\nindex d357204..464e772 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -2,50 +2,52 @@\n from setuptools import setup\n \n \n-version = \'5.0.0.dev0\'\n+version = "5.0.0.dev0"\n \n setup(\n-    name=\'plone.app.vocabularies\',\n+    name="plone.app.vocabularies",\n     version=version,\n-    description=\'Collection of generally useful vocabularies for Plone.\',\n-    long_description=\'{0}\\n{1}\'.format(\n-        open(\'README.rst\').read(), open(\'CHANGES.rst\').read()\n+    description="Collection of generally useful vocabularies for Plone.",\n+    long_description="{0}\\n{1}".format(\n+        open("README.rst").read(), open("CHANGES.rst").read()\n     ),\n     classifiers=[\n-        \'Development Status :: 6 - Mature\',\n-        \'Environment :: Web Environment\',\n-        \'Framework :: Plone\',\n-        \'Framework :: Plone :: Core\',\n-        \'Framework :: Plone :: 6.0\',\n-        \'Framework :: Zope :: 5\',\n-        \'License :: OSI Approved :: GNU General Public License v2 (GPLv2)\',\n-        \'Operating System :: OS Independent\',\n-        \'Programming Language :: Python\',\n-        \'Programming Language :: Python :: 3.7\',\n-        \'Programming Language :: Python :: 3.8\',\n-        \'Programming Language :: Python :: 3.9\',\n+        "Development Status :: 6 - Mature",\n+        "Environment :: Web Environment",\n+        "Framework :: Plone",\n+        "Framework :: Plone :: Core",\n+        "Framework :: Plone :: 6.0",\n+        "Framework :: Zope :: 5",\n+        "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n+        "Operating System :: OS Independent",\n+        "Programming Language :: Python",\n+        "Programming Language :: Python :: 3.7",\n+        "Programming Language :: Python :: 3.8",\n+        "Programming Language :: Python :: 3.9",\n     ],\n-    keywords=\'Plone Zope vocabularies\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://github.com/plone/plone.app.vocabularies\',\n-    license=\'GPL version 2\',\n+    keywords="Plone Zope vocabularies",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://github.com/plone/plone.app.vocabularies",\n+    license="GPL version 2",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\', \'plone.app\'],\n+    namespace_packages=["plone", "plone.app"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'plone.app.querystring\',\n-        \'plone.base\',\n-        \'pytz\',\n-        \'setuptools\',\n+        "plone.app.querystring",\n+        "plone.base",\n+        "pytz",\n+        "setuptools",\n+        "zope.deprecation",\n+        "zope.globalrequest",\n     ],\n     extras_require=dict(\n         test=[\n-            \'mock\',\n-            \'plone.app.testing\',\n-            \'zope.configuration\',\n-            \'zope.testing\',\n+            "mock",\n+            "plone.app.testing",\n+            "zope.configuration",\n+            "zope.testing",\n         ]\n     ),\n )\n'

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2022-08-18T08:27:00+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.vocabularies/commit/eb925b7be6129f09d3890803f653eac98b14c4ae

isort

Files changed:
M plone/app/vocabularies/catalog.py
M plone/app/vocabularies/language.py
M plone/app/vocabularies/security.py
M plone/app/vocabularies/skins.py
M plone/app/vocabularies/syndication.py
M plone/app/vocabularies/tests/base.py
M plone/app/vocabularies/tests/test_subjects_under_context.py
M plone/app/vocabularies/types.py

b"diff --git a/plone/app/vocabularies/catalog.py b/plone/app/vocabularies/catalog.py\nindex 1c48da8..f72b2a6 100644\n--- a/plone/app/vocabularies/catalog.py\n+++ b/plone/app/vocabularies/catalog.py\n@@ -4,17 +4,19 @@\n from plone.app.vocabularies.terms import BrowsableTerm\n from plone.app.vocabularies.terms import safe_simplevocabulary_from_values\n from plone.app.vocabularies.utils import parseQueryString\n-from plone.memoize.instance import memoize\n+from plone.base.utils import safe_text\n from plone.memoize import request\n+from plone.memoize.instance import memoize\n from plone.registry.interfaces import IRegistry\n from plone.uuid.interfaces import IUUID\n from Products.CMFCore.utils import getToolByName\n-from plone.base.utils import safe_text\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n from Products.ZCTextIndex.ParseTree import ParseError\n from z3c.formwidget.query.interfaces import IQuerySource\n from zope.browser.interfaces import ITerms\n from zope.component import queryUtility\n+from zope.component.hooks import getSite\n+from zope.globalrequest import getRequest\n from zope.interface import implementer\n from zope.interface import provider\n from zope.schema.interfaces import IContextSourceBinder\n@@ -22,8 +24,6 @@\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n-from zope.component.hooks import getSite\n-from zope.globalrequest import getRequest\n \n import itertools\n import json\ndiff --git a/plone/app/vocabularies/language.py b/plone/app/vocabularies/language.py\nindex 54648c3..ccd43b8 100644\n--- a/plone/app/vocabularies/language.py\n+++ b/plone/app/vocabularies/language.py\n@@ -1,11 +1,11 @@\n # -*- coding: utf-8 -*-\n from operator import itemgetter\n from Products.CMFCore.utils import getToolByName\n+from zope.component.hooks import getSite\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n-from zope.component.hooks import getSite\n \n \n @implementer(IVocabularyFactory)\ndiff --git a/plone/app/vocabularies/security.py b/plone/app/vocabularies/security.py\nindex af8e352..0bb6a1e 100644\n--- a/plone/app/vocabularies/security.py\n+++ b/plone/app/vocabularies/security.py\n@@ -2,13 +2,13 @@\n from Acquisition import aq_get\n from operator import attrgetter\n from Products.CMFCore.utils import getToolByName\n+from zope.component.hooks import getSite\n from zope.i18n import translate\n from zope.i18nmessageid import MessageFactory\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n-from zope.component.hooks import getSite\n \n import zope.deferredimport\n \ndiff --git a/plone/app/vocabularies/skins.py b/plone/app/vocabularies/skins.py\nindex c497d5a..cf05c51 100644\n--- a/plone/app/vocabularies/skins.py\n+++ b/plone/app/vocabularies/skins.py\n@@ -1,11 +1,11 @@\n # -*- coding: utf-8 -*-\n from Products.CMFCore.utils import getToolByName\n+from zope.component.hooks import getSite\n from zope.i18nmessageid import MessageFactory\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n-from zope.component.hooks import getSite\n \n \n _ = MessageFactory('plone')\ndiff --git a/plone/app/vocabularies/syndication.py b/plone/app/vocabularies/syndication.py\nindex 3753015..927b1cb 100644\n--- a/plone/app/vocabularies/syndication.py\n+++ b/plone/app/vocabularies/syndication.py\n@@ -1,5 +1,5 @@\n-from plone.base.interfaces import ISiteSyndicationSettings\n from plone.base import MessageFactory as _\n+from plone.base.interfaces import ISiteSyndicationSettings\n from plone.registry.interfaces import IRegistry\n from Products.CMFCore.utils import getToolByName\n from zope.component import getUtility\ndiff --git a/plone/app/vocabularies/tests/base.py b/plone/app/vocabularies/tests/base.py\nindex 7c3136d..e23d080 100644\n--- a/plone/app/vocabularies/tests/base.py\n+++ b/plone/app/vocabularies/tests/base.py\n@@ -2,8 +2,8 @@\n from OFS.interfaces import IItem\n from plone.app.layout.navigation.interfaces import INavigationRoot\n from Products.ZCTextIndex.ParseTree import ParseError\n-from zope.interface import implementer\n from zope.component.hooks import setSite\n+from zope.interface import implementer\n \n \n def create_context():\ndiff --git a/plone/app/vocabularies/tests/test_subjects_under_context.py b/plone/app/vocabularies/tests/test_subjects_under_context.py\nindex f1b25d5..eaa20f4 100644\n--- a/plone/app/vocabularies/tests/test_subjects_under_context.py\n+++ b/plone/app/vocabularies/tests/test_subjects_under_context.py\n@@ -22,10 +22,14 @@ def setUp(self):\n         context.portal_catalog = tool\n         context.portal_url = base.DummyUrlTool(context)\n \n-        from Products.PluginIndexes.KeywordIndex.KeywordIndex import KeywordIndex  # noqa\n+        from Products.PluginIndexes.KeywordIndex.KeywordIndex import (  # noqa\n+            KeywordIndex,\n+        )\n         kwindex = KeywordIndex('Subject')\n         tool.indexes['Subject'] = kwindex\n-        from Products.ExtendedPathIndex.ExtendedPathIndex import ExtendedPathIndex  # noqa\n+        from Products.ExtendedPathIndex.ExtendedPathIndex import (  # noqa\n+            ExtendedPathIndex,\n+        )\n         pathindex = ExtendedPathIndex('path')\n         tool.indexes['path'] = pathindex\n \ndiff --git a/plone/app/vocabularies/types.py b/plone/app/vocabularies/types.py\nindex b0b0551..dd1aa37 100644\n--- a/plone/app/vocabularies/types.py\n+++ b/plone/app/vocabularies/types.py\n@@ -2,12 +2,12 @@\n from Acquisition import aq_get\n from plone.app.vocabularies import PermissiveVocabulary\n from Products.CMFCore.utils import getToolByName\n+from zope.component.hooks import getSite\n from zope.i18n import translate\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n-from zope.component.hooks import getSite\n \n \n def getAllowedContentTypes(context):\n"

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2022-08-18T08:27:13+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.vocabularies/commit/9c3c10896cd7f55af28cfba2b97149a291a8bb61

black

Files changed:
M plone/__init__.py
M plone/app/__init__.py
M plone/app/vocabularies/__init__.py
M plone/app/vocabularies/actions.py
M plone/app/vocabularies/datetimerelated.py
M plone/app/vocabularies/editors.py
M plone/app/vocabularies/groups.py
M plone/app/vocabularies/images.py
M plone/app/vocabularies/interfaces.py
M plone/app/vocabularies/language.py
M plone/app/vocabularies/principals.py
M plone/app/vocabularies/security.py
M plone/app/vocabularies/skins.py
M plone/app/vocabularies/syndication.py
M plone/app/vocabularies/testing.py
M plone/app/vocabularies/tests/base.py
M plone/app/vocabularies/tests/test_imagesvocabularies.py
M plone/app/vocabularies/tests/test_principals.py
M plone/app/vocabularies/tests/test_subjects_under_context.py
M plone/app/vocabularies/tests/test_timezonevocabularies.py
M plone/app/vocabularies/tests/test_vocabularies.py
M plone/app/vocabularies/types.py
M plone/app/vocabularies/users.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..03d08ff 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1,2 @@\n # -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 68c04af..03d08ff 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,2 +1,2 @@\n # -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/vocabularies/__init__.py b/plone/app/vocabularies/__init__.py\nindex ccb2639..fb51752 100644\n--- a/plone/app/vocabularies/__init__.py\n+++ b/plone/app/vocabularies/__init__.py\n@@ -8,8 +8,8 @@\n from zope.schema.vocabulary import SimpleVocabulary\n \n \n-_token_parse_py3 = getattr(urllib, \'parse\', None)\n-_token_parse_py27 = lambda token: urllib.unquote_plus(token).decode(\'utf8\')\n+_token_parse_py3 = getattr(urllib, "parse", None)\n+_token_parse_py27 = lambda token: urllib.unquote_plus(token).decode("utf8")\n parse = _token_parse_py3.unquote if _token_parse_py3 else _token_parse_py27\n \n \ndiff --git a/plone/app/vocabularies/actions.py b/plone/app/vocabularies/actions.py\nindex c7de971..c0d2efa 100644\n--- a/plone/app/vocabularies/actions.py\n+++ b/plone/app/vocabularies/actions.py\n@@ -11,7 +11,7 @@ class ActionCategoriesVocabulary(object):\n     """Provides an actions categories vocabulary"""\n \n     def __call__(self, context):\n-        portal_actions = getToolByName(context, \'portal_actions\')\n+        portal_actions = getToolByName(context, "portal_actions")\n \n         # Building the list of action categories\n         try:\n@@ -32,11 +32,11 @@ class PortalActionCategoriesVocabulary(object):\n     """Provides portal action categories vocabulary."""\n \n     def __call__(self, context):\n-        portal_actions = getToolByName(context, \'portal_actions\')\n+        portal_actions = getToolByName(context, "portal_actions")\n         categories = portal_actions.objectIds()\n         terms = []\n         for category in sorted(categories):\n-            if category == \'controlpanel\':\n+            if category == "controlpanel":\n                 continue\n             title = portal_actions.get(category).title\n             if title:\n@@ -46,4 +46,5 @@ def __call__(self, context):\n             terms.append(SimpleTerm(category, title=title))\n         return SimpleVocabulary(terms)\n \n+\n PortalActionCategoriesVocabularyFactory = PortalActionCategoriesVocabulary()\ndiff --git a/plone/app/vocabularies/datetimerelated.py b/plone/app/vocabularies/datetimerelated.py\nindex 5951238..2f4d5c2 100644\n--- a/plone/app/vocabularies/datetimerelated.py\n+++ b/plone/app/vocabularies/datetimerelated.py\n@@ -11,7 +11,7 @@\n import pytz\n \n \n-PLMF = MessageFactory(\'plonelocales\')\n+PLMF = MessageFactory("plonelocales")\n \n \n @provider(IVocabularyFactory)\n@@ -20,9 +20,11 @@ def TimezonesFactory(context, query=None):\n \n     This are all timezones supported by pytz.\n     """\n-    tz_list = [SimpleTerm(value=it, title=PLMF(it, default=it))\n-               for it in pytz.all_timezones\n-               if query is None or query.lower() in it.lower()]\n+    tz_list = [\n+        SimpleTerm(value=it, title=PLMF(it, default=it))\n+        for it in pytz.all_timezones\n+        if query is None or query.lower() in it.lower()\n+    ]\n     return SimpleVocabulary(tz_list)\n \n \n@@ -32,35 +34,37 @@ def CommonTimezonesFactory(context, query=None):\n \n     This are the timezones a user would choose from in a form.\n     """\n-    tz_list = [SimpleTerm(value=it, title=PLMF(it, default=it))\n-               for it in pytz.common_timezones\n-               if query is None or query.lower() in it.lower()]\n+    tz_list = [\n+        SimpleTerm(value=it, title=PLMF(it, default=it))\n+        for it in pytz.common_timezones\n+        if query is None or query.lower() in it.lower()\n+    ]\n     return SimpleVocabulary(tz_list)\n \n \n @provider(IVocabularyFactory)\n def AvailableTimezonesFactory(context, query=None):\n-    """Vocabulary for available timezones, as set by in the controlpanel.\n-    """\n-    reg_key = \'plone.available_timezones\'\n+    """Vocabulary for available timezones, as set by in the controlpanel."""\n+    reg_key = "plone.available_timezones"\n     registry = getUtility(IRegistry)\n     # check if \'plone.available_timezones\' is in registry\n     if reg_key not in registry:\n         # else use \'plone.app.event.available_timezones\'\n-        reg_key = \'plone.app.event.available_timezones\'\n+        reg_key = "plone.app.event.available_timezones"\n     if reg_key not in registry:\n         raise NotImplementedError(\n-            \'"available timezones" needs Plone 5.x or plone.app.event \'\n-            \'installed.\'\n+            \'"available timezones" needs Plone 5.x or plone.app.event \' "installed."\n         )\n-    tz_list = [SimpleTerm(value=it, title=PLMF(it, default=it))\n-               for it in registry[reg_key]\n-               if query is None or query.lower() in it.lower()]\n+    tz_list = [\n+        SimpleTerm(value=it, title=PLMF(it, default=it))\n+        for it in registry[reg_key]\n+        if query is None or query.lower() in it.lower()\n+    ]\n     return SimpleVocabulary(tz_list)\n \n \n # PLEASE NOTE: strftime %w interprets 0 as Sunday unlike the calendar module!\n-WEEKDAY_PREFIXES = [\'mon\', \'tue\', \'wed\', \'thu\', \'fri\', \'sat\', \'sun\']\n+WEEKDAY_PREFIXES = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]\n \n \n @provider(IVocabularyFactory)\n@@ -100,7 +104,7 @@ def WeekdaysFactory(context):\n     """\n     items = []\n     for idx in range(len(WEEKDAY_PREFIXES)):\n-        msgstr = PLMF(\'weekday_{0}\'.format(WEEKDAY_PREFIXES[idx]))\n+        msgstr = PLMF("weekday_{0}".format(WEEKDAY_PREFIXES[idx]))\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\n \n@@ -142,7 +146,7 @@ def WeekdaysAbbrFactory(context):\n     """\n     items = []\n     for idx in range(len(WEEKDAY_PREFIXES)):\n-        msgstr = PLMF(\'weekday_{0}_abbr\'.format(WEEKDAY_PREFIXES[idx]))\n+        msgstr = PLMF("weekday_{0}_abbr".format(WEEKDAY_PREFIXES[idx]))\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\n \n@@ -184,13 +188,25 @@ def WeekdaysShortFactory(context):\n     """\n     items = []\n     for idx in range(len(WEEKDAY_PREFIXES)):\n-        msgstr = PLMF(\'weekday_{0}_short\'.format(WEEKDAY_PREFIXES[idx]))\n+        msgstr = PLMF("weekday_{0}_short".format(WEEKDAY_PREFIXES[idx]))\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\n \n \n-MONTH_PREFIXES = [\'jan\', \'feb\', \'mar\', \'apr\', \'may\', \'jun\',\n-                  \'jul\', \'aug\', \'sep\', \'oct\', \'nov\', \'dec\']\n+MONTH_PREFIXES = [\n+    "jan",\n+    "feb",\n+    "mar",\n+    "apr",\n+    "may",\n+    "jun",\n+    "jul",\n+    "aug",\n+    "sep",\n+    "oct",\n+    "nov",\n+    "dec",\n+]\n \n \n @provider(IVocabularyFactory)\n@@ -222,7 +238,7 @@ def MonthFactory(context):\n     """\n     items = []\n     for idx in range(len(MONTH_PREFIXES)):\n-        msgstr = PLMF(\'month_{0}\'.format(MONTH_PREFIXES[idx]))\n+        msgstr = PLMF("month_{0}".format(MONTH_PREFIXES[idx]))\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\n \n@@ -256,6 +272,6 @@ def MonthAbbrFactory(context):\n     """\n     items = []\n     for idx in range(len(MONTH_PREFIXES)):\n-        msgstr = PLMF(\'month_{0}_abbr\'.format(MONTH_PREFIXES[idx]))\n+        msgstr = PLMF("month_{0}_abbr".format(MONTH_PREFIXES[idx]))\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\ndiff --git a/plone/app/vocabularies/editors.py b/plone/app/vocabularies/editors.py\nindex 4743b83..61d1d05 100644\n--- a/plone/app/vocabularies/editors.py\n+++ b/plone/app/vocabularies/editors.py\n@@ -8,25 +8,21 @@\n from zope.schema.vocabulary import SimpleVocabulary\n \n \n-_ = MessageFactory(\'plone\')\n+_ = MessageFactory("plone")\n \n \n @implementer(IVocabularyFactory)\n class AvailableEditorsVocabulary(object):\n-\n     def __call__(self, context):\n         items = []\n \n         registry = getUtility(IRegistry)\n-        settings = registry.forInterface(\n-            IEditingSchema,\n-            prefix=\'plone\',\n-            check=False\n-        )\n+        settings = registry.forInterface(IEditingSchema, prefix="plone", check=False)\n \n         if settings:\n             editors = settings.available_editors\n             items = [SimpleTerm(e, e, _(e)) for e in editors]\n         return SimpleVocabulary(items)\n \n+\n AvailableEditorsVocabularyFactory = AvailableEditorsVocabulary()\ndiff --git a/plone/app/vocabularies/groups.py b/plone/app/vocabularies/groups.py\nindex 04b6c8d..6e0acb4 100644\n--- a/plone/app/vocabularies/groups.py\n+++ b/plone/app/vocabularies/groups.py\n@@ -25,48 +25,46 @@ class ISourceQueryView(Interface):\n @provider(IContextSourceBinder)\n class GroupsSource(object):\n     """\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n \n-      >>> context = create_context()\n+    >>> context = create_context()\n \n-      >>> tool = DummyTool(\'acl_users\')\n-      >>> groups = (\'group1\', \'group2\')\n-      >>> def getGroupById(value, default):\n-      ...     return value in groups and value or default\n-      >>> tool.getGroupById = getGroupById\n-      >>> def searchGroups(name=None):\n-      ...     return [dict(groupid=u) for u in groups]\n-      >>> tool.searchGroups = searchGroups\n-      >>> context.acl_users = tool\n+    >>> tool = DummyTool(\'acl_users\')\n+    >>> groups = (\'group1\', \'group2\')\n+    >>> def getGroupById(value, default):\n+    ...     return value in groups and value or default\n+    >>> tool.getGroupById = getGroupById\n+    >>> def searchGroups(name=None):\n+    ...     return [dict(groupid=u) for u in groups]\n+    >>> tool.searchGroups = searchGroups\n+    >>> context.acl_users = tool\n \n-      >>> source = GroupsSource(context)\n-      >>> source\n-      <plone.app.vocabularies.groups.GroupsSource object at ...>\n+    >>> source = GroupsSource(context)\n+    >>> source\n+    <plone.app.vocabularies.groups.GroupsSource object at ...>\n \n-      >>> len(source.search(\'\'))\n-      2\n+    >>> len(source.search(\'\'))\n+    2\n \n-      >>> len(source.search(u\'\\xa4\'))\n-      2\n+    >>> len(source.search(u\'\\xa4\'))\n+    2\n \n-      >>> \'group1\' in source, \'noone\' in source\n-      (True, False)\n+    >>> \'group1\' in source, \'noone\' in source\n+    (True, False)\n \n-      >>> source.get(\'group1\'), source.get(\'noone\')\n-      (\'group1\', None)\n+    >>> source.get(\'group1\'), source.get(\'noone\')\n+    (\'group1\', None)\n     """\n \n     def __init__(self, context):\n-        msg = \'GroupsSource is deprecated and will be removed on \' \\\n-              \'Plone 6\'\n+        msg = "GroupsSource is deprecated and will be removed on " "Plone 6"\n         warnings.warn(msg, DeprecationWarning)\n         self.context = context\n-        self.users = getToolByName(context, \'acl_users\')\n+        self.users = getToolByName(context, "acl_users")\n \n     def __contains__(self, value):\n-        """Return whether the value is available in this source\n-        """\n+        """Return whether the value is available in this source"""\n         if self.get(value) is None:\n             return False\n         return True\n@@ -77,11 +75,11 @@ def search(self, query):\n         # it\'s unicode\n \n         try:\n-            name = query.encode(\'ascii\')\n+            name = query.encode("ascii")\n         except UnicodeEncodeError:\n             name = query\n \n-        return [u[\'groupid\'] for u in self.users.searchGroups(name=name)]\n+        return [u["groupid"] for u in self.users.searchGroups(name=name)]\n \n     def get(self, value):\n         return self.users.getGroupById(value, None)\n@@ -90,69 +88,68 @@ def get(self, value):\n @implementer(ITerms, ISourceQueryView)\n class GroupsSourceQueryView(object):\n     """\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> from plone.app.vocabularies.tests.base import Request\n-\n-      >>> context = create_context()\n-\n-      >>> class Group(object):\n-      ...     def __init__(self, id):\n-      ...         self.id = id\n-      ...\n-      ...     def getProperty(self, value, default):\n-      ...         return self.id\n-      ...\n-      ...     getId = getProperty\n-\n-      >>> tool = DummyTool(\'acl_users\')\n-      >>> groups = (\'group1\', \'group2\')\n-      >>> def getGroupById(value, default):\n-      ...     return value in groups and Group(value) or None\n-      >>> tool.getGroupById = getGroupById\n-      >>> def searchGroups(name=None):\n-      ...     return [dict(groupid=u) for u in groups]\n-      >>> tool.searchGroups = searchGroups\n-      >>> context.acl_users = tool\n-\n-      >>> source = GroupsSource(context)\n-      >>> source\n-      <plone.app.vocabularies.groups.GroupsSource object at ...>\n-\n-      >>> view = GroupsSourceQueryView(source, Request())\n-      >>> view\n-      <plone.app.vocabularies.groups.GroupsSourceQueryView object at ...>\n-\n-      >>> view.getTerm(\'group1\')\n-      <zope.schema.vocabulary.SimpleTerm object at ...>\n-\n-      >>> view.getValue(\'group1\')\n-      \'group1\'\n-\n-      >>> view.getValue(\'noone\')\n-      Traceback (most recent call last):\n-      ...\n-      LookupError: noone\n-\n-      >>> template = view.render(name=\'t\')\n-\n-      >>> u\'<input type="text" name="t.query" value="" />\' in template\n-      True\n-\n-      >>> u\'<input type="submit" name="t.search" value="Search" />\' in template\n-      True\n-\n-      >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n-      >>> view = GroupsSourceQueryView(source, request)\n-      >>> view.results(\'t\')\n-      [\'group1\', \'group2\']\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import Request\n+\n+    >>> context = create_context()\n+\n+    >>> class Group(object):\n+    ...     def __init__(self, id):\n+    ...         self.id = id\n+    ...\n+    ...     def getProperty(self, value, default):\n+    ...         return self.id\n+    ...\n+    ...     getId = getProperty\n+\n+    >>> tool = DummyTool(\'acl_users\')\n+    >>> groups = (\'group1\', \'group2\')\n+    >>> def getGroupById(value, default):\n+    ...     return value in groups and Group(value) or None\n+    >>> tool.getGroupById = getGroupById\n+    >>> def searchGroups(name=None):\n+    ...     return [dict(groupid=u) for u in groups]\n+    >>> tool.searchGroups = searchGroups\n+    >>> context.acl_users = tool\n+\n+    >>> source = GroupsSource(context)\n+    >>> source\n+    <plone.app.vocabularies.groups.GroupsSource object at ...>\n+\n+    >>> view = GroupsSourceQueryView(source, Request())\n+    >>> view\n+    <plone.app.vocabularies.groups.GroupsSourceQueryView object at ...>\n+\n+    >>> view.getTerm(\'group1\')\n+    <zope.schema.vocabulary.SimpleTerm object at ...>\n+\n+    >>> view.getValue(\'group1\')\n+    \'group1\'\n+\n+    >>> view.getValue(\'noone\')\n+    Traceback (most recent call last):\n+    ...\n+    LookupError: noone\n+\n+    >>> template = view.render(name=\'t\')\n+\n+    >>> u\'<input type="text" name="t.query" value="" />\' in template\n+    True\n+\n+    >>> u\'<input type="submit" name="t.search" value="Search" />\' in template\n+    True\n+\n+    >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n+    >>> view = GroupsSourceQueryView(source, request)\n+    >>> view.results(\'t\')\n+    [\'group1\', \'group2\']\n     """\n \n-    template = ViewPageTemplateFile(\'searchabletextsource.pt\')\n+    template = ViewPageTemplateFile("searchabletextsource.pt")\n \n     def __init__(self, context, request):\n-        msg = \'GroupsSourceQueryView is deprecated and will be removed on \' \\\n-              \'Plone 6\'\n+        msg = "GroupsSourceQueryView is deprecated and will be removed on " "Plone 6"\n         warnings.warn(msg, DeprecationWarning)\n         self.context = context\n         self.request = request\n@@ -162,7 +159,7 @@ def getTerm(self, value):\n         token = value\n         title = value\n         if group is not None:\n-            title = group.getProperty(\'title\', None) or group.getId()\n+            title = group.getProperty("title", None) or group.getId()\n         return SimpleTerm(value, token=token, title=title)\n \n     def getValue(self, token):\n@@ -175,9 +172,9 @@ def render(self, name):\n \n     def results(self, name):\n         # check whether the normal search button was pressed\n-        if name + \'.search\' in self.request.form:\n-            query_fieldname = name + \'.query\'\n+        if name + ".search" in self.request.form:\n+            query_fieldname = name + ".query"\n             if query_fieldname in self.request.form:\n                 query = self.request.form[query_fieldname]\n-                if query != \'\':\n+                if query != "":\n                     return self.context.search(query)\ndiff --git a/plone/app/vocabularies/images.py b/plone/app/vocabularies/images.py\nindex b090ae0..6006b07 100644\n--- a/plone/app/vocabularies/images.py\n+++ b/plone/app/vocabularies/images.py\n@@ -9,20 +9,20 @@\n import six\n \n \n-PMF = MessageFactory(\'plone\')\n+PMF = MessageFactory("plone")\n \n \n @provider(IVocabularyFactory)\n def ScalesVocabulary(context):\n-    """Obtains available scales from registry\n-    """\n+    """Obtains available scales from registry"""\n     terms = []\n     allowedSizes = getAllowedSizes()\n     if allowedSizes is not None:\n         for scale, (width, height) in six.iteritems(getAllowedSizes()):\n             translated = PMF(\n-                \'imagescale_{0:s}\'.format(scale),\n-                default=\'{0:s} ${{width}}x${{height}}\'.format(scale),\n-                mapping={\'width\': str(width), \'height\': str(height)})\n+                "imagescale_{0:s}".format(scale),\n+                default="{0:s} ${{width}}x${{height}}".format(scale),\n+                mapping={"width": str(width), "height": str(height)},\n+            )\n             terms.append(SimpleTerm(scale, scale, translated))\n     return SimpleVocabulary(terms)\ndiff --git a/plone/app/vocabularies/interfaces.py b/plone/app/vocabularies/interfaces.py\nindex c2e90ad..b1334c2 100644\n--- a/plone/app/vocabularies/interfaces.py\n+++ b/plone/app/vocabularies/interfaces.py\n@@ -5,14 +5,14 @@\n \n \n class ITermWithDescription(Interface):\n-    """A term which carries an additional description\n-    """\n+    """A term which carries an additional description"""\n \n     description = Attribute(\n-        \'description\',\n+        "description",\n         """Description of the term, which will be displayed to distinguish\n            between terms with similar labels.\n-        """)\n+        """,\n+    )\n \n \n class IBrowsableTerm(Interface):\n@@ -21,28 +21,29 @@ class IBrowsableTerm(Interface):\n     """\n \n     browse_token = Attribute(\n-        \'browse_token\',\n+        "browse_token",\n         """Token which can be used to get contents of browsable terms in\n            queryable sources.\n \n         The value of this attribute must be a non-empty 7-bit string.\n         Control characters are not allowed.\n-        """)\n+        """,\n+    )\n \n     parent_token = Attribute(\n-        \'parent_token\',\n+        "parent_token",\n         """Token which can be used to get contents of the parent of browsable\n            terms in queryable sources.\n \n         The value of this attribute must be a non-empty 7-bit string.\n         Control characters are not allowed.\n-        """)\n+        """,\n+    )\n \n \n class ISlicableVocabulary(IVocabularyTokenized):\n-\n     def __getitem__(start, stop):\n-        """ return a slice of the results"""\n+        """return a slice of the results"""\n \n \n class IPermissiveVocabulary(IVocabularyTokenized):\ndiff --git a/plone/app/vocabularies/language.py b/plone/app/vocabularies/language.py\nindex ccd43b8..60b6129 100644\n--- a/plone/app/vocabularies/language.py\n+++ b/plone/app/vocabularies/language.py\n@@ -12,47 +12,48 @@\n class AvailableContentLanguageVocabulary(object):\n     """Vocabulary factory for available content languages in the portal.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-\n-      >>> name = \'plone.app.vocabularies.AvailableContentLanguages\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n-\n-      >>> len(util(context))  # \'en\' is given as default now\n-      1\n-\n-      >>> tool = DummyTool(\'portal_languages\')\n-      >>> def getAvailableLanguages():\n-      ...     return dict(en=dict(name=\'English\', native=\'English\'),\n-      ...                 de=dict(name=\'German\', native=\'Deutsch\'))\n-      >>> tool.getAvailableLanguages = getAvailableLanguages\n-      >>> context.portal_languages = tool\n-\n-      >>> languages = util(context)\n-      >>> languages\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n-\n-      >>> len(languages.by_token)\n-      2\n-\n-      >>> de = languages.by_token[\'de\']\n-      >>> de.title, de.token, de.value\n-      (\'Deutsch\', \'de\', \'de\')\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+\n+    >>> name = \'plone.app.vocabularies.AvailableContentLanguages\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n+\n+    >>> len(util(context))  # \'en\' is given as default now\n+    1\n+\n+    >>> tool = DummyTool(\'portal_languages\')\n+    >>> def getAvailableLanguages():\n+    ...     return dict(en=dict(name=\'English\', native=\'English\'),\n+    ...                 de=dict(name=\'German\', native=\'Deutsch\'))\n+    >>> tool.getAvailableLanguages = getAvailableLanguages\n+    >>> context.portal_languages = tool\n+\n+    >>> languages = util(context)\n+    >>> languages\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+\n+    >>> len(languages.by_token)\n+    2\n+\n+    >>> de = languages.by_token[\'de\']\n+    >>> de.title, de.token, de.value\n+    (\'Deutsch\', \'de\', \'de\')\n     """\n \n     def __call__(self, context):\n-        items = [SimpleTerm(\'en\', \'en\', \'English\')]  # default, only english\n+        items = [SimpleTerm("en", "en", "English")]  # default, only english\n         site = getSite()\n-        ltool = getToolByName(site, \'portal_languages\', None)\n+        ltool = getToolByName(site, "portal_languages", None)\n         if ltool is not None:\n             languages = ltool.getAvailableLanguages()\n-            items = [(l, languages[l].get(\'native\', l)) for l in languages]\n+            items = [(l, languages[l].get("native", l)) for l in languages]\n             items.sort(key=itemgetter(1))\n             items = [SimpleTerm(i[0], i[0], i[1]) for i in items]\n         return SimpleVocabulary(items)\n \n+\n AvailableContentLanguageVocabularyFactory = AvailableContentLanguageVocabulary()  # noqa\n \n \n@@ -60,58 +61,53 @@ def __call__(self, context):\n class SupportedContentLanguageVocabulary(object):\n     """Vocabulary factory for supported content languages in the portal.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-\n-      >>> name = \'plone.app.vocabularies.SupportedContentLanguages\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n-\n-      >>> len(util(context))\n-      0\n-\n-      >>> tool = DummyTool(\'portal_languages\')\n-      >>> def listSupportedLanguages():\n-      ...     return [(\'en\', \'English\'), (\'de\', \'German\')]\n-      >>> tool.listSupportedLanguages = listSupportedLanguages\n-      >>> def getAvailableLanguages():\n-      ...     return dict(en=dict(name=\'English\', native=\'English\'),\n-      ...                 de=dict(name=\'German\', native=\'Deutsch\'))\n-      >>> tool.getAvailableLanguages = getAvailableLanguages\n-      >>> context.portal_languages = tool\n-\n-      >>> languages = util(context)\n-      >>> languages\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n-\n-      >>> len(languages.by_token)\n-      2\n-\n-      >>> de = languages.by_token[\'de\']\n-      >>> de.title, de.token, de.value\n-      (\'Deutsch\', \'de\', \'de\')\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+\n+    >>> name = \'plone.app.vocabularies.SupportedContentLanguages\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n+\n+    >>> len(util(context))\n+    0\n+\n+    >>> tool = DummyTool(\'portal_languages\')\n+    >>> def listSupportedLanguages():\n+    ...     return [(\'en\', \'English\'), (\'de\', \'German\')]\n+    >>> tool.listSupportedLanguages = listSupportedLanguages\n+    >>> def getAvailableLanguages():\n+    ...     return dict(en=dict(name=\'English\', native=\'English\'),\n+    ...                 de=dict(name=\'German\', native=\'Deutsch\'))\n+    >>> tool.getAvailableLanguages = getAvailableLanguages\n+    >>> context.portal_languages = tool\n+\n+    >>> languages = util(context)\n+    >>> languages\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+\n+    >>> len(languages.by_token)\n+    2\n+\n+    >>> de = languages.by_token[\'de\']\n+    >>> de.title, de.token, de.value\n+    (\'Deutsch\', \'de\', \'de\')\n     """\n \n     def __call__(self, context):\n         items = []\n         site = getSite()\n-        ltool = getToolByName(site, \'portal_languages\', None)\n+        ltool = getToolByName(site, "portal_languages", None)\n         if ltool is not None:\n             items = ltool.listSupportedLanguages()\n             all_langs = ltool.getAvailableLanguages()\n-            items = [\n-                (l[0], all_langs[l[0]].get(\'native\', l[1]))\n-                for l in items\n-            ]\n+            items = [(l[0], all_langs[l[0]].get("native", l[1])) for l in items]\n             items.sort(key=itemgetter(1))\n             items = [\n-                SimpleTerm(\n-                    i[0],\n-                    i[0],\n-                    all_langs.get(i[0], {}).get(\'native\', i[1])\n-                ) for i in items\n+                SimpleTerm(i[0], i[0], all_langs.get(i[0], {}).get("native", i[1]))\n+                for i in items\n             ]\n         return SimpleVocabulary(items)\n \n+\n SupportedContentLanguageVocabularyFactory = SupportedContentLanguageVocabulary()  # noqa\ndiff --git a/plone/app/vocabularies/principals.py b/plone/app/vocabularies/principals.py\nindex 49afebd..7291f08 100644\n--- a/plone/app/vocabularies/principals.py\n+++ b/plone/app/vocabularies/principals.py\n@@ -10,40 +10,40 @@\n from zope.schema.vocabulary import SimpleVocabulary\n \n \n-GETTER = {\'user\': \'getUserById\', \'group\': \'getGroupById\'}\n+GETTER = {"user": "getUserById", "group": "getGroupById"}\n \n _USER_SEARCH = {\n-    \'search\': \'searchUsers\',\n+    "search": "searchUsers",\n     # Hint: The fullname search is provided i.e. in IUserEnumeration of\n     # the property plugin in PlonePAS.\n-    \'searchattr\': \'fullname\',\n-    \'searchargs\': {\'sort_by\': \'fullname\'},\n-    \'many\': \'plone.many_users\',\n+    "searchattr": "fullname",\n+    "searchargs": {"sort_by": "fullname"},\n+    "many": "plone.many_users",\n }\n _GROUP_SEARCH = {\n-    \'search\': \'searchGroups\',\n+    "search": "searchGroups",\n     # Hint: The fullname search is excluded in i.e. in IUserEnumeration of\n     # the property plugin in PlonePAS. title is supported.\n-    \'searchattr\': \'title\',\n-    \'searchargs\': {\'sort_by\': \'title\'},\n-    \'many\': \'plone.many_groups\',\n+    "searchattr": "title",\n+    "searchargs": {"sort_by": "title"},\n+    "many": "plone.many_groups",\n }\n \n SOURCES = {\n-    \'user\': {\n-        \'searches\': [_USER_SEARCH],\n-        \'get\': \'getUserById\',\n-        \'prefix\': False,\n+    "user": {\n+        "searches": [_USER_SEARCH],\n+        "get": "getUserById",\n+        "prefix": False,\n     },\n-    \'group\': {\n-        \'searches\': [_GROUP_SEARCH],\n-        \'get\': \'getGroupById\',\n-        \'prefix\': False,\n+    "group": {\n+        "searches": [_GROUP_SEARCH],\n+        "get": "getGroupById",\n+        "prefix": False,\n     },\n-    \'principal\': {\n-        \'searches\': [_GROUP_SEARCH, _USER_SEARCH],\n-        \'get\': \'getPrincipalById\',\n-        \'prefix\': True,\n+    "principal": {\n+        "searches": [_GROUP_SEARCH, _USER_SEARCH],\n+        "get": "getPrincipalById",\n+        "prefix": True,\n     },\n }\n \n@@ -53,38 +53,37 @@ def token_from_principal_info(info, prefix=False):\n     # for patternlib or for options tag (where the standard wants\n     # something CDATA compatible)\n     if not prefix:\n-        return info[\'id\']\n+        return info["id"]\n     # we use a double underscore here, a colon is already used in pattern\n     # values as separator\n-    return \'{0}__{1}\'.format(info[\'principal_type\'], info[\'id\'])\n+    return "{0}__{1}".format(info["principal_type"], info["id"])\n \n \n def merge_principal_infos(infos, prefix=False):\n     info = infos[0]\n     if len(infos) > 1:\n-        principal_types = set([\n-            info[\'principal_type\'] for info in infos if info[\'principal_type\']]\n+        principal_types = set(\n+            [info["principal_type"] for info in infos if info["principal_type"]]\n         )\n         if len(principal_types) > 1:\n             # Principals with the same ID but different types. Should not\n             # happen.\n-            raise ValueError(\'Principal ID not unique: {}\'.format(info[\'id\']))\n-        if not info[\'title\']:\n+            raise ValueError("Principal ID not unique: {}".format(info["id"]))\n+        if not info["title"]:\n             for candidate in infos:\n-                if candidate[\'title\']:\n-                    info[\'title\'] = candidate[\'title\']\n+                if candidate["title"]:\n+                    info["title"] = candidate["title"]\n                     break\n     return info\n \n \n def _get_acl_users():\n-    return getToolByName(getSite(), \'acl_users\')\n+    return getToolByName(getSite(), "acl_users")\n \n \n @implementer(ISlicableVocabulary)\n class PrincipalsVocabulary(SimpleVocabulary):\n-    """Vocabulary dealing with users/ groups (or in theory any other principal)\n-    """\n+    """Vocabulary dealing with users/ groups (or in theory any other principal)"""\n \n     @property\n     def principal_source(self):\n@@ -96,27 +95,24 @@ def principal_source(self, value):\n \n     @property\n     def _acl_users(self):\n-        aclu = getattr(self, \'_aclu\', None)\n+        aclu = getattr(self, "_aclu", None)\n         if not aclu:\n             aclu = self._aclu = _get_acl_users()\n         return aclu\n \n     def _get_principal_from_source(self, value=None, token=None, default=None):\n-        """Helper to get a user or group from users folder.\n-        """\n+        """Helper to get a user or group from users folder."""\n         if not (bool(value) ^ bool(token)):  # not (value xor token)\n-            raise ValueError(\n-                \'value or token must be provided (only one of those)\'\n-            )\n-        if SOURCES[self._principal_source][\'prefix\']:\n+            raise ValueError("value or token must be provided (only one of those)")\n+        if SOURCES[self._principal_source]["prefix"]:\n             if value:\n-                if \':\' not in value:\n+                if ":" not in value:\n                     return default\n-                principal_type, principal_id = value.split(\':\', 2)\n+                principal_type, principal_id = value.split(":", 2)\n             else:\n-                if \'__\' not in token:\n+                if "__" not in token:\n                     return default\n-                principal_type, principal_id = token.split(\'__\', 2)\n+                principal_type, principal_id = token.split("__", 2)\n         else:\n             principal_type = self._principal_source\n             principal_id = value or token\n@@ -124,34 +120,30 @@ def _get_principal_from_source(self, value=None, token=None, default=None):\n         return getter(principal_id, default)\n \n     def _get_term_from_source(self, value=None, token=None):\n-        """Helper to get a user or group from users folder.\n-        """\n+        """Helper to get a user or group from users folder."""\n         if not (bool(value) ^ bool(token)):  # not (value xor token)\n-            raise ValueError(\n-                \'value or token must be provided (only one of those)\'\n-            )\n+            raise ValueError("value or token must be provided (only one of those)")\n         principal = self._get_principal_from_source(value=value, token=token)\n         if principal is None:\n-            raise LookupError(\'Principal {} not found\'.format(value or token))\n+            raise LookupError("Principal {} not found".format(value or token))\n         if principal.isGroup():\n-            title = principal.getProperty(\'title\', principal.getId())\n-            principal_type = \'group\'\n+            title = principal.getProperty("title", principal.getId())\n+            principal_type = "group"\n         else:\n-            title = principal.getProperty(\'fullname\', principal.getId())\n-            principal_type = \'user\'\n+            title = principal.getProperty("fullname", principal.getId())\n+            principal_type = "user"\n         if token:\n             value = principal.getId()\n-            if SOURCES[self._principal_source][\'prefix\']:\n-                value = \'{0}:{1}\'.format(principal_type, value)\n+            if SOURCES[self._principal_source]["prefix"]:\n+                value = "{0}:{1}".format(principal_type, value)\n         else:\n             token = principal.getId()\n-            if SOURCES[self._principal_source][\'prefix\']:\n-                token = \'{0}__{1}\'.format(principal_type, token)\n+            if SOURCES[self._principal_source]["prefix"]:\n+                token = "{0}__{1}".format(principal_type, token)\n         return self.__class__.createTerm(value, token, title)\n \n     def __contains__(self, value):\n-        """Checks if the principal exists in current subset or in PAS.\n-        """\n+        """Checks if the principal exists in current subset or in PAS."""\n         result = super(PrincipalsVocabulary, self).__contains__(value)\n         return result or bool(self._get_principal_from_source(value=value))\n \n@@ -187,14 +179,12 @@ def __getitem__(self, start, stop=None):\n \n \n class BaseFactory(object):\n-    """Factory creating a PrincipalsVocabulary\n-    """\n+    """Factory creating a PrincipalsVocabulary"""\n \n     source = None\n \n     def should_search(self, query):\n-        """ Test if we should search for users\n-        """\n+        """Test if we should search for users"""\n         if query:\n             return True\n         registry = getUtility(IRegistry)\n@@ -202,7 +192,7 @@ def should_search(self, query):\n             x\n             for x in filter(\n                 registry.get,\n-                [cfg[\'many\'] for cfg in SOURCES[self.source][\'searches\']],\n+                [cfg["many"] for cfg in SOURCES[self.source]["searches"]],\n             )\n         ]\n \n@@ -223,7 +213,7 @@ def use_principal_triple(self, principal_triple):\n         """\n         return True\n \n-    def __call__(self, context, query=\'\'):\n+    def __call__(self, context, query=""):\n         if not self.should_search(query):\n             vocabulary = PrincipalsVocabulary([])\n             vocabulary.principal_source = self.source\n@@ -233,37 +223,32 @@ def __call__(self, context, query=\'\'):\n \n         def term_triples():\n             """Generator for term triples (value, token, name)"""\n-            for search_cfg in cfg[\'searches\']:\n-                search = getattr(acl_users, search_cfg[\'search\'])\n-                searchargs = search_cfg[\'searchargs\'].copy()\n-                searchargs[search_cfg[\'searchattr\']] = query\n+            for search_cfg in cfg["searches"]:\n+                search = getattr(acl_users, search_cfg["search"])\n+                searchargs = search_cfg["searchargs"].copy()\n+                searchargs[search_cfg["searchattr"]] = query\n                 infotree = {}\n                 for info in search(**searchargs):\n-                    infotree.setdefault(\n-                        info[\'id\'], {}).setdefault(\n-                            info[\'principal_type\'], []).append(\n-                                info)\n+                    infotree.setdefault(info["id"], {}).setdefault(\n+                        info["principal_type"], []\n+                    ).append(info)\n                 for principal_id, types_infos in infotree.items():\n-                    if len(types_infos) > 1 and not cfg[\'prefix\']:\n-                        raise ValueError(\'Principal ID not unique: {}\'.format(\n-                            principal_id))\n+                    if len(types_infos) > 1 and not cfg["prefix"]:\n+                        raise ValueError(\n+                            "Principal ID not unique: {}".format(principal_id)\n+                        )\n                     for principal_type, principal_infos in types_infos.items():\n                         value = principal_id\n                         info = merge_principal_infos(principal_infos)\n-                        if cfg[\'prefix\']:\n-                            value = \'{0}:{1}\'.format(\n-                                info[\'principal_type\'], value)\n-                        token = token_from_principal_info(\n-                            info, prefix=cfg[\'prefix\']\n-                        )\n-                        yield (value, token, info[\'title\'])\n+                        if cfg["prefix"]:\n+                            value = "{0}:{1}".format(info["principal_type"], value)\n+                        token = token_from_principal_info(info, prefix=cfg["prefix"])\n+                        yield (value, token, info["title"])\n \n         vocabulary = PrincipalsVocabulary(\n             [\n                 SimpleTerm(*term_triple)\n-                for term_triple in filter(\n-                    self.use_principal_triple, term_triples()\n-                )\n+                for term_triple in filter(self.use_principal_triple, term_triples())\n             ]\n         )\n         vocabulary.principal_source = self.source\n@@ -272,14 +257,14 @@ def term_triples():\n \n @implementer(IVocabularyFactory)\n class PrincipalsFactory(BaseFactory):\n-    source = \'principal\'\n+    source = "principal"\n \n \n @implementer(IVocabularyFactory)\n class UsersFactory(BaseFactory):\n-    source = \'user\'\n+    source = "user"\n \n \n @implementer(IVocabularyFactory)\n class GroupsFactory(BaseFactory):\n-    source = \'group\'\n+    source = "group"\ndiff --git a/plone/app/vocabularies/security.py b/plone/app/vocabularies/security.py\nindex 0bb6a1e..feeea26 100644\n--- a/plone/app/vocabularies/security.py\n+++ b/plone/app/vocabularies/security.py\n@@ -15,66 +15,66 @@\n \n zope.deferredimport.deprecated(\n     "Import from plone.app.vocabularies.principals instead",\n-    GroupsFactory=\'plone.app.vocabularies:principals.GroupsFactory\',\n-    GroupsVocabulary=\'plone.app.vocabularies:principals.GroupsVocabulary\',\n+    GroupsFactory="plone.app.vocabularies:principals.GroupsFactory",\n+    GroupsVocabulary="plone.app.vocabularies:principals.GroupsVocabulary",\n )\n \n-PMF = MessageFactory(\'plone\')\n+PMF = MessageFactory("plone")\n \n \n @implementer(IVocabularyFactory)\n class RolesVocabulary(object):\n     """Vocabulary factory for roles in the portal\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n \n-      >>> name = \'plone.app.vocabularies.Roles\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n+    >>> name = \'plone.app.vocabularies.Roles\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n \n-      >>> len(util(context))\n-      0\n+    >>> len(util(context))\n+    0\n \n-      >>> tool = DummyTool(\'portal_membership\')\n-      >>> def getPortalRoles():\n-      ...    return (\'Anonymous\', \'Authenticated\', \'Manager\', \'Ploonies\')\n-      >>> tool.getPortalRoles = getPortalRoles\n-      >>> context.portal_membership = tool\n+    >>> tool = DummyTool(\'portal_membership\')\n+    >>> def getPortalRoles():\n+    ...    return (\'Anonymous\', \'Authenticated\', \'Manager\', \'Ploonies\')\n+    >>> tool.getPortalRoles = getPortalRoles\n+    >>> context.portal_membership = tool\n \n-      >>> roles = util(context)\n-      >>> roles\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+    >>> roles = util(context)\n+    >>> roles\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n \n-      >>> len(roles.by_token)\n-      4\n+    >>> len(roles.by_token)\n+    4\n \n-      >>> manager = roles.by_token[\'Manager\']\n-      >>> manager.title, manager.token, manager.value\n-      (u\'Manager\', \'Manager\', \'Manager\')\n+    >>> manager = roles.by_token[\'Manager\']\n+    >>> manager.title, manager.token, manager.value\n+    (u\'Manager\', \'Manager\', \'Manager\')\n     """\n \n     def __call__(self, context):\n         site = getSite()\n-        mtool = getToolByName(site, \'portal_membership\', None)\n+        mtool = getToolByName(site, "portal_membership", None)\n         if mtool is None:\n             return SimpleVocabulary([])\n \n         items = []\n-        request = aq_get(mtool, \'REQUEST\', None)\n+        request = aq_get(mtool, "REQUEST", None)\n         roles = mtool.getPortalRoles()\n         for role_id in roles:\n             role_title = translate(PMF(role_id), context=request)\n             items.append(SimpleTerm(role_id, role_id, role_title))\n \n-        missing_roles = [\'Anonymous\', \'Authenticated\']\n+        missing_roles = ["Anonymous", "Authenticated"]\n         for role_id in missing_roles:\n             if role_id in roles:\n                 continue\n             role_title = translate(PMF(role_id), context=request)\n             items.append(SimpleTerm(role_id, role_id, role_title))\n-        items.sort(key=attrgetter(\'title\'))\n+        items.sort(key=attrgetter("title"))\n \n         return SimpleVocabulary(items)\n \n@@ -84,13 +84,11 @@ def __call__(self, context):\n \n @implementer(IVocabularyFactory)\n class PermissionsVocabulary(object):\n-    """Vocabulary factory for permissions.\n-    """\n+    """Vocabulary factory for permissions."""\n \n     def __call__(self, context):\n         site = getSite()\n-        items = [SimpleTerm(perm, perm, perm)\n-                 for perm in site.possible_permissions()]\n+        items = [SimpleTerm(perm, perm, perm) for perm in site.possible_permissions()]\n         return SimpleVocabulary(items)\n \n \ndiff --git a/plone/app/vocabularies/skins.py b/plone/app/vocabularies/skins.py\nindex cf05c51..cafb9a9 100644\n--- a/plone/app/vocabularies/skins.py\n+++ b/plone/app/vocabularies/skins.py\n@@ -8,65 +8,60 @@\n from zope.schema.vocabulary import SimpleVocabulary\n \n \n-_ = MessageFactory(\'plone\')\n+_ = MessageFactory("plone")\n \n \n @implementer(IVocabularyFactory)\n class SkinsVocabulary(object):\n     """Vocabulary factory for skins.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n \n-      >>> name = \'plone.app.vocabularies.Skins\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n+    >>> name = \'plone.app.vocabularies.Skins\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n \n-      >>> len(util(context))\n-      0\n+    >>> len(util(context))\n+    0\n \n-      >>> tool = DummyTool(\'portal_skins\')\n-      >>> def getSkinSelections():\n-      ...     return (\'Plone Default\', \'Plone Kitty\')\n-      >>> tool.getSkinSelections = getSkinSelections\n-      >>> context.portal_skins = tool\n+    >>> tool = DummyTool(\'portal_skins\')\n+    >>> def getSkinSelections():\n+    ...     return (\'Plone Default\', \'Plone Kitty\')\n+    >>> tool.getSkinSelections = getSkinSelections\n+    >>> context.portal_skins = tool\n \n-      >>> skins = util(context)\n-      >>> skins\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+    >>> skins = util(context)\n+    >>> skins\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n \n-      >>> len(skins.by_token)\n-      2\n+    >>> len(skins.by_token)\n+    2\n \n-      >>> term = skins.by_token[\'Plone Kitty\']\n-      >>> term.title, term.token, term.value\n-      (\'Plone Kitty\', \'Plone Kitty\', \'Plone Kitty\')\n+    >>> term = skins.by_token[\'Plone Kitty\']\n+    >>> term.title, term.token, term.value\n+    (\'Plone Kitty\', \'Plone Kitty\', \'Plone Kitty\')\n \n-      Plone Default is a special case that gets a different title\n-      for clarification.\n-      >>> term = skins.by_token[\'Plone Default\']\n-      >>> term.title, term.token, term.value\n-      (u\'(Unstyled)\', \'Plone Default\', \'Plone Default\')\n+    Plone Default is a special case that gets a different title\n+    for clarification.\n+    >>> term = skins.by_token[\'Plone Default\']\n+    >>> term.title, term.token, term.value\n+    (u\'(Unstyled)\', \'Plone Default\', \'Plone Default\')\n     """\n \n     def __call__(self, context):\n         terms = []\n         site = getSite()\n-        stool = getToolByName(site, \'portal_skins\', None)\n+        stool = getToolByName(site, "portal_skins", None)\n         if stool is not None:\n             items = list(stool.getSkinSelections())\n             items.sort()\n-            if \'Plone Default\' in items:\n-                terms = [\n-                    SimpleTerm(\n-                        \'Plone Default\',\n-                        \'Plone Default\',\n-                        _(u\'(Unstyled)\')\n-                    )\n-                ]\n-                items.remove(\'Plone Default\')\n+            if "Plone Default" in items:\n+                terms = [SimpleTerm("Plone Default", "Plone Default", _("(Unstyled)"))]\n+                items.remove("Plone Default")\n             terms += [SimpleTerm(i, i, i) for i in items]\n         return SimpleVocabulary(terms)\n \n+\n SkinsVocabularyFactory = SkinsVocabulary()\ndiff --git a/plone/app/vocabularies/syndication.py b/plone/app/vocabularies/syndication.py\nindex 927b1cb..50cc16d 100644\n--- a/plone/app/vocabularies/syndication.py\n+++ b/plone/app/vocabularies/syndication.py\n@@ -13,7 +13,6 @@\n \n @implementer(IVocabularyFactory)\n class SyndicationFeedTypesVocabulary(object):\n-\n     def __call__(self, context):\n         registry = getUtility(IRegistry)\n         try:\n@@ -22,38 +21,38 @@ def __call__(self, context):\n             return SimpleVocabulary([])\n         items = []\n         for _type in settings.allowed_feed_types:\n-            split = _type.split(\'|\')\n+            split = _type.split("|")\n             if len(split) == 2:\n                 name, title = split\n                 items.append(SimpleTerm(name, name, title))\n         return SimpleVocabulary(items)\n \n+\n SyndicationFeedTypesVocabularyFactory = SyndicationFeedTypesVocabulary()\n \n \n @implementer(IVocabularyFactory)\n class SyndicatableFeedItems(object):\n-\n     def __call__(self, context):\n         site = getSite()\n-        catalog = getToolByName(site, \'portal_catalog\')\n-        site_path = \'/\'.join(site.getPhysicalPath())\n+        catalog = getToolByName(site, "portal_catalog")\n+        site_path = "/".join(site.getPhysicalPath())\n         query = {\n-            \'portal_type\': (\'Folder\', \'Collection\', \'Topic\'),\n-            \'path\': {\'query\': site_path,\n-                     \'depth\': 2}\n+            "portal_type": ("Folder", "Collection", "Topic"),\n+            "path": {"query": site_path, "depth": 2},\n         }\n         items = []\n         for brain in catalog(**query):\n             uid = brain.UID\n             title = brain.Title\n             if isinstance(title, bytes):\n-                title = title.decode(\'utf8\')\n-            title = u\'{0}({1})\'.format(\n+                title = title.decode("utf8")\n+            title = "{0}({1})".format(\n                 title,\n-                brain.getPath()[len(site_path) + 1:],\n+                brain.getPath()[len(site_path) + 1 :],\n             )\n             items.append(SimpleTerm(uid, uid, title))\n         return SimpleVocabulary(items)\n \n+\n SyndicatableFeedItemsFactory = SyndicatableFeedItems()\ndiff --git a/plone/app/vocabularies/testing.py b/plone/app/vocabularies/testing.py\nindex a482206..ed08a43 100644\n--- a/plone/app/vocabularies/testing.py\n+++ b/plone/app/vocabularies/testing.py\n@@ -10,13 +10,12 @@ class PAVocabulariesLayer(PloneSandboxLayer):\n     def setUpZope(self, app, configurationContext):\n         # Load ZCML\n         import plone.app.vocabularies\n-        self.loadZCML(\n-            package=plone.app.vocabularies,\n-            context=configurationContext\n-        )\n+\n+        self.loadZCML(package=plone.app.vocabularies, context=configurationContext)\n+\n \n PAVocabularies_FIXTURE = PAVocabulariesLayer()\n PAVocabularies_INTEGRATION_TESTING = IntegrationTesting(\n     bases=(PAVocabularies_FIXTURE,),\n-    name=\'PAVocabularies:Integration\',\n+    name="PAVocabularies:Integration",\n )\ndiff --git a/plone/app/vocabularies/tests/base.py b/plone/app/vocabularies/tests/base.py\nindex e23d080..d04494b 100644\n--- a/plone/app/vocabularies/tests/base.py\n+++ b/plone/app/vocabularies/tests/base.py\n@@ -13,25 +13,25 @@ def create_context():\n \n \n class DummyContext(object):\n-\n     def __init__(self):\n-        self.__name__ = \'dummy\'\n+        self.__name__ = "dummy"\n         self.__parent__ = None\n \n     def getSiteManager(self):\n         from zope.component import getSiteManager\n+\n         return getSiteManager()\n \n     def getPhysicalPath(self):\n-        return [\'\', self.__name__]\n+        return ["", self.__name__]\n \n     def absolute_url(self, relative=False):\n-        return \'/\'.join(self.getPhysicalPath())\n+        return "/".join(self.getPhysicalPath())\n \n \n class DummyUrlTool(object):\n \n-    name = \'portal_url\'\n+    name = "portal_url"\n \n     def __init__(self, context):\n         self.portal = context\n@@ -44,13 +44,11 @@ def getPortalObject(self):\n \n \n class DummyTool(object):\n-\n     def __init__(self, name):\n         self.name = name\n \n \n class DummyType(object):\n-\n     def __init__(self, title):\n         self.title = title\n \n@@ -59,19 +57,17 @@ def Title(self):\n \n \n class DummyTypeTool(dict):\n-\n     def __init__(self):\n-        self[\'Document\'] = DummyType(\'Page\')\n-        self[\'Event\'] = DummyType(\'Event\')\n+        self["Document"] = DummyType("Page")\n+        self["Event"] = DummyType("Event")\n \n     def listContentTypes(self):\n         return self.keys()\n \n \n class Response(dict):\n-\n     def getHeader(self, value):\n-        return \'header {0}\'.format(value)\n+        return "header {0}".format(value)\n \n \n class Request(dict):\n@@ -85,7 +81,7 @@ def __init__(self, form=None):\n \n class Brain(object):\n \n-    Title = \'BrainTitle\'\n+    Title = "BrainTitle"\n     is_folderish = True\n \n     def __init__(self, rid):\n@@ -95,7 +91,7 @@ def getPath(self):\n         return self.rid\n \n     def getURL(self):\n-        return \'proto:\' + self.rid\n+        return "proto:" + self.rid\n \n     @property\n     def UID(self):\n@@ -104,16 +100,15 @@ def UID(self):\n \n @implementer(IItem)\n class DummyCatalog(dict):\n-\n     def __init__(self, values):\n         self.indexes = {}\n         for r in values:\n             self[r] = Brain(r)\n \n     def __call__(self, **values):\n-        if \'SearchableText\' in values:\n-            st = values[\'SearchableText\']\n-            if st.startswith(\'error\'):\n+        if "SearchableText" in values:\n+            st = values["SearchableText"]\n+            if st.startswith("error"):\n                 raise ParseError\n         return self.values()\n \n@@ -129,7 +124,6 @@ def getIndex(self, name):\n \n \n class DummyContent(object):\n-\n     def __init__(self, title, subjects=[]):\n         self.title = title\n         self.subjects = subjects\n@@ -160,7 +154,7 @@ def getPhysicalPath(self):\n         return self.__parent__.getPhysicalPath() + [self.__name__]\n \n     def absolute_url(self, relative=False):\n-        return \'/\'.join(self.getPhysicalPath())\n+        return "/".join(self.getPhysicalPath())\n \n \n @implementer(INavigationRoot)\n@@ -174,10 +168,10 @@ def __init__(self, _id, title=None, parent=None):\n             self.__parent__ = parent\n \n     def getPhysicalPath(self):\n-        return [\'\', self.__parent__.__name__, self.__name__]\n+        return ["", self.__parent__.__name__, self.__name__]\n \n     def absolute_url(self, relative=False):\n-        return \'/\'.join(self.getPhysicalPath())\n+        return "/".join(self.getPhysicalPath())\n \n     @property\n     def portal_catalog(self):\ndiff --git a/plone/app/vocabularies/tests/test_imagesvocabularies.py b/plone/app/vocabularies/tests/test_imagesvocabularies.py\nindex 5c93d47..c5bcc25 100644\n--- a/plone/app/vocabularies/tests/test_imagesvocabularies.py\n+++ b/plone/app/vocabularies/tests/test_imagesvocabularies.py\n@@ -10,14 +10,13 @@ class ImagesTest(unittest.TestCase):\n     layer = PAVocabularies_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def test_images_scales_vocabulary(self):\n         images_scales_voc = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.ImagesScales\'\n+            IVocabularyFactory, "plone.app.vocabularies.ImagesScales"\n         )\n         scales_list = [item.value for item in images_scales_voc(self.portal)]\n-        self.assertTrue(\'thumb\' in scales_list)\n-        self.assertTrue(\'large\' in scales_list)\n-        self.assertTrue(\'preview\' in scales_list)\n+        self.assertTrue("thumb" in scales_list)\n+        self.assertTrue("large" in scales_list)\n+        self.assertTrue("preview" in scales_list)\ndiff --git a/plone/app/vocabularies/tests/test_principals.py b/plone/app/vocabularies/tests/test_principals.py\nindex 134a629..cbe9b6c 100644\n--- a/plone/app/vocabularies/tests/test_principals.py\n+++ b/plone/app/vocabularies/tests/test_principals.py\n@@ -9,110 +9,108 @@ class PrincipalsTest(unittest.TestCase):\n     layer = PAVocabularies_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def _make_user(self, userid, fullname):\n-        user = self.portal[\'acl_users\']._doAddUser(\n-            userid, \'secret\', [\'Member\'], []\n-        )\n+        user = self.portal["acl_users"]._doAddUser(userid, "secret", ["Member"], [])\n         user.setProperties(fullname=fullname)\n \n     def _make_group(self, groupid, title):\n-        self.portal[\'acl_users\']._doAddGroup(groupid, [], title=title)\n+        self.portal["acl_users"]._doAddGroup(groupid, [], title=title)\n \n     def test_empty_principals_vocabulary(self):\n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary([])\n-        vocab.principal_source = \'user\'\n+        vocab.principal_source = "user"\n \n         # basic data\n-        self.assertEqual(vocab.principal_source, \'user\')\n-        self.assertEqual(vocab._acl_users, self.portal[\'acl_users\'])\n+        self.assertEqual(vocab.principal_source, "user")\n+        self.assertEqual(vocab._acl_users, self.portal["acl_users"])\n \n     def test_pas_connectivity_user(self):\n-        self._make_user(\'user1\', \'User One\')\n+        self._make_user("user1", "User One")\n \n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary([])\n-        vocab.principal_source = \'user\'\n+        vocab.principal_source = "user"\n \n         # test 1\n-        vuser = vocab._get_principal_from_source(\'user1\')\n-        self.assertEqual(vuser.getId(), \'user1\')\n+        vuser = vocab._get_principal_from_source("user1")\n+        self.assertEqual(vuser.getId(), "user1")\n \n         # test 2\n-        term = vocab.getTerm(\'user1\')\n-        self.assertEqual(term.value, \'user1\')\n-        self.assertEqual(term.token, \'user1\')\n-        self.assertEqual(term.title, \'User One\')\n+        term = vocab.getTerm("user1")\n+        self.assertEqual(term.value, "user1")\n+        self.assertEqual(term.token, "user1")\n+        self.assertEqual(term.title, "User One")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'user:non-existing\')\n+            term = vocab.getTerm("user:non-existing")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'non-existing\')\n+            term = vocab.getTerm("non-existing")\n \n     def test_pas_connectivity_group(self):\n-        self._make_group(\'group1\', \'Group One\')\n+        self._make_group("group1", "Group One")\n \n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary([])\n-        vocab.principal_source = \'group\'\n+        vocab.principal_source = "group"\n \n         # test 1\n-        vgroup = vocab._get_principal_from_source(\'group1\')\n-        self.assertEqual(vgroup.getId(), \'group1\')\n+        vgroup = vocab._get_principal_from_source("group1")\n+        self.assertEqual(vgroup.getId(), "group1")\n \n         # test 2\n-        term = vocab.getTerm(\'group1\')\n-        self.assertEqual(term.value, \'group1\')\n-        self.assertEqual(term.token, \'group1\')\n-        self.assertEqual(term.title, \'Group One\')\n+        term = vocab.getTerm("group1")\n+        self.assertEqual(term.value, "group1")\n+        self.assertEqual(term.token, "group1")\n+        self.assertEqual(term.title, "Group One")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'group:non-existing\')\n+            term = vocab.getTerm("group:non-existing")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'non-existing\')\n+            term = vocab.getTerm("non-existing")\n \n     def test_pas_connectivity_principal(self):\n-        self._make_user(\'user1\', \'User One\')\n-        self._make_group(\'group1\', \'Group One\')\n+        self._make_user("user1", "User One")\n+        self._make_group("group1", "Group One")\n \n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary([])\n-        vocab.principal_source = \'principal\'\n+        vocab.principal_source = "principal"\n \n         # test 1\n-        vgroup = vocab._get_principal_from_source(\'user:user1\')\n-        self.assertEqual(vgroup.getId(), \'user1\')\n-        vgroup = vocab._get_principal_from_source(\'group:group1\')\n-        self.assertEqual(vgroup.getId(), \'group1\')\n+        vgroup = vocab._get_principal_from_source("user:user1")\n+        self.assertEqual(vgroup.getId(), "user1")\n+        vgroup = vocab._get_principal_from_source("group:group1")\n+        self.assertEqual(vgroup.getId(), "group1")\n \n         # test 2\n-        term = vocab.getTerm(\'user:user1\')\n-        self.assertEqual(term.value, \'user:user1\')\n-        self.assertEqual(term.token, \'user__user1\')\n-        self.assertEqual(term.title, \'User One\')\n-        term = vocab.getTerm(\'group:group1\')\n-        self.assertEqual(term.value, \'group:group1\')\n-        self.assertEqual(term.token, \'group__group1\')\n-        self.assertEqual(term.title, \'Group One\')\n+        term = vocab.getTerm("user:user1")\n+        self.assertEqual(term.value, "user:user1")\n+        self.assertEqual(term.token, "user__user1")\n+        self.assertEqual(term.title, "User One")\n+        term = vocab.getTerm("group:group1")\n+        self.assertEqual(term.value, "group:group1")\n+        self.assertEqual(term.token, "group__group1")\n+        self.assertEqual(term.title, "Group One")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'user:non-existing\')\n+            term = vocab.getTerm("user:non-existing")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'group:non-existing\')\n+            term = vocab.getTerm("group:non-existing")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'non-existing\')\n+            term = vocab.getTerm("non-existing")\n \n     def test_populated_user(self):\n         from zope.schema.vocabulary import SimpleTerm\n \n         terms = [\n             SimpleTerm(\n-                \'user_{0}\'.format(idx),\n-                \'user{0}\'.format(idx),\n-                \'User {0}\'.format(idx),\n+                "user_{0}".format(idx),\n+                "user{0}".format(idx),\n+                "User {0}".format(idx),\n             )\n             for idx in range(0, 10)\n         ]\n@@ -120,33 +118,33 @@ def test_populated_user(self):\n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary(terms)\n-        vocab.principal_source = \'user\'\n+        vocab.principal_source = "user"\n \n-        self.assertEqual(vocab.getTerm(\'user_3\').value, \'user_3\')\n-        self.assertEqual(vocab.getTerm(\'user_3\').token, \'user3\')\n-        self.assertEqual(vocab.getTerm(\'user_3\').title, \'User 3\')\n+        self.assertEqual(vocab.getTerm("user_3").value, "user_3")\n+        self.assertEqual(vocab.getTerm("user_3").token, "user3")\n+        self.assertEqual(vocab.getTerm("user_3").title, "User 3")\n \n-        self.assertEqual(vocab.getTermByToken(\'user3\').value, \'user_3\')\n-        self.assertEqual(vocab.getTermByToken(\'user3\').token, \'user3\')\n-        self.assertEqual(vocab.getTermByToken(\'user3\').title, \'User 3\')\n+        self.assertEqual(vocab.getTermByToken("user3").value, "user_3")\n+        self.assertEqual(vocab.getTermByToken("user3").token, "user3")\n+        self.assertEqual(vocab.getTermByToken("user3").title, "User 3")\n \n-        self.assertEqual(vocab[6].value, \'user_6\')\n+        self.assertEqual(vocab[6].value, "user_6")\n         self.assertEqual(\n-            [\'user_2\', \'user_3\', \'user_4\', \'user_5\'],\n+            ["user_2", "user_3", "user_4", "user_5"],\n             [term.value for term in vocab[2:6]],\n         )\n \n-        self.assertTrue(\'user_2\' in vocab)\n-        self.assertFalse(\'non-existing\' in vocab)\n+        self.assertTrue("user_2" in vocab)\n+        self.assertFalse("non-existing" in vocab)\n \n     def test_populated_group(self):\n         from zope.schema.vocabulary import SimpleTerm\n \n         terms = [\n             SimpleTerm(\n-                \'group_{0}\'.format(idx),\n-                \'group{0}\'.format(idx),\n-                \'Group {0}\'.format(idx),\n+                "group_{0}".format(idx),\n+                "group{0}".format(idx),\n+                "Group {0}".format(idx),\n             )\n             for idx in range(0, 10)\n         ]\n@@ -154,41 +152,41 @@ def test_populated_group(self):\n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary(terms)\n-        vocab.principal_source = \'group\'\n+        vocab.principal_source = "group"\n \n-        self.assertEqual(vocab.getTerm(\'group_3\').value, \'group_3\')\n-        self.assertEqual(vocab.getTerm(\'group_3\').token, \'group3\')\n-        self.assertEqual(vocab.getTerm(\'group_3\').title, \'Group 3\')\n+        self.assertEqual(vocab.getTerm("group_3").value, "group_3")\n+        self.assertEqual(vocab.getTerm("group_3").token, "group3")\n+        self.assertEqual(vocab.getTerm("group_3").title, "Group 3")\n \n-        self.assertEqual(vocab.getTermByToken(\'group3\').value, \'group_3\')\n-        self.assertEqual(vocab.getTermByToken(\'group3\').token, \'group3\')\n-        self.assertEqual(vocab.getTermByToken(\'group3\').title, \'Group 3\')\n+        self.assertEqual(vocab.getTermByToken("group3").value, "group_3")\n+        self.assertEqual(vocab.getTermByToken("group3").token, "group3")\n+        self.assertEqual(vocab.getTermByToken("group3").title, "Group 3")\n \n-        self.assertEqual(vocab[6].value, \'group_6\')\n+        self.assertEqual(vocab[6].value, "group_6")\n         self.assertEqual(\n-            [\'group_2\', \'group_3\', \'group_4\', \'group_5\'],\n+            ["group_2", "group_3", "group_4", "group_5"],\n             [term.value for term in vocab[2:6]],\n         )\n \n-        self.assertTrue(\'group_2\' in vocab)\n-        self.assertFalse(\'non-existing\' in vocab)\n+        self.assertTrue("group_2" in vocab)\n+        self.assertFalse("non-existing" in vocab)\n \n     def test_populated_principals(self):\n         from zope.schema.vocabulary import SimpleTerm\n \n         terms = [\n             SimpleTerm(\n-                \'user:user_{0}\'.format(idx),\n-                \'user__user{0}\'.format(idx),\n-                \'User {0}\'.format(idx),\n+                "user:user_{0}".format(idx),\n+                "user__user{0}".format(idx),\n+                "User {0}".format(idx),\n             )\n             for idx in range(0, 10)\n         ]\n         terms += [\n             SimpleTerm(\n-                \'group:group_{0}\'.format(idx),\n-                \'group__group{0}\'.format(idx),\n-                \'Group {0}\'.format(idx),\n+                "group:group_{0}".format(idx),\n+                "group__group{0}".format(idx),\n+                "Group {0}".format(idx),\n             )\n             for idx in range(0, 10)\n         ]\n@@ -196,252 +194,248 @@ def test_populated_principals(self):\n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary(terms)\n-        vocab.principal_source = \'principal\'\n+        vocab.principal_source = "principal"\n \n         # users\n-        self.assertEqual(vocab.getTerm(\'user:user_4\').value, \'user:user_4\')\n-        self.assertEqual(vocab.getTerm(\'user:user_3\').token, \'user__user3\')\n-        self.assertEqual(vocab.getTerm(\'user:user_6\').title, \'User 6\')\n+        self.assertEqual(vocab.getTerm("user:user_4").value, "user:user_4")\n+        self.assertEqual(vocab.getTerm("user:user_3").token, "user__user3")\n+        self.assertEqual(vocab.getTerm("user:user_6").title, "User 6")\n \n-        self.assertEqual(\n-            vocab.getTermByToken(\'user__user4\').value, \'user:user_4\'\n-        )\n-        self.assertEqual(\n-            vocab.getTermByToken(\'user__user3\').token, \'user__user3\'\n-        )\n-        self.assertEqual(vocab.getTermByToken(\'user__user6\').title, \'User 6\')\n+        self.assertEqual(vocab.getTermByToken("user__user4").value, "user:user_4")\n+        self.assertEqual(vocab.getTermByToken("user__user3").token, "user__user3")\n+        self.assertEqual(vocab.getTermByToken("user__user6").title, "User 6")\n \n-        self.assertTrue(\'user:user_2\' in vocab)\n-        self.assertFalse(\'non-existing\' in vocab)\n+        self.assertTrue("user:user_2" in vocab)\n+        self.assertFalse("non-existing" in vocab)\n \n         # groups\n-        self.assertEqual(vocab.getTerm(\'group:group_3\').value, \'group:group_3\')\n-        self.assertEqual(vocab.getTerm(\'group:group_3\').token, \'group__group3\')\n-        self.assertEqual(vocab.getTerm(\'group:group_3\').title, \'Group 3\')\n+        self.assertEqual(vocab.getTerm("group:group_3").value, "group:group_3")\n+        self.assertEqual(vocab.getTerm("group:group_3").token, "group__group3")\n+        self.assertEqual(vocab.getTerm("group:group_3").title, "Group 3")\n \n-        self.assertEqual(\n-            vocab.getTermByToken(\'group__group3\').value, \'group:group_3\'\n-        )\n-        self.assertEqual(\n-            vocab.getTermByToken(\'group__group3\').token, \'group__group3\'\n-        )\n-        self.assertEqual(\n-            vocab.getTermByToken(\'group__group3\').title, \'Group 3\'\n-        )\n+        self.assertEqual(vocab.getTermByToken("group__group3").value, "group:group_3")\n+        self.assertEqual(vocab.getTermByToken("group__group3").token, "group__group3")\n+        self.assertEqual(vocab.getTermByToken("group__group3").title, "Group 3")\n \n         # getitem/slice\n-        self.assertEqual(vocab[6].value, \'user:user_6\')\n+        self.assertEqual(vocab[6].value, "user:user_6")\n         self.assertEqual(\n-            [\'group:group_7\', \'group:group_8\', \'group:group_9\'],\n+            ["group:group_7", "group:group_8", "group:group_9"],\n             [term.value for term in vocab[17:]],\n         )\n         self.assertEqual(\n-            [\'user:user_8\', \'user:user_9\', \'group:group_0\'],\n+            ["user:user_8", "user:user_9", "group:group_0"],\n             [term.value for term in vocab[8:11]],\n         )\n \n         # contains works too (by token)\n-        self.assertTrue(\'group:group_2\' in vocab)\n-        self.assertFalse(\'non-existing\' in vocab)\n+        self.assertTrue("group:group_2" in vocab)\n+        self.assertFalse("non-existing" in vocab)\n \n     def test_factory_user_blank(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            userid = \'us\xc3\xa9r{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' \xc3\x9cser\'\n+            userid = "us\xc3\xa9r{0}".format(idx)\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " \xc3\x9cser"\n             self._make_user(userid, fullname)\n \n         from plone.app.vocabularies.principals import UsersFactory\n \n         factory = UsersFactory()\n         vocab = factory(self.portal)\n-        self.assertEqual(vocab.getTerm(\'us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTerm(\'us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n+        self.assertEqual(vocab.getTerm("us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTerm("us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n \n     def test_factory_user_query(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            userid = \'us\xc3\xa9r{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' \xc3\x9cser\'\n+            userid = "us\xc3\xa9r{0}".format(idx)\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " \xc3\x9cser"\n             self._make_user(userid, fullname)\n \n         from plone.app.vocabularies.principals import UsersFactory\n \n         factory = UsersFactory()\n-        vocab = factory(self.portal, query=\'Cde\')\n+        vocab = factory(self.portal, query="Cde")\n \n         # reduced by query\n-        self.assertEqual([term.value for term in vocab], [\'us\xc3\xa9r2\'])\n+        self.assertEqual([term.value for term in vocab], ["us\xc3\xa9r2"])\n \n         # getTerm[ByToken] still works for all\n-        self.assertEqual(vocab.getTerm(\'us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTerm(\'us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n+        self.assertEqual(vocab.getTerm("us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTerm("us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n \n         # contains works (by value)\n-        self.assertTrue(\'us\xc3\xa9r0\' in vocab)\n-        self.assertTrue(\'us\xc3\xa9r2\' in vocab)\n+        self.assertTrue("us\xc3\xa9r0" in vocab)\n+        self.assertTrue("us\xc3\xa9r2" in vocab)\n \n     def test_factory_group_blank(self):\n         for idx in range(0, 10):\n             # creates group0: \'Abc Group\'; group1, \'Bcd Group\', ...\n-            groupid = \'gro\xc3\xbcp{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' Gr\xc3\xb6\xc3\xbcp\'\n+            groupid = "gro\xc3\xbcp{0}".format(idx)\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " Gr\xc3\xb6\xc3\xbcp"\n             self._make_group(groupid, fullname)\n \n         from plone.app.vocabularies.principals import GroupsFactory\n \n         factory = GroupsFactory()\n         vocab = factory(self.portal)\n-        self.assertEqual(vocab.getTerm(\'gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTerm(\'gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n+        self.assertEqual(vocab.getTerm("gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTerm("gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n \n     def test_factory_group_query(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            groupid = \'gro\xc3\xbcp{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' Gr\xc3\xb6\xc3\xbcp\'\n+            groupid = "gro\xc3\xbcp{0}".format(idx)\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " Gr\xc3\xb6\xc3\xbcp"\n             self._make_group(groupid, fullname)\n \n         from plone.app.vocabularies.principals import GroupsFactory\n \n         factory = GroupsFactory()\n-        vocab = factory(self.portal, query=\'Cde\')\n+        vocab = factory(self.portal, query="Cde")\n \n         # reduced by query\n-        self.assertEqual([term.value for term in vocab], [\'gro\xc3\xbcp2\'])\n+        self.assertEqual([term.value for term in vocab], ["gro\xc3\xbcp2"])\n \n         # getTerm[ByToken] still works for all\n-        self.assertEqual(vocab.getTerm(\'gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTerm(\'gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n+        self.assertEqual(vocab.getTerm("gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTerm("gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n \n         # contains works too (by token)\n-        self.assertTrue(\'gro\xc3\xbcp0\' in vocab)\n-        self.assertTrue(\'gro\xc3\xbcp2\' in vocab)\n+        self.assertTrue("gro\xc3\xbcp0" in vocab)\n+        self.assertTrue("gro\xc3\xbcp2" in vocab)\n \n     def test_factory_principal_blank(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            userid = \'us\xc3\xa9r{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' \xc3\x9cser\'\n+            userid = "us\xc3\xa9r{0}".format(idx)\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " \xc3\x9cser"\n             self._make_user(userid, fullname)\n         for idx in range(0, 10):\n             # creates group0: \'Abc Group\'; group1, \'Bcd Group\', ...\n-            groupid = \'gro\xc3\xbcp{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' Gr\xc3\xb6\xc3\xbcp\'\n+            groupid = "gro\xc3\xbcp{0}".format(idx)\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " Gr\xc3\xb6\xc3\xbcp"\n             self._make_group(groupid, fullname)\n \n         from plone.app.vocabularies.principals import PrincipalsFactory\n \n         factory = PrincipalsFactory()\n         vocab = factory(self.portal)\n-        self.assertEqual(vocab.getTerm(\'user:us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTerm(\'user:us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n-        self.assertEqual(vocab.getTerm(\'group:gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTerm(\'group:gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'user__us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'user__us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'group__gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'group__gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n+        self.assertEqual(vocab.getTerm("user:us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTerm("user:us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n+        self.assertEqual(vocab.getTerm("group:gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTerm("group:gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("user__us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("user__us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("group__gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("group__gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n \n     def test_factory_principal_query(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            userid = \'us\xc3\xa9r{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' \xc3\x9cser\'\n+            userid = "us\xc3\xa9r{0}".format(idx)\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " \xc3\x9cser"\n             self._make_user(userid, fullname)\n         for idx in range(0, 10):\n             # creates group0: \'Abc Group\'; group1, \'Bcd Group\', ...\n-            groupid = \'gro\xc3\xbcp{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' Gr\xc3\xb6\xc3\xbcp\'\n+            groupid = "gro\xc3\xbcp{0}".format(idx)\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " Gr\xc3\xb6\xc3\xbcp"\n             self._make_group(groupid, fullname)\n \n         from plone.app.vocabularies.principals import PrincipalsFactory\n \n         factory = PrincipalsFactory()\n-        vocab = factory(self.portal, query=\'Cde\')\n+        vocab = factory(self.portal, query="Cde")\n \n         # reduced by query\n-        self.assertEqual(\n-            [term.value for term in vocab], [\'group:gro\xc3\xbcp2\', \'user:us\xc3\xa9r2\']\n-        )\n+        self.assertEqual([term.value for term in vocab], ["group:gro\xc3\xbcp2", "user:us\xc3\xa9r2"])\n \n         # getTerm still works for all\n-        self.assertEqual(vocab.getTerm(\'user:us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTerm(\'user:us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n-        self.assertEqual(vocab.getTerm(\'group:gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTerm(\'group:gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'user__us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'user__us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'group__gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'group__gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n+        self.assertEqual(vocab.getTerm("user:us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTerm("user:us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n+        self.assertEqual(vocab.getTerm("group:gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTerm("group:gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("user__us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("user__us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("group__gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("group__gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n \n         # contains works (by token)\n-        self.assertTrue(\'user:us\xc3\xa9r0\' in vocab)\n-        self.assertTrue(\'user:us\xc3\xa9r2\' in vocab)\n-        self.assertTrue(\'group:gro\xc3\xbcp0\' in vocab)\n-        self.assertTrue(\'group:gro\xc3\xbcp2\' in vocab)\n+        self.assertTrue("user:us\xc3\xa9r0" in vocab)\n+        self.assertTrue("user:us\xc3\xa9r2" in vocab)\n+        self.assertTrue("group:gro\xc3\xbcp0" in vocab)\n+        self.assertTrue("group:gro\xc3\xbcp2" in vocab)\n \n     def test_factory_user_duplicate(self):\n-        """ For an LDAP user that has logged in at least once, we get one\n+        """For an LDAP user that has logged in at least once, we get one\n         result each from pasldap and from mutable_properties. This should be\n         treated as one user.\n         """\n         with mock.patch(\n-            \'plone.app.vocabularies.principals._get_acl_users\',\n+            "plone.app.vocabularies.principals._get_acl_users",\n         ) as fake_get_acl_users:\n             fake_get_acl_users.return_value.searchUsers.return_value = (\n-                    {\'id\': \'ldapus\xc3\xa9r\',\n-                     \'login\': \'ldapus\xc3\xa9r\',\n-                     \'pluginid\': \'pasldap\',\n-                     \'userid\': \'ldapus\xc3\xa9r\',\n-                     \'principal_type\': \'user\',\n-                     \'title\': \'LDAP Us\xc3\xa9r\'},\n-                    {\'id\': \'ldapus\xc3\xa9r\',\n-                     \'login\': \'ldapus\xc3\xa9r\',\n-                     \'title\': \'\',\n-                     \'description\': \'\',\n-                     \'email\': \'\',\n-                     \'pluginid\': \'mutable_properties\',\n-                     \'userid\': \'ldapus\xc3\xa9r\',\n-                     \'principal_type\': \'user\'},\n+                {\n+                    "id": "ldapus\xc3\xa9r",\n+                    "login": "ldapus\xc3\xa9r",\n+                    "pluginid": "pasldap",\n+                    "userid": "ldapus\xc3\xa9r",\n+                    "principal_type": "user",\n+                    "title": "LDAP Us\xc3\xa9r",\n+                },\n+                {\n+                    "id": "ldapus\xc3\xa9r",\n+                    "login": "ldapus\xc3\xa9r",\n+                    "title": "",\n+                    "description": "",\n+                    "email": "",\n+                    "pluginid": "mutable_properties",\n+                    "userid": "ldapus\xc3\xa9r",\n+                    "principal_type": "user",\n+                },\n             )\n             from plone.app.vocabularies.principals import UsersFactory\n \n             factory = UsersFactory()\n             vocab = factory(self.portal)\n-            self.assertEqual(vocab.getTerm(\'ldapus\xc3\xa9r\').title, \'LDAP Us\xc3\xa9r\')\n+            self.assertEqual(vocab.getTerm("ldapus\xc3\xa9r").title, "LDAP Us\xc3\xa9r")\n \n     def test_factory_user_conflict(self):\n-        """ In a user vocabulary, multiple results for the same principal ID\n+        """In a user vocabulary, multiple results for the same principal ID\n         but with different principal_type values indicate some problem. Raise\n         an error.\n         """\n         with mock.patch(\n-            \'plone.app.vocabularies.principals._get_acl_users\',\n+            "plone.app.vocabularies.principals._get_acl_users",\n         ) as fake_get_acl_users:\n             fake_get_acl_users.return_value.searchUsers.return_value = (\n-                    {\'id\': \'ldapus\xc3\xa9r\',\n-                     \'login\': \'ldapus\xc3\xa9r\',\n-                     \'pluginid\': \'pasldap\',\n-                     \'userid\': \'ldapus\xc3\xa9r\',\n-                     \'principal_type\': \'user\',\n-                     \'title\': \'LDAP Us\xc3\xa9r\'},\n-                    {\'id\': \'ldapus\xc3\xa9r\',\n-                     \'login\': \'ldapus\xc3\xa9r\',\n-                     \'title\': \'\',\n-                     \'description\': \'\',\n-                     \'email\': \'\',\n-                     \'pluginid\': \'mutable_properties\',\n-                     \'userid\': \'ldapus\xc3\xa9r\',\n-                     \'principal_type\': \'unknown\'},\n+                {\n+                    "id": "ldapus\xc3\xa9r",\n+                    "login": "ldapus\xc3\xa9r",\n+                    "pluginid": "pasldap",\n+                    "userid": "ldapus\xc3\xa9r",\n+                    "principal_type": "user",\n+                    "title": "LDAP Us\xc3\xa9r",\n+                },\n+                {\n+                    "id": "ldapus\xc3\xa9r",\n+                    "login": "ldapus\xc3\xa9r",\n+                    "title": "",\n+                    "description": "",\n+                    "email": "",\n+                    "pluginid": "mutable_properties",\n+                    "userid": "ldapus\xc3\xa9r",\n+                    "principal_type": "unknown",\n+                },\n             )\n             from plone.app.vocabularies.principals import UsersFactory\n \n@@ -453,38 +447,42 @@ def test_factory_user_conflict(self):\n             )\n \n     def test_factory_principal_conflict(self):\n-        """ In a principal vocabulary, multiple results for the same principal\n+        """In a principal vocabulary, multiple results for the same principal\n         ID but with different principal_type values can be handled because they\n         are prefixed.\n         """\n         with mock.patch(\n-            \'plone.app.vocabularies.principals._get_acl_users\',\n+            "plone.app.vocabularies.principals._get_acl_users",\n         ) as fake_get_acl_users:\n             fake_get_acl_users.return_value.searchUsers.return_value = (\n-                    {\'id\': \'duplicat\xc3\xa9\',\n-                     \'login\': \'duplicat\xc3\xa9\',\n-                     \'pluginid\': \'pasldap\',\n-                     \'userid\': \'duplicat\xc3\xa9\',\n-                     \'principal_type\': \'user\',\n-                     \'title\': \'Duplicat\xc3\xa9 User\'},\n-                    {\'id\': \'duplicat\xc3\xa9\',\n-                     \'login\': \'duplicat\xc3\xa9\',\n-                     \'title\': \'Duplicat\xc3\xa9 Group\',\n-                     \'description\': \'\',\n-                     \'email\': \'\',\n-                     \'pluginid\': \'source_groups\',\n-                     \'userid\': \'duplicat\xc3\xa9\',\n-                     \'principal_type\': \'group\'},\n+                {\n+                    "id": "duplicat\xc3\xa9",\n+                    "login": "duplicat\xc3\xa9",\n+                    "pluginid": "pasldap",\n+                    "userid": "duplicat\xc3\xa9",\n+                    "principal_type": "user",\n+                    "title": "Duplicat\xc3\xa9 User",\n+                },\n+                {\n+                    "id": "duplicat\xc3\xa9",\n+                    "login": "duplicat\xc3\xa9",\n+                    "title": "Duplicat\xc3\xa9 Group",\n+                    "description": "",\n+                    "email": "",\n+                    "pluginid": "source_groups",\n+                    "userid": "duplicat\xc3\xa9",\n+                    "principal_type": "group",\n+                },\n             )\n             from plone.app.vocabularies.principals import PrincipalsFactory\n \n             factory = PrincipalsFactory()\n             vocab = factory(self.portal)\n             self.assertEqual(\n-                vocab.getTerm(\'user:duplicat\xc3\xa9\').title,\n-                \'Duplicat\xc3\xa9 User\',\n+                vocab.getTerm("user:duplicat\xc3\xa9").title,\n+                "Duplicat\xc3\xa9 User",\n             )\n             self.assertEqual(\n-                vocab.getTerm(\'group:duplicat\xc3\xa9\').title,\n-                \'Duplicat\xc3\xa9 Group\',\n+                vocab.getTerm("group:duplicat\xc3\xa9").title,\n+                "Duplicat\xc3\xa9 Group",\n             )\ndiff --git a/plone/app/vocabularies/tests/test_subjects_under_context.py b/plone/app/vocabularies/tests/test_subjects_under_context.py\nindex eaa20f4..8ceb284 100644\n--- a/plone/app/vocabularies/tests/test_subjects_under_context.py\n+++ b/plone/app/vocabularies/tests/test_subjects_under_context.py\n@@ -13,11 +13,15 @@ class TestKeywordsUnderContext(unittest.TestCase):\n \n     def setUp(self):\n         """Custom setup for tests."""\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n         from plone.app.vocabularies.tests import base\n+\n         context = base.create_context()\n-        rids = (\'1\', \'2\',)\n+        rids = (\n+            "1",\n+            "2",\n+        )\n         tool = base.DummyCatalog(rids)\n         context.portal_catalog = tool\n         context.portal_url = base.DummyUrlTool(context)\n@@ -25,53 +29,55 @@ def setUp(self):\n         from Products.PluginIndexes.KeywordIndex.KeywordIndex import (  # noqa\n             KeywordIndex,\n         )\n-        kwindex = KeywordIndex(\'Subject\')\n-        tool.indexes[\'Subject\'] = kwindex\n+\n+        kwindex = KeywordIndex("Subject")\n+        tool.indexes["Subject"] = kwindex\n         from Products.ExtendedPathIndex.ExtendedPathIndex import (  # noqa\n             ExtendedPathIndex,\n         )\n-        pathindex = ExtendedPathIndex(\'path\')\n-        tool.indexes[\'path\'] = pathindex\n \n-        self.subjects_1 = [\'Berlin\', \'Wien\', \'Paris\', \'Barcelona\']\n-        self.subjects_2 = [\'Montreal\', \'Washington\', \'Brasilia\']\n+        pathindex = ExtendedPathIndex("path")\n+        tool.indexes["path"] = pathindex\n+\n+        self.subjects_1 = ["Berlin", "Wien", "Paris", "Barcelona"]\n+        self.subjects_2 = ["Montreal", "Washington", "Brasilia"]\n \n-        self.navroot1 = base.DummyContentWithParent(\'nr1\', parent=context)\n+        self.navroot1 = base.DummyContentWithParent("nr1", parent=context)\n         alsoProvides(self.navroot1, INavigationRoot)\n-        self.navroot2 = base.DummyContentWithParent(\'nr2\', parent=context)\n+        self.navroot2 = base.DummyContentWithParent("nr2", parent=context)\n         alsoProvides(self.navroot2, INavigationRoot)\n \n         self.doc1 = base.DummyContentWithParent(\n-            \'doc1\',\n-            subjects=self.subjects_1,\n-            parent=self.navroot1\n+            "doc1", subjects=self.subjects_1, parent=self.navroot1\n         )\n-        kwindex._index_object(1, self.doc1, attr=\'Subject\')\n+        kwindex._index_object(1, self.doc1, attr="Subject")\n         pathindex.index_object(1, self.doc1)\n \n         self.doc2 = base.DummyContentWithParent(\n-            \'doc2\',\n-            subjects=self.subjects_2,\n-            parent=self.navroot2\n+            "doc2", subjects=self.subjects_2, parent=self.navroot2\n         )\n-        kwindex._index_object(2, self.doc2, attr=\'Subject\')\n+        kwindex._index_object(2, self.doc2, attr="Subject")\n         pathindex.index_object(2, self.doc2)\n \n         from plone.app.vocabularies.catalog import KeywordsVocabulary\n+\n         self.vocab = KeywordsVocabulary()\n \n         # mock our registry\n         from plone.registry import Registry\n         from plone.registry.interfaces import IRegistry\n         from zope.component import getSiteManager\n+\n         sm = getSiteManager()\n         from Products.CMFCore.interfaces import ICatalogTool\n+\n         sm.registerUtility(tool, ICatalogTool)\n         registry = Registry()\n         sm.registerUtility(registry, IRegistry)\n         from Products.CMFCore.interfaces import IURLTool\n+\n         sm.registerUtility(context.portal_url, IURLTool)\n-        registry_patcher = mock.patch(\'plone.registry.registry.Registry.get\')\n+        registry_patcher = mock.patch("plone.registry.registry.Registry.get")\n         self.addCleanup(registry_patcher.stop)\n         self.registry_mock = registry_patcher.start()\n \ndiff --git a/plone/app/vocabularies/tests/test_timezonevocabularies.py b/plone/app/vocabularies/tests/test_timezonevocabularies.py\nindex 7b924a4..93bb791 100644\n--- a/plone/app/vocabularies/tests/test_timezonevocabularies.py\n+++ b/plone/app/vocabularies/tests/test_timezonevocabularies.py\n@@ -11,30 +11,24 @@ class TimezoneTest(unittest.TestCase):\n     layer = PAVocabularies_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def test_timezone_vocabulary(self):\n-        tzvocab = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.Timezones\'\n-        )\n+        tzvocab = getUtility(IVocabularyFactory, "plone.app.vocabularies.Timezones")\n         tz_list = [item.value for item in tzvocab(self.portal)]\n-        self.assertTrue(\'Africa/Abidjan\' in tz_list)\n-        self.assertTrue(\'Europe/London\' in tz_list)\n+        self.assertTrue("Africa/Abidjan" in tz_list)\n+        self.assertTrue("Europe/London" in tz_list)\n \n     def test_timezone_vocabulary_query(self):\n-        tzvocab = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.Timezones\'\n-        )\n-        tz_list = [item.value for item in tzvocab(self.portal, query=\'vienna\')]\n-        self.assertTrue(\'Europe/Vienna\' in tz_list)\n+        tzvocab = getUtility(IVocabularyFactory, "plone.app.vocabularies.Timezones")\n+        tz_list = [item.value for item in tzvocab(self.portal, query="vienna")]\n+        self.assertTrue("Europe/Vienna" in tz_list)\n         self.assertTrue(len(tz_list) == 1)\n \n     def test_available_timezones_vocabulary(self):\n         reg = getUtility(IRegistry)\n         # check if "plone.available_timezones" available_timezones\' in registry\n-        reg_key = \'plone.available_timezones\'\n+        reg_key = "plone.available_timezones"\n         if reg_key not in reg:\n             # ignore for Plone 4.3 w/o plone.app.event available\n             return\n@@ -42,12 +36,10 @@ def test_available_timezones_vocabulary(self):\n         # this works only for plone.app.event 2.0\n         # initially, all common zones are available in AvailableTimezones\n         common_zones_vocab = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.CommonTimezones\'\n+            IVocabularyFactory, "plone.app.vocabularies.CommonTimezones"\n         )(self.portal)\n         avail_zones_vocab = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.AvailableTimezones\'\n+            IVocabularyFactory, "plone.app.vocabularies.AvailableTimezones"\n         )(self.portal)\n         self.assertTrue(len(common_zones_vocab) > len(avail_zones_vocab) > 0)\n \n@@ -59,8 +51,7 @@ def test_available_timezones_vocabulary(self):\n         # those changes\n         del avail_zones_vocab\n         avail_zones_vocab = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.AvailableTimezones\'\n+            IVocabularyFactory, "plone.app.vocabularies.AvailableTimezones"\n         )(self.portal)\n \n         # the length of the avail_zones_vocab is now 10\n@@ -70,8 +61,7 @@ def test_available_timezones_vocabulary(self):\n         # Test querying AvailableTimezones vocabulary\n         reg[reg_key] = common_zones\n         filtered_zones_vocab = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.AvailableTimezones\'\n-        )(self.portal, query=\'vienna\')\n+            IVocabularyFactory, "plone.app.vocabularies.AvailableTimezones"\n+        )(self.portal, query="vienna")\n         # filtered all items down to one\n         self.assertEqual(len(filtered_zones_vocab), 1)\ndiff --git a/plone/app/vocabularies/tests/test_vocabularies.py b/plone/app/vocabularies/tests/test_vocabularies.py\nindex c6a6740..5a6d0d7 100644\n--- a/plone/app/vocabularies/tests/test_vocabularies.py\n+++ b/plone/app/vocabularies/tests/test_vocabularies.py\n@@ -15,8 +15,9 @@\n def vocabSetUp(self):\n     setUp()\n     import plone.app.vocabularies\n-    XMLConfig(\'meta.zcml\', zope.component)()\n-    XMLConfig(\'configure.zcml\', plone.app.vocabularies)()\n+\n+    XMLConfig("meta.zcml", zope.component)()\n+    XMLConfig("configure.zcml", plone.app.vocabularies)()\n     hooks.setHooks()\n \n \n@@ -27,7 +28,6 @@ def vocabTearDown(self):\n \n \n class Py23DocChecker(doctest.OutputChecker):\n-\n     def check_output(self, want, got, optionflags):\n         if not six.PY2:\n             want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n@@ -39,74 +39,72 @@ def test_suite():\n     optionflags = doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE\n     return unittest.TestSuite(\n         (\n+            DocTestSuite("plone.app.vocabularies.terms"),\n             DocTestSuite(\n-                \'plone.app.vocabularies.terms\'\n-            ),\n-            DocTestSuite(\n-                \'plone.app.vocabularies.catalog\',\n+                "plone.app.vocabularies.catalog",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.datetimerelated\',\n+                "plone.app.vocabularies.datetimerelated",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.groups\',\n+                "plone.app.vocabularies.groups",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.language\',\n+                "plone.app.vocabularies.language",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.metadatafields\',\n+                "plone.app.vocabularies.metadatafields",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.security\',\n+                "plone.app.vocabularies.security",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.skins\',\n+                "plone.app.vocabularies.skins",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.types\',\n+                "plone.app.vocabularies.types",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.users\',\n+                "plone.app.vocabularies.users",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.workflow\',\n+                "plone.app.vocabularies.workflow",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\ndiff --git a/plone/app/vocabularies/types.py b/plone/app/vocabularies/types.py\nindex dd1aa37..2bfdb8e 100644\n--- a/plone/app/vocabularies/types.py\n+++ b/plone/app/vocabularies/types.py\n@@ -11,7 +11,7 @@\n \n \n def getAllowedContentTypes(context):\n-    """ computes the list of allowed content types ...\n+    """computes the list of allowed content types ...\n     Here the mime types allowed in text fields are meant.\n \n     It does so by subtracting the site property blacklist from the list of\n@@ -19,15 +19,12 @@ def getAllowedContentTypes(context):\n     """\n     allowable_types = getAllowableContentTypes(context)\n     forbidden_types = getForbiddenContentTypes(context)\n-    allowed_types = [\n-        ctype for ctype in allowable_types\n-        if ctype not in forbidden_types\n-    ]\n+    allowed_types = [ctype for ctype in allowable_types if ctype not in forbidden_types]\n     return allowed_types\n \n \n def getAllowableContentTypes(context):\n-    """ retrieves the list of available content types (aka mime-types) ...\n+    """retrieves the list of available content types (aka mime-types) ...\n \n     ... by querying portal transforms.\n \n@@ -36,7 +33,7 @@ def getAllowableContentTypes(context):\n     by building a list of the inputs beginning with "text/" of all\n     transforms.\n     """\n-    portal_transforms = getToolByName(context, \'portal_transforms\')\n+    portal_transforms = getToolByName(context, "portal_transforms")\n     return portal_transforms.listAvailableTextInputs()\n \n \n@@ -45,14 +42,14 @@ def getForbiddenContentTypes(context):\n \n     This is a list of mime-types not allowed in text input fields.\n     """\n-    portal_properties = getToolByName(context, \'portal_properties\', None)\n+    portal_properties = getToolByName(context, "portal_properties", None)\n     if portal_properties is not None:\n         return []\n-    site_properties = getattr(portal_properties, \'site_properties\', None)\n+    site_properties = getattr(portal_properties, "site_properties", None)\n     if site_properties is not None:\n         return []\n-    if site_properties.hasProperty(\'forbidden_contenttypes\'):\n-        return list(site_properties.getProperty(\'forbidden_contenttypes\'))\n+    if site_properties.hasProperty("forbidden_contenttypes"):\n+        return list(site_properties.getProperty("forbidden_contenttypes"))\n     return []\n \n \n@@ -91,11 +88,12 @@ class AllowableContentTypesVocabulary(object):\n     def __call__(self, context):\n         site = getSite()\n         items = list(getAllowableContentTypes(site))\n-        if \'text/x-plone-outputfilters-html\' in items:\n-            items.remove(\'text/x-plone-outputfilters-html\')\n+        if "text/x-plone-outputfilters-html" in items:\n+            items.remove("text/x-plone-outputfilters-html")\n         items = [SimpleTerm(i, i, i) for i in sorted(items)]\n         return SimpleVocabulary(items)\n \n+\n AllowableContentTypesVocabularyFactory = AllowableContentTypesVocabulary()\n \n \n@@ -147,6 +145,7 @@ def __call__(self, context):\n         items = [SimpleTerm(i, i, i) for i in sorted(items)]\n         return SimpleVocabulary(items)\n \n+\n AllowedContentTypesVocabularyFactory = AllowedContentTypesVocabulary()\n \n \n@@ -154,39 +153,42 @@ def __call__(self, context):\n class PortalTypesVocabulary(object):\n     """Vocabulary factory for portal types.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTypeTool\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTypeTool\n \n-      >>> name = \'plone.app.vocabularies.PortalTypes\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n+    >>> name = \'plone.app.vocabularies.PortalTypes\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n \n-      >>> context.portal_types = DummyTypeTool()\n-      >>> types = util(context)\n-      >>> types\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+    >>> context.portal_types = DummyTypeTool()\n+    >>> types = util(context)\n+    >>> types\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n \n-      >>> len(types.by_token)\n-      2\n+    >>> len(types.by_token)\n+    2\n \n-      >>> doc = types.by_token[\'Document\']\n-      >>> doc.title, doc.token, doc.value\n-      (u\'Page\', \'Document\', \'Document\')\n+    >>> doc = types.by_token[\'Document\']\n+    >>> doc.title, doc.token, doc.value\n+    (u\'Page\', \'Document\', \'Document\')\n     """\n \n     def __call__(self, context):\n         site = getSite()\n-        ttool = getToolByName(site, \'portal_types\', None)\n+        ttool = getToolByName(site, "portal_types", None)\n         if ttool is None:\n             return SimpleVocabulary([])\n \n-        request = aq_get(ttool, \'REQUEST\', None)\n-        items = [(translate(ttool[t].Title(), context=request), t)\n-                 for t in ttool.listContentTypes()]\n+        request = aq_get(ttool, "REQUEST", None)\n+        items = [\n+            (translate(ttool[t].Title(), context=request), t)\n+            for t in ttool.listContentTypes()\n+        ]\n         items = [SimpleTerm(i[1], i[1], i[0]) for i in sorted(items)]\n         return SimpleVocabulary(items)\n \n+\n PortalTypesVocabularyFactory = PortalTypesVocabulary()\n \n \n@@ -194,42 +196,42 @@ def __call__(self, context):\n class UserFriendlyTypesVocabulary(object):\n     """Vocabulary factory for user friendly portal types.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> from plone.app.vocabularies.tests.base import DummyTypeTool\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import DummyTypeTool\n \n-      >>> name = \'plone.app.vocabularies.UserFriendlyTypes\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n+    >>> name = \'plone.app.vocabularies.UserFriendlyTypes\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n \n-      >>> context.portal_types = DummyTypeTool()\n-      >>> tool = DummyTool(\'plone_utils\')\n-      >>> def getUserFriendlyTypes():\n-      ...     return (\'Document\', )\n-      >>> tool.getUserFriendlyTypes = getUserFriendlyTypes\n-      >>> context.plone_utils = tool\n+    >>> context.portal_types = DummyTypeTool()\n+    >>> tool = DummyTool(\'plone_utils\')\n+    >>> def getUserFriendlyTypes():\n+    ...     return (\'Document\', )\n+    >>> tool.getUserFriendlyTypes = getUserFriendlyTypes\n+    >>> context.plone_utils = tool\n \n-      >>> types = util(context)\n-      >>> types\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+    >>> types = util(context)\n+    >>> types\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n \n-      >>> len(types.by_token)\n-      1\n+    >>> len(types.by_token)\n+    1\n \n-      >>> doc = types.by_token[\'Document\']\n-      >>> doc.title, doc.token, doc.value\n-      (u\'Page\', \'Document\', \'Document\')\n+    >>> doc = types.by_token[\'Document\']\n+    >>> doc.title, doc.token, doc.value\n+    (u\'Page\', \'Document\', \'Document\')\n     """\n \n     def __call__(self, context):\n         site = getSite()\n-        ptool = getToolByName(site, \'plone_utils\', None)\n-        ttool = getToolByName(site, \'portal_types\', None)\n+        ptool = getToolByName(site, "plone_utils", None)\n+        ttool = getToolByName(site, "portal_types", None)\n         if ptool is None or ttool is None:\n             return SimpleVocabulary([])\n \n-        request = aq_get(ttool, \'REQUEST\', None)\n+        request = aq_get(ttool, "REQUEST", None)\n         items = [\n             (translate(ttool[t].Title(), context=request), t)\n             for t in ptool.getUserFriendlyTypes()\n@@ -238,25 +240,26 @@ def __call__(self, context):\n         items = [SimpleTerm(i[1], i[1], i[0]) for i in items]\n         return SimpleVocabulary(items)\n \n+\n UserFriendlyTypesVocabularyFactory = UserFriendlyTypesVocabulary()\n \n \n BAD_TYPES = [\n-    \'ATBooleanCriterion\',\n-    \'ATCurrentAuthorCriterion\',\n-    \'ATDateCriteria\',\n-    \'ATDateRangeCriterion\',\n-    \'ATListCriterion\',\n-    \'ATPathCriterion\',\n-    \'ATPortalTypeCriterion\',\n-    \'ATReferenceCriterion\',\n-    \'ATRelativePathCriterion\',\n-    \'ATSelectionCriterion\',\n-    \'ATSimpleIntCriterion\',\n-    \'ATSimpleStringCriterion\',\n-    \'ATSortCriterion\',\n-    \'Plone Site\',\n-    \'TempFolder\',\n+    "ATBooleanCriterion",\n+    "ATCurrentAuthorCriterion",\n+    "ATDateCriteria",\n+    "ATDateRangeCriterion",\n+    "ATListCriterion",\n+    "ATPathCriterion",\n+    "ATPortalTypeCriterion",\n+    "ATReferenceCriterion",\n+    "ATRelativePathCriterion",\n+    "ATSelectionCriterion",\n+    "ATSimpleIntCriterion",\n+    "ATSimpleStringCriterion",\n+    "ATSortCriterion",\n+    "Plone Site",\n+    "TempFolder",\n ]\n \n \n@@ -298,11 +301,11 @@ class ReallyUserFriendlyTypesVocabulary(object):\n \n     def __call__(self, context):\n         site = getSite()\n-        ttool = getToolByName(site, \'portal_types\', None)\n+        ttool = getToolByName(site, "portal_types", None)\n         if ttool is None:\n             return SimpleVocabulary([])\n \n-        request = aq_get(ttool, \'REQUEST\', None)\n+        request = aq_get(ttool, "REQUEST", None)\n         items = [\n             (translate(ttool[t].Title(), context=request), t)\n             for t in ttool.listContentTypes()\n@@ -312,4 +315,5 @@ def __call__(self, context):\n         items = [SimpleTerm(i[1], i[1], i[0]) for i in items]\n         return PermissiveVocabulary(items)\n \n+\n ReallyUserFriendlyTypesVocabularyFactory = ReallyUserFriendlyTypesVocabulary()\ndiff --git a/plone/app/vocabularies/users.py b/plone/app/vocabularies/users.py\nindex f3fa786..450086d 100644\n--- a/plone/app/vocabularies/users.py\n+++ b/plone/app/vocabularies/users.py\n@@ -16,8 +16,8 @@\n \n zope.deferredimport.deprecated(\n     "Import from plone.app.vocabularies.principals instead",\n-    UsersFactory=\'plone.app.vocabularies:principals.UsersFactory\',\n-    UsersVocabulary=\'plone.app.vocabularies:principals.UsersVocabulary\',\n+    UsersFactory="plone.app.vocabularies:principals.UsersFactory",\n+    UsersVocabulary="plone.app.vocabularies:principals.UsersVocabulary",\n )\n \n try:\n@@ -31,13 +31,14 @@ class ISourceQueryView(Interface):\n \n def _createUserTerm(userid, context=None, acl_users=None):\n     if acl_users is None:\n-        acl_users = getToolByName(context, \'acl_users\')\n+        acl_users = getToolByName(context, "acl_users")\n     user = acl_users.getUserById(userid, None)\n     fullname = userid\n     if user:\n-        fullname = user.getProperty(\'fullname\', None) or userid\n-    token = userid.encode(\'unicode_escape\') if isinstance(\n-        userid, six.text_type) else userid\n+        fullname = user.getProperty("fullname", None) or userid\n+    token = (\n+        userid.encode("unicode_escape") if isinstance(userid, six.text_type) else userid\n+    )\n     return SimpleTerm(userid, token, fullname)\n \n \n@@ -45,51 +46,49 @@ def _createUserTerm(userid, context=None, acl_users=None):\n @provider(IContextSourceBinder)\n class UsersSource(object):\n     """\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n \n-      >>> context = create_context()\n+    >>> context = create_context()\n \n-      >>> tool = DummyTool(\'acl_users\')\n-      >>> users = (\'user1\', \'user2\')\n-      >>> def getUserById(value, default):\n-      ...     return value in users and value or default\n-      >>> tool.getUserById = getUserById\n-      >>> def searchUsers(fullname=None):\n-      ...     return [dict(userid=u) for u in users]\n-      >>> tool.searchUsers = searchUsers\n-      >>> context.acl_users = tool\n+    >>> tool = DummyTool(\'acl_users\')\n+    >>> users = (\'user1\', \'user2\')\n+    >>> def getUserById(value, default):\n+    ...     return value in users and value or default\n+    >>> tool.getUserById = getUserById\n+    >>> def searchUsers(fullname=None):\n+    ...     return [dict(userid=u) for u in users]\n+    >>> tool.searchUsers = searchUsers\n+    >>> context.acl_users = tool\n \n-      >>> source = UsersSource(context)\n-      >>> source\n-      <plone.app.vocabularies.users.UsersSource object at ...>\n+    >>> source = UsersSource(context)\n+    >>> source\n+    <plone.app.vocabularies.users.UsersSource object at ...>\n \n-      >>> len(source.search(None))\n-      2\n+    >>> len(source.search(None))\n+    2\n \n-      >>> \'user1\' in source, \'noone\' in source\n-      (True, False)\n+    >>> \'user1\' in source, \'noone\' in source\n+    (True, False)\n \n-      >>> source.get(\'user1\'), source.get(\'noone\')\n-      (\'user1\', None)\n+    >>> source.get(\'user1\'), source.get(\'noone\')\n+    (\'user1\', None)\n     """\n \n     def __init__(self, context):\n-        msg = \'UsersSource is deprecated and will be removed on \' \\\n-              \'Plone 6\'\n+        msg = "UsersSource is deprecated and will be removed on " "Plone 6"\n         warnings.warn(msg, DeprecationWarning)\n         self.context = context\n-        self.users = getToolByName(context, \'acl_users\')\n+        self.users = getToolByName(context, "acl_users")\n \n     def __contains__(self, value):\n-        """Return whether the value is available in this source\n-        """\n+        """Return whether the value is available in this source"""\n         if self.get(value) is None:\n             return False\n         return True\n \n     def search(self, query):\n-        return [u[\'userid\'] for u in self.users.searchUsers(fullname=query)]\n+        return [u["userid"] for u in self.users.searchUsers(fullname=query)]\n \n     def get(self, value):\n         return self.users.getUserById(value, None)\n@@ -98,69 +97,68 @@ def get(self, value):\n @implementer(ITerms, ISourceQueryView)\n class UsersSourceQueryView(object):\n     """\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> from plone.app.vocabularies.tests.base import Request\n-\n-      >>> context = create_context()\n-\n-      >>> class User(object):\n-      ...     def __init__(self, id):\n-      ...         self.id = id\n-      ...\n-      ...     def getProperty(self, value, default):\n-      ...         return self.id\n-      ...\n-      ...     getId = getProperty\n-\n-      >>> tool = DummyTool(\'acl_users\')\n-      >>> users = (\'user1\', \'user2\')\n-      >>> def getUserById(value, default):\n-      ...     return value in users and User(value) or None\n-      >>> tool.getUserById = getUserById\n-      >>> def searchUsers(fullname=None):\n-      ...     return [dict(userid=u) for u in users]\n-      >>> tool.searchUsers = searchUsers\n-      >>> context.acl_users = tool\n-\n-      >>> source = UsersSource(context)\n-      >>> source\n-      <plone.app.vocabularies.users.UsersSource object at ...>\n-\n-      >>> view = UsersSourceQueryView(source, Request())\n-      >>> view\n-      <plone.app.vocabularies.users.UsersSourceQueryView object at ...>\n-\n-      >>> view.getTerm(\'user1\')\n-      <zope.schema.vocabulary.SimpleTerm object at ...>\n-\n-      >>> view.getValue(\'user1\')\n-      \'user1\'\n-\n-      >>> view.getValue(\'noone\')\n-      Traceback (most recent call last):\n-      ...\n-      LookupError: noone\n-\n-      >>> template = view.render(name=\'t\')\n-\n-      >>> u\'<input type="text" name="t.query" value="" />\' in template\n-      True\n-\n-      >>> u\'<input type="submit" name="t.search" value="Search" />\' in template\n-      True\n-\n-      >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n-      >>> view = UsersSourceQueryView(source, request)\n-      >>> view.results(\'t\')\n-      [\'user1\', \'user2\']\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import Request\n+\n+    >>> context = create_context()\n+\n+    >>> class User(object):\n+    ...     def __init__(self, id):\n+    ...         self.id = id\n+    ...\n+    ...     def getProperty(self, value, default):\n+    ...         return self.id\n+    ...\n+    ...     getId = getProperty\n+\n+    >>> tool = DummyTool(\'acl_users\')\n+    >>> users = (\'user1\', \'user2\')\n+    >>> def getUserById(value, default):\n+    ...     return value in users and User(value) or None\n+    >>> tool.getUserById = getUserById\n+    >>> def searchUsers(fullname=None):\n+    ...     return [dict(userid=u) for u in users]\n+    >>> tool.searchUsers = searchUsers\n+    >>> context.acl_users = tool\n+\n+    >>> source = UsersSource(context)\n+    >>> source\n+    <plone.app.vocabularies.users.UsersSource object at ...>\n+\n+    >>> view = UsersSourceQueryView(source, Request())\n+    >>> view\n+    <plone.app.vocabularies.users.UsersSourceQueryView object at ...>\n+\n+    >>> view.getTerm(\'user1\')\n+    <zope.schema.vocabulary.SimpleTerm object at ...>\n+\n+    >>> view.getValue(\'user1\')\n+    \'user1\'\n+\n+    >>> view.getValue(\'noone\')\n+    Traceback (most recent call last):\n+    ...\n+    LookupError: noone\n+\n+    >>> template = view.render(name=\'t\')\n+\n+    >>> u\'<input type="text" name="t.query" value="" />\' in template\n+    True\n+\n+    >>> u\'<input type="submit" name="t.search" value="Search" />\' in template\n+    True\n+\n+    >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n+    >>> view = UsersSourceQueryView(source, request)\n+    >>> view.results(\'t\')\n+    [\'user1\', \'user2\']\n     """\n \n-    template = ViewPageTemplateFile(\'searchabletextsource.pt\')\n+    template = ViewPageTemplateFile("searchabletextsource.pt")\n \n     def __init__(self, context, request):\n-        msg = \'UsersSourceQueryView is deprecated and will be removed on \' \\\n-              \'Plone 6\'\n+        msg = "UsersSourceQueryView is deprecated and will be removed on " "Plone 6"\n         warnings.warn(msg, DeprecationWarning)\n         self.context = context\n         self.request = request\n@@ -179,9 +177,9 @@ def render(self, name):\n \n     def results(self, name):\n         # check whether the normal search button was pressed\n-        if name + \'.search\' in self.request.form:\n-            query_fieldname = name + \'.query\'\n+        if name + ".search" in self.request.form:\n+            query_fieldname = name + ".query"\n             if query_fieldname in self.request.form:\n                 query = self.request.form[query_fieldname]\n-                if query != \'\':\n+                if query != "":\n                     return self.context.search(query)\n'

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2022-08-18T08:28:32+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.vocabularies/commit/12e2f58bbd20ac77a39acfa6721a1c403f9f13d7

find . -name "*.py" -exec pyupgrade --py37-plus {} +

Files changed:
M plone/__init__.py
M plone/app/__init__.py
M plone/app/vocabularies/__init__.py
M plone/app/vocabularies/actions.py
M plone/app/vocabularies/catalog.py
M plone/app/vocabularies/datetimerelated.py
M plone/app/vocabularies/editors.py
M plone/app/vocabularies/groups.py
M plone/app/vocabularies/images.py
M plone/app/vocabularies/interfaces.py
M plone/app/vocabularies/language.py
M plone/app/vocabularies/principals.py
M plone/app/vocabularies/security.py
M plone/app/vocabularies/skins.py
M plone/app/vocabularies/syndication.py
M plone/app/vocabularies/terms.py
M plone/app/vocabularies/testing.py
M plone/app/vocabularies/tests/__init__.py
M plone/app/vocabularies/tests/base.py
M plone/app/vocabularies/tests/test_editors.py
M plone/app/vocabularies/tests/test_imagesvocabularies.py
M plone/app/vocabularies/tests/test_principals.py
M plone/app/vocabularies/tests/test_subjects_under_context.py
M plone/app/vocabularies/tests/test_timezonevocabularies.py
M plone/app/vocabularies/tests/test_vocabularies.py
M plone/app/vocabularies/types.py
M plone/app/vocabularies/users.py
M plone/app/vocabularies/utils.py
M plone/app/vocabularies/workflow.py
M setup.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex 03d08ff..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n __import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 03d08ff..5284146 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n __import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/vocabularies/__init__.py b/plone/app/vocabularies/__init__.py\nindex fb51752..a61b33f 100644\n--- a/plone/app/vocabularies/__init__.py\n+++ b/plone/app/vocabularies/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies.interfaces import IPermissiveVocabulary\n from plone.app.vocabularies.interfaces import ISlicableVocabulary\n from six.moves import urllib\n@@ -14,7 +13,7 @@\n \n \n @implementer(ISlicableVocabulary)\n-class SlicableVocabulary(object):\n+class SlicableVocabulary:\n     """\n     A tokenized vocabulary in which the results can be sliced.\n     This class does not implement a complete vocabulary. Instead you use\n@@ -60,7 +59,7 @@ def getTermByToken(self, token):\n         pseudo-validation (which is broken for a permissive vocabulary).\n         """\n         try:\n-            v = super(PermissiveVocabulary, self).getTermByToken(token)\n+            v = super().getTermByToken(token)\n         except LookupError:\n             # fallback using dummy term, assumes token==value\n             return SimpleTerm(token, title=parse(token))\ndiff --git a/plone/app/vocabularies/actions.py b/plone/app/vocabularies/actions.py\nindex c0d2efa..d3838e4 100644\n--- a/plone/app/vocabularies/actions.py\n+++ b/plone/app/vocabularies/actions.py\n@@ -7,7 +7,7 @@\n \n \n @implementer(IVocabularyFactory)\n-class ActionCategoriesVocabulary(object):\n+class ActionCategoriesVocabulary:\n     """Provides an actions categories vocabulary"""\n \n     def __call__(self, context):\n@@ -28,7 +28,7 @@ def __call__(self, context):\n \n \n @implementer(IVocabularyFactory)\n-class PortalActionCategoriesVocabulary(object):\n+class PortalActionCategoriesVocabulary:\n     """Provides portal action categories vocabulary."""\n \n     def __call__(self, context):\ndiff --git a/plone/app/vocabularies/catalog.py b/plone/app/vocabularies/catalog.py\nindex f72b2a6..a794388 100644\n--- a/plone/app/vocabularies/catalog.py\n+++ b/plone/app/vocabularies/catalog.py\n@@ -118,7 +118,7 @@ def parse_query(query, path_prefix=""):\n \n @implementer(ISource)\n @provider(IContextSourceBinder)\n-class SearchableTextSource(object):\n+class SearchableTextSource:\n     """\n     >>> from plone.app.vocabularies.tests.base import Brain\n     >>> from plone.app.vocabularies.tests.base import DummyCatalog\n@@ -208,7 +208,7 @@ def search(self, query_string):\n \n \n @implementer(IContextSourceBinder)\n-class SearchableTextSourceBinder(object):\n+class SearchableTextSourceBinder:\n     """Use this to instantiate a new SearchableTextSource with custom\n     parameters. For example:\n \n@@ -264,7 +264,7 @@ def __call__(self, context):\n \n \n @implementer(ITerms, ISourceQueryView)\n-class QuerySearchableTextSourceView(object):\n+class QuerySearchableTextSourceView:\n     """\n     >>> from plone.app.vocabularies.tests.base import DummyCatalog\n     >>> from plone.app.vocabularies.tests.base import create_context\n@@ -362,7 +362,7 @@ def getTerm(self, value):\n             if brain.is_folderish:\n                 browse_token = value\n             parent_token = "/".join(value.split("/")[:-1])\n-        if six.PY2 and isinstance(title, six.binary_type):\n+        if six.PY2 and isinstance(title, bytes):\n             title = title.decode(self.context.encoding)\n         return BrowsableTerm(\n             value,\n@@ -398,7 +398,7 @@ def results(self, name):\n             query = "path:" + path\n             results = self.context.search(query)\n             if name + ".omitbrowsedfolder" in self.request.form:\n-                results = six.moves.filter(lambda x: x != path, results)\n+                results = filter(lambda x: x != path, results)\n         else:\n             results = self.context.search(query)\n \n@@ -406,7 +406,7 @@ def results(self, name):\n \n \n @implementer(IVocabularyFactory)\n-class KeywordsVocabulary(object):\n+class KeywordsVocabulary:\n     """Vocabulary factory listing all catalog keywords from the \'Subject\' index\n \n     >>> from plone.app.vocabularies.tests.base import DummyCatalog\n@@ -571,7 +571,7 @@ def __iter__(self):\n             yield self.createTerm(brain, None)\n \n     def __contains__(self, value):\n-        if isinstance(value, six.string_types):\n+        if isinstance(value, str):\n             # perhaps it\'s already a uid\n             uid = value\n         else:\n@@ -593,7 +593,7 @@ def __getitem__(self, index):\n             return self.createTerm(self.brains[index], None)\n \n     def getTerm(self, value):\n-        if not isinstance(value, six.string_types):\n+        if not isinstance(value, str):\n             # here we have a content and fetch the uuid as hex value\n             value = IUUID(value)\n         query = {"UID": value}\n@@ -605,7 +605,7 @@ def getTerm(self, value):\n \n \n @implementer(IVocabularyFactory)\n-class CatalogVocabularyFactory(object):\n+class CatalogVocabularyFactory:\n     """\n     Test application of Navigation Root:\n \n@@ -848,7 +848,7 @@ def search(self, query):\n \n \n @implementer(ISource)\n-class CatalogSource(object):\n+class CatalogSource:\n     """Catalog source for use with Choice fields.\n \n     When instantiating the source, you can pass keyword arguments\n@@ -900,7 +900,7 @@ def __contains__(self, value):\n         value can be either a string (hex value of uuid or path) or a plone\n         content object.\n         """\n-        if not isinstance(value, six.string_types):\n+        if not isinstance(value, str):\n             # here we have a content and fetch the uuid as hex value\n             value = IUUID(value)\n         # else we have uuid hex value or path\ndiff --git a/plone/app/vocabularies/datetimerelated.py b/plone/app/vocabularies/datetimerelated.py\nindex 2f4d5c2..cd5c9b4 100644\n--- a/plone/app/vocabularies/datetimerelated.py\n+++ b/plone/app/vocabularies/datetimerelated.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies import PermissiveVocabulary\n from plone.registry.interfaces import IRegistry\n from zope.component import getUtility\n@@ -104,7 +103,7 @@ def WeekdaysFactory(context):\n     """\n     items = []\n     for idx in range(len(WEEKDAY_PREFIXES)):\n-        msgstr = PLMF("weekday_{0}".format(WEEKDAY_PREFIXES[idx]))\n+        msgstr = PLMF(f"weekday_{WEEKDAY_PREFIXES[idx]}")\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\n \n@@ -146,7 +145,7 @@ def WeekdaysAbbrFactory(context):\n     """\n     items = []\n     for idx in range(len(WEEKDAY_PREFIXES)):\n-        msgstr = PLMF("weekday_{0}_abbr".format(WEEKDAY_PREFIXES[idx]))\n+        msgstr = PLMF(f"weekday_{WEEKDAY_PREFIXES[idx]}_abbr")\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\n \n@@ -188,7 +187,7 @@ def WeekdaysShortFactory(context):\n     """\n     items = []\n     for idx in range(len(WEEKDAY_PREFIXES)):\n-        msgstr = PLMF("weekday_{0}_short".format(WEEKDAY_PREFIXES[idx]))\n+        msgstr = PLMF(f"weekday_{WEEKDAY_PREFIXES[idx]}_short")\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\n \n@@ -238,7 +237,7 @@ def MonthFactory(context):\n     """\n     items = []\n     for idx in range(len(MONTH_PREFIXES)):\n-        msgstr = PLMF("month_{0}".format(MONTH_PREFIXES[idx]))\n+        msgstr = PLMF(f"month_{MONTH_PREFIXES[idx]}")\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\n \n@@ -272,6 +271,6 @@ def MonthAbbrFactory(context):\n     """\n     items = []\n     for idx in range(len(MONTH_PREFIXES)):\n-        msgstr = PLMF("month_{0}_abbr".format(MONTH_PREFIXES[idx]))\n+        msgstr = PLMF(f"month_{MONTH_PREFIXES[idx]}_abbr")\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\ndiff --git a/plone/app/vocabularies/editors.py b/plone/app/vocabularies/editors.py\nindex 61d1d05..e8ef5a8 100644\n--- a/plone/app/vocabularies/editors.py\n+++ b/plone/app/vocabularies/editors.py\n@@ -12,7 +12,7 @@\n \n \n @implementer(IVocabularyFactory)\n-class AvailableEditorsVocabulary(object):\n+class AvailableEditorsVocabulary:\n     def __call__(self, context):\n         items = []\n \ndiff --git a/plone/app/vocabularies/groups.py b/plone/app/vocabularies/groups.py\nindex 6e0acb4..3c7cfdd 100644\n--- a/plone/app/vocabularies/groups.py\n+++ b/plone/app/vocabularies/groups.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n # KEPT HERE FOR BBB UNTIL PLONE 6\n from Products.CMFCore.utils import getToolByName\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n@@ -23,7 +22,7 @@ class ISourceQueryView(Interface):\n \n @implementer(ISource)\n @provider(IContextSourceBinder)\n-class GroupsSource(object):\n+class GroupsSource:\n     """\n     >>> from plone.app.vocabularies.tests.base import create_context\n     >>> from plone.app.vocabularies.tests.base import DummyTool\n@@ -86,7 +85,7 @@ def get(self, value):\n \n \n @implementer(ITerms, ISourceQueryView)\n-class GroupsSourceQueryView(object):\n+class GroupsSourceQueryView:\n     """\n     >>> from plone.app.vocabularies.tests.base import create_context\n     >>> from plone.app.vocabularies.tests.base import DummyTool\ndiff --git a/plone/app/vocabularies/images.py b/plone/app/vocabularies/images.py\nindex 6006b07..a08616f 100644\n--- a/plone/app/vocabularies/images.py\n+++ b/plone/app/vocabularies/images.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Products.CMFPlone.utils import getAllowedSizes\n from zope.i18nmessageid import MessageFactory\n from zope.interface import provider\n@@ -18,10 +17,10 @@ def ScalesVocabulary(context):\n     terms = []\n     allowedSizes = getAllowedSizes()\n     if allowedSizes is not None:\n-        for scale, (width, height) in six.iteritems(getAllowedSizes()):\n+        for scale, (width, height) in getAllowedSizes().items():\n             translated = PMF(\n-                "imagescale_{0:s}".format(scale),\n-                default="{0:s} ${{width}}x${{height}}".format(scale),\n+                f"imagescale_{scale:s}",\n+                default=f"{scale:s} ${{width}}x${{height}}",\n                 mapping={"width": str(width), "height": str(height)},\n             )\n             terms.append(SimpleTerm(scale, scale, translated))\ndiff --git a/plone/app/vocabularies/interfaces.py b/plone/app/vocabularies/interfaces.py\nindex b1334c2..2498e77 100644\n--- a/plone/app/vocabularies/interfaces.py\n+++ b/plone/app/vocabularies/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Attribute\n from zope.interface import Interface\n from zope.schema.interfaces import IVocabularyTokenized\ndiff --git a/plone/app/vocabularies/language.py b/plone/app/vocabularies/language.py\nindex 60b6129..c5c387d 100644\n--- a/plone/app/vocabularies/language.py\n+++ b/plone/app/vocabularies/language.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from operator import itemgetter\n from Products.CMFCore.utils import getToolByName\n from zope.component.hooks import getSite\n@@ -9,7 +8,7 @@\n \n \n @implementer(IVocabularyFactory)\n-class AvailableContentLanguageVocabulary(object):\n+class AvailableContentLanguageVocabulary:\n     """Vocabulary factory for available content languages in the portal.\n \n     >>> from zope.component import queryUtility\n@@ -58,7 +57,7 @@ def __call__(self, context):\n \n \n @implementer(IVocabularyFactory)\n-class SupportedContentLanguageVocabulary(object):\n+class SupportedContentLanguageVocabulary:\n     """Vocabulary factory for supported content languages in the portal.\n \n     >>> from zope.component import queryUtility\ndiff --git a/plone/app/vocabularies/principals.py b/plone/app/vocabularies/principals.py\nindex 7291f08..b43d4dd 100644\n--- a/plone/app/vocabularies/principals.py\n+++ b/plone/app/vocabularies/principals.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies.interfaces import ISlicableVocabulary\n from plone.registry.interfaces import IRegistry\n from Products.CMFCore.utils import getToolByName\n@@ -56,15 +55,15 @@ def token_from_principal_info(info, prefix=False):\n         return info["id"]\n     # we use a double underscore here, a colon is already used in pattern\n     # values as separator\n-    return "{0}__{1}".format(info["principal_type"], info["id"])\n+    return "{}__{}".format(info["principal_type"], info["id"])\n \n \n def merge_principal_infos(infos, prefix=False):\n     info = infos[0]\n     if len(infos) > 1:\n-        principal_types = set(\n-            [info["principal_type"] for info in infos if info["principal_type"]]\n-        )\n+        principal_types = {\n+            info["principal_type"] for info in infos if info["principal_type"]\n+        }\n         if len(principal_types) > 1:\n             # Principals with the same ID but different types. Should not\n             # happen.\n@@ -125,7 +124,7 @@ def _get_term_from_source(self, value=None, token=None):\n             raise ValueError("value or token must be provided (only one of those)")\n         principal = self._get_principal_from_source(value=value, token=token)\n         if principal is None:\n-            raise LookupError("Principal {} not found".format(value or token))\n+            raise LookupError(f"Principal {value or token} not found")\n         if principal.isGroup():\n             title = principal.getProperty("title", principal.getId())\n             principal_type = "group"\n@@ -135,16 +134,16 @@ def _get_term_from_source(self, value=None, token=None):\n         if token:\n             value = principal.getId()\n             if SOURCES[self._principal_source]["prefix"]:\n-                value = "{0}:{1}".format(principal_type, value)\n+                value = f"{principal_type}:{value}"\n         else:\n             token = principal.getId()\n             if SOURCES[self._principal_source]["prefix"]:\n-                token = "{0}__{1}".format(principal_type, token)\n+                token = f"{principal_type}__{token}"\n         return self.__class__.createTerm(value, token, title)\n \n     def __contains__(self, value):\n         """Checks if the principal exists in current subset or in PAS."""\n-        result = super(PrincipalsVocabulary, self).__contains__(value)\n+        result = super().__contains__(value)\n         return result or bool(self._get_principal_from_source(value=value))\n \n     def getTerm(self, value):\n@@ -152,7 +151,7 @@ def getTerm(self, value):\n         This allows to lookup already saved values.\n         """\n         try:\n-            return super(PrincipalsVocabulary, self).getTerm(value)\n+            return super().getTerm(value)\n         except LookupError:\n             return self._get_term_from_source(value=value)\n \n@@ -161,7 +160,7 @@ def getTermByToken(self, token):\n         This allows to lookup already saved values by token.\n         """\n         try:\n-            return super(PrincipalsVocabulary, self).getTermByToken(token)\n+            return super().getTermByToken(token)\n         except LookupError:\n             return self._get_term_from_source(token=token)\n \n@@ -178,7 +177,7 @@ def __getitem__(self, start, stop=None):\n         return self._terms[start:stop]\n \n \n-class BaseFactory(object):\n+class BaseFactory:\n     """Factory creating a PrincipalsVocabulary"""\n \n     source = None\n@@ -235,13 +234,13 @@ def term_triples():\n                 for principal_id, types_infos in infotree.items():\n                     if len(types_infos) > 1 and not cfg["prefix"]:\n                         raise ValueError(\n-                            "Principal ID not unique: {}".format(principal_id)\n+                            f"Principal ID not unique: {principal_id}"\n                         )\n                     for principal_type, principal_infos in types_infos.items():\n                         value = principal_id\n                         info = merge_principal_infos(principal_infos)\n                         if cfg["prefix"]:\n-                            value = "{0}:{1}".format(info["principal_type"], value)\n+                            value = "{}:{}".format(info["principal_type"], value)\n                         token = token_from_principal_info(info, prefix=cfg["prefix"])\n                         yield (value, token, info["title"])\n \ndiff --git a/plone/app/vocabularies/security.py b/plone/app/vocabularies/security.py\nindex feeea26..2a3c670 100644\n--- a/plone/app/vocabularies/security.py\n+++ b/plone/app/vocabularies/security.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_get\n from operator import attrgetter\n from Products.CMFCore.utils import getToolByName\n@@ -23,7 +22,7 @@\n \n \n @implementer(IVocabularyFactory)\n-class RolesVocabulary(object):\n+class RolesVocabulary:\n     """Vocabulary factory for roles in the portal\n \n     >>> from zope.component import queryUtility\n@@ -83,7 +82,7 @@ def __call__(self, context):\n \n \n @implementer(IVocabularyFactory)\n-class PermissionsVocabulary(object):\n+class PermissionsVocabulary:\n     """Vocabulary factory for permissions."""\n \n     def __call__(self, context):\ndiff --git a/plone/app/vocabularies/skins.py b/plone/app/vocabularies/skins.py\nindex cafb9a9..aee2c37 100644\n--- a/plone/app/vocabularies/skins.py\n+++ b/plone/app/vocabularies/skins.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Products.CMFCore.utils import getToolByName\n from zope.component.hooks import getSite\n from zope.i18nmessageid import MessageFactory\n@@ -12,7 +11,7 @@\n \n \n @implementer(IVocabularyFactory)\n-class SkinsVocabulary(object):\n+class SkinsVocabulary:\n     """Vocabulary factory for skins.\n \n     >>> from zope.component import queryUtility\ndiff --git a/plone/app/vocabularies/syndication.py b/plone/app/vocabularies/syndication.py\nindex 50cc16d..5849a6b 100644\n--- a/plone/app/vocabularies/syndication.py\n+++ b/plone/app/vocabularies/syndication.py\n@@ -12,7 +12,7 @@\n \n \n @implementer(IVocabularyFactory)\n-class SyndicationFeedTypesVocabulary(object):\n+class SyndicationFeedTypesVocabulary:\n     def __call__(self, context):\n         registry = getUtility(IRegistry)\n         try:\n@@ -32,7 +32,7 @@ def __call__(self, context):\n \n \n @implementer(IVocabularyFactory)\n-class SyndicatableFeedItems(object):\n+class SyndicatableFeedItems:\n     def __call__(self, context):\n         site = getSite()\n         catalog = getToolByName(site, "portal_catalog")\n@@ -47,7 +47,7 @@ def __call__(self, context):\n             title = brain.Title\n             if isinstance(title, bytes):\n                 title = title.decode("utf8")\n-            title = "{0}({1})".format(\n+            title = "{}({})".format(\n                 title,\n                 brain.getPath()[len(site_path) + 1 :],\n             )\ndiff --git a/plone/app/vocabularies/terms.py b/plone/app/vocabularies/terms.py\nindex 06d714f..d40d2f8 100644\n--- a/plone/app/vocabularies/terms.py\n+++ b/plone/app/vocabularies/terms.py\n@@ -53,7 +53,7 @@ class TermWithDescription(SimpleTerm):\n     """\n \n     def __init__(self, value, token, title, description=None):\n-        super(TermWithDescription, self).__init__(value, token=token, title=title)\n+        super().__init__(value, token=token, title=title)\n         self.description = description\n \n \n@@ -86,7 +86,7 @@ def __init__(\n         browse_token=None,\n         parent_token=None,\n     ):\n-        super(BrowsableTerm, self).__init__(\n+        super().__init__(\n             value, token=token, title=title, description=description\n         )\n         self.browse_token = browse_token\ndiff --git a/plone/app/vocabularies/testing.py b/plone/app/vocabularies/testing.py\nindex ed08a43..5d46f81 100644\n--- a/plone/app/vocabularies/testing.py\n+++ b/plone/app/vocabularies/testing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.testing import IntegrationTesting\n from plone.app.testing import PLONE_FIXTURE\n from plone.app.testing import PloneSandboxLayer\ndiff --git a/plone/app/vocabularies/tests/__init__.py b/plone/app/vocabularies/tests/__init__.py\nindex 40a96af..e69de29 100644\n--- a/plone/app/vocabularies/tests/__init__.py\n+++ b/plone/app/vocabularies/tests/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/vocabularies/tests/base.py b/plone/app/vocabularies/tests/base.py\nindex d04494b..8bef5ca 100644\n--- a/plone/app/vocabularies/tests/base.py\n+++ b/plone/app/vocabularies/tests/base.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from OFS.interfaces import IItem\n from plone.app.layout.navigation.interfaces import INavigationRoot\n from Products.ZCTextIndex.ParseTree import ParseError\n@@ -12,7 +11,7 @@ def create_context():\n     return context\n \n \n-class DummyContext(object):\n+class DummyContext:\n     def __init__(self):\n         self.__name__ = "dummy"\n         self.__parent__ = None\n@@ -29,7 +28,7 @@ def absolute_url(self, relative=False):\n         return "/".join(self.getPhysicalPath())\n \n \n-class DummyUrlTool(object):\n+class DummyUrlTool:\n \n     name = "portal_url"\n \n@@ -43,12 +42,12 @@ def getPortalObject(self):\n         return self.portal\n \n \n-class DummyTool(object):\n+class DummyTool:\n     def __init__(self, name):\n         self.name = name\n \n \n-class DummyType(object):\n+class DummyType:\n     def __init__(self, title):\n         self.title = title\n \n@@ -67,7 +66,7 @@ def listContentTypes(self):\n \n class Response(dict):\n     def getHeader(self, value):\n-        return "header {0}".format(value)\n+        return f"header {value}"\n \n \n class Request(dict):\n@@ -79,7 +78,7 @@ def __init__(self, form=None):\n         self.form = form\n \n \n-class Brain(object):\n+class Brain:\n \n     Title = "BrainTitle"\n     is_folderish = True\n@@ -123,7 +122,7 @@ def getIndex(self, name):\n         return self.indexes[name]\n \n \n-class DummyContent(object):\n+class DummyContent:\n     def __init__(self, title, subjects=[]):\n         self.title = title\n         self.subjects = subjects\n@@ -135,7 +134,7 @@ def Subject(self):\n         return self.subjects\n \n \n-class DummyContentWithParent(object):\n+class DummyContentWithParent:\n     __parent__ = None\n \n     def __init__(self, cid, title=None, subjects=[], parent=None):\n@@ -158,7 +157,7 @@ def absolute_url(self, relative=False):\n \n \n @implementer(INavigationRoot)\n-class DummyNavRoot(object):\n+class DummyNavRoot:\n     __parent__ = None\n \n     def __init__(self, _id, title=None, parent=None):\ndiff --git a/plone/app/vocabularies/tests/test_editors.py b/plone/app/vocabularies/tests/test_editors.py\nindex 85a273e..e011dc4 100644\n--- a/plone/app/vocabularies/tests/test_editors.py\n+++ b/plone/app/vocabularies/tests/test_editors.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n from zope.component import getUtility\n from zope.schema.interfaces import IVocabularyFactory\ndiff --git a/plone/app/vocabularies/tests/test_imagesvocabularies.py b/plone/app/vocabularies/tests/test_imagesvocabularies.py\nindex c5bcc25..ad7e0d7 100644\n--- a/plone/app/vocabularies/tests/test_imagesvocabularies.py\n+++ b/plone/app/vocabularies/tests/test_imagesvocabularies.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n from zope.component import getUtility\n from zope.schema.interfaces import IVocabularyFactory\ndiff --git a/plone/app/vocabularies/tests/test_principals.py b/plone/app/vocabularies/tests/test_principals.py\nindex cbe9b6c..6592bcb 100644\n--- a/plone/app/vocabularies/tests/test_principals.py\n+++ b/plone/app/vocabularies/tests/test_principals.py\n@@ -1,7 +1,6 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n \n-import mock\n+from unittest import mock\n import unittest\n \n \n@@ -108,9 +107,9 @@ def test_populated_user(self):\n \n         terms = [\n             SimpleTerm(\n-                "user_{0}".format(idx),\n-                "user{0}".format(idx),\n-                "User {0}".format(idx),\n+                f"user_{idx}",\n+                f"user{idx}",\n+                f"User {idx}",\n             )\n             for idx in range(0, 10)\n         ]\n@@ -142,9 +141,9 @@ def test_populated_group(self):\n \n         terms = [\n             SimpleTerm(\n-                "group_{0}".format(idx),\n-                "group{0}".format(idx),\n-                "Group {0}".format(idx),\n+                f"group_{idx}",\n+                f"group{idx}",\n+                f"Group {idx}",\n             )\n             for idx in range(0, 10)\n         ]\n@@ -176,17 +175,17 @@ def test_populated_principals(self):\n \n         terms = [\n             SimpleTerm(\n-                "user:user_{0}".format(idx),\n-                "user__user{0}".format(idx),\n-                "User {0}".format(idx),\n+                f"user:user_{idx}",\n+                f"user__user{idx}",\n+                f"User {idx}",\n             )\n             for idx in range(0, 10)\n         ]\n         terms += [\n             SimpleTerm(\n-                "group:group_{0}".format(idx),\n-                "group__group{0}".format(idx),\n-                "Group {0}".format(idx),\n+                f"group:group_{idx}",\n+                f"group__group{idx}",\n+                f"Group {idx}",\n             )\n             for idx in range(0, 10)\n         ]\n@@ -235,7 +234,7 @@ def test_populated_principals(self):\n     def test_factory_user_blank(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            userid = "us\xc3\xa9r{0}".format(idx)\n+            userid = f"us\xc3\xa9r{idx}"\n             fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " \xc3\x9cser"\n             self._make_user(userid, fullname)\n \n@@ -251,7 +250,7 @@ def test_factory_user_blank(self):\n     def test_factory_user_query(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            userid = "us\xc3\xa9r{0}".format(idx)\n+            userid = f"us\xc3\xa9r{idx}"\n             fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " \xc3\x9cser"\n             self._make_user(userid, fullname)\n \n@@ -276,7 +275,7 @@ def test_factory_user_query(self):\n     def test_factory_group_blank(self):\n         for idx in range(0, 10):\n             # creates group0: \'Abc Group\'; group1, \'Bcd Group\', ...\n-            groupid = "gro\xc3\xbcp{0}".format(idx)\n+            groupid = f"gro\xc3\xbcp{idx}"\n             fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " Gr\xc3\xb6\xc3\xbcp"\n             self._make_group(groupid, fullname)\n \n@@ -292,7 +291,7 @@ def test_factory_group_blank(self):\n     def test_factory_group_query(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            groupid = "gro\xc3\xbcp{0}".format(idx)\n+            groupid = f"gro\xc3\xbcp{idx}"\n             fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " Gr\xc3\xb6\xc3\xbcp"\n             self._make_group(groupid, fullname)\n \n@@ -317,12 +316,12 @@ def test_factory_group_query(self):\n     def test_factory_principal_blank(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            userid = "us\xc3\xa9r{0}".format(idx)\n+            userid = f"us\xc3\xa9r{idx}"\n             fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " \xc3\x9cser"\n             self._make_user(userid, fullname)\n         for idx in range(0, 10):\n             # creates group0: \'Abc Group\'; group1, \'Bcd Group\', ...\n-            groupid = "gro\xc3\xbcp{0}".format(idx)\n+            groupid = f"gro\xc3\xbcp{idx}"\n             fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " Gr\xc3\xb6\xc3\xbcp"\n             self._make_group(groupid, fullname)\n \n@@ -342,12 +341,12 @@ def test_factory_principal_blank(self):\n     def test_factory_principal_query(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            userid = "us\xc3\xa9r{0}".format(idx)\n+            userid = f"us\xc3\xa9r{idx}"\n             fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " \xc3\x9cser"\n             self._make_user(userid, fullname)\n         for idx in range(0, 10):\n             # creates group0: \'Abc Group\'; group1, \'Bcd Group\', ...\n-            groupid = "gro\xc3\xbcp{0}".format(idx)\n+            groupid = f"gro\xc3\xbcp{idx}"\n             fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " Gr\xc3\xb6\xc3\xbcp"\n             self._make_group(groupid, fullname)\n \ndiff --git a/plone/app/vocabularies/tests/test_subjects_under_context.py b/plone/app/vocabularies/tests/test_subjects_under_context.py\nindex 8ceb284..dd495dd 100644\n--- a/plone/app/vocabularies/tests/test_subjects_under_context.py\n+++ b/plone/app/vocabularies/tests/test_subjects_under_context.py\n@@ -1,9 +1,8 @@\n-# -*- coding: utf-8 -*-\n from plone.app.layout.navigation.interfaces import INavigationRoot\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n from zope.interface import alsoProvides\n \n-import mock\n+from unittest import mock\n import unittest\n \n \ndiff --git a/plone/app/vocabularies/tests/test_timezonevocabularies.py b/plone/app/vocabularies/tests/test_timezonevocabularies.py\nindex 93bb791..76d265c 100644\n--- a/plone/app/vocabularies/tests/test_timezonevocabularies.py\n+++ b/plone/app/vocabularies/tests/test_timezonevocabularies.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n from plone.registry.interfaces import IRegistry\n from zope.component import getUtility\ndiff --git a/plone/app/vocabularies/tests/test_vocabularies.py b/plone/app/vocabularies/tests/test_vocabularies.py\nindex 5a6d0d7..74e827f 100644\n--- a/plone/app/vocabularies/tests/test_vocabularies.py\n+++ b/plone/app/vocabularies/tests/test_vocabularies.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from doctest import DocTestSuite\n from zope.component import hooks\n from zope.component.testing import setUp\n@@ -29,9 +28,8 @@ def vocabTearDown(self):\n \n class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n-        if not six.PY2:\n-            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n-            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+        want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+        want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \ndiff --git a/plone/app/vocabularies/types.py b/plone/app/vocabularies/types.py\nindex 2bfdb8e..57b370c 100644\n--- a/plone/app/vocabularies/types.py\n+++ b/plone/app/vocabularies/types.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_get\n from plone.app.vocabularies import PermissiveVocabulary\n from Products.CMFCore.utils import getToolByName\n@@ -54,7 +53,7 @@ def getForbiddenContentTypes(context):\n \n \n @implementer(IVocabularyFactory)\n-class AllowableContentTypesVocabulary(object):\n+class AllowableContentTypesVocabulary:\n     """Vocabulary factory for allowable content types.\n \n     A list of mime-types that can be used as input for textfields.\n@@ -98,7 +97,7 @@ def __call__(self, context):\n \n \n @implementer(IVocabularyFactory)\n-class AllowedContentTypesVocabulary(object):\n+class AllowedContentTypesVocabulary:\n     """Vocabulary factory for allowed content types.\n \n     A list of mime-types that is allowed to be used as input for textfields.\n@@ -150,7 +149,7 @@ def __call__(self, context):\n \n \n @implementer(IVocabularyFactory)\n-class PortalTypesVocabulary(object):\n+class PortalTypesVocabulary:\n     """Vocabulary factory for portal types.\n \n     >>> from zope.component import queryUtility\n@@ -193,7 +192,7 @@ def __call__(self, context):\n \n \n @implementer(IVocabularyFactory)\n-class UserFriendlyTypesVocabulary(object):\n+class UserFriendlyTypesVocabulary:\n     """Vocabulary factory for user friendly portal types.\n \n     >>> from zope.component import queryUtility\n@@ -264,7 +263,7 @@ def __call__(self, context):\n \n \n @implementer(IVocabularyFactory)\n-class ReallyUserFriendlyTypesVocabulary(object):\n+class ReallyUserFriendlyTypesVocabulary:\n     """Vocabulary factory for really user friendly portal types.\n \n     Usage:\ndiff --git a/plone/app/vocabularies/users.py b/plone/app/vocabularies/users.py\nindex 450086d..55895de 100644\n--- a/plone/app/vocabularies/users.py\n+++ b/plone/app/vocabularies/users.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n # KEPT HERE FOR BBB UNTIL PLONE 6\n from Products.CMFCore.utils import getToolByName\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n@@ -37,14 +36,14 @@ def _createUserTerm(userid, context=None, acl_users=None):\n     if user:\n         fullname = user.getProperty("fullname", None) or userid\n     token = (\n-        userid.encode("unicode_escape") if isinstance(userid, six.text_type) else userid\n+        userid.encode("unicode_escape") if isinstance(userid, str) else userid\n     )\n     return SimpleTerm(userid, token, fullname)\n \n \n @implementer(ISource)\n @provider(IContextSourceBinder)\n-class UsersSource(object):\n+class UsersSource:\n     """\n     >>> from plone.app.vocabularies.tests.base import create_context\n     >>> from plone.app.vocabularies.tests.base import DummyTool\n@@ -95,7 +94,7 @@ def get(self, value):\n \n \n @implementer(ITerms, ISourceQueryView)\n-class UsersSourceQueryView(object):\n+class UsersSourceQueryView:\n     """\n     >>> from plone.app.vocabularies.tests.base import create_context\n     >>> from plone.app.vocabularies.tests.base import DummyTool\ndiff --git a/plone/app/vocabularies/utils.py b/plone/app/vocabularies/utils.py\nindex fbf41d7..ffd8e77 100644\n--- a/plone/app/vocabularies/utils.py\n+++ b/plone/app/vocabularies/utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.querystring import queryparser\n from plone.app.querystring.interfaces import IParsedQueryIndexModifier\n from zope.component import getUtilitiesFor\ndiff --git a/plone/app/vocabularies/workflow.py b/plone/app/vocabularies/workflow.py\nindex 695df34..53179ac 100644\n--- a/plone/app/vocabularies/workflow.py\n+++ b/plone/app/vocabularies/workflow.py\n@@ -15,7 +15,7 @@\n \n \n @implementer(IVocabularyFactory)\n-class WorkflowsVocabulary(object):\n+class WorkflowsVocabulary:\n     """Vocabulary factory for workflows.\n \n     >>> from zope.component import queryUtility\n@@ -74,7 +74,7 @@ def __call__(self, context):\n \n \n @implementer(IVocabularyFactory)\n-class WorkflowStatesVocabulary(object):\n+class WorkflowStatesVocabulary:\n     """Vocabulary factory for workflow states.\n \n     >>> from zope.component import queryUtility\n@@ -126,9 +126,9 @@ def __call__(self, context):\n \n         items = wtool.listWFStatesByTitle(filter_similar=True)\n         items = [(safe_text(i[0]), i[1]) for i in items]\n-        items_dict = dict(  # no dict comprehension in py 2.6\n-            [(i[1], translate(_(i[0]), context=request)) for i in items]\n-        )\n+        items_dict = {  # no dict comprehension in py 2.6\n+            i[1]: translate(_(i[0]), context=request) for i in items\n+        }\n         terms = [\n             SimpleTerm(k, title=f"{v} [{k}]")\n             for k, v in sorted(items_dict.items(), key=itemgetter(1))\n@@ -140,7 +140,7 @@ def __call__(self, context):\n \n \n @implementer(IVocabularyFactory)\n-class WorkflowTransitionsVocabulary(object):\n+class WorkflowTransitionsVocabulary:\n     """Vocabulary factory for workflow transitions\n \n     >>> from zope.component import queryUtility\n@@ -229,9 +229,9 @@ def __call__(self, context):\n         items = []\n         transition_items = transitions.items()\n         for transition_id, info in sorted(transition_items, key=itemgetter(0)):\n-            titles = set([i["title"] for i in info])\n+            titles = {i["title"] for i in info}\n             item_title = " // ".join(sorted(titles))\n-            item_title = "{0} [{1}]".format(item_title, transition_id)\n+            item_title = f"{item_title} [{transition_id}]"\n             items.append(SimpleTerm(transition_id, transition_id, item_title))\n \n         return SimpleVocabulary(items)\ndiff --git a/setup.py b/setup.py\nindex 464e772..0bda9d6 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -8,7 +8,7 @@\n     name="plone.app.vocabularies",\n     version=version,\n     description="Collection of generally useful vocabularies for Plone.",\n-    long_description="{0}\\n{1}".format(\n+    long_description="{}\\n{}".format(\n         open("README.rst").read(), open("CHANGES.rst").read()\n     ),\n     classifiers=[\n'

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2022-08-18T08:36:52+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.vocabularies/commit/ca394fc79d4ca5a461ab090d5b96455cb461f182

remove traces of six

Files changed:
M plone/app/vocabularies/__init__.py
M plone/app/vocabularies/catalog.py
M plone/app/vocabularies/images.py
M plone/app/vocabularies/principals.py
M plone/app/vocabularies/terms.py
M plone/app/vocabularies/tests/test_principals.py
M plone/app/vocabularies/tests/test_subjects_under_context.py
M plone/app/vocabularies/tests/test_vocabularies.py
M plone/app/vocabularies/users.py
M plone/app/vocabularies/workflow.py

b'diff --git a/plone/app/vocabularies/__init__.py b/plone/app/vocabularies/__init__.py\nindex a61b33f..d718a96 100644\n--- a/plone/app/vocabularies/__init__.py\n+++ b/plone/app/vocabularies/__init__.py\n@@ -1,11 +1,12 @@\n from plone.app.vocabularies.interfaces import IPermissiveVocabulary\n from plone.app.vocabularies.interfaces import ISlicableVocabulary\n-from six.moves import urllib\n from zope.interface import directlyProvides\n from zope.interface import implementer\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n+import urllib\n+\n \n _token_parse_py3 = getattr(urllib, "parse", None)\n _token_parse_py27 = lambda token: urllib.unquote_plus(token).decode("utf8")\ndiff --git a/plone/app/vocabularies/catalog.py b/plone/app/vocabularies/catalog.py\nindex a794388..ed19dec 100644\n--- a/plone/app/vocabularies/catalog.py\n+++ b/plone/app/vocabularies/catalog.py\n@@ -28,7 +28,6 @@\n import itertools\n import json\n import os\n-import six\n import warnings\n \n \n@@ -362,8 +361,6 @@ def getTerm(self, value):\n             if brain.is_folderish:\n                 browse_token = value\n             parent_token = "/".join(value.split("/")[:-1])\n-        if six.PY2 and isinstance(title, bytes):\n-            title = title.decode(self.context.encoding)\n         return BrowsableTerm(\n             value,\n             token=token,\n@@ -451,7 +448,7 @@ class KeywordsVocabulary:\n     True\n \n     Testing unicode vocabularies\n-    First clear the index. Comparing non-six.text_type to six.text_type objects fails.\n+    First clear the index. Comparing bytes to str objects fails.\n     >>> index.clear()\n     >>> done = index._index_object(\n     ...     1,\ndiff --git a/plone/app/vocabularies/images.py b/plone/app/vocabularies/images.py\nindex a08616f..d8c042c 100644\n--- a/plone/app/vocabularies/images.py\n+++ b/plone/app/vocabularies/images.py\n@@ -5,8 +5,6 @@\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n-import six\n-\n \n PMF = MessageFactory("plone")\n \ndiff --git a/plone/app/vocabularies/principals.py b/plone/app/vocabularies/principals.py\nindex b43d4dd..8aee569 100644\n--- a/plone/app/vocabularies/principals.py\n+++ b/plone/app/vocabularies/principals.py\n@@ -233,9 +233,7 @@ def term_triples():\n                     ).append(info)\n                 for principal_id, types_infos in infotree.items():\n                     if len(types_infos) > 1 and not cfg["prefix"]:\n-                        raise ValueError(\n-                            f"Principal ID not unique: {principal_id}"\n-                        )\n+                        raise ValueError(f"Principal ID not unique: {principal_id}")\n                     for principal_type, principal_infos in types_infos.items():\n                         value = principal_id\n                         info = merge_principal_infos(principal_infos)\ndiff --git a/plone/app/vocabularies/terms.py b/plone/app/vocabularies/terms.py\nindex d40d2f8..3776f9b 100644\n--- a/plone/app/vocabularies/terms.py\n+++ b/plone/app/vocabularies/terms.py\n@@ -86,9 +86,7 @@ def __init__(\n         browse_token=None,\n         parent_token=None,\n     ):\n-        super().__init__(\n-            value, token=token, title=title, description=description\n-        )\n+        super().__init__(value, token=token, title=title, description=description)\n         self.browse_token = browse_token\n         self.parent_token = parent_token\n         if browse_token is not None or parent_token is not None:\ndiff --git a/plone/app/vocabularies/tests/test_principals.py b/plone/app/vocabularies/tests/test_principals.py\nindex 6592bcb..e93bf81 100644\n--- a/plone/app/vocabularies/tests/test_principals.py\n+++ b/plone/app/vocabularies/tests/test_principals.py\n@@ -1,6 +1,6 @@\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n-\n from unittest import mock\n+\n import unittest\n \n \ndiff --git a/plone/app/vocabularies/tests/test_subjects_under_context.py b/plone/app/vocabularies/tests/test_subjects_under_context.py\nindex dd495dd..81f2227 100644\n--- a/plone/app/vocabularies/tests/test_subjects_under_context.py\n+++ b/plone/app/vocabularies/tests/test_subjects_under_context.py\n@@ -1,8 +1,8 @@\n from plone.app.layout.navigation.interfaces import INavigationRoot\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n+from unittest import mock\n from zope.interface import alsoProvides\n \n-from unittest import mock\n import unittest\n \n \ndiff --git a/plone/app/vocabularies/tests/test_vocabularies.py b/plone/app/vocabularies/tests/test_vocabularies.py\nindex 74e827f..eb587c9 100644\n--- a/plone/app/vocabularies/tests/test_vocabularies.py\n+++ b/plone/app/vocabularies/tests/test_vocabularies.py\n@@ -6,7 +6,6 @@\n \n import doctest\n import re\n-import six\n import unittest\n import zope.component\n \ndiff --git a/plone/app/vocabularies/users.py b/plone/app/vocabularies/users.py\nindex 55895de..5bee2b8 100644\n--- a/plone/app/vocabularies/users.py\n+++ b/plone/app/vocabularies/users.py\n@@ -1,4 +1,3 @@\n-# KEPT HERE FOR BBB UNTIL PLONE 6\n from Products.CMFCore.utils import getToolByName\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n from zope.browser.interfaces import ITerms\n@@ -8,7 +7,6 @@\n from zope.schema.interfaces import ISource\n from zope.schema.vocabulary import SimpleTerm\n \n-import six\n import warnings\n import zope.deferredimport\n \n@@ -35,9 +33,7 @@ def _createUserTerm(userid, context=None, acl_users=None):\n     fullname = userid\n     if user:\n         fullname = user.getProperty("fullname", None) or userid\n-    token = (\n-        userid.encode("unicode_escape") if isinstance(userid, str) else userid\n-    )\n+    token = userid.encode("unicode_escape") if isinstance(userid, str) else userid\n     return SimpleTerm(userid, token, fullname)\n \n \ndiff --git a/plone/app/vocabularies/workflow.py b/plone/app/vocabularies/workflow.py\nindex 53179ac..b05bfe7 100644\n--- a/plone/app/vocabularies/workflow.py\n+++ b/plone/app/vocabularies/workflow.py\n@@ -21,7 +21,6 @@ class WorkflowsVocabulary:\n     >>> from zope.component import queryUtility\n     >>> from plone.app.vocabularies.tests.base import create_context\n     >>> from plone.app.vocabularies.tests.base import DummyTool\n-    >>> import six\n \n     >>> name = \'plone.app.vocabularies.Workflows\'\n     >>> util = queryUtility(IVocabularyFactory, name)\n@@ -53,7 +52,6 @@ class WorkflowsVocabulary:\n \n     >>> noticias = workflows.by_token[\'noticias\']\n     >>> title = \'Workflow de Not\xc3\xadcias\'\n-    >>> title = title.decode(\'utf-8\') if six.PY2 else title\n     >>> noticias.title == title\n     True\n     """\n@@ -80,7 +78,6 @@ class WorkflowStatesVocabulary:\n     >>> from zope.component import queryUtility\n     >>> from plone.app.vocabularies.tests.base import create_context\n     >>> from plone.app.vocabularies.tests.base import DummyTool\n-    >>> import six\n \n     >>> name = \'plone.app.vocabularies.WorkflowStates\'\n     >>> util = queryUtility(IVocabularyFactory, name)\n@@ -107,7 +104,6 @@ class WorkflowStatesVocabulary:\n \n     >>> rev = states.by_token[\'revisao\']\n     >>> title = \'Revis\xc3\xa3o [revisao]\'\n-    >>> title = title.decode(\'utf-8\') if six.PY2 else title\n     >>> rev.title == title\n     True\n     """\n'

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2022-08-18T14:15:20+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.vocabularies/commit/e64dac4d61451a4132049fc326b9ab13fe8bf945

Merge branch 'master' into remove-bbb-update

Files changed:


b''

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2022-08-18T17:03:56+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.vocabularies/commit/56d426387972c1dbee7b7ae166cedda16a7d8ae8

remove dependency on CMFPlone for images vocabulary

Files changed:
M plone/app/vocabularies/images.py

b'diff --git a/plone/app/vocabularies/images.py b/plone/app/vocabularies/images.py\nindex d8c042c..0bc9c7d 100644\n--- a/plone/app/vocabularies/images.py\n+++ b/plone/app/vocabularies/images.py\n@@ -1,11 +1,11 @@\n-from Products.CMFPlone.utils import getAllowedSizes\n+from plone.namedfile.interfaces import IAvailableSizes\n+from zope.component import getUtility\n from zope.i18nmessageid import MessageFactory\n from zope.interface import provider\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n-\n PMF = MessageFactory("plone")\n \n \n@@ -13,9 +13,9 @@\n def ScalesVocabulary(context):\n     """Obtains available scales from registry"""\n     terms = []\n-    allowedSizes = getAllowedSizes()\n-    if allowedSizes is not None:\n-        for scale, (width, height) in getAllowedSizes().items():\n+    available_sizes = getUtility(IAvailableSizes)()\n+    if available_sizes is not None:\n+        for scale, (width, height) in available_sizes.items():\n             translated = PMF(\n                 f"imagescale_{scale:s}",\n                 default=f"{scale:s} ${{width}}x${{height}}",\n'

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2022-08-18T17:11:29+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.vocabularies/commit/56d51f9744e92d4722e22fb2bc6876ef2725b808

add changelog

Files changed:
A news/72.feature

b'diff --git a/news/72.feature b/news/72.feature\nnew file mode 100644\nindex 0000000..1348044\n--- /dev/null\n+++ b/news/72.feature\n@@ -0,0 +1,6 @@\n+Remove dependency on CMFPlone (use plone.base).\n+In images vocab use utility instead of import.\n+isort/black (pure) and pyupgrade --py37-plus`.\n+Remove traces of six.\n+Bump version to 5.0.\n+[jensens]\n'

Repository: plone.app.vocabularies


Branch: refs/heads/master
Date: 2022-08-19T00:39:35+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.vocabularies/commit/8c112c097a11f1533a63e3e7352aa0d8e9d90b15

Merge pull request #72 from plone/remove-bbb-update

Use plone.base and other updates

Files changed:
A news/72.feature
M plone/__init__.py
M plone/app/__init__.py
M plone/app/vocabularies/__init__.py
M plone/app/vocabularies/actions.py
M plone/app/vocabularies/catalog.py
M plone/app/vocabularies/datetimerelated.py
M plone/app/vocabularies/editors.py
M plone/app/vocabularies/groups.py
M plone/app/vocabularies/images.py
M plone/app/vocabularies/interfaces.py
M plone/app/vocabularies/language.py
M plone/app/vocabularies/metadatafields.py
M plone/app/vocabularies/principals.py
M plone/app/vocabularies/security.py
M plone/app/vocabularies/skins.py
M plone/app/vocabularies/syndication.py
M plone/app/vocabularies/terms.py
M plone/app/vocabularies/testing.py
M plone/app/vocabularies/tests/__init__.py
M plone/app/vocabularies/tests/base.py
M plone/app/vocabularies/tests/test_editors.py
M plone/app/vocabularies/tests/test_imagesvocabularies.py
M plone/app/vocabularies/tests/test_principals.py
M plone/app/vocabularies/tests/test_subjects_under_context.py
M plone/app/vocabularies/tests/test_timezonevocabularies.py
M plone/app/vocabularies/tests/test_vocabularies.py
M plone/app/vocabularies/types.py
M plone/app/vocabularies/users.py
M plone/app/vocabularies/utils.py
M plone/app/vocabularies/workflow.py
M pyproject.toml
M setup.cfg
M setup.py

b'diff --git a/news/72.feature b/news/72.feature\nnew file mode 100644\nindex 0000000..1348044\n--- /dev/null\n+++ b/news/72.feature\n@@ -0,0 +1,6 @@\n+Remove dependency on CMFPlone (use plone.base).\n+In images vocab use utility instead of import.\n+isort/black (pure) and pyupgrade --py37-plus`.\n+Remove traces of six.\n+Bump version to 5.0.\n+[jensens]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 68c04af..5284146 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/vocabularies/__init__.py b/plone/app/vocabularies/__init__.py\nindex ccb2639..d718a96 100644\n--- a/plone/app/vocabularies/__init__.py\n+++ b/plone/app/vocabularies/__init__.py\n@@ -1,20 +1,20 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies.interfaces import IPermissiveVocabulary\n from plone.app.vocabularies.interfaces import ISlicableVocabulary\n-from six.moves import urllib\n from zope.interface import directlyProvides\n from zope.interface import implementer\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n+import urllib\n \n-_token_parse_py3 = getattr(urllib, \'parse\', None)\n-_token_parse_py27 = lambda token: urllib.unquote_plus(token).decode(\'utf8\')\n+\n+_token_parse_py3 = getattr(urllib, "parse", None)\n+_token_parse_py27 = lambda token: urllib.unquote_plus(token).decode("utf8")\n parse = _token_parse_py3.unquote if _token_parse_py3 else _token_parse_py27\n \n \n @implementer(ISlicableVocabulary)\n-class SlicableVocabulary(object):\n+class SlicableVocabulary:\n     """\n     A tokenized vocabulary in which the results can be sliced.\n     This class does not implement a complete vocabulary. Instead you use\n@@ -60,7 +60,7 @@ def getTermByToken(self, token):\n         pseudo-validation (which is broken for a permissive vocabulary).\n         """\n         try:\n-            v = super(PermissiveVocabulary, self).getTermByToken(token)\n+            v = super().getTermByToken(token)\n         except LookupError:\n             # fallback using dummy term, assumes token==value\n             return SimpleTerm(token, title=parse(token))\ndiff --git a/plone/app/vocabularies/actions.py b/plone/app/vocabularies/actions.py\nindex c2b3f10..d3838e4 100644\n--- a/plone/app/vocabularies/actions.py\n+++ b/plone/app/vocabularies/actions.py\n@@ -1,6 +1,5 @@\n-# -*- coding:utf-8 -*-\n+from plone.base import PloneMessageFactory as _\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone import PloneMessageFactory as _\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n@@ -8,11 +7,11 @@\n \n \n @implementer(IVocabularyFactory)\n-class ActionCategoriesVocabulary(object):\n+class ActionCategoriesVocabulary:\n     """Provides an actions categories vocabulary"""\n \n     def __call__(self, context):\n-        portal_actions = getToolByName(context, \'portal_actions\')\n+        portal_actions = getToolByName(context, "portal_actions")\n \n         # Building the list of action categories\n         try:\n@@ -29,15 +28,15 @@ def __call__(self, context):\n \n \n @implementer(IVocabularyFactory)\n-class PortalActionCategoriesVocabulary(object):\n+class PortalActionCategoriesVocabulary:\n     """Provides portal action categories vocabulary."""\n \n     def __call__(self, context):\n-        portal_actions = getToolByName(context, \'portal_actions\')\n+        portal_actions = getToolByName(context, "portal_actions")\n         categories = portal_actions.objectIds()\n         terms = []\n         for category in sorted(categories):\n-            if category == \'controlpanel\':\n+            if category == "controlpanel":\n                 continue\n             title = portal_actions.get(category).title\n             if title:\n@@ -47,4 +46,5 @@ def __call__(self, context):\n             terms.append(SimpleTerm(category, title=title))\n         return SimpleVocabulary(terms)\n \n+\n PortalActionCategoriesVocabularyFactory = PortalActionCategoriesVocabulary()\ndiff --git a/plone/app/vocabularies/catalog.py b/plone/app/vocabularies/catalog.py\nindex a006e9e..ed19dec 100644\n--- a/plone/app/vocabularies/catalog.py\n+++ b/plone/app/vocabularies/catalog.py\n@@ -1,22 +1,22 @@\n-# -*- coding: utf-8 -*-\n from BTrees.IIBTree import intersection\n from plone.app.layout.navigation.root import getNavigationRootObject\n from plone.app.vocabularies import SlicableVocabulary\n from plone.app.vocabularies.terms import BrowsableTerm\n-from plone.app.vocabularies.terms import safe_encode\n from plone.app.vocabularies.terms import safe_simplevocabulary_from_values\n from plone.app.vocabularies.utils import parseQueryString\n-from plone.memoize.instance import memoize\n+from plone.base.utils import safe_text\n from plone.memoize import request\n+from plone.memoize.instance import memoize\n from plone.registry.interfaces import IRegistry\n from plone.uuid.interfaces import IUUID\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.utils import safe_unicode\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n from Products.ZCTextIndex.ParseTree import ParseError\n from z3c.formwidget.query.interfaces import IQuerySource\n from zope.browser.interfaces import ITerms\n from zope.component import queryUtility\n+from zope.component.hooks import getSite\n+from zope.globalrequest import getRequest\n from zope.interface import implementer\n from zope.interface import provider\n from zope.schema.interfaces import IContextSourceBinder\n@@ -24,18 +24,10 @@\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n-from zope.component.hooks import getSite\n-\n-try:\n-    from zope.globalrequest import getRequest\n-except ImportError:\n-    def getRequest():\n-        return None\n \n import itertools\n import json\n import os\n-import six\n import warnings\n \n \n@@ -48,143 +40,142 @@ class ISourceQueryView(Interface):\n         pass\n \n \n-def parse_query(query, path_prefix=\'\'):\n-    """ Parse the query string and turn it into a dictionary for querying the\n-        catalog.\n+def parse_query(query, path_prefix=""):\n+    """Parse the query string and turn it into a dictionary for querying the\n+    catalog.\n \n-        We want to find anything which starts with the given string, so we add\n-        a * at the end of words.\n+    We want to find anything which starts with the given string, so we add\n+    a * at the end of words.\n \n-        >>> parse_query(\'foo\')\n-        {\'SearchableText\': \'foo*\'}\n+    >>> parse_query(\'foo\')\n+    {\'SearchableText\': \'foo*\'}\n \n-        If we have more than one word, each of them should have the * and\n-        they should be combined with the AND operator.\n+    If we have more than one word, each of them should have the * and\n+    they should be combined with the AND operator.\n \n-        >>> parse_query(\'foo bar\')\n-        {\'SearchableText\': \'foo* AND bar*\'}\n+    >>> parse_query(\'foo bar\')\n+    {\'SearchableText\': \'foo* AND bar*\'}\n \n-        We also filter out some special characters. They are handled like\n-        spaces and seperate words from each other.\n+    We also filter out some special characters. They are handled like\n+    spaces and seperate words from each other.\n \n-        >>> parse_query(\'foo +bar some-thing\')\n-        {\'SearchableText\': \'foo* AND bar* AND some* AND thing*\'}\n+    >>> parse_query(\'foo +bar some-thing\')\n+    {\'SearchableText\': \'foo* AND bar* AND some* AND thing*\'}\n \n-        >>> parse_query(\'what? (spam) *ham\')\n-        {\'SearchableText\': \'what* AND spam* AND ham*\'}\n+    >>> parse_query(\'what? (spam) *ham\')\n+    {\'SearchableText\': \'what* AND spam* AND ham*\'}\n \n-        You can also limit searches to paths, if you only supply the path,\n-        then all contents of that folder will be searched. If you supply\n-        additional search words, then all subfolders are searched as well.\n+    You can also limit searches to paths, if you only supply the path,\n+    then all contents of that folder will be searched. If you supply\n+    additional search words, then all subfolders are searched as well.\n \n-        >>> expected = {\'path\': {\'query\': \'/dummy\', \'depth\': 1}}\n-        >>> parse_query(\'path:/dummy\') == expected\n-        True\n+    >>> expected = {\'path\': {\'query\': \'/dummy\', \'depth\': 1}}\n+    >>> parse_query(\'path:/dummy\') == expected\n+    True\n \n-        >>> expected = {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'bar*\'}\n-        >>> parse_query(\'bar path:/dummy\') == expected\n-        True\n+    >>> expected = {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'bar*\'}\n+    >>> parse_query(\'bar path:/dummy\') == expected\n+    True\n \n-        >>> expected = {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'foo*\'}\n-        >>> parse_query(\'path:/dummy foo\') == expected\n-        True\n+    >>> expected = {\'path\': {\'query\': \'/dummy\'}, \'SearchableText\': \'foo*\'}\n+    >>> parse_query(\'path:/dummy foo\') == expected\n+    True\n \n-        If you supply more then one path, then only the last one is used.\n+    If you supply more then one path, then only the last one is used.\n \n-        >>> expected = {\'path\': {\'query\': \'/spam\', \'depth\': 1}}\n-        >>> parse_query(\'path:/dummy path:/spam\') == expected\n-        True\n+    >>> expected = {\'path\': {\'query\': \'/spam\', \'depth\': 1}}\n+    >>> parse_query(\'path:/dummy path:/spam\') == expected\n+    True\n \n-        You can also provide a prefix for the path. This is useful for virtual\n-        hosting.\n+    You can also provide a prefix for the path. This is useful for virtual\n+    hosting.\n \n-        >>> expected = {\'path\': {\'query\': \'/portal/dummy\', \'depth\': 1}}\n-        >>> parse_query(\'path:/dummy\', path_prefix=\'/portal\') == expected\n-        True\n+    >>> expected = {\'path\': {\'query\': \'/portal/dummy\', \'depth\': 1}}\n+    >>> parse_query(\'path:/dummy\', path_prefix=\'/portal\') == expected\n+    True\n \n     """\n     query_parts = query.split()\n-    query = {\'SearchableText\': []}\n+    query = {"SearchableText": []}\n     for part in query_parts:\n-        if part.startswith(\'path:\'):\n+        if part.startswith("path:"):\n             path = part[5:]\n-            query[\'path\'] = {\'query\': path}\n+            query["path"] = {"query": path}\n         else:\n-            query[\'SearchableText\'].append(part)\n-    text = \' \'.join(query[\'SearchableText\'])\n-    for char in \'?-+*()\':\n-        text = text.replace(char, \' \')\n-    query[\'SearchableText\'] = \' AND \'.join(x + \'*\' for x in text.split())\n-    if \'path\' in query:\n-        if query[\'SearchableText\'] == \'\':\n-            del query[\'SearchableText\']\n-            query[\'path\'][\'depth\'] = 1\n-        query[\'path\'][\'query\'] = path_prefix + query[\'path\'][\'query\']\n+            query["SearchableText"].append(part)\n+    text = " ".join(query["SearchableText"])\n+    for char in "?-+*()":\n+        text = text.replace(char, " ")\n+    query["SearchableText"] = " AND ".join(x + "*" for x in text.split())\n+    if "path" in query:\n+        if query["SearchableText"] == "":\n+            del query["SearchableText"]\n+            query["path"]["depth"] = 1\n+        query["path"]["query"] = path_prefix + query["path"]["query"]\n     return query\n \n \n @implementer(ISource)\n @provider(IContextSourceBinder)\n-class SearchableTextSource(object):\n+class SearchableTextSource:\n     """\n-      >>> from plone.app.vocabularies.tests.base import Brain\n-      >>> from plone.app.vocabularies.tests.base import DummyCatalog\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import Brain\n+    >>> from plone.app.vocabularies.tests.base import DummyCatalog\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n \n-      >>> context = create_context()\n+    >>> context = create_context()\n \n-      >>> catalog = DummyCatalog((\'/1234\', \'/2345\'))\n-      >>> context.portal_catalog = catalog\n+    >>> catalog = DummyCatalog((\'/1234\', \'/2345\'))\n+    >>> context.portal_catalog = catalog\n \n-      >>> tool = DummyTool(\'portal_url\')\n-      >>> def getPortalPath():\n-      ...     return \'/\'\n-      >>> tool.getPortalPath = getPortalPath\n-      >>> context.portal_url = tool\n+    >>> tool = DummyTool(\'portal_url\')\n+    >>> def getPortalPath():\n+    ...     return \'/\'\n+    >>> tool.getPortalPath = getPortalPath\n+    >>> context.portal_url = tool\n \n-      >>> source = SearchableTextSource(context)\n-      >>> source\n-      <plone.app.vocabularies.catalog.SearchableTextSource object at ...>\n+    >>> source = SearchableTextSource(context)\n+    >>> source\n+    <plone.app.vocabularies.catalog.SearchableTextSource object at ...>\n \n-      >>> \'1234\' in source, \'1\' in source\n-      (True, False)\n+    >>> \'1234\' in source, \'1\' in source\n+    (True, False)\n \n-      >>> source.search(\'\')\n-      []\n+    >>> source.search(\'\')\n+    []\n \n-      >>> source.search(\'error\')\n-      []\n+    >>> source.search(\'error\')\n+    []\n \n-      >>> source.search(\'foo\')\n-      <generator object ...>\n+    >>> source.search(\'foo\')\n+    <generator object ...>\n \n-      >>> list(source.search(\'foo\'))\n-      [\'1234\', \'2345\']\n+    >>> list(source.search(\'foo\'))\n+    [\'1234\', \'2345\']\n \n-      >>> list(source.search(\'bar path:/dummy\'))\n-      [\'/dummy\', \'1234\', \'2345\']\n+    >>> list(source.search(\'bar path:/dummy\'))\n+    [\'/dummy\', \'1234\', \'2345\']\n \n-      >>> u\'\' in source\n-      True\n+    >>> u\'\' in source\n+    True\n \n-      >>> source = SearchableTextSource(context, default_query=\'default\')\n-      >>> list(source.search(\'\'))\n-      [\'1234\', \'2345\']\n+    >>> source = SearchableTextSource(context, default_query=\'default\')\n+    >>> list(source.search(\'\'))\n+    [\'1234\', \'2345\']\n     """\n \n     def __init__(self, context, base_query={}, default_query=None):\n         self.context = context\n         self.base_query = base_query\n         self.default_query = default_query\n-        self.catalog = getToolByName(context, \'portal_catalog\')\n-        self.portal_tool = getToolByName(context, \'portal_url\')\n+        self.catalog = getToolByName(context, "portal_catalog")\n+        self.portal_tool = getToolByName(context, "portal_url")\n         self.portal_path = self.portal_tool.getPortalPath()\n-        self.encoding = \'utf-8\'\n+        self.encoding = "utf-8"\n \n     def __contains__(self, value):\n-        """Return whether the value is available in this source\n-        """\n+        """Return whether the value is available in this source"""\n         if not value:\n             return True\n         elif self.catalog.getrid(self.portal_path + value) is None:\n@@ -193,7 +184,7 @@ def __contains__(self, value):\n \n     def search(self, query_string):\n         query = self.base_query.copy()\n-        if query_string == \'\':\n+        if query_string == "":\n             if self.default_query is not None:\n                 query.update(parse_query(self.default_query, self.portal_path))\n             else:\n@@ -203,21 +194,20 @@ def search(self, query_string):\n \n         try:\n             results = (\n-                x.getPath()[len(self.portal_path):]\n-                for x in self.catalog(**query)\n+                x.getPath()[len(self.portal_path) :] for x in self.catalog(**query)\n             )\n         except ParseError:\n             return []\n \n-        if \'path\' in query:\n-            path = query[\'path\'][\'query\'][len(self.portal_path):]\n-            if path != \'\':\n-                return itertools.chain((path, ), results)\n+        if "path" in query:\n+            path = query["path"]["query"][len(self.portal_path) :]\n+            if path != "":\n+                return itertools.chain((path,), results)\n         return results\n \n \n @implementer(IContextSourceBinder)\n-class SearchableTextSourceBinder(object):\n+class SearchableTextSourceBinder:\n     """Use this to instantiate a new SearchableTextSource with custom\n     parameters. For example:\n \n@@ -267,83 +257,86 @@ def __init__(self, query, default_query=None):\n         self.default_query = default_query\n \n     def __call__(self, context):\n-        return SearchableTextSource(context, base_query=self.query.copy(),\n-                                    default_query=self.default_query)\n+        return SearchableTextSource(\n+            context, base_query=self.query.copy(), default_query=self.default_query\n+        )\n \n \n @implementer(ITerms, ISourceQueryView)\n-class QuerySearchableTextSourceView(object):\n+class QuerySearchableTextSourceView:\n     """\n-      >>> from plone.app.vocabularies.tests.base import DummyCatalog\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> from plone.app.vocabularies.tests.base import Request\n+    >>> from plone.app.vocabularies.tests.base import DummyCatalog\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import Request\n \n-      >>> context = create_context()\n+    >>> context = create_context()\n \n-      >>> rids = (\'/1234\', \'/2345\', \'/dummy/1234\')\n-      >>> tool = DummyCatalog(rids)\n-      >>> context.portal_catalog = tool\n+    >>> rids = (\'/1234\', \'/2345\', \'/dummy/1234\')\n+    >>> tool = DummyCatalog(rids)\n+    >>> context.portal_catalog = tool\n \n-      >>> tool = DummyTool(\'portal_url\')\n-      >>> def getPortalPath():\n-      ...     return \'/dummy\'\n-      >>> tool.getPortalPath = getPortalPath\n-      >>> context.portal_url = tool\n+    >>> tool = DummyTool(\'portal_url\')\n+    >>> def getPortalPath():\n+    ...     return \'/dummy\'\n+    >>> tool.getPortalPath = getPortalPath\n+    >>> context.portal_url = tool\n \n-      >>> source = SearchableTextSource(context)\n-      >>> source\n-      <plone.app.vocabularies.catalog.SearchableTextSource object at ...>\n+    >>> source = SearchableTextSource(context)\n+    >>> source\n+    <plone.app.vocabularies.catalog.SearchableTextSource object at ...>\n \n-      >>> view = QuerySearchableTextSourceView(source, Request())\n-      >>> view\n-      <plone.app.vocabularies.catalog.QuerySearchableTextSourceView object ...>\n+    >>> view = QuerySearchableTextSourceView(source, Request())\n+    >>> view\n+    <plone.app.vocabularies.catalog.QuerySearchableTextSourceView object ...>\n \n-      >>> view.getValue(\'a\')\n-      Traceback (most recent call last):\n-      ...\n-      LookupError: a\n+    >>> view.getValue(\'a\')\n+    Traceback (most recent call last):\n+    ...\n+    LookupError: a\n \n-      >>> view.getValue(\'/1234\')\n-      \'/1234\'\n+    >>> view.getValue(\'/1234\')\n+    \'/1234\'\n \n-      >>> view.getTerm(None) is None\n-      True\n+    >>> view.getTerm(None) is None\n+    True\n \n-      >>> view.getTerm(\'1234\')\n-      <plone.app.vocabularies.terms.BrowsableTerm object at ...>\n+    >>> view.getTerm(\'1234\')\n+    <plone.app.vocabularies.terms.BrowsableTerm object at ...>\n \n-      >>> view.getTerm(\'/1234\')\n-      <plone.app.vocabularies.terms.BrowsableTerm object at ...>\n+    >>> view.getTerm(\'/1234\')\n+    <plone.app.vocabularies.terms.BrowsableTerm object at ...>\n \n-      >>> template = view.render(name=\'t\')\n-      >>> u\'<input type="text" name="t.query" value="" />\' in template\n-      True\n+    >>> template = view.render(name=\'t\')\n+    >>> u\'<input type="text" name="t.query" value="" />\' in template\n+    True\n \n-      >>> u\'<input type="submit" name="t.search" value="Search" />\' in template\n-      True\n+    >>> u\'<input type="submit" name="t.search" value="Search" />\' in template\n+    True\n \n-      >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n-      >>> view = QuerySearchableTextSourceView(source, request)\n-      >>> sorted(view.results(\'t\'))\n-      [\'\', \'\', \'/1234\']\n+    >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n+    >>> view = QuerySearchableTextSourceView(source, request)\n+    >>> sorted(view.results(\'t\'))\n+    [\'\', \'\', \'/1234\']\n \n-      >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\',\n-      ...                         \'t.browse.foo\' : \'/foo\'})\n-      >>> view = QuerySearchableTextSourceView(source, request)\n-      >>> sorted(view.results(\'t\'))\n-      [\'\', \'\', \'/1234\', \'foo\']\n+    >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\',\n+    ...                         \'t.browse.foo\' : \'/foo\'})\n+    >>> view = QuerySearchableTextSourceView(source, request)\n+    >>> sorted(view.results(\'t\'))\n+    [\'\', \'\', \'/1234\', \'foo\']\n \n-      Titles need to be unicode:\n-      >>> view.getTerm(list(view.results(\'t\'))[0]).title\n-      u\'/foo\'\n+    Titles need to be unicode:\n+    >>> view.getTerm(list(view.results(\'t\'))[0]).title\n+    u\'/foo\'\n     """\n \n-    template = ViewPageTemplateFile(\'searchabletextsource.pt\')\n+    template = ViewPageTemplateFile("searchabletextsource.pt")\n \n     def __init__(self, context, request):\n-        msg = \'QuerySearchableTextSourceView is deprecated and will be \' \\\n-              \'removed on Plone 6\'\n+        msg = (\n+            "QuerySearchableTextSourceView is deprecated and will be "\n+            "removed on Plone 6"\n+        )\n         warnings.warn(msg, DeprecationWarning)\n         self.context = context\n         self.request = request\n@@ -351,9 +344,8 @@ def __init__(self, context, request):\n     def getTerm(self, value):\n         if not value:\n             return None\n-        if (not self.context.portal_path.endswith(\'/\')) \\\n-                and (not value.startswith(\'/\')):\n-            value = \'/\' + value\n+        if (not self.context.portal_path.endswith("/")) and (not value.startswith("/")):\n+            value = "/" + value\n         # get rid for path\n         rid = self.context.catalog.getrid(self.context.portal_path + value)\n         # first some defaults\n@@ -368,14 +360,15 @@ def getTerm(self, value):\n             # title = brain.Title\n             if brain.is_folderish:\n                 browse_token = value\n-            parent_token = \'/\'.join(value.split(\'/\')[:-1])\n-        if six.PY2 and isinstance(title, six.binary_type):\n-            title = title.decode(self.context.encoding)\n-        return BrowsableTerm(value, token=token,\n-                             title=title,\n-                             description=value,\n-                             browse_token=browse_token,\n-                             parent_token=parent_token)\n+            parent_token = "/".join(value.split("/")[:-1])\n+        return BrowsableTerm(\n+            value,\n+            token=token,\n+            title=title,\n+            description=value,\n+            browse_token=browse_token,\n+            parent_token=parent_token,\n+        )\n \n     def getValue(self, token):\n         if token not in self.context:\n@@ -386,24 +379,23 @@ def render(self, name):\n         return self.template(name=name)\n \n     def results(self, name):\n-        query = \'\'\n+        query = ""\n \n         # check whether the normal search button was pressed\n-        if name + \'.search\' in self.request.form:\n-            query_fieldname = name + \'.query\'\n+        if name + ".search" in self.request.form:\n+            query_fieldname = name + ".query"\n             if query_fieldname in self.request.form:\n                 query = self.request.form[query_fieldname]\n \n         # check whether a browse button was pressed\n-        browse_prefix = name + \'.browse.\'\n-        browse = tuple(x for x in self.request.form\n-                       if x.startswith(browse_prefix))\n+        browse_prefix = name + ".browse."\n+        browse = tuple(x for x in self.request.form if x.startswith(browse_prefix))\n         if len(browse) == 1:\n-            path = browse[0][len(browse_prefix):]\n-            query = \'path:\' + path\n+            path = browse[0][len(browse_prefix) :]\n+            query = "path:" + path\n             results = self.context.search(query)\n-            if name + \'.omitbrowsedfolder\' in self.request.form:\n-                results = six.moves.filter(lambda x: x != path, results)\n+            if name + ".omitbrowsedfolder" in self.request.form:\n+                results = filter(lambda x: x != path, results)\n         else:\n             results = self.context.search(query)\n \n@@ -411,97 +403,96 @@ def results(self, name):\n \n \n @implementer(IVocabularyFactory)\n-class KeywordsVocabulary(object):\n-    u"""Vocabulary factory listing all catalog keywords from the \'Subject\' index\n-\n-        >>> from plone.app.vocabularies.tests.base import DummyCatalog\n-        >>> from plone.app.vocabularies.tests.base import create_context\n-        >>> from plone.app.vocabularies.tests.base import DummyContent\n-        >>> from plone.app.vocabularies.tests.base import Request\n-        >>> from Products.PluginIndexes.KeywordIndex.KeywordIndex import KeywordIndex  # noqa\n-\n-        >>> context = create_context()\n-\n-        First test bytes vocabularies\n-        >>> rids = (\'/1234\', \'/2345\', \'/dummy/1234\')\n-        >>> tool = DummyCatalog(rids)\n-        >>> context.portal_catalog = tool\n-        >>> index = KeywordIndex(\'Subject\')\n-        >>> done = index._index_object(\n-        ...     1,\n-        ...     DummyContent(\'ob1\', [b\'foo\', b\'bar\', b\'baz\']), attr=\'Subject\'\n-        ... )\n-        >>> done = index._index_object(\n-        ...     2,\n-        ...     DummyContent(\n-        ...         \'ob2\',\n-        ...         [b\'blee\', b\'bar\', u\'non-\xc3\xa5scii\'.encode(\'utf8\')]),\n-        ...         attr=\'Subject\',\n-        ... )\n-        >>> tool.indexes[\'Subject\'] = index\n-        >>> vocab = KeywordsVocabulary()\n-        >>> result = vocab(context)\n-\n-        Value type is kept ...\n-        >>> expected = [b\'bar\', b\'baz\', b\'blee\', b\'foo\', u\'non-\xc3\xa5scii\'.encode(\'utf8\')]\n-        >>> sorted(result.by_value) == expected\n-        True\n-\n-        but tokens are base64 encoded text\n-        >>> expected = [\'YmF6\', \'YmFy\', \'YmxlZQ==\', \'Zm9v\', \'bm9uLcOlc2NpaQ==\']\n-        >>> sorted(result.by_token) == expected\n-        True\n-\n-        >>> result.getTermByToken(expected[-1]).title == u\'non-\xc3\xa5scii\'\n-        True\n-\n-        Testing unicode vocabularies\n-        First clear the index. Comparing non-six.text_type to six.text_type objects fails.\n-        >>> index.clear()\n-        >>> done = index._index_object(\n-        ...     1,\n-        ...     DummyContent(\'obj1\', [u\'\xc3\xa4\xc3\xbc\xc3\xb6\', u\'nix\']), attr=\'Subject\'\n-        ... )\n-        >>> tool.indexes[\'Subject\'] = index\n-        >>> vocab = KeywordsVocabulary()\n-        >>> result = vocab(context)\n-        >>> expected = [\'bml4\', \'w6TDvMO2\']\n-        >>> sorted(result.by_token) == expected\n-        True\n-        >>> set(result.by_value) == {u\'nix\', u\'\xc3\xa4\xc3\xbc\xc3\xb6\'}\n-        True\n-        >>> result.getTermByToken(expected[0]).title == u\'nix\'\n-        True\n+class KeywordsVocabulary:\n+    """Vocabulary factory listing all catalog keywords from the \'Subject\' index\n+\n+    >>> from plone.app.vocabularies.tests.base import DummyCatalog\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyContent\n+    >>> from plone.app.vocabularies.tests.base import Request\n+    >>> from Products.PluginIndexes.KeywordIndex.KeywordIndex import KeywordIndex  # noqa\n+\n+    >>> context = create_context()\n+\n+    First test bytes vocabularies\n+    >>> rids = (\'/1234\', \'/2345\', \'/dummy/1234\')\n+    >>> tool = DummyCatalog(rids)\n+    >>> context.portal_catalog = tool\n+    >>> index = KeywordIndex(\'Subject\')\n+    >>> done = index._index_object(\n+    ...     1,\n+    ...     DummyContent(\'ob1\', [b\'foo\', b\'bar\', b\'baz\']), attr=\'Subject\'\n+    ... )\n+    >>> done = index._index_object(\n+    ...     2,\n+    ...     DummyContent(\n+    ...         \'ob2\',\n+    ...         [b\'blee\', b\'bar\', u\'non-\xc3\xa5scii\'.encode(\'utf8\')]),\n+    ...         attr=\'Subject\',\n+    ... )\n+    >>> tool.indexes[\'Subject\'] = index\n+    >>> vocab = KeywordsVocabulary()\n+    >>> result = vocab(context)\n+\n+    Value type is kept ...\n+    >>> expected = [b\'bar\', b\'baz\', b\'blee\', b\'foo\', u\'non-\xc3\xa5scii\'.encode(\'utf8\')]\n+    >>> sorted(result.by_value) == expected\n+    True\n+\n+    but tokens are base64 encoded text\n+    >>> expected = [\'YmF6\', \'YmFy\', \'YmxlZQ==\', \'Zm9v\', \'bm9uLcOlc2NpaQ==\']\n+    >>> sorted(result.by_token) == expected\n+    True\n+\n+    >>> result.getTermByToken(expected[-1]).title == u\'non-\xc3\xa5scii\'\n+    True\n+\n+    Testing unicode vocabularies\n+    First clear the index. Comparing bytes to str objects fails.\n+    >>> index.clear()\n+    >>> done = index._index_object(\n+    ...     1,\n+    ...     DummyContent(\'obj1\', [u\'\xc3\xa4\xc3\xbc\xc3\xb6\', u\'nix\']), attr=\'Subject\'\n+    ... )\n+    >>> tool.indexes[\'Subject\'] = index\n+    >>> vocab = KeywordsVocabulary()\n+    >>> result = vocab(context)\n+    >>> expected = [\'bml4\', \'w6TDvMO2\']\n+    >>> sorted(result.by_token) == expected\n+    True\n+    >>> set(result.by_value) == {u\'nix\', u\'\xc3\xa4\xc3\xbc\xc3\xb6\'}\n+    True\n+    >>> result.getTermByToken(expected[0]).title == u\'nix\'\n+    True\n \n     """\n+\n     # Allow users to customize the index to easily create\n     # KeywordVocabularies for other keyword indexes\n-    keyword_index = \'Subject\'\n-    path_index = \'path\'\n+    keyword_index = "Subject"\n+    path_index = "path"\n \n     def section(self, context):\n-        """gets section from which subjects are used.\n-        """\n+        """gets section from which subjects are used."""\n         registry = queryUtility(IRegistry)\n         if registry is None:\n             return None\n-        if registry.get(\'plone.subjects_of_navigation_root\', False):\n-            portal = getToolByName(context, \'portal_url\').getPortalObject()\n+        if registry.get("plone.subjects_of_navigation_root", False):\n+            portal = getToolByName(context, "portal_url").getPortalObject()\n             return getNavigationRootObject(context, portal)\n         return None\n \n     def all_keywords(self, kwfilter):\n         site = getSite()\n-        self.catalog = getToolByName(site, \'portal_catalog\', None)\n+        self.catalog = getToolByName(site, "portal_catalog", None)\n         if self.catalog is None:\n             return SimpleVocabulary([])\n         index = self.catalog._catalog.getIndex(self.keyword_index)\n         return safe_simplevocabulary_from_values(index._index, query=kwfilter)\n \n     def keywords_of_section(self, section, kwfilter):\n-        """Valid keywords under the given section.\n-        """\n-        pcat = getToolByName(section, \'portal_catalog\')\n+        """Valid keywords under the given section."""\n+        pcat = getToolByName(section, "portal_catalog")\n         cat = pcat._catalog\n         path_idx = cat.indexes[self.path_index]\n         tags_idx = cat.indexes[self.keyword_index]\n@@ -509,15 +500,15 @@ def keywords_of_section(self, section, kwfilter):\n         # query all oids of path - low level\n         pquery = {\n             self.path_index: {\n-                \'query\': \'/\'.join(section.getPhysicalPath()),\n-                \'depth\': -1,\n+                "query": "/".join(section.getPhysicalPath()),\n+                "depth": -1,\n             }\n         }\n-        kwfilter = safe_encode(kwfilter)\n+        kwfilter = safe_text(kwfilter)\n         # uses internal zcatalog specific details to quickly get the values.\n         path_result, info = path_idx._apply_index(pquery)\n         for tag in tags_idx.uniqueValues():\n-            if kwfilter and kwfilter not in safe_encode(tag):\n+            if kwfilter and kwfilter not in safe_text(tag):\n                 continue\n             tquery = {self.keyword_index: tag}\n             tags_result, info = tags_idx._apply_index(tquery)\n@@ -544,6 +535,7 @@ class CatalogVocabulary(SlicableVocabulary):\n     @classmethod\n     def fromItems(cls, query, context, *interfaces):\n         return cls(query)\n+\n     fromValues = fromItems\n \n     @classmethod\n@@ -556,7 +548,7 @@ def __init__(self, query, *interfaces):\n     @property\n     @memoize\n     def catalog(self):\n-        return getToolByName(getSite(), \'portal_catalog\')\n+        return getToolByName(getSite(), "portal_catalog")\n \n     @property\n     @memoize\n@@ -566,8 +558,8 @@ def brains(self):\n         except ParseError:\n             # a parseError: Query contains only common words may happen,\n             # semantically this means we want all result w/o SearchableText\n-            if \'SearchableText\' in self.query:\n-                del self.query[\'SearchableText\']\n+            if "SearchableText" in self.query:\n+                del self.query["SearchableText"]\n                 return self.catalog(**self.query)\n             raise\n \n@@ -576,13 +568,13 @@ def __iter__(self):\n             yield self.createTerm(brain, None)\n \n     def __contains__(self, value):\n-        if isinstance(value, six.string_types):\n+        if isinstance(value, str):\n             # perhaps it\'s already a uid\n             uid = value\n         else:\n             uid = IUUID(value)\n         query = self.query.copy()\n-        query[\'UID\'] = uid\n+        query["UID"] = uid\n         return len(self.catalog(**query)) > 0\n \n     def __len__(self):\n@@ -593,16 +585,15 @@ def __getitem__(self, index):\n             slice_inst = index\n             start = slice_inst.start\n             stop = slice_inst.stop\n-            return [self.createTerm(brain, None)\n-                    for brain in self.brains[start:stop]]\n+            return [self.createTerm(brain, None) for brain in self.brains[start:stop]]\n         else:\n             return self.createTerm(self.brains[index], None)\n \n     def getTerm(self, value):\n-        if not isinstance(value, six.string_types):\n+        if not isinstance(value, str):\n             # here we have a content and fetch the uuid as hex value\n             value = IUUID(value)\n-        query = {\'UID\': value}\n+        query = {"UID": value}\n         brains = self.catalog(**query)\n         for b in brains:\n             return self.createTerm(b, None)\n@@ -611,7 +602,7 @@ def getTerm(self, value):\n \n \n @implementer(IVocabularyFactory)\n-class CatalogVocabularyFactory(object):\n+class CatalogVocabularyFactory:\n     """\n     Test application of Navigation Root:\n \n@@ -640,6 +631,7 @@ class CatalogVocabularyFactory(object):\n       [\'/dummy/sub-site\', \'/dummy/sub-site/ghij\']\n \n     """\n+\n     # We want to get rid of this and use CatalogSource instead,\n     # but we can\'t in Plone versions that support\n     # plone.app.widgets < 1.6.0\n@@ -647,30 +639,28 @@ class CatalogVocabularyFactory(object):\n     def __call__(self, context, query=None):\n         parsed = {}\n         if query:\n-            parsed = parseQueryString(context, query[\'criteria\'])\n-            if \'sort_on\' in query:\n-                parsed[\'sort_on\'] = query[\'sort_on\']\n-            if \'sort_order\' in query:\n-                parsed[\'sort_order\'] = str(query[\'sort_order\'])\n+            parsed = parseQueryString(context, query["criteria"])\n+            if "sort_on" in query:\n+                parsed["sort_on"] = query["sort_on"]\n+            if "sort_order" in query:\n+                parsed["sort_order"] = str(query["sort_order"])\n \n         # If no path is specified check if we are in a sub-site and use that\n         # as the path root for catalog searches\n-        if \'path\' not in parsed:\n+        if "path" not in parsed:\n             site = getSite()\n             nav_root = getNavigationRootObject(context, site)\n             site_path = site.getPhysicalPath()\n             if nav_root and nav_root.getPhysicalPath() != site_path:\n-                parsed[\'path\'] = {\n-                    \'query\': \'/\'.join(nav_root.getPhysicalPath()),\n-                    \'depth\': -1\n+                parsed["path"] = {\n+                    "query": "/".join(nav_root.getPhysicalPath()),\n+                    "depth": -1,\n                 }\n         return CatalogVocabulary.fromItems(parsed, context)\n \n \n def request_query_cache_key(func, vocab):\n-    return json.dumps([\n-        vocab.query, vocab.text_search_index, vocab.title_template\n-    ])\n+    return json.dumps([vocab.query, vocab.text_search_index, vocab.title_template])\n \n \n @implementer(IQuerySource, IVocabularyFactory)\n@@ -793,11 +783,11 @@ def my_vocab_factory(context):\n        (u\'proto:/site/2345 /site/2345 - BrainTitle /2345\', \'/site/2345\')]\n \n     """\n+\n     title_template = "{brain.Title} ({path})"\n     text_search_index = "SearchableText"\n \n-    def __init__(self, query, text_search_index=None,\n-                 title_template=None):\n+    def __init__(self, query, text_search_index=None, title_template=None):\n         self.query = query\n         if text_search_index:\n             self.text_search_index = text_search_index\n@@ -809,13 +799,13 @@ def __init__(self, query, text_search_index=None,\n     def nav_root_path(self):\n         site = getSite()\n         nav_root = getNavigationRootObject(site, site)\n-        return \'/\'.join(nav_root.getPhysicalPath())\n+        return "/".join(nav_root.getPhysicalPath())\n \n     def get_brain_path(self, brain):\n         nav_root_path = self.nav_root_path\n         path = brain.getPath()\n         if path.startswith(nav_root_path):\n-            path = path[len(nav_root_path):]\n+            path = path[len(nav_root_path) :]\n         return path\n \n     @staticmethod\n@@ -829,11 +819,15 @@ def brains(self):\n \n     def createTerm(self, brain, context=None):\n         return SimpleTerm(\n-            value=brain.UID, token=brain.UID,\n-            title=safe_unicode(self.title_template.format(\n-                brain=brain, path=self.get_brain_path(brain),\n-                url=brain.getURL(),\n-            ))\n+            value=brain.UID,\n+            token=brain.UID,\n+            title=safe_text(\n+                self.title_template.format(\n+                    brain=brain,\n+                    path=self.get_brain_path(brain),\n+                    url=brain.getURL(),\n+                )\n+            ),\n         )\n \n     def search(self, query):\n@@ -847,13 +841,11 @@ def search(self, query):\n         query = {self.text_search_index: query}\n         query.update(self.query)\n         brains = self.catalog(**query)\n-        return SimpleVocabulary([\n-            self.createTerm(b) for b in brains\n-        ])\n+        return SimpleVocabulary([self.createTerm(b) for b in brains])\n \n \n @implementer(ISource)\n-class CatalogSource(object):\n+class CatalogSource:\n     """Catalog source for use with Choice fields.\n \n     When instantiating the source, you can pass keyword arguments\n@@ -905,24 +897,24 @@ def __contains__(self, value):\n         value can be either a string (hex value of uuid or path) or a plone\n         content object.\n         """\n-        if not isinstance(value, six.string_types):\n+        if not isinstance(value, str):\n             # here we have a content and fetch the uuid as hex value\n             value = IUUID(value)\n         # else we have uuid hex value or path\n \n-        if value.startswith(\'/\'):\n+        if value.startswith("/"):\n             # it is a path query\n             site = getSite()\n-            site_path = \'/\'.join(site.getPhysicalPath())\n-            path = os.path.join(site_path, value.lstrip(\'/\'))\n-            query = {\'path\': {\'query\': path, \'depth\': 0}}\n+            site_path = "/".join(site.getPhysicalPath())\n+            path = os.path.join(site_path, value.lstrip("/"))\n+            query = {"path": {"query": path, "depth": 0}}\n         else:\n             # its a uuid\n-            query = {\'UID\': value}\n+            query = {"UID": value}\n         return bool(self.search_catalog(query))\n \n     def search_catalog(self, user_query):\n         query = user_query.copy()\n         query.update(self.query)\n-        catalog = getToolByName(getSite(), \'portal_catalog\')\n+        catalog = getToolByName(getSite(), "portal_catalog")\n         return catalog(query)\ndiff --git a/plone/app/vocabularies/datetimerelated.py b/plone/app/vocabularies/datetimerelated.py\nindex 5951238..cd5c9b4 100644\n--- a/plone/app/vocabularies/datetimerelated.py\n+++ b/plone/app/vocabularies/datetimerelated.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies import PermissiveVocabulary\n from plone.registry.interfaces import IRegistry\n from zope.component import getUtility\n@@ -11,7 +10,7 @@\n import pytz\n \n \n-PLMF = MessageFactory(\'plonelocales\')\n+PLMF = MessageFactory("plonelocales")\n \n \n @provider(IVocabularyFactory)\n@@ -20,9 +19,11 @@ def TimezonesFactory(context, query=None):\n \n     This are all timezones supported by pytz.\n     """\n-    tz_list = [SimpleTerm(value=it, title=PLMF(it, default=it))\n-               for it in pytz.all_timezones\n-               if query is None or query.lower() in it.lower()]\n+    tz_list = [\n+        SimpleTerm(value=it, title=PLMF(it, default=it))\n+        for it in pytz.all_timezones\n+        if query is None or query.lower() in it.lower()\n+    ]\n     return SimpleVocabulary(tz_list)\n \n \n@@ -32,35 +33,37 @@ def CommonTimezonesFactory(context, query=None):\n \n     This are the timezones a user would choose from in a form.\n     """\n-    tz_list = [SimpleTerm(value=it, title=PLMF(it, default=it))\n-               for it in pytz.common_timezones\n-               if query is None or query.lower() in it.lower()]\n+    tz_list = [\n+        SimpleTerm(value=it, title=PLMF(it, default=it))\n+        for it in pytz.common_timezones\n+        if query is None or query.lower() in it.lower()\n+    ]\n     return SimpleVocabulary(tz_list)\n \n \n @provider(IVocabularyFactory)\n def AvailableTimezonesFactory(context, query=None):\n-    """Vocabulary for available timezones, as set by in the controlpanel.\n-    """\n-    reg_key = \'plone.available_timezones\'\n+    """Vocabulary for available timezones, as set by in the controlpanel."""\n+    reg_key = "plone.available_timezones"\n     registry = getUtility(IRegistry)\n     # check if \'plone.available_timezones\' is in registry\n     if reg_key not in registry:\n         # else use \'plone.app.event.available_timezones\'\n-        reg_key = \'plone.app.event.available_timezones\'\n+        reg_key = "plone.app.event.available_timezones"\n     if reg_key not in registry:\n         raise NotImplementedError(\n-            \'"available timezones" needs Plone 5.x or plone.app.event \'\n-            \'installed.\'\n+            \'"available timezones" needs Plone 5.x or plone.app.event \' "installed."\n         )\n-    tz_list = [SimpleTerm(value=it, title=PLMF(it, default=it))\n-               for it in registry[reg_key]\n-               if query is None or query.lower() in it.lower()]\n+    tz_list = [\n+        SimpleTerm(value=it, title=PLMF(it, default=it))\n+        for it in registry[reg_key]\n+        if query is None or query.lower() in it.lower()\n+    ]\n     return SimpleVocabulary(tz_list)\n \n \n # PLEASE NOTE: strftime %w interprets 0 as Sunday unlike the calendar module!\n-WEEKDAY_PREFIXES = [\'mon\', \'tue\', \'wed\', \'thu\', \'fri\', \'sat\', \'sun\']\n+WEEKDAY_PREFIXES = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]\n \n \n @provider(IVocabularyFactory)\n@@ -100,7 +103,7 @@ def WeekdaysFactory(context):\n     """\n     items = []\n     for idx in range(len(WEEKDAY_PREFIXES)):\n-        msgstr = PLMF(\'weekday_{0}\'.format(WEEKDAY_PREFIXES[idx]))\n+        msgstr = PLMF(f"weekday_{WEEKDAY_PREFIXES[idx]}")\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\n \n@@ -142,7 +145,7 @@ def WeekdaysAbbrFactory(context):\n     """\n     items = []\n     for idx in range(len(WEEKDAY_PREFIXES)):\n-        msgstr = PLMF(\'weekday_{0}_abbr\'.format(WEEKDAY_PREFIXES[idx]))\n+        msgstr = PLMF(f"weekday_{WEEKDAY_PREFIXES[idx]}_abbr")\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\n \n@@ -184,13 +187,25 @@ def WeekdaysShortFactory(context):\n     """\n     items = []\n     for idx in range(len(WEEKDAY_PREFIXES)):\n-        msgstr = PLMF(\'weekday_{0}_short\'.format(WEEKDAY_PREFIXES[idx]))\n+        msgstr = PLMF(f"weekday_{WEEKDAY_PREFIXES[idx]}_short")\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\n \n \n-MONTH_PREFIXES = [\'jan\', \'feb\', \'mar\', \'apr\', \'may\', \'jun\',\n-                  \'jul\', \'aug\', \'sep\', \'oct\', \'nov\', \'dec\']\n+MONTH_PREFIXES = [\n+    "jan",\n+    "feb",\n+    "mar",\n+    "apr",\n+    "may",\n+    "jun",\n+    "jul",\n+    "aug",\n+    "sep",\n+    "oct",\n+    "nov",\n+    "dec",\n+]\n \n \n @provider(IVocabularyFactory)\n@@ -222,7 +237,7 @@ def MonthFactory(context):\n     """\n     items = []\n     for idx in range(len(MONTH_PREFIXES)):\n-        msgstr = PLMF(\'month_{0}\'.format(MONTH_PREFIXES[idx]))\n+        msgstr = PLMF(f"month_{MONTH_PREFIXES[idx]}")\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\n \n@@ -256,6 +271,6 @@ def MonthAbbrFactory(context):\n     """\n     items = []\n     for idx in range(len(MONTH_PREFIXES)):\n-        msgstr = PLMF(\'month_{0}_abbr\'.format(MONTH_PREFIXES[idx]))\n+        msgstr = PLMF(f"month_{MONTH_PREFIXES[idx]}_abbr")\n         items.append(SimpleTerm(idx, str(idx), msgstr))\n     return PermissiveVocabulary(items)\ndiff --git a/plone/app/vocabularies/editors.py b/plone/app/vocabularies/editors.py\nindex 673b5c4..e8ef5a8 100644\n--- a/plone/app/vocabularies/editors.py\n+++ b/plone/app/vocabularies/editors.py\n@@ -1,6 +1,5 @@\n-# -*- coding: utf-8 -*-\n+from plone.base.interfaces import IEditingSchema\n from plone.registry.interfaces import IRegistry\n-from Products.CMFPlone.interfaces import IEditingSchema\n from zope.component import getUtility\n from zope.i18nmessageid import MessageFactory\n from zope.interface import implementer\n@@ -9,25 +8,21 @@\n from zope.schema.vocabulary import SimpleVocabulary\n \n \n-_ = MessageFactory(\'plone\')\n+_ = MessageFactory("plone")\n \n \n @implementer(IVocabularyFactory)\n-class AvailableEditorsVocabulary(object):\n-\n+class AvailableEditorsVocabulary:\n     def __call__(self, context):\n         items = []\n \n         registry = getUtility(IRegistry)\n-        settings = registry.forInterface(\n-            IEditingSchema,\n-            prefix=\'plone\',\n-            check=False\n-        )\n+        settings = registry.forInterface(IEditingSchema, prefix="plone", check=False)\n \n         if settings:\n             editors = settings.available_editors\n             items = [SimpleTerm(e, e, _(e)) for e in editors]\n         return SimpleVocabulary(items)\n \n+\n AvailableEditorsVocabularyFactory = AvailableEditorsVocabulary()\ndiff --git a/plone/app/vocabularies/groups.py b/plone/app/vocabularies/groups.py\nindex 04b6c8d..3c7cfdd 100644\n--- a/plone/app/vocabularies/groups.py\n+++ b/plone/app/vocabularies/groups.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n # KEPT HERE FOR BBB UNTIL PLONE 6\n from Products.CMFCore.utils import getToolByName\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n@@ -23,50 +22,48 @@ class ISourceQueryView(Interface):\n \n @implementer(ISource)\n @provider(IContextSourceBinder)\n-class GroupsSource(object):\n+class GroupsSource:\n     """\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n \n-      >>> context = create_context()\n+    >>> context = create_context()\n \n-      >>> tool = DummyTool(\'acl_users\')\n-      >>> groups = (\'group1\', \'group2\')\n-      >>> def getGroupById(value, default):\n-      ...     return value in groups and value or default\n-      >>> tool.getGroupById = getGroupById\n-      >>> def searchGroups(name=None):\n-      ...     return [dict(groupid=u) for u in groups]\n-      >>> tool.searchGroups = searchGroups\n-      >>> context.acl_users = tool\n+    >>> tool = DummyTool(\'acl_users\')\n+    >>> groups = (\'group1\', \'group2\')\n+    >>> def getGroupById(value, default):\n+    ...     return value in groups and value or default\n+    >>> tool.getGroupById = getGroupById\n+    >>> def searchGroups(name=None):\n+    ...     return [dict(groupid=u) for u in groups]\n+    >>> tool.searchGroups = searchGroups\n+    >>> context.acl_users = tool\n \n-      >>> source = GroupsSource(context)\n-      >>> source\n-      <plone.app.vocabularies.groups.GroupsSource object at ...>\n+    >>> source = GroupsSource(context)\n+    >>> source\n+    <plone.app.vocabularies.groups.GroupsSource object at ...>\n \n-      >>> len(source.search(\'\'))\n-      2\n+    >>> len(source.search(\'\'))\n+    2\n \n-      >>> len(source.search(u\'\\xa4\'))\n-      2\n+    >>> len(source.search(u\'\\xa4\'))\n+    2\n \n-      >>> \'group1\' in source, \'noone\' in source\n-      (True, False)\n+    >>> \'group1\' in source, \'noone\' in source\n+    (True, False)\n \n-      >>> source.get(\'group1\'), source.get(\'noone\')\n-      (\'group1\', None)\n+    >>> source.get(\'group1\'), source.get(\'noone\')\n+    (\'group1\', None)\n     """\n \n     def __init__(self, context):\n-        msg = \'GroupsSource is deprecated and will be removed on \' \\\n-              \'Plone 6\'\n+        msg = "GroupsSource is deprecated and will be removed on " "Plone 6"\n         warnings.warn(msg, DeprecationWarning)\n         self.context = context\n-        self.users = getToolByName(context, \'acl_users\')\n+        self.users = getToolByName(context, "acl_users")\n \n     def __contains__(self, value):\n-        """Return whether the value is available in this source\n-        """\n+        """Return whether the value is available in this source"""\n         if self.get(value) is None:\n             return False\n         return True\n@@ -77,82 +74,81 @@ def search(self, query):\n         # it\'s unicode\n \n         try:\n-            name = query.encode(\'ascii\')\n+            name = query.encode("ascii")\n         except UnicodeEncodeError:\n             name = query\n \n-        return [u[\'groupid\'] for u in self.users.searchGroups(name=name)]\n+        return [u["groupid"] for u in self.users.searchGroups(name=name)]\n \n     def get(self, value):\n         return self.users.getGroupById(value, None)\n \n \n @implementer(ITerms, ISourceQueryView)\n-class GroupsSourceQueryView(object):\n+class GroupsSourceQueryView:\n     """\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> from plone.app.vocabularies.tests.base import Request\n-\n-      >>> context = create_context()\n-\n-      >>> class Group(object):\n-      ...     def __init__(self, id):\n-      ...         self.id = id\n-      ...\n-      ...     def getProperty(self, value, default):\n-      ...         return self.id\n-      ...\n-      ...     getId = getProperty\n-\n-      >>> tool = DummyTool(\'acl_users\')\n-      >>> groups = (\'group1\', \'group2\')\n-      >>> def getGroupById(value, default):\n-      ...     return value in groups and Group(value) or None\n-      >>> tool.getGroupById = getGroupById\n-      >>> def searchGroups(name=None):\n-      ...     return [dict(groupid=u) for u in groups]\n-      >>> tool.searchGroups = searchGroups\n-      >>> context.acl_users = tool\n-\n-      >>> source = GroupsSource(context)\n-      >>> source\n-      <plone.app.vocabularies.groups.GroupsSource object at ...>\n-\n-      >>> view = GroupsSourceQueryView(source, Request())\n-      >>> view\n-      <plone.app.vocabularies.groups.GroupsSourceQueryView object at ...>\n-\n-      >>> view.getTerm(\'group1\')\n-      <zope.schema.vocabulary.SimpleTerm object at ...>\n-\n-      >>> view.getValue(\'group1\')\n-      \'group1\'\n-\n-      >>> view.getValue(\'noone\')\n-      Traceback (most recent call last):\n-      ...\n-      LookupError: noone\n-\n-      >>> template = view.render(name=\'t\')\n-\n-      >>> u\'<input type="text" name="t.query" value="" />\' in template\n-      True\n-\n-      >>> u\'<input type="submit" name="t.search" value="Search" />\' in template\n-      True\n-\n-      >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n-      >>> view = GroupsSourceQueryView(source, request)\n-      >>> view.results(\'t\')\n-      [\'group1\', \'group2\']\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import Request\n+\n+    >>> context = create_context()\n+\n+    >>> class Group(object):\n+    ...     def __init__(self, id):\n+    ...         self.id = id\n+    ...\n+    ...     def getProperty(self, value, default):\n+    ...         return self.id\n+    ...\n+    ...     getId = getProperty\n+\n+    >>> tool = DummyTool(\'acl_users\')\n+    >>> groups = (\'group1\', \'group2\')\n+    >>> def getGroupById(value, default):\n+    ...     return value in groups and Group(value) or None\n+    >>> tool.getGroupById = getGroupById\n+    >>> def searchGroups(name=None):\n+    ...     return [dict(groupid=u) for u in groups]\n+    >>> tool.searchGroups = searchGroups\n+    >>> context.acl_users = tool\n+\n+    >>> source = GroupsSource(context)\n+    >>> source\n+    <plone.app.vocabularies.groups.GroupsSource object at ...>\n+\n+    >>> view = GroupsSourceQueryView(source, Request())\n+    >>> view\n+    <plone.app.vocabularies.groups.GroupsSourceQueryView object at ...>\n+\n+    >>> view.getTerm(\'group1\')\n+    <zope.schema.vocabulary.SimpleTerm object at ...>\n+\n+    >>> view.getValue(\'group1\')\n+    \'group1\'\n+\n+    >>> view.getValue(\'noone\')\n+    Traceback (most recent call last):\n+    ...\n+    LookupError: noone\n+\n+    >>> template = view.render(name=\'t\')\n+\n+    >>> u\'<input type="text" name="t.query" value="" />\' in template\n+    True\n+\n+    >>> u\'<input type="submit" name="t.search" value="Search" />\' in template\n+    True\n+\n+    >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n+    >>> view = GroupsSourceQueryView(source, request)\n+    >>> view.results(\'t\')\n+    [\'group1\', \'group2\']\n     """\n \n-    template = ViewPageTemplateFile(\'searchabletextsource.pt\')\n+    template = ViewPageTemplateFile("searchabletextsource.pt")\n \n     def __init__(self, context, request):\n-        msg = \'GroupsSourceQueryView is deprecated and will be removed on \' \\\n-              \'Plone 6\'\n+        msg = "GroupsSourceQueryView is deprecated and will be removed on " "Plone 6"\n         warnings.warn(msg, DeprecationWarning)\n         self.context = context\n         self.request = request\n@@ -162,7 +158,7 @@ def getTerm(self, value):\n         token = value\n         title = value\n         if group is not None:\n-            title = group.getProperty(\'title\', None) or group.getId()\n+            title = group.getProperty("title", None) or group.getId()\n         return SimpleTerm(value, token=token, title=title)\n \n     def getValue(self, token):\n@@ -175,9 +171,9 @@ def render(self, name):\n \n     def results(self, name):\n         # check whether the normal search button was pressed\n-        if name + \'.search\' in self.request.form:\n-            query_fieldname = name + \'.query\'\n+        if name + ".search" in self.request.form:\n+            query_fieldname = name + ".query"\n             if query_fieldname in self.request.form:\n                 query = self.request.form[query_fieldname]\n-                if query != \'\':\n+                if query != "":\n                     return self.context.search(query)\ndiff --git a/plone/app/vocabularies/images.py b/plone/app/vocabularies/images.py\nindex b090ae0..0bc9c7d 100644\n--- a/plone/app/vocabularies/images.py\n+++ b/plone/app/vocabularies/images.py\n@@ -1,28 +1,25 @@\n-# -*- coding: utf-8 -*-\n-from Products.CMFPlone.utils import getAllowedSizes\n+from plone.namedfile.interfaces import IAvailableSizes\n+from zope.component import getUtility\n from zope.i18nmessageid import MessageFactory\n from zope.interface import provider\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n-import six\n-\n-\n-PMF = MessageFactory(\'plone\')\n+PMF = MessageFactory("plone")\n \n \n @provider(IVocabularyFactory)\n def ScalesVocabulary(context):\n-    """Obtains available scales from registry\n-    """\n+    """Obtains available scales from registry"""\n     terms = []\n-    allowedSizes = getAllowedSizes()\n-    if allowedSizes is not None:\n-        for scale, (width, height) in six.iteritems(getAllowedSizes()):\n+    available_sizes = getUtility(IAvailableSizes)()\n+    if available_sizes is not None:\n+        for scale, (width, height) in available_sizes.items():\n             translated = PMF(\n-                \'imagescale_{0:s}\'.format(scale),\n-                default=\'{0:s} ${{width}}x${{height}}\'.format(scale),\n-                mapping={\'width\': str(width), \'height\': str(height)})\n+                f"imagescale_{scale:s}",\n+                default=f"{scale:s} ${{width}}x${{height}}",\n+                mapping={"width": str(width), "height": str(height)},\n+            )\n             terms.append(SimpleTerm(scale, scale, translated))\n     return SimpleVocabulary(terms)\ndiff --git a/plone/app/vocabularies/interfaces.py b/plone/app/vocabularies/interfaces.py\nindex c2e90ad..2498e77 100644\n--- a/plone/app/vocabularies/interfaces.py\n+++ b/plone/app/vocabularies/interfaces.py\n@@ -1,18 +1,17 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Attribute\n from zope.interface import Interface\n from zope.schema.interfaces import IVocabularyTokenized\n \n \n class ITermWithDescription(Interface):\n-    """A term which carries an additional description\n-    """\n+    """A term which carries an additional description"""\n \n     description = Attribute(\n-        \'description\',\n+        "description",\n         """Description of the term, which will be displayed to distinguish\n            between terms with similar labels.\n-        """)\n+        """,\n+    )\n \n \n class IBrowsableTerm(Interface):\n@@ -21,28 +20,29 @@ class IBrowsableTerm(Interface):\n     """\n \n     browse_token = Attribute(\n-        \'browse_token\',\n+        "browse_token",\n         """Token which can be used to get contents of browsable terms in\n            queryable sources.\n \n         The value of this attribute must be a non-empty 7-bit string.\n         Control characters are not allowed.\n-        """)\n+        """,\n+    )\n \n     parent_token = Attribute(\n-        \'parent_token\',\n+        "parent_token",\n         """Token which can be used to get contents of the parent of browsable\n            terms in queryable sources.\n \n         The value of this attribute must be a non-empty 7-bit string.\n         Control characters are not allowed.\n-        """)\n+        """,\n+    )\n \n \n class ISlicableVocabulary(IVocabularyTokenized):\n-\n     def __getitem__(start, stop):\n-        """ return a slice of the results"""\n+        """return a slice of the results"""\n \n \n class IPermissiveVocabulary(IVocabularyTokenized):\ndiff --git a/plone/app/vocabularies/language.py b/plone/app/vocabularies/language.py\nindex 54648c3..c5c387d 100644\n--- a/plone/app/vocabularies/language.py\n+++ b/plone/app/vocabularies/language.py\n@@ -1,117 +1,112 @@\n-# -*- coding: utf-8 -*-\n from operator import itemgetter\n from Products.CMFCore.utils import getToolByName\n+from zope.component.hooks import getSite\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n-from zope.component.hooks import getSite\n \n \n @implementer(IVocabularyFactory)\n-class AvailableContentLanguageVocabulary(object):\n+class AvailableContentLanguageVocabulary:\n     """Vocabulary factory for available content languages in the portal.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n \n-      >>> name = \'plone.app.vocabularies.AvailableContentLanguages\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n+    >>> name = \'plone.app.vocabularies.AvailableContentLanguages\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n \n-      >>> len(util(context))  # \'en\' is given as default now\n-      1\n+    >>> len(util(context))  # \'en\' is given as default now\n+    1\n \n-      >>> tool = DummyTool(\'portal_languages\')\n-      >>> def getAvailableLanguages():\n-      ...     return dict(en=dict(name=\'English\', native=\'English\'),\n-      ...                 de=dict(name=\'German\', native=\'Deutsch\'))\n-      >>> tool.getAvailableLanguages = getAvailableLanguages\n-      >>> context.portal_languages = tool\n+    >>> tool = DummyTool(\'portal_languages\')\n+    >>> def getAvailableLanguages():\n+    ...     return dict(en=dict(name=\'English\', native=\'English\'),\n+    ...                 de=dict(name=\'German\', native=\'Deutsch\'))\n+    >>> tool.getAvailableLanguages = getAvailableLanguages\n+    >>> context.portal_languages = tool\n \n-      >>> languages = util(context)\n-      >>> languages\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+    >>> languages = util(context)\n+    >>> languages\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n \n-      >>> len(languages.by_token)\n-      2\n+    >>> len(languages.by_token)\n+    2\n \n-      >>> de = languages.by_token[\'de\']\n-      >>> de.title, de.token, de.value\n-      (\'Deutsch\', \'de\', \'de\')\n+    >>> de = languages.by_token[\'de\']\n+    >>> de.title, de.token, de.value\n+    (\'Deutsch\', \'de\', \'de\')\n     """\n \n     def __call__(self, context):\n-        items = [SimpleTerm(\'en\', \'en\', \'English\')]  # default, only english\n+        items = [SimpleTerm("en", "en", "English")]  # default, only english\n         site = getSite()\n-        ltool = getToolByName(site, \'portal_languages\', None)\n+        ltool = getToolByName(site, "portal_languages", None)\n         if ltool is not None:\n             languages = ltool.getAvailableLanguages()\n-            items = [(l, languages[l].get(\'native\', l)) for l in languages]\n+            items = [(l, languages[l].get("native", l)) for l in languages]\n             items.sort(key=itemgetter(1))\n             items = [SimpleTerm(i[0], i[0], i[1]) for i in items]\n         return SimpleVocabulary(items)\n \n+\n AvailableContentLanguageVocabularyFactory = AvailableContentLanguageVocabulary()  # noqa\n \n \n @implementer(IVocabularyFactory)\n-class SupportedContentLanguageVocabulary(object):\n+class SupportedContentLanguageVocabulary:\n     """Vocabulary factory for supported content languages in the portal.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-\n-      >>> name = \'plone.app.vocabularies.SupportedContentLanguages\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n-\n-      >>> len(util(context))\n-      0\n-\n-      >>> tool = DummyTool(\'portal_languages\')\n-      >>> def listSupportedLanguages():\n-      ...     return [(\'en\', \'English\'), (\'de\', \'German\')]\n-      >>> tool.listSupportedLanguages = listSupportedLanguages\n-      >>> def getAvailableLanguages():\n-      ...     return dict(en=dict(name=\'English\', native=\'English\'),\n-      ...                 de=dict(name=\'German\', native=\'Deutsch\'))\n-      >>> tool.getAvailableLanguages = getAvailableLanguages\n-      >>> context.portal_languages = tool\n-\n-      >>> languages = util(context)\n-      >>> languages\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n-\n-      >>> len(languages.by_token)\n-      2\n-\n-      >>> de = languages.by_token[\'de\']\n-      >>> de.title, de.token, de.value\n-      (\'Deutsch\', \'de\', \'de\')\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+\n+    >>> name = \'plone.app.vocabularies.SupportedContentLanguages\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n+\n+    >>> len(util(context))\n+    0\n+\n+    >>> tool = DummyTool(\'portal_languages\')\n+    >>> def listSupportedLanguages():\n+    ...     return [(\'en\', \'English\'), (\'de\', \'German\')]\n+    >>> tool.listSupportedLanguages = listSupportedLanguages\n+    >>> def getAvailableLanguages():\n+    ...     return dict(en=dict(name=\'English\', native=\'English\'),\n+    ...                 de=dict(name=\'German\', native=\'Deutsch\'))\n+    >>> tool.getAvailableLanguages = getAvailableLanguages\n+    >>> context.portal_languages = tool\n+\n+    >>> languages = util(context)\n+    >>> languages\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+\n+    >>> len(languages.by_token)\n+    2\n+\n+    >>> de = languages.by_token[\'de\']\n+    >>> de.title, de.token, de.value\n+    (\'Deutsch\', \'de\', \'de\')\n     """\n \n     def __call__(self, context):\n         items = []\n         site = getSite()\n-        ltool = getToolByName(site, \'portal_languages\', None)\n+        ltool = getToolByName(site, "portal_languages", None)\n         if ltool is not None:\n             items = ltool.listSupportedLanguages()\n             all_langs = ltool.getAvailableLanguages()\n-            items = [\n-                (l[0], all_langs[l[0]].get(\'native\', l[1]))\n-                for l in items\n-            ]\n+            items = [(l[0], all_langs[l[0]].get("native", l[1])) for l in items]\n             items.sort(key=itemgetter(1))\n             items = [\n-                SimpleTerm(\n-                    i[0],\n-                    i[0],\n-                    all_langs.get(i[0], {}).get(\'native\', i[1])\n-                ) for i in items\n+                SimpleTerm(i[0], i[0], all_langs.get(i[0], {}).get("native", i[1]))\n+                for i in items\n             ]\n         return SimpleVocabulary(items)\n \n+\n SupportedContentLanguageVocabularyFactory = SupportedContentLanguageVocabulary()  # noqa\ndiff --git a/plone/app/vocabularies/metadatafields.py b/plone/app/vocabularies/metadatafields.py\nindex 508a17e..fc29cdf 100644\n--- a/plone/app/vocabularies/metadatafields.py\n+++ b/plone/app/vocabularies/metadatafields.py\n@@ -1,6 +1,5 @@\n-# -*- coding: utf-8 -*-\n+from plone.base import PloneMessageFactory as _\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone import PloneMessageFactory as _\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n@@ -8,62 +7,66 @@\n \n \n _FIELD_LABEL = {\n-    \'CreationDate\': _(\'Created on\'),\n-    \'Creator\': _(\'Creator\'),\n-    \'Description\': _(\'Description\'),\n-    \'EffectiveDate\': _(\'Publication date\'),\n-    \'end\': _(\'End Date\'),\n-    \'exclude_from_nav\': _(\'Excluded from navigation\'),\n-    \'ExpirationDate\': _(\'Expiration date\'),\n-    \'getObjSize\': _(\'Object Size\'),\n-    \'id\': _(\'ID\'),\n-    \'is_folderish\': _(\'Folder\'),\n-    \'last_comment_date\': _(\'Last comment date\'),\n-    \'location\': _(\'Location\'),\n-    \'ModificationDate\': _(\'Last modified\'),\n-    \'review_state\': _(\'Review state\'),\n-    \'start\': _(\'Start Date\'),\n-    \'Subject\': _(\'Tags\'),\n-    \'Type\': _(\'Type\'),\n-    \'total_comments\': _(\'Total comments\'),\n-    \'mime_type\': _(\'MIME type\'),\n+    "CreationDate": _("Created on"),\n+    "Creator": _("Creator"),\n+    "Description": _("Description"),\n+    "EffectiveDate": _("Publication date"),\n+    "end": _("End Date"),\n+    "exclude_from_nav": _("Excluded from navigation"),\n+    "ExpirationDate": _("Expiration date"),\n+    "getObjSize": _("Object Size"),\n+    "id": _("ID"),\n+    "is_folderish": _("Folder"),\n+    "last_comment_date": _("Last comment date"),\n+    "location": _("Location"),\n+    "ModificationDate": _("Last modified"),\n+    "review_state": _("Review state"),\n+    "start": _("Start Date"),\n+    "Subject": _("Tags"),\n+    "Type": _("Type"),\n+    "total_comments": _("Total comments"),\n+    "mime_type": _("MIME type"),\n }\n \n \n @implementer(IVocabularyFactory)\n-class MetaDataFieldsVocabulary(object):\n+class MetaDataFieldsVocabulary:\n     """Vocabulary factory for metadata fields\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import DummyCatalog\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import DummyCatalog\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import create_context\n \n-      >>> context = create_context()\n+    >>> context = create_context()\n \n-      >>> catalog = DummyCatalog(())\n-      >>> catalog.schema = lambda: [\'ModificationDate\', \'review_state\', \'SomethingNew\']\n-      >>> context.portal_catalog = catalog\n+    >>> catalog = DummyCatalog(())\n+    >>> catalog.schema = lambda: [\'ModificationDate\', \'review_state\', \'SomethingNew\']\n+    >>> context.portal_catalog = catalog\n \n-      >>> name = \'plone.app.vocabularies.MetadataFields\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> name = \'plone.app.vocabularies.MetadataFields\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n \n-      >>> fields = util(context)\n-      >>> fields\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+    >>> fields = util(context)\n+    >>> fields\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n \n-      >>> len(fields.by_token)\n-      3\n+    >>> len(fields.by_token)\n+    3\n \n-      >>> modification_date = fields.by_token[\'ModificationDate\']\n-      >>> modification_date.title, modification_date.token, modification_date.value\n-      (u\'Last modified\', \'ModificationDate\', \'ModificationDate\')\n+    >>> modification_date = fields.by_token[\'ModificationDate\']\n+    >>> modification_date.title, modification_date.token, modification_date.value\n+    (u\'Last modified\', \'ModificationDate\', \'ModificationDate\')\n     """\n \n     def __call__(self, context):\n-        cat = getToolByName(context, \'portal_catalog\')\n+        cat = getToolByName(context, "portal_catalog")\n         items = [\n-            SimpleTerm(column, column, _FIELD_LABEL[column] if column in _FIELD_LABEL else _(column))\n+            SimpleTerm(\n+                column,\n+                column,\n+                _FIELD_LABEL[column] if column in _FIELD_LABEL else _(column),\n+            )\n             for column in cat.schema()\n         ]\n         return SimpleVocabulary(items)\ndiff --git a/plone/app/vocabularies/principals.py b/plone/app/vocabularies/principals.py\nindex 49afebd..8aee569 100644\n--- a/plone/app/vocabularies/principals.py\n+++ b/plone/app/vocabularies/principals.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies.interfaces import ISlicableVocabulary\n from plone.registry.interfaces import IRegistry\n from Products.CMFCore.utils import getToolByName\n@@ -10,40 +9,40 @@\n from zope.schema.vocabulary import SimpleVocabulary\n \n \n-GETTER = {\'user\': \'getUserById\', \'group\': \'getGroupById\'}\n+GETTER = {"user": "getUserById", "group": "getGroupById"}\n \n _USER_SEARCH = {\n-    \'search\': \'searchUsers\',\n+    "search": "searchUsers",\n     # Hint: The fullname search is provided i.e. in IUserEnumeration of\n     # the property plugin in PlonePAS.\n-    \'searchattr\': \'fullname\',\n-    \'searchargs\': {\'sort_by\': \'fullname\'},\n-    \'many\': \'plone.many_users\',\n+    "searchattr": "fullname",\n+    "searchargs": {"sort_by": "fullname"},\n+    "many": "plone.many_users",\n }\n _GROUP_SEARCH = {\n-    \'search\': \'searchGroups\',\n+    "search": "searchGroups",\n     # Hint: The fullname search is excluded in i.e. in IUserEnumeration of\n     # the property plugin in PlonePAS. title is supported.\n-    \'searchattr\': \'title\',\n-    \'searchargs\': {\'sort_by\': \'title\'},\n-    \'many\': \'plone.many_groups\',\n+    "searchattr": "title",\n+    "searchargs": {"sort_by": "title"},\n+    "many": "plone.many_groups",\n }\n \n SOURCES = {\n-    \'user\': {\n-        \'searches\': [_USER_SEARCH],\n-        \'get\': \'getUserById\',\n-        \'prefix\': False,\n+    "user": {\n+        "searches": [_USER_SEARCH],\n+        "get": "getUserById",\n+        "prefix": False,\n     },\n-    \'group\': {\n-        \'searches\': [_GROUP_SEARCH],\n-        \'get\': \'getGroupById\',\n-        \'prefix\': False,\n+    "group": {\n+        "searches": [_GROUP_SEARCH],\n+        "get": "getGroupById",\n+        "prefix": False,\n     },\n-    \'principal\': {\n-        \'searches\': [_GROUP_SEARCH, _USER_SEARCH],\n-        \'get\': \'getPrincipalById\',\n-        \'prefix\': True,\n+    "principal": {\n+        "searches": [_GROUP_SEARCH, _USER_SEARCH],\n+        "get": "getPrincipalById",\n+        "prefix": True,\n     },\n }\n \n@@ -53,38 +52,37 @@ def token_from_principal_info(info, prefix=False):\n     # for patternlib or for options tag (where the standard wants\n     # something CDATA compatible)\n     if not prefix:\n-        return info[\'id\']\n+        return info["id"]\n     # we use a double underscore here, a colon is already used in pattern\n     # values as separator\n-    return \'{0}__{1}\'.format(info[\'principal_type\'], info[\'id\'])\n+    return "{}__{}".format(info["principal_type"], info["id"])\n \n \n def merge_principal_infos(infos, prefix=False):\n     info = infos[0]\n     if len(infos) > 1:\n-        principal_types = set([\n-            info[\'principal_type\'] for info in infos if info[\'principal_type\']]\n-        )\n+        principal_types = {\n+            info["principal_type"] for info in infos if info["principal_type"]\n+        }\n         if len(principal_types) > 1:\n             # Principals with the same ID but different types. Should not\n             # happen.\n-            raise ValueError(\'Principal ID not unique: {}\'.format(info[\'id\']))\n-        if not info[\'title\']:\n+            raise ValueError("Principal ID not unique: {}".format(info["id"]))\n+        if not info["title"]:\n             for candidate in infos:\n-                if candidate[\'title\']:\n-                    info[\'title\'] = candidate[\'title\']\n+                if candidate["title"]:\n+                    info["title"] = candidate["title"]\n                     break\n     return info\n \n \n def _get_acl_users():\n-    return getToolByName(getSite(), \'acl_users\')\n+    return getToolByName(getSite(), "acl_users")\n \n \n @implementer(ISlicableVocabulary)\n class PrincipalsVocabulary(SimpleVocabulary):\n-    """Vocabulary dealing with users/ groups (or in theory any other principal)\n-    """\n+    """Vocabulary dealing with users/ groups (or in theory any other principal)"""\n \n     @property\n     def principal_source(self):\n@@ -96,27 +94,24 @@ def principal_source(self, value):\n \n     @property\n     def _acl_users(self):\n-        aclu = getattr(self, \'_aclu\', None)\n+        aclu = getattr(self, "_aclu", None)\n         if not aclu:\n             aclu = self._aclu = _get_acl_users()\n         return aclu\n \n     def _get_principal_from_source(self, value=None, token=None, default=None):\n-        """Helper to get a user or group from users folder.\n-        """\n+        """Helper to get a user or group from users folder."""\n         if not (bool(value) ^ bool(token)):  # not (value xor token)\n-            raise ValueError(\n-                \'value or token must be provided (only one of those)\'\n-            )\n-        if SOURCES[self._principal_source][\'prefix\']:\n+            raise ValueError("value or token must be provided (only one of those)")\n+        if SOURCES[self._principal_source]["prefix"]:\n             if value:\n-                if \':\' not in value:\n+                if ":" not in value:\n                     return default\n-                principal_type, principal_id = value.split(\':\', 2)\n+                principal_type, principal_id = value.split(":", 2)\n             else:\n-                if \'__\' not in token:\n+                if "__" not in token:\n                     return default\n-                principal_type, principal_id = token.split(\'__\', 2)\n+                principal_type, principal_id = token.split("__", 2)\n         else:\n             principal_type = self._principal_source\n             principal_id = value or token\n@@ -124,35 +119,31 @@ def _get_principal_from_source(self, value=None, token=None, default=None):\n         return getter(principal_id, default)\n \n     def _get_term_from_source(self, value=None, token=None):\n-        """Helper to get a user or group from users folder.\n-        """\n+        """Helper to get a user or group from users folder."""\n         if not (bool(value) ^ bool(token)):  # not (value xor token)\n-            raise ValueError(\n-                \'value or token must be provided (only one of those)\'\n-            )\n+            raise ValueError("value or token must be provided (only one of those)")\n         principal = self._get_principal_from_source(value=value, token=token)\n         if principal is None:\n-            raise LookupError(\'Principal {} not found\'.format(value or token))\n+            raise LookupError(f"Principal {value or token} not found")\n         if principal.isGroup():\n-            title = principal.getProperty(\'title\', principal.getId())\n-            principal_type = \'group\'\n+            title = principal.getProperty("title", principal.getId())\n+            principal_type = "group"\n         else:\n-            title = principal.getProperty(\'fullname\', principal.getId())\n-            principal_type = \'user\'\n+            title = principal.getProperty("fullname", principal.getId())\n+            principal_type = "user"\n         if token:\n             value = principal.getId()\n-            if SOURCES[self._principal_source][\'prefix\']:\n-                value = \'{0}:{1}\'.format(principal_type, value)\n+            if SOURCES[self._principal_source]["prefix"]:\n+                value = f"{principal_type}:{value}"\n         else:\n             token = principal.getId()\n-            if SOURCES[self._principal_source][\'prefix\']:\n-                token = \'{0}__{1}\'.format(principal_type, token)\n+            if SOURCES[self._principal_source]["prefix"]:\n+                token = f"{principal_type}__{token}"\n         return self.__class__.createTerm(value, token, title)\n \n     def __contains__(self, value):\n-        """Checks if the principal exists in current subset or in PAS.\n-        """\n-        result = super(PrincipalsVocabulary, self).__contains__(value)\n+        """Checks if the principal exists in current subset or in PAS."""\n+        result = super().__contains__(value)\n         return result or bool(self._get_principal_from_source(value=value))\n \n     def getTerm(self, value):\n@@ -160,7 +151,7 @@ def getTerm(self, value):\n         This allows to lookup already saved values.\n         """\n         try:\n-            return super(PrincipalsVocabulary, self).getTerm(value)\n+            return super().getTerm(value)\n         except LookupError:\n             return self._get_term_from_source(value=value)\n \n@@ -169,7 +160,7 @@ def getTermByToken(self, token):\n         This allows to lookup already saved values by token.\n         """\n         try:\n-            return super(PrincipalsVocabulary, self).getTermByToken(token)\n+            return super().getTermByToken(token)\n         except LookupError:\n             return self._get_term_from_source(token=token)\n \n@@ -186,15 +177,13 @@ def __getitem__(self, start, stop=None):\n         return self._terms[start:stop]\n \n \n-class BaseFactory(object):\n-    """Factory creating a PrincipalsVocabulary\n-    """\n+class BaseFactory:\n+    """Factory creating a PrincipalsVocabulary"""\n \n     source = None\n \n     def should_search(self, query):\n-        """ Test if we should search for users\n-        """\n+        """Test if we should search for users"""\n         if query:\n             return True\n         registry = getUtility(IRegistry)\n@@ -202,7 +191,7 @@ def should_search(self, query):\n             x\n             for x in filter(\n                 registry.get,\n-                [cfg[\'many\'] for cfg in SOURCES[self.source][\'searches\']],\n+                [cfg["many"] for cfg in SOURCES[self.source]["searches"]],\n             )\n         ]\n \n@@ -223,7 +212,7 @@ def use_principal_triple(self, principal_triple):\n         """\n         return True\n \n-    def __call__(self, context, query=\'\'):\n+    def __call__(self, context, query=""):\n         if not self.should_search(query):\n             vocabulary = PrincipalsVocabulary([])\n             vocabulary.principal_source = self.source\n@@ -233,37 +222,30 @@ def __call__(self, context, query=\'\'):\n \n         def term_triples():\n             """Generator for term triples (value, token, name)"""\n-            for search_cfg in cfg[\'searches\']:\n-                search = getattr(acl_users, search_cfg[\'search\'])\n-                searchargs = search_cfg[\'searchargs\'].copy()\n-                searchargs[search_cfg[\'searchattr\']] = query\n+            for search_cfg in cfg["searches"]:\n+                search = getattr(acl_users, search_cfg["search"])\n+                searchargs = search_cfg["searchargs"].copy()\n+                searchargs[search_cfg["searchattr"]] = query\n                 infotree = {}\n                 for info in search(**searchargs):\n-                    infotree.setdefault(\n-                        info[\'id\'], {}).setdefault(\n-                            info[\'principal_type\'], []).append(\n-                                info)\n+                    infotree.setdefault(info["id"], {}).setdefault(\n+                        info["principal_type"], []\n+                    ).append(info)\n                 for principal_id, types_infos in infotree.items():\n-                    if len(types_infos) > 1 and not cfg[\'prefix\']:\n-                        raise ValueError(\'Principal ID not unique: {}\'.format(\n-                            principal_id))\n+                    if len(types_infos) > 1 and not cfg["prefix"]:\n+                        raise ValueError(f"Principal ID not unique: {principal_id}")\n                     for principal_type, principal_infos in types_infos.items():\n                         value = principal_id\n                         info = merge_principal_infos(principal_infos)\n-                        if cfg[\'prefix\']:\n-                            value = \'{0}:{1}\'.format(\n-                                info[\'principal_type\'], value)\n-                        token = token_from_principal_info(\n-                            info, prefix=cfg[\'prefix\']\n-                        )\n-                        yield (value, token, info[\'title\'])\n+                        if cfg["prefix"]:\n+                            value = "{}:{}".format(info["principal_type"], value)\n+                        token = token_from_principal_info(info, prefix=cfg["prefix"])\n+                        yield (value, token, info["title"])\n \n         vocabulary = PrincipalsVocabulary(\n             [\n                 SimpleTerm(*term_triple)\n-                for term_triple in filter(\n-                    self.use_principal_triple, term_triples()\n-                )\n+                for term_triple in filter(self.use_principal_triple, term_triples())\n             ]\n         )\n         vocabulary.principal_source = self.source\n@@ -272,14 +254,14 @@ def term_triples():\n \n @implementer(IVocabularyFactory)\n class PrincipalsFactory(BaseFactory):\n-    source = \'principal\'\n+    source = "principal"\n \n \n @implementer(IVocabularyFactory)\n class UsersFactory(BaseFactory):\n-    source = \'user\'\n+    source = "user"\n \n \n @implementer(IVocabularyFactory)\n class GroupsFactory(BaseFactory):\n-    source = \'group\'\n+    source = "group"\ndiff --git a/plone/app/vocabularies/security.py b/plone/app/vocabularies/security.py\nindex af8e352..2a3c670 100644\n--- a/plone/app/vocabularies/security.py\n+++ b/plone/app/vocabularies/security.py\n@@ -1,80 +1,79 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_get\n from operator import attrgetter\n from Products.CMFCore.utils import getToolByName\n+from zope.component.hooks import getSite\n from zope.i18n import translate\n from zope.i18nmessageid import MessageFactory\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n-from zope.component.hooks import getSite\n \n import zope.deferredimport\n \n \n zope.deferredimport.deprecated(\n     "Import from plone.app.vocabularies.principals instead",\n-    GroupsFactory=\'plone.app.vocabularies:principals.GroupsFactory\',\n-    GroupsVocabulary=\'plone.app.vocabularies:principals.GroupsVocabulary\',\n+    GroupsFactory="plone.app.vocabularies:principals.GroupsFactory",\n+    GroupsVocabulary="plone.app.vocabularies:principals.GroupsVocabulary",\n )\n \n-PMF = MessageFactory(\'plone\')\n+PMF = MessageFactory("plone")\n \n \n @implementer(IVocabularyFactory)\n-class RolesVocabulary(object):\n+class RolesVocabulary:\n     """Vocabulary factory for roles in the portal\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n \n-      >>> name = \'plone.app.vocabularies.Roles\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n+    >>> name = \'plone.app.vocabularies.Roles\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n \n-      >>> len(util(context))\n-      0\n+    >>> len(util(context))\n+    0\n \n-      >>> tool = DummyTool(\'portal_membership\')\n-      >>> def getPortalRoles():\n-      ...    return (\'Anonymous\', \'Authenticated\', \'Manager\', \'Ploonies\')\n-      >>> tool.getPortalRoles = getPortalRoles\n-      >>> context.portal_membership = tool\n+    >>> tool = DummyTool(\'portal_membership\')\n+    >>> def getPortalRoles():\n+    ...    return (\'Anonymous\', \'Authenticated\', \'Manager\', \'Ploonies\')\n+    >>> tool.getPortalRoles = getPortalRoles\n+    >>> context.portal_membership = tool\n \n-      >>> roles = util(context)\n-      >>> roles\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+    >>> roles = util(context)\n+    >>> roles\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n \n-      >>> len(roles.by_token)\n-      4\n+    >>> len(roles.by_token)\n+    4\n \n-      >>> manager = roles.by_token[\'Manager\']\n-      >>> manager.title, manager.token, manager.value\n-      (u\'Manager\', \'Manager\', \'Manager\')\n+    >>> manager = roles.by_token[\'Manager\']\n+    >>> manager.title, manager.token, manager.value\n+    (u\'Manager\', \'Manager\', \'Manager\')\n     """\n \n     def __call__(self, context):\n         site = getSite()\n-        mtool = getToolByName(site, \'portal_membership\', None)\n+        mtool = getToolByName(site, "portal_membership", None)\n         if mtool is None:\n             return SimpleVocabulary([])\n \n         items = []\n-        request = aq_get(mtool, \'REQUEST\', None)\n+        request = aq_get(mtool, "REQUEST", None)\n         roles = mtool.getPortalRoles()\n         for role_id in roles:\n             role_title = translate(PMF(role_id), context=request)\n             items.append(SimpleTerm(role_id, role_id, role_title))\n \n-        missing_roles = [\'Anonymous\', \'Authenticated\']\n+        missing_roles = ["Anonymous", "Authenticated"]\n         for role_id in missing_roles:\n             if role_id in roles:\n                 continue\n             role_title = translate(PMF(role_id), context=request)\n             items.append(SimpleTerm(role_id, role_id, role_title))\n-        items.sort(key=attrgetter(\'title\'))\n+        items.sort(key=attrgetter("title"))\n \n         return SimpleVocabulary(items)\n \n@@ -83,14 +82,12 @@ def __call__(self, context):\n \n \n @implementer(IVocabularyFactory)\n-class PermissionsVocabulary(object):\n-    """Vocabulary factory for permissions.\n-    """\n+class PermissionsVocabulary:\n+    """Vocabulary factory for permissions."""\n \n     def __call__(self, context):\n         site = getSite()\n-        items = [SimpleTerm(perm, perm, perm)\n-                 for perm in site.possible_permissions()]\n+        items = [SimpleTerm(perm, perm, perm) for perm in site.possible_permissions()]\n         return SimpleVocabulary(items)\n \n \ndiff --git a/plone/app/vocabularies/skins.py b/plone/app/vocabularies/skins.py\nindex c497d5a..aee2c37 100644\n--- a/plone/app/vocabularies/skins.py\n+++ b/plone/app/vocabularies/skins.py\n@@ -1,72 +1,66 @@\n-# -*- coding: utf-8 -*-\n from Products.CMFCore.utils import getToolByName\n+from zope.component.hooks import getSite\n from zope.i18nmessageid import MessageFactory\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n-from zope.component.hooks import getSite\n \n \n-_ = MessageFactory(\'plone\')\n+_ = MessageFactory("plone")\n \n \n @implementer(IVocabularyFactory)\n-class SkinsVocabulary(object):\n+class SkinsVocabulary:\n     """Vocabulary factory for skins.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n \n-      >>> name = \'plone.app.vocabularies.Skins\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n+    >>> name = \'plone.app.vocabularies.Skins\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n \n-      >>> len(util(context))\n-      0\n+    >>> len(util(context))\n+    0\n \n-      >>> tool = DummyTool(\'portal_skins\')\n-      >>> def getSkinSelections():\n-      ...     return (\'Plone Default\', \'Plone Kitty\')\n-      >>> tool.getSkinSelections = getSkinSelections\n-      >>> context.portal_skins = tool\n+    >>> tool = DummyTool(\'portal_skins\')\n+    >>> def getSkinSelections():\n+    ...     return (\'Plone Default\', \'Plone Kitty\')\n+    >>> tool.getSkinSelections = getSkinSelections\n+    >>> context.portal_skins = tool\n \n-      >>> skins = util(context)\n-      >>> skins\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+    >>> skins = util(context)\n+    >>> skins\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n \n-      >>> len(skins.by_token)\n-      2\n+    >>> len(skins.by_token)\n+    2\n \n-      >>> term = skins.by_token[\'Plone Kitty\']\n-      >>> term.title, term.token, term.value\n-      (\'Plone Kitty\', \'Plone Kitty\', \'Plone Kitty\')\n+    >>> term = skins.by_token[\'Plone Kitty\']\n+    >>> term.title, term.token, term.value\n+    (\'Plone Kitty\', \'Plone Kitty\', \'Plone Kitty\')\n \n-      Plone Default is a special case that gets a different title\n-      for clarification.\n-      >>> term = skins.by_token[\'Plone Default\']\n-      >>> term.title, term.token, term.value\n-      (u\'(Unstyled)\', \'Plone Default\', \'Plone Default\')\n+    Plone Default is a special case that gets a different title\n+    for clarification.\n+    >>> term = skins.by_token[\'Plone Default\']\n+    >>> term.title, term.token, term.value\n+    (u\'(Unstyled)\', \'Plone Default\', \'Plone Default\')\n     """\n \n     def __call__(self, context):\n         terms = []\n         site = getSite()\n-        stool = getToolByName(site, \'portal_skins\', None)\n+        stool = getToolByName(site, "portal_skins", None)\n         if stool is not None:\n             items = list(stool.getSkinSelections())\n             items.sort()\n-            if \'Plone Default\' in items:\n-                terms = [\n-                    SimpleTerm(\n-                        \'Plone Default\',\n-                        \'Plone Default\',\n-                        _(u\'(Unstyled)\')\n-                    )\n-                ]\n-                items.remove(\'Plone Default\')\n+            if "Plone Default" in items:\n+                terms = [SimpleTerm("Plone Default", "Plone Default", _("(Unstyled)"))]\n+                items.remove("Plone Default")\n             terms += [SimpleTerm(i, i, i) for i in items]\n         return SimpleVocabulary(terms)\n \n+\n SkinsVocabularyFactory = SkinsVocabulary()\ndiff --git a/plone/app/vocabularies/syndication.py b/plone/app/vocabularies/syndication.py\nindex 218b9bc..5849a6b 100644\n--- a/plone/app/vocabularies/syndication.py\n+++ b/plone/app/vocabularies/syndication.py\n@@ -1,4 +1,5 @@\n-# -*- coding: utf-8 -*-\n+from plone.base import MessageFactory as _\n+from plone.base.interfaces import ISiteSyndicationSettings\n from plone.registry.interfaces import IRegistry\n from Products.CMFCore.utils import getToolByName\n from zope.component import getUtility\n@@ -9,26 +10,10 @@\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n-import six\n-\n-\n-try:\n-    # XXX: this is a circular dependency (not declared in setup.py)\n-    from Products.CMFPlone.interfaces.syndication import ISiteSyndicationSettings  # noqa\n-    HAS_SYNDICATION = True\n-except ImportError:\n-    # new syndication not available\n-    HAS_SYNDICATION = False\n-\n-_ = MessageFactory(\'plone\')\n-\n \n @implementer(IVocabularyFactory)\n-class SyndicationFeedTypesVocabulary(object):\n-\n+class SyndicationFeedTypesVocabulary:\n     def __call__(self, context):\n-        if not HAS_SYNDICATION:\n-            return SimpleVocabulary([])\n         registry = getUtility(IRegistry)\n         try:\n             settings = registry.forInterface(ISiteSyndicationSettings)\n@@ -36,38 +21,38 @@ def __call__(self, context):\n             return SimpleVocabulary([])\n         items = []\n         for _type in settings.allowed_feed_types:\n-            split = _type.split(\'|\')\n+            split = _type.split("|")\n             if len(split) == 2:\n                 name, title = split\n                 items.append(SimpleTerm(name, name, title))\n         return SimpleVocabulary(items)\n \n+\n SyndicationFeedTypesVocabularyFactory = SyndicationFeedTypesVocabulary()\n \n \n @implementer(IVocabularyFactory)\n-class SyndicatableFeedItems(object):\n-\n+class SyndicatableFeedItems:\n     def __call__(self, context):\n         site = getSite()\n-        catalog = getToolByName(site, \'portal_catalog\')\n-        site_path = \'/\'.join(site.getPhysicalPath())\n+        catalog = getToolByName(site, "portal_catalog")\n+        site_path = "/".join(site.getPhysicalPath())\n         query = {\n-            \'portal_type\': (\'Folder\', \'Collection\', \'Topic\'),\n-            \'path\': {\'query\': site_path,\n-                     \'depth\': 2}\n+            "portal_type": ("Folder", "Collection", "Topic"),\n+            "path": {"query": site_path, "depth": 2},\n         }\n         items = []\n         for brain in catalog(**query):\n             uid = brain.UID\n             title = brain.Title\n-            if isinstance(title, six.binary_type):\n-                title = title.decode(\'utf8\')\n-            title = u\'{0}({1})\'.format(\n+            if isinstance(title, bytes):\n+                title = title.decode("utf8")\n+            title = "{}({})".format(\n                 title,\n-                brain.getPath()[len(site_path) + 1:],\n+                brain.getPath()[len(site_path) + 1 :],\n             )\n             items.append(SimpleTerm(uid, uid, title))\n         return SimpleVocabulary(items)\n \n+\n SyndicatableFeedItemsFactory = SyndicatableFeedItems()\ndiff --git a/plone/app/vocabularies/terms.py b/plone/app/vocabularies/terms.py\nindex 7251da8..3776f9b 100644\n--- a/plone/app/vocabularies/terms.py\n+++ b/plone/app/vocabularies/terms.py\n@@ -1,21 +1,21 @@\n-# -*- coding: utf-8 -*-\n from base64 import urlsafe_b64encode\n from plone.app.vocabularies.interfaces import IBrowsableTerm\n from plone.app.vocabularies.interfaces import ITermWithDescription\n-from Products.CMFPlone.utils import safe_unicode\n+from plone.base.utils import safe_bytes\n+from plone.base.utils import safe_text\n+from zope.deprecation import deprecate\n from zope.interface import alsoProvides\n from zope.interface import implementer\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n \n-import six\n-\n \n+@deprecate("Use plone.base.utils.safe_bytes instead. Will be removed with version 6.")\n def safe_encode(value):\n-    if isinstance(value, six.text_type):\n+    if isinstance(value, str):\n         # no need to use portal encoding for transitional encoding from\n         # unicode to ascii. utf-8 should be fine.\n-        value = value.encode(\'utf-8\')\n+        value = value.encode("utf-8")\n     return value\n \n \n@@ -26,12 +26,11 @@ def safe_simpleterm_from_value(value):\n     - tokens cannot contain newlines\n     - anything for display has to be cleaned up, titles *must* be unicode\n     """\n-    return SimpleTerm(value, urlsafe_b64encode(safe_encode(value)), safe_unicode(value))\n+    return SimpleTerm(value, urlsafe_b64encode(safe_bytes(value)), safe_text(value))\n \n \n def safe_simplevocabulary_from_values(values, query=None):\n-    """Creates (filtered) SimpleVocabulary from iterable of untrusted values.\n-    """\n+    """Creates (filtered) SimpleVocabulary from iterable of untrusted values."""\n     items = [\n         safe_simpleterm_from_value(i)\n         for i in values\n@@ -43,53 +42,51 @@ def safe_simplevocabulary_from_values(values, query=None):\n @implementer(ITermWithDescription)\n class TermWithDescription(SimpleTerm):\n     """\n-      >>> term = TermWithDescription(\'value\', \'token\', \'title\')\n-      >>> term.value, term.token, term.title, term.description\n-      (\'value\', \'token\', \'title\', None)\n-\n-      >>> term = TermWithDescription(\'value\', \'token\', \'title\',\n-      ...                            description=\'description\')\n-      >>> term.value, term.token, term.title, term.description\n-      (\'value\', \'token\', \'title\', \'description\')\n+    >>> term = TermWithDescription(\'value\', \'token\', \'title\')\n+    >>> term.value, term.token, term.title, term.description\n+    (\'value\', \'token\', \'title\', None)\n+\n+    >>> term = TermWithDescription(\'value\', \'token\', \'title\',\n+    ...                            description=\'description\')\n+    >>> term.value, term.token, term.title, term.description\n+    (\'value\', \'token\', \'title\', \'description\')\n     """\n \n     def __init__(self, value, token, title, description=None):\n-        super(TermWithDescription, self).__init__(\n-            value,\n-            token=token,\n-            title=title\n-        )\n+        super().__init__(value, token=token, title=title)\n         self.description = description\n \n \n class BrowsableTerm(TermWithDescription):\n     """\n-      >>> term = BrowsableTerm(\'value\')\n-      >>> term.value, term.token, term.title, term.description\n-      (\'value\', \'value\', None, None)\n-      >>> IBrowsableTerm.providedBy(term)\n-      False\n-\n-      >>> term = BrowsableTerm(\'value\', \'token\', \'title\',\n-      ...                      description=\'description\',\n-      ...                      browse_token=\'browse_token\',\n-      ...                      parent_token=\'parent_token\')\n-      >>> term.value, term.token, term.title, term.description\n-      (\'value\', \'token\', \'title\', \'description\')\n-      >>> term.browse_token, term.parent_token\n-      (\'browse_token\', \'parent_token\')\n-      >>> IBrowsableTerm.providedBy(term)\n-      True\n+    >>> term = BrowsableTerm(\'value\')\n+    >>> term.value, term.token, term.title, term.description\n+    (\'value\', \'value\', None, None)\n+    >>> IBrowsableTerm.providedBy(term)\n+    False\n+\n+    >>> term = BrowsableTerm(\'value\', \'token\', \'title\',\n+    ...                      description=\'description\',\n+    ...                      browse_token=\'browse_token\',\n+    ...                      parent_token=\'parent_token\')\n+    >>> term.value, term.token, term.title, term.description\n+    (\'value\', \'token\', \'title\', \'description\')\n+    >>> term.browse_token, term.parent_token\n+    (\'browse_token\', \'parent_token\')\n+    >>> IBrowsableTerm.providedBy(term)\n+    True\n     """\n \n-    def __init__(self, value, token=None, title=None, description=None,\n-                 browse_token=None, parent_token=None):\n-        super(BrowsableTerm, self).__init__(\n-            value,\n-            token=token,\n-            title=title,\n-            description=description\n-        )\n+    def __init__(\n+        self,\n+        value,\n+        token=None,\n+        title=None,\n+        description=None,\n+        browse_token=None,\n+        parent_token=None,\n+    ):\n+        super().__init__(value, token=token, title=title, description=description)\n         self.browse_token = browse_token\n         self.parent_token = parent_token\n         if browse_token is not None or parent_token is not None:\ndiff --git a/plone/app/vocabularies/testing.py b/plone/app/vocabularies/testing.py\nindex a482206..5d46f81 100644\n--- a/plone/app/vocabularies/testing.py\n+++ b/plone/app/vocabularies/testing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.testing import IntegrationTesting\n from plone.app.testing import PLONE_FIXTURE\n from plone.app.testing import PloneSandboxLayer\n@@ -10,13 +9,12 @@ class PAVocabulariesLayer(PloneSandboxLayer):\n     def setUpZope(self, app, configurationContext):\n         # Load ZCML\n         import plone.app.vocabularies\n-        self.loadZCML(\n-            package=plone.app.vocabularies,\n-            context=configurationContext\n-        )\n+\n+        self.loadZCML(package=plone.app.vocabularies, context=configurationContext)\n+\n \n PAVocabularies_FIXTURE = PAVocabulariesLayer()\n PAVocabularies_INTEGRATION_TESTING = IntegrationTesting(\n     bases=(PAVocabularies_FIXTURE,),\n-    name=\'PAVocabularies:Integration\',\n+    name="PAVocabularies:Integration",\n )\ndiff --git a/plone/app/vocabularies/tests/__init__.py b/plone/app/vocabularies/tests/__init__.py\nindex 40a96af..e69de29 100644\n--- a/plone/app/vocabularies/tests/__init__.py\n+++ b/plone/app/vocabularies/tests/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/vocabularies/tests/base.py b/plone/app/vocabularies/tests/base.py\nindex 7c3136d..8bef5ca 100644\n--- a/plone/app/vocabularies/tests/base.py\n+++ b/plone/app/vocabularies/tests/base.py\n@@ -1,9 +1,8 @@\n-# -*- coding: utf-8 -*-\n from OFS.interfaces import IItem\n from plone.app.layout.navigation.interfaces import INavigationRoot\n from Products.ZCTextIndex.ParseTree import ParseError\n-from zope.interface import implementer\n from zope.component.hooks import setSite\n+from zope.interface import implementer\n \n \n def create_context():\n@@ -12,26 +11,26 @@ def create_context():\n     return context\n \n \n-class DummyContext(object):\n-\n+class DummyContext:\n     def __init__(self):\n-        self.__name__ = \'dummy\'\n+        self.__name__ = "dummy"\n         self.__parent__ = None\n \n     def getSiteManager(self):\n         from zope.component import getSiteManager\n+\n         return getSiteManager()\n \n     def getPhysicalPath(self):\n-        return [\'\', self.__name__]\n+        return ["", self.__name__]\n \n     def absolute_url(self, relative=False):\n-        return \'/\'.join(self.getPhysicalPath())\n+        return "/".join(self.getPhysicalPath())\n \n \n-class DummyUrlTool(object):\n+class DummyUrlTool:\n \n-    name = \'portal_url\'\n+    name = "portal_url"\n \n     def __init__(self, context):\n         self.portal = context\n@@ -43,14 +42,12 @@ def getPortalObject(self):\n         return self.portal\n \n \n-class DummyTool(object):\n-\n+class DummyTool:\n     def __init__(self, name):\n         self.name = name\n \n \n-class DummyType(object):\n-\n+class DummyType:\n     def __init__(self, title):\n         self.title = title\n \n@@ -59,19 +56,17 @@ def Title(self):\n \n \n class DummyTypeTool(dict):\n-\n     def __init__(self):\n-        self[\'Document\'] = DummyType(\'Page\')\n-        self[\'Event\'] = DummyType(\'Event\')\n+        self["Document"] = DummyType("Page")\n+        self["Event"] = DummyType("Event")\n \n     def listContentTypes(self):\n         return self.keys()\n \n \n class Response(dict):\n-\n     def getHeader(self, value):\n-        return \'header {0}\'.format(value)\n+        return f"header {value}"\n \n \n class Request(dict):\n@@ -83,9 +78,9 @@ def __init__(self, form=None):\n         self.form = form\n \n \n-class Brain(object):\n+class Brain:\n \n-    Title = \'BrainTitle\'\n+    Title = "BrainTitle"\n     is_folderish = True\n \n     def __init__(self, rid):\n@@ -95,7 +90,7 @@ def getPath(self):\n         return self.rid\n \n     def getURL(self):\n-        return \'proto:\' + self.rid\n+        return "proto:" + self.rid\n \n     @property\n     def UID(self):\n@@ -104,16 +99,15 @@ def UID(self):\n \n @implementer(IItem)\n class DummyCatalog(dict):\n-\n     def __init__(self, values):\n         self.indexes = {}\n         for r in values:\n             self[r] = Brain(r)\n \n     def __call__(self, **values):\n-        if \'SearchableText\' in values:\n-            st = values[\'SearchableText\']\n-            if st.startswith(\'error\'):\n+        if "SearchableText" in values:\n+            st = values["SearchableText"]\n+            if st.startswith("error"):\n                 raise ParseError\n         return self.values()\n \n@@ -128,8 +122,7 @@ def getIndex(self, name):\n         return self.indexes[name]\n \n \n-class DummyContent(object):\n-\n+class DummyContent:\n     def __init__(self, title, subjects=[]):\n         self.title = title\n         self.subjects = subjects\n@@ -141,7 +134,7 @@ def Subject(self):\n         return self.subjects\n \n \n-class DummyContentWithParent(object):\n+class DummyContentWithParent:\n     __parent__ = None\n \n     def __init__(self, cid, title=None, subjects=[], parent=None):\n@@ -160,11 +153,11 @@ def getPhysicalPath(self):\n         return self.__parent__.getPhysicalPath() + [self.__name__]\n \n     def absolute_url(self, relative=False):\n-        return \'/\'.join(self.getPhysicalPath())\n+        return "/".join(self.getPhysicalPath())\n \n \n @implementer(INavigationRoot)\n-class DummyNavRoot(object):\n+class DummyNavRoot:\n     __parent__ = None\n \n     def __init__(self, _id, title=None, parent=None):\n@@ -174,10 +167,10 @@ def __init__(self, _id, title=None, parent=None):\n             self.__parent__ = parent\n \n     def getPhysicalPath(self):\n-        return [\'\', self.__parent__.__name__, self.__name__]\n+        return ["", self.__parent__.__name__, self.__name__]\n \n     def absolute_url(self, relative=False):\n-        return \'/\'.join(self.getPhysicalPath())\n+        return "/".join(self.getPhysicalPath())\n \n     @property\n     def portal_catalog(self):\ndiff --git a/plone/app/vocabularies/tests/test_editors.py b/plone/app/vocabularies/tests/test_editors.py\nindex 7fa119d..e011dc4 100644\n--- a/plone/app/vocabularies/tests/test_editors.py\n+++ b/plone/app/vocabularies/tests/test_editors.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n from zope.component import getUtility\n from zope.schema.interfaces import IVocabularyFactory\n@@ -11,19 +10,20 @@ class AvailableEditorsTest(unittest.TestCase):\n     layer = PAVocabularies_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def test_editors(self):\n         from plone.registry import Registry\n+\n         registry = Registry()\n-        from Products.CMFPlone.interfaces import IEditingSchema\n-        registry.registerInterface(IEditingSchema, prefix=\'plone\')\n-        registry.records[\'plone.available_editors\']\n+        from plone.base.interfaces import IEditingSchema\n+\n+        registry.registerInterface(IEditingSchema, prefix="plone")\n+        registry.records["plone.available_editors"]\n         vocab_util = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.AvailableEditors\'\n+            IVocabularyFactory, "plone.app.vocabularies.AvailableEditors"\n         )\n         editors = vocab_util(self.portal)\n         self.assertEqual(2, len(editors.by_token))\n-        self.assertTrue(\'None\' in [x for x in editors.by_token])\n-        self.assertTrue(\'TinyMCE\' in [x for x in editors.by_token])\n+        self.assertTrue("None" in [x for x in editors.by_token])\n+        self.assertTrue("TinyMCE" in [x for x in editors.by_token])\ndiff --git a/plone/app/vocabularies/tests/test_imagesvocabularies.py b/plone/app/vocabularies/tests/test_imagesvocabularies.py\nindex 5c93d47..ad7e0d7 100644\n--- a/plone/app/vocabularies/tests/test_imagesvocabularies.py\n+++ b/plone/app/vocabularies/tests/test_imagesvocabularies.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n from zope.component import getUtility\n from zope.schema.interfaces import IVocabularyFactory\n@@ -10,14 +9,13 @@ class ImagesTest(unittest.TestCase):\n     layer = PAVocabularies_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def test_images_scales_vocabulary(self):\n         images_scales_voc = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.ImagesScales\'\n+            IVocabularyFactory, "plone.app.vocabularies.ImagesScales"\n         )\n         scales_list = [item.value for item in images_scales_voc(self.portal)]\n-        self.assertTrue(\'thumb\' in scales_list)\n-        self.assertTrue(\'large\' in scales_list)\n-        self.assertTrue(\'preview\' in scales_list)\n+        self.assertTrue("thumb" in scales_list)\n+        self.assertTrue("large" in scales_list)\n+        self.assertTrue("preview" in scales_list)\ndiff --git a/plone/app/vocabularies/tests/test_principals.py b/plone/app/vocabularies/tests/test_principals.py\nindex 134a629..e93bf81 100644\n--- a/plone/app/vocabularies/tests/test_principals.py\n+++ b/plone/app/vocabularies/tests/test_principals.py\n@@ -1,7 +1,6 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n+from unittest import mock\n \n-import mock\n import unittest\n \n \n@@ -9,110 +8,108 @@ class PrincipalsTest(unittest.TestCase):\n     layer = PAVocabularies_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def _make_user(self, userid, fullname):\n-        user = self.portal[\'acl_users\']._doAddUser(\n-            userid, \'secret\', [\'Member\'], []\n-        )\n+        user = self.portal["acl_users"]._doAddUser(userid, "secret", ["Member"], [])\n         user.setProperties(fullname=fullname)\n \n     def _make_group(self, groupid, title):\n-        self.portal[\'acl_users\']._doAddGroup(groupid, [], title=title)\n+        self.portal["acl_users"]._doAddGroup(groupid, [], title=title)\n \n     def test_empty_principals_vocabulary(self):\n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary([])\n-        vocab.principal_source = \'user\'\n+        vocab.principal_source = "user"\n \n         # basic data\n-        self.assertEqual(vocab.principal_source, \'user\')\n-        self.assertEqual(vocab._acl_users, self.portal[\'acl_users\'])\n+        self.assertEqual(vocab.principal_source, "user")\n+        self.assertEqual(vocab._acl_users, self.portal["acl_users"])\n \n     def test_pas_connectivity_user(self):\n-        self._make_user(\'user1\', \'User One\')\n+        self._make_user("user1", "User One")\n \n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary([])\n-        vocab.principal_source = \'user\'\n+        vocab.principal_source = "user"\n \n         # test 1\n-        vuser = vocab._get_principal_from_source(\'user1\')\n-        self.assertEqual(vuser.getId(), \'user1\')\n+        vuser = vocab._get_principal_from_source("user1")\n+        self.assertEqual(vuser.getId(), "user1")\n \n         # test 2\n-        term = vocab.getTerm(\'user1\')\n-        self.assertEqual(term.value, \'user1\')\n-        self.assertEqual(term.token, \'user1\')\n-        self.assertEqual(term.title, \'User One\')\n+        term = vocab.getTerm("user1")\n+        self.assertEqual(term.value, "user1")\n+        self.assertEqual(term.token, "user1")\n+        self.assertEqual(term.title, "User One")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'user:non-existing\')\n+            term = vocab.getTerm("user:non-existing")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'non-existing\')\n+            term = vocab.getTerm("non-existing")\n \n     def test_pas_connectivity_group(self):\n-        self._make_group(\'group1\', \'Group One\')\n+        self._make_group("group1", "Group One")\n \n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary([])\n-        vocab.principal_source = \'group\'\n+        vocab.principal_source = "group"\n \n         # test 1\n-        vgroup = vocab._get_principal_from_source(\'group1\')\n-        self.assertEqual(vgroup.getId(), \'group1\')\n+        vgroup = vocab._get_principal_from_source("group1")\n+        self.assertEqual(vgroup.getId(), "group1")\n \n         # test 2\n-        term = vocab.getTerm(\'group1\')\n-        self.assertEqual(term.value, \'group1\')\n-        self.assertEqual(term.token, \'group1\')\n-        self.assertEqual(term.title, \'Group One\')\n+        term = vocab.getTerm("group1")\n+        self.assertEqual(term.value, "group1")\n+        self.assertEqual(term.token, "group1")\n+        self.assertEqual(term.title, "Group One")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'group:non-existing\')\n+            term = vocab.getTerm("group:non-existing")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'non-existing\')\n+            term = vocab.getTerm("non-existing")\n \n     def test_pas_connectivity_principal(self):\n-        self._make_user(\'user1\', \'User One\')\n-        self._make_group(\'group1\', \'Group One\')\n+        self._make_user("user1", "User One")\n+        self._make_group("group1", "Group One")\n \n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary([])\n-        vocab.principal_source = \'principal\'\n+        vocab.principal_source = "principal"\n \n         # test 1\n-        vgroup = vocab._get_principal_from_source(\'user:user1\')\n-        self.assertEqual(vgroup.getId(), \'user1\')\n-        vgroup = vocab._get_principal_from_source(\'group:group1\')\n-        self.assertEqual(vgroup.getId(), \'group1\')\n+        vgroup = vocab._get_principal_from_source("user:user1")\n+        self.assertEqual(vgroup.getId(), "user1")\n+        vgroup = vocab._get_principal_from_source("group:group1")\n+        self.assertEqual(vgroup.getId(), "group1")\n \n         # test 2\n-        term = vocab.getTerm(\'user:user1\')\n-        self.assertEqual(term.value, \'user:user1\')\n-        self.assertEqual(term.token, \'user__user1\')\n-        self.assertEqual(term.title, \'User One\')\n-        term = vocab.getTerm(\'group:group1\')\n-        self.assertEqual(term.value, \'group:group1\')\n-        self.assertEqual(term.token, \'group__group1\')\n-        self.assertEqual(term.title, \'Group One\')\n+        term = vocab.getTerm("user:user1")\n+        self.assertEqual(term.value, "user:user1")\n+        self.assertEqual(term.token, "user__user1")\n+        self.assertEqual(term.title, "User One")\n+        term = vocab.getTerm("group:group1")\n+        self.assertEqual(term.value, "group:group1")\n+        self.assertEqual(term.token, "group__group1")\n+        self.assertEqual(term.title, "Group One")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'user:non-existing\')\n+            term = vocab.getTerm("user:non-existing")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'group:non-existing\')\n+            term = vocab.getTerm("group:non-existing")\n         with self.assertRaises(LookupError):\n-            term = vocab.getTerm(\'non-existing\')\n+            term = vocab.getTerm("non-existing")\n \n     def test_populated_user(self):\n         from zope.schema.vocabulary import SimpleTerm\n \n         terms = [\n             SimpleTerm(\n-                \'user_{0}\'.format(idx),\n-                \'user{0}\'.format(idx),\n-                \'User {0}\'.format(idx),\n+                f"user_{idx}",\n+                f"user{idx}",\n+                f"User {idx}",\n             )\n             for idx in range(0, 10)\n         ]\n@@ -120,33 +117,33 @@ def test_populated_user(self):\n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary(terms)\n-        vocab.principal_source = \'user\'\n+        vocab.principal_source = "user"\n \n-        self.assertEqual(vocab.getTerm(\'user_3\').value, \'user_3\')\n-        self.assertEqual(vocab.getTerm(\'user_3\').token, \'user3\')\n-        self.assertEqual(vocab.getTerm(\'user_3\').title, \'User 3\')\n+        self.assertEqual(vocab.getTerm("user_3").value, "user_3")\n+        self.assertEqual(vocab.getTerm("user_3").token, "user3")\n+        self.assertEqual(vocab.getTerm("user_3").title, "User 3")\n \n-        self.assertEqual(vocab.getTermByToken(\'user3\').value, \'user_3\')\n-        self.assertEqual(vocab.getTermByToken(\'user3\').token, \'user3\')\n-        self.assertEqual(vocab.getTermByToken(\'user3\').title, \'User 3\')\n+        self.assertEqual(vocab.getTermByToken("user3").value, "user_3")\n+        self.assertEqual(vocab.getTermByToken("user3").token, "user3")\n+        self.assertEqual(vocab.getTermByToken("user3").title, "User 3")\n \n-        self.assertEqual(vocab[6].value, \'user_6\')\n+        self.assertEqual(vocab[6].value, "user_6")\n         self.assertEqual(\n-            [\'user_2\', \'user_3\', \'user_4\', \'user_5\'],\n+            ["user_2", "user_3", "user_4", "user_5"],\n             [term.value for term in vocab[2:6]],\n         )\n \n-        self.assertTrue(\'user_2\' in vocab)\n-        self.assertFalse(\'non-existing\' in vocab)\n+        self.assertTrue("user_2" in vocab)\n+        self.assertFalse("non-existing" in vocab)\n \n     def test_populated_group(self):\n         from zope.schema.vocabulary import SimpleTerm\n \n         terms = [\n             SimpleTerm(\n-                \'group_{0}\'.format(idx),\n-                \'group{0}\'.format(idx),\n-                \'Group {0}\'.format(idx),\n+                f"group_{idx}",\n+                f"group{idx}",\n+                f"Group {idx}",\n             )\n             for idx in range(0, 10)\n         ]\n@@ -154,41 +151,41 @@ def test_populated_group(self):\n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary(terms)\n-        vocab.principal_source = \'group\'\n+        vocab.principal_source = "group"\n \n-        self.assertEqual(vocab.getTerm(\'group_3\').value, \'group_3\')\n-        self.assertEqual(vocab.getTerm(\'group_3\').token, \'group3\')\n-        self.assertEqual(vocab.getTerm(\'group_3\').title, \'Group 3\')\n+        self.assertEqual(vocab.getTerm("group_3").value, "group_3")\n+        self.assertEqual(vocab.getTerm("group_3").token, "group3")\n+        self.assertEqual(vocab.getTerm("group_3").title, "Group 3")\n \n-        self.assertEqual(vocab.getTermByToken(\'group3\').value, \'group_3\')\n-        self.assertEqual(vocab.getTermByToken(\'group3\').token, \'group3\')\n-        self.assertEqual(vocab.getTermByToken(\'group3\').title, \'Group 3\')\n+        self.assertEqual(vocab.getTermByToken("group3").value, "group_3")\n+        self.assertEqual(vocab.getTermByToken("group3").token, "group3")\n+        self.assertEqual(vocab.getTermByToken("group3").title, "Group 3")\n \n-        self.assertEqual(vocab[6].value, \'group_6\')\n+        self.assertEqual(vocab[6].value, "group_6")\n         self.assertEqual(\n-            [\'group_2\', \'group_3\', \'group_4\', \'group_5\'],\n+            ["group_2", "group_3", "group_4", "group_5"],\n             [term.value for term in vocab[2:6]],\n         )\n \n-        self.assertTrue(\'group_2\' in vocab)\n-        self.assertFalse(\'non-existing\' in vocab)\n+        self.assertTrue("group_2" in vocab)\n+        self.assertFalse("non-existing" in vocab)\n \n     def test_populated_principals(self):\n         from zope.schema.vocabulary import SimpleTerm\n \n         terms = [\n             SimpleTerm(\n-                \'user:user_{0}\'.format(idx),\n-                \'user__user{0}\'.format(idx),\n-                \'User {0}\'.format(idx),\n+                f"user:user_{idx}",\n+                f"user__user{idx}",\n+                f"User {idx}",\n             )\n             for idx in range(0, 10)\n         ]\n         terms += [\n             SimpleTerm(\n-                \'group:group_{0}\'.format(idx),\n-                \'group__group{0}\'.format(idx),\n-                \'Group {0}\'.format(idx),\n+                f"group:group_{idx}",\n+                f"group__group{idx}",\n+                f"Group {idx}",\n             )\n             for idx in range(0, 10)\n         ]\n@@ -196,252 +193,248 @@ def test_populated_principals(self):\n         from plone.app.vocabularies.principals import PrincipalsVocabulary\n \n         vocab = PrincipalsVocabulary(terms)\n-        vocab.principal_source = \'principal\'\n+        vocab.principal_source = "principal"\n \n         # users\n-        self.assertEqual(vocab.getTerm(\'user:user_4\').value, \'user:user_4\')\n-        self.assertEqual(vocab.getTerm(\'user:user_3\').token, \'user__user3\')\n-        self.assertEqual(vocab.getTerm(\'user:user_6\').title, \'User 6\')\n+        self.assertEqual(vocab.getTerm("user:user_4").value, "user:user_4")\n+        self.assertEqual(vocab.getTerm("user:user_3").token, "user__user3")\n+        self.assertEqual(vocab.getTerm("user:user_6").title, "User 6")\n \n-        self.assertEqual(\n-            vocab.getTermByToken(\'user__user4\').value, \'user:user_4\'\n-        )\n-        self.assertEqual(\n-            vocab.getTermByToken(\'user__user3\').token, \'user__user3\'\n-        )\n-        self.assertEqual(vocab.getTermByToken(\'user__user6\').title, \'User 6\')\n+        self.assertEqual(vocab.getTermByToken("user__user4").value, "user:user_4")\n+        self.assertEqual(vocab.getTermByToken("user__user3").token, "user__user3")\n+        self.assertEqual(vocab.getTermByToken("user__user6").title, "User 6")\n \n-        self.assertTrue(\'user:user_2\' in vocab)\n-        self.assertFalse(\'non-existing\' in vocab)\n+        self.assertTrue("user:user_2" in vocab)\n+        self.assertFalse("non-existing" in vocab)\n \n         # groups\n-        self.assertEqual(vocab.getTerm(\'group:group_3\').value, \'group:group_3\')\n-        self.assertEqual(vocab.getTerm(\'group:group_3\').token, \'group__group3\')\n-        self.assertEqual(vocab.getTerm(\'group:group_3\').title, \'Group 3\')\n+        self.assertEqual(vocab.getTerm("group:group_3").value, "group:group_3")\n+        self.assertEqual(vocab.getTerm("group:group_3").token, "group__group3")\n+        self.assertEqual(vocab.getTerm("group:group_3").title, "Group 3")\n \n-        self.assertEqual(\n-            vocab.getTermByToken(\'group__group3\').value, \'group:group_3\'\n-        )\n-        self.assertEqual(\n-            vocab.getTermByToken(\'group__group3\').token, \'group__group3\'\n-        )\n-        self.assertEqual(\n-            vocab.getTermByToken(\'group__group3\').title, \'Group 3\'\n-        )\n+        self.assertEqual(vocab.getTermByToken("group__group3").value, "group:group_3")\n+        self.assertEqual(vocab.getTermByToken("group__group3").token, "group__group3")\n+        self.assertEqual(vocab.getTermByToken("group__group3").title, "Group 3")\n \n         # getitem/slice\n-        self.assertEqual(vocab[6].value, \'user:user_6\')\n+        self.assertEqual(vocab[6].value, "user:user_6")\n         self.assertEqual(\n-            [\'group:group_7\', \'group:group_8\', \'group:group_9\'],\n+            ["group:group_7", "group:group_8", "group:group_9"],\n             [term.value for term in vocab[17:]],\n         )\n         self.assertEqual(\n-            [\'user:user_8\', \'user:user_9\', \'group:group_0\'],\n+            ["user:user_8", "user:user_9", "group:group_0"],\n             [term.value for term in vocab[8:11]],\n         )\n \n         # contains works too (by token)\n-        self.assertTrue(\'group:group_2\' in vocab)\n-        self.assertFalse(\'non-existing\' in vocab)\n+        self.assertTrue("group:group_2" in vocab)\n+        self.assertFalse("non-existing" in vocab)\n \n     def test_factory_user_blank(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            userid = \'us\xc3\xa9r{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' \xc3\x9cser\'\n+            userid = f"us\xc3\xa9r{idx}"\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " \xc3\x9cser"\n             self._make_user(userid, fullname)\n \n         from plone.app.vocabularies.principals import UsersFactory\n \n         factory = UsersFactory()\n         vocab = factory(self.portal)\n-        self.assertEqual(vocab.getTerm(\'us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTerm(\'us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n+        self.assertEqual(vocab.getTerm("us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTerm("us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n \n     def test_factory_user_query(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            userid = \'us\xc3\xa9r{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' \xc3\x9cser\'\n+            userid = f"us\xc3\xa9r{idx}"\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " \xc3\x9cser"\n             self._make_user(userid, fullname)\n \n         from plone.app.vocabularies.principals import UsersFactory\n \n         factory = UsersFactory()\n-        vocab = factory(self.portal, query=\'Cde\')\n+        vocab = factory(self.portal, query="Cde")\n \n         # reduced by query\n-        self.assertEqual([term.value for term in vocab], [\'us\xc3\xa9r2\'])\n+        self.assertEqual([term.value for term in vocab], ["us\xc3\xa9r2"])\n \n         # getTerm[ByToken] still works for all\n-        self.assertEqual(vocab.getTerm(\'us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTerm(\'us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n+        self.assertEqual(vocab.getTerm("us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTerm("us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n \n         # contains works (by value)\n-        self.assertTrue(\'us\xc3\xa9r0\' in vocab)\n-        self.assertTrue(\'us\xc3\xa9r2\' in vocab)\n+        self.assertTrue("us\xc3\xa9r0" in vocab)\n+        self.assertTrue("us\xc3\xa9r2" in vocab)\n \n     def test_factory_group_blank(self):\n         for idx in range(0, 10):\n             # creates group0: \'Abc Group\'; group1, \'Bcd Group\', ...\n-            groupid = \'gro\xc3\xbcp{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' Gr\xc3\xb6\xc3\xbcp\'\n+            groupid = f"gro\xc3\xbcp{idx}"\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " Gr\xc3\xb6\xc3\xbcp"\n             self._make_group(groupid, fullname)\n \n         from plone.app.vocabularies.principals import GroupsFactory\n \n         factory = GroupsFactory()\n         vocab = factory(self.portal)\n-        self.assertEqual(vocab.getTerm(\'gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTerm(\'gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n+        self.assertEqual(vocab.getTerm("gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTerm("gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n \n     def test_factory_group_query(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            groupid = \'gro\xc3\xbcp{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' Gr\xc3\xb6\xc3\xbcp\'\n+            groupid = f"gro\xc3\xbcp{idx}"\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " Gr\xc3\xb6\xc3\xbcp"\n             self._make_group(groupid, fullname)\n \n         from plone.app.vocabularies.principals import GroupsFactory\n \n         factory = GroupsFactory()\n-        vocab = factory(self.portal, query=\'Cde\')\n+        vocab = factory(self.portal, query="Cde")\n \n         # reduced by query\n-        self.assertEqual([term.value for term in vocab], [\'gro\xc3\xbcp2\'])\n+        self.assertEqual([term.value for term in vocab], ["gro\xc3\xbcp2"])\n \n         # getTerm[ByToken] still works for all\n-        self.assertEqual(vocab.getTerm(\'gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTerm(\'gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n+        self.assertEqual(vocab.getTerm("gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTerm("gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n \n         # contains works too (by token)\n-        self.assertTrue(\'gro\xc3\xbcp0\' in vocab)\n-        self.assertTrue(\'gro\xc3\xbcp2\' in vocab)\n+        self.assertTrue("gro\xc3\xbcp0" in vocab)\n+        self.assertTrue("gro\xc3\xbcp2" in vocab)\n \n     def test_factory_principal_blank(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            userid = \'us\xc3\xa9r{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' \xc3\x9cser\'\n+            userid = f"us\xc3\xa9r{idx}"\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " \xc3\x9cser"\n             self._make_user(userid, fullname)\n         for idx in range(0, 10):\n             # creates group0: \'Abc Group\'; group1, \'Bcd Group\', ...\n-            groupid = \'gro\xc3\xbcp{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' Gr\xc3\xb6\xc3\xbcp\'\n+            groupid = f"gro\xc3\xbcp{idx}"\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " Gr\xc3\xb6\xc3\xbcp"\n             self._make_group(groupid, fullname)\n \n         from plone.app.vocabularies.principals import PrincipalsFactory\n \n         factory = PrincipalsFactory()\n         vocab = factory(self.portal)\n-        self.assertEqual(vocab.getTerm(\'user:us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTerm(\'user:us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n-        self.assertEqual(vocab.getTerm(\'group:gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTerm(\'group:gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'user__us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'user__us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'group__gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'group__gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n+        self.assertEqual(vocab.getTerm("user:us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTerm("user:us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n+        self.assertEqual(vocab.getTerm("group:gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTerm("group:gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("user__us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("user__us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("group__gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("group__gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n \n     def test_factory_principal_query(self):\n         for idx in range(0, 10):\n             # creates user0: \'Abc User\'; user1, \'Bcd User\', ...\n-            userid = \'us\xc3\xa9r{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' \xc3\x9cser\'\n+            userid = f"us\xc3\xa9r{idx}"\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " \xc3\x9cser"\n             self._make_user(userid, fullname)\n         for idx in range(0, 10):\n             # creates group0: \'Abc Group\'; group1, \'Bcd Group\', ...\n-            groupid = \'gro\xc3\xbcp{0}\'.format(idx)\n-            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + \' Gr\xc3\xb6\xc3\xbcp\'\n+            groupid = f"gro\xc3\xbcp{idx}"\n+            fullname = chr(65 + idx) + chr(98 + idx) + chr(99 + idx) + " Gr\xc3\xb6\xc3\xbcp"\n             self._make_group(groupid, fullname)\n \n         from plone.app.vocabularies.principals import PrincipalsFactory\n \n         factory = PrincipalsFactory()\n-        vocab = factory(self.portal, query=\'Cde\')\n+        vocab = factory(self.portal, query="Cde")\n \n         # reduced by query\n-        self.assertEqual(\n-            [term.value for term in vocab], [\'group:gro\xc3\xbcp2\', \'user:us\xc3\xa9r2\']\n-        )\n+        self.assertEqual([term.value for term in vocab], ["group:gro\xc3\xbcp2", "user:us\xc3\xa9r2"])\n \n         # getTerm still works for all\n-        self.assertEqual(vocab.getTerm(\'user:us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTerm(\'user:us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n-        self.assertEqual(vocab.getTerm(\'group:gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTerm(\'group:gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'user__us\xc3\xa9r0\').title, \'Abc \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'user__us\xc3\xa9r2\').title, \'Cde \xc3\x9cser\')\n-        self.assertEqual(vocab.getTermByToken(\'group__gro\xc3\xbcp0\').title, \'Abc Gr\xc3\xb6\xc3\xbcp\')\n-        self.assertEqual(vocab.getTermByToken(\'group__gro\xc3\xbcp2\').title, \'Cde Gr\xc3\xb6\xc3\xbcp\')\n+        self.assertEqual(vocab.getTerm("user:us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTerm("user:us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n+        self.assertEqual(vocab.getTerm("group:gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTerm("group:gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("user__us\xc3\xa9r0").title, "Abc \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("user__us\xc3\xa9r2").title, "Cde \xc3\x9cser")\n+        self.assertEqual(vocab.getTermByToken("group__gro\xc3\xbcp0").title, "Abc Gr\xc3\xb6\xc3\xbcp")\n+        self.assertEqual(vocab.getTermByToken("group__gro\xc3\xbcp2").title, "Cde Gr\xc3\xb6\xc3\xbcp")\n \n         # contains works (by token)\n-        self.assertTrue(\'user:us\xc3\xa9r0\' in vocab)\n-        self.assertTrue(\'user:us\xc3\xa9r2\' in vocab)\n-        self.assertTrue(\'group:gro\xc3\xbcp0\' in vocab)\n-        self.assertTrue(\'group:gro\xc3\xbcp2\' in vocab)\n+        self.assertTrue("user:us\xc3\xa9r0" in vocab)\n+        self.assertTrue("user:us\xc3\xa9r2" in vocab)\n+        self.assertTrue("group:gro\xc3\xbcp0" in vocab)\n+        self.assertTrue("group:gro\xc3\xbcp2" in vocab)\n \n     def test_factory_user_duplicate(self):\n-        """ For an LDAP user that has logged in at least once, we get one\n+        """For an LDAP user that has logged in at least once, we get one\n         result each from pasldap and from mutable_properties. This should be\n         treated as one user.\n         """\n         with mock.patch(\n-            \'plone.app.vocabularies.principals._get_acl_users\',\n+            "plone.app.vocabularies.principals._get_acl_users",\n         ) as fake_get_acl_users:\n             fake_get_acl_users.return_value.searchUsers.return_value = (\n-                    {\'id\': \'ldapus\xc3\xa9r\',\n-                     \'login\': \'ldapus\xc3\xa9r\',\n-                     \'pluginid\': \'pasldap\',\n-                     \'userid\': \'ldapus\xc3\xa9r\',\n-                     \'principal_type\': \'user\',\n-                     \'title\': \'LDAP Us\xc3\xa9r\'},\n-                    {\'id\': \'ldapus\xc3\xa9r\',\n-                     \'login\': \'ldapus\xc3\xa9r\',\n-                     \'title\': \'\',\n-                     \'description\': \'\',\n-                     \'email\': \'\',\n-                     \'pluginid\': \'mutable_properties\',\n-                     \'userid\': \'ldapus\xc3\xa9r\',\n-                     \'principal_type\': \'user\'},\n+                {\n+                    "id": "ldapus\xc3\xa9r",\n+                    "login": "ldapus\xc3\xa9r",\n+                    "pluginid": "pasldap",\n+                    "userid": "ldapus\xc3\xa9r",\n+                    "principal_type": "user",\n+                    "title": "LDAP Us\xc3\xa9r",\n+                },\n+                {\n+                    "id": "ldapus\xc3\xa9r",\n+                    "login": "ldapus\xc3\xa9r",\n+                    "title": "",\n+                    "description": "",\n+                    "email": "",\n+                    "pluginid": "mutable_properties",\n+                    "userid": "ldapus\xc3\xa9r",\n+                    "principal_type": "user",\n+                },\n             )\n             from plone.app.vocabularies.principals import UsersFactory\n \n             factory = UsersFactory()\n             vocab = factory(self.portal)\n-            self.assertEqual(vocab.getTerm(\'ldapus\xc3\xa9r\').title, \'LDAP Us\xc3\xa9r\')\n+            self.assertEqual(vocab.getTerm("ldapus\xc3\xa9r").title, "LDAP Us\xc3\xa9r")\n \n     def test_factory_user_conflict(self):\n-        """ In a user vocabulary, multiple results for the same principal ID\n+        """In a user vocabulary, multiple results for the same principal ID\n         but with different principal_type values indicate some problem. Raise\n         an error.\n         """\n         with mock.patch(\n-            \'plone.app.vocabularies.principals._get_acl_users\',\n+            "plone.app.vocabularies.principals._get_acl_users",\n         ) as fake_get_acl_users:\n             fake_get_acl_users.return_value.searchUsers.return_value = (\n-                    {\'id\': \'ldapus\xc3\xa9r\',\n-                     \'login\': \'ldapus\xc3\xa9r\',\n-                     \'pluginid\': \'pasldap\',\n-                     \'userid\': \'ldapus\xc3\xa9r\',\n-                     \'principal_type\': \'user\',\n-                     \'title\': \'LDAP Us\xc3\xa9r\'},\n-                    {\'id\': \'ldapus\xc3\xa9r\',\n-                     \'login\': \'ldapus\xc3\xa9r\',\n-                     \'title\': \'\',\n-                     \'description\': \'\',\n-                     \'email\': \'\',\n-                     \'pluginid\': \'mutable_properties\',\n-                     \'userid\': \'ldapus\xc3\xa9r\',\n-                     \'principal_type\': \'unknown\'},\n+                {\n+                    "id": "ldapus\xc3\xa9r",\n+                    "login": "ldapus\xc3\xa9r",\n+                    "pluginid": "pasldap",\n+                    "userid": "ldapus\xc3\xa9r",\n+                    "principal_type": "user",\n+                    "title": "LDAP Us\xc3\xa9r",\n+                },\n+                {\n+                    "id": "ldapus\xc3\xa9r",\n+                    "login": "ldapus\xc3\xa9r",\n+                    "title": "",\n+                    "description": "",\n+                    "email": "",\n+                    "pluginid": "mutable_properties",\n+                    "userid": "ldapus\xc3\xa9r",\n+                    "principal_type": "unknown",\n+                },\n             )\n             from plone.app.vocabularies.principals import UsersFactory\n \n@@ -453,38 +446,42 @@ def test_factory_user_conflict(self):\n             )\n \n     def test_factory_principal_conflict(self):\n-        """ In a principal vocabulary, multiple results for the same principal\n+        """In a principal vocabulary, multiple results for the same principal\n         ID but with different principal_type values can be handled because they\n         are prefixed.\n         """\n         with mock.patch(\n-            \'plone.app.vocabularies.principals._get_acl_users\',\n+            "plone.app.vocabularies.principals._get_acl_users",\n         ) as fake_get_acl_users:\n             fake_get_acl_users.return_value.searchUsers.return_value = (\n-                    {\'id\': \'duplicat\xc3\xa9\',\n-                     \'login\': \'duplicat\xc3\xa9\',\n-                     \'pluginid\': \'pasldap\',\n-                     \'userid\': \'duplicat\xc3\xa9\',\n-                     \'principal_type\': \'user\',\n-                     \'title\': \'Duplicat\xc3\xa9 User\'},\n-                    {\'id\': \'duplicat\xc3\xa9\',\n-                     \'login\': \'duplicat\xc3\xa9\',\n-                     \'title\': \'Duplicat\xc3\xa9 Group\',\n-                     \'description\': \'\',\n-                     \'email\': \'\',\n-                     \'pluginid\': \'source_groups\',\n-                     \'userid\': \'duplicat\xc3\xa9\',\n-                     \'principal_type\': \'group\'},\n+                {\n+                    "id": "duplicat\xc3\xa9",\n+                    "login": "duplicat\xc3\xa9",\n+                    "pluginid": "pasldap",\n+                    "userid": "duplicat\xc3\xa9",\n+                    "principal_type": "user",\n+                    "title": "Duplicat\xc3\xa9 User",\n+                },\n+                {\n+                    "id": "duplicat\xc3\xa9",\n+                    "login": "duplicat\xc3\xa9",\n+                    "title": "Duplicat\xc3\xa9 Group",\n+                    "description": "",\n+                    "email": "",\n+                    "pluginid": "source_groups",\n+                    "userid": "duplicat\xc3\xa9",\n+                    "principal_type": "group",\n+                },\n             )\n             from plone.app.vocabularies.principals import PrincipalsFactory\n \n             factory = PrincipalsFactory()\n             vocab = factory(self.portal)\n             self.assertEqual(\n-                vocab.getTerm(\'user:duplicat\xc3\xa9\').title,\n-                \'Duplicat\xc3\xa9 User\',\n+                vocab.getTerm("user:duplicat\xc3\xa9").title,\n+                "Duplicat\xc3\xa9 User",\n             )\n             self.assertEqual(\n-                vocab.getTerm(\'group:duplicat\xc3\xa9\').title,\n-                \'Duplicat\xc3\xa9 Group\',\n+                vocab.getTerm("group:duplicat\xc3\xa9").title,\n+                "Duplicat\xc3\xa9 Group",\n             )\ndiff --git a/plone/app/vocabularies/tests/test_subjects_under_context.py b/plone/app/vocabularies/tests/test_subjects_under_context.py\nindex f1b25d5..81f2227 100644\n--- a/plone/app/vocabularies/tests/test_subjects_under_context.py\n+++ b/plone/app/vocabularies/tests/test_subjects_under_context.py\n@@ -1,9 +1,8 @@\n-# -*- coding: utf-8 -*-\n from plone.app.layout.navigation.interfaces import INavigationRoot\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n+from unittest import mock\n from zope.interface import alsoProvides\n \n-import mock\n import unittest\n \n \n@@ -13,61 +12,71 @@ class TestKeywordsUnderContext(unittest.TestCase):\n \n     def setUp(self):\n         """Custom setup for tests."""\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n         from plone.app.vocabularies.tests import base\n+\n         context = base.create_context()\n-        rids = (\'1\', \'2\',)\n+        rids = (\n+            "1",\n+            "2",\n+        )\n         tool = base.DummyCatalog(rids)\n         context.portal_catalog = tool\n         context.portal_url = base.DummyUrlTool(context)\n \n-        from Products.PluginIndexes.KeywordIndex.KeywordIndex import KeywordIndex  # noqa\n-        kwindex = KeywordIndex(\'Subject\')\n-        tool.indexes[\'Subject\'] = kwindex\n-        from Products.ExtendedPathIndex.ExtendedPathIndex import ExtendedPathIndex  # noqa\n-        pathindex = ExtendedPathIndex(\'path\')\n-        tool.indexes[\'path\'] = pathindex\n+        from Products.PluginIndexes.KeywordIndex.KeywordIndex import (  # noqa\n+            KeywordIndex,\n+        )\n+\n+        kwindex = KeywordIndex("Subject")\n+        tool.indexes["Subject"] = kwindex\n+        from Products.ExtendedPathIndex.ExtendedPathIndex import (  # noqa\n+            ExtendedPathIndex,\n+        )\n+\n+        pathindex = ExtendedPathIndex("path")\n+        tool.indexes["path"] = pathindex\n \n-        self.subjects_1 = [\'Berlin\', \'Wien\', \'Paris\', \'Barcelona\']\n-        self.subjects_2 = [\'Montreal\', \'Washington\', \'Brasilia\']\n+        self.subjects_1 = ["Berlin", "Wien", "Paris", "Barcelona"]\n+        self.subjects_2 = ["Montreal", "Washington", "Brasilia"]\n \n-        self.navroot1 = base.DummyContentWithParent(\'nr1\', parent=context)\n+        self.navroot1 = base.DummyContentWithParent("nr1", parent=context)\n         alsoProvides(self.navroot1, INavigationRoot)\n-        self.navroot2 = base.DummyContentWithParent(\'nr2\', parent=context)\n+        self.navroot2 = base.DummyContentWithParent("nr2", parent=context)\n         alsoProvides(self.navroot2, INavigationRoot)\n \n         self.doc1 = base.DummyContentWithParent(\n-            \'doc1\',\n-            subjects=self.subjects_1,\n-            parent=self.navroot1\n+            "doc1", subjects=self.subjects_1, parent=self.navroot1\n         )\n-        kwindex._index_object(1, self.doc1, attr=\'Subject\')\n+        kwindex._index_object(1, self.doc1, attr="Subject")\n         pathindex.index_object(1, self.doc1)\n \n         self.doc2 = base.DummyContentWithParent(\n-            \'doc2\',\n-            subjects=self.subjects_2,\n-            parent=self.navroot2\n+            "doc2", subjects=self.subjects_2, parent=self.navroot2\n         )\n-        kwindex._index_object(2, self.doc2, attr=\'Subject\')\n+        kwindex._index_object(2, self.doc2, attr="Subject")\n         pathindex.index_object(2, self.doc2)\n \n         from plone.app.vocabularies.catalog import KeywordsVocabulary\n+\n         self.vocab = KeywordsVocabulary()\n \n         # mock our registry\n         from plone.registry import Registry\n         from plone.registry.interfaces import IRegistry\n         from zope.component import getSiteManager\n+\n         sm = getSiteManager()\n         from Products.CMFCore.interfaces import ICatalogTool\n+\n         sm.registerUtility(tool, ICatalogTool)\n         registry = Registry()\n         sm.registerUtility(registry, IRegistry)\n         from Products.CMFCore.interfaces import IURLTool\n+\n         sm.registerUtility(context.portal_url, IURLTool)\n-        registry_patcher = mock.patch(\'plone.registry.registry.Registry.get\')\n+        registry_patcher = mock.patch("plone.registry.registry.Registry.get")\n         self.addCleanup(registry_patcher.stop)\n         self.registry_mock = registry_patcher.start()\n \ndiff --git a/plone/app/vocabularies/tests/test_timezonevocabularies.py b/plone/app/vocabularies/tests/test_timezonevocabularies.py\nindex 7b924a4..76d265c 100644\n--- a/plone/app/vocabularies/tests/test_timezonevocabularies.py\n+++ b/plone/app/vocabularies/tests/test_timezonevocabularies.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.vocabularies.testing import PAVocabularies_INTEGRATION_TESTING\n from plone.registry.interfaces import IRegistry\n from zope.component import getUtility\n@@ -11,30 +10,24 @@ class TimezoneTest(unittest.TestCase):\n     layer = PAVocabularies_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def test_timezone_vocabulary(self):\n-        tzvocab = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.Timezones\'\n-        )\n+        tzvocab = getUtility(IVocabularyFactory, "plone.app.vocabularies.Timezones")\n         tz_list = [item.value for item in tzvocab(self.portal)]\n-        self.assertTrue(\'Africa/Abidjan\' in tz_list)\n-        self.assertTrue(\'Europe/London\' in tz_list)\n+        self.assertTrue("Africa/Abidjan" in tz_list)\n+        self.assertTrue("Europe/London" in tz_list)\n \n     def test_timezone_vocabulary_query(self):\n-        tzvocab = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.Timezones\'\n-        )\n-        tz_list = [item.value for item in tzvocab(self.portal, query=\'vienna\')]\n-        self.assertTrue(\'Europe/Vienna\' in tz_list)\n+        tzvocab = getUtility(IVocabularyFactory, "plone.app.vocabularies.Timezones")\n+        tz_list = [item.value for item in tzvocab(self.portal, query="vienna")]\n+        self.assertTrue("Europe/Vienna" in tz_list)\n         self.assertTrue(len(tz_list) == 1)\n \n     def test_available_timezones_vocabulary(self):\n         reg = getUtility(IRegistry)\n         # check if "plone.available_timezones" available_timezones\' in registry\n-        reg_key = \'plone.available_timezones\'\n+        reg_key = "plone.available_timezones"\n         if reg_key not in reg:\n             # ignore for Plone 4.3 w/o plone.app.event available\n             return\n@@ -42,12 +35,10 @@ def test_available_timezones_vocabulary(self):\n         # this works only for plone.app.event 2.0\n         # initially, all common zones are available in AvailableTimezones\n         common_zones_vocab = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.CommonTimezones\'\n+            IVocabularyFactory, "plone.app.vocabularies.CommonTimezones"\n         )(self.portal)\n         avail_zones_vocab = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.AvailableTimezones\'\n+            IVocabularyFactory, "plone.app.vocabularies.AvailableTimezones"\n         )(self.portal)\n         self.assertTrue(len(common_zones_vocab) > len(avail_zones_vocab) > 0)\n \n@@ -59,8 +50,7 @@ def test_available_timezones_vocabulary(self):\n         # those changes\n         del avail_zones_vocab\n         avail_zones_vocab = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.AvailableTimezones\'\n+            IVocabularyFactory, "plone.app.vocabularies.AvailableTimezones"\n         )(self.portal)\n \n         # the length of the avail_zones_vocab is now 10\n@@ -70,8 +60,7 @@ def test_available_timezones_vocabulary(self):\n         # Test querying AvailableTimezones vocabulary\n         reg[reg_key] = common_zones\n         filtered_zones_vocab = getUtility(\n-            IVocabularyFactory,\n-            \'plone.app.vocabularies.AvailableTimezones\'\n-        )(self.portal, query=\'vienna\')\n+            IVocabularyFactory, "plone.app.vocabularies.AvailableTimezones"\n+        )(self.portal, query="vienna")\n         # filtered all items down to one\n         self.assertEqual(len(filtered_zones_vocab), 1)\ndiff --git a/plone/app/vocabularies/tests/test_vocabularies.py b/plone/app/vocabularies/tests/test_vocabularies.py\nindex c6a6740..eb587c9 100644\n--- a/plone/app/vocabularies/tests/test_vocabularies.py\n+++ b/plone/app/vocabularies/tests/test_vocabularies.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from doctest import DocTestSuite\n from zope.component import hooks\n from zope.component.testing import setUp\n@@ -7,7 +6,6 @@\n \n import doctest\n import re\n-import six\n import unittest\n import zope.component\n \n@@ -15,8 +13,9 @@\n def vocabSetUp(self):\n     setUp()\n     import plone.app.vocabularies\n-    XMLConfig(\'meta.zcml\', zope.component)()\n-    XMLConfig(\'configure.zcml\', plone.app.vocabularies)()\n+\n+    XMLConfig("meta.zcml", zope.component)()\n+    XMLConfig("configure.zcml", plone.app.vocabularies)()\n     hooks.setHooks()\n \n \n@@ -27,11 +26,9 @@ def vocabTearDown(self):\n \n \n class Py23DocChecker(doctest.OutputChecker):\n-\n     def check_output(self, want, got, optionflags):\n-        if not six.PY2:\n-            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n-            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+        want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+        want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \n@@ -39,74 +36,72 @@ def test_suite():\n     optionflags = doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE\n     return unittest.TestSuite(\n         (\n+            DocTestSuite("plone.app.vocabularies.terms"),\n             DocTestSuite(\n-                \'plone.app.vocabularies.terms\'\n-            ),\n-            DocTestSuite(\n-                \'plone.app.vocabularies.catalog\',\n+                "plone.app.vocabularies.catalog",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.datetimerelated\',\n+                "plone.app.vocabularies.datetimerelated",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.groups\',\n+                "plone.app.vocabularies.groups",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.language\',\n+                "plone.app.vocabularies.language",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.metadatafields\',\n+                "plone.app.vocabularies.metadatafields",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.security\',\n+                "plone.app.vocabularies.security",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.skins\',\n+                "plone.app.vocabularies.skins",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.types\',\n+                "plone.app.vocabularies.types",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.users\',\n+                "plone.app.vocabularies.users",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\n                 checker=Py23DocChecker(),\n             ),\n             DocTestSuite(\n-                \'plone.app.vocabularies.workflow\',\n+                "plone.app.vocabularies.workflow",\n                 setUp=vocabSetUp,\n                 tearDown=vocabTearDown,\n                 optionflags=optionflags,\ndiff --git a/plone/app/vocabularies/types.py b/plone/app/vocabularies/types.py\nindex b0b0551..57b370c 100644\n--- a/plone/app/vocabularies/types.py\n+++ b/plone/app/vocabularies/types.py\n@@ -1,17 +1,16 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_get\n from plone.app.vocabularies import PermissiveVocabulary\n from Products.CMFCore.utils import getToolByName\n+from zope.component.hooks import getSite\n from zope.i18n import translate\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n-from zope.component.hooks import getSite\n \n \n def getAllowedContentTypes(context):\n-    """ computes the list of allowed content types ...\n+    """computes the list of allowed content types ...\n     Here the mime types allowed in text fields are meant.\n \n     It does so by subtracting the site property blacklist from the list of\n@@ -19,15 +18,12 @@ def getAllowedContentTypes(context):\n     """\n     allowable_types = getAllowableContentTypes(context)\n     forbidden_types = getForbiddenContentTypes(context)\n-    allowed_types = [\n-        ctype for ctype in allowable_types\n-        if ctype not in forbidden_types\n-    ]\n+    allowed_types = [ctype for ctype in allowable_types if ctype not in forbidden_types]\n     return allowed_types\n \n \n def getAllowableContentTypes(context):\n-    """ retrieves the list of available content types (aka mime-types) ...\n+    """retrieves the list of available content types (aka mime-types) ...\n \n     ... by querying portal transforms.\n \n@@ -36,7 +32,7 @@ def getAllowableContentTypes(context):\n     by building a list of the inputs beginning with "text/" of all\n     transforms.\n     """\n-    portal_transforms = getToolByName(context, \'portal_transforms\')\n+    portal_transforms = getToolByName(context, "portal_transforms")\n     return portal_transforms.listAvailableTextInputs()\n \n \n@@ -45,19 +41,19 @@ def getForbiddenContentTypes(context):\n \n     This is a list of mime-types not allowed in text input fields.\n     """\n-    portal_properties = getToolByName(context, \'portal_properties\', None)\n+    portal_properties = getToolByName(context, "portal_properties", None)\n     if portal_properties is not None:\n         return []\n-    site_properties = getattr(portal_properties, \'site_properties\', None)\n+    site_properties = getattr(portal_properties, "site_properties", None)\n     if site_properties is not None:\n         return []\n-    if site_properties.hasProperty(\'forbidden_contenttypes\'):\n-        return list(site_properties.getProperty(\'forbidden_contenttypes\'))\n+    if site_properties.hasProperty("forbidden_contenttypes"):\n+        return list(site_properties.getProperty("forbidden_contenttypes"))\n     return []\n \n \n @implementer(IVocabularyFactory)\n-class AllowableContentTypesVocabulary(object):\n+class AllowableContentTypesVocabulary:\n     """Vocabulary factory for allowable content types.\n \n     A list of mime-types that can be used as input for textfields.\n@@ -91,16 +87,17 @@ class AllowableContentTypesVocabulary(object):\n     def __call__(self, context):\n         site = getSite()\n         items = list(getAllowableContentTypes(site))\n-        if \'text/x-plone-outputfilters-html\' in items:\n-            items.remove(\'text/x-plone-outputfilters-html\')\n+        if "text/x-plone-outputfilters-html" in items:\n+            items.remove("text/x-plone-outputfilters-html")\n         items = [SimpleTerm(i, i, i) for i in sorted(items)]\n         return SimpleVocabulary(items)\n \n+\n AllowableContentTypesVocabularyFactory = AllowableContentTypesVocabulary()\n \n \n @implementer(IVocabularyFactory)\n-class AllowedContentTypesVocabulary(object):\n+class AllowedContentTypesVocabulary:\n     """Vocabulary factory for allowed content types.\n \n     A list of mime-types that is allowed to be used as input for textfields.\n@@ -147,89 +144,93 @@ def __call__(self, context):\n         items = [SimpleTerm(i, i, i) for i in sorted(items)]\n         return SimpleVocabulary(items)\n \n+\n AllowedContentTypesVocabularyFactory = AllowedContentTypesVocabulary()\n \n \n @implementer(IVocabularyFactory)\n-class PortalTypesVocabulary(object):\n+class PortalTypesVocabulary:\n     """Vocabulary factory for portal types.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTypeTool\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTypeTool\n \n-      >>> name = \'plone.app.vocabularies.PortalTypes\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n+    >>> name = \'plone.app.vocabularies.PortalTypes\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n \n-      >>> context.portal_types = DummyTypeTool()\n-      >>> types = util(context)\n-      >>> types\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+    >>> context.portal_types = DummyTypeTool()\n+    >>> types = util(context)\n+    >>> types\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n \n-      >>> len(types.by_token)\n-      2\n+    >>> len(types.by_token)\n+    2\n \n-      >>> doc = types.by_token[\'Document\']\n-      >>> doc.title, doc.token, doc.value\n-      (u\'Page\', \'Document\', \'Document\')\n+    >>> doc = types.by_token[\'Document\']\n+    >>> doc.title, doc.token, doc.value\n+    (u\'Page\', \'Document\', \'Document\')\n     """\n \n     def __call__(self, context):\n         site = getSite()\n-        ttool = getToolByName(site, \'portal_types\', None)\n+        ttool = getToolByName(site, "portal_types", None)\n         if ttool is None:\n             return SimpleVocabulary([])\n \n-        request = aq_get(ttool, \'REQUEST\', None)\n-        items = [(translate(ttool[t].Title(), context=request), t)\n-                 for t in ttool.listContentTypes()]\n+        request = aq_get(ttool, "REQUEST", None)\n+        items = [\n+            (translate(ttool[t].Title(), context=request), t)\n+            for t in ttool.listContentTypes()\n+        ]\n         items = [SimpleTerm(i[1], i[1], i[0]) for i in sorted(items)]\n         return SimpleVocabulary(items)\n \n+\n PortalTypesVocabularyFactory = PortalTypesVocabulary()\n \n \n @implementer(IVocabularyFactory)\n-class UserFriendlyTypesVocabulary(object):\n+class UserFriendlyTypesVocabulary:\n     """Vocabulary factory for user friendly portal types.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> from plone.app.vocabularies.tests.base import DummyTypeTool\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import DummyTypeTool\n \n-      >>> name = \'plone.app.vocabularies.UserFriendlyTypes\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n+    >>> name = \'plone.app.vocabularies.UserFriendlyTypes\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n \n-      >>> context.portal_types = DummyTypeTool()\n-      >>> tool = DummyTool(\'plone_utils\')\n-      >>> def getUserFriendlyTypes():\n-      ...     return (\'Document\', )\n-      >>> tool.getUserFriendlyTypes = getUserFriendlyTypes\n-      >>> context.plone_utils = tool\n+    >>> context.portal_types = DummyTypeTool()\n+    >>> tool = DummyTool(\'plone_utils\')\n+    >>> def getUserFriendlyTypes():\n+    ...     return (\'Document\', )\n+    >>> tool.getUserFriendlyTypes = getUserFriendlyTypes\n+    >>> context.plone_utils = tool\n \n-      >>> types = util(context)\n-      >>> types\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+    >>> types = util(context)\n+    >>> types\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n \n-      >>> len(types.by_token)\n-      1\n+    >>> len(types.by_token)\n+    1\n \n-      >>> doc = types.by_token[\'Document\']\n-      >>> doc.title, doc.token, doc.value\n-      (u\'Page\', \'Document\', \'Document\')\n+    >>> doc = types.by_token[\'Document\']\n+    >>> doc.title, doc.token, doc.value\n+    (u\'Page\', \'Document\', \'Document\')\n     """\n \n     def __call__(self, context):\n         site = getSite()\n-        ptool = getToolByName(site, \'plone_utils\', None)\n-        ttool = getToolByName(site, \'portal_types\', None)\n+        ptool = getToolByName(site, "plone_utils", None)\n+        ttool = getToolByName(site, "portal_types", None)\n         if ptool is None or ttool is None:\n             return SimpleVocabulary([])\n \n-        request = aq_get(ttool, \'REQUEST\', None)\n+        request = aq_get(ttool, "REQUEST", None)\n         items = [\n             (translate(ttool[t].Title(), context=request), t)\n             for t in ptool.getUserFriendlyTypes()\n@@ -238,30 +239,31 @@ def __call__(self, context):\n         items = [SimpleTerm(i[1], i[1], i[0]) for i in items]\n         return SimpleVocabulary(items)\n \n+\n UserFriendlyTypesVocabularyFactory = UserFriendlyTypesVocabulary()\n \n \n BAD_TYPES = [\n-    \'ATBooleanCriterion\',\n-    \'ATCurrentAuthorCriterion\',\n-    \'ATDateCriteria\',\n-    \'ATDateRangeCriterion\',\n-    \'ATListCriterion\',\n-    \'ATPathCriterion\',\n-    \'ATPortalTypeCriterion\',\n-    \'ATReferenceCriterion\',\n-    \'ATRelativePathCriterion\',\n-    \'ATSelectionCriterion\',\n-    \'ATSimpleIntCriterion\',\n-    \'ATSimpleStringCriterion\',\n-    \'ATSortCriterion\',\n-    \'Plone Site\',\n-    \'TempFolder\',\n+    "ATBooleanCriterion",\n+    "ATCurrentAuthorCriterion",\n+    "ATDateCriteria",\n+    "ATDateRangeCriterion",\n+    "ATListCriterion",\n+    "ATPathCriterion",\n+    "ATPortalTypeCriterion",\n+    "ATReferenceCriterion",\n+    "ATRelativePathCriterion",\n+    "ATSelectionCriterion",\n+    "ATSimpleIntCriterion",\n+    "ATSimpleStringCriterion",\n+    "ATSortCriterion",\n+    "Plone Site",\n+    "TempFolder",\n ]\n \n \n @implementer(IVocabularyFactory)\n-class ReallyUserFriendlyTypesVocabulary(object):\n+class ReallyUserFriendlyTypesVocabulary:\n     """Vocabulary factory for really user friendly portal types.\n \n     Usage:\n@@ -298,11 +300,11 @@ class ReallyUserFriendlyTypesVocabulary(object):\n \n     def __call__(self, context):\n         site = getSite()\n-        ttool = getToolByName(site, \'portal_types\', None)\n+        ttool = getToolByName(site, "portal_types", None)\n         if ttool is None:\n             return SimpleVocabulary([])\n \n-        request = aq_get(ttool, \'REQUEST\', None)\n+        request = aq_get(ttool, "REQUEST", None)\n         items = [\n             (translate(ttool[t].Title(), context=request), t)\n             for t in ttool.listContentTypes()\n@@ -312,4 +314,5 @@ def __call__(self, context):\n         items = [SimpleTerm(i[1], i[1], i[0]) for i in items]\n         return PermissiveVocabulary(items)\n \n+\n ReallyUserFriendlyTypesVocabularyFactory = ReallyUserFriendlyTypesVocabulary()\ndiff --git a/plone/app/vocabularies/users.py b/plone/app/vocabularies/users.py\nindex f3fa786..5bee2b8 100644\n--- a/plone/app/vocabularies/users.py\n+++ b/plone/app/vocabularies/users.py\n@@ -1,5 +1,3 @@\n-# -*- coding: utf-8 -*-\n-# KEPT HERE FOR BBB UNTIL PLONE 6\n from Products.CMFCore.utils import getToolByName\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n from zope.browser.interfaces import ITerms\n@@ -9,15 +7,14 @@\n from zope.schema.interfaces import ISource\n from zope.schema.vocabulary import SimpleTerm\n \n-import six\n import warnings\n import zope.deferredimport\n \n \n zope.deferredimport.deprecated(\n     "Import from plone.app.vocabularies.principals instead",\n-    UsersFactory=\'plone.app.vocabularies:principals.UsersFactory\',\n-    UsersVocabulary=\'plone.app.vocabularies:principals.UsersVocabulary\',\n+    UsersFactory="plone.app.vocabularies:principals.UsersFactory",\n+    UsersVocabulary="plone.app.vocabularies:principals.UsersVocabulary",\n )\n \n try:\n@@ -31,136 +28,132 @@ class ISourceQueryView(Interface):\n \n def _createUserTerm(userid, context=None, acl_users=None):\n     if acl_users is None:\n-        acl_users = getToolByName(context, \'acl_users\')\n+        acl_users = getToolByName(context, "acl_users")\n     user = acl_users.getUserById(userid, None)\n     fullname = userid\n     if user:\n-        fullname = user.getProperty(\'fullname\', None) or userid\n-    token = userid.encode(\'unicode_escape\') if isinstance(\n-        userid, six.text_type) else userid\n+        fullname = user.getProperty("fullname", None) or userid\n+    token = userid.encode("unicode_escape") if isinstance(userid, str) else userid\n     return SimpleTerm(userid, token, fullname)\n \n \n @implementer(ISource)\n @provider(IContextSourceBinder)\n-class UsersSource(object):\n+class UsersSource:\n     """\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n \n-      >>> context = create_context()\n+    >>> context = create_context()\n \n-      >>> tool = DummyTool(\'acl_users\')\n-      >>> users = (\'user1\', \'user2\')\n-      >>> def getUserById(value, default):\n-      ...     return value in users and value or default\n-      >>> tool.getUserById = getUserById\n-      >>> def searchUsers(fullname=None):\n-      ...     return [dict(userid=u) for u in users]\n-      >>> tool.searchUsers = searchUsers\n-      >>> context.acl_users = tool\n+    >>> tool = DummyTool(\'acl_users\')\n+    >>> users = (\'user1\', \'user2\')\n+    >>> def getUserById(value, default):\n+    ...     return value in users and value or default\n+    >>> tool.getUserById = getUserById\n+    >>> def searchUsers(fullname=None):\n+    ...     return [dict(userid=u) for u in users]\n+    >>> tool.searchUsers = searchUsers\n+    >>> context.acl_users = tool\n \n-      >>> source = UsersSource(context)\n-      >>> source\n-      <plone.app.vocabularies.users.UsersSource object at ...>\n+    >>> source = UsersSource(context)\n+    >>> source\n+    <plone.app.vocabularies.users.UsersSource object at ...>\n \n-      >>> len(source.search(None))\n-      2\n+    >>> len(source.search(None))\n+    2\n \n-      >>> \'user1\' in source, \'noone\' in source\n-      (True, False)\n+    >>> \'user1\' in source, \'noone\' in source\n+    (True, False)\n \n-      >>> source.get(\'user1\'), source.get(\'noone\')\n-      (\'user1\', None)\n+    >>> source.get(\'user1\'), source.get(\'noone\')\n+    (\'user1\', None)\n     """\n \n     def __init__(self, context):\n-        msg = \'UsersSource is deprecated and will be removed on \' \\\n-              \'Plone 6\'\n+        msg = "UsersSource is deprecated and will be removed on " "Plone 6"\n         warnings.warn(msg, DeprecationWarning)\n         self.context = context\n-        self.users = getToolByName(context, \'acl_users\')\n+        self.users = getToolByName(context, "acl_users")\n \n     def __contains__(self, value):\n-        """Return whether the value is available in this source\n-        """\n+        """Return whether the value is available in this source"""\n         if self.get(value) is None:\n             return False\n         return True\n \n     def search(self, query):\n-        return [u[\'userid\'] for u in self.users.searchUsers(fullname=query)]\n+        return [u["userid"] for u in self.users.searchUsers(fullname=query)]\n \n     def get(self, value):\n         return self.users.getUserById(value, None)\n \n \n @implementer(ITerms, ISourceQueryView)\n-class UsersSourceQueryView(object):\n+class UsersSourceQueryView:\n     """\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> from plone.app.vocabularies.tests.base import Request\n-\n-      >>> context = create_context()\n-\n-      >>> class User(object):\n-      ...     def __init__(self, id):\n-      ...         self.id = id\n-      ...\n-      ...     def getProperty(self, value, default):\n-      ...         return self.id\n-      ...\n-      ...     getId = getProperty\n-\n-      >>> tool = DummyTool(\'acl_users\')\n-      >>> users = (\'user1\', \'user2\')\n-      >>> def getUserById(value, default):\n-      ...     return value in users and User(value) or None\n-      >>> tool.getUserById = getUserById\n-      >>> def searchUsers(fullname=None):\n-      ...     return [dict(userid=u) for u in users]\n-      >>> tool.searchUsers = searchUsers\n-      >>> context.acl_users = tool\n-\n-      >>> source = UsersSource(context)\n-      >>> source\n-      <plone.app.vocabularies.users.UsersSource object at ...>\n-\n-      >>> view = UsersSourceQueryView(source, Request())\n-      >>> view\n-      <plone.app.vocabularies.users.UsersSourceQueryView object at ...>\n-\n-      >>> view.getTerm(\'user1\')\n-      <zope.schema.vocabulary.SimpleTerm object at ...>\n-\n-      >>> view.getValue(\'user1\')\n-      \'user1\'\n-\n-      >>> view.getValue(\'noone\')\n-      Traceback (most recent call last):\n-      ...\n-      LookupError: noone\n-\n-      >>> template = view.render(name=\'t\')\n-\n-      >>> u\'<input type="text" name="t.query" value="" />\' in template\n-      True\n-\n-      >>> u\'<input type="submit" name="t.search" value="Search" />\' in template\n-      True\n-\n-      >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n-      >>> view = UsersSourceQueryView(source, request)\n-      >>> view.results(\'t\')\n-      [\'user1\', \'user2\']\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+    >>> from plone.app.vocabularies.tests.base import Request\n+\n+    >>> context = create_context()\n+\n+    >>> class User(object):\n+    ...     def __init__(self, id):\n+    ...         self.id = id\n+    ...\n+    ...     def getProperty(self, value, default):\n+    ...         return self.id\n+    ...\n+    ...     getId = getProperty\n+\n+    >>> tool = DummyTool(\'acl_users\')\n+    >>> users = (\'user1\', \'user2\')\n+    >>> def getUserById(value, default):\n+    ...     return value in users and User(value) or None\n+    >>> tool.getUserById = getUserById\n+    >>> def searchUsers(fullname=None):\n+    ...     return [dict(userid=u) for u in users]\n+    >>> tool.searchUsers = searchUsers\n+    >>> context.acl_users = tool\n+\n+    >>> source = UsersSource(context)\n+    >>> source\n+    <plone.app.vocabularies.users.UsersSource object at ...>\n+\n+    >>> view = UsersSourceQueryView(source, Request())\n+    >>> view\n+    <plone.app.vocabularies.users.UsersSourceQueryView object at ...>\n+\n+    >>> view.getTerm(\'user1\')\n+    <zope.schema.vocabulary.SimpleTerm object at ...>\n+\n+    >>> view.getValue(\'user1\')\n+    \'user1\'\n+\n+    >>> view.getValue(\'noone\')\n+    Traceback (most recent call last):\n+    ...\n+    LookupError: noone\n+\n+    >>> template = view.render(name=\'t\')\n+\n+    >>> u\'<input type="text" name="t.query" value="" />\' in template\n+    True\n+\n+    >>> u\'<input type="submit" name="t.search" value="Search" />\' in template\n+    True\n+\n+    >>> request = Request(form={\'t.search\' : True, \'t.query\' : \'value\'})\n+    >>> view = UsersSourceQueryView(source, request)\n+    >>> view.results(\'t\')\n+    [\'user1\', \'user2\']\n     """\n \n-    template = ViewPageTemplateFile(\'searchabletextsource.pt\')\n+    template = ViewPageTemplateFile("searchabletextsource.pt")\n \n     def __init__(self, context, request):\n-        msg = \'UsersSourceQueryView is deprecated and will be removed on \' \\\n-              \'Plone 6\'\n+        msg = "UsersSourceQueryView is deprecated and will be removed on " "Plone 6"\n         warnings.warn(msg, DeprecationWarning)\n         self.context = context\n         self.request = request\n@@ -179,9 +172,9 @@ def render(self, name):\n \n     def results(self, name):\n         # check whether the normal search button was pressed\n-        if name + \'.search\' in self.request.form:\n-            query_fieldname = name + \'.query\'\n+        if name + ".search" in self.request.form:\n+            query_fieldname = name + ".query"\n             if query_fieldname in self.request.form:\n                 query = self.request.form[query_fieldname]\n-                if query != \'\':\n+                if query != "":\n                     return self.context.search(query)\ndiff --git a/plone/app/vocabularies/utils.py b/plone/app/vocabularies/utils.py\nindex fbf41d7..ffd8e77 100644\n--- a/plone/app/vocabularies/utils.py\n+++ b/plone/app/vocabularies/utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.querystring import queryparser\n from plone.app.querystring.interfaces import IParsedQueryIndexModifier\n from zope.component import getUtilitiesFor\ndiff --git a/plone/app/vocabularies/workflow.py b/plone/app/vocabularies/workflow.py\nindex 198b77a..b05bfe7 100644\n--- a/plone/app/vocabularies/workflow.py\n+++ b/plone/app/vocabularies/workflow.py\n@@ -1,123 +1,116 @@\n-# -*- coding:utf-8 -*-\n from Acquisition import aq_get\n from operator import itemgetter\n+from plone.base.utils import safe_text\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.utils import safe_unicode\n+from zope.component.hooks import getSite\n from zope.i18n import translate\n from zope.i18nmessageid import MessageFactory\n from zope.interface import implementer\n from zope.schema.interfaces import IVocabularyFactory\n from zope.schema.vocabulary import SimpleTerm\n from zope.schema.vocabulary import SimpleVocabulary\n-from zope.component.hooks import getSite\n \n \n-_ = MessageFactory(\'plone\')\n+_ = MessageFactory("plone")\n \n \n @implementer(IVocabularyFactory)\n-class WorkflowsVocabulary(object):\n+class WorkflowsVocabulary:\n     """Vocabulary factory for workflows.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> import six\n-\n-      >>> name = \'plone.app.vocabularies.Workflows\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n-\n-      >>> class Workflow(object):\n-      ...     def __init__(self, id, title):\n-      ...         self.id = id\n-      ...         self.title = title\n-\n-      >>> tool = DummyTool(\'portal_workflow\')\n-      >>> def values():\n-      ...     return (Workflow(\'default\', \'Default Workflow\'),\n-      ...             Workflow(\'intranet\', \'Intranet Workflow\'),\n-      ...             Workflow(\'noticias\', \'Workflow de Not\xc3\xadcias\'),)\n-      >>> tool.values = values\n-      >>> context.portal_workflow = tool\n-\n-      >>> workflows = util(context)\n-      >>> workflows\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n-\n-      >>> len(workflows.by_token)\n-      3\n-\n-      >>> intranet = workflows.by_token[\'intranet\']\n-      >>> intranet.title, intranet.token, intranet.value\n-      (u\'Intranet Workflow\', \'intranet\', \'intranet\')\n-\n-      >>> noticias = workflows.by_token[\'noticias\']\n-      >>> title = \'Workflow de Not\xc3\xadcias\'\n-      >>> title = title.decode(\'utf-8\') if six.PY2 else title\n-      >>> noticias.title == title\n-      True\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+\n+    >>> name = \'plone.app.vocabularies.Workflows\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n+\n+    >>> class Workflow(object):\n+    ...     def __init__(self, id, title):\n+    ...         self.id = id\n+    ...         self.title = title\n+\n+    >>> tool = DummyTool(\'portal_workflow\')\n+    >>> def values():\n+    ...     return (Workflow(\'default\', \'Default Workflow\'),\n+    ...             Workflow(\'intranet\', \'Intranet Workflow\'),\n+    ...             Workflow(\'noticias\', \'Workflow de Not\xc3\xadcias\'),)\n+    >>> tool.values = values\n+    >>> context.portal_workflow = tool\n+\n+    >>> workflows = util(context)\n+    >>> workflows\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+\n+    >>> len(workflows.by_token)\n+    3\n+\n+    >>> intranet = workflows.by_token[\'intranet\']\n+    >>> intranet.title, intranet.token, intranet.value\n+    (u\'Intranet Workflow\', \'intranet\', \'intranet\')\n+\n+    >>> noticias = workflows.by_token[\'noticias\']\n+    >>> title = \'Workflow de Not\xc3\xadcias\'\n+    >>> noticias.title == title\n+    True\n     """\n \n     def __call__(self, context):\n         items = []\n         site = getSite()\n-        wtool = getToolByName(site, \'portal_workflow\', None)\n+        wtool = getToolByName(site, "portal_workflow", None)\n         if wtool is not None:\n             items = [(w.title, w.id) for w in wtool.values()]\n             items.sort()\n-            # All vocabularies return theirs term title as unicode\n-            items = [\n-                SimpleTerm(i[1], i[1], safe_unicode(i[0]))\n-                for i in items\n-            ]\n+            # All vocabularies return theirs term title as str\n+            items = [SimpleTerm(i[1], i[1], safe_text(i[0])) for i in items]\n         return SimpleVocabulary(items)\n \n+\n WorkflowsVocabularyFactory = WorkflowsVocabulary()\n \n \n @implementer(IVocabularyFactory)\n-class WorkflowStatesVocabulary(object):\n+class WorkflowStatesVocabulary:\n     """Vocabulary factory for workflow states.\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-      >>> import six\n-\n-      >>> name = \'plone.app.vocabularies.WorkflowStates\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n-\n-      >>> tool = DummyTool(\'portal_workflow\')\n-      >>> def listWFStatesByTitle(filter_similar=None):\n-      ...     return ((\'Private\', \'private\'),\n-      ...             (\'Revis\xc3\xa3o\', \'revisao\'),\n-      ...             (\'Published\', \'published\'))\n-      >>> tool.listWFStatesByTitle = listWFStatesByTitle\n-      >>> context.portal_workflow = tool\n-\n-      >>> states = util(context)\n-      >>> states\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n-\n-      >>> len(states.by_token)\n-      3\n-\n-      >>> pub = states.by_token[\'published\']\n-      >>> pub.title, pub.token, pub.value\n-      (u\'Published [published]\', \'published\', \'published\')\n-\n-      >>> rev = states.by_token[\'revisao\']\n-      >>> title = \'Revis\xc3\xa3o [revisao]\'\n-      >>> title = title.decode(\'utf-8\') if six.PY2 else title\n-      >>> rev.title == title\n-      True\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+\n+    >>> name = \'plone.app.vocabularies.WorkflowStates\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n+\n+    >>> tool = DummyTool(\'portal_workflow\')\n+    >>> def listWFStatesByTitle(filter_similar=None):\n+    ...     return ((\'Private\', \'private\'),\n+    ...             (\'Revis\xc3\xa3o\', \'revisao\'),\n+    ...             (\'Published\', \'published\'))\n+    >>> tool.listWFStatesByTitle = listWFStatesByTitle\n+    >>> context.portal_workflow = tool\n+\n+    >>> states = util(context)\n+    >>> states\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+\n+    >>> len(states.by_token)\n+    3\n+\n+    >>> pub = states.by_token[\'published\']\n+    >>> pub.title, pub.token, pub.value\n+    (u\'Published [published]\', \'published\', \'published\')\n+\n+    >>> rev = states.by_token[\'revisao\']\n+    >>> title = \'Revis\xc3\xa3o [revisao]\'\n+    >>> rev.title == title\n+    True\n     """\n \n     def __call__(self, context):\n         site = getSite()\n-        wtool = getToolByName(site, \'portal_workflow\', None)\n+        wtool = getToolByName(site, "portal_workflow", None)\n         if wtool is None:\n             return SimpleVocabulary([])\n \n@@ -125,94 +118,91 @@ def __call__(self, context):\n         # The sorting should go into a separate widget.\n \n         # we get REQUEST from wtool because context may be an adapter\n-        request = aq_get(wtool, \'REQUEST\', None)\n+        request = aq_get(wtool, "REQUEST", None)\n \n         items = wtool.listWFStatesByTitle(filter_similar=True)\n-        items = [(safe_unicode(i[0]), i[1]) for i in items]\n-        items_dict = dict(  # no dict comprehension in py 2.6\n-            [\n-                (i[1], translate(_(i[0]), context=request))\n-                for i in items\n-            ]\n-        )\n-        items_list = [(k, v) for k, v in items_dict.items()]\n+        items = [(safe_text(i[0]), i[1]) for i in items]\n+        items_dict = {  # no dict comprehension in py 2.6\n+            i[1]: translate(_(i[0]), context=request) for i in items\n+        }\n         terms = [\n-            SimpleTerm(k, title=u\'{0} [{1}]\'.format(v, k))\n-            for k, v in sorted(items_list, key=itemgetter(1))\n+            SimpleTerm(k, title=f"{v} [{k}]")\n+            for k, v in sorted(items_dict.items(), key=itemgetter(1))\n         ]\n         return SimpleVocabulary(terms)\n \n+\n WorkflowStatesVocabularyFactory = WorkflowStatesVocabulary()\n \n \n @implementer(IVocabularyFactory)\n-class WorkflowTransitionsVocabulary(object):\n+class WorkflowTransitionsVocabulary:\n     """Vocabulary factory for workflow transitions\n \n-      >>> from zope.component import queryUtility\n-      >>> from plone.app.vocabularies.tests.base import create_context\n-      >>> from plone.app.vocabularies.tests.base import DummyTool\n-\n-      >>> name = \'plone.app.vocabularies.WorkflowTransitions\'\n-      >>> util = queryUtility(IVocabularyFactory, name)\n-      >>> context = create_context()\n-\n-      >>> class Transition(object):\n-      ...     def __init__(self, id, actbox_name):\n-      ...         self.id = id\n-      ...         self.actbox_name = actbox_name\n-\n-      >>> class TransitionsFolder(object):\n-      ...     def __init__(self, values):\n-      ...         self._values = values\n-      ...     def values(self):\n-      ...         return self._values\n-\n-      >>> class Workflow(object):\n-      ...     def __init__(self, id, title, values):\n-      ...         self.id = id\n-      ...         self.title = title\n-      ...         self.transitions = TransitionsFolder(values)\n-\n-      >>> tool = DummyTool(\'portal_workflow\')\n-      >>> t1 = Transition(\'publish\', \'Publish\')\n-      >>> t2 = Transition(\'reject\', \'Reject\')\n-      >>> t3 = Transition(\'publicacao\', u\'Publica\xc3\xa7\xc3\xa3o\')\n-\n-      >>> wf1 = Workflow(\'default\', \'Default Workflow\', (t1, t2))\n-      >>> wf2 = Workflow(\'intranet\', \'Intranet Workflow\', (t1, ))\n-      >>> wf3 = Workflow(\'noticias\', \'Workflow de Not\xc3\xadcias\', (t2, t3))\n-\n-      >>> def values():\n-      ...     return  wf1, wf2, wf3\n-      >>> tool.values = values\n-      >>> context.portal_workflow = tool\n-\n-      >>> transitions = util(context)\n-      >>> transitions\n-      <zope.schema.vocabulary.SimpleVocabulary object at ...>\n-\n-      >>> len(transitions.by_token)\n-      3\n-\n-      >>> pub = transitions.by_token[\'publish\']\n-      >>> pub.title, pub.token, pub.value\n-      (u\'Publish [publish]\', \'publish\', \'publish\')\n-\n-      >>> publ = transitions.by_token[\'publicacao\']\n-      >>> publ.title == u\'Publica\xc3\xa7\xc3\xa3o [publicacao]\'\n-      True\n+    >>> from zope.component import queryUtility\n+    >>> from plone.app.vocabularies.tests.base import create_context\n+    >>> from plone.app.vocabularies.tests.base import DummyTool\n+\n+    >>> name = \'plone.app.vocabularies.WorkflowTransitions\'\n+    >>> util = queryUtility(IVocabularyFactory, name)\n+    >>> context = create_context()\n+\n+    >>> class Transition(object):\n+    ...     def __init__(self, id, actbox_name):\n+    ...         self.id = id\n+    ...         self.actbox_name = actbox_name\n+\n+    >>> class TransitionsFolder(object):\n+    ...     def __init__(self, values):\n+    ...         self._values = values\n+    ...     def values(self):\n+    ...         return self._values\n+\n+    >>> class Workflow(object):\n+    ...     def __init__(self, id, title, values):\n+    ...         self.id = id\n+    ...         self.title = title\n+    ...         self.transitions = TransitionsFolder(values)\n+\n+    >>> tool = DummyTool(\'portal_workflow\')\n+    >>> t1 = Transition(\'publish\', \'Publish\')\n+    >>> t2 = Transition(\'reject\', \'Reject\')\n+    >>> t3 = Transition(\'publicacao\', u\'Publica\xc3\xa7\xc3\xa3o\')\n+\n+    >>> wf1 = Workflow(\'default\', \'Default Workflow\', (t1, t2))\n+    >>> wf2 = Workflow(\'intranet\', \'Intranet Workflow\', (t1, ))\n+    >>> wf3 = Workflow(\'noticias\', \'Workflow de Not\xc3\xadcias\', (t2, t3))\n+\n+    >>> def values():\n+    ...     return  wf1, wf2, wf3\n+    >>> tool.values = values\n+    >>> context.portal_workflow = tool\n+\n+    >>> transitions = util(context)\n+    >>> transitions\n+    <zope.schema.vocabulary.SimpleVocabulary object at ...>\n+\n+    >>> len(transitions.by_token)\n+    3\n+\n+    >>> pub = transitions.by_token[\'publish\']\n+    >>> pub.title, pub.token, pub.value\n+    (u\'Publish [publish]\', \'publish\', \'publish\')\n+\n+    >>> publ = transitions.by_token[\'publicacao\']\n+    >>> publ.title == u\'Publica\xc3\xa7\xc3\xa3o [publicacao]\'\n+    True\n     """\n \n     def __call__(self, context):\n         site = getSite()\n-        wtool = getToolByName(site, \'portal_workflow\', None)\n+        wtool = getToolByName(site, "portal_workflow", None)\n         if wtool is None:\n             return SimpleVocabulary([])\n \n         transitions = {}\n         for wf in wtool.values():\n-            transition_folder = getattr(wf, \'transitions\', None)\n+            transition_folder = getattr(wf, "transitions", None)\n             wf_name = wf.title or wf.id\n             if transition_folder is not None:\n \n@@ -224,21 +214,23 @@ def __call__(self, context):\n                     # where transition names are in local language.\n                     # This may break overlying functionality even\n                     # if the terms themselves are never used\n-                    name = safe_unicode(transition.actbox_name)\n+                    name = safe_text(transition.actbox_name)\n \n                     transition_title = translate(\n-                        _(name),\n-                        context=aq_get(wtool, \'REQUEST\', None))\n+                        _(name), context=aq_get(wtool, "REQUEST", None)\n+                    )\n                     transitions.setdefault(transition.id, []).append(\n-                        dict(title=transition_title, wf_name=wf_name))\n+                        dict(title=transition_title, wf_name=wf_name)\n+                    )\n         items = []\n         transition_items = transitions.items()\n         for transition_id, info in sorted(transition_items, key=itemgetter(0)):\n-            titles = set([i[\'title\'] for i in info])\n-            item_title = \' // \'.join(sorted(titles))\n-            item_title = u\'{0} [{1}]\'.format(item_title, transition_id)\n+            titles = {i["title"] for i in info}\n+            item_title = " // ".join(sorted(titles))\n+            item_title = f"{item_title} [{transition_id}]"\n             items.append(SimpleTerm(transition_id, transition_id, item_title))\n \n         return SimpleVocabulary(items)\n \n+\n WorkflowTransitionsVocabularyFactory = WorkflowTransitionsVocabulary()\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 450b1d8..05b615d 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -18,7 +18,3 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n-\n-[tool.black]\n-line-length = 79\n-skip-string-normalization = true\ndiff --git a/setup.cfg b/setup.cfg\nindex 9cd9d89..fe8b457 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -2,10 +2,7 @@\n universal = 1\n \n [isort]\n-force_alphabetical_sort = True\n-force_single_line = True\n-lines_after_imports = 2\n-line_length = 79\n-not_skip = __init__.py\n-use_parentheses = True\n-multi_line_output = 3\n\\ No newline at end of file\n+profile = black\n+force_alphabetical_sort=True\n+force_single_line=True\n+lines_after_imports=2\n\\ No newline at end of file\ndiff --git a/setup.py b/setup.py\nindex 88f1bfb..0bda9d6 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,67 +1,53 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n \n-version = \'4.3.1.dev0\'\n+version = "5.0.0.dev0"\n \n setup(\n-    name=\'plone.app.vocabularies\',\n+    name="plone.app.vocabularies",\n     version=version,\n-    description=\'Collection of generally useful vocabularies for Plone.\',\n-    long_description=\'{0}\\n{1}\'.format(\n-        open(\'README.rst\').read(),\n-        open(\'CHANGES.rst\').read()\n+    description="Collection of generally useful vocabularies for Plone.",\n+    long_description="{}\\n{}".format(\n+        open("README.rst").read(), open("CHANGES.rst").read()\n     ),\n     classifiers=[\n-        \'Development Status :: 6 - Mature\',\n-        \'Environment :: Web Environment\',\n-        \'Framework :: Plone\',\n-        \'Framework :: Plone :: Core\',\n-        \'Framework :: Plone :: 5.2\',\n-        \'Framework :: Plone :: 6.0\',\n-        \'Framework :: Zope2\',\n-        \'Framework :: Zope :: 4\',\n-        \'License :: OSI Approved :: GNU General Public License v2 (GPLv2)\',\n-        \'Operating System :: OS Independent\',\n-        \'Programming Language :: Python\',\n-        \'Programming Language :: Python :: 2.7\',\n-        \'Programming Language :: Python :: 3.6\',\n-        \'Programming Language :: Python :: 3.7\',\n-        \'Programming Language :: Python :: 3.8\',\n-        \'Programming Language :: Python :: 3.9\',\n+        "Development Status :: 6 - Mature",\n+        "Environment :: Web Environment",\n+        "Framework :: Plone",\n+        "Framework :: Plone :: Core",\n+        "Framework :: Plone :: 6.0",\n+        "Framework :: Zope :: 5",\n+        "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n+        "Operating System :: OS Independent",\n+        "Programming Language :: Python",\n+        "Programming Language :: Python :: 3.7",\n+        "Programming Language :: Python :: 3.8",\n+        "Programming Language :: Python :: 3.9",\n     ],\n-    keywords=\'Plone Zope vocabularies\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://github.com/plone/plone.app.vocabularies\',\n-    license=\'GPL version 2\',\n+    keywords="Plone Zope vocabularies",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://github.com/plone/plone.app.vocabularies",\n+    license="GPL version 2",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\', \'plone.app\'],\n+    namespace_packages=["plone", "plone.app"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'Acquisition\',\n-        \'plone.app.querystring\',\n-        \'Products.CMFCore\',\n-        \'pytz\',\n-        \'setuptools\',\n-        \'six\',\n-        \'zope.browser\',\n-        \'zope.component\',\n-        \'zope.i18n\',\n-        \'zope.i18nmessageid\',\n-        \'zope.interface\',\n-        \'zope.schema\',\n-        \'zope.site\',\n-        \'Zope2\',\n+        "plone.app.querystring",\n+        "plone.base",\n+        "pytz",\n+        "setuptools",\n+        "zope.deprecation",\n+        "zope.globalrequest",\n     ],\n     extras_require=dict(\n         test=[\n-            \'mock\',\n-            \'plone.app.testing\',\n-            \'zope.configuration\',\n-            \'zope.testing\',\n+            "mock",\n+            "plone.app.testing",\n+            "zope.configuration",\n+            "zope.testing",\n         ]\n     ),\n )\n'

