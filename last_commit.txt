Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2017-02-22T15:21:43+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/Products.CMFPlone/commit/b0f302c682df93d215b290f9aefbc11e2f3b9f06

AccessInactivePortalContent in catalog queries
Checked for ``AccessInactivePortalContent`` for each path in a catalog query.
This solves a problem, where Editors couldn't see inactive content, even though they had the required permission on a subpath of the portal (e.g. a subsite).

Files changed:
M CHANGES.rst
M Products/CMFPlone/CatalogTool.py
M Products/CMFPlone/tests/testCatalogTool.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 231d7bf..3e38904 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -20,7 +20,11 @@ New features:
 
 Bug fixes:
 
-- *add item here*
+- Check for ``AccessInactivePortalContent`` for each path in a catalog query.
+  This solves a problem, where Editors couldn't see inactive content, even though they had the required permission on a subpath of the portal (e.g. a subsite).
+  [thet]
+  
+  *add item here*
 
 
 5.1b2 (2017-02-20)
diff --git a/Products/CMFPlone/CatalogTool.py b/Products/CMFPlone/CatalogTool.py
index 998dea1..5c9c79d 100644
--- a/Products/CMFPlone/CatalogTool.py
+++ b/Products/CMFPlone/CatalogTool.py
@@ -1,13 +1,7 @@
 # -*- coding: utf-8 -*-
-import logging
-import re
-import time
-import urllib
-
 from AccessControl import ClassSecurityInfo
 from AccessControl.PermissionRole import rolesForPermissionOn
-from AccessControl.Permissions import (
-    manage_zcatalog_entries as ManageZCatalogEntries)
+from AccessControl.Permissions import manage_zcatalog_entries as ManageZCatalogEntries  # noqa
 from AccessControl.Permissions import search_zcatalog as SearchZCatalog
 from Acquisition import aq_base
 from Acquisition import aq_inner
@@ -17,30 +11,36 @@
 from BTrees.Length import Length
 from DateTime import DateTime
 from OFS.interfaces import IOrderedContainer
+from plone.i18n.normalizer.base import mapUnicode
+from plone.indexer import indexer
+from plone.indexer.interfaces import IIndexableObject
 from Products.CMFCore.CatalogTool import CatalogTool as BaseTool
 from Products.CMFCore.CatalogTool import _mergedLocalRoles
+from Products.CMFCore.indexing import processQueue
 from Products.CMFCore.permissions import AccessInactivePortalContent
 from Products.CMFCore.utils import _checkPermission
 from Products.CMFCore.utils import _getAuthenticatedUser
 from Products.CMFCore.utils import getToolByName
 from Products.CMFPlone import DISCUSSION_ANNOTATION_KEY
-from Products.CMFPlone.PloneBaseTool import PloneBaseTool
 from Products.CMFPlone.interfaces import INonStructuralFolder
 from Products.CMFPlone.interfaces import IPloneCatalogTool
+from Products.CMFPlone.PloneBaseTool import PloneBaseTool
 from Products.CMFPlone.utils import base_hasattr
 from Products.CMFPlone.utils import safe_callable
 from Products.CMFPlone.utils import safe_unicode
 from Products.ZCatalog.ZCatalog import ZCatalog
-from plone.i18n.normalizer.base import mapUnicode
-from plone.indexer import indexer
-from plone.indexer.interfaces import IIndexableObject
 from zope.annotation.interfaces import IAnnotations
 from zope.component import queryMultiAdapter
-from zope.interface import Interface
+from zope.component.hooks import getSite
 from zope.interface import implementer
+from zope.interface import Interface
 from zope.interface import providedBy
 
-from Products.CMFCore.indexing import processQueue
+import logging
+import re
+import time
+import urllib
+
 
 logger = logging.getLogger('Plone')
 
@@ -379,6 +379,51 @@ def getCounter(self):
         processQueue()
         return self._counter is not None and self._counter() or 0
 
+    @security.private
+    def allow_inactive(self, query_kw):
+        """Check, if the user is allowed to see inactive content.
+        First, check if the user is allowed to see inactive content site-wide.
+        Second, if there is a 'path' key in the query, check if the user is
+        allowed to see inactive content for these paths.
+        Conservative check: as soon as one path is disallowed, return False.
+        If a path cannot be traversed, ignore it.
+        """
+        allow_inactive = _checkPermission(AccessInactivePortalContent, self)
+        if allow_inactive:
+            return True
+
+        paths = query_kw.get('path', False)
+        if not paths:
+            return False
+
+        if isinstance(paths, dict):
+            # Like: {'path': {'depth': 0, 'query': ['/Plone/events/']}}
+            # Or: {'path': {'depth': 0, 'query': '/Plone/events/'}}
+            paths = paths.get('query', [])
+
+        if isinstance(paths, basestring):
+            paths = [paths]
+
+        objs = []
+        site = getSite()
+        for path in list(paths):
+            path = path.encode('utf-8')  # paths must not be unicode
+            try:
+                objs.append(site.restrictedTraverse(path))
+            except (KeyError, AttributeError):
+                # When no object is found don't raise an error
+                pass
+
+        if not objs:
+            return False
+
+        allow = True
+        for ob in objs:
+            allow = allow and\
+                _checkPermission(AccessInactivePortalContent, ob)
+
+        return allow
+
     @security.protected(SearchZCatalog)
     def searchResults(self, REQUEST=None, **kw):
         # Calls ZCatalog.searchResults with extra arguments that
@@ -399,8 +444,7 @@ def searchResults(self, REQUEST=None, **kw):
         user = _getAuthenticatedUser(self)
         kw['allowedRolesAndUsers'] = self._listAllowedRolesAndUsers(user)
 
-        if not show_inactive \
-           and not _checkPermission(AccessInactivePortalContent, self):
+        if not show_inactive and not self.allow_inactive(kw):
             kw['effectiveRange'] = DateTime()
 
         return ZCatalog.searchResults(self, REQUEST, **kw)
@@ -421,7 +465,7 @@ def search(self, *args, **kw):
         user = _getAuthenticatedUser(self)
         query['allowedRolesAndUsers'] = self._listAllowedRolesAndUsers(user)
 
-        if not _checkPermission(AccessInactivePortalContent, self):
+        if not self.allow_inactive(kw):
             query['effectiveRange'] = DateTime()
 
         kw['query_request'] = query
diff --git a/Products/CMFPlone/tests/testCatalogTool.py b/Products/CMFPlone/tests/testCatalogTool.py
index a3bb1ab..0635d5e 100644
--- a/Products/CMFPlone/tests/testCatalogTool.py
+++ b/Products/CMFPlone/tests/testCatalogTool.py
@@ -949,6 +949,9 @@ def afterSetUp(self):
         self.catalog = self.portal.portal_catalog
         self.folder.invokeFactory('Document', id='doc')
 
+        # Create unprivileged user
+        self.portal.acl_users._doAddUser(user2, 'secret', ['Member'], [])
+
     def nofx(self):
         # Removes effective and expires to make sure we only test
         # the DateRangeIndex.
@@ -978,6 +981,7 @@ def testSearchResultsExpired(self):
         self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
         self.folder.doc.reindexObject()
         self.nofx()
+        self.login(user2)
         res = self.catalog.searchResults()
         self.assertResults(res, base_content[:-1])
 
@@ -985,6 +989,7 @@ def testCallExpired(self):
         self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
         self.folder.doc.reindexObject()
         self.nofx()
+        self.login(user2)
         res = self.catalog()
         self.assertResults(res, base_content[:-1])
 
@@ -992,6 +997,7 @@ def testSearchResultsExpiredWithExpiredDisabled(self):
         self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
         self.folder.doc.reindexObject()
         self.nofx()
+        self.login(user2)
         res = self.catalog.searchResults(dict(show_inactive=True))
         self.assertResults(res, base_content)
 
@@ -999,6 +1005,7 @@ def testCallExpiredWithExpiredDisabled(self):
         self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
         self.folder.doc.reindexObject()
         self.nofx()
+        self.login(user2)
         res = self.catalog(show_inactive=True)
         self.assertResults(res, base_content)
 
@@ -1006,6 +1013,7 @@ def testSearchResultsExpiredWithPermission(self):
         self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
         self.folder.doc.reindexObject()
         self.nofx()
+        self.login(user2)
         self.setPermissions([AccessInactivePortalContent])
         res = self.catalog.searchResults()
         self.assertResults(res, base_content)
@@ -1018,6 +1026,91 @@ def testCallExpiredWithPermission(self):
         res = self.catalog()
         self.assertResults(res, base_content)
 
+    def testExpiredWithPermissionOnSubpath(self):
+        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
+        self.folder.doc.reindexObject()
+        self.nofx()
+
+        # Login as unprivileged user
+        self.login(user2)
+
+        self.folder.manage_role('Member', [AccessInactivePortalContent])
+
+        expected_result = ['doc', 'test_user_1_']
+
+        query = {
+            'path': '/'.join(self.folder.getPhysicalPath())
+        }
+        res = self.catalog.searchResults(**query)
+        self.assertResults(res, expected_result)
+        res = self.catalog(**query)
+        self.assertResults(res, expected_result)
+
+        query = {
+            'path': {
+                'query': '/'.join(self.folder.getPhysicalPath())
+            }
+        }
+        res = self.catalog.searchResults(**query)
+        self.assertResults(res, expected_result)
+        res = self.catalog(**query)
+        self.assertResults(res, expected_result)
+
+        query = {
+            'path': {
+                'query': [
+                    '/'.join(self.folder.getPhysicalPath()),
+                    '/'.join(self.folder.doc.getPhysicalPath()),
+                ]
+            }
+        }
+        res = self.catalog.searchResults(**query)
+        self.assertResults(res, expected_result)
+        res = self.catalog(**query)
+        self.assertResults(res, expected_result)
+
+    def testExpiredWithoutPermissionOnSubpath(self):
+        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
+        self.folder.doc.reindexObject()
+        self.nofx()
+
+        # Login as unprivileged user
+        self.login(user2)
+
+        # Inactive content isn't shown without the required permission.
+        expected_result = ['test_user_1_']
+
+        query = {
+            'path': '/'.join(self.folder.getPhysicalPath())
+        }
+        res = self.catalog.searchResults(**query)
+        self.assertResults(res, expected_result)
+        res = self.catalog(**query)
+        self.assertResults(res, expected_result)
+
+        query = {
+            'path': {
+                'query': '/'.join(self.folder.getPhysicalPath())
+            }
+        }
+        res = self.catalog.searchResults(**query)
+        self.assertResults(res, expected_result)
+        res = self.catalog(**query)
+        self.assertResults(res, expected_result)
+
+        query = {
+            'path': {
+                'query': [
+                    '/'.join(self.folder.getPhysicalPath()),
+                    '/'.join(self.folder.doc.getPhysicalPath()),
+                ]
+            }
+        }
+        res = self.catalog.searchResults(**query)
+        self.assertResults(res, expected_result)
+        res = self.catalog(**query)
+        self.assertResults(res, expected_result)
+
     def testSearchResultsWithAdditionalExpiryFilter(self):
         # For this test we want the expires and effective indices in place,
         # let's make sure everything still works


Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2017-02-23T11:57:51+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFPlone/commit/9807e3948209a02874b13ef4825205c4aa1b352b

Merge pull request #1952 from plone/thet-accessinactiveportalcontent

AccessInactivePortalContent in catalog queries

Files changed:
M CHANGES.rst
M Products/CMFPlone/CatalogTool.py
M Products/CMFPlone/tests/testCatalogTool.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 231d7bf..3e38904 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -20,7 +20,11 @@ New features:
 
 Bug fixes:
 
-- *add item here*
+- Check for ``AccessInactivePortalContent`` for each path in a catalog query.
+  This solves a problem, where Editors couldn't see inactive content, even though they had the required permission on a subpath of the portal (e.g. a subsite).
+  [thet]
+  
+  *add item here*
 
 
 5.1b2 (2017-02-20)
diff --git a/Products/CMFPlone/CatalogTool.py b/Products/CMFPlone/CatalogTool.py
index 998dea1..5c9c79d 100644
--- a/Products/CMFPlone/CatalogTool.py
+++ b/Products/CMFPlone/CatalogTool.py
@@ -1,13 +1,7 @@
 # -*- coding: utf-8 -*-
-import logging
-import re
-import time
-import urllib
-
 from AccessControl import ClassSecurityInfo
 from AccessControl.PermissionRole import rolesForPermissionOn
-from AccessControl.Permissions import (
-    manage_zcatalog_entries as ManageZCatalogEntries)
+from AccessControl.Permissions import manage_zcatalog_entries as ManageZCatalogEntries  # noqa
 from AccessControl.Permissions import search_zcatalog as SearchZCatalog
 from Acquisition import aq_base
 from Acquisition import aq_inner
@@ -17,30 +11,36 @@
 from BTrees.Length import Length
 from DateTime import DateTime
 from OFS.interfaces import IOrderedContainer
+from plone.i18n.normalizer.base import mapUnicode
+from plone.indexer import indexer
+from plone.indexer.interfaces import IIndexableObject
 from Products.CMFCore.CatalogTool import CatalogTool as BaseTool
 from Products.CMFCore.CatalogTool import _mergedLocalRoles
+from Products.CMFCore.indexing import processQueue
 from Products.CMFCore.permissions import AccessInactivePortalContent
 from Products.CMFCore.utils import _checkPermission
 from Products.CMFCore.utils import _getAuthenticatedUser
 from Products.CMFCore.utils import getToolByName
 from Products.CMFPlone import DISCUSSION_ANNOTATION_KEY
-from Products.CMFPlone.PloneBaseTool import PloneBaseTool
 from Products.CMFPlone.interfaces import INonStructuralFolder
 from Products.CMFPlone.interfaces import IPloneCatalogTool
+from Products.CMFPlone.PloneBaseTool import PloneBaseTool
 from Products.CMFPlone.utils import base_hasattr
 from Products.CMFPlone.utils import safe_callable
 from Products.CMFPlone.utils import safe_unicode
 from Products.ZCatalog.ZCatalog import ZCatalog
-from plone.i18n.normalizer.base import mapUnicode
-from plone.indexer import indexer
-from plone.indexer.interfaces import IIndexableObject
 from zope.annotation.interfaces import IAnnotations
 from zope.component import queryMultiAdapter
-from zope.interface import Interface
+from zope.component.hooks import getSite
 from zope.interface import implementer
+from zope.interface import Interface
 from zope.interface import providedBy
 
-from Products.CMFCore.indexing import processQueue
+import logging
+import re
+import time
+import urllib
+
 
 logger = logging.getLogger('Plone')
 
@@ -379,6 +379,51 @@ def getCounter(self):
         processQueue()
         return self._counter is not None and self._counter() or 0
 
+    @security.private
+    def allow_inactive(self, query_kw):
+        """Check, if the user is allowed to see inactive content.
+        First, check if the user is allowed to see inactive content site-wide.
+        Second, if there is a 'path' key in the query, check if the user is
+        allowed to see inactive content for these paths.
+        Conservative check: as soon as one path is disallowed, return False.
+        If a path cannot be traversed, ignore it.
+        """
+        allow_inactive = _checkPermission(AccessInactivePortalContent, self)
+        if allow_inactive:
+            return True
+
+        paths = query_kw.get('path', False)
+        if not paths:
+            return False
+
+        if isinstance(paths, dict):
+            # Like: {'path': {'depth': 0, 'query': ['/Plone/events/']}}
+            # Or: {'path': {'depth': 0, 'query': '/Plone/events/'}}
+            paths = paths.get('query', [])
+
+        if isinstance(paths, basestring):
+            paths = [paths]
+
+        objs = []
+        site = getSite()
+        for path in list(paths):
+            path = path.encode('utf-8')  # paths must not be unicode
+            try:
+                objs.append(site.restrictedTraverse(path))
+            except (KeyError, AttributeError):
+                # When no object is found don't raise an error
+                pass
+
+        if not objs:
+            return False
+
+        allow = True
+        for ob in objs:
+            allow = allow and\
+                _checkPermission(AccessInactivePortalContent, ob)
+
+        return allow
+
     @security.protected(SearchZCatalog)
     def searchResults(self, REQUEST=None, **kw):
         # Calls ZCatalog.searchResults with extra arguments that
@@ -399,8 +444,7 @@ def searchResults(self, REQUEST=None, **kw):
         user = _getAuthenticatedUser(self)
         kw['allowedRolesAndUsers'] = self._listAllowedRolesAndUsers(user)
 
-        if not show_inactive \
-           and not _checkPermission(AccessInactivePortalContent, self):
+        if not show_inactive and not self.allow_inactive(kw):
             kw['effectiveRange'] = DateTime()
 
         return ZCatalog.searchResults(self, REQUEST, **kw)
@@ -421,7 +465,7 @@ def search(self, *args, **kw):
         user = _getAuthenticatedUser(self)
         query['allowedRolesAndUsers'] = self._listAllowedRolesAndUsers(user)
 
-        if not _checkPermission(AccessInactivePortalContent, self):
+        if not self.allow_inactive(kw):
             query['effectiveRange'] = DateTime()
 
         kw['query_request'] = query
diff --git a/Products/CMFPlone/tests/testCatalogTool.py b/Products/CMFPlone/tests/testCatalogTool.py
index a3bb1ab..0635d5e 100644
--- a/Products/CMFPlone/tests/testCatalogTool.py
+++ b/Products/CMFPlone/tests/testCatalogTool.py
@@ -949,6 +949,9 @@ def afterSetUp(self):
         self.catalog = self.portal.portal_catalog
         self.folder.invokeFactory('Document', id='doc')
 
+        # Create unprivileged user
+        self.portal.acl_users._doAddUser(user2, 'secret', ['Member'], [])
+
     def nofx(self):
         # Removes effective and expires to make sure we only test
         # the DateRangeIndex.
@@ -978,6 +981,7 @@ def testSearchResultsExpired(self):
         self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
         self.folder.doc.reindexObject()
         self.nofx()
+        self.login(user2)
         res = self.catalog.searchResults()
         self.assertResults(res, base_content[:-1])
 
@@ -985,6 +989,7 @@ def testCallExpired(self):
         self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
         self.folder.doc.reindexObject()
         self.nofx()
+        self.login(user2)
         res = self.catalog()
         self.assertResults(res, base_content[:-1])
 
@@ -992,6 +997,7 @@ def testSearchResultsExpiredWithExpiredDisabled(self):
         self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
         self.folder.doc.reindexObject()
         self.nofx()
+        self.login(user2)
         res = self.catalog.searchResults(dict(show_inactive=True))
         self.assertResults(res, base_content)
 
@@ -999,6 +1005,7 @@ def testCallExpiredWithExpiredDisabled(self):
         self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
         self.folder.doc.reindexObject()
         self.nofx()
+        self.login(user2)
         res = self.catalog(show_inactive=True)
         self.assertResults(res, base_content)
 
@@ -1006,6 +1013,7 @@ def testSearchResultsExpiredWithPermission(self):
         self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
         self.folder.doc.reindexObject()
         self.nofx()
+        self.login(user2)
         self.setPermissions([AccessInactivePortalContent])
         res = self.catalog.searchResults()
         self.assertResults(res, base_content)
@@ -1018,6 +1026,91 @@ def testCallExpiredWithPermission(self):
         res = self.catalog()
         self.assertResults(res, base_content)
 
+    def testExpiredWithPermissionOnSubpath(self):
+        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
+        self.folder.doc.reindexObject()
+        self.nofx()
+
+        # Login as unprivileged user
+        self.login(user2)
+
+        self.folder.manage_role('Member', [AccessInactivePortalContent])
+
+        expected_result = ['doc', 'test_user_1_']
+
+        query = {
+            'path': '/'.join(self.folder.getPhysicalPath())
+        }
+        res = self.catalog.searchResults(**query)
+        self.assertResults(res, expected_result)
+        res = self.catalog(**query)
+        self.assertResults(res, expected_result)
+
+        query = {
+            'path': {
+                'query': '/'.join(self.folder.getPhysicalPath())
+            }
+        }
+        res = self.catalog.searchResults(**query)
+        self.assertResults(res, expected_result)
+        res = self.catalog(**query)
+        self.assertResults(res, expected_result)
+
+        query = {
+            'path': {
+                'query': [
+                    '/'.join(self.folder.getPhysicalPath()),
+                    '/'.join(self.folder.doc.getPhysicalPath()),
+                ]
+            }
+        }
+        res = self.catalog.searchResults(**query)
+        self.assertResults(res, expected_result)
+        res = self.catalog(**query)
+        self.assertResults(res, expected_result)
+
+    def testExpiredWithoutPermissionOnSubpath(self):
+        self.folder.doc.setExpirationDate(DateTime(2000, 12, 31))
+        self.folder.doc.reindexObject()
+        self.nofx()
+
+        # Login as unprivileged user
+        self.login(user2)
+
+        # Inactive content isn't shown without the required permission.
+        expected_result = ['test_user_1_']
+
+        query = {
+            'path': '/'.join(self.folder.getPhysicalPath())
+        }
+        res = self.catalog.searchResults(**query)
+        self.assertResults(res, expected_result)
+        res = self.catalog(**query)
+        self.assertResults(res, expected_result)
+
+        query = {
+            'path': {
+                'query': '/'.join(self.folder.getPhysicalPath())
+            }
+        }
+        res = self.catalog.searchResults(**query)
+        self.assertResults(res, expected_result)
+        res = self.catalog(**query)
+        self.assertResults(res, expected_result)
+
+        query = {
+            'path': {
+                'query': [
+                    '/'.join(self.folder.getPhysicalPath()),
+                    '/'.join(self.folder.doc.getPhysicalPath()),
+                ]
+            }
+        }
+        res = self.catalog.searchResults(**query)
+        self.assertResults(res, expected_result)
+        res = self.catalog(**query)
+        self.assertResults(res, expected_result)
+
     def testSearchResultsWithAdditionalExpiryFilter(self):
         # For this test we want the expires and effective indices in place,
         # let's make sure everything still works


