Repository: plone.namedfile


Branch: refs/heads/master
Date: 2022-02-17T08:43:50+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.namedfile/commit/ea81748986a28696ebcccdcc4ec6eafebf410bf0

Register AnnotationStorage as IImageScaleStorage multi adapter. (#109)

* Register AnnotationStorage as IImageScaleStorage multi adapter.

Both from `plone.scale`.
Use this adapter in our scaling functions when we store or get an image scale.
See https://github.com/plone/plone.scale/issues/44

* Add tests that we get an adapter for IImageScaleStorage.

Until now, we defaulted to using plone.scale.storage.AnnotationStorage.

Files changed:
A news/44.feature
M plone/namedfile/scaling.py
M plone/namedfile/scaling.zcml
M plone/namedfile/tests/test_scaling.py

b'diff --git a/news/44.feature b/news/44.feature\nnew file mode 100644\nindex 0000000..221397e\n--- /dev/null\n+++ b/news/44.feature\n@@ -0,0 +1,4 @@\n+Register ``AnnotationStorage`` as ``IImageScaleStorage`` multi adapter.\n+Both from ``plone.scale``.\n+Use this adapter in our scaling functions when we store or get an image scale.\n+[maurits]\ndiff --git a/plone/namedfile/scaling.py b/plone/namedfile/scaling.py\nindex 30d7848..db2c59b 100644\n--- a/plone/namedfile/scaling.py\n+++ b/plone/namedfile/scaling.py\n@@ -15,13 +15,14 @@\n from plone.scale.interfaces import IImageScaleFactory\n from plone.scale.interfaces import IScaledImageQuality\n from plone.scale.scale import scaleImage\n-from plone.scale.storage import AnnotationStorage\n+from plone.scale.storage import IImageScaleStorage\n from Products.CMFPlone.utils import safe_encode\n from Products.Five import BrowserView\n from xml.sax.saxutils import quoteattr\n from zExceptions import Unauthorized\n from ZODB.blob import BlobFile\n from ZODB.POSException import ConflictError\n+from zope.component import getMultiAdapter\n from zope.component import queryUtility\n from zope.deprecation import deprecate\n from zope.interface import alsoProvides\n@@ -368,7 +369,7 @@ def publishTraverse(self, request, name):\n             # we got a uid...\n             if "." in name:\n                 name, ext = name.rsplit(".", 1)\n-            storage = AnnotationStorage(self.context)\n+            storage = getMultiAdapter((self.context, None), IImageScaleStorage)\n             info = storage.get(name)\n             if info is None:\n                 raise NotFound(self, name, self.request)\n@@ -493,9 +494,9 @@ def scale(\n             width, height = available[scale]\n         if IDisableCSRFProtection and self.request is not None:\n             alsoProvides(self.request, IDisableCSRFProtection)\n-        storage = AnnotationStorage(\n-            self.context,\n-            functools.partial(self.modified, fieldname)\n+        storage = getMultiAdapter(\n+            (self.context, functools.partial(self.modified, fieldname)),\n+            IImageScaleStorage\n         )\n         info = storage.scale(\n             fieldname=fieldname,\ndiff --git a/plone/namedfile/scaling.zcml b/plone/namedfile/scaling.zcml\nindex e528232..a4ae5b2 100644\n--- a/plone/namedfile/scaling.zcml\n+++ b/plone/namedfile/scaling.zcml\n@@ -22,6 +22,13 @@\n       factory=".scaling.DefaultImageScalingFactory"\n       for="*"\n   />\n+  <!-- For the storage, we adapt a context\n+       and an optional modified callable. -->\n+  <adapter\n+      factory="plone.scale.storage.AnnotationStorage"\n+      provides="plone.scale.storage.IImageScaleStorage"\n+      for="* *"\n+  />\n \n   <!-- In plone.app.caching, image scales are weakly cached.\n        But stable (uid) image scales should be strongly cached.\ndiff --git a/plone/namedfile/tests/test_scaling.py b/plone/namedfile/tests/test_scaling.py\nindex a31c644..64edf02 100644\n--- a/plone/namedfile/tests/test_scaling.py\n+++ b/plone/namedfile/tests/test_scaling.py\n@@ -10,12 +10,15 @@\n from plone.namedfile.testing import PLONE_NAMEDFILE_INTEGRATION_TESTING\n from plone.namedfile.tests import getFile\n from plone.scale.interfaces import IScaledImageQuality\n+from plone.scale.storage import IImageScaleStorage\n from six import BytesIO\n from zExceptions import Unauthorized\n from zope.annotation import IAttributeAnnotatable\n from zope.component import getGlobalSiteManager\n from zope.component import getSiteManager\n from zope.interface import implementer\n+from zope.interface import Interface\n+from zope.publisher.interfaces import NotFound\n \n import PIL\n import re\n@@ -62,6 +65,109 @@ def getQuality(self):\n         return 1  # as bad as it gets\n \n \n+class FakeImage:\n+    def __init__(self, value, format, key=None, uid="image"):\n+        self.value = value\n+        self.format = format\n+        self._width = len(value)\n+        self._height = len(format)\n+        self.contentType = f"image/{format}"\n+        # variables for scales:\n+        self._scales = {}\n+        self.key = key\n+        self.uid = uid\n+\n+    @property\n+    def data(self):\n+        return self\n+\n+    @property\n+    def info(self):\n+        return dict(\n+            data=self.data,\n+            width=self._width,\n+            height=self._height,\n+            mimetype=f\'image/{self.format.lower()}\',\n+            key=self.key,\n+            uid=self.uid\n+        )\n+\n+    def absolute_url(self):\n+        return "http://fake.image"\n+\n+    def Title(self):\n+        # used for tag\n+        return "Image Title"\n+\n+\n+@implementer(IImageScaleStorage)\n+class FakeImageScaleStorage:\n+    """Storage class for FakeImages."""\n+\n+    def __init__(self, context, modified=None):\n+        """ Adapt the given context item and optionally provide a callable\n+            to return a representation of the last modification date, which\n+            can be used to invalidate stored scale data on update. """\n+        self.context = context\n+        self.modified = modified\n+        self.storage = context._scales\n+\n+    def scale(self, factory=None, **parameters):\n+        """Find image scale data for the given parameters or create it.\n+\n+        In our version, we only support height and width.\n+        """\n+        stripped_parameters = {\n+            "target_height": parameters.get("height"),\n+            "target_width": parameters.get("width"),\n+        }\n+        key = self.hash(**stripped_parameters)\n+        storage = self.storage\n+        info = self.get_info_by_hash(key)\n+        if info is not None:\n+            # Note: we could do something with self.modified here,\n+            # but we choose to ignore it.\n+            return info\n+        return self.create_scale(**stripped_parameters)\n+\n+    def create_scale(self, target_height=None, target_width=None):\n+        if target_height is None and target_width is None:\n+            # Return the original.\n+            return self.context.info\n+\n+        # We have a funny way of scaling.\n+        value = self.context.value[:target_height]\n+        format = self.context.format[:target_width]\n+\n+        # Get uid and key.\n+        # Our implementation never throws away scales, so we can use uid-0, uid-1, etc.\n+        # Note: in ImageScaling.publishTraverse a dash in the url means it is a scale uid.\n+        uid = f"uid-{len(self.storage)}"\n+        key = self.hash(target_height=target_height, target_width=target_width)\n+\n+        # Create a new fake image for this scale.\n+        scale = FakeImage(value, format, key=key, uid=uid)\n+\n+        # Store the scale and return the info.\n+        self.storage[uid] = scale.info\n+        return scale.info\n+\n+    def __getitem__(self, uid):\n+        """ Find image scale data based on its uid. """\n+        return self.storage[uid]\n+\n+    def get(self, uid, default=None):\n+        return self.storage.get(uid, default)\n+\n+    def hash(self, **parameters):\n+        return tuple(parameters.values())\n+\n+    def get_info_by_hash(self, hash):\n+        for value in self.storage.values():\n+            if value["key"] == hash:\n+                return value\n+\n+\n class ImageScalingTests(unittest.TestCase):\n \n     layer = PLONE_NAMEDFILE_INTEGRATION_TESTING\n@@ -463,6 +569,104 @@ def testGuardedAccess(self):\n         self.item.__allow_access_to_unprotected_subobjects__ = 1\n \n \n+class StorageTests(unittest.TestCase):\n+    """Test the scale storage.\n+\n+    Especially test that we get an adapter for IImageScaleStorage\n+    instead of defaulting to plone.scale.storage.AnnotationStorage.\n+    """\n+\n+    layer = PLONE_NAMEDFILE_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        sm = getSiteManager()\n+        sm.registerAdapter(FakeImageScaleStorage, (FakeImage, Interface))\n+\n+    def tearDown(self):\n+        sm = getSiteManager()\n+        sm.unregisterAdapter(FakeImageScaleStorage, (FakeImage, Interface))\n+\n+    def test_original(self):\n+        item = FakeImage("abcdef", "jpeg")\n+        scaling = ImageScaling(item, None)\n+        original = scaling.scale("image")\n+        self.assertEqual(original.data.value, "abcdef")\n+        self.assertIs(original.data, item)\n+        self.assertEqual(original.mimetype, "image/jpeg")\n+        self.assertIsInstance(original.mimetype, str)\n+        self.assertEqual(original.data.contentType, "image/jpeg")\n+        self.assertIsInstance(original.data.contentType, str)\n+        self.assertEqual(original.width, 6)\n+        self.assertEqual(original.height, 4)\n+\n+        # Try the tag\n+        self.assertEqual(\n+            scaling.tag("image"),\n+            \'<img src="http://fake.image/@@images/image.jpeg" alt="Image Title" title="Image Title" height="4" width="6" />\',\n+        )\n+\n+        # Try to access the item via uid.\n+        # This should fail, because we only have the original, not a scale.\n+        with self.assertRaises(NotFound):\n+            scaling.publishTraverse(self.layer["request"], "uid-0")\n+\n+    def test_width(self):\n+        # For FakeImage scales, the width changes the mimetype/format.\n+        item = FakeImage("abcdef", "jpeg")\n+        scaling = ImageScaling(item, None)\n+        scale = scaling.scale("image", width=2)\n+        self.assertEqual(scale.data.value, "abcdef")\n+        self.assertIsInstance(scale.data, FakeImage)\n+        self.assertEqual(scale.mimetype, "image/jp")\n+        self.assertEqual(scale.data.contentType, "image/jp")\n+        self.assertEqual(scale.width, 6)\n+        self.assertEqual(scale.height, 2)\n+\n+        # Ask for the same scale and you get the same FakeImage.\n+        scale2 = scaling.scale("image", width=2)\n+        self.assertIs(scale.data, scale2.data)\n+\n+        # Try the tag.  It should have a uid.\n+        self.assertEqual(\n+            scaling.tag("image", width=2),\n+            \'<img src="http://fake.image/@@images/uid-0.jp" alt="Image Title" title="Image Title" height="2" width="6" />\',\n+        )\n+\n+        # Access the item via uid.\n+        scale_uid = scaling.publishTraverse(self.layer["request"], "uid-0")\n+        self.assertEqual(scale_uid.data.uid, "uid-0")\n+        self.assertEqual(scale_uid.data.info["uid"], "uid-0")\n+        self.assertIs(scale_uid.data, scale2.data)\n+\n+    def test_height(self):\n+        # For FakeImage scales, the height changes the value.\n+        item = FakeImage("abcdef", "jpeg")\n+        scaling = ImageScaling(item, None)\n+        scale = scaling.scale("image", height=3)\n+        self.assertEqual(scale.data.value, "abc")\n+        self.assertIsInstance(scale.data, FakeImage)\n+        self.assertEqual(scale.mimetype, "image/jpeg")\n+        self.assertEqual(scale.data.contentType, "image/jpeg")\n+        self.assertEqual(scale.width, 3)\n+        self.assertEqual(scale.height, 4)\n+\n+        # Ask for the same scale and you get the same FakeImage.\n+        scale2 = scaling.scale("image", height=3)\n+        self.assertIs(scale.data, scale2.data)\n+\n+        # Try the tag.  It should have a uid.\n+        self.assertEqual(\n+            scaling.tag("image", height=3),\n+            \'<img src="http://fake.image/@@images/uid-0.jpeg" alt="Image Title" title="Image Title" height="4" width="3" />\',\n+        )\n+\n+        # Access the item via uid.\n+        scale_uid = scaling.publishTraverse(self.layer["request"], "uid-0")\n+        self.assertEqual(scale_uid.data.uid, "uid-0")\n+        self.assertEqual(scale_uid.data.info["uid"], "uid-0")\n+        self.assertIs(scale_uid.data, scale2.data)\n+\n+\n def test_suite():\n     from unittest import defaultTestLoader\n     return defaultTestLoader.loadTestsFromName(__name__)\n'

