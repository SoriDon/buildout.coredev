Repository: plone.tiles


Branch: refs/heads/master
Date: 2016-02-16T14:01:52+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.tiles/commit/703bd5f62ac89b248c9f06e548f2168098ac779f

fixes a bunch of I001 Q000 S001 P002

Files changed:
M plone/tiles/__init__.py
M plone/tiles/absoluteurl.py
M plone/tiles/data.py
M plone/tiles/esi.py
M plone/tiles/tests.py
M plone/tiles/type.py

diff --git a/plone/tiles/__init__.py b/plone/tiles/__init__.py
index bb3a260..a013279 100644
--- a/plone/tiles/__init__.py
+++ b/plone/tiles/__init__.py
@@ -1,5 +1,7 @@
 # -*- coding: utf-8 -*-
 
+from plone.tiles.tile import PersistentTile
+from plone.tiles.tile import Tile
 # Convenience imports
-from plone.tiles.tile import Tile, PersistentTile
+
 assert Tile, PersistentTile  # silence pyflakes
diff --git a/plone/tiles/absoluteurl.py b/plone/tiles/absoluteurl.py
index dbc3fba..fd28d55 100644
--- a/plone/tiles/absoluteurl.py
+++ b/plone/tiles/absoluteurl.py
@@ -29,13 +29,13 @@ def __str__(self):
         if name is None or context is None:
             raise TypeError("Insufficient context to determine URL")
 
-        tileFragment = "@@" + urllib.quote(name.encode('utf-8'), _safe)
+        tileFragment = '@@' + urllib.quote(name.encode('utf-8'), _safe)
         if tid:
             tileFragment += '/' + urllib.quote(tid.encode('utf-8'), _safe)
 
         absolute_url = getMultiAdapter((context, request), IAbsoluteURL)
         try:
-            tileFragment = '%s/%s' % (str(absolute_url), tileFragment)
+            tileFragment = '/'.join([str(absolute_url), tileFragment])
         except TypeError:  # Not enough context to get URL information
             pass
 
@@ -49,15 +49,18 @@ def breadcrumbs(self):
         name = tile.__name__
         context = tile.__parent__
 
-        tileFragment = "@@" + urllib.quote(name.encode('utf-8'), _safe)
+        tileFragment = '@@' + urllib.quote(name.encode('utf-8'), _safe)
         if tid:
             tileFragment += '/' + urllib.quote(tid.encode('utf-8'), _safe)
 
         base = tuple(
             getMultiAdapter((context, request), IAbsoluteURL).breadcrumbs())
-        base += ({'name': name,
-                  'url': "%s/%s" % (base[-1]['url'], tileFragment,),
-                  },)
+        base += (
+            {
+                'name': name,
+                'url': '/'.join([base[-1]['url'], tileFragment]),
+            },
+        )
 
         return base
 
diff --git a/plone/tiles/data.py b/plone/tiles/data.py
index 24af156..10302cb 100644
--- a/plone/tiles/data.py
+++ b/plone/tiles/data.py
@@ -8,28 +8,20 @@
 from plone.tiles.interfaces import ITileType
 from zope.annotation.interfaces import IAnnotations
 from zope.component import adapter
-from zope.component import adapts
 from zope.component import getMultiAdapter
 from zope.component import queryUtility
 from zope.component.interfaces import ComponentLookupError
 from zope.interface import implementer
-from zope.interface import implements
 from zope.interface import Interface
 from zope.schema import getFields
 from zope.schema import getFieldsInOrder
 from zope.schema.interfaces import ISequence
 
+import json
 import logging
 import urllib
 
 
-try:
-    import json
-    assert json  # silence pyflakes
-except ImportError:
-    import simplejson as json
-
-
 ANNOTATIONS_KEY_PREFIX = u'plone.tiles.data'
 LOGGER = logging.getLogger('plone.tiles')
 
@@ -43,20 +35,21 @@ def transientTileDataManagerFactory(tile):
         return TransientTileDataManager(tile)
 
 
+@adapter(ITile)
+@implementer(ITileDataManager)
 class TransientTileDataManager(object):
     """A data manager for transient tile data, which reads data from the
     request query string.
     """
 
-    implements(ITileDataManager)
-    adapts(ITile)
-
     def __init__(self, tile):
         self.tile = tile
         self.tileType = queryUtility(ITileType, name=tile.__name__)
-        self.annotations = IAnnotations(self.tile.request,
-                                        self.tile.request.form)
-        self.key = "%s.%s" % (ANNOTATIONS_KEY_PREFIX, tile.id,)
+        self.annotations = IAnnotations(
+            self.tile.request,
+            self.tile.request.form
+        )
+        self.key = '.'.join([ANNOTATIONS_KEY_PREFIX, tile.id])
 
     def get(self):
         # use explicitly set data (saved as annotation on the request)
@@ -83,7 +76,7 @@ def get(self):
                     data = decode(self.tile.request.form,
                                   self.tileType.schema, missing=True)
                 except (ValueError, UnicodeDecodeError,):
-                    LOGGER.exception(u"Could not convert form data to schema")
+                    LOGGER.exception(u'Could not convert form data to schema')
                     return self.data.copy()
 
         return data
@@ -96,14 +89,13 @@ def delete(self):
             self.annotations[self.key] = {}
 
 
+@adapter(IPersistentTile)
+@implementer(ITileDataManager)
 class PersistentTileDataManager(object):
     """A data reader for persistent tiles operating on annotatable contexts.
     The data is retrieved from an annotation.
     """
 
-    implements(ITileDataManager)
-    adapts(IPersistentTile)
-
     def __init__(self, tile):
         self.tile = tile
         self.tileType = queryUtility(ITileType, name=tile.__name__)
@@ -112,7 +104,7 @@ def __init__(self, tile):
             (tile.context, tile.request, tile), ITileDataContext)
         self.annotations = IAnnotations(self.context)
 
-        self.key = "%s.%s" % (ANNOTATIONS_KEY_PREFIX, tile.id,)
+        self.key = '.'.join([ANNOTATIONS_KEY_PREFIX, tile.id])
 
     def _get_default_request_data(self):
         # If we don't have a schema, just take the request
@@ -124,7 +116,7 @@ def _get_default_request_data(self):
                 data = decode(self.tile.request.form,
                               self.tileType.schema, missing=True)
             except (ValueError, UnicodeDecodeError,):
-                LOGGER.exception(u"Could not convert form data to schema")
+                LOGGER.exception(u'Could not convert form data to schema')
                 return self.data.copy()
         return data
 
@@ -181,15 +173,23 @@ def guess_type(v):
                 marshall_type = guess_type(item_subvalue)
                 if isinstance(item_subvalue, bool):
                     item_subvalue = item_subvalue and '1' or ''
-                encoded_name = "%s.%s%s:list:%s" % (
-                    prefix, item_name, marshall_type, postfix)
+                encoded_name = '{0}.{1}{2}:list:{3}'.format(
+                    prefix,
+                    item_name,
+                    marshall_type,
+                    postfix
+                )
                 yield encoded_name, item_subvalue
         else:
             marshall_type = guess_type(item_value)
             if isinstance(item_value, bool):
                 item_value = item_value and '1' or ''
-            encoded_name = "%s.%s%s:%s" % (
-                prefix, item_name, marshall_type, postfix)
+            encoded_name = '{0:s}.{1:s}{2:s}:{3:s}'.format(
+                prefix,
+                item_name,
+                marshall_type,
+                postfix
+            )
             yield encoded_name, item_value
 
 
@@ -212,12 +212,16 @@ def encode(data, schema, ignore=()):
 
         converter = IFieldTypeConverter(field, None)
         if converter is None:
-            raise ComponentLookupError(u"Cannot URL encode %s of type %s" % (
-                name, field.__class__,))
+            raise ComponentLookupError(
+                u'Cannot URL encode {0} of type {1}'.format(
+                    name,
+                    field.__class__
+                )
+            )
 
         encoded_name = name
         if converter.token:
-            encoded_name = "%s:%s" % (name, converter.token,)
+            encoded_name = ':'.join([name, converter.token])
 
         value = data[name]
         if value is None:
@@ -229,12 +233,20 @@ def encode(data, schema, ignore=()):
             value_type_converter = IFieldTypeConverter(field.value_type, None)
             if value_type_converter is None:
                 raise ComponentLookupError(
-                    u"Cannot URL encode value type for %s of type %s : %s" % (
-                        name, field.__class__, field.value_type.__class__,))
+                    u'Cannot URL encode value type for {0} of type '
+                    u'{1} : {2}'.format(
+                        name,
+                        field.__class__,
+                        field.value_type.__class__
+                    )
+                )
 
             if value_type_converter.token:
-                encoded_name = "%s:%s:%s" % (
-                    name, value_type_converter.token, converter.token,)
+                encoded_name = ':'.join(
+                    name,
+                    value_type_converter.token,
+                    converter.token
+                )
 
             for item in value:
 
diff --git a/plone/tiles/esi.py b/plone/tiles/esi.py
index 69518cb..31bceaf 100644
--- a/plone/tiles/esi.py
+++ b/plone/tiles/esi.py
@@ -5,7 +5,7 @@
 from plone.tiles.interfaces import IESIRendered
 from plone.tiles.tile import PersistentTile
 from plone.tiles.tile import Tile
-from zope.interface import implements
+from zope.interface import implementer
 
 import re
 
@@ -14,16 +14,17 @@
 BODY_CHILDREN = re.compile(r'<body[^>]*>(.*)</body>', re.I | re.S)
 
 ESI_NAMESPACE_MAP = {'esi': 'http://www.edge-delivery.org/esi/1.0'}
-ESI_TEMPLATE = u"""\
+ESI_TEMPLATE = u'''\
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml">
     <body>
-        <a class="_esi_placeholder" rel="esi" """ + \
-    u"""href="%(url)s/@@%(esiMode)s?%(queryString)s"></a>
+        <a class="_esi_placeholder"
+           rel="esi"
+           href="%(url)s/@@%(esiMode)s?%(queryString)s"></a>
     </body>
 </html>
-"""
+'''
 
 
 def substituteESILinks(rendered):
@@ -58,14 +59,15 @@ def __call__(self, *args, **kwargs):
                 'queryString': self.request.get('QUERY_STRING', ''),
                 'esiMode': mode,
             }
-        if hasattr(self, 'index'):
+        try:
             return self.index(*args, **kwargs)
-
-        return self.render()
+        except AttributeError:
+            return self.render()
 
 
 # Convenience base classes
 
+@implementer(IESIRendered)
 class ESITile(ConditionalESIRendering, Tile):
     """Convenience class for tiles using ESI rendering.
 
@@ -73,10 +75,10 @@ class ESITile(ConditionalESIRendering, Tile):
     default is to render <body /> content.
     """
 
-    implements(IESIRendered)
     head = False
 
 
+@implementer(IESIRendered)
 class ESIPersistentTile(ConditionalESIRendering, PersistentTile):
     """Convenience class for tiles using ESI rendering.
 
@@ -84,7 +86,6 @@ class ESIPersistentTile(ConditionalESIRendering, PersistentTile):
     default is to render <body /> content.
     """
 
-    implements(IESIRendered)
     head = False
 
 
diff --git a/plone/tiles/tests.py b/plone/tiles/tests.py
index 8de88c5..c516c6c 100644
--- a/plone/tiles/tests.py
+++ b/plone/tiles/tests.py
@@ -18,7 +18,7 @@
 
 
 class IDummySchema(Interface):
-    foo = schema.TextLine(title=u"Foo")
+    foo = schema.TextLine(title=u'Foo')
 
 
 class IDummyContext(Interface):
@@ -32,7 +32,7 @@ class IDummyLayer(Interface):
 class DummyTile(Tile):
 
     def __call__(self):
-        return u"dummy"
+        return u'dummy'
 
 
 class DummyTileWithTemplate(PersistentTile):
@@ -54,14 +54,21 @@ def tearDown(self):
 PLONE_TILES_FIXTURE = PloneTiles()
 
 PLONE_TILES_INTEGRATION_TESTING = z2.IntegrationTesting(
-    bases=(PLONE_TILES_FIXTURE,), name="PloneTiles:Functional")
+    bases=(PLONE_TILES_FIXTURE,),
+    name='PloneTiles:Functional'
+)
 
 
 def test_suite():
     return unittest.TestSuite((
-        layered(doctest.DocFileSuite('tiles.rst', 'directives.rst',
-                                     'data.rst', 'esi.rst',
-                                     optionflags=doctest.ELLIPSIS),
-                layer=PLONE_TILES_INTEGRATION_TESTING
-                ),
+        layered(
+            doctest.DocFileSuite(
+                'tiles.rst',
+                'directives.rst',
+                'data.rst',
+                'esi.rst',
+                optionflags=doctest.ELLIPSIS
+            ),
+            layer=PLONE_TILES_INTEGRATION_TESTING
+        ),
     ))
diff --git a/plone/tiles/type.py b/plone/tiles/type.py
index 6a33f54..2af4dc9 100644
--- a/plone/tiles/type.py
+++ b/plone/tiles/type.py
@@ -29,4 +29,7 @@ def __init__(self, name, title, add_permission, edit_permission=None,
         self.schema = schema
 
     def __repr__(self):
-        return u"<TileType %s (%s)>" % (self.__name__, self.title,)
+        return u"<TileType {0} ({1})>".format(
+            self.__name__,
+            self.title
+        )


