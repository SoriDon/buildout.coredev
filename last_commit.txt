Repository: plone.autoform


Branch: refs/heads/master
Date: 2023-03-15T22:38:29+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.autoform/commit/5168a1bbfa81c68fc673afeb5bd6f4f6adc592dd

Configuring with plone/meta

Files changed:
A .editorconfig
A .meta.toml
A .pre-commit-config.yaml
A news/243ca9ec.internal
A tox.ini
M pyproject.toml
M setup.cfg

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..17f7b14\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "243ca9ec"\ndiff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nnew file mode 100644\nindex 0000000..582f8ac\n--- /dev/null\n+++ b/.pre-commit-config.yaml\n@@ -0,0 +1,42 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+ci:\n+    autofix_prs: false\n+    autoupdate_schedule: monthly\n+\n+repos:\n+-   repo: https://github.com/asottile/pyupgrade\n+    rev: v3.3.1\n+    hooks:\n+    -   id: pyupgrade\n+        args: [--py38-plus]\n+-   repo: https://github.com/pycqa/isort\n+    rev: 5.12.0\n+    hooks:\n+    -   id: isort\n+-   repo: https://github.com/psf/black\n+    rev: 23.1.0\n+    hooks:\n+    -   id: black\n+-   repo: https://github.com/collective/zpretty\n+    rev: 3.0.2\n+    hooks:\n+    -   id: zpretty\n+-   repo: https://github.com/PyCQA/flake8\n+    rev: 6.0.0\n+    hooks:\n+    -   id: flake8\n+-   repo: https://github.com/codespell-project/codespell\n+    rev: v2.2.2\n+    hooks:\n+    -   id: codespell\n+        additional_dependencies:\n+          - tomli\n+-   repo: https://github.com/mgedmin/check-manifest\n+    rev: "0.49"\n+    hooks:\n+    -   id: check-manifest\n+-   repo: https://github.com/regebro/pyroma\n+    rev: "4.2"\n+    hooks:\n+    -   id: pyroma\ndiff --git a/news/243ca9ec.internal b/news/243ca9ec.internal\nnew file mode 100644\nindex 0000000..c08f539\n--- /dev/null\n+++ b/news/243ca9ec.internal\n@@ -0,0 +1,2 @@\n+Update configuration files.\n+[plone devs]\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..9d0c563 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,43 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "internal"\n+name = "Internal:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "documentation"\n+name = "Documentation:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "tests"\n+name = "Tests"\n+showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\n+\n+[tool.dependencychecker]\n+Zope = [\n+  # Zope own provided namespaces\n+  \'App\', \'OFS\', \'Products.Five\', \'Products.OFSP\', \'Products.PageTemplates\',\n+  \'Products.SiteAccess\', \'Shared\', \'Testing\', \'ZPublisher\', \'ZTUtils\',\n+  \'Zope2\', \'webdav\', \'zmi\',\n+  # Zope dependencies\n+  \'Acquisition\', \'DateTime\', \'transaction\', \'zExceptions\', \'ZODB\', \'zope.component\',\n+  \'zope.configuration\', \'zope.container\', \'zope.deferredimport\', \'zope.event\',\n+  \'zope.exceptions\', \'zope.globalrequest\', \'zope.i18n\', \'zope.i18nmessageid\',\n+  \'zope.interface\', \'zope.lifecycleevent\', \'zope.location\', \'zope.publisher\',\n+  \'zope.schema\', \'zope.security\', \'zope.site\', \'zope.traversing\', \'AccessControl\',\n+]\n+\'plone.base\' = [\n+  \'setuptools\', \'AccessControl\', \'Products.BTreeFolder2\', \'Products.CMFCore\',\n+  \'Products.CMFDynamicViewFTI\', \'zope.deprecation\',\n+]\n+python-dateutil = [\'dateutil\']\ndiff --git a/setup.cfg b/setup.cfg\nindex c570e1e..0da8f8f 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,16 +1,23 @@\n-[check-manifest]\n-ignore =\n-    *.cfg\n-    bootstrap.py\n-\n-[isort]\n-force_alphabetical_sort = True\n-force_single_line = True\n-lines_after_imports = 2\n-line_length = 200\n-not_skip = __init__.py\n-\n-\n-\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [bdist_wheel]\n universal = 0\n+\n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n+\n+[check-manifest]\n+ignore =\n+    .editorconfig\n+    .meta.toml\n+    .pre-commit-config.yaml\n+    tox.ini\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..3f04073\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,50 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[tox]\n+envlist =\n+    format\n+    lint\n+    test\n+\n+[testenv]\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat code\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a pyupgrade\n+    pre-commit run -a isort\n+    pre-commit run -a black\n+    pre-commit run -a zpretty\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a\n+\n+[testenv:dependencies]\n+description = check if the package defines all its dependencies and generate a graph out of them\n+deps =\n+    z3c.dependencychecker==2.11\n+    pipdeptree==2.5.1\n+    graphviz  # optional dependency of pipdeptree\n+commands =\n+    dependencychecker\n+    sh -c \'pipdeptree --exclude setuptools,pipdeptree,wheel,pipdeptree,z3c.dependencychecker,zope.interface,zope.component --graph-output svg > dependencies.svg\'\n+\n+[testenv:test]\n+usedevelop = true\n+deps =\n+    zope.testrunner\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    zope-testrunner --test-path={toxinidir} -s plone.autoform\n+extras =\n+    test\n'

Repository: plone.autoform


Branch: refs/heads/master
Date: 2023-03-15T22:40:49+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.autoform/commit/74a7ba6f78c53716313f7aa6e592662f00cf2130

chore: pyupgrade

Files changed:
M plone/__init__.py
M plone/autoform/__init__.py
M plone/autoform/base.py
M plone/autoform/directives.py
M plone/autoform/form.py
M plone/autoform/interfaces.py
M plone/autoform/supermodel.py
M plone/autoform/testing.py
M plone/autoform/tests/__init__.py
M plone/autoform/tests/test_base.py
M plone/autoform/tests/test_directives.py
M plone/autoform/tests/test_doctests.py
M plone/autoform/tests/test_supermodel_handler.py
M plone/autoform/tests/test_utils.py
M plone/autoform/tests/test_widgets.py
M plone/autoform/utils.py
M plone/autoform/view.py
M plone/autoform/widgets.py
M setup.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..de40ea7 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n __import__(\'pkg_resources\').declare_namespace(__name__)\ndiff --git a/plone/autoform/__init__.py b/plone/autoform/__init__.py\nindex 40a96af..e69de29 100644\n--- a/plone/autoform/__init__.py\n+++ b/plone/autoform/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/autoform/base.py b/plone/autoform/base.py\nindex debbff3..d32ee41 100644\n--- a/plone/autoform/base.py\n+++ b/plone/autoform/base.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from collections import OrderedDict\n from operator import attrgetter\n from plone.autoform.interfaces import ORDER_KEY\n@@ -18,7 +17,7 @@\n _marker = object()\n \n \n-class AutoFields(object):\n+class AutoFields:\n     """Mixin class for the WidgetsView and AutoExtensibleForm classes.\n     Takes care of actually processing field updates\n     """\n@@ -145,7 +144,7 @@ def getPrefix(self, schema):\n     def _prepare_names(self, source, target, prefix):\n             # calculate prefixed fieldname\n             if prefix:\n-                source = \'{0}.{1}\'.format(prefix, source)\n+                source = f\'{prefix}.{source}\'\n \n             # Handle shortcut: leading . means "in this form". May be useful\n             # if you want to move a field relative to one in the current\n@@ -238,15 +237,12 @@ def _process_field_moves(self, rules):\n                 if not (before or after):\n                     raise ValueError(\n                         \'Direction of a field move must be before or \'\n-                        \'after, but got {0}.\'.format(rule[\'direction\'])\n+                        \'after, but got {}.\'.format(rule[\'direction\'])\n                     )\n                 try:\n                     move(self, name, before=before, after=after, prefix=prefix)\n                 except KeyError as e:\n-                    if six.PY2:\n-                        message = e.message\n-                    else:\n-                        message = e.args[0]\n+                    message = e.args[0]\n                     if (\n                         message.startswith(\'Field \') and\n                         message.endswith(\' not found\')\n@@ -254,7 +250,7 @@ def _process_field_moves(self, rules):\n                         # The relative_to field doesn\'t exist\n                         logger.debug(\n                             \'Field move to non-existing: \'\n-                            \'field name: {0}, rule: {1}\'.format(\n+                            \'field name: {}, rule: {}\'.format(\n                                 prefix + \'.\' + name,\n                                 str(rule)\n                             )\ndiff --git a/plone/autoform/directives.py b/plone/autoform/directives.py\nindex c3289cf..e3d9eeb 100644\n--- a/plone/autoform/directives.py\n+++ b/plone/autoform/directives.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.interfaces import MODES_KEY\n from plone.autoform.interfaces import OMITTED_KEY\n from plone.autoform.interfaces import ORDER_KEY\n@@ -121,8 +120,8 @@ def factory(self, field_name=None, widget_class=None, **kw):\n \n         if field_name is None:  # Usage 3\n             for field_name, widget in kw.items():\n-                if not isinstance(widget, six.string_types):\n-                    widget = \'{0}.{1}\'.format(\n+                if not isinstance(widget, str):\n+                    widget = \'{}.{}\'.format(\n                         widget.__module__,\n                         widget.__name__\n                     )\ndiff --git a/plone/autoform/form.py b/plone/autoform/form.py\nindex 818bcfc..d9f0503 100644\n--- a/plone/autoform/form.py\n+++ b/plone/autoform/form.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.base import AutoFields\n from plone.autoform.interfaces import IAutoExtensibleForm\n from plone.autoform.interfaces import IAutoObjectSubForm\n@@ -32,7 +31,7 @@ def additionalSchemata(self):\n \n     def updateFields(self):\n         self.updateFieldsFromSchemata()\n-        super(AutoExtensibleForm, self).updateFields()\n+        super().updateFields()\n \n \n @implementer(IAutoObjectSubForm)\ndiff --git a/plone/autoform/interfaces.py b/plone/autoform/interfaces.py\nindex 8364b9a..8edb077 100644\n--- a/plone/autoform/interfaces.py\n+++ b/plone/autoform/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.supermodel.interfaces import IFieldset\n from z3c.form.interfaces import IDisplayForm\n from z3c.form.interfaces import IFieldsForm\n@@ -11,13 +10,13 @@\n \n \n # Schema interface tagged value keys\n-MODES_KEY = u\'plone.autoform.modes\'\n-OMITTED_KEY = u\'plone.autoform.omitted\'\n-ORDER_KEY = u\'plone.autoform.order\'\n-WIDGETS_KEY = u\'plone.autoform.widgets\'\n+MODES_KEY = \'plone.autoform.modes\'\n+OMITTED_KEY = \'plone.autoform.omitted\'\n+ORDER_KEY = \'plone.autoform.order\'\n+WIDGETS_KEY = \'plone.autoform.widgets\'\n \n-READ_PERMISSIONS_KEY = u\'plone.autoform.security.read-permissions\'\n-WRITE_PERMISSIONS_KEY = u\'plone.autoform.security.write-permissions\'\n+READ_PERMISSIONS_KEY = \'plone.autoform.security.read-permissions\'\n+WRITE_PERMISSIONS_KEY = \'plone.autoform.security.write-permissions\'\n \n # Supermodel namespace and prefix\n \n@@ -42,19 +41,19 @@ class IAutoExtensibleForm(Interface):\n     """\n \n     ignorePrefix = zope.schema.Bool(\n-        title=u\'Do not set a prefix for additional schemata\',\n+        title=\'Do not set a prefix for additional schemata\',\n         default=False\n     )\n \n     schema = zope.schema.Object(\n-        title=u\'Schema providing form fields\',\n+        title=\'Schema providing form fields\',\n         schema=IInterface\n     )\n \n     additionalSchemata = zope.schema.Tuple(\n-        title=u\'Supplementary schemata providing additional form fields\',\n+        title=\'Supplementary schemata providing additional form fields\',\n         value_type=zope.schema.Object(\n-            title=u\'Schema interface\',\n+            title=\'Schema interface\',\n             schema=IInterface\n         ),\n         required=False\n@@ -67,7 +66,7 @@ class IAutoObjectSubForm(Interface):\n     """\n \n     schema = zope.schema.Object(\n-        title=u\'Schema providing form fields\',\n+        title=\'Schema providing form fields\',\n         schema=IInterface\n     )\n \n@@ -78,25 +77,25 @@ class IWidgetsView(IAutoExtensibleForm, IFieldsForm, IDisplayForm):\n     """\n \n     w = zope.schema.Dict(\n-        title=u\'Shortcut lookup for all widgets\',\n-        description=u\'Contains all widgets, including those from groups \'\n-                    u\'within this form\',\n+        title=\'Shortcut lookup for all widgets\',\n+        description=\'Contains all widgets, including those from groups \'\n+                    \'within this form\',\n         key_type=zope.schema.ASCIILine(\n-            title=u\'Widget name, with prefix\'\n+            title=\'Widget name, with prefix\'\n         ),\n         value_type=zope.schema.Object(\n-            title=u\'Widget\',\n+            title=\'Widget\',\n             schema=IWidget\n         )\n     )\n \n     fieldsets = zope.schema.Dict(\n-        title=u\'Lookup fieldset (group) by name\',\n+        title=\'Lookup fieldset (group) by name\',\n         key_type=zope.schema.ASCIILine(\n-            title=u\'Fieldset name\'\n+            title=\'Fieldset name\'\n         ),\n         value_type=zope.schema.Object(\n-            title=u\'Fieldset\',\n+            title=\'Fieldset\',\n             schema=IFieldset\n         )\n     )\ndiff --git a/plone/autoform/supermodel.py b/plone/autoform/supermodel.py\nindex 16211fb..17e02d2 100644\n--- a/plone/autoform/supermodel.py\n+++ b/plone/autoform/supermodel.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from lxml import etree\n from plone.autoform.interfaces import FORM_NAMESPACE\n from plone.autoform.interfaces import FORM_PREFIX\n@@ -24,7 +23,7 @@\n \n \n @implementer(IFieldMetadataHandler)\n-class FormSchema(object):\n+class FormSchema:\n     """Support the form: namespace in model definitions.\n     """\n \n@@ -50,7 +49,7 @@ def _add_interface_values(self, schema, key, name, values):\n                 interface = resolveDottedName(interface_dotted_name)\n                 if not isinstance(interface, InterfaceClass):\n                     raise ValueError(\n-                        \'{0} not an Interface.\'.format(interface_dotted_name)\n+                        f\'{interface_dotted_name} not an Interface.\'\n                     )\n             else:\n                 interface = Interface\n@@ -104,7 +103,7 @@ def read(self, fieldNode, schema, field):\n             obj = resolveDottedName(widgetAttr)\n             if not IFieldWidget.implementedBy(obj):\n                 raise ValueError(\n-                    \'IFieldWidget not implemented by {0}\'.format(obj)\n+                    f\'IFieldWidget not implemented by {obj}\'\n                 )\n             widget = widgetAttr\n         if widget is not None:\n@@ -144,7 +143,7 @@ def write(self, fieldNode, schema, field):\n         mode_values = []\n         for interface, value in mode:\n             if interface is not Interface:\n-                value = \'{0}:{1}\'.format(interface.__identifier__, value)\n+                value = f\'{interface.__identifier__}:{value}\'\n             mode_values.append(value)\n         if mode_values:\n             fieldNode.set(ns(\'mode\', self.namespace), \' \'.join(mode_values))\n@@ -152,7 +151,7 @@ def write(self, fieldNode, schema, field):\n         omitted_values = []\n         for interface, value in omitted:\n             if interface is not Interface:\n-                value = \'{0}:{1}\'.format(interface.__identifier__, value)\n+                value = f\'{interface.__identifier__}:{value}\'\n             omitted_values.append(value)\n         if omitted_values:\n             fieldNode.set(\n@@ -168,7 +167,7 @@ def write(self, fieldNode, schema, field):\n \n \n @implementer(IFieldMetadataHandler)\n-class SecuritySchema(object):\n+class SecuritySchema:\n     """Support the security: namespace in model definitions.\n     """\n \ndiff --git a/plone/autoform/testing.py b/plone/autoform/testing.py\nindex bd5b24a..399703e 100644\n--- a/plone/autoform/testing.py\n+++ b/plone/autoform/testing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.testing import z2\n from plone.testing import zca\n \ndiff --git a/plone/autoform/tests/__init__.py b/plone/autoform/tests/__init__.py\nindex 40a96af..e69de29 100644\n--- a/plone/autoform/tests/__init__.py\n+++ b/plone/autoform/tests/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/autoform/tests/test_base.py b/plone/autoform/tests/test_base.py\nindex 602fec3..ed05cc6 100644\n--- a/plone/autoform/tests/test_base.py\n+++ b/plone/autoform/tests/test_base.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from collections import OrderedDict\n from plone.testing.zca import UNIT_TESTING\n \ndiff --git a/plone/autoform/tests/test_directives.py b/plone/autoform/tests/test_directives.py\nindex db2df1d..1224ffb 100644\n--- a/plone/autoform/tests/test_directives.py\n+++ b/plone/autoform/tests/test_directives.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform import directives as form\n from plone.autoform.interfaces import MODES_KEY\n from plone.autoform.interfaces import OMITTED_KEY\n@@ -14,7 +13,7 @@\n import zope.schema\n \n \n-class DummyWidget(object):\n+class DummyWidget:\n     pass\n \n \n@@ -37,10 +36,10 @@ class IDummy(model.Schema):\n             form.read_permission(foo=\'zope2.View\')\n             form.write_permission(foo=\'cmf.ModifyPortalContent\')\n \n-            foo = zope.schema.TextLine(title=u\'Foo\')\n-            bar = zope.schema.TextLine(title=u\'Bar\')\n-            baz = zope.schema.TextLine(title=u\'Baz\')\n-            qux = zope.schema.TextLine(title=u\'Qux\')\n+            foo = zope.schema.TextLine(title=\'Foo\')\n+            bar = zope.schema.TextLine(title=\'Bar\')\n+            baz = zope.schema.TextLine(title=\'Baz\')\n+            qux = zope.schema.TextLine(title=\'Qux\')\n \n         model.finalizeSchemas(IDummy)\n \n@@ -68,9 +67,9 @@ def test_widget_supports_instances_and_strings(self):\n         class IDummy(model.Schema):\n             form.widget(foo=DummyWidget)\n \n-            foo = zope.schema.TextLine(title=u\'Foo\')\n-            bar = zope.schema.TextLine(title=u\'Bar\')\n-            baz = zope.schema.TextLine(title=u\'Baz\')\n+            foo = zope.schema.TextLine(title=\'Foo\')\n+            bar = zope.schema.TextLine(title=\'Bar\')\n+            baz = zope.schema.TextLine(title=\'Baz\')\n \n         self.assertEqual(\n             {\'foo\': \'plone.autoform.tests.test_directives.DummyWidget\'},\n@@ -83,14 +82,14 @@ def test_widget_parameterized(self):\n         from plone.autoform.widgets import ParameterizedWidget\n \n         @implementer(IWidget)\n-        class DummyWidget(object):\n+        class DummyWidget:\n \n             def __init__(self, request):\n                 pass\n \n         class IDummy(model.Schema):\n             form.widget(\'foo\', DummyWidget, foo=\'bar\')\n-            foo = zope.schema.TextLine(title=u\'Foo\')\n+            foo = zope.schema.TextLine(title=\'Foo\')\n \n         tv = IDummy.queryTaggedValue(WIDGETS_KEY)\n         self.assertTrue(isinstance(tv[\'foo\'], ParameterizedWidget))\n@@ -103,14 +102,14 @@ def test_widget_parameterized_default_widget_factory(self):\n         from plone.autoform.widgets import ParameterizedWidget\n \n         @implementer(IWidget)\n-        class DummyWidget(object):\n+        class DummyWidget:\n \n             def __init__(self, request):\n                 pass\n \n         class IDummy(model.Schema):\n             form.widget(\'foo\', foo=\'bar\')\n-            foo = zope.schema.TextLine(title=u\'Foo\')\n+            foo = zope.schema.TextLine(title=\'Foo\')\n \n         tv = IDummy.queryTaggedValue(WIDGETS_KEY)\n         self.assertTrue(isinstance(tv[\'foo\'], ParameterizedWidget))\n@@ -145,10 +144,10 @@ class IDummy(model.Schema):\n             form.write_permission(foo=\'cmf.ModifyPortalContent\')\n             form.write_permission(baz=\'another.Permission\')\n \n-            foo = zope.schema.TextLine(title=u\'Foo\')\n-            bar = zope.schema.TextLine(title=u\'Bar\')\n-            baz = zope.schema.TextLine(title=u\'Baz\')\n-            qux = zope.schema.TextLine(title=u\'Qux\')\n+            foo = zope.schema.TextLine(title=\'Foo\')\n+            bar = zope.schema.TextLine(title=\'Bar\')\n+            baz = zope.schema.TextLine(title=\'Baz\')\n+            qux = zope.schema.TextLine(title=\'Qux\')\n \n         self.assertEqual({\'foo\': \'some.dummy.Widget\',\n                           \'baz\': \'other.Widget\'},\ndiff --git a/plone/autoform/tests/test_doctests.py b/plone/autoform/tests/test_doctests.py\nindex 1f8262b..022ba11 100644\n--- a/plone/autoform/tests/test_doctests.py\n+++ b/plone/autoform/tests/test_doctests.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.testing import optionflags\n from plone.testing import layered\n from plone.testing.zca import UNIT_TESTING\ndiff --git a/plone/autoform/tests/test_supermodel_handler.py b/plone/autoform/tests/test_supermodel_handler.py\nindex c8bd266..5c716a4 100644\n--- a/plone/autoform/tests/test_supermodel_handler.py\n+++ b/plone/autoform/tests/test_supermodel_handler.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from lxml import etree\n from plone.autoform.interfaces import MODES_KEY\n from plone.autoform.interfaces import OMITTED_KEY\n@@ -23,7 +22,7 @@\n \n \n @implementer(IWidget)\n-class DummyWidget(object):\n+class DummyWidget:\n \n     def __init__(self, request):\n         pass\n@@ -50,7 +49,7 @@ def test_read(self):\n         )\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy\')\n+            dummy = zope.schema.TextLine(title=\'dummy\')\n \n         handler = FormSchema()\n         handler.read(field_node, IDummy, IDummy[\'dummy\'])\n@@ -93,8 +92,8 @@ def test_read_multiple(self):\n         field_node2.set(ns(\'omitted\', self.namespace), \'yes\')\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.TextLine(title=u\'dummy1\')\n-            dummy2 = zope.schema.TextLine(title=u\'dummy2\')\n+            dummy1 = zope.schema.TextLine(title=\'dummy1\')\n+            dummy2 = zope.schema.TextLine(title=\'dummy2\')\n \n         handler = FormSchema()\n         handler.read(field_node1, IDummy, IDummy[\'dummy1\'])\n@@ -122,7 +121,7 @@ def test_read_no_data(self):\n         field_node = etree.Element(\'field\')\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+            dummy = zope.schema.TextLine(title=\'dummy1\')\n \n         handler = FormSchema()\n         handler.read(field_node, IDummy, IDummy[\'dummy\'])\n@@ -156,26 +155,26 @@ def test_read_values_with_interfaces(self):\n         )\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.TextLine(title=u\'dummy1\')\n-            dummy2 = zope.schema.TextLine(title=u\'dummy2\')\n+            dummy1 = zope.schema.TextLine(title=\'dummy1\')\n+            dummy2 = zope.schema.TextLine(title=\'dummy2\')\n \n         handler = FormSchema()\n         handler.read(field_node1, IDummy, IDummy[\'dummy1\'])\n         handler.read(field_node2, IDummy, IDummy[\'dummy2\'])\n \n         expected_modes = [\n-            (IForm, u\'dummy1\', \'hidden\'),\n-            (IForm, u\'dummy2\', \'hidden\'),\n-            (IEditForm, u\'dummy2\', \'display\')\n+            (IForm, \'dummy1\', \'hidden\'),\n+            (IForm, \'dummy2\', \'hidden\'),\n+            (IEditForm, \'dummy2\', \'display\')\n         ]\n         self.assertEqual(\n             expected_modes,\n             IDummy.queryTaggedValue(MODES_KEY)\n         )\n         expected_omitted = [\n-            (IForm, u\'dummy1\', \'true\'),\n-            (IForm, u\'dummy2\', \'true\'),\n-            (IEditForm, u\'dummy2\', \'false\')\n+            (IForm, \'dummy1\', \'true\'),\n+            (IForm, \'dummy2\', \'true\'),\n+            (IEditForm, \'dummy2\', \'false\')\n         ]\n         self.assertEqual(\n             expected_omitted,\n@@ -197,7 +196,7 @@ def test_read_parameterized_widget(self):\n         field_node.append(widget_node)\n \n         class IDummy(Interface):\n-            foo = zope.schema.TextLine(title=u\'foo\')\n+            foo = zope.schema.TextLine(title=\'foo\')\n \n         handler = FormSchema()\n         handler.read(field_node, IDummy, IDummy[\'foo\'])\n@@ -221,7 +220,7 @@ def test_read_parameterized_widget_default(self):\n         field_node.append(widget_node)\n \n         class IDummy(Interface):\n-            foo = zope.schema.TextLine(title=u\'foo\')\n+            foo = zope.schema.TextLine(title=\'foo\')\n \n         handler = FormSchema()\n         handler.read(field_node, IDummy, IDummy[\'foo\'])\n@@ -238,7 +237,7 @@ def test_write(self):\n         field_node = etree.Element(\'field\')\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+            dummy = zope.schema.TextLine(title=\'dummy1\')\n \n         IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy\': \'SomeWidget\'})\n         IDummy.setTaggedValue(OMITTED_KEY, [(Interface, \'dummy\', \'true\')])\n@@ -261,7 +260,7 @@ def test_write_partial(self):\n         field_node = etree.Element(\'field\')\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+            dummy = zope.schema.TextLine(title=\'dummy1\')\n \n         IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy\': \'SomeWidget\'})\n         IDummy.setTaggedValue(OMITTED_KEY, [(Interface, \'dummy2\', \'true\')])\n@@ -284,7 +283,7 @@ def test_write_no_data(self):\n         field_node = etree.Element(\'field\')\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+            dummy = zope.schema.TextLine(title=\'dummy1\')\n \n         handler = FormSchema()\n         handler.write(field_node, IDummy, IDummy[\'dummy\'])\n@@ -299,19 +298,19 @@ def test_write_values_with_interfaces(self):\n         field_node2 = etree.Element(\'field\')\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.TextLine(title=u\'dummy1\')\n-            dummy2 = zope.schema.TextLine(title=u\'dummy2\')\n+            dummy1 = zope.schema.TextLine(title=\'dummy1\')\n+            dummy2 = zope.schema.TextLine(title=\'dummy2\')\n \n         modes_values = [\n-            (IForm, u\'dummy1\', \'hidden\'),\n-            (IForm, u\'dummy2\', \'hidden\'),\n-            (IEditForm, u\'dummy2\', \'display\')\n+            (IForm, \'dummy1\', \'hidden\'),\n+            (IForm, \'dummy2\', \'hidden\'),\n+            (IEditForm, \'dummy2\', \'display\')\n         ]\n         IDummy.setTaggedValue(MODES_KEY, modes_values)\n         omitted_values = [\n-            (IForm, u\'dummy1\', \'true\'),\n-            (IForm, u\'dummy2\', \'true\'),\n-            (IEditForm, u\'dummy2\', \'false\')\n+            (IForm, \'dummy1\', \'true\'),\n+            (IForm, \'dummy2\', \'true\'),\n+            (IEditForm, \'dummy2\', \'false\')\n         ]\n         IDummy.setTaggedValue(OMITTED_KEY, omitted_values)\n \n@@ -344,7 +343,7 @@ def test_write_parameterized_widget_string(self):\n         pw = ParameterizedWidget(\'foo\')\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.Text(title=u\'dummy1\')\n+            dummy1 = zope.schema.Text(title=\'dummy1\')\n         IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy1\': pw})\n \n         fieldNode = etree.Element(\'field\')\n@@ -363,7 +362,7 @@ def test_write_parameterized_widget_default(self):\n         pw = ParameterizedWidget(None)\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.Text(title=u\'dummy1\')\n+            dummy1 = zope.schema.Text(title=\'dummy1\')\n         IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy1\': pw})\n \n         fieldNode = etree.Element(\'field\')\n@@ -380,7 +379,7 @@ def test_write_parameterized_widget_with_handler(self):\n         pw = ParameterizedWidget(DummyWidget, klass=\'custom\')\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.Text(title=u\'dummy1\')\n+            dummy1 = zope.schema.Text(title=\'dummy1\')\n         IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy1\': pw})\n \n         fieldNode = etree.Element(\'field\')\n@@ -401,7 +400,7 @@ def test_write_parameterized_widget_default_with_handler(self):\n         pw = ParameterizedWidget(None, klass=\'custom\')\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.Text(title=u\'dummy1\')\n+            dummy1 = zope.schema.Text(title=\'dummy1\')\n         IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy1\': pw})\n \n         fieldNode = etree.Element(\'field\')\n@@ -425,17 +424,17 @@ def test_read(self):\n         field_node.set(ns(\'write-permission\', self.namespace), \'dummy.Write\')\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy\')\n+            dummy = zope.schema.TextLine(title=\'dummy\')\n \n         handler = SecuritySchema()\n         handler.read(field_node, IDummy, IDummy[\'dummy\'])\n \n         self.assertEqual(\n-            {u\'dummy\': \'dummy.Read\'},\n+            {\'dummy\': \'dummy.Read\'},\n             IDummy.getTaggedValue(READ_PERMISSIONS_KEY)\n         )\n         self.assertEqual(\n-            {u\'dummy\': \'dummy.Write\'},\n+            {\'dummy\': \'dummy.Write\'},\n             IDummy.getTaggedValue(WRITE_PERMISSIONS_KEY)\n         )\n \n@@ -443,7 +442,7 @@ def test_read_no_permissions(self):\n         field_node = etree.Element(\'field\')\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy\')\n+            dummy = zope.schema.TextLine(title=\'dummy\')\n \n         handler = SecuritySchema()\n         handler.read(field_node, IDummy, IDummy[\'dummy\'])\n@@ -455,10 +454,10 @@ def test_write(self):\n         field_node = etree.Element(\'field\')\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy\')\n+            dummy = zope.schema.TextLine(title=\'dummy\')\n \n-        IDummy.setTaggedValue(READ_PERMISSIONS_KEY, {u\'dummy\': \'dummy.Read\'})\n-        IDummy.setTaggedValue(WRITE_PERMISSIONS_KEY, {u\'dummy\': \'dummy.Write\'})\n+        IDummy.setTaggedValue(READ_PERMISSIONS_KEY, {\'dummy\': \'dummy.Read\'})\n+        IDummy.setTaggedValue(WRITE_PERMISSIONS_KEY, {\'dummy\': \'dummy.Write\'})\n \n         handler = SecuritySchema()\n         handler.write(field_node, IDummy, IDummy[\'dummy\'])\n@@ -476,9 +475,9 @@ def test_write_no_permissions(self):\n         field_node = etree.Element(\'field\')\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy\')\n+            dummy = zope.schema.TextLine(title=\'dummy\')\n \n-        IDummy.setTaggedValue(READ_PERMISSIONS_KEY, {u\'dummy\': None})\n+        IDummy.setTaggedValue(READ_PERMISSIONS_KEY, {\'dummy\': None})\n \n         handler = SecuritySchema()\n         handler.write(field_node, IDummy, IDummy[\'dummy\'])\n@@ -496,7 +495,7 @@ def test_write_no_metadata(self):\n         field_node = etree.Element(\'field\')\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy\')\n+            dummy = zope.schema.TextLine(title=\'dummy\')\n \n         handler = SecuritySchema()\n         handler.write(field_node, IDummy, IDummy[\'dummy\'])\ndiff --git a/plone/autoform/tests/test_utils.py b/plone/autoform/tests/test_utils.py\nindex c5538ad..0a99bfb 100644\n--- a/plone/autoform/tests/test_utils.py\n+++ b/plone/autoform/tests/test_utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from AccessControl.SecurityManagement import setSecurityManager\n from AccessControl.SecurityManagement import getSecurityManager\n from plone.autoform.interfaces import WRITE_PERMISSIONS_KEY\n@@ -19,7 +18,7 @@\n class TestValidator(SimpleFieldValidator):\n \n     def validate(self, value):\n-        super(TestValidator, self).validate(value)\n+        super().validate(value)\n         raise Invalid(\'Test\')\n \n \n@@ -29,9 +28,9 @@ class TestUtils(unittest.TestCase):\n \n     def setUp(self):\n         from zope.security.permission import Permission\n-        provideUtility(Permission(\'foo\', u\'foo\', u\'\'), name=u\'foo\')\n+        provideUtility(Permission(\'foo\', \'foo\', \'\'), name=\'foo\')\n \n-        class DummySecurityManager(object):\n+        class DummySecurityManager:\n             checks = []\n \n             def checkPermission(self, perm, context):\n@@ -77,14 +76,14 @@ def test_processFields_fieldsets_as_form_groups(self):\n         class schema(Interface):\n             title = zope.schema.TextLine()\n \n-        fieldset = Fieldset(\'custom\', label=u\'Custom\',\n+        fieldset = Fieldset(\'custom\', label=\'Custom\',\n                             fields=[\'title\'])\n         schema.setTaggedValue(FIELDSETS_KEY, [fieldset])\n \n         class subschema(schema):\n             subtitle = zope.schema.TextLine()\n \n-        fieldset = Fieldset(\'custom\', label=u\'Custom\',\n+        fieldset = Fieldset(\'custom\', label=\'Custom\',\n                             fields=[\'subtitle\'])\n         subschema.setTaggedValue(FIELDSETS_KEY, [fieldset])\n \n@@ -106,13 +105,13 @@ def test_fieldset_configuration(self):\n         class schema1(Interface):\n             title = zope.schema.TextLine()\n \n-        fs1 = Fieldset(\'fs1\', label=u\'fs1\', fields=[\'title\'])\n+        fs1 = Fieldset(\'fs1\', label=\'fs1\', fields=[\'title\'])\n         schema1.setTaggedValue(FIELDSETS_KEY, [fs1])\n \n         class schema2(Interface):\n             subtitle = zope.schema.TextLine()\n \n-        fs2 = Fieldset(\'fs2\', label=u\'fs2\', fields=[\'subtitle\'])\n+        fs2 = Fieldset(\'fs2\', label=\'fs2\', fields=[\'subtitle\'])\n         schema2.setTaggedValue(FIELDSETS_KEY, [fs2])\n \n         class schema3(Interface):\ndiff --git a/plone/autoform/tests/test_widgets.py b/plone/autoform/tests/test_widgets.py\nindex a62bf6e..57512fd 100644\n--- a/plone/autoform/tests/test_widgets.py\n+++ b/plone/autoform/tests/test_widgets.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.testing.zca import UNIT_TESTING\n \n import unittest\n@@ -16,7 +15,7 @@ def test_widget_instantiated_with_parameters(self):\n         from zope.schema import Field\n \n         @implementer(IWidget)\n-        class DummyWidget(object):\n+        class DummyWidget:\n \n             def __init__(self, request):\n                 self.request = request\n@@ -40,7 +39,7 @@ def test_default_widget_instantiated(self):\n         from zope.interface import implementer\n         from zope.schema import Field\n \n-        class DummyWidget(object):\n+        class DummyWidget:\n \n             def __init__(self, request):\n                 self.request = request\n@@ -61,7 +60,7 @@ def DummyFieldWidget(field, request):\n     def test_validates_for_field_widget(self):\n         from plone.autoform.widgets import ParameterizedWidget\n \n-        class NotAWidget(object):\n+        class NotAWidget:\n             pass\n \n         try:\ndiff --git a/plone/autoform/utils.py b/plone/autoform/utils.py\nindex f3f2515..585f806 100644\n--- a/plone/autoform/utils.py\n+++ b/plone/autoform/utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from AccessControl import getSecurityManager\n from plone.autoform.interfaces import IParameterizedWidget\n from plone.autoform.interfaces import MODES_KEY\n@@ -106,7 +105,7 @@ def _process_widgets(form, widgets, modes, newFields):\n \n         widgetFactory = None\n         if widgetName is not None:\n-            if isinstance(widgetName, six.string_types):\n+            if isinstance(widgetName, str):\n                 widgetFactory = resolveDottedName(widgetName)\n             elif IFieldWidget.implementedBy(widgetName):\n                 widgetFactory = widgetName\ndiff --git a/plone/autoform/view.py b/plone/autoform/view.py\nindex bc1e5f6..2a5851d 100644\n--- a/plone/autoform/view.py\n+++ b/plone/autoform/view.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.base import AutoFields\n from plone.autoform.interfaces import IWidgetsView\n from plone.z3cform import z2\ndiff --git a/plone/autoform/widgets.py b/plone/autoform/widgets.py\nindex c1f8d08..c759d3a 100644\n--- a/plone/autoform/widgets.py\n+++ b/plone/autoform/widgets.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.interfaces import IParameterizedWidget\n from plone.autoform.interfaces import IWidgetExportImportHandler\n from plone.autoform.utils import resolveDottedName\n@@ -22,7 +21,7 @@\n \n \n @implementer(IParameterizedWidget)\n-class ParameterizedWidget(object):\n+class ParameterizedWidget:\n     """A factory for deferred construction of widgets with parameters.\n \n     z3c.form widgets are associated with a particular request,\n@@ -46,7 +45,7 @@ def __init__(self, widget_factory=None, **params):\n         if widget_factory is not None:\n             if not IFieldWidget.implementedBy(widget_factory) \\\n                     and not IWidget.implementedBy(widget_factory) \\\n-                    and not isinstance(widget_factory, six.string_types):\n+                    and not isinstance(widget_factory, str):\n                 raise TypeError(\'widget_factory must be an IFieldWidget \'\n                                 \'or an IWidget\')\n         self.widget_factory = widget_factory\n@@ -54,17 +53,17 @@ def __init__(self, widget_factory=None, **params):\n \n     def __call__(self, field, request):\n         __traceback_info__ = (\n-            \'{0}, processing:\\n\'\n-            \'- field "{1}"\\n\'\n-            \'- widget: {2}\\n\'\n-            \'- params: {3}\\n\'.format(\n+            \'{}, processing:\\n\'\n+            \'- field "{}"\\n\'\n+            \'- widget: {}\\n\'\n+            \'- params: {}\\n\'.format(\n                 self.__class__.__name__,\n                 field.__name__,\n                 repr(self.widget_factory),\n                 self.params\n             )\n         )\n-        if isinstance(self.widget_factory, six.string_types):\n+        if isinstance(self.widget_factory, str):\n             __traceback_info__ += \'- resolving dotted name\\n\'\n             self.widget_factory = resolveDottedName(self.widget_factory)\n         if self.widget_factory is None:\n@@ -83,7 +82,7 @@ def __call__(self, field, request):\n         return widget\n \n     def __repr__(self):\n-        return \'{0}({1}, {2})\'.format(\n+        return \'{}({}, {})\'.format(\n             self.__class__.__name__,\n             self.widget_factory,\n             self.params\n@@ -97,8 +96,8 @@ def getWidgetFactoryName(self):\n         widget = self.widget_factory\n         if widget is None:\n             return\n-        if not isinstance(widget, six.string_types):\n-            widget = \'{0}.{1}\'.format(widget.__module__, widget.__name__)\n+        if not isinstance(widget, str):\n+            widget = f\'{widget.__module__}.{widget.__name__}\'\n         return widget\n \n     def getExportImportHandler(self, field):\n@@ -112,12 +111,12 @@ def getExportImportHandler(self, field):\n             widgetFactory = sm.adapters.lookup(\n                 (providedBy(field), IFormLayer), IFieldWidget)\n             if widgetFactory is not None:\n-                widgetName = \'{0}.{1}\'.format(\n+                widgetName = \'{}.{}\'.format(\n                     widgetFactory.__module__,\n                     widgetFactory.__name__\n                 )\n             else:\n-                widgetName = u\'\'\n+                widgetName = \'\'\n \n         widgetHandler = queryUtility(IWidgetExportImportHandler,\n                                      name=widgetName)\n@@ -127,7 +126,7 @@ def getExportImportHandler(self, field):\n \n \n @implementer(IWidgetExportImportHandler)\n-class WidgetExportImportHandler(object):\n+class WidgetExportImportHandler:\n \n     def __init__(self, widget_schema):\n         self.fieldAttributes = getFields(widget_schema)\ndiff --git a/setup.py b/setup.py\nindex 6787369..9d869e4 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n'

Repository: plone.autoform


Branch: refs/heads/master
Date: 2023-03-15T22:41:07+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.autoform/commit/12d74b21b20ec495a7b9768d8c3e5b694dfc067a

chore: isort

Files changed:
M plone/autoform/tests/test_directives.py
M plone/autoform/tests/test_utils.py
M plone/autoform/tests/test_widgets.py

b"diff --git a/plone/autoform/tests/test_directives.py b/plone/autoform/tests/test_directives.py\nindex 1224ffb..d540c61 100644\n--- a/plone/autoform/tests/test_directives.py\n+++ b/plone/autoform/tests/test_directives.py\n@@ -77,9 +77,9 @@ class IDummy(model.Schema):\n         )\n \n     def test_widget_parameterized(self):\n-        from zope.interface import implementer\n-        from z3c.form.interfaces import IWidget\n         from plone.autoform.widgets import ParameterizedWidget\n+        from z3c.form.interfaces import IWidget\n+        from zope.interface import implementer\n \n         @implementer(IWidget)\n         class DummyWidget:\n@@ -97,9 +97,9 @@ class IDummy(model.Schema):\n         self.assertEqual('bar', tv['foo'].params['foo'])\n \n     def test_widget_parameterized_default_widget_factory(self):\n-        from zope.interface import implementer\n-        from z3c.form.interfaces import IWidget\n         from plone.autoform.widgets import ParameterizedWidget\n+        from z3c.form.interfaces import IWidget\n+        from zope.interface import implementer\n \n         @implementer(IWidget)\n         class DummyWidget:\ndiff --git a/plone/autoform/tests/test_utils.py b/plone/autoform/tests/test_utils.py\nindex 0a99bfb..2db5338 100644\n--- a/plone/autoform/tests/test_utils.py\n+++ b/plone/autoform/tests/test_utils.py\n@@ -1,5 +1,5 @@\n-from AccessControl.SecurityManagement import setSecurityManager\n from AccessControl.SecurityManagement import getSecurityManager\n+from AccessControl.SecurityManagement import setSecurityManager\n from plone.autoform.interfaces import WRITE_PERMISSIONS_KEY\n from plone.autoform.utils import processFields\n from plone.supermodel.interfaces import FIELDSETS_KEY\ndiff --git a/plone/autoform/tests/test_widgets.py b/plone/autoform/tests/test_widgets.py\nindex 57512fd..f75396b 100644\n--- a/plone/autoform/tests/test_widgets.py\n+++ b/plone/autoform/tests/test_widgets.py\n@@ -35,8 +35,8 @@ def test_default_widget_instantiated(self):\n         from plone.autoform.widgets import ParameterizedWidget\n         from z3c.form.interfaces import IFieldWidget\n         from zope.component import provideAdapter\n-        from zope.interface import Interface\n         from zope.interface import implementer\n+        from zope.interface import Interface\n         from zope.schema import Field\n \n         class DummyWidget:\n"

Repository: plone.autoform


Branch: refs/heads/master
Date: 2023-03-15T22:50:09+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.autoform/commit/3ddd05ca453de9cf4ecd95541647c682cd923caa

chore: black

Files changed:
M plone/__init__.py
M plone/autoform/base.py
M plone/autoform/directives.py
M plone/autoform/form.py
M plone/autoform/interfaces.py
M plone/autoform/supermodel.py
M plone/autoform/testing.py
M plone/autoform/tests/test_base.py
M plone/autoform/tests/test_directives.py
M plone/autoform/tests/test_doctests.py
M plone/autoform/tests/test_supermodel_handler.py
M plone/autoform/tests/test_utils.py
M plone/autoform/tests/test_widgets.py
M plone/autoform/utils.py
M plone/autoform/view.py
M plone/autoform/widgets.py
M setup.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex de40ea7..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1 +1 @@\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/autoform/base.py b/plone/autoform/base.py\nindex d32ee41..4bb302c 100644\n--- a/plone/autoform/base.py\n+++ b/plone/autoform/base.py\n@@ -32,12 +32,11 @@ class AutoFields:\n     autoGroups = False\n \n     def updateFieldsFromSchemata(self):\n-\n         # If the form is called from the ++widget++ traversal namespace,\n         # we won\'t have a user yet. In this case, we can\'t perform permission\n         # checks.\n \n-        have_user = bool(self.request.get(\'AUTHENTICATED_USER\', False))\n+        have_user = bool(self.request.get("AUTHENTICATED_USER", False))\n \n         # Turn fields into an instance variable, since we will be modifying it\n         self.fields = field.Fields(self.fields)\n@@ -48,12 +47,12 @@ def updateFieldsFromSchemata(self):\n         groups = []\n \n         for group in self.groups:\n-            group_name = getattr(group, \'__name__\', group.label)\n+            group_name = getattr(group, "__name__", group.label)\n             fieldset_group = GroupFactory(\n                 group_name,\n                 field.Fields(group.fields),\n                 group.label,\n-                getattr(group, \'description\', None)\n+                getattr(group, "description", None),\n             )\n             groups.append(fieldset_group)\n \n@@ -68,7 +67,6 @@ def updateFieldsFromSchemata(self):\n \n         # Set up all widgets, modes, omitted fields and fieldsets\n         for schema in self.additionalSchemata:\n-\n             # Find the prefix to use for this form and cache for next round\n             prefix = self.getPrefix(schema)\n             if prefix and prefix in prefixes:\n@@ -92,7 +90,7 @@ def updateFieldsFromSchemata(self):\n                 # store this in a dict.\n                 found = False\n                 for g in self.groups:\n-                    if group_name == getattr(g, \'__name__\', g.label):\n+                    if group_name == getattr(g, "__name__", g.label):\n                         found = True\n                         break\n \n@@ -113,13 +111,13 @@ def updateFieldsFromSchemata(self):\n                 schema,\n                 prefix=prefix,\n                 defaultGroup=defaultGroup,\n-                permissionChecks=have_user\n+                permissionChecks=have_user,\n             )\n \n         # Then process relative field movements. The base schema is processed\n         # last to allow it to override any movements made in additional\n         # schemata.\n-        rules = {\'__all__\': {}}\n+        rules = {"__all__": {}}\n         for schema in self.additionalSchemata:\n             order = mergedTaggedValueList(schema, ORDER_KEY)\n             rules = self._calculate_field_moves(\n@@ -135,72 +133,66 @@ def updateFieldsFromSchemata(self):\n         self._process_group_order()\n \n     def getPrefix(self, schema):\n-        """Get the preferred prefix for the given schema\n-        """\n+        """Get the preferred prefix for the given schema"""\n         if self.ignorePrefix:\n-            return \'\'\n+            return ""\n         return schema.__name__\n \n     def _prepare_names(self, source, target, prefix):\n-            # calculate prefixed fieldname\n+        # calculate prefixed fieldname\n+        if prefix:\n+            source = f"{prefix}.{source}"\n+\n+        # Handle shortcut: leading . means "in this form". May be useful\n+        # if you want to move a field relative to one in the current\n+        # schema or (more likely) a base schema of the current schema,\n+        # without having to repeat the full prefix of this schema.\n+        if target.startswith("."):\n+            target = target[1:]\n             if prefix:\n-                source = f\'{prefix}.{source}\'\n-\n-            # Handle shortcut: leading . means "in this form". May be useful\n-            # if you want to move a field relative to one in the current\n-            # schema or (more likely) a base schema of the current schema,\n-            # without having to repeat the full prefix of this schema.\n-            if target.startswith(\'.\'):\n-                target = target[1:]\n-                if prefix:\n-                    target = expandPrefix(prefix) + target\n-            return source, target\n+                target = expandPrefix(prefix) + target\n+        return source, target\n \n     def _cleanup_rules(self, rules):\n-        for rulename in rules[\'__all__\']:\n-            if \'parent\' in rules[\'__all__\'][rulename]:\n-                del rules[\'__all__\'][rulename][\'parent\']\n-        del rules[\'__all__\']\n-\n-    def _calculate_field_moves(self, order, prefix=\'\', rules=None):\n-        """Calculates all needed field rules\n-        """\n+        for rulename in rules["__all__"]:\n+            if "parent" in rules["__all__"][rulename]:\n+                del rules["__all__"][rulename]["parent"]\n+        del rules["__all__"]\n+\n+    def _calculate_field_moves(self, order, prefix="", rules=None):\n+        """Calculates all needed field rules"""\n         # we want to be independent from the order of the schemas coming later\n         # so a if field_c is first moved after field_a, then field_a is moved\n         # after field_c, the output should be: b, a, c, because or first move\n         # sticks\n         if rules is None:\n             rules = {}\n-        allrules = rules.get(\'__all__\', None)\n+        allrules = rules.get("__all__", None)\n         if allrules is None:\n-            allrules = rules[\'__all__\'] = dict()\n+            allrules = rules["__all__"] = dict()\n \n         # (current field name, \'before\'/\'after\', other field name)\n         for source, direction, target in order:\n             source, target = self._prepare_names(source, target, prefix)\n             # use a simple tree to resolve dependencies\n             rule = allrules.get(source, {})\n-            if (\n-                \'target\' in rule and target != rule[\'target\']\n-            ):\n+            if "target" in rule and target != rule["target"]:\n                 # target override\n                 # reset this rule to a stub first\n-                del rule[\'target\']\n-                del rule[\'dir\']\n-                rule[\'stub\'] = True\n+                del rule["target"]\n+                del rule["dir"]\n+                rule["stub"] = True\n                 # unlink in parent\n-                del rule[\'parent\'][\'with\'][source]\n-                del rule[\'parent\']\n-            if (\n-                \'dir\' in rule and direction != rule[\'dir\']\n-            ):\n+                del rule["parent"]["with"][source]\n+                del rule["parent"]\n+            if "dir" in rule and direction != rule["dir"]:\n                 # direction override\n-                rule[\'dir\'] = direction\n-            if not rule or rule.get(\'stub\', False):\n-                if rule.get(\'stub\', False):\n-                    del rule[\'stub\']\n-                rule[\'target\'] = target\n-                rule[\'dir\'] = direction\n+                rule["dir"] = direction\n+            if not rule or rule.get("stub", False):\n+                if rule.get("stub", False):\n+                    del rule["stub"]\n+                rule["target"] = target\n+                rule["dir"] = direction\n                 allrules[source] = rule\n \n             # field is no longer a tree root\n@@ -210,57 +202,52 @@ def _calculate_field_moves(self, order, prefix=\'\', rules=None):\n             target_rule = allrules.get(target, None)\n             if target_rule is None:\n                 allrules[target] = target_rule = {\n-                    \'stub\': True,\n+                    "stub": True,\n                 }\n                 rules[target] = target_rule\n-            if \'with\' not in target_rule:\n-                target_rule[\'with\'] = OrderedDict()\n-            rule[\'parent\'] = target_rule\n-            target_rule[\'with\'][source] = rule\n+            if "with" not in target_rule:\n+                target_rule["with"] = OrderedDict()\n+            rule["parent"] = target_rule\n+            target_rule["with"][source] = rule\n \n         return rules\n \n     def _process_field_moves(self, rules):\n-        """move fields according to the rules\n-        """\n+        """move fields according to the rules"""\n         for name, rule in rules.items():\n-            if name == \'__all__\':\n+            if name == "__all__":\n                 continue\n             prefix = None\n-            if \'.\' in name:\n-                prefix, name = name.split(\'.\', 1)\n+            if "." in name:\n+                prefix, name = name.split(".", 1)\n             else:\n-                prefix = \'\'\n-            if not rule.get(\'stub\', False):\n-                after = rule[\'target\'] if rule[\'dir\'] == \'after\' else None\n-                before = rule[\'target\'] if rule[\'dir\'] == \'before\' else None\n+                prefix = ""\n+            if not rule.get("stub", False):\n+                after = rule["target"] if rule["dir"] == "after" else None\n+                before = rule["target"] if rule["dir"] == "before" else None\n                 if not (before or after):\n                     raise ValueError(\n-                        \'Direction of a field move must be before or \'\n-                        \'after, but got {}.\'.format(rule[\'direction\'])\n+                        "Direction of a field move must be before or "\n+                        "after, but got {}.".format(rule["direction"])\n                     )\n                 try:\n                     move(self, name, before=before, after=after, prefix=prefix)\n                 except KeyError as e:\n                     message = e.args[0]\n-                    if (\n-                        message.startswith(\'Field \') and\n-                        message.endswith(\' not found\')\n-                    ):\n+                    if message.startswith("Field ") and message.endswith(" not found"):\n                         # The relative_to field doesn\'t exist\n                         logger.debug(\n-                            \'Field move to non-existing: \'\n-                            \'field name: {}, rule: {}\'.format(\n-                                prefix + \'.\' + name,\n-                                str(rule)\n+                            "Field move to non-existing: "\n+                            "field name: {}, rule: {}".format(\n+                                prefix + "." + name, str(rule)\n                             )\n                         )\n                     else:\n                         raise\n-            self._process_field_moves(rule.get(\'with\', {}))\n+            self._process_field_moves(rule.get("with", {}))\n \n     def _process_group_order(self):\n         try:\n-            self.groups.sort(key=attrgetter(\'order\'))\n+            self.groups.sort(key=attrgetter("order"))\n         except TypeError:\n             pass\ndiff --git a/plone/autoform/directives.py b/plone/autoform/directives.py\nindex e3d9eeb..0013751 100644\n--- a/plone/autoform/directives.py\n+++ b/plone/autoform/directives.py\n@@ -18,16 +18,14 @@\n \n \n class omitted(MetadataListDirective):\n-    """Directive used to omit one or more fields\n-    """\n+    """Directive used to omit one or more fields"""\n+\n     key = OMITTED_KEY\n-    value = \'true\'\n+    value = "true"\n \n     def factory(self, *args):\n         if not args:\n-            raise TypeError(\n-                \'The omitted directive expects at least one argument.\'\n-            )\n+            raise TypeError("The omitted directive expects at least one argument.")\n         form_interface = Interface\n         if IInterface.providedBy(args[0]):\n             form_interface = args[0]\n@@ -36,13 +34,12 @@ def factory(self, *args):\n \n \n class no_omit(omitted):\n-    """Directive used to prevent one or more fields from being omitted\n-    """\n-    value = \'false\'\n+    """Directive used to prevent one or more fields from being omitted"""\n \n+    value = "false"\n \n-class OmittedPlugin(ListCheckerPlugin):\n \n+class OmittedPlugin(ListCheckerPlugin):\n     key = OMITTED_KEY\n \n     def fieldNames(self):\n@@ -53,15 +50,13 @@ def fieldNames(self):\n \n \n class mode(MetadataListDirective):\n-    """Directive used to set the mode of one or more fields\n-    """\n+    """Directive used to set the mode of one or more fields"""\n+\n     key = MODES_KEY\n \n     def factory(self, *args, **kw):\n         if len(args) > 1:\n-            raise TypeError(\n-                \'The mode directive expects 0 or 1 non-keyword arguments.\'\n-            )\n+            raise TypeError("The mode directive expects 0 or 1 non-keyword arguments.")\n         form_interface = Interface\n         if args:\n             form_interface = args[0]\n@@ -121,18 +116,15 @@ def factory(self, field_name=None, widget_class=None, **kw):\n         if field_name is None:  # Usage 3\n             for field_name, widget in kw.items():\n                 if not isinstance(widget, str):\n-                    widget = \'{}.{}\'.format(\n-                        widget.__module__,\n-                        widget.__name__\n-                    )\n+                    widget = f"{widget.__module__}.{widget.__name__}"\n                 widgets[field_name] = widget\n         else:\n-            if widget_class is not None \\\n-               and not IFieldWidget.implementedBy(widget_class) \\\n-               and not IWidget.implementedBy(widget_class):\n-                raise TypeError(\n-                    \'widget_class must implement IWidget or IFieldWidget\'\n-                )\n+            if (\n+                widget_class is not None\n+                and not IFieldWidget.implementedBy(widget_class)\n+                and not IWidget.implementedBy(widget_class)\n+            ):\n+                raise TypeError("widget_class must implement IWidget or IFieldWidget")\n             widgets[field_name] = ParameterizedWidget(widget_class, **kw)\n \n         return widgets\n@@ -143,23 +135,26 @@ class WidgetPlugin(DictCheckerPlugin):\n \n \n class order_before(MetadataListDirective):\n-    """Directive used to order one field before another\n-    """\n+    """Directive used to order one field before another"""\n+\n     key = ORDER_KEY\n \n     def factory(self, **kw):\n-        return [(field_name, \'before\', relative_to)\n-                for field_name, relative_to in kw.items()]\n+        return [\n+            (field_name, "before", relative_to)\n+            for field_name, relative_to in kw.items()\n+        ]\n \n \n class order_after(MetadataListDirective):\n-    """Directive used to order one field after another\n-    """\n+    """Directive used to order one field after another"""\n+\n     key = ORDER_KEY\n \n     def factory(self, **kw):\n-        return [(field_name, \'after\', relative_to)\n-                for field_name, relative_to in kw.items()]\n+        return [\n+            (field_name, "after", relative_to) for field_name, relative_to in kw.items()\n+        ]\n \n \n class OrderPlugin(ListCheckerPlugin):\n@@ -173,8 +168,8 @@ def fieldNames(self):\n \n \n class read_permission(MetadataDictDirective):\n-    """Directive used to set a field read permission\n-    """\n+    """Directive used to set a field read permission"""\n+\n     key = READ_PERMISSIONS_KEY\n \n     def factory(self, **kw):\n@@ -182,8 +177,8 @@ def factory(self, **kw):\n \n \n class write_permission(read_permission):\n-    """Directive used to set a field write permission\n-    """\n+    """Directive used to set a field write permission"""\n+\n     key = WRITE_PERMISSIONS_KEY\n \n \ndiff --git a/plone/autoform/form.py b/plone/autoform/form.py\nindex d9f0503..66b5187 100644\n--- a/plone/autoform/form.py\n+++ b/plone/autoform/form.py\n@@ -19,14 +19,13 @@ class AutoExtensibleForm(AutoFields, ExtensibleForm):\n     @property\n     def schema(self):\n         raise NotImplementedError(\n-            \'The class deriving from AutoExtensibleForm must have a \'\n-            \'\\\'schema\\\' property\'\n+            "The class deriving from AutoExtensibleForm must have a "\n+            "\'schema\' property"\n         )\n \n     @property\n     def additionalSchemata(self):\n-        """Default to there being no additional schemata\n-        """\n+        """Default to there being no additional schemata"""\n         return ()\n \n     def updateFields(self):\ndiff --git a/plone/autoform/interfaces.py b/plone/autoform/interfaces.py\nindex 8edb077..75c65a1 100644\n--- a/plone/autoform/interfaces.py\n+++ b/plone/autoform/interfaces.py\n@@ -10,26 +10,25 @@\n \n \n # Schema interface tagged value keys\n-MODES_KEY = \'plone.autoform.modes\'\n-OMITTED_KEY = \'plone.autoform.omitted\'\n-ORDER_KEY = \'plone.autoform.order\'\n-WIDGETS_KEY = \'plone.autoform.widgets\'\n+MODES_KEY = "plone.autoform.modes"\n+OMITTED_KEY = "plone.autoform.omitted"\n+ORDER_KEY = "plone.autoform.order"\n+WIDGETS_KEY = "plone.autoform.widgets"\n \n-READ_PERMISSIONS_KEY = \'plone.autoform.security.read-permissions\'\n-WRITE_PERMISSIONS_KEY = \'plone.autoform.security.write-permissions\'\n+READ_PERMISSIONS_KEY = "plone.autoform.security.read-permissions"\n+WRITE_PERMISSIONS_KEY = "plone.autoform.security.write-permissions"\n \n # Supermodel namespace and prefix\n \n-FORM_NAMESPACE = \'http://namespaces.plone.org/supermodel/form\'\n-FORM_PREFIX = \'form\'\n+FORM_NAMESPACE = "http://namespaces.plone.org/supermodel/form"\n+FORM_PREFIX = "form"\n \n-SECURITY_NAMESPACE = \'http://namespaces.plone.org/supermodel/security\'\n-SECURITY_PREFIX = \'security\'\n+SECURITY_NAMESPACE = "http://namespaces.plone.org/supermodel/security"\n+SECURITY_PREFIX = "security"\n \n \n class IFormFieldProvider(Interface):\n-    """Marker interface for schemata that provide form fields.\n-    """\n+    """Marker interface for schemata that provide form fields."""\n \n \n class IAutoExtensibleForm(Interface):\n@@ -41,22 +40,15 @@ class IAutoExtensibleForm(Interface):\n     """\n \n     ignorePrefix = zope.schema.Bool(\n-        title=\'Do not set a prefix for additional schemata\',\n-        default=False\n+        title="Do not set a prefix for additional schemata", default=False\n     )\n \n-    schema = zope.schema.Object(\n-        title=\'Schema providing form fields\',\n-        schema=IInterface\n-    )\n+    schema = zope.schema.Object(title="Schema providing form fields", schema=IInterface)\n \n     additionalSchemata = zope.schema.Tuple(\n-        title=\'Supplementary schemata providing additional form fields\',\n-        value_type=zope.schema.Object(\n-            title=\'Schema interface\',\n-            schema=IInterface\n-        ),\n-        required=False\n+        title="Supplementary schemata providing additional form fields",\n+        value_type=zope.schema.Object(title="Schema interface", schema=IInterface),\n+        required=False,\n     )\n \n \n@@ -65,10 +57,7 @@ class IAutoObjectSubForm(Interface):\n     to also have its fields updated with form hints. See subform.txt\n     """\n \n-    schema = zope.schema.Object(\n-        title=\'Schema providing form fields\',\n-        schema=IInterface\n-    )\n+    schema = zope.schema.Object(title="Schema providing form fields", schema=IInterface)\n \n \n class IWidgetsView(IAutoExtensibleForm, IFieldsForm, IDisplayForm):\n@@ -77,27 +66,17 @@ class IWidgetsView(IAutoExtensibleForm, IFieldsForm, IDisplayForm):\n     """\n \n     w = zope.schema.Dict(\n-        title=\'Shortcut lookup for all widgets\',\n-        description=\'Contains all widgets, including those from groups \'\n-                    \'within this form\',\n-        key_type=zope.schema.ASCIILine(\n-            title=\'Widget name, with prefix\'\n-        ),\n-        value_type=zope.schema.Object(\n-            title=\'Widget\',\n-            schema=IWidget\n-        )\n+        title="Shortcut lookup for all widgets",\n+        description="Contains all widgets, including those from groups "\n+        "within this form",\n+        key_type=zope.schema.ASCIILine(title="Widget name, with prefix"),\n+        value_type=zope.schema.Object(title="Widget", schema=IWidget),\n     )\n \n     fieldsets = zope.schema.Dict(\n-        title=\'Lookup fieldset (group) by name\',\n-        key_type=zope.schema.ASCIILine(\n-            title=\'Fieldset name\'\n-        ),\n-        value_type=zope.schema.Object(\n-            title=\'Fieldset\',\n-            schema=IFieldset\n-        )\n+        title="Lookup fieldset (group) by name",\n+        key_type=zope.schema.ASCIILine(title="Fieldset name"),\n+        value_type=zope.schema.Object(title="Fieldset", schema=IFieldset),\n     )\n \n \ndiff --git a/plone/autoform/supermodel.py b/plone/autoform/supermodel.py\nindex 17e02d2..6764dfb 100644\n--- a/plone/autoform/supermodel.py\n+++ b/plone/autoform/supermodel.py\n@@ -24,8 +24,7 @@\n \n @implementer(IFieldMetadataHandler)\n class FormSchema:\n-    """Support the form: namespace in model definitions.\n-    """\n+    """Support the form: namespace in model definitions."""\n \n     namespace = FORM_NAMESPACE\n     prefix = FORM_PREFIX\n@@ -37,20 +36,18 @@ def _add(self, schema, key, name, value):\n \n     def _add_order(self, schema, name, direction, relative_to):\n         tagged_value = schema.queryTaggedValue(ORDER_KEY, [])\n-        tagged_value.append((name, direction, relative_to,))\n+        tagged_value.append((name, direction, relative_to))\n         schema.setTaggedValue(ORDER_KEY, tagged_value)\n \n     def _add_interface_values(self, schema, key, name, values):\n         tagged_value = schema.queryTaggedValue(key, [])\n-        values = values.split(\' \')\n+        values = values.split(" ")\n         for value in values:\n-            if \':\' in value:\n-                (interface_dotted_name, value) = value.split(\':\')\n+            if ":" in value:\n+                (interface_dotted_name, value) = value.split(":")\n                 interface = resolveDottedName(interface_dotted_name)\n                 if not isinstance(interface, InterfaceClass):\n-                    raise ValueError(\n-                        f\'{interface_dotted_name} not an Interface.\'\n-                    )\n+                    raise ValueError(f"{interface_dotted_name} not an Interface.")\n             else:\n                 interface = Interface\n             tagged_value.append((interface, name, value))\n@@ -59,7 +56,7 @@ def _add_interface_values(self, schema, key, name, values):\n     def _add_validator(self, field, value):\n         validator = resolveDottedName(value)\n         if not IValidator.implementedBy(validator):\n-            msg = \'z3c.form.interfaces.IValidator not implemented by {0}.\'\n+            msg = "z3c.form.interfaces.IValidator not implemented by {0}."\n             raise ValueError(msg.format(value))\n         provideAdapter(\n             validator,\n@@ -70,28 +67,28 @@ def _add_validator(self, field, value):\n     def read(self, fieldNode, schema, field):\n         name = field.__name__\n \n-        widgetAttr = fieldNode.get(ns(\'widget\', self.namespace))\n-        mode = fieldNode.get(ns(\'mode\', self.namespace))\n-        omitted = fieldNode.get(ns(\'omitted\', self.namespace))\n-        before = fieldNode.get(ns(\'before\', self.namespace))\n-        after = fieldNode.get(ns(\'after\', self.namespace))\n-        validator = fieldNode.get(ns(\'validator\', self.namespace))\n+        widgetAttr = fieldNode.get(ns("widget", self.namespace))\n+        mode = fieldNode.get(ns("mode", self.namespace))\n+        omitted = fieldNode.get(ns("omitted", self.namespace))\n+        before = fieldNode.get(ns("before", self.namespace))\n+        after = fieldNode.get(ns("after", self.namespace))\n+        validator = fieldNode.get(ns("validator", self.namespace))\n \n         if mode:\n             self._add_interface_values(schema, MODES_KEY, name, mode)\n         if omitted:\n             self._add_interface_values(schema, OMITTED_KEY, name, omitted)\n         if before:\n-            self._add_order(schema, name, \'before\', before)\n+            self._add_order(schema, name, "before", before)\n         if after:\n-            self._add_order(schema, name, \'after\', after)\n+            self._add_order(schema, name, "after", after)\n         if validator:\n             self._add_validator(field, validator)\n \n-        widgetNode = fieldNode.find(ns(\'widget\', self.namespace))\n+        widgetNode = fieldNode.find(ns("widget", self.namespace))\n         widget = None\n         if widgetNode is not None:  # form:widget element\n-            widgetFactory = widgetNode.get(\'type\')\n+            widgetFactory = widgetNode.get("type")\n             if widgetFactory is not None:\n                 # resolve immediately so we don\'t have to each time\n                 # form is rendered\n@@ -102,9 +99,7 @@ def read(self, fieldNode, schema, field):\n         elif widgetAttr is not None:  # BBB for old form:widget attributes\n             obj = resolveDottedName(widgetAttr)\n             if not IFieldWidget.implementedBy(obj):\n-                raise ValueError(\n-                    f\'IFieldWidget not implemented by {obj}\'\n-                )\n+                raise ValueError(f"IFieldWidget not implemented by {obj}")\n             widget = widgetAttr\n         if widget is not None:\n             self._add(schema, WIDGETS_KEY, name, widget)\n@@ -114,16 +109,13 @@ def write(self, fieldNode, schema, field):\n \n         widget = schema.queryTaggedValue(WIDGETS_KEY, {}).get(name, None)\n         mode = [\n-            (i, v) for i, n, v in schema.queryTaggedValue(MODES_KEY, [])\n-            if n == name\n+            (i, v) for i, n, v in schema.queryTaggedValue(MODES_KEY, []) if n == name\n         ]\n         omitted = [\n-            (i, v) for i, n, v in schema.queryTaggedValue(OMITTED_KEY, [])\n-            if n == name\n+            (i, v) for i, n, v in schema.queryTaggedValue(OMITTED_KEY, []) if n == name\n         ]\n         order = [\n-            (d, v) for n, d, v in schema.queryTaggedValue(ORDER_KEY, [])\n-            if n == name\n+            (d, v) for n, d, v in schema.queryTaggedValue(ORDER_KEY, []) if n == name\n         ]\n \n         if widget is not None:\n@@ -131,10 +123,10 @@ def write(self, fieldNode, schema, field):\n                 widget = ParameterizedWidget(widget)\n \n             if widget.widget_factory or widget.params:\n-                widgetNode = etree.Element(ns(\'widget\', self.namespace))\n+                widgetNode = etree.Element(ns("widget", self.namespace))\n                 widgetName = widget.getWidgetFactoryName()\n                 if widgetName is not None:\n-                    widgetNode.set(\'type\', widgetName)\n+                    widgetNode.set("type", widgetName)\n \n                 widgetHandler = widget.getExportImportHandler(field)\n                 widgetHandler.write(widgetNode, widget.params)\n@@ -143,33 +135,29 @@ def write(self, fieldNode, schema, field):\n         mode_values = []\n         for interface, value in mode:\n             if interface is not Interface:\n-                value = f\'{interface.__identifier__}:{value}\'\n+                value = f"{interface.__identifier__}:{value}"\n             mode_values.append(value)\n         if mode_values:\n-            fieldNode.set(ns(\'mode\', self.namespace), \' \'.join(mode_values))\n+            fieldNode.set(ns("mode", self.namespace), " ".join(mode_values))\n \n         omitted_values = []\n         for interface, value in omitted:\n             if interface is not Interface:\n-                value = f\'{interface.__identifier__}:{value}\'\n+                value = f"{interface.__identifier__}:{value}"\n             omitted_values.append(value)\n         if omitted_values:\n-            fieldNode.set(\n-                ns(\'omitted\', self.namespace),\n-                \' \'.join(omitted_values)\n-            )\n+            fieldNode.set(ns("omitted", self.namespace), " ".join(omitted_values))\n \n         for direction, relative_to in order:\n-            if direction == \'before\':\n-                fieldNode.set(ns(\'before\', self.namespace), relative_to)\n-            elif direction == \'after\':\n-                fieldNode.set(ns(\'after\', self.namespace), relative_to)\n+            if direction == "before":\n+                fieldNode.set(ns("before", self.namespace), relative_to)\n+            elif direction == "after":\n+                fieldNode.set(ns("after", self.namespace), relative_to)\n \n \n @implementer(IFieldMetadataHandler)\n class SecuritySchema:\n-    """Support the security: namespace in model definitions.\n-    """\n+    """Support the security: namespace in model definitions."""\n \n     namespace = SECURITY_NAMESPACE\n     prefix = SECURITY_PREFIX\n@@ -177,10 +165,8 @@ class SecuritySchema:\n     def read(self, fieldNode, schema, field):\n         name = field.__name__\n \n-        read_permission = fieldNode.get(ns(\'read-permission\', self.namespace))\n-        write_permission = fieldNode.get(\n-            ns(\'write-permission\', self.namespace)\n-        )\n+        read_permission = fieldNode.get(ns("read-permission", self.namespace))\n+        write_permission = fieldNode.get(ns("write-permission", self.namespace))\n \n         read_permissions = schema.queryTaggedValue(READ_PERMISSIONS_KEY, {})\n         write_permissions = schema.queryTaggedValue(WRITE_PERMISSIONS_KEY, {})\n@@ -196,21 +182,14 @@ def read(self, fieldNode, schema, field):\n     def write(self, fieldNode, schema, field):\n         name = field.__name__\n \n-        read_permission = schema.queryTaggedValue(\n-            READ_PERMISSIONS_KEY, {}\n-        ).get(name, None)\n-        write_permission = schema.queryTaggedValue(\n-            WRITE_PERMISSIONS_KEY,\n-            {}\n-        ).get(name, None)\n+        read_permission = schema.queryTaggedValue(READ_PERMISSIONS_KEY, {}).get(\n+            name, None\n+        )\n+        write_permission = schema.queryTaggedValue(WRITE_PERMISSIONS_KEY, {}).get(\n+            name, None\n+        )\n \n         if read_permission:\n-            fieldNode.set(\n-                ns(\'read-permission\', self.namespace),\n-                read_permission\n-            )\n+            fieldNode.set(ns("read-permission", self.namespace), read_permission)\n         if write_permission:\n-            fieldNode.set(\n-                ns(\'write-permission\', self.namespace),\n-                write_permission\n-            )\n+            fieldNode.set(ns("write-permission", self.namespace), write_permission)\ndiff --git a/plone/autoform/testing.py b/plone/autoform/testing.py\nindex 399703e..20be3b5 100644\n--- a/plone/autoform/testing.py\n+++ b/plone/autoform/testing.py\n@@ -7,15 +7,13 @@\n \n AUTOFORM_FIXTURE = zca.ZCMLSandbox(\n     bases=(z2.STARTUP,),\n-    filename=\'configure.zcml\',\n+    filename="configure.zcml",\n     package=plone.autoform,\n-    name=\'plone.autoform:Fixture\')\n+    name="plone.autoform:Fixture",\n+)\n \n AUTOFORM_INTEGRATION_TESTING = z2.IntegrationTesting(\n-    bases=(AUTOFORM_FIXTURE,),\n-    name=\'plone.autoform:Integration\')\n-\n-optionflags = (\n-    doctest.NORMALIZE_WHITESPACE\n-    | doctest.ELLIPSIS\n+    bases=(AUTOFORM_FIXTURE,), name="plone.autoform:Integration"\n )\n+\n+optionflags = doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS\ndiff --git a/plone/autoform/tests/test_base.py b/plone/autoform/tests/test_base.py\nindex ed05cc6..e64f283 100644\n--- a/plone/autoform/tests/test_base.py\n+++ b/plone/autoform/tests/test_base.py\n@@ -5,122 +5,130 @@\n \n \n class TestBase(unittest.TestCase):\n-\n     layer = UNIT_TESTING\n \n     def test_calc_field_move_basics(self):\n         from plone.autoform.base import AutoFields\n+\n         autofields = AutoFields()\n \n         # we have a schema with fields [a, b, c]\n         # field \'c\' after \'a\'\n-        order = [(\'c\', \'after\', \'a\'), ]\n+        order = [\n+            ("c", "after", "a"),\n+        ]\n         rules = autofields._calculate_field_moves(order)\n-        self.assertIn(\'a\', rules)\n-        self.assertNotIn(\'c\', rules)\n-        self.assertIn(\'with\', rules[\'a\'])\n-        self.assertIn(\'stub\', rules[\'a\'])\n-        self.assertIn(\'c\', rules[\'a\'][\'with\'])\n-        self.assertIn(\'parent\', rules[\'a\'][\'with\'][\'c\'])\n-        self.assertIs(rules[\'a\'], rules[\'a\'][\'with\'][\'c\'][\'parent\'])\n-        self.assertIn(\'target\', rules[\'a\'][\'with\'][\'c\'])\n-        self.assertIn(\'dir\', rules[\'a\'][\'with\'][\'c\'])\n+        self.assertIn("a", rules)\n+        self.assertNotIn("c", rules)\n+        self.assertIn("with", rules["a"])\n+        self.assertIn("stub", rules["a"])\n+        self.assertIn("c", rules["a"]["with"])\n+        self.assertIn("parent", rules["a"]["with"]["c"])\n+        self.assertIs(rules["a"], rules["a"]["with"]["c"]["parent"])\n+        self.assertIn("target", rules["a"]["with"]["c"])\n+        self.assertIn("dir", rules["a"]["with"]["c"])\n \n     def test_calc_field_move_simple_dependency(self):\n         from plone.autoform.base import AutoFields\n+\n         autofields = AutoFields()\n \n         # we have a schema with fields [a, b, c]\n         # field a after b and field \'c\' after \'a\'\n         order = [\n-            (\'a\', \'after\', \'b\'),\n-            (\'c\', \'after\', \'a\'),\n+            ("a", "after", "b"),\n+            ("c", "after", "a"),\n         ]\n         expected = {\n-            \'stub\': True,\n-            \'with\': OrderedDict(\n+            "stub": True,\n+            "with": OrderedDict(\n                 [\n                     (\n-                        \'a\',\n+                        "a",\n                         {\n-                            \'with\': OrderedDict(\n-                                [(\'c\', {\'target\': \'a\', \'dir\': \'after\'})]\n+                            "with": OrderedDict(\n+                                [("c", {"target": "a", "dir": "after"})]\n                             ),\n-                            \'target\': \'b\', \'dir\': \'after\'}\n+                            "target": "b",\n+                            "dir": "after",\n+                        },\n                     ),\n                 ]\n-            )\n+            ),\n         }\n         rules = autofields._calculate_field_moves(order)\n-        self.assertIn(\'b\', rules)\n-        self.assertNotIn(\'a\', rules)\n-        self.assertNotIn(\'c\', rules)\n+        self.assertIn("b", rules)\n+        self.assertNotIn("a", rules)\n+        self.assertNotIn("c", rules)\n \n         # remove parent key enable comparison of  dicts\n-        del rules[\'__all__\'][\'a\'][\'parent\']\n-        del rules[\'__all__\'][\'c\'][\'parent\']\n-        self.assertEqual(rules[\'b\'], expected)\n+        del rules["__all__"]["a"]["parent"]\n+        del rules["__all__"]["c"]["parent"]\n+        self.assertEqual(rules["b"], expected)\n \n         # we have a schema with fields [a, b, c]\n         # vice versa defined now, must lead to same result\n         # field \'c\' after \'a\' and field a after b\n         order = reversed(order)\n         rules = autofields._calculate_field_moves(order)\n-        self.assertIn(\'b\', rules)\n-        self.assertNotIn(\'a\', rules)\n-        self.assertNotIn(\'c\', rules)\n+        self.assertIn("b", rules)\n+        self.assertNotIn("a", rules)\n+        self.assertNotIn("c", rules)\n \n         # remove parent key enable comparison of  dicts\n-        del rules[\'__all__\'][\'a\'][\'parent\']\n-        del rules[\'__all__\'][\'c\'][\'parent\']\n-        self.assertEqual(rules[\'b\'], expected)\n+        del rules["__all__"]["a"]["parent"]\n+        del rules["__all__"]["c"]["parent"]\n+        self.assertEqual(rules["b"], expected)\n \n     def test_calc_field_move_multiple_dependencies(self):\n         from plone.autoform.base import AutoFields\n+\n         autofields = AutoFields()\n \n         order = [\n-            (\'a\', \'after\', \'b\'),\n-            (\'c\', \'after\', \'a\'),\n-            (\'d\', \'after\', \'c\'),\n-            (\'z\', \'after\', \'x\'),\n-            (\'x\', \'after\', \'y\'),\n+            ("a", "after", "b"),\n+            ("c", "after", "a"),\n+            ("d", "after", "c"),\n+            ("z", "after", "x"),\n+            ("x", "after", "y"),\n         ]\n         rules = autofields._calculate_field_moves(order)\n-        self.assertIn(\'b\', rules)\n-        self.assertIn(\'y\', rules)\n-        self.assertNotIn(\'a\', rules)\n-        self.assertNotIn(\'c\', rules)\n-        self.assertNotIn(\'d\', rules)\n-        self.assertNotIn(\'z\', rules)\n-        self.assertNotIn(\'x\', rules)\n+        self.assertIn("b", rules)\n+        self.assertIn("y", rules)\n+        self.assertNotIn("a", rules)\n+        self.assertNotIn("c", rules)\n+        self.assertNotIn("d", rules)\n+        self.assertNotIn("z", rules)\n+        self.assertNotIn("x", rules)\n \n-        self.assertIn(\'a\', rules[\'b\'][\'with\'])\n-        self.assertEqual(1, len(rules[\'b\'][\'with\']))\n+        self.assertIn("a", rules["b"]["with"])\n+        self.assertEqual(1, len(rules["b"]["with"]))\n \n-        self.assertIn(\'c\', rules[\'b\'][\'with\'][\'a\'][\'with\'])\n-        self.assertEqual(1, len(rules[\'b\'][\'with\'][\'a\'][\'with\']))\n+        self.assertIn("c", rules["b"]["with"]["a"]["with"])\n+        self.assertEqual(1, len(rules["b"]["with"]["a"]["with"]))\n \n-        self.assertIn(\'d\', rules[\'b\'][\'with\'][\'a\'][\'with\'][\'c\'][\'with\'])\n-        self.assertEqual(1, len(rules[\'b\'][\'with\'][\'a\'][\'with\'][\'c\'][\'with\']))\n+        self.assertIn("d", rules["b"]["with"]["a"]["with"]["c"]["with"])\n+        self.assertEqual(1, len(rules["b"]["with"]["a"]["with"]["c"]["with"]))\n \n     def test_calc_field_move_override(self):\n         from plone.autoform.base import AutoFields\n+\n         autofields = AutoFields()\n \n         order = [\n-            (\'c\', \'after\', \'a\'),\n-            (\'a\', \'after\', \'b\'),\n-            (\'c\', \'after\', \'z\'),\n+            ("c", "after", "a"),\n+            ("a", "after", "b"),\n+            ("c", "after", "z"),\n         ]\n         rules = autofields._calculate_field_moves(order)\n-        self.assertIn(\'b\', rules)\n-        self.assertIn(\'z\', rules)\n-        self.assertNotIn(\'a\', rules)\n-        self.assertNotIn(\'c\', rules)\n+        self.assertIn("b", rules)\n+        self.assertIn("z", rules)\n+        self.assertNotIn("a", rules)\n+        self.assertNotIn("c", rules)\n \n     def test_updateFieldsFromSchemata(self):\n         from plone.autoform.base import AutoFields\n+\n         autofields = AutoFields()\n         autofields.request = {}\n         autofields.updateFieldsFromSchemata()\ndiff --git a/plone/autoform/tests/test_directives.py b/plone/autoform/tests/test_directives.py\nindex d540c61..d7b77b3 100644\n--- a/plone/autoform/tests/test_directives.py\n+++ b/plone/autoform/tests/test_directives.py\n@@ -18,62 +18,75 @@ class DummyWidget:\n \n \n class TestSchemaDirectives(unittest.TestCase):\n-\n     layer = AUTOFORM_INTEGRATION_TESTING\n \n     def test_schema_directives_store_tagged_values(self):\n-\n         class IDummy(model.Schema):\n-\n-            form.omitted(\'foo\', \'bar\')\n-            form.omitted(model.Schema, \'qux\')\n-            form.no_omit(model.Schema, \'bar\')\n-            form.widget(foo=\'some.dummy.Widget\', baz=\'other.Widget\')\n-            form.mode(bar=\'hidden\')\n-            form.mode(model.Schema, bar=\'input\')\n-            form.order_before(baz=\'title\')\n-            form.order_after(qux=\'title\')\n-            form.read_permission(foo=\'zope2.View\')\n-            form.write_permission(foo=\'cmf.ModifyPortalContent\')\n-\n-            foo = zope.schema.TextLine(title=\'Foo\')\n-            bar = zope.schema.TextLine(title=\'Bar\')\n-            baz = zope.schema.TextLine(title=\'Baz\')\n-            qux = zope.schema.TextLine(title=\'Qux\')\n+            form.omitted("foo", "bar")\n+            form.omitted(model.Schema, "qux")\n+            form.no_omit(model.Schema, "bar")\n+            form.widget(foo="some.dummy.Widget", baz="other.Widget")\n+            form.mode(bar="hidden")\n+            form.mode(model.Schema, bar="input")\n+            form.order_before(baz="title")\n+            form.order_after(qux="title")\n+            form.read_permission(foo="zope2.View")\n+            form.write_permission(foo="cmf.ModifyPortalContent")\n+\n+            foo = zope.schema.TextLine(title="Foo")\n+            bar = zope.schema.TextLine(title="Bar")\n+            baz = zope.schema.TextLine(title="Baz")\n+            qux = zope.schema.TextLine(title="Qux")\n \n         model.finalizeSchemas(IDummy)\n \n-        self.assertEqual({\'foo\': \'some.dummy.Widget\',\n-                          \'baz\': \'other.Widget\'},\n-                         IDummy.queryTaggedValue(WIDGETS_KEY))\n-        self.assertEqual([(Interface, \'foo\', \'true\'),\n-                          (Interface, \'bar\', \'true\'),\n-                          (model.Schema, \'qux\', \'true\'),\n-                          (model.Schema, \'bar\', \'false\')],\n-                         IDummy.queryTaggedValue(OMITTED_KEY))\n-        self.assertEqual([(Interface, \'bar\', \'hidden\'),\n-                          (model.Schema, \'bar\', \'input\')],\n-                         IDummy.queryTaggedValue(MODES_KEY))\n-        self.assertEqual([(\'baz\', \'before\', \'title\',),\n-                          (\'qux\', \'after\', \'title\')],\n-                         IDummy.queryTaggedValue(ORDER_KEY))\n-        self.assertEqual({\'foo\': \'zope2.View\'},\n-                         IDummy.queryTaggedValue(READ_PERMISSIONS_KEY))\n-        self.assertEqual({\'foo\': \'cmf.ModifyPortalContent\'},\n-                         IDummy.queryTaggedValue(WRITE_PERMISSIONS_KEY))\n+        self.assertEqual(\n+            {"foo": "some.dummy.Widget", "baz": "other.Widget"},\n+            IDummy.queryTaggedValue(WIDGETS_KEY),\n+        )\n+        self.assertEqual(\n+            [\n+                (Interface, "foo", "true"),\n+                (Interface, "bar", "true"),\n+                (model.Schema, "qux", "true"),\n+                (model.Schema, "bar", "false"),\n+            ],\n+            IDummy.queryTaggedValue(OMITTED_KEY),\n+        )\n+        self.assertEqual(\n+            [(Interface, "bar", "hidden"), (model.Schema, "bar", "input")],\n+            IDummy.queryTaggedValue(MODES_KEY),\n+        )\n+        self.assertEqual(\n+            [\n+                (\n+                    "baz",\n+                    "before",\n+                    "title",\n+                ),\n+                ("qux", "after", "title"),\n+            ],\n+            IDummy.queryTaggedValue(ORDER_KEY),\n+        )\n+        self.assertEqual(\n+            {"foo": "zope2.View"}, IDummy.queryTaggedValue(READ_PERMISSIONS_KEY)\n+        )\n+        self.assertEqual(\n+            {"foo": "cmf.ModifyPortalContent"},\n+            IDummy.queryTaggedValue(WRITE_PERMISSIONS_KEY),\n+        )\n \n     def test_widget_supports_instances_and_strings(self):\n-\n         class IDummy(model.Schema):\n             form.widget(foo=DummyWidget)\n \n-            foo = zope.schema.TextLine(title=\'Foo\')\n-            bar = zope.schema.TextLine(title=\'Bar\')\n-            baz = zope.schema.TextLine(title=\'Baz\')\n+            foo = zope.schema.TextLine(title="Foo")\n+            bar = zope.schema.TextLine(title="Bar")\n+            baz = zope.schema.TextLine(title="Baz")\n \n         self.assertEqual(\n-            {\'foo\': \'plone.autoform.tests.test_directives.DummyWidget\'},\n-            IDummy.queryTaggedValue(WIDGETS_KEY)\n+            {"foo": "plone.autoform.tests.test_directives.DummyWidget"},\n+            IDummy.queryTaggedValue(WIDGETS_KEY),\n         )\n \n     def test_widget_parameterized(self):\n@@ -83,18 +96,17 @@ def test_widget_parameterized(self):\n \n         @implementer(IWidget)\n         class DummyWidget:\n-\n             def __init__(self, request):\n                 pass\n \n         class IDummy(model.Schema):\n-            form.widget(\'foo\', DummyWidget, foo=\'bar\')\n-            foo = zope.schema.TextLine(title=\'Foo\')\n+            form.widget("foo", DummyWidget, foo="bar")\n+            foo = zope.schema.TextLine(title="Foo")\n \n         tv = IDummy.queryTaggedValue(WIDGETS_KEY)\n-        self.assertTrue(isinstance(tv[\'foo\'], ParameterizedWidget))\n-        self.assertTrue(tv[\'foo\'].widget_factory is DummyWidget)\n-        self.assertEqual(\'bar\', tv[\'foo\'].params[\'foo\'])\n+        self.assertTrue(isinstance(tv["foo"], ParameterizedWidget))\n+        self.assertTrue(tv["foo"].widget_factory is DummyWidget)\n+        self.assertEqual("bar", tv["foo"].params["foo"])\n \n     def test_widget_parameterized_default_widget_factory(self):\n         from plone.autoform.widgets import ParameterizedWidget\n@@ -103,107 +115,115 @@ def test_widget_parameterized_default_widget_factory(self):\n \n         @implementer(IWidget)\n         class DummyWidget:\n-\n             def __init__(self, request):\n                 pass\n \n         class IDummy(model.Schema):\n-            form.widget(\'foo\', foo=\'bar\')\n-            foo = zope.schema.TextLine(title=\'Foo\')\n+            form.widget("foo", foo="bar")\n+            foo = zope.schema.TextLine(title="Foo")\n \n         tv = IDummy.queryTaggedValue(WIDGETS_KEY)\n-        self.assertTrue(isinstance(tv[\'foo\'], ParameterizedWidget))\n-        self.assertTrue(tv[\'foo\'].widget_factory is None)\n-        self.assertEqual(\'bar\', tv[\'foo\'].params[\'foo\'])\n+        self.assertTrue(isinstance(tv["foo"], ParameterizedWidget))\n+        self.assertTrue(tv["foo"].widget_factory is None)\n+        self.assertEqual("bar", tv["foo"].params["foo"])\n \n     def test_widget_parameterized_wrong_type(self):\n         try:\n+\n             class IDummy(model.Schema):\n-                form.widget(\'foo\', object())\n+                form.widget("foo", object())\n+\n         except TypeError:\n             pass\n         else:\n-            self.fail(\'Expected TypeError\')\n+            self.fail("Expected TypeError")\n \n     def test_multiple_invocations(self):\n-\n         class IDummy(model.Schema):\n+            form.omitted("foo")\n+            form.omitted("bar")\n+            form.widget(foo="some.dummy.Widget")\n+            form.widget(baz="other.Widget")\n+            form.mode(bar="hidden")\n+            form.mode(foo="display")\n+            form.order_before(baz="title")\n+            form.order_after(baz="qux")\n+            form.order_after(qux="bar")\n+            form.order_before(foo="body")\n+            form.read_permission(foo="zope2.View", bar="zope2.View")\n+            form.read_permission(baz="random.Permission")\n+            form.write_permission(foo="cmf.ModifyPortalContent")\n+            form.write_permission(baz="another.Permission")\n+\n+            foo = zope.schema.TextLine(title="Foo")\n+            bar = zope.schema.TextLine(title="Bar")\n+            baz = zope.schema.TextLine(title="Baz")\n+            qux = zope.schema.TextLine(title="Qux")\n \n-            form.omitted(\'foo\')\n-            form.omitted(\'bar\')\n-            form.widget(foo=\'some.dummy.Widget\')\n-            form.widget(baz=\'other.Widget\')\n-            form.mode(bar=\'hidden\')\n-            form.mode(foo=\'display\')\n-            form.order_before(baz=\'title\')\n-            form.order_after(baz=\'qux\')\n-            form.order_after(qux=\'bar\')\n-            form.order_before(foo=\'body\')\n-            form.read_permission(foo=\'zope2.View\', bar=\'zope2.View\')\n-            form.read_permission(baz=\'random.Permission\')\n-            form.write_permission(foo=\'cmf.ModifyPortalContent\')\n-            form.write_permission(baz=\'another.Permission\')\n-\n-            foo = zope.schema.TextLine(title=\'Foo\')\n-            bar = zope.schema.TextLine(title=\'Bar\')\n-            baz = zope.schema.TextLine(title=\'Baz\')\n-            qux = zope.schema.TextLine(title=\'Qux\')\n-\n-        self.assertEqual({\'foo\': \'some.dummy.Widget\',\n-                          \'baz\': \'other.Widget\'},\n-                         IDummy.queryTaggedValue(WIDGETS_KEY))\n-        self.assertEqual([(Interface, \'foo\', \'true\'),\n-                          (Interface, \'bar\', \'true\')],\n-                         IDummy.queryTaggedValue(OMITTED_KEY))\n-        self.assertEqual([(Interface, \'bar\', \'hidden\'),\n-                          (Interface, \'foo\', \'display\')],\n-                         IDummy.queryTaggedValue(MODES_KEY))\n-        self.assertEqual([(\'baz\', \'before\', \'title\'),\n-                          (\'baz\', \'after\', \'qux\'),\n-                          (\'qux\', \'after\', \'bar\'),\n-                          (\'foo\', \'before\', \'body\'), ],\n-                         IDummy.queryTaggedValue(ORDER_KEY))\n         self.assertEqual(\n-            {\'foo\': \'zope2.View\',\n-             \'bar\': \'zope2.View\',\n-             \'baz\': \'random.Permission\'},\n-            IDummy.queryTaggedValue(READ_PERMISSIONS_KEY)\n+            {"foo": "some.dummy.Widget", "baz": "other.Widget"},\n+            IDummy.queryTaggedValue(WIDGETS_KEY),\n+        )\n+        self.assertEqual(\n+            [(Interface, "foo", "true"), (Interface, "bar", "true")],\n+            IDummy.queryTaggedValue(OMITTED_KEY),\n+        )\n+        self.assertEqual(\n+            [(Interface, "bar", "hidden"), (Interface, "foo", "display")],\n+            IDummy.queryTaggedValue(MODES_KEY),\n+        )\n+        self.assertEqual(\n+            [\n+                ("baz", "before", "title"),\n+                ("baz", "after", "qux"),\n+                ("qux", "after", "bar"),\n+                ("foo", "before", "body"),\n+            ],\n+            IDummy.queryTaggedValue(ORDER_KEY),\n         )\n         self.assertEqual(\n-            {\'foo\': \'cmf.ModifyPortalContent\', \'baz\': \'another.Permission\'},\n-            IDummy.queryTaggedValue(WRITE_PERMISSIONS_KEY)\n+            {"foo": "zope2.View", "bar": "zope2.View", "baz": "random.Permission"},\n+            IDummy.queryTaggedValue(READ_PERMISSIONS_KEY),\n+        )\n+        self.assertEqual(\n+            {"foo": "cmf.ModifyPortalContent", "baz": "another.Permission"},\n+            IDummy.queryTaggedValue(WRITE_PERMISSIONS_KEY),\n         )\n \n     def test_misspelled_field(self):\n-\n         try:\n+\n             class IBar(model.Schema):\n-                form.order_before(ber=\'*\')\n+                form.order_before(ber="*")\n                 bar = zope.schema.TextLine()\n+\n         except ValueError:\n             pass\n         else:\n-            self.fail(\'Did not raise ValueError\')\n+            self.fail("Did not raise ValueError")\n \n         try:\n+\n             class IBaz(model.Schema):\n-                form.omitted(\'buz\')\n+                form.omitted("buz")\n                 baz = zope.schema.TextLine()\n+\n         except ValueError:\n             pass\n         else:\n-            self.fail(\'Did not raise ValueError\')\n+            self.fail("Did not raise ValueError")\n \n     def test_derived_class_fields(self):\n-\n         class IFoo(model.Schema):\n             foo = zope.schema.TextLine()\n \n         class IBar(IFoo):\n-            form.order_after(foo=\'bar\')\n+            form.order_after(foo="bar")\n             bar = zope.schema.TextLine()\n \n         self.assertEqual(\n-            [(\'foo\', \'after\', \'bar\'), ],\n-            IBar.queryTaggedValue(ORDER_KEY)\n+            [\n+                ("foo", "after", "bar"),\n+            ],\n+            IBar.queryTaggedValue(ORDER_KEY),\n         )\ndiff --git a/plone/autoform/tests/test_doctests.py b/plone/autoform/tests/test_doctests.py\nindex 022ba11..f731a78 100644\n--- a/plone/autoform/tests/test_doctests.py\n+++ b/plone/autoform/tests/test_doctests.py\n@@ -9,10 +9,10 @@\n \n \n test_files = [\n-    \'../autoform.rst\',\n-    \'subform.txt\',\n-    \'../view.txt\',\n-    \'../supermodel.txt\',\n+    "../autoform.rst",\n+    "subform.txt",\n+    "../view.txt",\n+    "../supermodel.txt",\n ]\n \n \ndiff --git a/plone/autoform/tests/test_supermodel_handler.py b/plone/autoform/tests/test_supermodel_handler.py\nindex 5c716a4..1db3c92 100644\n--- a/plone/autoform/tests/test_supermodel_handler.py\n+++ b/plone/autoform/tests/test_supermodel_handler.py\n@@ -23,108 +23,103 @@\n \n @implementer(IWidget)\n class DummyWidget:\n-\n     def __init__(self, request):\n         pass\n \n \n class TestFormSchema(unittest.TestCase):\n-\n     layer = AUTOFORM_INTEGRATION_TESTING\n \n-    namespace = \'http://namespaces.plone.org/supermodel/form\'\n+    namespace = "http://namespaces.plone.org/supermodel/form"\n \n     def test_read(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n         field_node.set(\n-            ns(\'widget\', self.namespace),\n-            \'z3c.form.browser.password.PasswordFieldWidget\'\n+            ns("widget", self.namespace),\n+            "z3c.form.browser.password.PasswordFieldWidget",\n         )\n-        field_node.set(ns(\'mode\', self.namespace), \'hidden\')\n-        field_node.set(ns(\'omitted\', self.namespace), \'true\')\n-        field_node.set(ns(\'before\', self.namespace), \'somefield\')\n+        field_node.set(ns("mode", self.namespace), "hidden")\n+        field_node.set(ns("omitted", self.namespace), "true")\n+        field_node.set(ns("before", self.namespace), "somefield")\n         field_node.set(\n-            ns(\'validator\', self.namespace),\n-            \'plone.autoform.tests.test_utils.TestValidator\'\n+            ns("validator", self.namespace),\n+            "plone.autoform.tests.test_utils.TestValidator",\n         )\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=\'dummy\')\n+            dummy = zope.schema.TextLine(title="dummy")\n \n         handler = FormSchema()\n-        handler.read(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.read(field_node, IDummy, IDummy["dummy"])\n \n         self.assertEqual(\n-            {\'dummy\': \'z3c.form.browser.password.PasswordFieldWidget\'},\n-            IDummy.getTaggedValue(WIDGETS_KEY)\n+            {"dummy": "z3c.form.browser.password.PasswordFieldWidget"},\n+            IDummy.getTaggedValue(WIDGETS_KEY),\n         )\n         self.assertEqual(\n-            [(Interface, \'dummy\', \'true\')],\n-            IDummy.getTaggedValue(OMITTED_KEY)\n+            [(Interface, "dummy", "true")], IDummy.getTaggedValue(OMITTED_KEY)\n         )\n         self.assertEqual(\n-            [(Interface, \'dummy\', \'hidden\')],\n-            IDummy.getTaggedValue(MODES_KEY)\n+            [(Interface, "dummy", "hidden")], IDummy.getTaggedValue(MODES_KEY)\n         )\n         self.assertEqual(\n-            [(\'dummy\', \'before\', \'somefield\',)],\n-            IDummy.getTaggedValue(ORDER_KEY)\n+            [("dummy", "before", "somefield")],\n+            IDummy.getTaggedValue(ORDER_KEY),\n         )\n         validator = getMultiAdapter(\n-            (None, None, None, IDummy[\'dummy\'], None),\n-            IValidator\n+            (None, None, None, IDummy["dummy"], None), IValidator\n         )\n         from plone.autoform.tests.test_utils import TestValidator\n+\n         assert isinstance(validator, TestValidator)\n \n     def test_read_multiple(self):\n-        field_node1 = etree.Element(\'field\')\n+        field_node1 = etree.Element("field")\n         field_node1.set(\n-            ns(\'widget\', self.namespace),\n-            \'z3c.form.browser.password.PasswordFieldWidget\'\n+            ns("widget", self.namespace),\n+            "z3c.form.browser.password.PasswordFieldWidget",\n         )\n-        field_node1.set(ns(\'mode\', self.namespace), \'hidden\')\n-        field_node1.set(ns(\'omitted\', self.namespace), \'true\')\n-        field_node1.set(ns(\'before\', self.namespace), \'somefield\')\n+        field_node1.set(ns("mode", self.namespace), "hidden")\n+        field_node1.set(ns("omitted", self.namespace), "true")\n+        field_node1.set(ns("before", self.namespace), "somefield")\n \n-        field_node2 = etree.Element(\'field\')\n-        field_node2.set(ns(\'mode\', self.namespace), \'display\')\n-        field_node2.set(ns(\'omitted\', self.namespace), \'yes\')\n+        field_node2 = etree.Element("field")\n+        field_node2.set(ns("mode", self.namespace), "display")\n+        field_node2.set(ns("omitted", self.namespace), "yes")\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.TextLine(title=\'dummy1\')\n-            dummy2 = zope.schema.TextLine(title=\'dummy2\')\n+            dummy1 = zope.schema.TextLine(title="dummy1")\n+            dummy2 = zope.schema.TextLine(title="dummy2")\n \n         handler = FormSchema()\n-        handler.read(field_node1, IDummy, IDummy[\'dummy1\'])\n-        handler.read(field_node2, IDummy, IDummy[\'dummy2\'])\n+        handler.read(field_node1, IDummy, IDummy["dummy1"])\n+        handler.read(field_node2, IDummy, IDummy["dummy2"])\n \n         self.assertEqual(\n-            {\'dummy1\': \'z3c.form.browser.password.PasswordFieldWidget\'},\n-            IDummy.getTaggedValue(WIDGETS_KEY)\n+            {"dummy1": "z3c.form.browser.password.PasswordFieldWidget"},\n+            IDummy.getTaggedValue(WIDGETS_KEY),\n         )\n         self.assertEqual(\n-            [(Interface, \'dummy1\', \'true\'), (Interface, \'dummy2\', \'yes\')],\n-            IDummy.getTaggedValue(OMITTED_KEY)\n+            [(Interface, "dummy1", "true"), (Interface, "dummy2", "yes")],\n+            IDummy.getTaggedValue(OMITTED_KEY),\n         )\n         self.assertEqual(\n-            [(Interface, \'dummy1\', \'hidden\'),\n-             (Interface, \'dummy2\', \'display\')],\n-            IDummy.getTaggedValue(MODES_KEY)\n+            [(Interface, "dummy1", "hidden"), (Interface, "dummy2", "display")],\n+            IDummy.getTaggedValue(MODES_KEY),\n         )\n         self.assertEqual(\n-            [(\'dummy1\', \'before\', \'somefield\',)],\n-            IDummy.getTaggedValue(ORDER_KEY)\n+            [("dummy1", "before", "somefield")],\n+            IDummy.getTaggedValue(ORDER_KEY),\n         )\n \n     def test_read_no_data(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=\'dummy1\')\n+            dummy = zope.schema.TextLine(title="dummy1")\n \n         handler = FormSchema()\n-        handler.read(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.read(field_node, IDummy, IDummy["dummy"])\n \n         self.assertEqual(None, IDummy.queryTaggedValue(WIDGETS_KEY))\n         self.assertEqual(None, IDummy.queryTaggedValue(OMITTED_KEY))\n@@ -132,379 +127,352 @@ class IDummy(Interface):\n         self.assertEqual(None, IDummy.queryTaggedValue(ORDER_KEY))\n \n     def test_read_values_with_interfaces(self):\n-        field_node1 = etree.Element(\'field\')\n-        field_node1.set(\n-            ns(\'mode\', self.namespace),\n-            \'z3c.form.interfaces.IForm:hidden\'\n-        )\n-        field_node1.set(\n-            ns(\'omitted\', self.namespace),\n-            \'z3c.form.interfaces.IForm:true\'\n-        )\n+        field_node1 = etree.Element("field")\n+        field_node1.set(ns("mode", self.namespace), "z3c.form.interfaces.IForm:hidden")\n+        field_node1.set(ns("omitted", self.namespace), "z3c.form.interfaces.IForm:true")\n \n-        field_node2 = etree.Element(\'field\')\n+        field_node2 = etree.Element("field")\n         field_node2.set(\n-            ns(\'mode\', self.namespace),\n-            \'z3c.form.interfaces.IForm:hidden \'\n-            \'z3c.form.interfaces.IEditForm:display\'\n+            ns("mode", self.namespace),\n+            "z3c.form.interfaces.IForm:hidden " "z3c.form.interfaces.IEditForm:display",\n         )\n         field_node2.set(\n-            ns(\'omitted\', self.namespace),\n-            \'z3c.form.interfaces.IForm:true \'\n-            \'z3c.form.interfaces.IEditForm:false\'\n+            ns("omitted", self.namespace),\n+            "z3c.form.interfaces.IForm:true " "z3c.form.interfaces.IEditForm:false",\n         )\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.TextLine(title=\'dummy1\')\n-            dummy2 = zope.schema.TextLine(title=\'dummy2\')\n+            dummy1 = zope.schema.TextLine(title="dummy1")\n+            dummy2 = zope.schema.TextLine(title="dummy2")\n \n         handler = FormSchema()\n-        handler.read(field_node1, IDummy, IDummy[\'dummy1\'])\n-        handler.read(field_node2, IDummy, IDummy[\'dummy2\'])\n+        handler.read(field_node1, IDummy, IDummy["dummy1"])\n+        handler.read(field_node2, IDummy, IDummy["dummy2"])\n \n         expected_modes = [\n-            (IForm, \'dummy1\', \'hidden\'),\n-            (IForm, \'dummy2\', \'hidden\'),\n-            (IEditForm, \'dummy2\', \'display\')\n+            (IForm, "dummy1", "hidden"),\n+            (IForm, "dummy2", "hidden"),\n+            (IEditForm, "dummy2", "display"),\n         ]\n-        self.assertEqual(\n-            expected_modes,\n-            IDummy.queryTaggedValue(MODES_KEY)\n-        )\n+        self.assertEqual(expected_modes, IDummy.queryTaggedValue(MODES_KEY))\n         expected_omitted = [\n-            (IForm, \'dummy1\', \'true\'),\n-            (IForm, \'dummy2\', \'true\'),\n-            (IEditForm, \'dummy2\', \'false\')\n+            (IForm, "dummy1", "true"),\n+            (IForm, "dummy2", "true"),\n+            (IEditForm, "dummy2", "false"),\n         ]\n-        self.assertEqual(\n-            expected_omitted,\n-            IDummy.queryTaggedValue(OMITTED_KEY)\n-        )\n+        self.assertEqual(expected_omitted, IDummy.queryTaggedValue(OMITTED_KEY))\n \n     def test_read_parameterized_widget(self):\n         from plone.autoform.widgets import ParameterizedWidget\n \n-        param_node = etree.Element(\'klass\')\n-        param_node.text = \'custom\'\n-        widget_node = etree.Element(ns(\'widget\', self.namespace))\n+        param_node = etree.Element("klass")\n+        param_node.text = "custom"\n+        widget_node = etree.Element(ns("widget", self.namespace))\n         widget_node.set(\n-            \'type\',\n-            \'plone.autoform.tests.test_supermodel_handler.DummyWidget\'\n+            "type", "plone.autoform.tests.test_supermodel_handler.DummyWidget"\n         )\n         widget_node.append(param_node)\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n         field_node.append(widget_node)\n \n         class IDummy(Interface):\n-            foo = zope.schema.TextLine(title=\'foo\')\n+            foo = zope.schema.TextLine(title="foo")\n \n         handler = FormSchema()\n-        handler.read(field_node, IDummy, IDummy[\'foo\'])\n+        handler.read(field_node, IDummy, IDummy["foo"])\n \n         widgets = IDummy.queryTaggedValue(WIDGETS_KEY)\n-        self.assertTrue(isinstance(widgets[\'foo\'], ParameterizedWidget))\n-        self.assertTrue(widgets[\'foo\'].widget_factory is DummyWidget)\n-        self.assertEqual(widgets[\'foo\'].params, {\'klass\': \'custom\'})\n+        self.assertTrue(isinstance(widgets["foo"], ParameterizedWidget))\n+        self.assertTrue(widgets["foo"].widget_factory is DummyWidget)\n+        self.assertEqual(widgets["foo"].params, {"klass": "custom"})\n \n     def test_read_parameterized_widget_default(self):\n         from plone.autoform.widgets import ParameterizedWidget\n \n-        param_node = etree.Element(\'klass\')\n-        param_node.text = \'custom\'\n-        param2_node = etree.Element(\'placeholder\')\n-        param2_node.text = \'help\'\n-        widget_node = etree.Element(ns(\'widget\', self.namespace))\n+        param_node = etree.Element("klass")\n+        param_node.text = "custom"\n+        param2_node = etree.Element("placeholder")\n+        param2_node.text = "help"\n+        widget_node = etree.Element(ns("widget", self.namespace))\n         widget_node.append(param_node)\n         widget_node.append(param2_node)\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n         field_node.append(widget_node)\n \n         class IDummy(Interface):\n-            foo = zope.schema.TextLine(title=\'foo\')\n+            foo = zope.schema.TextLine(title="foo")\n \n         handler = FormSchema()\n-        handler.read(field_node, IDummy, IDummy[\'foo\'])\n+        handler.read(field_node, IDummy, IDummy["foo"])\n \n         widgets = IDummy.queryTaggedValue(WIDGETS_KEY)\n-        self.assertTrue(isinstance(widgets[\'foo\'], ParameterizedWidget))\n-        self.assertTrue(widgets[\'foo\'].widget_factory is None)\n-        self.assertIn(\'klass\', widgets[\'foo\'].params)\n-        self.assertEqual(widgets[\'foo\'].params[\'klass\'], \'custom\')\n-        self.assertIn(\'placeholder\', widgets[\'foo\'].params)\n-        self.assertEqual(widgets[\'foo\'].params[\'placeholder\'], \'help\')\n+        self.assertTrue(isinstance(widgets["foo"], ParameterizedWidget))\n+        self.assertTrue(widgets["foo"].widget_factory is None)\n+        self.assertIn("klass", widgets["foo"].params)\n+        self.assertEqual(widgets["foo"].params["klass"], "custom")\n+        self.assertIn("placeholder", widgets["foo"].params)\n+        self.assertEqual(widgets["foo"].params["placeholder"], "help")\n \n     def test_write(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=\'dummy1\')\n+            dummy = zope.schema.TextLine(title="dummy1")\n \n-        IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy\': \'SomeWidget\'})\n-        IDummy.setTaggedValue(OMITTED_KEY, [(Interface, \'dummy\', \'true\')])\n-        IDummy.setTaggedValue(MODES_KEY, [(Interface, \'dummy\', \'hidden\')])\n-        IDummy.setTaggedValue(ORDER_KEY, [(\'dummy\', \'before\', \'somefield\',)])\n+        IDummy.setTaggedValue(WIDGETS_KEY, {"dummy": "SomeWidget"})\n+        IDummy.setTaggedValue(OMITTED_KEY, [(Interface, "dummy", "true")])\n+        IDummy.setTaggedValue(MODES_KEY, [(Interface, "dummy", "hidden")])\n+        IDummy.setTaggedValue(\n+            ORDER_KEY,\n+            [("dummy", "before", "somefield")],\n+        )\n \n         handler = FormSchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n-        widget_node = field_node.find(ns(\'widget\', self.namespace))\n-        self.assertEqual(\'SomeWidget\', widget_node.get(\'type\'))\n-        self.assertEqual(\'true\', field_node.get(ns(\'omitted\', self.namespace)))\n-        self.assertEqual(\'hidden\', field_node.get(ns(\'mode\', self.namespace)))\n-        self.assertEqual(\n-            \'somefield\',\n-            field_node.get(ns(\'before\', self.namespace))\n-        )\n+        widget_node = field_node.find(ns("widget", self.namespace))\n+        self.assertEqual("SomeWidget", widget_node.get("type"))\n+        self.assertEqual("true", field_node.get(ns("omitted", self.namespace)))\n+        self.assertEqual("hidden", field_node.get(ns("mode", self.namespace)))\n+        self.assertEqual("somefield", field_node.get(ns("before", self.namespace)))\n \n     def test_write_partial(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=\'dummy1\')\n+            dummy = zope.schema.TextLine(title="dummy1")\n \n-        IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy\': \'SomeWidget\'})\n-        IDummy.setTaggedValue(OMITTED_KEY, [(Interface, \'dummy2\', \'true\')])\n+        IDummy.setTaggedValue(WIDGETS_KEY, {"dummy": "SomeWidget"})\n+        IDummy.setTaggedValue(OMITTED_KEY, [(Interface, "dummy2", "true")])\n         IDummy.setTaggedValue(\n             MODES_KEY,\n-            [(Interface, \'dummy\', \'display\'), (Interface, \'dummy2\', \'hidden\')]\n+            [(Interface, "dummy", "display"), (Interface, "dummy2", "hidden")],\n         )\n         IDummy.setTaggedValue(ORDER_KEY, [])\n \n         handler = FormSchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n-        widget_node = field_node.find(ns(\'widget\', self.namespace))\n-        self.assertEqual(\'SomeWidget\', widget_node.get(\'type\'))\n-        self.assertEqual(None, field_node.get(ns(\'omitted\', self.namespace)))\n-        self.assertEqual(\'display\', field_node.get(ns(\'mode\', self.namespace)))\n-        self.assertEqual(None, field_node.get(ns(\'before\', self.namespace)))\n+        widget_node = field_node.find(ns("widget", self.namespace))\n+        self.assertEqual("SomeWidget", widget_node.get("type"))\n+        self.assertEqual(None, field_node.get(ns("omitted", self.namespace)))\n+        self.assertEqual("display", field_node.get(ns("mode", self.namespace)))\n+        self.assertEqual(None, field_node.get(ns("before", self.namespace)))\n \n     def test_write_no_data(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=\'dummy1\')\n+            dummy = zope.schema.TextLine(title="dummy1")\n \n         handler = FormSchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n-        self.assertEqual(None, field_node.find(ns(\'widget\', self.namespace)))\n-        self.assertEqual(None, field_node.get(ns(\'omitted\', self.namespace)))\n-        self.assertEqual(None, field_node.get(ns(\'mode\', self.namespace)))\n-        self.assertEqual(None, field_node.get(ns(\'before\', self.namespace)))\n+        self.assertEqual(None, field_node.find(ns("widget", self.namespace)))\n+        self.assertEqual(None, field_node.get(ns("omitted", self.namespace)))\n+        self.assertEqual(None, field_node.get(ns("mode", self.namespace)))\n+        self.assertEqual(None, field_node.get(ns("before", self.namespace)))\n \n     def test_write_values_with_interfaces(self):\n-        field_node1 = etree.Element(\'field\')\n-        field_node2 = etree.Element(\'field\')\n+        field_node1 = etree.Element("field")\n+        field_node2 = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.TextLine(title=\'dummy1\')\n-            dummy2 = zope.schema.TextLine(title=\'dummy2\')\n+            dummy1 = zope.schema.TextLine(title="dummy1")\n+            dummy2 = zope.schema.TextLine(title="dummy2")\n \n         modes_values = [\n-            (IForm, \'dummy1\', \'hidden\'),\n-            (IForm, \'dummy2\', \'hidden\'),\n-            (IEditForm, \'dummy2\', \'display\')\n+            (IForm, "dummy1", "hidden"),\n+            (IForm, "dummy2", "hidden"),\n+            (IEditForm, "dummy2", "display"),\n         ]\n         IDummy.setTaggedValue(MODES_KEY, modes_values)\n         omitted_values = [\n-            (IForm, \'dummy1\', \'true\'),\n-            (IForm, \'dummy2\', \'true\'),\n-            (IEditForm, \'dummy2\', \'false\')\n+            (IForm, "dummy1", "true"),\n+            (IForm, "dummy2", "true"),\n+            (IEditForm, "dummy2", "false"),\n         ]\n         IDummy.setTaggedValue(OMITTED_KEY, omitted_values)\n \n         handler = FormSchema()\n-        handler.write(field_node1, IDummy, IDummy[\'dummy1\'])\n-        handler.write(field_node2, IDummy, IDummy[\'dummy2\'])\n+        handler.write(field_node1, IDummy, IDummy["dummy1"])\n+        handler.write(field_node2, IDummy, IDummy["dummy2"])\n \n         self.assertEqual(\n-            \'z3c.form.interfaces.IForm:hidden\',\n-            field_node1.get(ns(\'mode\', self.namespace))\n+            "z3c.form.interfaces.IForm:hidden",\n+            field_node1.get(ns("mode", self.namespace)),\n         )\n         self.assertEqual(\n-            \'z3c.form.interfaces.IForm:true\',\n-            field_node1.get(ns(\'omitted\', self.namespace))\n+            "z3c.form.interfaces.IForm:true",\n+            field_node1.get(ns("omitted", self.namespace)),\n         )\n \n         self.assertEqual(\n-            \'z3c.form.interfaces.IForm:hidden \'\n-            \'z3c.form.interfaces.IEditForm:display\',\n-            field_node2.get(ns(\'mode\', self.namespace))\n+            "z3c.form.interfaces.IForm:hidden " "z3c.form.interfaces.IEditForm:display",\n+            field_node2.get(ns("mode", self.namespace)),\n         )\n         self.assertEqual(\n-            \'z3c.form.interfaces.IForm:true \'\n-            \'z3c.form.interfaces.IEditForm:false\',\n-            field_node2.get(ns(\'omitted\', self.namespace))\n+            "z3c.form.interfaces.IForm:true " "z3c.form.interfaces.IEditForm:false",\n+            field_node2.get(ns("omitted", self.namespace)),\n         )\n \n     def test_write_parameterized_widget_string(self):\n         from plone.autoform.widgets import ParameterizedWidget\n-        pw = ParameterizedWidget(\'foo\')\n+\n+        pw = ParameterizedWidget("foo")\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.Text(title=\'dummy1\')\n-        IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy1\': pw})\n+            dummy1 = zope.schema.Text(title="dummy1")\n+\n+        IDummy.setTaggedValue(WIDGETS_KEY, {"dummy1": pw})\n \n-        fieldNode = etree.Element(\'field\')\n+        fieldNode = etree.Element("field")\n         handler = FormSchema()\n-        handler.write(fieldNode, IDummy, IDummy[\'dummy1\'])\n+        handler.write(fieldNode, IDummy, IDummy["dummy1"])\n \n         self.assertEqual(\n             etree.tostring(fieldNode),\n-            b\'<field><ns0:widget\'\n+            b"<field><ns0:widget"\n             b\' xmlns:ns0="http://namespaces.plone.org/supermodel/form"\'\n-            b\' type="foo"/></field>\'\n+            b\' type="foo"/></field>\',\n         )\n \n     def test_write_parameterized_widget_default(self):\n         from plone.autoform.widgets import ParameterizedWidget\n+\n         pw = ParameterizedWidget(None)\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.Text(title=\'dummy1\')\n-        IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy1\': pw})\n+            dummy1 = zope.schema.Text(title="dummy1")\n+\n+        IDummy.setTaggedValue(WIDGETS_KEY, {"dummy1": pw})\n \n-        fieldNode = etree.Element(\'field\')\n+        fieldNode = etree.Element("field")\n         handler = FormSchema()\n-        handler.write(fieldNode, IDummy, IDummy[\'dummy1\'])\n+        handler.write(fieldNode, IDummy, IDummy["dummy1"])\n \n-        self.assertEqual(\n-            etree.tostring(fieldNode),\n-            b\'<field/>\'\n-        )\n+        self.assertEqual(etree.tostring(fieldNode), b"<field/>")\n \n     def test_write_parameterized_widget_with_handler(self):\n         from plone.autoform.widgets import ParameterizedWidget\n-        pw = ParameterizedWidget(DummyWidget, klass=\'custom\')\n+\n+        pw = ParameterizedWidget(DummyWidget, klass="custom")\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.Text(title=\'dummy1\')\n-        IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy1\': pw})\n+            dummy1 = zope.schema.Text(title="dummy1")\n+\n+        IDummy.setTaggedValue(WIDGETS_KEY, {"dummy1": pw})\n \n-        fieldNode = etree.Element(\'field\')\n+        fieldNode = etree.Element("field")\n         handler = FormSchema()\n-        handler.write(fieldNode, IDummy, IDummy[\'dummy1\'])\n+        handler.write(fieldNode, IDummy, IDummy["dummy1"])\n \n         self.assertEqual(\n             etree.tostring(fieldNode),\n-            b\'<field><ns0:widget\'\n+            b"<field><ns0:widget"\n             b\' xmlns:ns0="http://namespaces.plone.org/supermodel/form"\'\n             b\' type="plone.autoform.tests.test_supermodel_handler.\'\n             b\'DummyWidget">\'\n-            b\'<klass>custom</klass>\'\n-            b\'</ns0:widget></field>\')\n+            b"<klass>custom</klass>"\n+            b"</ns0:widget></field>",\n+        )\n \n     def test_write_parameterized_widget_default_with_handler(self):\n         from plone.autoform.widgets import ParameterizedWidget\n-        pw = ParameterizedWidget(None, klass=\'custom\')\n+\n+        pw = ParameterizedWidget(None, klass="custom")\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.Text(title=\'dummy1\')\n-        IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy1\': pw})\n+            dummy1 = zope.schema.Text(title="dummy1")\n \n-        fieldNode = etree.Element(\'field\')\n+        IDummy.setTaggedValue(WIDGETS_KEY, {"dummy1": pw})\n+\n+        fieldNode = etree.Element("field")\n         handler = FormSchema()\n-        handler.write(fieldNode, IDummy, IDummy[\'dummy1\'])\n+        handler.write(fieldNode, IDummy, IDummy["dummy1"])\n \n         self.assertEqual(\n             etree.tostring(fieldNode),\n-            b\'<field><ns0:widget\'\n+            b"<field><ns0:widget"\n             b\' xmlns:ns0="http://namespaces.plone.org/supermodel/form">\'\n-            b\'<klass>custom</klass></ns0:widget></field>\')\n+            b"<klass>custom</klass></ns0:widget></field>",\n+        )\n \n \n class TestSecuritySchema(unittest.TestCase):\n-\n-    namespace = \'http://namespaces.plone.org/supermodel/security\'\n+    namespace = "http://namespaces.plone.org/supermodel/security"\n \n     def test_read(self):\n-        field_node = etree.Element(\'field\')\n-        field_node.set(ns(\'read-permission\', self.namespace), \'dummy.Read\')\n-        field_node.set(ns(\'write-permission\', self.namespace), \'dummy.Write\')\n+        field_node = etree.Element("field")\n+        field_node.set(ns("read-permission", self.namespace), "dummy.Read")\n+        field_node.set(ns("write-permission", self.namespace), "dummy.Write")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=\'dummy\')\n+            dummy = zope.schema.TextLine(title="dummy")\n \n         handler = SecuritySchema()\n-        handler.read(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.read(field_node, IDummy, IDummy["dummy"])\n \n         self.assertEqual(\n-            {\'dummy\': \'dummy.Read\'},\n-            IDummy.getTaggedValue(READ_PERMISSIONS_KEY)\n+            {"dummy": "dummy.Read"}, IDummy.getTaggedValue(READ_PERMISSIONS_KEY)\n         )\n         self.assertEqual(\n-            {\'dummy\': \'dummy.Write\'},\n-            IDummy.getTaggedValue(WRITE_PERMISSIONS_KEY)\n+            {"dummy": "dummy.Write"}, IDummy.getTaggedValue(WRITE_PERMISSIONS_KEY)\n         )\n \n     def test_read_no_permissions(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=\'dummy\')\n+            dummy = zope.schema.TextLine(title="dummy")\n \n         handler = SecuritySchema()\n-        handler.read(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.read(field_node, IDummy, IDummy["dummy"])\n \n         self.assertFalse(READ_PERMISSIONS_KEY in IDummy.getTaggedValueTags())\n         self.assertFalse(WRITE_PERMISSIONS_KEY in IDummy.getTaggedValueTags())\n \n     def test_write(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=\'dummy\')\n+            dummy = zope.schema.TextLine(title="dummy")\n \n-        IDummy.setTaggedValue(READ_PERMISSIONS_KEY, {\'dummy\': \'dummy.Read\'})\n-        IDummy.setTaggedValue(WRITE_PERMISSIONS_KEY, {\'dummy\': \'dummy.Write\'})\n+        IDummy.setTaggedValue(READ_PERMISSIONS_KEY, {"dummy": "dummy.Read"})\n+        IDummy.setTaggedValue(WRITE_PERMISSIONS_KEY, {"dummy": "dummy.Write"})\n \n         handler = SecuritySchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n         self.assertEqual(\n-            \'dummy.Read\',\n-            field_node.get(ns(\'read-permission\', self.namespace))\n+            "dummy.Read", field_node.get(ns("read-permission", self.namespace))\n         )\n         self.assertEqual(\n-            \'dummy.Write\',\n-            field_node.get(ns(\'write-permission\', self.namespace))\n+            "dummy.Write", field_node.get(ns("write-permission", self.namespace))\n         )\n \n     def test_write_no_permissions(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=\'dummy\')\n+            dummy = zope.schema.TextLine(title="dummy")\n \n-        IDummy.setTaggedValue(READ_PERMISSIONS_KEY, {\'dummy\': None})\n+        IDummy.setTaggedValue(READ_PERMISSIONS_KEY, {"dummy": None})\n \n         handler = SecuritySchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n-        self.assertEqual(\n-            None,\n-            field_node.get(ns(\'read-permission\', self.namespace))\n-        )\n-        self.assertEqual(\n-            None,\n-            field_node.get(ns(\'write-permission\', self.namespace))\n-        )\n+        self.assertEqual(None, field_node.get(ns("read-permission", self.namespace)))\n+        self.assertEqual(None, field_node.get(ns("write-permission", self.namespace)))\n \n     def test_write_no_metadata(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=\'dummy\')\n+            dummy = zope.schema.TextLine(title="dummy")\n \n         handler = SecuritySchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n-        self.assertEqual(\n-            None,\n-            field_node.get(ns(\'read-permission\', self.namespace))\n-        )\n-        self.assertEqual(\n-            None,\n-            field_node.get(ns(\'write-permission\', self.namespace))\n-        )\n+        self.assertEqual(None, field_node.get(ns("read-permission", self.namespace)))\n+        self.assertEqual(None, field_node.get(ns("write-permission", self.namespace)))\ndiff --git a/plone/autoform/tests/test_utils.py b/plone/autoform/tests/test_utils.py\nindex 2db5338..93dbd58 100644\n--- a/plone/autoform/tests/test_utils.py\n+++ b/plone/autoform/tests/test_utils.py\n@@ -16,19 +16,18 @@\n \n \n class TestValidator(SimpleFieldValidator):\n-\n     def validate(self, value):\n         super().validate(value)\n-        raise Invalid(\'Test\')\n+        raise Invalid("Test")\n \n \n class TestUtils(unittest.TestCase):\n-\n     layer = UNIT_TESTING\n \n     def setUp(self):\n         from zope.security.permission import Permission\n-        provideUtility(Permission(\'foo\', \'foo\', \'\'), name=\'foo\')\n+\n+        provideUtility(Permission("foo", "foo", ""), name="foo")\n \n         class DummySecurityManager:\n             checks = []\n@@ -51,11 +50,11 @@ def test_processFields_permissionChecks_no_prefix(self):\n         class schema(Interface):\n             title = zope.schema.TextLine()\n \n-        schema.setTaggedValue(WRITE_PERMISSIONS_KEY, {\'title\': \'foo\'})\n-        processFields(form, schema, prefix=\'\', permissionChecks=True)\n+        schema.setTaggedValue(WRITE_PERMISSIONS_KEY, {"title": "foo"})\n+        processFields(form, schema, prefix="", permissionChecks=True)\n \n-        self.assertEqual(\'foo\', self.secman.checks.pop())\n-        self.assertFalse(\'title\' in form.fields)\n+        self.assertEqual("foo", self.secman.checks.pop())\n+        self.assertFalse("title" in form.fields)\n \n     def test_processFields_permissionChecks_w_prefix(self):\n         form = Form(None, None)\n@@ -63,11 +62,12 @@ def test_processFields_permissionChecks_w_prefix(self):\n \n         class schema(Interface):\n             title = zope.schema.TextLine()\n-        schema.setTaggedValue(WRITE_PERMISSIONS_KEY, {\'title\': \'foo\'})\n-        processFields(form, schema, prefix=\'prefix\', permissionChecks=True)\n \n-        self.assertEqual(\'foo\', self.secman.checks.pop())\n-        self.assertFalse(\'prefix.title\' in form.fields)\n+        schema.setTaggedValue(WRITE_PERMISSIONS_KEY, {"title": "foo"})\n+        processFields(form, schema, prefix="prefix", permissionChecks=True)\n+\n+        self.assertEqual("foo", self.secman.checks.pop())\n+        self.assertFalse("prefix.title" in form.fields)\n \n     def test_processFields_fieldsets_as_form_groups(self):\n         form = Form(None, None)\n@@ -76,23 +76,20 @@ def test_processFields_fieldsets_as_form_groups(self):\n         class schema(Interface):\n             title = zope.schema.TextLine()\n \n-        fieldset = Fieldset(\'custom\', label=\'Custom\',\n-                            fields=[\'title\'])\n+        fieldset = Fieldset("custom", label="Custom", fields=["title"])\n         schema.setTaggedValue(FIELDSETS_KEY, [fieldset])\n \n         class subschema(schema):\n             subtitle = zope.schema.TextLine()\n \n-        fieldset = Fieldset(\'custom\', label=\'Custom\',\n-                            fields=[\'subtitle\'])\n+        fieldset = Fieldset("custom", label="Custom", fields=["subtitle"])\n         subschema.setTaggedValue(FIELDSETS_KEY, [fieldset])\n \n-        processFields(form, subschema,\n-                      prefix=\'prefix\', permissionChecks=True)\n+        processFields(form, subschema, prefix="prefix", permissionChecks=True)\n \n         self.assertEqual(len(form.groups), 1)\n         self.assertEqual(len(form.groups[0].fields), 2)\n-        self.assertEqual([g.__name__ for g in form.groups], [\'custom\'])\n+        self.assertEqual([g.__name__ for g in form.groups], ["custom"])\n \n     def test_fieldset_configuration(self):\n         """Test, if fieldsets can be orderd via fieldset configuration on a\n@@ -105,30 +102,30 @@ def test_fieldset_configuration(self):\n         class schema1(Interface):\n             title = zope.schema.TextLine()\n \n-        fs1 = Fieldset(\'fs1\', label=\'fs1\', fields=[\'title\'])\n+        fs1 = Fieldset("fs1", label="fs1", fields=["title"])\n         schema1.setTaggedValue(FIELDSETS_KEY, [fs1])\n \n         class schema2(Interface):\n             subtitle = zope.schema.TextLine()\n \n-        fs2 = Fieldset(\'fs2\', label=\'fs2\', fields=[\'subtitle\'])\n+        fs2 = Fieldset("fs2", label="fs2", fields=["subtitle"])\n         schema2.setTaggedValue(FIELDSETS_KEY, [fs2])\n \n         class schema3(Interface):\n             pass\n \n-        fs3 = Fieldset(\'fs1\', order=2)\n-        fs4 = Fieldset(\'fs2\', order=1)\n+        fs3 = Fieldset("fs1", order=2)\n+        fs4 = Fieldset("fs2", order=1)\n         schema3.setTaggedValue(FIELDSETS_KEY, [fs3, fs4])\n \n-        processFields(form, schema1, prefix=\'prefix\', permissionChecks=True)\n-        processFields(form, schema2, prefix=\'prefix\', permissionChecks=True)\n-        processFields(form, schema3, prefix=\'prefix\', permissionChecks=True)\n+        processFields(form, schema1, prefix="prefix", permissionChecks=True)\n+        processFields(form, schema2, prefix="prefix", permissionChecks=True)\n+        processFields(form, schema3, prefix="prefix", permissionChecks=True)\n \n         self.assertEqual(len(form.groups), 2)\n \n-        self.assertEqual(form.groups[0].__name__, \'fs1\')\n+        self.assertEqual(form.groups[0].__name__, "fs1")\n         self.assertEqual(form.groups[0].order, 2)\n \n-        self.assertEqual(form.groups[1].__name__, \'fs2\')\n+        self.assertEqual(form.groups[1].__name__, "fs2")\n         self.assertEqual(form.groups[1].order, 1)\ndiff --git a/plone/autoform/tests/test_widgets.py b/plone/autoform/tests/test_widgets.py\nindex f75396b..8d2396d 100644\n--- a/plone/autoform/tests/test_widgets.py\n+++ b/plone/autoform/tests/test_widgets.py\n@@ -4,7 +4,6 @@\n \n \n class TestParameterizedWidget(unittest.TestCase):\n-\n     layer = UNIT_TESTING\n \n     def test_widget_instantiated_with_parameters(self):\n@@ -16,7 +15,6 @@ def test_widget_instantiated_with_parameters(self):\n \n         @implementer(IWidget)\n         class DummyWidget:\n-\n             def __init__(self, request):\n                 self.request = request\n \n@@ -26,10 +24,10 @@ def DummyFieldWidget(field, request):\n \n         field = Field()\n         request = object()\n-        widget = ParameterizedWidget(DummyWidget, foo=\'bar\')(field, request)\n+        widget = ParameterizedWidget(DummyWidget, foo="bar")(field, request)\n \n         self.assertTrue(isinstance(widget, DummyWidget))\n-        self.assertEqual(\'bar\', widget.foo)\n+        self.assertEqual("bar", widget.foo)\n \n     def test_default_widget_instantiated(self):\n         from plone.autoform.widgets import ParameterizedWidget\n@@ -40,7 +38,6 @@ def test_default_widget_instantiated(self):\n         from zope.schema import Field\n \n         class DummyWidget:\n-\n             def __init__(self, request):\n                 self.request = request\n \n@@ -52,10 +49,10 @@ def DummyFieldWidget(field, request):\n \n         field = Field()\n         request = object()\n-        widget = ParameterizedWidget(foo=\'bar\')(field, request)\n+        widget = ParameterizedWidget(foo="bar")(field, request)\n \n         self.assertTrue(isinstance(widget, DummyWidget))\n-        self.assertEqual(\'bar\', widget.foo)\n+        self.assertEqual("bar", widget.foo)\n \n     def test_validates_for_field_widget(self):\n         from plone.autoform.widgets import ParameterizedWidget\n@@ -69,4 +66,4 @@ class NotAWidget:\n         except TypeError:\n             pass\n         else:\n-            self.fail(\'Expected TypeError\')\n+            self.fail("Expected TypeError")\ndiff --git a/plone/autoform/utils.py b/plone/autoform/utils.py\nindex 585f806..fb6a77e 100644\n--- a/plone/autoform/utils.py\n+++ b/plone/autoform/utils.py\n@@ -30,8 +30,7 @@\n \n \n def resolveDottedName(dottedName):\n-    """Resolve a dotted name to a real object\n-    """\n+    """Resolve a dotted name to a real object"""\n     global _dottedCache\n     if dottedName not in _dottedCache:\n         _dottedCache[dottedName] = resolve(dottedName)\n@@ -46,8 +45,7 @@ def mergedTaggedValuesForIRO(schema, name, iro):\n     interfaces actually provided by \'form\'.\n     """\n     # filter out settings irrelevant to this form\n-    threeples = [t for t in mergedTaggedValueList(schema, name)\n-                 if t[0] in iro]\n+    threeples = [t for t in mergedTaggedValueList(schema, name) if t[0] in iro]\n \n     # Sort by interface resolution order of the form interface,\n     # then by IRO of the interface the value came from\n@@ -55,6 +53,7 @@ def mergedTaggedValuesForIRO(schema, name, iro):\n     def by_iro(threeple):\n         interface = threeple[0]\n         return iro.index(interface)\n+\n     threeples.sort(key=by_iro)\n     d = {}\n     # Now iterate through in the reverse order -- the values assigned last win.\n@@ -70,9 +69,9 @@ def mergedTaggedValuesForForm(schema, name, form):\n \n # Some helper functions\n \n+\n def _process_prefixed_name(prefix, fieldName):\n-    """Give prefixed fieldname if applicable\n-    """\n+    """Give prefixed fieldname if applicable"""\n     if prefix:\n         return expandPrefix(prefix) + fieldName\n     else:\n@@ -80,28 +79,24 @@ def _process_prefixed_name(prefix, fieldName):\n \n \n def _bn(fieldInstance):\n-    """Base Name: Give base (non-prefixed) fieldname\n-    """\n+    """Base Name: Give base (non-prefixed) fieldname"""\n     prefix = fieldInstance.prefix\n     fieldName = fieldInstance.__name__\n     if prefix:\n-        return fieldName[len(prefix) + 1:]\n+        return fieldName[len(prefix) + 1 :]\n     else:\n         return fieldName\n \n \n def _process_widgets(form, widgets, modes, newFields):\n-    """Update the fields list with widgets\n-    """\n+    """Update the fields list with widgets"""\n \n     for fieldName in newFields:\n         fieldInstance = newFields[fieldName]\n         baseName = _bn(fieldInstance)\n \n         widgetName = widgets.get(baseName, None)\n-        widgetMode = modes.get(baseName, fieldInstance.mode) \\\n-            or form.mode \\\n-            or INPUT_MODE\n+        widgetMode = modes.get(baseName, fieldInstance.mode) or form.mode or INPUT_MODE\n \n         widgetFactory = None\n         if widgetName is not None:\n@@ -119,15 +114,8 @@ def _process_widgets(form, widgets, modes, newFields):\n             newFields[fieldName].mode = widgetMode\n \n \n-def _process_fieldsets(\n-    form,\n-    schema,\n-    groups,\n-    all_fields,\n-    prefix,\n-    default_group\n-):\n-    """ Keep track of which fields are in a fieldset, and, by elimination,\n+def _process_fieldsets(form, schema, groups, all_fields, prefix, default_group):\n+    """Keep track of which fields are in a fieldset, and, by elimination,\n     which ones are not\n     """\n     # { name => e.g. \'hidden\' }\n@@ -158,8 +146,11 @@ def _process_fieldsets(\n \n     for fieldset in fieldsets:\n         new_fields = all_fields.select(\n-            *[_process_prefixed_name(prefix, name) for name in fieldset.fields\n-              if _process_prefixed_name(prefix, name) in all_fields]\n+            *[\n+                _process_prefixed_name(prefix, name)\n+                for name in fieldset.fields\n+                if _process_prefixed_name(prefix, name) in all_fields\n+            ]\n         )\n \n         if fieldset.__name__ in groups:\n@@ -168,31 +159,30 @@ def _process_fieldsets(\n             group = groups[fieldset.__name__]\n             group.fields += new_fields\n             if (\n-                fieldset.label and\n-                group.label != fieldset.label and\n-                group.__name__ != fieldset.label  # defaults to name!\n+                fieldset.label\n+                and group.label != fieldset.label\n+                and group.__name__ != fieldset.label  # defaults to name!\n             ):\n                 group.label = fieldset.label\n-            if (\n-                fieldset.description and\n-                group.description != fieldset.description\n-            ):\n+            if fieldset.description and group.description != fieldset.description:\n                 group.description = fieldset.description\n             if (\n-                fieldset.order and\n-                fieldset.order != DEFAULT_ORDER and\n-                fieldset.order != group.order\n+                fieldset.order\n+                and fieldset.order != DEFAULT_ORDER\n+                and fieldset.order != group.order\n             ):\n                 group.order = fieldset.order\n \n-        if len(new_fields) > 0 or getattr(form, \'showEmptyGroups\', False):\n+        if len(new_fields) > 0 or getattr(form, "showEmptyGroups", False):\n             _process_widgets(form, widgets, modes, new_fields)\n             if fieldset.__name__ not in groups:\n-                group = GroupFactory(fieldset.__name__,\n-                                     label=fieldset.label,\n-                                     description=fieldset.description,\n-                                     order=fieldset.order,\n-                                     fields=new_fields)\n+                group = GroupFactory(\n+                    fieldset.__name__,\n+                    label=fieldset.label,\n+                    description=fieldset.description,\n+                    order=fieldset.order,\n+                    fields=new_fields,\n+                )\n                 form.groups.append(group)\n                 groups[group.__name__] = group\n \n@@ -203,15 +193,9 @@ def _process_permissions(schema, form, all_fields):\n     permission_cache = {}  # permission name -> allowed/disallowed\n \n     # name => permission name\n-    read_permissions = mergedTaggedValueDict(\n-        schema,\n-        READ_PERMISSIONS_KEY\n-    )\n+    read_permissions = mergedTaggedValueDict(schema, READ_PERMISSIONS_KEY)\n     # name => permission name\n-    write_permissions = mergedTaggedValueDict(\n-        schema,\n-        WRITE_PERMISSIONS_KEY\n-    )\n+    write_permissions = mergedTaggedValueDict(schema, WRITE_PERMISSIONS_KEY)\n     security_manager = getSecurityManager()\n     disallowed_fields = []\n \n@@ -231,10 +215,7 @@ def _process_permissions(schema, form, all_fields):\n                 permission_cache[permission_name] = True\n             else:\n                 permission_cache[permission_name] = bool(\n-                    security_manager.checkPermission(\n-                        permission.title,\n-                        form.context\n-                    )\n+                    security_manager.checkPermission(permission.title, form.context)\n                 )\n         if not permission_cache.get(permission_name, True):\n             disallowed_fields.append(field_name)\n@@ -242,8 +223,7 @@ def _process_permissions(schema, form, all_fields):\n     return all_fields.omit(*disallowed_fields)\n \n \n-def processFields(form, schema, prefix=\'\', defaultGroup=None,\n-                  permissionChecks=True):\n+def processFields(form, schema, prefix="", defaultGroup=None, permissionChecks=True):\n     """Add the fields from the schema to the form, taking into account\n     the hints in the various tagged values as well as fieldsets. If prefix\n     is given, the fields will be prefixed with this prefix. If\n@@ -266,20 +246,18 @@ def processFields(form, schema, prefix=\'\', defaultGroup=None,\n     do_not_process = list(form.fields.keys())\n \n     for field_name, status in omitted.items():\n-        if status and status != \'false\':\n+        if status and status != "false":\n             do_not_process.append(_process_prefixed_name(prefix, field_name))\n \n     for group in form.groups:\n         do_not_process.extend(list(group.fields.keys()))\n-        groups[getattr(group, \'__name__\', group.label)] = group\n+        groups[getattr(group, "__name__", group.label)] = group\n \n     # Find all allowed fields so that we have something to select from\n     omit_read_only = form.mode != DISPLAY_MODE\n-    all_fields = field.Fields(\n-        schema,\n-        prefix=prefix,\n-        omitReadOnly=omit_read_only\n-    ).omit(*do_not_process)\n+    all_fields = field.Fields(schema, prefix=prefix, omitReadOnly=omit_read_only).omit(\n+        *do_not_process\n+    )\n \n     if permissionChecks:\n         all_fields = _process_permissions(schema, form, all_fields)\n@@ -287,14 +265,14 @@ def processFields(form, schema, prefix=\'\', defaultGroup=None,\n \n \n @deprecate(\n-    \'processFieldMoves must not be used any longer. Its implementation is \'\n-    \'unreproducible if same schemas are coming in in different orders. \'\n-    \'The new solution is part of the base.AutoFields class and does \'\n-    \'follow strict rules by first creating a rule dependency tree.\'\n-    \'This function will be remove in a 2.0 releaese and kept until then for \'\n-    \'backward compatibility reasons.\'\n+    "processFieldMoves must not be used any longer. Its implementation is "\n+    "unreproducible if same schemas are coming in in different orders. "\n+    "The new solution is part of the base.AutoFields class and does "\n+    "follow strict rules by first creating a rule dependency tree."\n+    "This function will be remove in a 2.0 releaese and kept until then for "\n+    "backward compatibility reasons."\n )\n-def processFieldMoves(form, schema, prefix=\'\'):\n+def processFieldMoves(form, schema, prefix=""):\n     """Process all field moves stored under ORDER_KEY in the schema tagged\n     value. This should be run after all schemata have been processed with\n     processFields().\n@@ -303,21 +281,20 @@ def processFieldMoves(form, schema, prefix=\'\'):\n     # (name, \'before\'/\'after\', other name)\n     order = mergedTaggedValueList(schema, ORDER_KEY)\n     for field_name, direction, relative_to in order:\n-\n         # Handle shortcut: leading . means \'in this schema\'. May be useful\n         # if you want to move a field relative to one in the current\n         # schema or (more likely) a base schema of the current schema, without\n         # having to repeat the full prefix of this schema.\n \n-        if relative_to.startswith(\'.\'):\n+        if relative_to.startswith("."):\n             relative_to = relative_to[1:]\n             if prefix:\n                 relative_to = expandPrefix(prefix) + relative_to\n \n         try:\n-            if direction == \'before\':\n+            if direction == "before":\n                 move(form, field_name, before=relative_to, prefix=prefix)\n-            elif direction == \'after\':\n+            elif direction == "after":\n                 move(form, field_name, after=relative_to, prefix=prefix)\n         except KeyError:\n             # The relative_to field doesn\'t exist\ndiff --git a/plone/autoform/view.py b/plone/autoform/view.py\nindex 2a5851d..7019922 100644\n--- a/plone/autoform/view.py\n+++ b/plone/autoform/view.py\n@@ -28,7 +28,7 @@ def update(self):\n         self._update()\n \n     def render(self):\n-        if getattr(self, \'index\', None) is not None:\n+        if getattr(self, "index", None) is not None:\n             return self.index()\n         raise NotImplementedError("You must implement the \'render\' method")\n \n@@ -65,7 +65,7 @@ def _update(self):\n \n             groups.append(group)\n \n-            group_name = getattr(group, \'__name__\', str(idx))\n+            group_name = getattr(group, "__name__", str(idx))\n             self.fieldsets[group_name] = group\n \n         self.groups = tuple(groups)\ndiff --git a/plone/autoform/widgets.py b/plone/autoform/widgets.py\nindex c759d3a..015dc3a 100644\n--- a/plone/autoform/widgets.py\n+++ b/plone/autoform/widgets.py\n@@ -43,49 +43,51 @@ class ParameterizedWidget:\n \n     def __init__(self, widget_factory=None, **params):\n         if widget_factory is not None:\n-            if not IFieldWidget.implementedBy(widget_factory) \\\n-                    and not IWidget.implementedBy(widget_factory) \\\n-                    and not isinstance(widget_factory, str):\n-                raise TypeError(\'widget_factory must be an IFieldWidget \'\n-                                \'or an IWidget\')\n+            if (\n+                not IFieldWidget.implementedBy(widget_factory)\n+                and not IWidget.implementedBy(widget_factory)\n+                and not isinstance(widget_factory, str)\n+            ):\n+                raise TypeError(\n+                    "widget_factory must be an IFieldWidget " "or an IWidget"\n+                )\n         self.widget_factory = widget_factory\n         self.params = params\n \n     def __call__(self, field, request):\n         __traceback_info__ = (\n-            \'{}, processing:\\n\'\n+            "{}, processing:\\n"\n             \'- field "{}"\\n\'\n-            \'- widget: {}\\n\'\n-            \'- params: {}\\n\'.format(\n+            "- widget: {}\\n"\n+            "- params: {}\\n".format(\n                 self.__class__.__name__,\n                 field.__name__,\n                 repr(self.widget_factory),\n-                self.params\n+                self.params,\n             )\n         )\n         if isinstance(self.widget_factory, str):\n-            __traceback_info__ += \'- resolving dotted name\\n\'\n+            __traceback_info__ += "- resolving dotted name\\n"\n             self.widget_factory = resolveDottedName(self.widget_factory)\n         if self.widget_factory is None:\n             # use default widget factory for this field type\n-            __traceback_info__ += \'- using default widget factory\\n\'\n+            __traceback_info__ += "- using default widget factory\\n"\n             widget = getMultiAdapter((field, request), IFieldWidget)\n         elif IWidget.implementedBy(self.widget_factory):\n-            __traceback_info__ += \'- calling factory, then wrapping with \' \\\n-                                  \'FieldWidget\\n\'\n+            __traceback_info__ += (\n+                "- calling factory, then wrapping with " "FieldWidget\\n"\n+            )\n             widget = FieldWidget(field, self.widget_factory(request))\n         elif IFieldWidget.implementedBy(self.widget_factory):\n-            __traceback_info__ += \'- calling factory\\n\'\n+            __traceback_info__ += "- calling factory\\n"\n             widget = self.widget_factory(field, request)\n         for k, v in self.params.items():\n             setattr(widget, k, v)\n         return widget\n \n     def __repr__(self):\n-        return \'{}({}, {})\'.format(\n-            self.__class__.__name__,\n-            self.widget_factory,\n-            self.params\n+        return "{}({}, {})".format(\n+            self.__class__.__name__, self.widget_factory, self.params\n         )\n \n     def getWidgetFactoryName(self):\n@@ -97,7 +99,7 @@ def getWidgetFactoryName(self):\n         if widget is None:\n             return\n         if not isinstance(widget, str):\n-            widget = f\'{widget.__module__}.{widget.__name__}\'\n+            widget = f"{widget.__module__}.{widget.__name__}"\n         return widget\n \n     def getExportImportHandler(self, field):\n@@ -109,17 +111,16 @@ def getExportImportHandler(self, field):\n             # instantiate the widget.\n             sm = getSiteManager()\n             widgetFactory = sm.adapters.lookup(\n-                (providedBy(field), IFormLayer), IFieldWidget)\n+                (providedBy(field), IFormLayer), IFieldWidget\n+            )\n             if widgetFactory is not None:\n-                widgetName = \'{}.{}\'.format(\n-                    widgetFactory.__module__,\n-                    widgetFactory.__name__\n+                widgetName = "{}.{}".format(\n+                    widgetFactory.__module__, widgetFactory.__name__\n                 )\n             else:\n-                widgetName = \'\'\n+                widgetName = ""\n \n-        widgetHandler = queryUtility(IWidgetExportImportHandler,\n-                                     name=widgetName)\n+        widgetHandler = queryUtility(IWidgetExportImportHandler, name=widgetName)\n         if widgetHandler is None:\n             widgetHandler = WidgetExportImportHandler(IHTMLFormElement)\n         return widgetHandler\n@@ -127,7 +128,6 @@ def getExportImportHandler(self, field):\n \n @implementer(IWidgetExportImportHandler)\n class WidgetExportImportHandler:\n-\n     def __init__(self, widget_schema):\n         self.fieldAttributes = getFields(widget_schema)\n \n@@ -135,10 +135,7 @@ def read(self, widgetNode, params):\n         for attributeName, attributeField in self.fieldAttributes.items():\n             for node in widgetNode.iterchildren():\n                 if noNS(node.tag) == attributeName:\n-                    params[attributeName] = elementToValue(\n-                        attributeField,\n-                        node\n-                    )\n+                    params[attributeName] = elementToValue(attributeField, node)\n \n     def write(self, widgetNode, params):\n         for attributeName, attributeField in self.fieldAttributes.items():\ndiff --git a/setup.py b/setup.py\nindex 9d869e4..4a00a41 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -8,12 +8,12 @@ def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n \n-version = \'2.0.1.dev0\'\n+version = "2.0.1.dev0"\n \n-long_description = (read(\'README.rst\') + \'\\n\' + read(\'CHANGES.rst\'))\n+long_description = read("README.rst") + "\\n" + read("CHANGES.rst")\n \n setup(\n-    name=\'plone.autoform\',\n+    name="plone.autoform",\n     version=version,\n     description="Tools to construct z3c.form forms",\n     long_description=long_description,\n@@ -31,25 +31,25 @@ def read(*rnames):\n         "Programming Language :: Python :: 3.11",\n         "Topic :: Software Development :: Libraries :: Python Modules",\n     ],\n-    keywords=\'plone form z3c.form\',\n-    author=\'Martin Aspeli\',\n-    author_email=\'optilude@gmail.com\',\n-    url=\'http://github.com/plone/plone.autoform\',\n-    license=\'LGPL\',\n+    keywords="plone form z3c.form",\n+    author="Martin Aspeli",\n+    author_email="optilude@gmail.com",\n+    url="http://github.com/plone/plone.autoform",\n+    license="LGPL",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'zope.interface\',\n-        \'zope.schema\',\n-        \'zope.security\',\n-        \'zope.dottedname\',\n-        \'plone.supermodel>=1.3\',\n-        \'plone.z3cform>=2.0.0\',\n-        \'z3c.form\',\n+        "setuptools",\n+        "six",\n+        "zope.interface",\n+        "zope.schema",\n+        "zope.security",\n+        "zope.dottedname",\n+        "plone.supermodel>=1.3",\n+        "plone.z3cform>=2.0.0",\n+        "z3c.form",\n     ],\n     entry_points="""\n     # -*- Entry points: -*-\n'

Repository: plone.autoform


Branch: refs/heads/master
Date: 2023-03-15T22:50:27+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.autoform/commit/f067a2e4b83c5354ef5f3fbec5a6a30b4f7cd78d

chore: zpretty

Files changed:
M plone/autoform/configure.zcml

b'diff --git a/plone/autoform/configure.zcml b/plone/autoform/configure.zcml\nindex e5e9e00..9509634 100644\n--- a/plone/autoform/configure.zcml\n+++ b/plone/autoform/configure.zcml\n@@ -1,61 +1,62 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    i18n_domain="plone.autoform">\n-\n-    <include package="plone.z3cform" />\n-    <include package="plone.supermodel" />\n-\n-    <utility\n-        factory=".supermodel.FormSchema"\n-        name="plone.autoform.form"\n-        />\n-\n-    <utility\n-        factory=".supermodel.SecuritySchema"\n-        name="plone.autoform.security"\n-        />\n-\n-    <adapter\n-        factory=".directives.OmittedPlugin"\n-        name="plone.autoform.omitted"\n-        />\n-\n-    <adapter\n-        factory=".directives.ModePlugin"\n-        name="plone.autoform.mode"\n-        />\n-\n-    <adapter\n-        factory=".directives.WidgetPlugin"\n-        name="plone.autoform.widget"\n-        />\n-\n-    <adapter\n-        factory=".directives.OrderPlugin"\n-        name="plone.autoform.order"\n-        />\n-\n-    <adapter\n-        factory=".directives.ReadPermissionsPlugin"\n-        name="plone.autoform.read_permissions"\n-        />\n-\n-    <adapter\n-        factory=".directives.WritePermissionsPlugin"\n-        name="plone.autoform.write_permissions"\n-        />\n-\n-    <!-- widget import/export -->\n-\n-    <utility\n-        provides=".interfaces.IWidgetExportImportHandler"\n-        component=".widgets.TextInputWidgetExportImportHandler"\n-        name="z3c.form.browser.text.TextFieldWidget"\n-        />\n-\n-    <utility\n-        provides=".interfaces.IWidgetExportImportHandler"\n-        component=".widgets.TextAreaWidgetExportImportHandler"\n-        name="z3c.form.browser.textarea.TextAreaFieldWidget"\n-        />\n+    i18n_domain="plone.autoform"\n+    >\n+\n+  <include package="plone.z3cform" />\n+  <include package="plone.supermodel" />\n+\n+  <utility\n+      factory=".supermodel.FormSchema"\n+      name="plone.autoform.form"\n+      />\n+\n+  <utility\n+      factory=".supermodel.SecuritySchema"\n+      name="plone.autoform.security"\n+      />\n+\n+  <adapter\n+      factory=".directives.OmittedPlugin"\n+      name="plone.autoform.omitted"\n+      />\n+\n+  <adapter\n+      factory=".directives.ModePlugin"\n+      name="plone.autoform.mode"\n+      />\n+\n+  <adapter\n+      factory=".directives.WidgetPlugin"\n+      name="plone.autoform.widget"\n+      />\n+\n+  <adapter\n+      factory=".directives.OrderPlugin"\n+      name="plone.autoform.order"\n+      />\n+\n+  <adapter\n+      factory=".directives.ReadPermissionsPlugin"\n+      name="plone.autoform.read_permissions"\n+      />\n+\n+  <adapter\n+      factory=".directives.WritePermissionsPlugin"\n+      name="plone.autoform.write_permissions"\n+      />\n+\n+  <!-- widget import/export -->\n+\n+  <utility\n+      provides=".interfaces.IWidgetExportImportHandler"\n+      name="z3c.form.browser.text.TextFieldWidget"\n+      component=".widgets.TextInputWidgetExportImportHandler"\n+      />\n+\n+  <utility\n+      provides=".interfaces.IWidgetExportImportHandler"\n+      name="z3c.form.browser.textarea.TextAreaFieldWidget"\n+      component=".widgets.TextAreaWidgetExportImportHandler"\n+      />\n </configure>\n'

Repository: plone.autoform


Branch: refs/heads/master
Date: 2023-03-15T22:51:12+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.autoform/commit/0df46f821d4dcbbda9a6bbed7373416cbbdb4383

feat: pyroma

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex 4a00a41..c058933 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -40,6 +40,7 @@ def read(*rnames):\n     namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n+    python_requires=">=3.8",\n     install_requires=[\n         "setuptools",\n         "six",\n'

Repository: plone.autoform


Branch: refs/heads/master
Date: 2023-03-15T22:52:55+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.autoform/commit/9db7872068ff1d54e6f96c7e867ca83543823589

feat: flake8

Files changed:
M plone/autoform/base.py
M plone/autoform/directives.py
M plone/autoform/utils.py
M plone/autoform/widgets.py

b'diff --git a/plone/autoform/base.py b/plone/autoform/base.py\nindex 4bb302c..35f3074 100644\n--- a/plone/autoform/base.py\n+++ b/plone/autoform/base.py\n@@ -10,7 +10,6 @@\n from z3c.form.util import expandPrefix\n \n import logging\n-import six\n \n \n logger = logging.getLogger(__name__)\ndiff --git a/plone/autoform/directives.py b/plone/autoform/directives.py\nindex 0013751..db7c163 100644\n--- a/plone/autoform/directives.py\n+++ b/plone/autoform/directives.py\n@@ -14,8 +14,6 @@\n from zope.interface import Interface\n from zope.interface.interfaces import IInterface\n \n-import six\n-\n \n class omitted(MetadataListDirective):\n     """Directive used to omit one or more fields"""\ndiff --git a/plone/autoform/utils.py b/plone/autoform/utils.py\nindex fb6a77e..f49b512 100644\n--- a/plone/autoform/utils.py\n+++ b/plone/autoform/utils.py\n@@ -23,8 +23,6 @@\n from zope.interface import providedBy\n from zope.security.interfaces import IPermission\n \n-import six\n-\n \n _dottedCache = {}\n \ndiff --git a/plone/autoform/widgets.py b/plone/autoform/widgets.py\nindex 015dc3a..010855f 100644\n--- a/plone/autoform/widgets.py\n+++ b/plone/autoform/widgets.py\n@@ -16,7 +16,6 @@\n from zope.interface import providedBy\n from zope.schema import getFields\n \n-import six\n import z3c.form.browser.interfaces\n \n \n'

Repository: plone.autoform


Branch: refs/heads/master
Date: 2023-03-15T22:54:28+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.autoform/commit/1181369a0077bb5b6fe09af01552e350946a5ade

feat: codespell

Files changed:
M CHANGES.rst
M plone/autoform/tests/test_utils.py
M plone/autoform/view.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 77da548..d4fe761 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -150,14 +150,14 @@ Incompatibilities:\n \n New:\n \n-- Fieldset labels/descriptions we\'re taken from first occurence.\n+- Fieldset labels/descriptions we\'re taken from first occurrence.\n   It was not possible to override them in a subsequent directive.\n   Also it was not possible to set them in a subsequent directive, if it was not set before.\n   Now subsequent directives w/o a label/description are just adding the field to the fieldset.\n   If a different label and/or description is given, it replaces the existing prior loaded one.\n   [jensens]\n \n-- The order of the fieldsets can be defined now explictly with the ``plone.supermodel.directives.fieldset`` directive.\n+- The order of the fieldsets can be defined now explicitly with the ``plone.supermodel.directives.fieldset`` directive.\n   ``plone.autoform`` now does the sorting while fieldset processing.\n   [jensens]\n \ndiff --git a/plone/autoform/tests/test_utils.py b/plone/autoform/tests/test_utils.py\nindex 93dbd58..143ea9b 100644\n--- a/plone/autoform/tests/test_utils.py\n+++ b/plone/autoform/tests/test_utils.py\n@@ -92,7 +92,7 @@ class subschema(schema):\n         self.assertEqual([g.__name__ for g in form.groups], ["custom"])\n \n     def test_fieldset_configuration(self):\n-        """Test, if fieldsets can be orderd via fieldset configuration on a\n+        """Test, if fieldsets can be ordered via fieldset configuration on a\n         schema without fields. This schema should also not be included in form\n         groups.\n         """\ndiff --git a/plone/autoform/view.py b/plone/autoform/view.py\nindex 7019922..1f23846 100644\n--- a/plone/autoform/view.py\n+++ b/plone/autoform/view.py\n@@ -8,7 +8,7 @@\n \n @implementer(IWidgetsView)\n class WidgetsView(AutoFields, DisplayForm):\n-    """Mix-in to allow widgets (in view mode) to be accesed from browser\n+    """Mix-in to allow widgets (in view mode) to be accessed from browser\n     views.\n     """\n \n'

Repository: plone.autoform


Branch: refs/heads/master
Date: 2023-03-16T09:29:17+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.autoform/commit/82a50644f4824f5a1eb2e15faba2e8b4119e8caa

feat: remove six dependency

Files changed:
M plone/autoform/autoform.rst
M plone/autoform/supermodel.txt
M plone/autoform/tests/subform.txt
M plone/autoform/tests/test_doctests.py
M plone/autoform/view.txt
M setup.py

b'diff --git a/plone/autoform/autoform.rst b/plone/autoform/autoform.rst\nindex 3966118..bb8da23 100644\n--- a/plone/autoform/autoform.rst\n+++ b/plone/autoform/autoform.rst\n@@ -44,8 +44,7 @@ First, let\'s load this package\'s ZCML so that we can run the tests::\n     ...\n     ... </configure>\n     ... """\n-    >>> import six\n-    >>> from six import StringIO\n+    >>> from io import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \ndiff --git a/plone/autoform/supermodel.txt b/plone/autoform/supermodel.txt\nindex c823ed5..14491fa 100644\n--- a/plone/autoform/supermodel.txt\n+++ b/plone/autoform/supermodel.txt\n@@ -19,8 +19,7 @@ First, let\'s load this package\'s ZCML so that we can run the tests:\n     ...\n     ... </configure>\n     ... """\n-    >>> import six\n-    >>> from six import StringIO\n+    >>> from io import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \ndiff --git a/plone/autoform/tests/subform.txt b/plone/autoform/tests/subform.txt\nindex 96dc447..dc0488f 100644\n--- a/plone/autoform/tests/subform.txt\n+++ b/plone/autoform/tests/subform.txt\n@@ -36,8 +36,7 @@ First, let\'s load this package\'s ZCML so that we can run the tests:\n     ...\n     ... </configure>\n     ... """\n-    >>> import six\n-    >>> from six import StringIO\n+    >>> from io import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \ndiff --git a/plone/autoform/tests/test_doctests.py b/plone/autoform/tests/test_doctests.py\nindex f731a78..52aad04 100644\n--- a/plone/autoform/tests/test_doctests.py\n+++ b/plone/autoform/tests/test_doctests.py\n@@ -3,8 +3,6 @@\n from plone.testing.zca import UNIT_TESTING\n \n import doctest\n-import re\n-import six\n import unittest\n \n \n@@ -16,21 +14,12 @@\n ]\n \n \n-class Py23DocChecker(doctest.OutputChecker):\n-    def check_output(self, want, got, optionflags):\n-        if six.PY2:\n-            got = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n-            # want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n-        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n-\n-\n def test_suite():\n     tests = [\n         layered(\n             doctest.DocFileSuite(\n                 test_file,\n                 optionflags=optionflags,\n-                checker=Py23DocChecker(),\n             ),\n             layer=UNIT_TESTING,\n         )\ndiff --git a/plone/autoform/view.txt b/plone/autoform/view.txt\nindex 52fa463..6689c67 100644\n--- a/plone/autoform/view.txt\n+++ b/plone/autoform/view.txt\n@@ -15,8 +15,7 @@ First, let\'s load this package\'s ZCML so that we can run the tests:\n     ...\n     ... </configure>\n     ... """\n-    >>> import six\n-    >>> from six import StringIO\n+    >>> from io import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \ndiff --git a/setup.py b/setup.py\nindex c058933..e81154b 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -43,7 +43,6 @@ def read(*rnames):\n     python_requires=">=3.8",\n     install_requires=[\n         "setuptools",\n-        "six",\n         "zope.interface",\n         "zope.schema",\n         "zope.security",\n'

Repository: plone.autoform


Branch: refs/heads/master
Date: 2023-03-16T09:29:17+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.autoform/commit/99fe9b9a09c9cf71a1c12f181ac2613b483f9631

feat: declare dependencies

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex e81154b..af81df1 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -42,7 +42,9 @@ def read(*rnames):\n     zip_safe=False,\n     python_requires=">=3.8",\n     install_requires=[\n+        "lxml",\n         "setuptools",\n+        "zope.deprecation",\n         "zope.interface",\n         "zope.schema",\n         "zope.security",\n@@ -51,6 +53,11 @@ def read(*rnames):\n         "plone.z3cform>=2.0.0",\n         "z3c.form",\n     ],\n+    extras_require={\n+        "test": [\n+            "plone.testing",\n+        ],\n+    },\n     entry_points="""\n     # -*- Entry points: -*-\n     """,\n'

Repository: plone.autoform


Branch: refs/heads/master
Date: 2023-03-16T13:44:38+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.autoform/commit/ef12921490fa246202282fae50d7f9f4a6bd3c6a

Merge pull request #42 from plone/config-with-default-template-f5fdf945

Config with default template

Files changed:
A .editorconfig
A .meta.toml
A .pre-commit-config.yaml
A news/243ca9ec.internal
A tox.ini
M CHANGES.rst
M plone/__init__.py
M plone/autoform/__init__.py
M plone/autoform/autoform.rst
M plone/autoform/base.py
M plone/autoform/configure.zcml
M plone/autoform/directives.py
M plone/autoform/form.py
M plone/autoform/interfaces.py
M plone/autoform/supermodel.py
M plone/autoform/supermodel.txt
M plone/autoform/testing.py
M plone/autoform/tests/__init__.py
M plone/autoform/tests/subform.txt
M plone/autoform/tests/test_base.py
M plone/autoform/tests/test_directives.py
M plone/autoform/tests/test_doctests.py
M plone/autoform/tests/test_supermodel_handler.py
M plone/autoform/tests/test_utils.py
M plone/autoform/tests/test_widgets.py
M plone/autoform/utils.py
M plone/autoform/view.py
M plone/autoform/view.txt
M plone/autoform/widgets.py
M pyproject.toml
M setup.cfg
M setup.py

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..17f7b14\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "243ca9ec"\ndiff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nnew file mode 100644\nindex 0000000..582f8ac\n--- /dev/null\n+++ b/.pre-commit-config.yaml\n@@ -0,0 +1,42 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+ci:\n+    autofix_prs: false\n+    autoupdate_schedule: monthly\n+\n+repos:\n+-   repo: https://github.com/asottile/pyupgrade\n+    rev: v3.3.1\n+    hooks:\n+    -   id: pyupgrade\n+        args: [--py38-plus]\n+-   repo: https://github.com/pycqa/isort\n+    rev: 5.12.0\n+    hooks:\n+    -   id: isort\n+-   repo: https://github.com/psf/black\n+    rev: 23.1.0\n+    hooks:\n+    -   id: black\n+-   repo: https://github.com/collective/zpretty\n+    rev: 3.0.2\n+    hooks:\n+    -   id: zpretty\n+-   repo: https://github.com/PyCQA/flake8\n+    rev: 6.0.0\n+    hooks:\n+    -   id: flake8\n+-   repo: https://github.com/codespell-project/codespell\n+    rev: v2.2.2\n+    hooks:\n+    -   id: codespell\n+        additional_dependencies:\n+          - tomli\n+-   repo: https://github.com/mgedmin/check-manifest\n+    rev: "0.49"\n+    hooks:\n+    -   id: check-manifest\n+-   repo: https://github.com/regebro/pyroma\n+    rev: "4.2"\n+    hooks:\n+    -   id: pyroma\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex 77da548..d4fe761 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -150,14 +150,14 @@ Incompatibilities:\n \n New:\n \n-- Fieldset labels/descriptions we\'re taken from first occurence.\n+- Fieldset labels/descriptions we\'re taken from first occurrence.\n   It was not possible to override them in a subsequent directive.\n   Also it was not possible to set them in a subsequent directive, if it was not set before.\n   Now subsequent directives w/o a label/description are just adding the field to the fieldset.\n   If a different label and/or description is given, it replaces the existing prior loaded one.\n   [jensens]\n \n-- The order of the fieldsets can be defined now explictly with the ``plone.supermodel.directives.fieldset`` directive.\n+- The order of the fieldsets can be defined now explicitly with the ``plone.supermodel.directives.fieldset`` directive.\n   ``plone.autoform`` now does the sorting while fieldset processing.\n   [jensens]\n \ndiff --git a/news/243ca9ec.internal b/news/243ca9ec.internal\nnew file mode 100644\nindex 0000000..c08f539\n--- /dev/null\n+++ b/news/243ca9ec.internal\n@@ -0,0 +1,2 @@\n+Update configuration files.\n+[plone devs]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/autoform/__init__.py b/plone/autoform/__init__.py\nindex 40a96af..e69de29 100644\n--- a/plone/autoform/__init__.py\n+++ b/plone/autoform/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/autoform/autoform.rst b/plone/autoform/autoform.rst\nindex 3966118..bb8da23 100644\n--- a/plone/autoform/autoform.rst\n+++ b/plone/autoform/autoform.rst\n@@ -44,8 +44,7 @@ First, let\'s load this package\'s ZCML so that we can run the tests::\n     ...\n     ... </configure>\n     ... """\n-    >>> import six\n-    >>> from six import StringIO\n+    >>> from io import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \ndiff --git a/plone/autoform/base.py b/plone/autoform/base.py\nindex debbff3..35f3074 100644\n--- a/plone/autoform/base.py\n+++ b/plone/autoform/base.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from collections import OrderedDict\n from operator import attrgetter\n from plone.autoform.interfaces import ORDER_KEY\n@@ -11,14 +10,13 @@\n from z3c.form.util import expandPrefix\n \n import logging\n-import six\n \n \n logger = logging.getLogger(__name__)\n _marker = object()\n \n \n-class AutoFields(object):\n+class AutoFields:\n     """Mixin class for the WidgetsView and AutoExtensibleForm classes.\n     Takes care of actually processing field updates\n     """\n@@ -33,12 +31,11 @@ class AutoFields(object):\n     autoGroups = False\n \n     def updateFieldsFromSchemata(self):\n-\n         # If the form is called from the ++widget++ traversal namespace,\n         # we won\'t have a user yet. In this case, we can\'t perform permission\n         # checks.\n \n-        have_user = bool(self.request.get(\'AUTHENTICATED_USER\', False))\n+        have_user = bool(self.request.get("AUTHENTICATED_USER", False))\n \n         # Turn fields into an instance variable, since we will be modifying it\n         self.fields = field.Fields(self.fields)\n@@ -49,12 +46,12 @@ def updateFieldsFromSchemata(self):\n         groups = []\n \n         for group in self.groups:\n-            group_name = getattr(group, \'__name__\', group.label)\n+            group_name = getattr(group, "__name__", group.label)\n             fieldset_group = GroupFactory(\n                 group_name,\n                 field.Fields(group.fields),\n                 group.label,\n-                getattr(group, \'description\', None)\n+                getattr(group, "description", None),\n             )\n             groups.append(fieldset_group)\n \n@@ -69,7 +66,6 @@ def updateFieldsFromSchemata(self):\n \n         # Set up all widgets, modes, omitted fields and fieldsets\n         for schema in self.additionalSchemata:\n-\n             # Find the prefix to use for this form and cache for next round\n             prefix = self.getPrefix(schema)\n             if prefix and prefix in prefixes:\n@@ -93,7 +89,7 @@ def updateFieldsFromSchemata(self):\n                 # store this in a dict.\n                 found = False\n                 for g in self.groups:\n-                    if group_name == getattr(g, \'__name__\', g.label):\n+                    if group_name == getattr(g, "__name__", g.label):\n                         found = True\n                         break\n \n@@ -114,13 +110,13 @@ def updateFieldsFromSchemata(self):\n                 schema,\n                 prefix=prefix,\n                 defaultGroup=defaultGroup,\n-                permissionChecks=have_user\n+                permissionChecks=have_user,\n             )\n \n         # Then process relative field movements. The base schema is processed\n         # last to allow it to override any movements made in additional\n         # schemata.\n-        rules = {\'__all__\': {}}\n+        rules = {"__all__": {}}\n         for schema in self.additionalSchemata:\n             order = mergedTaggedValueList(schema, ORDER_KEY)\n             rules = self._calculate_field_moves(\n@@ -136,72 +132,66 @@ def updateFieldsFromSchemata(self):\n         self._process_group_order()\n \n     def getPrefix(self, schema):\n-        """Get the preferred prefix for the given schema\n-        """\n+        """Get the preferred prefix for the given schema"""\n         if self.ignorePrefix:\n-            return \'\'\n+            return ""\n         return schema.__name__\n \n     def _prepare_names(self, source, target, prefix):\n-            # calculate prefixed fieldname\n+        # calculate prefixed fieldname\n+        if prefix:\n+            source = f"{prefix}.{source}"\n+\n+        # Handle shortcut: leading . means "in this form". May be useful\n+        # if you want to move a field relative to one in the current\n+        # schema or (more likely) a base schema of the current schema,\n+        # without having to repeat the full prefix of this schema.\n+        if target.startswith("."):\n+            target = target[1:]\n             if prefix:\n-                source = \'{0}.{1}\'.format(prefix, source)\n-\n-            # Handle shortcut: leading . means "in this form". May be useful\n-            # if you want to move a field relative to one in the current\n-            # schema or (more likely) a base schema of the current schema,\n-            # without having to repeat the full prefix of this schema.\n-            if target.startswith(\'.\'):\n-                target = target[1:]\n-                if prefix:\n-                    target = expandPrefix(prefix) + target\n-            return source, target\n+                target = expandPrefix(prefix) + target\n+        return source, target\n \n     def _cleanup_rules(self, rules):\n-        for rulename in rules[\'__all__\']:\n-            if \'parent\' in rules[\'__all__\'][rulename]:\n-                del rules[\'__all__\'][rulename][\'parent\']\n-        del rules[\'__all__\']\n-\n-    def _calculate_field_moves(self, order, prefix=\'\', rules=None):\n-        """Calculates all needed field rules\n-        """\n+        for rulename in rules["__all__"]:\n+            if "parent" in rules["__all__"][rulename]:\n+                del rules["__all__"][rulename]["parent"]\n+        del rules["__all__"]\n+\n+    def _calculate_field_moves(self, order, prefix="", rules=None):\n+        """Calculates all needed field rules"""\n         # we want to be independent from the order of the schemas coming later\n         # so a if field_c is first moved after field_a, then field_a is moved\n         # after field_c, the output should be: b, a, c, because or first move\n         # sticks\n         if rules is None:\n             rules = {}\n-        allrules = rules.get(\'__all__\', None)\n+        allrules = rules.get("__all__", None)\n         if allrules is None:\n-            allrules = rules[\'__all__\'] = dict()\n+            allrules = rules["__all__"] = dict()\n \n         # (current field name, \'before\'/\'after\', other field name)\n         for source, direction, target in order:\n             source, target = self._prepare_names(source, target, prefix)\n             # use a simple tree to resolve dependencies\n             rule = allrules.get(source, {})\n-            if (\n-                \'target\' in rule and target != rule[\'target\']\n-            ):\n+            if "target" in rule and target != rule["target"]:\n                 # target override\n                 # reset this rule to a stub first\n-                del rule[\'target\']\n-                del rule[\'dir\']\n-                rule[\'stub\'] = True\n+                del rule["target"]\n+                del rule["dir"]\n+                rule["stub"] = True\n                 # unlink in parent\n-                del rule[\'parent\'][\'with\'][source]\n-                del rule[\'parent\']\n-            if (\n-                \'dir\' in rule and direction != rule[\'dir\']\n-            ):\n+                del rule["parent"]["with"][source]\n+                del rule["parent"]\n+            if "dir" in rule and direction != rule["dir"]:\n                 # direction override\n-                rule[\'dir\'] = direction\n-            if not rule or rule.get(\'stub\', False):\n-                if rule.get(\'stub\', False):\n-                    del rule[\'stub\']\n-                rule[\'target\'] = target\n-                rule[\'dir\'] = direction\n+                rule["dir"] = direction\n+            if not rule or rule.get("stub", False):\n+                if rule.get("stub", False):\n+                    del rule["stub"]\n+                rule["target"] = target\n+                rule["dir"] = direction\n                 allrules[source] = rule\n \n             # field is no longer a tree root\n@@ -211,60 +201,52 @@ def _calculate_field_moves(self, order, prefix=\'\', rules=None):\n             target_rule = allrules.get(target, None)\n             if target_rule is None:\n                 allrules[target] = target_rule = {\n-                    \'stub\': True,\n+                    "stub": True,\n                 }\n                 rules[target] = target_rule\n-            if \'with\' not in target_rule:\n-                target_rule[\'with\'] = OrderedDict()\n-            rule[\'parent\'] = target_rule\n-            target_rule[\'with\'][source] = rule\n+            if "with" not in target_rule:\n+                target_rule["with"] = OrderedDict()\n+            rule["parent"] = target_rule\n+            target_rule["with"][source] = rule\n \n         return rules\n \n     def _process_field_moves(self, rules):\n-        """move fields according to the rules\n-        """\n+        """move fields according to the rules"""\n         for name, rule in rules.items():\n-            if name == \'__all__\':\n+            if name == "__all__":\n                 continue\n             prefix = None\n-            if \'.\' in name:\n-                prefix, name = name.split(\'.\', 1)\n+            if "." in name:\n+                prefix, name = name.split(".", 1)\n             else:\n-                prefix = \'\'\n-            if not rule.get(\'stub\', False):\n-                after = rule[\'target\'] if rule[\'dir\'] == \'after\' else None\n-                before = rule[\'target\'] if rule[\'dir\'] == \'before\' else None\n+                prefix = ""\n+            if not rule.get("stub", False):\n+                after = rule["target"] if rule["dir"] == "after" else None\n+                before = rule["target"] if rule["dir"] == "before" else None\n                 if not (before or after):\n                     raise ValueError(\n-                        \'Direction of a field move must be before or \'\n-                        \'after, but got {0}.\'.format(rule[\'direction\'])\n+                        "Direction of a field move must be before or "\n+                        "after, but got {}.".format(rule["direction"])\n                     )\n                 try:\n                     move(self, name, before=before, after=after, prefix=prefix)\n                 except KeyError as e:\n-                    if six.PY2:\n-                        message = e.message\n-                    else:\n-                        message = e.args[0]\n-                    if (\n-                        message.startswith(\'Field \') and\n-                        message.endswith(\' not found\')\n-                    ):\n+                    message = e.args[0]\n+                    if message.startswith("Field ") and message.endswith(" not found"):\n                         # The relative_to field doesn\'t exist\n                         logger.debug(\n-                            \'Field move to non-existing: \'\n-                            \'field name: {0}, rule: {1}\'.format(\n-                                prefix + \'.\' + name,\n-                                str(rule)\n+                            "Field move to non-existing: "\n+                            "field name: {}, rule: {}".format(\n+                                prefix + "." + name, str(rule)\n                             )\n                         )\n                     else:\n                         raise\n-            self._process_field_moves(rule.get(\'with\', {}))\n+            self._process_field_moves(rule.get("with", {}))\n \n     def _process_group_order(self):\n         try:\n-            self.groups.sort(key=attrgetter(\'order\'))\n+            self.groups.sort(key=attrgetter("order"))\n         except TypeError:\n             pass\ndiff --git a/plone/autoform/configure.zcml b/plone/autoform/configure.zcml\nindex e5e9e00..9509634 100644\n--- a/plone/autoform/configure.zcml\n+++ b/plone/autoform/configure.zcml\n@@ -1,61 +1,62 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    i18n_domain="plone.autoform">\n-\n-    <include package="plone.z3cform" />\n-    <include package="plone.supermodel" />\n-\n-    <utility\n-        factory=".supermodel.FormSchema"\n-        name="plone.autoform.form"\n-        />\n-\n-    <utility\n-        factory=".supermodel.SecuritySchema"\n-        name="plone.autoform.security"\n-        />\n-\n-    <adapter\n-        factory=".directives.OmittedPlugin"\n-        name="plone.autoform.omitted"\n-        />\n-\n-    <adapter\n-        factory=".directives.ModePlugin"\n-        name="plone.autoform.mode"\n-        />\n-\n-    <adapter\n-        factory=".directives.WidgetPlugin"\n-        name="plone.autoform.widget"\n-        />\n-\n-    <adapter\n-        factory=".directives.OrderPlugin"\n-        name="plone.autoform.order"\n-        />\n-\n-    <adapter\n-        factory=".directives.ReadPermissionsPlugin"\n-        name="plone.autoform.read_permissions"\n-        />\n-\n-    <adapter\n-        factory=".directives.WritePermissionsPlugin"\n-        name="plone.autoform.write_permissions"\n-        />\n-\n-    <!-- widget import/export -->\n-\n-    <utility\n-        provides=".interfaces.IWidgetExportImportHandler"\n-        component=".widgets.TextInputWidgetExportImportHandler"\n-        name="z3c.form.browser.text.TextFieldWidget"\n-        />\n-\n-    <utility\n-        provides=".interfaces.IWidgetExportImportHandler"\n-        component=".widgets.TextAreaWidgetExportImportHandler"\n-        name="z3c.form.browser.textarea.TextAreaFieldWidget"\n-        />\n+    i18n_domain="plone.autoform"\n+    >\n+\n+  <include package="plone.z3cform" />\n+  <include package="plone.supermodel" />\n+\n+  <utility\n+      factory=".supermodel.FormSchema"\n+      name="plone.autoform.form"\n+      />\n+\n+  <utility\n+      factory=".supermodel.SecuritySchema"\n+      name="plone.autoform.security"\n+      />\n+\n+  <adapter\n+      factory=".directives.OmittedPlugin"\n+      name="plone.autoform.omitted"\n+      />\n+\n+  <adapter\n+      factory=".directives.ModePlugin"\n+      name="plone.autoform.mode"\n+      />\n+\n+  <adapter\n+      factory=".directives.WidgetPlugin"\n+      name="plone.autoform.widget"\n+      />\n+\n+  <adapter\n+      factory=".directives.OrderPlugin"\n+      name="plone.autoform.order"\n+      />\n+\n+  <adapter\n+      factory=".directives.ReadPermissionsPlugin"\n+      name="plone.autoform.read_permissions"\n+      />\n+\n+  <adapter\n+      factory=".directives.WritePermissionsPlugin"\n+      name="plone.autoform.write_permissions"\n+      />\n+\n+  <!-- widget import/export -->\n+\n+  <utility\n+      provides=".interfaces.IWidgetExportImportHandler"\n+      name="z3c.form.browser.text.TextFieldWidget"\n+      component=".widgets.TextInputWidgetExportImportHandler"\n+      />\n+\n+  <utility\n+      provides=".interfaces.IWidgetExportImportHandler"\n+      name="z3c.form.browser.textarea.TextAreaFieldWidget"\n+      component=".widgets.TextAreaWidgetExportImportHandler"\n+      />\n </configure>\ndiff --git a/plone/autoform/directives.py b/plone/autoform/directives.py\nindex c3289cf..db7c163 100644\n--- a/plone/autoform/directives.py\n+++ b/plone/autoform/directives.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.interfaces import MODES_KEY\n from plone.autoform.interfaces import OMITTED_KEY\n from plone.autoform.interfaces import ORDER_KEY\n@@ -15,20 +14,16 @@\n from zope.interface import Interface\n from zope.interface.interfaces import IInterface\n \n-import six\n-\n \n class omitted(MetadataListDirective):\n-    """Directive used to omit one or more fields\n-    """\n+    """Directive used to omit one or more fields"""\n+\n     key = OMITTED_KEY\n-    value = \'true\'\n+    value = "true"\n \n     def factory(self, *args):\n         if not args:\n-            raise TypeError(\n-                \'The omitted directive expects at least one argument.\'\n-            )\n+            raise TypeError("The omitted directive expects at least one argument.")\n         form_interface = Interface\n         if IInterface.providedBy(args[0]):\n             form_interface = args[0]\n@@ -37,13 +32,12 @@ def factory(self, *args):\n \n \n class no_omit(omitted):\n-    """Directive used to prevent one or more fields from being omitted\n-    """\n-    value = \'false\'\n+    """Directive used to prevent one or more fields from being omitted"""\n \n+    value = "false"\n \n-class OmittedPlugin(ListCheckerPlugin):\n \n+class OmittedPlugin(ListCheckerPlugin):\n     key = OMITTED_KEY\n \n     def fieldNames(self):\n@@ -54,15 +48,13 @@ def fieldNames(self):\n \n \n class mode(MetadataListDirective):\n-    """Directive used to set the mode of one or more fields\n-    """\n+    """Directive used to set the mode of one or more fields"""\n+\n     key = MODES_KEY\n \n     def factory(self, *args, **kw):\n         if len(args) > 1:\n-            raise TypeError(\n-                \'The mode directive expects 0 or 1 non-keyword arguments.\'\n-            )\n+            raise TypeError("The mode directive expects 0 or 1 non-keyword arguments.")\n         form_interface = Interface\n         if args:\n             form_interface = args[0]\n@@ -121,19 +113,16 @@ def factory(self, field_name=None, widget_class=None, **kw):\n \n         if field_name is None:  # Usage 3\n             for field_name, widget in kw.items():\n-                if not isinstance(widget, six.string_types):\n-                    widget = \'{0}.{1}\'.format(\n-                        widget.__module__,\n-                        widget.__name__\n-                    )\n+                if not isinstance(widget, str):\n+                    widget = f"{widget.__module__}.{widget.__name__}"\n                 widgets[field_name] = widget\n         else:\n-            if widget_class is not None \\\n-               and not IFieldWidget.implementedBy(widget_class) \\\n-               and not IWidget.implementedBy(widget_class):\n-                raise TypeError(\n-                    \'widget_class must implement IWidget or IFieldWidget\'\n-                )\n+            if (\n+                widget_class is not None\n+                and not IFieldWidget.implementedBy(widget_class)\n+                and not IWidget.implementedBy(widget_class)\n+            ):\n+                raise TypeError("widget_class must implement IWidget or IFieldWidget")\n             widgets[field_name] = ParameterizedWidget(widget_class, **kw)\n \n         return widgets\n@@ -144,23 +133,26 @@ class WidgetPlugin(DictCheckerPlugin):\n \n \n class order_before(MetadataListDirective):\n-    """Directive used to order one field before another\n-    """\n+    """Directive used to order one field before another"""\n+\n     key = ORDER_KEY\n \n     def factory(self, **kw):\n-        return [(field_name, \'before\', relative_to)\n-                for field_name, relative_to in kw.items()]\n+        return [\n+            (field_name, "before", relative_to)\n+            for field_name, relative_to in kw.items()\n+        ]\n \n \n class order_after(MetadataListDirective):\n-    """Directive used to order one field after another\n-    """\n+    """Directive used to order one field after another"""\n+\n     key = ORDER_KEY\n \n     def factory(self, **kw):\n-        return [(field_name, \'after\', relative_to)\n-                for field_name, relative_to in kw.items()]\n+        return [\n+            (field_name, "after", relative_to) for field_name, relative_to in kw.items()\n+        ]\n \n \n class OrderPlugin(ListCheckerPlugin):\n@@ -174,8 +166,8 @@ def fieldNames(self):\n \n \n class read_permission(MetadataDictDirective):\n-    """Directive used to set a field read permission\n-    """\n+    """Directive used to set a field read permission"""\n+\n     key = READ_PERMISSIONS_KEY\n \n     def factory(self, **kw):\n@@ -183,8 +175,8 @@ def factory(self, **kw):\n \n \n class write_permission(read_permission):\n-    """Directive used to set a field write permission\n-    """\n+    """Directive used to set a field write permission"""\n+\n     key = WRITE_PERMISSIONS_KEY\n \n \ndiff --git a/plone/autoform/form.py b/plone/autoform/form.py\nindex 818bcfc..66b5187 100644\n--- a/plone/autoform/form.py\n+++ b/plone/autoform/form.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.base import AutoFields\n from plone.autoform.interfaces import IAutoExtensibleForm\n from plone.autoform.interfaces import IAutoObjectSubForm\n@@ -20,19 +19,18 @@ class AutoExtensibleForm(AutoFields, ExtensibleForm):\n     @property\n     def schema(self):\n         raise NotImplementedError(\n-            \'The class deriving from AutoExtensibleForm must have a \'\n-            \'\\\'schema\\\' property\'\n+            "The class deriving from AutoExtensibleForm must have a "\n+            "\'schema\' property"\n         )\n \n     @property\n     def additionalSchemata(self):\n-        """Default to there being no additional schemata\n-        """\n+        """Default to there being no additional schemata"""\n         return ()\n \n     def updateFields(self):\n         self.updateFieldsFromSchemata()\n-        super(AutoExtensibleForm, self).updateFields()\n+        super().updateFields()\n \n \n @implementer(IAutoObjectSubForm)\ndiff --git a/plone/autoform/interfaces.py b/plone/autoform/interfaces.py\nindex 8364b9a..75c65a1 100644\n--- a/plone/autoform/interfaces.py\n+++ b/plone/autoform/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.supermodel.interfaces import IFieldset\n from z3c.form.interfaces import IDisplayForm\n from z3c.form.interfaces import IFieldsForm\n@@ -11,26 +10,25 @@\n \n \n # Schema interface tagged value keys\n-MODES_KEY = u\'plone.autoform.modes\'\n-OMITTED_KEY = u\'plone.autoform.omitted\'\n-ORDER_KEY = u\'plone.autoform.order\'\n-WIDGETS_KEY = u\'plone.autoform.widgets\'\n+MODES_KEY = "plone.autoform.modes"\n+OMITTED_KEY = "plone.autoform.omitted"\n+ORDER_KEY = "plone.autoform.order"\n+WIDGETS_KEY = "plone.autoform.widgets"\n \n-READ_PERMISSIONS_KEY = u\'plone.autoform.security.read-permissions\'\n-WRITE_PERMISSIONS_KEY = u\'plone.autoform.security.write-permissions\'\n+READ_PERMISSIONS_KEY = "plone.autoform.security.read-permissions"\n+WRITE_PERMISSIONS_KEY = "plone.autoform.security.write-permissions"\n \n # Supermodel namespace and prefix\n \n-FORM_NAMESPACE = \'http://namespaces.plone.org/supermodel/form\'\n-FORM_PREFIX = \'form\'\n+FORM_NAMESPACE = "http://namespaces.plone.org/supermodel/form"\n+FORM_PREFIX = "form"\n \n-SECURITY_NAMESPACE = \'http://namespaces.plone.org/supermodel/security\'\n-SECURITY_PREFIX = \'security\'\n+SECURITY_NAMESPACE = "http://namespaces.plone.org/supermodel/security"\n+SECURITY_PREFIX = "security"\n \n \n class IFormFieldProvider(Interface):\n-    """Marker interface for schemata that provide form fields.\n-    """\n+    """Marker interface for schemata that provide form fields."""\n \n \n class IAutoExtensibleForm(Interface):\n@@ -42,22 +40,15 @@ class IAutoExtensibleForm(Interface):\n     """\n \n     ignorePrefix = zope.schema.Bool(\n-        title=u\'Do not set a prefix for additional schemata\',\n-        default=False\n+        title="Do not set a prefix for additional schemata", default=False\n     )\n \n-    schema = zope.schema.Object(\n-        title=u\'Schema providing form fields\',\n-        schema=IInterface\n-    )\n+    schema = zope.schema.Object(title="Schema providing form fields", schema=IInterface)\n \n     additionalSchemata = zope.schema.Tuple(\n-        title=u\'Supplementary schemata providing additional form fields\',\n-        value_type=zope.schema.Object(\n-            title=u\'Schema interface\',\n-            schema=IInterface\n-        ),\n-        required=False\n+        title="Supplementary schemata providing additional form fields",\n+        value_type=zope.schema.Object(title="Schema interface", schema=IInterface),\n+        required=False,\n     )\n \n \n@@ -66,10 +57,7 @@ class IAutoObjectSubForm(Interface):\n     to also have its fields updated with form hints. See subform.txt\n     """\n \n-    schema = zope.schema.Object(\n-        title=u\'Schema providing form fields\',\n-        schema=IInterface\n-    )\n+    schema = zope.schema.Object(title="Schema providing form fields", schema=IInterface)\n \n \n class IWidgetsView(IAutoExtensibleForm, IFieldsForm, IDisplayForm):\n@@ -78,27 +66,17 @@ class IWidgetsView(IAutoExtensibleForm, IFieldsForm, IDisplayForm):\n     """\n \n     w = zope.schema.Dict(\n-        title=u\'Shortcut lookup for all widgets\',\n-        description=u\'Contains all widgets, including those from groups \'\n-                    u\'within this form\',\n-        key_type=zope.schema.ASCIILine(\n-            title=u\'Widget name, with prefix\'\n-        ),\n-        value_type=zope.schema.Object(\n-            title=u\'Widget\',\n-            schema=IWidget\n-        )\n+        title="Shortcut lookup for all widgets",\n+        description="Contains all widgets, including those from groups "\n+        "within this form",\n+        key_type=zope.schema.ASCIILine(title="Widget name, with prefix"),\n+        value_type=zope.schema.Object(title="Widget", schema=IWidget),\n     )\n \n     fieldsets = zope.schema.Dict(\n-        title=u\'Lookup fieldset (group) by name\',\n-        key_type=zope.schema.ASCIILine(\n-            title=u\'Fieldset name\'\n-        ),\n-        value_type=zope.schema.Object(\n-            title=u\'Fieldset\',\n-            schema=IFieldset\n-        )\n+        title="Lookup fieldset (group) by name",\n+        key_type=zope.schema.ASCIILine(title="Fieldset name"),\n+        value_type=zope.schema.Object(title="Fieldset", schema=IFieldset),\n     )\n \n \ndiff --git a/plone/autoform/supermodel.py b/plone/autoform/supermodel.py\nindex 16211fb..6764dfb 100644\n--- a/plone/autoform/supermodel.py\n+++ b/plone/autoform/supermodel.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from lxml import etree\n from plone.autoform.interfaces import FORM_NAMESPACE\n from plone.autoform.interfaces import FORM_PREFIX\n@@ -24,9 +23,8 @@\n \n \n @implementer(IFieldMetadataHandler)\n-class FormSchema(object):\n-    """Support the form: namespace in model definitions.\n-    """\n+class FormSchema:\n+    """Support the form: namespace in model definitions."""\n \n     namespace = FORM_NAMESPACE\n     prefix = FORM_PREFIX\n@@ -38,20 +36,18 @@ def _add(self, schema, key, name, value):\n \n     def _add_order(self, schema, name, direction, relative_to):\n         tagged_value = schema.queryTaggedValue(ORDER_KEY, [])\n-        tagged_value.append((name, direction, relative_to,))\n+        tagged_value.append((name, direction, relative_to))\n         schema.setTaggedValue(ORDER_KEY, tagged_value)\n \n     def _add_interface_values(self, schema, key, name, values):\n         tagged_value = schema.queryTaggedValue(key, [])\n-        values = values.split(\' \')\n+        values = values.split(" ")\n         for value in values:\n-            if \':\' in value:\n-                (interface_dotted_name, value) = value.split(\':\')\n+            if ":" in value:\n+                (interface_dotted_name, value) = value.split(":")\n                 interface = resolveDottedName(interface_dotted_name)\n                 if not isinstance(interface, InterfaceClass):\n-                    raise ValueError(\n-                        \'{0} not an Interface.\'.format(interface_dotted_name)\n-                    )\n+                    raise ValueError(f"{interface_dotted_name} not an Interface.")\n             else:\n                 interface = Interface\n             tagged_value.append((interface, name, value))\n@@ -60,7 +56,7 @@ def _add_interface_values(self, schema, key, name, values):\n     def _add_validator(self, field, value):\n         validator = resolveDottedName(value)\n         if not IValidator.implementedBy(validator):\n-            msg = \'z3c.form.interfaces.IValidator not implemented by {0}.\'\n+            msg = "z3c.form.interfaces.IValidator not implemented by {0}."\n             raise ValueError(msg.format(value))\n         provideAdapter(\n             validator,\n@@ -71,28 +67,28 @@ def _add_validator(self, field, value):\n     def read(self, fieldNode, schema, field):\n         name = field.__name__\n \n-        widgetAttr = fieldNode.get(ns(\'widget\', self.namespace))\n-        mode = fieldNode.get(ns(\'mode\', self.namespace))\n-        omitted = fieldNode.get(ns(\'omitted\', self.namespace))\n-        before = fieldNode.get(ns(\'before\', self.namespace))\n-        after = fieldNode.get(ns(\'after\', self.namespace))\n-        validator = fieldNode.get(ns(\'validator\', self.namespace))\n+        widgetAttr = fieldNode.get(ns("widget", self.namespace))\n+        mode = fieldNode.get(ns("mode", self.namespace))\n+        omitted = fieldNode.get(ns("omitted", self.namespace))\n+        before = fieldNode.get(ns("before", self.namespace))\n+        after = fieldNode.get(ns("after", self.namespace))\n+        validator = fieldNode.get(ns("validator", self.namespace))\n \n         if mode:\n             self._add_interface_values(schema, MODES_KEY, name, mode)\n         if omitted:\n             self._add_interface_values(schema, OMITTED_KEY, name, omitted)\n         if before:\n-            self._add_order(schema, name, \'before\', before)\n+            self._add_order(schema, name, "before", before)\n         if after:\n-            self._add_order(schema, name, \'after\', after)\n+            self._add_order(schema, name, "after", after)\n         if validator:\n             self._add_validator(field, validator)\n \n-        widgetNode = fieldNode.find(ns(\'widget\', self.namespace))\n+        widgetNode = fieldNode.find(ns("widget", self.namespace))\n         widget = None\n         if widgetNode is not None:  # form:widget element\n-            widgetFactory = widgetNode.get(\'type\')\n+            widgetFactory = widgetNode.get("type")\n             if widgetFactory is not None:\n                 # resolve immediately so we don\'t have to each time\n                 # form is rendered\n@@ -103,9 +99,7 @@ def read(self, fieldNode, schema, field):\n         elif widgetAttr is not None:  # BBB for old form:widget attributes\n             obj = resolveDottedName(widgetAttr)\n             if not IFieldWidget.implementedBy(obj):\n-                raise ValueError(\n-                    \'IFieldWidget not implemented by {0}\'.format(obj)\n-                )\n+                raise ValueError(f"IFieldWidget not implemented by {obj}")\n             widget = widgetAttr\n         if widget is not None:\n             self._add(schema, WIDGETS_KEY, name, widget)\n@@ -115,16 +109,13 @@ def write(self, fieldNode, schema, field):\n \n         widget = schema.queryTaggedValue(WIDGETS_KEY, {}).get(name, None)\n         mode = [\n-            (i, v) for i, n, v in schema.queryTaggedValue(MODES_KEY, [])\n-            if n == name\n+            (i, v) for i, n, v in schema.queryTaggedValue(MODES_KEY, []) if n == name\n         ]\n         omitted = [\n-            (i, v) for i, n, v in schema.queryTaggedValue(OMITTED_KEY, [])\n-            if n == name\n+            (i, v) for i, n, v in schema.queryTaggedValue(OMITTED_KEY, []) if n == name\n         ]\n         order = [\n-            (d, v) for n, d, v in schema.queryTaggedValue(ORDER_KEY, [])\n-            if n == name\n+            (d, v) for n, d, v in schema.queryTaggedValue(ORDER_KEY, []) if n == name\n         ]\n \n         if widget is not None:\n@@ -132,10 +123,10 @@ def write(self, fieldNode, schema, field):\n                 widget = ParameterizedWidget(widget)\n \n             if widget.widget_factory or widget.params:\n-                widgetNode = etree.Element(ns(\'widget\', self.namespace))\n+                widgetNode = etree.Element(ns("widget", self.namespace))\n                 widgetName = widget.getWidgetFactoryName()\n                 if widgetName is not None:\n-                    widgetNode.set(\'type\', widgetName)\n+                    widgetNode.set("type", widgetName)\n \n                 widgetHandler = widget.getExportImportHandler(field)\n                 widgetHandler.write(widgetNode, widget.params)\n@@ -144,33 +135,29 @@ def write(self, fieldNode, schema, field):\n         mode_values = []\n         for interface, value in mode:\n             if interface is not Interface:\n-                value = \'{0}:{1}\'.format(interface.__identifier__, value)\n+                value = f"{interface.__identifier__}:{value}"\n             mode_values.append(value)\n         if mode_values:\n-            fieldNode.set(ns(\'mode\', self.namespace), \' \'.join(mode_values))\n+            fieldNode.set(ns("mode", self.namespace), " ".join(mode_values))\n \n         omitted_values = []\n         for interface, value in omitted:\n             if interface is not Interface:\n-                value = \'{0}:{1}\'.format(interface.__identifier__, value)\n+                value = f"{interface.__identifier__}:{value}"\n             omitted_values.append(value)\n         if omitted_values:\n-            fieldNode.set(\n-                ns(\'omitted\', self.namespace),\n-                \' \'.join(omitted_values)\n-            )\n+            fieldNode.set(ns("omitted", self.namespace), " ".join(omitted_values))\n \n         for direction, relative_to in order:\n-            if direction == \'before\':\n-                fieldNode.set(ns(\'before\', self.namespace), relative_to)\n-            elif direction == \'after\':\n-                fieldNode.set(ns(\'after\', self.namespace), relative_to)\n+            if direction == "before":\n+                fieldNode.set(ns("before", self.namespace), relative_to)\n+            elif direction == "after":\n+                fieldNode.set(ns("after", self.namespace), relative_to)\n \n \n @implementer(IFieldMetadataHandler)\n-class SecuritySchema(object):\n-    """Support the security: namespace in model definitions.\n-    """\n+class SecuritySchema:\n+    """Support the security: namespace in model definitions."""\n \n     namespace = SECURITY_NAMESPACE\n     prefix = SECURITY_PREFIX\n@@ -178,10 +165,8 @@ class SecuritySchema(object):\n     def read(self, fieldNode, schema, field):\n         name = field.__name__\n \n-        read_permission = fieldNode.get(ns(\'read-permission\', self.namespace))\n-        write_permission = fieldNode.get(\n-            ns(\'write-permission\', self.namespace)\n-        )\n+        read_permission = fieldNode.get(ns("read-permission", self.namespace))\n+        write_permission = fieldNode.get(ns("write-permission", self.namespace))\n \n         read_permissions = schema.queryTaggedValue(READ_PERMISSIONS_KEY, {})\n         write_permissions = schema.queryTaggedValue(WRITE_PERMISSIONS_KEY, {})\n@@ -197,21 +182,14 @@ def read(self, fieldNode, schema, field):\n     def write(self, fieldNode, schema, field):\n         name = field.__name__\n \n-        read_permission = schema.queryTaggedValue(\n-            READ_PERMISSIONS_KEY, {}\n-        ).get(name, None)\n-        write_permission = schema.queryTaggedValue(\n-            WRITE_PERMISSIONS_KEY,\n-            {}\n-        ).get(name, None)\n+        read_permission = schema.queryTaggedValue(READ_PERMISSIONS_KEY, {}).get(\n+            name, None\n+        )\n+        write_permission = schema.queryTaggedValue(WRITE_PERMISSIONS_KEY, {}).get(\n+            name, None\n+        )\n \n         if read_permission:\n-            fieldNode.set(\n-                ns(\'read-permission\', self.namespace),\n-                read_permission\n-            )\n+            fieldNode.set(ns("read-permission", self.namespace), read_permission)\n         if write_permission:\n-            fieldNode.set(\n-                ns(\'write-permission\', self.namespace),\n-                write_permission\n-            )\n+            fieldNode.set(ns("write-permission", self.namespace), write_permission)\ndiff --git a/plone/autoform/supermodel.txt b/plone/autoform/supermodel.txt\nindex c823ed5..14491fa 100644\n--- a/plone/autoform/supermodel.txt\n+++ b/plone/autoform/supermodel.txt\n@@ -19,8 +19,7 @@ First, let\'s load this package\'s ZCML so that we can run the tests:\n     ...\n     ... </configure>\n     ... """\n-    >>> import six\n-    >>> from six import StringIO\n+    >>> from io import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \ndiff --git a/plone/autoform/testing.py b/plone/autoform/testing.py\nindex bd5b24a..20be3b5 100644\n--- a/plone/autoform/testing.py\n+++ b/plone/autoform/testing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.testing import z2\n from plone.testing import zca\n \n@@ -8,15 +7,13 @@\n \n AUTOFORM_FIXTURE = zca.ZCMLSandbox(\n     bases=(z2.STARTUP,),\n-    filename=\'configure.zcml\',\n+    filename="configure.zcml",\n     package=plone.autoform,\n-    name=\'plone.autoform:Fixture\')\n+    name="plone.autoform:Fixture",\n+)\n \n AUTOFORM_INTEGRATION_TESTING = z2.IntegrationTesting(\n-    bases=(AUTOFORM_FIXTURE,),\n-    name=\'plone.autoform:Integration\')\n-\n-optionflags = (\n-    doctest.NORMALIZE_WHITESPACE\n-    | doctest.ELLIPSIS\n+    bases=(AUTOFORM_FIXTURE,), name="plone.autoform:Integration"\n )\n+\n+optionflags = doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS\ndiff --git a/plone/autoform/tests/__init__.py b/plone/autoform/tests/__init__.py\nindex 40a96af..e69de29 100644\n--- a/plone/autoform/tests/__init__.py\n+++ b/plone/autoform/tests/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/autoform/tests/subform.txt b/plone/autoform/tests/subform.txt\nindex 96dc447..dc0488f 100644\n--- a/plone/autoform/tests/subform.txt\n+++ b/plone/autoform/tests/subform.txt\n@@ -36,8 +36,7 @@ First, let\'s load this package\'s ZCML so that we can run the tests:\n     ...\n     ... </configure>\n     ... """\n-    >>> import six\n-    >>> from six import StringIO\n+    >>> from io import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \ndiff --git a/plone/autoform/tests/test_base.py b/plone/autoform/tests/test_base.py\nindex 602fec3..e64f283 100644\n--- a/plone/autoform/tests/test_base.py\n+++ b/plone/autoform/tests/test_base.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from collections import OrderedDict\n from plone.testing.zca import UNIT_TESTING\n \n@@ -6,122 +5,130 @@\n \n \n class TestBase(unittest.TestCase):\n-\n     layer = UNIT_TESTING\n \n     def test_calc_field_move_basics(self):\n         from plone.autoform.base import AutoFields\n+\n         autofields = AutoFields()\n \n         # we have a schema with fields [a, b, c]\n         # field \'c\' after \'a\'\n-        order = [(\'c\', \'after\', \'a\'), ]\n+        order = [\n+            ("c", "after", "a"),\n+        ]\n         rules = autofields._calculate_field_moves(order)\n-        self.assertIn(\'a\', rules)\n-        self.assertNotIn(\'c\', rules)\n-        self.assertIn(\'with\', rules[\'a\'])\n-        self.assertIn(\'stub\', rules[\'a\'])\n-        self.assertIn(\'c\', rules[\'a\'][\'with\'])\n-        self.assertIn(\'parent\', rules[\'a\'][\'with\'][\'c\'])\n-        self.assertIs(rules[\'a\'], rules[\'a\'][\'with\'][\'c\'][\'parent\'])\n-        self.assertIn(\'target\', rules[\'a\'][\'with\'][\'c\'])\n-        self.assertIn(\'dir\', rules[\'a\'][\'with\'][\'c\'])\n+        self.assertIn("a", rules)\n+        self.assertNotIn("c", rules)\n+        self.assertIn("with", rules["a"])\n+        self.assertIn("stub", rules["a"])\n+        self.assertIn("c", rules["a"]["with"])\n+        self.assertIn("parent", rules["a"]["with"]["c"])\n+        self.assertIs(rules["a"], rules["a"]["with"]["c"]["parent"])\n+        self.assertIn("target", rules["a"]["with"]["c"])\n+        self.assertIn("dir", rules["a"]["with"]["c"])\n \n     def test_calc_field_move_simple_dependency(self):\n         from plone.autoform.base import AutoFields\n+\n         autofields = AutoFields()\n \n         # we have a schema with fields [a, b, c]\n         # field a after b and field \'c\' after \'a\'\n         order = [\n-            (\'a\', \'after\', \'b\'),\n-            (\'c\', \'after\', \'a\'),\n+            ("a", "after", "b"),\n+            ("c", "after", "a"),\n         ]\n         expected = {\n-            \'stub\': True,\n-            \'with\': OrderedDict(\n+            "stub": True,\n+            "with": OrderedDict(\n                 [\n                     (\n-                        \'a\',\n+                        "a",\n                         {\n-                            \'with\': OrderedDict(\n-                                [(\'c\', {\'target\': \'a\', \'dir\': \'after\'})]\n+                            "with": OrderedDict(\n+                                [("c", {"target": "a", "dir": "after"})]\n                             ),\n-                            \'target\': \'b\', \'dir\': \'after\'}\n+                            "target": "b",\n+                            "dir": "after",\n+                        },\n                     ),\n                 ]\n-            )\n+            ),\n         }\n         rules = autofields._calculate_field_moves(order)\n-        self.assertIn(\'b\', rules)\n-        self.assertNotIn(\'a\', rules)\n-        self.assertNotIn(\'c\', rules)\n+        self.assertIn("b", rules)\n+        self.assertNotIn("a", rules)\n+        self.assertNotIn("c", rules)\n \n         # remove parent key enable comparison of  dicts\n-        del rules[\'__all__\'][\'a\'][\'parent\']\n-        del rules[\'__all__\'][\'c\'][\'parent\']\n-        self.assertEqual(rules[\'b\'], expected)\n+        del rules["__all__"]["a"]["parent"]\n+        del rules["__all__"]["c"]["parent"]\n+        self.assertEqual(rules["b"], expected)\n \n         # we have a schema with fields [a, b, c]\n         # vice versa defined now, must lead to same result\n         # field \'c\' after \'a\' and field a after b\n         order = reversed(order)\n         rules = autofields._calculate_field_moves(order)\n-        self.assertIn(\'b\', rules)\n-        self.assertNotIn(\'a\', rules)\n-        self.assertNotIn(\'c\', rules)\n+        self.assertIn("b", rules)\n+        self.assertNotIn("a", rules)\n+        self.assertNotIn("c", rules)\n \n         # remove parent key enable comparison of  dicts\n-        del rules[\'__all__\'][\'a\'][\'parent\']\n-        del rules[\'__all__\'][\'c\'][\'parent\']\n-        self.assertEqual(rules[\'b\'], expected)\n+        del rules["__all__"]["a"]["parent"]\n+        del rules["__all__"]["c"]["parent"]\n+        self.assertEqual(rules["b"], expected)\n \n     def test_calc_field_move_multiple_dependencies(self):\n         from plone.autoform.base import AutoFields\n+\n         autofields = AutoFields()\n \n         order = [\n-            (\'a\', \'after\', \'b\'),\n-            (\'c\', \'after\', \'a\'),\n-            (\'d\', \'after\', \'c\'),\n-            (\'z\', \'after\', \'x\'),\n-            (\'x\', \'after\', \'y\'),\n+            ("a", "after", "b"),\n+            ("c", "after", "a"),\n+            ("d", "after", "c"),\n+            ("z", "after", "x"),\n+            ("x", "after", "y"),\n         ]\n         rules = autofields._calculate_field_moves(order)\n-        self.assertIn(\'b\', rules)\n-        self.assertIn(\'y\', rules)\n-        self.assertNotIn(\'a\', rules)\n-        self.assertNotIn(\'c\', rules)\n-        self.assertNotIn(\'d\', rules)\n-        self.assertNotIn(\'z\', rules)\n-        self.assertNotIn(\'x\', rules)\n+        self.assertIn("b", rules)\n+        self.assertIn("y", rules)\n+        self.assertNotIn("a", rules)\n+        self.assertNotIn("c", rules)\n+        self.assertNotIn("d", rules)\n+        self.assertNotIn("z", rules)\n+        self.assertNotIn("x", rules)\n \n-        self.assertIn(\'a\', rules[\'b\'][\'with\'])\n-        self.assertEqual(1, len(rules[\'b\'][\'with\']))\n+        self.assertIn("a", rules["b"]["with"])\n+        self.assertEqual(1, len(rules["b"]["with"]))\n \n-        self.assertIn(\'c\', rules[\'b\'][\'with\'][\'a\'][\'with\'])\n-        self.assertEqual(1, len(rules[\'b\'][\'with\'][\'a\'][\'with\']))\n+        self.assertIn("c", rules["b"]["with"]["a"]["with"])\n+        self.assertEqual(1, len(rules["b"]["with"]["a"]["with"]))\n \n-        self.assertIn(\'d\', rules[\'b\'][\'with\'][\'a\'][\'with\'][\'c\'][\'with\'])\n-        self.assertEqual(1, len(rules[\'b\'][\'with\'][\'a\'][\'with\'][\'c\'][\'with\']))\n+        self.assertIn("d", rules["b"]["with"]["a"]["with"]["c"]["with"])\n+        self.assertEqual(1, len(rules["b"]["with"]["a"]["with"]["c"]["with"]))\n \n     def test_calc_field_move_override(self):\n         from plone.autoform.base import AutoFields\n+\n         autofields = AutoFields()\n \n         order = [\n-            (\'c\', \'after\', \'a\'),\n-            (\'a\', \'after\', \'b\'),\n-            (\'c\', \'after\', \'z\'),\n+            ("c", "after", "a"),\n+            ("a", "after", "b"),\n+            ("c", "after", "z"),\n         ]\n         rules = autofields._calculate_field_moves(order)\n-        self.assertIn(\'b\', rules)\n-        self.assertIn(\'z\', rules)\n-        self.assertNotIn(\'a\', rules)\n-        self.assertNotIn(\'c\', rules)\n+        self.assertIn("b", rules)\n+        self.assertIn("z", rules)\n+        self.assertNotIn("a", rules)\n+        self.assertNotIn("c", rules)\n \n     def test_updateFieldsFromSchemata(self):\n         from plone.autoform.base import AutoFields\n+\n         autofields = AutoFields()\n         autofields.request = {}\n         autofields.updateFieldsFromSchemata()\ndiff --git a/plone/autoform/tests/test_directives.py b/plone/autoform/tests/test_directives.py\nindex db2df1d..d7b77b3 100644\n--- a/plone/autoform/tests/test_directives.py\n+++ b/plone/autoform/tests/test_directives.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform import directives as form\n from plone.autoform.interfaces import MODES_KEY\n from plone.autoform.interfaces import OMITTED_KEY\n@@ -14,197 +13,217 @@\n import zope.schema\n \n \n-class DummyWidget(object):\n+class DummyWidget:\n     pass\n \n \n class TestSchemaDirectives(unittest.TestCase):\n-\n     layer = AUTOFORM_INTEGRATION_TESTING\n \n     def test_schema_directives_store_tagged_values(self):\n-\n         class IDummy(model.Schema):\n-\n-            form.omitted(\'foo\', \'bar\')\n-            form.omitted(model.Schema, \'qux\')\n-            form.no_omit(model.Schema, \'bar\')\n-            form.widget(foo=\'some.dummy.Widget\', baz=\'other.Widget\')\n-            form.mode(bar=\'hidden\')\n-            form.mode(model.Schema, bar=\'input\')\n-            form.order_before(baz=\'title\')\n-            form.order_after(qux=\'title\')\n-            form.read_permission(foo=\'zope2.View\')\n-            form.write_permission(foo=\'cmf.ModifyPortalContent\')\n-\n-            foo = zope.schema.TextLine(title=u\'Foo\')\n-            bar = zope.schema.TextLine(title=u\'Bar\')\n-            baz = zope.schema.TextLine(title=u\'Baz\')\n-            qux = zope.schema.TextLine(title=u\'Qux\')\n+            form.omitted("foo", "bar")\n+            form.omitted(model.Schema, "qux")\n+            form.no_omit(model.Schema, "bar")\n+            form.widget(foo="some.dummy.Widget", baz="other.Widget")\n+            form.mode(bar="hidden")\n+            form.mode(model.Schema, bar="input")\n+            form.order_before(baz="title")\n+            form.order_after(qux="title")\n+            form.read_permission(foo="zope2.View")\n+            form.write_permission(foo="cmf.ModifyPortalContent")\n+\n+            foo = zope.schema.TextLine(title="Foo")\n+            bar = zope.schema.TextLine(title="Bar")\n+            baz = zope.schema.TextLine(title="Baz")\n+            qux = zope.schema.TextLine(title="Qux")\n \n         model.finalizeSchemas(IDummy)\n \n-        self.assertEqual({\'foo\': \'some.dummy.Widget\',\n-                          \'baz\': \'other.Widget\'},\n-                         IDummy.queryTaggedValue(WIDGETS_KEY))\n-        self.assertEqual([(Interface, \'foo\', \'true\'),\n-                          (Interface, \'bar\', \'true\'),\n-                          (model.Schema, \'qux\', \'true\'),\n-                          (model.Schema, \'bar\', \'false\')],\n-                         IDummy.queryTaggedValue(OMITTED_KEY))\n-        self.assertEqual([(Interface, \'bar\', \'hidden\'),\n-                          (model.Schema, \'bar\', \'input\')],\n-                         IDummy.queryTaggedValue(MODES_KEY))\n-        self.assertEqual([(\'baz\', \'before\', \'title\',),\n-                          (\'qux\', \'after\', \'title\')],\n-                         IDummy.queryTaggedValue(ORDER_KEY))\n-        self.assertEqual({\'foo\': \'zope2.View\'},\n-                         IDummy.queryTaggedValue(READ_PERMISSIONS_KEY))\n-        self.assertEqual({\'foo\': \'cmf.ModifyPortalContent\'},\n-                         IDummy.queryTaggedValue(WRITE_PERMISSIONS_KEY))\n+        self.assertEqual(\n+            {"foo": "some.dummy.Widget", "baz": "other.Widget"},\n+            IDummy.queryTaggedValue(WIDGETS_KEY),\n+        )\n+        self.assertEqual(\n+            [\n+                (Interface, "foo", "true"),\n+                (Interface, "bar", "true"),\n+                (model.Schema, "qux", "true"),\n+                (model.Schema, "bar", "false"),\n+            ],\n+            IDummy.queryTaggedValue(OMITTED_KEY),\n+        )\n+        self.assertEqual(\n+            [(Interface, "bar", "hidden"), (model.Schema, "bar", "input")],\n+            IDummy.queryTaggedValue(MODES_KEY),\n+        )\n+        self.assertEqual(\n+            [\n+                (\n+                    "baz",\n+                    "before",\n+                    "title",\n+                ),\n+                ("qux", "after", "title"),\n+            ],\n+            IDummy.queryTaggedValue(ORDER_KEY),\n+        )\n+        self.assertEqual(\n+            {"foo": "zope2.View"}, IDummy.queryTaggedValue(READ_PERMISSIONS_KEY)\n+        )\n+        self.assertEqual(\n+            {"foo": "cmf.ModifyPortalContent"},\n+            IDummy.queryTaggedValue(WRITE_PERMISSIONS_KEY),\n+        )\n \n     def test_widget_supports_instances_and_strings(self):\n-\n         class IDummy(model.Schema):\n             form.widget(foo=DummyWidget)\n \n-            foo = zope.schema.TextLine(title=u\'Foo\')\n-            bar = zope.schema.TextLine(title=u\'Bar\')\n-            baz = zope.schema.TextLine(title=u\'Baz\')\n+            foo = zope.schema.TextLine(title="Foo")\n+            bar = zope.schema.TextLine(title="Bar")\n+            baz = zope.schema.TextLine(title="Baz")\n \n         self.assertEqual(\n-            {\'foo\': \'plone.autoform.tests.test_directives.DummyWidget\'},\n-            IDummy.queryTaggedValue(WIDGETS_KEY)\n+            {"foo": "plone.autoform.tests.test_directives.DummyWidget"},\n+            IDummy.queryTaggedValue(WIDGETS_KEY),\n         )\n \n     def test_widget_parameterized(self):\n-        from zope.interface import implementer\n-        from z3c.form.interfaces import IWidget\n         from plone.autoform.widgets import ParameterizedWidget\n+        from z3c.form.interfaces import IWidget\n+        from zope.interface import implementer\n \n         @implementer(IWidget)\n-        class DummyWidget(object):\n-\n+        class DummyWidget:\n             def __init__(self, request):\n                 pass\n \n         class IDummy(model.Schema):\n-            form.widget(\'foo\', DummyWidget, foo=\'bar\')\n-            foo = zope.schema.TextLine(title=u\'Foo\')\n+            form.widget("foo", DummyWidget, foo="bar")\n+            foo = zope.schema.TextLine(title="Foo")\n \n         tv = IDummy.queryTaggedValue(WIDGETS_KEY)\n-        self.assertTrue(isinstance(tv[\'foo\'], ParameterizedWidget))\n-        self.assertTrue(tv[\'foo\'].widget_factory is DummyWidget)\n-        self.assertEqual(\'bar\', tv[\'foo\'].params[\'foo\'])\n+        self.assertTrue(isinstance(tv["foo"], ParameterizedWidget))\n+        self.assertTrue(tv["foo"].widget_factory is DummyWidget)\n+        self.assertEqual("bar", tv["foo"].params["foo"])\n \n     def test_widget_parameterized_default_widget_factory(self):\n-        from zope.interface import implementer\n-        from z3c.form.interfaces import IWidget\n         from plone.autoform.widgets import ParameterizedWidget\n+        from z3c.form.interfaces import IWidget\n+        from zope.interface import implementer\n \n         @implementer(IWidget)\n-        class DummyWidget(object):\n-\n+        class DummyWidget:\n             def __init__(self, request):\n                 pass\n \n         class IDummy(model.Schema):\n-            form.widget(\'foo\', foo=\'bar\')\n-            foo = zope.schema.TextLine(title=u\'Foo\')\n+            form.widget("foo", foo="bar")\n+            foo = zope.schema.TextLine(title="Foo")\n \n         tv = IDummy.queryTaggedValue(WIDGETS_KEY)\n-        self.assertTrue(isinstance(tv[\'foo\'], ParameterizedWidget))\n-        self.assertTrue(tv[\'foo\'].widget_factory is None)\n-        self.assertEqual(\'bar\', tv[\'foo\'].params[\'foo\'])\n+        self.assertTrue(isinstance(tv["foo"], ParameterizedWidget))\n+        self.assertTrue(tv["foo"].widget_factory is None)\n+        self.assertEqual("bar", tv["foo"].params["foo"])\n \n     def test_widget_parameterized_wrong_type(self):\n         try:\n+\n             class IDummy(model.Schema):\n-                form.widget(\'foo\', object())\n+                form.widget("foo", object())\n+\n         except TypeError:\n             pass\n         else:\n-            self.fail(\'Expected TypeError\')\n+            self.fail("Expected TypeError")\n \n     def test_multiple_invocations(self):\n-\n         class IDummy(model.Schema):\n+            form.omitted("foo")\n+            form.omitted("bar")\n+            form.widget(foo="some.dummy.Widget")\n+            form.widget(baz="other.Widget")\n+            form.mode(bar="hidden")\n+            form.mode(foo="display")\n+            form.order_before(baz="title")\n+            form.order_after(baz="qux")\n+            form.order_after(qux="bar")\n+            form.order_before(foo="body")\n+            form.read_permission(foo="zope2.View", bar="zope2.View")\n+            form.read_permission(baz="random.Permission")\n+            form.write_permission(foo="cmf.ModifyPortalContent")\n+            form.write_permission(baz="another.Permission")\n+\n+            foo = zope.schema.TextLine(title="Foo")\n+            bar = zope.schema.TextLine(title="Bar")\n+            baz = zope.schema.TextLine(title="Baz")\n+            qux = zope.schema.TextLine(title="Qux")\n \n-            form.omitted(\'foo\')\n-            form.omitted(\'bar\')\n-            form.widget(foo=\'some.dummy.Widget\')\n-            form.widget(baz=\'other.Widget\')\n-            form.mode(bar=\'hidden\')\n-            form.mode(foo=\'display\')\n-            form.order_before(baz=\'title\')\n-            form.order_after(baz=\'qux\')\n-            form.order_after(qux=\'bar\')\n-            form.order_before(foo=\'body\')\n-            form.read_permission(foo=\'zope2.View\', bar=\'zope2.View\')\n-            form.read_permission(baz=\'random.Permission\')\n-            form.write_permission(foo=\'cmf.ModifyPortalContent\')\n-            form.write_permission(baz=\'another.Permission\')\n-\n-            foo = zope.schema.TextLine(title=u\'Foo\')\n-            bar = zope.schema.TextLine(title=u\'Bar\')\n-            baz = zope.schema.TextLine(title=u\'Baz\')\n-            qux = zope.schema.TextLine(title=u\'Qux\')\n-\n-        self.assertEqual({\'foo\': \'some.dummy.Widget\',\n-                          \'baz\': \'other.Widget\'},\n-                         IDummy.queryTaggedValue(WIDGETS_KEY))\n-        self.assertEqual([(Interface, \'foo\', \'true\'),\n-                          (Interface, \'bar\', \'true\')],\n-                         IDummy.queryTaggedValue(OMITTED_KEY))\n-        self.assertEqual([(Interface, \'bar\', \'hidden\'),\n-                          (Interface, \'foo\', \'display\')],\n-                         IDummy.queryTaggedValue(MODES_KEY))\n-        self.assertEqual([(\'baz\', \'before\', \'title\'),\n-                          (\'baz\', \'after\', \'qux\'),\n-                          (\'qux\', \'after\', \'bar\'),\n-                          (\'foo\', \'before\', \'body\'), ],\n-                         IDummy.queryTaggedValue(ORDER_KEY))\n         self.assertEqual(\n-            {\'foo\': \'zope2.View\',\n-             \'bar\': \'zope2.View\',\n-             \'baz\': \'random.Permission\'},\n-            IDummy.queryTaggedValue(READ_PERMISSIONS_KEY)\n+            {"foo": "some.dummy.Widget", "baz": "other.Widget"},\n+            IDummy.queryTaggedValue(WIDGETS_KEY),\n+        )\n+        self.assertEqual(\n+            [(Interface, "foo", "true"), (Interface, "bar", "true")],\n+            IDummy.queryTaggedValue(OMITTED_KEY),\n+        )\n+        self.assertEqual(\n+            [(Interface, "bar", "hidden"), (Interface, "foo", "display")],\n+            IDummy.queryTaggedValue(MODES_KEY),\n         )\n         self.assertEqual(\n-            {\'foo\': \'cmf.ModifyPortalContent\', \'baz\': \'another.Permission\'},\n-            IDummy.queryTaggedValue(WRITE_PERMISSIONS_KEY)\n+            [\n+                ("baz", "before", "title"),\n+                ("baz", "after", "qux"),\n+                ("qux", "after", "bar"),\n+                ("foo", "before", "body"),\n+            ],\n+            IDummy.queryTaggedValue(ORDER_KEY),\n+        )\n+        self.assertEqual(\n+            {"foo": "zope2.View", "bar": "zope2.View", "baz": "random.Permission"},\n+            IDummy.queryTaggedValue(READ_PERMISSIONS_KEY),\n+        )\n+        self.assertEqual(\n+            {"foo": "cmf.ModifyPortalContent", "baz": "another.Permission"},\n+            IDummy.queryTaggedValue(WRITE_PERMISSIONS_KEY),\n         )\n \n     def test_misspelled_field(self):\n-\n         try:\n+\n             class IBar(model.Schema):\n-                form.order_before(ber=\'*\')\n+                form.order_before(ber="*")\n                 bar = zope.schema.TextLine()\n+\n         except ValueError:\n             pass\n         else:\n-            self.fail(\'Did not raise ValueError\')\n+            self.fail("Did not raise ValueError")\n \n         try:\n+\n             class IBaz(model.Schema):\n-                form.omitted(\'buz\')\n+                form.omitted("buz")\n                 baz = zope.schema.TextLine()\n+\n         except ValueError:\n             pass\n         else:\n-            self.fail(\'Did not raise ValueError\')\n+            self.fail("Did not raise ValueError")\n \n     def test_derived_class_fields(self):\n-\n         class IFoo(model.Schema):\n             foo = zope.schema.TextLine()\n \n         class IBar(IFoo):\n-            form.order_after(foo=\'bar\')\n+            form.order_after(foo="bar")\n             bar = zope.schema.TextLine()\n \n         self.assertEqual(\n-            [(\'foo\', \'after\', \'bar\'), ],\n-            IBar.queryTaggedValue(ORDER_KEY)\n+            [\n+                ("foo", "after", "bar"),\n+            ],\n+            IBar.queryTaggedValue(ORDER_KEY),\n         )\ndiff --git a/plone/autoform/tests/test_doctests.py b/plone/autoform/tests/test_doctests.py\nindex 1f8262b..52aad04 100644\n--- a/plone/autoform/tests/test_doctests.py\n+++ b/plone/autoform/tests/test_doctests.py\n@@ -1,37 +1,25 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.testing import optionflags\n from plone.testing import layered\n from plone.testing.zca import UNIT_TESTING\n \n import doctest\n-import re\n-import six\n import unittest\n \n \n test_files = [\n-    \'../autoform.rst\',\n-    \'subform.txt\',\n-    \'../view.txt\',\n-    \'../supermodel.txt\',\n+    "../autoform.rst",\n+    "subform.txt",\n+    "../view.txt",\n+    "../supermodel.txt",\n ]\n \n \n-class Py23DocChecker(doctest.OutputChecker):\n-    def check_output(self, want, got, optionflags):\n-        if six.PY2:\n-            got = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n-            # want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n-        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n-\n-\n def test_suite():\n     tests = [\n         layered(\n             doctest.DocFileSuite(\n                 test_file,\n                 optionflags=optionflags,\n-                checker=Py23DocChecker(),\n             ),\n             layer=UNIT_TESTING,\n         )\ndiff --git a/plone/autoform/tests/test_supermodel_handler.py b/plone/autoform/tests/test_supermodel_handler.py\nindex c8bd266..1db3c92 100644\n--- a/plone/autoform/tests/test_supermodel_handler.py\n+++ b/plone/autoform/tests/test_supermodel_handler.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from lxml import etree\n from plone.autoform.interfaces import MODES_KEY\n from plone.autoform.interfaces import OMITTED_KEY\n@@ -23,109 +22,104 @@\n \n \n @implementer(IWidget)\n-class DummyWidget(object):\n-\n+class DummyWidget:\n     def __init__(self, request):\n         pass\n \n \n class TestFormSchema(unittest.TestCase):\n-\n     layer = AUTOFORM_INTEGRATION_TESTING\n \n-    namespace = \'http://namespaces.plone.org/supermodel/form\'\n+    namespace = "http://namespaces.plone.org/supermodel/form"\n \n     def test_read(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n         field_node.set(\n-            ns(\'widget\', self.namespace),\n-            \'z3c.form.browser.password.PasswordFieldWidget\'\n+            ns("widget", self.namespace),\n+            "z3c.form.browser.password.PasswordFieldWidget",\n         )\n-        field_node.set(ns(\'mode\', self.namespace), \'hidden\')\n-        field_node.set(ns(\'omitted\', self.namespace), \'true\')\n-        field_node.set(ns(\'before\', self.namespace), \'somefield\')\n+        field_node.set(ns("mode", self.namespace), "hidden")\n+        field_node.set(ns("omitted", self.namespace), "true")\n+        field_node.set(ns("before", self.namespace), "somefield")\n         field_node.set(\n-            ns(\'validator\', self.namespace),\n-            \'plone.autoform.tests.test_utils.TestValidator\'\n+            ns("validator", self.namespace),\n+            "plone.autoform.tests.test_utils.TestValidator",\n         )\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy\')\n+            dummy = zope.schema.TextLine(title="dummy")\n \n         handler = FormSchema()\n-        handler.read(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.read(field_node, IDummy, IDummy["dummy"])\n \n         self.assertEqual(\n-            {\'dummy\': \'z3c.form.browser.password.PasswordFieldWidget\'},\n-            IDummy.getTaggedValue(WIDGETS_KEY)\n+            {"dummy": "z3c.form.browser.password.PasswordFieldWidget"},\n+            IDummy.getTaggedValue(WIDGETS_KEY),\n         )\n         self.assertEqual(\n-            [(Interface, \'dummy\', \'true\')],\n-            IDummy.getTaggedValue(OMITTED_KEY)\n+            [(Interface, "dummy", "true")], IDummy.getTaggedValue(OMITTED_KEY)\n         )\n         self.assertEqual(\n-            [(Interface, \'dummy\', \'hidden\')],\n-            IDummy.getTaggedValue(MODES_KEY)\n+            [(Interface, "dummy", "hidden")], IDummy.getTaggedValue(MODES_KEY)\n         )\n         self.assertEqual(\n-            [(\'dummy\', \'before\', \'somefield\',)],\n-            IDummy.getTaggedValue(ORDER_KEY)\n+            [("dummy", "before", "somefield")],\n+            IDummy.getTaggedValue(ORDER_KEY),\n         )\n         validator = getMultiAdapter(\n-            (None, None, None, IDummy[\'dummy\'], None),\n-            IValidator\n+            (None, None, None, IDummy["dummy"], None), IValidator\n         )\n         from plone.autoform.tests.test_utils import TestValidator\n+\n         assert isinstance(validator, TestValidator)\n \n     def test_read_multiple(self):\n-        field_node1 = etree.Element(\'field\')\n+        field_node1 = etree.Element("field")\n         field_node1.set(\n-            ns(\'widget\', self.namespace),\n-            \'z3c.form.browser.password.PasswordFieldWidget\'\n+            ns("widget", self.namespace),\n+            "z3c.form.browser.password.PasswordFieldWidget",\n         )\n-        field_node1.set(ns(\'mode\', self.namespace), \'hidden\')\n-        field_node1.set(ns(\'omitted\', self.namespace), \'true\')\n-        field_node1.set(ns(\'before\', self.namespace), \'somefield\')\n+        field_node1.set(ns("mode", self.namespace), "hidden")\n+        field_node1.set(ns("omitted", self.namespace), "true")\n+        field_node1.set(ns("before", self.namespace), "somefield")\n \n-        field_node2 = etree.Element(\'field\')\n-        field_node2.set(ns(\'mode\', self.namespace), \'display\')\n-        field_node2.set(ns(\'omitted\', self.namespace), \'yes\')\n+        field_node2 = etree.Element("field")\n+        field_node2.set(ns("mode", self.namespace), "display")\n+        field_node2.set(ns("omitted", self.namespace), "yes")\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.TextLine(title=u\'dummy1\')\n-            dummy2 = zope.schema.TextLine(title=u\'dummy2\')\n+            dummy1 = zope.schema.TextLine(title="dummy1")\n+            dummy2 = zope.schema.TextLine(title="dummy2")\n \n         handler = FormSchema()\n-        handler.read(field_node1, IDummy, IDummy[\'dummy1\'])\n-        handler.read(field_node2, IDummy, IDummy[\'dummy2\'])\n+        handler.read(field_node1, IDummy, IDummy["dummy1"])\n+        handler.read(field_node2, IDummy, IDummy["dummy2"])\n \n         self.assertEqual(\n-            {\'dummy1\': \'z3c.form.browser.password.PasswordFieldWidget\'},\n-            IDummy.getTaggedValue(WIDGETS_KEY)\n+            {"dummy1": "z3c.form.browser.password.PasswordFieldWidget"},\n+            IDummy.getTaggedValue(WIDGETS_KEY),\n         )\n         self.assertEqual(\n-            [(Interface, \'dummy1\', \'true\'), (Interface, \'dummy2\', \'yes\')],\n-            IDummy.getTaggedValue(OMITTED_KEY)\n+            [(Interface, "dummy1", "true"), (Interface, "dummy2", "yes")],\n+            IDummy.getTaggedValue(OMITTED_KEY),\n         )\n         self.assertEqual(\n-            [(Interface, \'dummy1\', \'hidden\'),\n-             (Interface, \'dummy2\', \'display\')],\n-            IDummy.getTaggedValue(MODES_KEY)\n+            [(Interface, "dummy1", "hidden"), (Interface, "dummy2", "display")],\n+            IDummy.getTaggedValue(MODES_KEY),\n         )\n         self.assertEqual(\n-            [(\'dummy1\', \'before\', \'somefield\',)],\n-            IDummy.getTaggedValue(ORDER_KEY)\n+            [("dummy1", "before", "somefield")],\n+            IDummy.getTaggedValue(ORDER_KEY),\n         )\n \n     def test_read_no_data(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+            dummy = zope.schema.TextLine(title="dummy1")\n \n         handler = FormSchema()\n-        handler.read(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.read(field_node, IDummy, IDummy["dummy"])\n \n         self.assertEqual(None, IDummy.queryTaggedValue(WIDGETS_KEY))\n         self.assertEqual(None, IDummy.queryTaggedValue(OMITTED_KEY))\n@@ -133,379 +127,352 @@ class IDummy(Interface):\n         self.assertEqual(None, IDummy.queryTaggedValue(ORDER_KEY))\n \n     def test_read_values_with_interfaces(self):\n-        field_node1 = etree.Element(\'field\')\n-        field_node1.set(\n-            ns(\'mode\', self.namespace),\n-            \'z3c.form.interfaces.IForm:hidden\'\n-        )\n-        field_node1.set(\n-            ns(\'omitted\', self.namespace),\n-            \'z3c.form.interfaces.IForm:true\'\n-        )\n+        field_node1 = etree.Element("field")\n+        field_node1.set(ns("mode", self.namespace), "z3c.form.interfaces.IForm:hidden")\n+        field_node1.set(ns("omitted", self.namespace), "z3c.form.interfaces.IForm:true")\n \n-        field_node2 = etree.Element(\'field\')\n+        field_node2 = etree.Element("field")\n         field_node2.set(\n-            ns(\'mode\', self.namespace),\n-            \'z3c.form.interfaces.IForm:hidden \'\n-            \'z3c.form.interfaces.IEditForm:display\'\n+            ns("mode", self.namespace),\n+            "z3c.form.interfaces.IForm:hidden " "z3c.form.interfaces.IEditForm:display",\n         )\n         field_node2.set(\n-            ns(\'omitted\', self.namespace),\n-            \'z3c.form.interfaces.IForm:true \'\n-            \'z3c.form.interfaces.IEditForm:false\'\n+            ns("omitted", self.namespace),\n+            "z3c.form.interfaces.IForm:true " "z3c.form.interfaces.IEditForm:false",\n         )\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.TextLine(title=u\'dummy1\')\n-            dummy2 = zope.schema.TextLine(title=u\'dummy2\')\n+            dummy1 = zope.schema.TextLine(title="dummy1")\n+            dummy2 = zope.schema.TextLine(title="dummy2")\n \n         handler = FormSchema()\n-        handler.read(field_node1, IDummy, IDummy[\'dummy1\'])\n-        handler.read(field_node2, IDummy, IDummy[\'dummy2\'])\n+        handler.read(field_node1, IDummy, IDummy["dummy1"])\n+        handler.read(field_node2, IDummy, IDummy["dummy2"])\n \n         expected_modes = [\n-            (IForm, u\'dummy1\', \'hidden\'),\n-            (IForm, u\'dummy2\', \'hidden\'),\n-            (IEditForm, u\'dummy2\', \'display\')\n+            (IForm, "dummy1", "hidden"),\n+            (IForm, "dummy2", "hidden"),\n+            (IEditForm, "dummy2", "display"),\n         ]\n-        self.assertEqual(\n-            expected_modes,\n-            IDummy.queryTaggedValue(MODES_KEY)\n-        )\n+        self.assertEqual(expected_modes, IDummy.queryTaggedValue(MODES_KEY))\n         expected_omitted = [\n-            (IForm, u\'dummy1\', \'true\'),\n-            (IForm, u\'dummy2\', \'true\'),\n-            (IEditForm, u\'dummy2\', \'false\')\n+            (IForm, "dummy1", "true"),\n+            (IForm, "dummy2", "true"),\n+            (IEditForm, "dummy2", "false"),\n         ]\n-        self.assertEqual(\n-            expected_omitted,\n-            IDummy.queryTaggedValue(OMITTED_KEY)\n-        )\n+        self.assertEqual(expected_omitted, IDummy.queryTaggedValue(OMITTED_KEY))\n \n     def test_read_parameterized_widget(self):\n         from plone.autoform.widgets import ParameterizedWidget\n \n-        param_node = etree.Element(\'klass\')\n-        param_node.text = \'custom\'\n-        widget_node = etree.Element(ns(\'widget\', self.namespace))\n+        param_node = etree.Element("klass")\n+        param_node.text = "custom"\n+        widget_node = etree.Element(ns("widget", self.namespace))\n         widget_node.set(\n-            \'type\',\n-            \'plone.autoform.tests.test_supermodel_handler.DummyWidget\'\n+            "type", "plone.autoform.tests.test_supermodel_handler.DummyWidget"\n         )\n         widget_node.append(param_node)\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n         field_node.append(widget_node)\n \n         class IDummy(Interface):\n-            foo = zope.schema.TextLine(title=u\'foo\')\n+            foo = zope.schema.TextLine(title="foo")\n \n         handler = FormSchema()\n-        handler.read(field_node, IDummy, IDummy[\'foo\'])\n+        handler.read(field_node, IDummy, IDummy["foo"])\n \n         widgets = IDummy.queryTaggedValue(WIDGETS_KEY)\n-        self.assertTrue(isinstance(widgets[\'foo\'], ParameterizedWidget))\n-        self.assertTrue(widgets[\'foo\'].widget_factory is DummyWidget)\n-        self.assertEqual(widgets[\'foo\'].params, {\'klass\': \'custom\'})\n+        self.assertTrue(isinstance(widgets["foo"], ParameterizedWidget))\n+        self.assertTrue(widgets["foo"].widget_factory is DummyWidget)\n+        self.assertEqual(widgets["foo"].params, {"klass": "custom"})\n \n     def test_read_parameterized_widget_default(self):\n         from plone.autoform.widgets import ParameterizedWidget\n \n-        param_node = etree.Element(\'klass\')\n-        param_node.text = \'custom\'\n-        param2_node = etree.Element(\'placeholder\')\n-        param2_node.text = \'help\'\n-        widget_node = etree.Element(ns(\'widget\', self.namespace))\n+        param_node = etree.Element("klass")\n+        param_node.text = "custom"\n+        param2_node = etree.Element("placeholder")\n+        param2_node.text = "help"\n+        widget_node = etree.Element(ns("widget", self.namespace))\n         widget_node.append(param_node)\n         widget_node.append(param2_node)\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n         field_node.append(widget_node)\n \n         class IDummy(Interface):\n-            foo = zope.schema.TextLine(title=u\'foo\')\n+            foo = zope.schema.TextLine(title="foo")\n \n         handler = FormSchema()\n-        handler.read(field_node, IDummy, IDummy[\'foo\'])\n+        handler.read(field_node, IDummy, IDummy["foo"])\n \n         widgets = IDummy.queryTaggedValue(WIDGETS_KEY)\n-        self.assertTrue(isinstance(widgets[\'foo\'], ParameterizedWidget))\n-        self.assertTrue(widgets[\'foo\'].widget_factory is None)\n-        self.assertIn(\'klass\', widgets[\'foo\'].params)\n-        self.assertEqual(widgets[\'foo\'].params[\'klass\'], \'custom\')\n-        self.assertIn(\'placeholder\', widgets[\'foo\'].params)\n-        self.assertEqual(widgets[\'foo\'].params[\'placeholder\'], \'help\')\n+        self.assertTrue(isinstance(widgets["foo"], ParameterizedWidget))\n+        self.assertTrue(widgets["foo"].widget_factory is None)\n+        self.assertIn("klass", widgets["foo"].params)\n+        self.assertEqual(widgets["foo"].params["klass"], "custom")\n+        self.assertIn("placeholder", widgets["foo"].params)\n+        self.assertEqual(widgets["foo"].params["placeholder"], "help")\n \n     def test_write(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+            dummy = zope.schema.TextLine(title="dummy1")\n \n-        IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy\': \'SomeWidget\'})\n-        IDummy.setTaggedValue(OMITTED_KEY, [(Interface, \'dummy\', \'true\')])\n-        IDummy.setTaggedValue(MODES_KEY, [(Interface, \'dummy\', \'hidden\')])\n-        IDummy.setTaggedValue(ORDER_KEY, [(\'dummy\', \'before\', \'somefield\',)])\n+        IDummy.setTaggedValue(WIDGETS_KEY, {"dummy": "SomeWidget"})\n+        IDummy.setTaggedValue(OMITTED_KEY, [(Interface, "dummy", "true")])\n+        IDummy.setTaggedValue(MODES_KEY, [(Interface, "dummy", "hidden")])\n+        IDummy.setTaggedValue(\n+            ORDER_KEY,\n+            [("dummy", "before", "somefield")],\n+        )\n \n         handler = FormSchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n-        widget_node = field_node.find(ns(\'widget\', self.namespace))\n-        self.assertEqual(\'SomeWidget\', widget_node.get(\'type\'))\n-        self.assertEqual(\'true\', field_node.get(ns(\'omitted\', self.namespace)))\n-        self.assertEqual(\'hidden\', field_node.get(ns(\'mode\', self.namespace)))\n-        self.assertEqual(\n-            \'somefield\',\n-            field_node.get(ns(\'before\', self.namespace))\n-        )\n+        widget_node = field_node.find(ns("widget", self.namespace))\n+        self.assertEqual("SomeWidget", widget_node.get("type"))\n+        self.assertEqual("true", field_node.get(ns("omitted", self.namespace)))\n+        self.assertEqual("hidden", field_node.get(ns("mode", self.namespace)))\n+        self.assertEqual("somefield", field_node.get(ns("before", self.namespace)))\n \n     def test_write_partial(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+            dummy = zope.schema.TextLine(title="dummy1")\n \n-        IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy\': \'SomeWidget\'})\n-        IDummy.setTaggedValue(OMITTED_KEY, [(Interface, \'dummy2\', \'true\')])\n+        IDummy.setTaggedValue(WIDGETS_KEY, {"dummy": "SomeWidget"})\n+        IDummy.setTaggedValue(OMITTED_KEY, [(Interface, "dummy2", "true")])\n         IDummy.setTaggedValue(\n             MODES_KEY,\n-            [(Interface, \'dummy\', \'display\'), (Interface, \'dummy2\', \'hidden\')]\n+            [(Interface, "dummy", "display"), (Interface, "dummy2", "hidden")],\n         )\n         IDummy.setTaggedValue(ORDER_KEY, [])\n \n         handler = FormSchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n-        widget_node = field_node.find(ns(\'widget\', self.namespace))\n-        self.assertEqual(\'SomeWidget\', widget_node.get(\'type\'))\n-        self.assertEqual(None, field_node.get(ns(\'omitted\', self.namespace)))\n-        self.assertEqual(\'display\', field_node.get(ns(\'mode\', self.namespace)))\n-        self.assertEqual(None, field_node.get(ns(\'before\', self.namespace)))\n+        widget_node = field_node.find(ns("widget", self.namespace))\n+        self.assertEqual("SomeWidget", widget_node.get("type"))\n+        self.assertEqual(None, field_node.get(ns("omitted", self.namespace)))\n+        self.assertEqual("display", field_node.get(ns("mode", self.namespace)))\n+        self.assertEqual(None, field_node.get(ns("before", self.namespace)))\n \n     def test_write_no_data(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy1\')\n+            dummy = zope.schema.TextLine(title="dummy1")\n \n         handler = FormSchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n-        self.assertEqual(None, field_node.find(ns(\'widget\', self.namespace)))\n-        self.assertEqual(None, field_node.get(ns(\'omitted\', self.namespace)))\n-        self.assertEqual(None, field_node.get(ns(\'mode\', self.namespace)))\n-        self.assertEqual(None, field_node.get(ns(\'before\', self.namespace)))\n+        self.assertEqual(None, field_node.find(ns("widget", self.namespace)))\n+        self.assertEqual(None, field_node.get(ns("omitted", self.namespace)))\n+        self.assertEqual(None, field_node.get(ns("mode", self.namespace)))\n+        self.assertEqual(None, field_node.get(ns("before", self.namespace)))\n \n     def test_write_values_with_interfaces(self):\n-        field_node1 = etree.Element(\'field\')\n-        field_node2 = etree.Element(\'field\')\n+        field_node1 = etree.Element("field")\n+        field_node2 = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.TextLine(title=u\'dummy1\')\n-            dummy2 = zope.schema.TextLine(title=u\'dummy2\')\n+            dummy1 = zope.schema.TextLine(title="dummy1")\n+            dummy2 = zope.schema.TextLine(title="dummy2")\n \n         modes_values = [\n-            (IForm, u\'dummy1\', \'hidden\'),\n-            (IForm, u\'dummy2\', \'hidden\'),\n-            (IEditForm, u\'dummy2\', \'display\')\n+            (IForm, "dummy1", "hidden"),\n+            (IForm, "dummy2", "hidden"),\n+            (IEditForm, "dummy2", "display"),\n         ]\n         IDummy.setTaggedValue(MODES_KEY, modes_values)\n         omitted_values = [\n-            (IForm, u\'dummy1\', \'true\'),\n-            (IForm, u\'dummy2\', \'true\'),\n-            (IEditForm, u\'dummy2\', \'false\')\n+            (IForm, "dummy1", "true"),\n+            (IForm, "dummy2", "true"),\n+            (IEditForm, "dummy2", "false"),\n         ]\n         IDummy.setTaggedValue(OMITTED_KEY, omitted_values)\n \n         handler = FormSchema()\n-        handler.write(field_node1, IDummy, IDummy[\'dummy1\'])\n-        handler.write(field_node2, IDummy, IDummy[\'dummy2\'])\n+        handler.write(field_node1, IDummy, IDummy["dummy1"])\n+        handler.write(field_node2, IDummy, IDummy["dummy2"])\n \n         self.assertEqual(\n-            \'z3c.form.interfaces.IForm:hidden\',\n-            field_node1.get(ns(\'mode\', self.namespace))\n+            "z3c.form.interfaces.IForm:hidden",\n+            field_node1.get(ns("mode", self.namespace)),\n         )\n         self.assertEqual(\n-            \'z3c.form.interfaces.IForm:true\',\n-            field_node1.get(ns(\'omitted\', self.namespace))\n+            "z3c.form.interfaces.IForm:true",\n+            field_node1.get(ns("omitted", self.namespace)),\n         )\n \n         self.assertEqual(\n-            \'z3c.form.interfaces.IForm:hidden \'\n-            \'z3c.form.interfaces.IEditForm:display\',\n-            field_node2.get(ns(\'mode\', self.namespace))\n+            "z3c.form.interfaces.IForm:hidden " "z3c.form.interfaces.IEditForm:display",\n+            field_node2.get(ns("mode", self.namespace)),\n         )\n         self.assertEqual(\n-            \'z3c.form.interfaces.IForm:true \'\n-            \'z3c.form.interfaces.IEditForm:false\',\n-            field_node2.get(ns(\'omitted\', self.namespace))\n+            "z3c.form.interfaces.IForm:true " "z3c.form.interfaces.IEditForm:false",\n+            field_node2.get(ns("omitted", self.namespace)),\n         )\n \n     def test_write_parameterized_widget_string(self):\n         from plone.autoform.widgets import ParameterizedWidget\n-        pw = ParameterizedWidget(\'foo\')\n+\n+        pw = ParameterizedWidget("foo")\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.Text(title=u\'dummy1\')\n-        IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy1\': pw})\n+            dummy1 = zope.schema.Text(title="dummy1")\n+\n+        IDummy.setTaggedValue(WIDGETS_KEY, {"dummy1": pw})\n \n-        fieldNode = etree.Element(\'field\')\n+        fieldNode = etree.Element("field")\n         handler = FormSchema()\n-        handler.write(fieldNode, IDummy, IDummy[\'dummy1\'])\n+        handler.write(fieldNode, IDummy, IDummy["dummy1"])\n \n         self.assertEqual(\n             etree.tostring(fieldNode),\n-            b\'<field><ns0:widget\'\n+            b"<field><ns0:widget"\n             b\' xmlns:ns0="http://namespaces.plone.org/supermodel/form"\'\n-            b\' type="foo"/></field>\'\n+            b\' type="foo"/></field>\',\n         )\n \n     def test_write_parameterized_widget_default(self):\n         from plone.autoform.widgets import ParameterizedWidget\n+\n         pw = ParameterizedWidget(None)\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.Text(title=u\'dummy1\')\n-        IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy1\': pw})\n+            dummy1 = zope.schema.Text(title="dummy1")\n+\n+        IDummy.setTaggedValue(WIDGETS_KEY, {"dummy1": pw})\n \n-        fieldNode = etree.Element(\'field\')\n+        fieldNode = etree.Element("field")\n         handler = FormSchema()\n-        handler.write(fieldNode, IDummy, IDummy[\'dummy1\'])\n+        handler.write(fieldNode, IDummy, IDummy["dummy1"])\n \n-        self.assertEqual(\n-            etree.tostring(fieldNode),\n-            b\'<field/>\'\n-        )\n+        self.assertEqual(etree.tostring(fieldNode), b"<field/>")\n \n     def test_write_parameterized_widget_with_handler(self):\n         from plone.autoform.widgets import ParameterizedWidget\n-        pw = ParameterizedWidget(DummyWidget, klass=\'custom\')\n+\n+        pw = ParameterizedWidget(DummyWidget, klass="custom")\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.Text(title=u\'dummy1\')\n-        IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy1\': pw})\n+            dummy1 = zope.schema.Text(title="dummy1")\n+\n+        IDummy.setTaggedValue(WIDGETS_KEY, {"dummy1": pw})\n \n-        fieldNode = etree.Element(\'field\')\n+        fieldNode = etree.Element("field")\n         handler = FormSchema()\n-        handler.write(fieldNode, IDummy, IDummy[\'dummy1\'])\n+        handler.write(fieldNode, IDummy, IDummy["dummy1"])\n \n         self.assertEqual(\n             etree.tostring(fieldNode),\n-            b\'<field><ns0:widget\'\n+            b"<field><ns0:widget"\n             b\' xmlns:ns0="http://namespaces.plone.org/supermodel/form"\'\n             b\' type="plone.autoform.tests.test_supermodel_handler.\'\n             b\'DummyWidget">\'\n-            b\'<klass>custom</klass>\'\n-            b\'</ns0:widget></field>\')\n+            b"<klass>custom</klass>"\n+            b"</ns0:widget></field>",\n+        )\n \n     def test_write_parameterized_widget_default_with_handler(self):\n         from plone.autoform.widgets import ParameterizedWidget\n-        pw = ParameterizedWidget(None, klass=\'custom\')\n+\n+        pw = ParameterizedWidget(None, klass="custom")\n \n         class IDummy(Interface):\n-            dummy1 = zope.schema.Text(title=u\'dummy1\')\n-        IDummy.setTaggedValue(WIDGETS_KEY, {\'dummy1\': pw})\n+            dummy1 = zope.schema.Text(title="dummy1")\n \n-        fieldNode = etree.Element(\'field\')\n+        IDummy.setTaggedValue(WIDGETS_KEY, {"dummy1": pw})\n+\n+        fieldNode = etree.Element("field")\n         handler = FormSchema()\n-        handler.write(fieldNode, IDummy, IDummy[\'dummy1\'])\n+        handler.write(fieldNode, IDummy, IDummy["dummy1"])\n \n         self.assertEqual(\n             etree.tostring(fieldNode),\n-            b\'<field><ns0:widget\'\n+            b"<field><ns0:widget"\n             b\' xmlns:ns0="http://namespaces.plone.org/supermodel/form">\'\n-            b\'<klass>custom</klass></ns0:widget></field>\')\n+            b"<klass>custom</klass></ns0:widget></field>",\n+        )\n \n \n class TestSecuritySchema(unittest.TestCase):\n-\n-    namespace = \'http://namespaces.plone.org/supermodel/security\'\n+    namespace = "http://namespaces.plone.org/supermodel/security"\n \n     def test_read(self):\n-        field_node = etree.Element(\'field\')\n-        field_node.set(ns(\'read-permission\', self.namespace), \'dummy.Read\')\n-        field_node.set(ns(\'write-permission\', self.namespace), \'dummy.Write\')\n+        field_node = etree.Element("field")\n+        field_node.set(ns("read-permission", self.namespace), "dummy.Read")\n+        field_node.set(ns("write-permission", self.namespace), "dummy.Write")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy\')\n+            dummy = zope.schema.TextLine(title="dummy")\n \n         handler = SecuritySchema()\n-        handler.read(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.read(field_node, IDummy, IDummy["dummy"])\n \n         self.assertEqual(\n-            {u\'dummy\': \'dummy.Read\'},\n-            IDummy.getTaggedValue(READ_PERMISSIONS_KEY)\n+            {"dummy": "dummy.Read"}, IDummy.getTaggedValue(READ_PERMISSIONS_KEY)\n         )\n         self.assertEqual(\n-            {u\'dummy\': \'dummy.Write\'},\n-            IDummy.getTaggedValue(WRITE_PERMISSIONS_KEY)\n+            {"dummy": "dummy.Write"}, IDummy.getTaggedValue(WRITE_PERMISSIONS_KEY)\n         )\n \n     def test_read_no_permissions(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy\')\n+            dummy = zope.schema.TextLine(title="dummy")\n \n         handler = SecuritySchema()\n-        handler.read(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.read(field_node, IDummy, IDummy["dummy"])\n \n         self.assertFalse(READ_PERMISSIONS_KEY in IDummy.getTaggedValueTags())\n         self.assertFalse(WRITE_PERMISSIONS_KEY in IDummy.getTaggedValueTags())\n \n     def test_write(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy\')\n+            dummy = zope.schema.TextLine(title="dummy")\n \n-        IDummy.setTaggedValue(READ_PERMISSIONS_KEY, {u\'dummy\': \'dummy.Read\'})\n-        IDummy.setTaggedValue(WRITE_PERMISSIONS_KEY, {u\'dummy\': \'dummy.Write\'})\n+        IDummy.setTaggedValue(READ_PERMISSIONS_KEY, {"dummy": "dummy.Read"})\n+        IDummy.setTaggedValue(WRITE_PERMISSIONS_KEY, {"dummy": "dummy.Write"})\n \n         handler = SecuritySchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n         self.assertEqual(\n-            \'dummy.Read\',\n-            field_node.get(ns(\'read-permission\', self.namespace))\n+            "dummy.Read", field_node.get(ns("read-permission", self.namespace))\n         )\n         self.assertEqual(\n-            \'dummy.Write\',\n-            field_node.get(ns(\'write-permission\', self.namespace))\n+            "dummy.Write", field_node.get(ns("write-permission", self.namespace))\n         )\n \n     def test_write_no_permissions(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy\')\n+            dummy = zope.schema.TextLine(title="dummy")\n \n-        IDummy.setTaggedValue(READ_PERMISSIONS_KEY, {u\'dummy\': None})\n+        IDummy.setTaggedValue(READ_PERMISSIONS_KEY, {"dummy": None})\n \n         handler = SecuritySchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n-        self.assertEqual(\n-            None,\n-            field_node.get(ns(\'read-permission\', self.namespace))\n-        )\n-        self.assertEqual(\n-            None,\n-            field_node.get(ns(\'write-permission\', self.namespace))\n-        )\n+        self.assertEqual(None, field_node.get(ns("read-permission", self.namespace)))\n+        self.assertEqual(None, field_node.get(ns("write-permission", self.namespace)))\n \n     def test_write_no_metadata(self):\n-        field_node = etree.Element(\'field\')\n+        field_node = etree.Element("field")\n \n         class IDummy(Interface):\n-            dummy = zope.schema.TextLine(title=u\'dummy\')\n+            dummy = zope.schema.TextLine(title="dummy")\n \n         handler = SecuritySchema()\n-        handler.write(field_node, IDummy, IDummy[\'dummy\'])\n+        handler.write(field_node, IDummy, IDummy["dummy"])\n \n-        self.assertEqual(\n-            None,\n-            field_node.get(ns(\'read-permission\', self.namespace))\n-        )\n-        self.assertEqual(\n-            None,\n-            field_node.get(ns(\'write-permission\', self.namespace))\n-        )\n+        self.assertEqual(None, field_node.get(ns("read-permission", self.namespace)))\n+        self.assertEqual(None, field_node.get(ns("write-permission", self.namespace)))\ndiff --git a/plone/autoform/tests/test_utils.py b/plone/autoform/tests/test_utils.py\nindex c5538ad..143ea9b 100644\n--- a/plone/autoform/tests/test_utils.py\n+++ b/plone/autoform/tests/test_utils.py\n@@ -1,6 +1,5 @@\n-# -*- coding: utf-8 -*-\n-from AccessControl.SecurityManagement import setSecurityManager\n from AccessControl.SecurityManagement import getSecurityManager\n+from AccessControl.SecurityManagement import setSecurityManager\n from plone.autoform.interfaces import WRITE_PERMISSIONS_KEY\n from plone.autoform.utils import processFields\n from plone.supermodel.interfaces import FIELDSETS_KEY\n@@ -17,21 +16,20 @@\n \n \n class TestValidator(SimpleFieldValidator):\n-\n     def validate(self, value):\n-        super(TestValidator, self).validate(value)\n-        raise Invalid(\'Test\')\n+        super().validate(value)\n+        raise Invalid("Test")\n \n \n class TestUtils(unittest.TestCase):\n-\n     layer = UNIT_TESTING\n \n     def setUp(self):\n         from zope.security.permission import Permission\n-        provideUtility(Permission(\'foo\', u\'foo\', u\'\'), name=u\'foo\')\n \n-        class DummySecurityManager(object):\n+        provideUtility(Permission("foo", "foo", ""), name="foo")\n+\n+        class DummySecurityManager:\n             checks = []\n \n             def checkPermission(self, perm, context):\n@@ -52,11 +50,11 @@ def test_processFields_permissionChecks_no_prefix(self):\n         class schema(Interface):\n             title = zope.schema.TextLine()\n \n-        schema.setTaggedValue(WRITE_PERMISSIONS_KEY, {\'title\': \'foo\'})\n-        processFields(form, schema, prefix=\'\', permissionChecks=True)\n+        schema.setTaggedValue(WRITE_PERMISSIONS_KEY, {"title": "foo"})\n+        processFields(form, schema, prefix="", permissionChecks=True)\n \n-        self.assertEqual(\'foo\', self.secman.checks.pop())\n-        self.assertFalse(\'title\' in form.fields)\n+        self.assertEqual("foo", self.secman.checks.pop())\n+        self.assertFalse("title" in form.fields)\n \n     def test_processFields_permissionChecks_w_prefix(self):\n         form = Form(None, None)\n@@ -64,11 +62,12 @@ def test_processFields_permissionChecks_w_prefix(self):\n \n         class schema(Interface):\n             title = zope.schema.TextLine()\n-        schema.setTaggedValue(WRITE_PERMISSIONS_KEY, {\'title\': \'foo\'})\n-        processFields(form, schema, prefix=\'prefix\', permissionChecks=True)\n \n-        self.assertEqual(\'foo\', self.secman.checks.pop())\n-        self.assertFalse(\'prefix.title\' in form.fields)\n+        schema.setTaggedValue(WRITE_PERMISSIONS_KEY, {"title": "foo"})\n+        processFields(form, schema, prefix="prefix", permissionChecks=True)\n+\n+        self.assertEqual("foo", self.secman.checks.pop())\n+        self.assertFalse("prefix.title" in form.fields)\n \n     def test_processFields_fieldsets_as_form_groups(self):\n         form = Form(None, None)\n@@ -77,26 +76,23 @@ def test_processFields_fieldsets_as_form_groups(self):\n         class schema(Interface):\n             title = zope.schema.TextLine()\n \n-        fieldset = Fieldset(\'custom\', label=u\'Custom\',\n-                            fields=[\'title\'])\n+        fieldset = Fieldset("custom", label="Custom", fields=["title"])\n         schema.setTaggedValue(FIELDSETS_KEY, [fieldset])\n \n         class subschema(schema):\n             subtitle = zope.schema.TextLine()\n \n-        fieldset = Fieldset(\'custom\', label=u\'Custom\',\n-                            fields=[\'subtitle\'])\n+        fieldset = Fieldset("custom", label="Custom", fields=["subtitle"])\n         subschema.setTaggedValue(FIELDSETS_KEY, [fieldset])\n \n-        processFields(form, subschema,\n-                      prefix=\'prefix\', permissionChecks=True)\n+        processFields(form, subschema, prefix="prefix", permissionChecks=True)\n \n         self.assertEqual(len(form.groups), 1)\n         self.assertEqual(len(form.groups[0].fields), 2)\n-        self.assertEqual([g.__name__ for g in form.groups], [\'custom\'])\n+        self.assertEqual([g.__name__ for g in form.groups], ["custom"])\n \n     def test_fieldset_configuration(self):\n-        """Test, if fieldsets can be orderd via fieldset configuration on a\n+        """Test, if fieldsets can be ordered via fieldset configuration on a\n         schema without fields. This schema should also not be included in form\n         groups.\n         """\n@@ -106,30 +102,30 @@ def test_fieldset_configuration(self):\n         class schema1(Interface):\n             title = zope.schema.TextLine()\n \n-        fs1 = Fieldset(\'fs1\', label=u\'fs1\', fields=[\'title\'])\n+        fs1 = Fieldset("fs1", label="fs1", fields=["title"])\n         schema1.setTaggedValue(FIELDSETS_KEY, [fs1])\n \n         class schema2(Interface):\n             subtitle = zope.schema.TextLine()\n \n-        fs2 = Fieldset(\'fs2\', label=u\'fs2\', fields=[\'subtitle\'])\n+        fs2 = Fieldset("fs2", label="fs2", fields=["subtitle"])\n         schema2.setTaggedValue(FIELDSETS_KEY, [fs2])\n \n         class schema3(Interface):\n             pass\n \n-        fs3 = Fieldset(\'fs1\', order=2)\n-        fs4 = Fieldset(\'fs2\', order=1)\n+        fs3 = Fieldset("fs1", order=2)\n+        fs4 = Fieldset("fs2", order=1)\n         schema3.setTaggedValue(FIELDSETS_KEY, [fs3, fs4])\n \n-        processFields(form, schema1, prefix=\'prefix\', permissionChecks=True)\n-        processFields(form, schema2, prefix=\'prefix\', permissionChecks=True)\n-        processFields(form, schema3, prefix=\'prefix\', permissionChecks=True)\n+        processFields(form, schema1, prefix="prefix", permissionChecks=True)\n+        processFields(form, schema2, prefix="prefix", permissionChecks=True)\n+        processFields(form, schema3, prefix="prefix", permissionChecks=True)\n \n         self.assertEqual(len(form.groups), 2)\n \n-        self.assertEqual(form.groups[0].__name__, \'fs1\')\n+        self.assertEqual(form.groups[0].__name__, "fs1")\n         self.assertEqual(form.groups[0].order, 2)\n \n-        self.assertEqual(form.groups[1].__name__, \'fs2\')\n+        self.assertEqual(form.groups[1].__name__, "fs2")\n         self.assertEqual(form.groups[1].order, 1)\ndiff --git a/plone/autoform/tests/test_widgets.py b/plone/autoform/tests/test_widgets.py\nindex a62bf6e..8d2396d 100644\n--- a/plone/autoform/tests/test_widgets.py\n+++ b/plone/autoform/tests/test_widgets.py\n@@ -1,11 +1,9 @@\n-# -*- coding: utf-8 -*-\n from plone.testing.zca import UNIT_TESTING\n \n import unittest\n \n \n class TestParameterizedWidget(unittest.TestCase):\n-\n     layer = UNIT_TESTING\n \n     def test_widget_instantiated_with_parameters(self):\n@@ -16,8 +14,7 @@ def test_widget_instantiated_with_parameters(self):\n         from zope.schema import Field\n \n         @implementer(IWidget)\n-        class DummyWidget(object):\n-\n+        class DummyWidget:\n             def __init__(self, request):\n                 self.request = request\n \n@@ -27,21 +24,20 @@ def DummyFieldWidget(field, request):\n \n         field = Field()\n         request = object()\n-        widget = ParameterizedWidget(DummyWidget, foo=\'bar\')(field, request)\n+        widget = ParameterizedWidget(DummyWidget, foo="bar")(field, request)\n \n         self.assertTrue(isinstance(widget, DummyWidget))\n-        self.assertEqual(\'bar\', widget.foo)\n+        self.assertEqual("bar", widget.foo)\n \n     def test_default_widget_instantiated(self):\n         from plone.autoform.widgets import ParameterizedWidget\n         from z3c.form.interfaces import IFieldWidget\n         from zope.component import provideAdapter\n-        from zope.interface import Interface\n         from zope.interface import implementer\n+        from zope.interface import Interface\n         from zope.schema import Field\n \n-        class DummyWidget(object):\n-\n+        class DummyWidget:\n             def __init__(self, request):\n                 self.request = request\n \n@@ -53,15 +49,15 @@ def DummyFieldWidget(field, request):\n \n         field = Field()\n         request = object()\n-        widget = ParameterizedWidget(foo=\'bar\')(field, request)\n+        widget = ParameterizedWidget(foo="bar")(field, request)\n \n         self.assertTrue(isinstance(widget, DummyWidget))\n-        self.assertEqual(\'bar\', widget.foo)\n+        self.assertEqual("bar", widget.foo)\n \n     def test_validates_for_field_widget(self):\n         from plone.autoform.widgets import ParameterizedWidget\n \n-        class NotAWidget(object):\n+        class NotAWidget:\n             pass\n \n         try:\n@@ -70,4 +66,4 @@ class NotAWidget(object):\n         except TypeError:\n             pass\n         else:\n-            self.fail(\'Expected TypeError\')\n+            self.fail("Expected TypeError")\ndiff --git a/plone/autoform/utils.py b/plone/autoform/utils.py\nindex f3f2515..f49b512 100644\n--- a/plone/autoform/utils.py\n+++ b/plone/autoform/utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from AccessControl import getSecurityManager\n from plone.autoform.interfaces import IParameterizedWidget\n from plone.autoform.interfaces import MODES_KEY\n@@ -24,15 +23,12 @@\n from zope.interface import providedBy\n from zope.security.interfaces import IPermission\n \n-import six\n-\n \n _dottedCache = {}\n \n \n def resolveDottedName(dottedName):\n-    """Resolve a dotted name to a real object\n-    """\n+    """Resolve a dotted name to a real object"""\n     global _dottedCache\n     if dottedName not in _dottedCache:\n         _dottedCache[dottedName] = resolve(dottedName)\n@@ -47,8 +43,7 @@ def mergedTaggedValuesForIRO(schema, name, iro):\n     interfaces actually provided by \'form\'.\n     """\n     # filter out settings irrelevant to this form\n-    threeples = [t for t in mergedTaggedValueList(schema, name)\n-                 if t[0] in iro]\n+    threeples = [t for t in mergedTaggedValueList(schema, name) if t[0] in iro]\n \n     # Sort by interface resolution order of the form interface,\n     # then by IRO of the interface the value came from\n@@ -56,6 +51,7 @@ def mergedTaggedValuesForIRO(schema, name, iro):\n     def by_iro(threeple):\n         interface = threeple[0]\n         return iro.index(interface)\n+\n     threeples.sort(key=by_iro)\n     d = {}\n     # Now iterate through in the reverse order -- the values assigned last win.\n@@ -71,9 +67,9 @@ def mergedTaggedValuesForForm(schema, name, form):\n \n # Some helper functions\n \n+\n def _process_prefixed_name(prefix, fieldName):\n-    """Give prefixed fieldname if applicable\n-    """\n+    """Give prefixed fieldname if applicable"""\n     if prefix:\n         return expandPrefix(prefix) + fieldName\n     else:\n@@ -81,32 +77,28 @@ def _process_prefixed_name(prefix, fieldName):\n \n \n def _bn(fieldInstance):\n-    """Base Name: Give base (non-prefixed) fieldname\n-    """\n+    """Base Name: Give base (non-prefixed) fieldname"""\n     prefix = fieldInstance.prefix\n     fieldName = fieldInstance.__name__\n     if prefix:\n-        return fieldName[len(prefix) + 1:]\n+        return fieldName[len(prefix) + 1 :]\n     else:\n         return fieldName\n \n \n def _process_widgets(form, widgets, modes, newFields):\n-    """Update the fields list with widgets\n-    """\n+    """Update the fields list with widgets"""\n \n     for fieldName in newFields:\n         fieldInstance = newFields[fieldName]\n         baseName = _bn(fieldInstance)\n \n         widgetName = widgets.get(baseName, None)\n-        widgetMode = modes.get(baseName, fieldInstance.mode) \\\n-            or form.mode \\\n-            or INPUT_MODE\n+        widgetMode = modes.get(baseName, fieldInstance.mode) or form.mode or INPUT_MODE\n \n         widgetFactory = None\n         if widgetName is not None:\n-            if isinstance(widgetName, six.string_types):\n+            if isinstance(widgetName, str):\n                 widgetFactory = resolveDottedName(widgetName)\n             elif IFieldWidget.implementedBy(widgetName):\n                 widgetFactory = widgetName\n@@ -120,15 +112,8 @@ def _process_widgets(form, widgets, modes, newFields):\n             newFields[fieldName].mode = widgetMode\n \n \n-def _process_fieldsets(\n-    form,\n-    schema,\n-    groups,\n-    all_fields,\n-    prefix,\n-    default_group\n-):\n-    """ Keep track of which fields are in a fieldset, and, by elimination,\n+def _process_fieldsets(form, schema, groups, all_fields, prefix, default_group):\n+    """Keep track of which fields are in a fieldset, and, by elimination,\n     which ones are not\n     """\n     # { name => e.g. \'hidden\' }\n@@ -159,8 +144,11 @@ def _process_fieldsets(\n \n     for fieldset in fieldsets:\n         new_fields = all_fields.select(\n-            *[_process_prefixed_name(prefix, name) for name in fieldset.fields\n-              if _process_prefixed_name(prefix, name) in all_fields]\n+            *[\n+                _process_prefixed_name(prefix, name)\n+                for name in fieldset.fields\n+                if _process_prefixed_name(prefix, name) in all_fields\n+            ]\n         )\n \n         if fieldset.__name__ in groups:\n@@ -169,31 +157,30 @@ def _process_fieldsets(\n             group = groups[fieldset.__name__]\n             group.fields += new_fields\n             if (\n-                fieldset.label and\n-                group.label != fieldset.label and\n-                group.__name__ != fieldset.label  # defaults to name!\n+                fieldset.label\n+                and group.label != fieldset.label\n+                and group.__name__ != fieldset.label  # defaults to name!\n             ):\n                 group.label = fieldset.label\n-            if (\n-                fieldset.description and\n-                group.description != fieldset.description\n-            ):\n+            if fieldset.description and group.description != fieldset.description:\n                 group.description = fieldset.description\n             if (\n-                fieldset.order and\n-                fieldset.order != DEFAULT_ORDER and\n-                fieldset.order != group.order\n+                fieldset.order\n+                and fieldset.order != DEFAULT_ORDER\n+                and fieldset.order != group.order\n             ):\n                 group.order = fieldset.order\n \n-        if len(new_fields) > 0 or getattr(form, \'showEmptyGroups\', False):\n+        if len(new_fields) > 0 or getattr(form, "showEmptyGroups", False):\n             _process_widgets(form, widgets, modes, new_fields)\n             if fieldset.__name__ not in groups:\n-                group = GroupFactory(fieldset.__name__,\n-                                     label=fieldset.label,\n-                                     description=fieldset.description,\n-                                     order=fieldset.order,\n-                                     fields=new_fields)\n+                group = GroupFactory(\n+                    fieldset.__name__,\n+                    label=fieldset.label,\n+                    description=fieldset.description,\n+                    order=fieldset.order,\n+                    fields=new_fields,\n+                )\n                 form.groups.append(group)\n                 groups[group.__name__] = group\n \n@@ -204,15 +191,9 @@ def _process_permissions(schema, form, all_fields):\n     permission_cache = {}  # permission name -> allowed/disallowed\n \n     # name => permission name\n-    read_permissions = mergedTaggedValueDict(\n-        schema,\n-        READ_PERMISSIONS_KEY\n-    )\n+    read_permissions = mergedTaggedValueDict(schema, READ_PERMISSIONS_KEY)\n     # name => permission name\n-    write_permissions = mergedTaggedValueDict(\n-        schema,\n-        WRITE_PERMISSIONS_KEY\n-    )\n+    write_permissions = mergedTaggedValueDict(schema, WRITE_PERMISSIONS_KEY)\n     security_manager = getSecurityManager()\n     disallowed_fields = []\n \n@@ -232,10 +213,7 @@ def _process_permissions(schema, form, all_fields):\n                 permission_cache[permission_name] = True\n             else:\n                 permission_cache[permission_name] = bool(\n-                    security_manager.checkPermission(\n-                        permission.title,\n-                        form.context\n-                    )\n+                    security_manager.checkPermission(permission.title, form.context)\n                 )\n         if not permission_cache.get(permission_name, True):\n             disallowed_fields.append(field_name)\n@@ -243,8 +221,7 @@ def _process_permissions(schema, form, all_fields):\n     return all_fields.omit(*disallowed_fields)\n \n \n-def processFields(form, schema, prefix=\'\', defaultGroup=None,\n-                  permissionChecks=True):\n+def processFields(form, schema, prefix="", defaultGroup=None, permissionChecks=True):\n     """Add the fields from the schema to the form, taking into account\n     the hints in the various tagged values as well as fieldsets. If prefix\n     is given, the fields will be prefixed with this prefix. If\n@@ -267,20 +244,18 @@ def processFields(form, schema, prefix=\'\', defaultGroup=None,\n     do_not_process = list(form.fields.keys())\n \n     for field_name, status in omitted.items():\n-        if status and status != \'false\':\n+        if status and status != "false":\n             do_not_process.append(_process_prefixed_name(prefix, field_name))\n \n     for group in form.groups:\n         do_not_process.extend(list(group.fields.keys()))\n-        groups[getattr(group, \'__name__\', group.label)] = group\n+        groups[getattr(group, "__name__", group.label)] = group\n \n     # Find all allowed fields so that we have something to select from\n     omit_read_only = form.mode != DISPLAY_MODE\n-    all_fields = field.Fields(\n-        schema,\n-        prefix=prefix,\n-        omitReadOnly=omit_read_only\n-    ).omit(*do_not_process)\n+    all_fields = field.Fields(schema, prefix=prefix, omitReadOnly=omit_read_only).omit(\n+        *do_not_process\n+    )\n \n     if permissionChecks:\n         all_fields = _process_permissions(schema, form, all_fields)\n@@ -288,14 +263,14 @@ def processFields(form, schema, prefix=\'\', defaultGroup=None,\n \n \n @deprecate(\n-    \'processFieldMoves must not be used any longer. Its implementation is \'\n-    \'unreproducible if same schemas are coming in in different orders. \'\n-    \'The new solution is part of the base.AutoFields class and does \'\n-    \'follow strict rules by first creating a rule dependency tree.\'\n-    \'This function will be remove in a 2.0 releaese and kept until then for \'\n-    \'backward compatibility reasons.\'\n+    "processFieldMoves must not be used any longer. Its implementation is "\n+    "unreproducible if same schemas are coming in in different orders. "\n+    "The new solution is part of the base.AutoFields class and does "\n+    "follow strict rules by first creating a rule dependency tree."\n+    "This function will be remove in a 2.0 releaese and kept until then for "\n+    "backward compatibility reasons."\n )\n-def processFieldMoves(form, schema, prefix=\'\'):\n+def processFieldMoves(form, schema, prefix=""):\n     """Process all field moves stored under ORDER_KEY in the schema tagged\n     value. This should be run after all schemata have been processed with\n     processFields().\n@@ -304,21 +279,20 @@ def processFieldMoves(form, schema, prefix=\'\'):\n     # (name, \'before\'/\'after\', other name)\n     order = mergedTaggedValueList(schema, ORDER_KEY)\n     for field_name, direction, relative_to in order:\n-\n         # Handle shortcut: leading . means \'in this schema\'. May be useful\n         # if you want to move a field relative to one in the current\n         # schema or (more likely) a base schema of the current schema, without\n         # having to repeat the full prefix of this schema.\n \n-        if relative_to.startswith(\'.\'):\n+        if relative_to.startswith("."):\n             relative_to = relative_to[1:]\n             if prefix:\n                 relative_to = expandPrefix(prefix) + relative_to\n \n         try:\n-            if direction == \'before\':\n+            if direction == "before":\n                 move(form, field_name, before=relative_to, prefix=prefix)\n-            elif direction == \'after\':\n+            elif direction == "after":\n                 move(form, field_name, after=relative_to, prefix=prefix)\n         except KeyError:\n             # The relative_to field doesn\'t exist\ndiff --git a/plone/autoform/view.py b/plone/autoform/view.py\nindex bc1e5f6..1f23846 100644\n--- a/plone/autoform/view.py\n+++ b/plone/autoform/view.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.base import AutoFields\n from plone.autoform.interfaces import IWidgetsView\n from plone.z3cform import z2\n@@ -9,7 +8,7 @@\n \n @implementer(IWidgetsView)\n class WidgetsView(AutoFields, DisplayForm):\n-    """Mix-in to allow widgets (in view mode) to be accesed from browser\n+    """Mix-in to allow widgets (in view mode) to be accessed from browser\n     views.\n     """\n \n@@ -29,7 +28,7 @@ def update(self):\n         self._update()\n \n     def render(self):\n-        if getattr(self, \'index\', None) is not None:\n+        if getattr(self, "index", None) is not None:\n             return self.index()\n         raise NotImplementedError("You must implement the \'render\' method")\n \n@@ -66,7 +65,7 @@ def _update(self):\n \n             groups.append(group)\n \n-            group_name = getattr(group, \'__name__\', str(idx))\n+            group_name = getattr(group, "__name__", str(idx))\n             self.fieldsets[group_name] = group\n \n         self.groups = tuple(groups)\ndiff --git a/plone/autoform/view.txt b/plone/autoform/view.txt\nindex 52fa463..6689c67 100644\n--- a/plone/autoform/view.txt\n+++ b/plone/autoform/view.txt\n@@ -15,8 +15,7 @@ First, let\'s load this package\'s ZCML so that we can run the tests:\n     ...\n     ... </configure>\n     ... """\n-    >>> import six\n-    >>> from six import StringIO\n+    >>> from io import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \ndiff --git a/plone/autoform/widgets.py b/plone/autoform/widgets.py\nindex c1f8d08..010855f 100644\n--- a/plone/autoform/widgets.py\n+++ b/plone/autoform/widgets.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.autoform.interfaces import IParameterizedWidget\n from plone.autoform.interfaces import IWidgetExportImportHandler\n from plone.autoform.utils import resolveDottedName\n@@ -17,12 +16,11 @@\n from zope.interface import providedBy\n from zope.schema import getFields\n \n-import six\n import z3c.form.browser.interfaces\n \n \n @implementer(IParameterizedWidget)\n-class ParameterizedWidget(object):\n+class ParameterizedWidget:\n     """A factory for deferred construction of widgets with parameters.\n \n     z3c.form widgets are associated with a particular request,\n@@ -44,49 +42,51 @@ class ParameterizedWidget(object):\n \n     def __init__(self, widget_factory=None, **params):\n         if widget_factory is not None:\n-            if not IFieldWidget.implementedBy(widget_factory) \\\n-                    and not IWidget.implementedBy(widget_factory) \\\n-                    and not isinstance(widget_factory, six.string_types):\n-                raise TypeError(\'widget_factory must be an IFieldWidget \'\n-                                \'or an IWidget\')\n+            if (\n+                not IFieldWidget.implementedBy(widget_factory)\n+                and not IWidget.implementedBy(widget_factory)\n+                and not isinstance(widget_factory, str)\n+            ):\n+                raise TypeError(\n+                    "widget_factory must be an IFieldWidget " "or an IWidget"\n+                )\n         self.widget_factory = widget_factory\n         self.params = params\n \n     def __call__(self, field, request):\n         __traceback_info__ = (\n-            \'{0}, processing:\\n\'\n-            \'- field "{1}"\\n\'\n-            \'- widget: {2}\\n\'\n-            \'- params: {3}\\n\'.format(\n+            "{}, processing:\\n"\n+            \'- field "{}"\\n\'\n+            "- widget: {}\\n"\n+            "- params: {}\\n".format(\n                 self.__class__.__name__,\n                 field.__name__,\n                 repr(self.widget_factory),\n-                self.params\n+                self.params,\n             )\n         )\n-        if isinstance(self.widget_factory, six.string_types):\n-            __traceback_info__ += \'- resolving dotted name\\n\'\n+        if isinstance(self.widget_factory, str):\n+            __traceback_info__ += "- resolving dotted name\\n"\n             self.widget_factory = resolveDottedName(self.widget_factory)\n         if self.widget_factory is None:\n             # use default widget factory for this field type\n-            __traceback_info__ += \'- using default widget factory\\n\'\n+            __traceback_info__ += "- using default widget factory\\n"\n             widget = getMultiAdapter((field, request), IFieldWidget)\n         elif IWidget.implementedBy(self.widget_factory):\n-            __traceback_info__ += \'- calling factory, then wrapping with \' \\\n-                                  \'FieldWidget\\n\'\n+            __traceback_info__ += (\n+                "- calling factory, then wrapping with " "FieldWidget\\n"\n+            )\n             widget = FieldWidget(field, self.widget_factory(request))\n         elif IFieldWidget.implementedBy(self.widget_factory):\n-            __traceback_info__ += \'- calling factory\\n\'\n+            __traceback_info__ += "- calling factory\\n"\n             widget = self.widget_factory(field, request)\n         for k, v in self.params.items():\n             setattr(widget, k, v)\n         return widget\n \n     def __repr__(self):\n-        return \'{0}({1}, {2})\'.format(\n-            self.__class__.__name__,\n-            self.widget_factory,\n-            self.params\n+        return "{}({}, {})".format(\n+            self.__class__.__name__, self.widget_factory, self.params\n         )\n \n     def getWidgetFactoryName(self):\n@@ -97,8 +97,8 @@ def getWidgetFactoryName(self):\n         widget = self.widget_factory\n         if widget is None:\n             return\n-        if not isinstance(widget, six.string_types):\n-            widget = \'{0}.{1}\'.format(widget.__module__, widget.__name__)\n+        if not isinstance(widget, str):\n+            widget = f"{widget.__module__}.{widget.__name__}"\n         return widget\n \n     def getExportImportHandler(self, field):\n@@ -110,25 +110,23 @@ def getExportImportHandler(self, field):\n             # instantiate the widget.\n             sm = getSiteManager()\n             widgetFactory = sm.adapters.lookup(\n-                (providedBy(field), IFormLayer), IFieldWidget)\n+                (providedBy(field), IFormLayer), IFieldWidget\n+            )\n             if widgetFactory is not None:\n-                widgetName = \'{0}.{1}\'.format(\n-                    widgetFactory.__module__,\n-                    widgetFactory.__name__\n+                widgetName = "{}.{}".format(\n+                    widgetFactory.__module__, widgetFactory.__name__\n                 )\n             else:\n-                widgetName = u\'\'\n+                widgetName = ""\n \n-        widgetHandler = queryUtility(IWidgetExportImportHandler,\n-                                     name=widgetName)\n+        widgetHandler = queryUtility(IWidgetExportImportHandler, name=widgetName)\n         if widgetHandler is None:\n             widgetHandler = WidgetExportImportHandler(IHTMLFormElement)\n         return widgetHandler\n \n \n @implementer(IWidgetExportImportHandler)\n-class WidgetExportImportHandler(object):\n-\n+class WidgetExportImportHandler:\n     def __init__(self, widget_schema):\n         self.fieldAttributes = getFields(widget_schema)\n \n@@ -136,10 +134,7 @@ def read(self, widgetNode, params):\n         for attributeName, attributeField in self.fieldAttributes.items():\n             for node in widgetNode.iterchildren():\n                 if noNS(node.tag) == attributeName:\n-                    params[attributeName] = elementToValue(\n-                        attributeField,\n-                        node\n-                    )\n+                    params[attributeName] = elementToValue(attributeField, node)\n \n     def write(self, widgetNode, params):\n         for attributeName, attributeField in self.fieldAttributes.items():\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..9d0c563 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,43 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "internal"\n+name = "Internal:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "documentation"\n+name = "Documentation:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "tests"\n+name = "Tests"\n+showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\n+\n+[tool.dependencychecker]\n+Zope = [\n+  # Zope own provided namespaces\n+  \'App\', \'OFS\', \'Products.Five\', \'Products.OFSP\', \'Products.PageTemplates\',\n+  \'Products.SiteAccess\', \'Shared\', \'Testing\', \'ZPublisher\', \'ZTUtils\',\n+  \'Zope2\', \'webdav\', \'zmi\',\n+  # Zope dependencies\n+  \'Acquisition\', \'DateTime\', \'transaction\', \'zExceptions\', \'ZODB\', \'zope.component\',\n+  \'zope.configuration\', \'zope.container\', \'zope.deferredimport\', \'zope.event\',\n+  \'zope.exceptions\', \'zope.globalrequest\', \'zope.i18n\', \'zope.i18nmessageid\',\n+  \'zope.interface\', \'zope.lifecycleevent\', \'zope.location\', \'zope.publisher\',\n+  \'zope.schema\', \'zope.security\', \'zope.site\', \'zope.traversing\', \'AccessControl\',\n+]\n+\'plone.base\' = [\n+  \'setuptools\', \'AccessControl\', \'Products.BTreeFolder2\', \'Products.CMFCore\',\n+  \'Products.CMFDynamicViewFTI\', \'zope.deprecation\',\n+]\n+python-dateutil = [\'dateutil\']\ndiff --git a/setup.cfg b/setup.cfg\nindex c570e1e..0da8f8f 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,16 +1,23 @@\n-[check-manifest]\n-ignore =\n-    *.cfg\n-    bootstrap.py\n-\n-[isort]\n-force_alphabetical_sort = True\n-force_single_line = True\n-lines_after_imports = 2\n-line_length = 200\n-not_skip = __init__.py\n-\n-\n-\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [bdist_wheel]\n universal = 0\n+\n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n+\n+[check-manifest]\n+ignore =\n+    .editorconfig\n+    .meta.toml\n+    .pre-commit-config.yaml\n+    tox.ini\ndiff --git a/setup.py b/setup.py\nindex 6787369..af81df1 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n@@ -9,12 +8,12 @@ def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n \n-version = \'2.0.1.dev0\'\n+version = "2.0.1.dev0"\n \n-long_description = (read(\'README.rst\') + \'\\n\' + read(\'CHANGES.rst\'))\n+long_description = read("README.rst") + "\\n" + read("CHANGES.rst")\n \n setup(\n-    name=\'plone.autoform\',\n+    name="plone.autoform",\n     version=version,\n     description="Tools to construct z3c.form forms",\n     long_description=long_description,\n@@ -32,26 +31,33 @@ def read(*rnames):\n         "Programming Language :: Python :: 3.11",\n         "Topic :: Software Development :: Libraries :: Python Modules",\n     ],\n-    keywords=\'plone form z3c.form\',\n-    author=\'Martin Aspeli\',\n-    author_email=\'optilude@gmail.com\',\n-    url=\'http://github.com/plone/plone.autoform\',\n-    license=\'LGPL\',\n+    keywords="plone form z3c.form",\n+    author="Martin Aspeli",\n+    author_email="optilude@gmail.com",\n+    url="http://github.com/plone/plone.autoform",\n+    license="LGPL",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n+    python_requires=">=3.8",\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'zope.interface\',\n-        \'zope.schema\',\n-        \'zope.security\',\n-        \'zope.dottedname\',\n-        \'plone.supermodel>=1.3\',\n-        \'plone.z3cform>=2.0.0\',\n-        \'z3c.form\',\n+        "lxml",\n+        "setuptools",\n+        "zope.deprecation",\n+        "zope.interface",\n+        "zope.schema",\n+        "zope.security",\n+        "zope.dottedname",\n+        "plone.supermodel>=1.3",\n+        "plone.z3cform>=2.0.0",\n+        "z3c.form",\n     ],\n+    extras_require={\n+        "test": [\n+            "plone.testing",\n+        ],\n+    },\n     entry_points="""\n     # -*- Entry points: -*-\n     """,\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..3f04073\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,50 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[tox]\n+envlist =\n+    format\n+    lint\n+    test\n+\n+[testenv]\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat code\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a pyupgrade\n+    pre-commit run -a isort\n+    pre-commit run -a black\n+    pre-commit run -a zpretty\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a\n+\n+[testenv:dependencies]\n+description = check if the package defines all its dependencies and generate a graph out of them\n+deps =\n+    z3c.dependencychecker==2.11\n+    pipdeptree==2.5.1\n+    graphviz  # optional dependency of pipdeptree\n+commands =\n+    dependencychecker\n+    sh -c \'pipdeptree --exclude setuptools,pipdeptree,wheel,pipdeptree,z3c.dependencychecker,zope.interface,zope.component --graph-output svg > dependencies.svg\'\n+\n+[testenv:test]\n+usedevelop = true\n+deps =\n+    zope.testrunner\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    zope-testrunner --test-path={toxinidir} -s plone.autoform\n+extras =\n+    test\n'

