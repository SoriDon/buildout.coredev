Repository: plone.namedfile


Branch: refs/heads/master
Date: 2022-06-21T11:30:10+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.namedfile/commit/05696daf516090b21a97ad7e3ce3502270691ae0

Let NavigationRootScaling use the new image_scales metadata.

Fall back to getObject.

Files changed:
M plone/namedfile/scaling.py
M setup.py
M sources-60.ini

b'diff --git a/plone/namedfile/scaling.py b/plone/namedfile/scaling.py\nindex 7b20dc5..074662c 100644\n--- a/plone/namedfile/scaling.py\n+++ b/plone/namedfile/scaling.py\n@@ -17,12 +17,14 @@\n from plone.scale.interfaces import IScaledImageQuality\n from plone.scale.scale import scaleImage\n from plone.scale.storage import IImageScaleStorage\n+from Products.CMFCore.utils import getToolByName\n from Products.CMFPlone.utils import safe_encode\n from Products.Five import BrowserView\n from xml.sax.saxutils import quoteattr\n from zExceptions import Unauthorized\n from ZODB.blob import BlobFile\n from ZODB.POSException import ConflictError\n+from zope.cachedescriptors.property import Lazy as lazy_property\n from zope.component import getMultiAdapter\n from zope.component import queryUtility\n from zope.deprecation import deprecate\n@@ -41,6 +43,25 @@\n _marker = object()\n \n \n+def _image_tag_from_values(*values):\n+    """Turn list of tuples into an img tag.\n+\n+    Naturally, this should at least contain ("src", "some url").\n+    """\n+    parts = ["<img"]\n+    for k, v in values:\n+        if v is None:\n+            continue\n+        if isinstance(v, int):\n+            v = str(v)\n+        elif isinstance(v, bytes):\n+            v = str(v, "utf8")\n+        parts.append(f"{k}={quoteattr(v)}")\n+    parts.append("/>")\n+\n+    return " ".join(parts)\n+\n+\n class ImageScale(BrowserView):\n     """view used for rendering image scales"""\n \n@@ -120,19 +141,7 @@ def tag(\n             values.append(("srcset", srcset_attr))\n \n         values.extend(kwargs.items())\n-\n-        parts = ["<img"]\n-        for k, v in values:\n-            if v is None:\n-                continue\n-            if isinstance(v, int):\n-                v = str(v)\n-            elif isinstance(v, bytes):\n-                v = str(v, "utf8")\n-            parts.append(f"{k}={quoteattr(v)}")\n-        parts.append("/>")\n-\n-        return " ".join(parts)\n+        return _image_tag_from_values(*values)\n \n     def validate_access(self):\n         fieldname = getattr(self.data, "fieldname", getattr(self, "fieldname", None))\n@@ -661,6 +670,18 @@ def picture(\n \n \n class NavigationRootScaling(ImageScaling):\n+    @lazy_property\n+    def _supports_image_scales_metadata(self):\n+        # Do we have the image_scales in the portal_catalog?\n+        # Expected to be False on Plone 5.2, True on Plone 6.0.\n+        catalog = getToolByName(self.context, "portal_catalog")\n+        return "image_scales" in catalog._catalog.schema\n+\n+    @lazy_property\n+    def _supports_hidpi(self):\n+        # Do we have any "old-style" high DPI scales (2x/3x)?\n+        return bool(self.getHighPixelDensityScales())\n+\n     def _scale_cachekey(method, self, brain, fieldname, **kwargs):\n         return (\n             self.context.absolute_url(),\n@@ -672,11 +693,75 @@ def _scale_cachekey(method, self, brain, fieldname, **kwargs):\n \n     @ram.cache(_scale_cachekey)\n     def tag(self, brain, fieldname, **kwargs):\n+        if self._supports_image_scales_metadata:\n+            tag = self._tag_from_brain_image_scales(brain, fieldname, **kwargs)\n+            if tag:\n+                return tag\n         obj = brain.getObject()\n         images = obj.restrictedTraverse("@@images")\n         tag = images.tag(fieldname, **kwargs)\n         return tag\n \n+    def _tag_from_brain_image_scales(\n+        self,\n+        brain,\n+        fieldname,\n+        scale=None,\n+        alt=_marker,\n+        css_class=None,\n+        title=_marker,\n+        **kwargs,\n+    ):\n+        """Try to get a tag from the image_scales metadata.\n+\n+        If we have any non-standard keyword arguments, we cannot use this method.\n+        Especially you cannot set a direction: we must use the default "thumbnail".\n+\n+        Also, no old-style hidpi srcsets are included.  If the site has enabled this,\n+        we return nothing: this information is not (easily) available in the brain.\n+        """\n+        if self._supports_hidpi:\n+            return\n+        if not (brain and fieldname and scale):\n+            return\n+        if kwargs:\n+            # too many keyword arguments\n+            return\n+        if not getattr(brain, "image_scales", None):\n+            # no images here at all\n+            return\n+        if fieldname not in brain.image_scales:\n+            return\n+        try:\n+            # Note: per field we get a list with dicts.\n+            # For normal image fields this will always be one dict.\n+            # When the field is a RelationList pointing to images,\n+            # it might contain more.  That does not sound like something\n+            # we can support out of the box, so we always use the first one.\n+            # This probably makes the most sense in that corner case as well.\n+            data = brain.image_scales[fieldname][0]["scales"][scale]\n+        except (KeyError, IndexError):\n+            return\n+\n+        # data has download, height and width\n+        if title is _marker:\n+            title = brain.Title\n+            if callable(title):\n+                # Brain may be a CatalogContentListingObject.\n+                title = title()\n+        if alt is _marker:\n+            alt = title\n+        values = [\n+            ("src", data["download"]),\n+            ("alt", alt),\n+            ("title", title),\n+            ("height", data["height"]),\n+            ("width", data["width"]),\n+        ]\n+        if css_class:\n+            values.append(("class", css_class))\n+        return _image_tag_from_values(*values)\n+\n \n def _scale_sort_key(item):\n     key, value = item\ndiff --git a/setup.py b/setup.py\nindex 03c2727..2a477ad 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -55,6 +55,7 @@\n         "plone.supermodel",\n         "setuptools",\n         "zope.browserpage",\n+        "zope.cachedescriptors",\n         "zope.component",\n         "zope.copy",\n         "zope.security",\ndiff --git a/sources-60.ini b/sources-60.ini\nindex 5ff6556..f69c5e7 100644\n--- a/sources-60.ini\n+++ b/sources-60.ini\n@@ -10,7 +10,12 @@ constraints-out = constraints-60-mxdev.txt\n ignores =\n     plone.namedfile\n     plone.scale\n+    Products.CMFPlone\n \n [plone.scale]\n url = https://github.com/plone/plone.scale.git\n branch = pre-scale\n+\n+[Products.CMFPlone]\n+url = https://github.com/plone/Products.CMFPlone.git\n+branch = image_scales_metadata\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2022-06-21T12:01:39+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.namedfile/commit/8bc64294104b616855780faa4ab5f6cbed783dc8

Register adapter for image fields to the new image_scales metadata.

Files changed:
A news/3521.feature
A plone/namedfile/adapters.py
M plone/namedfile/configure.zcml

b'diff --git a/news/3521.feature b/news/3521.feature\nnew file mode 100644\nindex 0000000..5e6737c\n--- /dev/null\n+++ b/news/3521.feature\n@@ -0,0 +1,4 @@\n+Register adapter for image fields to the new image_scales metadata.\n+Use this in the image_scale view to get images from a list a brains.\n+This code is not active on Plone 5, only Plone 6.\n+[cekk, maurits]\ndiff --git a/plone/namedfile/adapters.py b/plone/namedfile/adapters.py\nnew file mode 100644\nindex 0000000..33b636b\n--- /dev/null\n+++ b/plone/namedfile/adapters.py\n@@ -0,0 +1,115 @@\n+# Note: this file should only be loaded in zcml on Plone 6, with plone.base.\n+from plone.base.interfaces import IImageScalesFieldAdapter\n+from plone.base.interfaces import IImagingSchema\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.namedfile.interfaces import INamedImageField\n+from plone.registry.interfaces import IRegistry\n+from zope.component import adapter\n+from zope.component import getMultiAdapter\n+from zope.component import getUtility\n+from zope.interface import implementer\n+from zope.interface import Interface\n+\n+\n+def _split_scale_info(allowed_size):\n+    name, dims = allowed_size.split(" ")\n+    width, height = list(map(int, dims.split(":")))\n+    return name, width, height\n+\n+\n+def _get_scale_infos():\n+    """Returns list of (name, width, height) of the available image scales."""\n+    registry = getUtility(IRegistry)\n+    imaging_settings = registry.forInterface(IImagingSchema, prefix="plone")\n+    allowed_sizes = imaging_settings.allowed_sizes\n+    return [_split_scale_info(size) for size in allowed_sizes]\n+\n+\n+@implementer(IImageScalesFieldAdapter)\n+@adapter(INamedImageField, IDexterityContent, Interface)\n+class ImageFieldScales:\n+    def __init__(self, field, context, request):\n+        self.context = context\n+        self.request = request\n+        self.field = field\n+\n+    def __call__(self):\n+        image = self.field.get(self.context)\n+        if not image:\n+            return\n+\n+        # Get the @@images view once and store it, so all methods can use it.\n+        self.images_view = getMultiAdapter((self.context, self.request), name="images")\n+        width, height = image.getImageSize()\n+        url = self.get_original_image_url(self.field.__name__, width, height)\n+        scales = self.get_scales(self.field, width, height)\n+\n+        # Return a list with one dictionary.  Why a list?\n+        # Some people feel a need in custom code to support a different adapter for\n+        # RelationList fields.  Such a field may point to three images.\n+        # In that case the adapter could return information for all three images,\n+        # so a list of three dictionaries.  The default case should use the same\n+        # structure.\n+        return [\n+            {\n+                "filename": image.filename,\n+                "content-type": image.contentType,\n+                "size": image.getSize(),\n+                "download": url,\n+                "width": width,\n+                "height": height,\n+                "scales": scales,\n+            }\n+        ]\n+\n+    def get_scales(self, field, width, height):\n+        """Get a dictionary of available scales for a particular image field,\n+        with the actual dimensions (aspect ratio of the original image).\n+        """\n+        scales = {}\n+\n+        for name, actual_width, actual_height in _get_scale_infos():\n+            if actual_width > width:\n+                # The width of the scale is larger than the original width.\n+                # Scaling would simply return the original (or perhaps a copy\n+                # with the same size).  We do not need this scale.\n+                # If we *do* want this, we should call the scale method with\n+                # mode="cover", so it scales up.\n+                continue\n+\n+            # Get the scale info without actually generating the scale,\n+            # nor any old-style HiDPI scales.\n+            scale = self.images_view.scale(\n+                field.__name__,\n+                width=actual_width,\n+                height=actual_height,\n+                pre=True,\n+                include_srcset=False,\n+            )\n+            if scale is None:\n+                # If we cannot get a scale, it is probably a corrupt image.\n+                continue\n+\n+            url = scale.url\n+            actual_width = scale.width\n+            actual_height = scale.height\n+\n+            scales[name] = {\n+                "download": url,\n+                "width": actual_width,\n+                "height": actual_height,\n+            }\n+\n+        return scales\n+\n+    def get_original_image_url(self, fieldname, width, height):\n+        scale = self.images_view.scale(\n+            fieldname,\n+            width=width,\n+            height=height,\n+            direction="thumbnail",\n+            pre=True,\n+            include_srcset=False,\n+        )\n+        # Corrupt images may not have a scale.\n+        return scale.url if scale else None\ndiff --git a/plone/namedfile/configure.zcml b/plone/namedfile/configure.zcml\nindex b4aeae2..d33aa89 100644\n--- a/plone/namedfile/configure.zcml\n+++ b/plone/namedfile/configure.zcml\n@@ -24,4 +24,7 @@\n   <include file="editor.zcml" />\n   <include file="field.zcml" />\n \n+  <!-- This adapter is only needed and used on Plone 6.  -->\n+  <adapter zcml:condition="installed plone.base" factory=".adapters.ImageFieldScales" />\n+\n </configure>\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2022-06-22T00:19:36+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.namedfile/commit/f85ea3aa51cd7673677bc111030a3999caf8f624

Add tests for our IImageScalesFieldAdapter.

Files changed:
A plone/namedfile/tests/900.jpg
A plone/namedfile/tests/dummy.py
A plone/namedfile/tests/test_adapters.py
A plone/namedfile/tests/tool.gif
M plone/namedfile/testing.zcml

b'diff --git a/plone/namedfile/testing.zcml b/plone/namedfile/testing.zcml\nindex 903a60a..78e8885 100644\n--- a/plone/namedfile/testing.zcml\n+++ b/plone/namedfile/testing.zcml\n@@ -9,5 +9,9 @@\n   <permission id="zope2.View" title="View" />\n \n   <include package="plone.namedfile" />\n+  <class class="plone.dexterity.content.DexterityContent">\n+    <!-- This is normally done in plone.app.dexterity. -->\n+    <implements interface="plone.namedfile.interfaces.IImageScaleTraversable" />\n+  </class>\n \n </configure>\ndiff --git a/plone/namedfile/tests/900.jpg b/plone/namedfile/tests/900.jpg\nnew file mode 100644\nindex 0000000..e9ef7db\nBinary files /dev/null and b/plone/namedfile/tests/900.jpg differ\ndiff --git a/plone/namedfile/tests/dummy.py b/plone/namedfile/tests/dummy.py\nnew file mode 100644\nindex 0000000..6102108\n--- /dev/null\n+++ b/plone/namedfile/tests/dummy.py\n@@ -0,0 +1,61 @@\n+from io import BytesIO\n+from ZPublisher.HTTPRequest import FileUpload\n+\n+import os\n+\n+\n+GIF_FILE = os.path.join(os.path.dirname(__file__), "tool.gif")\n+with open(GIF_FILE, "rb") as f:\n+    GIF = f.read()\n+# jpeg file of 900x900 pixels\n+JPEG_FILE = os.path.join(os.path.dirname(__file__), "900.jpg")\n+with open(JPEG_FILE, "rb") as f:\n+    JPEG = f.read()\n+\n+\n+class File(FileUpload):\n+    """Dummy upload object\n+    Used to fake uploaded files.\n+    """\n+\n+    __allow_access_to_unprotected_subobjects__ = 1\n+    filename = "dummy.txt"\n+    data = b"file data"\n+    headers = {}\n+\n+    def __init__(self, filename=None, data=None, headers=None):\n+        if filename is not None:\n+            self.filename = filename\n+        if data is not None:\n+            self.data = data\n+        if headers is not None:\n+            self.headers = headers\n+        self.file = BytesIO(self.data)\n+\n+    def seek(self, *args):\n+        pass\n+\n+    def tell(self, *args):\n+        return 1\n+\n+    def read(self, *args):\n+        return self.data\n+\n+\n+class Image(File):\n+    """Dummy image upload object\n+    Contains valid image data by default.\n+    """\n+\n+    filename = "dummy.gif"\n+    data = GIF\n+\n+\n+class JpegImage(File):\n+    """Dummy jpeg image upload object\n+\n+    900 by 900 pixels.\n+    """\n+\n+    filename = "900.jpeg"\n+    data = JPEG\ndiff --git a/plone/namedfile/tests/test_adapters.py b/plone/namedfile/tests/test_adapters.py\nnew file mode 100644\nindex 0000000..e2b93ab\n--- /dev/null\n+++ b/plone/namedfile/tests/test_adapters.py\n@@ -0,0 +1,133 @@\n+from plone.base.interfaces import IImageScalesFieldAdapter\n+from plone.dexterity.content import Item\n+from plone.namedfile.field import NamedImage as NamedImageField\n+from plone.namedfile.file import NamedImage\n+from plone.namedfile.testing import PLONE_NAMEDFILE_INTEGRATION_TESTING\n+from plone.namedfile.tests import dummy\n+from unittest.mock import patch\n+from zope.component import queryMultiAdapter\n+from zope.publisher.browser import TestRequest\n+\n+import unittest\n+import plone.namedfile.adapters\n+\n+\n+def patch_get_scale_infos():\n+    # The IRegistry utility cannot be found in the test layer,\n+    # so we mock what Plone 6 would return.\n+    return [\n+        ("huge", 1600, 65536),\n+        ("great", 1200, 65536),\n+        ("larger", 1000, 65536),\n+        ("large", 800, 65536),\n+        ("teaser", 600, 65536),\n+        ("preview", 400, 65536),\n+        ("mini", 200, 65536),\n+        ("thumb", 128, 128),\n+        ("tile", 64, 64),\n+        ("icon", 32, 32),\n+        ("listing", 16, 16),\n+    ]\n+\n+\n+class ImageScalesAdaptersRegisteredTest(unittest.TestCase):\n+    """Test portal actions control panel."""\n+\n+    layer = PLONE_NAMEDFILE_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.request = TestRequest()\n+        self.content = Item()\n+\n+    @patch.object(\n+        plone.namedfile.adapters,\n+        "_get_scale_infos",\n+        new=patch_get_scale_infos,\n+        spec=True,\n+    )\n+    def serialize(self, context, field):\n+        serializer = queryMultiAdapter(\n+            (field, context, self.request), IImageScalesFieldAdapter\n+        )\n+        if serializer:\n+            return serializer()\n+        return\n+\n+    def create_field(self, value=None):\n+        field = NamedImageField()\n+        field.__name__ = "image1"\n+        field.set(self.content, value)\n+        return field\n+\n+    def test_field_adapter_return_scales(self):\n+        image = NamedImage(dummy.Image(), filename="dummy.gif")\n+        field = self.create_field(image)\n+        res = self.serialize(self.content, field)\n+        self.assertNotEqual(res, None)\n+        self.assertEqual(len(res), 1)\n+        res = res[0]\n+        download = res.pop("download")\n+        scales = res.pop("scales")\n+        self.assertEqual(\n+            res,\n+            {\n+                "content-type": "image/gif",\n+                "filename": "dummy.gif",\n+                "height": 16,\n+                "size": 168,\n+                "width": 16,\n+            },\n+        )\n+        # Note: self.content.absolute_url() is actually empty in this test.\n+        images_url = self.content.absolute_url() + "/@@images"\n+        self.assertTrue(download.startswith(f"{images_url}/image1-16-"))\n+        self.assertTrue(download.endswith(".gif"))\n+        self.assertIn("listing", scales)\n+        self.assertEqual(len(scales), 1)\n+        listing = scales["listing"]\n+        self.assertEqual(sorted(listing.keys()), ["download", "height", "width"])\n+        self.assertEqual(listing["height"], 16)\n+        self.assertEqual(listing["width"], 16)\n+        download = listing["download"]\n+        self.assertTrue(download.startswith(f"{images_url}/image1-16-"))\n+        self.assertTrue(download.endswith(".gif"))\n+\n+    def test_field_adapter_do_not_return_scales_for_empty_fields_with_adapter(self):\n+        field = self.create_field()\n+        res = self.serialize(self.content, field)\n+        self.assertEqual(res, None)\n+\n+    def test_field_adapter_does_not_return_larger_scales(self):\n+        # Add an image of 900 by 900 pixels.\n+        image = NamedImage(dummy.JpegImage(), filename="900.jpeg")\n+        field = self.create_field(image)\n+        res = self.serialize(self.content, field)\n+        self.assertNotEqual(res, None)\n+        self.assertEqual(len(res), 1)\n+        res = res[0]\n+        download = res.pop("download")\n+        scales = res.pop("scales")\n+        self.assertEqual(\n+            res,\n+            {\n+                "content-type": "image/jpeg",\n+                "filename": "900.jpeg",\n+                "height": 900,\n+                "size": 160651,\n+                "width": 900,\n+            },\n+        )\n+        # Note: self.content.absolute_url() is actually empty in this test.\n+        images_url = self.content.absolute_url() + "/@@images"\n+        self.assertTrue(download.startswith(f"{images_url}/image1-900-"))\n+        self.assertTrue(download.endswith(".jpeg"))\n+        # larger and huge should not be in here: these scales would return the same\n+        # content as the original.\n+        self.assertEqual(\n+            sorted(scales.keys()),\n+            ["icon", "large", "listing", "mini", "preview", "teaser", "thumb", "tile"],\n+        )\n+        preview = scales["preview"]\n+        self.assertEqual(preview["width"], 400)\n+        self.assertEqual(preview["height"], 400)\n+        self.assertTrue(preview["download"].startswith(f"{images_url}/image1-400-"))\ndiff --git a/plone/namedfile/tests/tool.gif b/plone/namedfile/tests/tool.gif\nnew file mode 100644\nindex 0000000..1b2f53b\nBinary files /dev/null and b/plone/namedfile/tests/tool.gif differ\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2022-06-22T00:43:43+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.namedfile/commit/0c3e483214513aa923baa8f0057066c4378923c7

test_adapters: skip most tests on Plone 5.

For good measure added one test for Plone 5, to see that nothing is returned, which we skip in Plone 6.
Make sure adapters.py can be loaded also on Plone 5, even if it is not used.
The idea is that test_adapters should be importable on Plone 5 and contain at least one test, otherwise the test runner will complain.

Files changed:
M plone/namedfile/adapters.py
M plone/namedfile/tests/test_adapters.py

b'diff --git a/plone/namedfile/adapters.py b/plone/namedfile/adapters.py\nindex 33b636b..bf463cf 100644\n--- a/plone/namedfile/adapters.py\n+++ b/plone/namedfile/adapters.py\n@@ -1,6 +1,3 @@\n-# Note: this file should only be loaded in zcml on Plone 6, with plone.base.\n-from plone.base.interfaces import IImageScalesFieldAdapter\n-from plone.base.interfaces import IImagingSchema\n from plone.dexterity.interfaces import IDexterityContent\n from plone.namedfile.interfaces import INamedImageField\n from plone.registry.interfaces import IRegistry\n@@ -11,6 +8,15 @@\n from zope.interface import Interface\n \n \n+try:\n+    from plone.base.interfaces import IImageScalesFieldAdapter\n+    from plone.base.interfaces import IImagingSchema\n+except ImportError:\n+    # BBB Plone 5\n+    IImageScalesFieldAdapter = Interface\n+    IImagingSchema = None\n+\n+\n def _split_scale_info(allowed_size):\n     name, dims = allowed_size.split(" ")\n     width, height = list(map(int, dims.split(":")))\n@@ -19,6 +25,8 @@ def _split_scale_info(allowed_size):\n \n def _get_scale_infos():\n     """Returns list of (name, width, height) of the available image scales."""\n+    if IImagingSchema is None:\n+        return []\n     registry = getUtility(IRegistry)\n     imaging_settings = registry.forInterface(IImagingSchema, prefix="plone")\n     allowed_sizes = imaging_settings.allowed_sizes\ndiff --git a/plone/namedfile/tests/test_adapters.py b/plone/namedfile/tests/test_adapters.py\nindex e2b93ab..b144aeb 100644\n--- a/plone/namedfile/tests/test_adapters.py\n+++ b/plone/namedfile/tests/test_adapters.py\n@@ -1,4 +1,3 @@\n-from plone.base.interfaces import IImageScalesFieldAdapter\n from plone.dexterity.content import Item\n from plone.namedfile.field import NamedImage as NamedImageField\n from plone.namedfile.file import NamedImage\n@@ -8,8 +7,14 @@\n from zope.component import queryMultiAdapter\n from zope.publisher.browser import TestRequest\n \n-import unittest\n import plone.namedfile.adapters\n+import unittest\n+\n+\n+try:\n+    from plone.base.interfaces import IImageScalesFieldAdapter\n+except ImportError:\n+    IImageScalesFieldAdapter = None\n \n \n def patch_get_scale_infos():\n@@ -59,6 +64,7 @@ def create_field(self, value=None):\n         field.set(self.content, value)\n         return field\n \n+    @unittest.skipIf(IImageScalesFieldAdapter is None, "Skipping on Plone 5")\n     def test_field_adapter_return_scales(self):\n         image = NamedImage(dummy.Image(), filename="dummy.gif")\n         field = self.create_field(image)\n@@ -92,11 +98,19 @@ def test_field_adapter_return_scales(self):\n         self.assertTrue(download.startswith(f"{images_url}/image1-16-"))\n         self.assertTrue(download.endswith(".gif"))\n \n+    @unittest.skipIf(IImageScalesFieldAdapter is not None, "Skipping on Plone 6")\n+    def test_field_adapter_return_nothing_without_plone_base(self):\n+        image = NamedImage(dummy.Image(), filename="dummy.gif")\n+        field = self.create_field(image)\n+        res = self.serialize(self.content, field)\n+        self.assertIsNone(res)\n+\n     def test_field_adapter_do_not_return_scales_for_empty_fields_with_adapter(self):\n         field = self.create_field()\n         res = self.serialize(self.content, field)\n         self.assertEqual(res, None)\n \n+    @unittest.skipIf(IImageScalesFieldAdapter is None, "Skipping on Plone 5")\n     def test_field_adapter_does_not_return_larger_scales(self):\n         # Add an image of 900 by 900 pixels.\n         image = NamedImage(dummy.JpegImage(), filename="900.jpeg")\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2022-06-22T00:48:45+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.namedfile/commit/251460b1437a590661891d1f73c6bbca702bf61f

For testing, we need plone.base branch image_scales_metadata

Files changed:
M sources-60.ini

b'diff --git a/sources-60.ini b/sources-60.ini\nindex f69c5e7..759af57 100644\n--- a/sources-60.ini\n+++ b/sources-60.ini\n@@ -10,12 +10,12 @@ constraints-out = constraints-60-mxdev.txt\n ignores =\n     plone.namedfile\n     plone.scale\n-    Products.CMFPlone\n+    plone.base\n \n [plone.scale]\n url = https://github.com/plone/plone.scale.git\n branch = pre-scale\n \n-[Products.CMFPlone]\n-url = https://github.com/plone/Products.CMFPlone.git\n+[plone.base]\n+url = https://github.com/plone/plone.base.git\n branch = image_scales_metadata\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2022-06-22T10:42:20+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.namedfile/commit/df1df12302a26b6a6b04e2ec0162e4f37807bc3e

image_scales: catch ComponentLookupError when getting images view.

Files changed:
M plone/namedfile/adapters.py

b'diff --git a/plone/namedfile/adapters.py b/plone/namedfile/adapters.py\nindex bf463cf..c38bdda 100644\n--- a/plone/namedfile/adapters.py\n+++ b/plone/namedfile/adapters.py\n@@ -6,6 +6,7 @@\n from zope.component import getUtility\n from zope.interface import implementer\n from zope.interface import Interface\n+from zope.interface.interfaces import ComponentLookupError\n \n \n try:\n@@ -47,7 +48,12 @@ def __call__(self):\n             return\n \n         # Get the @@images view once and store it, so all methods can use it.\n-        self.images_view = getMultiAdapter((self.context, self.request), name="images")\n+        try:\n+            self.images_view = getMultiAdapter((self.context, self.request), name="images")\n+        except ComponentLookupError:\n+            # Seen in plone.app.caching.tests.test_profile_with_caching_proxy.\n+            # If we cannot find the images view, there is nothing for us to do.\n+            return\n         width, height = image.getImageSize()\n         url = self.get_original_image_url(self.field.__name__, width, height)\n         scales = self.get_scales(self.field, width, height)\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2022-06-22T22:15:15+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.namedfile/commit/a7d90a68e7127d72bc7b27e9615dc2bd700d1c87

Merge pull request #121 from plone/maurits-navigationrootscaling-use-image-scales-metadata

Let NavigationRootScaling use the new image_scales metadata.

Files changed:
A news/3521.feature
A plone/namedfile/adapters.py
A plone/namedfile/tests/900.jpg
A plone/namedfile/tests/dummy.py
A plone/namedfile/tests/test_adapters.py
A plone/namedfile/tests/tool.gif
M plone/namedfile/configure.zcml
M plone/namedfile/scaling.py
M plone/namedfile/testing.zcml
M setup.py
M sources-60.ini

b'diff --git a/news/3521.feature b/news/3521.feature\nnew file mode 100644\nindex 0000000..5e6737c\n--- /dev/null\n+++ b/news/3521.feature\n@@ -0,0 +1,4 @@\n+Register adapter for image fields to the new image_scales metadata.\n+Use this in the image_scale view to get images from a list a brains.\n+This code is not active on Plone 5, only Plone 6.\n+[cekk, maurits]\ndiff --git a/plone/namedfile/adapters.py b/plone/namedfile/adapters.py\nnew file mode 100644\nindex 0000000..c38bdda\n--- /dev/null\n+++ b/plone/namedfile/adapters.py\n@@ -0,0 +1,129 @@\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.namedfile.interfaces import INamedImageField\n+from plone.registry.interfaces import IRegistry\n+from zope.component import adapter\n+from zope.component import getMultiAdapter\n+from zope.component import getUtility\n+from zope.interface import implementer\n+from zope.interface import Interface\n+from zope.interface.interfaces import ComponentLookupError\n+\n+\n+try:\n+    from plone.base.interfaces import IImageScalesFieldAdapter\n+    from plone.base.interfaces import IImagingSchema\n+except ImportError:\n+    # BBB Plone 5\n+    IImageScalesFieldAdapter = Interface\n+    IImagingSchema = None\n+\n+\n+def _split_scale_info(allowed_size):\n+    name, dims = allowed_size.split(" ")\n+    width, height = list(map(int, dims.split(":")))\n+    return name, width, height\n+\n+\n+def _get_scale_infos():\n+    """Returns list of (name, width, height) of the available image scales."""\n+    if IImagingSchema is None:\n+        return []\n+    registry = getUtility(IRegistry)\n+    imaging_settings = registry.forInterface(IImagingSchema, prefix="plone")\n+    allowed_sizes = imaging_settings.allowed_sizes\n+    return [_split_scale_info(size) for size in allowed_sizes]\n+\n+\n+@implementer(IImageScalesFieldAdapter)\n+@adapter(INamedImageField, IDexterityContent, Interface)\n+class ImageFieldScales:\n+    def __init__(self, field, context, request):\n+        self.context = context\n+        self.request = request\n+        self.field = field\n+\n+    def __call__(self):\n+        image = self.field.get(self.context)\n+        if not image:\n+            return\n+\n+        # Get the @@images view once and store it, so all methods can use it.\n+        try:\n+            self.images_view = getMultiAdapter((self.context, self.request), name="images")\n+        except ComponentLookupError:\n+            # Seen in plone.app.caching.tests.test_profile_with_caching_proxy.\n+            # If we cannot find the images view, there is nothing for us to do.\n+            return\n+        width, height = image.getImageSize()\n+        url = self.get_original_image_url(self.field.__name__, width, height)\n+        scales = self.get_scales(self.field, width, height)\n+\n+        # Return a list with one dictionary.  Why a list?\n+        # Some people feel a need in custom code to support a different adapter for\n+        # RelationList fields.  Such a field may point to three images.\n+        # In that case the adapter could return information for all three images,\n+        # so a list of three dictionaries.  The default case should use the same\n+        # structure.\n+        return [\n+            {\n+                "filename": image.filename,\n+                "content-type": image.contentType,\n+                "size": image.getSize(),\n+                "download": url,\n+                "width": width,\n+                "height": height,\n+                "scales": scales,\n+            }\n+        ]\n+\n+    def get_scales(self, field, width, height):\n+        """Get a dictionary of available scales for a particular image field,\n+        with the actual dimensions (aspect ratio of the original image).\n+        """\n+        scales = {}\n+\n+        for name, actual_width, actual_height in _get_scale_infos():\n+            if actual_width > width:\n+                # The width of the scale is larger than the original width.\n+                # Scaling would simply return the original (or perhaps a copy\n+                # with the same size).  We do not need this scale.\n+                # If we *do* want this, we should call the scale method with\n+                # mode="cover", so it scales up.\n+                continue\n+\n+            # Get the scale info without actually generating the scale,\n+            # nor any old-style HiDPI scales.\n+            scale = self.images_view.scale(\n+                field.__name__,\n+                width=actual_width,\n+                height=actual_height,\n+                pre=True,\n+                include_srcset=False,\n+            )\n+            if scale is None:\n+                # If we cannot get a scale, it is probably a corrupt image.\n+                continue\n+\n+            url = scale.url\n+            actual_width = scale.width\n+            actual_height = scale.height\n+\n+            scales[name] = {\n+                "download": url,\n+                "width": actual_width,\n+                "height": actual_height,\n+            }\n+\n+        return scales\n+\n+    def get_original_image_url(self, fieldname, width, height):\n+        scale = self.images_view.scale(\n+            fieldname,\n+            width=width,\n+            height=height,\n+            direction="thumbnail",\n+            pre=True,\n+            include_srcset=False,\n+        )\n+        # Corrupt images may not have a scale.\n+        return scale.url if scale else None\ndiff --git a/plone/namedfile/configure.zcml b/plone/namedfile/configure.zcml\nindex b4aeae2..d33aa89 100644\n--- a/plone/namedfile/configure.zcml\n+++ b/plone/namedfile/configure.zcml\n@@ -24,4 +24,7 @@\n   <include file="editor.zcml" />\n   <include file="field.zcml" />\n \n+  <!-- This adapter is only needed and used on Plone 6.  -->\n+  <adapter zcml:condition="installed plone.base" factory=".adapters.ImageFieldScales" />\n+\n </configure>\ndiff --git a/plone/namedfile/scaling.py b/plone/namedfile/scaling.py\nindex 7b20dc5..074662c 100644\n--- a/plone/namedfile/scaling.py\n+++ b/plone/namedfile/scaling.py\n@@ -17,12 +17,14 @@\n from plone.scale.interfaces import IScaledImageQuality\n from plone.scale.scale import scaleImage\n from plone.scale.storage import IImageScaleStorage\n+from Products.CMFCore.utils import getToolByName\n from Products.CMFPlone.utils import safe_encode\n from Products.Five import BrowserView\n from xml.sax.saxutils import quoteattr\n from zExceptions import Unauthorized\n from ZODB.blob import BlobFile\n from ZODB.POSException import ConflictError\n+from zope.cachedescriptors.property import Lazy as lazy_property\n from zope.component import getMultiAdapter\n from zope.component import queryUtility\n from zope.deprecation import deprecate\n@@ -41,6 +43,25 @@\n _marker = object()\n \n \n+def _image_tag_from_values(*values):\n+    """Turn list of tuples into an img tag.\n+\n+    Naturally, this should at least contain ("src", "some url").\n+    """\n+    parts = ["<img"]\n+    for k, v in values:\n+        if v is None:\n+            continue\n+        if isinstance(v, int):\n+            v = str(v)\n+        elif isinstance(v, bytes):\n+            v = str(v, "utf8")\n+        parts.append(f"{k}={quoteattr(v)}")\n+    parts.append("/>")\n+\n+    return " ".join(parts)\n+\n+\n class ImageScale(BrowserView):\n     """view used for rendering image scales"""\n \n@@ -120,19 +141,7 @@ def tag(\n             values.append(("srcset", srcset_attr))\n \n         values.extend(kwargs.items())\n-\n-        parts = ["<img"]\n-        for k, v in values:\n-            if v is None:\n-                continue\n-            if isinstance(v, int):\n-                v = str(v)\n-            elif isinstance(v, bytes):\n-                v = str(v, "utf8")\n-            parts.append(f"{k}={quoteattr(v)}")\n-        parts.append("/>")\n-\n-        return " ".join(parts)\n+        return _image_tag_from_values(*values)\n \n     def validate_access(self):\n         fieldname = getattr(self.data, "fieldname", getattr(self, "fieldname", None))\n@@ -661,6 +670,18 @@ def picture(\n \n \n class NavigationRootScaling(ImageScaling):\n+    @lazy_property\n+    def _supports_image_scales_metadata(self):\n+        # Do we have the image_scales in the portal_catalog?\n+        # Expected to be False on Plone 5.2, True on Plone 6.0.\n+        catalog = getToolByName(self.context, "portal_catalog")\n+        return "image_scales" in catalog._catalog.schema\n+\n+    @lazy_property\n+    def _supports_hidpi(self):\n+        # Do we have any "old-style" high DPI scales (2x/3x)?\n+        return bool(self.getHighPixelDensityScales())\n+\n     def _scale_cachekey(method, self, brain, fieldname, **kwargs):\n         return (\n             self.context.absolute_url(),\n@@ -672,11 +693,75 @@ def _scale_cachekey(method, self, brain, fieldname, **kwargs):\n \n     @ram.cache(_scale_cachekey)\n     def tag(self, brain, fieldname, **kwargs):\n+        if self._supports_image_scales_metadata:\n+            tag = self._tag_from_brain_image_scales(brain, fieldname, **kwargs)\n+            if tag:\n+                return tag\n         obj = brain.getObject()\n         images = obj.restrictedTraverse("@@images")\n         tag = images.tag(fieldname, **kwargs)\n         return tag\n \n+    def _tag_from_brain_image_scales(\n+        self,\n+        brain,\n+        fieldname,\n+        scale=None,\n+        alt=_marker,\n+        css_class=None,\n+        title=_marker,\n+        **kwargs,\n+    ):\n+        """Try to get a tag from the image_scales metadata.\n+\n+        If we have any non-standard keyword arguments, we cannot use this method.\n+        Especially you cannot set a direction: we must use the default "thumbnail".\n+\n+        Also, no old-style hidpi srcsets are included.  If the site has enabled this,\n+        we return nothing: this information is not (easily) available in the brain.\n+        """\n+        if self._supports_hidpi:\n+            return\n+        if not (brain and fieldname and scale):\n+            return\n+        if kwargs:\n+            # too many keyword arguments\n+            return\n+        if not getattr(brain, "image_scales", None):\n+            # no images here at all\n+            return\n+        if fieldname not in brain.image_scales:\n+            return\n+        try:\n+            # Note: per field we get a list with dicts.\n+            # For normal image fields this will always be one dict.\n+            # When the field is a RelationList pointing to images,\n+            # it might contain more.  That does not sound like something\n+            # we can support out of the box, so we always use the first one.\n+            # This probably makes the most sense in that corner case as well.\n+            data = brain.image_scales[fieldname][0]["scales"][scale]\n+        except (KeyError, IndexError):\n+            return\n+\n+        # data has download, height and width\n+        if title is _marker:\n+            title = brain.Title\n+            if callable(title):\n+                # Brain may be a CatalogContentListingObject.\n+                title = title()\n+        if alt is _marker:\n+            alt = title\n+        values = [\n+            ("src", data["download"]),\n+            ("alt", alt),\n+            ("title", title),\n+            ("height", data["height"]),\n+            ("width", data["width"]),\n+        ]\n+        if css_class:\n+            values.append(("class", css_class))\n+        return _image_tag_from_values(*values)\n+\n \n def _scale_sort_key(item):\n     key, value = item\ndiff --git a/plone/namedfile/testing.zcml b/plone/namedfile/testing.zcml\nindex 903a60a..78e8885 100644\n--- a/plone/namedfile/testing.zcml\n+++ b/plone/namedfile/testing.zcml\n@@ -9,5 +9,9 @@\n   <permission id="zope2.View" title="View" />\n \n   <include package="plone.namedfile" />\n+  <class class="plone.dexterity.content.DexterityContent">\n+    <!-- This is normally done in plone.app.dexterity. -->\n+    <implements interface="plone.namedfile.interfaces.IImageScaleTraversable" />\n+  </class>\n \n </configure>\ndiff --git a/plone/namedfile/tests/900.jpg b/plone/namedfile/tests/900.jpg\nnew file mode 100644\nindex 0000000..e9ef7db\nBinary files /dev/null and b/plone/namedfile/tests/900.jpg differ\ndiff --git a/plone/namedfile/tests/dummy.py b/plone/namedfile/tests/dummy.py\nnew file mode 100644\nindex 0000000..6102108\n--- /dev/null\n+++ b/plone/namedfile/tests/dummy.py\n@@ -0,0 +1,61 @@\n+from io import BytesIO\n+from ZPublisher.HTTPRequest import FileUpload\n+\n+import os\n+\n+\n+GIF_FILE = os.path.join(os.path.dirname(__file__), "tool.gif")\n+with open(GIF_FILE, "rb") as f:\n+    GIF = f.read()\n+# jpeg file of 900x900 pixels\n+JPEG_FILE = os.path.join(os.path.dirname(__file__), "900.jpg")\n+with open(JPEG_FILE, "rb") as f:\n+    JPEG = f.read()\n+\n+\n+class File(FileUpload):\n+    """Dummy upload object\n+    Used to fake uploaded files.\n+    """\n+\n+    __allow_access_to_unprotected_subobjects__ = 1\n+    filename = "dummy.txt"\n+    data = b"file data"\n+    headers = {}\n+\n+    def __init__(self, filename=None, data=None, headers=None):\n+        if filename is not None:\n+            self.filename = filename\n+        if data is not None:\n+            self.data = data\n+        if headers is not None:\n+            self.headers = headers\n+        self.file = BytesIO(self.data)\n+\n+    def seek(self, *args):\n+        pass\n+\n+    def tell(self, *args):\n+        return 1\n+\n+    def read(self, *args):\n+        return self.data\n+\n+\n+class Image(File):\n+    """Dummy image upload object\n+    Contains valid image data by default.\n+    """\n+\n+    filename = "dummy.gif"\n+    data = GIF\n+\n+\n+class JpegImage(File):\n+    """Dummy jpeg image upload object\n+\n+    900 by 900 pixels.\n+    """\n+\n+    filename = "900.jpeg"\n+    data = JPEG\ndiff --git a/plone/namedfile/tests/test_adapters.py b/plone/namedfile/tests/test_adapters.py\nnew file mode 100644\nindex 0000000..b144aeb\n--- /dev/null\n+++ b/plone/namedfile/tests/test_adapters.py\n@@ -0,0 +1,147 @@\n+from plone.dexterity.content import Item\n+from plone.namedfile.field import NamedImage as NamedImageField\n+from plone.namedfile.file import NamedImage\n+from plone.namedfile.testing import PLONE_NAMEDFILE_INTEGRATION_TESTING\n+from plone.namedfile.tests import dummy\n+from unittest.mock import patch\n+from zope.component import queryMultiAdapter\n+from zope.publisher.browser import TestRequest\n+\n+import plone.namedfile.adapters\n+import unittest\n+\n+\n+try:\n+    from plone.base.interfaces import IImageScalesFieldAdapter\n+except ImportError:\n+    IImageScalesFieldAdapter = None\n+\n+\n+def patch_get_scale_infos():\n+    # The IRegistry utility cannot be found in the test layer,\n+    # so we mock what Plone 6 would return.\n+    return [\n+        ("huge", 1600, 65536),\n+        ("great", 1200, 65536),\n+        ("larger", 1000, 65536),\n+        ("large", 800, 65536),\n+        ("teaser", 600, 65536),\n+        ("preview", 400, 65536),\n+        ("mini", 200, 65536),\n+        ("thumb", 128, 128),\n+        ("tile", 64, 64),\n+        ("icon", 32, 32),\n+        ("listing", 16, 16),\n+    ]\n+\n+\n+class ImageScalesAdaptersRegisteredTest(unittest.TestCase):\n+    """Test portal actions control panel."""\n+\n+    layer = PLONE_NAMEDFILE_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.request = TestRequest()\n+        self.content = Item()\n+\n+    @patch.object(\n+        plone.namedfile.adapters,\n+        "_get_scale_infos",\n+        new=patch_get_scale_infos,\n+        spec=True,\n+    )\n+    def serialize(self, context, field):\n+        serializer = queryMultiAdapter(\n+            (field, context, self.request), IImageScalesFieldAdapter\n+        )\n+        if serializer:\n+            return serializer()\n+        return\n+\n+    def create_field(self, value=None):\n+        field = NamedImageField()\n+        field.__name__ = "image1"\n+        field.set(self.content, value)\n+        return field\n+\n+    @unittest.skipIf(IImageScalesFieldAdapter is None, "Skipping on Plone 5")\n+    def test_field_adapter_return_scales(self):\n+        image = NamedImage(dummy.Image(), filename="dummy.gif")\n+        field = self.create_field(image)\n+        res = self.serialize(self.content, field)\n+        self.assertNotEqual(res, None)\n+        self.assertEqual(len(res), 1)\n+        res = res[0]\n+        download = res.pop("download")\n+        scales = res.pop("scales")\n+        self.assertEqual(\n+            res,\n+            {\n+                "content-type": "image/gif",\n+                "filename": "dummy.gif",\n+                "height": 16,\n+                "size": 168,\n+                "width": 16,\n+            },\n+        )\n+        # Note: self.content.absolute_url() is actually empty in this test.\n+        images_url = self.content.absolute_url() + "/@@images"\n+        self.assertTrue(download.startswith(f"{images_url}/image1-16-"))\n+        self.assertTrue(download.endswith(".gif"))\n+        self.assertIn("listing", scales)\n+        self.assertEqual(len(scales), 1)\n+        listing = scales["listing"]\n+        self.assertEqual(sorted(listing.keys()), ["download", "height", "width"])\n+        self.assertEqual(listing["height"], 16)\n+        self.assertEqual(listing["width"], 16)\n+        download = listing["download"]\n+        self.assertTrue(download.startswith(f"{images_url}/image1-16-"))\n+        self.assertTrue(download.endswith(".gif"))\n+\n+    @unittest.skipIf(IImageScalesFieldAdapter is not None, "Skipping on Plone 6")\n+    def test_field_adapter_return_nothing_without_plone_base(self):\n+        image = NamedImage(dummy.Image(), filename="dummy.gif")\n+        field = self.create_field(image)\n+        res = self.serialize(self.content, field)\n+        self.assertIsNone(res)\n+\n+    def test_field_adapter_do_not_return_scales_for_empty_fields_with_adapter(self):\n+        field = self.create_field()\n+        res = self.serialize(self.content, field)\n+        self.assertEqual(res, None)\n+\n+    @unittest.skipIf(IImageScalesFieldAdapter is None, "Skipping on Plone 5")\n+    def test_field_adapter_does_not_return_larger_scales(self):\n+        # Add an image of 900 by 900 pixels.\n+        image = NamedImage(dummy.JpegImage(), filename="900.jpeg")\n+        field = self.create_field(image)\n+        res = self.serialize(self.content, field)\n+        self.assertNotEqual(res, None)\n+        self.assertEqual(len(res), 1)\n+        res = res[0]\n+        download = res.pop("download")\n+        scales = res.pop("scales")\n+        self.assertEqual(\n+            res,\n+            {\n+                "content-type": "image/jpeg",\n+                "filename": "900.jpeg",\n+                "height": 900,\n+                "size": 160651,\n+                "width": 900,\n+            },\n+        )\n+        # Note: self.content.absolute_url() is actually empty in this test.\n+        images_url = self.content.absolute_url() + "/@@images"\n+        self.assertTrue(download.startswith(f"{images_url}/image1-900-"))\n+        self.assertTrue(download.endswith(".jpeg"))\n+        # larger and huge should not be in here: these scales would return the same\n+        # content as the original.\n+        self.assertEqual(\n+            sorted(scales.keys()),\n+            ["icon", "large", "listing", "mini", "preview", "teaser", "thumb", "tile"],\n+        )\n+        preview = scales["preview"]\n+        self.assertEqual(preview["width"], 400)\n+        self.assertEqual(preview["height"], 400)\n+        self.assertTrue(preview["download"].startswith(f"{images_url}/image1-400-"))\ndiff --git a/plone/namedfile/tests/tool.gif b/plone/namedfile/tests/tool.gif\nnew file mode 100644\nindex 0000000..1b2f53b\nBinary files /dev/null and b/plone/namedfile/tests/tool.gif differ\ndiff --git a/setup.py b/setup.py\nindex 03c2727..2a477ad 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -55,6 +55,7 @@\n         "plone.supermodel",\n         "setuptools",\n         "zope.browserpage",\n+        "zope.cachedescriptors",\n         "zope.component",\n         "zope.copy",\n         "zope.security",\ndiff --git a/sources-60.ini b/sources-60.ini\nindex 5ff6556..759af57 100644\n--- a/sources-60.ini\n+++ b/sources-60.ini\n@@ -10,7 +10,12 @@ constraints-out = constraints-60-mxdev.txt\n ignores =\n     plone.namedfile\n     plone.scale\n+    plone.base\n \n [plone.scale]\n url = https://github.com/plone/plone.scale.git\n branch = pre-scale\n+\n+[plone.base]\n+url = https://github.com/plone/plone.base.git\n+branch = image_scales_metadata\n'

