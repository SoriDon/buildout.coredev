Repository: plone.session


Branch: refs/heads/master
Date: 2022-08-24T21:42:01+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.session/commit/a8a2ff17069fe9ce18a56ce6af74558f1eddcd74

Run black -S

Files changed:
M plone/session/__init__.py
M plone/session/hiddenprofiles.py
M plone/session/interfaces.py
M plone/session/plugins/session.py
M plone/session/testing.py
M plone/session/tests/testDocTests.py
M plone/session/tests/testPAS.py
M plone/session/tktauth.py
M setup.py

b'diff --git a/plone/session/__init__.py b/plone/session/__init__.py\nindex d1a751a..cce9b97 100644\n--- a/plone/session/__init__.py\n+++ b/plone/session/__init__.py\n@@ -13,6 +13,7 @@ def initialize(context):\n         permission=add_user_folders,\n         constructors=(\n             session.manage_addSessionPluginForm,\n-            session.manage_addSessionPlugin),\n-        visibility=None\n+            session.manage_addSessionPlugin,\n+        ),\n+        visibility=None,\n     )\ndiff --git a/plone/session/hiddenprofiles.py b/plone/session/hiddenprofiles.py\nindex 268d902..7cb39d2 100644\n--- a/plone/session/hiddenprofiles.py\n+++ b/plone/session/hiddenprofiles.py\n@@ -5,7 +5,6 @@\n \n @implementer(INonInstallable)\n class HiddenProfiles(object):\n-\n     def getNonInstallableProfiles(self):\n         """Prevents uninstall profile from showing up in the profile list\n         when creating a Plone site.\ndiff --git a/plone/session/interfaces.py b/plone/session/interfaces.py\nindex 4f836a4..a4790f7 100644\n--- a/plone/session/interfaces.py\n+++ b/plone/session/interfaces.py\n@@ -3,8 +3,7 @@\n \n \n class ISessionPlugin(Interface):\n-    """Session handling PAS plugin.\n-    """\n+    """Session handling PAS plugin."""\n \n     def _setupSession(userid, response):\n         """\ndiff --git a/plone/session/plugins/session.py b/plone/session/plugins/session.py\nindex 763f8c8..df1fd55 100644\n--- a/plone/session/plugins/session.py\n+++ b/plone/session/plugins/session.py\n@@ -9,15 +9,9 @@\n from plone.session import tktauth\n from plone.session.interfaces import ISessionPlugin\n from Products.PageTemplates.PageTemplateFile import PageTemplateFile\n-from Products.PluggableAuthService.interfaces.plugins import (\n-    IAuthenticationPlugin,\n-)\n-from Products.PluggableAuthService.interfaces.plugins import (\n-    ICredentialsResetPlugin,\n-)\n-from Products.PluggableAuthService.interfaces.plugins import (\n-    ICredentialsUpdatePlugin,\n-)\n+from Products.PluggableAuthService.interfaces.plugins import IAuthenticationPlugin\n+from Products.PluggableAuthService.interfaces.plugins import ICredentialsResetPlugin\n+from Products.PluggableAuthService.interfaces.plugins import ICredentialsUpdatePlugin\n from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin\n from Products.PluggableAuthService.permissions import ManageUsers\n from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin\n@@ -38,8 +32,7 @@\n manage_addSessionPluginForm = PageTemplateFile(\'session\', globals())\n \n \n-def manage_addSessionPlugin(dispatcher, id, title=None, path=\'/\',\n-                            REQUEST=None):\n+def manage_addSessionPlugin(dispatcher, id, title=None, path=\'/\', REQUEST=None):\n     """Add a session plugin."""\n     sp = SessionPlugin(id, title=title, path=path)\n     dispatcher._setObject(id, sp)\n@@ -63,11 +56,10 @@ def cookie_expiration_date(days):\n     IExtractionPlugin,\n     IAuthenticationPlugin,\n     ICredentialsResetPlugin,\n-    ICredentialsUpdatePlugin\n+    ICredentialsUpdatePlugin,\n )\n class SessionPlugin(BasePlugin):\n-    """Session authentication plugin.\n-    """\n+    """Session authentication plugin."""\n \n     meta_type = "Plone Session Plugin"\n     security = ClassSecurityInfo()\n@@ -208,9 +200,7 @@ def extractCredentials(self, request):\n             return creds\n \n         try:\n-            creds["cookie"] = binascii.a2b_base64(\n-                request.get(self.cookie_name)\n-            )\n+            creds["cookie"] = binascii.a2b_base64(request.get(self.cookie_name))\n         except binascii.Error:\n             # If we have a cookie which is not properly base64 encoded it\n             # can not be ours.\n@@ -249,7 +239,7 @@ def _validateTicket(self, ticket, now=None):\n                 ticket,\n                 timeout=self.timeout,\n                 now=now,\n-                mod_auth_tkt=self.mod_auth_tkt\n+                mod_auth_tkt=self.mod_auth_tkt,\n             )\n         else:\n             ticket_data = None\n@@ -271,7 +261,7 @@ def _validateTicket(self, ticket, now=None):\n                     ticket,\n                     timeout=self.timeout,\n                     now=now,\n-                    mod_auth_tkt=self.mod_auth_tkt\n+                    mod_auth_tkt=self.mod_auth_tkt,\n                 )\n                 if ticket_data is not None:\n                     break\n@@ -315,7 +305,8 @@ def resetCredentials(self, request, response):\n         response = self.REQUEST["RESPONSE"]\n         if self.cookie_domain:\n             response.expireCookie(\n-                self.cookie_name, path=self.path, domain=self.cookie_domain)\n+                self.cookie_name, path=self.path, domain=self.cookie_domain\n+            )\n         else:\n             response.expireCookie(self.cookie_name, path=self.path)\n \n@@ -334,36 +325,34 @@ def manage_clearSecrets(self, REQUEST):\n                 manager.rotate(ring=ring)\n         response = REQUEST.response\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\' %\n-            (self.absolute_url(), \'All+secrets+cleared.\')\n+            \'%s/manage_secret?manage_tabs_message=%s\'\n+            % (self.absolute_url(), \'All+secrets+cleared.\')\n         )\n \n     @security.protected(ManageUsers)\n     @postonly\n     def manage_createNewSecret(self, REQUEST):\n-        """Create a new (signing) secret.\n-        """\n+        """Create a new (signing) secret."""\n         manager = getUtility(IKeyManager)\n         for ring in manager:\n             if ring.startswith(self.secret_prefix) or ring == "_system":\n                 manager.rotate(ring=ring)\n         response = REQUEST.response\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\' %\n-            (self.absolute_url(), \'New+secret+created.\')\n+            \'%s/manage_secret?manage_tabs_message=%s\'\n+            % (self.absolute_url(), \'New+secret+created.\')\n         )\n \n     @security.protected(ManageUsers)\n     @postonly\n     def manage_togglePerUserKeyring(self, REQUEST):\n-        """Toggle per-user keyrings.\n-        """\n+        """Toggle per-user keyrings."""\n         self.per_user_keyring = not self.per_user_keyring\n         response = REQUEST.response\n         action = "enabled" if self.per_user_keyring else "disabled"\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\' %\n-            (self.absolute_url(), \'Per-user+keyrings+%s.\' % (action, ))\n+            \'%s/manage_secret?manage_tabs_message=%s\'\n+            % (self.absolute_url(), \'Per-user+keyrings+%s.\' % (action,))\n         )\n \n     @security.protected(ManageUsers)\n@@ -379,27 +368,26 @@ def manage_removeSharedSecret(self, REQUEST):\n         self._shared_secret = None\n         response = REQUEST.response\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\' %\n-            (self.absolute_url(), \'Shared+secret+removed.\')\n+            \'%s/manage_secret?manage_tabs_message=%s\'\n+            % (self.absolute_url(), \'Shared+secret+removed.\')\n         )\n \n     @security.protected(ManageUsers)\n     @postonly\n     def manage_setSharedSecret(self, REQUEST):\n-        """Set the shared secret.\n-        """\n+        """Set the shared secret."""\n         secret = REQUEST.get(\'shared_secret\')\n         response = REQUEST.response\n         if not secret:\n             response.redirect(\n-                \'%s/manage_secret?manage_tabs_message=%s\' %\n-                (self.absolute_url(), \'Shared+secret+must+not+be+blank.\')\n+                \'%s/manage_secret?manage_tabs_message=%s\'\n+                % (self.absolute_url(), \'Shared+secret+must+not+be+blank.\')\n             )\n             return\n         self._shared_secret = secret\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\' %\n-            (self.absolute_url(), \'New+shared+secret+set.\')\n+            \'%s/manage_secret?manage_tabs_message=%s\'\n+            % (self.absolute_url(), \'New+shared+secret+set.\')\n         )\n \n     def _refreshSession(self, request, now=None):\n@@ -446,15 +434,16 @@ def refresh(self, REQUEST):\n             # We have an unauthenticated user\n             setHeader(\n                 \'Cache-Control\',\n-                \'public, must-revalidate, max-age=%d, s-max-age=86400\' %\n-                self.refresh_interval\n+                \'public, must-revalidate, max-age=%d, s-max-age=86400\'\n+                % self.refresh_interval,\n             )\n             setHeader(\'Vary\', \'Cookie\')\n         else:\n             setHeader(\n                 \'Cache-Control\',\n                 \'private, must-revalidate, proxy-revalidate, max-age=%d, \'\n-                \'s-max-age=0\' % self.refresh_interval)\n+                \'s-max-age=0\' % self.refresh_interval,\n+            )\n         return self._refresh_content(REQUEST)\n \n     @security.public\n@@ -465,7 +454,6 @@ def remove(self, REQUEST):\n         # Disable HTTP 1.0 Caching\n         setHeader(\'Expires\', formatdate(0, usegmt=True))\n         setHeader(\n-            \'Cache-Control\',\n-            \'public, must-revalidate, max-age=0, s-max-age=86400\'\n+            \'Cache-Control\', \'public, must-revalidate, max-age=0, s-max-age=86400\'\n         )\n         return self._refresh_content(REQUEST)\ndiff --git a/plone/session/testing.py b/plone/session/testing.py\nindex d5bbd9c..8bd6a59 100644\n--- a/plone/session/testing.py\n+++ b/plone/session/testing.py\n@@ -63,7 +63,8 @@ def _create_structure(self):\n     bases=(PLONE_SESSION_FIXTURE,), name=\'PloneSessionLayer:Integration\'\n )\n PLONE_SEESION_FUNCTIONAL_TESTING = FunctionalTesting(\n-    bases=(PLONE_SESSION_FIXTURE,), name=\'PloneSessionLayer:Functional\',\n+    bases=(PLONE_SESSION_FIXTURE,),\n+    name=\'PloneSessionLayer:Functional\',\n )\n \n optionflags = (\ndiff --git a/plone/session/tests/testDocTests.py b/plone/session/tests/testDocTests.py\nindex 71ee47d..333b581 100644\n--- a/plone/session/tests/testDocTests.py\n+++ b/plone/session/tests/testDocTests.py\n@@ -11,7 +11,6 @@\n \n \n class Py23DocChecker(doctest.OutputChecker):\n-\n     def check_output(self, want, got, optionflags):\n         if six.PY2:\n             want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\ndiff --git a/plone/session/tests/testPAS.py b/plone/session/tests/testPAS.py\nindex c24eb65..e031358 100644\n--- a/plone/session/tests/testPAS.py\n+++ b/plone/session/tests/testPAS.py\n@@ -11,9 +11,16 @@\n \n \n class MockResponse(object):\n-\n-    def setCookie(self, name, value, path,\n-                  expires=None, secure=False, http_only=False, same_site=None):\n+    def setCookie(\n+        self,\n+        name,\n+        value,\n+        path,\n+        expires=None,\n+        secure=False,\n+        http_only=False,\n+        same_site=None,\n+    ):\n         self.cookie = value\n         self.cookie_expires = expires\n         self.cookie_http_only = http_only\n@@ -115,12 +122,7 @@ def testCredentialsUpdateAnonymous(self):\n         logout()\n         session = self.folder.pas.session\n         request = self.makeRequest("test string")\n-        session.updateCredentials(\n-            request,\n-            request.response,\n-            "our_user",\n-            "password"\n-        )\n+        session.updateCredentials(request, request.response, "our_user", "password")\n         self.assertIsNotNone(\n             request.response.getCookie(session.cookie_name),\n         )\n@@ -130,24 +132,14 @@ def testCredentialsUpdateOtherUser(self):\n         # The session should not be updated then.\n         session = self.folder.pas.session\n         request = self.makeRequest("test string")\n-        session.updateCredentials(\n-            request,\n-            request.response,\n-            "our_user",\n-            "password"\n-        )\n+        session.updateCredentials(request, request.response, "our_user", "password")\n         self.assertIsNone(request.response.getCookie(session.cookie_name))\n \n     def testRefresh(self):\n         logout()\n         session = self.folder.pas.session\n         request = self.makeRequest("test string")\n-        session.updateCredentials(\n-            request,\n-            request.response,\n-            "our_user",\n-            "password"\n-        )\n+        session.updateCredentials(request, request.response, "our_user", "password")\n         cookie = request.response.getCookie(session.cookie_name)[\'value\']\n         request2 = self.makeRequest(cookie)\n         request2.form[\'type\'] = \'gif\'\ndiff --git a/plone/session/tktauth.py b/plone/session/tktauth.py\nindex 8b7578a..e6db31e 100755\n--- a/plone/session/tktauth.py\n+++ b/plone/session/tktauth.py\n@@ -181,8 +181,7 @@ def safe_text(value, encoding=\'utf-8\'):\n \n def is_equal(val1, val2):\n     # constant time comparison\n-    if not isinstance(val1, six.binary_type) or \\\n-       not isinstance(val2, six.binary_type):\n+    if not isinstance(val1, six.binary_type) or not isinstance(val2, six.binary_type):\n         return False\n     if len(val1) != len(val2):\n         return False\n@@ -206,8 +205,16 @@ def mod_auth_tkt_digest(secret, data1, data2):\n     return digest\n \n \n-def createTicket(secret, userid, tokens=(), user_data=\'\', ip=\'0.0.0.0\',\n-                 timestamp=None, encoding=\'utf-8\', mod_auth_tkt=False):\n+def createTicket(\n+    secret,\n+    userid,\n+    tokens=(),\n+    user_data=\'\',\n+    ip=\'0.0.0.0\',\n+    timestamp=None,\n+    encoding=\'utf-8\',\n+    mod_auth_tkt=False,\n+):\n     """\n     By default, use a more compatible\n     """\n@@ -273,22 +280,15 @@ def splitTicket(ticket, encoding=None):\n     return (digest, userid, tokens, user_data, timestamp)\n \n \n-def validateTicket(secret, ticket, ip=\'0.0.0.0\', timeout=0, now=None,\n-                   encoding=None, mod_auth_tkt=False):\n+def validateTicket(\n+    secret, ticket, ip=\'0.0.0.0\', timeout=0, now=None, encoding=None, mod_auth_tkt=False\n+):\n     try:\n-        (digest, userid, tokens, user_data, timestamp) = data = \\\n-            splitTicket(ticket)\n+        (digest, userid, tokens, user_data, timestamp) = data = splitTicket(ticket)\n     except ValueError:\n         return None\n     new_ticket = createTicket(\n-        secret,\n-        userid,\n-        tokens,\n-        user_data,\n-        ip,\n-        timestamp,\n-        encoding,\n-        mod_auth_tkt\n+        secret, userid, tokens, user_data, ip, timestamp, encoding, mod_auth_tkt\n     )\n     if is_equal(new_ticket[:32], digest):\n         if not timeout:\n@@ -305,6 +305,7 @@ def _test():\n     from plone.session.tests.testDocTests import Py23DocChecker\n \n     import doctest\n+\n     doctest.testmod(\n         optionflags=doctest.ELLIPSIS + doctest.NORMALIZE_WHITESPACE,\n         checker=Py23DocChecker(),\ndiff --git a/setup.py b/setup.py\nindex dfe1593..9a24f8c 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -39,19 +39,19 @@\n     include_package_data=True,\n     zip_safe=False,\n     extras_require=dict(\n-      test=[\n-          \'zope.configuration\',\n-          \'zope.publisher\',\n-      ]\n+        test=[\n+            \'zope.configuration\',\n+            \'zope.publisher\',\n+        ]\n     ),\n     install_requires=[\n-      \'plone.keyring\',\n-      \'plone.protect\',\n-      \'Products.PluggableAuthService\',\n-      \'setuptools\',\n-      \'six\',\n-      \'zope.component\',\n-      \'zope.interface\',\n-      \'Zope2\',\n+        \'plone.keyring\',\n+        \'plone.protect\',\n+        \'Products.PluggableAuthService\',\n+        \'setuptools\',\n+        \'six\',\n+        \'zope.component\',\n+        \'zope.interface\',\n+        \'Zope2\',\n     ],\n )\n'

Repository: plone.session


Branch: refs/heads/master
Date: 2022-08-24T21:42:01+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.session/commit/722f132380d8dd05aa0088725f92a04208e0c5c2

Run black

Files changed:
M plone/__init__.py
M plone/session/hiddenprofiles.py
M plone/session/plugins/session.py
M plone/session/testing.py
M plone/session/tests/testPAS.py
M plone/session/tktauth.py
M setup.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex e31cc00..b40aab6 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1,2 @@\n # See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/session/hiddenprofiles.py b/plone/session/hiddenprofiles.py\nindex 7cb39d2..e6908da 100644\n--- a/plone/session/hiddenprofiles.py\n+++ b/plone/session/hiddenprofiles.py\n@@ -11,5 +11,5 @@ def getNonInstallableProfiles(self):\n \n         """\n         return [\n-            \'plone.session:uninstall\',\n+            "plone.session:uninstall",\n         ]\ndiff --git a/plone/session/plugins/session.py b/plone/session/plugins/session.py\nindex df1fd55..b9ff8c7 100644\n--- a/plone/session/plugins/session.py\n+++ b/plone/session/plugins/session.py\n@@ -24,23 +24,23 @@\n \n \n EMPTY_GIF = (\n-    \'GIF89a\\x01\\x00\\x01\\x00\\xf0\\x01\\x00\\xff\\xff\\xff\'\n-    \'\\x00\\x00\\x00!\\xf9\\x04\\x01\\n\\x00\\x00\\x00\'\n-    \',\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x02\\x02D\\x01\\x00;\'\n+    "GIF89a\\x01\\x00\\x01\\x00\\xf0\\x01\\x00\\xff\\xff\\xff"\n+    "\\x00\\x00\\x00!\\xf9\\x04\\x01\\n\\x00\\x00\\x00"\n+    ",\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x02\\x02D\\x01\\x00;"\n )\n \n-manage_addSessionPluginForm = PageTemplateFile(\'session\', globals())\n+manage_addSessionPluginForm = PageTemplateFile("session", globals())\n \n \n-def manage_addSessionPlugin(dispatcher, id, title=None, path=\'/\', REQUEST=None):\n+def manage_addSessionPlugin(dispatcher, id, title=None, path="/", REQUEST=None):\n     """Add a session plugin."""\n     sp = SessionPlugin(id, title=title, path=path)\n     dispatcher._setObject(id, sp)\n \n     if REQUEST is not None:\n         REQUEST.response.redirect(\n-            \'{0}/manage_workspace?\'\n-            \'manage_tabs_message=Session+plugin+created.\'.format(\n+            "{0}/manage_workspace?"\n+            "manage_tabs_message=Session+plugin+created.".format(\n                 dispatcher.absolute_url()\n             )\n         )\n@@ -66,11 +66,11 @@ class SessionPlugin(BasePlugin):\n \n     cookie_name = "__ac"\n     cookie_lifetime = 0\n-    cookie_domain = \'\'\n+    cookie_domain = ""\n     mod_auth_tkt = False\n     timeout = 2 * 60 * 60  # 2h - same as default in mod_auth_tkt\n     refresh_interval = 1 * 60 * 60  # -1 to disable\n-    external_ticket_name = \'ticket\'\n+    external_ticket_name = "ticket"\n     secure = False\n     _shared_secret = None\n     secret_prefix = "_plone.session_"\n@@ -134,7 +134,7 @@ class SessionPlugin(BasePlugin):\n             "label": (\n                 "Create a keyring for each user. "\n                 "Enables server-side logout."\n-                "Toggle this from the \\"Manage secrets\\" tab."\n+                \'Toggle this from the "Manage secrets" tab.\'\n             ),\n             "type": "boolean",\n             "mode": "r",\n@@ -142,7 +142,7 @@ class SessionPlugin(BasePlugin):\n     )\n \n     manage_options = (\n-        dict(label=\'Manage secrets\', action=\'manage_secret\'),\n+        dict(label="Manage secrets", action="manage_secret"),\n     ) + BasePlugin.manage_options\n \n     def __init__(self, id, title=None, path="/"):\n@@ -168,7 +168,7 @@ def _getSigningSecret(self, userid):\n         return manager.secret()\n \n     # ISessionPlugin implementation\n-    def _setupSession(self, userid, response, tokens=(), user_data=\'\'):\n+    def _setupSession(self, userid, response, tokens=(), user_data=""):\n         cookie = tktauth.createTicket(\n             secret=self._getSigningSecret(userid),\n             userid=userid,\n@@ -187,9 +187,9 @@ def _setCookie(self, cookie, response):\n             secure = self.secure\n         options = dict(path=self.path, secure=secure, http_only=True, same_site="Lax")\n         if self.cookie_domain:\n-            options[\'domain\'] = self.cookie_domain\n+            options["domain"] = self.cookie_domain\n         if self.cookie_lifetime:\n-            options[\'expires\'] = cookie_expiration_date(self.cookie_lifetime)\n+            options["expires"] = cookie_expiration_date(self.cookie_lifetime)\n         response.setCookie(self.cookie_name, cookie, **options)\n \n     # IExtractionPlugin implementation\n@@ -225,7 +225,7 @@ def authenticateCredentials(self, credentials):\n             return None\n \n         # XXX Should refresh the ticket if after timeout refresh.\n-        return (info[\'id\'], info[\'login\'])\n+        return (info["id"], info["login"])\n \n     def _validateTicket(self, ticket, now=None):\n         _, userid, _, _, _ = tktauth.splitTicket(ticket)\n@@ -251,7 +251,7 @@ def _validateTicket(self, ticket, now=None):\n             if secret_key in manager:\n                 secrets = manager[secret_key]\n             else:\n-                secrets = manager[u"_system"]\n+                secrets = manager["_system"]\n \n             for secret in secrets:\n                 if secret is None:\n@@ -325,8 +325,8 @@ def manage_clearSecrets(self, REQUEST):\n                 manager.rotate(ring=ring)\n         response = REQUEST.response\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\'\n-            % (self.absolute_url(), \'All+secrets+cleared.\')\n+            "%s/manage_secret?manage_tabs_message=%s"\n+            % (self.absolute_url(), "All+secrets+cleared.")\n         )\n \n     @security.protected(ManageUsers)\n@@ -339,8 +339,8 @@ def manage_createNewSecret(self, REQUEST):\n                 manager.rotate(ring=ring)\n         response = REQUEST.response\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\'\n-            % (self.absolute_url(), \'New+secret+created.\')\n+            "%s/manage_secret?manage_tabs_message=%s"\n+            % (self.absolute_url(), "New+secret+created.")\n         )\n \n     @security.protected(ManageUsers)\n@@ -351,8 +351,8 @@ def manage_togglePerUserKeyring(self, REQUEST):\n         response = REQUEST.response\n         action = "enabled" if self.per_user_keyring else "disabled"\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\'\n-            % (self.absolute_url(), \'Per-user+keyrings+%s.\' % (action,))\n+            "%s/manage_secret?manage_tabs_message=%s"\n+            % (self.absolute_url(), "Per-user+keyrings+%s." % (action,))\n         )\n \n     @security.protected(ManageUsers)\n@@ -368,26 +368,26 @@ def manage_removeSharedSecret(self, REQUEST):\n         self._shared_secret = None\n         response = REQUEST.response\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\'\n-            % (self.absolute_url(), \'Shared+secret+removed.\')\n+            "%s/manage_secret?manage_tabs_message=%s"\n+            % (self.absolute_url(), "Shared+secret+removed.")\n         )\n \n     @security.protected(ManageUsers)\n     @postonly\n     def manage_setSharedSecret(self, REQUEST):\n         """Set the shared secret."""\n-        secret = REQUEST.get(\'shared_secret\')\n+        secret = REQUEST.get("shared_secret")\n         response = REQUEST.response\n         if not secret:\n             response.redirect(\n-                \'%s/manage_secret?manage_tabs_message=%s\'\n-                % (self.absolute_url(), \'Shared+secret+must+not+be+blank.\')\n+                "%s/manage_secret?manage_tabs_message=%s"\n+                % (self.absolute_url(), "Shared+secret+must+not+be+blank.")\n             )\n             return\n         self._shared_secret = secret\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\'\n-            % (self.absolute_url(), \'New+shared+secret+set.\')\n+            "%s/manage_secret?manage_tabs_message=%s"\n+            % (self.absolute_url(), "New+shared+secret+set.")\n         )\n \n     def _refreshSession(self, request, now=None):\n@@ -409,15 +409,15 @@ def _refreshSession(self, request, now=None):\n \n     def _refresh_content(self, REQUEST):\n         setHeader = REQUEST.response.setHeader\n-        type = REQUEST.get(\'type\')\n-        if type == \'gif\':\n-            setHeader(\'Content-Type\', \'image/gif\')\n+        type = REQUEST.get("type")\n+        if type == "gif":\n+            setHeader("Content-Type", "image/gif")\n             return EMPTY_GIF\n-        elif type == \'css\':\n-            setHeader(\'Content-Type\', \'text/css\')\n+        elif type == "css":\n+            setHeader("Content-Type", "text/css")\n             return ""\n-        elif type == \'js\':\n-            setHeader(\'Content-Type\', \'text/javascript\')\n+        elif type == "js":\n+            setHeader("Content-Type", "text/javascript")\n             return ""\n \n     @security.public\n@@ -425,7 +425,7 @@ def refresh(self, REQUEST):\n         """Refresh the cookie"""\n         setHeader = REQUEST.response.setHeader\n         # Disable HTTP 1.0 Caching\n-        setHeader(\'Expires\', formatdate(0, usegmt=True))\n+        setHeader("Expires", formatdate(0, usegmt=True))\n         if self.refresh_interval < 0:\n             return self._refresh_content(REQUEST)\n         now = time.time()\n@@ -433,16 +433,16 @@ def refresh(self, REQUEST):\n         if not refreshed:\n             # We have an unauthenticated user\n             setHeader(\n-                \'Cache-Control\',\n-                \'public, must-revalidate, max-age=%d, s-max-age=86400\'\n+                "Cache-Control",\n+                "public, must-revalidate, max-age=%d, s-max-age=86400"\n                 % self.refresh_interval,\n             )\n-            setHeader(\'Vary\', \'Cookie\')\n+            setHeader("Vary", "Cookie")\n         else:\n             setHeader(\n-                \'Cache-Control\',\n-                \'private, must-revalidate, proxy-revalidate, max-age=%d, \'\n-                \'s-max-age=0\' % self.refresh_interval,\n+                "Cache-Control",\n+                "private, must-revalidate, proxy-revalidate, max-age=%d, "\n+                "s-max-age=0" % self.refresh_interval,\n             )\n         return self._refresh_content(REQUEST)\n \n@@ -452,8 +452,8 @@ def remove(self, REQUEST):\n         self.resetCredentials(REQUEST, REQUEST.response)\n         setHeader = REQUEST.response.setHeader\n         # Disable HTTP 1.0 Caching\n-        setHeader(\'Expires\', formatdate(0, usegmt=True))\n+        setHeader("Expires", formatdate(0, usegmt=True))\n         setHeader(\n-            \'Cache-Control\', \'public, must-revalidate, max-age=0, s-max-age=86400\'\n+            "Cache-Control", "public, must-revalidate, max-age=0, s-max-age=86400"\n         )\n         return self._refresh_content(REQUEST)\ndiff --git a/plone/session/testing.py b/plone/session/testing.py\nindex 8bd6a59..5fe7d6f 100644\n--- a/plone/session/testing.py\n+++ b/plone/session/testing.py\n@@ -12,10 +12,10 @@\n import doctest\n \n \n-folder_name = \'test_folder_1_\'\n-user_name = \'test_user_1_\'\n-user_password = \'secret\'\n-user_role = \'test_role_1_\'\n+folder_name = "test_folder_1_"\n+user_name = "test_user_1_"\n+user_password = "secret"\n+user_role = "test_role_1_"\n standard_permissions = [access_contents_information, view]\n \n \n@@ -27,7 +27,7 @@ def updateCredentials(self, request, response, userid, password):\n \n     def _verifyUser(self, plugin, user_id=None, login=None):\n         assert user_id is None\n-        if login == \'our_user\':\n+        if login == "our_user":\n             return dict(id=login, login=login, pluginid="session")\n         return None\n \n@@ -39,7 +39,7 @@ def setUpZope(self, app, configurationContext):\n         import plone.session\n         import plone.session.tests\n \n-        self.loadZCML(package=plone.session, name=\'meta.zcml\')\n+        self.loadZCML(package=plone.session, name="meta.zcml")\n         self.loadZCML(package=plone.session)\n         self.loadZCML(package=plone.session.tests)\n \n@@ -60,11 +60,11 @@ def _create_structure(self):\n PLONE_SESSION_FIXTURE = PloneSessionLayer()\n \n PLONE_SESSION_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(PLONE_SESSION_FIXTURE,), name=\'PloneSessionLayer:Integration\'\n+    bases=(PLONE_SESSION_FIXTURE,), name="PloneSessionLayer:Integration"\n )\n PLONE_SEESION_FUNCTIONAL_TESTING = FunctionalTesting(\n     bases=(PLONE_SESSION_FIXTURE,),\n-    name=\'PloneSessionLayer:Functional\',\n+    name="PloneSessionLayer:Functional",\n )\n \n optionflags = (\ndiff --git a/plone/session/tests/testPAS.py b/plone/session/tests/testPAS.py\nindex e031358..cd8d57f 100644\n--- a/plone/session/tests/testPAS.py\n+++ b/plone/session/tests/testPAS.py\n@@ -31,10 +31,10 @@ def setCookie(\n class TestSessionPlugin(unittest.TestCase):\n \n     layer = PLONE_SEESION_FUNCTIONAL_TESTING\n-    userid = \'jbloggs\'\n+    userid = "jbloggs"\n \n     def setUp(self):\n-        self.folder = self.layer[\'app\'][\'test_folder_1_\']\n+        self.folder = self.layer["app"]["test_folder_1_"]\n \n     def testInterfaces(self):\n         session = self.folder.pas.session\n@@ -64,7 +64,7 @@ def testSecureCookies(self):\n         session._setupSession(self.userid, response)\n         self.assertEqual(response.secure, False)\n \n-        setattr(session, \'secure\', True)\n+        setattr(session, "secure", True)\n         session._setupSession(self.userid, response)\n         self.assertEqual(response.secure, True)\n \n@@ -86,8 +86,8 @@ def testCookieLifetimeWithExpirationSet(self):\n         session.cookie_lifetime = 100\n         session._setupSession(self.userid, response)\n         self.assertEqual(\n-            DateTime(response.cookie_expires).strftime(\'%Y%m%d\'),\n-            (DateTime() + 100).strftime(\'%Y%m%d\'),\n+            DateTime(response.cookie_expires).strftime("%Y%m%d"),\n+            (DateTime() + 100).strftime("%Y%m%d"),\n         )\n \n     def testExtraction(self):\n@@ -97,7 +97,7 @@ def testExtraction(self):\n             request_body = base64.encodestring(b"test string")\n         else:\n             request_body = base64.encodebytes(b"test string").decode()\n-        self.assertEqual(request_body, \'dGVzdCBzdHJpbmc=\\n\')\n+        self.assertEqual(request_body, "dGVzdCBzdHJpbmc=\\n")\n         request = self.makeRequest(request_body)\n         creds = session.extractCredentials(request)\n         self.assertEqual(creds["source"], "plone.session")\n@@ -140,9 +140,9 @@ def testRefresh(self):\n         session = self.folder.pas.session\n         request = self.makeRequest("test string")\n         session.updateCredentials(request, request.response, "our_user", "password")\n-        cookie = request.response.getCookie(session.cookie_name)[\'value\']\n+        cookie = request.response.getCookie(session.cookie_name)["value"]\n         request2 = self.makeRequest(cookie)\n-        request2.form[\'type\'] = \'gif\'\n+        request2.form["type"] = "gif"\n         session.refresh(request2)\n         self.assertIsNotNone(request2.response.getCookie(session.cookie_name))\n \n@@ -154,7 +154,7 @@ def testUnicodeUserid(self):\n         session._setupSession(unicode_userid, response)\n \n     def testSpecialCharUserid(self):\n-        unicode_userid = u"\xc3\xa3bcd\xc3\xa9fghijk"\n+        unicode_userid = "\xc3\xa3bcd\xc3\xa9fghijk"\n         response = MockResponse()\n         session = self.folder.pas.session\n         # This step would fail.\ndiff --git a/plone/session/tktauth.py b/plone/session/tktauth.py\nindex e6db31e..71fa9ad 100755\n--- a/plone/session/tktauth.py\n+++ b/plone/session/tktauth.py\n@@ -144,7 +144,7 @@\n import time\n \n \n-def safe_encode(value, encoding=\'utf-8\'):\n+def safe_encode(value, encoding="utf-8"):\n     """Convert unicode to the specified encoding.\n \n     copied from Products.CMFPlone.utils b/c this package does not depend on it\n@@ -154,7 +154,7 @@ def safe_encode(value, encoding=\'utf-8\'):\n     return value\n \n \n-def safe_text(value, encoding=\'utf-8\'):\n+def safe_text(value, encoding="utf-8"):\n     """Converts a value to text, even it is already a text string.\n \n     copied from Products.CMFPlone.utils b/c this package does not depend on it\n@@ -166,7 +166,7 @@ def safe_text(value, encoding=\'utf-8\'):\n             try:\n                 value = unicode(value, encoding)\n             except (UnicodeDecodeError):\n-                value = value.decode(\'utf-8\', \'replace\')\n+                value = value.decode("utf-8", "replace")\n         return value\n \n     if isinstance(value, str):\n@@ -175,7 +175,7 @@ def safe_text(value, encoding=\'utf-8\'):\n         try:\n             value = str(value, encoding)\n         except (UnicodeDecodeError):\n-            value = value.decode(\'utf-8\', \'replace\')\n+            value = value.decode("utf-8", "replace")\n     return value\n \n \n@@ -209,10 +209,10 @@ def createTicket(\n     secret,\n     userid,\n     tokens=(),\n-    user_data=\'\',\n-    ip=\'0.0.0.0\',\n+    user_data="",\n+    ip="0.0.0.0",\n     timestamp=None,\n-    encoding=\'utf-8\',\n+    encoding="utf-8",\n     mod_auth_tkt=False,\n ):\n     """\n@@ -225,7 +225,7 @@ def createTicket(\n     tokens = [safe_encode(t) for t in tokens]\n     user_data = safe_encode(user_data)\n \n-    token_list = b\',\'.join(tokens)\n+    token_list = b",".join(tokens)\n \n     # ip address is part of the format, set it to 0.0.0.0 to be ignored.\n     # inet_aton packs the ip address into a 4 bytes in network byte order.\n@@ -234,8 +234,8 @@ def createTicket(\n     # Unfortunately, some older versions of Python assume that longs are always\n     # 32 bits, so we need to trucate the result in case we are on a 64-bit\n     # naive system.\n-    data1 = inet_aton(ip)[:4] + pack(\'!I\', timestamp)\n-    data2 = b\'\\0\'.join((userid, token_list, user_data))\n+    data1 = inet_aton(ip)[:4] + pack("!I", timestamp)\n+    data2 = b"\\0".join((userid, token_list, user_data))\n     if mod_auth_tkt:\n         digest = mod_auth_tkt_digest(secret, data1, data2)\n     else:\n@@ -246,9 +246,9 @@ def createTicket(\n         digest = digest.encode()\n \n     # digest + timestamp as an eight character hexadecimal + userid + !\n-    ticket = b\'%s%08x%s!\' % (digest, timestamp, userid)\n+    ticket = b"%s%08x%s!" % (digest, timestamp, userid)\n     if tokens:\n-        ticket += token_list + b\'!\'\n+        ticket += token_list + b"!"\n     ticket += user_data\n \n     return ticket\n@@ -266,14 +266,14 @@ def splitTicket(ticket, encoding=None):\n         remainder = safe_text(remainder)\n     elif encoding is not None:\n         remainder = safe_text(remainder, encoding)\n-    parts = remainder.split(\'!\')\n+    parts = remainder.split("!")\n \n     if len(parts) == 2:\n         userid, user_data = parts\n         tokens = ()\n     elif len(parts) == 3:\n         userid, token_list, user_data = parts\n-        tokens = tuple(token_list.split(\',\'))\n+        tokens = tuple(token_list.split(","))\n     else:\n         raise ValueError\n \n@@ -281,7 +281,7 @@ def splitTicket(ticket, encoding=None):\n \n \n def validateTicket(\n-    secret, ticket, ip=\'0.0.0.0\', timeout=0, now=None, encoding=None, mod_auth_tkt=False\n+    secret, ticket, ip="0.0.0.0", timeout=0, now=None, encoding=None, mod_auth_tkt=False\n ):\n     try:\n         (digest, userid, tokens, user_data, timestamp) = data = splitTicket(ticket)\n@@ -312,5 +312,5 @@ def _test():\n     )\n \n \n-if __name__ == \'__main__\':\n+if __name__ == "__main__":\n     _test()\ndiff --git a/setup.py b/setup.py\nindex 9a24f8c..f8bdaed 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -3,55 +3,55 @@\n from setuptools import setup\n \n \n-version = \'4.0.0b2.dev0\'\n-longdescription = open(\'README.rst\').read()\n-longdescription += \'\\n\'\n-longdescription += open(\'CHANGES.rst\').read()\n+version = "4.0.0b2.dev0"\n+longdescription = open("README.rst").read()\n+longdescription += "\\n"\n+longdescription += open("CHANGES.rst").read()\n \n setup(\n-    name=\'plone.session\',\n+    name="plone.session",\n     version=version,\n-    description=\'Session based auth tkt authentication for Zope\',\n+    description="Session based auth tkt authentication for Zope",\n     long_description=longdescription,\n     classifiers=[\n-        \'Development Status :: 5 - Production/Stable\',\n-        \'Environment :: Web Environment\',\n-        \'Framework :: Plone :: 6.0\',\n-        \'Framework :: Plone :: Core\',\n-        \'Framework :: Plone\',\n-        \'Framework :: Zope2\',\n-        \'Framework :: Zope :: 4\',\n-        \'License :: OSI Approved :: BSD License\',\n-        \'Operating System :: OS Independent\',\n-        \'Programming Language :: Python :: 3.7\',\n-        \'Programming Language :: Python :: 3.8\',\n-        \'Programming Language :: Python :: 3.9\',\n-        \'Programming Language :: Python\',\n-        \'Topic :: System :: Systems Administration :: Authentication/Directory\',  # noqa\n+        "Development Status :: 5 - Production/Stable",\n+        "Environment :: Web Environment",\n+        "Framework :: Plone :: 6.0",\n+        "Framework :: Plone :: Core",\n+        "Framework :: Plone",\n+        "Framework :: Zope2",\n+        "Framework :: Zope :: 4",\n+        "License :: OSI Approved :: BSD License",\n+        "Operating System :: OS Independent",\n+        "Programming Language :: Python :: 3.7",\n+        "Programming Language :: Python :: 3.8",\n+        "Programming Language :: Python :: 3.9",\n+        "Programming Language :: Python",\n+        "Topic :: System :: Systems Administration :: Authentication/Directory",  # noqa\n     ],\n-    keywords=\'PAS session authentication Zope auth_tkt\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://github.com/plone/plone.session/\',\n-    license=\'BSD\',\n+    keywords="PAS session authentication Zope auth_tkt",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://github.com/plone/plone.session/",\n+    license="BSD",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     extras_require=dict(\n         test=[\n-            \'zope.configuration\',\n-            \'zope.publisher\',\n+            "zope.configuration",\n+            "zope.publisher",\n         ]\n     ),\n     install_requires=[\n-        \'plone.keyring\',\n-        \'plone.protect\',\n-        \'Products.PluggableAuthService\',\n-        \'setuptools\',\n-        \'six\',\n-        \'zope.component\',\n-        \'zope.interface\',\n-        \'Zope2\',\n+        "plone.keyring",\n+        "plone.protect",\n+        "Products.PluggableAuthService",\n+        "setuptools",\n+        "six",\n+        "zope.component",\n+        "zope.interface",\n+        "Zope2",\n     ],\n )\n'

Repository: plone.session


Branch: refs/heads/master
Date: 2022-08-24T21:42:01+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.session/commit/363d288778de6811d935442588fa70ce99c72c38

Remove six

Files changed:
M plone/session/tests/testDocTests.py
M plone/session/tests/testPAS.py
M plone/session/tktauth.py
M setup.py

b'diff --git a/plone/session/tests/testDocTests.py b/plone/session/tests/testDocTests.py\nindex 333b581..0dd3e4f 100644\n--- a/plone/session/tests/testDocTests.py\n+++ b/plone/session/tests/testDocTests.py\n@@ -3,7 +3,6 @@\n \n import doctest\n import re\n-import six\n import unittest\n \n \n@@ -12,10 +11,7 @@\n \n class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n-        if six.PY2:\n-            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n-        else:\n-            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+        want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \ndiff --git a/plone/session/tests/testPAS.py b/plone/session/tests/testPAS.py\nindex cd8d57f..7048f5f 100644\n--- a/plone/session/tests/testPAS.py\n+++ b/plone/session/tests/testPAS.py\n@@ -6,7 +6,6 @@\n from zope.publisher.browser import TestRequest\n \n import base64\n-import six\n import unittest\n \n \n@@ -93,10 +92,7 @@ def testCookieLifetimeWithExpirationSet(self):\n     def testExtraction(self):\n         session = self.folder.pas.session\n         # We will preapre a request that is equal in Py2 and Py3\n-        if six.PY2:\n-            request_body = base64.encodestring(b"test string")\n-        else:\n-            request_body = base64.encodebytes(b"test string").decode()\n+        request_body = base64.encodebytes(b"test string").decode()\n         self.assertEqual(request_body, "dGVzdCBzdHJpbmc=\\n")\n         request = self.makeRequest(request_body)\n         creds = session.extractCredentials(request)\n@@ -147,11 +143,10 @@ def testRefresh(self):\n         self.assertIsNotNone(request2.response.getCookie(session.cookie_name))\n \n     def testUnicodeUserid(self):\n-        unicode_userid = six.text_type(self.userid)\n         response = MockResponse()\n         session = self.folder.pas.session\n         # This step would fail.\n-        session._setupSession(unicode_userid, response)\n+        session._setupSession(self.userid, response)\n \n     def testSpecialCharUserid(self):\n         unicode_userid = "\xc3\xa3bcd\xc3\xa9fghijk"\ndiff --git a/plone/session/tktauth.py b/plone/session/tktauth.py\nindex 71fa9ad..2588d55 100755\n--- a/plone/session/tktauth.py\n+++ b/plone/session/tktauth.py\n@@ -55,9 +55,9 @@\n The cookie itself should be base64 encoded. We will use the built-in Cookie\n module here, your web framework may supply it\'s own mechanism.\n \n-  >>> from six.moves import http_cookies\n+  >>> from http import cookies\n   >>> import binascii\n-  >>> cookie = http_cookies.SimpleCookie()\n+  >>> cookie = cookies.SimpleCookie()\n   >>> cookie[\'auth_tkt\'] = binascii.b2a_base64(tkt).strip().decode()\n   >>> print(cookie)\n   Set-Cookie: auth_tkt=YzdjNzMwMGFjNWNmNTI5NjU2NDQ0MTIzYWNhMzQ1Mjk0ODg1YWZh...\n@@ -72,7 +72,7 @@\n   >>> tkt\n   b\'c7c7300ac5cf529656444123aca345294885afa0jbloggs!\'\n \n-Splitting the data reveals the contents (note the six.text_type output):\n+Splitting the data reveals the contents (note the str output):\n \n   >>> splitTicket(tkt)\n   (b\'c7c7300ac5cf529656444123aca34529\', \'jbloggs\', (), \'\', 1216720800)\n@@ -140,7 +140,6 @@\n \n import hashlib\n import hmac\n-import six\n import time\n \n \n@@ -149,7 +148,7 @@ def safe_encode(value, encoding="utf-8"):\n \n     copied from Products.CMFPlone.utils b/c this package does not depend on it\n     """\n-    if isinstance(value, six.text_type):\n+    if isinstance(value, str):\n         value = value.encode(encoding)\n     return value\n \n@@ -159,16 +158,6 @@ def safe_text(value, encoding="utf-8"):\n \n     copied from Products.CMFPlone.utils b/c this package does not depend on it\n     """\n-    if six.PY2:\n-        if isinstance(value, unicode):\n-            return value\n-        elif isinstance(value, basestring):\n-            try:\n-                value = unicode(value, encoding)\n-            except (UnicodeDecodeError):\n-                value = value.decode("utf-8", "replace")\n-        return value\n-\n     if isinstance(value, str):\n         return value\n     elif isinstance(value, bytes):\n@@ -181,26 +170,21 @@ def safe_text(value, encoding="utf-8"):\n \n def is_equal(val1, val2):\n     # constant time comparison\n-    if not isinstance(val1, six.binary_type) or not isinstance(val2, six.binary_type):\n+    if not isinstance(val1, bytes) or not isinstance(val2, bytes):\n         return False\n     if len(val1) != len(val2):\n         return False\n     result = 0\n-    if six.PY2:\n-        for x, y in zip(val1, val2):\n-            result |= ord(x) ^ ord(y)\n-    else:\n-        for x, y in zip(val1, val2):\n-            result |= x ^ y\n+    for x, y in zip(val1, val2):\n+        result |= x ^ y\n     return result == 0\n \n \n def mod_auth_tkt_digest(secret, data1, data2):\n     digest0 = hashlib.md5(data1 + secret + data2).hexdigest()\n-    if not six.PY2:\n-        # In Python 3 hashlib.md5(value).hexdigest() wants a bites value\n-        # and returns text\n-        digest0 = digest0.encode()\n+    # In Python 3 hashlib.md5(value).hexdigest() wants a bites value\n+    # and returns text\n+    digest0 = digest0.encode()\n     digest = hashlib.md5(digest0 + secret).hexdigest()\n     return digest\n \n@@ -242,7 +226,7 @@ def createTicket(\n         # a sha256 digest is the same length as an md5 hexdigest\n         digest = hmac.new(secret, data1 + data2, hashlib.sha256).digest()\n \n-    if not isinstance(digest, six.binary_type):\n+    if not isinstance(digest, bytes):\n         digest = digest.encode()\n \n     # digest + timestamp as an eight character hexadecimal + userid + !\n@@ -262,10 +246,7 @@ def splitTicket(ticket, encoding=None):\n         raise ValueError\n     timestamp = int(val, 16)  # convert from hexadecimal+\n \n-    if six.PY3:\n-        remainder = safe_text(remainder)\n-    elif encoding is not None:\n-        remainder = safe_text(remainder, encoding)\n+    remainder = safe_text(remainder)\n     parts = remainder.split("!")\n \n     if len(parts) == 2:\ndiff --git a/setup.py b/setup.py\nindex f8bdaed..d1f1d05 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -49,7 +49,6 @@\n         "plone.protect",\n         "Products.PluggableAuthService",\n         "setuptools",\n-        "six",\n         "zope.component",\n         "zope.interface",\n         "Zope2",\n'

Repository: plone.session


Branch: refs/heads/master
Date: 2022-08-24T21:42:01+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.session/commit/62fbf97a826670698db04bfd05d6e7e7bf365327

Remove the Py23DocChecker

Files changed:
M plone/session/tests/testDocTests.py
M plone/session/tktauth.py

b'diff --git a/plone/session/tests/testDocTests.py b/plone/session/tests/testDocTests.py\nindex 0dd3e4f..59aa6e9 100644\n--- a/plone/session/tests/testDocTests.py\n+++ b/plone/session/tests/testDocTests.py\n@@ -2,26 +2,18 @@\n from plone.session import tktauth\n \n import doctest\n-import re\n import unittest\n \n \n optionflags = doctest.ELLIPSIS\n \n \n-class Py23DocChecker(doctest.OutputChecker):\n-    def check_output(self, want, got, optionflags):\n-        want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n-        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n-\n-\n def test_suite():\n     suite = unittest.TestSuite()\n     suite.addTest(\n         doctest.DocTestSuite(\n             tktauth,\n             optionflags=optionflags,\n-            checker=Py23DocChecker(),\n         )\n     )\n     return suite\ndiff --git a/plone/session/tktauth.py b/plone/session/tktauth.py\nindex 2588d55..3565d3b 100755\n--- a/plone/session/tktauth.py\n+++ b/plone/session/tktauth.py\n@@ -283,14 +283,9 @@ def validateTicket(\n \n # doctest runner\n def _test():\n-    from plone.session.tests.testDocTests import Py23DocChecker\n-\n     import doctest\n \n-    doctest.testmod(\n-        optionflags=doctest.ELLIPSIS + doctest.NORMALIZE_WHITESPACE,\n-        checker=Py23DocChecker(),\n-    )\n+    doctest.testmod(optionflags=doctest.ELLIPSIS + doctest.NORMALIZE_WHITESPACE)\n \n \n if __name__ == "__main__":\n'

Repository: plone.session


Branch: refs/heads/master
Date: 2022-08-24T22:44:51+02:00
Author: Maurits van Rees (mauritsvanrees) <m.van.rees@zestsoftware.nl>
Commit: https://github.com/plone/plone.session/commit/36d8728f086de3044d7db04a23a9b86ab609fed6

Merge pull request #32 from plone/remove-six

isort + flake8 + black + remove six + remove the Py23DocChecker

Files changed:
M plone/__init__.py
M plone/session/__init__.py
M plone/session/hiddenprofiles.py
M plone/session/interfaces.py
M plone/session/plugins/session.py
M plone/session/testing.py
M plone/session/tests/testDocTests.py
M plone/session/tests/testPAS.py
M plone/session/tktauth.py
M setup.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex e31cc00..b40aab6 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1,2 @@\n # See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/session/__init__.py b/plone/session/__init__.py\nindex d1a751a..cce9b97 100644\n--- a/plone/session/__init__.py\n+++ b/plone/session/__init__.py\n@@ -13,6 +13,7 @@ def initialize(context):\n         permission=add_user_folders,\n         constructors=(\n             session.manage_addSessionPluginForm,\n-            session.manage_addSessionPlugin),\n-        visibility=None\n+            session.manage_addSessionPlugin,\n+        ),\n+        visibility=None,\n     )\ndiff --git a/plone/session/hiddenprofiles.py b/plone/session/hiddenprofiles.py\nindex 268d902..e6908da 100644\n--- a/plone/session/hiddenprofiles.py\n+++ b/plone/session/hiddenprofiles.py\n@@ -5,12 +5,11 @@\n \n @implementer(INonInstallable)\n class HiddenProfiles(object):\n-\n     def getNonInstallableProfiles(self):\n         """Prevents uninstall profile from showing up in the profile list\n         when creating a Plone site.\n \n         """\n         return [\n-            \'plone.session:uninstall\',\n+            "plone.session:uninstall",\n         ]\ndiff --git a/plone/session/interfaces.py b/plone/session/interfaces.py\nindex 4f836a4..a4790f7 100644\n--- a/plone/session/interfaces.py\n+++ b/plone/session/interfaces.py\n@@ -3,8 +3,7 @@\n \n \n class ISessionPlugin(Interface):\n-    """Session handling PAS plugin.\n-    """\n+    """Session handling PAS plugin."""\n \n     def _setupSession(userid, response):\n         """\ndiff --git a/plone/session/plugins/session.py b/plone/session/plugins/session.py\nindex 763f8c8..b9ff8c7 100644\n--- a/plone/session/plugins/session.py\n+++ b/plone/session/plugins/session.py\n@@ -9,15 +9,9 @@\n from plone.session import tktauth\n from plone.session.interfaces import ISessionPlugin\n from Products.PageTemplates.PageTemplateFile import PageTemplateFile\n-from Products.PluggableAuthService.interfaces.plugins import (\n-    IAuthenticationPlugin,\n-)\n-from Products.PluggableAuthService.interfaces.plugins import (\n-    ICredentialsResetPlugin,\n-)\n-from Products.PluggableAuthService.interfaces.plugins import (\n-    ICredentialsUpdatePlugin,\n-)\n+from Products.PluggableAuthService.interfaces.plugins import IAuthenticationPlugin\n+from Products.PluggableAuthService.interfaces.plugins import ICredentialsResetPlugin\n+from Products.PluggableAuthService.interfaces.plugins import ICredentialsUpdatePlugin\n from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin\n from Products.PluggableAuthService.permissions import ManageUsers\n from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin\n@@ -30,24 +24,23 @@\n \n \n EMPTY_GIF = (\n-    \'GIF89a\\x01\\x00\\x01\\x00\\xf0\\x01\\x00\\xff\\xff\\xff\'\n-    \'\\x00\\x00\\x00!\\xf9\\x04\\x01\\n\\x00\\x00\\x00\'\n-    \',\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x02\\x02D\\x01\\x00;\'\n+    "GIF89a\\x01\\x00\\x01\\x00\\xf0\\x01\\x00\\xff\\xff\\xff"\n+    "\\x00\\x00\\x00!\\xf9\\x04\\x01\\n\\x00\\x00\\x00"\n+    ",\\x00\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x02\\x02D\\x01\\x00;"\n )\n \n-manage_addSessionPluginForm = PageTemplateFile(\'session\', globals())\n+manage_addSessionPluginForm = PageTemplateFile("session", globals())\n \n \n-def manage_addSessionPlugin(dispatcher, id, title=None, path=\'/\',\n-                            REQUEST=None):\n+def manage_addSessionPlugin(dispatcher, id, title=None, path="/", REQUEST=None):\n     """Add a session plugin."""\n     sp = SessionPlugin(id, title=title, path=path)\n     dispatcher._setObject(id, sp)\n \n     if REQUEST is not None:\n         REQUEST.response.redirect(\n-            \'{0}/manage_workspace?\'\n-            \'manage_tabs_message=Session+plugin+created.\'.format(\n+            "{0}/manage_workspace?"\n+            "manage_tabs_message=Session+plugin+created.".format(\n                 dispatcher.absolute_url()\n             )\n         )\n@@ -63,22 +56,21 @@ def cookie_expiration_date(days):\n     IExtractionPlugin,\n     IAuthenticationPlugin,\n     ICredentialsResetPlugin,\n-    ICredentialsUpdatePlugin\n+    ICredentialsUpdatePlugin,\n )\n class SessionPlugin(BasePlugin):\n-    """Session authentication plugin.\n-    """\n+    """Session authentication plugin."""\n \n     meta_type = "Plone Session Plugin"\n     security = ClassSecurityInfo()\n \n     cookie_name = "__ac"\n     cookie_lifetime = 0\n-    cookie_domain = \'\'\n+    cookie_domain = ""\n     mod_auth_tkt = False\n     timeout = 2 * 60 * 60  # 2h - same as default in mod_auth_tkt\n     refresh_interval = 1 * 60 * 60  # -1 to disable\n-    external_ticket_name = \'ticket\'\n+    external_ticket_name = "ticket"\n     secure = False\n     _shared_secret = None\n     secret_prefix = "_plone.session_"\n@@ -142,7 +134,7 @@ class SessionPlugin(BasePlugin):\n             "label": (\n                 "Create a keyring for each user. "\n                 "Enables server-side logout."\n-                "Toggle this from the \\"Manage secrets\\" tab."\n+                \'Toggle this from the "Manage secrets" tab.\'\n             ),\n             "type": "boolean",\n             "mode": "r",\n@@ -150,7 +142,7 @@ class SessionPlugin(BasePlugin):\n     )\n \n     manage_options = (\n-        dict(label=\'Manage secrets\', action=\'manage_secret\'),\n+        dict(label="Manage secrets", action="manage_secret"),\n     ) + BasePlugin.manage_options\n \n     def __init__(self, id, title=None, path="/"):\n@@ -176,7 +168,7 @@ def _getSigningSecret(self, userid):\n         return manager.secret()\n \n     # ISessionPlugin implementation\n-    def _setupSession(self, userid, response, tokens=(), user_data=\'\'):\n+    def _setupSession(self, userid, response, tokens=(), user_data=""):\n         cookie = tktauth.createTicket(\n             secret=self._getSigningSecret(userid),\n             userid=userid,\n@@ -195,9 +187,9 @@ def _setCookie(self, cookie, response):\n             secure = self.secure\n         options = dict(path=self.path, secure=secure, http_only=True, same_site="Lax")\n         if self.cookie_domain:\n-            options[\'domain\'] = self.cookie_domain\n+            options["domain"] = self.cookie_domain\n         if self.cookie_lifetime:\n-            options[\'expires\'] = cookie_expiration_date(self.cookie_lifetime)\n+            options["expires"] = cookie_expiration_date(self.cookie_lifetime)\n         response.setCookie(self.cookie_name, cookie, **options)\n \n     # IExtractionPlugin implementation\n@@ -208,9 +200,7 @@ def extractCredentials(self, request):\n             return creds\n \n         try:\n-            creds["cookie"] = binascii.a2b_base64(\n-                request.get(self.cookie_name)\n-            )\n+            creds["cookie"] = binascii.a2b_base64(request.get(self.cookie_name))\n         except binascii.Error:\n             # If we have a cookie which is not properly base64 encoded it\n             # can not be ours.\n@@ -235,7 +225,7 @@ def authenticateCredentials(self, credentials):\n             return None\n \n         # XXX Should refresh the ticket if after timeout refresh.\n-        return (info[\'id\'], info[\'login\'])\n+        return (info["id"], info["login"])\n \n     def _validateTicket(self, ticket, now=None):\n         _, userid, _, _, _ = tktauth.splitTicket(ticket)\n@@ -249,7 +239,7 @@ def _validateTicket(self, ticket, now=None):\n                 ticket,\n                 timeout=self.timeout,\n                 now=now,\n-                mod_auth_tkt=self.mod_auth_tkt\n+                mod_auth_tkt=self.mod_auth_tkt,\n             )\n         else:\n             ticket_data = None\n@@ -261,7 +251,7 @@ def _validateTicket(self, ticket, now=None):\n             if secret_key in manager:\n                 secrets = manager[secret_key]\n             else:\n-                secrets = manager[u"_system"]\n+                secrets = manager["_system"]\n \n             for secret in secrets:\n                 if secret is None:\n@@ -271,7 +261,7 @@ def _validateTicket(self, ticket, now=None):\n                     ticket,\n                     timeout=self.timeout,\n                     now=now,\n-                    mod_auth_tkt=self.mod_auth_tkt\n+                    mod_auth_tkt=self.mod_auth_tkt,\n                 )\n                 if ticket_data is not None:\n                     break\n@@ -315,7 +305,8 @@ def resetCredentials(self, request, response):\n         response = self.REQUEST["RESPONSE"]\n         if self.cookie_domain:\n             response.expireCookie(\n-                self.cookie_name, path=self.path, domain=self.cookie_domain)\n+                self.cookie_name, path=self.path, domain=self.cookie_domain\n+            )\n         else:\n             response.expireCookie(self.cookie_name, path=self.path)\n \n@@ -334,36 +325,34 @@ def manage_clearSecrets(self, REQUEST):\n                 manager.rotate(ring=ring)\n         response = REQUEST.response\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\' %\n-            (self.absolute_url(), \'All+secrets+cleared.\')\n+            "%s/manage_secret?manage_tabs_message=%s"\n+            % (self.absolute_url(), "All+secrets+cleared.")\n         )\n \n     @security.protected(ManageUsers)\n     @postonly\n     def manage_createNewSecret(self, REQUEST):\n-        """Create a new (signing) secret.\n-        """\n+        """Create a new (signing) secret."""\n         manager = getUtility(IKeyManager)\n         for ring in manager:\n             if ring.startswith(self.secret_prefix) or ring == "_system":\n                 manager.rotate(ring=ring)\n         response = REQUEST.response\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\' %\n-            (self.absolute_url(), \'New+secret+created.\')\n+            "%s/manage_secret?manage_tabs_message=%s"\n+            % (self.absolute_url(), "New+secret+created.")\n         )\n \n     @security.protected(ManageUsers)\n     @postonly\n     def manage_togglePerUserKeyring(self, REQUEST):\n-        """Toggle per-user keyrings.\n-        """\n+        """Toggle per-user keyrings."""\n         self.per_user_keyring = not self.per_user_keyring\n         response = REQUEST.response\n         action = "enabled" if self.per_user_keyring else "disabled"\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\' %\n-            (self.absolute_url(), \'Per-user+keyrings+%s.\' % (action, ))\n+            "%s/manage_secret?manage_tabs_message=%s"\n+            % (self.absolute_url(), "Per-user+keyrings+%s." % (action,))\n         )\n \n     @security.protected(ManageUsers)\n@@ -379,27 +368,26 @@ def manage_removeSharedSecret(self, REQUEST):\n         self._shared_secret = None\n         response = REQUEST.response\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\' %\n-            (self.absolute_url(), \'Shared+secret+removed.\')\n+            "%s/manage_secret?manage_tabs_message=%s"\n+            % (self.absolute_url(), "Shared+secret+removed.")\n         )\n \n     @security.protected(ManageUsers)\n     @postonly\n     def manage_setSharedSecret(self, REQUEST):\n-        """Set the shared secret.\n-        """\n-        secret = REQUEST.get(\'shared_secret\')\n+        """Set the shared secret."""\n+        secret = REQUEST.get("shared_secret")\n         response = REQUEST.response\n         if not secret:\n             response.redirect(\n-                \'%s/manage_secret?manage_tabs_message=%s\' %\n-                (self.absolute_url(), \'Shared+secret+must+not+be+blank.\')\n+                "%s/manage_secret?manage_tabs_message=%s"\n+                % (self.absolute_url(), "Shared+secret+must+not+be+blank.")\n             )\n             return\n         self._shared_secret = secret\n         response.redirect(\n-            \'%s/manage_secret?manage_tabs_message=%s\' %\n-            (self.absolute_url(), \'New+shared+secret+set.\')\n+            "%s/manage_secret?manage_tabs_message=%s"\n+            % (self.absolute_url(), "New+shared+secret+set.")\n         )\n \n     def _refreshSession(self, request, now=None):\n@@ -421,15 +409,15 @@ def _refreshSession(self, request, now=None):\n \n     def _refresh_content(self, REQUEST):\n         setHeader = REQUEST.response.setHeader\n-        type = REQUEST.get(\'type\')\n-        if type == \'gif\':\n-            setHeader(\'Content-Type\', \'image/gif\')\n+        type = REQUEST.get("type")\n+        if type == "gif":\n+            setHeader("Content-Type", "image/gif")\n             return EMPTY_GIF\n-        elif type == \'css\':\n-            setHeader(\'Content-Type\', \'text/css\')\n+        elif type == "css":\n+            setHeader("Content-Type", "text/css")\n             return ""\n-        elif type == \'js\':\n-            setHeader(\'Content-Type\', \'text/javascript\')\n+        elif type == "js":\n+            setHeader("Content-Type", "text/javascript")\n             return ""\n \n     @security.public\n@@ -437,7 +425,7 @@ def refresh(self, REQUEST):\n         """Refresh the cookie"""\n         setHeader = REQUEST.response.setHeader\n         # Disable HTTP 1.0 Caching\n-        setHeader(\'Expires\', formatdate(0, usegmt=True))\n+        setHeader("Expires", formatdate(0, usegmt=True))\n         if self.refresh_interval < 0:\n             return self._refresh_content(REQUEST)\n         now = time.time()\n@@ -445,16 +433,17 @@ def refresh(self, REQUEST):\n         if not refreshed:\n             # We have an unauthenticated user\n             setHeader(\n-                \'Cache-Control\',\n-                \'public, must-revalidate, max-age=%d, s-max-age=86400\' %\n-                self.refresh_interval\n+                "Cache-Control",\n+                "public, must-revalidate, max-age=%d, s-max-age=86400"\n+                % self.refresh_interval,\n             )\n-            setHeader(\'Vary\', \'Cookie\')\n+            setHeader("Vary", "Cookie")\n         else:\n             setHeader(\n-                \'Cache-Control\',\n-                \'private, must-revalidate, proxy-revalidate, max-age=%d, \'\n-                \'s-max-age=0\' % self.refresh_interval)\n+                "Cache-Control",\n+                "private, must-revalidate, proxy-revalidate, max-age=%d, "\n+                "s-max-age=0" % self.refresh_interval,\n+            )\n         return self._refresh_content(REQUEST)\n \n     @security.public\n@@ -463,9 +452,8 @@ def remove(self, REQUEST):\n         self.resetCredentials(REQUEST, REQUEST.response)\n         setHeader = REQUEST.response.setHeader\n         # Disable HTTP 1.0 Caching\n-        setHeader(\'Expires\', formatdate(0, usegmt=True))\n+        setHeader("Expires", formatdate(0, usegmt=True))\n         setHeader(\n-            \'Cache-Control\',\n-            \'public, must-revalidate, max-age=0, s-max-age=86400\'\n+            "Cache-Control", "public, must-revalidate, max-age=0, s-max-age=86400"\n         )\n         return self._refresh_content(REQUEST)\ndiff --git a/plone/session/testing.py b/plone/session/testing.py\nindex d5bbd9c..5fe7d6f 100644\n--- a/plone/session/testing.py\n+++ b/plone/session/testing.py\n@@ -12,10 +12,10 @@\n import doctest\n \n \n-folder_name = \'test_folder_1_\'\n-user_name = \'test_user_1_\'\n-user_password = \'secret\'\n-user_role = \'test_role_1_\'\n+folder_name = "test_folder_1_"\n+user_name = "test_user_1_"\n+user_password = "secret"\n+user_role = "test_role_1_"\n standard_permissions = [access_contents_information, view]\n \n \n@@ -27,7 +27,7 @@ def updateCredentials(self, request, response, userid, password):\n \n     def _verifyUser(self, plugin, user_id=None, login=None):\n         assert user_id is None\n-        if login == \'our_user\':\n+        if login == "our_user":\n             return dict(id=login, login=login, pluginid="session")\n         return None\n \n@@ -39,7 +39,7 @@ def setUpZope(self, app, configurationContext):\n         import plone.session\n         import plone.session.tests\n \n-        self.loadZCML(package=plone.session, name=\'meta.zcml\')\n+        self.loadZCML(package=plone.session, name="meta.zcml")\n         self.loadZCML(package=plone.session)\n         self.loadZCML(package=plone.session.tests)\n \n@@ -60,10 +60,11 @@ def _create_structure(self):\n PLONE_SESSION_FIXTURE = PloneSessionLayer()\n \n PLONE_SESSION_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(PLONE_SESSION_FIXTURE,), name=\'PloneSessionLayer:Integration\'\n+    bases=(PLONE_SESSION_FIXTURE,), name="PloneSessionLayer:Integration"\n )\n PLONE_SEESION_FUNCTIONAL_TESTING = FunctionalTesting(\n-    bases=(PLONE_SESSION_FIXTURE,), name=\'PloneSessionLayer:Functional\',\n+    bases=(PLONE_SESSION_FIXTURE,),\n+    name="PloneSessionLayer:Functional",\n )\n \n optionflags = (\ndiff --git a/plone/session/tests/testDocTests.py b/plone/session/tests/testDocTests.py\nindex 71ee47d..59aa6e9 100644\n--- a/plone/session/tests/testDocTests.py\n+++ b/plone/session/tests/testDocTests.py\n@@ -2,31 +2,18 @@\n from plone.session import tktauth\n \n import doctest\n-import re\n-import six\n import unittest\n \n \n optionflags = doctest.ELLIPSIS\n \n \n-class Py23DocChecker(doctest.OutputChecker):\n-\n-    def check_output(self, want, got, optionflags):\n-        if six.PY2:\n-            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n-        else:\n-            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n-        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n-\n-\n def test_suite():\n     suite = unittest.TestSuite()\n     suite.addTest(\n         doctest.DocTestSuite(\n             tktauth,\n             optionflags=optionflags,\n-            checker=Py23DocChecker(),\n         )\n     )\n     return suite\ndiff --git a/plone/session/tests/testPAS.py b/plone/session/tests/testPAS.py\nindex c24eb65..7048f5f 100644\n--- a/plone/session/tests/testPAS.py\n+++ b/plone/session/tests/testPAS.py\n@@ -6,14 +6,20 @@\n from zope.publisher.browser import TestRequest\n \n import base64\n-import six\n import unittest\n \n \n class MockResponse(object):\n-\n-    def setCookie(self, name, value, path,\n-                  expires=None, secure=False, http_only=False, same_site=None):\n+    def setCookie(\n+        self,\n+        name,\n+        value,\n+        path,\n+        expires=None,\n+        secure=False,\n+        http_only=False,\n+        same_site=None,\n+    ):\n         self.cookie = value\n         self.cookie_expires = expires\n         self.cookie_http_only = http_only\n@@ -24,10 +30,10 @@ def setCookie(self, name, value, path,\n class TestSessionPlugin(unittest.TestCase):\n \n     layer = PLONE_SEESION_FUNCTIONAL_TESTING\n-    userid = \'jbloggs\'\n+    userid = "jbloggs"\n \n     def setUp(self):\n-        self.folder = self.layer[\'app\'][\'test_folder_1_\']\n+        self.folder = self.layer["app"]["test_folder_1_"]\n \n     def testInterfaces(self):\n         session = self.folder.pas.session\n@@ -57,7 +63,7 @@ def testSecureCookies(self):\n         session._setupSession(self.userid, response)\n         self.assertEqual(response.secure, False)\n \n-        setattr(session, \'secure\', True)\n+        setattr(session, "secure", True)\n         session._setupSession(self.userid, response)\n         self.assertEqual(response.secure, True)\n \n@@ -79,18 +85,15 @@ def testCookieLifetimeWithExpirationSet(self):\n         session.cookie_lifetime = 100\n         session._setupSession(self.userid, response)\n         self.assertEqual(\n-            DateTime(response.cookie_expires).strftime(\'%Y%m%d\'),\n-            (DateTime() + 100).strftime(\'%Y%m%d\'),\n+            DateTime(response.cookie_expires).strftime("%Y%m%d"),\n+            (DateTime() + 100).strftime("%Y%m%d"),\n         )\n \n     def testExtraction(self):\n         session = self.folder.pas.session\n         # We will preapre a request that is equal in Py2 and Py3\n-        if six.PY2:\n-            request_body = base64.encodestring(b"test string")\n-        else:\n-            request_body = base64.encodebytes(b"test string").decode()\n-        self.assertEqual(request_body, \'dGVzdCBzdHJpbmc=\\n\')\n+        request_body = base64.encodebytes(b"test string").decode()\n+        self.assertEqual(request_body, "dGVzdCBzdHJpbmc=\\n")\n         request = self.makeRequest(request_body)\n         creds = session.extractCredentials(request)\n         self.assertEqual(creds["source"], "plone.session")\n@@ -115,12 +118,7 @@ def testCredentialsUpdateAnonymous(self):\n         logout()\n         session = self.folder.pas.session\n         request = self.makeRequest("test string")\n-        session.updateCredentials(\n-            request,\n-            request.response,\n-            "our_user",\n-            "password"\n-        )\n+        session.updateCredentials(request, request.response, "our_user", "password")\n         self.assertIsNotNone(\n             request.response.getCookie(session.cookie_name),\n         )\n@@ -130,39 +128,28 @@ def testCredentialsUpdateOtherUser(self):\n         # The session should not be updated then.\n         session = self.folder.pas.session\n         request = self.makeRequest("test string")\n-        session.updateCredentials(\n-            request,\n-            request.response,\n-            "our_user",\n-            "password"\n-        )\n+        session.updateCredentials(request, request.response, "our_user", "password")\n         self.assertIsNone(request.response.getCookie(session.cookie_name))\n \n     def testRefresh(self):\n         logout()\n         session = self.folder.pas.session\n         request = self.makeRequest("test string")\n-        session.updateCredentials(\n-            request,\n-            request.response,\n-            "our_user",\n-            "password"\n-        )\n-        cookie = request.response.getCookie(session.cookie_name)[\'value\']\n+        session.updateCredentials(request, request.response, "our_user", "password")\n+        cookie = request.response.getCookie(session.cookie_name)["value"]\n         request2 = self.makeRequest(cookie)\n-        request2.form[\'type\'] = \'gif\'\n+        request2.form["type"] = "gif"\n         session.refresh(request2)\n         self.assertIsNotNone(request2.response.getCookie(session.cookie_name))\n \n     def testUnicodeUserid(self):\n-        unicode_userid = six.text_type(self.userid)\n         response = MockResponse()\n         session = self.folder.pas.session\n         # This step would fail.\n-        session._setupSession(unicode_userid, response)\n+        session._setupSession(self.userid, response)\n \n     def testSpecialCharUserid(self):\n-        unicode_userid = u"\xc3\xa3bcd\xc3\xa9fghijk"\n+        unicode_userid = "\xc3\xa3bcd\xc3\xa9fghijk"\n         response = MockResponse()\n         session = self.folder.pas.session\n         # This step would fail.\ndiff --git a/plone/session/tktauth.py b/plone/session/tktauth.py\nindex 8b7578a..3565d3b 100755\n--- a/plone/session/tktauth.py\n+++ b/plone/session/tktauth.py\n@@ -55,9 +55,9 @@\n The cookie itself should be base64 encoded. We will use the built-in Cookie\n module here, your web framework may supply it\'s own mechanism.\n \n-  >>> from six.moves import http_cookies\n+  >>> from http import cookies\n   >>> import binascii\n-  >>> cookie = http_cookies.SimpleCookie()\n+  >>> cookie = cookies.SimpleCookie()\n   >>> cookie[\'auth_tkt\'] = binascii.b2a_base64(tkt).strip().decode()\n   >>> print(cookie)\n   Set-Cookie: auth_tkt=YzdjNzMwMGFjNWNmNTI5NjU2NDQ0MTIzYWNhMzQ1Mjk0ODg1YWZh...\n@@ -72,7 +72,7 @@\n   >>> tkt\n   b\'c7c7300ac5cf529656444123aca345294885afa0jbloggs!\'\n \n-Splitting the data reveals the contents (note the six.text_type output):\n+Splitting the data reveals the contents (note the str output):\n \n   >>> splitTicket(tkt)\n   (b\'c7c7300ac5cf529656444123aca34529\', \'jbloggs\', (), \'\', 1216720800)\n@@ -140,74 +140,65 @@\n \n import hashlib\n import hmac\n-import six\n import time\n \n \n-def safe_encode(value, encoding=\'utf-8\'):\n+def safe_encode(value, encoding="utf-8"):\n     """Convert unicode to the specified encoding.\n \n     copied from Products.CMFPlone.utils b/c this package does not depend on it\n     """\n-    if isinstance(value, six.text_type):\n+    if isinstance(value, str):\n         value = value.encode(encoding)\n     return value\n \n \n-def safe_text(value, encoding=\'utf-8\'):\n+def safe_text(value, encoding="utf-8"):\n     """Converts a value to text, even it is already a text string.\n \n     copied from Products.CMFPlone.utils b/c this package does not depend on it\n     """\n-    if six.PY2:\n-        if isinstance(value, unicode):\n-            return value\n-        elif isinstance(value, basestring):\n-            try:\n-                value = unicode(value, encoding)\n-            except (UnicodeDecodeError):\n-                value = value.decode(\'utf-8\', \'replace\')\n-        return value\n-\n     if isinstance(value, str):\n         return value\n     elif isinstance(value, bytes):\n         try:\n             value = str(value, encoding)\n         except (UnicodeDecodeError):\n-            value = value.decode(\'utf-8\', \'replace\')\n+            value = value.decode("utf-8", "replace")\n     return value\n \n \n def is_equal(val1, val2):\n     # constant time comparison\n-    if not isinstance(val1, six.binary_type) or \\\n-       not isinstance(val2, six.binary_type):\n+    if not isinstance(val1, bytes) or not isinstance(val2, bytes):\n         return False\n     if len(val1) != len(val2):\n         return False\n     result = 0\n-    if six.PY2:\n-        for x, y in zip(val1, val2):\n-            result |= ord(x) ^ ord(y)\n-    else:\n-        for x, y in zip(val1, val2):\n-            result |= x ^ y\n+    for x, y in zip(val1, val2):\n+        result |= x ^ y\n     return result == 0\n \n \n def mod_auth_tkt_digest(secret, data1, data2):\n     digest0 = hashlib.md5(data1 + secret + data2).hexdigest()\n-    if not six.PY2:\n-        # In Python 3 hashlib.md5(value).hexdigest() wants a bites value\n-        # and returns text\n-        digest0 = digest0.encode()\n+    # In Python 3 hashlib.md5(value).hexdigest() wants a bites value\n+    # and returns text\n+    digest0 = digest0.encode()\n     digest = hashlib.md5(digest0 + secret).hexdigest()\n     return digest\n \n \n-def createTicket(secret, userid, tokens=(), user_data=\'\', ip=\'0.0.0.0\',\n-                 timestamp=None, encoding=\'utf-8\', mod_auth_tkt=False):\n+def createTicket(\n+    secret,\n+    userid,\n+    tokens=(),\n+    user_data="",\n+    ip="0.0.0.0",\n+    timestamp=None,\n+    encoding="utf-8",\n+    mod_auth_tkt=False,\n+):\n     """\n     By default, use a more compatible\n     """\n@@ -218,7 +209,7 @@ def createTicket(secret, userid, tokens=(), user_data=\'\', ip=\'0.0.0.0\',\n     tokens = [safe_encode(t) for t in tokens]\n     user_data = safe_encode(user_data)\n \n-    token_list = b\',\'.join(tokens)\n+    token_list = b",".join(tokens)\n \n     # ip address is part of the format, set it to 0.0.0.0 to be ignored.\n     # inet_aton packs the ip address into a 4 bytes in network byte order.\n@@ -227,21 +218,21 @@ def createTicket(secret, userid, tokens=(), user_data=\'\', ip=\'0.0.0.0\',\n     # Unfortunately, some older versions of Python assume that longs are always\n     # 32 bits, so we need to trucate the result in case we are on a 64-bit\n     # naive system.\n-    data1 = inet_aton(ip)[:4] + pack(\'!I\', timestamp)\n-    data2 = b\'\\0\'.join((userid, token_list, user_data))\n+    data1 = inet_aton(ip)[:4] + pack("!I", timestamp)\n+    data2 = b"\\0".join((userid, token_list, user_data))\n     if mod_auth_tkt:\n         digest = mod_auth_tkt_digest(secret, data1, data2)\n     else:\n         # a sha256 digest is the same length as an md5 hexdigest\n         digest = hmac.new(secret, data1 + data2, hashlib.sha256).digest()\n \n-    if not isinstance(digest, six.binary_type):\n+    if not isinstance(digest, bytes):\n         digest = digest.encode()\n \n     # digest + timestamp as an eight character hexadecimal + userid + !\n-    ticket = b\'%s%08x%s!\' % (digest, timestamp, userid)\n+    ticket = b"%s%08x%s!" % (digest, timestamp, userid)\n     if tokens:\n-        ticket += token_list + b\'!\'\n+        ticket += token_list + b"!"\n     ticket += user_data\n \n     return ticket\n@@ -255,40 +246,30 @@ def splitTicket(ticket, encoding=None):\n         raise ValueError\n     timestamp = int(val, 16)  # convert from hexadecimal+\n \n-    if six.PY3:\n-        remainder = safe_text(remainder)\n-    elif encoding is not None:\n-        remainder = safe_text(remainder, encoding)\n-    parts = remainder.split(\'!\')\n+    remainder = safe_text(remainder)\n+    parts = remainder.split("!")\n \n     if len(parts) == 2:\n         userid, user_data = parts\n         tokens = ()\n     elif len(parts) == 3:\n         userid, token_list, user_data = parts\n-        tokens = tuple(token_list.split(\',\'))\n+        tokens = tuple(token_list.split(","))\n     else:\n         raise ValueError\n \n     return (digest, userid, tokens, user_data, timestamp)\n \n \n-def validateTicket(secret, ticket, ip=\'0.0.0.0\', timeout=0, now=None,\n-                   encoding=None, mod_auth_tkt=False):\n+def validateTicket(\n+    secret, ticket, ip="0.0.0.0", timeout=0, now=None, encoding=None, mod_auth_tkt=False\n+):\n     try:\n-        (digest, userid, tokens, user_data, timestamp) = data = \\\n-            splitTicket(ticket)\n+        (digest, userid, tokens, user_data, timestamp) = data = splitTicket(ticket)\n     except ValueError:\n         return None\n     new_ticket = createTicket(\n-        secret,\n-        userid,\n-        tokens,\n-        user_data,\n-        ip,\n-        timestamp,\n-        encoding,\n-        mod_auth_tkt\n+        secret, userid, tokens, user_data, ip, timestamp, encoding, mod_auth_tkt\n     )\n     if is_equal(new_ticket[:32], digest):\n         if not timeout:\n@@ -302,14 +283,10 @@ def validateTicket(secret, ticket, ip=\'0.0.0.0\', timeout=0, now=None,\n \n # doctest runner\n def _test():\n-    from plone.session.tests.testDocTests import Py23DocChecker\n-\n     import doctest\n-    doctest.testmod(\n-        optionflags=doctest.ELLIPSIS + doctest.NORMALIZE_WHITESPACE,\n-        checker=Py23DocChecker(),\n-    )\n+\n+    doctest.testmod(optionflags=doctest.ELLIPSIS + doctest.NORMALIZE_WHITESPACE)\n \n \n-if __name__ == \'__main__\':\n+if __name__ == "__main__":\n     _test()\ndiff --git a/setup.py b/setup.py\nindex dfe1593..d1f1d05 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -3,55 +3,54 @@\n from setuptools import setup\n \n \n-version = \'4.0.0b2.dev0\'\n-longdescription = open(\'README.rst\').read()\n-longdescription += \'\\n\'\n-longdescription += open(\'CHANGES.rst\').read()\n+version = "4.0.0b2.dev0"\n+longdescription = open("README.rst").read()\n+longdescription += "\\n"\n+longdescription += open("CHANGES.rst").read()\n \n setup(\n-    name=\'plone.session\',\n+    name="plone.session",\n     version=version,\n-    description=\'Session based auth tkt authentication for Zope\',\n+    description="Session based auth tkt authentication for Zope",\n     long_description=longdescription,\n     classifiers=[\n-        \'Development Status :: 5 - Production/Stable\',\n-        \'Environment :: Web Environment\',\n-        \'Framework :: Plone :: 6.0\',\n-        \'Framework :: Plone :: Core\',\n-        \'Framework :: Plone\',\n-        \'Framework :: Zope2\',\n-        \'Framework :: Zope :: 4\',\n-        \'License :: OSI Approved :: BSD License\',\n-        \'Operating System :: OS Independent\',\n-        \'Programming Language :: Python :: 3.7\',\n-        \'Programming Language :: Python :: 3.8\',\n-        \'Programming Language :: Python :: 3.9\',\n-        \'Programming Language :: Python\',\n-        \'Topic :: System :: Systems Administration :: Authentication/Directory\',  # noqa\n+        "Development Status :: 5 - Production/Stable",\n+        "Environment :: Web Environment",\n+        "Framework :: Plone :: 6.0",\n+        "Framework :: Plone :: Core",\n+        "Framework :: Plone",\n+        "Framework :: Zope2",\n+        "Framework :: Zope :: 4",\n+        "License :: OSI Approved :: BSD License",\n+        "Operating System :: OS Independent",\n+        "Programming Language :: Python :: 3.7",\n+        "Programming Language :: Python :: 3.8",\n+        "Programming Language :: Python :: 3.9",\n+        "Programming Language :: Python",\n+        "Topic :: System :: Systems Administration :: Authentication/Directory",  # noqa\n     ],\n-    keywords=\'PAS session authentication Zope auth_tkt\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://github.com/plone/plone.session/\',\n-    license=\'BSD\',\n+    keywords="PAS session authentication Zope auth_tkt",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://github.com/plone/plone.session/",\n+    license="BSD",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     extras_require=dict(\n-      test=[\n-          \'zope.configuration\',\n-          \'zope.publisher\',\n-      ]\n+        test=[\n+            "zope.configuration",\n+            "zope.publisher",\n+        ]\n     ),\n     install_requires=[\n-      \'plone.keyring\',\n-      \'plone.protect\',\n-      \'Products.PluggableAuthService\',\n-      \'setuptools\',\n-      \'six\',\n-      \'zope.component\',\n-      \'zope.interface\',\n-      \'Zope2\',\n+        "plone.keyring",\n+        "plone.protect",\n+        "Products.PluggableAuthService",\n+        "setuptools",\n+        "zope.component",\n+        "zope.interface",\n+        "Zope2",\n     ],\n )\n'

