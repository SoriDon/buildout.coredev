Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-06-16T19:11:24+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/911a4a36a656f0fe37fbec1d89165b3b1408803f

Merge pull request #51 from plone/maurits-fix-pypi-rights-check

Allow disabling PyPI rights check

Files changed:
A news/50.bugfix
M plone/releaser/pypi.py
M plone/releaser/release.py

b'diff --git a/news/50.bugfix b/news/50.bugfix\nnew file mode 100644\nindex 0000000..ba7b816\n--- /dev/null\n+++ b/news/50.bugfix\n@@ -0,0 +1,4 @@\n+Allow disabling PyPI rights check, as this does not know how to check organisations.\n+Set env variable ``PLONE_RELEASER_CHECK_PYPI_ACCESS=0`` if you want to disable it.\n+Also, we do not check PyPI if the user is `__token__`, so using an API token.\n+[maurits]\ndiff --git a/plone/releaser/pypi.py b/plone/releaser/pypi.py\nindex b3dd29e..3515ef5 100644\n--- a/plone/releaser/pypi.py\n+++ b/plone/releaser/pypi.py\n@@ -2,10 +2,15 @@\n \n \n def get_users_with_release_rights(package_name):\n+    # Note: this is deprecated, but I don\'t see an alternative:\n+    # https://warehouse.pypa.io/api-reference/xml-rpc.html\n     client = ServerProxy("https://pypi.org/pypi")\n     existing_admins = {user for role, user in client.package_roles(package_name)}\n     return existing_admins\n \n \n def can_user_release_package_to_pypi(user, package_name):\n+    # Note: most packages that we release, will have/get the \'plone\' organisation\n+    # as owner, and the code here does not know this, and does not know if you\n+    # are a member of this PyPI organisation.\n     return user in get_users_with_release_rights(package_name)\ndiff --git a/plone/releaser/release.py b/plone/releaser/release.py\nindex c15cd1a..1d17cbd 100644\n--- a/plone/releaser/release.py\n+++ b/plone/releaser/release.py\n@@ -171,7 +171,23 @@ def cleanup_changelog(data):\n \n \n def check_pypi_access(data):\n-    pypi_user = pypi.PypiConfig().config.get("pypi", "username")\n+    env_var = "PLONE_RELEASER_CHECK_PYPI_ACCESS"\n+    try:\n+        if int(os.getenv(env_var, 1)) == 0:\n+            print(\n+                f"{env_var} variable set to zero: not checking pypi release rights."\n+            )\n+            return\n+    except (TypeError, ValueError, AttributeError):\n+        print(\n+            f"ERROR: could not parse {env_var} env var. Ignoring it."\n+        )\n+\n+    section = os.getenv("TWINE_REPOSITORY", "pypi")\n+    pypi_user = pypi.PypiConfig().config.get(section, "username")\n+    if pypi_user == "__token__":\n+        print("Using token for PyPI upload: cannot check if you have release rights.")\n+        return\n     if not can_user_release_package_to_pypi(pypi_user, data["name"]):\n         msg = "User {0} does not have pypi release rights to {1}. Continue?"\n         if not ask(msg.format(pypi_user, data["name"]), default=False):\n@@ -225,7 +241,7 @@ def update_core(data, branch=None):\n \n \n def update_other_core_branches(data):\n-    CORE_BRANCHES = ["5.2", "6.0"]\n+    CORE_BRANCHES = ["5.2", "6.0", "6.1"]\n     package_name = data["name"]\n     root_path = os.path.join(os.getcwd(), "../../")\n \n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-21T23:06:31+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/0c4b5fb2f3839942109cc8e4a6111a1545e77e37

Check all versions*.cfg files when updating a pin.

In coredev 6.0 we have versions.cfg, versions-ecosystem.cfg, versions-extra.cfg.

Files changed:
A news/52.bugfix
M plone/releaser/release.py

b'diff --git a/news/52.bugfix b/news/52.bugfix\nnew file mode 100644\nindex 0000000..549657d\n--- /dev/null\n+++ b/news/52.bugfix\n@@ -0,0 +1,2 @@\n+Check all ``versions*.cfg`` files when updating a pin.\n+[maurits]\ndiff --git a/plone/releaser/release.py b/plone/releaser/release.py\nindex 1d17cbd..b75344d 100644\n--- a/plone/releaser/release.py\n+++ b/plone/releaser/release.py\n@@ -9,7 +9,9 @@\n from zest.releaser.utils import write_text_file\n \n import git\n+import glob\n import os\n+import pathlib\n import sys\n import textwrap\n \n@@ -282,10 +284,16 @@ def _get_package_branch(package_name):\n \n def update_versions(package_name, new_version):\n     # Update version\n-    print("Updating versions.cfg")\n-    path = os.path.join(os.getcwd(), "../../versions.cfg")\n-    versions = VersionsFile(path)\n-    versions.set(package_name, new_version)\n+    print("Updating buildout versions")\n+    cwd = pathlib.Path.cwd()\n+    buildout_dir = (cwd / os.pardir / os.pardir).resolve()\n+    # In coredev 6.0 we have versions.cfg, versions-ecosystem.cfg, versions-extra.cfg.\n+    for filename in glob.glob("versions*.cfg", root_dir=buildout_dir):\n+        path = buildout_dir / filename\n+        versions = VersionsFile(path)\n+        if package_name in versions:\n+            print(f"Updating {filename}")\n+            versions.set(package_name, new_version)\n \n \n def remove_from_checkouts(package_name):\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-22T01:12:49+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/4ac78fa6dd0687bee8404304379e2a78a561388f

Enable updating versions in pip constraints files.

Files changed:
A news/53.feature.1
A plone/releaser/pip.py
M plone/releaser/manage.py
M plone/releaser/release.py

b'diff --git a/news/53.feature.1 b/news/53.feature.1\nnew file mode 100644\nindex 0000000..f29a42c\n--- /dev/null\n+++ b/news/53.feature.1\n@@ -0,0 +1,2 @@\n+Enable updating versions in pip constraints files.\n+[maurits]\ndiff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex 8bafc20..54bbaa6 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -11,6 +11,7 @@\n from plone.releaser.buildout import CheckoutsFile\n from plone.releaser.buildout import VersionsFile\n from plone.releaser.package import Package\n+from plone.releaser.pip import ConstraintsFile\n from progress.bar import Bar\n \n import keyring\n@@ -127,7 +128,20 @@ def append_jenkins_build_number_to_package_version(jenkins_build_number):\n \n \n def set_package_version(version_file_path, package_name, new_version):\n-    versions = VersionsFile(version_file_path)\n+    """Pin package to new version in a versions file.\n+\n+    This can also be a pip constraints file.\n+    If the package is not pinned yet, we add it.\n+\n+    If you want it really fancy you can also add identifiers,\n+    but that only gives valid results for pip files:\n+\n+    bin/manage set-package-version requirements.txt setuptools "65.7.0; python_version >= \'3.0\'"\n+    """\n+    if version_file_path.endswith(".txt"):\n+        versions = ConstraintsFile(version_file_path)\n+    else:\n+        versions = VersionsFile(version_file_path)\n     versions.set(package_name, new_version)\n \n \ndiff --git a/plone/releaser/pip.py b/plone/releaser/pip.py\nnew file mode 100644\nindex 0000000..c593d7a\n--- /dev/null\n+++ b/plone/releaser/pip.py\n@@ -0,0 +1,63 @@\n+import pathlib\n+import re\n+\n+\n+class ConstraintsFile:\n+    def __init__(self, file_location):\n+        self.file_location = file_location\n+        self.path = pathlib.Path(self.file_location).resolve()\n+\n+    @property\n+    def constraints(self):\n+        """Read the constraints."""\n+        contents = self.path.read_text()\n+        constraints = {}\n+        for line in contents.splitlines():\n+            line = line.strip()\n+            if line.startswith("#"):\n+                continue\n+            if "==" not in line:\n+                # We might want to support e.g. \'>=\', but for now keep it simple.\n+                continue\n+            package = line.split("==")[0].strip().lower()\n+            version = line.split("==")[1].strip()\n+            # The line could also contain identifiers like this:\n+            # "; python_version >= \'3.0\'"\n+            # But currently I think we really only need the package name,\n+            # and not even the version.  Let\'s use the entire rest of the line.\n+            constraints[package] = version\n+        return constraints\n+\n+    def __contains__(self, package_name):\n+        return package_name.lower() in self.constraints\n+\n+    def __getitem__(self, package_name):\n+        if package_name in self:\n+            return self.constraints.get(package_name.lower())\n+        raise KeyError\n+\n+    def __setitem__(self, package_name, new_version):\n+        contents = self.path.read_text()\n+        if not contents.endswith("\\n"):\n+            contents += "\\n"\n+\n+        # Should we use \'==\' or \' == \'?  Use spaces when more than half already\n+        # uses them.\n+        newline = f"{package_name}=={new_version}"\n+        if contents.count(" == ") > contents.count("==") / 2:\n+            newline = newline.replace("==", " == ")\n+        if package_name not in self:\n+            contents += newline + "\\n"\n+\n+        reg = re.compile(\n+            rf"^{package_name} ?==.*$",\n+            re.MULTILINE,\n+        )\n+        new_contents = reg.sub(newline, contents)\n+        self.path.write_text(new_contents)\n+\n+    def get(self, package_name):\n+        return self.__getitem__(package_name)\n+\n+    def set(self, package_name, new_version):\n+        return self.__setitem__(package_name, new_version)\ndiff --git a/plone/releaser/release.py b/plone/releaser/release.py\nindex b75344d..349da15 100644\n--- a/plone/releaser/release.py\n+++ b/plone/releaser/release.py\n@@ -2,6 +2,7 @@\n from plone.releaser.buildout import CheckoutsFile\n from plone.releaser.buildout import SourcesFile\n from plone.releaser.buildout import VersionsFile\n+from plone.releaser.pip import ConstraintsFile\n from plone.releaser.pypi import can_user_release_package_to_pypi\n from zest.releaser import pypi\n from zest.releaser.utils import ask\n@@ -286,15 +287,23 @@ def update_versions(package_name, new_version):\n     # Update version\n     print("Updating buildout versions")\n     cwd = pathlib.Path.cwd()\n-    buildout_dir = (cwd / os.pardir / os.pardir).resolve()\n+    coredev_dir = (cwd / os.pardir / os.pardir).resolve()\n     # In coredev 6.0 we have versions.cfg, versions-ecosystem.cfg, versions-extra.cfg.\n-    for filename in glob.glob("versions*.cfg", root_dir=buildout_dir):\n-        path = buildout_dir / filename\n+    for filename in glob.glob("versions*.cfg", root_dir=coredev_dir):\n+        path = coredev_dir / filename\n         versions = VersionsFile(path)\n         if package_name in versions:\n             print(f"Updating {filename}")\n             versions.set(package_name, new_version)\n \n+    # We may have pip constraints files to update.\n+    for filename in glob.glob("constraints*.txt", root_dir=coredev_dir):\n+        path = coredev_dir / filename\n+        versions = ConstraintsFile(path)\n+        if package_name in versions:\n+            print(f"Updating {filename}")\n+            versions.set(package_name, new_version)\n+\n \n def remove_from_checkouts(package_name):\n     print("Removing package from checkouts.cfg")\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-22T01:13:46+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/d330dabcb5a1ec4be417c14c791f511df91bdfe5

Enable updating checkouts in mxdex.ini files.

Files changed:
A news/53.feature.2
M plone/releaser/manage.py
M plone/releaser/pip.py
M plone/releaser/release.py

b'diff --git a/news/53.feature.2 b/news/53.feature.2\nnew file mode 100644\nindex 0000000..f3c5ac7\n--- /dev/null\n+++ b/news/53.feature.2\n@@ -0,0 +1,2 @@\n+Enable updating checkouts in mxdex.ini files.\n+[maurits]\ndiff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex 54bbaa6..c9a832a 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -12,10 +12,12 @@\n from plone.releaser.buildout import VersionsFile\n from plone.releaser.package import Package\n from plone.releaser.pip import ConstraintsFile\n+from plone.releaser.pip import IniFile\n from progress.bar import Bar\n \n import keyring\n import time\n+import sys\n \n \n # TODO\n@@ -111,9 +113,22 @@ def changelog(**kwargs):\n \n \n def check_checkout(package_name, path):\n-    if package_name not in CheckoutsFile(path):\n-        msg = "Your package {0} is not on auto-checkout section"\n-        raise KeyError(msg.format(package_name))\n+    if path.endswith(".ini"):\n+        checkouts = IniFile(path)\n+    else:\n+        checkouts = CheckoutsFile(path)\n+    if package_name not in checkouts:\n+        print(f"No, your package {package_name} is NOT on auto checkout.")\n+        sys.exit(1)\n+    print(f"YES, your package {package_name} is on auto checkout.")\n+\n+\n+def remove_checkout(package_name, path):\n+    if path.endswith(".ini"):\n+        checkouts = IniFile(path)\n+    else:\n+        checkouts = CheckoutsFile(path)\n+    checkouts.remove(package_name)\n \n \n def append_jenkins_build_number_to_package_version(jenkins_build_number):\n@@ -156,6 +171,7 @@ def __call__(self, **kwargs):\n                 pulls,\n                 changelog,\n                 check_checkout,\n+                remove_checkout,\n                 append_jenkins_build_number_to_package_version,\n                 set_package_version,\n                 jenkins_report,\ndiff --git a/plone/releaser/pip.py b/plone/releaser/pip.py\nindex c593d7a..6fbbe57 100644\n--- a/plone/releaser/pip.py\n+++ b/plone/releaser/pip.py\n@@ -1,7 +1,19 @@\n+from collections import UserDict\n+from configparser import ConfigParser\n+from configparser import ExtendedInterpolation\n+\n import pathlib\n import re\n \n \n+def to_bool(value):\n+    if not isinstance(value, str):\n+        return bool(value)\n+    if value.lower() in ("true", "on", "yes", "1"):\n+        return True\n+    return False\n+\n+\n class ConstraintsFile:\n     def __init__(self, file_location):\n         self.file_location = file_location\n@@ -61,3 +73,100 @@ def get(self, package_name):\n \n     def set(self, package_name, new_version):\n         return self.__setitem__(package_name, new_version)\n+\n+\n+class IniFile(UserDict):\n+    """Ini file for mxdev.\n+\n+    What we want to do here is similar to what we have in buildout.py\n+    in the CheckoutsFile: remove a package from auto-checkouts.\n+    For mxdev: set \'use = false\'.\n+    The default is in \'settings\': \'default-use\'.\n+    """\n+    def __init__(self, file_location):\n+        self.file_location = file_location\n+        self.path = pathlib.Path(self.file_location).resolve()\n+        self.config = ConfigParser(\n+            default_section="settings",\n+            interpolation=ExtendedInterpolation(),\n+        )\n+        with open(self.file_location) as f:\n+            self.config.read_file(f)\n+        self.default_use = to_bool(self.config["settings"].get("default-use", True))\n+\n+    @property\n+    def data(self):\n+        checkouts = []\n+        for package in self.config.sections():\n+            use = to_bool(self.config[package].get("use", self.default_use))\n+            if use:\n+                checkouts.append(package)\n+        return checkouts\n+\n+    def __contains__(self, package_name):\n+        return package_name in self.data\n+\n+    def __setitem__(self, package_name, enabled=True):\n+        """Enable or disable a checkout.\n+\n+        Mostly this will be called to disable a checkout.\n+        Expected is that default-use is false.\n+        This means we can remove \'use = true\' from the package.\n+\n+        But let\'s support the other way around as well:\n+        when default-use is true, we set \'use = false\'.\n+        """\n+        use = to_bool(self.config[package_name].get("use", self.default_use))\n+        if use and enabled:\n+            print(f"{package_name} is already used as checkout.")\n+            return\n+        if not use and not enabled:\n+            print(f"{package_name} is not used as checkout.")\n+            return\n+\n+        contents = self.path.read_text()\n+        if not contents.endswith("\\n"):\n+            contents += "\\n"\n+\n+        lines = []\n+        found_package = False\n+        for line in contents.splitlines():\n+            line = line.rstrip()\n+            if line == f"[{package_name}]":\n+                found_package = True\n+                lines.append(line)\n+                continue\n+            if not found_package:\n+                lines.append(line)\n+                continue\n+            if line.startswith("use =") or line.startswith("use="):\n+                # Ignore this line.  We may add a new one a bit further.\n+                continue\n+            if line == "" or line.startswith("["):\n+                # A new section is starting.\n+                if self.default_use and not enabled:\n+                    # We need to explicitly disable it.\n+                    lines.append("use = false")\n+                elif not self.default_use and enabled:\n+                    # We need to explicitly enable it.\n+                    lines.append("use = true")\n+                # We are done with the section for this package name.\n+                found_package = False\n+                # We still need to append the original line.\n+                lines.append(line)\n+                continue\n+            # Just a regular line.\n+            lines.append(line)\n+\n+        contents = "\\n".join(lines) + "\\n"\n+        self.path.write_text(contents)\n+\n+    def __delitem__(self, package_name):\n+        return self.__setitem__(package_name, False)\n+\n+    def add(self, package_name):\n+        return self.__setitem__(package_name, True)\n+\n+    def remove(self, package_name):\n+        # Remove from checkouts.\n+        return self.__delitem__(package_name)\ndiff --git a/plone/releaser/release.py b/plone/releaser/release.py\nindex 349da15..605733d 100644\n--- a/plone/releaser/release.py\n+++ b/plone/releaser/release.py\n@@ -3,6 +3,7 @@\n from plone.releaser.buildout import SourcesFile\n from plone.releaser.buildout import VersionsFile\n from plone.releaser.pip import ConstraintsFile\n+from plone.releaser.pip import IniFile\n from plone.releaser.pypi import can_user_release_package_to_pypi\n from zest.releaser import pypi\n from zest.releaser.utils import ask\n@@ -306,7 +307,14 @@ def update_versions(package_name, new_version):\n \n \n def remove_from_checkouts(package_name):\n-    print("Removing package from checkouts.cfg")\n-    path = os.path.join(os.getcwd(), "../../checkouts.cfg")\n-    checkouts = CheckoutsFile(path)\n-    checkouts.remove(package_name)\n+    print("Removing package from checkouts")\n+    cwd = pathlib.Path.cwd()\n+    coredev_dir = (cwd / os.pardir / os.pardir).resolve()\n+    checkouts_file = coredev_dir / "checkouts.cfg"\n+    if checkouts_file.exists():\n+        checkouts = CheckoutsFile(checkouts_file)\n+        checkouts.remove(package_name)\n+    checkouts_file = coredev_dir / "mxdev.ini"\n+    if checkouts_file.exists():\n+        checkouts = IniFile(checkouts_file)\n+        checkouts.remove(package_name)\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-22T01:35:53+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/d7ecb945f8e05a6a272c24804e0fd5bb678a908c

Only set [buildout] directory option when buildout section exists.

This is only the case in versions.cfg, not in versions-extra.cfg or versions-ecosystem.cfg.

Files changed:
M plone/releaser/buildout.py

b'diff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex 52f7dfd..0f4cd4e 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -65,7 +65,8 @@ def versions(self):\n         with open(self.file_location) as f:\n             config.read_file(f)\n         # https://github.com/plone/plone.releaser/issues/42\n-        config["buildout"]["directory"] = os.getcwd()\n+        if config.has_section("buildout"):\n+            config["buildout"]["directory"] = os.getcwd()\n         versions = {}\n         for section in config.sections():\n             if "versions" in section.split(":"):\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-22T21:27:19+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/a7a12436e3248fb208e8087b924d516716a9cc10

set-package-version: set in several files when no path is given.

This switches the order of the arguments.

Files changed:
M plone/releaser/manage.py

b'diff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex c9a832a..2f16d0a 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -15,6 +15,7 @@\n from plone.releaser.pip import IniFile\n from progress.bar import Bar\n \n+import glob\n import keyring\n import time\n import sys\n@@ -142,22 +143,31 @@ def append_jenkins_build_number_to_package_version(jenkins_build_number):\n     return new_version\n \n \n-def set_package_version(version_file_path, package_name, new_version):\n+def set_package_version(package_name, new_version, version_file_path=None):\n     """Pin package to new version in a versions file.\n \n     This can also be a pip constraints file.\n     If the package is not pinned yet, we add it.\n \n+    If no path is given, we try several paths and set the version in all of them.\n+\n     If you want it really fancy you can also add identifiers,\n     but that only gives valid results for pip files:\n \n-    bin/manage set-package-version requirements.txt setuptools "65.7.0; python_version >= \'3.0\'"\n+    bin/manage set-package-version setuptools "65.7.0; python_version >= \'3.0\'" requirements.txt\n     """\n-    if version_file_path.endswith(".txt"):\n-        versions = ConstraintsFile(version_file_path)\n+    if version_file_path:\n+        paths = [version_file_path]\n     else:\n-        versions = VersionsFile(version_file_path)\n-    versions.set(package_name, new_version)\n+        paths = glob.glob("constraints*.txt") + glob.glob("versions*.cfg")\n+    for path in paths:\n+        if path.endswith(".txt"):\n+            versions = ConstraintsFile(path)\n+        else:\n+            versions = VersionsFile(path)\n+        if package_name in versions:\n+            print(f"Updating {path}")\n+            versions.set(package_name, new_version)\n \n \n class Manage:\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-22T21:34:36+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/f49803496dda0fd9d7e329e605baa2e295ad7fb5

check-checkout, remove-checkout: handle several files when no path is given.

Files changed:
M plone/releaser/manage.py

b'diff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex 2f16d0a..9e243e7 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -113,23 +113,43 @@ def changelog(**kwargs):\n     build_unified_changelog(kwargs["start"], kwargs["end"])\n \n \n-def check_checkout(package_name, path):\n-    if path.endswith(".ini"):\n-        checkouts = IniFile(path)\n+def check_checkout(package_name, path=None):\n+    """Check if package is in the checkouts.\n+\n+    If no path is given, we try several paths:\n+    both checkouts.cfg and mxdev.ini.\n+    """\n+    if path:\n+        paths = [path]\n     else:\n-        checkouts = CheckoutsFile(path)\n-    if package_name not in checkouts:\n-        print(f"No, your package {package_name} is NOT on auto checkout.")\n-        sys.exit(1)\n-    print(f"YES, your package {package_name} is on auto checkout.")\n+        paths = glob.glob("mxdev.ini") + glob.glob("checkouts.cfg")\n+    for path in paths:\n+        if path.endswith(".ini"):\n+            checkouts = IniFile(path)\n+        else:\n+            checkouts = CheckoutsFile(path)\n+        if package_name not in checkouts:\n+            print(f"No, your package {package_name} is NOT on auto checkout in {path}.")\n+        else:\n+            print(f"YES, your package {package_name} is on auto checkout in {path}.")\n \n \n-def remove_checkout(package_name, path):\n-    if path.endswith(".ini"):\n-        checkouts = IniFile(path)\n+def remove_checkout(package_name, path=None):\n+    """Remove package from auto checkouts.\n+\n+    If no path is given, we try several paths:\n+    both checkouts.cfg and mxdev.ini.\n+    """\n+    if path:\n+        paths = [path]\n     else:\n-        checkouts = CheckoutsFile(path)\n-    checkouts.remove(package_name)\n+        paths = glob.glob("mxdev.ini") + glob.glob("checkouts.cfg")\n+    for path in paths:\n+        if path.endswith(".ini"):\n+            checkouts = IniFile(path)\n+        else:\n+            checkouts = CheckoutsFile(path)\n+        checkouts.remove(package_name)\n \n \n def append_jenkins_build_number_to_package_version(jenkins_build_number):\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-24T12:34:30+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/042c99d5a8afd731198da6f5eb33883c7e64018d

set-package-version: pass --path if you want to update a specific file.

I thought '=None' made this an argument that you could add or leave away.
But it made it a command line option, so you need --path.

Files changed:
M plone/releaser/manage.py

b'diff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex 9e243e7..8a5ef23 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -163,7 +163,7 @@ def append_jenkins_build_number_to_package_version(jenkins_build_number):\n     return new_version\n \n \n-def set_package_version(package_name, new_version, version_file_path=None):\n+def set_package_version(package_name, new_version, path=None):\n     """Pin package to new version in a versions file.\n \n     This can also be a pip constraints file.\n@@ -174,10 +174,10 @@ def set_package_version(package_name, new_version, version_file_path=None):\n     If you want it really fancy you can also add identifiers,\n     but that only gives valid results for pip files:\n \n-    bin/manage set-package-version setuptools "65.7.0; python_version >= \'3.0\'" requirements.txt\n+    bin/manage set-package-version setuptools "65.7.0; python_version >= \'3.0\'" --path requirements.txt\n     """\n-    if version_file_path:\n-        paths = [version_file_path]\n+    if path:\n+        paths = [path]\n     else:\n         paths = glob.glob("constraints*.txt") + glob.glob("versions*.cfg")\n     for path in paths:\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-24T13:35:07+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/17f085a62680007811a538408e84ec5605b138bf

Let remove/add/check checkout work case insensitively.

'add-checkout' is new.

Files changed:
M plone/releaser/buildout.py
M plone/releaser/manage.py
M plone/releaser/pip.py

b'diff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex 0f4cd4e..2857cea 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -152,33 +152,47 @@ def data(self):\n             config.read_file(f)\n         config["buildout"]["directory"] = os.getcwd()\n         checkouts = config.get("buildout", "auto-checkout")\n-        checkout_list = checkouts.split("\\n")\n-        return checkout_list\n+        # Map from lower case to actual case, so we can find the package.\n+        mapping = {}\n+        for package in checkouts.splitlines():\n+            mapping[package.lower()] = package\n+        return mapping\n \n     def __contains__(self, package_name):\n-        return package_name in self.data\n+        return package_name.lower() in self.data\n \n     def __setitem__(self, package_name, enabled=True):\n         path = os.path.join(os.getcwd(), self.file_location)\n         with open(path) as f:\n             checkoutstxt = f.read()\n-        with open(path, "w") as f:\n-            if not checkoutstxt.endswith("\\n"):\n-                # Make sure the file ends with a newline.\n-                checkoutstxt += "\\n"\n-            # Look for the package name on a line of its own,\n-            # with likely whitespace in front.\n-            reg = re.compile(rf"^[\\s]*{package_name}\\n", re.MULTILINE)\n+        # Look for the package name on a line of its own,\n+        # with likely whitespace in front.\n+        # Regexp is failing we while trying to use re.IGNORECASE,\n+        # so let\'s do it line by line.\n+        # reg = re.compile(rf"^[\\s]*{package_name}\\n", re.MULTILINE | re.IGNORECASE)\n+        lines = []\n+        found = False\n+        for line in checkoutstxt.splitlines():\n+            if line.strip().lower() != package_name.lower():\n+                lines.append(line)\n+                continue\n+            # We have a match.\n+            if found:\n+                # This is a duplicate, ignore the line.\n+                continue\n+            found = True\n+            # Include this line only if we want it enabled.\n             if enabled:\n-                # We used to look for "# test-only fixes:" here,\n-                # and place the checkout before it.\n-                # But this text is no longer in any current checkouts.cfg.\n-                if not reg.match(checkoutstxt):\n-                    # It is indeed not yet in the checkouts.\n-                    newCheckoutsTxt = checkoutstxt + f"    {package_name}\\n"\n-            else:\n-                # Remove the package name\n-                newCheckoutsTxt = reg.sub("", checkoutstxt)\n+                lines.append(line)\n+        # The only case we still need to handle, is when the package was not found\n+        # and enabled=True.\n+        if enabled and not found:\n+            lines.append(f"    {package_name}")\n+        newCheckoutsTxt = "\\n".join(lines)\n+        if not newCheckoutsTxt.endswith("\\n"):\n+            # Make sure the file ends with a newline.\n+            newCheckoutsTxt += "\\n"\n+        with open(path, "w") as f:\n             f.write(newCheckoutsTxt)\n \n     def __delitem__(self, package_name):\ndiff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex 8a5ef23..0d2ecc4 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -152,6 +152,24 @@ def remove_checkout(package_name, path=None):\n         checkouts.remove(package_name)\n \n \n+def add_checkout(package_name, path=None):\n+    """Add package to auto checkouts.\n+\n+    If no path is given, we try several paths:\n+    both checkouts.cfg and mxdev.ini.\n+    """\n+    if path:\n+        paths = [path]\n+    else:\n+        paths = glob.glob("mxdev.ini") + glob.glob("checkouts.cfg")\n+    for path in paths:\n+        if path.endswith(".ini"):\n+            checkouts = IniFile(path)\n+        else:\n+            checkouts = CheckoutsFile(path)\n+        checkouts.add(package_name)\n+\n+\n def append_jenkins_build_number_to_package_version(jenkins_build_number):\n     from zest.releaser.utils import cleanup_version\n     from zest.releaser.vcs import BaseVersionControl\n@@ -202,6 +220,7 @@ def __call__(self, **kwargs):\n                 changelog,\n                 check_checkout,\n                 remove_checkout,\n+                add_checkout,\n                 append_jenkins_build_number_to_package_version,\n                 set_package_version,\n                 jenkins_report,\ndiff --git a/plone/releaser/pip.py b/plone/releaser/pip.py\nindex 6fbbe57..f49dc33 100644\n--- a/plone/releaser/pip.py\n+++ b/plone/releaser/pip.py\n@@ -96,15 +96,16 @@ def __init__(self, file_location):\n \n     @property\n     def data(self):\n-        checkouts = []\n+        checkouts = {}\n         for package in self.config.sections():\n             use = to_bool(self.config[package].get("use", self.default_use))\n             if use:\n-                checkouts.append(package)\n+                # Map from lower case to actual case, so we can find the package.\n+                checkouts[package.lower()] = package\n         return checkouts\n \n     def __contains__(self, package_name):\n-        return package_name in self.data\n+        return package_name.lower() in self.data\n \n     def __setitem__(self, package_name, enabled=True):\n         """Enable or disable a checkout.\n@@ -116,7 +117,12 @@ def __setitem__(self, package_name, enabled=True):\n         But let\'s support the other way around as well:\n         when default-use is true, we set \'use = false\'.\n         """\n-        use = to_bool(self.config[package_name].get("use", self.default_use))\n+        stored_package_name = self.data.get(package_name.lower())\n+        if stored_package_name:\n+            package_name = stored_package_name\n+            use = to_bool(self.config[package_name].get("use", self.default_use))\n+        else:\n+            use = False\n         if use and enabled:\n             print(f"{package_name} is already used as checkout.")\n             return\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-26T22:04:30+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/f1584f66d7b95ab2895b94585d7aa86140b969a5

Factor out shared code for getting parsed checkouts.

Files changed:
M plone/releaser/manage.py

b'diff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex 0d2ecc4..0fee1cc 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -18,7 +18,6 @@\n import glob\n import keyring\n import time\n-import sys\n \n \n # TODO\n@@ -113,10 +112,10 @@ def changelog(**kwargs):\n     build_unified_changelog(kwargs["start"], kwargs["end"])\n \n \n-def check_checkout(package_name, path=None):\n-    """Check if package is in the checkouts.\n+def _get_checkouts(path=None):\n+    """Get the parsed checkouts file at the given path.\n \n-    If no path is given, we try several paths:\n+    If no path is given, we use several paths:\n     both checkouts.cfg and mxdev.ini.\n     """\n     if path:\n@@ -128,10 +127,25 @@ def check_checkout(package_name, path=None):\n             checkouts = IniFile(path)\n         else:\n             checkouts = CheckoutsFile(path)\n+        yield checkouts\n+\n+\n+def check_checkout(package_name, path=None):\n+    """Check if package is in the checkouts.\n+\n+    If no path is given, we try several paths:\n+    both checkouts.cfg and mxdev.ini.\n+    """\n+    for checkouts in _get_checkouts(path=path):\n+        loc = checkouts.file_location\n         if package_name not in checkouts:\n-            print(f"No, your package {package_name} is NOT on auto checkout in {path}.")\n+            print(\n+                f"No, your package {package_name} is NOT on auto checkout in {loc}."\n+            )\n         else:\n-            print(f"YES, your package {package_name} is on auto checkout in {path}.")\n+            print(\n+                f"YES, your package {package_name} is on auto checkout in {loc}."\n+            )\n \n \n def remove_checkout(package_name, path=None):\n@@ -140,15 +154,7 @@ def remove_checkout(package_name, path=None):\n     If no path is given, we try several paths:\n     both checkouts.cfg and mxdev.ini.\n     """\n-    if path:\n-        paths = [path]\n-    else:\n-        paths = glob.glob("mxdev.ini") + glob.glob("checkouts.cfg")\n-    for path in paths:\n-        if path.endswith(".ini"):\n-            checkouts = IniFile(path)\n-        else:\n-            checkouts = CheckoutsFile(path)\n+    for checkouts in _get_checkouts(path=path):\n         checkouts.remove(package_name)\n \n \n@@ -158,15 +164,7 @@ def add_checkout(package_name, path=None):\n     If no path is given, we try several paths:\n     both checkouts.cfg and mxdev.ini.\n     """\n-    if path:\n-        paths = [path]\n-    else:\n-        paths = glob.glob("mxdev.ini") + glob.glob("checkouts.cfg")\n-    for path in paths:\n-        if path.endswith(".ini"):\n-            checkouts = IniFile(path)\n-        else:\n-            checkouts = CheckoutsFile(path)\n+    for checkouts in _get_checkouts(path=path):\n         checkouts.add(package_name)\n \n \n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-26T22:18:09+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/2fd42b00e36bbc056998d6792cfc913d948e3a66

checkouts: always report if, what, and where we did something.

Make the messages the same for pip/mxdev and buildout.

Files changed:
M plone/releaser/buildout.py
M plone/releaser/pip.py

b'diff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex 2857cea..c73a079 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -184,10 +184,16 @@ def __setitem__(self, package_name, enabled=True):\n             # Include this line only if we want it enabled.\n             if enabled:\n                 lines.append(line)\n-        # The only case we still need to handle, is when the package was not found\n-        # and enabled=True.\n-        if enabled and not found:\n-            lines.append(f"    {package_name}")\n+                print(f"{self.file_location}: {package_name} already in checkouts.")\n+            else:\n+                print(f"{self.file_location}: {package_name} removed from checkouts.")\n+        if not found:\n+            if enabled:\n+                lines.append(f"    {package_name}")\n+                print(f"{self.file_location}: {package_name} added to checkouts.")\n+            else:\n+                print(f"{self.file_location}: {package_name} not in checkouts.")\n+\n         newCheckoutsTxt = "\\n".join(lines)\n         if not newCheckoutsTxt.endswith("\\n"):\n             # Make sure the file ends with a newline.\ndiff --git a/plone/releaser/pip.py b/plone/releaser/pip.py\nindex f49dc33..2327f4f 100644\n--- a/plone/releaser/pip.py\n+++ b/plone/releaser/pip.py\n@@ -83,6 +83,7 @@ class IniFile(UserDict):\n     For mxdev: set \'use = false\'.\n     The default is in \'settings\': \'default-use\'.\n     """\n+\n     def __init__(self, file_location):\n         self.file_location = file_location\n         self.path = pathlib.Path(self.file_location).resolve()\n@@ -124,10 +125,10 @@ def __setitem__(self, package_name, enabled=True):\n         else:\n             use = False\n         if use and enabled:\n-            print(f"{package_name} is already used as checkout.")\n+            print(f"{self.file_location}: {package_name} already in checkouts.")\n             return\n         if not use and not enabled:\n-            print(f"{package_name} is not used as checkout.")\n+            print(f"{self.file_location}: {package_name} not in checkouts.")\n             return\n \n         contents = self.path.read_text()\n@@ -150,12 +151,18 @@ def __setitem__(self, package_name, enabled=True):\n                 continue\n             if line == "" or line.startswith("["):\n                 # A new section is starting.\n-                if self.default_use and not enabled:\n-                    # We need to explicitly disable it.\n-                    lines.append("use = false")\n-                elif not self.default_use and enabled:\n-                    # We need to explicitly enable it.\n-                    lines.append("use = true")\n+                if not enabled:\n+                    if self.default_use:\n+                        # We need to explicitly disable it.\n+                        lines.append("use = false")\n+                    print(\n+                        f"{self.file_location}: {package_name} removed from checkouts."\n+                    )\n+                else:\n+                    if not self.default_use:\n+                        # We need to explicitly enable it.\n+                        lines.append("use = true")\n+                    print(f"{self.file_location}: {package_name} added to checkouts.")\n                 # We are done with the section for this package name.\n                 found_package = False\n                 # We still need to append the original line.\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-26T22:20:49+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/a5699229ab7c8c5545942f0870c1eed92c08e56e

pip.py: use cached_property for constraints.

Files changed:
M plone/releaser/pip.py

b'diff --git a/plone/releaser/pip.py b/plone/releaser/pip.py\nindex 2327f4f..b03daf1 100644\n--- a/plone/releaser/pip.py\n+++ b/plone/releaser/pip.py\n@@ -1,6 +1,7 @@\n from collections import UserDict\n from configparser import ConfigParser\n from configparser import ExtendedInterpolation\n+from functools import cached_property\n \n import pathlib\n import re\n@@ -19,7 +20,7 @@ def __init__(self, file_location):\n         self.file_location = file_location\n         self.path = pathlib.Path(self.file_location).resolve()\n \n-    @property\n+    @cached_property\n     def constraints(self):\n         """Read the constraints."""\n         contents = self.path.read_text()\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-26T22:22:44+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/af7b40a47bc55eaa55216c883b00033a3477373e

constraints: always set '==' without spaces.

Files changed:
M plone/releaser/pip.py

b'diff --git a/plone/releaser/pip.py b/plone/releaser/pip.py\nindex b03daf1..3e41af6 100644\n--- a/plone/releaser/pip.py\n+++ b/plone/releaser/pip.py\n@@ -54,11 +54,7 @@ def __setitem__(self, package_name, new_version):\n         if not contents.endswith("\\n"):\n             contents += "\\n"\n \n-        # Should we use \'==\' or \' == \'?  Use spaces when more than half already\n-        # uses them.\n         newline = f"{package_name}=={new_version}"\n-        if contents.count(" == ") > contents.count("==") / 2:\n-            newline = newline.replace("==", " == ")\n         if package_name not in self:\n             contents += newline + "\\n"\n \n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-26T23:07:46+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/8521c02803a0c0e86fa1b8e15c44540337372ef4

Add get-package-version. Better report on what set-package-version does.

More similar to the checkouts commands now.
Some lowercase fixes still need to happen though.

Files changed:
M plone/releaser/buildout.py
M plone/releaser/manage.py
M plone/releaser/package.py
M plone/releaser/pip.py
M plone/releaser/release.py

b'diff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex c73a079..5de996f 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -3,6 +3,7 @@\n from configparser import ConfigParser\n from configparser import ExtendedInterpolation\n \n+import pathlib\n import os\n import re\n \n@@ -49,6 +50,7 @@ def path(self):\n class VersionsFile:\n     def __init__(self, file_location):\n         self.file_location = file_location\n+        self.path = pathlib.Path(self.file_location).resolve()\n \n     @property\n     def versions(self):\n@@ -84,21 +86,28 @@ def __getitem__(self, package_name):\n         raise KeyError\n \n     def __setitem__(self, package_name, new_version):\n-        path = os.path.join(os.getcwd(), self.file_location)\n-        with open(path) as f:\n-            versionstxt = f.read()\n+        versionstxt = self.path.read_text()\n+        if not versionstxt.endswith("\\n"):\n+            versionstxt += "\\n"\n+            self.path.write_text(versionstxt)\n \n+        newline = f"{package_name} = {new_version}"\n         if package_name not in self:\n-            newline = f"{package_name} = {new_version}"\n             versionstxt += newline\n+            print(f"{self.file_location}: \'{newline}\' added.")\n+            self.path.write_text(versionstxt)\n+            return\n \n         reg = re.compile(\n             rf"(^{package_name}[\\s\\=]+)[0-9\\.abrc]+(.post\\d+)?(.dev\\d+)?",\n             re.MULTILINE,\n         )\n         newVersionsTxt = reg.sub(rf"\\g<1>{new_version}", versionstxt)\n-        with open(path, "w") as f:\n-            f.write(newVersionsTxt)\n+        if versionstxt != newVersionsTxt:\n+            print(f"{self.file_location}: have set \'{newline}\'.")\n+            self.path.write_text(newVersionsTxt)\n+            return\n+        print(f"{self.file_location}: \'{newline}\' already there.")\n \n     def get(self, package_name):\n         return self.__getitem__(package_name)\n@@ -110,6 +119,7 @@ def set(self, package_name, new_version):\n class SourcesFile(UserDict):\n     def __init__(self, file_location):\n         self.file_location = file_location\n+        self.path = pathlib.Path(self.file_location).resolve()\n \n     @property\n     def data(self):\n@@ -144,6 +154,7 @@ def __iter__(self):\n class CheckoutsFile(UserDict):\n     def __init__(self, file_location):\n         self.file_location = file_location\n+        self.path = pathlib.Path(self.file_location).resolve()\n \n     @property\n     def data(self):\n@@ -162,9 +173,12 @@ def __contains__(self, package_name):\n         return package_name.lower() in self.data\n \n     def __setitem__(self, package_name, enabled=True):\n-        path = os.path.join(os.getcwd(), self.file_location)\n-        with open(path) as f:\n-            checkoutstxt = f.read()\n+        checkoutstxt = self.path.read_text()\n+        if not checkoutstxt.endswith("\\n"):\n+            # Make sure the file ends with a newline.\n+            checkoutstxt += "\\n"\n+            self.path.write_text(checkoutstxt)\n+\n         # Look for the package name on a line of its own,\n         # with likely whitespace in front.\n         # Regexp is failing we while trying to use re.IGNORECASE,\n@@ -194,12 +208,9 @@ def __setitem__(self, package_name, enabled=True):\n             else:\n                 print(f"{self.file_location}: {package_name} not in checkouts.")\n \n-        newCheckoutsTxt = "\\n".join(lines)\n-        if not newCheckoutsTxt.endswith("\\n"):\n-            # Make sure the file ends with a newline.\n-            newCheckoutsTxt += "\\n"\n-        with open(path, "w") as f:\n-            f.write(newCheckoutsTxt)\n+        newCheckoutsTxt = "\\n".join(lines) + "\\n"\n+        if checkoutstxt != newCheckoutsTxt:\n+            self.path.write_text(newCheckoutsTxt)\n \n     def __delitem__(self, package_name):\n         return self.__setitem__(package_name, False)\ndiff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex 0fee1cc..3e9eaa9 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -139,13 +139,9 @@ def check_checkout(package_name, path=None):\n     for checkouts in _get_checkouts(path=path):\n         loc = checkouts.file_location\n         if package_name not in checkouts:\n-            print(\n-                f"No, your package {package_name} is NOT on auto checkout in {loc}."\n-            )\n+            print(f"No, your package {package_name} is NOT on auto checkout in {loc}.")\n         else:\n-            print(\n-                f"YES, your package {package_name} is on auto checkout in {loc}."\n-            )\n+            print(f"YES, your package {package_name} is on auto checkout in {loc}.")\n \n \n def remove_checkout(package_name, path=None):\n@@ -179,31 +175,62 @@ def append_jenkins_build_number_to_package_version(jenkins_build_number):\n     return new_version\n \n \n+def _get_constraints(path=None):\n+    """Get the parsed constraints/versions file at the given path.\n+\n+    If no path is given, we use several paths:\n+    constraints*.txt and versions*.cfg.\n+    """\n+    if path:\n+        paths = [path]\n+    else:\n+        paths = glob.glob("constraints*.txt") + glob.glob("versions*.cfg")\n+    for path in paths:\n+        if path.endswith(".txt"):\n+            constraints = ConstraintsFile(path)\n+        else:\n+            constraints = VersionsFile(path)\n+        yield constraints\n+\n+\n+def get_package_version(package_name, path=None):\n+    """Get package version fron constraints/versions file.\n+\n+    If no path is given, we try several paths.\n+    """\n+    for constraints in _get_constraints(path=None):\n+        if package_name not in constraints:\n+            print(f"{constraints.file_location}: {package_name} missing.")\n+            continue\n+        version = constraints.get(package_name)\n+        print(f"{constraints.file_location}: {package_name} {version}.")\n+\n+\n def set_package_version(package_name, new_version, path=None):\n     """Pin package to new version in a versions file.\n \n     This can also be a pip constraints file.\n     If the package is not pinned yet, we add it.\n \n-    If no path is given, we try several paths and set the version in all of them.\n+    If no path is given, we try several paths and set the version in all of them,\n+    bu only if the package is already there: we do not want to add one package\n+    in three versions*.cfg files.\n \n     If you want it really fancy you can also add identifiers,\n     but that only gives valid results for pip files:\n \n     bin/manage set-package-version setuptools "65.7.0; python_version >= \'3.0\'" --path requirements.txt\n     """\n-    if path:\n-        paths = [path]\n-    else:\n-        paths = glob.glob("constraints*.txt") + glob.glob("versions*.cfg")\n-    for path in paths:\n-        if path.endswith(".txt"):\n-            versions = ConstraintsFile(path)\n-        else:\n-            versions = VersionsFile(path)\n-        if package_name in versions:\n-            print(f"Updating {path}")\n-            versions.set(package_name, new_version)\n+    for constraints in _get_constraints(path=None):\n+        if package_name not in constraints:\n+            if path is None:\n+                print(f"{constraints.file_location}: {package_name} missing.")\n+                continue\n+            print(\n+                f"{constraints.file_location}: {package_name} not pinned yet. "\n+                f"Adding pin because you explicitly gave the path."\n+            )\n+        constraints.set(package_name, new_version)\n \n \n class Manage:\n@@ -221,6 +248,7 @@ def __call__(self, **kwargs):\n                 add_checkout,\n                 append_jenkins_build_number_to_package_version,\n                 set_package_version,\n+                get_package_version,\n                 jenkins_report,\n             ]\n         )\ndiff --git a/plone/releaser/package.py b/plone/releaser/package.py\nindex d68a91c..09b55d9 100644\n--- a/plone/releaser/package.py\n+++ b/plone/releaser/package.py\n@@ -50,7 +50,6 @@ def buildout_coredev():\n \n \n class Package:\n-\n     # A reference to an plone.releaser.buildout.Buildout instance\n     buildout = None\n \ndiff --git a/plone/releaser/pip.py b/plone/releaser/pip.py\nindex 3e41af6..3f1b900 100644\n--- a/plone/releaser/pip.py\n+++ b/plone/releaser/pip.py\n@@ -53,17 +53,25 @@ def __setitem__(self, package_name, new_version):\n         contents = self.path.read_text()\n         if not contents.endswith("\\n"):\n             contents += "\\n"\n+            self.path.write_text(contents)\n \n         newline = f"{package_name}=={new_version}"\n         if package_name not in self:\n             contents += newline + "\\n"\n+            print(f"{self.file_location}: \'{newline}\' added.")\n+            self.path.write_text(contents)\n+            return\n \n         reg = re.compile(\n             rf"^{package_name} ?==.*$",\n             re.MULTILINE,\n         )\n         new_contents = reg.sub(newline, contents)\n-        self.path.write_text(new_contents)\n+        if contents != new_contents:\n+            print(f"{self.file_location}: have set \'{newline}\'.")\n+            self.path.write_text(new_contents)\n+            return\n+        print(f"{self.file_location}: \'{newline}\' already there.")\n \n     def get(self, package_name):\n         return self.__getitem__(package_name)\n@@ -131,6 +139,7 @@ def __setitem__(self, package_name, enabled=True):\n         contents = self.path.read_text()\n         if not contents.endswith("\\n"):\n             contents += "\\n"\n+            self.path.write_text(contents)\n \n         lines = []\n         found_package = False\ndiff --git a/plone/releaser/release.py b/plone/releaser/release.py\nindex 605733d..870ee57 100644\n--- a/plone/releaser/release.py\n+++ b/plone/releaser/release.py\n@@ -178,14 +178,10 @@ def check_pypi_access(data):\n     env_var = "PLONE_RELEASER_CHECK_PYPI_ACCESS"\n     try:\n         if int(os.getenv(env_var, 1)) == 0:\n-            print(\n-                f"{env_var} variable set to zero: not checking pypi release rights."\n-            )\n+            print(f"{env_var} variable set to zero: not checking pypi release rights.")\n             return\n     except (TypeError, ValueError, AttributeError):\n-        print(\n-            f"ERROR: could not parse {env_var} env var. Ignoring it."\n-        )\n+        print(f"ERROR: could not parse {env_var} env var. Ignoring it.")\n \n     section = os.getenv("TWINE_REPOSITORY", "pypi")\n     pypi_user = pypi.PypiConfig().config.get(section, "username")\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-27T00:18:12+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/f3828f04dd7eb74ab8a93ffa0ddacb8e6a99cda5

Actually pass path to _get_constraints.

Files changed:
M plone/releaser/manage.py

b'diff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex 3e9eaa9..c31f519 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -198,7 +198,7 @@ def get_package_version(package_name, path=None):\n \n     If no path is given, we try several paths.\n     """\n-    for constraints in _get_constraints(path=None):\n+    for constraints in _get_constraints(path=path):\n         if package_name not in constraints:\n             print(f"{constraints.file_location}: {package_name} missing.")\n             continue\n@@ -221,7 +221,7 @@ def set_package_version(package_name, new_version, path=None):\n \n     bin/manage set-package-version setuptools "65.7.0; python_version >= \'3.0\'" --path requirements.txt\n     """\n-    for constraints in _get_constraints(path=None):\n+    for constraints in _get_constraints(path=path):\n         if package_name not in constraints:\n             if path is None:\n                 print(f"{constraints.file_location}: {package_name} missing.")\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-27T00:36:09+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/586c280be39d2b66ee6a3b5216a30ba79559833c

buildout: factor out update_contents function.

Use this for both updating versions.cfg and checkouts.cfg.
The regexp in versions.cfg was not working well when the case did not match.
We should use this function for both buildout and pip/mxdev.

Files changed:
M plone/releaser/buildout.py

b'diff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex 5de996f..5af16e0 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -13,6 +13,65 @@\n )\n \n \n+def update_contents(contents, line_check, newline, filename, stop_check=None):\n+    """Update contents to have a new line if needed.\n+\n+    * contents is some file contents\n+    * line_check is a function we call to check if a line matches.\n+    * newline is the line with which we replace the matched line.\n+      This can be None to signal that the old line should be removed\n+    * filename is used for reporting.\n+    * stop_check is an optional function we call to check if we should stop\n+      trying to match.\n+\n+    Returns the new contents.\n+    """\n+    lines = []\n+    found = False\n+    content_lines = contents.splitlines()\n+    while content_lines:\n+        line = content_lines.pop(0)\n+        line = line.rstrip()\n+        if stop_check is not None and stop_check(line):\n+            # Put this line back.  We will handle this line and the other\n+            # remaining lines outside of this loop.\n+            content_lines.insert(0, line)\n+            break\n+        if not line_check(line):\n+            lines.append(line)\n+            continue\n+        # We have a match.\n+        if found:\n+            # This is a duplicate, ignore the line.\n+            continue\n+        found = True\n+        # Include this line only if we want it enabled.\n+        if newline is None:\n+            print(f"{filename}: \'{line}\' removed.")\n+        elif line == newline:\n+            lines.append(line)\n+            print(f"{filename}: \'{newline}\' already there.")\n+        else:\n+            lines.append(newline)\n+            print(f"{filename}: have set \'{newline}\'.")\n+\n+    if not found:\n+        if newline is None:\n+            print(f"{filename}: line not found.")\n+        else:\n+            if not lines[-1]:\n+                # Insert before this last empty line.\n+                lines.insert(-1, newline)\n+            else:\n+                lines.append(newline)\n+            print(f"{filename}: \'{newline}\' added.")\n+\n+    if content_lines:\n+        lines.extend(content_lines)\n+\n+    return "\\n".join(lines) + "\\n"\n+\n+\n class Source:\n     def __init__(self, protocol=None, url=None, push_url=None, branch=None):\n         self.protocol = protocol\n@@ -86,28 +145,36 @@ def __getitem__(self, package_name):\n         raise KeyError\n \n     def __setitem__(self, package_name, new_version):\n-        versionstxt = self.path.read_text()\n-        if not versionstxt.endswith("\\n"):\n-            versionstxt += "\\n"\n-            self.path.write_text(versionstxt)\n+        contents = self.path.read_text()\n+        if not contents.endswith("\\n"):\n+            # Make sure the file ends with a newline.\n+            contents += "\\n"\n+            self.path.write_text(contents)\n \n         newline = f"{package_name} = {new_version}"\n-        if package_name not in self:\n-            versionstxt += newline\n-            print(f"{self.file_location}: \'{newline}\' added.")\n-            self.path.write_text(versionstxt)\n-            return\n-\n-        reg = re.compile(\n-            rf"(^{package_name}[\\s\\=]+)[0-9\\.abrc]+(.post\\d+)?(.dev\\d+)?",\n-            re.MULTILINE,\n+        # if package_name not in self:\n+        #     contents += newline + "\\n"\n+        #     print(f"{self.file_location}: \'{newline}\' added.")\n+        #     self.path.write_text(contents)\n+        #     return\n+\n+        line_reg = re.compile(rf"^{package_name.lower()} *=.*")\n+\n+        def line_check(line):\n+            # Look for the \'package name = version\' on a line of its own,\n+            # no whitespace in front.  Maybe whitespace in between.\n+            return line_reg.match(line)\n+\n+        def stop_check(line):\n+            # If we see this line, we should stop trying to match.\n+            return line.startswith("[versionannotations]") or line.startswith("[versions:")\n+\n+        # set version in contents.\n+        new_contents = update_contents(\n+            contents, line_check, newline, self.file_location, stop_check=stop_check\n         )\n-        newVersionsTxt = reg.sub(rf"\\g<1>{new_version}", versionstxt)\n-        if versionstxt != newVersionsTxt:\n-            print(f"{self.file_location}: have set \'{newline}\'.")\n-            self.path.write_text(newVersionsTxt)\n-            return\n-        print(f"{self.file_location}: \'{newline}\' already there.")\n+        if contents != new_contents:\n+            self.path.write_text(new_contents)\n \n     def get(self, package_name):\n         return self.__getitem__(package_name)\n@@ -173,44 +240,24 @@ def __contains__(self, package_name):\n         return package_name.lower() in self.data\n \n     def __setitem__(self, package_name, enabled=True):\n-        checkoutstxt = self.path.read_text()\n-        if not checkoutstxt.endswith("\\n"):\n+        contents = self.path.read_text()\n+        if not contents.endswith("\\n"):\n             # Make sure the file ends with a newline.\n-            checkoutstxt += "\\n"\n-            self.path.write_text(checkoutstxt)\n-\n-        # Look for the package name on a line of its own,\n-        # with likely whitespace in front.\n-        # Regexp is failing we while trying to use re.IGNORECASE,\n-        # so let\'s do it line by line.\n-        # reg = re.compile(rf"^[\\s]*{package_name}\\n", re.MULTILINE | re.IGNORECASE)\n-        lines = []\n-        found = False\n-        for line in checkoutstxt.splitlines():\n-            if line.strip().lower() != package_name.lower():\n-                lines.append(line)\n-                continue\n-            # We have a match.\n-            if found:\n-                # This is a duplicate, ignore the line.\n-                continue\n-            found = True\n-            # Include this line only if we want it enabled.\n-            if enabled:\n-                lines.append(line)\n-                print(f"{self.file_location}: {package_name} already in checkouts.")\n-            else:\n-                print(f"{self.file_location}: {package_name} removed from checkouts.")\n-        if not found:\n-            if enabled:\n-                lines.append(f"    {package_name}")\n-                print(f"{self.file_location}: {package_name} added to checkouts.")\n-            else:\n-                print(f"{self.file_location}: {package_name} not in checkouts.")\n-\n-        newCheckoutsTxt = "\\n".join(lines) + "\\n"\n-        if checkoutstxt != newCheckoutsTxt:\n-            self.path.write_text(newCheckoutsTxt)\n+            contents += "\\n"\n+            self.path.write_text(contents)\n+\n+        def line_check(line):\n+            # Look for the package name on a line of its own,\n+            # with likely whitespace in front.\n+            return line.strip().lower() == package_name.lower()\n+\n+        # add or remove the package name from the contents.\n+        newline = f"    {package_name}" if enabled else None\n+        new_contents = update_contents(\n+            contents, line_check, newline, self.file_location\n+        )\n+        if contents != new_contents:\n+            self.path.write_text(new_contents)\n \n     def __delitem__(self, package_name):\n         return self.__setitem__(package_name, False)\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-27T11:17:09+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/54b73892f02e00b69dbe59cbe9e14a8cbfa46c9d

Moved update_contents function to new utils.py and add tests.

I want to use pytest.  For now you should just `pipx install pytest` and run `pytest`.
Or `pytest -W ignore` to silence warnings, like for namespace packages.

Files changed:
A plone/releaser/tests/__init__.py
A plone/releaser/tests/input/versions.cfg
A plone/releaser/tests/test_utils.py
A plone/releaser/utils.py
M plone/releaser/buildout.py

b'diff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex 5af16e0..03b58da 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -1,3 +1,4 @@\n+from .utils import update_contents\n from collections import OrderedDict\n from collections import UserDict\n from configparser import ConfigParser\n@@ -13,65 +14,6 @@\n )\n \n \n-def update_contents(contents, line_check, newline, filename, stop_check=None):\n-    """Update contents to have a new line if needed.\n-\n-    * contents is some file contents\n-    * line_check is a function we call to check if a line matches.\n-    * newline is the line with which we replace the matched line.\n-      This can be None to signal that the old line should be removed\n-    * filename is used for reporting.\n-    * stop_check is an optional function we call to check if we should stop\n-      trying to match.\n-\n-    Returns the new contents.\n-    """\n-    lines = []\n-    found = False\n-    content_lines = contents.splitlines()\n-    while content_lines:\n-        line = content_lines.pop(0)\n-        line = line.rstrip()\n-        if stop_check is not None and stop_check(line):\n-            # Put this line back.  We will handle this line and the other\n-            # remaining lines outside of this loop.\n-            content_lines.insert(0, line)\n-            break\n-        if not line_check(line):\n-            lines.append(line)\n-            continue\n-        # We have a match.\n-        if found:\n-            # This is a duplicate, ignore the line.\n-            continue\n-        found = True\n-        # Include this line only if we want it enabled.\n-        if newline is None:\n-            print(f"{filename}: \'{line}\' removed.")\n-        elif line == newline:\n-            lines.append(line)\n-            print(f"{filename}: \'{newline}\' already there.")\n-        else:\n-            lines.append(newline)\n-            print(f"{filename}: have set \'{newline}\'.")\n-\n-    if not found:\n-        if newline is None:\n-            print(f"{filename}: line not found.")\n-        else:\n-            if not lines[-1]:\n-                # Insert before this last empty line.\n-                lines.insert(-1, newline)\n-            else:\n-                lines.append(newline)\n-            print(f"{filename}: \'{newline}\' added.")\n-\n-    if content_lines:\n-        lines.extend(content_lines)\n-\n-    return "\\n".join(lines) + "\\n"\n-\n-\n class Source:\n     def __init__(self, protocol=None, url=None, push_url=None, branch=None):\n         self.protocol = protocol\n@@ -167,7 +109,9 @@ def line_check(line):\n \n         def stop_check(line):\n             # If we see this line, we should stop trying to match.\n-            return line.startswith("[versionannotations]") or line.startswith("[versions:")\n+            return line.startswith("[versionannotations]") or line.startswith(\n+                "[versions:"\n+            )\n \n         # set version in contents.\n         new_contents = update_contents(\ndiff --git a/plone/releaser/tests/__init__.py b/plone/releaser/tests/__init__.py\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/plone/releaser/tests/input/versions.cfg b/plone/releaser/tests/input/versions.cfg\nnew file mode 100644\nindex 0000000..6aa318f\n--- /dev/null\n+++ b/plone/releaser/tests/input/versions.cfg\n@@ -0,0 +1,18 @@\n+[buildout]\n+# We should not touch this.\n+extends = https://zopefoundation.github.io/Zope/releases/5.8.3/versions.cfg\n+\n+[versions]\n+# comment = 1.0\n+annotated = 1.0\n+duplicate = 1.0\n+duplicate = 1.0\n+package = 1.0\n+pyspecific = 1.0\n+\n+[versions:python312]\n+pyspecific = 2.0\n+\n+[versionannotations]\n+annotated =\n+    annotated = 1.1 conflicts with package = 1.1\ndiff --git a/plone/releaser/tests/test_utils.py b/plone/releaser/tests/test_utils.py\nnew file mode 100644\nindex 0000000..0b27907\n--- /dev/null\n+++ b/plone/releaser/tests/test_utils.py\n@@ -0,0 +1,64 @@\n+from plone.releaser.utils import update_contents\n+\n+import pathlib\n+\n+\n+TESTS_DIR = pathlib.Path(__file__).parent\n+INPUT_DIR = TESTS_DIR / "input"\n+# Sample buildout versions.cfg\n+VERSIONS = (INPUT_DIR / "versions.cfg").read_text()\n+\n+\n+def test_update_contents_empty():\n+    assert update_contents("\\n", lambda x: True, "", "") == "\\n"\n+\n+\n+def test_update_contents_newline_at_end():\n+    assert update_contents("", lambda x: True, "", "") == "\\n"\n+\n+\n+def test_update_contents_versions_match():\n+    def line_check(line):\n+        return line.startswith("package =")\n+\n+    result = update_contents(VERSIONS, line_check, "package = 2.0", "")\n+    assert "package = 2.0" in result\n+    assert "package = 1.0" not in result\n+\n+\n+def test_update_contents_versions_add_at_end():\n+    def line_check(line):\n+        return line.startswith("new =")\n+\n+    result = update_contents(VERSIONS, line_check, "new = 2.0", "")\n+    assert "new = 2.0" in result\n+    assert "new = 2.0" == result.splitlines()[-1]\n+\n+\n+def test_update_contents_versions_add_before_markers():\n+    def line_check(line):\n+        return line.startswith("new =")\n+\n+    def stop_check(line):\n+        # If we see this line, we should stop trying to match.\n+        return line.startswith("[versions:")\n+\n+    result = update_contents(\n+        VERSIONS, line_check, "new = 2.0", "", stop_check=stop_check\n+    )\n+    assert "new = 2.0" in result\n+    assert result.index("new = 2.0") < result.index("[versions:")\n+    lines = result.splitlines()\n+    new_index = lines.index("new = 2.0")\n+    # We have left a blank line.\n+    assert lines[new_index + 1] == ""\n+    assert lines[new_index + 2] == "[versions:python312]"\n+\n+\n+def test_update_contents_versions_removes_duplicates():\n+    def line_check(line):\n+        return line.startswith("duplicate =")\n+\n+    result = update_contents(VERSIONS, line_check, "duplicate = 2.0", "")\n+    assert "duplicate = 2.0" in result\n+    assert result.count("duplicate =") == 1\ndiff --git a/plone/releaser/utils.py b/plone/releaser/utils.py\nnew file mode 100644\nindex 0000000..432d943\n--- /dev/null\n+++ b/plone/releaser/utils.py\n@@ -0,0 +1,57 @@\n+def update_contents(contents, line_check, newline, filename, stop_check=None):\n+    """Update contents to have a new line if needed.\n+\n+    * contents is some file contents\n+    * line_check is a function we call to check if a line matches.\n+    * newline is the line with which we replace the matched line.\n+      This can be None to signal that the old line should be removed\n+    * filename is used for reporting.\n+    * stop_check is an optional function we call to check if we should stop\n+      trying to match.\n+\n+    Returns the new contents.\n+    """\n+    lines = []\n+    found = False\n+    content_lines = contents.splitlines()\n+    while content_lines:\n+        line = content_lines.pop(0)\n+        line = line.rstrip()\n+        if stop_check is not None and stop_check(line):\n+            # Put this line back.  We will handle this line and the other\n+            # remaining lines outside of this loop.\n+            content_lines.insert(0, line)\n+            break\n+        if not line_check(line):\n+            lines.append(line)\n+            continue\n+        # We have a match.\n+        if found:\n+            # This is a duplicate, ignore the line.\n+            continue\n+        found = True\n+        # Include this line only if we want it enabled.\n+        if newline is None:\n+            print(f"{filename}: \'{line}\' removed.")\n+        elif line == newline:\n+            lines.append(line)\n+            print(f"{filename}: \'{newline}\' already there.")\n+        else:\n+            lines.append(newline)\n+            print(f"{filename}: have set \'{newline}\'.")\n+\n+    if not found:\n+        if newline is None:\n+            print(f"{filename}: line not found.")\n+        else:\n+            if lines and not lines[-1]:\n+                # Insert before this last empty line.\n+                lines.insert(-1, newline)\n+            else:\n+                lines.append(newline)\n+            print(f"{filename}: \'{newline}\' added.")\n+\n+    if content_lines:\n+        lines.extend(content_lines)\n+\n+    return "\\n".join(lines) + "\\n"\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-27T11:27:56+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/3f470100b735a43a53e7c41320db07e5e08959a4

Use pytest capsys fixture to capture stdout in some tests.

Files changed:
M plone/releaser/tests/test_utils.py

b'diff --git a/plone/releaser/tests/test_utils.py b/plone/releaser/tests/test_utils.py\nindex 0b27907..0a8927e 100644\n--- a/plone/releaser/tests/test_utils.py\n+++ b/plone/releaser/tests/test_utils.py\n@@ -17,22 +17,26 @@ def test_update_contents_newline_at_end():\n     assert update_contents("", lambda x: True, "", "") == "\\n"\n \n \n-def test_update_contents_versions_match():\n+def test_update_contents_versions_match(capsys):\n     def line_check(line):\n         return line.startswith("package =")\n \n-    result = update_contents(VERSIONS, line_check, "package = 2.0", "")\n+    result = update_contents(VERSIONS, line_check, "package = 2.0", "file")\n     assert "package = 2.0" in result\n     assert "package = 1.0" not in result\n+    captured = capsys.readouterr()\n+    assert captured.out.strip() == "file: have set \'package = 2.0\'."\n \n \n-def test_update_contents_versions_add_at_end():\n+def test_update_contents_versions_add_at_end(capsys):\n     def line_check(line):\n         return line.startswith("new =")\n \n-    result = update_contents(VERSIONS, line_check, "new = 2.0", "")\n+    result = update_contents(VERSIONS, line_check, "new = 2.0", "file")\n     assert "new = 2.0" in result\n     assert "new = 2.0" == result.splitlines()[-1]\n+    captured = capsys.readouterr()\n+    assert captured.out.strip() == "file: \'new = 2.0\' added."\n \n \n def test_update_contents_versions_add_before_markers():\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-27T11:34:13+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/9d4422680a13c40d3f6194dd2f21f1f773b0e93b

tox.ini: add test env

Files changed:
M tox.ini

b'diff --git a/tox.ini b/tox.ini\nindex 2678f96..c8197fa 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -4,6 +4,7 @@\n envlist =\n     format\n     lint\n+    test\n \n [testenv]\n py_files = git ls-files "*.py"\n@@ -62,3 +63,14 @@ deps =\n     -c lint-requirements.txt\n commands =\n     sh -c \'pipdeptree --exclude setuptools,pipdeptree,wheel --graph-output svg > dependencies.svg\'\n+\n+[testenv:test]\n+description = run the distribution tests\n+use_develop = true\n+skip_install = false\n+constrain_package_deps = true\n+deps =\n+    pytest\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    pytest\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-27T11:37:39+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/aae41b3d7d7781333a666146a7a5b42c100ece10

Fixed problems reported by tox format/lint.

It's an old setup, but let's not touch too many files in this already big PR.

Files changed:
M MANIFEST.in
M plone/releaser/buildout.py
M plone/releaser/manage.py

b'diff --git a/MANIFEST.in b/MANIFEST.in\nindex 12cb105..b8ebfe4 100644\n--- a/MANIFEST.in\n+++ b/MANIFEST.in\n@@ -2,5 +2,7 @@ include *.py\n include *.rst\n include buildout.cfg\n include pyproject.toml\n+graft plone\n recursive-exclude news *\n exclude news\n+global-exclude *.pyc\ndiff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex 03b58da..b438052 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -4,8 +4,8 @@\n from configparser import ConfigParser\n from configparser import ExtendedInterpolation\n \n-import pathlib\n import os\n+import pathlib\n import re\n \n \ndiff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex c31f519..c62929d 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -194,7 +194,7 @@ def _get_constraints(path=None):\n \n \n def get_package_version(package_name, path=None):\n-    """Get package version fron constraints/versions file.\n+    """Get package version from constraints/versions file.\n \n     If no path is given, we try several paths.\n     """\n@@ -213,7 +213,7 @@ def set_package_version(package_name, new_version, path=None):\n     If the package is not pinned yet, we add it.\n \n     If no path is given, we try several paths and set the version in all of them,\n-    bu only if the package is already there: we do not want to add one package\n+    but only if the package is already there: we do not want to add one package\n     in three versions*.cfg files.\n \n     If you want it really fancy you can also add identifiers,\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-27T11:42:06+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/ac1ee4b5df17ed632c9fe717b7f4a1cfc2cdaf11

Add shortened version of .github/workflows/meta.yml.

Only runs the tox test env for now.  We can do the rest later when we reconfigure the package.

Files changed:
A .github/workflows/meta.yml

b'diff --git a/.github/workflows/meta.yml b/.github/workflows/meta.yml\nnew file mode 100644\nindex 0000000..43e3a6f\n--- /dev/null\n+++ b/.github/workflows/meta.yml\n@@ -0,0 +1,18 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+# See the inline comments on how to expand/tweak this configuration file\n+name: Meta\n+on:\n+  push:\n+    branches:\n+      - master\n+      - main\n+  pull_request:\n+    branches:\n+      - master\n+      - main\n+  workflow_dispatch:\n+\n+jobs:\n+  test:\n+    uses: plone/meta/.github/workflows/test.yml@master\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-27T11:53:43+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/86ac5f57ea553e8bef7769189dfa50bccbf5c300

Use utils.update_contents for pip constraints as well.

For mxdev.ini it seems not useful yet, as we need to remove 'use = true', which may be in this file a lot of times.
It may be possible, but would need some more changes in the function.

Files changed:
M plone/releaser/buildout.py
M plone/releaser/pip.py

b'diff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex b438052..cc56327 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -94,12 +94,6 @@ def __setitem__(self, package_name, new_version):\n             self.path.write_text(contents)\n \n         newline = f"{package_name} = {new_version}"\n-        # if package_name not in self:\n-        #     contents += newline + "\\n"\n-        #     print(f"{self.file_location}: \'{newline}\' added.")\n-        #     self.path.write_text(contents)\n-        #     return\n-\n         line_reg = re.compile(rf"^{package_name.lower()} *=.*")\n \n         def line_check(line):\ndiff --git a/plone/releaser/pip.py b/plone/releaser/pip.py\nindex 3f1b900..08f1962 100644\n--- a/plone/releaser/pip.py\n+++ b/plone/releaser/pip.py\n@@ -1,3 +1,4 @@\n+from .utils import update_contents\n from collections import UserDict\n from configparser import ConfigParser\n from configparser import ExtendedInterpolation\n@@ -56,22 +57,19 @@ def __setitem__(self, package_name, new_version):\n             self.path.write_text(contents)\n \n         newline = f"{package_name}=={new_version}"\n-        if package_name not in self:\n-            contents += newline + "\\n"\n-            print(f"{self.file_location}: \'{newline}\' added.")\n-            self.path.write_text(contents)\n-            return\n+        line_reg = re.compile(rf"^{package_name.lower()}==.*")\n \n-        reg = re.compile(\n-            rf"^{package_name} ?==.*$",\n-            re.MULTILINE,\n+        def line_check(line):\n+            # Look for \'package name==version\' on a line of its own,\n+            # no whitespace in front.\n+            return line_reg.match(line)\n+\n+        # set version in contents.\n+        new_contents = update_contents(\n+            contents, line_check, newline, self.file_location\n         )\n-        new_contents = reg.sub(newline, contents)\n         if contents != new_contents:\n-            print(f"{self.file_location}: have set \'{newline}\'.")\n             self.path.write_text(new_contents)\n-            return\n-        print(f"{self.file_location}: \'{newline}\' already there.")\n \n     def get(self, package_name):\n         return self.__getitem__(package_name)\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-27T21:46:35+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/10f778d54ec37b22c00bf59c98ff0a7ceba17d69

Start adding tests for buildout.VersionsFile.

Files changed:
A plone/releaser/tests/test_buildout.py
M plone/releaser/buildout.py
M plone/releaser/tests/input/versions.cfg
M setup.py

b'diff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex cc56327..f724821 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -114,8 +114,10 @@ def stop_check(line):\n         if contents != new_contents:\n             self.path.write_text(new_contents)\n \n-    def get(self, package_name):\n-        return self.__getitem__(package_name)\n+    def get(self, package_name, default=None):\n+        if package_name in self:\n+            return self.__getitem__(package_name)\n+        return default\n \n     def set(self, package_name, new_version):\n         return self.__setitem__(package_name, new_version)\ndiff --git a/plone/releaser/tests/input/versions.cfg b/plone/releaser/tests/input/versions.cfg\nindex 6aa318f..15b43b0 100644\n--- a/plone/releaser/tests/input/versions.cfg\n+++ b/plone/releaser/tests/input/versions.cfg\n@@ -5,10 +5,13 @@ extends = https://zopefoundation.github.io/Zope/releases/5.8.3/versions.cfg\n [versions]\n # comment = 1.0\n annotated = 1.0\n+CamelCase = 1.0\n duplicate = 1.0\n duplicate = 1.0\n+lowercase = 1.0\n package = 1.0\n pyspecific = 1.0\n+UPPERCASE = 1.0\n \n [versions:python312]\n pyspecific = 2.0\ndiff --git a/plone/releaser/tests/test_buildout.py b/plone/releaser/tests/test_buildout.py\nnew file mode 100644\nindex 0000000..9dd371a\n--- /dev/null\n+++ b/plone/releaser/tests/test_buildout.py\n@@ -0,0 +1,61 @@\n+from plone.releaser.buildout import VersionsFile\n+\n+import pathlib\n+import pytest\n+\n+\n+TESTS_DIR = pathlib.Path(__file__).parent\n+INPUT_DIR = TESTS_DIR / "input"\n+VERSIONS_FILE = INPUT_DIR / "versions.cfg"\n+\n+\n+def test_versions_file_versions():\n+    vf = VersionsFile(VERSIONS_FILE)\n+    # All versions are reported lowercased.\n+    assert vf.versions == {\n+        "annotated": "1.0",\n+        "camelcase": "1.0",\n+        "duplicate": "1.0",\n+        "lowercase": "1.0",\n+        "package": "1.0",\n+        "pyspecific": "2.0",\n+        "uppercase": "1.0",\n+    }\n+\n+\n+def test_versions_file_contains():\n+    vf = VersionsFile(VERSIONS_FILE)\n+    assert "package" in vf\n+    assert "nope" not in vf\n+    # We compare case insensitively.\n+    # Let\'s try all combinations\n+    assert "camelcase" in vf\n+    assert "CamelCase" in vf\n+    assert "CAMELCASE" in vf\n+    assert "lowercase" in vf\n+    assert "LowerCase" in vf\n+    assert "LOWERCASE" in vf\n+    assert "uppercase" in vf\n+    assert "UpperCase" in vf\n+    assert "UPPERCASE" in vf\n+\n+\n+def test_versions_file_get():\n+    vf = VersionsFile(VERSIONS_FILE)\n+    assert vf.get("package") == "1.0"\n+    assert vf["package"] == "1.0"\n+    with pytest.raises(KeyError):\n+        vf["nope"]\n+    assert vf.get("nope") is None\n+    assert vf.get("nope", "hello") == "hello"\n+    # We compare case insensitively.\n+    # Let\'s try all combinations\n+    assert vf["camelcase"] == "1.0"\n+    assert vf["CamelCase"] == "1.0"\n+    assert vf["CAMELCASE"] == "1.0"\n+    assert vf["lowercase"] == "1.0"\n+    assert vf["LowerCase"] == "1.0"\n+    assert vf["LOWERCASE"] == "1.0"\n+    assert vf["uppercase"] == "1.0"\n+    assert vf["UpperCase"] == "1.0"\n+    assert vf["UPPERCASE"] == "1.0"\ndiff --git a/setup.py b/setup.py\nindex 67b979a..fec104b 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -47,6 +47,9 @@\n         "zestreleaser.towncrier>=1.3.0",\n         "docutils",\n     ],\n+    extras_requires={\n+        "test": ["pytest"],\n+    },\n     entry_points={\n         "console_scripts": ["manage = plone.releaser.manage:manage"],\n         "zest.releaser.prereleaser.before": [\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-27T23:23:46+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/341ac902a9e4ef6e651e8d9d2b359197c65e635e

Test buildout.VersionsFile.set_version.

Files changed:
M plone/releaser/tests/test_buildout.py

b'diff --git a/plone/releaser/tests/test_buildout.py b/plone/releaser/tests/test_buildout.py\nindex 9dd371a..cda2e27 100644\n--- a/plone/releaser/tests/test_buildout.py\n+++ b/plone/releaser/tests/test_buildout.py\n@@ -2,6 +2,7 @@\n \n import pathlib\n import pytest\n+import shutil\n \n \n TESTS_DIR = pathlib.Path(__file__).parent\n@@ -59,3 +60,14 @@ def test_versions_file_get():\n     assert vf["uppercase"] == "1.0"\n     assert vf["UpperCase"] == "1.0"\n     assert vf["UPPERCASE"] == "1.0"\n+\n+\n+def test_versions_file_set(tmp_path):\n+    # When we set a version, the file changes, so we work on a copy.\n+    shutil.copyfile(VERSIONS_FILE, tmp_path / "versions.cfg")\n+    vf = VersionsFile(tmp_path / "versions.cfg")\n+    assert vf.get("package") == "1.0"\n+    vf.set("package", "2.0")\n+    assert vf.get("package") == "2.0"\n+    vf["package"] = "3.0"\n+    assert vf.get("package") == "3.0"\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-28T09:38:14+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/94fc41776abee0e90c2e0b8c03f60e72b05af52b

tests: read versionsfile fresh after setting version.

Files changed:
M plone/releaser/tests/test_buildout.py

b'diff --git a/plone/releaser/tests/test_buildout.py b/plone/releaser/tests/test_buildout.py\nindex cda2e27..8172157 100644\n--- a/plone/releaser/tests/test_buildout.py\n+++ b/plone/releaser/tests/test_buildout.py\n@@ -62,12 +62,16 @@ def test_versions_file_get():\n     assert vf["UPPERCASE"] == "1.0"\n \n \n-def test_versions_file_set(tmp_path):\n+def test_versions_file_set_normal(tmp_path):\n     # When we set a version, the file changes, so we work on a copy.\n-    shutil.copyfile(VERSIONS_FILE, tmp_path / "versions.cfg")\n-    vf = VersionsFile(tmp_path / "versions.cfg")\n+    copy_path = tmp_path / "versions.cfg"\n+    shutil.copyfile(VERSIONS_FILE, copy_path)\n+    vf = VersionsFile(copy_path)\n     assert vf.get("package") == "1.0"\n     vf.set("package", "2.0")\n+    # Let\'s read it fresh, for good measure.\n+    vf = VersionsFile(copy_path)\n     assert vf.get("package") == "2.0"\n     vf["package"] = "3.0"\n+    vf = VersionsFile(copy_path)\n     assert vf.get("package") == "3.0"\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-28T12:28:31+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/0b66c71b3e65addb90ed361bf79c46fc108fdd28

buildout.VersionsFile: do not report or change versions with markers.

A section `[versions:pythonX]` will be ignored.

Files changed:
M plone/releaser/buildout.py
M plone/releaser/tests/test_buildout.py

b'diff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex f724821..0e3742a 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -60,9 +60,17 @@ def versions(self):\n         We use strict=False to avoid a DuplicateOptionError.\n         This happens in coredev 4.3 because we pin \'babel\' and \'Babel\'.\n \n-        We need to combine all versions sections, like these:\n+        We used to combine all versions sections, like these:\n         [\'versions\', \'versions:python27\']\n-\n+        That fixed https://github.com/plone/plone.releaser/issues/24\n+        and was needed when we had packages like Archetypes which were only for\n+        Python 2.  With Plone 6 I don\'t think we will need this.  We can still\n+        have Python-version-specific sections, but that would be for external\n+        packages.  I don\'t think we will be releasing Plone packages that are\n+        for specific Python versions.  Or if we do, it would be overkill for\n+        plone.releaser to support such a corner case.\n+\n+        So we do not want to report or edit anything except the versions section.\n         """\n         config = ConfigParser(interpolation=ExtendedInterpolation(), strict=False)\n         with open(self.file_location) as f:\n@@ -72,7 +80,7 @@ def versions(self):\n             config["buildout"]["directory"] = os.getcwd()\n         versions = {}\n         for section in config.sections():\n-            if "versions" in section.split(":"):\n+            if section == "versions":\n                 for package, version in config[section].items():\n                     # Note: the package names are lower case.\n                     versions[package] = version\ndiff --git a/plone/releaser/tests/test_buildout.py b/plone/releaser/tests/test_buildout.py\nindex 8172157..2229930 100644\n--- a/plone/releaser/tests/test_buildout.py\n+++ b/plone/releaser/tests/test_buildout.py\n@@ -19,7 +19,7 @@ def test_versions_file_versions():\n         "duplicate": "1.0",\n         "lowercase": "1.0",\n         "package": "1.0",\n-        "pyspecific": "2.0",\n+        "pyspecific": "1.0",\n         "uppercase": "1.0",\n     }\n \n@@ -75,3 +75,18 @@ def test_versions_file_set_normal(tmp_path):\n     vf["package"] = "3.0"\n     vf = VersionsFile(copy_path)\n     assert vf.get("package") == "3.0"\n+\n+\n+def test_versions_file_set_ignore_markers(tmp_path):\n+    # [versions:python312] pins \'pyspecific = 2.0\'.\n+    # We do not report or change this section.\n+    copy_path = tmp_path / "versions.cfg"\n+    shutil.copyfile(VERSIONS_FILE, copy_path)\n+    vf = VersionsFile(copy_path)\n+    assert "pyspecific = 2.0" in copy_path.read_text()\n+    assert vf.get("pyspecific") == "1.0"\n+    vf.set("package", "1.1")\n+    # Let\'s read it fresh, for good measure.\n+    vf = VersionsFile(copy_path)\n+    assert vf.get("package") == "1.1"\n+    assert "pyspecific = 2.0" in copy_path.read_text()\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-28T12:31:50+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/ca620056e765b0f8e2b5480b716ed204b9126609

test that duplicates are removed.

Files changed:
M plone/releaser/tests/test_buildout.py

b'diff --git a/plone/releaser/tests/test_buildout.py b/plone/releaser/tests/test_buildout.py\nindex 2229930..de4b558 100644\n--- a/plone/releaser/tests/test_buildout.py\n+++ b/plone/releaser/tests/test_buildout.py\n@@ -90,3 +90,17 @@ def test_versions_file_set_ignore_markers(tmp_path):\n     vf = VersionsFile(copy_path)\n     assert vf.get("package") == "1.1"\n     assert "pyspecific = 2.0" in copy_path.read_text()\n+\n+\n+def test_versions_file_set_cleanup_duplicates(tmp_path):\n+    copy_path = tmp_path / "versions.cfg"\n+    shutil.copyfile(VERSIONS_FILE, copy_path)\n+    assert copy_path.read_text().count("duplicate = 1.0") == 2\n+    vf = VersionsFile(copy_path)\n+    assert vf.get("duplicate") == "1.0"\n+    vf.set("duplicate", "2.0")\n+    # Let\'s read it fresh, for good measure.\n+    vf = VersionsFile(copy_path)\n+    assert vf.get("duplicate") == "2.0"\n+    assert copy_path.read_text().count("duplicate = 2.0") == 1\n+    assert copy_path.read_text().count("duplicate = 1.0") == 0\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-28T13:03:37+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/866d0d7c7f5637813b3693170e319342e02199d3

pip.ConstraintsFile: do not report or change versions with environment markers.

Same as I just did for buildout.
Added tests for pip.ConstraintsFile.

Files changed:
A plone/releaser/tests/input/constraints.txt
A plone/releaser/tests/test_pip.py
M plone/releaser/manage.py
M plone/releaser/pip.py

b'diff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex c62929d..89e79a9 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -197,6 +197,24 @@ def get_package_version(package_name, path=None):\n     """Get package version from constraints/versions file.\n \n     If no path is given, we try several paths.\n+\n+    Note that versions with environment markers are ignored.\n+    See https://peps.python.org/pep-0496/ explaining them.\n+    The 99.99 percent use case of this part of plone.releaser is to get or set\n+    versions for a Plone package, and after abandoning Python 2 we are unlikely\n+    to need different versions of our core packages for different environments.\n+\n+    So in all the following cases, package version 1.0 is reported:\n+\n+    package==1.0\n+    package==2.0; python_version=="3.11"\n+\n+    [versions]\n+    package = 1.0\n+    [versions:python311]\n+    package = 2.0\n+    [versions:python_version=="3.12"]\n+    package = 3.0\n     """\n     for constraints in _get_constraints(path=path):\n         if package_name not in constraints:\n@@ -216,10 +234,8 @@ def set_package_version(package_name, new_version, path=None):\n     but only if the package is already there: we do not want to add one package\n     in three versions*.cfg files.\n \n-    If you want it really fancy you can also add identifiers,\n-    but that only gives valid results for pip files:\n-\n-    bin/manage set-package-version setuptools "65.7.0; python_version >= \'3.0\'" --path requirements.txt\n+    If you want to add environment markers, like "python_version >= \'3.0\'",\n+    please just edit the files yourself.\n     """\n     for constraints in _get_constraints(path=path):\n         if package_name not in constraints:\ndiff --git a/plone/releaser/pip.py b/plone/releaser/pip.py\nindex 08f1962..7bae302 100644\n--- a/plone/releaser/pip.py\n+++ b/plone/releaser/pip.py\n@@ -35,10 +35,20 @@ def constraints(self):\n                 continue\n             package = line.split("==")[0].strip().lower()\n             version = line.split("==")[1].strip()\n-            # The line could also contain identifiers like this:\n+            # The line could also contain environment markers like this:\n             # "; python_version >= \'3.0\'"\n             # But currently I think we really only need the package name,\n             # and not even the version.  Let\'s use the entire rest of the line.\n+            # Actually, for our purposes, we should ignore lines that have such\n+            # markers, just like we do in buildout.py:VersionsFile.\n+            if ";" in version:\n+                continue\n+            if package in constraints:\n+                if constraints[package] != version:\n+                    print(\n+                        f"ERROR: {package} is in {self.file_location} with two "\n+                        f"constraints: \'{contraints[package]}\' and \'{version}\'.")\n+                continue\n             constraints[package] = version\n         return constraints\n \n@@ -71,8 +81,10 @@ def line_check(line):\n         if contents != new_contents:\n             self.path.write_text(new_contents)\n \n-    def get(self, package_name):\n-        return self.__getitem__(package_name)\n+    def get(self, package_name, default=None):\n+        if package_name in self:\n+            return self.__getitem__(package_name)\n+        return default\n \n     def set(self, package_name, new_version):\n         return self.__setitem__(package_name, new_version)\ndiff --git a/plone/releaser/tests/input/constraints.txt b/plone/releaser/tests/input/constraints.txt\nnew file mode 100644\nindex 0000000..6c401aa\n--- /dev/null\n+++ b/plone/releaser/tests/input/constraints.txt\n@@ -0,0 +1,12 @@\n+# We should not touch this.\n+-c https://zopefoundation.github.io/Zope/releases/5.8.3/constraints.txt\n+# comment==1.0\n+annotated==1.0\n+CamelCase==1.0\n+duplicate==1.0\n+duplicate==1.0\n+lowercase==1.0\n+package==1.0\n+pyspecific==1.0\n+pyspecific==2.0; python_version=="3.12"\n+UPPERCASE==1.0\ndiff --git a/plone/releaser/tests/test_pip.py b/plone/releaser/tests/test_pip.py\nnew file mode 100644\nindex 0000000..775ba70\n--- /dev/null\n+++ b/plone/releaser/tests/test_pip.py\n@@ -0,0 +1,106 @@\n+from plone.releaser.pip import ConstraintsFile\n+\n+import pathlib\n+import pytest\n+import shutil\n+\n+\n+TESTS_DIR = pathlib.Path(__file__).parent\n+INPUT_DIR = TESTS_DIR / "input"\n+CONSTRAINTS_FILE = INPUT_DIR / "constraints.txt"\n+\n+\n+def test_constraints_file_constraints():\n+    cf = ConstraintsFile(CONSTRAINTS_FILE)\n+    # All constraints are reported lowercased.\n+    assert cf.constraints == {\n+        "annotated": "1.0",\n+        "camelcase": "1.0",\n+        "duplicate": "1.0",\n+        "lowercase": "1.0",\n+        "package": "1.0",\n+        "pyspecific": "1.0",\n+        "uppercase": "1.0",\n+    }\n+\n+\n+def test_constraints_file_contains():\n+    cf = ConstraintsFile(CONSTRAINTS_FILE)\n+    assert "package" in cf\n+    assert "nope" not in cf\n+    # We compare case insensitively.\n+    # Let\'s try all combinations\n+    assert "camelcase" in cf\n+    assert "CamelCase" in cf\n+    assert "CAMELCASE" in cf\n+    assert "lowercase" in cf\n+    assert "LowerCase" in cf\n+    assert "LOWERCASE" in cf\n+    assert "uppercase" in cf\n+    assert "UpperCase" in cf\n+    assert "UPPERCASE" in cf\n+\n+\n+def test_constraints_file_get():\n+    cf = ConstraintsFile(CONSTRAINTS_FILE)\n+    assert cf.get("package") == "1.0"\n+    assert cf["package"] == "1.0"\n+    with pytest.raises(KeyError):\n+        cf["nope"]\n+    assert cf.get("nope") is None\n+    assert cf.get("nope", "hello") == "hello"\n+    # We compare case insensitively.\n+    # Let\'s try all combinations\n+    assert cf["camelcase"] == "1.0"\n+    assert cf["CamelCase"] == "1.0"\n+    assert cf["CAMELCASE"] == "1.0"\n+    assert cf["lowercase"] == "1.0"\n+    assert cf["LowerCase"] == "1.0"\n+    assert cf["LOWERCASE"] == "1.0"\n+    assert cf["uppercase"] == "1.0"\n+    assert cf["UpperCase"] == "1.0"\n+    assert cf["UPPERCASE"] == "1.0"\n+\n+\n+def test_constraints_file_set_normal(tmp_path):\n+    # When we set a version, the file changes, so we work on a copy.\n+    copy_path = tmp_path / "constraints.txt"\n+    shutil.copyfile(CONSTRAINTS_FILE, copy_path)\n+    cf = ConstraintsFile(copy_path)\n+    assert cf.get("package") == "1.0"\n+    cf.set("package", "2.0")\n+    # Let\'s read it fresh, for good measure.\n+    cf = ConstraintsFile(copy_path)\n+    assert cf.get("package") == "2.0"\n+    cf["package"] = "3.0"\n+    cf = ConstraintsFile(copy_path)\n+    assert cf.get("package") == "3.0"\n+\n+\n+def test_constraints_file_set_ignore_markers(tmp_path):\n+    # [constraints:python312] pins \'pyspecific = 2.0\'.\n+    # We do not report or change this section.\n+    copy_path = tmp_path / "constraints.txt"\n+    shutil.copyfile(CONSTRAINTS_FILE, copy_path)\n+    cf = ConstraintsFile(copy_path)\n+    assert "pyspecific==2.0" in copy_path.read_text()\n+    assert cf.get("pyspecific") == "1.0"\n+    cf.set("package", "1.1")\n+    # Let\'s read it fresh, for good measure.\n+    cf = ConstraintsFile(copy_path)\n+    assert cf.get("package") == "1.1"\n+    assert "pyspecific==2.0" in copy_path.read_text()\n+\n+\n+def test_constraints_file_set_cleanup_duplicates(tmp_path):\n+    copy_path = tmp_path / "constraints.txt"\n+    shutil.copyfile(CONSTRAINTS_FILE, copy_path)\n+    assert copy_path.read_text().count("duplicate==1.0") == 2\n+    cf = ConstraintsFile(copy_path)\n+    assert cf.get("duplicate") == "1.0"\n+    cf.set("duplicate", "2.0")\n+    # Let\'s read it fresh, for good measure.\n+    cf = ConstraintsFile(copy_path)\n+    assert cf.get("duplicate") == "2.0"\n+    assert copy_path.read_text().count("duplicate==2.0") == 1\n+    assert copy_path.read_text().count("duplicate==1.0") == 0\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-28T14:30:54+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/23ca00316db068485c3e815ae5efa20cf3821644

Update plone/releaser/tests/test_pip.py

Co-authored-by: Gil Forcada Codinachs &lt;gil.gnome@gmail.com&gt;

Files changed:
M plone/releaser/tests/test_pip.py

b'diff --git a/plone/releaser/tests/test_pip.py b/plone/releaser/tests/test_pip.py\nindex 775ba70..5ca9a7e 100644\n--- a/plone/releaser/tests/test_pip.py\n+++ b/plone/releaser/tests/test_pip.py\n@@ -78,8 +78,8 @@ def test_constraints_file_set_normal(tmp_path):\n \n \n def test_constraints_file_set_ignore_markers(tmp_path):\n-    # [constraints:python312] pins \'pyspecific = 2.0\'.\n-    # We do not report or change this section.\n+    # pyspecific==2.0; python_version=="3.12"\n+    # version pins that have a specific `python_version` are not changed.\n     copy_path = tmp_path / "constraints.txt"\n     shutil.copyfile(CONSTRAINTS_FILE, copy_path)\n     cf = ConstraintsFile(copy_path)\n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-28T14:41:58+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/6ab09d421d577ca5b7d6a3e97d60b149d2ca1b80

Fix ignoring environment markers when setting constraint in pip.

Fixed the tests that tried to test this.

Files changed:
M plone/releaser/pip.py
M plone/releaser/tests/test_buildout.py
M plone/releaser/tests/test_pip.py

b'diff --git a/plone/releaser/pip.py b/plone/releaser/pip.py\nindex 7bae302..9d69501 100644\n--- a/plone/releaser/pip.py\n+++ b/plone/releaser/pip.py\n@@ -67,11 +67,11 @@ def __setitem__(self, package_name, new_version):\n             self.path.write_text(contents)\n \n         newline = f"{package_name}=={new_version}"\n-        line_reg = re.compile(rf"^{package_name.lower()}==.*")\n+        # Look for \'package name==version\' on a line of its own,\n+        # no whitespace, no environment markers.\n+        line_reg = re.compile(rf"^{package_name.lower()}==[^;]*$")\n \n         def line_check(line):\n-            # Look for \'package name==version\' on a line of its own,\n-            # no whitespace in front.\n             return line_reg.match(line)\n \n         # set version in contents.\ndiff --git a/plone/releaser/tests/test_buildout.py b/plone/releaser/tests/test_buildout.py\nindex de4b558..03f4f4e 100644\n--- a/plone/releaser/tests/test_buildout.py\n+++ b/plone/releaser/tests/test_buildout.py\n@@ -85,10 +85,10 @@ def test_versions_file_set_ignore_markers(tmp_path):\n     vf = VersionsFile(copy_path)\n     assert "pyspecific = 2.0" in copy_path.read_text()\n     assert vf.get("pyspecific") == "1.0"\n-    vf.set("package", "1.1")\n+    vf.set("pyspecific", "1.1")\n     # Let\'s read it fresh, for good measure.\n     vf = VersionsFile(copy_path)\n-    assert vf.get("package") == "1.1"\n+    assert vf.get("pyspecific") == "1.1"\n     assert "pyspecific = 2.0" in copy_path.read_text()\n \n \ndiff --git a/plone/releaser/tests/test_pip.py b/plone/releaser/tests/test_pip.py\nindex 5ca9a7e..4ef3d6d 100644\n--- a/plone/releaser/tests/test_pip.py\n+++ b/plone/releaser/tests/test_pip.py\n@@ -85,10 +85,10 @@ def test_constraints_file_set_ignore_markers(tmp_path):\n     cf = ConstraintsFile(copy_path)\n     assert "pyspecific==2.0" in copy_path.read_text()\n     assert cf.get("pyspecific") == "1.0"\n-    cf.set("package", "1.1")\n+    cf.set("pyspecific", "1.1")\n     # Let\'s read it fresh, for good measure.\n     cf = ConstraintsFile(copy_path)\n-    assert cf.get("package") == "1.1"\n+    assert cf.get("pyspecific") == "1.1"\n     assert "pyspecific==2.0" in copy_path.read_text()\n \n \n'

Repository: plone.releaser


Branch: refs/heads/master
Date: 2023-07-28T16:28:04+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.releaser/commit/242b4e553dcf361383d7e105d1049b7980caee36

Merge pull request #54 from plone/maurits-set-versions

Set constraints and checkouts in pip/mxdev files as well

Files changed:
A .github/workflows/meta.yml
A news/52.bugfix
A news/53.feature.1
A news/53.feature.2
A plone/releaser/pip.py
A plone/releaser/tests/__init__.py
A plone/releaser/tests/input/constraints.txt
A plone/releaser/tests/input/versions.cfg
A plone/releaser/tests/test_buildout.py
A plone/releaser/tests/test_pip.py
A plone/releaser/tests/test_utils.py
A plone/releaser/utils.py
M MANIFEST.in
M plone/releaser/buildout.py
M plone/releaser/manage.py
M plone/releaser/package.py
M plone/releaser/release.py
M setup.py
M tox.ini

b'diff --git a/.github/workflows/meta.yml b/.github/workflows/meta.yml\nnew file mode 100644\nindex 0000000..43e3a6f\n--- /dev/null\n+++ b/.github/workflows/meta.yml\n@@ -0,0 +1,18 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+# See the inline comments on how to expand/tweak this configuration file\n+name: Meta\n+on:\n+  push:\n+    branches:\n+      - master\n+      - main\n+  pull_request:\n+    branches:\n+      - master\n+      - main\n+  workflow_dispatch:\n+\n+jobs:\n+  test:\n+    uses: plone/meta/.github/workflows/test.yml@master\ndiff --git a/MANIFEST.in b/MANIFEST.in\nindex 12cb105..b8ebfe4 100644\n--- a/MANIFEST.in\n+++ b/MANIFEST.in\n@@ -2,5 +2,7 @@ include *.py\n include *.rst\n include buildout.cfg\n include pyproject.toml\n+graft plone\n recursive-exclude news *\n exclude news\n+global-exclude *.pyc\ndiff --git a/news/52.bugfix b/news/52.bugfix\nnew file mode 100644\nindex 0000000..549657d\n--- /dev/null\n+++ b/news/52.bugfix\n@@ -0,0 +1,2 @@\n+Check all ``versions*.cfg`` files when updating a pin.\n+[maurits]\ndiff --git a/news/53.feature.1 b/news/53.feature.1\nnew file mode 100644\nindex 0000000..f29a42c\n--- /dev/null\n+++ b/news/53.feature.1\n@@ -0,0 +1,2 @@\n+Enable updating versions in pip constraints files.\n+[maurits]\ndiff --git a/news/53.feature.2 b/news/53.feature.2\nnew file mode 100644\nindex 0000000..f3c5ac7\n--- /dev/null\n+++ b/news/53.feature.2\n@@ -0,0 +1,2 @@\n+Enable updating checkouts in mxdex.ini files.\n+[maurits]\ndiff --git a/plone/releaser/buildout.py b/plone/releaser/buildout.py\nindex 52f7dfd..0e3742a 100644\n--- a/plone/releaser/buildout.py\n+++ b/plone/releaser/buildout.py\n@@ -1,9 +1,11 @@\n+from .utils import update_contents\n from collections import OrderedDict\n from collections import UserDict\n from configparser import ConfigParser\n from configparser import ExtendedInterpolation\n \n import os\n+import pathlib\n import re\n \n \n@@ -49,6 +51,7 @@ def path(self):\n class VersionsFile:\n     def __init__(self, file_location):\n         self.file_location = file_location\n+        self.path = pathlib.Path(self.file_location).resolve()\n \n     @property\n     def versions(self):\n@@ -57,18 +60,27 @@ def versions(self):\n         We use strict=False to avoid a DuplicateOptionError.\n         This happens in coredev 4.3 because we pin \'babel\' and \'Babel\'.\n \n-        We need to combine all versions sections, like these:\n+        We used to combine all versions sections, like these:\n         [\'versions\', \'versions:python27\']\n-\n+        That fixed https://github.com/plone/plone.releaser/issues/24\n+        and was needed when we had packages like Archetypes which were only for\n+        Python 2.  With Plone 6 I don\'t think we will need this.  We can still\n+        have Python-version-specific sections, but that would be for external\n+        packages.  I don\'t think we will be releasing Plone packages that are\n+        for specific Python versions.  Or if we do, it would be overkill for\n+        plone.releaser to support such a corner case.\n+\n+        So we do not want to report or edit anything except the versions section.\n         """\n         config = ConfigParser(interpolation=ExtendedInterpolation(), strict=False)\n         with open(self.file_location) as f:\n             config.read_file(f)\n         # https://github.com/plone/plone.releaser/issues/42\n-        config["buildout"]["directory"] = os.getcwd()\n+        if config.has_section("buildout"):\n+            config["buildout"]["directory"] = os.getcwd()\n         versions = {}\n         for section in config.sections():\n-            if "versions" in section.split(":"):\n+            if section == "versions":\n                 for package, version in config[section].items():\n                     # Note: the package names are lower case.\n                     versions[package] = version\n@@ -83,24 +95,37 @@ def __getitem__(self, package_name):\n         raise KeyError\n \n     def __setitem__(self, package_name, new_version):\n-        path = os.path.join(os.getcwd(), self.file_location)\n-        with open(path) as f:\n-            versionstxt = f.read()\n-\n-        if package_name not in self:\n-            newline = f"{package_name} = {new_version}"\n-            versionstxt += newline\n-\n-        reg = re.compile(\n-            rf"(^{package_name}[\\s\\=]+)[0-9\\.abrc]+(.post\\d+)?(.dev\\d+)?",\n-            re.MULTILINE,\n+        contents = self.path.read_text()\n+        if not contents.endswith("\\n"):\n+            # Make sure the file ends with a newline.\n+            contents += "\\n"\n+            self.path.write_text(contents)\n+\n+        newline = f"{package_name} = {new_version}"\n+        line_reg = re.compile(rf"^{package_name.lower()} *=.*")\n+\n+        def line_check(line):\n+            # Look for the \'package name = version\' on a line of its own,\n+            # no whitespace in front.  Maybe whitespace in between.\n+            return line_reg.match(line)\n+\n+        def stop_check(line):\n+            # If we see this line, we should stop trying to match.\n+            return line.startswith("[versionannotations]") or line.startswith(\n+                "[versions:"\n+            )\n+\n+        # set version in contents.\n+        new_contents = update_contents(\n+            contents, line_check, newline, self.file_location, stop_check=stop_check\n         )\n-        newVersionsTxt = reg.sub(rf"\\g<1>{new_version}", versionstxt)\n-        with open(path, "w") as f:\n-            f.write(newVersionsTxt)\n+        if contents != new_contents:\n+            self.path.write_text(new_contents)\n \n-    def get(self, package_name):\n-        return self.__getitem__(package_name)\n+    def get(self, package_name, default=None):\n+        if package_name in self:\n+            return self.__getitem__(package_name)\n+        return default\n \n     def set(self, package_name, new_version):\n         return self.__setitem__(package_name, new_version)\n@@ -109,6 +134,7 @@ def set(self, package_name, new_version):\n class SourcesFile(UserDict):\n     def __init__(self, file_location):\n         self.file_location = file_location\n+        self.path = pathlib.Path(self.file_location).resolve()\n \n     @property\n     def data(self):\n@@ -143,6 +169,7 @@ def __iter__(self):\n class CheckoutsFile(UserDict):\n     def __init__(self, file_location):\n         self.file_location = file_location\n+        self.path = pathlib.Path(self.file_location).resolve()\n \n     @property\n     def data(self):\n@@ -151,34 +178,34 @@ def data(self):\n             config.read_file(f)\n         config["buildout"]["directory"] = os.getcwd()\n         checkouts = config.get("buildout", "auto-checkout")\n-        checkout_list = checkouts.split("\\n")\n-        return checkout_list\n+        # Map from lower case to actual case, so we can find the package.\n+        mapping = {}\n+        for package in checkouts.splitlines():\n+            mapping[package.lower()] = package\n+        return mapping\n \n     def __contains__(self, package_name):\n-        return package_name in self.data\n+        return package_name.lower() in self.data\n \n     def __setitem__(self, package_name, enabled=True):\n-        path = os.path.join(os.getcwd(), self.file_location)\n-        with open(path) as f:\n-            checkoutstxt = f.read()\n-        with open(path, "w") as f:\n-            if not checkoutstxt.endswith("\\n"):\n-                # Make sure the file ends with a newline.\n-                checkoutstxt += "\\n"\n+        contents = self.path.read_text()\n+        if not contents.endswith("\\n"):\n+            # Make sure the file ends with a newline.\n+            contents += "\\n"\n+            self.path.write_text(contents)\n+\n+        def line_check(line):\n             # Look for the package name on a line of its own,\n             # with likely whitespace in front.\n-            reg = re.compile(rf"^[\\s]*{package_name}\\n", re.MULTILINE)\n-            if enabled:\n-                # We used to look for "# test-only fixes:" here,\n-                # and place the checkout before it.\n-                # But this text is no longer in any current checkouts.cfg.\n-                if not reg.match(checkoutstxt):\n-                    # It is indeed not yet in the checkouts.\n-                    newCheckoutsTxt = checkoutstxt + f"    {package_name}\\n"\n-            else:\n-                # Remove the package name\n-                newCheckoutsTxt = reg.sub("", checkoutstxt)\n-            f.write(newCheckoutsTxt)\n+            return line.strip().lower() == package_name.lower()\n+\n+        # add or remove the package name from the contents.\n+        newline = f"    {package_name}" if enabled else None\n+        new_contents = update_contents(\n+            contents, line_check, newline, self.file_location\n+        )\n+        if contents != new_contents:\n+            self.path.write_text(new_contents)\n \n     def __delitem__(self, package_name):\n         return self.__setitem__(package_name, False)\ndiff --git a/plone/releaser/manage.py b/plone/releaser/manage.py\nindex 8bafc20..89e79a9 100644\n--- a/plone/releaser/manage.py\n+++ b/plone/releaser/manage.py\n@@ -11,8 +11,11 @@\n from plone.releaser.buildout import CheckoutsFile\n from plone.releaser.buildout import VersionsFile\n from plone.releaser.package import Package\n+from plone.releaser.pip import ConstraintsFile\n+from plone.releaser.pip import IniFile\n from progress.bar import Bar\n \n+import glob\n import keyring\n import time\n \n@@ -109,10 +112,56 @@ def changelog(**kwargs):\n     build_unified_changelog(kwargs["start"], kwargs["end"])\n \n \n-def check_checkout(package_name, path):\n-    if package_name not in CheckoutsFile(path):\n-        msg = "Your package {0} is not on auto-checkout section"\n-        raise KeyError(msg.format(package_name))\n+def _get_checkouts(path=None):\n+    """Get the parsed checkouts file at the given path.\n+\n+    If no path is given, we use several paths:\n+    both checkouts.cfg and mxdev.ini.\n+    """\n+    if path:\n+        paths = [path]\n+    else:\n+        paths = glob.glob("mxdev.ini") + glob.glob("checkouts.cfg")\n+    for path in paths:\n+        if path.endswith(".ini"):\n+            checkouts = IniFile(path)\n+        else:\n+            checkouts = CheckoutsFile(path)\n+        yield checkouts\n+\n+\n+def check_checkout(package_name, path=None):\n+    """Check if package is in the checkouts.\n+\n+    If no path is given, we try several paths:\n+    both checkouts.cfg and mxdev.ini.\n+    """\n+    for checkouts in _get_checkouts(path=path):\n+        loc = checkouts.file_location\n+        if package_name not in checkouts:\n+            print(f"No, your package {package_name} is NOT on auto checkout in {loc}.")\n+        else:\n+            print(f"YES, your package {package_name} is on auto checkout in {loc}.")\n+\n+\n+def remove_checkout(package_name, path=None):\n+    """Remove package from auto checkouts.\n+\n+    If no path is given, we try several paths:\n+    both checkouts.cfg and mxdev.ini.\n+    """\n+    for checkouts in _get_checkouts(path=path):\n+        checkouts.remove(package_name)\n+\n+\n+def add_checkout(package_name, path=None):\n+    """Add package to auto checkouts.\n+\n+    If no path is given, we try several paths:\n+    both checkouts.cfg and mxdev.ini.\n+    """\n+    for checkouts in _get_checkouts(path=path):\n+        checkouts.add(package_name)\n \n \n def append_jenkins_build_number_to_package_version(jenkins_build_number):\n@@ -126,9 +175,78 @@ def append_jenkins_build_number_to_package_version(jenkins_build_number):\n     return new_version\n \n \n-def set_package_version(version_file_path, package_name, new_version):\n-    versions = VersionsFile(version_file_path)\n-    versions.set(package_name, new_version)\n+def _get_constraints(path=None):\n+    """Get the parsed constraints/versions file at the given path.\n+\n+    If no path is given, we use several paths:\n+    constraints*.txt and versions*.cfg.\n+    """\n+    if path:\n+        paths = [path]\n+    else:\n+        paths = glob.glob("constraints*.txt") + glob.glob("versions*.cfg")\n+    for path in paths:\n+        if path.endswith(".txt"):\n+            constraints = ConstraintsFile(path)\n+        else:\n+            constraints = VersionsFile(path)\n+        yield constraints\n+\n+\n+def get_package_version(package_name, path=None):\n+    """Get package version from constraints/versions file.\n+\n+    If no path is given, we try several paths.\n+\n+    Note that versions with environment markers are ignored.\n+    See https://peps.python.org/pep-0496/ explaining them.\n+    The 99.99 percent use case of this part of plone.releaser is to get or set\n+    versions for a Plone package, and after abandoning Python 2 we are unlikely\n+    to need different versions of our core packages for different environments.\n+\n+    So in all the following cases, package version 1.0 is reported:\n+\n+    package==1.0\n+    package==2.0; python_version=="3.11"\n+\n+    [versions]\n+    package = 1.0\n+    [versions:python311]\n+    package = 2.0\n+    [versions:python_version=="3.12"]\n+    package = 3.0\n+    """\n+    for constraints in _get_constraints(path=path):\n+        if package_name not in constraints:\n+            print(f"{constraints.file_location}: {package_name} missing.")\n+            continue\n+        version = constraints.get(package_name)\n+        print(f"{constraints.file_location}: {package_name} {version}.")\n+\n+\n+def set_package_version(package_name, new_version, path=None):\n+    """Pin package to new version in a versions file.\n+\n+    This can also be a pip constraints file.\n+    If the package is not pinned yet, we add it.\n+\n+    If no path is given, we try several paths and set the version in all of them,\n+    but only if the package is already there: we do not want to add one package\n+    in three versions*.cfg files.\n+\n+    If you want to add environment markers, like "python_version >= \'3.0\'",\n+    please just edit the files yourself.\n+    """\n+    for constraints in _get_constraints(path=path):\n+        if package_name not in constraints:\n+            if path is None:\n+                print(f"{constraints.file_location}: {package_name} missing.")\n+                continue\n+            print(\n+                f"{constraints.file_location}: {package_name} not pinned yet. "\n+                f"Adding pin because you explicitly gave the path."\n+            )\n+        constraints.set(package_name, new_version)\n \n \n class Manage:\n@@ -142,8 +260,11 @@ def __call__(self, **kwargs):\n                 pulls,\n                 changelog,\n                 check_checkout,\n+                remove_checkout,\n+                add_checkout,\n                 append_jenkins_build_number_to_package_version,\n                 set_package_version,\n+                get_package_version,\n                 jenkins_report,\n             ]\n         )\ndiff --git a/plone/releaser/package.py b/plone/releaser/package.py\nindex d68a91c..09b55d9 100644\n--- a/plone/releaser/package.py\n+++ b/plone/releaser/package.py\n@@ -50,7 +50,6 @@ def buildout_coredev():\n \n \n class Package:\n-\n     # A reference to an plone.releaser.buildout.Buildout instance\n     buildout = None\n \ndiff --git a/plone/releaser/pip.py b/plone/releaser/pip.py\nnew file mode 100644\nindex 0000000..9d69501\n--- /dev/null\n+++ b/plone/releaser/pip.py\n@@ -0,0 +1,201 @@\n+from .utils import update_contents\n+from collections import UserDict\n+from configparser import ConfigParser\n+from configparser import ExtendedInterpolation\n+from functools import cached_property\n+\n+import pathlib\n+import re\n+\n+\n+def to_bool(value):\n+    if not isinstance(value, str):\n+        return bool(value)\n+    if value.lower() in ("true", "on", "yes", "1"):\n+        return True\n+    return False\n+\n+\n+class ConstraintsFile:\n+    def __init__(self, file_location):\n+        self.file_location = file_location\n+        self.path = pathlib.Path(self.file_location).resolve()\n+\n+    @cached_property\n+    def constraints(self):\n+        """Read the constraints."""\n+        contents = self.path.read_text()\n+        constraints = {}\n+        for line in contents.splitlines():\n+            line = line.strip()\n+            if line.startswith("#"):\n+                continue\n+            if "==" not in line:\n+                # We might want to support e.g. \'>=\', but for now keep it simple.\n+                continue\n+            package = line.split("==")[0].strip().lower()\n+            version = line.split("==")[1].strip()\n+            # The line could also contain environment markers like this:\n+            # "; python_version >= \'3.0\'"\n+            # But currently I think we really only need the package name,\n+            # and not even the version.  Let\'s use the entire rest of the line.\n+            # Actually, for our purposes, we should ignore lines that have such\n+            # markers, just like we do in buildout.py:VersionsFile.\n+            if ";" in version:\n+                continue\n+            if package in constraints:\n+                if constraints[package] != version:\n+                    print(\n+                        f"ERROR: {package} is in {self.file_location} with two "\n+                        f"constraints: \'{contraints[package]}\' and \'{version}\'.")\n+                continue\n+            constraints[package] = version\n+        return constraints\n+\n+    def __contains__(self, package_name):\n+        return package_name.lower() in self.constraints\n+\n+    def __getitem__(self, package_name):\n+        if package_name in self:\n+            return self.constraints.get(package_name.lower())\n+        raise KeyError\n+\n+    def __setitem__(self, package_name, new_version):\n+        contents = self.path.read_text()\n+        if not contents.endswith("\\n"):\n+            contents += "\\n"\n+            self.path.write_text(contents)\n+\n+        newline = f"{package_name}=={new_version}"\n+        # Look for \'package name==version\' on a line of its own,\n+        # no whitespace, no environment markers.\n+        line_reg = re.compile(rf"^{package_name.lower()}==[^;]*$")\n+\n+        def line_check(line):\n+            return line_reg.match(line)\n+\n+        # set version in contents.\n+        new_contents = update_contents(\n+            contents, line_check, newline, self.file_location\n+        )\n+        if contents != new_contents:\n+            self.path.write_text(new_contents)\n+\n+    def get(self, package_name, default=None):\n+        if package_name in self:\n+            return self.__getitem__(package_name)\n+        return default\n+\n+    def set(self, package_name, new_version):\n+        return self.__setitem__(package_name, new_version)\n+\n+\n+class IniFile(UserDict):\n+    """Ini file for mxdev.\n+\n+    What we want to do here is similar to what we have in buildout.py\n+    in the CheckoutsFile: remove a package from auto-checkouts.\n+    For mxdev: set \'use = false\'.\n+    The default is in \'settings\': \'default-use\'.\n+    """\n+\n+    def __init__(self, file_location):\n+        self.file_location = file_location\n+        self.path = pathlib.Path(self.file_location).resolve()\n+        self.config = ConfigParser(\n+            default_section="settings",\n+            interpolation=ExtendedInterpolation(),\n+        )\n+        with open(self.file_location) as f:\n+            self.config.read_file(f)\n+        self.default_use = to_bool(self.config["settings"].get("default-use", True))\n+\n+    @property\n+    def data(self):\n+        checkouts = {}\n+        for package in self.config.sections():\n+            use = to_bool(self.config[package].get("use", self.default_use))\n+            if use:\n+                # Map from lower case to actual case, so we can find the package.\n+                checkouts[package.lower()] = package\n+        return checkouts\n+\n+    def __contains__(self, package_name):\n+        return package_name.lower() in self.data\n+\n+    def __setitem__(self, package_name, enabled=True):\n+        """Enable or disable a checkout.\n+\n+        Mostly this will be called to disable a checkout.\n+        Expected is that default-use is false.\n+        This means we can remove \'use = true\' from the package.\n+\n+        But let\'s support the other way around as well:\n+        when default-use is true, we set \'use = false\'.\n+        """\n+        stored_package_name = self.data.get(package_name.lower())\n+        if stored_package_name:\n+            package_name = stored_package_name\n+            use = to_bool(self.config[package_name].get("use", self.default_use))\n+        else:\n+            use = False\n+        if use and enabled:\n+            print(f"{self.file_location}: {package_name} already in checkouts.")\n+            return\n+        if not use and not enabled:\n+            print(f"{self.file_location}: {package_name} not in checkouts.")\n+            return\n+\n+        contents = self.path.read_text()\n+        if not contents.endswith("\\n"):\n+            contents += "\\n"\n+            self.path.write_text(contents)\n+\n+        lines = []\n+        found_package = False\n+        for line in contents.splitlines():\n+            line = line.rstrip()\n+            if line == f"[{package_name}]":\n+                found_package = True\n+                lines.append(line)\n+                continue\n+            if not found_package:\n+                lines.append(line)\n+                continue\n+            if line.startswith("use =") or line.startswith("use="):\n+                # Ignore this line.  We may add a new one a bit further.\n+                continue\n+            if line == "" or line.startswith("["):\n+                # A new section is starting.\n+                if not enabled:\n+                    if self.default_use:\n+                        # We need to explicitly disable it.\n+                        lines.append("use = false")\n+                    print(\n+                        f"{self.file_location}: {package_name} removed from checkouts."\n+                    )\n+                else:\n+                    if not self.default_use:\n+                        # We need to explicitly enable it.\n+                        lines.append("use = true")\n+                    print(f"{self.file_location}: {package_name} added to checkouts.")\n+                # We are done with the section for this package name.\n+                found_package = False\n+                # We still need to append the original line.\n+                lines.append(line)\n+                continue\n+            # Just a regular line.\n+            lines.append(line)\n+\n+        contents = "\\n".join(lines) + "\\n"\n+        self.path.write_text(contents)\n+\n+    def __delitem__(self, package_name):\n+        return self.__setitem__(package_name, False)\n+\n+    def add(self, package_name):\n+        return self.__setitem__(package_name, True)\n+\n+    def remove(self, package_name):\n+        # Remove from checkouts.\n+        return self.__delitem__(package_name)\ndiff --git a/plone/releaser/release.py b/plone/releaser/release.py\nindex 1d17cbd..870ee57 100644\n--- a/plone/releaser/release.py\n+++ b/plone/releaser/release.py\n@@ -2,6 +2,8 @@\n from plone.releaser.buildout import CheckoutsFile\n from plone.releaser.buildout import SourcesFile\n from plone.releaser.buildout import VersionsFile\n+from plone.releaser.pip import ConstraintsFile\n+from plone.releaser.pip import IniFile\n from plone.releaser.pypi import can_user_release_package_to_pypi\n from zest.releaser import pypi\n from zest.releaser.utils import ask\n@@ -9,7 +11,9 @@\n from zest.releaser.utils import write_text_file\n \n import git\n+import glob\n import os\n+import pathlib\n import sys\n import textwrap\n \n@@ -174,14 +178,10 @@ def check_pypi_access(data):\n     env_var = "PLONE_RELEASER_CHECK_PYPI_ACCESS"\n     try:\n         if int(os.getenv(env_var, 1)) == 0:\n-            print(\n-                f"{env_var} variable set to zero: not checking pypi release rights."\n-            )\n+            print(f"{env_var} variable set to zero: not checking pypi release rights.")\n             return\n     except (TypeError, ValueError, AttributeError):\n-        print(\n-            f"ERROR: could not parse {env_var} env var. Ignoring it."\n-        )\n+        print(f"ERROR: could not parse {env_var} env var. Ignoring it.")\n \n     section = os.getenv("TWINE_REPOSITORY", "pypi")\n     pypi_user = pypi.PypiConfig().config.get(section, "username")\n@@ -282,14 +282,35 @@ def _get_package_branch(package_name):\n \n def update_versions(package_name, new_version):\n     # Update version\n-    print("Updating versions.cfg")\n-    path = os.path.join(os.getcwd(), "../../versions.cfg")\n-    versions = VersionsFile(path)\n-    versions.set(package_name, new_version)\n+    print("Updating buildout versions")\n+    cwd = pathlib.Path.cwd()\n+    coredev_dir = (cwd / os.pardir / os.pardir).resolve()\n+    # In coredev 6.0 we have versions.cfg, versions-ecosystem.cfg, versions-extra.cfg.\n+    for filename in glob.glob("versions*.cfg", root_dir=coredev_dir):\n+        path = coredev_dir / filename\n+        versions = VersionsFile(path)\n+        if package_name in versions:\n+            print(f"Updating {filename}")\n+            versions.set(package_name, new_version)\n+\n+    # We may have pip constraints files to update.\n+    for filename in glob.glob("constraints*.txt", root_dir=coredev_dir):\n+        path = coredev_dir / filename\n+        versions = ConstraintsFile(path)\n+        if package_name in versions:\n+            print(f"Updating {filename}")\n+            versions.set(package_name, new_version)\n \n \n def remove_from_checkouts(package_name):\n-    print("Removing package from checkouts.cfg")\n-    path = os.path.join(os.getcwd(), "../../checkouts.cfg")\n-    checkouts = CheckoutsFile(path)\n-    checkouts.remove(package_name)\n+    print("Removing package from checkouts")\n+    cwd = pathlib.Path.cwd()\n+    coredev_dir = (cwd / os.pardir / os.pardir).resolve()\n+    checkouts_file = coredev_dir / "checkouts.cfg"\n+    if checkouts_file.exists():\n+        checkouts = CheckoutsFile(checkouts_file)\n+        checkouts.remove(package_name)\n+    checkouts_file = coredev_dir / "mxdev.ini"\n+    if checkouts_file.exists():\n+        checkouts = IniFile(checkouts_file)\n+        checkouts.remove(package_name)\ndiff --git a/plone/releaser/tests/__init__.py b/plone/releaser/tests/__init__.py\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/plone/releaser/tests/input/constraints.txt b/plone/releaser/tests/input/constraints.txt\nnew file mode 100644\nindex 0000000..6c401aa\n--- /dev/null\n+++ b/plone/releaser/tests/input/constraints.txt\n@@ -0,0 +1,12 @@\n+# We should not touch this.\n+-c https://zopefoundation.github.io/Zope/releases/5.8.3/constraints.txt\n+# comment==1.0\n+annotated==1.0\n+CamelCase==1.0\n+duplicate==1.0\n+duplicate==1.0\n+lowercase==1.0\n+package==1.0\n+pyspecific==1.0\n+pyspecific==2.0; python_version=="3.12"\n+UPPERCASE==1.0\ndiff --git a/plone/releaser/tests/input/versions.cfg b/plone/releaser/tests/input/versions.cfg\nnew file mode 100644\nindex 0000000..15b43b0\n--- /dev/null\n+++ b/plone/releaser/tests/input/versions.cfg\n@@ -0,0 +1,21 @@\n+[buildout]\n+# We should not touch this.\n+extends = https://zopefoundation.github.io/Zope/releases/5.8.3/versions.cfg\n+\n+[versions]\n+# comment = 1.0\n+annotated = 1.0\n+CamelCase = 1.0\n+duplicate = 1.0\n+duplicate = 1.0\n+lowercase = 1.0\n+package = 1.0\n+pyspecific = 1.0\n+UPPERCASE = 1.0\n+\n+[versions:python312]\n+pyspecific = 2.0\n+\n+[versionannotations]\n+annotated =\n+    annotated = 1.1 conflicts with package = 1.1\ndiff --git a/plone/releaser/tests/test_buildout.py b/plone/releaser/tests/test_buildout.py\nnew file mode 100644\nindex 0000000..03f4f4e\n--- /dev/null\n+++ b/plone/releaser/tests/test_buildout.py\n@@ -0,0 +1,106 @@\n+from plone.releaser.buildout import VersionsFile\n+\n+import pathlib\n+import pytest\n+import shutil\n+\n+\n+TESTS_DIR = pathlib.Path(__file__).parent\n+INPUT_DIR = TESTS_DIR / "input"\n+VERSIONS_FILE = INPUT_DIR / "versions.cfg"\n+\n+\n+def test_versions_file_versions():\n+    vf = VersionsFile(VERSIONS_FILE)\n+    # All versions are reported lowercased.\n+    assert vf.versions == {\n+        "annotated": "1.0",\n+        "camelcase": "1.0",\n+        "duplicate": "1.0",\n+        "lowercase": "1.0",\n+        "package": "1.0",\n+        "pyspecific": "1.0",\n+        "uppercase": "1.0",\n+    }\n+\n+\n+def test_versions_file_contains():\n+    vf = VersionsFile(VERSIONS_FILE)\n+    assert "package" in vf\n+    assert "nope" not in vf\n+    # We compare case insensitively.\n+    # Let\'s try all combinations\n+    assert "camelcase" in vf\n+    assert "CamelCase" in vf\n+    assert "CAMELCASE" in vf\n+    assert "lowercase" in vf\n+    assert "LowerCase" in vf\n+    assert "LOWERCASE" in vf\n+    assert "uppercase" in vf\n+    assert "UpperCase" in vf\n+    assert "UPPERCASE" in vf\n+\n+\n+def test_versions_file_get():\n+    vf = VersionsFile(VERSIONS_FILE)\n+    assert vf.get("package") == "1.0"\n+    assert vf["package"] == "1.0"\n+    with pytest.raises(KeyError):\n+        vf["nope"]\n+    assert vf.get("nope") is None\n+    assert vf.get("nope", "hello") == "hello"\n+    # We compare case insensitively.\n+    # Let\'s try all combinations\n+    assert vf["camelcase"] == "1.0"\n+    assert vf["CamelCase"] == "1.0"\n+    assert vf["CAMELCASE"] == "1.0"\n+    assert vf["lowercase"] == "1.0"\n+    assert vf["LowerCase"] == "1.0"\n+    assert vf["LOWERCASE"] == "1.0"\n+    assert vf["uppercase"] == "1.0"\n+    assert vf["UpperCase"] == "1.0"\n+    assert vf["UPPERCASE"] == "1.0"\n+\n+\n+def test_versions_file_set_normal(tmp_path):\n+    # When we set a version, the file changes, so we work on a copy.\n+    copy_path = tmp_path / "versions.cfg"\n+    shutil.copyfile(VERSIONS_FILE, copy_path)\n+    vf = VersionsFile(copy_path)\n+    assert vf.get("package") == "1.0"\n+    vf.set("package", "2.0")\n+    # Let\'s read it fresh, for good measure.\n+    vf = VersionsFile(copy_path)\n+    assert vf.get("package") == "2.0"\n+    vf["package"] = "3.0"\n+    vf = VersionsFile(copy_path)\n+    assert vf.get("package") == "3.0"\n+\n+\n+def test_versions_file_set_ignore_markers(tmp_path):\n+    # [versions:python312] pins \'pyspecific = 2.0\'.\n+    # We do not report or change this section.\n+    copy_path = tmp_path / "versions.cfg"\n+    shutil.copyfile(VERSIONS_FILE, copy_path)\n+    vf = VersionsFile(copy_path)\n+    assert "pyspecific = 2.0" in copy_path.read_text()\n+    assert vf.get("pyspecific") == "1.0"\n+    vf.set("pyspecific", "1.1")\n+    # Let\'s read it fresh, for good measure.\n+    vf = VersionsFile(copy_path)\n+    assert vf.get("pyspecific") == "1.1"\n+    assert "pyspecific = 2.0" in copy_path.read_text()\n+\n+\n+def test_versions_file_set_cleanup_duplicates(tmp_path):\n+    copy_path = tmp_path / "versions.cfg"\n+    shutil.copyfile(VERSIONS_FILE, copy_path)\n+    assert copy_path.read_text().count("duplicate = 1.0") == 2\n+    vf = VersionsFile(copy_path)\n+    assert vf.get("duplicate") == "1.0"\n+    vf.set("duplicate", "2.0")\n+    # Let\'s read it fresh, for good measure.\n+    vf = VersionsFile(copy_path)\n+    assert vf.get("duplicate") == "2.0"\n+    assert copy_path.read_text().count("duplicate = 2.0") == 1\n+    assert copy_path.read_text().count("duplicate = 1.0") == 0\ndiff --git a/plone/releaser/tests/test_pip.py b/plone/releaser/tests/test_pip.py\nnew file mode 100644\nindex 0000000..4ef3d6d\n--- /dev/null\n+++ b/plone/releaser/tests/test_pip.py\n@@ -0,0 +1,106 @@\n+from plone.releaser.pip import ConstraintsFile\n+\n+import pathlib\n+import pytest\n+import shutil\n+\n+\n+TESTS_DIR = pathlib.Path(__file__).parent\n+INPUT_DIR = TESTS_DIR / "input"\n+CONSTRAINTS_FILE = INPUT_DIR / "constraints.txt"\n+\n+\n+def test_constraints_file_constraints():\n+    cf = ConstraintsFile(CONSTRAINTS_FILE)\n+    # All constraints are reported lowercased.\n+    assert cf.constraints == {\n+        "annotated": "1.0",\n+        "camelcase": "1.0",\n+        "duplicate": "1.0",\n+        "lowercase": "1.0",\n+        "package": "1.0",\n+        "pyspecific": "1.0",\n+        "uppercase": "1.0",\n+    }\n+\n+\n+def test_constraints_file_contains():\n+    cf = ConstraintsFile(CONSTRAINTS_FILE)\n+    assert "package" in cf\n+    assert "nope" not in cf\n+    # We compare case insensitively.\n+    # Let\'s try all combinations\n+    assert "camelcase" in cf\n+    assert "CamelCase" in cf\n+    assert "CAMELCASE" in cf\n+    assert "lowercase" in cf\n+    assert "LowerCase" in cf\n+    assert "LOWERCASE" in cf\n+    assert "uppercase" in cf\n+    assert "UpperCase" in cf\n+    assert "UPPERCASE" in cf\n+\n+\n+def test_constraints_file_get():\n+    cf = ConstraintsFile(CONSTRAINTS_FILE)\n+    assert cf.get("package") == "1.0"\n+    assert cf["package"] == "1.0"\n+    with pytest.raises(KeyError):\n+        cf["nope"]\n+    assert cf.get("nope") is None\n+    assert cf.get("nope", "hello") == "hello"\n+    # We compare case insensitively.\n+    # Let\'s try all combinations\n+    assert cf["camelcase"] == "1.0"\n+    assert cf["CamelCase"] == "1.0"\n+    assert cf["CAMELCASE"] == "1.0"\n+    assert cf["lowercase"] == "1.0"\n+    assert cf["LowerCase"] == "1.0"\n+    assert cf["LOWERCASE"] == "1.0"\n+    assert cf["uppercase"] == "1.0"\n+    assert cf["UpperCase"] == "1.0"\n+    assert cf["UPPERCASE"] == "1.0"\n+\n+\n+def test_constraints_file_set_normal(tmp_path):\n+    # When we set a version, the file changes, so we work on a copy.\n+    copy_path = tmp_path / "constraints.txt"\n+    shutil.copyfile(CONSTRAINTS_FILE, copy_path)\n+    cf = ConstraintsFile(copy_path)\n+    assert cf.get("package") == "1.0"\n+    cf.set("package", "2.0")\n+    # Let\'s read it fresh, for good measure.\n+    cf = ConstraintsFile(copy_path)\n+    assert cf.get("package") == "2.0"\n+    cf["package"] = "3.0"\n+    cf = ConstraintsFile(copy_path)\n+    assert cf.get("package") == "3.0"\n+\n+\n+def test_constraints_file_set_ignore_markers(tmp_path):\n+    # pyspecific==2.0; python_version=="3.12"\n+    # version pins that have a specific `python_version` are not changed.\n+    copy_path = tmp_path / "constraints.txt"\n+    shutil.copyfile(CONSTRAINTS_FILE, copy_path)\n+    cf = ConstraintsFile(copy_path)\n+    assert "pyspecific==2.0" in copy_path.read_text()\n+    assert cf.get("pyspecific") == "1.0"\n+    cf.set("pyspecific", "1.1")\n+    # Let\'s read it fresh, for good measure.\n+    cf = ConstraintsFile(copy_path)\n+    assert cf.get("pyspecific") == "1.1"\n+    assert "pyspecific==2.0" in copy_path.read_text()\n+\n+\n+def test_constraints_file_set_cleanup_duplicates(tmp_path):\n+    copy_path = tmp_path / "constraints.txt"\n+    shutil.copyfile(CONSTRAINTS_FILE, copy_path)\n+    assert copy_path.read_text().count("duplicate==1.0") == 2\n+    cf = ConstraintsFile(copy_path)\n+    assert cf.get("duplicate") == "1.0"\n+    cf.set("duplicate", "2.0")\n+    # Let\'s read it fresh, for good measure.\n+    cf = ConstraintsFile(copy_path)\n+    assert cf.get("duplicate") == "2.0"\n+    assert copy_path.read_text().count("duplicate==2.0") == 1\n+    assert copy_path.read_text().count("duplicate==1.0") == 0\ndiff --git a/plone/releaser/tests/test_utils.py b/plone/releaser/tests/test_utils.py\nnew file mode 100644\nindex 0000000..0a8927e\n--- /dev/null\n+++ b/plone/releaser/tests/test_utils.py\n@@ -0,0 +1,68 @@\n+from plone.releaser.utils import update_contents\n+\n+import pathlib\n+\n+\n+TESTS_DIR = pathlib.Path(__file__).parent\n+INPUT_DIR = TESTS_DIR / "input"\n+# Sample buildout versions.cfg\n+VERSIONS = (INPUT_DIR / "versions.cfg").read_text()\n+\n+\n+def test_update_contents_empty():\n+    assert update_contents("\\n", lambda x: True, "", "") == "\\n"\n+\n+\n+def test_update_contents_newline_at_end():\n+    assert update_contents("", lambda x: True, "", "") == "\\n"\n+\n+\n+def test_update_contents_versions_match(capsys):\n+    def line_check(line):\n+        return line.startswith("package =")\n+\n+    result = update_contents(VERSIONS, line_check, "package = 2.0", "file")\n+    assert "package = 2.0" in result\n+    assert "package = 1.0" not in result\n+    captured = capsys.readouterr()\n+    assert captured.out.strip() == "file: have set \'package = 2.0\'."\n+\n+\n+def test_update_contents_versions_add_at_end(capsys):\n+    def line_check(line):\n+        return line.startswith("new =")\n+\n+    result = update_contents(VERSIONS, line_check, "new = 2.0", "file")\n+    assert "new = 2.0" in result\n+    assert "new = 2.0" == result.splitlines()[-1]\n+    captured = capsys.readouterr()\n+    assert captured.out.strip() == "file: \'new = 2.0\' added."\n+\n+\n+def test_update_contents_versions_add_before_markers():\n+    def line_check(line):\n+        return line.startswith("new =")\n+\n+    def stop_check(line):\n+        # If we see this line, we should stop trying to match.\n+        return line.startswith("[versions:")\n+\n+    result = update_contents(\n+        VERSIONS, line_check, "new = 2.0", "", stop_check=stop_check\n+    )\n+    assert "new = 2.0" in result\n+    assert result.index("new = 2.0") < result.index("[versions:")\n+    lines = result.splitlines()\n+    new_index = lines.index("new = 2.0")\n+    # We have left a blank line.\n+    assert lines[new_index + 1] == ""\n+    assert lines[new_index + 2] == "[versions:python312]"\n+\n+\n+def test_update_contents_versions_removes_duplicates():\n+    def line_check(line):\n+        return line.startswith("duplicate =")\n+\n+    result = update_contents(VERSIONS, line_check, "duplicate = 2.0", "")\n+    assert "duplicate = 2.0" in result\n+    assert result.count("duplicate =") == 1\ndiff --git a/plone/releaser/utils.py b/plone/releaser/utils.py\nnew file mode 100644\nindex 0000000..432d943\n--- /dev/null\n+++ b/plone/releaser/utils.py\n@@ -0,0 +1,57 @@\n+def update_contents(contents, line_check, newline, filename, stop_check=None):\n+    """Update contents to have a new line if needed.\n+\n+    * contents is some file contents\n+    * line_check is a function we call to check if a line matches.\n+    * newline is the line with which we replace the matched line.\n+      This can be None to signal that the old line should be removed\n+    * filename is used for reporting.\n+    * stop_check is an optional function we call to check if we should stop\n+      trying to match.\n+\n+    Returns the new contents.\n+    """\n+    lines = []\n+    found = False\n+    content_lines = contents.splitlines()\n+    while content_lines:\n+        line = content_lines.pop(0)\n+        line = line.rstrip()\n+        if stop_check is not None and stop_check(line):\n+            # Put this line back.  We will handle this line and the other\n+            # remaining lines outside of this loop.\n+            content_lines.insert(0, line)\n+            break\n+        if not line_check(line):\n+            lines.append(line)\n+            continue\n+        # We have a match.\n+        if found:\n+            # This is a duplicate, ignore the line.\n+            continue\n+        found = True\n+        # Include this line only if we want it enabled.\n+        if newline is None:\n+            print(f"{filename}: \'{line}\' removed.")\n+        elif line == newline:\n+            lines.append(line)\n+            print(f"{filename}: \'{newline}\' already there.")\n+        else:\n+            lines.append(newline)\n+            print(f"{filename}: have set \'{newline}\'.")\n+\n+    if not found:\n+        if newline is None:\n+            print(f"{filename}: line not found.")\n+        else:\n+            if lines and not lines[-1]:\n+                # Insert before this last empty line.\n+                lines.insert(-1, newline)\n+            else:\n+                lines.append(newline)\n+            print(f"{filename}: \'{newline}\' added.")\n+\n+    if content_lines:\n+        lines.extend(content_lines)\n+\n+    return "\\n".join(lines) + "\\n"\ndiff --git a/setup.py b/setup.py\nindex 10a7113..5471d56 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -47,6 +47,9 @@\n         "zestreleaser.towncrier>=1.3.0",\n         "docutils",\n     ],\n+    extras_requires={\n+        "test": ["pytest"],\n+    },\n     entry_points={\n         "console_scripts": ["manage = plone.releaser.manage:manage"],\n         "zest.releaser.prereleaser.before": [\ndiff --git a/tox.ini b/tox.ini\nindex 2678f96..c8197fa 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -4,6 +4,7 @@\n envlist =\n     format\n     lint\n+    test\n \n [testenv]\n py_files = git ls-files "*.py"\n@@ -62,3 +63,14 @@ deps =\n     -c lint-requirements.txt\n commands =\n     sh -c \'pipdeptree --exclude setuptools,pipdeptree,wheel --graph-output svg > dependencies.svg\'\n+\n+[testenv:test]\n+description = run the distribution tests\n+use_develop = true\n+skip_install = false\n+constrain_package_deps = true\n+deps =\n+    pytest\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    pytest\n'

