Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2018-10-06T12:10:56+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/6d18f34495c691bc40b9e33261f9dc3c5d699cae

Copied Products/CMFPlone/skins/plone_scripts/check_id.py to utils.check_id.

No code changes yet, so this will need to be fixed.
This just makes it easier to see what has changed compared with the original script.

Files changed:
M Products/CMFPlone/utils.py

b'diff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py\nindex f0bdf9a79..f09eaaa75 100644\n--- a/Products/CMFPlone/utils.py\n+++ b/Products/CMFPlone/utils.py\n@@ -31,6 +31,7 @@\n from Products.CMFPlone.log import log_deprecated\n from Products.CMFPlone.log import log_exc\n from six.moves.urllib.parse import urlparse\n+from ZODB.POSException import ConflictError\n from zope import schema\n from zope.component import getMultiAdapter\n from zope.component import getUtility\n@@ -833,3 +834,192 @@ def human_readable_size(size):\n                 break\n         return \'%.1f %s\' % (float(size / float(SIZE_CONST[c])), c)\n     return size\n+\n+\n+def check_id(\n+        context, id=None, required=0, alternative_id=None, contained_by=None):\n+    """Test an id to make sure it is valid.\n+\n+    This used to be in Products/CMFPlone/skins/plone_scripts/check_id.py.\n+\n+    Returns an error message if the id is bad or None if the id is good.\n+    Parameters are as follows:\n+\n+        id - the id to check\n+\n+        required - if False, id can be the empty string\n+\n+        alternative_id - an alternative value to use for the id\n+        if the id is empty or autogenerated\n+\n+    Note: The reason the id is included is to handle id error messages for such\n+    objects as files and images that supply an alternative id when an id is auto-\n+    generated. If you say "There is already an item with this name in this folder"\n+    for an image that has the Name field populated with an autogenerated id,\n+    it can cause some confusion; since the real problem is the name of\n+    the image file name, not in the name of the autogenerated id.\n+    """\n+    ts = getToolByName(context, \'translation_service\')\n+\n+\n+    def xlate(message):\n+        return ts.translate(message, context=context.REQUEST)\n+\n+\n+    # if an alternative id has been supplied, see if we need to use it\n+    if alternative_id and not id:\n+        id = alternative_id\n+\n+    # make sure we have an id if one is required\n+    if not id:\n+        if required:\n+            return _(u\'Please enter a name.\')\n+\n+        # Id is not required and no alternative was specified, so assume the\n+        # object\'s id will be context.getId(). We still should check to make sure\n+        # context.getId() is OK to handle the case of pre-created objects\n+        # constructed via portal_factory.  The main potential problem is an id\n+        # collision, e.g. if portal_factory autogenerates an id that already\n+        # exists.\n+\n+        id = context.getId()\n+\n+    #\n+    # do basic id validation\n+    #\n+\n+    # check for reserved names\n+    if id in (\'login\', \'layout\', \'plone\', \'zip\', \'properties\', ):\n+        return xlate(\n+            _(u\'${name} is reserved.\',\n+              mapping={\'name\': id}))\n+\n+    # check for bad characters\n+    plone_utils = getToolByName(container, \'plone_utils\', None)\n+    if plone_utils is not None:\n+        bad_chars = plone_utils.bad_chars(id)\n+        if len(bad_chars) > 0:\n+            bad_chars = \'\'.join(bad_chars).decode(\'utf-8\')\n+            decoded_id = id.decode(\'utf-8\')\n+            return xlate(\n+                _(u\'${name} is not a legal name. The following characters are \'\n+                  u\'invalid: ${characters}\',\n+                  mapping={u\'name\': decoded_id, u\'characters\': bad_chars}))\n+\n+    # check for a catalog index\n+    portal_catalog = getToolByName(container, \'portal_catalog\', None)\n+    if portal_catalog is not None:\n+        try:\n+            if id in portal_catalog.indexes() + portal_catalog.schema():\n+                return xlate(\n+                    _(u\'${name} is reserved.\',\n+                      mapping={u\'name\': id}))\n+        except Unauthorized:\n+            # ignore if we don\'t have permission; will get picked up at the end\n+            pass\n+\n+    # id is good; decide if we should check for id collisions\n+    portal_factory = getToolByName(container, \'portal_factory\', None)\n+    if contained_by is not None:\n+        # always check for collisions if a container was passed\n+        checkForCollision = True\n+    elif portal_factory is not None and portal_factory.isTemporary(context):\n+        # always check for collisions if we are creating a new object\n+        checkForCollision = True\n+        try:\n+            # XXX this can\'t really be necessary, can it!?\n+            contained_by = context.aq_inner.aq_parent.aq_parent.aq_parent\n+        except Unauthorized:\n+            pass\n+    else:\n+        # if we have an existing object, only check for collisions\n+        # if we are changing the id\n+        checkForCollision = (context.getId() != id)\n+\n+    # check for id collisions\n+    if checkForCollision:\n+        # handles two use cases:\n+        # 1. object has not yet been created and we don\'t know where it will be\n+        # 2. object has been created and checking validity of id within container\n+        if contained_by is None:\n+            try:\n+                contained_by = context.getParentNode()\n+            except Unauthorized:\n+                return  # nothing we can do\n+\n+        # Check for an existing object.\n+        if id in contained_by:\n+            try:\n+                existing_obj = getattr(contained_by, id, None)\n+                if base_hasattr(existing_obj, \'portal_type\'):\n+                    return xlate(\n+                        _(u\'There is already an item named ${name} in this \'\n+                          u\'folder.\',\n+                          mapping={u\'name\': id}))\n+            except Unauthorized:\n+                # we can\'t access the object: safe to assume we can\'t replace it\n+                return xlate(\n+                    _(u\'There is already an item named ${name} in this folder.\',\n+                      mapping={u\'name\': id}))\n+\n+        if base_hasattr(contained_by, \'checkIdAvailable\'):\n+            try:\n+                if not contained_by.checkIdAvailable(id):\n+                    return xlate(\n+                        _(u\'${name} is reserved.\',\n+                          mapping={u\'name\': id}))\n+            except Unauthorized:\n+                pass  # ignore if we don\'t have permission\n+\n+        # containers may implement this hook to further restrict ids\n+        if base_hasattr(contained_by, \'checkValidId\'):\n+            try:\n+                contained_by.checkValidId(id)\n+            except Unauthorized:\n+                raise\n+            except ConflictError:\n+                raise\n+            except:\n+                return xlate(\n+                    _(u\'${name} is reserved.\',\n+                      mapping={u\'name\': id}))\n+\n+        # make sure we don\'t collide with any parent method aliases\n+        portal_types = getToolByName(context, \'portal_types\', None)\n+        if plone_utils is not None and portal_types is not None:\n+            parentFti = portal_types.getTypeInfo(contained_by)\n+            if parentFti is not None:\n+                aliases = plone_utils.getMethodAliases(parentFti)\n+                if aliases is not None:\n+                    if id in aliases.keys():\n+                        return xlate(\n+                            _(u\'${name} is reserved.\',\n+                              mapping={u\'name\': id}))\n+\n+        # Lastly, we want to disallow the id of any of the tools in the portal\n+        # root, as well as any object that can be acquired via portal_skins.\n+        # However, we do want to allow overriding of *content* in the object\'s\n+        # parent path, including the portal root.\n+\n+        if id != \'index_html\':  # always allow index_html\n+            portal = context.portal_url.getPortalObject()\n+            if id not in portal.contentIds():  # can override root *content*\n+                try:\n+                    # it is allowed to give an object the same id as another\n+                    # container in it\'s acquisition path as long as the\n+                    # object is outside the portal\n+                    outsideportal = getattr(portal.aq_parent, id, None)\n+                    insideportal = getattr(portal, id, None)\n+                    if (insideportal is not None\n+                            and outsideportal is not None\n+                            and outsideportal.aq_base == insideportal.aq_base):\n+                        return\n+                    # but not other things\n+                    if getattr(portal, id, None) is not None:\n+                        return xlate(\n+                            _(u\'${name} is reserved.\',\n+                              mapping={u\'name\': id}))\n+                except Unauthorized:\n+                    pass  # ignore if we don\'t have permission\n+\n+    return\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2018-10-06T12:11:03+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/929d524ca4160c68807a76dc19cf60be8e8e83fe

Basic cleanup of check_id function.

Mostly: use context instead of container.

Files changed:
M Products/CMFPlone/utils.py

b'diff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py\nindex f09eaaa75..e208629e1 100644\n--- a/Products/CMFPlone/utils.py\n+++ b/Products/CMFPlone/utils.py\n@@ -852,20 +852,19 @@ def check_id(\n         alternative_id - an alternative value to use for the id\n         if the id is empty or autogenerated\n \n-    Note: The reason the id is included is to handle id error messages for such\n-    objects as files and images that supply an alternative id when an id is auto-\n-    generated. If you say "There is already an item with this name in this folder"\n+    Note: The reason the id is included is to handle id error messages for\n+    such objects as files and images that supply an alternative id when an\n+    id is auto-generated.\n+    If you say "There is already an item with this name in this folder"\n     for an image that has the Name field populated with an autogenerated id,\n     it can cause some confusion; since the real problem is the name of\n     the image file name, not in the name of the autogenerated id.\n     """\n     ts = getToolByName(context, \'translation_service\')\n \n-\n     def xlate(message):\n         return ts.translate(message, context=context.REQUEST)\n \n-\n     # if an alternative id has been supplied, see if we need to use it\n     if alternative_id and not id:\n         id = alternative_id\n@@ -876,8 +875,8 @@ def xlate(message):\n             return _(u\'Please enter a name.\')\n \n         # Id is not required and no alternative was specified, so assume the\n-        # object\'s id will be context.getId(). We still should check to make sure\n-        # context.getId() is OK to handle the case of pre-created objects\n+        # object\'s id will be context.getId(). We still should check to make\n+        # sure context.getId() is OK to handle the case of pre-created objects\n         # constructed via portal_factory.  The main potential problem is an id\n         # collision, e.g. if portal_factory autogenerates an id that already\n         # exists.\n@@ -895,7 +894,7 @@ def xlate(message):\n               mapping={\'name\': id}))\n \n     # check for bad characters\n-    plone_utils = getToolByName(container, \'plone_utils\', None)\n+    plone_utils = getToolByName(context, \'plone_utils\', None)\n     if plone_utils is not None:\n         bad_chars = plone_utils.bad_chars(id)\n         if len(bad_chars) > 0:\n@@ -907,7 +906,7 @@ def xlate(message):\n                   mapping={u\'name\': decoded_id, u\'characters\': bad_chars}))\n \n     # check for a catalog index\n-    portal_catalog = getToolByName(container, \'portal_catalog\', None)\n+    portal_catalog = getToolByName(context, \'portal_catalog\', None)\n     if portal_catalog is not None:\n         try:\n             if id in portal_catalog.indexes() + portal_catalog.schema():\n@@ -919,7 +918,7 @@ def xlate(message):\n             pass\n \n     # id is good; decide if we should check for id collisions\n-    portal_factory = getToolByName(container, \'portal_factory\', None)\n+    portal_factory = getToolByName(context, \'portal_factory\', None)\n     if contained_by is not None:\n         # always check for collisions if a container was passed\n         checkForCollision = True\n@@ -940,7 +939,8 @@ def xlate(message):\n     if checkForCollision:\n         # handles two use cases:\n         # 1. object has not yet been created and we don\'t know where it will be\n-        # 2. object has been created and checking validity of id within container\n+        # 2. object has been created and checking validity of id within\n+        #    container\n         if contained_by is None:\n             try:\n                 contained_by = context.getParentNode()\n@@ -957,10 +957,11 @@ def xlate(message):\n                           u\'folder.\',\n                           mapping={u\'name\': id}))\n             except Unauthorized:\n-                # we can\'t access the object: safe to assume we can\'t replace it\n+                # We can\'t access the object:\n+                # safe to assume we can\'t replace it.\n                 return xlate(\n-                    _(u\'There is already an item named ${name} in this folder.\',\n-                      mapping={u\'name\': id}))\n+                    _(u\'There is already an item named ${name} \'\n+                      \'in this folder.\', mapping={u\'name\': id}))\n \n         if base_hasattr(contained_by, \'checkIdAvailable\'):\n             try:\n@@ -979,7 +980,7 @@ def xlate(message):\n                 raise\n             except ConflictError:\n                 raise\n-            except:\n+            except:  # noqa: E722\n                 return xlate(\n                     _(u\'${name} is reserved.\',\n                       mapping={u\'name\': id}))\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2018-10-06T12:11:03+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/2765f140f65318aba08ede3e38dd73f482e41d9a

Test utils.check_id instead of the old check_id skin script.

Files changed:
M Products/CMFPlone/tests/testCheckId.py

b'diff --git a/Products/CMFPlone/tests/testCheckId.py b/Products/CMFPlone/tests/testCheckId.py\nindex 9e961a369..8835424b9 100644\n--- a/Products/CMFPlone/tests/testCheckId.py\n+++ b/Products/CMFPlone/tests/testCheckId.py\n@@ -3,6 +3,7 @@\n from plone.app.testing.bbb import PloneTestCase\n from Products.CMFCore.utils import getToolByName\n from Products.CMFPlone.tests import dummy\n+from Products.CMFPlone.utils import check_id\n from ZODB.POSException import ConflictError\n \n \n@@ -48,29 +49,29 @@ def testValidPortalTypeNameButNotAutoGeneratedId(self):\n class TestCheckId(PloneTestCase):\n \n     def testGoodId(self):\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testEmptyId(self):\n-        r = self.folder.check_id(\'\')\n+        r = check_id(self.folder, \'\')\n         self.assertEqual(r, None)   # success\n \n     def testRequiredId(self):\n-        r = self.folder.check_id(\'\', required=1)\n+        r = check_id(self.folder, \'\', required=1)\n         self.assertEqual(r, u\'Please enter a name.\')\n \n     def testAlternativeId(self):\n-        r = self.folder.check_id(\'\', alternative_id=\'foo\')\n+        r = check_id(self.folder, \'\', alternative_id=\'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testBadId(self):\n         # See https://github.com/zopefoundation/Zope/pull/181\n-        r = self.folder.check_id(\'=\')\n+        r = check_id(self.folder, \'=\')\n         self.assertEqual(r, None)\n \n     def testDecodeId(self):\n         # See https://github.com/zopefoundation/Zope/pull/181\n-        r = self.folder.check_id(\'\\xc3\\xa4\')\n+        r = check_id(self.folder, \'\\xc3\\xa4\')\n         self.assertEqual(r, None)\n \n     def testCatalogIndex(self):\n@@ -81,7 +82,7 @@ def testCatalogIndex(self):\n                                         self.portal.portal_catalog),\n                         \'Expected permission "Search ZCatalog"\')\n \n-        r = self.folder.check_id(\'created\')\n+        r = check_id(self.folder, \'created\')\n         self.assertEqual(r, u\'created is reserved.\')\n \n     def testCatalogMetadata(self):\n@@ -89,50 +90,50 @@ def testCatalogMetadata(self):\n         portal_catalog.addColumn(\'new_metadata\')\n         self.assertTrue(\'new_metadata\' in portal_catalog.schema())\n         self.assertFalse(\'new_metadata\' in portal_catalog.indexes())\n-        r = self.folder.check_id(\'new_metadata\')\n+        r = check_id(self.folder, \'new_metadata\')\n         self.assertEqual(r, u\'new_metadata is reserved.\')\n \n     def testCollision(self):\n         self.folder.invokeFactory(\'Document\', id=\'foo\')\n         self.folder.invokeFactory(\'Document\', id=\'bar\')\n-        r = self.folder.foo.check_id(\'bar\')\n+        r = check_id(self.folder.foo, \'bar\')\n         self.assertEqual(r, u\'There is already an item named bar in this \'\n                             u\'folder.\')\n \n     def testTempObjectCollision(self):\n         foo = self.folder.restrictedTraverse(\'portal_factory/Document/foo\')\n         self.folder._setObject(\'bar\', dummy.Item(\'bar\'))\n-        r = foo.check_id(\'bar\')\n+        r = check_id(foo, \'bar\')\n         self.assertEqual(r, u\'bar is reserved.\')\n \n     def testReservedId(self):\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'portal_catalog\')\n+        r = check_id(self.folder.foo, \'portal_catalog\')\n         self.assertEqual(r, u\'portal_catalog is reserved.\')\n \n     def testHiddenObjectId(self):\n         # If a parallel object is not in content-space, should get \'reserved\'\n         # instead of \'taken\'\n-        r = self.folder.check_id(\'portal_skins\')\n+        r = check_id(self.folder, \'portal_skins\')\n         self.assertEqual(r, u\'portal_skins is reserved.\')\n \n     def testCanOverrideParentNames(self):\n         self.folder.invokeFactory(\'Document\', id=\'item1\')\n         self.folder.invokeFactory(\'Folder\', id=\'folder1\')\n         self.folder.invokeFactory(\'Document\', id=\'foo\')\n-        r = self.folder.folder1.foo.check_id(\'item1\')\n+        r = check_id(self.folder.folder1.foo, \'item1\')\n         self.assertEqual(r, None)\n \n     def testInvalidId(self):\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'_foo\')\n+        r = check_id(self.folder.foo, \'_foo\')\n         self.assertEqual(r, u\'_foo is reserved.\')\n \n     def testContainerHook(self):\n         # Container may have a checkValidId method; make sure it is called\n         self.folder._setObject(\'checkValidId\', dummy.Raiser(dummy.Error))\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'whatever\')\n+        r = check_id(self.folder.foo, \'whatever\')\n         self.assertEqual(r, u\'whatever is reserved.\')\n \n     def testContainerHookRaisesUnauthorized(self):\n@@ -150,19 +151,19 @@ def testContainerHookRaisesConflictError(self):\n     def testMissingUtils(self):\n         # check_id should not bomb out if the plone_utils tool is missing\n         self.portal._delObject(\'plone_utils\')\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testMissingCatalog(self):\n         # check_id should not bomb out if the portal_catalog tool is missing\n         self.portal._delObject(\'portal_catalog\')\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testMissingFactory(self):\n         # check_id should not bomb out if the portal_factory tool is missing\n         self.portal._delObject(\'portal_factory\')\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testCatalogIndexSkipped(self):\n@@ -171,7 +172,7 @@ def testCatalogIndexSkipped(self):\n         self.portal.manage_permission(\'Search ZCatalog\', [\'Manager\'],\n                                       acquire=0)\n \n-        r = self.folder.check_id(\'created\')\n+        r = check_id(self.folder, \'created\')\n         # But now the final hasattr check picks this up\n         self.assertEqual(r, u\'created is reserved.\')\n \n@@ -183,7 +184,7 @@ def testCollisionSkipped(self):\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n         self.folder._setObject(\'bar\', dummy.Item(\'bar\'))\n-        r = self.folder.foo.check_id(\'bar\')\n+        r = check_id(self.folder.foo, \'bar\')\n         self.assertEqual(r, None)   # success\n \n     def testReservedIdSkipped(self):\n@@ -193,7 +194,7 @@ def testReservedIdSkipped(self):\n         self.folder.manage_permission(\'Add portal content\', [], acquire=0)\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'portal_catalog\')\n+        r = check_id(self.folder.foo, \'portal_catalog\')\n         self.assertEqual(r, u\'portal_catalog is reserved.\')\n \n     def testInvalidIdSkipped(self):\n@@ -202,7 +203,7 @@ def testInvalidIdSkipped(self):\n         self.folder.manage_permission(\'Add portal content\', [], acquire=0)\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'_foo\')\n+        r = check_id(self.folder.foo, \'_foo\')\n         self.assertEqual(r, None)   # success\n \n     def testParentMethodAliasDisallowed(self):\n@@ -213,7 +214,7 @@ def testParentMethodAliasDisallowed(self):\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n         for alias in self.folder.getTypeInfo().getMethodAliases().keys():\n-            r = self.folder.foo.check_id(alias)\n+            r = check_id(self.folder.foo, alias)\n             self.assertEqual(r, u\'%s is reserved.\' % alias)\n \n     def testCheckingMethodAliasesOnPortalRoot(self):\n@@ -225,7 +226,7 @@ def testCheckingMethodAliasesOnPortalRoot(self):\n         # Should not raise: Before we were using obj.getTypeInfo(), which is\n         # not defined on the portal root.\n         try:\n-            self.portal.check_id(\'foo\')\n+            check_id(self.portal, \'foo\')\n         except AttributeError as e:\n             self.fail(e)\n \n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2018-10-06T12:11:03+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/6124d3f32681f6282aa3f1ef94e3e52f2c4ee9c8

Explicitly do some security checks in check_id.

This used to be done automatically when it was still a skin script.

Files changed:
M Products/CMFPlone/utils.py

b"diff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py\nindex e208629e1..5a5ae6cc2 100644\n--- a/Products/CMFPlone/utils.py\n+++ b/Products/CMFPlone/utils.py\n@@ -20,6 +20,7 @@\n from os.path import split\n from plone.i18n.normalizer.interfaces import IIDNormalizer\n from plone.registry.interfaces import IRegistry\n+from Products.CMFCore.permissions import AddPortalContent\n from Products.CMFCore.permissions import ManageUsers\n from Products.CMFCore.utils import ToolInit as CMFCoreToolInit\n from Products.CMFCore.utils import getToolByName\n@@ -890,7 +891,7 @@ def xlate(message):\n     # check for reserved names\n     if id in ('login', 'layout', 'plone', 'zip', 'properties', ):\n         return xlate(\n-            _(u'${name} is reserved.',\n+            _(u'${name} is reserved 1.',\n               mapping={'name': id}))\n \n     # check for bad characters\n@@ -947,6 +948,16 @@ def xlate(message):\n             except Unauthorized:\n                 return  # nothing we can do\n \n+        # When this was still a Python skin script, some security checks\n+        # would have been done automatically and caught by the various\n+        # 'except Unauthorized' lines below.  Now, in unrestricted Python\n+        # code, we explicitly check.\n+        secman = getSecurityManager()\n+        if not secman.checkPermission(\n+                'Access contents information', contained_by):\n+            # We cannot check.  Do not complain.\n+            return\n+\n         # Check for an existing object.\n         if id in contained_by:\n             try:\n@@ -964,13 +975,14 @@ def xlate(message):\n                       'in this folder.', mapping={u'name': id}))\n \n         if base_hasattr(contained_by, 'checkIdAvailable'):\n-            try:\n+            # This used to be called from the check_id skin script,\n+            # which would check the permission automatically,\n+            # and the code would catch the Unauthorized exception.\n+            if secman.checkPermission(AddPortalContent, contained_by):\n                 if not contained_by.checkIdAvailable(id):\n                     return xlate(\n                         _(u'${name} is reserved.',\n                           mapping={u'name': id}))\n-            except Unauthorized:\n-                pass  # ignore if we don't have permission\n \n         # containers may implement this hook to further restrict ids\n         if base_hasattr(contained_by, 'checkValidId'):\n"

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2018-10-06T12:11:03+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/da8dec87c31ed4e22e4fa543fcb8911ed5086aaa

Restructure check_id to be clearer.

Mostly less indentation.

Files changed:
M Products/CMFPlone/utils.py

b'diff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py\nindex 5a5ae6cc2..cb4e8ffd9 100644\n--- a/Products/CMFPlone/utils.py\n+++ b/Products/CMFPlone/utils.py\n@@ -861,9 +861,8 @@ def check_id(\n     it can cause some confusion; since the real problem is the name of\n     the image file name, not in the name of the autogenerated id.\n     """\n-    ts = getToolByName(context, \'translation_service\')\n-\n     def xlate(message):\n+        ts = getToolByName(context, \'translation_service\')\n         return ts.translate(message, context=context.REQUEST)\n \n     # if an alternative id has been supplied, see if we need to use it\n@@ -873,7 +872,7 @@ def xlate(message):\n     # make sure we have an id if one is required\n     if not id:\n         if required:\n-            return _(u\'Please enter a name.\')\n+            return xlate(_(u\'Please enter a name.\'))\n \n         # Id is not required and no alternative was specified, so assume the\n         # object\'s id will be context.getId(). We still should check to make\n@@ -909,130 +908,128 @@ def xlate(message):\n     # check for a catalog index\n     portal_catalog = getToolByName(context, \'portal_catalog\', None)\n     if portal_catalog is not None:\n-        try:\n-            if id in portal_catalog.indexes() + portal_catalog.schema():\n-                return xlate(\n-                    _(u\'${name} is reserved.\',\n-                      mapping={u\'name\': id}))\n-        except Unauthorized:\n-            # ignore if we don\'t have permission; will get picked up at the end\n-            pass\n+        if id in portal_catalog.indexes() + portal_catalog.schema():\n+            return xlate(\n+                _(u\'${name} is reserved.\',\n+                  mapping={u\'name\': id}))\n \n     # id is good; decide if we should check for id collisions\n     portal_factory = getToolByName(context, \'portal_factory\', None)\n     if contained_by is not None:\n-        # always check for collisions if a container was passed\n+        # Always check for collisions if a container was passed\n+        # via the contained_by parameter.\n         checkForCollision = True\n     elif portal_factory is not None and portal_factory.isTemporary(context):\n         # always check for collisions if we are creating a new object\n         checkForCollision = True\n-        try:\n-            # XXX this can\'t really be necessary, can it!?\n-            contained_by = context.aq_inner.aq_parent.aq_parent.aq_parent\n-        except Unauthorized:\n-            pass\n+        # Climb the acquisition chain until you get at the real container.\n+        contained_by = aq_parent(aq_parent(aq_parent(aq_inner(context))))\n     else:\n         # if we have an existing object, only check for collisions\n         # if we are changing the id\n         checkForCollision = (context.getId() != id)\n \n     # check for id collisions\n-    if checkForCollision:\n-        # handles two use cases:\n-        # 1. object has not yet been created and we don\'t know where it will be\n-        # 2. object has been created and checking validity of id within\n-        #    container\n-        if contained_by is None:\n-            try:\n-                contained_by = context.getParentNode()\n-            except Unauthorized:\n-                return  # nothing we can do\n-\n-        # When this was still a Python skin script, some security checks\n-        # would have been done automatically and caught by the various\n-        # \'except Unauthorized\' lines below.  Now, in unrestricted Python\n-        # code, we explicitly check.\n-        secman = getSecurityManager()\n-        if not secman.checkPermission(\n-                \'Access contents information\', contained_by):\n-            # We cannot check.  Do not complain.\n-            return\n+    if not checkForCollision:\n+        # We are done.\n+        return\n+    # handles two use cases:\n+    # 1. object has not yet been created and we don\'t know where it will be\n+    # 2. object has been created and checking validity of id within\n+    #    container\n+    if contained_by is None:\n+        try:\n+            contained_by = context.getParentNode()\n+        except Unauthorized:\n+            return  # nothing we can do\n \n-        # Check for an existing object.\n-        if id in contained_by:\n-            try:\n-                existing_obj = getattr(contained_by, id, None)\n-                if base_hasattr(existing_obj, \'portal_type\'):\n-                    return xlate(\n-                        _(u\'There is already an item named ${name} in this \'\n-                          u\'folder.\',\n-                          mapping={u\'name\': id}))\n-            except Unauthorized:\n-                # We can\'t access the object:\n-                # safe to assume we can\'t replace it.\n+    # When this was still a Python skin script, some security checks\n+    # would have been done automatically and caught by the various\n+    # \'except Unauthorized\' lines below.  Now, in unrestricted Python\n+    # code, we explicitly check.\n+    secman = getSecurityManager()\n+    if not secman.checkPermission(\n+            \'Access contents information\', contained_by):\n+        # We cannot check.  Do not complain.\n+        return\n+\n+    # Check for an existing object.\n+    if id in contained_by:\n+        try:\n+            existing_obj = getattr(contained_by, id, None)\n+            if base_hasattr(existing_obj, \'portal_type\'):\n                 return xlate(\n-                    _(u\'There is already an item named ${name} \'\n-                      \'in this folder.\', mapping={u\'name\': id}))\n-\n-        if base_hasattr(contained_by, \'checkIdAvailable\'):\n-            # This used to be called from the check_id skin script,\n-            # which would check the permission automatically,\n-            # and the code would catch the Unauthorized exception.\n-            if secman.checkPermission(AddPortalContent, contained_by):\n-                if not contained_by.checkIdAvailable(id):\n+                    _(u\'There is already an item named ${name} in this \'\n+                      u\'folder.\',\n+                      mapping={u\'name\': id}))\n+        except Unauthorized:\n+            # We can\'t access the object:\n+            # safe to assume we can\'t replace it.\n+            return xlate(\n+                _(u\'There is already an item named ${name} \'\n+                  \'in this folder.\', mapping={u\'name\': id}))\n+\n+    if base_hasattr(contained_by, \'checkIdAvailable\'):\n+        # This used to be called from the check_id skin script,\n+        # which would check the permission automatically,\n+        # and the code would catch the Unauthorized exception.\n+        if secman.checkPermission(AddPortalContent, contained_by):\n+            if not contained_by.checkIdAvailable(id):\n+                return xlate(\n+                    _(u\'${name} is reserved.\',\n+                      mapping={u\'name\': id}))\n+\n+    # containers may implement this hook to further restrict ids\n+    if base_hasattr(contained_by, \'checkValidId\'):\n+        try:\n+            contained_by.checkValidId(id)\n+        except Unauthorized:\n+            raise\n+        except ConflictError:\n+            raise\n+        except:  # noqa: E722\n+            return xlate(\n+                _(u\'${name} is reserved.\',\n+                  mapping={u\'name\': id}))\n+\n+    # make sure we don\'t collide with any parent method aliases\n+    portal_types = getToolByName(context, \'portal_types\', None)\n+    if plone_utils is not None and portal_types is not None:\n+        parentFti = portal_types.getTypeInfo(contained_by)\n+        if parentFti is not None:\n+            aliases = plone_utils.getMethodAliases(parentFti)\n+            if aliases is not None:\n+                if id in aliases.keys():\n                     return xlate(\n                         _(u\'${name} is reserved.\',\n                           mapping={u\'name\': id}))\n \n-        # containers may implement this hook to further restrict ids\n-        if base_hasattr(contained_by, \'checkValidId\'):\n-            try:\n-                contained_by.checkValidId(id)\n-            except Unauthorized:\n-                raise\n-            except ConflictError:\n-                raise\n-            except:  # noqa: E722\n-                return xlate(\n-                    _(u\'${name} is reserved.\',\n-                      mapping={u\'name\': id}))\n+    # Lastly, we want to disallow the id of any of the tools in the portal\n+    # root, as well as any object that can be acquired via portal_skins.\n+    # However, we do want to allow overriding of *content* in the object\'s\n+    # parent path, including the portal root.\n \n-        # make sure we don\'t collide with any parent method aliases\n-        portal_types = getToolByName(context, \'portal_types\', None)\n-        if plone_utils is not None and portal_types is not None:\n-            parentFti = portal_types.getTypeInfo(contained_by)\n-            if parentFti is not None:\n-                aliases = plone_utils.getMethodAliases(parentFti)\n-                if aliases is not None:\n-                    if id in aliases.keys():\n-                        return xlate(\n-                            _(u\'${name} is reserved.\',\n-                              mapping={u\'name\': id}))\n-\n-        # Lastly, we want to disallow the id of any of the tools in the portal\n-        # root, as well as any object that can be acquired via portal_skins.\n-        # However, we do want to allow overriding of *content* in the object\'s\n-        # parent path, including the portal root.\n-\n-        if id != \'index_html\':  # always allow index_html\n-            portal = context.portal_url.getPortalObject()\n-            if id not in portal.contentIds():  # can override root *content*\n-                try:\n-                    # it is allowed to give an object the same id as another\n-                    # container in it\'s acquisition path as long as the\n-                    # object is outside the portal\n-                    outsideportal = getattr(portal.aq_parent, id, None)\n-                    insideportal = getattr(portal, id, None)\n-                    if (insideportal is not None\n-                            and outsideportal is not None\n-                            and outsideportal.aq_base == insideportal.aq_base):\n-                        return\n-                    # but not other things\n-                    if getattr(portal, id, None) is not None:\n-                        return xlate(\n-                            _(u\'${name} is reserved.\',\n-                              mapping={u\'name\': id}))\n-                except Unauthorized:\n-                    pass  # ignore if we don\'t have permission\n-\n-    return\n+    if id == \'index_html\':\n+        # always allow index_html\n+        return\n+    portal = context.portal_url.getPortalObject()\n+    if id in portal.contentIds():\n+        # Fine to use the same id as a *content* item from the root.\n+        return\n+    try:\n+        # it is allowed to give an object the same id as another\n+        # container in it\'s acquisition path as long as the\n+        # object is outside the portal\n+        outsideportal = getattr(portal.aq_parent, id, None)\n+        insideportal = getattr(portal, id, None)\n+        if (insideportal is not None\n+                and outsideportal is not None\n+                and outsideportal.aq_base == insideportal.aq_base):\n+            return\n+        # but not other things\n+        if getattr(portal, id, None) is not None:\n+            return xlate(\n+                _(u\'${name} is reserved.\',\n+                  mapping={u\'name\': id}))\n+    except Unauthorized:\n+        pass  # ignore if we don\'t have permission\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2018-10-06T12:11:03+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/215e84e05faa977849889eda722da71ab485fbe0

Split function _check_for_collision out from check_id.

This took up half of the function.
This had try/except Unauthorized a couple of times, which will likely not be raised now that it is no longer a skin script.
But for safety we call _check_for_collision with a try/except Unauthorized.

Files changed:
M Products/CMFPlone/utils.py

b"diff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py\nindex cb4e8ffd9..7d5f838ef 100644\n--- a/Products/CMFPlone/utils.py\n+++ b/Products/CMFPlone/utils.py\n@@ -942,11 +942,24 @@ def xlate(message):\n             contained_by = context.getParentNode()\n         except Unauthorized:\n             return  # nothing we can do\n+    try:\n+        result = _check_for_collision(contained_by, id)\n+    except Unauthorized:\n+        # There is a permission problem. Safe to assume we can't use this id.\n+        return xlate(\n+            _(u'${name} is reserved.',\n+              mapping={u'name': id}))\n+    if result is not None:\n+        result = xlate(result, )\n+    return result\n \n+\n+def _check_for_collision(contained_by, id):\n     # When this was still a Python skin script, some security checks\n-    # would have been done automatically and caught by the various\n-    # 'except Unauthorized' lines below.  Now, in unrestricted Python\n-    # code, we explicitly check.\n+    # would have been done automatically and caught by some\n+    # 'except Unauthorized' lines.  Now, in unrestricted Python\n+    # code, we explicitly check.  For safety, we let the check_id\n+    # function do a try/except Unauthorized when calling us.\n     secman = getSecurityManager()\n     if not secman.checkPermission(\n             'Access contents information', contained_by):\n@@ -955,19 +968,11 @@ def xlate(message):\n \n     # Check for an existing object.\n     if id in contained_by:\n-        try:\n-            existing_obj = getattr(contained_by, id, None)\n-            if base_hasattr(existing_obj, 'portal_type'):\n-                return xlate(\n-                    _(u'There is already an item named ${name} in this '\n-                      u'folder.',\n-                      mapping={u'name': id}))\n-        except Unauthorized:\n-            # We can't access the object:\n-            # safe to assume we can't replace it.\n-            return xlate(\n-                _(u'There is already an item named ${name} '\n-                  'in this folder.', mapping={u'name': id}))\n+        existing_obj = getattr(contained_by, id, None)\n+        if base_hasattr(existing_obj, 'portal_type'):\n+            return _(\n+                u'There is already an item named ${name} in this folder.',\n+                mapping={u'name': id})\n \n     if base_hasattr(contained_by, 'checkIdAvailable'):\n         # This used to be called from the check_id skin script,\n@@ -975,34 +980,27 @@ def xlate(message):\n         # and the code would catch the Unauthorized exception.\n         if secman.checkPermission(AddPortalContent, contained_by):\n             if not contained_by.checkIdAvailable(id):\n-                return xlate(\n-                    _(u'${name} is reserved.',\n-                      mapping={u'name': id}))\n+                return _(u'${name} is reserved.', mapping={u'name': id})\n \n     # containers may implement this hook to further restrict ids\n     if base_hasattr(contained_by, 'checkValidId'):\n         try:\n             contained_by.checkValidId(id)\n-        except Unauthorized:\n-            raise\n         except ConflictError:\n             raise\n         except:  # noqa: E722\n-            return xlate(\n-                _(u'${name} is reserved.',\n-                  mapping={u'name': id}))\n+            return _(u'${name} is reserved.', mapping={u'name': id})\n \n     # make sure we don't collide with any parent method aliases\n-    portal_types = getToolByName(context, 'portal_types', None)\n+    plone_utils = getToolByName(contained_by, 'plone_utils', None)\n+    portal_types = getToolByName(contained_by, 'portal_types', None)\n     if plone_utils is not None and portal_types is not None:\n         parentFti = portal_types.getTypeInfo(contained_by)\n         if parentFti is not None:\n             aliases = plone_utils.getMethodAliases(parentFti)\n             if aliases is not None:\n                 if id in aliases.keys():\n-                    return xlate(\n-                        _(u'${name} is reserved.',\n-                          mapping={u'name': id}))\n+                    return _(u'${name} is reserved.', mapping={u'name': id})\n \n     # Lastly, we want to disallow the id of any of the tools in the portal\n     # root, as well as any object that can be acquired via portal_skins.\n@@ -1012,24 +1010,19 @@ def xlate(message):\n     if id == 'index_html':\n         # always allow index_html\n         return\n-    portal = context.portal_url.getPortalObject()\n+    portal = getToolByName(contained_by, 'portal_url').getPortalObject()\n     if id in portal.contentIds():\n         # Fine to use the same id as a *content* item from the root.\n         return\n-    try:\n-        # it is allowed to give an object the same id as another\n-        # container in it's acquisition path as long as the\n-        # object is outside the portal\n-        outsideportal = getattr(portal.aq_parent, id, None)\n-        insideportal = getattr(portal, id, None)\n-        if (insideportal is not None\n-                and outsideportal is not None\n-                and outsideportal.aq_base == insideportal.aq_base):\n-            return\n-        # but not other things\n-        if getattr(portal, id, None) is not None:\n-            return xlate(\n-                _(u'${name} is reserved.',\n-                  mapping={u'name': id}))\n-    except Unauthorized:\n-        pass  # ignore if we don't have permission\n+    # It is allowed to give an object the same id as another\n+    # container in it's acquisition path as long as the\n+    # object is outside the portal.\n+    outsideportal = getattr(aq_parent(portal), id, None)\n+    insideportal = getattr(portal, id, None)\n+    if (insideportal is not None\n+            and outsideportal is not None\n+            and aq_base(outsideportal) == aq_base(insideportal)):\n+        return\n+    # but not other things\n+    if getattr(portal, id, None) is not None:\n+        return _(u'${name} is reserved.', mapping={u'name': id})\n"

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2018-10-06T12:11:03+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/1fda95ebe9a18670d5b87dd745c2eeeb61d3ebbd

check_id: more compatible with IdValidator from Products.validation.

Files changed:
M Products/CMFPlone/utils.py

b'diff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py\nindex 7d5f838ef..7f1ae19b9 100644\n--- a/Products/CMFPlone/utils.py\n+++ b/Products/CMFPlone/utils.py\n@@ -838,7 +838,8 @@ def human_readable_size(size):\n \n \n def check_id(\n-        context, id=None, required=0, alternative_id=None, contained_by=None):\n+        context, id=None, required=0, alternative_id=None, contained_by=None,\n+        **kwargs):\n     """Test an id to make sure it is valid.\n \n     This used to be in Products/CMFPlone/skins/plone_scripts/check_id.py.\n@@ -853,6 +854,9 @@ def check_id(\n         alternative_id - an alternative value to use for the id\n         if the id is empty or autogenerated\n \n+    Accept keyword arguments for compatibility with the fallback\n+    in Products.validation.\n+\n     Note: The reason the id is included is to handle id error messages for\n     such objects as files and images that supply an alternative id when an\n     id is auto-generated.\n@@ -862,7 +866,9 @@ def check_id(\n     the image file name, not in the name of the autogenerated id.\n     """\n     def xlate(message):\n-        ts = getToolByName(context, \'translation_service\')\n+        ts = getToolByName(context, \'translation_service\', None)\n+        if ts is None:\n+            return message\n         return ts.translate(message, context=context.REQUEST)\n \n     # if an alternative id has been supplied, see if we need to use it\n@@ -890,7 +896,7 @@ def xlate(message):\n     # check for reserved names\n     if id in (\'login\', \'layout\', \'plone\', \'zip\', \'properties\', ):\n         return xlate(\n-            _(u\'${name} is reserved 1.\',\n+            _(u\'${name} is reserved.\',\n               mapping={\'name\': id}))\n \n     # check for bad characters\n@@ -943,7 +949,7 @@ def xlate(message):\n         except Unauthorized:\n             return  # nothing we can do\n     try:\n-        result = _check_for_collision(contained_by, id)\n+        result = _check_for_collision(contained_by, id, **kwargs)\n     except Unauthorized:\n         # There is a permission problem. Safe to assume we can\'t use this id.\n         return xlate(\n@@ -954,12 +960,18 @@ def xlate(message):\n     return result\n \n \n-def _check_for_collision(contained_by, id):\n-    # When this was still a Python skin script, some security checks\n-    # would have been done automatically and caught by some\n-    # \'except Unauthorized\' lines.  Now, in unrestricted Python\n-    # code, we explicitly check.  For safety, we let the check_id\n-    # function do a try/except Unauthorized when calling us.\n+def _check_for_collision(contained_by, id, **kwargs):\n+    """Check for collisions of an object id in a container.\n+\n+    Accept keyword arguments for compatibility with the fallback\n+    in Products.validation.\n+\n+    When this was still a Python skin script, some security checks\n+    would have been done automatically and caught by some\n+    \'except Unauthorized\' lines.  Now, in unrestricted Python\n+    code, we explicitly check.  For safety, we let the check_id\n+    function do a try/except Unauthorized when calling us.\n+    """\n     secman = getSecurityManager()\n     if not secman.checkPermission(\n             \'Access contents information\', contained_by):\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2018-10-06T12:11:03+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/24213d171de272ba1effabcb994df65c0109a137

check_id: do not break when portal_url tool is not found.

Happens in basic plone.app.content tests.

Files changed:
M Products/CMFPlone/utils.py

b"diff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py\nindex 7f1ae19b9..3cb8abdda 100644\n--- a/Products/CMFPlone/utils.py\n+++ b/Products/CMFPlone/utils.py\n@@ -1022,7 +1022,12 @@ def _check_for_collision(contained_by, id, **kwargs):\n     if id == 'index_html':\n         # always allow index_html\n         return\n-    portal = getToolByName(contained_by, 'portal_url').getPortalObject()\n+    portal_url = getToolByName(contained_by, 'portal_url', None)\n+    if portal_url is None:\n+        # Probably a test.\n+        # All other code needs the portal, so there is nothing left to check.\n+        return\n+    portal = portal_url.getPortalObject()\n     if id in portal.contentIds():\n         # Fine to use the same id as a *content* item from the root.\n         return\n"

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2018-10-06T12:11:03+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/d406bd77fb3f51870c686b563610cb262beb5e36

Really removed skins/plone_scripts/check_id.py.

Files changed:
D Products/CMFPlone/skins/plone_scripts/check_id.py
D Products/CMFPlone/skins/plone_scripts/check_id.py.metadata

b'diff --git a/Products/CMFPlone/skins/plone_scripts/check_id.py b/Products/CMFPlone/skins/plone_scripts/check_id.py\ndeleted file mode 100644\nindex 48406ce11..000000000\n--- a/Products/CMFPlone/skins/plone_scripts/check_id.py\n+++ /dev/null\n@@ -1,199 +0,0 @@\n-## Script (Python) "check_id"\n-##bind container=container\n-##bind context=context\n-##bind namespace=\n-##bind script=script\n-##bind subpath=traverse_subpath\n-##parameters=id=None,required=0,alternative_id=None,contained_by=None\n-##title=Check an id\'s validity\n-\n-"""\n-This script tests an id to make sure it is valid.\n-\n-Returns an error message if the id is bad or None if the id is good.\n-Parameters are as follows:\n-\n-    id - the id to check\n-\n-    required - if False, id can be the empty string\n-\n-    alternative_id - an alternative value to use for the id\n-    if the id is empty or autogenerated\n-\n-Note: The reason the id is included is to handle id error messages for such\n-objects as files and images that supply an alternative id when an id is auto-\n-generated. If you say "There is already an item with this name in this folder"\n-for an image that has the Name field populated with an autogenerated id,\n-it can cause some confusion; since the real problem is the name of\n-the image file name, not in the name of the autogenerated id.\n-"""\n-\n-from AccessControl import Unauthorized\n-from ZODB.POSException import ConflictError\n-from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone import PloneMessageFactory as _\n-from Products.CMFPlone.utils import base_hasattr\n-\n-# http://dev.plone.org/plone/ticket/10518#comment:7\n-ts = getToolByName(context, \'translation_service\')\n-\n-\n-def xlate(message):\n-    return ts.translate(message, context=context.REQUEST)\n-\n-\n-# if an alternative id has been supplied, see if we need to use it\n-if alternative_id and not id:\n-    id = alternative_id\n-\n-# make sure we have an id if one is required\n-if not id:\n-    if required:\n-        return _(u\'Please enter a name.\')\n-\n-    # Id is not required and no alternative was specified, so assume the\n-    # object\'s id will be context.getId(). We still should check to make sure\n-    # context.getId() is OK to handle the case of pre-created objects\n-    # constructed via portal_factory.  The main potential problem is an id\n-    # collision, e.g. if portal_factory autogenerates an id that already\n-    # exists.\n-\n-    id = context.getId()\n-\n-#\n-# do basic id validation\n-#\n-\n-# check for reserved names\n-if id in (\'login\', \'layout\', \'plone\', \'zip\', \'properties\', ):\n-    return xlate(\n-        _(u\'${name} is reserved.\',\n-          mapping={\'name\': id}))\n-\n-# check for bad characters\n-plone_utils = getToolByName(container, \'plone_utils\', None)\n-if plone_utils is not None:\n-    bad_chars = plone_utils.bad_chars(id)\n-    if len(bad_chars) > 0:\n-        bad_chars = \'\'.join(bad_chars).decode(\'utf-8\')\n-        decoded_id = id.decode(\'utf-8\')\n-        return xlate(\n-            _(u\'${name} is not a legal name. The following characters are \'\n-              u\'invalid: ${characters}\',\n-              mapping={u\'name\': decoded_id, u\'characters\': bad_chars}))\n-\n-# check for a catalog index\n-portal_catalog = getToolByName(container, \'portal_catalog\', None)\n-if portal_catalog is not None:\n-    try:\n-        if id in portal_catalog.indexes() + portal_catalog.schema():\n-            return xlate(\n-                _(u\'${name} is reserved.\',\n-                  mapping={u\'name\': id}))\n-    except Unauthorized:\n-        # ignore if we don\'t have permission; will get picked up at the end\n-        pass\n-\n-# id is good; decide if we should check for id collisions\n-portal_factory = getToolByName(container, \'portal_factory\', None)\n-if contained_by is not None:\n-    # always check for collisions if a container was passed\n-    checkForCollision = True\n-elif portal_factory is not None and portal_factory.isTemporary(context):\n-    # always check for collisions if we are creating a new object\n-    checkForCollision = True\n-    try:\n-        # XXX this can\'t really be necessary, can it!?\n-        contained_by = context.aq_inner.aq_parent.aq_parent.aq_parent\n-    except Unauthorized:\n-        pass\n-else:\n-    # if we have an existing object, only check for collisions\n-    # if we are changing the id\n-    checkForCollision = (context.getId() != id)\n-\n-# check for id collisions\n-if checkForCollision:\n-    # handles two use cases:\n-    # 1. object has not yet been created and we don\'t know where it will be\n-    # 2. object has been created and checking validity of id within container\n-    if contained_by is None:\n-        try:\n-            contained_by = context.getParentNode()\n-        except Unauthorized:\n-            return  # nothing we can do\n-\n-    # Check for an existing object.\n-    if id in contained_by:\n-        try:\n-            existing_obj = getattr(contained_by, id, None)\n-            if base_hasattr(existing_obj, \'portal_type\'):\n-                return xlate(\n-                    _(u\'There is already an item named ${name} in this \'\n-                      u\'folder.\',\n-                      mapping={u\'name\': id}))\n-        except Unauthorized:\n-            # we can\'t access the object: safe to assume we can\'t replace it\n-            return xlate(\n-                _(u\'There is already an item named ${name} in this folder.\',\n-                  mapping={u\'name\': id}))\n-\n-    if base_hasattr(contained_by, \'checkIdAvailable\'):\n-        try:\n-            if not contained_by.checkIdAvailable(id):\n-                return xlate(\n-                    _(u\'${name} is reserved.\',\n-                      mapping={u\'name\': id}))\n-        except Unauthorized:\n-            pass  # ignore if we don\'t have permission\n-\n-    # containers may implement this hook to further restrict ids\n-    if base_hasattr(contained_by, \'checkValidId\'):\n-        try:\n-            contained_by.checkValidId(id)\n-        except Unauthorized:\n-            raise\n-        except ConflictError:\n-            raise\n-        except:\n-            return xlate(\n-                _(u\'${name} is reserved.\',\n-                  mapping={u\'name\': id}))\n-\n-    # make sure we don\'t collide with any parent method aliases\n-    portal_types = getToolByName(context, \'portal_types\', None)\n-    if plone_utils is not None and portal_types is not None:\n-        parentFti = portal_types.getTypeInfo(contained_by)\n-        if parentFti is not None:\n-            aliases = plone_utils.getMethodAliases(parentFti)\n-            if aliases is not None:\n-                if id in aliases.keys():\n-                    return xlate(\n-                        _(u\'${name} is reserved.\',\n-                          mapping={u\'name\': id}))\n-\n-    # Lastly, we want to disallow the id of any of the tools in the portal\n-    # root, as well as any object that can be acquired via portal_skins.\n-    # However, we do want to allow overriding of *content* in the object\'s\n-    # parent path, including the portal root.\n-\n-    if id != \'index_html\':  # always allow index_html\n-        portal = context.portal_url.getPortalObject()\n-        if id not in portal.contentIds():  # can override root *content*\n-            try:\n-                # it is allowed to give an object the same id as another\n-                # container in it\'s acquisition path as long as the\n-                # object is outside the portal\n-                outsideportal = getattr(portal.aq_parent, id, None)\n-                insideportal = getattr(portal, id, None)\n-                if (insideportal is not None\n-                        and outsideportal is not None\n-                        and outsideportal.aq_base == insideportal.aq_base):\n-                    return\n-                # but not other things\n-                if getattr(portal, id, None) is not None:\n-                    return xlate(\n-                        _(u\'${name} is reserved.\',\n-                          mapping={u\'name\': id}))\n-            except Unauthorized:\n-                pass  # ignore if we don\'t have permission\ndiff --git a/Products/CMFPlone/skins/plone_scripts/check_id.py.metadata b/Products/CMFPlone/skins/plone_scripts/check_id.py.metadata\ndeleted file mode 100644\nindex 3b7f5db21..000000000\n--- a/Products/CMFPlone/skins/plone_scripts/check_id.py.metadata\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-[default]\n-proxy = Manager, Owner, Authenticated, Anonymous\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2018-10-06T12:14:08+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/21dacfc7cb039b3134f144a80765bf2f949273c8

changelog entry: Removed check_id.py skin script.  Replaced with utils.check_id function.

Files changed:
M CHANGES.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex e6834ab0f..db5302219 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -15,12 +15,16 @@ Breaking changes:\n   which is a backward compatibilit package only, or also update to not depend on it anymore.\n   [jensens]\n \n+- Removed check_id.py skin script.  Replaced with utils.check_id function.\n+  #1801 and #2582.\n+  [maurits]\n+\n - Removed my_worklist.py skin script. #1801\n   [reinhardt]\n-  \n+\n - Removed getObjectsFromPathList.py skin script. #1801\n   [reinhardt]\n-  \n+\n - Removed redirectToReferrer.py skin script. #1801\n   [tlotze]\n \n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2018-10-06T14:18:25+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/104385f2253a8529d01d3ff4f9d6081dcd5f4bf3

Fixed failing check_id tests.

We no longer test the proxy roles, because we no longer have nor need the check_id.py.metadata file.

Files changed:
M Products/CMFPlone/tests/testCheckId.py

b"diff --git a/Products/CMFPlone/tests/testCheckId.py b/Products/CMFPlone/tests/testCheckId.py\nindex 8835424b9..b617e6686 100644\n--- a/Products/CMFPlone/tests/testCheckId.py\n+++ b/Products/CMFPlone/tests/testCheckId.py\n@@ -140,13 +140,13 @@ def testContainerHookRaisesUnauthorized(self):\n         # check_id should not swallow Unauthorized errors raised by hook\n         self.folder._setObject('checkValidId', dummy.Raiser(Unauthorized))\n         self.folder._setObject('foo', dummy.Item('foo'))\n-        self.assertRaises(Unauthorized, self.folder.foo.check_id, 'whatever')\n+        self.assertRaises(Unauthorized, check_id(self.folder.foo), 'whatever')\n \n     def testContainerHookRaisesConflictError(self):\n         # check_id should not swallow ConflictErrors raised by hook\n         self.folder._setObject('checkValidId', dummy.Raiser(ConflictError))\n         self.folder._setObject('foo', dummy.Item('foo'))\n-        self.assertRaises(ConflictError, self.folder.foo.check_id, 'whatever')\n+        self.assertRaises(ConflictError, check_id(self.folder.foo), 'whatever')\n \n     def testMissingUtils(self):\n         # check_id should not bomb out if the plone_utils tool is missing\n@@ -229,12 +229,3 @@ def testCheckingMethodAliasesOnPortalRoot(self):\n             check_id(self.portal, 'foo')\n         except AttributeError as e:\n             self.fail(e)\n-\n-    def testProxyRoles(self):\n-        # Proxy roles should cover missing view permission for all but the\n-        # most unusual workflows.\n-        proxy_roles = self.folder.check_id._proxy_roles\n-        self.assertTrue('Manager' in proxy_roles)\n-        self.assertTrue('Owner' in proxy_roles)\n-        self.assertTrue('Authenticated' in proxy_roles)\n-        self.assertTrue('Anonymous' in proxy_roles)\n"

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2018-10-08T18:12:39+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/9fd8e95e5d2012510c5afc909a1e0106fea8822c

check_id: do not check for Access contents information permission.

Files changed:
M Products/CMFPlone/tests/testCheckId.py
M Products/CMFPlone/utils.py

b'diff --git a/Products/CMFPlone/tests/testCheckId.py b/Products/CMFPlone/tests/testCheckId.py\nindex b617e6686..5edf7fe60 100644\n--- a/Products/CMFPlone/tests/testCheckId.py\n+++ b/Products/CMFPlone/tests/testCheckId.py\n@@ -176,16 +176,21 @@ def testCatalogIndexSkipped(self):\n         # But now the final hasattr check picks this up\n         self.assertEqual(r, u\'created is reserved.\')\n \n-    def testCollisionSkipped(self):\n-        # Note that check is skipped when we don\'t have\n+    def testCollisionNotSkipped(self):\n+        # Note that the existing object check is done, even when we don\'t have\n         # the "Access contents information" permission.\n+        # This used to be the other way around.  The reason got lost.\n+        # Probably this was because the permission was checked automatically\n+        # because check_id was a skin script.  Since Plone 5.2 it is a\n+        # function which cannot be accessed from the web or templates,\n+        # so the permission test seems unneeded.\n         self.folder.manage_permission(\'Access contents information\', [],\n                                       acquire=0)\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n         self.folder._setObject(\'bar\', dummy.Item(\'bar\'))\n         r = check_id(self.folder.foo, \'bar\')\n-        self.assertEqual(r, None)   # success\n+        self.assertEqual(r, u\'bar is reserved.\')\n \n     def testReservedIdSkipped(self):\n         # This check is picked up by the checkIdAvailable, unless we don\'t have\ndiff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py\nindex 3cb8abdda..a48d84588 100644\n--- a/Products/CMFPlone/utils.py\n+++ b/Products/CMFPlone/utils.py\n@@ -969,14 +969,19 @@ def _check_for_collision(contained_by, id, **kwargs):\n     When this was still a Python skin script, some security checks\n     would have been done automatically and caught by some\n     \'except Unauthorized\' lines.  Now, in unrestricted Python\n-    code, we explicitly check.  For safety, we let the check_id\n+    code, we explicitly check.  But not all checks make sense.  If you don\'t\n+    have the \'Access contents information\' permission, theoretically\n+    you should not be able to check for an existing conflicting id,\n+    but it seems silly to then pretend that there is no conflict.\n+\n+    For safety, we let the check_id\n     function do a try/except Unauthorized when calling us.\n     """\n     secman = getSecurityManager()\n-    if not secman.checkPermission(\n-            \'Access contents information\', contained_by):\n-        # We cannot check.  Do not complain.\n-        return\n+    # if not secman.checkPermission(\n+    #         \'Access contents information\', contained_by):\n+    #     # We cannot check.  Do not complain.\n+    #     return\n \n     # Check for an existing object.\n     if id in contained_by:\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2018-10-22T21:20:44+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/fd213b7efdadc1b25a6e9bb058da0a5339b2e06f

Merge branch 'remove-checkid-script'

Manually edited utils.py and testCheckId.py to get Python 3 fixes in that were merged to master.

Files changed:
M CHANGES.rst
M Products/CMFPlone/tests/testCheckId.py
M Products/CMFPlone/utils.py
D Products/CMFPlone/skins/plone_scripts/check_id.py
D Products/CMFPlone/skins/plone_scripts/check_id.py.metadata

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 065600db8..1211088cd 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -15,6 +15,10 @@ Breaking changes:\n   which is a backward compatibilit package only, or also update to not depend on it anymore.\n   [jensens]\n \n+- Removed check_id.py skin script.  Replaced with utils.check_id function.\n+  #1801 and #2582.\n+  [maurits]\n+\n - Removed my_worklist.py skin script. #1801\n   [reinhardt]\n \ndiff --git a/Products/CMFPlone/skins/plone_scripts/check_id.py b/Products/CMFPlone/skins/plone_scripts/check_id.py\ndeleted file mode 100644\nindex a19df72e0..000000000\n--- a/Products/CMFPlone/skins/plone_scripts/check_id.py\n+++ /dev/null\n@@ -1,199 +0,0 @@\n-## Script (Python) "check_id"\n-##bind container=container\n-##bind context=context\n-##bind namespace=\n-##bind script=script\n-##bind subpath=traverse_subpath\n-##parameters=id=None,required=0,alternative_id=None,contained_by=None\n-##title=Check an id\'s validity\n-\n-"""\n-This script tests an id to make sure it is valid.\n-\n-Returns an error message if the id is bad or None if the id is good.\n-Parameters are as follows:\n-\n-    id - the id to check\n-\n-    required - if False, id can be the empty string\n-\n-    alternative_id - an alternative value to use for the id\n-    if the id is empty or autogenerated\n-\n-Note: The reason the id is included is to handle id error messages for such\n-objects as files and images that supply an alternative id when an id is auto-\n-generated. If you say "There is already an item with this name in this folder"\n-for an image that has the Name field populated with an autogenerated id,\n-it can cause some confusion; since the real problem is the name of\n-the image file name, not in the name of the autogenerated id.\n-"""\n-\n-from AccessControl import Unauthorized\n-from ZODB.POSException import ConflictError\n-from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone import PloneMessageFactory as _\n-from Products.CMFPlone.utils import base_hasattr\n-\n-# http://dev.plone.org/plone/ticket/10518#comment:7\n-ts = getToolByName(context, \'translation_service\')\n-\n-\n-def xlate(message):\n-    return ts.translate(message, context=context.REQUEST)\n-\n-\n-# if an alternative id has been supplied, see if we need to use it\n-if alternative_id and not id:\n-    id = alternative_id\n-\n-# make sure we have an id if one is required\n-if not id:\n-    if required:\n-        return _(u\'Please enter a name.\')\n-\n-    # Id is not required and no alternative was specified, so assume the\n-    # object\'s id will be context.getId(). We still should check to make sure\n-    # context.getId() is OK to handle the case of pre-created objects\n-    # constructed via portal_factory.  The main potential problem is an id\n-    # collision, e.g. if portal_factory autogenerates an id that already\n-    # exists.\n-\n-    id = context.getId()\n-\n-#\n-# do basic id validation\n-#\n-\n-# check for reserved names\n-if id in (\'login\', \'layout\', \'plone\', \'zip\', \'properties\', ):\n-    return xlate(\n-        _(u\'${name} is reserved.\',\n-          mapping={\'name\': id}))\n-\n-# check for bad characters\n-plone_utils = getToolByName(container, \'plone_utils\', None)\n-if plone_utils is not None:\n-    bad_chars = plone_utils.bad_chars(id)\n-    if len(bad_chars) > 0:\n-        bad_chars = \'\'.join(bad_chars).decode(\'utf-8\')\n-        decoded_id = id.decode(\'utf-8\')\n-        return xlate(\n-            _(u\'${name} is not a legal name. The following characters are \'\n-              u\'invalid: ${characters}\',\n-              mapping={u\'name\': decoded_id, u\'characters\': bad_chars}))\n-\n-# check for a catalog index\n-portal_catalog = getToolByName(container, \'portal_catalog\', None)\n-if portal_catalog is not None:\n-    try:\n-        if id in list(portal_catalog.indexes()) + list(portal_catalog.schema()):\n-            return xlate(\n-                _(u\'${name} is reserved.\',\n-                  mapping={u\'name\': id}))\n-    except Unauthorized:\n-        # ignore if we don\'t have permission; will get picked up at the end\n-        pass\n-\n-# id is good; decide if we should check for id collisions\n-portal_factory = getToolByName(container, \'portal_factory\', None)\n-if contained_by is not None:\n-    # always check for collisions if a container was passed\n-    checkForCollision = True\n-elif portal_factory is not None and portal_factory.isTemporary(context):\n-    # always check for collisions if we are creating a new object\n-    checkForCollision = True\n-    try:\n-        # XXX this can\'t really be necessary, can it!?\n-        contained_by = context.aq_inner.aq_parent.aq_parent.aq_parent\n-    except Unauthorized:\n-        pass\n-else:\n-    # if we have an existing object, only check for collisions\n-    # if we are changing the id\n-    checkForCollision = (context.getId() != id)\n-\n-# check for id collisions\n-if checkForCollision:\n-    # handles two use cases:\n-    # 1. object has not yet been created and we don\'t know where it will be\n-    # 2. object has been created and checking validity of id within container\n-    if contained_by is None:\n-        try:\n-            contained_by = context.getParentNode()\n-        except Unauthorized:\n-            return  # nothing we can do\n-\n-    # Check for an existing object.\n-    if id in contained_by:\n-        try:\n-            existing_obj = getattr(contained_by, id, None)\n-            if base_hasattr(existing_obj, \'portal_type\'):\n-                return xlate(\n-                    _(u\'There is already an item named ${name} in this \'\n-                      u\'folder.\',\n-                      mapping={u\'name\': id}))\n-        except Unauthorized:\n-            # we can\'t access the object: safe to assume we can\'t replace it\n-            return xlate(\n-                _(u\'There is already an item named ${name} in this folder.\',\n-                  mapping={u\'name\': id}))\n-\n-    if base_hasattr(contained_by, \'checkIdAvailable\'):\n-        try:\n-            if not contained_by.checkIdAvailable(id):\n-                return xlate(\n-                    _(u\'${name} is reserved.\',\n-                      mapping={u\'name\': id}))\n-        except Unauthorized:\n-            pass  # ignore if we don\'t have permission\n-\n-    # containers may implement this hook to further restrict ids\n-    if base_hasattr(contained_by, \'checkValidId\'):\n-        try:\n-            contained_by.checkValidId(id)\n-        except Unauthorized:\n-            raise\n-        except ConflictError:\n-            raise\n-        except:\n-            return xlate(\n-                _(u\'${name} is reserved.\',\n-                  mapping={u\'name\': id}))\n-\n-    # make sure we don\'t collide with any parent method aliases\n-    portal_types = getToolByName(context, \'portal_types\', None)\n-    if plone_utils is not None and portal_types is not None:\n-        parentFti = portal_types.getTypeInfo(contained_by)\n-        if parentFti is not None:\n-            aliases = plone_utils.getMethodAliases(parentFti)\n-            if aliases is not None:\n-                if id in aliases.keys():\n-                    return xlate(\n-                        _(u\'${name} is reserved.\',\n-                          mapping={u\'name\': id}))\n-\n-    # Lastly, we want to disallow the id of any of the tools in the portal\n-    # root, as well as any object that can be acquired via portal_skins.\n-    # However, we do want to allow overriding of *content* in the object\'s\n-    # parent path, including the portal root.\n-\n-    if id != \'index_html\':  # always allow index_html\n-        portal = context.portal_url.getPortalObject()\n-        if id not in portal.contentIds():  # can override root *content*\n-            try:\n-                # it is allowed to give an object the same id as another\n-                # container in it\'s acquisition path as long as the\n-                # object is outside the portal\n-                outsideportal = getattr(portal.aq_parent, id, None)\n-                insideportal = getattr(portal, id, None)\n-                if (insideportal is not None\n-                        and outsideportal is not None\n-                        and outsideportal.aq_base == insideportal.aq_base):\n-                    return\n-                # but not other things\n-                if getattr(portal, id, None) is not None:\n-                    return xlate(\n-                        _(u\'${name} is reserved.\',\n-                          mapping={u\'name\': id}))\n-            except Unauthorized:\n-                pass  # ignore if we don\'t have permission\ndiff --git a/Products/CMFPlone/skins/plone_scripts/check_id.py.metadata b/Products/CMFPlone/skins/plone_scripts/check_id.py.metadata\ndeleted file mode 100644\nindex 3b7f5db21..000000000\n--- a/Products/CMFPlone/skins/plone_scripts/check_id.py.metadata\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-[default]\n-proxy = Manager, Owner, Authenticated, Anonymous\ndiff --git a/Products/CMFPlone/tests/testCheckId.py b/Products/CMFPlone/tests/testCheckId.py\nindex 7805fe55d..c811b21c9 100644\n--- a/Products/CMFPlone/tests/testCheckId.py\n+++ b/Products/CMFPlone/tests/testCheckId.py\n@@ -3,6 +3,7 @@\n from plone.app.testing.bbb import PloneTestCase\n from Products.CMFCore.utils import getToolByName\n from Products.CMFPlone.tests import dummy\n+from Products.CMFPlone.utils import check_id\n from ZODB.POSException import ConflictError\n \n \n@@ -48,29 +49,29 @@ def testValidPortalTypeNameButNotAutoGeneratedId(self):\n class TestCheckId(PloneTestCase):\n \n     def testGoodId(self):\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testEmptyId(self):\n-        r = self.folder.check_id(\'\')\n+        r = check_id(self.folder, \'\')\n         self.assertEqual(r, None)   # success\n \n     def testRequiredId(self):\n-        r = self.folder.check_id(\'\', required=1)\n+        r = check_id(self.folder, \'\', required=1)\n         self.assertEqual(r, u\'Please enter a name.\')\n \n     def testAlternativeId(self):\n-        r = self.folder.check_id(\'\', alternative_id=\'foo\')\n+        r = check_id(self.folder, \'\', alternative_id=\'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testBadId(self):\n         # See https://github.com/zopefoundation/Zope/pull/181\n-        r = self.folder.check_id(\'=\')\n+        r = check_id(self.folder, \'=\')\n         self.assertEqual(r, None)\n \n     def testDecodeId(self):\n         # See https://github.com/zopefoundation/Zope/pull/181\n-        r = self.folder.check_id(\'\\xc3\\xa4\')\n+        r = check_id(self.folder, \'\\xc3\\xa4\')\n         self.assertEqual(r, None)\n \n     def testCatalogIndex(self):\n@@ -81,7 +82,7 @@ def testCatalogIndex(self):\n                                         self.portal.portal_catalog),\n                         \'Expected permission "Search ZCatalog"\')\n \n-        r = self.folder.check_id(\'created\')\n+        r = check_id(self.folder, \'created\')\n         self.assertEqual(r, u\'created is reserved.\')\n \n     def testCatalogMetadata(self):\n@@ -89,13 +90,13 @@ def testCatalogMetadata(self):\n         portal_catalog.addColumn(\'new_metadata\')\n         self.assertTrue(\'new_metadata\' in portal_catalog.schema())\n         self.assertFalse(\'new_metadata\' in portal_catalog.indexes())\n-        r = self.folder.check_id(\'new_metadata\')\n+        r = check_id(self.folder, \'new_metadata\')\n         self.assertEqual(r, u\'new_metadata is reserved.\')\n \n     def testCollision(self):\n         self.folder.invokeFactory(\'Document\', id=\'foo\')\n         self.folder.invokeFactory(\'Document\', id=\'bar\')\n-        r = self.folder.foo.check_id(\'bar\')\n+        r = check_id(self.folder.foo, \'bar\')\n         self.assertEqual(r, u\'There is already an item named bar in this \'\n                             u\'folder.\')\n \n@@ -104,68 +105,68 @@ def testCollision(self):\n     #     from plone.dexterity.utils import createContent\n     #     foo = createContent(\'Document\', id=\'foo\')\n     #     self.folder._setObject(\'bar\', dummy.Item(\'bar\'))\n-    #     r = foo.check_id(\'bar\')\n+    #     r = check_id(foo, \'bar\')\n     #     self.assertEqual(r, u\'bar is reserved.\')\n \n     def testReservedId(self):\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'portal_catalog\')\n+        r = check_id(self.folder.foo, \'portal_catalog\')\n         self.assertEqual(r, u\'portal_catalog is reserved.\')\n \n     def testHiddenObjectId(self):\n         # If a parallel object is not in content-space, should get \'reserved\'\n         # instead of \'taken\'\n-        r = self.folder.check_id(\'portal_skins\')\n+        r = check_id(self.folder, \'portal_skins\')\n         self.assertEqual(r, u\'portal_skins is reserved.\')\n \n     def testCanOverrideParentNames(self):\n         self.folder.invokeFactory(\'Document\', id=\'item1\')\n         self.folder.invokeFactory(\'Folder\', id=\'folder1\')\n         self.folder.invokeFactory(\'Document\', id=\'foo\')\n-        r = self.folder.folder1.foo.check_id(\'item1\')\n+        r = check_id(self.folder.folder1.foo, \'item1\')\n         self.assertEqual(r, None)\n \n     def testInvalidId(self):\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'_foo\')\n+        r = check_id(self.folder.foo, \'_foo\')\n         self.assertEqual(r, u\'_foo is reserved.\')\n \n     def testContainerHook(self):\n         # Container may have a checkValidId method; make sure it is called\n         self.folder._setObject(\'checkValidId\', dummy.Raiser(dummy.Error))\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'whatever\')\n+        r = check_id(self.folder.foo, \'whatever\')\n         self.assertEqual(r, u\'whatever is reserved.\')\n \n     def testContainerHookRaisesUnauthorized(self):\n         # check_id should not swallow Unauthorized errors raised by hook\n         self.folder._setObject(\'checkValidId\', dummy.Raiser(Unauthorized))\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        self.assertRaises(Unauthorized, self.folder.foo.check_id, \'whatever\')\n+        self.assertRaises(Unauthorized, check_id(self.folder.foo), \'whatever\')\n \n     def testContainerHookRaisesConflictError(self):\n         # check_id should not swallow ConflictErrors raised by hook\n         self.folder._setObject(\'checkValidId\', dummy.Raiser(ConflictError))\n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        self.assertRaises(ConflictError, self.folder.foo.check_id, \'whatever\')\n+        self.assertRaises(ConflictError, check_id(self.folder.foo), \'whatever\')\n \n     def testMissingUtils(self):\n         # check_id should not bomb out if the plone_utils tool is missing\n         self.portal._delObject(\'plone_utils\')\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testMissingCatalog(self):\n         # check_id should not bomb out if the portal_catalog tool is missing\n         self.portal._delObject(\'portal_catalog\')\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testMissingFactory(self):\n         # check_id should not bomb out if the portal_factory tool is missing\n         if \'portal_factory\' in self.portal:\n             self.portal._delObject(\'portal_factory\')\n-        r = self.folder.check_id(\'foo\')\n+        r = check_id(self.folder, \'foo\')\n         self.assertEqual(r, None)   # success\n \n     def testCatalogIndexSkipped(self):\n@@ -174,20 +175,25 @@ def testCatalogIndexSkipped(self):\n         self.portal.manage_permission(\'Search ZCatalog\', [\'Manager\'],\n                                       acquire=0)\n \n-        r = self.folder.check_id(\'created\')\n+        r = check_id(self.folder, \'created\')\n         # But now the final hasattr check picks this up\n         self.assertEqual(r, u\'created is reserved.\')\n \n-    def testCollisionSkipped(self):\n-        # Note that check is skipped when we don\'t have\n+    def testCollisionNotSkipped(self):\n+        # Note that the existing object check is done, even when we don\'t have\n         # the "Access contents information" permission.\n+        # This used to be the other way around.  The reason got lost.\n+        # Probably this was because the permission was checked automatically\n+        # because check_id was a skin script.  Since Plone 5.2 it is a\n+        # function which cannot be accessed from the web or templates,\n+        # so the permission test seems unneeded.\n         self.folder.manage_permission(\'Access contents information\', [],\n                                       acquire=0)\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n         self.folder._setObject(\'bar\', dummy.Item(\'bar\'))\n-        r = self.folder.foo.check_id(\'bar\')\n-        self.assertEqual(r, None)   # success\n+        r = check_id(self.folder.foo, \'bar\')\n+        self.assertEqual(r, u\'bar is reserved.\')\n \n     def testReservedIdSkipped(self):\n         # This check is picked up by the checkIdAvailable, unless we don\'t have\n@@ -196,7 +202,7 @@ def testReservedIdSkipped(self):\n         self.folder.manage_permission(\'Add portal content\', [], acquire=0)\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'portal_catalog\')\n+        r = check_id(self.folder.foo, \'portal_catalog\')\n         self.assertEqual(r, u\'portal_catalog is reserved.\')\n \n     def testInvalidIdSkipped(self):\n@@ -205,7 +211,7 @@ def testInvalidIdSkipped(self):\n         self.folder.manage_permission(\'Add portal content\', [], acquire=0)\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n-        r = self.folder.foo.check_id(\'_foo\')\n+        r = check_id(self.folder.foo, \'_foo\')\n         self.assertEqual(r, None)   # success\n \n     def testParentMethodAliasDisallowed(self):\n@@ -216,7 +222,7 @@ def testParentMethodAliasDisallowed(self):\n \n         self.folder._setObject(\'foo\', dummy.Item(\'foo\'))\n         for alias in self.folder.getTypeInfo().getMethodAliases().keys():\n-            r = self.folder.foo.check_id(alias)\n+            r = check_id(self.folder.foo, alias)\n             self.assertEqual(r, u\'%s is reserved.\' % alias)\n \n     def testCheckingMethodAliasesOnPortalRoot(self):\n@@ -228,15 +234,6 @@ def testCheckingMethodAliasesOnPortalRoot(self):\n         # Should not raise: Before we were using obj.getTypeInfo(), which is\n         # not defined on the portal root.\n         try:\n-            self.portal.check_id(\'foo\')\n+            check_id(self.portal, \'foo\')\n         except AttributeError as e:\n             self.fail(e)\n-\n-    def testProxyRoles(self):\n-        # Proxy roles should cover missing view permission for all but the\n-        # most unusual workflows.\n-        proxy_roles = self.folder.check_id._proxy_roles\n-        self.assertTrue(\'Manager\' in proxy_roles)\n-        self.assertTrue(\'Owner\' in proxy_roles)\n-        self.assertTrue(\'Authenticated\' in proxy_roles)\n-        self.assertTrue(\'Anonymous\' in proxy_roles)\ndiff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py\nindex d37a2ded9..0d932b6c5 100644\n--- a/Products/CMFPlone/utils.py\n+++ b/Products/CMFPlone/utils.py\n@@ -21,6 +21,7 @@\n from os.path import split\n from plone.i18n.normalizer.interfaces import IIDNormalizer\n from plone.registry.interfaces import IRegistry\n+from Products.CMFCore.permissions import AddPortalContent\n from Products.CMFCore.permissions import ManageUsers\n from Products.CMFCore.utils import ToolInit as CMFCoreToolInit\n from Products.CMFCore.utils import getToolByName\n@@ -32,6 +33,7 @@\n from Products.CMFPlone.log import log_deprecated\n from Products.CMFPlone.log import log_exc\n from six.moves.urllib.parse import urlparse\n+from ZODB.POSException import ConflictError\n from zope import schema\n from zope.component import getMultiAdapter\n from zope.component import getUtility\n@@ -863,3 +865,216 @@ def human_readable_size(size):\n                 break\n         return \'%.1f %s\' % (float(size / float(SIZE_CONST[c])), c)\n     return size\n+\n+\n+def check_id(\n+        context, id=None, required=0, alternative_id=None, contained_by=None,\n+        **kwargs):\n+    """Test an id to make sure it is valid.\n+\n+    This used to be in Products/CMFPlone/skins/plone_scripts/check_id.py.\n+\n+    Returns an error message if the id is bad or None if the id is good.\n+    Parameters are as follows:\n+\n+        id - the id to check\n+\n+        required - if False, id can be the empty string\n+\n+        alternative_id - an alternative value to use for the id\n+        if the id is empty or autogenerated\n+\n+    Accept keyword arguments for compatibility with the fallback\n+    in Products.validation.\n+\n+    Note: The reason the id is included is to handle id error messages for\n+    such objects as files and images that supply an alternative id when an\n+    id is auto-generated.\n+    If you say "There is already an item with this name in this folder"\n+    for an image that has the Name field populated with an autogenerated id,\n+    it can cause some confusion; since the real problem is the name of\n+    the image file name, not in the name of the autogenerated id.\n+    """\n+    def xlate(message):\n+        ts = getToolByName(context, \'translation_service\', None)\n+        if ts is None:\n+            return message\n+        return ts.translate(message, context=context.REQUEST)\n+\n+    # if an alternative id has been supplied, see if we need to use it\n+    if alternative_id and not id:\n+        id = alternative_id\n+\n+    # make sure we have an id if one is required\n+    if not id:\n+        if required:\n+            return xlate(_(u\'Please enter a name.\'))\n+\n+        # Id is not required and no alternative was specified, so assume the\n+        # object\'s id will be context.getId(). We still should check to make\n+        # sure context.getId() is OK to handle the case of pre-created objects\n+        # constructed via portal_factory.  The main potential problem is an id\n+        # collision, e.g. if portal_factory autogenerates an id that already\n+        # exists.\n+\n+        id = context.getId()\n+\n+    #\n+    # do basic id validation\n+    #\n+\n+    # check for reserved names\n+    if id in (\'login\', \'layout\', \'plone\', \'zip\', \'properties\', ):\n+        return xlate(\n+            _(u\'${name} is reserved.\',\n+              mapping={\'name\': id}))\n+\n+    # check for bad characters\n+    plone_utils = getToolByName(context, \'plone_utils\', None)\n+    if plone_utils is not None:\n+        bad_chars = plone_utils.bad_chars(id)\n+        if len(bad_chars) > 0:\n+            bad_chars = \'\'.join(bad_chars).decode(\'utf-8\')\n+            decoded_id = id.decode(\'utf-8\')\n+            return xlate(\n+                _(u\'${name} is not a legal name. The following characters are \'\n+                  u\'invalid: ${characters}\',\n+                  mapping={u\'name\': decoded_id, u\'characters\': bad_chars}))\n+\n+    # check for a catalog index\n+    portal_catalog = getToolByName(context, \'portal_catalog\', None)\n+    if portal_catalog is not None:\n+        if id in list(portal_catalog.indexes()) + list(portal_catalog.schema()):\n+            return xlate(\n+                _(u\'${name} is reserved.\',\n+                  mapping={u\'name\': id}))\n+\n+    # id is good; decide if we should check for id collisions\n+    portal_factory = getToolByName(context, \'portal_factory\', None)\n+    if contained_by is not None:\n+        # Always check for collisions if a container was passed\n+        # via the contained_by parameter.\n+        checkForCollision = True\n+    elif portal_factory is not None and portal_factory.isTemporary(context):\n+        # always check for collisions if we are creating a new object\n+        checkForCollision = True\n+        # Climb the acquisition chain until you get at the real container.\n+        contained_by = aq_parent(aq_parent(aq_parent(aq_inner(context))))\n+    else:\n+        # if we have an existing object, only check for collisions\n+        # if we are changing the id\n+        checkForCollision = (context.getId() != id)\n+\n+    # check for id collisions\n+    if not checkForCollision:\n+        # We are done.\n+        return\n+    # handles two use cases:\n+    # 1. object has not yet been created and we don\'t know where it will be\n+    # 2. object has been created and checking validity of id within\n+    #    container\n+    if contained_by is None:\n+        try:\n+            contained_by = context.getParentNode()\n+        except Unauthorized:\n+            return  # nothing we can do\n+    try:\n+        result = _check_for_collision(contained_by, id, **kwargs)\n+    except Unauthorized:\n+        # There is a permission problem. Safe to assume we can\'t use this id.\n+        return xlate(\n+            _(u\'${name} is reserved.\',\n+              mapping={u\'name\': id}))\n+    if result is not None:\n+        result = xlate(result, )\n+    return result\n+\n+\n+def _check_for_collision(contained_by, id, **kwargs):\n+    """Check for collisions of an object id in a container.\n+\n+    Accept keyword arguments for compatibility with the fallback\n+    in Products.validation.\n+\n+    When this was still a Python skin script, some security checks\n+    would have been done automatically and caught by some\n+    \'except Unauthorized\' lines.  Now, in unrestricted Python\n+    code, we explicitly check.  But not all checks make sense.  If you don\'t\n+    have the \'Access contents information\' permission, theoretically\n+    you should not be able to check for an existing conflicting id,\n+    but it seems silly to then pretend that there is no conflict.\n+\n+    For safety, we let the check_id\n+    function do a try/except Unauthorized when calling us.\n+    """\n+    secman = getSecurityManager()\n+    # if not secman.checkPermission(\n+    #         \'Access contents information\', contained_by):\n+    #     # We cannot check.  Do not complain.\n+    #     return\n+\n+    # Check for an existing object.\n+    if id in contained_by:\n+        existing_obj = getattr(contained_by, id, None)\n+        if base_hasattr(existing_obj, \'portal_type\'):\n+            return _(\n+                u\'There is already an item named ${name} in this folder.\',\n+                mapping={u\'name\': id})\n+\n+    if base_hasattr(contained_by, \'checkIdAvailable\'):\n+        # This used to be called from the check_id skin script,\n+        # which would check the permission automatically,\n+        # and the code would catch the Unauthorized exception.\n+        if secman.checkPermission(AddPortalContent, contained_by):\n+            if not contained_by.checkIdAvailable(id):\n+                return _(u\'${name} is reserved.\', mapping={u\'name\': id})\n+\n+    # containers may implement this hook to further restrict ids\n+    if base_hasattr(contained_by, \'checkValidId\'):\n+        try:\n+            contained_by.checkValidId(id)\n+        except ConflictError:\n+            raise\n+        except:  # noqa: E722\n+            return _(u\'${name} is reserved.\', mapping={u\'name\': id})\n+\n+    # make sure we don\'t collide with any parent method aliases\n+    plone_utils = getToolByName(contained_by, \'plone_utils\', None)\n+    portal_types = getToolByName(contained_by, \'portal_types\', None)\n+    if plone_utils is not None and portal_types is not None:\n+        parentFti = portal_types.getTypeInfo(contained_by)\n+        if parentFti is not None:\n+            aliases = plone_utils.getMethodAliases(parentFti)\n+            if aliases is not None:\n+                if id in aliases.keys():\n+                    return _(u\'${name} is reserved.\', mapping={u\'name\': id})\n+\n+    # Lastly, we want to disallow the id of any of the tools in the portal\n+    # root, as well as any object that can be acquired via portal_skins.\n+    # However, we do want to allow overriding of *content* in the object\'s\n+    # parent path, including the portal root.\n+\n+    if id == \'index_html\':\n+        # always allow index_html\n+        return\n+    portal_url = getToolByName(contained_by, \'portal_url\', None)\n+    if portal_url is None:\n+        # Probably a test.\n+        # All other code needs the portal, so there is nothing left to check.\n+        return\n+    portal = portal_url.getPortalObject()\n+    if id in portal.contentIds():\n+        # Fine to use the same id as a *content* item from the root.\n+        return\n+    # It is allowed to give an object the same id as another\n+    # container in it\'s acquisition path as long as the\n+    # object is outside the portal.\n+    outsideportal = getattr(aq_parent(portal), id, None)\n+    insideportal = getattr(portal, id, None)\n+    if (insideportal is not None\n+            and outsideportal is not None\n+            and aq_base(outsideportal) == aq_base(insideportal)):\n+        return\n+    # but not other things\n+    if getattr(portal, id, None) is not None:\n+        return _(u\'${name} is reserved.\', mapping={u\'name\': id})\n'

