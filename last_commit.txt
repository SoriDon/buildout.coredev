Repository: plone.event


Branch: refs/heads/master
Date: 2023-04-15T14:10:11+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.event/commit/4ffbbcab695ac0a508dfdfa650b3433be4960c1c

Configuring with plone/meta

Files changed:
A .editorconfig
A .meta.toml
A .pre-commit-config.yaml
A news/5cc689e5.internal
M pyproject.toml
M setup.cfg
M tox.ini
D .travis.yml

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..1b2346d\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "5cc689e5"\ndiff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nnew file mode 100644\nindex 0000000..fdafec1\n--- /dev/null\n+++ b/.pre-commit-config.yaml\n@@ -0,0 +1,42 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+ci:\n+    autofix_prs: false\n+    autoupdate_schedule: monthly\n+\n+repos:\n+-   repo: https://github.com/asottile/pyupgrade\n+    rev: v3.3.1\n+    hooks:\n+    -   id: pyupgrade\n+        args: [--py38-plus]\n+-   repo: https://github.com/pycqa/isort\n+    rev: 5.12.0\n+    hooks:\n+    -   id: isort\n+-   repo: https://github.com/psf/black\n+    rev: 23.3.0\n+    hooks:\n+    -   id: black\n+-   repo: https://github.com/collective/zpretty\n+    rev: 3.0.3\n+    hooks:\n+    -   id: zpretty\n+-   repo: https://github.com/PyCQA/flake8\n+    rev: 6.0.0\n+    hooks:\n+    -   id: flake8\n+-   repo: https://github.com/codespell-project/codespell\n+    rev: v2.2.4\n+    hooks:\n+    -   id: codespell\n+        additional_dependencies:\n+          - tomli\n+-   repo: https://github.com/mgedmin/check-manifest\n+    rev: "0.49"\n+    hooks:\n+    -   id: check-manifest\n+-   repo: https://github.com/regebro/pyroma\n+    rev: "4.2"\n+    hooks:\n+    -   id: pyroma\ndiff --git a/.travis.yml b/.travis.yml\ndeleted file mode 100644\nindex afff7e4..0000000\n--- a/.travis.yml\n+++ /dev/null\n@@ -1,12 +0,0 @@\n-language: python\n-python:\n-    - 2.7\n-    - 3.6\n-    - 3.7\n-    - 3.8\n-install:\n-    - pip install tox-travis\n-script:\n-    - tox\n-notifications:\n-    email: false\ndiff --git a/news/5cc689e5.internal b/news/5cc689e5.internal\nnew file mode 100644\nindex 0000000..c08f539\n--- /dev/null\n+++ b/news/5cc689e5.internal\n@@ -0,0 +1,2 @@\n+Update configuration files.\n+[plone devs]\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..92c3af9 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,64 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "internal"\n+name = "Internal:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "documentation"\n+name = "Documentation:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "tests"\n+name = "Tests"\n+showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\n+\n+[tool.dependencychecker]\n+Zope = [\n+  # Zope own provided namespaces\n+  \'App\', \'OFS\', \'Products.Five\', \'Products.OFSP\', \'Products.PageTemplates\',\n+  \'Products.SiteAccess\', \'Shared\', \'Testing\', \'ZPublisher\', \'ZTUtils\',\n+  \'Zope2\', \'webdav\', \'zmi\',\n+  # ExtensionClass own provided namespaces\n+  \'ExtensionClass\', \'ComputedAttribute\', \'MethodObject\',\n+  # Zope dependencies\n+  \'AccessControl\', \'Acquisition\', \'AuthEncoding\', \'beautifulsoup4\', \'BTrees\',\n+  \'cffi\', \'Chameleon\', \'DateTime\', \'DocumentTemplate\',\n+  \'MultiMapping\', \'multipart\', \'PasteDeploy\', \'Persistence\', \'persistent\',\n+  \'pycparser\', \'python-gettext\', \'pytz\', \'RestrictedPython\', \'roman\', \'six\',\n+  \'soupsieve\', \'transaction\', \'waitress\', \'WebOb\', \'WebTest\', \'WSGIProxy2\',\n+  \'z3c.pt\', \'zc.lockfile\', \'ZConfig\', \'zExceptions\', \'ZODB\', \'zodbpickle\',\n+  \'zope.annotation\', \'zope.browser\', \'zope.browsermenu\', \'zope.browserpage\',\n+  \'zope.browserresource\', \'zope.cachedescriptors\', \'zope.component\',\n+  \'zope.configuration\', \'zope.container\', \'zope.contentprovider\',\n+  \'zope.contenttype\', \'zope.datetime\', \'zope.deferredimport\',\n+  \'zope.deprecation\', \'zope.dottedname\', \'zope.event\', \'zope.exceptions\',\n+  \'zope.filerepresentation\', \'zope.globalrequest\', \'zope.hookable\',\n+  \'zope.i18n\', \'zope.i18nmessageid\', \'zope.interface\', \'zope.lifecycleevent\',\n+  \'zope.location\', \'zope.pagetemplate\', \'zope.processlifetime\', \'zope.proxy\',\n+  \'zope.ptresource\', \'zope.publisher\', \'zope.schema\', \'zope.security\',\n+  \'zope.sequencesort\', \'zope.site\', \'zope.size\', \'zope.structuredtext\',\n+  \'zope.tal\', \'zope.tales\', \'zope.testbrowser\', \'zope.testing\',\n+  \'zope.traversing\', \'zope.viewlet\'\n+]\n+\'Products.CMFCore\' = [\n+  \'docutils\', \'five.localsitemanager\', \'Missing\', \'Products.BTreeFolder2\',\n+  \'Products.GenericSetup\', \'Products.MailHost\', \'Products.PythonScripts\',\n+  \'Products.StandardCacheManagers\', \'Products.ZCatalog\', \'Record\',\n+  \'zope.sendmail\', \'Zope\'\n+]\n+\'plone.base\' = [\n+  \'plone.batching\', \'plone.registry\', \'plone.schema\',\'plone.z3cform\',\n+  \'Products.CMFCore\', \'Products.CMFDynamicViewFTI\',\n+]\n+python-dateutil = [\'dateutil\']\ndiff --git a/setup.cfg b/setup.cfg\nindex 3ee2840..0da8f8f 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,9 +1,23 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[bdist_wheel]\n+universal = 0\n+\n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n+\n [check-manifest]\n ignore =\n+    .editorconfig\n+    .meta.toml\n+    .pre-commit-config.yaml\n     tox.ini\n-\n-[bdist_wheel]\n-universal = 1\n-\n-[zest.releaser]\n-create-wheel = yes\ndiff --git a/tox.ini b/tox.ini\nindex 5b2fe14..c4521cf 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -1,10 +1,68 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tox]\n+# We need 4.4.0 for constrain_package_deps.\n+min_version = 4.4.0\n envlist =\n-    py27,py36,py37,py38\n+    format\n+    lint\n+    test\n \n [testenv]\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat code\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a pyupgrade\n+    pre-commit run -a isort\n+    pre-commit run -a black\n+    pre-commit run -a zpretty\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a\n+\n+[testenv:dependencies]\n+description = check if the package defines all its dependencies and generate a graph out of them\n+deps =\n+    z3c.dependencychecker==2.11\n+    pipdeptree==2.5.1\n+    graphviz  # optional dependency of pipdeptree\n+commands =\n+    dependencychecker\n+    sh -c \'pipdeptree --exclude setuptools,wheel,pipdeptree,z3c.dependencychecker,zope.interface,zope.component --graph-output svg > dependencies.svg\'\n+\n+[testenv:test]\n+usedevelop = true\n+constrain_package_deps = true\n+set_env = ROBOT_BROWSER=headlesschrome\n+deps =\n+    zope.testrunner\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    zope-testrunner --all --test-path={toxinidir} -s plone.event {posargs}\n+extras =\n+    test\n+\n+[testenv:coverage]\n+usedevelop = true\n+constrain_package_deps = true\n+set_env = ROBOT_BROWSER=headlesschrome\n deps =\n+    coverage\n     zope.testrunner\n-    .[test]\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n commands =\n-    zope-testrunner --test-path=. {posargs:-pvc}\n+    coverage run {envbindir}/zope-testrunner --all --test-path={toxinidir} -s plone.event {posargs}\n+    coverage report -m --format markdown\n+extras =\n+    test\n'

Repository: plone.event


Branch: refs/heads/master
Date: 2023-04-15T14:12:15+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.event/commit/4a341632aac6ac2cbd2cb5456013e3e2918de1ba

chore: pyupgrade

Files changed:
M plone/__init__.py
M plone/event/adapters.py
M plone/event/interfaces.py
M plone/event/recurrence.py
M plone/event/tests/test_adapters.py
M plone/event/tests/test_doctest.py
M plone/event/tests/test_recurrence_int_sequence.py
M plone/event/tests/test_recurrence_sequence_ical.py
M plone/event/tests/test_recurrence_sequence_timedelta.py
M plone/event/tests/test_utils.py
M plone/event/utils.py
M setup.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..de40ea7 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n __import__(\'pkg_resources\').declare_namespace(__name__)\ndiff --git a/plone/event/adapters.py b/plone/event/adapters.py\nindex 717657a..2ce3afc 100644\n--- a/plone/event/adapters.py\n+++ b/plone/event/adapters.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.event.interfaces import IEvent\n from plone.event.interfaces import IEventAccessor\n from zope.component import adapter\n@@ -7,7 +6,7 @@\n \n @implementer(IEventAccessor)\n @adapter(IEvent)\n-class EventAccessor(object):\n+class EventAccessor:\n     """Simple event accessor adapter implementation for generic events, which\n     follow the IEvent interface closely.\n \ndiff --git a/plone/event/interfaces.py b/plone/event/interfaces.py\nindex fa88995..8dc85bc 100644\n--- a/plone/event/interfaces.py\n+++ b/plone/event/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Attribute\n from zope.interface import Interface\n \n@@ -21,8 +20,8 @@ class IOccurrence(Interface):\n     occurrence.\n \n     """\n-    start = Attribute(u\'Occurrence start date\')\n-    end = Attribute(u\'Occurrence end date\')\n+    start = Attribute(\'Occurrence start date\')\n+    end = Attribute(\'Occurrence end date\')\n \n \n class ICalendarAccessor(Interface):\n@@ -31,11 +30,11 @@ class ICalendarAccessor(Interface):\n     A calendar is a collection of calendar components, like events.\n \n     """\n-    uid = Attribute(u\'UID of the calendar. Autogenerated, read only.\')\n+    uid = Attribute(\'UID of the calendar. Autogenerated, read only.\')\n     # rw attributes\n-    title = Attribute(u\'Calendar title.\')\n-    description = Attribute(u\'Calendar description text.\')\n-    timezone = Attribute(u\'Default timezone of the calendar.\')\n+    title = Attribute(\'Calendar title.\')\n+    description = Attribute(\'Calendar description text.\')\n+    timezone = Attribute(\'Default timezone of the calendar.\')\n \n     def items(self):\n         """Return a list of calendar component items, like events.\n@@ -52,34 +51,34 @@ class IEventAccessor(Interface):\n     """\n \n     # ro attributes\n-    uid = Attribute(u\'UID of the event. Autogenerated, read only.\')\n-    created = Attribute(u\'Python datetime of the event creation timestamp.\')\n-    duration = Attribute(u\'Duration of the event. Computed attribute.\')\n+    uid = Attribute(\'UID of the event. Autogenerated, read only.\')\n+    created = Attribute(\'Python datetime of the event creation timestamp.\')\n+    duration = Attribute(\'Duration of the event. Computed attribute.\')\n \n     # reference\n     url = Attribute(\n-        u\'Cannonical, unique url of the event. External events \'\n-        u\'are referenced by the origin url unless explicitly set.\'\n+        \'Cannonical, unique url of the event. External events \'\n+        \'are referenced by the origin url unless explicitly set.\'\n     )\n \n     # rw attributes\n-    last_modified = Attribute(u\'Last modified Python datetime.\')\n-    title = Attribute(u\'Event title.\')\n-    description = Attribute(u\'Event description text.\')\n-    start = Attribute(u\'Event start date as Python datetime.\')\n-    end = Attribute(u\'Event end date as Python datetime.\')\n-    whole_day = Attribute(u\'Event lasts whole day.\')\n-    open_end = Attribute(u\'Event has no defined end time.\')\n-    timezone = Attribute(u\'Timezone of the event. A pytz timezone identifier.\')\n-    recurrence = Attribute(u\'RFC5545 compatible recurrence definition.\')\n-    location = Attribute(u\'Location of the event.\')\n-    attendees = Attribute(u\'List of attendees.\')\n-    contact_name = Attribute(u\'Contact name.\')\n-    contact_email = Attribute(u\'Contact email.\')\n-    contact_phone = Attribute(u\'Contact phone.\')\n-    event_url = Attribute(u\'Website of the event.\')\n-    subjects = Attribute(u\'Categories.\')\n-    text = Attribute(u\'Body text of the event.\')\n+    last_modified = Attribute(\'Last modified Python datetime.\')\n+    title = Attribute(\'Event title.\')\n+    description = Attribute(\'Event description text.\')\n+    start = Attribute(\'Event start date as Python datetime.\')\n+    end = Attribute(\'Event end date as Python datetime.\')\n+    whole_day = Attribute(\'Event lasts whole day.\')\n+    open_end = Attribute(\'Event has no defined end time.\')\n+    timezone = Attribute(\'Timezone of the event. A pytz timezone identifier.\')\n+    recurrence = Attribute(\'RFC5545 compatible recurrence definition.\')\n+    location = Attribute(\'Location of the event.\')\n+    attendees = Attribute(\'List of attendees.\')\n+    contact_name = Attribute(\'Contact name.\')\n+    contact_email = Attribute(\'Contact email.\')\n+    contact_phone = Attribute(\'Contact phone.\')\n+    event_url = Attribute(\'Website of the event.\')\n+    subjects = Attribute(\'Categories.\')\n+    text = Attribute(\'Body text of the event.\')\n \n \n class IRecurrenceSupport(Interface):\n@@ -156,37 +155,37 @@ class / created / description / geo /\n     resources / rdate / x-prop / iana-prop\n \n     """\n-    dtstart = Attribute(u\'Start Date/Time\')\n-    dtend = Attribute(u\'End Date/Time\')\n-    duration = Attribute(u\'Duration\')\n-    rrule = Attribute(u\'Recurrence Rule\')\n-    description = Attribute(u\'Description\')\n-    location = Attribute(u\'Location\')\n-    summary = Attribute(u\'Summary\')\n-    url = Attribute(u\'Url\')\n-    attendee = Attribute(u\'Attendee\')\n-    categories = Attribute(u\'Categories\')\n-    contact = Attribute(u\'Contact\')\n-\n-    exdate = Attribute(u\'Exdate\')\n-    rdate = Attribute(u\'Rdate\')\n-\n-    dtstamp = Attribute(u\'Timestamp\')\n-    uid = Attribute(u\'Unique identifier\')\n-    klass = Attribute(u\'Class\')  # class\n-    created = Attribute(u\'Created\')\n-    geo = Attribute(u\'Geo\')\n-    last_mod = Attribute(u\'Last Modified\')  # last-mod\n-    organizer = Attribute(u\'Organizer\')\n-    priority = Attribute(u\'Priority\')\n-    seq = Attribute(u\'Seq\')\n-    status = Attribute(u\'Status\')\n-    transp = Attribute(u\'Transp\')\n-    recurid = Attribute(u\'Recurid\')\n-    attach = Attribute(u\'Attach\')\n-    comment = Attribute(u\'Comment\')\n-    rstatus = Attribute(u\'Rstatus\')\n-    related = Attribute(u\'Related\')\n-    resources = Attribute(u\'Resources\')\n-    x_prop = Attribute(u\'X Prop\')  # x-prop\n-    iana_prop = Attribute(u\'Iana Prop\')  # iana-prop\n+    dtstart = Attribute(\'Start Date/Time\')\n+    dtend = Attribute(\'End Date/Time\')\n+    duration = Attribute(\'Duration\')\n+    rrule = Attribute(\'Recurrence Rule\')\n+    description = Attribute(\'Description\')\n+    location = Attribute(\'Location\')\n+    summary = Attribute(\'Summary\')\n+    url = Attribute(\'Url\')\n+    attendee = Attribute(\'Attendee\')\n+    categories = Attribute(\'Categories\')\n+    contact = Attribute(\'Contact\')\n+\n+    exdate = Attribute(\'Exdate\')\n+    rdate = Attribute(\'Rdate\')\n+\n+    dtstamp = Attribute(\'Timestamp\')\n+    uid = Attribute(\'Unique identifier\')\n+    klass = Attribute(\'Class\')  # class\n+    created = Attribute(\'Created\')\n+    geo = Attribute(\'Geo\')\n+    last_mod = Attribute(\'Last Modified\')  # last-mod\n+    organizer = Attribute(\'Organizer\')\n+    priority = Attribute(\'Priority\')\n+    seq = Attribute(\'Seq\')\n+    status = Attribute(\'Status\')\n+    transp = Attribute(\'Transp\')\n+    recurid = Attribute(\'Recurid\')\n+    attach = Attribute(\'Attach\')\n+    comment = Attribute(\'Comment\')\n+    rstatus = Attribute(\'Rstatus\')\n+    related = Attribute(\'Related\')\n+    resources = Attribute(\'Resources\')\n+    x_prop = Attribute(\'X Prop\')  # x-prop\n+    iana_prop = Attribute(\'Iana Prop\')  # iana-prop\ndiff --git a/plone/event/recurrence.py b/plone/event/recurrence.py\nindex 0bb42ce..7dd27ea 100644\n--- a/plone/event/recurrence.py\n+++ b/plone/event/recurrence.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from dateutil import rrule\n from plone.event.utils import DSTAUTO\n from plone.event.utils import dt2int\n@@ -88,7 +87,7 @@ def recurrence_sequence_ical(\n         # time for UNTIL, RDATE and EXDATE.\n         t0 = start.time()  # set initial time information.\n         # First, replace all times in the recurring rule with starttime\n-        t0str = \'T{0:02d}{1:02d}{2:02d}\'.format(t0.hour, t0.minute, t0.second)\n+        t0str = f\'T{t0.hour:02d}{t0.minute:02d}{t0.second:02d}\'\n         # Replace any times set to 000000 with start time, not all\n         # rrules are set by a specific broken widget.  Don\'t waste time\n         # subbing if the start time is already 000000.\ndiff --git a/plone/event/tests/test_adapters.py b/plone/event/tests/test_adapters.py\nindex b302192..ad51528 100644\n--- a/plone/event/tests/test_adapters.py\n+++ b/plone/event/tests/test_adapters.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import datetime\n from plone.event.interfaces import IEvent\n from plone.event.interfaces import IEventAccessor\n@@ -9,7 +8,7 @@\n import zope.interface\n \n \n-class MockObject(object):\n+class MockObject:\n     """Mock object"""\n \n \ndiff --git a/plone/event/tests/test_doctest.py b/plone/event/tests/test_doctest.py\nindex 77ab9e1..001e083 100644\n--- a/plone/event/tests/test_doctest.py\n+++ b/plone/event/tests/test_doctest.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.component.testing import tearDown\n \n import doctest\ndiff --git a/plone/event/tests/test_recurrence_int_sequence.py b/plone/event/tests/test_recurrence_int_sequence.py\nindex ccd072c..00f7ec8 100644\n--- a/plone/event/tests/test_recurrence_int_sequence.py\n+++ b/plone/event/tests/test_recurrence_int_sequence.py\n@@ -1,5 +1,4 @@\n-# -*- coding: utf-8 -*-\n-import mock\n+from unittest import mock\n import unittest\n \n \ndiff --git a/plone/event/tests/test_recurrence_sequence_ical.py b/plone/event/tests/test_recurrence_sequence_ical.py\nindex 6f2ed8e..679cb77 100644\n--- a/plone/event/tests/test_recurrence_sequence_ical.py\n+++ b/plone/event/tests/test_recurrence_sequence_ical.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n import unittest\n \n \ndiff --git a/plone/event/tests/test_recurrence_sequence_timedelta.py b/plone/event/tests/test_recurrence_sequence_timedelta.py\nindex c9493f7..9cc407a 100644\n--- a/plone/event/tests/test_recurrence_sequence_timedelta.py\n+++ b/plone/event/tests/test_recurrence_sequence_timedelta.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n import unittest\n \n \ndiff --git a/plone/event/tests/test_utils.py b/plone/event/tests/test_utils.py\nindex f90fedd..f2a8e7e 100644\n--- a/plone/event/tests/test_utils.py\n+++ b/plone/event/tests/test_utils.py\n@@ -1,5 +1,4 @@\n-# -*- coding: utf-8 -*-\n-import mock\n+from unittest import mock\n import unittest\n \n \ndiff --git a/plone/event/utils.py b/plone/event/utils.py\nindex 0763205..389a733 100644\n--- a/plone/event/utils.py\n+++ b/plone/event/utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import date\n from datetime import datetime\n from datetime import timedelta\n@@ -59,8 +58,8 @@ def validated_timezone(timezone, fallback=None):\n     except Exception:\n         if fallback:\n             logger.warn(\n-                "The timezone {0} is not a valid timezone from the "\n-                "Olson database or pytz. Falling back to {1}.".format(\n+                "The timezone {} is not a valid timezone from the "\n+                "Olson database or pytz. Falling back to {}.".format(\n                     timezone,\n                     fallback,\n                 )\n@@ -68,7 +67,7 @@ def validated_timezone(timezone, fallback=None):\n             return fallback\n         else:\n             raise ValueError(\n-                "The timezone {0} is not a valid timezone from "\n+                "The timezone {} is not a valid timezone from "\n                 "the Olson database or pytz.".format(timezone)\n             )\n \n@@ -558,7 +557,7 @@ def dt2int(dt):\n     if value > MAX32:\n         # value must be integer fitting in the 32bit range\n         raise OverflowError(\n-            """{0} is not within the range of indexable dates,<<\n+            """{} is not within the range of indexable dates,<<\n             exceeding 32bit range.""".format(\n                 dt\n             )\n@@ -663,7 +662,7 @@ def rfc2445dt(dt, mode="utc", date=True, time=True):\n     dt = pydt(dt)\n     if mode == "utc":\n         dt = utc(dt)\n-    date = "{0}{1}{2}{3}".format(\n+    date = "{}{}{}{}".format(\n         date and dt.strftime("%Y%m%d") or "",\n         date and time and "T" or "",\n         time and dt.strftime("%H%M%S") or "",\ndiff --git a/setup.py b/setup.py\nindex 05d6d46..93f57df 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n@@ -10,7 +9,7 @@\n     version=version,\n     description="Event and calendaring related tools not bound to Plone",\n     long_description=(\n-        open("README.rst").read() + "\\n" + open(("CHANGES.rst")).read()\n+        open("README.rst").read() + "\\n" + open("CHANGES.rst").read()\n     ),\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n'

Repository: plone.event


Branch: refs/heads/master
Date: 2023-04-15T14:12:42+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.event/commit/894078e617c0fdaf9526b559e0829fca897e807c

chore: isort

Files changed:
M plone/event/tests/test_recurrence_int_sequence.py
M plone/event/tests/test_recurrence_sequence_ical.py
M plone/event/tests/test_recurrence_sequence_timedelta.py
M plone/event/tests/test_utils.py

b'diff --git a/plone/event/tests/test_recurrence_int_sequence.py b/plone/event/tests/test_recurrence_int_sequence.py\nindex 00f7ec8..b858a9c 100644\n--- a/plone/event/tests/test_recurrence_int_sequence.py\n+++ b/plone/event/tests/test_recurrence_int_sequence.py\n@@ -1,4 +1,5 @@\n from unittest import mock\n+\n import unittest\n \n \ndiff --git a/plone/event/tests/test_recurrence_sequence_ical.py b/plone/event/tests/test_recurrence_sequence_ical.py\nindex 679cb77..ae08c8f 100644\n--- a/plone/event/tests/test_recurrence_sequence_ical.py\n+++ b/plone/event/tests/test_recurrence_sequence_ical.py\n@@ -3,16 +3,16 @@\n \n class TestRecurrenceSequenceIcal(unittest.TestCase):\n     def test_start(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n         start = datetime(2011, 11, 23)\n         seq = recurrence_sequence_ical(start)\n         results = [res for res in seq]\n         self.assertEqual(len(results), 1)\n \n     def test_recrule_str(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n         start = datetime(2011, 11, 23)\n         recrule = \'FREQ=DAILY;INTERVAL=10;COUNT=5\'\n         seq = recurrence_sequence_ical(start, recrule=recrule)\n@@ -23,8 +23,8 @@ def test_recrule_str_rdate(self):\n         """Test, if an RDATE date has the correct time set.\n             See: "BUGFIX WRONG RDATE TIME" in recurrence.py\n         """\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n         start = datetime(2011, 11, 23, 10, 10)\n         recrule = """FREQ=DAILY;INTERVAL=1;COUNT=3\n RDATE:20111129T000000"""\n@@ -36,8 +36,9 @@ def test_recrule_str_rdate(self):\n     def test_recrule_str_exdate(self):\n         """Test, if an EXDATE date are not in the resulting recurrence set.\n         """\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n+\n         import pytz\n         at = pytz.timezone(\'Europe/Vienna\')\n         start = at.localize(datetime(2013, 6, 29, 10, 10))\n@@ -57,8 +58,9 @@ def test_recrule_str_until(self):\n         """Test, if UNTIL stops the sequence at the end of the day, even if\n         it\'s set to 0:00 by the recurrence widget.\n         """\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n+\n         import pytz\n         at = pytz.timezone(\'Europe/Vienna\')\n         start = at.localize(datetime(2013, 6, 29, 10, 10))\n@@ -75,8 +77,8 @@ def test_recrule_str_until(self):\n         self.assertEqual(res, res_test)\n \n     def test_recrule_from_until(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n         start = datetime(2011, 11, 23)\n         recrule = None\n         from_ = datetime(2011, 11, 1)\n@@ -91,8 +93,8 @@ def test_recrule_from_until(self):\n         self.assertEqual(len(results), 1)\n \n     def test_recrule_str_more_than_MAXCOUNT(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n         start = datetime(2011, 11, 23)\n         recrule = \'FREQ=DAILY;INTERVAL=10;COUNT=1001\'\n         seq = recurrence_sequence_ical(start, recrule=recrule)\n@@ -100,8 +102,8 @@ def test_recrule_str_more_than_MAXCOUNT(self):\n         self.assertEqual(len(results), 1000)\n \n     def test_recrule_str_more_than_count(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n         start = datetime(2011, 11, 23)\n         recrule = \'FREQ=DAILY;INTERVAL=10;COUNT=10\'\n         count = 5\n@@ -110,8 +112,8 @@ def test_recrule_str_more_than_count(self):\n         self.assertEqual(len(results), 5)\n \n     def test_recrule_from(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n         start = datetime(2011, 11, 23)\n         recrule = \'FREQ=DAILY;INTERVAL=1;COUNT=5\'\n         from_ = datetime(2011, 11, 25)\n@@ -126,8 +128,8 @@ def test_recrule_from(self):\n         self.assertEqual(len(results), 3)\n \n     def test_recrule_until(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n         start = datetime(2011, 11, 24)\n         recrule = \'FREQ=DAILY;INTERVAL=1;COUNT=5\'\n         from_ = datetime(2011, 11, 23)\n@@ -144,9 +146,9 @@ def test_recrule_until(self):\n     def test_recrule_from_until_with_duration(self):\n         """Should include events ranging into the queried timerange.\n         """\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n         from datetime import timedelta\n+        from plone.event.recurrence import recurrence_sequence_ical\n         start = datetime(2011, 11, 23)\n         recrule = \'FREQ=DAILY;INTERVAL=1;COUNT=5\'\n         from_ = datetime(2011, 11, 26)\n@@ -162,8 +164,8 @@ def test_recrule_from_until_with_duration(self):\n         self.assertEqual(len(results), 4)\n \n     def test_recrule_until_with_timezone(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n \n         start = datetime(2011, 11, 24)\n         recrule = \'RRULE:FREQ=DAILY;UNTIL=20111130T000000Z\'\ndiff --git a/plone/event/tests/test_recurrence_sequence_timedelta.py b/plone/event/tests/test_recurrence_sequence_timedelta.py\nindex 9cc407a..fdb21af 100644\n--- a/plone/event/tests/test_recurrence_sequence_timedelta.py\n+++ b/plone/event/tests/test_recurrence_sequence_timedelta.py\n@@ -3,8 +3,8 @@\n \n class TestRecurrenceSequenceTimedelta(unittest.TestCase):\n     def test_delta_None(self):\n-        from plone.event.recurrence import recurrence_sequence_timedelta\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_timedelta\n         start = datetime(2011, 11, 23)\n         until = datetime(2011, 11, 24)\n         td = recurrence_sequence_timedelta(start, until=until)\n@@ -12,8 +12,8 @@ def test_delta_None(self):\n         self.assertEqual(len(results), 1)\n \n     def test_delta_zero(self):\n-        from plone.event.recurrence import recurrence_sequence_timedelta\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_timedelta\n         start = datetime(2011, 11, 23)\n         delta = 0\n         until = datetime(2011, 11, 24)\n@@ -22,8 +22,8 @@ def test_delta_zero(self):\n         self.assertEqual(len(results), 1)\n \n     def test_until_None(self):\n-        from plone.event.recurrence import recurrence_sequence_timedelta\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_timedelta\n         start = datetime(2011, 11, 23)\n         delta = 1\n         td = recurrence_sequence_timedelta(start, delta=delta)\n@@ -31,8 +31,8 @@ def test_until_None(self):\n         self.assertEqual(len(results), 1)\n \n     def test_delta_an_hour_until_next_day(self):\n-        from plone.event.recurrence import recurrence_sequence_timedelta\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_timedelta\n         start = datetime(2011, 11, 23)\n         delta = 60\n         until = datetime(2011, 11, 24)\n@@ -41,8 +41,8 @@ def test_delta_an_hour_until_next_day(self):\n         self.assertEqual(len(results), 25)\n \n     def test_recur_more_than_MAXCOUNT(self):\n-        from plone.event.recurrence import recurrence_sequence_timedelta\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_timedelta\n         start = datetime(2011, 11, 23)\n         delta = 1\n         until = datetime(2012, 11, 23)\n@@ -51,8 +51,8 @@ def test_recur_more_than_MAXCOUNT(self):\n         self.assertEqual(len(results), 1001)\n \n     def test_recur_more_than_count(self):\n-        from plone.event.recurrence import recurrence_sequence_timedelta\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_timedelta\n         start = datetime(2011, 11, 23)\n         delta = 1\n         until = datetime(2011, 11, 24)\ndiff --git a/plone/event/tests/test_utils.py b/plone/event/tests/test_utils.py\nindex f2a8e7e..0576920 100644\n--- a/plone/event/tests/test_utils.py\n+++ b/plone/event/tests/test_utils.py\n@@ -1,4 +1,5 @@\n from unittest import mock\n+\n import unittest\n \n \n'

Repository: plone.event


Branch: refs/heads/master
Date: 2023-04-15T14:13:22+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.event/commit/dfc81ff143aa27cb7fdca0196cf8a34c31fd1eb6

chore: black

Files changed:
M plone/__init__.py
M plone/event/adapters.py
M plone/event/interfaces.py
M plone/event/recurrence.py
M plone/event/tests/test_adapters.py
M plone/event/tests/test_doctest.py
M plone/event/tests/test_recurrence_int_sequence.py
M plone/event/tests/test_recurrence_sequence_ical.py
M plone/event/tests/test_recurrence_sequence_timedelta.py
M plone/event/tests/test_utils.py
M setup.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex de40ea7..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1 +1 @@\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/event/adapters.py b/plone/event/adapters.py\nindex 2ce3afc..2549298 100644\n--- a/plone/event/adapters.py\n+++ b/plone/event/adapters.py\n@@ -14,7 +14,7 @@ class EventAccessor:\n     """\n \n     def __init__(self, context):\n-        object.__setattr__(self, \'context\', context)\n+        object.__setattr__(self, "context", context)\n \n     def __getattr__(self, name):\n         return getattr(self.context, name)\ndiff --git a/plone/event/interfaces.py b/plone/event/interfaces.py\nindex 8dc85bc..5f3af6e 100644\n--- a/plone/event/interfaces.py\n+++ b/plone/event/interfaces.py\n@@ -3,9 +3,7 @@\n \n \n class IEvent(Interface):\n-    """Event type marker interface.\n-\n-    """\n+    """Event type marker interface."""\n \n \n class IEventRecurrence(Interface):\n@@ -20,8 +18,9 @@ class IOccurrence(Interface):\n     occurrence.\n \n     """\n-    start = Attribute(\'Occurrence start date\')\n-    end = Attribute(\'Occurrence end date\')\n+\n+    start = Attribute("Occurrence start date")\n+    end = Attribute("Occurrence end date")\n \n \n class ICalendarAccessor(Interface):\n@@ -30,16 +29,15 @@ class ICalendarAccessor(Interface):\n     A calendar is a collection of calendar components, like events.\n \n     """\n-    uid = Attribute(\'UID of the calendar. Autogenerated, read only.\')\n+\n+    uid = Attribute("UID of the calendar. Autogenerated, read only.")\n     # rw attributes\n-    title = Attribute(\'Calendar title.\')\n-    description = Attribute(\'Calendar description text.\')\n-    timezone = Attribute(\'Default timezone of the calendar.\')\n+    title = Attribute("Calendar title.")\n+    description = Attribute("Calendar description text.")\n+    timezone = Attribute("Default timezone of the calendar.")\n \n     def items(self):\n-        """Return a list of calendar component items, like events.\n-\n-        """\n+        """Return a list of calendar component items, like events."""\n \n \n class IEventAccessor(Interface):\n@@ -51,40 +49,38 @@ class IEventAccessor(Interface):\n     """\n \n     # ro attributes\n-    uid = Attribute(\'UID of the event. Autogenerated, read only.\')\n-    created = Attribute(\'Python datetime of the event creation timestamp.\')\n-    duration = Attribute(\'Duration of the event. Computed attribute.\')\n+    uid = Attribute("UID of the event. Autogenerated, read only.")\n+    created = Attribute("Python datetime of the event creation timestamp.")\n+    duration = Attribute("Duration of the event. Computed attribute.")\n \n     # reference\n     url = Attribute(\n-        \'Cannonical, unique url of the event. External events \'\n-        \'are referenced by the origin url unless explicitly set.\'\n+        "Cannonical, unique url of the event. External events "\n+        "are referenced by the origin url unless explicitly set."\n     )\n \n     # rw attributes\n-    last_modified = Attribute(\'Last modified Python datetime.\')\n-    title = Attribute(\'Event title.\')\n-    description = Attribute(\'Event description text.\')\n-    start = Attribute(\'Event start date as Python datetime.\')\n-    end = Attribute(\'Event end date as Python datetime.\')\n-    whole_day = Attribute(\'Event lasts whole day.\')\n-    open_end = Attribute(\'Event has no defined end time.\')\n-    timezone = Attribute(\'Timezone of the event. A pytz timezone identifier.\')\n-    recurrence = Attribute(\'RFC5545 compatible recurrence definition.\')\n-    location = Attribute(\'Location of the event.\')\n-    attendees = Attribute(\'List of attendees.\')\n-    contact_name = Attribute(\'Contact name.\')\n-    contact_email = Attribute(\'Contact email.\')\n-    contact_phone = Attribute(\'Contact phone.\')\n-    event_url = Attribute(\'Website of the event.\')\n-    subjects = Attribute(\'Categories.\')\n-    text = Attribute(\'Body text of the event.\')\n+    last_modified = Attribute("Last modified Python datetime.")\n+    title = Attribute("Event title.")\n+    description = Attribute("Event description text.")\n+    start = Attribute("Event start date as Python datetime.")\n+    end = Attribute("Event end date as Python datetime.")\n+    whole_day = Attribute("Event lasts whole day.")\n+    open_end = Attribute("Event has no defined end time.")\n+    timezone = Attribute("Timezone of the event. A pytz timezone identifier.")\n+    recurrence = Attribute("RFC5545 compatible recurrence definition.")\n+    location = Attribute("Location of the event.")\n+    attendees = Attribute("List of attendees.")\n+    contact_name = Attribute("Contact name.")\n+    contact_email = Attribute("Contact email.")\n+    contact_phone = Attribute("Contact phone.")\n+    event_url = Attribute("Website of the event.")\n+    subjects = Attribute("Categories.")\n+    text = Attribute("Body text of the event.")\n \n \n class IRecurrenceSupport(Interface):\n-    """Event type recurrence adatper.\n-\n-    """\n+    """Event type recurrence adatper."""\n \n     def occurrences(self, range_start, range_end):\n         """Return a list of IOccurrence objects with custom attributes of the\n@@ -100,9 +96,7 @@ def occurrences(self, range_start, range_end):\n \n \n class IICalendar(Interface):\n-    """Adapter, which is used to construct an icalendar object.\n-\n-    """\n+    """Adapter, which is used to construct an icalendar object."""\n \n \n class IICalendarEventComponent(Interface):\n@@ -155,37 +149,38 @@ class / created / description / geo /\n     resources / rdate / x-prop / iana-prop\n \n     """\n-    dtstart = Attribute(\'Start Date/Time\')\n-    dtend = Attribute(\'End Date/Time\')\n-    duration = Attribute(\'Duration\')\n-    rrule = Attribute(\'Recurrence Rule\')\n-    description = Attribute(\'Description\')\n-    location = Attribute(\'Location\')\n-    summary = Attribute(\'Summary\')\n-    url = Attribute(\'Url\')\n-    attendee = Attribute(\'Attendee\')\n-    categories = Attribute(\'Categories\')\n-    contact = Attribute(\'Contact\')\n-\n-    exdate = Attribute(\'Exdate\')\n-    rdate = Attribute(\'Rdate\')\n-\n-    dtstamp = Attribute(\'Timestamp\')\n-    uid = Attribute(\'Unique identifier\')\n-    klass = Attribute(\'Class\')  # class\n-    created = Attribute(\'Created\')\n-    geo = Attribute(\'Geo\')\n-    last_mod = Attribute(\'Last Modified\')  # last-mod\n-    organizer = Attribute(\'Organizer\')\n-    priority = Attribute(\'Priority\')\n-    seq = Attribute(\'Seq\')\n-    status = Attribute(\'Status\')\n-    transp = Attribute(\'Transp\')\n-    recurid = Attribute(\'Recurid\')\n-    attach = Attribute(\'Attach\')\n-    comment = Attribute(\'Comment\')\n-    rstatus = Attribute(\'Rstatus\')\n-    related = Attribute(\'Related\')\n-    resources = Attribute(\'Resources\')\n-    x_prop = Attribute(\'X Prop\')  # x-prop\n-    iana_prop = Attribute(\'Iana Prop\')  # iana-prop\n+\n+    dtstart = Attribute("Start Date/Time")\n+    dtend = Attribute("End Date/Time")\n+    duration = Attribute("Duration")\n+    rrule = Attribute("Recurrence Rule")\n+    description = Attribute("Description")\n+    location = Attribute("Location")\n+    summary = Attribute("Summary")\n+    url = Attribute("Url")\n+    attendee = Attribute("Attendee")\n+    categories = Attribute("Categories")\n+    contact = Attribute("Contact")\n+\n+    exdate = Attribute("Exdate")\n+    rdate = Attribute("Rdate")\n+\n+    dtstamp = Attribute("Timestamp")\n+    uid = Attribute("Unique identifier")\n+    klass = Attribute("Class")  # class\n+    created = Attribute("Created")\n+    geo = Attribute("Geo")\n+    last_mod = Attribute("Last Modified")  # last-mod\n+    organizer = Attribute("Organizer")\n+    priority = Attribute("Priority")\n+    seq = Attribute("Seq")\n+    status = Attribute("Status")\n+    transp = Attribute("Transp")\n+    recurid = Attribute("Recurid")\n+    attach = Attribute("Attach")\n+    comment = Attribute("Comment")\n+    rstatus = Attribute("Rstatus")\n+    related = Attribute("Related")\n+    resources = Attribute("Resources")\n+    x_prop = Attribute("X Prop")  # x-prop\n+    iana_prop = Attribute("Iana Prop")  # iana-prop\ndiff --git a/plone/event/recurrence.py b/plone/event/recurrence.py\nindex 7dd27ea..e2b528b 100644\n--- a/plone/event/recurrence.py\n+++ b/plone/event/recurrence.py\n@@ -15,12 +15,12 @@\n \n \n def recurrence_sequence_ical(\n-        start,\n-        recrule=None,\n-        from_=None,\n-        until=None,\n-        count=None,\n-        duration=None,\n+    start,\n+    recrule=None,\n+    from_=None,\n+    until=None,\n+    count=None,\n+    duration=None,\n ):\n     """Calculates a sequence of datetime objects from a recurrence rule\n     following the RFC2445 specification, using python-dateutil recurrence\n@@ -67,7 +67,7 @@ def recurrence_sequence_ical(\n     _from = tzdel(from_)\n     _until = tzdel(until)\n     if duration:\n-        assert (isinstance(duration, datetime.timedelta))\n+        assert isinstance(duration, datetime.timedelta)\n     else:\n         duration = datetime.timedelta(0)\n \n@@ -87,16 +87,16 @@ def recurrence_sequence_ical(\n         # time for UNTIL, RDATE and EXDATE.\n         t0 = start.time()  # set initial time information.\n         # First, replace all times in the recurring rule with starttime\n-        t0str = f\'T{t0.hour:02d}{t0.minute:02d}{t0.second:02d}\'\n+        t0str = f"T{t0.hour:02d}{t0.minute:02d}{t0.second:02d}"\n         # Replace any times set to 000000 with start time, not all\n         # rrules are set by a specific broken widget.  Don\'t waste time\n         # subbing if the start time is already 000000.\n-        if t0str != \'T000000\':\n-            recrule = re.sub(r\'T000000\', t0str, recrule)\n+        if t0str != "T000000":\n+            recrule = re.sub(r"T000000", t0str, recrule)\n         # Then, replace incorrect until times with the end of the day\n         recrule = re.sub(\n-            r\'(UNTIL[^T]*[0-9]{8})T(000000)\',\n-            r\'\\1T235959\',\n+            r"(UNTIL[^T]*[0-9]{8})T(000000)",\n+            r"\\1T235959",\n             recrule,\n         )\n \n@@ -140,13 +140,13 @@ def recurrence_sequence_ical(\n \n \n def recurrence_sequence_timedelta(\n-        start,\n-        delta=None,\n-        until=None,\n-        count=None,\n-        dst=DSTAUTO,\n+    start,\n+    delta=None,\n+    until=None,\n+    count=None,\n+    dst=DSTAUTO,\n ):\n-    """ Calculates a sequence of datetime objects from a timedelta integer,\n+    """Calculates a sequence of datetime objects from a timedelta integer,\n     which defines the minutes between each occurence.\n \n     :param start: datetime or DateTime instance of the date from which the\n@@ -204,7 +204,7 @@ def recurrence_sequence_timedelta(\n \n \n def recurrence_int_sequence(sequence):\n-    """ Generates a sequence of integer representations from a sequence of\n+    """Generates a sequence of integer representations from a sequence of\n     dateime instances.\n \n     :param sequence: An iterable sequence of datetime instances.\ndiff --git a/plone/event/tests/test_adapters.py b/plone/event/tests/test_adapters.py\nindex ad51528..df92e79 100644\n--- a/plone/event/tests/test_adapters.py\n+++ b/plone/event/tests/test_adapters.py\n@@ -15,15 +15,17 @@ class MockObject:\n class TestAdapters(unittest.TestCase):\n     def setUp(self):\n         import zope.component\n-        context = xmlconfig.file(\'meta.zcml\', zope.component)\n-        xmlconfig.file(\'configure.zcml\', zope.component, context=context)\n+\n+        context = xmlconfig.file("meta.zcml", zope.component)\n+        xmlconfig.file("configure.zcml", zope.component, context=context)\n \n         import plone.event\n-        xmlconfig.file(\'configure.zcml\', plone.event, context=context)\n+\n+        xmlconfig.file("configure.zcml", plone.event, context=context)\n \n     def test_event_accessor(self):\n         obj = MockObject()\n-        tz = pytz.timezone(\'Europe/Vienna\')\n+        tz = pytz.timezone("Europe/Vienna")\n         obj.start = datetime(2012, 12, 12, 10, 0, tzinfo=tz)\n         obj.end = datetime(2012, 12, 12, 12, 0, tzinfo=tz)\n         zope.interface.alsoProvides(obj, IEvent)\n@@ -48,9 +50,9 @@ def test_event_accessor(self):\n         acc.something = True\n         self.assertTrue(acc.something == obj.something is True)\n         del acc.something\n-        self.assertTrue(hasattr(acc, \'something\') is False)\n-        self.assertTrue(hasattr(obj, \'something\') is False)\n+        self.assertTrue(hasattr(acc, "something") is False)\n+        self.assertTrue(hasattr(obj, "something") is False)\n \n         del acc.start\n-        self.assertTrue(hasattr(acc, \'start\') is False)\n-        self.assertTrue(hasattr(obj, \'start\') is False)\n+        self.assertTrue(hasattr(acc, "start") is False)\n+        self.assertTrue(hasattr(obj, "start") is False)\ndiff --git a/plone/event/tests/test_doctest.py b/plone/event/tests/test_doctest.py\nindex 001e083..6e7b759 100644\n--- a/plone/event/tests/test_doctest.py\n+++ b/plone/event/tests/test_doctest.py\n@@ -7,11 +7,13 @@\n \n OPTIONFLAGS = doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS\n DOCFILES = [\n-    \'recurrence.rst\',\n-    \'recurrence_dateutil.rst\',\n-    \'utils.rst\',\n+    "recurrence.rst",\n+    "recurrence_dateutil.rst",\n+    "utils.rst",\n+]\n+DOCMODS = [\n+    "plone.event.utils",\n ]\n-DOCMODS = [\'plone.event.utils\', ]\n \n \n def test_suite():\n@@ -19,24 +21,19 @@ def test_suite():\n     suite.addTests(\n         [\n             doctest.DocFileSuite(\n-                os.path.join(os.path.dirname(__file__), \'..\', docfile),\n+                os.path.join(os.path.dirname(__file__), "..", docfile),\n                 module_relative=False,\n                 optionflags=OPTIONFLAGS,\n-                tearDown=tearDown\n+                tearDown=tearDown,\n             )\n             for docfile in DOCFILES\n         ]\n     )\n     suite.addTests(\n-        [\n-            doctest.DocTestSuite(\n-                docmod, optionflags=OPTIONFLAGS\n-            )\n-            for docmod in DOCMODS\n-        ]\n+        [doctest.DocTestSuite(docmod, optionflags=OPTIONFLAGS) for docmod in DOCMODS]\n     )\n     return suite\n \n \n-if __name__ == \'__main__\':\n-    unittest.main(defaultTest=\'test_suite\')\n+if __name__ == "__main__":\n+    unittest.main(defaultTest="test_suite")\ndiff --git a/plone/event/tests/test_recurrence_int_sequence.py b/plone/event/tests/test_recurrence_int_sequence.py\nindex b858a9c..9812fb4 100644\n--- a/plone/event/tests/test_recurrence_int_sequence.py\n+++ b/plone/event/tests/test_recurrence_int_sequence.py\n@@ -4,10 +4,11 @@\n \n \n class TestRecurrenceIntSequence(unittest.TestCase):\n-    @mock.patch(\'plone.event.recurrence.dt2int\')\n+    @mock.patch("plone.event.recurrence.dt2int")\n     def test_recrule_str_(self, dt2int):\n         from plone.event.recurrence import recurrence_int_sequence\n+\n         sequence = [1, 2, 3]\n-        dt2int.return_value = \'a\'\n+        dt2int.return_value = "a"\n         res = [a for a in recurrence_int_sequence(sequence)]\n-        self.assertEqual(res, [\'a\', \'a\', \'a\'])\n+        self.assertEqual(res, ["a", "a", "a"])\ndiff --git a/plone/event/tests/test_recurrence_sequence_ical.py b/plone/event/tests/test_recurrence_sequence_ical.py\nindex ae08c8f..25f1887 100644\n--- a/plone/event/tests/test_recurrence_sequence_ical.py\n+++ b/plone/event/tests/test_recurrence_sequence_ical.py\n@@ -5,6 +5,7 @@ class TestRecurrenceSequenceIcal(unittest.TestCase):\n     def test_start(self):\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n         seq = recurrence_sequence_ical(start)\n         results = [res for res in seq]\n@@ -13,18 +14,20 @@ def test_start(self):\n     def test_recrule_str(self):\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n-        recrule = \'FREQ=DAILY;INTERVAL=10;COUNT=5\'\n+        recrule = "FREQ=DAILY;INTERVAL=10;COUNT=5"\n         seq = recurrence_sequence_ical(start, recrule=recrule)\n         results = [res for res in seq]\n         self.assertEqual(len(results), 5)\n \n     def test_recrule_str_rdate(self):\n         """Test, if an RDATE date has the correct time set.\n-            See: "BUGFIX WRONG RDATE TIME" in recurrence.py\n+        See: "BUGFIX WRONG RDATE TIME" in recurrence.py\n         """\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23, 10, 10)\n         recrule = """FREQ=DAILY;INTERVAL=1;COUNT=3\n RDATE:20111129T000000"""\n@@ -34,22 +37,22 @@ def test_recrule_str_rdate(self):\n         self.assertEqual(results[0].time(), results[-1].time())\n \n     def test_recrule_str_exdate(self):\n-        """Test, if an EXDATE date are not in the resulting recurrence set.\n-        """\n+        """Test, if an EXDATE date are not in the resulting recurrence set."""\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_ical\n \n         import pytz\n-        at = pytz.timezone(\'Europe/Vienna\')\n+\n+        at = pytz.timezone("Europe/Vienna")\n         start = at.localize(datetime(2013, 6, 29, 10, 10))\n-        recrule = \'RRULE:FREQ=DAILY;COUNT=4\\r\\nEXDATE:20130630T000000,20130701T000000\\r\\nRDATE:20130706T000000,20130809T000000\'  # noqa\n+        recrule = "RRULE:FREQ=DAILY;COUNT=4\\r\\nEXDATE:20130630T000000,20130701T000000\\r\\nRDATE:20130706T000000,20130809T000000"  # noqa\n         seq = recurrence_sequence_ical(start, recrule=recrule)\n         res = [res for res in seq]\n         res_test = [\n             at.localize(datetime(2013, 6, 29, 10, 10)),\n             at.localize(datetime(2013, 7, 2, 10, 10)),\n             at.localize(datetime(2013, 7, 6, 10, 10)),\n-            at.localize(datetime(2013, 8, 9, 10, 10))\n+            at.localize(datetime(2013, 8, 9, 10, 10)),\n         ]\n         self.assertEqual(len(res), 4)\n         self.assertEqual(res, res_test)\n@@ -62,16 +65,17 @@ def test_recrule_str_until(self):\n         from plone.event.recurrence import recurrence_sequence_ical\n \n         import pytz\n-        at = pytz.timezone(\'Europe/Vienna\')\n+\n+        at = pytz.timezone("Europe/Vienna")\n         start = at.localize(datetime(2013, 6, 29, 10, 10))\n-        recrule = \'RRULE:FREQ=DAILY;UNTIL=20130702T000000\'\n+        recrule = "RRULE:FREQ=DAILY;UNTIL=20130702T000000"\n         seq = recurrence_sequence_ical(start, recrule=recrule)\n         res = [res for res in seq]\n         res_test = [\n             at.localize(datetime(2013, 6, 29, 10, 10)),\n             at.localize(datetime(2013, 6, 30, 10, 10)),\n             at.localize(datetime(2013, 7, 1, 10, 10)),\n-            at.localize(datetime(2013, 7, 2, 10, 10))\n+            at.localize(datetime(2013, 7, 2, 10, 10)),\n         ]\n         self.assertEqual(len(res), 4)\n         self.assertEqual(res, res_test)\n@@ -79,6 +83,7 @@ def test_recrule_str_until(self):\n     def test_recrule_from_until(self):\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n         recrule = None\n         from_ = datetime(2011, 11, 1)\n@@ -95,8 +100,9 @@ def test_recrule_from_until(self):\n     def test_recrule_str_more_than_MAXCOUNT(self):\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n-        recrule = \'FREQ=DAILY;INTERVAL=10;COUNT=1001\'\n+        recrule = "FREQ=DAILY;INTERVAL=10;COUNT=1001"\n         seq = recurrence_sequence_ical(start, recrule=recrule)\n         results = [res for res in seq]\n         self.assertEqual(len(results), 1000)\n@@ -104,8 +110,9 @@ def test_recrule_str_more_than_MAXCOUNT(self):\n     def test_recrule_str_more_than_count(self):\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n-        recrule = \'FREQ=DAILY;INTERVAL=10;COUNT=10\'\n+        recrule = "FREQ=DAILY;INTERVAL=10;COUNT=10"\n         count = 5\n         seq = recurrence_sequence_ical(start, recrule=recrule, count=count)\n         results = [res for res in seq]\n@@ -114,8 +121,9 @@ def test_recrule_str_more_than_count(self):\n     def test_recrule_from(self):\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n-        recrule = \'FREQ=DAILY;INTERVAL=1;COUNT=5\'\n+        recrule = "FREQ=DAILY;INTERVAL=1;COUNT=5"\n         from_ = datetime(2011, 11, 25)\n         until = datetime(2011, 11, 27)\n         seq = recurrence_sequence_ical(\n@@ -130,8 +138,9 @@ def test_recrule_from(self):\n     def test_recrule_until(self):\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 24)\n-        recrule = \'FREQ=DAILY;INTERVAL=1;COUNT=5\'\n+        recrule = "FREQ=DAILY;INTERVAL=1;COUNT=5"\n         from_ = datetime(2011, 11, 23)\n         until = datetime(2011, 11, 27)\n         seq = recurrence_sequence_ical(\n@@ -144,13 +153,13 @@ def test_recrule_until(self):\n         self.assertEqual(len(results), 4)\n \n     def test_recrule_from_until_with_duration(self):\n-        """Should include events ranging into the queried timerange.\n-        """\n+        """Should include events ranging into the queried timerange."""\n         from datetime import datetime\n         from datetime import timedelta\n         from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n-        recrule = \'FREQ=DAILY;INTERVAL=1;COUNT=5\'\n+        recrule = "FREQ=DAILY;INTERVAL=1;COUNT=5"\n         from_ = datetime(2011, 11, 26)\n         until = datetime(2011, 11, 27)\n         seq = recurrence_sequence_ical(\n@@ -168,6 +177,6 @@ def test_recrule_until_with_timezone(self):\n         from plone.event.recurrence import recurrence_sequence_ical\n \n         start = datetime(2011, 11, 24)\n-        recrule = \'RRULE:FREQ=DAILY;UNTIL=20111130T000000Z\'\n+        recrule = "RRULE:FREQ=DAILY;UNTIL=20111130T000000Z"\n         seq = list(recurrence_sequence_ical(start, recrule=recrule))\n         self.assertEqual(len(seq), 7)\ndiff --git a/plone/event/tests/test_recurrence_sequence_timedelta.py b/plone/event/tests/test_recurrence_sequence_timedelta.py\nindex fdb21af..9ca7210 100644\n--- a/plone/event/tests/test_recurrence_sequence_timedelta.py\n+++ b/plone/event/tests/test_recurrence_sequence_timedelta.py\n@@ -5,6 +5,7 @@ class TestRecurrenceSequenceTimedelta(unittest.TestCase):\n     def test_delta_None(self):\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_timedelta\n+\n         start = datetime(2011, 11, 23)\n         until = datetime(2011, 11, 24)\n         td = recurrence_sequence_timedelta(start, until=until)\n@@ -14,6 +15,7 @@ def test_delta_None(self):\n     def test_delta_zero(self):\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_timedelta\n+\n         start = datetime(2011, 11, 23)\n         delta = 0\n         until = datetime(2011, 11, 24)\n@@ -24,6 +26,7 @@ def test_delta_zero(self):\n     def test_until_None(self):\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_timedelta\n+\n         start = datetime(2011, 11, 23)\n         delta = 1\n         td = recurrence_sequence_timedelta(start, delta=delta)\n@@ -33,6 +36,7 @@ def test_until_None(self):\n     def test_delta_an_hour_until_next_day(self):\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_timedelta\n+\n         start = datetime(2011, 11, 23)\n         delta = 60\n         until = datetime(2011, 11, 24)\n@@ -43,6 +47,7 @@ def test_delta_an_hour_until_next_day(self):\n     def test_recur_more_than_MAXCOUNT(self):\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_timedelta\n+\n         start = datetime(2011, 11, 23)\n         delta = 1\n         until = datetime(2012, 11, 23)\n@@ -53,6 +58,7 @@ def test_recur_more_than_MAXCOUNT(self):\n     def test_recur_more_than_count(self):\n         from datetime import datetime\n         from plone.event.recurrence import recurrence_sequence_timedelta\n+\n         start = datetime(2011, 11, 23)\n         delta = 1\n         until = datetime(2011, 11, 24)\ndiff --git a/plone/event/tests/test_utils.py b/plone/event/tests/test_utils.py\nindex 0576920..ca82a01 100644\n--- a/plone/event/tests/test_utils.py\n+++ b/plone/event/tests/test_utils.py\n@@ -4,41 +4,47 @@\n \n \n class TestUtils(unittest.TestCase):\n-    @mock.patch(\'plone.event.utils.pytz\')\n-    @mock.patch(\'plone.event.utils.os\')\n+    @mock.patch("plone.event.utils.pytz")\n+    @mock.patch("plone.event.utils.os")\n     def test_default_timezone(self, os, pytz):\n         from plone.event.utils import default_timezone\n-        os.environ.keys.return_value = [\'TZ\']\n+\n+        os.environ.keys.return_value = ["TZ"]\n         os.environ = mock.MagicMock()\n-        pytz.timezone().zone = \'zone\'\n-        self.assertEqual(default_timezone(), \'zone\')\n+        pytz.timezone().zone = "zone"\n+        self.assertEqual(default_timezone(), "zone")\n \n     def test_utcoffset_normalize(self):\n         from plone.event.utils import utcoffset_normalize\n+\n         date = mock.Mock()\n         date.replace = mock.Mock(side_effect=KeyError)\n         self.assertEqual(utcoffset_normalize(date), date)\n \n-    @mock.patch(\'plone.event.utils.guesstz\')\n-    @mock.patch(\'plone.event.utils.utctz\')\n+    @mock.patch("plone.event.utils.guesstz")\n+    @mock.patch("plone.event.utils.utctz")\n     def test_pydt__missing_zone_is_None(self, utctz, guesstz):\n         from plone.event.utils import pydt\n+\n         dt = mock.Mock()\n         dt.toZone.return_value = dt\n         dt.parts.return_value = (2011, 11, 24, 11, 39, 00)\n         guesstz.return_value = None\n         import pytz\n-        utctz.return_value = pytz.timezone(\'UTC\')\n+\n+        utctz.return_value = pytz.timezone("UTC")\n         pydt(dt)\n         self.assertTrue(utctz.called)\n \n-    @mock.patch(\'plone.event.utils.guesstz\')\n-    @mock.patch(\'plone.event.utils.utctz\')\n+    @mock.patch("plone.event.utils.guesstz")\n+    @mock.patch("plone.event.utils.utctz")\n     def test_pydt__missing_zone_is_not_None(self, utctz, guesstz):\n         from plone.event.utils import pydt\n+\n         dt = mock.Mock()\n         import pytz\n-        utctz.return_value = pytz.timezone(\'UTC\')\n+\n+        utctz.return_value = pytz.timezone("UTC")\n         missing_zone = utctz()\n         dt.toZone.return_value = dt\n         dt.parts.return_value = (2011, 11, 24, 11, 39, 00)\n@@ -48,16 +54,19 @@ def test_pydt__missing_zone_is_not_None(self, utctz, guesstz):\n \n     def test_pydt__wrong_type(self):\n         from plone.event.utils import pydt\n-        self.assertEqual(pydt(\'wrongtype\'), None)\n+\n+        self.assertEqual(pydt("wrongtype"), None)\n \n     def test_dt2int_dt_is_None(self):\n         from plone.event.utils import dt2int\n+\n         self.assertFalse(dt2int(None))\n \n-    @mock.patch(\'plone.event.utils.MAX32\', 0)\n-    @mock.patch(\'plone.event.utils.utc\')\n+    @mock.patch("plone.event.utils.MAX32", 0)\n+    @mock.patch("plone.event.utils.utc")\n     def test_dt2int_less_MAX32(self, utc):\n         from plone.event.utils import dt2int\n+\n         dt = mock.Mock()\n         dd = mock.Mock()\n         utc.return_value = dd\n@@ -68,10 +77,11 @@ def test_dt2int_less_MAX32(self, utc):\n         dd.minute = 16\n         self.assertRaises(OverflowError, lambda: dt2int(dt))\n \n-    @mock.patch(\'plone.event.utils.MAX32\', 1077778937)\n-    @mock.patch(\'plone.event.utils.utc\')\n+    @mock.patch("plone.event.utils.MAX32", 1077778937)\n+    @mock.patch("plone.event.utils.utc")\n     def test_dt2int_more_MAX32(self, utc):\n         from plone.event.utils import dt2int\n+\n         dt = mock.Mock()\n         dd = mock.Mock()\n         utc.return_value = dd\ndiff --git a/setup.py b/setup.py\nindex 93f57df..b6ccb92 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -2,15 +2,13 @@\n from setuptools import setup\n \n \n-version = \'1.4.3.dev0\'\n+version = "1.4.3.dev0"\n \n setup(\n-    name=\'plone.event\',\n+    name="plone.event",\n     version=version,\n     description="Event and calendaring related tools not bound to Plone",\n-    long_description=(\n-        open("README.rst").read() + "\\n" + open("CHANGES.rst").read()\n-    ),\n+    long_description=(open("README.rst").read() + "\\n" + open("CHANGES.rst").read()),\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Framework :: Plone",\n@@ -28,26 +26,28 @@\n         "Programming Language :: Python :: 3.10",\n         "Programming Language :: Python :: 3.11",\n     ],\n-    keywords=\'Plone calendar calendaring event recurring\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://github.com/plone/plone.event\',\n-    license=\'GPL\',\n+    keywords="Plone calendar calendaring event recurring",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://github.com/plone/plone.event",\n+    license="GPL",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n-    python_requires=\'>=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,!=3.5.*\',\n+    python_requires=">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,!=3.5.*",\n     install_requires=[\n-        \'setuptools\',\n-        \'python-dateutil\',  # >4.0.2\n-        \'pytz\',\n-        \'zope.component\',\n-        \'zope.interface\',\n+        "setuptools",\n+        "python-dateutil",  # >4.0.2\n+        "pytz",\n+        "zope.component",\n+        "zope.interface",\n     ],\n-    extras_require={\'test\': [\n-        \'DateTime\',\n-        \'mock\',\n-        \'zope.configuration\',\n-    ], },\n+    extras_require={\n+        "test": [\n+            "DateTime",\n+            "mock",\n+            "zope.configuration",\n+        ],\n+    },\n )\n'

Repository: plone.event


Branch: refs/heads/master
Date: 2023-04-15T14:13:37+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.event/commit/9df45c0f2f4fbb1ad5ed753a7e30c7106f5fc655

chore: zpretty

Files changed:
M plone/event/configure.zcml

b'diff --git a/plone/event/configure.zcml b/plone/event/configure.zcml\nindex f9699f7..1e6e17c 100644\n--- a/plone/event/configure.zcml\n+++ b/plone/event/configure.zcml\n@@ -1,7 +1,8 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    i18n_domain="plone.event">\n+    i18n_domain="plone.event"\n+    >\n \n-    <adapter factory=".adapters.EventAccessor" />\n+  <adapter factory=".adapters.EventAccessor" />\n \n </configure>\n'

Repository: plone.event


Branch: refs/heads/master
Date: 2023-04-15T14:21:23+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.event/commit/f30946baf0d147d70b4285f7ce6a5db1fc420118

feat: codespell

Files changed:
M CHANGES.rst
M plone/event/interfaces.py
M plone/event/recurrence.py
M plone/event/recurrence.rst
M plone/event/recurrence_dateutil.rst
M plone/event/utils.py
M plone/event/utils.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex b5948f3..1b72551 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -108,10 +108,10 @@ Fixes:\n ----------------\n \n - Fix tests, where they broke with unicode recurrence strings and unicode date\n-  formating strings.\n+  formatting strings.\n   [thet]\n \n-- Make rrule munging hack only apply to RDATEs, EXDATEs and UNTILs which have\n+- Make rrule munging hack only apply to `RDATE`, `EXDATE` and `UNTIL` which have\n   null times, otherwise the DateRecurrenceIndex is broken for those who are\n   generating RRULES using a non-broken widget. This will still result in broken\n   RRULEs for some edge cases (where an RDATE is explicitly set for midnight on\ndiff --git a/plone/event/interfaces.py b/plone/event/interfaces.py\nindex 5f3af6e..572b7e1 100644\n--- a/plone/event/interfaces.py\n+++ b/plone/event/interfaces.py\n@@ -55,7 +55,7 @@ class IEventAccessor(Interface):\n \n     # reference\n     url = Attribute(\n-        "Cannonical, unique url of the event. External events "\n+        "Canonical, unique url of the event. External events "\n         "are referenced by the origin url unless explicitly set."\n     )\n \n@@ -80,7 +80,7 @@ class IEventAccessor(Interface):\n \n \n class IRecurrenceSupport(Interface):\n-    """Event type recurrence adatper."""\n+    """Event type recurrence adapter."""\n \n     def occurrences(self, range_start, range_end):\n         """Return a list of IOccurrence objects with custom attributes of the\ndiff --git a/plone/event/recurrence.py b/plone/event/recurrence.py\nindex e2b528b..2900837 100644\n--- a/plone/event/recurrence.py\n+++ b/plone/event/recurrence.py\n@@ -44,13 +44,13 @@ def recurrence_sequence_ical(\n                     MAXDATE limit the recurrence calculation.\n     :type until: datetime.datetime\n \n-    :param count:   Optional integer which defines the number of occurences.\n+    :param count:   Optional integer which defines the number of occurrences.\n                     If not given, until or MAXDATE limits the recurrence\n                     calculation.\n     :type count: integer\n \n     :param duration: Optional timedelta instance, which is used to calculate\n-                     if a occurence datetime plus duration is within the\n+                     if a occurrence datetime plus duration is within the\n                      queried timerange.\n     :type duration:  datetime.timedelta\n \n@@ -147,14 +147,14 @@ def recurrence_sequence_timedelta(\n     dst=DSTAUTO,\n ):\n     """Calculates a sequence of datetime objects from a timedelta integer,\n-    which defines the minutes between each occurence.\n+    which defines the minutes between each occurrence.\n \n     :param start: datetime or DateTime instance of the date from which the\n                   recurrence sequence is calculated.\n     :type start: datetime\n \n     :param delta: Integer which defines the minutes\n-                  between each date occurence.\n+                  between each date occurrence.\n     :type delta: integer\n \n     :param until: datetime or DateTime instance of the date, until the\n@@ -162,7 +162,7 @@ def recurrence_sequence_timedelta(\n                   count or MAXDATE limit the recurrence calculation.\n     :type until: datetime\n \n-    :param count: Integer which defines the number of occurences. If not given,\n+    :param count: Integer which defines the number of occurrences. If not given,\n                   until or MAXDATE limits the recurrence calculation.\n     :param count: integer\n \ndiff --git a/plone/event/recurrence.rst b/plone/event/recurrence.rst\nindex 67ad89e..e85db9d 100644\n--- a/plone/event/recurrence.rst\n+++ b/plone/event/recurrence.rst\n@@ -65,7 +65,7 @@ Timezone aware Daylight Saving Time dates crossing\n         datetime.datetime(2010, 11, 1, 9, 0, tzinfo=<DstTzInfo \'Europe/Vienna\' CET+1:00:00 STD>)]\n \n \n-Note, that recurrence_sequence_ical calculates occurences timezone naively and\n+Note, that recurrence_sequence_ical calculates occurrences timezone naively and\n applies timezones afterwards. This leads into a problem in corner cases:\n     >>> list(recurrence_sequence_ical(\n     ...      start=at.localize(datetime(2010,10,30,23,0,0,0)),\n@@ -109,10 +109,10 @@ Multiple Ruleset\n         datetime.datetime(2010, 1, 20, 0, 0, tzinfo=<DstTzInfo \'Europe/Vienna\' CET+1:00:00 STD>)]\n \n \n-Limiting number of occurences\n+Limiting number of occurrences\n -----------------------------\n \n-Until (date until recurrence happens) and count (Number of occurences) can also\n+Until (date until recurrence happens) and count (Number of occurrences) can also\n be given in recurrence_sequence_ical, instead of defining it in the rrule.\n But defining it in a rrule gives more flexibility since you can set it for each\n rrule individually.\n@@ -301,10 +301,10 @@ Here the correct behaviour on day level with DSTKEEP.\n         datetime.datetime(2008, 3, 30, 19, 0, tzinfo=<DstTzInfo \'CET\' CEST+2:00:00 DST>),\n         datetime.datetime(2008, 3, 30, 20, 0, tzinfo=<DstTzInfo \'CET\' CEST+2:00:00 DST>)]\n \n-Usally we want an clever behaviour, dependend on delta. This is implemented\n+Usually we want a clever behaviour, dependent on delta. This is implemented\n with DSTAUTO, which is the default behaviour.\n \n-Here the correct behaviour on day level or above: DSTADJUST is choosen.\n+Here the correct behaviour on day level or above: DSTADJUST is chosen.\n \n     >>> start = datetime(2008, 3, 29, 11, 0, 0, 0, pytz.timezone(\'CET\'))\n     >>> until = datetime(2008, 3, 31, 11, 0, 0, 0, pytz.timezone(\'CET\'))\n@@ -319,7 +319,7 @@ Here the correct behaviour on day level or above: DSTADJUST is choosen.\n         datetime.datetime(2008, 3, 31, 11, 0, tzinfo=<DstTzInfo \'CET\' CEST+2:00:00 DST>)]\n \n \n-The correct behaviour on below day level: DSTKEEP is choosen.\n+The correct behaviour on below day level: DSTKEEP is chosen.\n \n     >>> start = datetime(2008, 3, 29, 21, 0, 0, 0, pytz.timezone(\'CET\'))\n     >>> until = datetime(2008, 3, 30, 21, 0, 0, 0, pytz.timezone(\'CET\')) - timedelta(microseconds=1)\n@@ -398,7 +398,7 @@ timezones works.\n     >>> seqDT[0] == seqdt[0]\n     True\n \n-Does integer represenation work?\n+Does integer representation work?\n     >>> seqDT = list(recurrence_int_sequence(recurrence_sequence_timedelta(DT, 0, None)))\n     >>> seqdt = list(recurrence_int_sequence(recurrence_sequence_timedelta(dt, 0, None)))\n \ndiff --git a/plone/event/recurrence_dateutil.rst b/plone/event/recurrence_dateutil.rst\nindex 685f700..cf2dc85 100644\n--- a/plone/event/recurrence_dateutil.rst\n+++ b/plone/event/recurrence_dateutil.rst\n@@ -49,12 +49,12 @@ This issue is corrected by plone.event.util.utcoffset_normalize:\n \n \n It\'s safer to let rrule calculate timezone naive dates and localizing them\n-afterwards than letting rrule substracting (EXDATE) timezone correct dates from\n+afterwards than letting rrule subtracting (EXDATE) timezone correct dates from\n a possibly timezone incorrect recurrence sequence. This issue will be gone, if\n rrule does TZ normalizing itself before applying EXDATE to the recurrence\n sequence.\n \n-See here... This is our recurrence rule. We want to substract from the sequence\n+See here... This is our recurrence rule. We want to subtract from the sequence\n the date 2010-10-31, 23:30 in UTC, which is 2010-11-01, 0:30 in Austria, UTC+1\n \n ::\n@@ -63,7 +63,7 @@ the date 2010-10-31, 23:30 in UTC, which is 2010-11-01, 0:30 in Austria, UTC+1\n     ...              EXDATE:20101031T233000Z"""\n \n If we let the sequence start from 1st November, the 1st November is correctly\n-substracted, since the sequence has all correct timezones.\n+subtracted, since the sequence has all correct timezones.\n \n ::\n \n@@ -73,7 +73,7 @@ substracted, since the sequence has all correct timezones.\n         datetime.datetime(2010, 11, 3, 0, 30, tzinfo=<DstTzInfo \'Europe/Vienna\' CET+1:00:00 STD>)]\n \n But if we start from 30th October, where UTC+2 offset is still active, the\n-sequence has incorrect timezones and substracting does not work as expected\n+sequence has incorrect timezones and subtracting does not work as expected\n anymore.\n \n ::\ndiff --git a/plone/event/utils.py b/plone/event/utils.py\nindex 389a733..e5acbb6 100644\n--- a/plone/event/utils.py\n+++ b/plone/event/utils.py\n@@ -272,7 +272,7 @@ def utcoffset_normalize(date, delta=None, dstmode=DSTAUTO):\n                   the same relative to UTC.  So, 8:00 GMT+1 before will result\n                   in 7:00 GMT+2 afterwards. This behavior might be what\n                   machines expect, when recurrence rules are defined.\n-                  Mode DSTAUTO: If the relative delta between two occurences of\n+                  Mode DSTAUTO: If the relative delta between two occurrences of\n                   a reucurrence sequence is less than a day, DSTKEEP will be\n                   used - otherwise DSTADJUST. This behavior is the default.\n     """\n@@ -508,7 +508,7 @@ def pydt(dt, missing_zone=None, exact=False):\n def guesstz(DT):\n     """\'Guess\' pytz from a zope DateTime.\n \n-    !!! theres no real good method to guess the timezone.\n+    !!! there is no real good method to guess the timezone.\n     DateTime was build somewhere in 1998 long before python had a working\n     datetime implementation available and still stucks with this incomplete\n     implementation.\n@@ -521,12 +521,12 @@ def guesstz(DT):\n     \'Europe/Vienna\'\n \n     GMT timezones which are popular with DateTime cannot be guessed,\n-    unfortunatly\n+    unfortunately\n     >>> guesstz(DateTime(\'2010-01-01 GMT+1\'))\n     """\n     tzname = DT.timezone()\n \n-    # Please note, the GMT offset based timezone informations in DateTime are\n+    # Please note, the GMT offset based timezone information in DateTime are\n     # not compatible with Etc/GMT based from pytz. They have different offsets.\n     try:\n         tz = pytz.timezone(tzname)\ndiff --git a/plone/event/utils.rst b/plone/event/utils.rst\nindex 5278036..cdac790 100644\n--- a/plone/event/utils.rst\n+++ b/plone/event/utils.rst\n@@ -44,7 +44,7 @@ time in a way, that it\'s value will be the same as before normalizing.\n     >>> utcoffset_normalize(date2, dstmode=DSTADJUST)\n     datetime.datetime(2010, 11, 10, 0, 0, tzinfo=<DstTzInfo \'Europe/Vienna\' CET+1:00:00 STD>)\n \n-With DSTKEEP, normalizing will also keep the time as originaly set by UTC\n+With DSTKEEP, normalizing will also keep the time as originally set by UTC\n offset - time\'s value will change.\n     >>> utcoffset_normalize(date2, dstmode=DSTKEEP)\n     datetime.datetime(2010, 11, 9, 23, 0, tzinfo=<DstTzInfo \'Europe/Vienna\' CET+1:00:00 STD>)\n'

Repository: plone.event


Branch: refs/heads/master
Date: 2023-04-15T14:21:47+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.event/commit/31ea59015a0862f171f5167b71b2a4f6a198ae04

feat: flake8

Files changed:
M plone/event/utils.py

b'diff --git a/plone/event/utils.py b/plone/event/utils.py\nindex e5acbb6..16029d4 100644\n--- a/plone/event/utils.py\n+++ b/plone/event/utils.py\n@@ -149,7 +149,7 @@ def is_same_time(start, end, exact=False):\n     :returns: True, if start and end have the same time, otherwise False.\n     :rtype: Boolean.\n \n-    >>> from plone.event.utils import is_same_time, pydt\n+    >>> from plone.event.utils import is_same_time\n     >>> from datetime import datetime, timedelta\n \n     >>> is_same_time(datetime.now(), datetime.now()+timedelta(hours=1))\n'

Repository: plone.event


Branch: refs/heads/master
Date: 2023-04-15T14:22:43+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.event/commit/9d861f26ab412238e1fee6b61f421ca1130218d4

chore: update trove classifiers

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex b6ccb92..6f5cdac 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -12,15 +12,10 @@\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Framework :: Plone",\n-        "Framework :: Plone :: 5.1",\n-        "Framework :: Plone :: 5.2",\n         "Framework :: Plone :: 6.0",\n         "Framework :: Plone :: Core",\n         "License :: OSI Approved :: GNU General Public License (GPL)",\n         "Programming Language :: Python",\n-        "Programming Language :: Python :: 2.7",\n-        "Programming Language :: Python :: 3.6",\n-        "Programming Language :: Python :: 3.7",\n         "Programming Language :: Python :: 3.8",\n         "Programming Language :: Python :: 3.9",\n         "Programming Language :: Python :: 3.10",\n@@ -35,7 +30,7 @@\n     namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n-    python_requires=">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,!=3.5.*",\n+    python_requires=">=3.8",\n     install_requires=[\n         "setuptools",\n         "python-dateutil",  # >4.0.2\n'

Repository: plone.event


Branch: refs/heads/master
Date: 2023-04-15T14:23:29+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.event/commit/73866e439fe2b14be18d5a7c6cfbe5dfa388925e

feat: declare dependencies

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex 6f5cdac..ec9ce29 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -41,7 +41,6 @@\n     extras_require={\n         "test": [\n             "DateTime",\n-            "mock",\n             "zope.configuration",\n         ],\n     },\n'

Repository: plone.event


Branch: refs/heads/master
Date: 2023-04-15T14:27:19+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.event/commit/f4d751acdb793927ba2d69519ef05dcf81b31898

chore: bump version

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex ec9ce29..9234b93 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -2,7 +2,7 @@\n from setuptools import setup\n \n \n-version = "1.4.3.dev0"\n+version = "2.0.0.dev0"\n \n setup(\n     name="plone.event",\n'

Repository: plone.event


Branch: refs/heads/master
Date: 2023-04-15T14:27:19+02:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/plone.event/commit/2e2c3542ebfa69401ff6d12f98f4e4547daa4773

Add news entry

Files changed:
A news/1.breaking

b'diff --git a/news/1.breaking b/news/1.breaking\nnew file mode 100644\nindex 0000000..6a2e7d2\n--- /dev/null\n+++ b/news/1.breaking\n@@ -0,0 +1,2 @@\n+Drop python 2.7 compatibility.\n+[gforcada]\n'

Repository: plone.event


Branch: refs/heads/master
Date: 2023-04-17T18:10:17+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.event/commit/32ed6428ab87c33b4c85ecc677b23e3966302e6c

Merge pull request #16 from plone/config-with-default-template-79a1a2bf

Config with default template

Files changed:
A .editorconfig
A .meta.toml
A .pre-commit-config.yaml
A news/1.breaking
A news/5cc689e5.internal
M CHANGES.rst
M plone/__init__.py
M plone/event/adapters.py
M plone/event/configure.zcml
M plone/event/interfaces.py
M plone/event/recurrence.py
M plone/event/recurrence.rst
M plone/event/recurrence_dateutil.rst
M plone/event/tests/test_adapters.py
M plone/event/tests/test_doctest.py
M plone/event/tests/test_recurrence_int_sequence.py
M plone/event/tests/test_recurrence_sequence_ical.py
M plone/event/tests/test_recurrence_sequence_timedelta.py
M plone/event/tests/test_utils.py
M plone/event/utils.py
M plone/event/utils.rst
M pyproject.toml
M setup.cfg
M setup.py
M tox.ini
D .travis.yml

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..1b2346d\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "5cc689e5"\ndiff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nnew file mode 100644\nindex 0000000..fdafec1\n--- /dev/null\n+++ b/.pre-commit-config.yaml\n@@ -0,0 +1,42 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+ci:\n+    autofix_prs: false\n+    autoupdate_schedule: monthly\n+\n+repos:\n+-   repo: https://github.com/asottile/pyupgrade\n+    rev: v3.3.1\n+    hooks:\n+    -   id: pyupgrade\n+        args: [--py38-plus]\n+-   repo: https://github.com/pycqa/isort\n+    rev: 5.12.0\n+    hooks:\n+    -   id: isort\n+-   repo: https://github.com/psf/black\n+    rev: 23.3.0\n+    hooks:\n+    -   id: black\n+-   repo: https://github.com/collective/zpretty\n+    rev: 3.0.3\n+    hooks:\n+    -   id: zpretty\n+-   repo: https://github.com/PyCQA/flake8\n+    rev: 6.0.0\n+    hooks:\n+    -   id: flake8\n+-   repo: https://github.com/codespell-project/codespell\n+    rev: v2.2.4\n+    hooks:\n+    -   id: codespell\n+        additional_dependencies:\n+          - tomli\n+-   repo: https://github.com/mgedmin/check-manifest\n+    rev: "0.49"\n+    hooks:\n+    -   id: check-manifest\n+-   repo: https://github.com/regebro/pyroma\n+    rev: "4.2"\n+    hooks:\n+    -   id: pyroma\ndiff --git a/.travis.yml b/.travis.yml\ndeleted file mode 100644\nindex afff7e4..0000000\n--- a/.travis.yml\n+++ /dev/null\n@@ -1,12 +0,0 @@\n-language: python\n-python:\n-    - 2.7\n-    - 3.6\n-    - 3.7\n-    - 3.8\n-install:\n-    - pip install tox-travis\n-script:\n-    - tox\n-notifications:\n-    email: false\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex b5948f3..1b72551 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -108,10 +108,10 @@ Fixes:\n ----------------\n \n - Fix tests, where they broke with unicode recurrence strings and unicode date\n-  formating strings.\n+  formatting strings.\n   [thet]\n \n-- Make rrule munging hack only apply to RDATEs, EXDATEs and UNTILs which have\n+- Make rrule munging hack only apply to `RDATE`, `EXDATE` and `UNTIL` which have\n   null times, otherwise the DateRecurrenceIndex is broken for those who are\n   generating RRULES using a non-broken widget. This will still result in broken\n   RRULEs for some edge cases (where an RDATE is explicitly set for midnight on\ndiff --git a/news/1.breaking b/news/1.breaking\nnew file mode 100644\nindex 0000000..6a2e7d2\n--- /dev/null\n+++ b/news/1.breaking\n@@ -0,0 +1,2 @@\n+Drop python 2.7 compatibility.\n+[gforcada]\ndiff --git a/news/5cc689e5.internal b/news/5cc689e5.internal\nnew file mode 100644\nindex 0000000..c08f539\n--- /dev/null\n+++ b/news/5cc689e5.internal\n@@ -0,0 +1,2 @@\n+Update configuration files.\n+[plone devs]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/event/adapters.py b/plone/event/adapters.py\nindex 717657a..2549298 100644\n--- a/plone/event/adapters.py\n+++ b/plone/event/adapters.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.event.interfaces import IEvent\n from plone.event.interfaces import IEventAccessor\n from zope.component import adapter\n@@ -7,7 +6,7 @@\n \n @implementer(IEventAccessor)\n @adapter(IEvent)\n-class EventAccessor(object):\n+class EventAccessor:\n     """Simple event accessor adapter implementation for generic events, which\n     follow the IEvent interface closely.\n \n@@ -15,7 +14,7 @@ class EventAccessor(object):\n     """\n \n     def __init__(self, context):\n-        object.__setattr__(self, \'context\', context)\n+        object.__setattr__(self, "context", context)\n \n     def __getattr__(self, name):\n         return getattr(self.context, name)\ndiff --git a/plone/event/configure.zcml b/plone/event/configure.zcml\nindex f9699f7..1e6e17c 100644\n--- a/plone/event/configure.zcml\n+++ b/plone/event/configure.zcml\n@@ -1,7 +1,8 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    i18n_domain="plone.event">\n+    i18n_domain="plone.event"\n+    >\n \n-    <adapter factory=".adapters.EventAccessor" />\n+  <adapter factory=".adapters.EventAccessor" />\n \n </configure>\ndiff --git a/plone/event/interfaces.py b/plone/event/interfaces.py\nindex fa88995..572b7e1 100644\n--- a/plone/event/interfaces.py\n+++ b/plone/event/interfaces.py\n@@ -1,12 +1,9 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Attribute\n from zope.interface import Interface\n \n \n class IEvent(Interface):\n-    """Event type marker interface.\n-\n-    """\n+    """Event type marker interface."""\n \n \n class IEventRecurrence(Interface):\n@@ -21,8 +18,9 @@ class IOccurrence(Interface):\n     occurrence.\n \n     """\n-    start = Attribute(u\'Occurrence start date\')\n-    end = Attribute(u\'Occurrence end date\')\n+\n+    start = Attribute("Occurrence start date")\n+    end = Attribute("Occurrence end date")\n \n \n class ICalendarAccessor(Interface):\n@@ -31,16 +29,15 @@ class ICalendarAccessor(Interface):\n     A calendar is a collection of calendar components, like events.\n \n     """\n-    uid = Attribute(u\'UID of the calendar. Autogenerated, read only.\')\n+\n+    uid = Attribute("UID of the calendar. Autogenerated, read only.")\n     # rw attributes\n-    title = Attribute(u\'Calendar title.\')\n-    description = Attribute(u\'Calendar description text.\')\n-    timezone = Attribute(u\'Default timezone of the calendar.\')\n+    title = Attribute("Calendar title.")\n+    description = Attribute("Calendar description text.")\n+    timezone = Attribute("Default timezone of the calendar.")\n \n     def items(self):\n-        """Return a list of calendar component items, like events.\n-\n-        """\n+        """Return a list of calendar component items, like events."""\n \n \n class IEventAccessor(Interface):\n@@ -52,40 +49,38 @@ class IEventAccessor(Interface):\n     """\n \n     # ro attributes\n-    uid = Attribute(u\'UID of the event. Autogenerated, read only.\')\n-    created = Attribute(u\'Python datetime of the event creation timestamp.\')\n-    duration = Attribute(u\'Duration of the event. Computed attribute.\')\n+    uid = Attribute("UID of the event. Autogenerated, read only.")\n+    created = Attribute("Python datetime of the event creation timestamp.")\n+    duration = Attribute("Duration of the event. Computed attribute.")\n \n     # reference\n     url = Attribute(\n-        u\'Cannonical, unique url of the event. External events \'\n-        u\'are referenced by the origin url unless explicitly set.\'\n+        "Canonical, unique url of the event. External events "\n+        "are referenced by the origin url unless explicitly set."\n     )\n \n     # rw attributes\n-    last_modified = Attribute(u\'Last modified Python datetime.\')\n-    title = Attribute(u\'Event title.\')\n-    description = Attribute(u\'Event description text.\')\n-    start = Attribute(u\'Event start date as Python datetime.\')\n-    end = Attribute(u\'Event end date as Python datetime.\')\n-    whole_day = Attribute(u\'Event lasts whole day.\')\n-    open_end = Attribute(u\'Event has no defined end time.\')\n-    timezone = Attribute(u\'Timezone of the event. A pytz timezone identifier.\')\n-    recurrence = Attribute(u\'RFC5545 compatible recurrence definition.\')\n-    location = Attribute(u\'Location of the event.\')\n-    attendees = Attribute(u\'List of attendees.\')\n-    contact_name = Attribute(u\'Contact name.\')\n-    contact_email = Attribute(u\'Contact email.\')\n-    contact_phone = Attribute(u\'Contact phone.\')\n-    event_url = Attribute(u\'Website of the event.\')\n-    subjects = Attribute(u\'Categories.\')\n-    text = Attribute(u\'Body text of the event.\')\n+    last_modified = Attribute("Last modified Python datetime.")\n+    title = Attribute("Event title.")\n+    description = Attribute("Event description text.")\n+    start = Attribute("Event start date as Python datetime.")\n+    end = Attribute("Event end date as Python datetime.")\n+    whole_day = Attribute("Event lasts whole day.")\n+    open_end = Attribute("Event has no defined end time.")\n+    timezone = Attribute("Timezone of the event. A pytz timezone identifier.")\n+    recurrence = Attribute("RFC5545 compatible recurrence definition.")\n+    location = Attribute("Location of the event.")\n+    attendees = Attribute("List of attendees.")\n+    contact_name = Attribute("Contact name.")\n+    contact_email = Attribute("Contact email.")\n+    contact_phone = Attribute("Contact phone.")\n+    event_url = Attribute("Website of the event.")\n+    subjects = Attribute("Categories.")\n+    text = Attribute("Body text of the event.")\n \n \n class IRecurrenceSupport(Interface):\n-    """Event type recurrence adatper.\n-\n-    """\n+    """Event type recurrence adapter."""\n \n     def occurrences(self, range_start, range_end):\n         """Return a list of IOccurrence objects with custom attributes of the\n@@ -101,9 +96,7 @@ def occurrences(self, range_start, range_end):\n \n \n class IICalendar(Interface):\n-    """Adapter, which is used to construct an icalendar object.\n-\n-    """\n+    """Adapter, which is used to construct an icalendar object."""\n \n \n class IICalendarEventComponent(Interface):\n@@ -156,37 +149,38 @@ class / created / description / geo /\n     resources / rdate / x-prop / iana-prop\n \n     """\n-    dtstart = Attribute(u\'Start Date/Time\')\n-    dtend = Attribute(u\'End Date/Time\')\n-    duration = Attribute(u\'Duration\')\n-    rrule = Attribute(u\'Recurrence Rule\')\n-    description = Attribute(u\'Description\')\n-    location = Attribute(u\'Location\')\n-    summary = Attribute(u\'Summary\')\n-    url = Attribute(u\'Url\')\n-    attendee = Attribute(u\'Attendee\')\n-    categories = Attribute(u\'Categories\')\n-    contact = Attribute(u\'Contact\')\n-\n-    exdate = Attribute(u\'Exdate\')\n-    rdate = Attribute(u\'Rdate\')\n-\n-    dtstamp = Attribute(u\'Timestamp\')\n-    uid = Attribute(u\'Unique identifier\')\n-    klass = Attribute(u\'Class\')  # class\n-    created = Attribute(u\'Created\')\n-    geo = Attribute(u\'Geo\')\n-    last_mod = Attribute(u\'Last Modified\')  # last-mod\n-    organizer = Attribute(u\'Organizer\')\n-    priority = Attribute(u\'Priority\')\n-    seq = Attribute(u\'Seq\')\n-    status = Attribute(u\'Status\')\n-    transp = Attribute(u\'Transp\')\n-    recurid = Attribute(u\'Recurid\')\n-    attach = Attribute(u\'Attach\')\n-    comment = Attribute(u\'Comment\')\n-    rstatus = Attribute(u\'Rstatus\')\n-    related = Attribute(u\'Related\')\n-    resources = Attribute(u\'Resources\')\n-    x_prop = Attribute(u\'X Prop\')  # x-prop\n-    iana_prop = Attribute(u\'Iana Prop\')  # iana-prop\n+\n+    dtstart = Attribute("Start Date/Time")\n+    dtend = Attribute("End Date/Time")\n+    duration = Attribute("Duration")\n+    rrule = Attribute("Recurrence Rule")\n+    description = Attribute("Description")\n+    location = Attribute("Location")\n+    summary = Attribute("Summary")\n+    url = Attribute("Url")\n+    attendee = Attribute("Attendee")\n+    categories = Attribute("Categories")\n+    contact = Attribute("Contact")\n+\n+    exdate = Attribute("Exdate")\n+    rdate = Attribute("Rdate")\n+\n+    dtstamp = Attribute("Timestamp")\n+    uid = Attribute("Unique identifier")\n+    klass = Attribute("Class")  # class\n+    created = Attribute("Created")\n+    geo = Attribute("Geo")\n+    last_mod = Attribute("Last Modified")  # last-mod\n+    organizer = Attribute("Organizer")\n+    priority = Attribute("Priority")\n+    seq = Attribute("Seq")\n+    status = Attribute("Status")\n+    transp = Attribute("Transp")\n+    recurid = Attribute("Recurid")\n+    attach = Attribute("Attach")\n+    comment = Attribute("Comment")\n+    rstatus = Attribute("Rstatus")\n+    related = Attribute("Related")\n+    resources = Attribute("Resources")\n+    x_prop = Attribute("X Prop")  # x-prop\n+    iana_prop = Attribute("Iana Prop")  # iana-prop\ndiff --git a/plone/event/recurrence.py b/plone/event/recurrence.py\nindex 0bb42ce..2900837 100644\n--- a/plone/event/recurrence.py\n+++ b/plone/event/recurrence.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from dateutil import rrule\n from plone.event.utils import DSTAUTO\n from plone.event.utils import dt2int\n@@ -16,12 +15,12 @@\n \n \n def recurrence_sequence_ical(\n-        start,\n-        recrule=None,\n-        from_=None,\n-        until=None,\n-        count=None,\n-        duration=None,\n+    start,\n+    recrule=None,\n+    from_=None,\n+    until=None,\n+    count=None,\n+    duration=None,\n ):\n     """Calculates a sequence of datetime objects from a recurrence rule\n     following the RFC2445 specification, using python-dateutil recurrence\n@@ -45,13 +44,13 @@ def recurrence_sequence_ical(\n                     MAXDATE limit the recurrence calculation.\n     :type until: datetime.datetime\n \n-    :param count:   Optional integer which defines the number of occurences.\n+    :param count:   Optional integer which defines the number of occurrences.\n                     If not given, until or MAXDATE limits the recurrence\n                     calculation.\n     :type count: integer\n \n     :param duration: Optional timedelta instance, which is used to calculate\n-                     if a occurence datetime plus duration is within the\n+                     if a occurrence datetime plus duration is within the\n                      queried timerange.\n     :type duration:  datetime.timedelta\n \n@@ -68,7 +67,7 @@ def recurrence_sequence_ical(\n     _from = tzdel(from_)\n     _until = tzdel(until)\n     if duration:\n-        assert (isinstance(duration, datetime.timedelta))\n+        assert isinstance(duration, datetime.timedelta)\n     else:\n         duration = datetime.timedelta(0)\n \n@@ -88,16 +87,16 @@ def recurrence_sequence_ical(\n         # time for UNTIL, RDATE and EXDATE.\n         t0 = start.time()  # set initial time information.\n         # First, replace all times in the recurring rule with starttime\n-        t0str = \'T{0:02d}{1:02d}{2:02d}\'.format(t0.hour, t0.minute, t0.second)\n+        t0str = f"T{t0.hour:02d}{t0.minute:02d}{t0.second:02d}"\n         # Replace any times set to 000000 with start time, not all\n         # rrules are set by a specific broken widget.  Don\'t waste time\n         # subbing if the start time is already 000000.\n-        if t0str != \'T000000\':\n-            recrule = re.sub(r\'T000000\', t0str, recrule)\n+        if t0str != "T000000":\n+            recrule = re.sub(r"T000000", t0str, recrule)\n         # Then, replace incorrect until times with the end of the day\n         recrule = re.sub(\n-            r\'(UNTIL[^T]*[0-9]{8})T(000000)\',\n-            r\'\\1T235959\',\n+            r"(UNTIL[^T]*[0-9]{8})T(000000)",\n+            r"\\1T235959",\n             recrule,\n         )\n \n@@ -141,21 +140,21 @@ def recurrence_sequence_ical(\n \n \n def recurrence_sequence_timedelta(\n-        start,\n-        delta=None,\n-        until=None,\n-        count=None,\n-        dst=DSTAUTO,\n+    start,\n+    delta=None,\n+    until=None,\n+    count=None,\n+    dst=DSTAUTO,\n ):\n-    """ Calculates a sequence of datetime objects from a timedelta integer,\n-    which defines the minutes between each occurence.\n+    """Calculates a sequence of datetime objects from a timedelta integer,\n+    which defines the minutes between each occurrence.\n \n     :param start: datetime or DateTime instance of the date from which the\n                   recurrence sequence is calculated.\n     :type start: datetime\n \n     :param delta: Integer which defines the minutes\n-                  between each date occurence.\n+                  between each date occurrence.\n     :type delta: integer\n \n     :param until: datetime or DateTime instance of the date, until the\n@@ -163,7 +162,7 @@ def recurrence_sequence_timedelta(\n                   count or MAXDATE limit the recurrence calculation.\n     :type until: datetime\n \n-    :param count: Integer which defines the number of occurences. If not given,\n+    :param count: Integer which defines the number of occurrences. If not given,\n                   until or MAXDATE limits the recurrence calculation.\n     :param count: integer\n \n@@ -205,7 +204,7 @@ def recurrence_sequence_timedelta(\n \n \n def recurrence_int_sequence(sequence):\n-    """ Generates a sequence of integer representations from a sequence of\n+    """Generates a sequence of integer representations from a sequence of\n     dateime instances.\n \n     :param sequence: An iterable sequence of datetime instances.\ndiff --git a/plone/event/recurrence.rst b/plone/event/recurrence.rst\nindex 67ad89e..e85db9d 100644\n--- a/plone/event/recurrence.rst\n+++ b/plone/event/recurrence.rst\n@@ -65,7 +65,7 @@ Timezone aware Daylight Saving Time dates crossing\n         datetime.datetime(2010, 11, 1, 9, 0, tzinfo=<DstTzInfo \'Europe/Vienna\' CET+1:00:00 STD>)]\n \n \n-Note, that recurrence_sequence_ical calculates occurences timezone naively and\n+Note, that recurrence_sequence_ical calculates occurrences timezone naively and\n applies timezones afterwards. This leads into a problem in corner cases:\n     >>> list(recurrence_sequence_ical(\n     ...      start=at.localize(datetime(2010,10,30,23,0,0,0)),\n@@ -109,10 +109,10 @@ Multiple Ruleset\n         datetime.datetime(2010, 1, 20, 0, 0, tzinfo=<DstTzInfo \'Europe/Vienna\' CET+1:00:00 STD>)]\n \n \n-Limiting number of occurences\n+Limiting number of occurrences\n -----------------------------\n \n-Until (date until recurrence happens) and count (Number of occurences) can also\n+Until (date until recurrence happens) and count (Number of occurrences) can also\n be given in recurrence_sequence_ical, instead of defining it in the rrule.\n But defining it in a rrule gives more flexibility since you can set it for each\n rrule individually.\n@@ -301,10 +301,10 @@ Here the correct behaviour on day level with DSTKEEP.\n         datetime.datetime(2008, 3, 30, 19, 0, tzinfo=<DstTzInfo \'CET\' CEST+2:00:00 DST>),\n         datetime.datetime(2008, 3, 30, 20, 0, tzinfo=<DstTzInfo \'CET\' CEST+2:00:00 DST>)]\n \n-Usally we want an clever behaviour, dependend on delta. This is implemented\n+Usually we want a clever behaviour, dependent on delta. This is implemented\n with DSTAUTO, which is the default behaviour.\n \n-Here the correct behaviour on day level or above: DSTADJUST is choosen.\n+Here the correct behaviour on day level or above: DSTADJUST is chosen.\n \n     >>> start = datetime(2008, 3, 29, 11, 0, 0, 0, pytz.timezone(\'CET\'))\n     >>> until = datetime(2008, 3, 31, 11, 0, 0, 0, pytz.timezone(\'CET\'))\n@@ -319,7 +319,7 @@ Here the correct behaviour on day level or above: DSTADJUST is choosen.\n         datetime.datetime(2008, 3, 31, 11, 0, tzinfo=<DstTzInfo \'CET\' CEST+2:00:00 DST>)]\n \n \n-The correct behaviour on below day level: DSTKEEP is choosen.\n+The correct behaviour on below day level: DSTKEEP is chosen.\n \n     >>> start = datetime(2008, 3, 29, 21, 0, 0, 0, pytz.timezone(\'CET\'))\n     >>> until = datetime(2008, 3, 30, 21, 0, 0, 0, pytz.timezone(\'CET\')) - timedelta(microseconds=1)\n@@ -398,7 +398,7 @@ timezones works.\n     >>> seqDT[0] == seqdt[0]\n     True\n \n-Does integer represenation work?\n+Does integer representation work?\n     >>> seqDT = list(recurrence_int_sequence(recurrence_sequence_timedelta(DT, 0, None)))\n     >>> seqdt = list(recurrence_int_sequence(recurrence_sequence_timedelta(dt, 0, None)))\n \ndiff --git a/plone/event/recurrence_dateutil.rst b/plone/event/recurrence_dateutil.rst\nindex 685f700..cf2dc85 100644\n--- a/plone/event/recurrence_dateutil.rst\n+++ b/plone/event/recurrence_dateutil.rst\n@@ -49,12 +49,12 @@ This issue is corrected by plone.event.util.utcoffset_normalize:\n \n \n It\'s safer to let rrule calculate timezone naive dates and localizing them\n-afterwards than letting rrule substracting (EXDATE) timezone correct dates from\n+afterwards than letting rrule subtracting (EXDATE) timezone correct dates from\n a possibly timezone incorrect recurrence sequence. This issue will be gone, if\n rrule does TZ normalizing itself before applying EXDATE to the recurrence\n sequence.\n \n-See here... This is our recurrence rule. We want to substract from the sequence\n+See here... This is our recurrence rule. We want to subtract from the sequence\n the date 2010-10-31, 23:30 in UTC, which is 2010-11-01, 0:30 in Austria, UTC+1\n \n ::\n@@ -63,7 +63,7 @@ the date 2010-10-31, 23:30 in UTC, which is 2010-11-01, 0:30 in Austria, UTC+1\n     ...              EXDATE:20101031T233000Z"""\n \n If we let the sequence start from 1st November, the 1st November is correctly\n-substracted, since the sequence has all correct timezones.\n+subtracted, since the sequence has all correct timezones.\n \n ::\n \n@@ -73,7 +73,7 @@ substracted, since the sequence has all correct timezones.\n         datetime.datetime(2010, 11, 3, 0, 30, tzinfo=<DstTzInfo \'Europe/Vienna\' CET+1:00:00 STD>)]\n \n But if we start from 30th October, where UTC+2 offset is still active, the\n-sequence has incorrect timezones and substracting does not work as expected\n+sequence has incorrect timezones and subtracting does not work as expected\n anymore.\n \n ::\ndiff --git a/plone/event/tests/test_adapters.py b/plone/event/tests/test_adapters.py\nindex b302192..df92e79 100644\n--- a/plone/event/tests/test_adapters.py\n+++ b/plone/event/tests/test_adapters.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import datetime\n from plone.event.interfaces import IEvent\n from plone.event.interfaces import IEventAccessor\n@@ -9,22 +8,24 @@\n import zope.interface\n \n \n-class MockObject(object):\n+class MockObject:\n     """Mock object"""\n \n \n class TestAdapters(unittest.TestCase):\n     def setUp(self):\n         import zope.component\n-        context = xmlconfig.file(\'meta.zcml\', zope.component)\n-        xmlconfig.file(\'configure.zcml\', zope.component, context=context)\n+\n+        context = xmlconfig.file("meta.zcml", zope.component)\n+        xmlconfig.file("configure.zcml", zope.component, context=context)\n \n         import plone.event\n-        xmlconfig.file(\'configure.zcml\', plone.event, context=context)\n+\n+        xmlconfig.file("configure.zcml", plone.event, context=context)\n \n     def test_event_accessor(self):\n         obj = MockObject()\n-        tz = pytz.timezone(\'Europe/Vienna\')\n+        tz = pytz.timezone("Europe/Vienna")\n         obj.start = datetime(2012, 12, 12, 10, 0, tzinfo=tz)\n         obj.end = datetime(2012, 12, 12, 12, 0, tzinfo=tz)\n         zope.interface.alsoProvides(obj, IEvent)\n@@ -49,9 +50,9 @@ def test_event_accessor(self):\n         acc.something = True\n         self.assertTrue(acc.something == obj.something is True)\n         del acc.something\n-        self.assertTrue(hasattr(acc, \'something\') is False)\n-        self.assertTrue(hasattr(obj, \'something\') is False)\n+        self.assertTrue(hasattr(acc, "something") is False)\n+        self.assertTrue(hasattr(obj, "something") is False)\n \n         del acc.start\n-        self.assertTrue(hasattr(acc, \'start\') is False)\n-        self.assertTrue(hasattr(obj, \'start\') is False)\n+        self.assertTrue(hasattr(acc, "start") is False)\n+        self.assertTrue(hasattr(obj, "start") is False)\ndiff --git a/plone/event/tests/test_doctest.py b/plone/event/tests/test_doctest.py\nindex 77ab9e1..6e7b759 100644\n--- a/plone/event/tests/test_doctest.py\n+++ b/plone/event/tests/test_doctest.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.component.testing import tearDown\n \n import doctest\n@@ -8,11 +7,13 @@\n \n OPTIONFLAGS = doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS\n DOCFILES = [\n-    \'recurrence.rst\',\n-    \'recurrence_dateutil.rst\',\n-    \'utils.rst\',\n+    "recurrence.rst",\n+    "recurrence_dateutil.rst",\n+    "utils.rst",\n+]\n+DOCMODS = [\n+    "plone.event.utils",\n ]\n-DOCMODS = [\'plone.event.utils\', ]\n \n \n def test_suite():\n@@ -20,24 +21,19 @@ def test_suite():\n     suite.addTests(\n         [\n             doctest.DocFileSuite(\n-                os.path.join(os.path.dirname(__file__), \'..\', docfile),\n+                os.path.join(os.path.dirname(__file__), "..", docfile),\n                 module_relative=False,\n                 optionflags=OPTIONFLAGS,\n-                tearDown=tearDown\n+                tearDown=tearDown,\n             )\n             for docfile in DOCFILES\n         ]\n     )\n     suite.addTests(\n-        [\n-            doctest.DocTestSuite(\n-                docmod, optionflags=OPTIONFLAGS\n-            )\n-            for docmod in DOCMODS\n-        ]\n+        [doctest.DocTestSuite(docmod, optionflags=OPTIONFLAGS) for docmod in DOCMODS]\n     )\n     return suite\n \n \n-if __name__ == \'__main__\':\n-    unittest.main(defaultTest=\'test_suite\')\n+if __name__ == "__main__":\n+    unittest.main(defaultTest="test_suite")\ndiff --git a/plone/event/tests/test_recurrence_int_sequence.py b/plone/event/tests/test_recurrence_int_sequence.py\nindex ccd072c..9812fb4 100644\n--- a/plone/event/tests/test_recurrence_int_sequence.py\n+++ b/plone/event/tests/test_recurrence_int_sequence.py\n@@ -1,13 +1,14 @@\n-# -*- coding: utf-8 -*-\n-import mock\n+from unittest import mock\n+\n import unittest\n \n \n class TestRecurrenceIntSequence(unittest.TestCase):\n-    @mock.patch(\'plone.event.recurrence.dt2int\')\n+    @mock.patch("plone.event.recurrence.dt2int")\n     def test_recrule_str_(self, dt2int):\n         from plone.event.recurrence import recurrence_int_sequence\n+\n         sequence = [1, 2, 3]\n-        dt2int.return_value = \'a\'\n+        dt2int.return_value = "a"\n         res = [a for a in recurrence_int_sequence(sequence)]\n-        self.assertEqual(res, [\'a\', \'a\', \'a\'])\n+        self.assertEqual(res, ["a", "a", "a"])\ndiff --git a/plone/event/tests/test_recurrence_sequence_ical.py b/plone/event/tests/test_recurrence_sequence_ical.py\nindex 6f2ed8e..25f1887 100644\n--- a/plone/event/tests/test_recurrence_sequence_ical.py\n+++ b/plone/event/tests/test_recurrence_sequence_ical.py\n@@ -1,31 +1,33 @@\n-# -*- coding: utf-8 -*-\n import unittest\n \n \n class TestRecurrenceSequenceIcal(unittest.TestCase):\n     def test_start(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n         seq = recurrence_sequence_ical(start)\n         results = [res for res in seq]\n         self.assertEqual(len(results), 1)\n \n     def test_recrule_str(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n-        recrule = \'FREQ=DAILY;INTERVAL=10;COUNT=5\'\n+        recrule = "FREQ=DAILY;INTERVAL=10;COUNT=5"\n         seq = recurrence_sequence_ical(start, recrule=recrule)\n         results = [res for res in seq]\n         self.assertEqual(len(results), 5)\n \n     def test_recrule_str_rdate(self):\n         """Test, if an RDATE date has the correct time set.\n-            See: "BUGFIX WRONG RDATE TIME" in recurrence.py\n+        See: "BUGFIX WRONG RDATE TIME" in recurrence.py\n         """\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23, 10, 10)\n         recrule = """FREQ=DAILY;INTERVAL=1;COUNT=3\n RDATE:20111129T000000"""\n@@ -35,21 +37,22 @@ def test_recrule_str_rdate(self):\n         self.assertEqual(results[0].time(), results[-1].time())\n \n     def test_recrule_str_exdate(self):\n-        """Test, if an EXDATE date are not in the resulting recurrence set.\n-        """\n-        from plone.event.recurrence import recurrence_sequence_ical\n+        """Test, if an EXDATE date are not in the resulting recurrence set."""\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n+\n         import pytz\n-        at = pytz.timezone(\'Europe/Vienna\')\n+\n+        at = pytz.timezone("Europe/Vienna")\n         start = at.localize(datetime(2013, 6, 29, 10, 10))\n-        recrule = \'RRULE:FREQ=DAILY;COUNT=4\\r\\nEXDATE:20130630T000000,20130701T000000\\r\\nRDATE:20130706T000000,20130809T000000\'  # noqa\n+        recrule = "RRULE:FREQ=DAILY;COUNT=4\\r\\nEXDATE:20130630T000000,20130701T000000\\r\\nRDATE:20130706T000000,20130809T000000"  # noqa\n         seq = recurrence_sequence_ical(start, recrule=recrule)\n         res = [res for res in seq]\n         res_test = [\n             at.localize(datetime(2013, 6, 29, 10, 10)),\n             at.localize(datetime(2013, 7, 2, 10, 10)),\n             at.localize(datetime(2013, 7, 6, 10, 10)),\n-            at.localize(datetime(2013, 8, 9, 10, 10))\n+            at.localize(datetime(2013, 8, 9, 10, 10)),\n         ]\n         self.assertEqual(len(res), 4)\n         self.assertEqual(res, res_test)\n@@ -58,26 +61,29 @@ def test_recrule_str_until(self):\n         """Test, if UNTIL stops the sequence at the end of the day, even if\n         it\'s set to 0:00 by the recurrence widget.\n         """\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n+\n         import pytz\n-        at = pytz.timezone(\'Europe/Vienna\')\n+\n+        at = pytz.timezone("Europe/Vienna")\n         start = at.localize(datetime(2013, 6, 29, 10, 10))\n-        recrule = \'RRULE:FREQ=DAILY;UNTIL=20130702T000000\'\n+        recrule = "RRULE:FREQ=DAILY;UNTIL=20130702T000000"\n         seq = recurrence_sequence_ical(start, recrule=recrule)\n         res = [res for res in seq]\n         res_test = [\n             at.localize(datetime(2013, 6, 29, 10, 10)),\n             at.localize(datetime(2013, 6, 30, 10, 10)),\n             at.localize(datetime(2013, 7, 1, 10, 10)),\n-            at.localize(datetime(2013, 7, 2, 10, 10))\n+            at.localize(datetime(2013, 7, 2, 10, 10)),\n         ]\n         self.assertEqual(len(res), 4)\n         self.assertEqual(res, res_test)\n \n     def test_recrule_from_until(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n         recrule = None\n         from_ = datetime(2011, 11, 1)\n@@ -92,29 +98,32 @@ def test_recrule_from_until(self):\n         self.assertEqual(len(results), 1)\n \n     def test_recrule_str_more_than_MAXCOUNT(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n-        recrule = \'FREQ=DAILY;INTERVAL=10;COUNT=1001\'\n+        recrule = "FREQ=DAILY;INTERVAL=10;COUNT=1001"\n         seq = recurrence_sequence_ical(start, recrule=recrule)\n         results = [res for res in seq]\n         self.assertEqual(len(results), 1000)\n \n     def test_recrule_str_more_than_count(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n-        recrule = \'FREQ=DAILY;INTERVAL=10;COUNT=10\'\n+        recrule = "FREQ=DAILY;INTERVAL=10;COUNT=10"\n         count = 5\n         seq = recurrence_sequence_ical(start, recrule=recrule, count=count)\n         results = [res for res in seq]\n         self.assertEqual(len(results), 5)\n \n     def test_recrule_from(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n-        recrule = \'FREQ=DAILY;INTERVAL=1;COUNT=5\'\n+        recrule = "FREQ=DAILY;INTERVAL=1;COUNT=5"\n         from_ = datetime(2011, 11, 25)\n         until = datetime(2011, 11, 27)\n         seq = recurrence_sequence_ical(\n@@ -127,10 +136,11 @@ def test_recrule_from(self):\n         self.assertEqual(len(results), 3)\n \n     def test_recrule_until(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 24)\n-        recrule = \'FREQ=DAILY;INTERVAL=1;COUNT=5\'\n+        recrule = "FREQ=DAILY;INTERVAL=1;COUNT=5"\n         from_ = datetime(2011, 11, 23)\n         until = datetime(2011, 11, 27)\n         seq = recurrence_sequence_ical(\n@@ -143,13 +153,13 @@ def test_recrule_until(self):\n         self.assertEqual(len(results), 4)\n \n     def test_recrule_from_until_with_duration(self):\n-        """Should include events ranging into the queried timerange.\n-        """\n-        from plone.event.recurrence import recurrence_sequence_ical\n+        """Should include events ranging into the queried timerange."""\n         from datetime import datetime\n         from datetime import timedelta\n+        from plone.event.recurrence import recurrence_sequence_ical\n+\n         start = datetime(2011, 11, 23)\n-        recrule = \'FREQ=DAILY;INTERVAL=1;COUNT=5\'\n+        recrule = "FREQ=DAILY;INTERVAL=1;COUNT=5"\n         from_ = datetime(2011, 11, 26)\n         until = datetime(2011, 11, 27)\n         seq = recurrence_sequence_ical(\n@@ -163,10 +173,10 @@ def test_recrule_from_until_with_duration(self):\n         self.assertEqual(len(results), 4)\n \n     def test_recrule_until_with_timezone(self):\n-        from plone.event.recurrence import recurrence_sequence_ical\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_ical\n \n         start = datetime(2011, 11, 24)\n-        recrule = \'RRULE:FREQ=DAILY;UNTIL=20111130T000000Z\'\n+        recrule = "RRULE:FREQ=DAILY;UNTIL=20111130T000000Z"\n         seq = list(recurrence_sequence_ical(start, recrule=recrule))\n         self.assertEqual(len(seq), 7)\ndiff --git a/plone/event/tests/test_recurrence_sequence_timedelta.py b/plone/event/tests/test_recurrence_sequence_timedelta.py\nindex c9493f7..9ca7210 100644\n--- a/plone/event/tests/test_recurrence_sequence_timedelta.py\n+++ b/plone/event/tests/test_recurrence_sequence_timedelta.py\n@@ -1,11 +1,11 @@\n-# -*- coding: utf-8 -*-\n import unittest\n \n \n class TestRecurrenceSequenceTimedelta(unittest.TestCase):\n     def test_delta_None(self):\n-        from plone.event.recurrence import recurrence_sequence_timedelta\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_timedelta\n+\n         start = datetime(2011, 11, 23)\n         until = datetime(2011, 11, 24)\n         td = recurrence_sequence_timedelta(start, until=until)\n@@ -13,8 +13,9 @@ def test_delta_None(self):\n         self.assertEqual(len(results), 1)\n \n     def test_delta_zero(self):\n-        from plone.event.recurrence import recurrence_sequence_timedelta\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_timedelta\n+\n         start = datetime(2011, 11, 23)\n         delta = 0\n         until = datetime(2011, 11, 24)\n@@ -23,8 +24,9 @@ def test_delta_zero(self):\n         self.assertEqual(len(results), 1)\n \n     def test_until_None(self):\n-        from plone.event.recurrence import recurrence_sequence_timedelta\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_timedelta\n+\n         start = datetime(2011, 11, 23)\n         delta = 1\n         td = recurrence_sequence_timedelta(start, delta=delta)\n@@ -32,8 +34,9 @@ def test_until_None(self):\n         self.assertEqual(len(results), 1)\n \n     def test_delta_an_hour_until_next_day(self):\n-        from plone.event.recurrence import recurrence_sequence_timedelta\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_timedelta\n+\n         start = datetime(2011, 11, 23)\n         delta = 60\n         until = datetime(2011, 11, 24)\n@@ -42,8 +45,9 @@ def test_delta_an_hour_until_next_day(self):\n         self.assertEqual(len(results), 25)\n \n     def test_recur_more_than_MAXCOUNT(self):\n-        from plone.event.recurrence import recurrence_sequence_timedelta\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_timedelta\n+\n         start = datetime(2011, 11, 23)\n         delta = 1\n         until = datetime(2012, 11, 23)\n@@ -52,8 +56,9 @@ def test_recur_more_than_MAXCOUNT(self):\n         self.assertEqual(len(results), 1001)\n \n     def test_recur_more_than_count(self):\n-        from plone.event.recurrence import recurrence_sequence_timedelta\n         from datetime import datetime\n+        from plone.event.recurrence import recurrence_sequence_timedelta\n+\n         start = datetime(2011, 11, 23)\n         delta = 1\n         until = datetime(2011, 11, 24)\ndiff --git a/plone/event/tests/test_utils.py b/plone/event/tests/test_utils.py\nindex f90fedd..ca82a01 100644\n--- a/plone/event/tests/test_utils.py\n+++ b/plone/event/tests/test_utils.py\n@@ -1,44 +1,50 @@\n-# -*- coding: utf-8 -*-\n-import mock\n+from unittest import mock\n+\n import unittest\n \n \n class TestUtils(unittest.TestCase):\n-    @mock.patch(\'plone.event.utils.pytz\')\n-    @mock.patch(\'plone.event.utils.os\')\n+    @mock.patch("plone.event.utils.pytz")\n+    @mock.patch("plone.event.utils.os")\n     def test_default_timezone(self, os, pytz):\n         from plone.event.utils import default_timezone\n-        os.environ.keys.return_value = [\'TZ\']\n+\n+        os.environ.keys.return_value = ["TZ"]\n         os.environ = mock.MagicMock()\n-        pytz.timezone().zone = \'zone\'\n-        self.assertEqual(default_timezone(), \'zone\')\n+        pytz.timezone().zone = "zone"\n+        self.assertEqual(default_timezone(), "zone")\n \n     def test_utcoffset_normalize(self):\n         from plone.event.utils import utcoffset_normalize\n+\n         date = mock.Mock()\n         date.replace = mock.Mock(side_effect=KeyError)\n         self.assertEqual(utcoffset_normalize(date), date)\n \n-    @mock.patch(\'plone.event.utils.guesstz\')\n-    @mock.patch(\'plone.event.utils.utctz\')\n+    @mock.patch("plone.event.utils.guesstz")\n+    @mock.patch("plone.event.utils.utctz")\n     def test_pydt__missing_zone_is_None(self, utctz, guesstz):\n         from plone.event.utils import pydt\n+\n         dt = mock.Mock()\n         dt.toZone.return_value = dt\n         dt.parts.return_value = (2011, 11, 24, 11, 39, 00)\n         guesstz.return_value = None\n         import pytz\n-        utctz.return_value = pytz.timezone(\'UTC\')\n+\n+        utctz.return_value = pytz.timezone("UTC")\n         pydt(dt)\n         self.assertTrue(utctz.called)\n \n-    @mock.patch(\'plone.event.utils.guesstz\')\n-    @mock.patch(\'plone.event.utils.utctz\')\n+    @mock.patch("plone.event.utils.guesstz")\n+    @mock.patch("plone.event.utils.utctz")\n     def test_pydt__missing_zone_is_not_None(self, utctz, guesstz):\n         from plone.event.utils import pydt\n+\n         dt = mock.Mock()\n         import pytz\n-        utctz.return_value = pytz.timezone(\'UTC\')\n+\n+        utctz.return_value = pytz.timezone("UTC")\n         missing_zone = utctz()\n         dt.toZone.return_value = dt\n         dt.parts.return_value = (2011, 11, 24, 11, 39, 00)\n@@ -48,16 +54,19 @@ def test_pydt__missing_zone_is_not_None(self, utctz, guesstz):\n \n     def test_pydt__wrong_type(self):\n         from plone.event.utils import pydt\n-        self.assertEqual(pydt(\'wrongtype\'), None)\n+\n+        self.assertEqual(pydt("wrongtype"), None)\n \n     def test_dt2int_dt_is_None(self):\n         from plone.event.utils import dt2int\n+\n         self.assertFalse(dt2int(None))\n \n-    @mock.patch(\'plone.event.utils.MAX32\', 0)\n-    @mock.patch(\'plone.event.utils.utc\')\n+    @mock.patch("plone.event.utils.MAX32", 0)\n+    @mock.patch("plone.event.utils.utc")\n     def test_dt2int_less_MAX32(self, utc):\n         from plone.event.utils import dt2int\n+\n         dt = mock.Mock()\n         dd = mock.Mock()\n         utc.return_value = dd\n@@ -68,10 +77,11 @@ def test_dt2int_less_MAX32(self, utc):\n         dd.minute = 16\n         self.assertRaises(OverflowError, lambda: dt2int(dt))\n \n-    @mock.patch(\'plone.event.utils.MAX32\', 1077778937)\n-    @mock.patch(\'plone.event.utils.utc\')\n+    @mock.patch("plone.event.utils.MAX32", 1077778937)\n+    @mock.patch("plone.event.utils.utc")\n     def test_dt2int_more_MAX32(self, utc):\n         from plone.event.utils import dt2int\n+\n         dt = mock.Mock()\n         dd = mock.Mock()\n         utc.return_value = dd\ndiff --git a/plone/event/utils.py b/plone/event/utils.py\nindex 0763205..16029d4 100644\n--- a/plone/event/utils.py\n+++ b/plone/event/utils.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from datetime import date\n from datetime import datetime\n from datetime import timedelta\n@@ -59,8 +58,8 @@ def validated_timezone(timezone, fallback=None):\n     except Exception:\n         if fallback:\n             logger.warn(\n-                "The timezone {0} is not a valid timezone from the "\n-                "Olson database or pytz. Falling back to {1}.".format(\n+                "The timezone {} is not a valid timezone from the "\n+                "Olson database or pytz. Falling back to {}.".format(\n                     timezone,\n                     fallback,\n                 )\n@@ -68,7 +67,7 @@ def validated_timezone(timezone, fallback=None):\n             return fallback\n         else:\n             raise ValueError(\n-                "The timezone {0} is not a valid timezone from "\n+                "The timezone {} is not a valid timezone from "\n                 "the Olson database or pytz.".format(timezone)\n             )\n \n@@ -150,7 +149,7 @@ def is_same_time(start, end, exact=False):\n     :returns: True, if start and end have the same time, otherwise False.\n     :rtype: Boolean.\n \n-    >>> from plone.event.utils import is_same_time, pydt\n+    >>> from plone.event.utils import is_same_time\n     >>> from datetime import datetime, timedelta\n \n     >>> is_same_time(datetime.now(), datetime.now()+timedelta(hours=1))\n@@ -273,7 +272,7 @@ def utcoffset_normalize(date, delta=None, dstmode=DSTAUTO):\n                   the same relative to UTC.  So, 8:00 GMT+1 before will result\n                   in 7:00 GMT+2 afterwards. This behavior might be what\n                   machines expect, when recurrence rules are defined.\n-                  Mode DSTAUTO: If the relative delta between two occurences of\n+                  Mode DSTAUTO: If the relative delta between two occurrences of\n                   a reucurrence sequence is less than a day, DSTKEEP will be\n                   used - otherwise DSTADJUST. This behavior is the default.\n     """\n@@ -509,7 +508,7 @@ def pydt(dt, missing_zone=None, exact=False):\n def guesstz(DT):\n     """\'Guess\' pytz from a zope DateTime.\n \n-    !!! theres no real good method to guess the timezone.\n+    !!! there is no real good method to guess the timezone.\n     DateTime was build somewhere in 1998 long before python had a working\n     datetime implementation available and still stucks with this incomplete\n     implementation.\n@@ -522,12 +521,12 @@ def guesstz(DT):\n     \'Europe/Vienna\'\n \n     GMT timezones which are popular with DateTime cannot be guessed,\n-    unfortunatly\n+    unfortunately\n     >>> guesstz(DateTime(\'2010-01-01 GMT+1\'))\n     """\n     tzname = DT.timezone()\n \n-    # Please note, the GMT offset based timezone informations in DateTime are\n+    # Please note, the GMT offset based timezone information in DateTime are\n     # not compatible with Etc/GMT based from pytz. They have different offsets.\n     try:\n         tz = pytz.timezone(tzname)\n@@ -558,7 +557,7 @@ def dt2int(dt):\n     if value > MAX32:\n         # value must be integer fitting in the 32bit range\n         raise OverflowError(\n-            """{0} is not within the range of indexable dates,<<\n+            """{} is not within the range of indexable dates,<<\n             exceeding 32bit range.""".format(\n                 dt\n             )\n@@ -663,7 +662,7 @@ def rfc2445dt(dt, mode="utc", date=True, time=True):\n     dt = pydt(dt)\n     if mode == "utc":\n         dt = utc(dt)\n-    date = "{0}{1}{2}{3}".format(\n+    date = "{}{}{}{}".format(\n         date and dt.strftime("%Y%m%d") or "",\n         date and time and "T" or "",\n         time and dt.strftime("%H%M%S") or "",\ndiff --git a/plone/event/utils.rst b/plone/event/utils.rst\nindex 5278036..cdac790 100644\n--- a/plone/event/utils.rst\n+++ b/plone/event/utils.rst\n@@ -44,7 +44,7 @@ time in a way, that it\'s value will be the same as before normalizing.\n     >>> utcoffset_normalize(date2, dstmode=DSTADJUST)\n     datetime.datetime(2010, 11, 10, 0, 0, tzinfo=<DstTzInfo \'Europe/Vienna\' CET+1:00:00 STD>)\n \n-With DSTKEEP, normalizing will also keep the time as originaly set by UTC\n+With DSTKEEP, normalizing will also keep the time as originally set by UTC\n offset - time\'s value will change.\n     >>> utcoffset_normalize(date2, dstmode=DSTKEEP)\n     datetime.datetime(2010, 11, 9, 23, 0, tzinfo=<DstTzInfo \'Europe/Vienna\' CET+1:00:00 STD>)\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..92c3af9 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,64 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "internal"\n+name = "Internal:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "documentation"\n+name = "Documentation:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "tests"\n+name = "Tests"\n+showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\n+\n+[tool.dependencychecker]\n+Zope = [\n+  # Zope own provided namespaces\n+  \'App\', \'OFS\', \'Products.Five\', \'Products.OFSP\', \'Products.PageTemplates\',\n+  \'Products.SiteAccess\', \'Shared\', \'Testing\', \'ZPublisher\', \'ZTUtils\',\n+  \'Zope2\', \'webdav\', \'zmi\',\n+  # ExtensionClass own provided namespaces\n+  \'ExtensionClass\', \'ComputedAttribute\', \'MethodObject\',\n+  # Zope dependencies\n+  \'AccessControl\', \'Acquisition\', \'AuthEncoding\', \'beautifulsoup4\', \'BTrees\',\n+  \'cffi\', \'Chameleon\', \'DateTime\', \'DocumentTemplate\',\n+  \'MultiMapping\', \'multipart\', \'PasteDeploy\', \'Persistence\', \'persistent\',\n+  \'pycparser\', \'python-gettext\', \'pytz\', \'RestrictedPython\', \'roman\', \'six\',\n+  \'soupsieve\', \'transaction\', \'waitress\', \'WebOb\', \'WebTest\', \'WSGIProxy2\',\n+  \'z3c.pt\', \'zc.lockfile\', \'ZConfig\', \'zExceptions\', \'ZODB\', \'zodbpickle\',\n+  \'zope.annotation\', \'zope.browser\', \'zope.browsermenu\', \'zope.browserpage\',\n+  \'zope.browserresource\', \'zope.cachedescriptors\', \'zope.component\',\n+  \'zope.configuration\', \'zope.container\', \'zope.contentprovider\',\n+  \'zope.contenttype\', \'zope.datetime\', \'zope.deferredimport\',\n+  \'zope.deprecation\', \'zope.dottedname\', \'zope.event\', \'zope.exceptions\',\n+  \'zope.filerepresentation\', \'zope.globalrequest\', \'zope.hookable\',\n+  \'zope.i18n\', \'zope.i18nmessageid\', \'zope.interface\', \'zope.lifecycleevent\',\n+  \'zope.location\', \'zope.pagetemplate\', \'zope.processlifetime\', \'zope.proxy\',\n+  \'zope.ptresource\', \'zope.publisher\', \'zope.schema\', \'zope.security\',\n+  \'zope.sequencesort\', \'zope.site\', \'zope.size\', \'zope.structuredtext\',\n+  \'zope.tal\', \'zope.tales\', \'zope.testbrowser\', \'zope.testing\',\n+  \'zope.traversing\', \'zope.viewlet\'\n+]\n+\'Products.CMFCore\' = [\n+  \'docutils\', \'five.localsitemanager\', \'Missing\', \'Products.BTreeFolder2\',\n+  \'Products.GenericSetup\', \'Products.MailHost\', \'Products.PythonScripts\',\n+  \'Products.StandardCacheManagers\', \'Products.ZCatalog\', \'Record\',\n+  \'zope.sendmail\', \'Zope\'\n+]\n+\'plone.base\' = [\n+  \'plone.batching\', \'plone.registry\', \'plone.schema\',\'plone.z3cform\',\n+  \'Products.CMFCore\', \'Products.CMFDynamicViewFTI\',\n+]\n+python-dateutil = [\'dateutil\']\ndiff --git a/setup.cfg b/setup.cfg\nindex 3ee2840..0da8f8f 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,9 +1,23 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[bdist_wheel]\n+universal = 0\n+\n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n+\n [check-manifest]\n ignore =\n+    .editorconfig\n+    .meta.toml\n+    .pre-commit-config.yaml\n     tox.ini\n-\n-[bdist_wheel]\n-universal = 1\n-\n-[zest.releaser]\n-create-wheel = yes\ndiff --git a/setup.py b/setup.py\nindex 05d6d46..9234b93 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,54 +1,47 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n \n-version = \'1.4.3.dev0\'\n+version = "2.0.0.dev0"\n \n setup(\n-    name=\'plone.event\',\n+    name="plone.event",\n     version=version,\n     description="Event and calendaring related tools not bound to Plone",\n-    long_description=(\n-        open("README.rst").read() + "\\n" + open(("CHANGES.rst")).read()\n-    ),\n+    long_description=(open("README.rst").read() + "\\n" + open("CHANGES.rst").read()),\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Framework :: Plone",\n-        "Framework :: Plone :: 5.1",\n-        "Framework :: Plone :: 5.2",\n         "Framework :: Plone :: 6.0",\n         "Framework :: Plone :: Core",\n         "License :: OSI Approved :: GNU General Public License (GPL)",\n         "Programming Language :: Python",\n-        "Programming Language :: Python :: 2.7",\n-        "Programming Language :: Python :: 3.6",\n-        "Programming Language :: Python :: 3.7",\n         "Programming Language :: Python :: 3.8",\n         "Programming Language :: Python :: 3.9",\n         "Programming Language :: Python :: 3.10",\n         "Programming Language :: Python :: 3.11",\n     ],\n-    keywords=\'Plone calendar calendaring event recurring\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://github.com/plone/plone.event\',\n-    license=\'GPL\',\n+    keywords="Plone calendar calendaring event recurring",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://github.com/plone/plone.event",\n+    license="GPL",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n-    python_requires=\'>=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,!=3.5.*\',\n+    python_requires=">=3.8",\n     install_requires=[\n-        \'setuptools\',\n-        \'python-dateutil\',  # >4.0.2\n-        \'pytz\',\n-        \'zope.component\',\n-        \'zope.interface\',\n+        "setuptools",\n+        "python-dateutil",  # >4.0.2\n+        "pytz",\n+        "zope.component",\n+        "zope.interface",\n     ],\n-    extras_require={\'test\': [\n-        \'DateTime\',\n-        \'mock\',\n-        \'zope.configuration\',\n-    ], },\n+    extras_require={\n+        "test": [\n+            "DateTime",\n+            "zope.configuration",\n+        ],\n+    },\n )\ndiff --git a/tox.ini b/tox.ini\nindex 5b2fe14..c4521cf 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -1,10 +1,68 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tox]\n+# We need 4.4.0 for constrain_package_deps.\n+min_version = 4.4.0\n envlist =\n-    py27,py36,py37,py38\n+    format\n+    lint\n+    test\n \n [testenv]\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat code\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a pyupgrade\n+    pre-commit run -a isort\n+    pre-commit run -a black\n+    pre-commit run -a zpretty\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a\n+\n+[testenv:dependencies]\n+description = check if the package defines all its dependencies and generate a graph out of them\n+deps =\n+    z3c.dependencychecker==2.11\n+    pipdeptree==2.5.1\n+    graphviz  # optional dependency of pipdeptree\n+commands =\n+    dependencychecker\n+    sh -c \'pipdeptree --exclude setuptools,wheel,pipdeptree,z3c.dependencychecker,zope.interface,zope.component --graph-output svg > dependencies.svg\'\n+\n+[testenv:test]\n+usedevelop = true\n+constrain_package_deps = true\n+set_env = ROBOT_BROWSER=headlesschrome\n+deps =\n+    zope.testrunner\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    zope-testrunner --all --test-path={toxinidir} -s plone.event {posargs}\n+extras =\n+    test\n+\n+[testenv:coverage]\n+usedevelop = true\n+constrain_package_deps = true\n+set_env = ROBOT_BROWSER=headlesschrome\n deps =\n+    coverage\n     zope.testrunner\n-    .[test]\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n commands =\n-    zope-testrunner --test-path=. {posargs:-pvc}\n+    coverage run {envbindir}/zope-testrunner --all --test-path={toxinidir} -s plone.event {posargs}\n+    coverage report -m --format markdown\n+extras =\n+    test\n'

