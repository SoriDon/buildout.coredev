Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-16T23:36:27+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/91e4d0fd6cecf621abf384b286e8ad14665383ee

black -S

Files changed:
M Products/CMFEditions/ArchivistTool.py
M Products/CMFEditions/CopyModifyMergeRepositoryTool.py
M Products/CMFEditions/KeepLastNVersionsTool.py
M Products/CMFEditions/ModifierRegistryTool.py
M Products/CMFEditions/Modifiers.py
M Products/CMFEditions/ReferenceFactoriesTool.py
M Products/CMFEditions/StandardModifiers.py
M Products/CMFEditions/StorageMigrationSupport.py
M Products/CMFEditions/UniqueIdHandlerTool.py
M Products/CMFEditions/VersionPolicies.py
M Products/CMFEditions/ZVCStorageTool.py
M Products/CMFEditions/__init__.py
M Products/CMFEditions/browser/diff.py
M Products/CMFEditions/browser/utils.py
M Products/CMFEditions/browser/views.py
M Products/CMFEditions/exportimport/repository.py
M Products/CMFEditions/interfaces/IArchivist.py
M Products/CMFEditions/interfaces/IModifier.py
M Products/CMFEditions/interfaces/IReferenceFactories.py
M Products/CMFEditions/interfaces/IRepository.py
M Products/CMFEditions/interfaces/IStorage.py
M Products/CMFEditions/interfaces/IVersionPolicy.py
M Products/CMFEditions/interfaces/__init__.py
M Products/CMFEditions/interfaces/_tools.py
M Products/CMFEditions/subscriber.py
M Products/CMFEditions/tests/DummyTools.py
M Products/CMFEditions/tests/base.py
M Products/CMFEditions/tests/test_ArchivistTool.py
M Products/CMFEditions/tests/test_ContentTypes.py
M Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py
M Products/CMFEditions/tests/test_IntegrationTests.py
M Products/CMFEditions/tests/test_KeepLastNVersionsTool.py
M Products/CMFEditions/tests/test_ModifierRegistryTool.py
M Products/CMFEditions/tests/test_ZVCStorageTool.py
M Products/CMFEditions/tests/test_doctests.py
M Products/CMFEditions/tests/test_versions_history_form.py
M Products/CMFEditions/utilities.py
M Products/__init__.py

b'diff --git a/Products/CMFEditions/ArchivistTool.py b/Products/CMFEditions/ArchivistTool.py\nindex 14ade95..3e9f0a0 100644\n--- a/Products/CMFEditions/ArchivistTool.py\n+++ b/Products/CMFEditions/ArchivistTool.py\n@@ -60,13 +60,14 @@\n import time\n \n \n-RETRIEVING_UNREGISTERED_FAILED = \\\n-    "Retrieving a version of an unregistered object is not possible. " \\\n+RETRIEVING_UNREGISTERED_FAILED = (\n+    "Retrieving a version of an unregistered object is not possible. "\n     "Register the object \'%r\' first. "\n+)\n+\n \n def deepcopy(obj):\n-    """Makes a deep copy of the object using the pickle mechanism.\n-    """\n+    """Makes a deep copy of the object using the pickle mechanism."""\n     stream = BytesIO()\n     p = Pickler(stream, 1)\n     p.dump(aq_base(obj))\n@@ -74,13 +75,19 @@ def deepcopy(obj):\n     u = Unpickler(stream)\n     return u.load()\n \n+\n @implementer(IVersionData)\n class VersionData:\n-    """\n-    """\n-\n-    def __init__(self, data, refs_to_be_deleted, attr_handling_references,\n-                 preserved_data, metadata):\n+    """ """\n+\n+    def __init__(\n+        self,\n+        data,\n+        refs_to_be_deleted,\n+        attr_handling_references,\n+        preserved_data,\n+        metadata,\n+    ):\n         self.data = data\n         self.refs_to_be_deleted = refs_to_be_deleted\n         self.attr_handling_references = attr_handling_references\n@@ -91,7 +98,6 @@ def __init__(self, data, refs_to_be_deleted, attr_handling_references,\n \n @implementer(IAttributeAdapter)\n class AttributeAdapter(Persistent):\n-\n     def __init__(self, parent, attr_name, type=None):\n         self._parent = aq_base(parent)\n         self._name = attr_name\n@@ -111,9 +117,9 @@ def getAttributeName(self):\n     def getType(self):\n         return self._type\n \n+\n @implementer(IAttributeAdapter)\n class ObjectManagerStorageAdapter(Persistent):\n-\n     def __init__(self, parent, attr_name, type=None):\n         self._parent = aq_base(parent)\n         self._name = attr_name\n@@ -139,8 +145,7 @@ def getType(self):\n \n @implementer(IVersionAwareReference)\n class VersionAwareReference(Persistent):\n-    """A Reference that is version aware (and in future also location aware).\n-    """\n+    """A Reference that is version aware (and in future also location aware)."""\n \n     def __init__(self, **info):\n         self.history_id = None\n@@ -149,8 +154,7 @@ def __init__(self, **info):\n         self.info = info\n \n     def setReference(self, target_obj, remove_info=True):\n-        """See IVersionAwareReference\n-        """\n+        """See IVersionAwareReference"""\n         storage = getToolByName(target_obj, \'portal_historiesstorage\')\n \n         # save as much information as possible\n@@ -160,7 +164,7 @@ def setReference(self, target_obj, remove_info=True):\n         if storage.isRegistered(self.history_id):\n             self.version_id = target_obj.version_id\n             # XXX the location id has to be gotten from the object directly\n-            self.location_id = 0 # XXX only one location possible currently\n+            self.location_id = 0  # XXX only one location possible currently\n             # XXX store the information if the referenced working copy\n             # was unchanged since the last checkin. In this case the\n             # the exact state of the referenced object may be retrieved also.\n@@ -176,8 +180,7 @@ def __of__(self, obj):\n \n @implementer(IArchivistTool, IArchivist, IPurgeSupport)\n class ArchivistTool(UniqueObject, SimpleItem):\n-    """\n-    """\n+    """ """\n \n     id = \'portal_archivist\'\n     alternative_id = \'portal_standard_archivist\'\n@@ -202,13 +205,11 @@ class ArchivistTool(UniqueObject, SimpleItem):\n \n     security = ClassSecurityInfo()\n \n-\n     # -------------------------------------------------------------------\n     # private helper methods\n     # -------------------------------------------------------------------\n     def _cloneByPickle(self, obj):\n-        """Returns a deep copy of a ZODB object, loading ghosts as needed.\n-        """\n+        """Returns a deep copy of a ZODB object, loading ghosts as needed."""\n         modifier = getToolByName(self, \'portal_modifier\')\n         callbacks = modifier.getOnCloneModifiers(obj)\n         if callbacks is not None:\n@@ -228,15 +229,14 @@ def _cloneByPickle(self, obj):\n             u.persistent_load = pers_load\n         return approxSize, u.load(), inside_orefs, outside_orefs\n \n-\n     # -------------------------------------------------------------------\n     # methods implementing IArchivist\n     # -------------------------------------------------------------------\n \n     security.declarePrivate(\'prepare\')\n+\n     def prepare(self, obj, app_metadata=None, sys_metadata={}):\n-        """See IArchivist.\n-        """\n+        """See IArchivist."""\n         storage = getToolByName(self, \'portal_historiesstorage\')\n         modifier = getToolByName(self, \'portal_modifier\')\n \n@@ -265,10 +265,8 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n         # 2. clone the object with some modifications\n         # 3. modify the clone further\n         referenced_data = modifier.getReferencedAttributes(obj)\n-        approxSize, clone, inside_orefs, outside_orefs = \\\n-            self._cloneByPickle(obj)\n-        metadata, inside_crefs, outside_crefs = \\\n-            modifier.beforeSaveModifier(obj, clone)\n+        approxSize, clone, inside_orefs, outside_orefs = self._cloneByPickle(obj)\n+        metadata, inside_crefs, outside_crefs = modifier.beforeSaveModifier(obj, clone)\n \n         # extend the ``sys_metadata`` by the metadata returned by the\n         # ``beforeSaveModifier`` modifier\n@@ -282,57 +280,71 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n         # return the prepared infos (clone, refs, etc.)\n         clone_info = ObjectData(clone, inside_crefs, outside_crefs)\n         obj_info = ObjectData(obj, inside_orefs, outside_orefs)\n-        return PreparedObject(history_id, obj_info, clone_info,\n-                              referenced_data, app_metadata,\n-                              sys_metadata, is_registered, approxSize)\n+        return PreparedObject(\n+            history_id,\n+            obj_info,\n+            clone_info,\n+            referenced_data,\n+            app_metadata,\n+            sys_metadata,\n+            is_registered,\n+            approxSize,\n+        )\n \n     security.declarePrivate(\'register\')\n+\n     def register(self, prepared_obj):\n-        """See IArchivist.\n-        """\n+        """See IArchivist."""\n         # only register at the storage layer if not yet registered\n         if not prepared_obj.is_registered:\n             storage = getToolByName(self, \'portal_historiesstorage\')\n-            return storage.register(prepared_obj.history_id,\n-                                    prepared_obj.clone,\n-                                    prepared_obj.referenced_data,\n-                                    prepared_obj.metadata)\n+            return storage.register(\n+                prepared_obj.history_id,\n+                prepared_obj.clone,\n+                prepared_obj.referenced_data,\n+                prepared_obj.metadata,\n+            )\n \n     security.declarePrivate(\'save\')\n+\n     def save(self, prepared_obj, autoregister=None):\n-        """See IArchivist.\n-        """\n+        """See IArchivist."""\n         if not prepared_obj.is_registered:\n             if autoregister:\n                 return self.register(prepared_obj)\n             raise ArchivistSaveError(\n                 "Saving an unregistered object is not possible. Register "\n-                "the object \'%r\' first. "% prepared_obj.original.object)\n+                "the object \'%r\' first. " % prepared_obj.original.object\n+            )\n \n         storage = getToolByName(self, \'portal_historiesstorage\')\n-        return storage.save(prepared_obj.history_id,\n-                            prepared_obj.clone,\n-                            prepared_obj.referenced_data,\n-                            prepared_obj.metadata)\n+        return storage.save(\n+            prepared_obj.history_id,\n+            prepared_obj.clone,\n+            prepared_obj.referenced_data,\n+            prepared_obj.metadata,\n+        )\n \n     # -------------------------------------------------------------------\n     # methods implementing IPurgeSupport\n     # -------------------------------------------------------------------\n \n     security.declarePrivate(\'purge\')\n-    def purge(self, obj=None, history_id=None, selector=None, metadata={},\n-              countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+\n+    def purge(\n+        self, obj=None, history_id=None, selector=None, metadata={}, countPurged=True\n+    ):\n+        """See IPurgeSupport."""\n         storage = getToolByName(self, \'portal_historiesstorage\')\n         obj, history_id = dereference(obj, history_id, self)\n         storage.purge(history_id, selector, metadata, countPurged)\n \n     security.declarePrivate(\'retrieve\')\n-    def retrieve(self, obj=None, history_id=None, selector=None, preserve=(),\n-                 countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+\n+    def retrieve(\n+        self, obj=None, history_id=None, selector=None, preserve=(), countPurged=True\n+    ):\n+        """See IPurgeSupport."""\n         # retrieve the object by accessing the right history entry\n         # (counting from the oldest version)\n         # the histories storage called by LazyHistory knows what to do\n@@ -343,26 +355,28 @@ def retrieve(self, obj=None, history_id=None, selector=None, preserve=(),\n         except StorageRetrieveError:\n             raise ArchivistRetrieveError(\n                 "Retrieving of \'%r\' failed. Version \'%s\' does not exist. "\n-                % (obj, selector))\n+                % (obj, selector)\n+            )\n \n     security.declarePrivate(\'getHistory\')\n-    def getHistory(self, obj=None, history_id=None, preserve=(),\n-                   countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+\n+    def getHistory(self, obj=None, history_id=None, preserve=(), countPurged=True):\n+        """See IPurgeSupport."""\n         try:\n             return LazyHistory(self, obj, history_id, preserve, countPurged)\n         except StorageUnregisteredError:\n             raise ArchivistUnregisteredError(\n                 "Retrieving a version of an unregistered object is not "\n-                "possible. Register the object \'%r\' first. " % obj)\n+                "possible. Register the object \'%r\' first. " % obj\n+            )\n \n     security.declarePrivate(\'getHistoryMetadata\')\n+\n     def getHistoryMetadata(self, obj=None, history_id=None):\n-        """ Return the metadata blob for presenting summary\n-            information, etc. If obj is not supplied, history is found\n-            by history_id, if history_id is not supplied, history is\n-            found by obj. If neither, return None.\n+        """Return the metadata blob for presenting summary\n+        information, etc. If obj is not supplied, history is found\n+        by history_id, if history_id is not supplied, history is\n+        found by obj. If neither, return None.\n         """\n         obj, history_id = dereference(obj, history_id, self)\n         storage = getToolByName(self, \'portal_historiesstorage\')\n@@ -371,13 +385,15 @@ def getHistoryMetadata(self, obj=None, history_id=None):\n         except StorageUnregisteredError:\n             raise ArchivistUnregisteredError(\n                 "Retrieving a version of an unregistered object is not "\n-                "possible. Register the object \'%r\' first. " % obj)\n+                "possible. Register the object \'%r\' first. " % obj\n+            )\n \n     security.declarePrivate(\'queryHistory\')\n-    def queryHistory(self, obj=None, history_id=None, preserve=(), default=None,\n-                     countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+\n+    def queryHistory(\n+        self, obj=None, history_id=None, preserve=(), default=None, countPurged=True\n+    ):\n+        """See IPurgeSupport."""\n         if default is None:\n             default = []\n         try:\n@@ -386,20 +402,18 @@ def queryHistory(self, obj=None, history_id=None, preserve=(), default=None,\n             return default\n \n     security.declarePrivate(\'isUpToDate\')\n-    def isUpToDate(self, obj=None, history_id=None, selector=None,\n-                   countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+\n+    def isUpToDate(self, obj=None, history_id=None, selector=None, countPurged=True):\n+        """See IPurgeSupport."""\n         storage = getToolByName(self, \'portal_historiesstorage\')\n         obj, history_id = dereference(obj, history_id, self)\n         if not storage.isRegistered(history_id):\n-            raise ArchivistUnregisteredError(\n-                "The object %r is not registered" % obj)\n+            raise ArchivistUnregisteredError("The object %r is not registered" % obj)\n \n-        modified = storage.getModificationDate(history_id, selector,\n-                                               countPurged)\n+        modified = storage.getModificationDate(history_id, selector, countPurged)\n         return modified == obj.modified()\n \n+\n InitializeClass(ArchivistTool)\n \n \n@@ -409,8 +423,7 @@ def getUserId():\n \n @implementer(IObjectData)\n class ObjectData(Persistent):\n-    """\n-    """\n+    """ """\n \n     def __init__(self, obj, inside_refs=(), outside_refs=()):\n         self.object = obj\n@@ -420,11 +433,19 @@ def __init__(self, obj, inside_refs=(), outside_refs=()):\n \n @implementer(IPreparedObject)\n class PreparedObject:\n-    """\n-    """\n-\n-    def __init__(self, history_id, original, clone, referenced_data,\n-                 app_metadata, sys_metadata, is_registered, approxSize):\n+    """ """\n+\n+    def __init__(\n+        self,\n+        history_id,\n+        original,\n+        clone,\n+        referenced_data,\n+        app_metadata,\n+        sys_metadata,\n+        is_registered,\n+        approxSize,\n+    ):\n \n         # parent reference (register the parent with the unique id handler)\n         # register with sys_metadata as there is no other possibility\n@@ -434,8 +455,7 @@ def __init__(self, history_id, original, clone, referenced_data,\n \n         # set defaults if missing\n         sys_metadata[\'comment\'] = sys_metadata.get(\'comment\', \'\')\n-        sys_metadata[\'timestamp\'] = sys_metadata.get(\'timestamp\',\n-                                                     int(time.time()))\n+        sys_metadata[\'timestamp\'] = sys_metadata.get(\'timestamp\', int(time.time()))\n         sys_metadata[\'originator\'] = sys_metadata.get(\'originator\', None)\n         sys_metadata[\'principal\'] = getUserId()\n         sys_metadata[\'approxSize\'] = approxSize\n@@ -464,8 +484,7 @@ def copyVersionIdFromClone(self):\n \n @implementer(IHistory)\n class LazyHistory:\n-    """Lazy history.\n-    """\n+    """Lazy history."""\n \n     def __init__(self, archivist, obj, history_id, preserve, countPurged):\n         """Sets up a lazy history.\n@@ -483,13 +502,11 @@ def __init__(self, archivist, obj, history_id, preserve, countPurged):\n         self._history = storage.getHistory(history_id, countPurged)\n \n     def __len__(self):\n-        """See IHistory\n-        """\n+        """See IHistory"""\n         return len(self._history)\n \n     def __getitem__(self, selector):\n-        """See IHistory\n-        """\n+        """See IHistory"""\n         # To retrieve an object from the storage the following\n         # steps have to be carried out:\n         #\n@@ -507,28 +524,27 @@ def __getitem__(self, selector):\n         metadata = deepcopy(vdata.metadata)\n \n         # 5. reattach the separately saved attributes\n-        self._modifier.reattachReferencedAttributes(repo_clone,\n-                                                    referenced_data)\n+        self._modifier.reattachReferencedAttributes(repo_clone, referenced_data)\n \n         # 6. call the after retrieve modifier\n-        refs_to_be_deleted, attr_handling_references, preserved_data = \\\n-            self._modifier.afterRetrieveModifier(self._obj, repo_clone,\n-                                                 self._preserve)\n+        (\n+            refs_to_be_deleted,\n+            attr_handling_references,\n+            preserved_data,\n+        ) = self._modifier.afterRetrieveModifier(self._obj, repo_clone, self._preserve)\n \n-        return VersionData(data, refs_to_be_deleted,\n-                           attr_handling_references, preserved_data,\n-                           metadata)\n+        return VersionData(\n+            data, refs_to_be_deleted, attr_handling_references, preserved_data, metadata\n+        )\n \n     def __iter__(self):\n-        """See IHistory.\n-        """\n-        return GetItemIterator(self.__getitem__,\n-                               stopExceptions=(StorageRetrieveError,))\n+        """See IHistory."""\n+        return GetItemIterator(self.__getitem__, stopExceptions=(StorageRetrieveError,))\n \n \n class GetItemIterator:\n-    """Iterator object using a getitem implementation to iterate over.\n-    """\n+    """Iterator object using a getitem implementation to iterate over."""\n+\n     def __init__(self, getItem, stopExceptions):\n         self._getItem = getItem\n         self._stopExceptions = stopExceptions\ndiff --git a/Products/CMFEditions/CopyModifyMergeRepositoryTool.py b/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\nindex 0c2b4f1..85d07e0 100644\n--- a/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\n+++ b/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\n@@ -37,12 +37,8 @@\n from Products.CMFCore.utils import UniqueObject\n from Products.CMFEditions.interfaces.IArchivist import ArchivistRetrieveError\n from Products.CMFEditions.interfaces.IModifier import ModifierException\n-from Products.CMFEditions.interfaces.IRepository import (\n-    IContentTypeVersionPolicySupport\n-)\n-from Products.CMFEditions.interfaces.IRepository import (\n-    ICopyModifyMergeRepository\n-)\n+from Products.CMFEditions.interfaces.IRepository import IContentTypeVersionPolicySupport\n+from Products.CMFEditions.interfaces.IRepository import ICopyModifyMergeRepository\n from Products.CMFEditions.interfaces.IRepository import IHistory\n from Products.CMFEditions.interfaces.IRepository import IPurgeSupport\n from Products.CMFEditions.interfaces.IRepository import IRepositoryTool\n@@ -89,8 +85,7 @@\n )\n class CopyModifyMergeRepositoryTool(UniqueObject, SimpleItem):\n \n-    """See ICopyModifyMergeRepository\n-    """\n+    """See ICopyModifyMergeRepository"""\n \n     id = "portal_repository"\n     alternative_id = "portal_copymergerepository"\n@@ -122,8 +117,7 @@ def _migrateVersionPolicies(self):\n \n     @security.public\n     def isVersionable(self, obj):\n-        """See interface.\n-        """\n+        """See interface."""\n         if hasattr(aq_base(obj), "versioning_enabled") and not getattr(\n             obj, "versioning_enabled"\n         ):\n@@ -140,9 +134,7 @@ def setVersionableContentTypes(self, new_content_types):\n \n     # XXX: There was a typo which mismatched the interface def, preserve it\n     # for backwards compatibility\n-    security.declareProtected(\n-        ManageVersioningPolicies, "setVersionableContentType"\n-    )\n+    security.declareProtected(ManageVersioningPolicies, "setVersionableContentType")\n     setVersionableContentType = setVersionableContentTypes\n \n     @security.protected(ManageVersioningPolicies)\n@@ -211,9 +203,7 @@ def listPolicies(self):\n         return policy_list\n \n     @security.protected(ManageVersioningPolicies)\n-    def addPolicy(\n-        self, policy_id, policy_title, policy_class=VersionPolicy, **kw\n-    ):\n+    def addPolicy(self, policy_id, policy_title, policy_class=VersionPolicy, **kw):\n         self._policy_defs[policy_id] = policy_class(policy_id, policy_title)\n         self._callPolicyHook("add", policy_id, **kw)\n \n@@ -239,8 +229,7 @@ def manage_changePolicyDefs(self, policy_list, **kwargs):\n                 raise AssertionError("List items must be tuples: %s" % str(item))\n             if len(item) not in (2, 3, 4):\n                 raise AssertionError(\n-                    "Each policy definition must contain a title and id: %s"\n-                    % str(item)\n+                    "Each policy definition must contain a title and id: %s" % str(item)\n                 )\n             if not isinstance(item[0], six.string_types):\n                 raise AssertionError("Policy id must be a string: %s" % str(item[0]))\n@@ -286,14 +275,12 @@ def _callPolicyHook(self, action, policy_id, *args, **kw):\n \n     @security.protected(ApplyVersionControl)\n     def setAutoApplyMode(self, autoapply):\n-        """See ICopyModifyMergeRepository.\n-        """\n+        """See ICopyModifyMergeRepository."""\n         self.autoapply = autoapply\n \n     @security.public\n     def applyVersionControl(self, obj, comment="", metadata={}):\n-        """See ICopyModifyMergeRepository.\n-        """\n+        """See ICopyModifyMergeRepository."""\n         self._assertAuthorized(obj, ApplyVersionControl, "applyVersionControl")\n         sp = transaction.savepoint(optimistic=True)\n         try:\n@@ -310,8 +297,7 @@ def applyVersionControl(self, obj, comment="", metadata={}):\n \n     @security.public\n     def save(self, obj, comment="", metadata={}):\n-        """See ICopyModifyMergeRepository.\n-        """\n+        """See ICopyModifyMergeRepository."""\n         self._assertAuthorized(obj, SaveNewVersion, "save")\n         sp = transaction.savepoint(optimistic=True)\n         try:\n@@ -332,8 +318,7 @@ def save(self, obj, comment="", metadata={}):\n \n     @security.public\n     def purge(self, obj, selector, comment="", metadata={}, countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+        """See IPurgeSupport."""\n         self._assertAuthorized(obj, PurgeVersion, "purge")\n \n         # Trying to avoid mess with purged versions which we don\'t offer\n@@ -363,8 +348,7 @@ def purge(self, obj, selector, comment="", metadata={}, countPurged=True):\n \n     @security.public\n     def revert(self, obj, selector=None, countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+        """See IPurgeSupport."""\n         # XXX this should go away if _recursiveRetrieve is correctly\n         # implemented\n         original_id = obj.getId()\n@@ -390,17 +374,13 @@ def revert(self, obj, selector=None, countPurged=True):\n \n     @security.public\n     def retrieve(self, obj, selector=None, preserve=(), countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+        """See IPurgeSupport."""\n         self._assertAuthorized(obj, AccessPreviousVersions, "retrieve")\n         return self._retrieve(obj, selector, preserve, countPurged)\n \n     @security.public\n-    def restore(\n-        self, history_id, selector, container, new_id=None, countPurged=True\n-    ):\n-        """See IPurgeSupport.\n-        """\n+    def restore(self, history_id, selector, container, new_id=None, countPurged=True):\n+        """See IPurgeSupport."""\n \n         self._assertAuthorized(container, RevertToPreviousVersions, "revert")\n         fixup_queue = []\n@@ -426,21 +406,15 @@ def restore(\n         self._doInplaceFixups(fixup_queue, True)\n \n     @security.public\n-    def getHistory(\n-        self, obj, oldestFirst=False, preserve=(), countPurged=True\n-    ):\n-        """See IPurgeSupport.\n-        """\n+    def getHistory(self, obj, oldestFirst=False, preserve=(), countPurged=True):\n+        """See IPurgeSupport."""\n         self._assertAuthorized(obj, AccessPreviousVersions, "getHistory")\n         return LazyHistory(self, obj, oldestFirst, preserve, countPurged)\n \n     @security.public\n     def getHistoryMetadata(self, obj):\n-        """Returns the versioning metadata history.\n-        """\n-        self._assertAuthorized(\n-            obj, AccessPreviousVersions, "getHistoryMetadata"\n-        )\n+        """Returns the versioning metadata history."""\n+        self._assertAuthorized(obj, AccessPreviousVersions, "getHistoryMetadata")\n         portal_archivist = getToolByName(self, "portal_archivist")\n         hist = portal_archivist.getHistoryMetadata(obj)\n         if hist:\n@@ -449,8 +423,7 @@ def getHistoryMetadata(self, obj):\n \n     @security.public\n     def isUpToDate(self, obj, selector=None, countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+        """See IPurgeSupport."""\n         portal_archivist = getToolByName(self, "portal_archivist")\n         return portal_archivist.isUpToDate(\n             obj=obj, selector=selector, countPurged=countPurged\n@@ -510,9 +483,7 @@ def _recursiveSave(self, obj, app_metadata, sys_metadata, autoapply):\n             prep.clone.inside_refs,\n         )\n         for orig_ref, clone_ref in inside_refs:\n-            self._recursiveSave(\n-                orig_ref, app_metadata, sys_metadata, autoapply\n-            )\n+            self._recursiveSave(orig_ref, app_metadata, sys_metadata, autoapply)\n             clone_ref.setReference(orig_ref, remove_info=True)\n \n         outside_refs = map(\n@@ -550,9 +521,7 @@ def _retrieve(self, obj, selector, preserve, countPurged):\n         )\n         saved.rollback()\n         wrapped = wrap(vd.data.object, aq_parent(aq_inner(obj)))\n-        return VersionData(\n-            wrapped, vd.preserved_data, vd.sys_metadata, vd.app_metadata\n-        )\n+        return VersionData(wrapped, vd.preserved_data, vd.sys_metadata, vd.app_metadata)\n \n     def _recursiveRetrieve(\n         self,\n@@ -566,8 +535,7 @@ def _recursiveRetrieve(\n         ignore_existing=False,\n         countPurged=True,\n     ):\n-        """This is the real workhorse pulling objects out recursively.\n-        """\n+        """This is the real workhorse pulling objects out recursively."""\n         portal_archivist = getToolByName(self, "portal_archivist")\n         portal_reffactories = getToolByName(self, "portal_referencefactories")\n         if ignore_existing:\n@@ -675,9 +643,7 @@ def _recursiveRetrieve(\n             if va_ref is None:\n                 continue\n             try:\n-                ref = dereference(\n-                    history_id=va_ref.history_id, zodb_hook=self\n-                )[0]\n+                ref = dereference(history_id=va_ref.history_id, zodb_hook=self)[0]\n             except (TypeError, AttributeError):\n                 # get the attribute from the working copy\n                 ref = cur_value\n@@ -694,7 +660,7 @@ def _recursiveRetrieve(\n         return vdata\n \n     def _doInplaceFixups(self, queue, inplace):\n-        """ Perform fixups to deal with implementation details\n+        """Perform fixups to deal with implementation details\n         (especially zodb and cmf details) which need to be done in\n         each retrieved object."""\n         for obj in queue:\n@@ -703,7 +669,7 @@ def _doInplaceFixups(self, queue, inplace):\n                 self._fixupCatalogData(obj)\n \n     def _fixupCatalogData(self, obj):\n-        """ Reindex the object, otherwise the catalog will certainly\n+        """Reindex the object, otherwise the catalog will certainly\n         be out of sync."""\n         portal_catalog = getToolByName(self, "portal_catalog")\n         portal_catalog.indexObject(obj)\n@@ -757,8 +723,7 @@ def _fixIds(self, obj):\n     # -------------------------------------------------------------------\n \n     def createTestHierarchy(self, context):\n-        """Create a Content Test Hierarchy\n-        """\n+        """Create a Content Test Hierarchy"""\n         # XXX to be allowed in test mode only\n         from StorageMigrationSupport import createTestHierarchy\n \n@@ -767,8 +732,7 @@ def createTestHierarchy(self, context):\n \n @implementer(IVersionData)\n class VersionData:\n-    """\n-    """\n+    """ """\n \n     security = ClassSecurityInfo()\n     security.declareObjectPublic()\n@@ -789,8 +753,7 @@ def __init__(self, object, preserved_data, sys_metadata, app_metadata):\n \n @implementer(IHistory)\n class LazyHistory:\n-    """Lazy history.\n-    """\n+    """Lazy history."""\n \n     __allow_access_to_unprotected_subobjects__ = 1\n \n@@ -803,20 +766,16 @@ def __init__(self, repository, obj, oldestFirst, preserve, countPurged):\n         self._countPurged = countPurged\n         self._retrieve = repository._retrieve\n         self._length = len(\n-            archivist.queryHistory(\n-                obj=obj, preserve=preserve, countPurged=countPurged\n-            )\n+            archivist.queryHistory(obj=obj, preserve=preserve, countPurged=countPurged)\n         )\n         self._cache = {}\n \n     def __len__(self):\n-        """See IHistory\n-        """\n+        """See IHistory"""\n         return self._length\n \n     def __getitem__(self, selector):\n-        """See IHistory\n-        """\n+        """See IHistory"""\n         if not self._oldestFirst and selector < self._length:\n             if selector >= 0:\n                 selector = self._length - 1 - selector\n@@ -831,24 +790,20 @@ def __getitem__(self, selector):\n         return result\n \n     def __iter__(self):\n-        """See IHistory.\n-        """\n+        """See IHistory."""\n         return GetItemIterator(\n             self.__getitem__, stopExceptions=(ArchivistRetrieveError,)\n         )\n \n \n class GetItemIterator:\n-    """Iterator object using a getitem implementation to iterate over.\n-    """\n+    """Iterator object using a getitem implementation to iterate over."""\n \n     def __init__(self, getItem, stopExceptions):\n         self._getItem = getItem\n         self._stopExceptions = stopExceptions\n         self._pos = -1\n-        self.next = (\n-            self.__next__\n-        )  # In order to keep compatibility with Python 2\n+        self.next = self.__next__  # In order to keep compatibility with Python 2\n \n     def __iter__(self):\n         return self\ndiff --git a/Products/CMFEditions/KeepLastNVersionsTool.py b/Products/CMFEditions/KeepLastNVersionsTool.py\nindex 28b9eda..0787ba1 100644\n--- a/Products/CMFEditions/KeepLastNVersionsTool.py\n+++ b/Products/CMFEditions/KeepLastNVersionsTool.py\n@@ -36,22 +36,24 @@\n \n @implementer(IPurgePolicyTool, IPurgePolicy)\n class KeepLastNVersionsTool(UniqueObject, SimpleItem, PropertyManager):\n-    """\n-    """\n+    """ """\n \n     id = \'portal_purgepolicy\'\n     alternative_id = \'portal_keeplastnversions\'\n \n     meta_type = "CMFEditions Purge Policy Keeping Only the n last Versions"\n \n-    manage_options = PropertyManager.manage_options \\\n-      + SimpleItem.manage_options\n+    manage_options = PropertyManager.manage_options + SimpleItem.manage_options\n \n-    maxNumberOfVersionsToKeep = -1 # disabled\n+    maxNumberOfVersionsToKeep = -1  # disabled\n \n     _properties = (\n-        {\'id\': \'maxNumberOfVersionsToKeep\', \'type\': \'int\', \'mode\': \'w\',\n-         \'label\': "maximum number of versions to keep in the storage (set to -1 for infinite)"},\n+        {\n+            \'id\': \'maxNumberOfVersionsToKeep\',\n+            \'type\': \'int\',\n+            \'mode\': \'w\',\n+            \'label\': "maximum number of versions to keep in the storage (set to -1 for infinite)",\n+        },\n     )\n     security = ClassSecurityInfo()\n \n@@ -77,10 +79,12 @@ def beforeSaveHook(self, history_id, obj, metadata={}):\n             if length < self.maxNumberOfVersionsToKeep:\n                 break\n             comment = "purged on save of version %s" % currentVersion\n-            storage.purge(history_id, 0, metadata={\'sys_metadata\': {\n-                                                           \'comment\': comment}\n-                                                   },\n-                          countPurged=False)\n+            storage.purge(\n+                history_id,\n+                0,\n+                metadata={\'sys_metadata\': {\'comment\': comment}},\n+                countPurged=False,\n+            )\n \n         # save current version\n         return True\n@@ -115,4 +119,5 @@ def retrieveSubstitute(self, history_id, selector, default=None):\n \n         return default\n \n+\n InitializeClass(KeepLastNVersionsTool)\ndiff --git a/Products/CMFEditions/ModifierRegistryTool.py b/Products/CMFEditions/ModifierRegistryTool.py\nindex 1efdcd8..19dff6e 100644\n--- a/Products/CMFEditions/ModifierRegistryTool.py\n+++ b/Products/CMFEditions/ModifierRegistryTool.py\n@@ -47,13 +47,16 @@\n \n \n @implementer(\n-        IAttributeModifier, ISaveRetrieveModifier, ICloneModifier,\n-        IModifierRegistrySet,\n-        IModifierRegistryQuery,\n-#        IBulkEditableSubscriberRegistry,        # not yet implemented\n-        IPortalModifierTool,)\n+    IAttributeModifier,\n+    ISaveRetrieveModifier,\n+    ICloneModifier,\n+    IModifierRegistrySet,\n+    IModifierRegistryQuery,\n+    #        IBulkEditableSubscriberRegistry,        # not yet implemented\n+    IPortalModifierTool,\n+)\n class ModifierRegistryTool(UniqueObject, OrderedFolder):\n-    __doc__ = __doc__ # copy from module\n+    __doc__ = __doc__  # copy from module\n \n     id = \'portal_modifier\'\n     alternative_id = \'portal_modifierregistry\'\n@@ -65,8 +68,7 @@ class ModifierRegistryTool(UniqueObject, OrderedFolder):\n         IConditionalModifier=IConditionalModifier,\n         IConditionalTalesModifier=IConditionalTalesModifier,\n     )\n-    exceptions = KwAsAttributes(\n-    )\n+    exceptions = KwAsAttributes()\n     classes = KwAsAttributes(\n         ConditionalModifier=ConditionalModifier,\n         ConditionalTalesModifier=ConditionalTalesModifier,\n@@ -78,35 +80,33 @@ class ModifierRegistryTool(UniqueObject, OrderedFolder):\n     security = ClassSecurityInfo()\n \n     def all_meta_types(self, interfaces=None):\n-        """Allow adding of objects implementing \'IConditionalModifier\' only.\n-        """\n+        """Allow adding of objects implementing \'IConditionalModifier\' only."""\n         if interfaces is None:\n-            interfaces = (IConditionalModifier, )\n+            interfaces = (IConditionalModifier,)\n         return OrderedFolder.all_meta_types(self, interfaces)\n \n     # be aware that the tool implements also the OrderedObjectManager API\n \n     orderedFolderSetObject = OrderedFolder._setObject\n+\n     def _setObject(self, id, object, roles=None, user=None, set_owner=1):\n-        """Wrap condition and modifier into one object if necessary.\n-        """\n+        """Wrap condition and modifier into one object if necessary."""\n \n         # wrap the object by a conditional tales modifier if it isn\'t one yet\n         if not IConditionalModifier.providedBy(object):\n             object = ConditionalTalesModifier(id, object)\n \n-        return self.orderedFolderSetObject(id, object, roles=roles,\n-                                           user=user, set_owner=set_owner)\n+        return self.orderedFolderSetObject(\n+            id, object, roles=roles, user=user, set_owner=set_owner\n+        )\n \n     def _collectModifiers(self, obj, interface, reversed=False):\n-        """ Returns a list of valid modifiers\n-        """\n+        """Returns a list of valid modifiers"""\n         modifier_list = []\n         portal = getToolByName(self, \'portal_url\').getPortalObject()\n         for id, o in self.objectItems():\n             # collect objects modifier only when appropriate\n-            if IConditionalModifier.providedBy(o) \\\n-               and o.isApplicable(obj, portal):\n+            if IConditionalModifier.providedBy(o) and o.isApplicable(obj, portal):\n                 mod = o.getModifier()\n                 if interface.providedBy(mod):\n                     modifier_list.append((id, mod))\n@@ -124,9 +124,9 @@ def _collectModifiers(self, obj, interface, reversed=False):\n     # -------------------------------------------------------------------\n \n     security.declarePrivate(\'getReferencedAttributes\')\n+\n     def getReferencedAttributes(self, obj):\n-        """See IModifier\n-        """\n+        """See IModifier"""\n         # just loop over all objects implementing the IModifier interface.\n         referenced_data = {}\n         for id, mod in self._collectModifiers(obj, IAttributeModifier):\n@@ -140,9 +140,9 @@ def getReferencedAttributes(self, obj):\n         return referenced_data\n \n     security.declarePrivate(\'reattachReferencedAttributes\')\n+\n     def reattachReferencedAttributes(self, obj, referenced_data):\n-        """\n-        """\n+        """ """\n         # the input of \'referenced_data\' is of the format:\n         #     {\'<modifier_id>/<name>\': <refrenced_data>, ...}\n         # build a structure by modifier id\n@@ -157,14 +157,16 @@ def reattachReferencedAttributes(self, obj, referenced_data):\n \n         # loop over modifiers in reverse\n         if data_by_modid:\n-            for id, mod in self._collectModifiers(obj, IAttributeModifier, reversed=True):\n+            for id, mod in self._collectModifiers(\n+                obj, IAttributeModifier, reversed=True\n+            ):\n                 if id in data_by_modid:\n                     mod.reattachReferencedAttributes(obj, data_by_modid[id])\n \n     security.declarePrivate(\'getOnCloneModifiers\')\n+\n     def getOnCloneModifiers(self, obj):\n-        """See IModifier\n-        """\n+        """See IModifier"""\n         # First check if there is at least one ICloneModifier to loop over.\n         # The clone operation is much fater if there are no \'persistent_id\'\n         # hooks to call.\n@@ -204,9 +206,9 @@ def persistent_load(named_pid):\n         return persistent_id, persistent_load, inside_orefs, outside_orefs, \'\'\n \n     security.declarePrivate(\'beforeSaveModifier\')\n+\n     def beforeSaveModifier(self, obj, obj_clone):\n-        """See IModifier\n-        """\n+        """See IModifier"""\n         inside_crefs = []\n         outside_crefs = []\n         metadata = {}\n@@ -221,9 +223,9 @@ def beforeSaveModifier(self, obj, obj_clone):\n         return metadata, inside_crefs, outside_crefs\n \n     security.declarePrivate(\'afterRetrieveModifier\')\n+\n     def afterRetrieveModifier(self, obj, repo_clone, preserve=None):\n-        """See IModifier\n-        """\n+        """See IModifier"""\n         if preserve is None:\n             preserve = []\n         # before letting the after retrieve modifiers replace\n@@ -238,7 +240,9 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=None):\n         # just loop over all modifiers in reverse order\n         refs_to_be_deleted = []\n         attrs_handling_subobjects = []\n-        for ignored_id, mod in self._collectModifiers(obj, ISaveRetrieveModifier, reversed=True):\n+        for ignored_id, mod in self._collectModifiers(\n+            obj, ISaveRetrieveModifier, reversed=True\n+        ):\n             to_be_del, attrs, preserve = mod.afterRetrieveModifier(obj, repo_clone)\n             refs_to_be_deleted.extend(to_be_del)\n             attrs_handling_subobjects.extend(attrs)\n@@ -256,9 +260,9 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=None):\n     # -------------------------------------------------------------------\n \n     security.declareProtected(ManagePortal, \'register\')\n+\n     def register(self, id, modifier, pos=-1):\n-        """See IModifierRegistrySet\n-        """\n+        """See IModifierRegistrySet"""\n         # add the modifier\n         id = self._setObject(id, modifier)\n \n@@ -270,42 +274,42 @@ def register(self, id, modifier, pos=-1):\n         self.moveObjectToPosition(id, pos)\n \n     security.declareProtected(ManagePortal, \'unregister\')\n+\n     def unregister(self, id):\n-        """See IModifierRegistrySet\n-        """\n+        """See IModifierRegistrySet"""\n         self.manage_delObjects(ids=[id])\n \n     security.declareProtected(ManagePortal, \'edit\')\n+\n     def edit(self, id, enabled=None, condition=None):\n-        """See IModifierRegistrySet\n-        """\n+        """See IModifierRegistrySet"""\n         modifier = self.get(id)\n         if IConditionalTalesModifier.providedBy(modifier):\n             modifier.edit(enabled, condition)\n         else:\n             if condition:\n                 raise NotImplementedError(\n-                    \'%s does not implement conditions.\' % modifier)\n+                    \'%s does not implement conditions.\' % modifier\n+                )\n             modifier.edit(enabled)\n \n     security.declareProtected(ManagePortal, \'get\')\n+\n     def get(self, id):\n-        """See IModifierRegistryQuery\n-        """\n+        """See IModifierRegistryQuery"""\n         # raises the correct exception for us\n         getattr(aq_base(self), id)\n         return getattr(self, id)\n \n     security.declareProtected(ManagePortal, \'query\')\n+\n     def query(self, id, default=None):\n-        """See IModifierRegistryQuery\n-        """\n+        """See IModifierRegistryQuery"""\n         try:\n             return self.get(id)\n         except AttributeError:\n             return default\n \n-\n     # -------------------------------------------------------------------\n     # methods implementing IBulkModifierRegistry\n     # -------------------------------------------------------------------\ndiff --git a/Products/CMFEditions/Modifiers.py b/Products/CMFEditions/Modifiers.py\nindex 1361214..93fea00 100644\n--- a/Products/CMFEditions/Modifiers.py\n+++ b/Products/CMFEditions/Modifiers.py\n@@ -38,26 +38,28 @@\n from ZODB.broken import Broken\n from zope.interface import implementer\n \n-manage_addModifierForm = PageTemplateFile(\'www/modifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_addModifierForm\')\n+manage_addModifierForm = PageTemplateFile(\n+    \'www/modifierAddForm.pt\', globals(), __name__=\'manage_addModifierForm\'\n+)\n+\n \n @implementer(\n-        IConditionalModifier,)\n+    IConditionalModifier,\n+)\n class ConditionalModifier(SimpleItem):\n-    """This is a wrapper for a modifier.\n-    """\n+    """This is a wrapper for a modifier."""\n \n-    modifierEditForm = PageTemplateFile(\'www/modifierEditForm.pt\',\n-                                        globals(),\n-                                        __name__=\'modifierEditForm\')\n+    modifierEditForm = PageTemplateFile(\n+        \'www/modifierEditForm.pt\', globals(), __name__=\'modifierEditForm\'\n+    )\n     modifierEditForm._owner = None\n     manage = manage_main = modifierEditForm\n-    manage_options = ({\'label\' : \'Edit\', \'action\' : \'modifierEditForm\'},) + SimpleItem.manage_options[:]\n+    manage_options = (\n+        {\'label\': \'Edit\', \'action\': \'modifierEditForm\'},\n+    ) + SimpleItem.manage_options[:]\n \n     def __init__(self, id, modifier, title=\'\'):\n-        """See IConditionalModifier.\n-        """\n+        """See IConditionalModifier."""\n         self.id = str(id)\n         self.title = str(title)\n         self.meta_type = \'edmod_%s\' % id\n@@ -65,11 +67,10 @@ def __init__(self, id, modifier, title=\'\'):\n         self._enabled = False\n \n     def edit(self, enabled=None, title=\'\', REQUEST=None):\n-        """See IConditionalModifier.\n-        """\n+        """See IConditionalModifier."""\n         self.title = title\n \n-        if enabled is not None and (enabled==\'True\' or enabled==True):\n+        if enabled is not None and (enabled == \'True\' or enabled == True):\n             self._enabled = enabled\n         else:\n             self._enabled = False\n@@ -86,49 +87,48 @@ def isBroken(self):\n         return isinstance(self.getModifier(), Broken)\n \n     def isApplicable(self, obj, portal=None):\n-        """See IConditionalModifier.\n-        """\n+        """See IConditionalModifier."""\n         # check if disabled or an empty condition and not broken\n         if self._enabled and not self.isBroken():\n             return True\n \n     def isEnabled(self):\n-        """See IConditionalModifier.\n-        """\n+        """See IConditionalModifier."""\n         return self._enabled\n \n     def getModifier(self):\n-        """See IConditionalModifier.\n-        """\n+        """See IConditionalModifier."""\n         return self._modifier\n \n+\n InitializeClass(ConditionalModifier)\n \n \n-manage_addTalesModifierForm = PageTemplateFile(\'www/talesModifierAddForm.pt\',\n-                                               globals(),\n-                                               __name__=\'manage_addTalesModifierForm\')\n+manage_addTalesModifierForm = PageTemplateFile(\n+    \'www/talesModifierAddForm.pt\', globals(), __name__=\'manage_addTalesModifierForm\'\n+)\n+\n \n @implementer(\n-        IConditionalTalesModifier,)\n+    IConditionalTalesModifier,\n+)\n class ConditionalTalesModifier(ConditionalModifier):\n-    """This is a wrapper with a tales condition for a modifier.\n-    """\n+    """This is a wrapper with a tales condition for a modifier."""\n \n-    modifierEditForm = PageTemplateFile(\'www/talesModifierEditForm.pt\',\n-                                        globals(),\n-                                        __name__=\'modifierEditForm\')\n-    manage_options = ({\'label\' : \'Edit\', \'action\' : \'modifierEditForm\'},) + ConditionalModifier.manage_options[:]\n+    modifierEditForm = PageTemplateFile(\n+        \'www/talesModifierEditForm.pt\', globals(), __name__=\'modifierEditForm\'\n+    )\n+    manage_options = (\n+        {\'label\': \'Edit\', \'action\': \'modifierEditForm\'},\n+    ) + ConditionalModifier.manage_options[:]\n \n     def __init__(self, id, modifier, title=\'\'):\n-        """See IConditionalTalesModifier.\n-        """\n+        """See IConditionalTalesModifier."""\n         ConditionalModifier.__init__(self, id, modifier, title)\n         self._condition = None\n \n     def edit(self, enabled=None, condition=None, title=\'\', REQUEST=None):\n-        """See IConditionalTalesModifier.\n-        """\n+        """See IConditionalTalesModifier."""\n         ConditionalModifier.edit(self, enabled, title)\n         if condition is not None and condition != self.getTalesCondition():\n             self._condition = Expression(condition)\n@@ -138,8 +138,7 @@ def edit(self, enabled=None, condition=None, title=\'\', REQUEST=None):\n             return self.modifierEditForm(self, REQUEST)\n \n     def isApplicable(self, obj, portal=None):\n-        """See IConditionalTalesModifier.\n-        """\n+        """See IConditionalTalesModifier."""\n         # check if disabled or an empty condition or broken\n         if not self._enabled or not self.getTalesCondition() or self.isBroken():\n             return False\n@@ -149,10 +148,10 @@ def isApplicable(self, obj, portal=None):\n         return self._condition(context)\n \n     def getTalesCondition(self):\n-        """See IConditionalTalesModifier.\n-        """\n+        """See IConditionalTalesModifier."""\n         return getattr(self._condition, \'text\', \'\')\n \n+\n InitializeClass(ConditionalTalesModifier)\n \n \n@@ -217,21 +216,21 @@ def findNextFolderishParent(obj):\n     try:\n         portal_type = obj.getPortalTypeName()\n     except AttributeError:\n-        portal_type  = None\n+        portal_type = None\n \n     data = {\n-        \'object_url\':   obj_url,\n-        \'folder_url\':   folder is not None and folder.absolute_url() or \'\',\n-        \'portal_url\':   portal is not None and portal.absolute_url() or \'\',\n-        \'object\':       obj,\n-        \'folder\':       folder,\n-        \'portal\':       portal,\n-        \'nothing\':      None,\n-        \'request\':      getattr(obj, \'REQUEST\', None),\n-        \'modules\':      SecureModuleImporter,\n-        \'member\':       member,\n-        \'meta_type\':    meta_type,\n-        \'portal_type\':  portal_type,\n-        }\n+        \'object_url\': obj_url,\n+        \'folder_url\': folder is not None and folder.absolute_url() or \'\',\n+        \'portal_url\': portal is not None and portal.absolute_url() or \'\',\n+        \'object\': obj,\n+        \'folder\': folder,\n+        \'portal\': portal,\n+        \'nothing\': None,\n+        \'request\': getattr(obj, \'REQUEST\', None),\n+        \'modules\': SecureModuleImporter,\n+        \'member\': member,\n+        \'meta_type\': meta_type,\n+        \'portal_type\': portal_type,\n+    }\n     data.update(more_symbols)\n     return getEngine().getContext(data)\ndiff --git a/Products/CMFEditions/ReferenceFactoriesTool.py b/Products/CMFEditions/ReferenceFactoriesTool.py\nindex c38b237..897ad53 100644\n--- a/Products/CMFEditions/ReferenceFactoriesTool.py\n+++ b/Products/CMFEditions/ReferenceFactoriesTool.py\n@@ -36,9 +36,10 @@\n \n \n @implementer(\n-        IReferenceFactories,)\n+    IReferenceFactories,\n+)\n class ReferenceFactoriesTool(UniqueObject, OrderedFolder):\n-    __doc__ = __doc__ # copy from module\n+    __doc__ = __doc__  # copy from module\n \n     id = \'portal_referencefactories\'\n     alternative_id = \'portal_referencefactoryregistry\'\n@@ -54,9 +55,9 @@ class ReferenceFactoriesTool(UniqueObject, OrderedFolder):\n     # -------------------------------------------------------------------\n \n     security.declarePrivate(\'invokeFactory\')\n+\n     def invokeFactory(self, repo_clone, source, selector=None):\n-        """See IReferenceFactories\n-        """\n+        """See IReferenceFactories"""\n         # Just assuming ObjectManager behaviour for now\n         portal_hidhandler = getToolByName(self, \'portal_historyidhandler\')\n         try:\n@@ -80,10 +81,11 @@ def invokeFactory(self, repo_clone, source, selector=None):\n         return obj\n \n     security.declarePrivate(\'hasBeenMoved\')\n+\n     def hasBeenMoved(self, obj, source):\n-        """See IReferenceFactories\n-        """\n+        """See IReferenceFactories"""\n         # Check that the path of the object\'s parent (by path) is the same as the source\n         return aq_parent(aq_inner(obj)).getPhysicalPath() != source.getPhysicalPath()\n \n+\n InitializeClass(ReferenceFactoriesTool)\ndiff --git a/Products/CMFEditions/StandardModifiers.py b/Products/CMFEditions/StandardModifiers.py\nindex 9e887d7..3db47ba 100644\n--- a/Products/CMFEditions/StandardModifiers.py\n+++ b/Products/CMFEditions/StandardModifiers.py\n@@ -54,24 +54,25 @@\n _marker = []\n \n \n-#----------------------------------------------------------------------\n+# ----------------------------------------------------------------------\n # Product initialziation, installation and factory stuff\n-#----------------------------------------------------------------------\n+# ----------------------------------------------------------------------\n+\n \n def initialize(context):\n-    """Registers modifiers with zope (on zope startup).\n-    """\n+    """Registers modifiers with zope (on zope startup)."""\n     for m in modifiers:\n         context.registerClass(\n-            m[\'wrapper\'], m[\'id\'],\n-            permission = ManagePortal,\n-            constructors = (m[\'form\'], m[\'factory\']),\n-            icon = m[\'icon\'],\n+            m[\'wrapper\'],\n+            m[\'id\'],\n+            permission=ManagePortal,\n+            constructors=(m[\'form\'], m[\'factory\']),\n+            icon=m[\'icon\'],\n         )\n \n+\n def install(portal_modifier, ids=None):\n-    """Registers modifiers in the modifier registry (at tool install time).\n-    """\n+    """Registers modifiers in the modifier registry (at tool install time)."""\n     for m in modifiers:\n         id = m[\'id\']\n         if ids is not None and id not in ids:\n@@ -90,190 +91,201 @@ def install(portal_modifier, ids=None):\n         portal_modifier.register(m[\'id\'], wrapper)\n \n \n-manage_OMOutsideChildrensModifierAddForm = PageTemplateFile(\'www/OMOutsideChildrensModifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_OMOutsideChildrensModifierAddForm\')\n+manage_OMOutsideChildrensModifierAddForm = PageTemplateFile(\n+    \'www/OMOutsideChildrensModifierAddForm.pt\',\n+    globals(),\n+    __name__=\'manage_OMOutsideChildrensModifierAddForm\',\n+)\n+\n \n def manage_addOMOutsideChildrensModifier(self, id, title=None, REQUEST=None):\n-    """Add an object manager modifier treating childrens as outside refs\n-    """\n+    """Add an object manager modifier treating childrens as outside refs"""\n     modifier = OMOutsideChildrensModifier()\n     self._setObject(id, ConditionalTalesModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n \n \n-manage_OMInsideChildrensModifierAddForm = PageTemplateFile(\'www/OMInsideChildrensModifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_OMInsideChildrensModifierAddForm\')\n+manage_OMInsideChildrensModifierAddForm = PageTemplateFile(\n+    \'www/OMInsideChildrensModifierAddForm.pt\',\n+    globals(),\n+    __name__=\'manage_OMInsideChildrensModifierAddForm\',\n+)\n \n-def manage_addOMInsideChildrensModifier(self, id, title=None,\n-                                        REQUEST=None):\n-    """Add an object manager modifier treating children as inside refs\n-    """\n+\n+def manage_addOMInsideChildrensModifier(self, id, title=None, REQUEST=None):\n+    """Add an object manager modifier treating children as inside refs"""\n     modifier = OMInsideChildrensModifier()\n     self._setObject(id, ConditionalTalesModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+\n \n+manage_RetainUIDsModifierAddForm = PageTemplateFile(\n+    \'www/RetainUIDsModifierAddForm.pt\',\n+    globals(),\n+    __name__=\'manage_RetainUIDsModifierAddForm\',\n+)\n \n-manage_RetainUIDsModifierAddForm =  \\\n-                         PageTemplateFile(\'www/RetainUIDsModifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_RetainUIDsModifierAddForm\')\n \n def manage_addRetainUIDs(self, id, title=None, REQUEST=None):\n-    """Add a modifier retaining UIDs upon retrieve.\n-    """\n+    """Add a modifier retaining UIDs upon retrieve."""\n     modifier = RetainUIDs()\n     self._setObject(id, ConditionalModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+\n \n+manage_RetainWorkflowStateAndHistoryModifierAddForm = PageTemplateFile(\n+    \'www/RetainWorkflowStateAndHistoryModifierAddForm.pt\',\n+    globals(),\n+    __name__=\'manage_RetainWorkflowStateAndHistoryModifierAddForm\',\n+)\n \n-manage_RetainWorkflowStateAndHistoryModifierAddForm =  \\\n-                         PageTemplateFile(\'www/RetainWorkflowStateAndHistoryModifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_RetainWorkflowStateAndHistoryModifierAddForm\')\n \n-def manage_addRetainWorkflowStateAndHistory(self, id, title=None,\n-                                            REQUEST=None):\n-    """Add a modifier retaining workflow state upon retrieve.\n-    """\n+def manage_addRetainWorkflowStateAndHistory(self, id, title=None, REQUEST=None):\n+    """Add a modifier retaining workflow state upon retrieve."""\n     modifier = RetainWorkflowStateAndHistory()\n     self._setObject(id, ConditionalModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n \n \n-manage_RetainPermissionsSettingsAddForm =  \\\n-                         PageTemplateFile(\'www/RetainPermissionsSettingsModifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_RetainPermissionsSettingsModifierAddForm\')\n+manage_RetainPermissionsSettingsAddForm = PageTemplateFile(\n+    \'www/RetainPermissionsSettingsModifierAddForm.pt\',\n+    globals(),\n+    __name__=\'manage_RetainPermissionsSettingsModifierAddForm\',\n+)\n \n-def manage_addRetainPermissionsSettings(self, id, title=None,\n-                                            REQUEST=None):\n-    """Add a modifier retaining permissions upon retrieve.\n-    """\n+\n+def manage_addRetainPermissionsSettings(self, id, title=None, REQUEST=None):\n+    """Add a modifier retaining permissions upon retrieve."""\n     modifier = RetainPermissionsSettings()\n     self._setObject(id, ConditionalModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n \n \n-manage_SaveFileDataInFileTypeByReferenceModifierAddForm =  \\\n-                         PageTemplateFile(\'www/SaveFileDataInFileTypeByReferenceModifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_SaveFileDataInFileTypeByReferenceModifierAddForm\')\n+manage_SaveFileDataInFileTypeByReferenceModifierAddForm = PageTemplateFile(\n+    \'www/SaveFileDataInFileTypeByReferenceModifierAddForm.pt\',\n+    globals(),\n+    __name__=\'manage_SaveFileDataInFileTypeByReferenceModifierAddForm\',\n+)\n \n-def manage_addSaveFileDataInFileTypeByReference(self, id, title=None,\n-                                                REQUEST=None):\n-    """Add a modifier avoiding unnecessary cloning of file data.\n-    """\n+\n+def manage_addSaveFileDataInFileTypeByReference(self, id, title=None, REQUEST=None):\n+    """Add a modifier avoiding unnecessary cloning of file data."""\n     modifier = SaveFileDataInFileTypeByReference()\n     self._setObject(id, ConditionalTalesModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+\n \n # silly modifier just for demos\n-manage_SillyDemoRetrieveModifierAddForm =  \\\n-    PageTemplateFile(\'www/SillyDemoRetrieveModifierAddForm.pt\', globals(),\n-                     __name__=\'manage_SillyDemoRetrieveModifierAddForm\')\n+manage_SillyDemoRetrieveModifierAddForm = PageTemplateFile(\n+    \'www/SillyDemoRetrieveModifierAddForm.pt\',\n+    globals(),\n+    __name__=\'manage_SillyDemoRetrieveModifierAddForm\',\n+)\n \n-def manage_addSillyDemoRetrieveModifier(self, id, title=None,\n-                                            REQUEST=None):\n-    """Add a silly demo retrieve modifier\n-    """\n+\n+def manage_addSillyDemoRetrieveModifier(self, id, title=None, REQUEST=None):\n+    """Add a silly demo retrieve modifier"""\n     modifier = SillyDemoRetrieveModifier()\n     self._setObject(id, ConditionalTalesModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n \n \n-manage_AbortVersioningOfLargeFilesAndImagesAddForm =  \\\n-    PageTemplateFile(\'www/AbortVersioningOfLargeFilesAndImagesAddForm.pt\',\n-                  globals(),\n-                  __name__=\'manage_AbortVersioningOfLargeFilesAndImagesAddForm\')\n+manage_AbortVersioningOfLargeFilesAndImagesAddForm = PageTemplateFile(\n+    \'www/AbortVersioningOfLargeFilesAndImagesAddForm.pt\',\n+    globals(),\n+    __name__=\'manage_AbortVersioningOfLargeFilesAndImagesAddForm\',\n+)\n \n-def manage_addAbortVersioningOfLargeFilesAndImages(self, id, title=None,\n-                                            REQUEST=None):\n-    """Add a silly demo retrieve modifier\n-    """\n+\n+def manage_addAbortVersioningOfLargeFilesAndImages(self, id, title=None, REQUEST=None):\n+    """Add a silly demo retrieve modifier"""\n     modifier = AbortVersioningOfLargeFilesAndImages(id, title)\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n \n \n-manage_SkipVersioningOfLargeFilesAndImagesAddForm =  \\\n-    PageTemplateFile(\'www/SkipVersioningOfLargeFilesAndImagesAddForm.pt\',\n-                   globals(),\n-                   __name__=\'manage_SkipVersioningOfLargeFilesAndImagesAddForm\')\n+manage_SkipVersioningOfLargeFilesAndImagesAddForm = PageTemplateFile(\n+    \'www/SkipVersioningOfLargeFilesAndImagesAddForm.pt\',\n+    globals(),\n+    __name__=\'manage_SkipVersioningOfLargeFilesAndImagesAddForm\',\n+)\n \n-def manage_addSkipVersioningOfLargeFilesAndImages(self, id, title=None,\n-                                            REQUEST=None):\n-    """Add a silly demo retrieve modifier\n-    """\n+\n+def manage_addSkipVersioningOfLargeFilesAndImages(self, id, title=None, REQUEST=None):\n+    """Add a silly demo retrieve modifier"""\n     modifier = SkipVersioningOfLargeFilesAndImages(id, title)\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+\n+\n+manage_SkipParentPointersAddForm = PageTemplateFile(\n+    \'www/SkipParentPointersAddForm.pt\',\n+    globals(),\n+    __name__=\'manage_SkipParentPointersAddForm\',\n+)\n \n-manage_SkipParentPointersAddForm =  \\\n-    PageTemplateFile(\'www/SkipParentPointersAddForm.pt\',\n-                   globals(),\n-                   __name__=\'manage_SkipParentPointersAddForm\')\n \n def manage_addSkipParentPointers(self, id, title=None, REQUEST=None):\n-    """Add a skip parent pointers modifier\n-    """\n+    """Add a skip parent pointers modifier"""\n     modifier = SkipParentPointers(id, title)\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+\n+\n+manage_SkipRegistryBasesPointersAddForm = PageTemplateFile(\n+    \'www/SkipRegistryBasesPointersAddForm.pt\',\n+    globals(),\n+    __name__=\'manage_SkipRegistryBasesPointersAddForm\',\n+)\n \n-manage_SkipRegistryBasesPointersAddForm =  \\\n-    PageTemplateFile(\'www/SkipRegistryBasesPointersAddForm.pt\',\n-                   globals(),\n-                   __name__=\'manage_SkipRegistryBasesPointersAddForm\')\n \n def manage_addSkipRegistryBasesPointers(self, id, title=None, REQUEST=None):\n-    """Add a skip component registry bases modifier\n-    """\n+    """Add a skip component registry bases modifier"""\n     modifier = SkipRegistryBasesPointers(id, title)\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+\n+\n+manage_Skip_z3c_blobfileAddForm = PageTemplateFile(\n+    \'www/Skip_z3c_blobfile.pt\', globals(), __name__=\'manage_Skip_z3c_blobfileAddForm\'\n+)\n \n-manage_Skip_z3c_blobfileAddForm =  \\\n-    PageTemplateFile(\'www/Skip_z3c_blobfile.pt\',\n-                   globals(),\n-                   __name__=\'manage_Skip_z3c_blobfileAddForm\')\n \n def manage_addSkip_z3c_blobfile(self, id, title=None, REQUEST=None):\n-    """Add a skip z3c.blobfile modifier\n-    """\n+    """Add a skip z3c.blobfile modifier"""\n     modifier = Skip_z3c_blobfile(id, title)\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n \n \n-#----------------------------------------------------------------------\n+# ----------------------------------------------------------------------\n # Standard modifier implementation\n-#----------------------------------------------------------------------\n+# ----------------------------------------------------------------------\n+\n \n @implementer(ISaveRetrieveModifier)\n class RetainAttributeAnnotationItemsBase:\n@@ -305,15 +317,12 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n \n \n class OMBaseModifier(RetainAttributeAnnotationItemsBase):\n-    """Base class for ObjectManager modifiers.\n-    """\n+    """Base class for ObjectManager modifiers."""\n \n-    PRESERVE_ANNOTATION_KEYS = (DefaultOrdering.ORDER_KEY,\n-                                DefaultOrdering.POS_KEY)\n+    PRESERVE_ANNOTATION_KEYS = (DefaultOrdering.ORDER_KEY, DefaultOrdering.POS_KEY)\n \n     def _getOnCloneModifiers(self, obj):\n-        """Removes all childrens and returns them as references.\n-        """\n+        """Removes all childrens and returns them as references."""\n         portal_archivist = getToolByName(obj, \'portal_archivist\')\n         VersionAwareReference = portal_archivist.classes.VersionAwareReference\n \n@@ -340,8 +349,7 @@ def persistent_load(ignored):\n         return persistent_id, persistent_load, result_refs\n \n     def _beforeSaveModifier(self, obj, clone):\n-        """Returns all unititialized \'IVersionAwareReference\' objects.\n-        """\n+        """Returns all unititialized \'IVersionAwareReference\' objects."""\n         portal_archivist = getToolByName(obj, \'portal_archivist\')\n         adapter = portal_archivist.classes.ObjectManagerStorageAdapter\n \n@@ -354,7 +362,7 @@ def _beforeSaveModifier(self, obj, clone):\n         return result_refs\n \n     def _getAttributeNamesHandlingSubObjects(self, obj, repo_clone):\n-        attrs = list(set(tuple(repo_clone.objectIds())+tuple(obj.objectIds())))\n+        attrs = list(set(tuple(repo_clone.objectIds()) + tuple(obj.objectIds())))\n \n         if isinstance(obj, BTreeFolder2Base):\n             attrs.extend([\'_tree\', \'_count\', \'_mt_index\'])\n@@ -363,6 +371,7 @@ def _getAttributeNamesHandlingSubObjects(self, obj, repo_clone):\n \n         return attrs\n \n+\n @implementer(ICloneModifier, ISaveRetrieveModifier)\n class OMOutsideChildrensModifier(OMBaseModifier):\n     """ObjectManager modifier treating all childrens as outside refs\n@@ -372,8 +381,7 @@ class OMOutsideChildrensModifier(OMBaseModifier):\n     """\n \n     def getOnCloneModifiers(self, obj):\n-        """Removes all childrens and returns them as references.\n-        """\n+        """Removes all childrens and returns them as references."""\n         pers_id, pers_load, outside_refs = self._getOnCloneModifiers(obj)\n         return pers_id, pers_load, [], outside_refs, \'\'\n \n@@ -415,12 +423,13 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n             if orig_objects is not _marker:\n                 setattr(repo_clone, attr_name, orig_objects)\n \n-        RetainAttributeAnnotationItemsBase.afterRetrieveModifier(self, obj,\n-                                                                 repo_clone,\n-                                                                 preserve)\n+        RetainAttributeAnnotationItemsBase.afterRetrieveModifier(\n+            self, obj, repo_clone, preserve\n+        )\n \n         return [], ref_names, {}\n \n+\n InitializeClass(OMOutsideChildrensModifier)\n \n \n@@ -433,8 +442,7 @@ class OMInsideChildrensModifier(OMBaseModifier):\n     """\n \n     def getOnCloneModifiers(self, obj):\n-        """Removes all childrens and returns them as references.\n-        """\n+        """Removes all childrens and returns them as references."""\n         pers_id, pers_load, inside_refs = self._getOnCloneModifiers(obj)\n         return pers_id, pers_load, inside_refs, [], \'\'\n \n@@ -473,7 +481,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n             if histid is not None:\n                 orig_histids[histid] = id\n             else:\n-                orig_histids[\'no_history\'+id]=id\n+                orig_histids[\'no_history\' + id] = id\n \n         # (2) evaluate the refs that get replaced anyway\n         for varef in repo_clone.objectValues():\n@@ -482,8 +490,9 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n                 del orig_histids[histid]\n \n         # (3) build the list of adapters to the references to be removed\n-        refs_to_be_deleted = \\\n-            [OMSubObjectAdapter(obj, name) for name in orig_histids.values()]\n+        refs_to_be_deleted = [\n+            OMSubObjectAdapter(obj, name) for name in orig_histids.values()\n+        ]\n \n         # return all attribute names that have something to do with\n         # referencing\n@@ -492,32 +501,29 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         # We copy the ordering annotations from the working copy to\n         # the repo clone, so that we don\'t have inconsistencies between the\n         # objectValues and objectIds.\n-        RetainAttributeAnnotationItemsBase.afterRetrieveModifier(self, obj,\n-                                                                 repo_clone)\n+        RetainAttributeAnnotationItemsBase.afterRetrieveModifier(self, obj, repo_clone)\n \n         return refs_to_be_deleted, ref_names, {}\n \n+\n InitializeClass(OMInsideChildrensModifier)\n \n+\n @implementer(IReferenceAdapter)\n class OMSubObjectAdapter:\n-    """Adapter to an object manager children.\n-    """\n+    """Adapter to an object manager children."""\n \n     def __init__(self, obj, name):\n-        """Initialize the adapter.\n-        """\n+        """Initialize the adapter."""\n         self._obj = obj\n         self._name = name\n \n     def save(self, dict):\n-        """See interface\n-        """\n+        """See interface"""\n         dict[self._name] = self._obj._getOb(self._name)\n \n     def remove(self, permanent=False):\n-        """See interface\n-        """\n+        """See interface"""\n         # XXX do we want there is the ``manage_afterDelete`` hook called?\n         # The decision has to go into the interface documentation.\n         # IM(alecm)O, we should update the catalog if the change is permanent\n@@ -565,20 +571,20 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         # one of the working copy or delete it\n         if getattr(aq_base(obj), \'review_state\', _marker) is not _marker:\n             repo_clone.review_state = obj.review_state\n-        elif (getattr(aq_base(repo_clone), \'review_state\', _marker)\n-              is not _marker):\n+        elif getattr(aq_base(repo_clone), \'review_state\', _marker) is not _marker:\n             del repo_clone.review_state\n \n         if getattr(aq_base(obj), \'workflow_history\', _marker) is not _marker:\n             repo_clone.workflow_history = obj.workflow_history\n-        elif (getattr(aq_base(repo_clone), \'workflow_history\', _marker)\n-              is not _marker):\n+        elif getattr(aq_base(repo_clone), \'workflow_history\', _marker) is not _marker:\n             del repo_clone.workflow_history\n \n         return [], [], {}\n \n+\n InitializeClass(RetainWorkflowStateAndHistory)\n \n+\n @implementer(ISaveRetrieveModifier)\n class RetainPermissionsSettings:\n     """Standard modifier retaining permissions settings\n@@ -603,12 +609,14 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n \n         return [], [], {}\n \n+\n InitializeClass(RetainPermissionsSettings)\n \n+\n @implementer(ISaveRetrieveModifier)\n class RetainUIDs:\n     """Modifier which ensures uid consistency by retaining the uid from the working copy.  Ensuring\n-       that newly created objects are assigned an appropriate uid is a job for the repository tool.\n+    that newly created objects are assigned an appropriate uid is a job for the repository tool.\n     """\n \n     def beforeSaveModifier(self, obj, clone):\n@@ -619,7 +627,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         if obj is None:\n             return [], [], {}\n \n-        #Preserve CMFUid\n+        # Preserve CMFUid\n         uid_tool = getToolByName(obj, \'portal_historyidhandler\', None)\n         if uid_tool is not None:\n             working_uid = uid_tool.queryUid(obj)\n@@ -629,6 +637,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n \n         return [], [], {}\n \n+\n InitializeClass(RetainUIDs)\n \n \n@@ -640,7 +649,7 @@ class SaveFileDataInFileTypeByReference:\n     """\n \n     def getReferencedAttributes(self, obj):\n-        return {\'data\': getattr(aq_base(obj),\'data\', None)}\n+        return {\'data\': getattr(aq_base(obj), \'data\', None)}\n \n     def reattachReferencedAttributes(self, obj, attrs_dict):\n \n@@ -651,6 +660,7 @@ def reattachReferencedAttributes(self, obj, attrs_dict):\n \n InitializeClass(SaveFileDataInFileTypeByReference)\n \n+\n @implementer(ICloneModifier, ISaveRetrieveModifier)\n class SkipParentPointers:\n     """Standard modifier to avoid cloning of __parent__ pointers and\n@@ -658,8 +668,7 @@ class SkipParentPointers:\n     """\n \n     def getOnCloneModifiers(self, obj):\n-        """Removes parent pointers and stores a marker\n-        """\n+        """Removes parent pointers and stores a marker"""\n         parent = getattr(obj, \'__parent__\', _marker)\n         if parent is _marker:\n             return None\n@@ -683,10 +692,14 @@ def beforeSaveModifier(self, obj, clone):\n \n     def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         """Install the parent from the working copy"""\n-        if (getattr(repo_clone, \'__parent__\', _marker) is None\n-            and getattr(obj, \'__parent__\', _marker) is not _marker):\n+        if (\n+            getattr(repo_clone, \'__parent__\', _marker) is None\n+            and getattr(obj, \'__parent__\', _marker) is not _marker\n+        ):\n             repo_clone.__parent__ = obj.__parent__\n         return [], [], {}\n+\n+\n InitializeClass(SkipParentPointers)\n \n \n@@ -706,19 +719,24 @@ def querySiteManager(self, obj):\n         return registry\n \n     def getOnCloneModifiers(self, obj):\n-        """Removes component registry bases pointers and stores a marker\n-        """\n+        """Removes component registry bases pointers and stores a marker"""\n         registry = self.querySiteManager(obj)\n         if registry is None:\n             return\n \n         component_bases = dict(\n-            registry=dict((id(aq_base(base)), aq_base(base))\n-                          for base in registry.__bases__),\n-            utilities=dict((id(aq_base(base)), aq_base(base))\n-                           for base in registry.utilities.__bases__),\n-            adapters=dict((id(aq_base(base)), aq_base(base))\n-                           for base in registry.adapters.__bases__))\n+            registry=dict(\n+                (id(aq_base(base)), aq_base(base)) for base in registry.__bases__\n+            ),\n+            utilities=dict(\n+                (id(aq_base(base)), aq_base(base))\n+                for base in registry.utilities.__bases__\n+            ),\n+            adapters=dict(\n+                (id(aq_base(base)), aq_base(base))\n+                for base in registry.adapters.__bases__\n+            ),\n+        )\n \n         def persistent_id(obj):\n             obj_id = id(aq_base(obj))\n@@ -747,6 +765,8 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n             obj_sm = obj.getSiteManager()\n             sm.__bases__ = obj_sm.__bases__\n         return [], [], {}\n+\n+\n InitializeClass(SkipRegistryBasesPointers)\n \n \n@@ -765,6 +785,7 @@ def beforeSaveModifier(self, obj, clone):\n \n     def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         from AccessControl import getSecurityManager\n+\n         if getSecurityManager().getUser().getUserName() != "gregweb":\n             return [], [], {}\n \n@@ -781,6 +802,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n \n         return [], [], {}\n \n+\n InitializeClass(SillyDemoRetrieveModifier)\n \n \n@@ -790,25 +812,32 @@ class AbortVersioningOfLargeFilesAndImages(ConditionalTalesModifier):\n     object in a specified field is larger than a fixed default"""\n \n     field_names = (\'file\', \'image\')\n-    max_size = 26214400 # This represents a 400 element long Pdata list\n+    max_size = 26214400  # This represents a 400 element long Pdata list\n \n-    modifierEditForm = PageTemplateFile(\'www/fieldModifierEditForm.pt\',\n-                                        globals(),\n-                                        __name__=\'modifierEditForm\')\n+    modifierEditForm = PageTemplateFile(\n+        \'www/fieldModifierEditForm.pt\', globals(), __name__=\'modifierEditForm\'\n+    )\n \n     _condition = Expression("python: portal_type in (\'Image\', \'File\')")\n \n-    def __init__(self, id=\'AbortVersioningOfLargeFilesAndImages\', modifier=None,\n-                 title=\'\'):\n+    def __init__(\n+        self, id=\'AbortVersioningOfLargeFilesAndImages\', modifier=None, title=\'\'\n+    ):\n         self.id = str(id)\n         self.title = str(title)\n         self.meta_type = \'edmod_%s\' % id\n         self._enabled = False\n \n-    def edit(self, enabled=None, condition=None, title=\'\', field_names=None,\n-             max_size=None, REQUEST=None):\n-        """See IConditionalTalesModifier.\n-        """\n+    def edit(\n+        self,\n+        enabled=None,\n+        condition=None,\n+        title=\'\',\n+        field_names=None,\n+        max_size=None,\n+        REQUEST=None,\n+    ):\n+        """See IConditionalTalesModifier."""\n         if max_size is not None:\n             self.max_size = int(max_size)\n         if field_names is not None:\n@@ -822,7 +851,7 @@ def getFieldNames(self):\n         return \'\\n\'.join(self.field_names)\n \n     def getModifier(self):\n-        """We are the modifier, not some silly wrapper. """\n+        """We are the modifier, not some silly wrapper."""\n         return self\n \n     def _getFieldValues(self, obj):\n@@ -835,7 +864,7 @@ def _getFieldValues(self, obj):\n         We used to also have \'annotation\', but that was only for\n         fields stored via Archetypes AnnotationStorage.\n         """\n-        max_size  = self.max_size\n+        max_size = self.max_size\n \n         # Search for fields stored via AttributeStorage\n         for name in self.field_names:\n@@ -847,32 +876,34 @@ def _getFieldValues(self, obj):\n                     yield \'attribute\', name, val\n \n     def getOnCloneModifiers(self, obj):\n-        """Detects large file objects and raises an error\n-        """\n+        """Detects large file objects and raises an error"""\n         for storage, name, val in self._getFieldValues(obj):\n             # if we find a file that\'s too big, abort\n             raise FileTooLargeToVersionError\n-        return None # no effect otherwise\n+        return None  # no effect otherwise\n+\n \n InitializeClass(AbortVersioningOfLargeFilesAndImages)\n \n-_empty_marker =[]\n+_empty_marker = []\n+\n+\n class LargeFilePlaceHolder(object):\n     """PlaceHolder for a large object"""\n+\n     @staticmethod\n     def getSize():\n         return sys.maxsize\n \n-@implementer(IConditionalTalesModifier, ICloneModifier,\n-                      ISaveRetrieveModifier)\n+\n+@implementer(IConditionalTalesModifier, ICloneModifier, ISaveRetrieveModifier)\n class SkipVersioningOfLargeFilesAndImages(AbortVersioningOfLargeFilesAndImages):\n     """Replaces any excessively large file and images stored as\n     annotations or attributes on the object with a marker.  On\n     retrieve, the marker will be replaced with the current value.."""\n \n     def getOnCloneModifiers(self, obj):\n-        """Removes large file objects and returns them as references\n-        """\n+        """Removes large file objects and returns them as references"""\n         refs = {}\n         ref_list = []\n         for storage, name, val in self._getFieldValues(obj):\n@@ -880,7 +911,7 @@ def getOnCloneModifiers(self, obj):\n             refs[id(val)] = True\n \n         if not refs:\n-            return None # don\'t do anything\n+            return None  # don\'t do anything\n \n         def persistent_id(obj):\n             return refs.get(id(obj), None)\n@@ -908,6 +939,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n                     delattr(repo_clone, name)\n         return [], [], {}\n \n+\n InitializeClass(SkipVersioningOfLargeFilesAndImages)\n \n \n@@ -935,14 +967,16 @@ def _blob_file_classes(self):\n         return tuple(blob_file_classes)\n \n     def getOnCloneModifiers(self, obj):\n-        """Removes z3c.blobfile fields\n-        """\n+        """Removes z3c.blobfile fields"""\n         blob_file_classes = self._blob_file_classes()\n         if not blob_file_classes:\n             return\n \n-        blob_refs = set(id(v) for v in six.itervalues(obj.__dict__)\n-                        if isinstance(v, blob_file_classes))\n+        blob_refs = set(\n+            id(v)\n+            for v in six.itervalues(obj.__dict__)\n+            if isinstance(v, blob_file_classes)\n+        )\n \n         def persistent_id(obj):\n             if id(aq_base(obj)) in blob_refs:\n@@ -965,19 +999,23 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         if obj is None:\n             return [], [], {}\n \n-        blob_fields = ((k, v) for k, v in six.iteritems(obj.__dict__)\n-                        if isinstance(v, blob_file_classes))\n+        blob_fields = (\n+            (k, v)\n+            for k, v in six.iteritems(obj.__dict__)\n+            if isinstance(v, blob_file_classes)\n+        )\n \n         for k, v in blob_fields:\n             setattr(repo_clone, k, v)\n \n         return [], [], {}\n \n+\n InitializeClass(Skip_z3c_blobfile)\n \n-#----------------------------------------------------------------------\n+# ----------------------------------------------------------------------\n # Standard modifier configuration\n-#----------------------------------------------------------------------\n+# ----------------------------------------------------------------------\n \n modifiers = (\n     {\n@@ -1028,7 +1066,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         \'enabled\': True,\n         \'wrapper\': ConditionalModifier,\n         \'modifier\': RetainPermissionsSettings,\n-        \'form\': manage_RetainPermissionsSettingsAddForm ,\n+        \'form\': manage_RetainPermissionsSettingsAddForm,\n         \'factory\': manage_addRetainPermissionsSettings,\n         \'icon\': \'www/modifier.gif\',\n     },\ndiff --git a/Products/CMFEditions/StorageMigrationSupport.py b/Products/CMFEditions/StorageMigrationSupport.py\nindex e8f5ad8..a21f692 100644\n--- a/Products/CMFEditions/StorageMigrationSupport.py\n+++ b/Products/CMFEditions/StorageMigrationSupport.py\n@@ -34,16 +34,19 @@\n \n logger = logging.getLogger(\'CMFEditions\')\n \n+\n def create(context, type, name):\n     context.invokeFactory(type, name)\n     obj = getattr(context, name)\n     editMethods[type](obj, version=0)\n     return obj\n \n+\n def edit(obj, version):\n     type = obj.getPortalTypeName()\n     editMethods[type](obj, version)\n \n+\n def editEvent(context, version=0):\n     title = context.Title()\n     desc = context.Description()\n@@ -63,9 +66,14 @@ def editEvent(context, version=0):\n         location = "%s%s" % (version, location[1:])\n         contact = "%s%s" % (version, contact[1:])\n \n-    context.update(title=title, description=desc,\n-                   eventType=eventType, location=location,\n-                   contactName=contact)\n+    context.update(\n+        title=title,\n+        description=desc,\n+        eventType=eventType,\n+        location=location,\n+        contactName=contact,\n+    )\n+\n \n def editFile(context, version=0):\n     title = context.Title()\n@@ -82,6 +90,7 @@ def editFile(context, version=0):\n         file = 100 * ("%s%s" % (version, ": %s file body\\n" % name))\n     context.update(title=title, description=desc, file=file)\n \n+\n def editFolder(context, version=0):\n     title = context.Title()\n     desc = context.Description()\n@@ -93,6 +102,7 @@ def editFolder(context, version=0):\n     desc = "%s%s" % (version, desc[1:])\n     context.folder_edit(title=title, description=desc)\n \n+\n def editImage(context, version=0):\n     title = context.Title()\n     desc = context.Description()\n@@ -112,6 +122,7 @@ def editImage(context, version=0):\n         desc = "%s%s" % (version, desc[1:])\n     context.update(title=title, description=desc, image=image)\n \n+\n def editLink(context, version=0):\n     title = context.Title()\n     desc = context.Description()\n@@ -127,6 +138,7 @@ def editLink(context, version=0):\n         remoteUrl = "%s%s" % (remoteUrl[:-1], version)\n     context.update(title=title, description=desc, remoteUrl=remoteUrl)\n \n+\n def editNewsItem(context, version=0):\n     title = context.Title()\n     desc = context.Description()\n@@ -142,6 +154,7 @@ def editNewsItem(context, version=0):\n         text = "%s%s" % (version, text[1:])\n     context.update(title=title, description=desc, text=text)\n \n+\n def editDocument(context, version=0):\n     title = context.Title()\n     desc = context.Description()\n@@ -161,6 +174,7 @@ def editDocument(context, version=0):\n def editTopic(context, version=0):\n     pass\n \n+\n editMethods = {\n     "Event": editEvent,\n     "File": editFile,\n@@ -183,16 +197,19 @@ def editTopic(context, version=0):\n     "topics": ("Folder", "Topic", 0, 0),\n }\n \n+\n def createTestHierarchy(context):\n     startTime = time.time()\n     repo = getToolByName(context, "portal_repository")\n-    testRoot = create(context,  "Folder", "CMFEditionsTestHierarchy")\n+    testRoot = create(context, "Folder", "CMFEditionsTestHierarchy")\n     nbrOfObjects = 0\n     nbrOfEdits = 0\n     nbrOfSaves = 0\n     for name, type in hierarchy.items():\n-        logger.log(logging.INFO, "createTestHierarchy: creating container %s(%s)" \\\n-            % (name, type[0]))\n+        logger.log(\n+            logging.INFO,\n+            "createTestHierarchy: creating container %s(%s)" % (name, type[0]),\n+        )\n         folder = create(testRoot, type[0], name)\n         nbrOfObjects += 1\n         logger.log(logging.INFO, "createTestHierarchy: save #0")\n@@ -205,9 +222,11 @@ def createTestHierarchy(context):\n                 ext = ""\n \n             # create and save\n-            objName = name[:-1]+str(i+1)+ext\n-            logger.log(logging.INFO, "createTestHierarchy: creating %s(%s)" \\\n-                % (objName, type[1]))\n+            objName = name[:-1] + str(i + 1) + ext\n+            logger.log(\n+                logging.INFO,\n+                "createTestHierarchy: creating %s(%s)" % (objName, type[1]),\n+            )\n             obj = create(folder, type[1], objName)\n             nbrOfObjects += 1\n             logger.log(logging.INFO, "createTestHierarchy: save #0")\n@@ -223,7 +242,7 @@ def createTestHierarchy(context):\n                 repo.save(obj, comment="save #%s" % j)\n                 nbrOfSaves += 1\n \n-                vers = j + i*(type[3]-1)\n+                vers = j + i * (type[3] - 1)\n                 logger.log(logging.INFO, "createTestHierarchy: editing parent")\n                 edit(folder, vers)\n                 nbrOfEdits += 1\n@@ -232,8 +251,10 @@ def createTestHierarchy(context):\n                 nbrOfSaves += 1\n \n     totalTime = time.time() - startTime\n-    logger.log(logging.INFO,\n-        "createTestHierarchy: created %s objects, edited them %s times and saved %s versions in total in %.1f seconds" \\\n-        % (nbrOfObjects, nbrOfEdits, nbrOfSaves, round(totalTime, 1)))\n+    logger.log(\n+        logging.INFO,\n+        "createTestHierarchy: created %s objects, edited them %s times and saved %s versions in total in %.1f seconds"\n+        % (nbrOfObjects, nbrOfEdits, nbrOfSaves, round(totalTime, 1)),\n+    )\n \n     return testRoot\ndiff --git a/Products/CMFEditions/UniqueIdHandlerTool.py b/Products/CMFEditions/UniqueIdHandlerTool.py\nindex 483ef51..2ae1c5d 100644\n--- a/Products/CMFEditions/UniqueIdHandlerTool.py\n+++ b/Products/CMFEditions/UniqueIdHandlerTool.py\n@@ -1,9 +1,9 @@\n from zope.deferredimport import deprecated\n \n \n-deprecated("UniqueIdHandlerTool has been removed; "\n+deprecated(\n+    "UniqueIdHandlerTool has been removed; "\n     "use Products.CMFEditions.historyidhandlertool.HistoryIdHandlerTool or "\n     "Products.CMFUid.UniqueIdHandlerTool.UniqueIdHandlerTool",\n-    UniqueIdHandlerTool=(\n-        \'Products.CMFUid.UniqueIdHandlerTool:UniqueIdHandlerTool\'),\n-    )\n+    UniqueIdHandlerTool=(\'Products.CMFUid.UniqueIdHandlerTool:UniqueIdHandlerTool\'),\n+)\ndiff --git a/Products/CMFEditions/VersionPolicies.py b/Products/CMFEditions/VersionPolicies.py\nindex de1c7a3..2967327 100644\n--- a/Products/CMFEditions/VersionPolicies.py\n+++ b/Products/CMFEditions/VersionPolicies.py\n@@ -40,6 +40,7 @@ def __init__(self, obj_id, title, **kw):\n         self.title = title\n \n     security.declarePublic(\'Title\')\n+\n     def Title(self):\n         return self.title\n \n@@ -61,4 +62,5 @@ class ATVersionOnEditPolicy(VersionPolicy):\n     Most importantly: if a policy with this id is enabled for a portal_type,\n     no matter which class is behind it, a new version is stored on edit.\n     """\n+\n     pass\ndiff --git a/Products/CMFEditions/ZVCStorageTool.py b/Products/CMFEditions/ZVCStorageTool.py\nindex b83aaa5..68be55b 100644\n--- a/Products/CMFEditions/ZVCStorageTool.py\n+++ b/Products/CMFEditions/ZVCStorageTool.py\n@@ -65,6 +65,7 @@\n \n logger = logging.getLogger(\'CMFEditions\')\n \n+\n def deepCopy(obj):\n     stream = BytesIO()\n     p = Pickler(stream, 1)\n@@ -73,9 +74,9 @@ def deepCopy(obj):\n     u = Unpickler(stream)\n     return u.load()\n \n+\n def getSize(obj):\n-    """Calculate the size as cheap as possible\n-    """\n+    """Calculate the size as cheap as possible"""\n     # Try the cheap variants first.\n     # Actually the checks ensure the code never fails but beeing sure\n     # is better.\n@@ -127,9 +128,10 @@ def getSize(obj):\n \n \n @implementer(\n-        IPurgeSupport,\n-        IStorage,\n-        IStorageTool,)\n+    IPurgeSupport,\n+    IStorage,\n+    IStorageTool,\n+)\n class ZVCStorageTool(UniqueObject, SimpleItem):\n     """Zope Version Control Based Version Storage\n \n@@ -156,11 +158,12 @@ class ZVCStorageTool(UniqueObject, SimpleItem):\n \n     meta_type = \'CMFEditions Portal ZVC based Histories Storage Tool\'\n \n-    storageStatistics = PageTemplateFile(\'www/storageStatistics.pt\',\n-                                         globals(),\n-                                         __name__=\'modifierEditForm\')\n-    manage_options = ({\'label\' : \'Statistics (may take time)\', \'action\' : \'storageStatistics\'}, ) \\\n-                     + SimpleItem.manage_options[:]\n+    storageStatistics = PageTemplateFile(\n+        \'www/storageStatistics.pt\', globals(), __name__=\'modifierEditForm\'\n+    )\n+    manage_options = (\n+        {\'label\': \'Statistics (may take time)\', \'action\': \'storageStatistics\'},\n+    ) + SimpleItem.manage_options[:]\n \n     # make exceptions available trough the tool\n     StorageError = StorageError\n@@ -180,9 +183,9 @@ class ZVCStorageTool(UniqueObject, SimpleItem):\n     # -------------------------------------------------------------------\n \n     security.declarePrivate(\'isRegistered\')\n+\n     def isRegistered(self, history_id):\n-        """See IStorage.\n-        """\n+        """See IStorage."""\n         # Do not wake up the ZODB (aka write to it) if there wasn\'t any\n         # version saved yet.\n         shadow_storage = self._getShadowStorage(autoAdd=False)\n@@ -191,9 +194,9 @@ def isRegistered(self, history_id):\n         return shadow_storage.isRegistered(history_id)\n \n     security.declarePrivate(\'register\')\n+\n     def register(self, history_id, object, referenced_data={}, metadata=None):\n-        """See IStorage.\n-        """\n+        """See IStorage."""\n         # check if already registered\n         if self.isRegistered(history_id):\n             return\n@@ -202,24 +205,25 @@ def register(self, history_id, object, referenced_data={}, metadata=None):\n         shadowInfo = {"vc_info": None}\n         zvc_method = self._getZVCRepo().applyVersionControl\n         try:\n-            return self._applyOrCheckin(zvc_method, history_id, shadowInfo,\n-                                        object, referenced_data, metadata)\n+            return self._applyOrCheckin(\n+                zvc_method, history_id, shadowInfo, object, referenced_data, metadata\n+            )\n         except VersionControlError:\n             raise StorageRegisterError(\n                 "Registering the object with history id \'%s\' failed. "\n-                "The underlying storage implementation reported an error."\n-                % history_id)\n+                "The underlying storage implementation reported an error." % history_id\n+            )\n \n     security.declarePrivate(\'save\')\n+\n     def save(self, history_id, object, referenced_data={}, metadata=None):\n-        """See IStorage.\n-        """\n+        """See IStorage."""\n         # check if already registered\n         if not self.isRegistered(history_id):\n             raise StorageUnregisteredError(\n                 "Saving an unregistered object is not possible. "\n-                "Register the object with history id \'%s\' first. "\n-                % history_id)\n+                "Register the object with history id \'%s\' first. " % history_id\n+            )\n \n         # retrieve the ZVC info from the youngest version\n         history = self._getShadowHistory(history_id, autoAdd=True)\n@@ -227,35 +231,37 @@ def save(self, history_id, object, referenced_data={}, metadata=None):\n \n         zvc_method = self._getZVCRepo().checkinResource\n         try:\n-            return self._applyOrCheckin(zvc_method, history_id, shadowInfo,\n-                                        object, referenced_data, metadata)\n+            return self._applyOrCheckin(\n+                zvc_method, history_id, shadowInfo, object, referenced_data, metadata\n+            )\n         except VersionControlError:\n             # this shouldn\'t really happen\n             raise StorageSaveError(\n                 "Saving the object with history id \'%s\' failed. "\n-                "The underlying storage implementation reported an error."\n-                % history_id)\n+                "The underlying storage implementation reported an error." % history_id\n+            )\n \n     security.declarePrivate(\'retrieve\')\n-    def retrieve(self, history_id, selector=None,\n-                 countPurged=True, substitute=True):\n-        """See ``IStorage`` and Comments in ``IPurgePolicy``\n-        """\n+\n+    def retrieve(self, history_id, selector=None, countPurged=True, substitute=True):\n+        """See ``IStorage`` and Comments in ``IPurgePolicy``"""\n         zvc_repo = self._getZVCRepo()\n-        zvc_histid, zvc_selector = \\\n-            self._getZVCAccessInfo(history_id, selector, countPurged)\n+        zvc_histid, zvc_selector = self._getZVCAccessInfo(\n+            history_id, selector, countPurged\n+        )\n \n         if zvc_histid is None:\n             raise StorageRetrieveError(\n                 "Retrieving version \'%s\' of object with history id \'%s\' "\n                 "failed. A history with the given history id does not exist."\n-                % (selector, history_id))\n+                % (selector, history_id)\n+            )\n \n         if zvc_selector is None:\n             raise StorageRetrieveError(\n                 "Retrieving version \'%s\' of object with history id \'%s\' "\n-                "failed. The version does not exist."\n-                % (selector, history_id))\n+                "failed. The version does not exist." % (selector, history_id)\n+            )\n \n         # retrieve the object\n         try:\n@@ -265,7 +271,8 @@ def retrieve(self, history_id, selector=None,\n             raise StorageRetrieveError(\n                 "Retrieving version \'%s\' of object with history id \'%s\' "\n                 "failed. The underlying storage implementation reported "\n-                "an error." % (selector, history_id))\n+                "an error." % (selector, history_id)\n+            )\n \n         # retrieve metadata\n         # TODO: read this from the shadow storage directly\n@@ -286,47 +293,48 @@ def retrieve(self, history_id, selector=None,\n             # removed object\n             policy = getToolByName(self, \'portal_purgepolicy\', None)\n             if policy is not None:\n-                data = policy.retrieveSubstitute(history_id, selector,\n-                                                 default=data)\n+                data = policy.retrieveSubstitute(history_id, selector, default=data)\n         return data\n \n     security.declarePrivate(\'getHistory\')\n+\n     def getHistory(self, history_id, countPurged=True, substitute=True):\n-        """See IStorage.\n-        """\n+        """See IStorage."""\n         return LazyHistory(self, history_id, countPurged, substitute)\n \n     security.declarePrivate(\'getModificationDate\')\n-    def getModificationDate(self, history_id, selector=None,\n-                            countPurged=True, substitute=True):\n-        """See IStorage.\n-        """\n+\n+    def getModificationDate(\n+        self, history_id, selector=None, countPurged=True, substitute=True\n+    ):\n+        """See IStorage."""\n         vdata = self.retrieve(history_id, selector, countPurged, substitute)\n         return vdata.object.object.modified()\n \n-\n     # -------------------------------------------------------------------\n     # methods implementing IPurgeSupport\n     # -------------------------------------------------------------------\n \n     security.declarePrivate(\'purge\')\n+\n     def purge(self, history_id, selector, metadata={}, countPurged=True):\n-        """See ``IPurgeSupport``\n-        """\n+        """See ``IPurgeSupport``"""\n         zvc_repo = self._getZVCRepo()\n-        zvc_histid, zvc_selector = \\\n-            self._getZVCAccessInfo(history_id, selector, countPurged)\n+        zvc_histid, zvc_selector = self._getZVCAccessInfo(\n+            history_id, selector, countPurged\n+        )\n         if zvc_histid is None:\n             raise StoragePurgeError(\n                 "Purging version \'%s\' of object with history id \'%s\' "\n                 "failed. A history with the given history id does not exist."\n-                % (selector, history_id))\n+                % (selector, history_id)\n+            )\n \n         if zvc_selector is None:\n             raise StoragePurgeError(\n                 "Purging version \'%s\' of object with history id \'%s\' "\n-                "failed. The version does not exist."\n-                % (selector, history_id))\n+                "failed. The version does not exist." % (selector, history_id)\n+            )\n \n         # digging into ZVC internals:\n         # Get a reference to the version stored in the ZVC history storage\n@@ -357,15 +365,14 @@ def purge(self, history_id, selector, metadata={}, countPurged=True):\n             logEntry = self._retrieveZVCLogEntry(zvc_histid, zvc_selector)\n             logEntry.message = self._encodeMetadata(metadata)\n \n-\n     # -------------------------------------------------------------------\n     # private helper methods\n     # -------------------------------------------------------------------\n \n-    def _applyOrCheckin(self, zvc_method, history_id, shadowInfo,\n-                        object, referenced_data, metadata):\n-        """Just centralizing similar code.\n-        """\n+    def _applyOrCheckin(\n+        self, zvc_method, history_id, shadowInfo, object, referenced_data, metadata\n+    ):\n+        """Just centralizing similar code."""\n         # delegate the decision if and what to purge to the purge policy\n         # tool if one exists. If the call returns ``False`` do not save\n         # or register the current version.\n@@ -387,8 +394,7 @@ def _applyOrCheckin(self, zvc_method, history_id, shadowInfo,\n         #   (selector=None).\n         # - Wrap the object, the referenced data and metadata\n         vc_info = self._getVcInfo(object, shadowInfo)\n-        zvc_obj = ZVCAwareWrapper(object, metadata,\n-                                  vc_info)\n+        zvc_obj = ZVCAwareWrapper(object, metadata, vc_info)\n         message = self._encodeMetadata(metadata)\n \n         # call appropriate ZVC method\n@@ -416,9 +422,10 @@ def _getShadowStorage(self, autoAdd=True):\n         return self._shadowStorage\n \n     security.declarePrivate(\'getHistoryMetadata\')\n+\n     def getHistoryMetadata(self, history_id):\n-        """ Return the metadata blob from ShadowHistory for presenting\n-            summary information, etc.\n+        """Return the metadata blob from ShadowHistory for presenting\n+        summary information, etc.\n         """\n         if history_id is None:\n             return []\n@@ -428,8 +435,7 @@ def getHistoryMetadata(self, history_id):\n         return hist\n \n     def _getShadowHistory(self, history_id, autoAdd=False):\n-        """Returns a History from the Shadow Storage\n-        """\n+        """Returns a History from the Shadow Storage"""\n         return self._getShadowStorage().getHistory(history_id, autoAdd)\n \n     def _getZVCRepo(self):\n@@ -464,8 +470,7 @@ def _getZVCAccessInfo(self, history_id, selector, countPurged):\n         return zvc_hid, zvc_vid\n \n     def _getVcInfo(self, obj, shadowInfo, set_checked_in=False):\n-        """Recalls ZVC Related Informations and Attaches them to the Object\n-        """\n+        """Recalls ZVC Related Informations and Attaches them to the Object"""\n         vc_info = deepCopy(shadowInfo["vc_info"])\n         if vc_info is None:\n             return None\n@@ -498,13 +503,18 @@ def _retrieveZVCLogEntry(self, zvc_histid, zvc_selector):\n         zvc_repo = self._getZVCRepo()\n         log = zvc_repo.getVersionHistory(zvc_histid).getLogEntries()\n         checkin = LogEntry.ACTION_CHECKIN\n-        entries = [e for e in log if e.version_id==zvc_selector and e.action==checkin]\n+        entries = [\n+            e for e in log if e.version_id == zvc_selector and e.action == checkin\n+        ]\n \n         # just make a log entry if something wrong happened\n         if len(entries) != 1:\n-            logger.log(logging.INFO, "CMFEditions ASSERT:"\n-                     "Uups, an object has been stored %s times with the same "\n-                     "history \'%s\'!!!" % (len(entries), zvc_selector))\n+            logger.log(\n+                logging.INFO,\n+                "CMFEditions ASSERT:"\n+                "Uups, an object has been stored %s times with the same "\n+                "history \'%s\'!!!" % (len(entries), zvc_selector),\n+            )\n \n         return entries[0]\n \n@@ -524,7 +534,6 @@ def _retrieveMetadataFromZVC(self, zvc_histid, zvc_selector):\n         metadata = loads(logEntry.message.split(b\'\\x00\\n\', 1)[1])\n         return metadata\n \n-\n     # -------------------------------------------------------------------\n     # Migration Support\n     #\n@@ -532,37 +541,47 @@ def _retrieveMetadataFromZVC(self, zvc_histid, zvc_selector):\n     # -------------------------------------------------------------------\n \n     def _is10alpha3Layout(self):\n-        """Returns True if Storage is of 1.0alpha3 layout\n-        """\n+        """Returns True if Storage is of 1.0alpha3 layout"""\n         return getattr(self, "_history_id_mapping", None) is not None\n \n     def migrateStorage(self):\n-        """Migrate the Storage to Newest Layout\n-        """\n+        """Migrate the Storage to Newest Layout"""\n         # check if already done\n         if not self._is10alpha3Layout():\n-            logger.log(logging.INFO, "CMFEditions storage migration:"\n-                "Storage already migrated.")\n+            logger.log(\n+                logging.INFO,\n+                "CMFEditions storage migration:" "Storage already migrated.",\n+            )\n             return None\n \n         startTime = time.time()\n-        logger.log(logging.INFO, "CMFEditions storage migration:"\n-            "started migrating the whole storage")\n+        logger.log(\n+            logging.INFO,\n+            "CMFEditions storage migration:" "started migrating the whole storage",\n+        )\n         from Products.ZopeVersionControl.Utility import VersionInfo\n \n         # build reverse mapping: zvc history id --> CMFEditions history id\n-        logger.log(logging.INFO, "CMFEditions storage migration:"\n-            "preparing history mapping CMFEditions <--> ZVC")\n+        logger.log(\n+            logging.INFO,\n+            "CMFEditions storage migration:"\n+            "preparing history mapping CMFEditions <--> ZVC",\n+        )\n         hidMapping = self._history_id_mapping\n         hidReverseMapping = {}\n         for hid, zvcHid in hidMapping.items():\n             hidReverseMapping[zvcHid.history_id] = hid\n-            logger.log(logging.INFO, "CMFEditions storage migration:"\n-                " %6i <--> %s" % (hid, zvcHid.history_id))\n+            logger.log(\n+                logging.INFO,\n+                "CMFEditions storage migration:"\n+                " %6i <--> %s" % (hid, zvcHid.history_id),\n+            )\n \n         # iterate over all histories\n-        logger.log(logging.INFO, "CMFEditions storage migration:"\n-            "iterating over all histories:")\n+        logger.log(\n+            logging.INFO,\n+            "CMFEditions storage migration:" "iterating over all histories:",\n+        )\n         nbrOfMigratedHistories = 0\n         nbrOfMigratedVersions = 0\n         repo = self._getZVCRepo()\n@@ -571,9 +590,12 @@ def migrateStorage(self):\n             zvcVersionIds = zvcHistory.getVersionIds()\n             history_id = hidReverseMapping[zvcHid]\n             history = self._getShadowHistory(history_id, autoAdd=True)\n-            logger.log(logging.INFO, "CMFEditions storage migration:"\n+            logger.log(\n+                logging.INFO,\n+                "CMFEditions storage migration:"\n                 " migrating %s versions of history %s (ZVC: %s)"\n-                % (len(zvcVersionIds), history_id, zvcHid))\n+                % (len(zvcVersionIds), history_id, zvcHid),\n+            )\n             nbrOfMigratedHistories += 1\n \n             # iterate over all versions\n@@ -600,24 +622,35 @@ def migrateStorage(self):\n                 }\n \n                 # save metadata in shadow history\n-                logger.log(logging.INFO, "CMFEditions storage migration:"\n-                    " migrating version %s:" % (int(zvcVid)-1))\n+                logger.log(\n+                    logging.INFO,\n+                    "CMFEditions storage migration:"\n+                    " migrating version %s:" % (int(zvcVid) - 1),\n+                )\n                 history.save(shadowInfo)\n \n                 app_metadata = metadata.get("app_metadata", {})\n                 if app_metadata:\n-                    logger.log(logging.INFO, "CMFEditions storage migration:"\n-                        " application metadata:")\n+                    logger.log(\n+                        logging.INFO,\n+                        "CMFEditions storage migration:" " application metadata:",\n+                    )\n                     for item in app_metadata.items():\n-                        logger.log(logging.INFO,\n-                            "CMFEditions storage migration: %s = %s" % item)\n+                        logger.log(\n+                            logging.INFO,\n+                            "CMFEditions storage migration: %s = %s" % item,\n+                        )\n                 sys_metadata = metadata.get("sys_metadata", {})\n                 if sys_metadata:\n-                    logger.log(logging.INFO, "CMFEditions storage migration:"\n-                        " system metadata:")\n+                    logger.log(\n+                        logging.INFO,\n+                        "CMFEditions storage migration:" " system metadata:",\n+                    )\n                     for item in sys_metadata.items():\n-                        logger.log(logging.INFO,\n-                            "CMFEditions storage migration: %s = %s" % item)\n+                        logger.log(\n+                            logging.INFO,\n+                            "CMFEditions storage migration: %s = %s" % item,\n+                        )\n                 nbrOfMigratedVersions += 1\n \n         # delete the old metadata\n@@ -625,9 +658,12 @@ def migrateStorage(self):\n \n         # log a summary\n         totalTime = round(time.time() - startTime, 2)\n-        logger.log(logging.INFO, "CMFEditions storage migration:"\n+        logger.log(\n+            logging.INFO,\n+            "CMFEditions storage migration:"\n             "migrated %s histories and a total of %s versions in %.2f seconds"\n-            % (nbrOfMigratedHistories, nbrOfMigratedVersions, totalTime))\n+            % (nbrOfMigratedHistories, nbrOfMigratedVersions, totalTime),\n+        )\n \n         # XXX have to add purge policy\n \n@@ -638,9 +674,9 @@ def migrateStorage(self):\n     # -------------------------------------------------------------------\n \n     security.declareProtected(ManagePortal, \'zmi_getStorageStatistics\')\n+\n     def zmi_getStorageStatistics(self):\n-        """\n-        """\n+        """ """\n         startTime = time.time()\n         # get all history ids (incl. such that were deleted in the portal)\n         storage = self._getShadowStorage(autoAdd=False)\n@@ -700,31 +736,33 @@ def zmi_getStorageStatistics(self):\n                 deleted.append(histData)\n                 deletedHistories += 1\n                 deletedVersions += histData["length"]\n-                deletedSize += 0 # TODO\n+                deletedSize += 0  # TODO\n             else:\n                 existing.append(histData)\n                 existingHistories += 1\n                 existingVersions += histData["length"]\n-                existingSize += 0 # TODO\n+                existingSize += 0  # TODO\n \n         processingTime = "%.2f" % round(time.time() - startTime, 2)\n-        histories = existingHistories+deletedHistories\n-        versions = existingVersions+deletedVersions\n+        histories = existingHistories + deletedHistories\n+        versions = existingVersions + deletedVersions\n \n         if histories:\n-            totalAverage = "%.1f" % round(float(versions)/histories, 1)\n+            totalAverage = "%.1f" % round(float(versions) / histories, 1)\n         else:\n             totalAverage = "n/a"\n \n         if existingHistories:\n-            existingAverage = "%.1f" % \\\n-                round(float(existingVersions)/existingHistories, 1)\n+            existingAverage = "%.1f" % round(\n+                float(existingVersions) / existingHistories, 1\n+            )\n         else:\n             existingAverage = "n/a"\n \n         if deletedHistories:\n-            deletedAverage = "%.1f" % \\\n-                round(float(deletedVersions)/deletedHistories, 1)\n+            deletedAverage = "%.1f" % round(\n+                float(deletedVersions) / deletedHistories, 1\n+            )\n         else:\n             deletedAverage = "n/a"\n \n@@ -742,9 +780,10 @@ def zmi_getStorageStatistics(self):\n                 "deletedHistories": deletedHistories,\n                 "deletedVersions": deletedVersions,\n                 "deletedAverage": deletedAverage,\n-            }\n+            },\n         }\n \n+\n InitializeClass(ZVCStorageTool)\n \n \n@@ -753,6 +792,7 @@ class ShadowStorage(Persistent):\n \n     Only cares about containerish operations.\n     """\n+\n     def __init__(self):\n         # Using an OOBtree to allow history ids of any type. The type\n         # of the history ids highly depends on the unique id tool which\n@@ -760,8 +800,7 @@ def __init__(self):\n         self._storage = OOBTree()\n \n     def isRegistered(self, history_id):\n-        """Returns True if a History With the Given History id Exists\n-        """\n+        """Returns True if a History With the Given History id Exists"""\n         if history_id is None:\n             return False\n         return history_id in self._storage\n@@ -779,12 +818,13 @@ def getHistory(self, history_id, autoAdd=False):\n             self._storage[history_id] = ShadowHistory()\n         return self._storage.get(history_id, None)\n \n+\n InitializeClass(ShadowStorage)\n \n \n class ShadowHistory(Persistent):\n-    """Purge Aware History for Storage Related Metadata\n-    """\n+    """Purge Aware History for Storage Related Metadata"""\n+\n     security = ClassSecurityInfo()\n \n     def __init__(self):\n@@ -829,6 +869,7 @@ def save(self, data):\n         return version_id\n \n     security.declareProtected(AccessPreviousVersions, \'retrieve\')\n+\n     def retrieve(self, selector, countPurged=True):\n         """Retrieves the Selected Data From the History\n \n@@ -843,8 +884,7 @@ def retrieve(self, selector, countPurged=True):\n         return self._full[version_id]\n \n     def purge(self, selector, data, countPurged):\n-        """Purge selected version from the history\n-        """\n+        """Purge selected version from the history"""\n         # find the position to purge\n         version_pos = self._getVersionPos(selector, countPurged)\n         version_id = self._available[version_pos]\n@@ -871,9 +911,9 @@ def purge(self, selector, data, countPurged):\n             pass\n \n     security.declareProtected(AccessPreviousVersions, \'getLength\')\n+\n     def getLength(self, countPurged):\n-        """Length of the History Either Counting Purged Versions or Not\n-        """\n+        """Length of the History Either Counting Purged Versions or Not"""\n         if countPurged:\n             return self.nextVersionId\n         else:\n@@ -884,8 +924,7 @@ def __len__(self):\n         return self.getLength(True)\n \n     def getSize(self):\n-        """Returns the size including the quality of the size\n-        """\n+        """Returns the size including the quality of the size"""\n         # don\'t like exceptions taking down CMFEditions\n         if getattr(self, "_sizeInaccurate", None) is None:\n             return 0, "not available"\n@@ -947,6 +986,7 @@ def _getVersionPos(self, selector, countPurged):\n             selector = None\n         return selector\n \n+\n InitializeClass(ShadowHistory)\n \n \n@@ -955,10 +995,10 @@ class ZVCAwareWrapper(Persistent):\n \n     ZVC, arghh ...\n     """\n+\n     def __init__(self, object, metadata, vc_info=None):\n         self._object = object\n-        self._physicalPath = \\\n-            metadata[\'sys_metadata\'].get(\'physicalPath\', ())[:] # copy\n+        self._physicalPath = metadata[\'sys_metadata\'].get(\'physicalPath\', ())[:]  # copy\n         if vc_info is not None:\n             self.__vc_info__ = vc_info\n \n@@ -968,42 +1008,39 @@ def getWrappedObject(self):\n     def getPhysicalPath(self):\n         return self._physicalPath\n \n+\n InitializeClass(ZVCAwareWrapper)\n \n \n class Removed(Persistent):\n-    """Indicates that removement of data\n-    """\n+    """Indicates that removement of data"""\n \n     def __init__(self, reason, metadata):\n-        """Store Removed Info\n-        """\n+        """Store Removed Info"""\n         self.reason = reason\n         self.metadata = metadata\n \n \n @implementer(IVersionData)\n class VersionData:\n-\n     def __init__(self, object, referenced_data, metadata):\n         self.object = object\n         self.referenced_data = referenced_data\n         self.metadata = metadata\n \n     def isValid(self):\n-        """Returns True if Valid (not Purged)\n-        """\n+        """Returns True if Valid (not Purged)"""\n         return not isinstance(self.object, Removed)\n \n+\n @implementer(\n-        IHistory,)\n+    IHistory,\n+)\n class LazyHistory:\n-    """Lazy history adapter.\n-    """\n+    """Lazy history adapter."""\n \n     def __init__(self, storage, history_id, countPurged=True, substitute=True):\n-        """See IHistory.\n-        """\n+        """See IHistory."""\n         history = storage._getShadowHistory(history_id)\n         if history is None:\n             self._length = 0\n@@ -1015,26 +1052,23 @@ def __init__(self, storage, history_id, countPurged=True, substitute=True):\n         self._retrieve = storage.retrieve\n \n     def __len__(self):\n-        """See IHistory.\n-        """\n+        """See IHistory."""\n         return self._length\n \n     def __getitem__(self, selector):\n-        """See IHistory.\n-        """\n-        return self._retrieve(self._history_id, selector, self._countPurged,\n-                              self._substitute)\n+        """See IHistory."""\n+        return self._retrieve(\n+            self._history_id, selector, self._countPurged, self._substitute\n+        )\n \n     def __iter__(self):\n-        """See IHistory.\n-        """\n-        return GetItemIterator(self.__getitem__,\n-                               stopExceptions=(StorageRetrieveError,))\n+        """See IHistory."""\n+        return GetItemIterator(self.__getitem__, stopExceptions=(StorageRetrieveError,))\n \n \n class GetItemIterator:\n-    """Iterator object using a getitem implementation to iterate over.\n-    """\n+    """Iterator object using a getitem implementation to iterate over."""\n+\n     def __init__(self, getItem, stopExceptions):\n         self._getItem = getItem\n         self._stopExceptions = stopExceptions\ndiff --git a/Products/CMFEditions/__init__.py b/Products/CMFEditions/__init__.py\nindex c9fc51c..30a02a6 100644\n--- a/Products/CMFEditions/__init__.py\n+++ b/Products/CMFEditions/__init__.py\n@@ -34,6 +34,7 @@\n from Products.CMFEditions import ReferenceFactoriesTool\n from Products.CMFEditions import StandardModifiers\n from Products.CMFEditions import ZVCStorageTool\n+\n # Set up a MessageFactory for the cmfeditions domain\n from zope.i18nmessageid import MessageFactory\n \n@@ -49,21 +50,27 @@\n     CopyModifyMergeRepositoryTool.CopyModifyMergeRepositoryTool,\n     ReferenceFactoriesTool.ReferenceFactoriesTool,\n     KeepLastNVersionsTool.KeepLastNVersionsTool,\n-    )\n+)\n \n \n CMFEditionsMessageFactory = MessageFactory(\'cmfeditions\')\n \n ModuleSecurityInfo(\'Products.CMFEditions\').declarePublic(\'CMFEditionsMessageFactory\')\n-ModuleSecurityInfo(\'Products.CMFEditions.interfaces.IArchivist\').declarePublic(\'ArchivistUnregisteredError\')\n-ModuleSecurityInfo(\'Products.CMFEditions.interfaces.IModifier\').declarePublic(\'FileTooLargeToVersionError\')\n+ModuleSecurityInfo(\'Products.CMFEditions.interfaces.IArchivist\').declarePublic(\n+    \'ArchivistUnregisteredError\'\n+)\n+ModuleSecurityInfo(\'Products.CMFEditions.interfaces.IModifier\').declarePublic(\n+    \'FileTooLargeToVersionError\'\n+)\n ModuleSecurityInfo(\'Products.CMFEditions.utilities\').declarePublic(\'isObjectChanged\')\n ModuleSecurityInfo(\'Products.CMFEditions.utilities\').declarePublic(\'isObjectVersioned\')\n ModuleSecurityInfo(\'Products.CMFEditions.utilities\').declarePublic(\'maybeSaveVersion\')\n \n+\n def initialize(context):\n-    utils.ToolInit(meta_type=\'CMF Editions Tool\', tools=tools,\n-                   icon=\'tool.gif\').initialize(context)\n+    utils.ToolInit(\n+        meta_type=\'CMF Editions Tool\', tools=tools, icon=\'tool.gif\'\n+    ).initialize(context)\n \n     # initialize standard modifiers to make them addable through the ZMI\n     StandardModifiers.initialize(context)\ndiff --git a/Products/CMFEditions/browser/diff.py b/Products/CMFEditions/browser/diff.py\nindex 4ef23a2..26a79f0 100644\n--- a/Products/CMFEditions/browser/diff.py\n+++ b/Products/CMFEditions/browser/diff.py\n@@ -34,9 +34,8 @@ def versionTitle(self, version):\n         version_name = self.versionName(version)\n \n         return translate(\n-            _(u"version ${version}",\n-              mapping=dict(version=version_name)),\n-            context=self.request\n+            _(u"version ${version}", mapping=dict(version=version_name)),\n+            context=self.request,\n         )\n \n     def __call__(self):\n@@ -57,19 +56,21 @@ def __call__(self):\n             self.getVersion(version2),\n             self.getVersion(version1),\n             id1=self.versionTitle(version2),\n-            id2=self.versionTitle(version1))\n-        self.changes = [change for change in self.changeset.getDiffs()\n-                        if not change.same]\n+            id2=self.versionTitle(version1),\n+        )\n+        self.changes = [\n+            change for change in self.changeset.getDiffs() if not change.same\n+        ]\n \n         return self.template()\n \n \n class CanDiff(BrowserView):\n-\n     def can_diff(self):\n-        """Return True if content is diffable\n-        """\n+        """Return True if content is diffable"""\n         context = self.context\n         portal_diff = getToolByName(context, \'portal_diff\', None)\n-        return portal_diff \\\n+        return (\n+            portal_diff\n             and len(portal_diff.getDiffForPortalType(context.portal_type)) > 0\n+        )\ndiff --git a/Products/CMFEditions/browser/utils.py b/Products/CMFEditions/browser/utils.py\nindex 6b1f1d1..b0b7d8a 100644\n--- a/Products/CMFEditions/browser/utils.py\n+++ b/Products/CMFEditions/browser/utils.py\n@@ -27,18 +27,16 @@ def get_macros(self, vdata):\n             # Should use IBrowserDefault.getLayout ?\n             def_method_name = type_info.getViewMethod(context)\n         else:\n-            def_method_name = type_info.getActionInfo(\n-                \'object/view\')[\'url\'].split(\'/\')[-1] or \\\n-                getattr(type_info, \'default_view\', \'view\')\n+            def_method_name = type_info.getActionInfo(\'object/view\')[\'url\'].split(\'/\')[\n+                -1\n+            ] or getattr(type_info, \'default_view\', \'view\')\n         versionPreviewMethodName = \'version_%s\' % def_method_name\n-        versionPreviewTemplate = getattr(\n-            context, versionPreviewMethodName, None)\n+        versionPreviewTemplate = getattr(context, versionPreviewMethodName, None)\n \n         # check if a special version view exists\n         if getattr(versionPreviewTemplate, \'macros\', None) is None:\n             # Use the Plone\'s default view template\n-            versionPreviewTemplate = context.restrictedTraverse(\n-                def_method_name)\n+            versionPreviewTemplate = context.restrictedTraverse(def_method_name)\n \n         if getattr(versionPreviewTemplate, \'macros\', None) is None:\n             return None\n@@ -53,8 +51,7 @@ def get_macros(self, vdata):\n             return versionPreviewTemplate.macros[\'main\']\n         except KeyError:\n             logger.warn(\n-                \'Missing TAL macros {0} in template "{1}".\' .format(\n-                    \', \'.join(macro_names),\n-                    versionPreviewMethodName\n+                \'Missing TAL macros {0} in template "{1}".\'.format(\n+                    \', \'.join(macro_names), versionPreviewMethodName\n                 )\n             )\ndiff --git a/Products/CMFEditions/browser/views.py b/Products/CMFEditions/browser/views.py\nindex 64507d6..1c975dc 100644\n--- a/Products/CMFEditions/browser/views.py\n+++ b/Products/CMFEditions/browser/views.py\n@@ -11,7 +11,6 @@\n \n \n class UpdateVersionOnEditView(BrowserView):\n-\n     def success(self):\n         self.request.response.redirect(\'view\')\n \n@@ -31,13 +30,12 @@ def __call__(self):\n         try:\n             maybeSaveVersion(context, comment=comment, force=False)\n         except FileTooLargeToVersionError:\n-            pass # the on edit save will emit a warning\n+            pass  # the on edit save will emit a warning\n \n         return self.success()\n \n \n class UpdateVersionBeforeEditView(BrowserView):\n-\n     def success(self):\n         return self.context.restrictedTraverse(\'content_edit\')\n \n@@ -54,13 +52,12 @@ def __call__(self):\n         except FileTooLargeToVersionError:\n             IStatusMessage(self.request).addStatusMessage(\n                 _(\'Versioning for this file has been disabled because it is too large\'),\n-                type=\'warn\'\n-                )\n+                type=\'warn\',\n+            )\n         return self.success()\n \n \n class FileDownloadVersionView(BrowserView):\n-\n     def __call__(self):\n         context = aq_inner(self.context)\n         version_id = int(self.request.get(\'version_id\', 1))\n@@ -70,13 +67,13 @@ def __call__(self):\n         obj = portal_repository.retrieve(context, version_id).object\n         RESPONSE.setHeader(\'Content-Type\', obj.getContentType())\n         RESPONSE.setHeader(\'Content-Length\', obj.get_size())\n-        RESPONSE.setHeader(\'Content-Disposition\',\n-                           \'attachment;filename="%s"\'%(obj.getFilename()))\n+        RESPONSE.setHeader(\n+            \'Content-Disposition\', \'attachment;filename="%s"\' % (obj.getFilename())\n+        )\n         return obj.data\n \n \n class VersionImageTagView(BrowserView):\n-\n     def __call__(self):\n         version_id = int(self.request.get(\'version_id\', 1))\n         here_url = self.request.get(\'here_url\', \'\')\n@@ -85,12 +82,14 @@ def __call__(self):\n         obj = portal_repository.retrieve(context, version_id).object\n         working_copy_tag = obj.tag()\n         altPos = working_copy_tag.find("alt=")\n-        tag = \'<img src="%s/file_download_version?version_id=%s" %s\' % \\\n-              (here_url, version_id, working_copy_tag[altPos:])\n+        tag = \'<img src="%s/file_download_version?version_id=%s" %s\' % (\n+            here_url,\n+            version_id,\n+            working_copy_tag[altPos:],\n+        )\n         return tag\n \n \n class VersionView(BrowserView):\n-\n     def human_readable_size(self):\n         return human_readable_size\ndiff --git a/Products/CMFEditions/exportimport/repository.py b/Products/CMFEditions/exportimport/repository.py\nindex 91e052f..8d17783 100644\n--- a/Products/CMFEditions/exportimport/repository.py\n+++ b/Products/CMFEditions/exportimport/repository.py\n@@ -8,21 +8,18 @@\n \n \n class RepositoryToolXMLAdapter(XMLAdapterBase):\n-    """Mode in- and exporter for RepositoryTool.\n-    """\n+    """Mode in- and exporter for RepositoryTool."""\n \n     name = \'repositorytool\'\n \n     def _exportNode(self):\n-        """Export the object as a DOM node.\n-        """\n-        node=self._doc.createElement(\'repositorytool\')\n+        """Export the object as a DOM node."""\n+        node = self._doc.createElement(\'repositorytool\')\n         node.appendChild(self._extractPolicies())\n         node.appendChild(self._extractTypePolicies())\n         self._logger.info(\'RepositoryTool settings exported.\')\n         return node\n \n-\n     def _importNode(self, node):\n         if self.environ.shouldPurge():\n             self._purgeTypePolicies()\n@@ -57,7 +54,7 @@ def _initPolicies(self, node):\n                     if policy.nodeName != \'policy\':\n                         raise AssertionError(\n                             "<policies> must only contain <policy> tags, not <%s>.",\n-                            policy.nodeName\n+                            policy.nodeName,\n                         )\n                     policy_id = policy.getAttribute(\'name\')\n                     policy_title = policy.getAttribute(\'title\')\n@@ -98,7 +95,7 @@ def _initTypePolicies(self, node):\n                     if p_type.nodeName != \'type\':\n                         raise AssertionError(\n                             "<policymap> must only contain <type> tags, not <%s>.",\n-                            p_type.nodeName\n+                            p_type.nodeName,\n                         )\n                     portal_type = p_type.getAttribute(\'name\')\n                     existing_policies = tool.getPolicyMap().get(portal_type, [])\n@@ -111,7 +108,7 @@ def _initTypePolicies(self, node):\n                         if policy.nodeName != \'policy\':\n                             raise AssertionError(\n                                 "<policymap><type> must only contain <policy> tags, not <%s>.",\n-                                policy.nodeName\n+                                policy.nodeName,\n                             )\n                         policies.append(policy.getAttribute(\'name\'))\n                     versionable_types = tool.getVersionableContentTypes()\n@@ -125,7 +122,6 @@ def _initTypePolicies(self, node):\n                             versionable_types.remove(portal_type)\n                     tool.setVersionableContentTypes(versionable_types)\n \n-\n     def _extractTypePolicies(self):\n         node = self._doc.createElement(\'policymap\')\n         mapping = sorted(self.context.getPolicyMap().items())\n@@ -141,8 +137,7 @@ def _extractTypePolicies(self):\n \n \n def importRepositoryTool(context):\n-    """Import Repository Tool configuration.\n-    """\n+    """Import Repository Tool configuration."""\n     site = context.getSite()\n     tool = getToolByName(site, \'portal_repository\', None)\n     if tool is None:\n@@ -152,9 +147,9 @@ def importRepositoryTool(context):\n \n     importObjects(tool, \'\', context)\n \n+\n def exportRepositoryTool(context):\n-    """Export Repository Tool configuration.\n-    """\n+    """Export Repository Tool configuration."""\n     site = context.getSite()\n     tool = getToolByName(site, \'portal_repository\', None)\n     if tool is None:\ndiff --git a/Products/CMFEditions/interfaces/IArchivist.py b/Products/CMFEditions/interfaces/IArchivist.py\nindex c403bc0..394289f 100644\n--- a/Products/CMFEditions/interfaces/IArchivist.py\n+++ b/Products/CMFEditions/interfaces/IArchivist.py\n@@ -127,8 +127,7 @@ def queryHistory(obj=None, history_id=None, preserve=(), default=None):\n         """\n \n     def getHistoryMetadata(obj=None, history_id=None):\n-        """Returns the versioning metadata history.\n-        """\n+        """Returns the versioning metadata history."""\n \n \n class IPurgeSupport(Interface):\n@@ -168,8 +167,7 @@ class IPurgeSupport(Interface):\n         version retrieved: 0, 1, 2, 5, 6, 7, 8, 9, e, e\n     """\n \n-    def purge(obj=None, history_id=None, selector=None, metadata={},\n-              countPurged=True):\n+    def purge(obj=None, history_id=None, selector=None, metadata={}, countPurged=True):\n         """Purge a version of a content object.\n \n         Requires either an object which is the working copy, or a history_id\n@@ -183,8 +181,7 @@ def purge(obj=None, history_id=None, selector=None, metadata={},\n         (see interface documentation for details).\n         """\n \n-    def isUpToDate(obj=None, history_id=None, selector=None,\n-                   countPurged=True):\n+    def isUpToDate(obj=None, history_id=None, selector=None, countPurged=True):\n         """Check if the corking copy is up to date.\n \n         Returns True if the working copy has changed since the last save\n@@ -198,8 +195,9 @@ def isUpToDate(obj=None, history_id=None, selector=None,\n         (see interface documentation for details).\n         """\n \n-    def retrieve(obj=None, history_id=None, selector=None, preserve=(),\n-                 countPurged=True):\n+    def retrieve(\n+        obj=None, history_id=None, selector=None, preserve=(), countPurged=True\n+    ):\n         """Retrieve a former state of an object.\n \n         Requires either an object which is the working copy, or a history_id\n@@ -245,8 +243,9 @@ def getHistory(obj=None, history_id=None, preserve=(), countPurged=True):\n         (see interface documentation for details).\n         """\n \n-    def queryHistory(obj=None, history_id=None, preserve=(), default=None,\n-                     countPurged=True):\n+    def queryHistory(\n+        obj=None, history_id=None, preserve=(), default=None, countPurged=True\n+    ):\n         """Return the history of an object.\n \n         Does the same as ``getHistory`` with the difference of returning\n@@ -258,12 +257,12 @@ def queryHistory(obj=None, history_id=None, preserve=(), default=None,\n \n \n class IPreparedObject(Interface):\n-    """Contains data prepared for save or register.\n-    """\n+    """Contains data prepared for save or register."""\n \n     history_id = Attribute(\n         """The id of the objects history.\n-        """)\n+        """\n+    )\n \n     original = Attribute(\n         """The unaltered original object before the modifiers were applied.\n@@ -271,13 +270,15 @@ class IPreparedObject(Interface):\n         This is a \'IObjectData\' object.\n \n         The original object shall not be modified!\n-        """)\n+        """\n+    )\n \n     clone = Attribute(\n         """The cloned object and version aware reference info.\n \n         This is a \'IObjectData\' object.\n-        """)\n+        """\n+    )\n \n     referenced_data = Attribute(\n         """Data that is passed to the storage by reference.\n@@ -289,44 +290,50 @@ class IPreparedObject(Interface):\n         Returns a dictionary of the following format:\n \n             {\'name\': pyref_to_object, ...}\n-        """)\n+        """\n+    )\n \n     metadata = Attribute(\n         """Metadata to be passed to history storage.\n-        """)\n+        """\n+    )\n \n     is_registered = Attribute(\n         """True if already registered by the Archivist.\n-        """)\n+        """\n+    )\n \n \n class IVersionData(Interface):\n-    """\n-    """\n+    """ """\n \n     data = Attribute(\n         """The previously saved object.\n \n         This is a \'IObjectData\' object.\n-        """)\n+        """\n+    )\n \n     refs_to_be_deleted = Attribute(\n         """List of references to be deleted on revert.\n \n         The items (containing the reference informations) are of\n         ``IReferenceAdapter``.\n-        """)\n+        """\n+    )\n \n     attr_handling_references = Attribute(\n         """List of names of attributes handling references.\n-        """)\n+        """\n+    )\n \n     preserved_data = Attribute(\n         """Returns data beeing preserved from beeing overwritten by modifiers.\n \n         The preserved data is a flat dictionary. With the example from above:\n         nick_name = obj.preserved_data[\'nick_name\']\n-        """)\n+        """\n+    )\n \n     sys_metadata = Attribute(\n         """System related metadata.\n@@ -337,16 +344,17 @@ class IVersionData(Interface):\n         - principal: the actor that did the save\n         - parent: Dictionary with ``history_id``, ``version_id`` and\n           ``location_id``\n-        """)\n+        """\n+    )\n \n     app_metadata = Attribute(\n         """Metadata stored alongside when the objects state was saved.\n-        """)\n+        """\n+    )\n \n \n class IHistory(Interface):\n-    """Iterable version history.\n-    """\n+    """Iterable version history."""\n \n     def __init__(archivist, obj):\n         """Instantiates a lazy iterable history.\n@@ -356,8 +364,7 @@ def __init__(archivist, obj):\n         """\n \n     def __len__():\n-        """Returns the length of the history.\n-        """\n+        """Returns the length of the history."""\n \n     def __getattr__(version_id):\n         """Returns the version of an object corresponding to the version id.\n@@ -373,23 +380,25 @@ def __iter__():\n \n \n class IObjectData(Interface):\n-    """The object including informations about outgoing references.\n-    """\n+    """The object including informations about outgoing references."""\n \n     object = Attribute(\n         """The object with some of the python references replaced by\n            version aware references.\n-        """)\n+        """\n+    )\n \n     inside_refs = Attribute(\n         """List of \'IAttributeAdapter\' objects adapting "object inside"\n            \'IVersionAwareReference\'.\n-        """)\n+        """\n+    )\n \n     outside_refs = Attribute(\n         """List of \'IAttributeAdapter\' objects adapting "object outside"\n            \'IVersionAwareReference\'.\n-        """)\n+        """\n+    )\n \n \n class IAttributeAdapter(Interface):\n@@ -400,24 +409,19 @@ class IAttributeAdapter(Interface):\n     """\n \n     def __init__(parent, attr_name, type=None):\n-        """Store the attributes "coordinates".\n-        """\n+        """Store the attributes "coordinates"."""\n \n     def setAttribute(obj):\n-        """Sets the given object as attribute.\n-        """\n+        """Sets the given object as attribute."""\n \n     def getAttribute(alternate=None):\n-        """Returns the current attribute.\n-        """\n+        """Returns the current attribute."""\n \n     def getAttributeName():\n-        """Returns the attributes name.\n-        """\n+        """Returns the attributes name."""\n \n     def getType():\n-        """Returns the attributes type.\n-        """\n+        """Returns the attributes type."""\n \n \n class IVersionAwareReference(Interface):\n@@ -452,8 +456,7 @@ def __init__(**info):\n         """\n \n     def setReference(target_obj, remove_info=True):\n-        """Set a reference to the given target object.\n-        """\n+        """Set a reference to the given target object."""\n \n     history_id = Attribute(\n         """The history id of the referenced resource.\n@@ -462,48 +465,56 @@ def setReference(target_obj, remove_info=True):\n \n         May be None. In this case the reference isn\'t set yet or the\n         target object isn\'t referenceable.\n-        """)\n+        """\n+    )\n \n     version_id = Attribute(\n         """The version id of the referenced resource.\n \n         May be None. For the interpretation see above.\n-        """)\n+        """\n+    )\n \n     location_id = Attribute(\n         """The location id of the working copy of the referenced resource.\n \n         May be None. For the interpretation see above.\n-        """)\n+        """\n+    )\n \n     info = Attribute(\n         """The info stored alongside on instantiation time.\n \n         May not exist.\n-        """)\n+        """\n+    )\n \n \n class ArchivistError(Exception):\n-    """Archivist exception\n-    """\n+    """Archivist exception"""\n+\n     pass\n \n+\n class ArchivistRetrieveError(ArchivistError):\n-    """Raised if tried to retrieve a non existent version of a resource.\n-    """\n+    """Raised if tried to retrieve a non existent version of a resource."""\n+\n     pass\n \n+\n class ArchivistRegisterError(ArchivistError):\n-    """Raised if registering the resource failed.\n-    """\n+    """Raised if registering the resource failed."""\n+\n     pass\n \n+\n class ArchivistSaveError(ArchivistError):\n-    """Raised if saving a new version of a resource failed.\n-    """\n+    """Raised if saving a new version of a resource failed."""\n+\n     pass\n \n+\n class ArchivistUnregisteredError(ArchivistError):\n-    """Raised if trying to save an unregistered resource.\n-    """\n+    """Raised if trying to save an unregistered resource."""\n+\n     pass\ndiff --git a/Products/CMFEditions/interfaces/IModifier.py b/Products/CMFEditions/interfaces/IModifier.py\nindex f099726..8e1074f 100644\n--- a/Products/CMFEditions/interfaces/IModifier.py\n+++ b/Products/CMFEditions/interfaces/IModifier.py\n@@ -31,8 +31,8 @@\n \n class IAttributeModifier(Interface):\n     """The simplest possible modifier, it indicates, which attributes\n-       shouldn\'t be copied by the archivist, but be passed to the the storage\n-       by reference.\n+    shouldn\'t be copied by the archivist, but be passed to the the storage\n+    by reference.\n \n     """\n \n@@ -44,9 +44,10 @@ def getReferencedAttributes(obj):\n \n     def reattachReferencedAttributes(obj, attrs_dict):\n         """Giving an obj and and an attribute dict composed by\n-           attribute names and values, reattach them to the obj.\n+        attribute names and values, reattach them to the obj.\n         """\n \n+\n class ICloneModifier(Interface):\n     """Modifies an object on save to or retrieval from a repository storage.\n \n@@ -72,7 +73,6 @@ def getOnCloneModifiers(obj):\n         """\n \n \n-\n class ISaveRetrieveModifier(Interface):\n     """Modifies an object on save to or retrieval from a repository storage.\n \n@@ -134,6 +134,7 @@ def afterRetrieveModifier(obj, repo_clone, preserve=()):\n           overwritten.\n         """\n \n+\n class IReferenceAdapter(Interface):\n     """Adapts to a references.\n \n@@ -142,13 +143,11 @@ class IReferenceAdapter(Interface):\n     """\n \n     def remove():\n-        """Removes the refrence adapted to.\n-        """\n+        """Removes the refrence adapted to."""\n \n \n class IModifierRegistrySet(Interface):\n-    """Registring and editing a modifier registry.\n-    """\n+    """Registring and editing a modifier registry."""\n \n     def register(id, modifier, pos=-1):\n         """Registers a before save and after retrieve modifier.\n@@ -175,8 +174,7 @@ def edit(id, enabled=None, condition=None):\n \n \n class IModifierRegistryQuery(Interface):\n-    """Querying a modifier registry.\n-    """\n+    """Querying a modifier registry."""\n \n     def get(id):\n         """Returns the conditional modifier with the given id.\n@@ -220,12 +218,10 @@ def isApplicable(obj, portal=None):\n         """\n \n     def isEnabled():\n-        """Returns the enable status.\n-        """\n+        """Returns the enable status."""\n \n     def getModifier():\n-        """Returns the modifier.\n-        """\n+        """Returns the modifier."""\n \n \n class IConditionalTalesModifier(IConditionalModifier):\n@@ -244,8 +240,7 @@ def edit(enabled=None, condition=None):\n         """\n \n     def getTalesCondition():\n-        """Returns the TALES expression.\n-        """\n+        """Returns the TALES expression."""\n \n \n # not yet implemented stuff, subject to change\n@@ -278,13 +273,17 @@ def setModifiers(ids, pos, before_save, after_retrieve, on_clone):\n         Use this to set all subscribers at once from a form.\n         """\n \n+\n class ModifierException(Exception):\n     """A base class for exceptions thrown by modifiers which wish to abort\n     a save operation"""\n+\n     pass\n \n+\n class FileTooLargeToVersionError(ModifierException):\n     """A simple exception indicating that an object contained a file\n     object that was too large to support versioning, and that versioning\n     will be aborted as a result"""\n+\n     pass\ndiff --git a/Products/CMFEditions/interfaces/IReferenceFactories.py b/Products/CMFEditions/interfaces/IReferenceFactories.py\nindex 4e62e19..c5d47e1 100644\n--- a/Products/CMFEditions/interfaces/IReferenceFactories.py\n+++ b/Products/CMFEditions/interfaces/IReferenceFactories.py\n@@ -44,5 +44,4 @@ def invokeFactory(repo_clone, source, selector=None):\n         """\n \n     def hasBeenMoved(obj, source):\n-        """Returns True if the object has been moved away from ``source``.\n-        """\n+        """Returns True if the object has been moved away from ``source``."""\ndiff --git a/Products/CMFEditions/interfaces/IRepository.py b/Products/CMFEditions/interfaces/IRepository.py\nindex eae31be..a57849e 100644\n--- a/Products/CMFEditions/interfaces/IRepository.py\n+++ b/Products/CMFEditions/interfaces/IRepository.py\n@@ -51,8 +51,7 @@ class ICopyModifyMergeRepository(Interface):\n     """\n \n     def isVersionable(obj):\n-        """Return True if the content type is versionable.\n-        """\n+        """Return True if the content type is versionable."""\n \n     def setAutoApplyMode(autoapply):\n         """Sets the autoapply mode.\n@@ -124,8 +123,7 @@ def getHistory(obj, oldestFirst=False, preserve=()):\n         """\n \n     def getHistoryMetadata(obj):\n-        """Returns the versioning metadata history.\n-        """\n+        """Returns the versioning metadata history."""\n \n \n class IPurgeSupport(Interface):\n@@ -209,8 +207,7 @@ def retrieve(obj, selector=None, preserve=(), countPurged=True):\n         (see interface documentation for details).\n         """\n \n-    def restore(history_id, selector, container, new_id=None,\n-                countPurged=True):\n+    def restore(history_id, selector, container, new_id=None, countPurged=True):\n         """Restore a Specific version of an Object into a Container\n \n         Usage Hint:\n@@ -246,29 +243,25 @@ def getHistory(obj, oldestFirst=False, preserve=(), countPurged=True):\n \n \n class IVersionSupport(Interface):\n-    """Check if versioning is supported for a specific content.\n-    """\n+    """Check if versioning is supported for a specific content."""\n \n     def isVersionable(obj):\n-        """Returns True if the object is versionable\n-        """\n+        """Returns True if the object is versionable"""\n \n \n class IContentTypeVersionSupport(IVersionSupport):\n-    """Registry for versionable content types\n-    """\n+    """Registry for versionable content types"""\n \n     def getVersionableContentTypes():\n-        """Returns a list of Versionable content types\n-        """\n+        """Returns a list of Versionable content types"""\n \n     def setVersionableContentTypes(new_content_types):\n-        """Set the list of Versionable content types\n-        """\n+        """Set the list of Versionable content types"""\n+\n \n class IContentTypeVersionPolicySupport(IContentTypeVersionSupport):\n     """Determine if a type supports a particular versioning method, the policy\n-       parameter is simply a string representing the policy"""\n+    parameter is simply a string representing the policy"""\n \n     def addPolicyForContentType(content_type, policy):\n         """Sets a content type to use a specific policy"""\n@@ -277,8 +270,7 @@ def removePolicyFromContentType(content_type, policy):\n         """Sets a content type to use a specific policy"""\n \n     def supportsPolicy(obj, policy):\n-        """Determine if an object is set to use a specific versioning policy\n-        """\n+        """Determine if an object is set to use a specific versioning policy"""\n \n     def hasPolicy(obj):\n         """Determine if an object has any assigned versioning policies"""\n@@ -293,31 +285,31 @@ def listPolicies():\n \n     def addPolicy(policy_id, policy_title, policy_class):\n         """Add a new versioning policy, can optionally use an alternate\n-           policy class."""\n+        policy class."""\n \n     def removePolicy(policy_id):\n         """Removes a versioning policy from the tool and all types which\n-           support it"""\n+        support it"""\n \n     def manage_changePolicyDefs(policy_list):\n         """Update the policy structure with a list of tuples [(id, title),...]\n-           The tuples may optionally contain a policy class and a dict of\n-           kwargs to pass to the policy add hook. e.g.:\n-          [(id, title, klass, {\'arg1\': val1}), ...]\n+         The tuples may optionally contain a policy class and a dict of\n+         kwargs to pass to the policy add hook. e.g.:\n+        [(id, title, klass, {\'arg1\': val1}), ...]\n         """\n \n     def getPolicyMap():\n         """Return a mapping of types to the lists of policies they support,\n-           for use in config screen."""\n+        for use in config screen."""\n \n \n class IVersionData(Interface):\n-    """ Used to store the versioned content plus additional data.\n-    """\n+    """Used to store the versioned content plus additional data."""\n \n     object = Attribute(\n         """The retrieved version of the content.\n-        """)\n+        """\n+    )\n \n     preserved_data = Attribute(\n         """It is the data preserved from overwriting during the\n@@ -326,15 +318,18 @@ class IVersionData(Interface):\n         The preserved data is a flat dictionary.\n         With the example from above:\n                 nick_name = vdata.preserved_data[\'nick_name\']\n-        """)\n+        """\n+    )\n \n     comment = Attribute(\n         """The comment stored when the working copies version was saved.\n-        """)\n+        """\n+    )\n \n     metadata = Attribute(\n         """Metadata stored when the working copies version was saved.\n-        """)\n+        """\n+    )\n \n     sys_metadata = Attribute(\n         """System related metadata.\n@@ -342,20 +337,20 @@ class IVersionData(Interface):\n         A Dictionary with the following keys:\n         - timestamp: save time\n         - principal: the actor that did the save\n-        """)\n+        """\n+    )\n \n     version_id = Attribute(\n         """The version_id of the object.\n-        """)\n+        """\n+    )\n \n \n class IHistory(Interface):\n-    """Iterable version history.\n-    """\n+    """Iterable version history."""\n \n     def __len__():\n-        """Returns the length of the history.\n-        """\n+        """Returns the length of the history."""\n \n     def __getitem__(selector):\n         """Returns the selected version of a content.\n@@ -364,21 +359,18 @@ def __getitem__(selector):\n         """\n \n     def __iter__():\n-        """ Returns an iterator returning \'IVersionData\' object.\n-        """\n+        """Returns an iterator returning \'IVersionData\' object."""\n \n \n class IRepositoryTool(Interface):\n     """Marker interface for the repository tool used in GenericSetup\n-       exportimport handlers.\n+    exportimport handlers.\n     """\n \n \n class RepositoryError(Exception):\n-    """Repository exception.\n-    """\n+    """Repository exception."""\n \n \n class RepositoryPurgeError(RepositoryError):\n-    """Purge is only possible with a purge policy installed.\n-    """\n+    """Purge is only possible with a purge policy installed."""\ndiff --git a/Products/CMFEditions/interfaces/IStorage.py b/Products/CMFEditions/interfaces/IStorage.py\nindex f70b382..8f51b3e 100644\n--- a/Products/CMFEditions/interfaces/IStorage.py\n+++ b/Products/CMFEditions/interfaces/IStorage.py\n@@ -101,11 +101,10 @@ def getHistory(history_id):\n         """\n \n     def getHistoryMetadata(history_id):\n-        """Returns the versioning metadata history.\n-        """\n+        """Returns the versioning metadata history."""\n \n     def getModificationDate(history_id, selector=None):\n-        """ Returns the modification date of the selected version of object\n+        """Returns the modification date of the selected version of object\n             which has the given history id.\n \n         If selected is None, the most recent version (HEAD) is taken.\n@@ -185,9 +184,10 @@ def getHistory(history_id, countPurged=True, substitute=True):\n         Return a ``IHistory`` object.\n         """\n \n-    def getModificationDate(history_id, selector=None, countPurged=True,\n-                            substitute=True):\n-        """ Returns the modification date of the selected version of object\n+    def getModificationDate(\n+        history_id, selector=None, countPurged=True, substitute=True\n+    ):\n+        """Returns the modification date of the selected version of object\n             which has the given history id.\n \n         If ``countPurged`` is ``True`` purged versions are returned also.\n@@ -201,12 +201,10 @@ def getModificationDate(history_id, selector=None, countPurged=True,\n \n \n class IHistory(Interface):\n-    """Iterable version history.\n-    """\n+    """Iterable version history."""\n \n     def __len__():\n-        """Return the length of the history.\n-        """\n+        """Return the length of the history."""\n \n     def __getattr__(version_id):\n         """Return the version of an object corresponding to the version id.\n@@ -222,28 +220,31 @@ def __iter__():\n \n \n class IVersionData(Interface):\n-    """\n-    """\n+    """ """\n+\n     object = Attribute(\n         """The objects state at save time.\n \n         To avoid temporal problems (by changing the history) this\n         object has to be cloned before any change.\n-        """)\n+        """\n+    )\n \n     referenced_data = Attribute(\n         """Data beeing passed by reference at save time.\n \n         Needs not be cloned before allowing write access. Cloning was\n         already done by the storage layer.\n-        """)\n+        """\n+    )\n \n     metadata = Attribute(\n         """Metadata stored alongside when the objects state was saved.\n \n         Metadata has to be cloned before any write change to avoid\n         temporal problems (by changing the history).\n-        """)\n+        """\n+    )\n \n \n class IStreamableReference(Interface):\n@@ -255,37 +256,34 @@ class IStreamableReference(Interface):\n     """\n \n     def __init__(self, obj):\n-        """Wrap the object to be passed to the storage\n-        """\n+        """Wrap the object to be passed to the storage"""\n \n     def getObject(self):\n-        """Return the object\n-        """\n+        """Return the object"""\n \n     def getSize(self):\n-        """Return the size of the streamable object or None\n-        """\n+        """Return the size of the streamable object or None"""\n+\n \n class StorageError(Exception):\n-    """History storage exception.\n-    """\n+    """History storage exception."""\n+\n \n class StorageRetrieveError(StorageError):\n-    """Raised if tried to retrieve a non existent version of a resource.\n-    """\n+    """Raised if tried to retrieve a non existent version of a resource."""\n+\n \n class StorageRegisterError(StorageError):\n-    """Raised if registering the resource failed.\n-    """\n+    """Raised if registering the resource failed."""\n+\n \n class StorageSaveError(StorageError):\n-    """Raised if saving a new version of a resource failed.\n-    """\n+    """Raised if saving a new version of a resource failed."""\n+\n \n class StorageUnregisteredError(StorageError):\n-    """Raised if trying to save an unregistered resource.\n-    """\n+    """Raised if trying to save an unregistered resource."""\n+\n \n class StoragePurgeError(StorageError):\n-    """Raised if tried to purge a non existent version of a resource.\n-    """\n+    """Raised if tried to purge a non existent version of a resource."""\ndiff --git a/Products/CMFEditions/interfaces/IVersionPolicy.py b/Products/CMFEditions/interfaces/IVersionPolicy.py\nindex 7d9e654..79902e9 100644\n--- a/Products/CMFEditions/interfaces/IVersionPolicy.py\n+++ b/Products/CMFEditions/interfaces/IVersionPolicy.py\n@@ -26,7 +26,7 @@\n \n class IVersionPolicy(Interface):\n     """A version policy object, which describes and sets up a versioning\n-       policy\n+    policy\n     """\n \n     def Title():\ndiff --git a/Products/CMFEditions/interfaces/__init__.py b/Products/CMFEditions/interfaces/__init__.py\nindex 4dabd71..030ea06 100644\n--- a/Products/CMFEditions/interfaces/__init__.py\n+++ b/Products/CMFEditions/interfaces/__init__.py\n@@ -1,6 +1,8 @@\n # -*- coding: utf-8 -*-\n from Products.CMFEditions.interfaces._tools import IArchivistTool  # noqa: F401\n-from Products.CMFEditions.interfaces._tools import IPortalModifierTool  # noqa: F401,E501\n+from Products.CMFEditions.interfaces._tools import (\n+    IPortalModifierTool,\n+)  # noqa: F401,E501\n from Products.CMFEditions.interfaces._tools import IPurgePolicyTool  # noqa: F401,E501\n from Products.CMFEditions.interfaces._tools import IStorageTool  # noqa: F401\n from zope import interface\n@@ -10,4 +12,5 @@ class IVersioned(interface.Interface):\n     """Marker interface for objects that carry a version id, and are\n     thus versioned.\n     """\n+\n     version_id = interface.Attribute(\'The version id of this object.\')\ndiff --git a/Products/CMFEditions/interfaces/_tools.py b/Products/CMFEditions/interfaces/_tools.py\nindex 13d62fc..7bb34a0 100644\n--- a/Products/CMFEditions/interfaces/_tools.py\n+++ b/Products/CMFEditions/interfaces/_tools.py\n@@ -3,20 +3,16 @@\n \n \n class IArchivistTool(Interface):\n-    """Marker interface for the portal_archivist tool.\n-    """\n+    """Marker interface for the portal_archivist tool."""\n \n \n class IPortalModifierTool(Interface):\n-    """Marker interface for the portal_modifier tool.\n-    """\n+    """Marker interface for the portal_modifier tool."""\n \n \n class IPurgePolicyTool(Interface):\n-    """Marker interface for the portal_purgepolicy tool.\n-    """\n+    """Marker interface for the portal_purgepolicy tool."""\n \n \n class IStorageTool(Interface):\n-    """Marker interface for the portal_historiesstorage tool.\n-    """\n+    """Marker interface for the portal_historiesstorage tool."""\ndiff --git a/Products/CMFEditions/subscriber.py b/Products/CMFEditions/subscriber.py\nindex d3a6161..8b64f2c 100644\n--- a/Products/CMFEditions/subscriber.py\n+++ b/Products/CMFEditions/subscriber.py\n@@ -28,7 +28,7 @@\n \n \n def object_removed(obj, event):\n-    """ an object is being deleted -\n+    """an object is being deleted -\n     also delete it\'s history\n     """\n     if not IContentish.providedBy(obj):\n@@ -55,11 +55,9 @@ def object_removed(obj, event):\n         return\n     current = metadata.retrieve(num_versions - 1)\n     sys_metadata = current[\'metadata\'][\'sys_metadata\']\n-    if (\'parent\' in sys_metadata) and \\\n-            (sys_metadata[\'parent\'][\'history_id\'] != histid):\n+    if (\'parent\' in sys_metadata) and (sys_metadata[\'parent\'][\'history_id\'] != histid):\n         try:\n-            histories_storage.retrieve(\n-                history_id=sys_metadata[\'parent\'][\'history_id\'])\n+            histories_storage.retrieve(history_id=sys_metadata[\'parent\'][\'history_id\'])\n             return\n         except StorageRetrieveError:\n             pass\n@@ -69,4 +67,5 @@ def object_removed(obj, event):\n             histid,\n             0,\n             metadata={\'sys_metadata\': {\'comment\': \'purged\'}},\n-            countPurged=False)\n+            countPurged=False,\n+        )\ndiff --git a/Products/CMFEditions/tests/DummyTools.py b/Products/CMFEditions/tests/DummyTools.py\nindex 67e0bda..d1dc6cd 100644\n--- a/Products/CMFEditions/tests/DummyTools.py\n+++ b/Products/CMFEditions/tests/DummyTools.py\n@@ -30,7 +30,6 @@\n \n \n class Dummy(SimpleItem):\n-\n     def __init__(self):\n         now = DateTime()\n         self.modification_date = now\n@@ -45,10 +44,12 @@ def notifyModified(self):\n class UniqueIdError(Exception):\n     pass\n \n+\n class DummyBaseTool(SimpleItem):\n     def getId(self):\n         return self.id\n \n+\n def deepCopy(obj):\n     stream = BytesIO()\n     p = Pickler(stream, 1)\n@@ -57,6 +58,7 @@ def deepCopy(obj):\n     u = Unpickler(stream)\n     return u.load()\n \n+\n def notifyModified(obj):\n     """Notify the object as modified.\n \n@@ -64,13 +66,14 @@ def notifyModified(obj):\n     notifies the object as modified (faster than time.sleep(2)).\n     """\n     t = obj.modified()\n-    while t == DateTime(): pass\n+    while t == DateTime():\n+        pass\n     obj.notifyModified()\n \n \n class DummyArchivist(SimpleItem):\n-    """Archivist simulating modifiers and history storage.\n-    """\n+    """Archivist simulating modifiers and history storage."""\n+\n     id = \'portal_archivist\'\n \n     def getId(self):\n@@ -144,14 +147,19 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n         if sys_metadata[\'originator\'] is None:\n             self.log("")\n         if orefs:\n-            self.log("%sprepare %s: hid=%s, refs=(%s)"\n-                        % (self.alog_indent,\n-                           obj.getId(),\n-                           history_id,\n-                           \', \'.join([ref.getId() for ref in orefs])))\n+            self.log(\n+                "%sprepare %s: hid=%s, refs=(%s)"\n+                % (\n+                    self.alog_indent,\n+                    obj.getId(),\n+                    history_id,\n+                    \', \'.join([ref.getId() for ref in orefs]),\n+                )\n+            )\n         else:\n-            self.log("%sprepare %s: hid=%s"\n-                        % (self.alog_indent, obj.getId(), history_id))\n+            self.log(\n+                "%sprepare %s: hid=%s" % (self.alog_indent, obj.getId(), history_id)\n+            )\n         self.alog_indent += \'  \'\n \n         # prepare object structure\n@@ -160,16 +168,28 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n \n         approxSize = None\n \n-        return PreparedObject(history_id, original_info, clone_info, (),\n-                              app_metadata, sys_metadata, is_registered, approxSize)\n+        return PreparedObject(\n+            history_id,\n+            original_info,\n+            clone_info,\n+            (),\n+            app_metadata,\n+            sys_metadata,\n+            is_registered,\n+            approxSize,\n+        )\n \n     def register(self, prepared_obj):\n         # log\n-        self.log("%sregister %s: hid=%s, is_registered=%s"\n-                    % (self.alog_indent,\n-                       prepared_obj.original.object.getId(),\n-                       prepared_obj.history_id,\n-                       prepared_obj.is_registered))\n+        self.log(\n+            "%sregister %s: hid=%s, is_registered=%s"\n+            % (\n+                self.alog_indent,\n+                prepared_obj.original.object.getId(),\n+                prepared_obj.history_id,\n+                prepared_obj.is_registered,\n+            )\n+        )\n \n         if not prepared_obj.is_registered:\n             # new empty history\n@@ -179,7 +199,9 @@ def register(self, prepared_obj):\n     def save(self, prepared_obj, autoregister=False):\n         if not prepared_obj.is_registered:\n             if not autoregister:\n-                raise ArchivistError("not registered: %s " % prepared_obj.original.object)\n+                raise ArchivistError(\n+                    "not registered: %s " % prepared_obj.original.object\n+                )\n             self._archive[prepared_obj.history_id] = []\n \n         # log\n@@ -187,10 +209,8 @@ def save(self, prepared_obj, autoregister=False):\n \n         irefs = [ref.getAttribute() for ref in prepared_obj.clone.inside_refs]\n         orefs = [ref.getAttribute() for ref in prepared_obj.clone.outside_refs]\n-        irefs_prep = [\'{hid:%s, vid:%s}\' % (r.history_id, r.version_id)\n-                      for r in irefs]\n-        orefs_prep = [\'{hid:%s, vid:%s}\' % (r.history_id, r.version_id)\n-                      for r in orefs]\n+        irefs_prep = [\'{hid:%s, vid:%s}\' % (r.history_id, r.version_id) for r in irefs]\n+        orefs_prep = [\'{hid:%s, vid:%s}\' % (r.history_id, r.version_id) for r in orefs]\n         irefs = \', \'.join(irefs_prep)\n         orefs = \', \'.join(orefs_prep)\n         if irefs:\n@@ -198,13 +218,17 @@ def save(self, prepared_obj, autoregister=False):\n         if orefs:\n             orefs = "orefs=(%s), " % orefs\n         refs = irefs + orefs\n-        self.log("%ssave    %s: hid=%s, %sisreg=%s, auto=%s"\n-                    % (self.alog_indent,\n-                       prepared_obj.original.object.getId(),\n-                       prepared_obj.history_id,\n-                       refs,\n-                       prepared_obj.is_registered,\n-                       autoregister))\n+        self.log(\n+            "%ssave    %s: hid=%s, %sisreg=%s, auto=%s"\n+            % (\n+                self.alog_indent,\n+                prepared_obj.original.object.getId(),\n+                prepared_obj.history_id,\n+                refs,\n+                prepared_obj.is_registered,\n+                autoregister,\n+            )\n+        )\n \n         # save in the format the data needs to be retrieved\n         svdata = {\n@@ -215,24 +239,35 @@ def save(self, prepared_obj, autoregister=False):\n         # storage simulation\n         self._archive[prepared_obj.history_id].append(svdata)\n \n-    def retrieve(self, obj=None, history_id=None, selector=None, preserve=(),\n-                 countPurged=True):\n+    def retrieve(\n+        self, obj=None, history_id=None, selector=None, preserve=(), countPurged=True\n+    ):\n         obj, history_id = dereference(obj, history_id, self)\n         if selector is None:\n-            selector = len(self._archive[history_id]) - 1  #HEAD\n+            selector = len(self._archive[history_id]) - 1  # HEAD\n \n-        self.log("%sretrieve %s: hid=%s, selector=%s"\n-                    % (self.alog_indent, obj.getId(), history_id, selector))\n+        self.log(\n+            "%sretrieve %s: hid=%s, selector=%s"\n+            % (self.alog_indent, obj.getId(), history_id, selector)\n+        )\n \n         data = self._archive[history_id][selector]\n-        attr_handling_references = [\'_objects\',\'_tree\',\'_count\',\'_mt_index\', \'__annotations__\']\n+        attr_handling_references = [\n+            \'_objects\',\n+            \'_tree\',\n+            \'_count\',\n+            \'_mt_index\',\n+            \'__annotations__\',\n+        ]\n         attr_handling_references.extend(data[\'clone\'].object.objectIds())\n         attr_handling_references.extend(obj.objectIds())\n-        vdata = VersionData(data[\'clone\'],\n-                    [],\n-                    attr_handling_references,\n-                    data[\'referenced_data\'],\n-                    data[\'metadata\'])\n+        vdata = VersionData(\n+            data[\'clone\'],\n+            [],\n+            attr_handling_references,\n+            data[\'referenced_data\'],\n+            data[\'metadata\'],\n+        )\n \n         return deepCopy(vdata)\n \n@@ -244,8 +279,7 @@ def getHistoryMetadata(self, obj=None, history_id=None):\n         obj, history_id = dereference(obj, history_id, self)\n         return [item[\'metadata\'] for item in self._archive[history_id]]\n \n-    def queryHistory(self, obj=None, history_id=None,\n-                     preserve=(), default=None):\n+    def queryHistory(self, obj=None, history_id=None, preserve=(), default=None):\n         if default is None:\n             default = []\n         try:\n@@ -272,8 +306,8 @@ def setReference(self, target_obj, remove_info=True):\n         portal_hidhandler = getToolByName(target_obj, \'portal_historyidhandler\')\n         portal_archivist = getToolByName(target_obj, \'portal_archivist\')\n         self.history_id = portal_hidhandler.queryUid(target_obj)\n-        self.version_id = len(portal_archivist.queryHistory(target_obj))-1\n-        self.location_id = 1 # only one location possible currently\n+        self.version_id = len(portal_archivist.queryHistory(target_obj)) - 1\n+        self.location_id = 1  # only one location possible currently\n         if remove_info and hasattr(self, \'info\'):\n             self.info = None\n \n@@ -285,7 +319,7 @@ class DummyModifier(DummyBaseTool):\n     id = \'portal_modifier\'\n \n     def beforeSaveModifier(self, obj, clone):\n-        return {}, [], [] # XXX 2nd and 3rd shall be lists\n+        return {}, [], []  # XXX 2nd and 3rd shall be lists\n \n     def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         preserved = {}\n@@ -304,9 +338,9 @@ def reattachReferencedAttributes(self, object, referenced_data):\n     def getOnCloneModifiers(self, obj):\n         return None\n \n+\n class FolderishContentObjectModifier(DummyBaseTool):\n-    """This is a full fledged modifier.\n-    """\n+    """This is a full fledged modifier."""\n \n     id = \'portal_modifier\'\n \n@@ -401,7 +435,9 @@ def reattachReferencedAttributes(self, object, referenced_data):\n             setattr(object, key, value)\n \n     def _getAttributeNamesHandlingSubObjects(self, obj):\n-        return [\'_objects\', \'_tree\', \'_count\', \'_mt_index\', \'__annotations__\'].extend(obj.objectIds())\n+        return [\'_objects\', \'_tree\', \'_count\', \'_mt_index\', \'__annotations__\'].extend(\n+            obj.objectIds()\n+        )\n \n \n class DummyHistoryIdHandler(DummyBaseTool):\n@@ -439,39 +475,41 @@ def queryObject(self, uid, default=None):\n         except KeyError:\n             return default\n \n+\n #    def setUid(self, obj, uid, check_uniqueness=True):\n #        setattr(obj, self.UID_ATTRIBUTE_NAME, uid)\n \n+\n class StorageVersionData:\n     def __init__(self, object, referenced_data, metadata):\n         self.object = object\n         self.referenced_data = referenced_data\n         self.metadata = metadata\n+\n     def isValid(self):\n         return not isinstance(self.object, Removed)\n \n+\n class Removed:\n-    """Indicates that removement of data\n-    """\n+    """Indicates that removement of data"""\n \n     def __init__(self, reason, metadata):\n-        """Store Removed Info\n-        """\n+        """Store Removed Info"""\n         self.reason = reason\n         self.metadata = metadata\n \n+\n @implementer(IStorage, IPurgeSupport)\n class MemoryStorage(DummyBaseTool):\n     id = \'portal_historiesstorage\'\n \n-\n     def __init__(self):\n         self._histories = {}\n \n     def register(self, history_id, object, referenced_data={}, metadata=None):\n         histories = self._histories\n         if history_id not in histories.keys():\n-           return self._save(history_id, object, referenced_data, metadata)\n+            return self._save(history_id, object, referenced_data, metadata)\n \n     def save(self, history_id, object, referenced_data={}, metadata=None):\n         # delegate the decission what to purge to the purge policy tool\n@@ -486,11 +524,11 @@ def save(self, history_id, object, referenced_data={}, metadata=None):\n             raise StorageUnregisteredError(\n                 "Saving or retrieving an unregistered object is not "\n                 "possible. Register the object with history id \'%s\' first. "\n-                % history_id)\n+                % history_id\n+            )\n \n         return self._save(history_id, object, referenced_data, metadata)\n \n-\n     def _save(self, history_id, object, referenced_data={}, metadata=None):\n         histories = self._histories\n         cloned_referenced_data = {}\n@@ -501,9 +539,11 @@ def _save(self, history_id, object, referenced_data={}, metadata=None):\n                 cloned_referenced_data[key] = deepCopy(ref.getObject())\n             else:\n                 cloned_referenced_data[key] = deepCopy(ref)\n-        vdata = StorageVersionData(object=deepCopy(object),\n-                                   referenced_data=cloned_referenced_data,\n-                                   metadata=metadata)\n+        vdata = StorageVersionData(\n+            object=deepCopy(object),\n+            referenced_data=cloned_referenced_data,\n+            metadata=metadata,\n+        )\n         if history_id in histories.keys():\n             histories[history_id].append(vdata)\n         else:\n@@ -511,8 +551,7 @@ def _save(self, history_id, object, referenced_data={}, metadata=None):\n \n         return len(histories[history_id]) - 1\n \n-    def retrieve(self, history_id, selector=None,\n-                 countPurged=True, substitute=True):\n+    def retrieve(self, history_id, selector=None, countPurged=True, substitute=True):\n         if selector is None:\n             selector = len(self._getHistory(history_id)) - 1\n \n@@ -520,8 +559,9 @@ def retrieve(self, history_id, selector=None,\n             try:\n                 vdata = self._getHistory(history_id)[selector]\n             except IndexError:\n-                raise StorageRetrieveError("Retrieving non existing version %s"\n-                                           % selector)\n+                raise StorageRetrieveError(\n+                    "Retrieving non existing version %s" % selector\n+                )\n \n             vdata.referenced_data = deepcopy(vdata.referenced_data)\n             if substitute and isinstance(vdata.object, Removed):\n@@ -540,11 +580,9 @@ def retrieve(self, history_id, selector=None,\n                 if valid == selector:\n                     return vdata\n                 valid += 1\n-            raise StorageRetrieveError("Retrieving non existing version %s"\n-                                       % selector)\n+            raise StorageRetrieveError("Retrieving non existing version %s" % selector)\n \n-    def getHistory(self, history_id, preserve=(), countPurged=True,\n-                   substitute=True):\n+    def getHistory(self, history_id, preserve=(), countPurged=True, substitute=True):\n         history = []\n         sel = 0\n \n@@ -564,18 +602,17 @@ def getHistoryMetadata(self, history_id):\n     def isRegistered(self, history_id):\n         return history_id in self._histories\n \n-    def getModificationDate(self, history_id, selector=None,\n-                            countPurged=True, substitute=True):\n+    def getModificationDate(\n+        self, history_id, selector=None, countPurged=True, substitute=True\n+    ):\n         vdata = self.retrieve(history_id, selector, countPurged, substitute)\n         return vdata.object.object.modified()\n \n     def purge(self, history_id, selector, metadata={}, countPurged=True):\n-        """See ``IPurgeSupport``\n-        """\n+        """See ``IPurgeSupport``"""\n         histories = self._histories\n         history = histories[history_id]\n-        vdata = self.retrieve(history_id, selector, countPurged,\n-                              substitute=False)\n+        vdata = self.retrieve(history_id, selector, countPurged, substitute=False)\n         selector = history.index(vdata)\n         if not isinstance(vdata.object, Removed):\n             # prepare replacement for the deleted object and metadata\n@@ -591,13 +628,14 @@ def _getHistory(self, history_id):\n             raise StorageUnregisteredError(\n                 "Saving or retrieving an unregistered object is not "\n                 "possible. Register the object with history id \'%s\' first. "\n-                % history_id)\n+                % history_id\n+            )\n         return history\n-#        return HistoryList(history)\n+\n+    #        return HistoryList(history)\n \n     def _getLength(self, history_id, countPurged=True):\n-        """Returns the length of the history\n-        """\n+        """Returns the length of the history"""\n         histories = self._histories\n         history = self._getHistory(history_id)\n         if countPurged:\n@@ -612,25 +650,26 @@ def _getLength(self, history_id, countPurged=True):\n \n \n class HistoryList(list):\n-    """\n-    """\n+    """ """\n+\n     def __getitem__(self, selector):\n         if selector is None:\n             selector = -1\n         try:\n-           return list.__getitem__(self, selector)\n+            return list.__getitem__(self, selector)\n         except IndexError:\n             raise StorageRetrieveError("Retrieving non existing version %s" % selector)\n \n     def retrieve(self, selector, ignored=True):\n-       """Faux metadata only retrieval"""\n-       item = self[selector]\n-       return {\'metadata\': item.metadata}\n+        """Faux metadata only retrieval"""\n+        item = self[selector]\n+        return {\'metadata\': item.metadata}\n+\n \n @implementer(IPurgePolicy)\n class DummyPurgePolicy(DummyBaseTool):\n-    """Dummy Purge Policy\n-    """\n+    """Dummy Purge Policy"""\n+\n     id = \'portal_purgepolicy\'\n \n     def beforeSaveHook(self, history_id, obj, metadata={}):\n@@ -652,8 +691,7 @@ def beforeSaveHook(self, history_id, obj, metadata={}):\n         return True\n \n     def retrieveSubstitute(self, history_id, selector, default=None):\n-        """Retrives the next older version\n-        """\n+        """Retrives the next older version"""\n         storage = getToolByName(self, \'portal_historiesstorage\')\n         while selector:\n             selector -= 1\n@@ -665,8 +703,8 @@ def retrieveSubstitute(self, history_id, selector, default=None):\n \n @implementer(IStorage, IPurgeSupport)\n class PurgePolicyTestDummyStorage(DummyBaseTool):\n-    """Partial Storage used for PurgePolicy Tetss\n-    """\n+    """Partial Storage used for PurgePolicy Tetss"""\n+\n     id = \'portal_historiesstorage\'\n \n     def __init__(self):\n@@ -675,16 +713,13 @@ def __init__(self):\n     def save(self, history_id, obj):\n         self.history.append(obj)\n \n-    def getHistory(self, history_id, preserve=(), countPurged=True,\n-                   substitute=True):\n+    def getHistory(self, history_id, preserve=(), countPurged=True, substitute=True):\n         return self.history\n \n-    def purge(self, history_id, selector, metadata={},\n-              countPurged=True):\n+    def purge(self, history_id, selector, metadata={}, countPurged=True):\n         del self.history[selector]\n \n-    def retrieve(self, history_id, selector=None,\n-                 countPurged=True, substitute=True):\n+    def retrieve(self, history_id, selector=None, countPurged=True, substitute=True):\n         if selector >= len(self.history):\n             raise StorageRetrieveError()\n         return self.history[selector]\ndiff --git a/Products/CMFEditions/tests/base.py b/Products/CMFEditions/tests/base.py\nindex 86bdef3..3359c15 100644\n--- a/Products/CMFEditions/tests/base.py\n+++ b/Products/CMFEditions/tests/base.py\n@@ -6,7 +6,7 @@\n \n \n class CMFEditionsBaseTestCase(unittest.TestCase):\n-    """ A base class for Products.CMFEditions testing """\n+    """A base class for Products.CMFEditions testing"""\n \n     layer = PRODUCTS_CMFEDITIONS_INTEGRATION_TESTING\n \ndiff --git a/Products/CMFEditions/tests/test_ArchivistTool.py b/Products/CMFEditions/tests/test_ArchivistTool.py\nindex 56cfac6..d3b1b2d 100644\n--- a/Products/CMFEditions/tests/test_ArchivistTool.py\n+++ b/Products/CMFEditions/tests/test_ArchivistTool.py\n@@ -36,12 +36,10 @@\n \n \n class TestArchivistToolMemoryStorage(CMFEditionsBaseTestCase):\n-\n     def setUp(self):\n         super(TestArchivistToolMemoryStorage, self).setUp()\n \n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\',\n-                                                [\'Manager\'], \'\')\n+        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\', [\'Manager\'], \'\')\n         self.portal.invokeFactory(\'Document\', \'doc\')\n         self.portal.invokeFactory(\'Folder\', \'fol\')\n         self.portal.fol.invokeFactory(\'Document\', \'doc1_inside\')\n@@ -50,7 +48,7 @@ def setUp(self):\n         tools = (\n             DummyModifier(),\n             DummyHistoryIdHandler(),\n-            )\n+        )\n         for tool in tools:\n             self._setDummyTool(tool)\n \n@@ -92,16 +90,18 @@ def test02_retrieve(self):\n         doc.text = \'text v2\'\n         prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n         portal_archivist.save(prep)\n-        vdata = portal_archivist.retrieve(obj=doc, selector=0, preserve=(\'gaga\', \'gugus\'))\n+        vdata = portal_archivist.retrieve(\n+            obj=doc, selector=0, preserve=(\'gaga\', \'gugus\')\n+        )\n         retr_doc = vdata.data.object\n         retr_meta = vdata.app_metadata\n         doc_histid = portal_historyidhandler.queryUid(doc)\n         retr_histid = portal_historyidhandler.queryUid(retr_doc)\n         self.assertEqual(doc_histid, retr_histid)\n         # check if correct version retrieved and working object unchanged\n-        self.assertEqual(retr_doc.text , \'text v1\')\n-        self.assertEqual(retr_meta , \'save number 1\')\n-        self.assertEqual(doc.text , \'text v2\')\n+        self.assertEqual(retr_doc.text, \'text v1\')\n+        self.assertEqual(retr_meta, \'save number 1\')\n+        self.assertEqual(doc.text, \'text v2\')\n         self.assertEqual(len(vdata.preserved_data), 2)\n         self.assertEqual(vdata.preserved_data[\'gaga\'], \'gaga\')\n         self.assertEqual(vdata.preserved_data[\'gugus\'], \'gugus\')\n@@ -117,14 +117,15 @@ def test03_retrieveById(self):\n         prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n         portal_archivist.save(prep)\n         doc_histid = portal_historyidhandler.queryUid(doc)\n-        vdata = portal_archivist.retrieve(history_id=doc_histid, selector=0,\n-                                          preserve=(\'gaga\', \'gugus\'))\n+        vdata = portal_archivist.retrieve(\n+            history_id=doc_histid, selector=0, preserve=(\'gaga\', \'gugus\')\n+        )\n         retr_doc = vdata.data.object\n         retr_meta = vdata.app_metadata\n         # check if correct version retrieved and working object unchanged\n-        self.assertEqual(retr_doc.text , \'text v1\')\n-        self.assertEqual(retr_meta , \'save number 1\')\n-        self.assertEqual(doc.text , \'text v2\')\n+        self.assertEqual(retr_doc.text, \'text v1\')\n+        self.assertEqual(retr_meta, \'save number 1\')\n+        self.assertEqual(doc.text, \'text v2\')\n         self.assertEqual(len(vdata.preserved_data), 2)\n         self.assertEqual(vdata.preserved_data[\'gaga\'], \'gaga\')\n         self.assertEqual(vdata.preserved_data[\'gugus\'], \'gugus\')\n@@ -229,7 +230,7 @@ def test07_prepareObjectWithReferences(self):\n         outside_refs = prep.clone.outside_refs\n         self.assertEqual(len(inside_refs), 2)\n         self.assertEqual(len(outside_refs), 1)\n-        refs = [ref.getAttribute() for ref in inside_refs+outside_refs]\n+        refs = [ref.getAttribute() for ref in inside_refs + outside_refs]\n         for ref in refs:\n             self.assertTrue(IVersionAwareReference.providedBy(ref))\n         cloneValues = prep.clone.object.objectValues()\n@@ -242,7 +243,7 @@ def test07_prepareObjectWithReferences(self):\n         outside_orefs = prep.original.outside_refs\n         self.assertEqual(len(inside_orefs), 2)\n         self.assertEqual(len(outside_orefs), 1)\n-        refs = inside_orefs+outside_orefs\n+        refs = inside_orefs + outside_orefs\n         originalValues = prep.original.object.objectValues()\n \n         for sub in originalValues:\n@@ -250,8 +251,9 @@ def test07_prepareObjectWithReferences(self):\n \n         # the clones and the originals refs must also reference the\n         # "same" object\n-        self.assertEqual(prep.clone.object.objectIds(),\n-                         prep.original.object.objectIds())\n+        self.assertEqual(\n+            prep.clone.object.objectIds(), prep.original.object.objectIds()\n+        )\n \n         self.assertEqual(len(prep.referenced_data), 1)\n         self.assertTrue(prep.referenced_data[\'title\'] is fol.title)\n@@ -284,7 +286,7 @@ def test08_retrieveWithReferences(self):\n         # reference stuff is saved and retrieved correctly\n         inside_refs = prep.clone.inside_refs\n         outside_refs = prep.clone.outside_refs\n-        refs = [ref.getAttribute() for ref in inside_refs+outside_refs]\n+        refs = [ref.getAttribute() for ref in inside_refs + outside_refs]\n         for ref in refs:\n             ref.info = refs.index(ref)\n \n@@ -302,7 +304,7 @@ def test08_retrieveWithReferences(self):\n         outside_refs = retr.data.outside_refs\n         self.assertEqual(len(inside_refs), 2)\n         self.assertEqual(len(outside_refs), 1)\n-        refs = [ref.getAttribute() for ref in inside_refs+outside_refs]\n+        refs = [ref.getAttribute() for ref in inside_refs + outside_refs]\n         for ref in refs:\n             self.assertTrue(IVersionAwareReference.providedBy(ref))\n             # check info value (see note above)\n@@ -348,8 +350,12 @@ def test09_getHistoryMetadata(self):\n         self.assertTrue(history.retrieve(1)[\'metadata\'][\'sys_metadata\'][\'timestamp\'])\n         self.assertTrue(history.retrieve(0)[\'metadata\'][\'sys_metadata\'][\'principal\'])\n         # check if correct data and metadata retrieved\n-        self.assertEqual(history.retrieve(0)[\'metadata\'][\'app_metadata\'], \'save number 1\')\n-        self.assertEqual(history.retrieve(1)[\'metadata\'][\'app_metadata\'], \'save number 2\')\n+        self.assertEqual(\n+            history.retrieve(0)[\'metadata\'][\'app_metadata\'], \'save number 1\'\n+        )\n+        self.assertEqual(\n+            history.retrieve(1)[\'metadata\'][\'app_metadata\'], \'save number 2\'\n+        )\n \n     def test09_getHistoryMetadata_byId(self):\n         portal_archivist = self.portal.portal_archivist\n@@ -371,15 +377,19 @@ def test09_getHistoryMetadata_byId(self):\n         self.assertTrue(history.retrieve(1)[\'metadata\'][\'sys_metadata\'][\'timestamp\'])\n         self.assertTrue(history.retrieve(0)[\'metadata\'][\'sys_metadata\'][\'principal\'])\n         # check if correct data and metadata retrieved\n-        self.assertEqual(history.retrieve(0)[\'metadata\'][\'app_metadata\'], \'save number 1\')\n-        self.assertEqual(history.retrieve(1)[\'metadata\'][\'app_metadata\'], \'save number 2\')\n+        self.assertEqual(\n+            history.retrieve(0)[\'metadata\'][\'app_metadata\'], \'save number 1\'\n+        )\n+        self.assertEqual(\n+            history.retrieve(1)[\'metadata\'][\'app_metadata\'], \'save number 2\'\n+        )\n \n-class TestArchivistToolZStorage(TestArchivistToolMemoryStorage):\n \n-   def installStorageTool(self):\n-       """Test with a real ZODB storage overriding the storage installation\n-          in the super class.\n-       """\n-       # reset the shadow storage to avoid the effect of any versions created\n-       # during portal setup\n-       self.portal.portal_historiesstorage._shadowStorage = None\n+class TestArchivistToolZStorage(TestArchivistToolMemoryStorage):\n+    def installStorageTool(self):\n+        """Test with a real ZODB storage overriding the storage installation\n+        in the super class.\n+        """\n+        # reset the shadow storage to avoid the effect of any versions created\n+        # during portal setup\n+        self.portal.portal_historiesstorage._shadowStorage = None\ndiff --git a/Products/CMFEditions/tests/test_ContentTypes.py b/Products/CMFEditions/tests/test_ContentTypes.py\nindex fcaaa02..1fcebbe 100644\n--- a/Products/CMFEditions/tests/test_ContentTypes.py\n+++ b/Products/CMFEditions/tests/test_ContentTypes.py\n@@ -17,7 +17,6 @@ def read_image(file_path):\n \n \n class TestPloneContents(CMFEditionsBaseTestCase):\n-\n     def setUp(self):\n         super(TestPloneContents, self).setUp()\n         self.membership = self.portal.portal_membership\ndiff --git a/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py b/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py\nindex 28b06b2..a1d0659 100644\n--- a/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py\n+++ b/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py\n@@ -26,12 +26,8 @@\n \n from .DummyTools import DummyArchivist\n from .DummyTools import notifyModified\n-from Products.CMFEditions.interfaces.IRepository import (\n-    IContentTypeVersionPolicySupport\n-)\n-from Products.CMFEditions.interfaces.IRepository import (\n-    ICopyModifyMergeRepository\n-)\n+from Products.CMFEditions.interfaces.IRepository import IContentTypeVersionPolicySupport\n+from Products.CMFEditions.interfaces.IRepository import ICopyModifyMergeRepository\n from Products.CMFEditions.interfaces.IRepository import IPurgeSupport\n from Products.CMFEditions.interfaces.IRepository import IVersionData\n from Products.CMFEditions.interfaces.IRepository import RepositoryPurgeError\n@@ -63,9 +59,7 @@ def setUp(self):\n         super(TestCopyModifyMergeRepositoryToolBase, self).setUp()\n \n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\n-            "reviewer", "reviewer", ["Manager"], ""\n-        )\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n \n         # add test data\n         self.portal.invokeFactory("Document", "doc")\n@@ -225,9 +219,7 @@ def test07_restoreDeletedObject(self):\n         self.portal.manage_delObjects(ids=["doc"])\n         self.assertFalse("doc" in self.portal.objectIds())\n         with self.assertRaises(AttributeError):\n-            portal_repository.restore(\n-                history_id, selector=0, container=self.portal\n-            )\n+            portal_repository.restore(history_id, selector=0, container=self.portal)\n         # portal_repository.restore(history_id, selector=0, container=self.portal)  # noqa: E501\n         # self.assertTrue(\'doc\' in self.portal.objectIds())\n         # restored = self.portal.doc\n@@ -289,12 +281,8 @@ def test09_getHistoryMetadata(self):\n         # The history is acquisition wrapped\n         self.assertEqual(history.aq_parent, doc)\n         # check if timestamp and principal available\n-        self.assertTrue(\n-            history.retrieve(1)["metadata"]["sys_metadata"]["timestamp"]\n-        )\n-        self.assertTrue(\n-            history.retrieve(0)["metadata"]["sys_metadata"]["principal"]\n-        )\n+        self.assertTrue(history.retrieve(1)["metadata"]["sys_metadata"]["timestamp"])\n+        self.assertTrue(history.retrieve(0)["metadata"]["sys_metadata"]["principal"])\n         # check if correct data and metadata retrieved\n         self.assertEqual(\n             history.retrieve(0)["metadata"]["sys_metadata"]["comment"],\n@@ -381,23 +369,15 @@ def test02_recursiveRetrieve(self):\n \n         # check result\n         self.assertEqual(retr.object.title, "fol title v1")\n-        self.assertEqual(\n-            retr.object.doc1_inside.title, "doc1_inside title text v1"\n-        )\n-        self.assertEqual(\n-            retr.object.doc2_inside.title, "doc2_inside title text v1"\n-        )\n-        self.assertEqual(\n-            retr.object.doc3_outside.title, "doc3_outside title text v2"\n-        )\n+        self.assertEqual(retr.object.doc1_inside.title, "doc1_inside title text v1")\n+        self.assertEqual(retr.object.doc2_inside.title, "doc2_inside title text v1")\n+        self.assertEqual(retr.object.doc3_outside.title, "doc3_outside title text v2")\n \n \n class TestRegressionTests(CMFEditionsBaseTestCase):\n     def setUp(self):\n         super(TestRegressionTests, self).setUp()\n-        self.portal.acl_users.userFolderAddUser(\n-            "reviewer", "reviewer", ["Manager"], ""\n-        )\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n \n         self.portal.invokeFactory("Document", "doc")\n         self.portal.invokeFactory("Folder", "fol")\n@@ -439,66 +419,40 @@ def test01_remove_policy_from_type(self):\n         portal_repository = self.portal.portal_repository\n         # Set it twice to ensure that duplicates aren\'t created\n         self.assertTrue(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n-        )\n-        portal_repository.removePolicyFromContentType(\n-            "Document", "at_edit_autoversion"\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n+        portal_repository.removePolicyFromContentType("Document", "at_edit_autoversion")\n         self.assertFalse(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n         # Calling it twice should not fail.\n-        portal_repository.removePolicyFromContentType(\n-            "Document", "at_edit_autoversion"\n-        )\n+        portal_repository.removePolicyFromContentType("Document", "at_edit_autoversion")\n \n     def test02_set_policy_on_type(self):\n         # test that policies can be set and retrieved\n         portal_repository = self.portal.portal_repository\n         self.assertTrue(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n-        )\n-        portal_repository.removePolicyFromContentType(\n-            "Document", "at_edit_autoversion"\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n+        portal_repository.removePolicyFromContentType("Document", "at_edit_autoversion")\n         self.assertFalse(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n-        )\n-        portal_repository.addPolicyForContentType(\n-            "Document", "at_edit_autoversion"\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n+        portal_repository.addPolicyForContentType("Document", "at_edit_autoversion")\n         self.assertTrue(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n \n     def test03_set_policy_types_map(self):\n         # test the mapping of policies to types\n         portal_repository = self.portal.portal_repository\n         # Get something in place first\n-        portal_repository.addPolicyForContentType(\n-            "Document", "at_edit_autoversion"\n-        )\n-        portal_repository.removePolicyFromContentType(\n-            "Document", "at_edit_autoversion"\n-        )\n+        portal_repository.addPolicyForContentType("Document", "at_edit_autoversion")\n+        portal_repository.removePolicyFromContentType("Document", "at_edit_autoversion")\n         # update the mapping\n-        portal_repository.manage_setTypePolicies(\n-            {"Document": ["at_edit_autoversion"]}\n-        )\n+        portal_repository.manage_setTypePolicies({"Document": ["at_edit_autoversion"]})\n         self.assertTrue(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n \n         # assign two policies and then unassign them.\n@@ -512,14 +466,10 @@ def test03_set_policy_types_map(self):\n         )\n         portal_repository.manage_setTypePolicies({"Document": []})\n         self.assertFalse(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n         self.assertFalse(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "version_on_publish"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "version_on_publish")\n         )\n \n     def test04_add_policy(self):\n@@ -548,15 +498,11 @@ def test05_remove_policy(self):\n         portal_repository.addPolicy(\n             "version_on_publish", "Create version when published"\n         )\n-        portal_repository.addPolicyForContentType(\n-            "Document", "version_on_publish"\n-        )\n+        portal_repository.addPolicyForContentType("Document", "version_on_publish")\n         portal_repository.removePolicy("version_on_publish")\n         self.assertEqual(len(portal_repository.listPolicies()), self.np)\n         self.assertFalse(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "version_on_publish"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "version_on_publish")\n         )\n \n     def test07_set_policy_defs(self):\n@@ -645,22 +591,16 @@ def test09_policy_hooks(self):\n             "Document", "my_bogus_policy", out=out\n         )\n         self.assertTrue(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "my_bogus_policy"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "my_bogus_policy")\n         )\n         self.assertEqual(out, ["added", "enabled Document"])\n         portal_repository.removePolicyFromContentType(\n             "Document", "my_bogus_policy", out=out\n         )\n         self.assertFalse(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "my_bogus_policy"\n-            )\n-        )\n-        self.assertEqual(\n-            out, ["added", "enabled Document", "disabled Document"]\n+            portal_repository.supportsPolicy(self.portal.doc, "my_bogus_policy")\n         )\n+        self.assertEqual(out, ["added", "enabled Document", "disabled Document"])\n         portal_repository.removePolicy("my_bogus_policy", out=out)\n         self.assertEqual(\n             out, ["added", "enabled Document", "disabled Document", "removed"]\n@@ -743,12 +683,8 @@ def test14_has_policy(self):\n         portal_repository = self.portal.portal_repository\n         # We already have two policies by default\n         self.assertTrue(portal_repository.hasPolicy(self.portal.doc))\n-        portal_repository.removePolicyFromContentType(\n-            "Document", "at_edit_autoversion"\n-        )\n-        portal_repository.removePolicyFromContentType(\n-            "Document", "version_on_revert"\n-        )\n+        portal_repository.removePolicyFromContentType("Document", "at_edit_autoversion")\n+        portal_repository.removePolicyFromContentType("Document", "version_on_revert")\n         self.assertFalse(portal_repository.hasPolicy(self.portal.doc))\n \n     def test15_remove_policy_twice(self):\ndiff --git a/Products/CMFEditions/tests/test_IntegrationTests.py b/Products/CMFEditions/tests/test_IntegrationTests.py\nindex 07d64db..8acda81 100644\n--- a/Products/CMFEditions/tests/test_IntegrationTests.py\n+++ b/Products/CMFEditions/tests/test_IntegrationTests.py\n@@ -39,13 +39,11 @@\n \n \n class TestIntegration(CMFEditionsBaseTestCase):\n-\n     def setUp(self):\n         super(TestIntegration, self).setUp()\n \n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\',\n-                                                [\'Manager\'], \'\')\n+        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\', [\'Manager\'], \'\')\n         # add a document\n         self.portal.invokeFactory(\'Document\', \'doc\')\n \n@@ -146,8 +144,7 @@ def test06_retrieveSpecificVersion(self):\n         portal_repo = self.portal.portal_repository\n         doc = self.portal.doc\n \n-        review_state = self.portal.portal_workflow.getInfoFor(\n-            doc, \'review_state\')\n+        review_state = self.portal.portal_workflow.getInfoFor(doc, \'review_state\')\n \n         # store the work edition two times\n         doc.setTitle("v1")\n@@ -167,8 +164,7 @@ def test06_retrieveSpecificVersion(self):\n \n         # since 1.0beta1 the workflows review state is saved to the\n         # system metadata by a modifier.\n-        self.assertEqual(\n-            retrieved_doc.sys_metadata["review_state"], review_state)\n+        self.assertEqual(retrieved_doc.sys_metadata["review_state"], review_state)\n \n     def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):\n         portal_repo = self.portal.portal_repository\n@@ -179,8 +175,7 @@ def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):\n         portal_repo.applyVersionControl(doc)\n \n         # copy\n-        self.portal.manage_pasteObjects(\n-            self.portal.manage_copyObjects(ids=[\'doc\']))\n+        self.portal.manage_pasteObjects(self.portal.manage_copyObjects(ids=[\'doc\']))\n         copy = self.portal.copy_of_doc\n \n         # the copy shall not have a history yet: that\'s correct\n@@ -189,7 +184,8 @@ def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):\n         # just to be sure the history is definitivels different\n         self.assertNotEqual(\n             portal_historyidhandler.queryUid(doc),\n-            portal_historyidhandler.queryUid(copy))  # may be None\n+            portal_historyidhandler.queryUid(copy),\n+        )  # may be None\n \n     def test08_loopOverHistory(self):\n         portal_repo = self.portal.portal_repository\n@@ -225,11 +221,12 @@ def test09_retrieveAndRevertRetainWorkingCopiesWorkflowInfo(self):\n         # ----- retrieve\n         # check if retrieved object carries the working copies workflow info\n         retrieved_data = portal_repo.retrieve(\n-            doc, 0, preserve=[\'review_state\', \'workflow_history\'])\n-        self.assertEqual(retrieved_data.object.review_state,\n-                         "fake rev state v2")\n-        self.assertEqual(retrieved_data.object.workflow_history[0],\n-                         "fake wf history v2")\n+            doc, 0, preserve=[\'review_state\', \'workflow_history\']\n+        )\n+        self.assertEqual(retrieved_data.object.review_state, "fake rev state v2")\n+        self.assertEqual(\n+            retrieved_data.object.workflow_history[0], "fake wf history v2"\n+        )\n \n         # check that the working copies workflow info is unchanged\n         self.assertEqual(doc.review_state, "fake rev state v2")\n@@ -292,10 +289,14 @@ def test11_versionAFolderishObjectThatTreatsChildrensAsInsideRefs(self):\n         # just configure the standard folder to treat the childrens as\n         # inside refrences. For this we reconfigure the standard modifiers.\n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n         fol.setTitle(\'v1 of fol\')\n@@ -340,8 +341,7 @@ def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):\n         doc = self.portal.doc\n         perm = \'Access contents information\'\n         member_role = \'permission_{0}role_{1}\'.format(\n-            _string_hash(perm),\n-            _string_hash(\'Member\')\n+            _string_hash(perm), _string_hash(\'Member\')\n         )\n \n         doc.manage_permission(perm, (\'Manager\',), 0)\n@@ -354,33 +354,29 @@ def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):\n         # just check the original is unchanged\n         settings = doc.permission_settings(perm)[0]\n         self.assertTrue(settings[\'acquire\'])\n-        role_enabled = [r for r in settings[\'roles\']\n-                        if r[\'name\'] == member_role][0]\n+        role_enabled = [r for r in settings[\'roles\'] if r[\'name\'] == member_role][0]\n         self.assertTrue(role_enabled[\'checked\'])\n \n         # ----- retrieve\n         # check if retrieved object carries the working copy\'s permissions\n         retrieved_data = portal_repo.retrieve(\n-            doc, 0, preserve=[\'_Access_contents_information_Permission\'])\n+            doc, 0, preserve=[\'_Access_contents_information_Permission\']\n+        )\n         settings = retrieved_data.object.permission_settings(perm)[0]\n         self.assertTrue(settings[\'acquire\'])\n-        role_enabled = [\n-            r for r in settings[\'roles\']\n-            if r[\'name\'] == member_role\n-        ][0]\n+        role_enabled = [r for r in settings[\'roles\'] if r[\'name\'] == member_role][0]\n         self.assertTrue(role_enabled[\'checked\'])\n \n         # check that the working copy\'s permissions are unchanged\n         settings = doc.permission_settings(perm)[0]\n         self.assertTrue(settings[\'acquire\'])\n-        role_enabled = [\n-            r for r in settings[\'roles\']\n-            if r[\'name\'] == member_role\n-        ][0]\n+        role_enabled = [r for r in settings[\'roles\'] if r[\'name\'] == member_role][0]\n         self.assertTrue(role_enabled[\'checked\'])\n \n         # check if the preserved data is returned correctly\n-        preserved = retrieved_data.preserved_data[\'_Access_contents_information_Permission\']  # noqa\n+        preserved = retrieved_data.preserved_data[\n+            \'_Access_contents_information_Permission\'\n+        ]  # noqa\n         self.assertEqual(preserved, (\'Manager\',))\n \n         # ----- revert\n@@ -388,8 +384,7 @@ def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):\n         portal_repo.revert(doc, 0)\n         settings = doc.permission_settings(perm)[0]\n         self.assertTrue(settings[\'acquire\'])\n-        role_enabled = [r for r in settings[\'roles\']\n-                        if r[\'name\'] == member_role][0]\n+        role_enabled = [r for r in settings[\'roles\'] if r[\'name\'] == member_role][0]\n         self.assertTrue(role_enabled[\'checked\'])\n \n     def test13_revertUpdatesCatalog(self):\n@@ -409,7 +404,8 @@ def test13_revertUpdatesCatalog(self):\n         self.assertEqual(results[0].getObject(), doc)\n \n         retrieved_data = portal_repo.retrieve(\n-            doc, 0, preserve=[\'_Access_contents_information_Permission\'])\n+            doc, 0, preserve=[\'_Access_contents_information_Permission\']\n+        )\n         retrieved_doc = retrieved_data.object\n         self.assertTrue(\'Plain text\' in retrieved_doc.text.raw)\n         # Test that basic retrieval did not alter the catalog\n@@ -443,8 +439,7 @@ def test14_retrieveFolderWithAddedOrDeletedObjects(self):\n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n         self.assertEqual(ret_folder.objectIds(), fol.objectIds())\n-        self.assertEqual(tuple(ret_folder.objectValues()),\n-                         tuple(fol.objectValues()))\n+        self.assertEqual(tuple(ret_folder.objectValues()), tuple(fol.objectValues()))\n \n         # remove an item\n         fol.manage_delObjects(\'doc2\')\n@@ -453,8 +448,7 @@ def test14_retrieveFolderWithAddedOrDeletedObjects(self):\n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n         self.assertEqual(ret_folder.objectIds(), fol.objectIds())\n-        self.assertEqual(tuple(ret_folder.objectValues()),\n-                         tuple(fol.objectValues()))\n+        self.assertEqual(tuple(ret_folder.objectValues()), tuple(fol.objectValues()))\n \n         # add it back\n         fol.invokeFactory(\'Document\', \'doc2\')\n@@ -465,8 +459,7 @@ def test14_retrieveFolderWithAddedOrDeletedObjects(self):\n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n         self.assertEqual(ret_folder.objectIds(), fol.objectIds())\n-        self.assertEqual(tuple(ret_folder.objectValues()),\n-                         tuple(fol.objectValues()))\n+        self.assertEqual(tuple(ret_folder.objectValues()), tuple(fol.objectValues()))\n         self.assertEqual(ret_folder.doc2.Title(), \'v2 of doc2\')\n \n         # add new item\n@@ -478,8 +471,7 @@ def test14_retrieveFolderWithAddedOrDeletedObjects(self):\n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n         self.assertEqual(ret_folder.objectIds(), fol.objectIds())\n-        self.assertEqual(tuple(ret_folder.objectValues()),\n-                         tuple(fol.objectValues()))\n+        self.assertEqual(tuple(ret_folder.objectValues()), tuple(fol.objectValues()))\n         self.assertEqual(ret_folder.doc3.Title(), \'v1 of doc3\')\n \n         orig_ids = fol.objectIds()\n@@ -503,10 +495,14 @@ def test15_retrieveInsideRefsFolderWithAddedOrDeletedObjects(self):\n         # just configure the standard folder to treat the children as\n         # inside references. For this we reconfigure the standard modifiers.\n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n         fol.setTitle(\'v1 of fol\')\n@@ -585,10 +581,14 @@ def test16_revertInsideRefsUpdatesCatalog(self):\n         # just configure the standard folder to treat the childrens as\n         # inside refrences. For this we reconfigure the standard modifiers.\n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n         fol.setTitle(\'v1 of fol\')\n@@ -612,11 +612,14 @@ def test16_revertInsideRefsUpdatesCatalog(self):\n         self.assertEqual(results[0].getObject(), doc)\n \n         retrieved_data = portal_repo.retrieve(\n-            fol, 0, preserve=[\'_Access_contents_information_Permission\'])\n+            fol, 0, preserve=[\'_Access_contents_information_Permission\']\n+        )\n         retrieved_doc = retrieved_data.object.doc1\n         self.assertEqual(retrieved_doc.Title(), \'v1 of doc1\')\n         # Test that basic retrieval did not alter the catalog\n-        results = cat(SearchableText=\'v1\', )\n+        results = cat(\n+            SearchableText=\'v1\',\n+        )\n         self.assertEqual(len(results), 0)\n         results = cat(SearchableText=\'v2\', portal_type=\'Document\')\n         self.assertEqual(len(results), 1)\n@@ -646,10 +649,14 @@ def test17_moveInsideRefThenRevertChangesUid(self):\n         # just configure the standard folder to treat the childrens as\n         # inside refrences. For this we reconfigure the standard modifiers.\n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n         fol.setTitle(\'v1 of fol\')\n@@ -668,8 +675,10 @@ def test17_moveInsideRefThenRevertChangesUid(self):\n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n         ret_doc = ret_folder.doc1\n-        self.assertFalse(portal_historyidhandler.queryUid(ret_doc) == orig_uid,\n-                    "UIDs should not be equal, current value: %s" % orig_uid)\n+        self.assertFalse(\n+            portal_historyidhandler.queryUid(ret_doc) == orig_uid,\n+            "UIDs should not be equal, current value: %s" % orig_uid,\n+        )\n \n         # revert to original state, ensure that subobject changes are\n         # reverted and that uid is changed\n@@ -678,8 +687,10 @@ def test17_moveInsideRefThenRevertChangesUid(self):\n         reverted_doc = fol.doc1\n \n         # check if reversion worked correctly\n-        self.assertFalse(portal_historyidhandler.queryUid(reverted_doc) == orig_uid,\n-                    "UIDs should not be equal, current value: %s" % orig_uid)\n+        self.assertFalse(\n+            portal_historyidhandler.queryUid(reverted_doc) == orig_uid,\n+            "UIDs should not be equal, current value: %s" % orig_uid,\n+        )\n \n     def test18_retrieveObjectWhichHasBeenReplaced(self):\n         portal_repo = self.portal.portal_repository\n@@ -717,7 +728,9 @@ def test18_retrieveObjectWhichHasBeenReplaced(self):\n         self.assertEqual(rev_doc.getId(), \'doc1_renamed\')\n         self.assertEqual(rev_doc.Title(), \'v1 of doc1\')\n \n-    def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolder(self):  # noqa\n+    def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolder(\n+        self,\n+    ):  # noqa\n         # disabled by gregweb/21-10-2006\n         # reason: Needs concentrated and deeper look.\n         # --> Ideas exist, pleas contact us on the list if you like to work\n@@ -730,10 +743,14 @@ def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolde\n         doc2 = fol.doc2\n \n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n         fol.setTitle(\'v1 of fol\')\n@@ -773,7 +790,9 @@ def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolde\n         self.assertEqual(rev_doc2.getId(), \'doc2\')\n         self.assertEqual(rev_doc2.Title(), \'v1 of doc2\')\n \n-    def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(self):  # noqa\n+    def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(\n+        self,\n+    ):  # noqa\n         # disabled by gregweb/21-10-2006\n         # reason: Needs concentrated and deeper look.\n         # --> Ideas exist, pleas contact us on the list if you like to work\n@@ -786,10 +805,14 @@ def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(\n         doc2 = fol.doc2\n \n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n         fol.setTitle(\'v1 of fol\')\n@@ -838,10 +861,14 @@ def test21_DontLeaveDanglingCatalogEntriesWhenInvokingFactory(self):\n         doc2 = fol.doc2\n \n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n         fol.setTitle(\'v1 of fol\')\n@@ -990,14 +1017,12 @@ def test23_versioningPreservesFolderAnnotations(self):\n         self.assertEqual(repo_fol1.__annotations__[\'something\'], True)\n         self.assertEqual(repo_fol2.__annotations__[\'something\'], False)\n         self.assertEqual(fol.__annotations__[\'something\'], None)\n-        self.assertEqual(repo_fol2.__annotations__.get(\'another_thing\',\n-                                                           None), None)\n+        self.assertEqual(repo_fol2.__annotations__.get(\'another_thing\', None), None)\n \n         # Test that revert brings in the original annotation\n         portal_repo.revert(fol)\n         self.assertEqual(fol.__annotations__[\'something\'], False)\n-        self.assertEqual(fol.__annotations__.get(\'another_thing\', None),\n-                             None)\n+        self.assertEqual(fol.__annotations__.get(\'another_thing\', None), None)\n \n         portal_repo.revert(fol, 0)\n         self.assertEqual(fol.__annotations__[\'something\'], True)\n@@ -1049,17 +1074,20 @@ def test24_versioningPreservesFolderOrder(self):\n         self.assertEqual(fol._tree.get(\'doc2\', None), None)\n         self.assertEqual(fol._tree[\'doc3\'], doc3)\n         self.assertEqual(fol._count(), 2)\n-        self.assertEqual(fol._mt_index[doc2.meta_type].get(\'doc2\', None),\n-                             None)\n+        self.assertEqual(fol._mt_index[doc2.meta_type].get(\'doc2\', None), None)\n         self.assertEqual(fol._mt_index[doc3.meta_type][\'doc3\'], 1)\n \n     def test25_versioningRestoresInsideRefsFolderOrder(self):\n         # Enable OMInsideChildrensModifier\n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         portal_repo = self.portal.portal_repository\n         fol = self.portal.fol\n@@ -1128,8 +1156,7 @@ def test25_versioningRestoresInsideRefsFolderOrder(self):\n         # Test the BTreeFolder internals\n         self.assertEqual(fol._tree.get(\'doc5\', None), None)\n         self.assertEqual(fol._count(), 4)\n-        self.assertEqual(fol._mt_index[doc3.meta_type].get(\'doc5\', None),\n-                             None)\n+        self.assertEqual(fol._mt_index[doc3.meta_type].get(\'doc5\', None), None)\n         self.assertEqual(fol._tree[\'doc3\'], fol[\'doc3\'].aq_base)\n         self.assertEqual(fol._mt_index[doc3.meta_type][\'doc3\'], 1)\n \n@@ -1146,10 +1173,14 @@ def test26_RegistryBasesNotVersionedOrRestored(self):\n         portal_repo.applyVersionControl(fol)\n \n         broken_iface = broken.find_global(\n-            \'never_gonna_be_real\', \'IMissing\',\n-            Broken=ZODB.interfaces.IBroken, type=InterfaceClass)\n+            \'never_gonna_be_real\',\n+            \'IMissing\',\n+            Broken=ZODB.interfaces.IBroken,\n+            type=InterfaceClass,\n+        )\n         sys.modules[broken_iface.__module__] = module = imp.new_module(\n-            broken_iface.__module__)\n+            broken_iface.__module__\n+        )\n         module.IMissing = broken_iface\n \n         # add a broken registrsation but do a savepoint before\n@@ -1167,5 +1198,4 @@ def test26_RegistryBasesNotVersionedOrRestored(self):\n         portal_archivist._cloneByPickle(fol)\n \n         self.assertEqual(self.portal.fol.Title(), "v2")\n-        self.assertTrue(\n-            self.portal.fol.getSiteManager().__bases__[0] is base)\n+        self.assertTrue(self.portal.fol.getSiteManager().__bases__[0] is base)\ndiff --git a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\nindex af24006..967a2f8 100644\n--- a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\n+++ b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\n@@ -32,12 +32,10 @@\n \n \n class TestKeepLastNVersionsTool(CMFEditionsBaseTestCase):\n-\n     def setUp(self):\n         super(TestKeepLastNVersionsTool, self).setUp()\n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\',\n-                                                [\'Manager\'], \'\')\n+        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\', [\'Manager\'], \'\')\n \n         # install test storage\n         self._setDummyTool(PurgePolicyTestDummyStorage())\ndiff --git a/Products/CMFEditions/tests/test_ModifierRegistryTool.py b/Products/CMFEditions/tests/test_ModifierRegistryTool.py\nindex c5f9963..3087799 100644\n--- a/Products/CMFEditions/tests/test_ModifierRegistryTool.py\n+++ b/Products/CMFEditions/tests/test_ModifierRegistryTool.py\n@@ -24,6 +24,7 @@\n """\n \n from Acquisition import aq_base\n+\n # provoke the warning messages before the first test\n from OFS.SimpleItem import SimpleItem\n from pickle import dumps\n@@ -42,14 +43,17 @@\n \n class Dummy(SimpleItem):\n     pass\n+\n+\n def deepcopy(obj):\n     return loads(dumps(obj, HIGHEST_PROTOCOL))\n+\n+\n deepcopy(Dummy())\n \n \n @implementer(ISaveRetrieveModifier)\n class SimpleModifierBase:\n-\n     def beforeSaveModifier(self, obj, copy_obj):\n         try:\n             bsm = getattr(copy_obj, self.beforeSaveModifierAttribute)\n@@ -68,23 +72,29 @@ def afterRetrieveModifier(self, obj, repo_obj):\n         setattr(repo_obj, self.afterRetrieveModifierAttribute, arm)\n         return [], [], {}\n \n+\n class SimpleModifier1(SimpleModifierBase):\n     beforeSaveModifierAttribute = \'beforeSave1\'\n     afterRetrieveModifierAttribute = \'afterRetrieve1\'\n \n+\n class SimpleModifier2(SimpleModifierBase):\n     beforeSaveModifierAttribute = \'beforeSave2\'\n     afterRetrieveModifierAttribute = \'afterRetrieve2\'\n \n+\n class SimpleModifier3(SimpleModifierBase):\n     beforeSaveModifierAttribute = \'beforeSave3\'\n     afterRetrieveModifierAttribute = \'afterRetrieve3\'\n \n+\n class NonModifier(SimpleItem):\n     pass\n \n+\n mlog = []\n \n+\n def dictToString(dict):\n     dict_list = []\n     keys = [key for key in dict.keys()]\n@@ -93,16 +103,18 @@ def dictToString(dict):\n         dict_list.append("%s = %s" % (k, dict[k]))\n     return \', \'.join(dict_list)\n \n+\n @implementer(IAttributeModifier, ICloneModifier, ISaveRetrieveModifier)\n class LoggingModifierBase:\n-\n     def getReferencedAttributes(self, obj):\n         referenced_data = {\n-            \'k1\': \'v1:\'+str(self.__class__.__name__),\n-            \'k2\': \'v2:\'+str(self.__class__.__name__),\n+            \'k1\': \'v1:\' + str(self.__class__.__name__),\n+            \'k2\': \'v2:\' + str(self.__class__.__name__),\n         }\n-        mlog.append("%s.getReferencedAttributes: %s" %\n-                    (self.__class__.__name__, dictToString(referenced_data)))\n+        mlog.append(\n+            "%s.getReferencedAttributes: %s"\n+            % (self.__class__.__name__, dictToString(referenced_data))\n+        )\n         return referenced_data\n \n     def getOnCloneModifiers(self, obj):\n@@ -125,18 +137,23 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         mlog.append("%s.afterRetrieveModifier" % (self.__class__.__name__))\n         return [], [], {}\n \n+\n class LoggingModifier_A(LoggingModifierBase):\n     pass\n \n+\n class LoggingModifier_B(LoggingModifierBase):\n     pass\n \n+\n class LoggingModifier_C(LoggingModifierBase):\n     pass\n \n+\n class LoggingModifier_D(LoggingModifierBase):\n     pass\n \n+\n loggingModifiers = (\n     LoggingModifier_A(),\n     LoggingModifier_B(),\n@@ -144,14 +161,13 @@ class LoggingModifier_D(LoggingModifierBase):\n     LoggingModifier_D(),\n )\n \n-class TestModifierRegistryTool(CMFEditionsBaseTestCase):\n \n+class TestModifierRegistryTool(CMFEditionsBaseTestCase):\n     def setUp(self):\n         super(TestModifierRegistryTool, self).setUp()\n \n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\',\n-                                                [\'Manager\'], \'\')\n+        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\', [\'Manager\'], \'\')\n         # add a document\n         self.portal.invokeFactory(\'Document\', \'doc\')\n \n@@ -165,10 +181,11 @@ def test00_interface(self):\n         portal_modifier = self.portal.portal_modifier\n \n         # test interface conformance\n-        #verifyObject(IModifier, portal_modifier)\n+        # verifyObject(IModifier, portal_modifier)\n         verifyObject(IModifierRegistrySet, portal_modifier)\n         verifyObject(IModifierRegistryQuery, portal_modifier)\n-#        verifyObject(IBulkEditableSubscriberRegistry, portal_modifier)\n+\n+    #        verifyObject(IBulkEditableSubscriberRegistry, portal_modifier)\n \n     def test01_modifiersNotCalled(self):\n         portal_modifier = self.portal.portal_modifier\n@@ -292,18 +309,20 @@ def test09_conditionContextSetUpCorretcly(self):\n         doc_copy = deepcopy(aq_base(doc))\n \n         # just check if variables got defined\n-        condition = \'python:"%s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s" % (\' \\\n-                    \'object_url, \' \\\n-                    \'folder_url, \' \\\n-                    \'portal_url, \' \\\n-                    \'object, \' \\\n-                    \'folder, \' \\\n-                    \'portal, \' \\\n-                    \'nothing, \' \\\n-                    \'request, \' \\\n-                    \'modules, \' \\\n-                    \'member,\' \\\n-                    \')\'\n+        condition = (\n+            \'python:"%s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s" % (\'\n+            \'object_url, \'\n+            \'folder_url, \'\n+            \'portal_url, \'\n+            \'object, \'\n+            \'folder, \'\n+            \'portal, \'\n+            \'nothing, \'\n+            \'request, \'\n+            \'modules, \'\n+            \'member,\'\n+            \')\'\n+        )\n         portal_modifier.register(\'1\', SimpleModifier1())\n         portal_modifier.edit(\'1\', enabled=True, condition=condition)\n \n@@ -325,9 +344,7 @@ def test10_callingOrder(self):\n         for m in loggingModifiers:\n             counter += 1\n             portal_modifier.register(str(counter), m)\n-            portal_modifier.edit(str(counter),\n-                                 enabled=True,\n-                                 condition=\'python:True\')\n+            portal_modifier.edit(str(counter), enabled=True, condition=\'python:True\')\n \n         mlog.append(\'<save>\')\n         portal_modifier.getReferencedAttributes(doc)\n@@ -338,9 +355,10 @@ def test10_callingOrder(self):\n         portal_modifier.afterRetrieveModifier(doc, doc_copy)\n         mlog.append(\'<end>\')\n \n-        mlog_str = \'\\n\'.join(mlog).replace(\'__main__\', \'CMFEditions.tests.test_ModifierRegistryTool\')\n-        expected_result = \\\n-"""<save>\n+        mlog_str = \'\\n\'.join(mlog).replace(\n+            \'__main__\', \'CMFEditions.tests.test_ModifierRegistryTool\'\n+        )\n+        expected_result = """<save>\n %(class)s_A.getReferencedAttributes: k1 = v1:%(class)s_A, k2 = v2:%(class)s_A\n %(class)s_B.getReferencedAttributes: k1 = v1:%(class)s_B, k2 = v2:%(class)s_B\n %(class)s_C.getReferencedAttributes: k1 = v1:%(class)s_C, k2 = v2:%(class)s_C\n@@ -358,5 +376,7 @@ def test10_callingOrder(self):\n %(class)s_C.afterRetrieveModifier\n %(class)s_B.afterRetrieveModifier\n %(class)s_A.afterRetrieveModifier\n-<end>"""%{\'class\':\'LoggingModifier\'}\n+<end>""" % {\n+            \'class\': \'LoggingModifier\'\n+        }\n         self.assertEqual(mlog_str, expected_result)\ndiff --git a/Products/CMFEditions/tests/test_ZVCStorageTool.py b/Products/CMFEditions/tests/test_ZVCStorageTool.py\nindex 120ae41..c581eb1 100644\n--- a/Products/CMFEditions/tests/test_ZVCStorageTool.py\n+++ b/Products/CMFEditions/tests/test_ZVCStorageTool.py\n@@ -46,13 +46,11 @@ class DummyOM(ObjectManager):\n \n \n class CMFDummy(Dummy):\n-\n     def __init__(self, id, cmfuid, effective=None, expires=None):\n         super(CMFDummy, self).__init__()\n         self.id = id\n         self.cmf_uid = cmfuid\n-        self.effective = \\\n-            effective if effective is not None else self.modification_date\n+        self.effective = effective if effective is not None else self.modification_date\n         self.expires = expires\n \n     def getPortalTypeName(self):\n@@ -60,13 +58,11 @@ def getPortalTypeName(self):\n \n \n class TestZVCStorageTool(CMFEditionsBaseTestCase):\n-\n     def setUp(self):\n         super(TestZVCStorageTool, self).setUp()\n \n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\',\n-                                                [\'Manager\'], \'\')\n+        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\', [\'Manager\'], \'\')\n \n         # eventually install another storage\n         self.installStorageTool()\n@@ -108,31 +104,41 @@ def test01_saveAfterRegisteringDoesNotRaiseException(self):\n         portal_storage = self.portal.portal_historiesstorage\n         obj = Dummy()\n \n-        sel = portal_storage.register(1, ObjectData(obj),\n-                                      metadata=self.buildMetadata(\'saved\'))\n+        sel = portal_storage.register(\n+            1, ObjectData(obj), metadata=self.buildMetadata(\'saved\')\n+        )\n         self.assertEqual(sel, 0)\n-        sel = portal_storage.save(1, ObjectData(obj),\n-                                  metadata=self.buildMetadata(\'saved\'))\n+        sel = portal_storage.save(\n+            1, ObjectData(obj), metadata=self.buildMetadata(\'saved\')\n+        )\n         self.assertEqual(sel, 1)\n \n     def test02_saveUnregisteredObjectRaisesException(self):\n         portal_storage = self.portal.portal_historiesstorage\n         obj = Dummy()\n \n-        self.assertRaises(StorageUnregisteredError,\n-                          portal_storage.save,\n-                          1, ObjectData(obj), metadata=self.buildMetadata(\'saved\'))\n+        self.assertRaises(\n+            StorageUnregisteredError,\n+            portal_storage.save,\n+            1,\n+            ObjectData(obj),\n+            metadata=self.buildMetadata(\'saved\'),\n+        )\n \n     def test03_saveAndRetrieve(self):\n         portal_storage = self.portal.portal_historiesstorage\n \n         obj1 = Dummy()\n         obj1.text = \'v1 of text\'\n-        portal_storage.register(1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\'))\n+        portal_storage.register(\n+            1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+        )\n \n         obj2 = Dummy()\n         obj2.text = \'v2 of text\'\n-        portal_storage.save(1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\'))\n+        portal_storage.save(\n+            1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\')\n+        )\n \n         # retrieve the state at registration time\n         retrieved_obj = portal_storage.retrieve(history_id=1, selector=0)\n@@ -149,18 +155,21 @@ def test05_getHistory(self):\n \n         obj1 = Dummy()\n         obj1.text = \'v1 of text\'\n-        portal_storage.register(1, ObjectData(obj1),\n-                                metadata=self.buildMetadata(\'saved v1\'))\n+        portal_storage.register(\n+            1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+        )\n \n         obj2 = Dummy()\n         obj2.text = \'v2 of text\'\n-        portal_storage.save(1, ObjectData(obj2),\n-                            metadata=self.buildMetadata(\'saved v2\'))\n+        portal_storage.save(\n+            1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\')\n+        )\n \n         obj3 = Dummy()\n         obj3.text = \'v3 of text\'\n-        portal_storage.save(1, ObjectData(obj3),\n-                            metadata=self.buildMetadata(\'saved v3\'))\n+        portal_storage.save(\n+            1, ObjectData(obj3), metadata=self.buildMetadata(\'saved v3\')\n+        )\n \n         history = portal_storage.getHistory(history_id=1)\n         length = len(history)\n@@ -170,11 +179,11 @@ def test05_getHistory(self):\n \n         # iterating over the history\n         for i, vdata in enumerate(history):\n-            expected_test = \'v%s of text\' % (i+1)\n+            expected_test = \'v%s of text\' % (i + 1)\n             self.assertEquals(vdata.object.object.text, expected_test)\n             self.assertEquals(history[i].object.object.text, expected_test)\n \n-            expected_comment = \'saved v%s\' % (i+1)\n+            expected_comment = \'saved v%s\' % (i + 1)\n             self.assertEqual(self.getComment(vdata), expected_comment)\n             self.assertEqual(self.getComment(history[i]), expected_comment)\n \n@@ -195,7 +204,9 @@ def test06_checkObjectManagerIntegrity(self):\n         om._setObject(\'sub1\', sub1)\n         om._setObject(\'sub2\', sub2)\n         self.assertEqual(len(om.objectIds()), 2)\n-        portal_storage.register(1, ObjectData(om), metadata=self.buildMetadata(\'saved v1\'))\n+        portal_storage.register(\n+            1, ObjectData(om), metadata=self.buildMetadata(\'saved v1\')\n+        )\n         vdata = portal_storage.retrieve(history_id=1, selector=0)\n         retrieved_om = vdata.object\n         self.assertEqual(len(retrieved_om.object.objectIds()), 2)\n@@ -204,42 +215,64 @@ def test07_getModificationDate(self):\n         portal_storage = self.portal.portal_historiesstorage\n         obj = Dummy()\n         v1_modified = obj.modified()\n-        v1 = portal_storage.register(history_id=1, object=ObjectData(obj), metadata=self.buildMetadata(\'saved v1\'))\n+        v1 = portal_storage.register(\n+            history_id=1,\n+            object=ObjectData(obj),\n+            metadata=self.buildMetadata(\'saved v1\'),\n+        )\n \n         self.assertEqual(v1_modified, portal_storage.getModificationDate(history_id=1))\n-        self.assertEqual(v1_modified, portal_storage.getModificationDate(history_id=1, selector=v1))\n+        self.assertEqual(\n+            v1_modified, portal_storage.getModificationDate(history_id=1, selector=v1)\n+        )\n \n-        #storage never gets the same object twice, because the archivist always generates another copy on save,\n-        #which then have a diffrent python id.\n+        # storage never gets the same object twice, because the archivist always generates another copy on save,\n+        # which then have a diffrent python id.\n \n-        #simulate object copy\n+        # simulate object copy\n         notifyModified(obj)\n         obj = Dummy()\n         v2_modified = obj.modified()\n-        v2 = portal_storage.save(history_id=1, object=ObjectData(obj), metadata=self.buildMetadata(\'saved v2\'))\n+        v2 = portal_storage.save(\n+            history_id=1,\n+            object=ObjectData(obj),\n+            metadata=self.buildMetadata(\'saved v2\'),\n+        )\n         self.assertNotEquals(v1, v2)\n         self.assertEqual(v2_modified, portal_storage.getModificationDate(history_id=1))\n-        self.assertEqual(v2_modified, portal_storage.getModificationDate(history_id=1, selector=v2))\n-        self.assertEqual(v1_modified, portal_storage.getModificationDate(history_id=1, selector=v1))\n+        self.assertEqual(\n+            v2_modified, portal_storage.getModificationDate(history_id=1, selector=v2)\n+        )\n+        self.assertEqual(\n+            v1_modified, portal_storage.getModificationDate(history_id=1, selector=v1)\n+        )\n \n     def _setupMinimalHistory(self):\n         portal_storage = self.portal.portal_historiesstorage\n \n         obj1 = Dummy()\n         obj1.text = \'v1 of text\'\n-        portal_storage.register(1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\'))\n+        portal_storage.register(\n+            1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+        )\n \n         obj2 = Dummy()\n         obj2.text = \'v2 of text\'\n-        portal_storage.save(1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\'))\n+        portal_storage.save(\n+            1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\')\n+        )\n \n         obj3 = Dummy()\n         obj3.text = \'v3 of text\'\n-        portal_storage.save(1, ObjectData(obj3), metadata=self.buildMetadata(\'saved v3\'))\n+        portal_storage.save(\n+            1, ObjectData(obj3), metadata=self.buildMetadata(\'saved v3\')\n+        )\n \n         obj4 = Dummy()\n         obj4.text = \'v4 of text\'\n-        portal_storage.save(1, ObjectData(obj4), metadata=self.buildMetadata(\'saved v4\'))\n+        portal_storage.save(\n+            1, ObjectData(obj4), metadata=self.buildMetadata(\'saved v4\')\n+        )\n \n     def test08_lengthAfterHavingPurgedAVersion(self):\n         self._setupMinimalHistory()\n@@ -277,14 +310,16 @@ def test09_retrievePurgedVersionsNoPolicyInstalled(self):\n         self.assertEqual(retrieved_obj.object.reason, "purged")\n         self.assertEqual(self.getComment(retrieved_obj), "purged v3")\n \n-        retrieved_obj = portal_storage.retrieve(history_id=1, selector=2,\n-                                                substitute=False)\n+        retrieved_obj = portal_storage.retrieve(\n+            history_id=1, selector=2, substitute=False\n+        )\n         self.assertFalse(retrieved_obj.isValid())\n         self.assertEqual(retrieved_obj.object.reason, "purged")\n         self.assertEqual(self.getComment(retrieved_obj), "purged v3")\n \n-        retrieved_obj = portal_storage.retrieve(history_id=1, selector=2,\n-                                                countPurged=False)\n+        retrieved_obj = portal_storage.retrieve(\n+            history_id=1, selector=2, countPurged=False\n+        )\n         self.assertTrue(retrieved_obj.isValid())\n         self.assertEqual(retrieved_obj.object.object.text, \'v4 of text\')\n         self.assertEqual(self.getComment(retrieved_obj), \'saved v4\')\n@@ -328,13 +363,15 @@ def test10_retrievePurgedVersionsWithPolicyInstalled(self):\n         self.assertEqual(self.getComment(retrieved_obj), \'saved v4\')\n \n         # check with substitute=False: should return the removed info\n-        retrieved_obj = portal_storage.retrieve(history_id=1, selector=1,\n-                                                substitute=False)\n+        retrieved_obj = portal_storage.retrieve(\n+            history_id=1, selector=1, substitute=False\n+        )\n         self.assertFalse(retrieved_obj.isValid())\n         self.assertEqual(retrieved_obj.object.reason, "purged")\n         self.assertEqual(self.getComment(retrieved_obj), "purged v2")\n-        retrieved_obj = portal_storage.retrieve(history_id=1, selector=2,\n-                                                substitute=False)\n+        retrieved_obj = portal_storage.retrieve(\n+            history_id=1, selector=2, substitute=False\n+        )\n         self.assertFalse(retrieved_obj.isValid())\n         self.assertEqual(retrieved_obj.object.reason, "purged")\n         self.assertEqual(self.getComment(retrieved_obj), "purged v3")\n@@ -349,8 +386,9 @@ def test11_purgeOnSave(self):\n         obj1 = Dummy()\n         obj1.text = \'v1 of text\'\n \n-        sel = portal_storage.register(1, ObjectData(obj1),\n-                                      metadata=self.buildMetadata(\'saved v1\'))\n+        sel = portal_storage.register(\n+            1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+        )\n         history = portal_storage.getHistory(1, countPurged=False)\n \n         self.assertEquals(sel, 0)\n@@ -361,8 +399,9 @@ def test11_purgeOnSave(self):\n         # save no 2\n         obj2 = Dummy()\n         obj2.text = \'v2 of text\'\n-        sel = portal_storage.save(1, ObjectData(obj2),\n-                                  metadata=self.buildMetadata(\'saved v2\'))\n+        sel = portal_storage.save(\n+            1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\')\n+        )\n         history = portal_storage.getHistory(1, countPurged=False)\n \n         self.assertEquals(sel, 1)\n@@ -375,17 +414,16 @@ def test11_purgeOnSave(self):\n         # save no 3: purged oldest version\n         obj3 = Dummy()\n         obj3.text = \'v3 of text\'\n-        sel = portal_storage.save(1, ObjectData(obj3),\n-                                  metadata=self.buildMetadata(\'saved v3\'))\n+        sel = portal_storage.save(\n+            1, ObjectData(obj3), metadata=self.buildMetadata(\'saved v3\')\n+        )\n         history = portal_storage.getHistory(1, countPurged=False)\n         length = len(history)\n \n         # iterating over the history\n         for i, vdata in enumerate(history):\n-            self.assertEquals(vdata.object.object.text,\n-                              \'v%s of text\' % (i+2))\n-            self.assertEqual(self.getComment(vdata),\n-                             \'saved v%s\' % (i+2))\n+            self.assertEquals(vdata.object.object.text, \'v%s of text\' % (i + 2))\n+            self.assertEqual(self.getComment(vdata), \'saved v%s\' % (i + 2))\n \n         self.assertEquals(sel, 2)\n         self.assertEquals(length, 2)\n@@ -397,17 +435,16 @@ def test11_purgeOnSave(self):\n         # save no 4: purged oldest version\n         obj4 = Dummy()\n         obj4.text = \'v4 of text\'\n-        sel = portal_storage.save(1, ObjectData(obj4),\n-                                  metadata=self.buildMetadata(\'saved v4\'))\n+        sel = portal_storage.save(\n+            1, ObjectData(obj4), metadata=self.buildMetadata(\'saved v4\')\n+        )\n         history = portal_storage.getHistory(1, countPurged=False)\n         length = len(history)\n \n         # iterating over the history\n         for i, vdata in enumerate(history):\n-            self.assertEquals(vdata.object.object.text,\n-                              \'v%s of text\' % (i+3))\n-            self.assertEqual(self.getComment(vdata),\n-                             \'saved v%s\' % (i+3))\n+            self.assertEquals(vdata.object.object.text, \'v%s of text\' % (i + 3))\n+            self.assertEqual(self.getComment(vdata), \'saved v%s\' % (i + 3))\n \n         self.assertEquals(sel, 3)\n         self.assertEquals(length, 2)\n@@ -421,32 +458,47 @@ def test12_retrieveNonExistentVersion(self):\n \n         obj1 = Dummy()\n         obj1.text = \'v1 of text\'\n-        portal_storage.register(1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\'))\n+        portal_storage.register(\n+            1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+        )\n \n         obj2 = Dummy()\n         obj2.text = \'v2 of text\'\n-        portal_storage.save(1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\'))\n+        portal_storage.save(\n+            1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\')\n+        )\n \n         # purge\n         portal_storage.purge(1, 0, metadata=self.buildMetadata("purged v1"))\n \n         # retrieve non existing version\n-        self.assertRaises(StorageRetrieveError,\n-                          portal_storage.retrieve, history_id=1, selector=2,\n-                          countPurged=True, substitute=True)\n-\n-        self.assertRaises(StorageRetrieveError,\n-                          portal_storage.retrieve, history_id=1, selector=1,\n-                          countPurged=False)\n+        self.assertRaises(\n+            StorageRetrieveError,\n+            portal_storage.retrieve,\n+            history_id=1,\n+            selector=2,\n+            countPurged=True,\n+            substitute=True,\n+        )\n+\n+        self.assertRaises(\n+            StorageRetrieveError,\n+            portal_storage.retrieve,\n+            history_id=1,\n+            selector=1,\n+            countPurged=False,\n+        )\n \n     def test13_saveWithUnicodeComment(self):\n         portal_storage = self.portal.portal_historiesstorage\n         obj1 = Dummy()\n         obj1.text = \'v1 of text\'\n-        portal_storage.register(1, ObjectData(obj1),\n-                                metadata=self.buildMetadata(\'saved v1\'))\n-        portal_storage.save(1, ObjectData(obj1),\n-                            metadata=self.buildMetadata(u\'saved v1\\xc3\\xa1\'))\n+        portal_storage.register(\n+            1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+        )\n+        portal_storage.save(\n+            1, ObjectData(obj1), metadata=self.buildMetadata(u\'saved v1\\xc3\\xa1\')\n+        )\n \n     def test14_getHistoryMetadata(self):\n         portal_storage = self.portal.portal_historiesstorage\n@@ -455,10 +507,18 @@ def test14_getHistoryMetadata(self):\n         self.assertEqual(len(history), 4)\n \n         # accessing the versions\n-        self.assertEqual(history.retrieve(0)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v1")\n-        self.assertEqual(history.retrieve(1)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v2")\n-        self.assertEqual(history.retrieve(2)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v3")\n-        self.assertEqual(history.retrieve(3)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v4")\n+        self.assertEqual(\n+            history.retrieve(0)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v1"\n+        )\n+        self.assertEqual(\n+            history.retrieve(1)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v2"\n+        )\n+        self.assertEqual(\n+            history.retrieve(2)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v3"\n+        )\n+        self.assertEqual(\n+            history.retrieve(3)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v4"\n+        )\n \n     def test15_storageStatistics(self):\n         self.maxDiff = None\n@@ -467,21 +527,29 @@ def test15_storageStatistics(self):\n         cmf_uid = 1\n         obj1 = CMFDummy(\'obj\', cmf_uid)\n         obj1.text = \'v1 of text\'\n-        portal_storage.register(cmf_uid, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\'))\n+        portal_storage.register(\n+            cmf_uid, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+        )\n \n         obj2 = CMFDummy(\'obj\', cmf_uid)\n         obj2.text = \'v2 of text\'\n-        portal_storage.save(cmf_uid, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\'))\n+        portal_storage.save(\n+            cmf_uid, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\')\n+        )\n \n         obj3 = CMFDummy(\'obj\', cmf_uid)\n         obj3.text = \'v3 of text\'\n-        portal_storage.save(cmf_uid, ObjectData(obj3), metadata=self.buildMetadata(\'saved v3\'))\n+        portal_storage.save(\n+            cmf_uid, ObjectData(obj3), metadata=self.buildMetadata(\'saved v3\')\n+        )\n \n         obj4 = CMFDummy(\'obj\', cmf_uid)\n         obj4.text = \'v4 of text\'\n         self.portal._setObject(\'obj\', obj4)\n         self.portal.portal_catalog.indexObject(self.portal.obj)\n-        portal_storage.save(cmf_uid, ObjectData(obj4), metadata=self.buildMetadata(\'saved v4\'))\n+        portal_storage.save(\n+            cmf_uid, ObjectData(obj4), metadata=self.buildMetadata(\'saved v4\')\n+        )\n \n         cmf_uid = 2\n         tomorrow = DateTime() + 1\n@@ -489,7 +557,9 @@ def test15_storageStatistics(self):\n         obj5.allowedRolesAndUsers = [\'Anonymous\']\n         self.portal._setObject(\'tomorrow\', obj5)\n         self.portal.portal_catalog.indexObject(self.portal.tomorrow)\n-        portal_storage.register(cmf_uid, ObjectData(obj5), metadata=self.buildMetadata(\'effective tomorrow\'))\n+        portal_storage.register(\n+            cmf_uid, ObjectData(obj5), metadata=self.buildMetadata(\'effective tomorrow\')\n+        )\n \n         cmf_uid = 3\n         yesterday = DateTime() - 1\n@@ -497,7 +567,9 @@ def test15_storageStatistics(self):\n         obj6.allowedRolesAndUsers = [\'Anonymous\']\n         self.portal._setObject(\'yesterday\', obj6)\n         self.portal.portal_catalog.indexObject(self.portal.yesterday)\n-        portal_storage.register(cmf_uid, ObjectData(obj6), metadata=self.buildMetadata(\'expired yesterday\'))\n+        portal_storage.register(\n+            cmf_uid, ObjectData(obj6), metadata=self.buildMetadata(\'expired yesterday\')\n+        )\n \n         cmf_uid = 4\n         obj7 = CMFDummy(\'public\', cmf_uid)\n@@ -505,53 +577,62 @@ def test15_storageStatistics(self):\n         obj7.allowedRolesAndUsers = [\'Anonymous\']\n         self.portal._setObject(\'public\', obj7)\n         self.portal.portal_catalog.indexObject(self.portal.public)\n-        portal_storage.register(cmf_uid, ObjectData(obj7), metadata=self.buildMetadata(\'saved public\'))\n+        portal_storage.register(\n+            cmf_uid, ObjectData(obj7), metadata=self.buildMetadata(\'saved public\')\n+        )\n \n         processQueue()\n         got = portal_storage.zmi_getStorageStatistics()\n-        expected = {\'deleted\': [],\n-                    \'summaries\': {\n-                        \'totalHistories\': 4,\n-                        \'deletedVersions\': 0,\n-                        \'existingVersions\': 7,\n-                        \'deletedHistories\': 0,\n-                        # time may easily be different\n-                        # \'time\': \'0.00\',\n-                        \'totalVersions\': 7,\n-                        \'existingAverage\': \'1.8\',\n-                        \'existingHistories\': 4,\n-                        \'deletedAverage\': \'n/a\',\n-                        \'totalAverage\': \'1.8\'},\n-                    \'existing\': [\n-                        {\n-                            \'url\': \'http://nohost/plone/obj\',\n-                            \'history_id\': 1,\n-                            \'length\': 4,\n-                            \'path\': \'/obj\',\n-                            \'sizeState\': \'approximate\',\n-                            \'portal_type\': \'Dummy\',\n-                        }, {\n-                            \'url\': \'http://nohost/plone/tomorrow\',\n-                            \'history_id\': 2,\n-                            \'length\': 1,\n-                            \'path\': \'/tomorrow\',\n-                            \'sizeState\': \'approximate\',\n-                            \'portal_type\': \'Dummy\',\n-                        }, {\n-                            \'url\': \'http://nohost/plone/yesterday\',\n-                            \'history_id\': 3,\n-                            \'length\': 1,\n-                            \'path\': \'/yesterday\',\n-                            \'sizeState\': \'approximate\',\n-                            \'portal_type\': \'Dummy\',\n-                        }, {\n-                            \'url\': \'http://nohost/plone/public\',\n-                            \'history_id\': 4,\n-                            \'length\': 1,\n-                            \'path\': \'/public\',\n-                            \'sizeState\': \'approximate\',\n-                            \'portal_type\': \'Dummy\',\n-                        }]}\n+        expected = {\n+            \'deleted\': [],\n+            \'summaries\': {\n+                \'totalHistories\': 4,\n+                \'deletedVersions\': 0,\n+                \'existingVersions\': 7,\n+                \'deletedHistories\': 0,\n+                # time may easily be different\n+                # \'time\': \'0.00\',\n+                \'totalVersions\': 7,\n+                \'existingAverage\': \'1.8\',\n+                \'existingHistories\': 4,\n+                \'deletedAverage\': \'n/a\',\n+                \'totalAverage\': \'1.8\',\n+            },\n+            \'existing\': [\n+                {\n+                    \'url\': \'http://nohost/plone/obj\',\n+                    \'history_id\': 1,\n+                    \'length\': 4,\n+                    \'path\': \'/obj\',\n+                    \'sizeState\': \'approximate\',\n+                    \'portal_type\': \'Dummy\',\n+                },\n+                {\n+                    \'url\': \'http://nohost/plone/tomorrow\',\n+                    \'history_id\': 2,\n+                    \'length\': 1,\n+                    \'path\': \'/tomorrow\',\n+                    \'sizeState\': \'approximate\',\n+                    \'portal_type\': \'Dummy\',\n+                },\n+                {\n+                    \'url\': \'http://nohost/plone/yesterday\',\n+                    \'history_id\': 3,\n+                    \'length\': 1,\n+                    \'path\': \'/yesterday\',\n+                    \'sizeState\': \'approximate\',\n+                    \'portal_type\': \'Dummy\',\n+                },\n+                {\n+                    \'url\': \'http://nohost/plone/public\',\n+                    \'history_id\': 4,\n+                    \'length\': 1,\n+                    \'path\': \'/public\',\n+                    \'sizeState\': \'approximate\',\n+                    \'portal_type\': \'Dummy\',\n+                },\n+            ],\n+        }\n         self.assertEqual(expected[\'deleted\'], got[\'deleted\'])\n         self.assertTrue(\'summaries\' in got)\n         self.assertTrue(\'time\' in got[\'summaries\'])\n@@ -568,7 +649,7 @@ def test15_storageStatistics(self):\n             self.assertTrue(actual[\'size\'] > 0)\n \n     def test16_delete_history_on_content_deletion(self):\n-        """ If a content item gets deleted, delete it\'s history\n+        """If a content item gets deleted, delete it\'s history\n         as well\n         """\n         portal_hidhandler = self.portal.portal_historyidhandler\n@@ -581,22 +662,25 @@ def test16_delete_history_on_content_deletion(self):\n         doc = self.portal.doc\n         doc_histid = portal_hidhandler.register(doc)\n         portal_storage.register(\n-            doc_histid, ObjectData(aq_base(doc)),\n-            metadata=self.buildMetadata(\'initial\'))\n+            doc_histid, ObjectData(aq_base(doc)), metadata=self.buildMetadata(\'initial\')\n+        )\n         portal_storage.save(\n-            doc_histid,\n-            ObjectData(aq_base(doc)),\n-            metadata=self.buildMetadata(\'v2\'))\n+            doc_histid, ObjectData(aq_base(doc)), metadata=self.buildMetadata(\'v2\')\n+        )\n         link = self.portal.link\n         link_histid = portal_hidhandler.register(link)\n         portal_storage.register(\n-            link_histid, ObjectData(aq_base(link)),\n-            metadata=self.buildMetadata(\'initial\'))\n+            link_histid,\n+            ObjectData(aq_base(link)),\n+            metadata=self.buildMetadata(\'initial\'),\n+        )\n         folder = self.portal.folder\n         folder_histid = portal_hidhandler.register(folder)\n         portal_storage.register(\n-            folder_histid, ObjectData(aq_base(folder)),\n-            metadata=self.buildMetadata(\'first draft\'))\n+            folder_histid,\n+            ObjectData(aq_base(folder)),\n+            metadata=self.buildMetadata(\'first draft\'),\n+        )\n         dochist = portal_storage.retrieve(doc_histid).object\n         doctype = dochist.object.portal_type\n         self.assertEqual(\'Document\', doctype)\n@@ -606,8 +690,7 @@ def test16_delete_history_on_content_deletion(self):\n         folderhist = portal_storage.retrieve(folder_histid).object\n         foldertype = folderhist.object.portal_type\n         self.assertEqual(\'Folder\', foldertype)\n-        self.portal.manage_delObjects(\n-            ids=[\'doc\', \'link\', \'folder\', \'unversioned_doc\'])\n+        self.portal.manage_delObjects(ids=[\'doc\', \'link\', \'folder\', \'unversioned_doc\'])\n         removed_doc = portal_storage.retrieve(history_id=doc_histid)\n         self.assertTrue(type(removed_doc.object) == Removed)\n         removed_link = portal_storage.retrieve(history_id=link_histid)\n@@ -617,18 +700,15 @@ def test16_delete_history_on_content_deletion(self):\n \n \n class TestMemoryStorage(TestZVCStorageTool):\n-\n     def installStorageTool(self):\n         # install the memory storage\n         tool = MemoryStorage()\n         setattr(self.portal, tool.getId(), tool)\n \n     def test15_storageStatistics(self):\n-        """ MemoryStorage does not implement zmi_getStorageStatistics\n-        """\n+        """MemoryStorage does not implement zmi_getStorageStatistics"""\n         pass\n \n     def test16_delete_history_on_content_deletion(self):\n-        """ MemoryStorage does not implement _getZVCRepo\n-        """\n+        """MemoryStorage does not implement _getZVCRepo"""\n         pass\ndiff --git a/Products/CMFEditions/tests/test_doctests.py b/Products/CMFEditions/tests/test_doctests.py\nindex 2f361fb..a06b1b8 100644\n--- a/Products/CMFEditions/tests/test_doctests.py\n+++ b/Products/CMFEditions/tests/test_doctests.py\n@@ -6,6 +6,7 @@\n # These two classes are needed in the doctest. Don\'t remove it\n class DummyFile(object):\n     """A sized object"""\n+\n     def __init__(self, size):\n         self.size = size\n \ndiff --git a/Products/CMFEditions/tests/test_versions_history_form.py b/Products/CMFEditions/tests/test_versions_history_form.py\nindex eda9a6a..495c72f 100644\n--- a/Products/CMFEditions/tests/test_versions_history_form.py\n+++ b/Products/CMFEditions/tests/test_versions_history_form.py\n@@ -35,7 +35,6 @@\n \n \n class TestVersionsHistoryForm(CMFEditionsBaseTestCase):\n-\n     def setUp(self):\n         super(TestVersionsHistoryForm, self).setUp()\n         self.portal_repository = self.portal.portal_repository\n@@ -46,10 +45,7 @@ def setUp(self):\n             text=RichTextValue(_TEXT_INITIAL, \'text/plain\', \'text/plain\'),\n         )\n         self.doc = self.portal.doc\n-        self.portal_repository.applyVersionControl(\n-            self.doc,\n-            comment=\'save version 0\'\n-        )\n+        self.portal_repository.applyVersionControl(self.doc, comment=\'save version 0\')\n         self.request = self.portal.REQUEST\n \n     def test_versions_history_form(self):\ndiff --git a/Products/CMFEditions/utilities.py b/Products/CMFEditions/utilities.py\nindex dfb1f98..47e43df 100644\n--- a/Products/CMFEditions/utilities.py\n+++ b/Products/CMFEditions/utilities.py\n@@ -32,9 +32,9 @@\n \n STUB_OBJECT_PREFIX = \'_CMFEditionsTempId\'\n \n+\n class KwAsAttributes(Persistent):\n-    """Class attaching to itself passed keyword attributes.\n-    """\n+    """Class attaching to itself passed keyword attributes."""\n \n     # Not web accessable\n     __roles__ = ()\n@@ -81,20 +81,20 @@ def dereference(obj=None, history_id=None, zodb_hook=None):\n \n \n def generateId(parent, prefix=\'\', volatile=False):\n-    """Generate an unused id (optionaly a volatile one).\n-    """\n+    """Generate an unused id (optionaly a volatile one)."""\n     existingIds = parent.objectIds()\n     idTemplate = \'%s%s_%%s\' % (volatile * \'__v_\', prefix + STUB_OBJECT_PREFIX)\n     while 1:\n-        id =  idTemplate % random.randrange(1000000)\n+        id = idTemplate % random.randrange(1000000)\n         if id not in existingIds:\n             return id\n \n+\n def isObjectVersioned(obj):\n-    """Return true iff object has a version_id.\n-    """\n+    """Return true iff object has a version_id."""\n     return getattr(aq_base(obj), \'version_id\', None) is not None\n \n+\n def isObjectChanged(obj):\n     pr = getToolByName(obj, \'portal_repository\', None)\n     if pr is None:\ndiff --git a/Products/__init__.py b/Products/__init__.py\nindex 85880ef..eda5e9f 100644\n--- a/Products/__init__.py\n+++ b/Products/__init__.py\n@@ -4,4 +4,5 @@\n     __import__(\'pkg_resources\').declare_namespace(__name__)\n except ImportError:\n     from pkgutil import extend_path\n+\n     __path__ = extend_path(__path__, __name__)\n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-16T23:36:48+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/12be9cafc26e2c0b7a5d4657d2e9aff574b4b0f2

black

Files changed:
M Products/CMFEditions/ArchivistTool.py
M Products/CMFEditions/KeepLastNVersionsTool.py
M Products/CMFEditions/ModifierRegistryTool.py
M Products/CMFEditions/Modifiers.py
M Products/CMFEditions/Permissions.py
M Products/CMFEditions/ReferenceFactoriesTool.py
M Products/CMFEditions/StandardModifiers.py
M Products/CMFEditions/StorageMigrationSupport.py
M Products/CMFEditions/UniqueIdHandlerTool.py
M Products/CMFEditions/VersionPolicies.py
M Products/CMFEditions/ZVCStorageTool.py
M Products/CMFEditions/__init__.py
M Products/CMFEditions/browser/diff.py
M Products/CMFEditions/browser/utils.py
M Products/CMFEditions/browser/views.py
M Products/CMFEditions/exportimport/repository.py
M Products/CMFEditions/historyidhandlertool.py
M Products/CMFEditions/interfaces/IModifier.py
M Products/CMFEditions/interfaces/IRepository.py
M Products/CMFEditions/interfaces/__init__.py
M Products/CMFEditions/setuphandlers.py
M Products/CMFEditions/subscriber.py
M Products/CMFEditions/testing.py
M Products/CMFEditions/tests/DummyTools.py
M Products/CMFEditions/tests/base.py
M Products/CMFEditions/tests/test_ArchivistTool.py
M Products/CMFEditions/tests/test_ContentTypes.py
M Products/CMFEditions/tests/test_IntegrationTests.py
M Products/CMFEditions/tests/test_KeepLastNVersionsTool.py
M Products/CMFEditions/tests/test_ModifierRegistryTool.py
M Products/CMFEditions/tests/test_ZVCStorageTool.py
M Products/CMFEditions/tests/test_doctests.py
M Products/CMFEditions/tests/test_versions_history_form.py
M Products/CMFEditions/utilities.py
M Products/__init__.py
M setup.py

b'diff --git a/Products/CMFEditions/ArchivistTool.py b/Products/CMFEditions/ArchivistTool.py\nindex 3e9f0a0..ab73573 100644\n--- a/Products/CMFEditions/ArchivistTool.py\n+++ b/Products/CMFEditions/ArchivistTool.py\n@@ -92,8 +92,8 @@ def __init__(\n         self.refs_to_be_deleted = refs_to_be_deleted\n         self.attr_handling_references = attr_handling_references\n         self.preserved_data = preserved_data\n-        self.sys_metadata = metadata[\'sys_metadata\']\n-        self.app_metadata = metadata[\'app_metadata\']\n+        self.sys_metadata = metadata["sys_metadata"]\n+        self.app_metadata = metadata["app_metadata"]\n \n \n @implementer(IAttributeAdapter)\n@@ -155,7 +155,7 @@ def __init__(self, **info):\n \n     def setReference(self, target_obj, remove_info=True):\n         """See IVersionAwareReference"""\n-        storage = getToolByName(target_obj, \'portal_historiesstorage\')\n+        storage = getToolByName(target_obj, "portal_historiesstorage")\n \n         # save as much information as possible\n         # it may be that the target object is not yet registered with the\n@@ -170,7 +170,7 @@ def setReference(self, target_obj, remove_info=True):\n             # the exact state of the referenced object may be retrieved also.\n             # XXX we really need a isUpToDate/isChanged methods!\n \n-        if remove_info and hasattr(self, \'info\'):\n+        if remove_info and hasattr(self, "info"):\n             del self.info\n \n     def __of__(self, obj):\n@@ -182,10 +182,10 @@ def __of__(self, obj):\n class ArchivistTool(UniqueObject, SimpleItem):\n     """ """\n \n-    id = \'portal_archivist\'\n-    alternative_id = \'portal_standard_archivist\'\n+    id = "portal_archivist"\n+    alternative_id = "portal_standard_archivist"\n \n-    meta_type = \'CMFEditions Portal Archivist Tool\'\n+    meta_type = "CMFEditions Portal Archivist Tool"\n \n     # make interfaces, exceptions and classes available through the tool\n     interfaces = KwAsAttributes(\n@@ -210,7 +210,7 @@ class ArchivistTool(UniqueObject, SimpleItem):\n     # -------------------------------------------------------------------\n     def _cloneByPickle(self, obj):\n         """Returns a deep copy of a ZODB object, loading ghosts as needed."""\n-        modifier = getToolByName(self, \'portal_modifier\')\n+        modifier = getToolByName(self, "portal_modifier")\n         callbacks = modifier.getOnCloneModifiers(obj)\n         if callbacks is not None:\n             pers_id, pers_load, inside_orefs, outside_orefs = callbacks[0:4]\n@@ -233,12 +233,12 @@ def _cloneByPickle(self, obj):\n     # methods implementing IArchivist\n     # -------------------------------------------------------------------\n \n-    security.declarePrivate(\'prepare\')\n+    security.declarePrivate("prepare")\n \n     def prepare(self, obj, app_metadata=None, sys_metadata={}):\n         """See IArchivist."""\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n-        modifier = getToolByName(self, \'portal_modifier\')\n+        storage = getToolByName(self, "portal_historiesstorage")\n+        modifier = getToolByName(self, "portal_modifier")\n \n         obj, history_id = dereference(obj, zodb_hook=self)\n         if storage.isRegistered(history_id):\n@@ -252,7 +252,7 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n             # (the current implementation isn\'t able yet to handle multiple\n             # locations. Nevertheless lets set the location id to a well\n             # known default value)\n-            uidhandler = getToolByName(self, \'portal_historyidhandler\')\n+            uidhandler = getToolByName(self, "portal_historyidhandler")\n             history_id = uidhandler.register(obj)\n             version_id = obj.version_id = 0\n             alsoProvides(obj, IVersioned)\n@@ -291,13 +291,13 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n             approxSize,\n         )\n \n-    security.declarePrivate(\'register\')\n+    security.declarePrivate("register")\n \n     def register(self, prepared_obj):\n         """See IArchivist."""\n         # only register at the storage layer if not yet registered\n         if not prepared_obj.is_registered:\n-            storage = getToolByName(self, \'portal_historiesstorage\')\n+            storage = getToolByName(self, "portal_historiesstorage")\n             return storage.register(\n                 prepared_obj.history_id,\n                 prepared_obj.clone,\n@@ -305,7 +305,7 @@ def register(self, prepared_obj):\n                 prepared_obj.metadata,\n             )\n \n-    security.declarePrivate(\'save\')\n+    security.declarePrivate("save")\n \n     def save(self, prepared_obj, autoregister=None):\n         """See IArchivist."""\n@@ -317,7 +317,7 @@ def save(self, prepared_obj, autoregister=None):\n                 "the object \'%r\' first. " % prepared_obj.original.object\n             )\n \n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+        storage = getToolByName(self, "portal_historiesstorage")\n         return storage.save(\n             prepared_obj.history_id,\n             prepared_obj.clone,\n@@ -329,17 +329,17 @@ def save(self, prepared_obj, autoregister=None):\n     # methods implementing IPurgeSupport\n     # -------------------------------------------------------------------\n \n-    security.declarePrivate(\'purge\')\n+    security.declarePrivate("purge")\n \n     def purge(\n         self, obj=None, history_id=None, selector=None, metadata={}, countPurged=True\n     ):\n         """See IPurgeSupport."""\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+        storage = getToolByName(self, "portal_historiesstorage")\n         obj, history_id = dereference(obj, history_id, self)\n         storage.purge(history_id, selector, metadata, countPurged)\n \n-    security.declarePrivate(\'retrieve\')\n+    security.declarePrivate("retrieve")\n \n     def retrieve(\n         self, obj=None, history_id=None, selector=None, preserve=(), countPurged=True\n@@ -358,7 +358,7 @@ def retrieve(\n                 % (obj, selector)\n             )\n \n-    security.declarePrivate(\'getHistory\')\n+    security.declarePrivate("getHistory")\n \n     def getHistory(self, obj=None, history_id=None, preserve=(), countPurged=True):\n         """See IPurgeSupport."""\n@@ -370,7 +370,7 @@ def getHistory(self, obj=None, history_id=None, preserve=(), countPurged=True):\n                 "possible. Register the object \'%r\' first. " % obj\n             )\n \n-    security.declarePrivate(\'getHistoryMetadata\')\n+    security.declarePrivate("getHistoryMetadata")\n \n     def getHistoryMetadata(self, obj=None, history_id=None):\n         """Return the metadata blob for presenting summary\n@@ -379,7 +379,7 @@ def getHistoryMetadata(self, obj=None, history_id=None):\n         found by obj. If neither, return None.\n         """\n         obj, history_id = dereference(obj, history_id, self)\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+        storage = getToolByName(self, "portal_historiesstorage")\n         try:\n             return storage.getHistoryMetadata(history_id)\n         except StorageUnregisteredError:\n@@ -388,7 +388,7 @@ def getHistoryMetadata(self, obj=None, history_id=None):\n                 "possible. Register the object \'%r\' first. " % obj\n             )\n \n-    security.declarePrivate(\'queryHistory\')\n+    security.declarePrivate("queryHistory")\n \n     def queryHistory(\n         self, obj=None, history_id=None, preserve=(), default=None, countPurged=True\n@@ -401,11 +401,11 @@ def queryHistory(\n         except StorageUnregisteredError:\n             return default\n \n-    security.declarePrivate(\'isUpToDate\')\n+    security.declarePrivate("isUpToDate")\n \n     def isUpToDate(self, obj=None, history_id=None, selector=None, countPurged=True):\n         """See IPurgeSupport."""\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+        storage = getToolByName(self, "portal_historiesstorage")\n         obj, history_id = dereference(obj, history_id, self)\n         if not storage.isRegistered(history_id):\n             raise ArchivistUnregisteredError("The object %r is not registered" % obj)\n@@ -451,24 +451,24 @@ def __init__(\n         # register with sys_metadata as there is no other possibility\n         obj = original.object\n         parent = aq_parent(aq_inner(obj))\n-        portal_uidhandler = getToolByName(obj, \'portal_historyidhandler\')\n+        portal_uidhandler = getToolByName(obj, "portal_historyidhandler")\n \n         # set defaults if missing\n-        sys_metadata[\'comment\'] = sys_metadata.get(\'comment\', \'\')\n-        sys_metadata[\'timestamp\'] = sys_metadata.get(\'timestamp\', int(time.time()))\n-        sys_metadata[\'originator\'] = sys_metadata.get(\'originator\', None)\n-        sys_metadata[\'principal\'] = getUserId()\n-        sys_metadata[\'approxSize\'] = approxSize\n-        sys_metadata[\'parent\'] = {\n-            \'history_id\': portal_uidhandler.register(parent),\n-            \'version_id\': getattr(parent, "version_id", None),\n-            \'location_id\': getattr(parent, "location_id", None),\n+        sys_metadata["comment"] = sys_metadata.get("comment", "")\n+        sys_metadata["timestamp"] = sys_metadata.get("timestamp", int(time.time()))\n+        sys_metadata["originator"] = sys_metadata.get("originator", None)\n+        sys_metadata["principal"] = getUserId()\n+        sys_metadata["approxSize"] = approxSize\n+        sys_metadata["parent"] = {\n+            "history_id": portal_uidhandler.register(parent),\n+            "version_id": getattr(parent, "version_id", None),\n+            "location_id": getattr(parent, "location_id", None),\n         }\n \n         # bundle application and system metadata in different namespaces\n         metadata = {\n-            \'sys_metadata\': sys_metadata,\n-            \'app_metadata\': app_metadata,\n+            "sys_metadata": sys_metadata,\n+            "app_metadata": app_metadata,\n         }\n \n         self.history_id = history_id\n@@ -495,8 +495,8 @@ def __init__(self, archivist, obj, history_id, preserve, countPurged):\n         the obj. If the obj is omitted, then the obj will be obtained by\n         dereferencing the history_id.\n         """\n-        self._modifier = getToolByName(archivist, \'portal_modifier\')\n-        storage = getToolByName(archivist, \'portal_historiesstorage\')\n+        self._modifier = getToolByName(archivist, "portal_modifier")\n+        storage = getToolByName(archivist, "portal_historiesstorage")\n         self._obj, history_id = dereference(obj, history_id, archivist)\n         self._preserve = preserve\n         self._history = storage.getHistory(history_id, countPurged)\n@@ -563,5 +563,5 @@ def __next__(self):\n \n \n def object_copied(obj, event):\n-    if getattr(aq_base(obj), \'version_id\', None) is not None:\n-        delattr(obj, \'version_id\')\n+    if getattr(aq_base(obj), "version_id", None) is not None:\n+        delattr(obj, "version_id")\ndiff --git a/Products/CMFEditions/KeepLastNVersionsTool.py b/Products/CMFEditions/KeepLastNVersionsTool.py\nindex 0787ba1..a0340f7 100644\n--- a/Products/CMFEditions/KeepLastNVersionsTool.py\n+++ b/Products/CMFEditions/KeepLastNVersionsTool.py\n@@ -38,8 +38,8 @@\n class KeepLastNVersionsTool(UniqueObject, SimpleItem, PropertyManager):\n     """ """\n \n-    id = \'portal_purgepolicy\'\n-    alternative_id = \'portal_keeplastnversions\'\n+    id = "portal_purgepolicy"\n+    alternative_id = "portal_keeplastnversions"\n \n     meta_type = "CMFEditions Purge Policy Keeping Only the n last Versions"\n \n@@ -49,10 +49,10 @@ class KeepLastNVersionsTool(UniqueObject, SimpleItem, PropertyManager):\n \n     _properties = (\n         {\n-            \'id\': \'maxNumberOfVersionsToKeep\',\n-            \'type\': \'int\',\n-            \'mode\': \'w\',\n-            \'label\': "maximum number of versions to keep in the storage (set to -1 for infinite)",\n+            "id": "maxNumberOfVersionsToKeep",\n+            "type": "int",\n+            "mode": "w",\n+            "label": "maximum number of versions to keep in the storage (set to -1 for infinite)",\n         },\n     )\n     security = ClassSecurityInfo()\n@@ -72,7 +72,7 @@ def beforeSaveHook(self, history_id, obj, metadata={}):\n             # infinite: do nothing\n             return True\n \n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+        storage = getToolByName(self, "portal_historiesstorage")\n         currentVersion = len(storage.getHistory(history_id))\n         while True:\n             length = len(storage.getHistory(history_id, countPurged=False))\n@@ -82,7 +82,7 @@ def beforeSaveHook(self, history_id, obj, metadata={}):\n             storage.purge(\n                 history_id,\n                 0,\n-                metadata={\'sys_metadata\': {\'comment\': comment}},\n+                metadata={"sys_metadata": {"comment": comment}},\n                 countPurged=False,\n             )\n \n@@ -98,7 +98,7 @@ def retrieveSubstitute(self, history_id, selector, default=None):\n             selector = 0\n         else:\n             selector = int(selector)\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+        storage = getToolByName(self, "portal_historiesstorage")\n         savedSelector = selector\n         while selector:\n             selector -= 1\ndiff --git a/Products/CMFEditions/ModifierRegistryTool.py b/Products/CMFEditions/ModifierRegistryTool.py\nindex 19dff6e..8a35779 100644\n--- a/Products/CMFEditions/ModifierRegistryTool.py\n+++ b/Products/CMFEditions/ModifierRegistryTool.py\n@@ -58,10 +58,10 @@\n class ModifierRegistryTool(UniqueObject, OrderedFolder):\n     __doc__ = __doc__  # copy from module\n \n-    id = \'portal_modifier\'\n-    alternative_id = \'portal_modifierregistry\'\n+    id = "portal_modifier"\n+    alternative_id = "portal_modifierregistry"\n \n-    meta_type = \'Version Data Modifier Registry\'\n+    meta_type = "Version Data Modifier Registry"\n \n     # make interfaces, exceptions and classes available through the tool\n     interfaces = KwAsAttributes(\n@@ -103,7 +103,7 @@ def _setObject(self, id, object, roles=None, user=None, set_owner=1):\n     def _collectModifiers(self, obj, interface, reversed=False):\n         """Returns a list of valid modifiers"""\n         modifier_list = []\n-        portal = getToolByName(self, \'portal_url\').getPortalObject()\n+        portal = getToolByName(self, "portal_url").getPortalObject()\n         for id, o in self.objectItems():\n             # collect objects modifier only when appropriate\n             if IConditionalModifier.providedBy(o) and o.isApplicable(obj, portal):\n@@ -123,7 +123,7 @@ def _collectModifiers(self, obj, interface, reversed=False):\n     #    an IModifier.\n     # -------------------------------------------------------------------\n \n-    security.declarePrivate(\'getReferencedAttributes\')\n+    security.declarePrivate("getReferencedAttributes")\n \n     def getReferencedAttributes(self, obj):\n         """See IModifier"""\n@@ -131,7 +131,7 @@ def getReferencedAttributes(self, obj):\n         referenced_data = {}\n         for id, mod in self._collectModifiers(obj, IAttributeModifier):\n             # prepend the modifiers id to the attributes name\n-            template = \'%s/%%s\' % id\n+            template = "%s/%%s" % id\n             for name, attrs in mod.getReferencedAttributes(obj).items():\n                 referenced_data[template % name] = attrs\n \n@@ -139,7 +139,7 @@ def getReferencedAttributes(self, obj):\n         #     {\'<modifier_id>/<name>\': <refrenced_data>, ...}\n         return referenced_data\n \n-    security.declarePrivate(\'reattachReferencedAttributes\')\n+    security.declarePrivate("reattachReferencedAttributes")\n \n     def reattachReferencedAttributes(self, obj, referenced_data):\n         """ """\n@@ -150,7 +150,7 @@ def reattachReferencedAttributes(self, obj, referenced_data):\n         data_by_modid = {}\n \n         for id_name, data in referenced_data.items():\n-            id, name = id_name.split(\'/\', 1)\n+            id, name = id_name.split("/", 1)\n             if not id in data_by_modid:\n                 data_by_modid[id] = {}\n             data_by_modid[id][name] = data\n@@ -163,7 +163,7 @@ def reattachReferencedAttributes(self, obj, referenced_data):\n                 if id in data_by_modid:\n                     mod.reattachReferencedAttributes(obj, data_by_modid[id])\n \n-    security.declarePrivate(\'getOnCloneModifiers\')\n+    security.declarePrivate("getOnCloneModifiers")\n \n     def getOnCloneModifiers(self, obj):\n         """See IModifier"""\n@@ -200,12 +200,12 @@ def persistent_id(obj):\n \n         def persistent_load(named_pid):\n             # call the right modifiers persistent_load callback\n-            name, pid = named_pid.split(\'/\', 1)\n+            name, pid = named_pid.split("/", 1)\n             return pers_load_byname[name](pid)\n \n-        return persistent_id, persistent_load, inside_orefs, outside_orefs, \'\'\n+        return persistent_id, persistent_load, inside_orefs, outside_orefs, ""\n \n-    security.declarePrivate(\'beforeSaveModifier\')\n+    security.declarePrivate("beforeSaveModifier")\n \n     def beforeSaveModifier(self, obj, obj_clone):\n         """See IModifier"""\n@@ -222,7 +222,7 @@ def beforeSaveModifier(self, obj, obj_clone):\n \n         return metadata, inside_crefs, outside_crefs\n \n-    security.declarePrivate(\'afterRetrieveModifier\')\n+    security.declarePrivate("afterRetrieveModifier")\n \n     def afterRetrieveModifier(self, obj, repo_clone, preserve=None):\n         """See IModifier"""\n@@ -259,7 +259,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=None):\n     #    The ModifierRegistryTool is also a registry of IModifier objects.\n     # -------------------------------------------------------------------\n \n-    security.declareProtected(ManagePortal, \'register\')\n+    security.declareProtected(ManagePortal, "register")\n \n     def register(self, id, modifier, pos=-1):\n         """See IModifierRegistrySet"""\n@@ -273,13 +273,13 @@ def register(self, id, modifier, pos=-1):\n             pos += max(0, len(self.objectIds()) + 1)\n         self.moveObjectToPosition(id, pos)\n \n-    security.declareProtected(ManagePortal, \'unregister\')\n+    security.declareProtected(ManagePortal, "unregister")\n \n     def unregister(self, id):\n         """See IModifierRegistrySet"""\n         self.manage_delObjects(ids=[id])\n \n-    security.declareProtected(ManagePortal, \'edit\')\n+    security.declareProtected(ManagePortal, "edit")\n \n     def edit(self, id, enabled=None, condition=None):\n         """See IModifierRegistrySet"""\n@@ -289,11 +289,11 @@ def edit(self, id, enabled=None, condition=None):\n         else:\n             if condition:\n                 raise NotImplementedError(\n-                    \'%s does not implement conditions.\' % modifier\n+                    "%s does not implement conditions." % modifier\n                 )\n             modifier.edit(enabled)\n \n-    security.declareProtected(ManagePortal, \'get\')\n+    security.declareProtected(ManagePortal, "get")\n \n     def get(self, id):\n         """See IModifierRegistryQuery"""\n@@ -301,7 +301,7 @@ def get(self, id):\n         getattr(aq_base(self), id)\n         return getattr(self, id)\n \n-    security.declareProtected(ManagePortal, \'query\')\n+    security.declareProtected(ManagePortal, "query")\n \n     def query(self, id, default=None):\n         """See IModifierRegistryQuery"""\ndiff --git a/Products/CMFEditions/Modifiers.py b/Products/CMFEditions/Modifiers.py\nindex 93fea00..17fa2be 100644\n--- a/Products/CMFEditions/Modifiers.py\n+++ b/Products/CMFEditions/Modifiers.py\n@@ -39,7 +39,7 @@\n from zope.interface import implementer\n \n manage_addModifierForm = PageTemplateFile(\n-    \'www/modifierAddForm.pt\', globals(), __name__=\'manage_addModifierForm\'\n+    "www/modifierAddForm.pt", globals(), __name__="manage_addModifierForm"\n )\n \n \n@@ -50,27 +50,27 @@ class ConditionalModifier(SimpleItem):\n     """This is a wrapper for a modifier."""\n \n     modifierEditForm = PageTemplateFile(\n-        \'www/modifierEditForm.pt\', globals(), __name__=\'modifierEditForm\'\n+        "www/modifierEditForm.pt", globals(), __name__="modifierEditForm"\n     )\n     modifierEditForm._owner = None\n     manage = manage_main = modifierEditForm\n     manage_options = (\n-        {\'label\': \'Edit\', \'action\': \'modifierEditForm\'},\n+        {"label": "Edit", "action": "modifierEditForm"},\n     ) + SimpleItem.manage_options[:]\n \n-    def __init__(self, id, modifier, title=\'\'):\n+    def __init__(self, id, modifier, title=""):\n         """See IConditionalModifier."""\n         self.id = str(id)\n         self.title = str(title)\n-        self.meta_type = \'edmod_%s\' % id\n+        self.meta_type = "edmod_%s" % id\n         self._modifier = modifier\n         self._enabled = False\n \n-    def edit(self, enabled=None, title=\'\', REQUEST=None):\n+    def edit(self, enabled=None, title="", REQUEST=None):\n         """See IConditionalModifier."""\n         self.title = title\n \n-        if enabled is not None and (enabled == \'True\' or enabled == True):\n+        if enabled is not None and (enabled == "True" or enabled == True):\n             self._enabled = enabled\n         else:\n             self._enabled = False\n@@ -105,7 +105,7 @@ def getModifier(self):\n \n \n manage_addTalesModifierForm = PageTemplateFile(\n-    \'www/talesModifierAddForm.pt\', globals(), __name__=\'manage_addTalesModifierForm\'\n+    "www/talesModifierAddForm.pt", globals(), __name__="manage_addTalesModifierForm"\n )\n \n \n@@ -116,18 +116,18 @@ class ConditionalTalesModifier(ConditionalModifier):\n     """This is a wrapper with a tales condition for a modifier."""\n \n     modifierEditForm = PageTemplateFile(\n-        \'www/talesModifierEditForm.pt\', globals(), __name__=\'modifierEditForm\'\n+        "www/talesModifierEditForm.pt", globals(), __name__="modifierEditForm"\n     )\n     manage_options = (\n-        {\'label\': \'Edit\', \'action\': \'modifierEditForm\'},\n+        {"label": "Edit", "action": "modifierEditForm"},\n     ) + ConditionalModifier.manage_options[:]\n \n-    def __init__(self, id, modifier, title=\'\'):\n+    def __init__(self, id, modifier, title=""):\n         """See IConditionalTalesModifier."""\n         ConditionalModifier.__init__(self, id, modifier, title)\n         self._condition = None\n \n-    def edit(self, enabled=None, condition=None, title=\'\', REQUEST=None):\n+    def edit(self, enabled=None, condition=None, title="", REQUEST=None):\n         """See IConditionalTalesModifier."""\n         ConditionalModifier.edit(self, enabled, title)\n         if condition is not None and condition != self.getTalesCondition():\n@@ -149,7 +149,7 @@ def isApplicable(self, obj, portal=None):\n \n     def getTalesCondition(self):\n         """See IConditionalTalesModifier."""\n-        return getattr(self._condition, \'text\', \'\')\n+        return getattr(self._condition, "text", "")\n \n \n InitializeClass(ConditionalTalesModifier)\n@@ -180,14 +180,14 @@ def findNextFolderishParent(obj):\n         """\n         # XXX propose this check (should be the same):\n         #    if aq_base(obj) is obj:\n-        if obj is None or not hasattr(obj, \'aq_base\'):\n+        if obj is None or not hasattr(obj, "aq_base"):\n             folder = None\n         else:\n             folder = obj\n             # Search up the containment hierarchy until we find an\n             # obj that claims it\'s a folder.\n             while folder is not None:\n-                if getattr(aq_base(folder), \'isPrincipiaFolderish\', 0):\n+                if getattr(aq_base(folder), "isPrincipiaFolderish", 0):\n                     # found it.\n                     break\n                 else:\n@@ -197,12 +197,12 @@ def findNextFolderishParent(obj):\n     try:\n         obj_url = obj.absolute_url()\n     except AttributeError:\n-        obj_url = \'\'\n+        obj_url = ""\n \n     # use the portal if folder lookup fails due to an unwrapped obj\n     folder = findNextFolderishParent(obj) or portal\n \n-    pm = getToolByName(portal, \'portal_membership\', None)\n+    pm = getToolByName(portal, "portal_membership", None)\n     if pm is None or pm.isAnonymousUser():\n         member = None\n     else:\n@@ -219,18 +219,18 @@ def findNextFolderishParent(obj):\n         portal_type = None\n \n     data = {\n-        \'object_url\': obj_url,\n-        \'folder_url\': folder is not None and folder.absolute_url() or \'\',\n-        \'portal_url\': portal is not None and portal.absolute_url() or \'\',\n-        \'object\': obj,\n-        \'folder\': folder,\n-        \'portal\': portal,\n-        \'nothing\': None,\n-        \'request\': getattr(obj, \'REQUEST\', None),\n-        \'modules\': SecureModuleImporter,\n-        \'member\': member,\n-        \'meta_type\': meta_type,\n-        \'portal_type\': portal_type,\n+        "object_url": obj_url,\n+        "folder_url": folder is not None and folder.absolute_url() or "",\n+        "portal_url": portal is not None and portal.absolute_url() or "",\n+        "object": obj,\n+        "folder": folder,\n+        "portal": portal,\n+        "nothing": None,\n+        "request": getattr(obj, "REQUEST", None),\n+        "modules": SecureModuleImporter,\n+        "member": member,\n+        "meta_type": meta_type,\n+        "portal_type": portal_type,\n     }\n     data.update(more_symbols)\n     return getEngine().getContext(data)\ndiff --git a/Products/CMFEditions/Permissions.py b/Products/CMFEditions/Permissions.py\nindex dcb9b81..bb56e02 100644\n--- a/Products/CMFEditions/Permissions.py\n+++ b/Products/CMFEditions/Permissions.py\n@@ -26,23 +26,23 @@\n from AccessControl.Permission import addPermission\n \n \n-ApplyVersionControl = \'CMFEditions: Apply version control\'\n-addPermission(ApplyVersionControl, (\'Manager\', \'Site Administrator\'))\n+ApplyVersionControl = "CMFEditions: Apply version control"\n+addPermission(ApplyVersionControl, ("Manager", "Site Administrator"))\n \n-SaveNewVersion = \'CMFEditions: Save new version\'\n-addPermission(SaveNewVersion, (\'Manager\', \'Site Administrator\'))\n+SaveNewVersion = "CMFEditions: Save new version"\n+addPermission(SaveNewVersion, ("Manager", "Site Administrator"))\n \n-PurgeVersion = \'CMFEditions: Purge version\'\n-addPermission(PurgeVersion, (\'Manager\', \'Site Administrator\'))\n+PurgeVersion = "CMFEditions: Purge version"\n+addPermission(PurgeVersion, ("Manager", "Site Administrator"))\n \n-AccessPreviousVersions = \'CMFEditions: Access previous versions\'\n-addPermission(AccessPreviousVersions, (\'Manager\', \'Site Administrator\'))\n+AccessPreviousVersions = "CMFEditions: Access previous versions"\n+addPermission(AccessPreviousVersions, ("Manager", "Site Administrator"))\n \n-RevertToPreviousVersions = \'CMFEditions: Revert to previous versions\'\n-addPermission(RevertToPreviousVersions, (\'Manager\', \'Site Administrator\'))\n+RevertToPreviousVersions = "CMFEditions: Revert to previous versions"\n+addPermission(RevertToPreviousVersions, ("Manager", "Site Administrator"))\n \n-CheckoutToLocation = \'CMFEditions: Checkout to location\'\n-addPermission(CheckoutToLocation, (\'Manager\', \'Site Administrator\'))\n+CheckoutToLocation = "CMFEditions: Checkout to location"\n+addPermission(CheckoutToLocation, ("Manager", "Site Administrator"))\n \n-ManageVersioningPolicies = \'CMFEditions: Manage versioning policies\'\n-addPermission(ManageVersioningPolicies, (\'Manager\', \'Site Administrator\'))\n+ManageVersioningPolicies = "CMFEditions: Manage versioning policies"\n+addPermission(ManageVersioningPolicies, ("Manager", "Site Administrator"))\ndiff --git a/Products/CMFEditions/ReferenceFactoriesTool.py b/Products/CMFEditions/ReferenceFactoriesTool.py\nindex 897ad53..2f67637 100644\n--- a/Products/CMFEditions/ReferenceFactoriesTool.py\n+++ b/Products/CMFEditions/ReferenceFactoriesTool.py\n@@ -41,10 +41,10 @@\n class ReferenceFactoriesTool(UniqueObject, OrderedFolder):\n     __doc__ = __doc__  # copy from module\n \n-    id = \'portal_referencefactories\'\n-    alternative_id = \'portal_referencefactoryregistry\'\n+    id = "portal_referencefactories"\n+    alternative_id = "portal_referencefactoryregistry"\n \n-    meta_type = \'Reference Factory Registry\'\n+    meta_type = "Reference Factory Registry"\n \n     security = ClassSecurityInfo()\n \n@@ -54,12 +54,12 @@ class ReferenceFactoriesTool(UniqueObject, OrderedFolder):\n     # methods implementing IFactories\n     # -------------------------------------------------------------------\n \n-    security.declarePrivate(\'invokeFactory\')\n+    security.declarePrivate("invokeFactory")\n \n     def invokeFactory(self, repo_clone, source, selector=None):\n         """See IReferenceFactories"""\n         # Just assuming ObjectManager behaviour for now\n-        portal_hidhandler = getToolByName(self, \'portal_historyidhandler\')\n+        portal_hidhandler = getToolByName(self, "portal_historyidhandler")\n         try:\n             portal_type = repo_clone.getPortalTypeName()\n         except AttributeError:\n@@ -80,7 +80,7 @@ def invokeFactory(self, repo_clone, source, selector=None):\n \n         return obj\n \n-    security.declarePrivate(\'hasBeenMoved\')\n+    security.declarePrivate("hasBeenMoved")\n \n     def hasBeenMoved(self, obj, source):\n         """See IReferenceFactories"""\ndiff --git a/Products/CMFEditions/StandardModifiers.py b/Products/CMFEditions/StandardModifiers.py\nindex 3db47ba..f5f4042 100644\n--- a/Products/CMFEditions/StandardModifiers.py\n+++ b/Products/CMFEditions/StandardModifiers.py\n@@ -63,38 +63,38 @@ def initialize(context):\n     """Registers modifiers with zope (on zope startup)."""\n     for m in modifiers:\n         context.registerClass(\n-            m[\'wrapper\'],\n-            m[\'id\'],\n+            m["wrapper"],\n+            m["id"],\n             permission=ManagePortal,\n-            constructors=(m[\'form\'], m[\'factory\']),\n-            icon=m[\'icon\'],\n+            constructors=(m["form"], m["factory"]),\n+            icon=m["icon"],\n         )\n \n \n def install(portal_modifier, ids=None):\n     """Registers modifiers in the modifier registry (at tool install time)."""\n     for m in modifiers:\n-        id = m[\'id\']\n+        id = m["id"]\n         if ids is not None and id not in ids:\n             continue\n         if id in portal_modifier.objectIds():\n             continue\n-        title = m[\'title\']\n-        modifier = m[\'modifier\']()\n-        wrapper = m[\'wrapper\'](id, modifier, title)\n-        enabled = m[\'enabled\']\n+        title = m["title"]\n+        modifier = m["modifier"]()\n+        wrapper = m["wrapper"](id, modifier, title)\n+        enabled = m["enabled"]\n         if IConditionalTalesModifier.providedBy(wrapper):\n-            wrapper.edit(enabled, m[\'condition\'])\n+            wrapper.edit(enabled, m["condition"])\n         else:\n             wrapper.edit(enabled)\n \n-        portal_modifier.register(m[\'id\'], wrapper)\n+        portal_modifier.register(m["id"], wrapper)\n \n \n manage_OMOutsideChildrensModifierAddForm = PageTemplateFile(\n-    \'www/OMOutsideChildrensModifierAddForm.pt\',\n+    "www/OMOutsideChildrensModifierAddForm.pt",\n     globals(),\n-    __name__=\'manage_OMOutsideChildrensModifierAddForm\',\n+    __name__="manage_OMOutsideChildrensModifierAddForm",\n )\n \n \n@@ -104,13 +104,13 @@ def manage_addOMOutsideChildrensModifier(self, id, title=None, REQUEST=None):\n     self._setObject(id, ConditionalTalesModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n manage_OMInsideChildrensModifierAddForm = PageTemplateFile(\n-    \'www/OMInsideChildrensModifierAddForm.pt\',\n+    "www/OMInsideChildrensModifierAddForm.pt",\n     globals(),\n-    __name__=\'manage_OMInsideChildrensModifierAddForm\',\n+    __name__="manage_OMInsideChildrensModifierAddForm",\n )\n \n \n@@ -120,13 +120,13 @@ def manage_addOMInsideChildrensModifier(self, id, title=None, REQUEST=None):\n     self._setObject(id, ConditionalTalesModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n manage_RetainUIDsModifierAddForm = PageTemplateFile(\n-    \'www/RetainUIDsModifierAddForm.pt\',\n+    "www/RetainUIDsModifierAddForm.pt",\n     globals(),\n-    __name__=\'manage_RetainUIDsModifierAddForm\',\n+    __name__="manage_RetainUIDsModifierAddForm",\n )\n \n \n@@ -136,13 +136,13 @@ def manage_addRetainUIDs(self, id, title=None, REQUEST=None):\n     self._setObject(id, ConditionalModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n manage_RetainWorkflowStateAndHistoryModifierAddForm = PageTemplateFile(\n-    \'www/RetainWorkflowStateAndHistoryModifierAddForm.pt\',\n+    "www/RetainWorkflowStateAndHistoryModifierAddForm.pt",\n     globals(),\n-    __name__=\'manage_RetainWorkflowStateAndHistoryModifierAddForm\',\n+    __name__="manage_RetainWorkflowStateAndHistoryModifierAddForm",\n )\n \n \n@@ -152,13 +152,13 @@ def manage_addRetainWorkflowStateAndHistory(self, id, title=None, REQUEST=None):\n     self._setObject(id, ConditionalModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n manage_RetainPermissionsSettingsAddForm = PageTemplateFile(\n-    \'www/RetainPermissionsSettingsModifierAddForm.pt\',\n+    "www/RetainPermissionsSettingsModifierAddForm.pt",\n     globals(),\n-    __name__=\'manage_RetainPermissionsSettingsModifierAddForm\',\n+    __name__="manage_RetainPermissionsSettingsModifierAddForm",\n )\n \n \n@@ -168,13 +168,13 @@ def manage_addRetainPermissionsSettings(self, id, title=None, REQUEST=None):\n     self._setObject(id, ConditionalModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n manage_SaveFileDataInFileTypeByReferenceModifierAddForm = PageTemplateFile(\n-    \'www/SaveFileDataInFileTypeByReferenceModifierAddForm.pt\',\n+    "www/SaveFileDataInFileTypeByReferenceModifierAddForm.pt",\n     globals(),\n-    __name__=\'manage_SaveFileDataInFileTypeByReferenceModifierAddForm\',\n+    __name__="manage_SaveFileDataInFileTypeByReferenceModifierAddForm",\n )\n \n \n@@ -184,14 +184,14 @@ def manage_addSaveFileDataInFileTypeByReference(self, id, title=None, REQUEST=No\n     self._setObject(id, ConditionalTalesModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n # silly modifier just for demos\n manage_SillyDemoRetrieveModifierAddForm = PageTemplateFile(\n-    \'www/SillyDemoRetrieveModifierAddForm.pt\',\n+    "www/SillyDemoRetrieveModifierAddForm.pt",\n     globals(),\n-    __name__=\'manage_SillyDemoRetrieveModifierAddForm\',\n+    __name__="manage_SillyDemoRetrieveModifierAddForm",\n )\n \n \n@@ -201,13 +201,13 @@ def manage_addSillyDemoRetrieveModifier(self, id, title=None, REQUEST=None):\n     self._setObject(id, ConditionalTalesModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n manage_AbortVersioningOfLargeFilesAndImagesAddForm = PageTemplateFile(\n-    \'www/AbortVersioningOfLargeFilesAndImagesAddForm.pt\',\n+    "www/AbortVersioningOfLargeFilesAndImagesAddForm.pt",\n     globals(),\n-    __name__=\'manage_AbortVersioningOfLargeFilesAndImagesAddForm\',\n+    __name__="manage_AbortVersioningOfLargeFilesAndImagesAddForm",\n )\n \n \n@@ -217,13 +217,13 @@ def manage_addAbortVersioningOfLargeFilesAndImages(self, id, title=None, REQUEST\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n manage_SkipVersioningOfLargeFilesAndImagesAddForm = PageTemplateFile(\n-    \'www/SkipVersioningOfLargeFilesAndImagesAddForm.pt\',\n+    "www/SkipVersioningOfLargeFilesAndImagesAddForm.pt",\n     globals(),\n-    __name__=\'manage_SkipVersioningOfLargeFilesAndImagesAddForm\',\n+    __name__="manage_SkipVersioningOfLargeFilesAndImagesAddForm",\n )\n \n \n@@ -233,13 +233,13 @@ def manage_addSkipVersioningOfLargeFilesAndImages(self, id, title=None, REQUEST=\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n manage_SkipParentPointersAddForm = PageTemplateFile(\n-    \'www/SkipParentPointersAddForm.pt\',\n+    "www/SkipParentPointersAddForm.pt",\n     globals(),\n-    __name__=\'manage_SkipParentPointersAddForm\',\n+    __name__="manage_SkipParentPointersAddForm",\n )\n \n \n@@ -249,13 +249,13 @@ def manage_addSkipParentPointers(self, id, title=None, REQUEST=None):\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n manage_SkipRegistryBasesPointersAddForm = PageTemplateFile(\n-    \'www/SkipRegistryBasesPointersAddForm.pt\',\n+    "www/SkipRegistryBasesPointersAddForm.pt",\n     globals(),\n-    __name__=\'manage_SkipRegistryBasesPointersAddForm\',\n+    __name__="manage_SkipRegistryBasesPointersAddForm",\n )\n \n \n@@ -265,11 +265,11 @@ def manage_addSkipRegistryBasesPointers(self, id, title=None, REQUEST=None):\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n manage_Skip_z3c_blobfileAddForm = PageTemplateFile(\n-    \'www/Skip_z3c_blobfile.pt\', globals(), __name__=\'manage_Skip_z3c_blobfileAddForm\'\n+    "www/Skip_z3c_blobfile.pt", globals(), __name__="manage_Skip_z3c_blobfileAddForm"\n )\n \n \n@@ -279,7 +279,7 @@ def manage_addSkip_z3c_blobfile(self, id, title=None, REQUEST=None):\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url() + \'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n # ----------------------------------------------------------------------\n@@ -297,8 +297,8 @@ class RetainAttributeAnnotationItemsBase:\n \n     def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         # replace specific annotation elements with those from the working copy\n-        repo_annotations = getattr(repo_clone, \'__annotations__\', None)\n-        obj_annotations = getattr(obj, \'__annotations__\', None)\n+        repo_annotations = getattr(repo_clone, "__annotations__", None)\n+        obj_annotations = getattr(obj, "__annotations__", None)\n \n         # check if the modifier is called with a valid working copy\n         # with annotations\n@@ -323,7 +323,7 @@ class OMBaseModifier(RetainAttributeAnnotationItemsBase):\n \n     def _getOnCloneModifiers(self, obj):\n         """Removes all childrens and returns them as references."""\n-        portal_archivist = getToolByName(obj, \'portal_archivist\')\n+        portal_archivist = getToolByName(obj, "portal_archivist")\n         VersionAwareReference = portal_archivist.classes.VersionAwareReference\n \n         # do not pickle the object managers subobjects\n@@ -350,7 +350,7 @@ def persistent_load(ignored):\n \n     def _beforeSaveModifier(self, obj, clone):\n         """Returns all unititialized \'IVersionAwareReference\' objects."""\n-        portal_archivist = getToolByName(obj, \'portal_archivist\')\n+        portal_archivist = getToolByName(obj, "portal_archivist")\n         adapter = portal_archivist.classes.ObjectManagerStorageAdapter\n \n         # just return adapters to the attributes that were replaced by\n@@ -365,9 +365,9 @@ def _getAttributeNamesHandlingSubObjects(self, obj, repo_clone):\n         attrs = list(set(tuple(repo_clone.objectIds()) + tuple(obj.objectIds())))\n \n         if isinstance(obj, BTreeFolder2Base):\n-            attrs.extend([\'_tree\', \'_count\', \'_mt_index\'])\n+            attrs.extend(["_tree", "_count", "_mt_index"])\n         elif isinstance(obj, ObjectManager):\n-            attrs.extend([\'_objects\'])\n+            attrs.extend(["_objects"])\n \n         return attrs\n \n@@ -383,7 +383,7 @@ class OMOutsideChildrensModifier(OMBaseModifier):\n     def getOnCloneModifiers(self, obj):\n         """Removes all childrens and returns them as references."""\n         pers_id, pers_load, outside_refs = self._getOnCloneModifiers(obj)\n-        return pers_id, pers_load, [], outside_refs, \'\'\n+        return pers_id, pers_load, [], outside_refs, ""\n \n     def beforeSaveModifier(self, obj, clone):\n         """Returns all unititialized \'IVersionAwareReference\' objects.\n@@ -394,7 +394,7 @@ def beforeSaveModifier(self, obj, clone):\n         return {}, [], outside_refs\n \n     def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n-        portal_archivist = getToolByName(obj, \'portal_archivist\')\n+        portal_archivist = getToolByName(obj, "portal_archivist")\n         OMStorageAdapter = portal_archivist.classes.ObjectManagerStorageAdapter\n \n         ref_names = self._getAttributeNamesHandlingSubObjects(obj, repo_clone)\n@@ -444,7 +444,7 @@ class OMInsideChildrensModifier(OMBaseModifier):\n     def getOnCloneModifiers(self, obj):\n         """Removes all childrens and returns them as references."""\n         pers_id, pers_load, inside_refs = self._getOnCloneModifiers(obj)\n-        return pers_id, pers_load, inside_refs, [], \'\'\n+        return pers_id, pers_load, inside_refs, [], ""\n \n     def beforeSaveModifier(self, obj, clone):\n         """Returns all unititialized \'IVersionAwareReference\' objects.\n@@ -459,7 +459,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         if obj is None:\n             return [], [], {}\n \n-        hidhandler = getToolByName(obj, \'portal_historyidhandler\')\n+        hidhandler = getToolByName(obj, "portal_historyidhandler")\n         queryUid = hidhandler.queryUid\n \n         # Inside refs from the original object that have no counterpart\n@@ -481,7 +481,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n             if histid is not None:\n                 orig_histids[histid] = id\n             else:\n-                orig_histids[\'no_history\' + id] = id\n+                orig_histids["no_history" + id] = id\n \n         # (2) evaluate the refs that get replaced anyway\n         for varef in repo_clone.objectValues():\n@@ -569,14 +569,14 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n \n         # replace the workflow stuff of the repository clone by the\n         # one of the working copy or delete it\n-        if getattr(aq_base(obj), \'review_state\', _marker) is not _marker:\n+        if getattr(aq_base(obj), "review_state", _marker) is not _marker:\n             repo_clone.review_state = obj.review_state\n-        elif getattr(aq_base(repo_clone), \'review_state\', _marker) is not _marker:\n+        elif getattr(aq_base(repo_clone), "review_state", _marker) is not _marker:\n             del repo_clone.review_state\n \n-        if getattr(aq_base(obj), \'workflow_history\', _marker) is not _marker:\n+        if getattr(aq_base(obj), "workflow_history", _marker) is not _marker:\n             repo_clone.workflow_history = obj.workflow_history\n-        elif getattr(aq_base(repo_clone), \'workflow_history\', _marker) is not _marker:\n+        elif getattr(aq_base(repo_clone), "workflow_history", _marker) is not _marker:\n             del repo_clone.workflow_history\n \n         return [], [], {}\n@@ -604,7 +604,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         # one of the working copy or delete it\n         for key, val in obj.__dict__.items():\n             # Find permission settings\n-            if key.startswith(\'_\') and key.endswith(\'_Permission\'):\n+            if key.startswith("_") and key.endswith("_Permission"):\n                 setattr(repo_clone, key, val)\n \n         return [], [], {}\n@@ -628,10 +628,10 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n             return [], [], {}\n \n         # Preserve CMFUid\n-        uid_tool = getToolByName(obj, \'portal_historyidhandler\', None)\n+        uid_tool = getToolByName(obj, "portal_historyidhandler", None)\n         if uid_tool is not None:\n             working_uid = uid_tool.queryUid(obj)\n-            anno_tool = getToolByName(obj, \'portal_uidannotation\')\n+            anno_tool = getToolByName(obj, "portal_uidannotation")\n             annotation = anno_tool(repo_clone, uid_tool.UID_ATTRIBUTE_NAME)\n             annotation.setUid(working_uid)\n \n@@ -649,7 +649,7 @@ class SaveFileDataInFileTypeByReference:\n     """\n \n     def getReferencedAttributes(self, obj):\n-        return {\'data\': getattr(aq_base(obj), \'data\', None)}\n+        return {"data": getattr(aq_base(obj), "data", None)}\n \n     def reattachReferencedAttributes(self, obj, attrs_dict):\n \n@@ -669,7 +669,7 @@ class SkipParentPointers:\n \n     def getOnCloneModifiers(self, obj):\n         """Removes parent pointers and stores a marker"""\n-        parent = getattr(obj, \'__parent__\', _marker)\n+        parent = getattr(obj, "__parent__", _marker)\n         if parent is _marker:\n             return None\n \n@@ -693,8 +693,8 @@ def beforeSaveModifier(self, obj, clone):\n     def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         """Install the parent from the working copy"""\n         if (\n-            getattr(repo_clone, \'__parent__\', _marker) is None\n-            and getattr(obj, \'__parent__\', _marker) is not _marker\n+            getattr(repo_clone, "__parent__", _marker) is None\n+            and getattr(obj, "__parent__", _marker) is not _marker\n         ):\n             repo_clone.__parent__ = obj.__parent__\n         return [], [], {}\n@@ -742,11 +742,11 @@ def persistent_id(obj):\n             obj_id = id(aq_base(obj))\n             for key, bases in six.iteritems(component_bases):\n                 if obj_id in bases:\n-                    return \'%s:%s\' % (key, obj_id)\n+                    return "%s:%s" % (key, obj_id)\n             return None\n \n         def persistent_load(obj):\n-            key, base_id = obj.split(\':\')\n+            key, base_id = obj.split(":")\n             return component_bases[key][int(base_id)]\n \n         return persistent_id, persistent_load, [], []\n@@ -811,28 +811,28 @@ class AbortVersioningOfLargeFilesAndImages(ConditionalTalesModifier):\n     """Raises an error if a file or image attribute stored on the\n     object in a specified field is larger than a fixed default"""\n \n-    field_names = (\'file\', \'image\')\n+    field_names = ("file", "image")\n     max_size = 26214400  # This represents a 400 element long Pdata list\n \n     modifierEditForm = PageTemplateFile(\n-        \'www/fieldModifierEditForm.pt\', globals(), __name__=\'modifierEditForm\'\n+        "www/fieldModifierEditForm.pt", globals(), __name__="modifierEditForm"\n     )\n \n     _condition = Expression("python: portal_type in (\'Image\', \'File\')")\n \n     def __init__(\n-        self, id=\'AbortVersioningOfLargeFilesAndImages\', modifier=None, title=\'\'\n+        self, id="AbortVersioningOfLargeFilesAndImages", modifier=None, title=""\n     ):\n         self.id = str(id)\n         self.title = str(title)\n-        self.meta_type = \'edmod_%s\' % id\n+        self.meta_type = "edmod_%s" % id\n         self._enabled = False\n \n     def edit(\n         self,\n         enabled=None,\n         condition=None,\n-        title=\'\',\n+        title="",\n         field_names=None,\n         max_size=None,\n         REQUEST=None,\n@@ -841,14 +841,14 @@ def edit(\n         if max_size is not None:\n             self.max_size = int(max_size)\n         if field_names is not None:\n-            field_names = tuple(s.strip() for s in field_names.split(\'\\n\') if s)\n+            field_names = tuple(s.strip() for s in field_names.split("\\n") if s)\n             if field_names != self.field_names:\n                 self.field_names = field_names\n         return ConditionalTalesModifier.edit(self, enabled, condition, title)\n \n     def getFieldNames(self):\n         """For the edit form"""\n-        return \'\\n\'.join(self.field_names)\n+        return "\\n".join(self.field_names)\n \n     def getModifier(self):\n         """We are the modifier, not some silly wrapper."""\n@@ -870,10 +870,10 @@ def _getFieldValues(self, obj):\n         for name in self.field_names:\n             val = getattr(obj, name, None)\n             # Skip linked Pdata chains too long for the pickler\n-            if hasattr(aq_base(val), \'getSize\') and callable(val.getSize):\n+            if hasattr(aq_base(val), "getSize") and callable(val.getSize):\n                 size = val.getSize()\n                 if isinstance(size, six.integer_types) and size >= max_size:\n-                    yield \'attribute\', name, val\n+                    yield "attribute", name, val\n \n     def getOnCloneModifiers(self, obj):\n         """Detects large file objects and raises an error"""\n@@ -1019,132 +1019,132 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n \n modifiers = (\n     {\n-        \'id\': \'OMInsideChildrensModifier\',\n-        \'title\': "Modifier for object managers treating children as inside objects.",\n-        \'enabled\': True,\n-        \'condition\': \'python: object and path("object/isPrincipiaFolderish|nothing") and not path("object/@@plone/isStructuralFolder|nothing")\',\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': OMInsideChildrensModifier,\n-        \'form\': manage_OMInsideChildrensModifierAddForm,\n-        \'factory\': manage_addOMInsideChildrensModifier,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "OMInsideChildrensModifier",\n+        "title": "Modifier for object managers treating children as inside objects.",\n+        "enabled": True,\n+        "condition": \'python: object and path("object/isPrincipiaFolderish|nothing") and not path("object/@@plone/isStructuralFolder|nothing")\',\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": OMInsideChildrensModifier,\n+        "form": manage_OMInsideChildrensModifierAddForm,\n+        "factory": manage_addOMInsideChildrensModifier,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'OMOutsideChildrensModifier\',\n-        \'title\': "Modifier for object managers (like standard folders) treating children as outside objects.",\n-        \'enabled\': True,\n-        \'condition\': "python:path(\'object/@@plone/isStructuralFolder|nothing\') or portal_type == \'Folder\'",\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': OMOutsideChildrensModifier,\n-        \'form\': manage_OMOutsideChildrensModifierAddForm,\n-        \'factory\': manage_addOMOutsideChildrensModifier,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "OMOutsideChildrensModifier",\n+        "title": "Modifier for object managers (like standard folders) treating children as outside objects.",\n+        "enabled": True,\n+        "condition": "python:path(\'object/@@plone/isStructuralFolder|nothing\') or portal_type == \'Folder\'",\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": OMOutsideChildrensModifier,\n+        "form": manage_OMOutsideChildrensModifierAddForm,\n+        "factory": manage_addOMOutsideChildrensModifier,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'RetainUIDs\',\n-        \'title\': "Retains the CMF UIDs from the working copy",\n-        \'enabled\': True,\n-        \'wrapper\': ConditionalModifier,\n-        \'modifier\': RetainUIDs,\n-        \'form\': manage_RetainUIDsModifierAddForm,\n-        \'factory\': manage_addRetainUIDs,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "RetainUIDs",\n+        "title": "Retains the CMF UIDs from the working copy",\n+        "enabled": True,\n+        "wrapper": ConditionalModifier,\n+        "modifier": RetainUIDs,\n+        "form": manage_RetainUIDsModifierAddForm,\n+        "factory": manage_addRetainUIDs,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'RetainWorkflowStateAndHistory\',\n-        \'title\': "Retains the working copies workflow state upon retrieval/revertion.",\n-        \'enabled\': True,\n-        \'wrapper\': ConditionalModifier,\n-        \'modifier\': RetainWorkflowStateAndHistory,\n-        \'form\': manage_RetainWorkflowStateAndHistoryModifierAddForm,\n-        \'factory\': manage_addRetainWorkflowStateAndHistory,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "RetainWorkflowStateAndHistory",\n+        "title": "Retains the working copies workflow state upon retrieval/revertion.",\n+        "enabled": True,\n+        "wrapper": ConditionalModifier,\n+        "modifier": RetainWorkflowStateAndHistory,\n+        "form": manage_RetainWorkflowStateAndHistoryModifierAddForm,\n+        "factory": manage_addRetainWorkflowStateAndHistory,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'RetainPermissionsSettings\',\n-        \'title\': "Retains the permission settings upon retrieval/revertion.",\n-        \'enabled\': True,\n-        \'wrapper\': ConditionalModifier,\n-        \'modifier\': RetainPermissionsSettings,\n-        \'form\': manage_RetainPermissionsSettingsAddForm,\n-        \'factory\': manage_addRetainPermissionsSettings,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "RetainPermissionsSettings",\n+        "title": "Retains the permission settings upon retrieval/revertion.",\n+        "enabled": True,\n+        "wrapper": ConditionalModifier,\n+        "modifier": RetainPermissionsSettings,\n+        "form": manage_RetainPermissionsSettingsAddForm,\n+        "factory": manage_addRetainPermissionsSettings,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'SaveFileDataInFileTypeByReference\',\n-        \'title\': "Let\'s the storage optimize cloning of file data.",\n-        \'enabled\': False,\n-        \'condition\': "python: meta_type==\'Portal File\'",\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': SaveFileDataInFileTypeByReference,\n-        \'form\': manage_SaveFileDataInFileTypeByReferenceModifierAddForm,\n-        \'factory\': manage_addSaveFileDataInFileTypeByReference,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "SaveFileDataInFileTypeByReference",\n+        "title": "Let\'s the storage optimize cloning of file data.",\n+        "enabled": False,\n+        "condition": "python: meta_type==\'Portal File\'",\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": SaveFileDataInFileTypeByReference,\n+        "form": manage_SaveFileDataInFileTypeByReferenceModifierAddForm,\n+        "factory": manage_addSaveFileDataInFileTypeByReference,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'SillyDemoRetrieveModifier\',\n-        \'title\': "Silly retrive modifier for demos only.",\n-        \'enabled\': False,\n-        \'condition\': "python: True",\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': SillyDemoRetrieveModifier,\n-        \'form\': manage_SillyDemoRetrieveModifierAddForm,\n-        \'factory\': manage_addSillyDemoRetrieveModifier,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "SillyDemoRetrieveModifier",\n+        "title": "Silly retrive modifier for demos only.",\n+        "enabled": False,\n+        "condition": "python: True",\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": SillyDemoRetrieveModifier,\n+        "form": manage_SillyDemoRetrieveModifierAddForm,\n+        "factory": manage_addSillyDemoRetrieveModifier,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'SkipParentPointers\',\n-        \'title\': "Skip Saving of Parent Pointers",\n-        \'enabled\': True,\n-        \'condition\': "python: True",\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': SkipParentPointers,\n-        \'form\': manage_SkipParentPointersAddForm,\n-        \'factory\': manage_addSkipParentPointers,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "SkipParentPointers",\n+        "title": "Skip Saving of Parent Pointers",\n+        "enabled": True,\n+        "condition": "python: True",\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": SkipParentPointers,\n+        "form": manage_SkipParentPointersAddForm,\n+        "factory": manage_addSkipParentPointers,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'SkipRegistryBasesPointers\',\n-        \'title\': "Skip Saving of Component Registry Bases",\n-        \'enabled\': True,\n-        \'condition\': "python: True",\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': SkipRegistryBasesPointers,\n-        \'form\': manage_SkipRegistryBasesPointersAddForm,\n-        \'factory\': manage_addSkipRegistryBasesPointers,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "SkipRegistryBasesPointers",\n+        "title": "Skip Saving of Component Registry Bases",\n+        "enabled": True,\n+        "condition": "python: True",\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": SkipRegistryBasesPointers,\n+        "form": manage_SkipRegistryBasesPointersAddForm,\n+        "factory": manage_addSkipRegistryBasesPointers,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'AbortVersioningOfLargeFilesAndImages\',\n-        \'title\': "Abort versioning of objects if file data if it\'s too large",\n-        \'enabled\': True,\n-        \'condition\': "python: portal_type in (\'Image\', \'File\')",\n-        \'wrapper\': AbortVersioningOfLargeFilesAndImages,\n-        \'modifier\': AbortVersioningOfLargeFilesAndImages,\n-        \'form\': manage_AbortVersioningOfLargeFilesAndImagesAddForm,\n-        \'factory\': manage_addAbortVersioningOfLargeFilesAndImages,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "AbortVersioningOfLargeFilesAndImages",\n+        "title": "Abort versioning of objects if file data if it\'s too large",\n+        "enabled": True,\n+        "condition": "python: portal_type in (\'Image\', \'File\')",\n+        "wrapper": AbortVersioningOfLargeFilesAndImages,\n+        "modifier": AbortVersioningOfLargeFilesAndImages,\n+        "form": manage_AbortVersioningOfLargeFilesAndImagesAddForm,\n+        "factory": manage_addAbortVersioningOfLargeFilesAndImages,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'SkipVersioningOfLargeFilesAndImages\',\n-        \'title\': "Skip versioning of objects if file data if it\'s too large",\n-        \'enabled\': False,\n-        \'condition\': "python: portal_type in (\'Image\', \'File\')",\n-        \'wrapper\': SkipVersioningOfLargeFilesAndImages,\n-        \'modifier\': SkipVersioningOfLargeFilesAndImages,\n-        \'form\': manage_SkipVersioningOfLargeFilesAndImagesAddForm,\n-        \'factory\': manage_addSkipVersioningOfLargeFilesAndImages,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "SkipVersioningOfLargeFilesAndImages",\n+        "title": "Skip versioning of objects if file data if it\'s too large",\n+        "enabled": False,\n+        "condition": "python: portal_type in (\'Image\', \'File\')",\n+        "wrapper": SkipVersioningOfLargeFilesAndImages,\n+        "modifier": SkipVersioningOfLargeFilesAndImages,\n+        "form": manage_SkipVersioningOfLargeFilesAndImagesAddForm,\n+        "factory": manage_addSkipVersioningOfLargeFilesAndImages,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'Skip_z3c_blobfile\',\n-        \'title\': "Skip storing z3c.blobfile.file.File fields on objects",\n-        \'enabled\': True,\n-        \'condition\': "python:True",\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': Skip_z3c_blobfile,\n-        \'form\': manage_Skip_z3c_blobfileAddForm,\n-        \'factory\': manage_addSkip_z3c_blobfile,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "Skip_z3c_blobfile",\n+        "title": "Skip storing z3c.blobfile.file.File fields on objects",\n+        "enabled": True,\n+        "condition": "python:True",\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": Skip_z3c_blobfile,\n+        "form": manage_Skip_z3c_blobfileAddForm,\n+        "factory": manage_addSkip_z3c_blobfile,\n+        "icon": "www/modifier.gif",\n     },\n )\ndiff --git a/Products/CMFEditions/StorageMigrationSupport.py b/Products/CMFEditions/StorageMigrationSupport.py\nindex a21f692..a647eef 100644\n--- a/Products/CMFEditions/StorageMigrationSupport.py\n+++ b/Products/CMFEditions/StorageMigrationSupport.py\n@@ -32,7 +32,7 @@\n import time\n \n \n-logger = logging.getLogger(\'CMFEditions\')\n+logger = logging.getLogger("CMFEditions")\n \n \n def create(context, type, name):\ndiff --git a/Products/CMFEditions/UniqueIdHandlerTool.py b/Products/CMFEditions/UniqueIdHandlerTool.py\nindex 2ae1c5d..4b16e80 100644\n--- a/Products/CMFEditions/UniqueIdHandlerTool.py\n+++ b/Products/CMFEditions/UniqueIdHandlerTool.py\n@@ -5,5 +5,5 @@\n     "UniqueIdHandlerTool has been removed; "\n     "use Products.CMFEditions.historyidhandlertool.HistoryIdHandlerTool or "\n     "Products.CMFUid.UniqueIdHandlerTool.UniqueIdHandlerTool",\n-    UniqueIdHandlerTool=(\'Products.CMFUid.UniqueIdHandlerTool:UniqueIdHandlerTool\'),\n+    UniqueIdHandlerTool=("Products.CMFUid.UniqueIdHandlerTool:UniqueIdHandlerTool"),\n )\ndiff --git a/Products/CMFEditions/VersionPolicies.py b/Products/CMFEditions/VersionPolicies.py\nindex 2967327..a77fd40 100644\n--- a/Products/CMFEditions/VersionPolicies.py\n+++ b/Products/CMFEditions/VersionPolicies.py\n@@ -39,7 +39,7 @@ def __init__(self, obj_id, title, **kw):\n         self.id = obj_id\n         self.title = title\n \n-    security.declarePublic(\'Title\')\n+    security.declarePublic("Title")\n \n     def Title(self):\n         return self.title\ndiff --git a/Products/CMFEditions/ZVCStorageTool.py b/Products/CMFEditions/ZVCStorageTool.py\nindex 68be55b..0440006 100644\n--- a/Products/CMFEditions/ZVCStorageTool.py\n+++ b/Products/CMFEditions/ZVCStorageTool.py\n@@ -63,7 +63,7 @@\n import types\n \n \n-logger = logging.getLogger(\'CMFEditions\')\n+logger = logging.getLogger("CMFEditions")\n \n \n def deepCopy(obj):\n@@ -153,16 +153,16 @@ class ZVCStorageTool(UniqueObject, SimpleItem):\n       objects.\n     """\n \n-    id = \'portal_historiesstorage\'\n-    alternative_id = \'portal_zvcstorage\'\n+    id = "portal_historiesstorage"\n+    alternative_id = "portal_zvcstorage"\n \n-    meta_type = \'CMFEditions Portal ZVC based Histories Storage Tool\'\n+    meta_type = "CMFEditions Portal ZVC based Histories Storage Tool"\n \n     storageStatistics = PageTemplateFile(\n-        \'www/storageStatistics.pt\', globals(), __name__=\'modifierEditForm\'\n+        "www/storageStatistics.pt", globals(), __name__="modifierEditForm"\n     )\n     manage_options = (\n-        {\'label\': \'Statistics (may take time)\', \'action\': \'storageStatistics\'},\n+        {"label": "Statistics (may take time)", "action": "storageStatistics"},\n     ) + SimpleItem.manage_options[:]\n \n     # make exceptions available trough the tool\n@@ -182,7 +182,7 @@ class ZVCStorageTool(UniqueObject, SimpleItem):\n     # methods implementing IStorage\n     # -------------------------------------------------------------------\n \n-    security.declarePrivate(\'isRegistered\')\n+    security.declarePrivate("isRegistered")\n \n     def isRegistered(self, history_id):\n         """See IStorage."""\n@@ -193,7 +193,7 @@ def isRegistered(self, history_id):\n             return False\n         return shadow_storage.isRegistered(history_id)\n \n-    security.declarePrivate(\'register\')\n+    security.declarePrivate("register")\n \n     def register(self, history_id, object, referenced_data={}, metadata=None):\n         """See IStorage."""\n@@ -214,7 +214,7 @@ def register(self, history_id, object, referenced_data={}, metadata=None):\n                 "The underlying storage implementation reported an error." % history_id\n             )\n \n-    security.declarePrivate(\'save\')\n+    security.declarePrivate("save")\n \n     def save(self, history_id, object, referenced_data={}, metadata=None):\n         """See IStorage."""\n@@ -241,7 +241,7 @@ def save(self, history_id, object, referenced_data={}, metadata=None):\n                 "The underlying storage implementation reported an error." % history_id\n             )\n \n-    security.declarePrivate(\'retrieve\')\n+    security.declarePrivate("retrieve")\n \n     def retrieve(self, history_id, selector=None, countPurged=True, substitute=True):\n         """See ``IStorage`` and Comments in ``IPurgePolicy``"""\n@@ -282,7 +282,7 @@ def retrieve(self, history_id, selector=None, countPurged=True, substitute=True)\n         object = zvc_obj.getWrappedObject()\n         # Get referenced data from shadow history\n         history = self._getShadowHistory(history_id)\n-        referenced_data = history.retrieve(selector).get(\'referenced_data\', {})\n+        referenced_data = history.retrieve(selector).get("referenced_data", {})\n         data = VersionData(object, referenced_data, metadata)\n \n         # check if retrieved a replacement for a removed object and\n@@ -291,18 +291,18 @@ def retrieve(self, history_id, selector=None, countPurged=True, substitute=True)\n             # delegate retrieving to purge policy if one is available\n             # if none is available just return the replacement for the\n             # removed object\n-            policy = getToolByName(self, \'portal_purgepolicy\', None)\n+            policy = getToolByName(self, "portal_purgepolicy", None)\n             if policy is not None:\n                 data = policy.retrieveSubstitute(history_id, selector, default=data)\n         return data\n \n-    security.declarePrivate(\'getHistory\')\n+    security.declarePrivate("getHistory")\n \n     def getHistory(self, history_id, countPurged=True, substitute=True):\n         """See IStorage."""\n         return LazyHistory(self, history_id, countPurged, substitute)\n \n-    security.declarePrivate(\'getModificationDate\')\n+    security.declarePrivate("getModificationDate")\n \n     def getModificationDate(\n         self, history_id, selector=None, countPurged=True, substitute=True\n@@ -315,7 +315,7 @@ def getModificationDate(\n     # methods implementing IPurgeSupport\n     # -------------------------------------------------------------------\n \n-    security.declarePrivate(\'purge\')\n+    security.declarePrivate("purge")\n \n     def purge(self, history_id, selector, metadata={}, countPurged=True):\n         """See ``IPurgeSupport``"""\n@@ -376,7 +376,7 @@ def _applyOrCheckin(\n         # delegate the decision if and what to purge to the purge policy\n         # tool if one exists. If the call returns ``False`` do not save\n         # or register the current version.\n-        policy = getToolByName(self, \'portal_purgepolicy\', None)\n+        policy = getToolByName(self, "portal_purgepolicy", None)\n         if policy is not None:\n             if not policy.beforeSaveHook(history_id, object, metadata):\n                 # returning None signalizes that the version wasn\'t saved\n@@ -421,7 +421,7 @@ def _getShadowStorage(self, autoAdd=True):\n             self._shadowStorage = ShadowStorage()\n         return self._shadowStorage\n \n-    security.declarePrivate(\'getHistoryMetadata\')\n+    security.declarePrivate("getHistoryMetadata")\n \n     def getHistoryMetadata(self, history_id):\n         """Return the metadata blob from ShadowHistory for presenting\n@@ -444,7 +444,7 @@ def _getZVCRepo(self):\n         Instantiates one with the first call.\n         """\n         if self.zvc_repo is None:\n-            self.zvc_repo = ZopeRepository(\'repo\', \'ZVC Storage\')\n+            self.zvc_repo = ZopeRepository("repo", "ZVC Storage")\n         return self.zvc_repo\n \n     def _getZVCAccessInfo(self, history_id, selector, countPurged):\n@@ -523,15 +523,15 @@ def _encodeMetadata(self, metadata):\n         #    - first line with trailing \\x00: comment or empty comment\n         #    - then: pickled metadata (incl. comment)\n         try:\n-            comment = metadata[\'sys_metadata\'][\'comment\']\n+            comment = metadata["sys_metadata"]["comment"]\n             comment = dumps(comment)\n         except KeyError:\n-            comment = \'\'\n-        return b\'\\x00\\n\'.join((comment, dumps(metadata, HIGHEST_PROTOCOL)))\n+            comment = ""\n+        return b"\\x00\\n".join((comment, dumps(metadata, HIGHEST_PROTOCOL)))\n \n     def _retrieveMetadataFromZVC(self, zvc_histid, zvc_selector):\n         logEntry = self._retrieveZVCLogEntry(zvc_histid, zvc_selector)\n-        metadata = loads(logEntry.message.split(b\'\\x00\\n\', 1)[1])\n+        metadata = loads(logEntry.message.split(b"\\x00\\n", 1)[1])\n         return metadata\n \n     # -------------------------------------------------------------------\n@@ -673,7 +673,7 @@ def migrateStorage(self):\n     # ZMI methods\n     # -------------------------------------------------------------------\n \n-    security.declareProtected(ManagePortal, \'zmi_getStorageStatistics\')\n+    security.declareProtected(ManagePortal, "zmi_getStorageStatistics")\n \n     def zmi_getStorageStatistics(self):\n         """ """\n@@ -708,7 +708,7 @@ def zmi_getStorageStatistics(self):\n                 url = None\n                 object_ = self.retrieve(hid).object\n                 if isinstance(object_, Removed):\n-                    portal_type = \'Removed\'\n+                    portal_type = "Removed"\n                 else:\n                     portal_type = object_.object.getPortalTypeName()\n             histData = {\n@@ -849,11 +849,11 @@ def save(self, data):\n         version_id = self.nextVersionId\n         referenced = {}\n         # Store referenced data as is\n-        if \'referenced_data\' in data:\n-            referenced = data[\'referenced_data\']\n-            del data[\'referenced_data\']\n+        if "referenced_data" in data:\n+            referenced = data["referenced_data"]\n+            del data["referenced_data"]\n         self._full[version_id] = deepCopy(data)\n-        self._full[version_id][\'referenced_data\'] = referenced\n+        self._full[version_id]["referenced_data"] = referenced\n         self._available.append(version_id)\n         # Provokes a write conflict if two saves happen the same\n         # time. That\'s exactly what\'s desired.\n@@ -868,7 +868,7 @@ def save(self, data):\n \n         return version_id\n \n-    security.declareProtected(AccessPreviousVersions, \'retrieve\')\n+    security.declareProtected(AccessPreviousVersions, "retrieve")\n \n     def retrieve(self, selector, countPurged=True):\n         """Retrieves the Selected Data From the History\n@@ -910,7 +910,7 @@ def purge(self, selector, data, countPurged):\n         except KeyError:\n             pass\n \n-    security.declareProtected(AccessPreviousVersions, \'getLength\')\n+    security.declareProtected(AccessPreviousVersions, "getLength")\n \n     def getLength(self, countPurged):\n         """Length of the History Either Counting Purged Versions or Not"""\n@@ -998,7 +998,7 @@ class ZVCAwareWrapper(Persistent):\n \n     def __init__(self, object, metadata, vc_info=None):\n         self._object = object\n-        self._physicalPath = metadata[\'sys_metadata\'].get(\'physicalPath\', ())[:]  # copy\n+        self._physicalPath = metadata["sys_metadata"].get("physicalPath", ())[:]  # copy\n         if vc_info is not None:\n             self.__vc_info__ = vc_info\n \ndiff --git a/Products/CMFEditions/__init__.py b/Products/CMFEditions/__init__.py\nindex 30a02a6..4fb5e6c 100644\n--- a/Products/CMFEditions/__init__.py\n+++ b/Products/CMFEditions/__init__.py\n@@ -53,23 +53,23 @@\n )\n \n \n-CMFEditionsMessageFactory = MessageFactory(\'cmfeditions\')\n+CMFEditionsMessageFactory = MessageFactory("cmfeditions")\n \n-ModuleSecurityInfo(\'Products.CMFEditions\').declarePublic(\'CMFEditionsMessageFactory\')\n-ModuleSecurityInfo(\'Products.CMFEditions.interfaces.IArchivist\').declarePublic(\n-    \'ArchivistUnregisteredError\'\n+ModuleSecurityInfo("Products.CMFEditions").declarePublic("CMFEditionsMessageFactory")\n+ModuleSecurityInfo("Products.CMFEditions.interfaces.IArchivist").declarePublic(\n+    "ArchivistUnregisteredError"\n )\n-ModuleSecurityInfo(\'Products.CMFEditions.interfaces.IModifier\').declarePublic(\n-    \'FileTooLargeToVersionError\'\n+ModuleSecurityInfo("Products.CMFEditions.interfaces.IModifier").declarePublic(\n+    "FileTooLargeToVersionError"\n )\n-ModuleSecurityInfo(\'Products.CMFEditions.utilities\').declarePublic(\'isObjectChanged\')\n-ModuleSecurityInfo(\'Products.CMFEditions.utilities\').declarePublic(\'isObjectVersioned\')\n-ModuleSecurityInfo(\'Products.CMFEditions.utilities\').declarePublic(\'maybeSaveVersion\')\n+ModuleSecurityInfo("Products.CMFEditions.utilities").declarePublic("isObjectChanged")\n+ModuleSecurityInfo("Products.CMFEditions.utilities").declarePublic("isObjectVersioned")\n+ModuleSecurityInfo("Products.CMFEditions.utilities").declarePublic("maybeSaveVersion")\n \n \n def initialize(context):\n     utils.ToolInit(\n-        meta_type=\'CMF Editions Tool\', tools=tools, icon=\'tool.gif\'\n+        meta_type="CMF Editions Tool", tools=tools, icon="tool.gif"\n     ).initialize(context)\n \n     # initialize standard modifiers to make them addable through the ZMI\ndiff --git a/Products/CMFEditions/browser/diff.py b/Products/CMFEditions/browser/diff.py\nindex 26a79f0..217c9f4 100644\n--- a/Products/CMFEditions/browser/diff.py\n+++ b/Products/CMFEditions/browser/diff.py\n@@ -48,8 +48,8 @@ def __call__(self):\n         history = self.history = []\n         # Count backwards from most recent to least recent\n         for i in range(history_metadata.getLength(countPurged=False) - 1, -1, -1):\n-            version = retrieve(i, countPurged=False)[\'metadata\'].copy()\n-            version[\'version_id\'] = getId(i, countPurged=False)\n+            version = retrieve(i, countPurged=False)["metadata"].copy()\n+            version["version_id"] = getId(i, countPurged=False)\n             history.append(version)\n         dt = getToolByName(self.context, "portal_diff")\n         self.changeset = dt.createChangeSet(\n@@ -69,7 +69,7 @@ class CanDiff(BrowserView):\n     def can_diff(self):\n         """Return True if content is diffable"""\n         context = self.context\n-        portal_diff = getToolByName(context, \'portal_diff\', None)\n+        portal_diff = getToolByName(context, "portal_diff", None)\n         return (\n             portal_diff\n             and len(portal_diff.getDiffForPortalType(context.portal_type)) > 0\ndiff --git a/Products/CMFEditions/browser/utils.py b/Products/CMFEditions/browser/utils.py\nindex b0b7d8a..703420b 100644\n--- a/Products/CMFEditions/browser/utils.py\n+++ b/Products/CMFEditions/browser/utils.py\n@@ -23,35 +23,35 @@ def get_macros(self, vdata):\n         type_info = context.portal_types.getTypeInfo(vdata.object)\n \n         # build the name of special versions views\n-        if getattr(type_info, \'getViewMethod\', None) is not None:\n+        if getattr(type_info, "getViewMethod", None) is not None:\n             # Should use IBrowserDefault.getLayout ?\n             def_method_name = type_info.getViewMethod(context)\n         else:\n-            def_method_name = type_info.getActionInfo(\'object/view\')[\'url\'].split(\'/\')[\n+            def_method_name = type_info.getActionInfo("object/view")["url"].split("/")[\n                 -1\n-            ] or getattr(type_info, \'default_view\', \'view\')\n-        versionPreviewMethodName = \'version_%s\' % def_method_name\n+            ] or getattr(type_info, "default_view", "view")\n+        versionPreviewMethodName = "version_%s" % def_method_name\n         versionPreviewTemplate = getattr(context, versionPreviewMethodName, None)\n \n         # check if a special version view exists\n-        if getattr(versionPreviewTemplate, \'macros\', None) is None:\n+        if getattr(versionPreviewTemplate, "macros", None) is None:\n             # Use the Plone\'s default view template\n             versionPreviewTemplate = context.restrictedTraverse(def_method_name)\n \n-        if getattr(versionPreviewTemplate, \'macros\', None) is None:\n+        if getattr(versionPreviewTemplate, "macros", None) is None:\n             return None\n \n-        macro_names = [\'content-core\', \'main\']\n+        macro_names = ["content-core", "main"]\n \n         try:\n-            return versionPreviewTemplate.macros[\'content-core\']\n+            return versionPreviewTemplate.macros["content-core"]\n         except KeyError:\n             pass  # No content-core macro could mean that we are in plone3 land\n         try:\n-            return versionPreviewTemplate.macros[\'main\']\n+            return versionPreviewTemplate.macros["main"]\n         except KeyError:\n             logger.warn(\n                 \'Missing TAL macros {0} in template "{1}".\'.format(\n-                    \', \'.join(macro_names), versionPreviewMethodName\n+                    ", ".join(macro_names), versionPreviewMethodName\n                 )\n             )\ndiff --git a/Products/CMFEditions/browser/views.py b/Products/CMFEditions/browser/views.py\nindex 1c975dc..0da223c 100644\n--- a/Products/CMFEditions/browser/views.py\n+++ b/Products/CMFEditions/browser/views.py\n@@ -12,11 +12,11 @@\n \n class UpdateVersionOnEditView(BrowserView):\n     def success(self):\n-        self.request.response.redirect(\'view\')\n+        self.request.response.redirect("view")\n \n     def __call__(self):\n         context = aq_inner(self.context)\n-        pf = getToolByName(context, \'portal_factory\')\n+        pf = getToolByName(context, "portal_factory")\n \n         if pf.isTemporary(context):\n             # don\'t do anything if we\'re in the factory\n@@ -37,12 +37,12 @@ def __call__(self):\n \n class UpdateVersionBeforeEditView(BrowserView):\n     def success(self):\n-        return self.context.restrictedTraverse(\'content_edit\')\n+        return self.context.restrictedTraverse("content_edit")\n \n     def __call__(self):\n         context = aq_inner(self.context)\n-        comment = self.request.get(\'cmfeditions_version_comment\', \'\')\n-        force = self.request.get(\'cmfeditions_save_new_version\', None) is not None\n+        comment = self.request.get("cmfeditions_version_comment", "")\n+        force = self.request.get("cmfeditions_save_new_version", None) is not None\n \n         if not (isObjectChanged(context) or force):\n             return self.success()\n@@ -51,8 +51,8 @@ def __call__(self):\n             maybeSaveVersion(context, comment=comment, force=force)\n         except FileTooLargeToVersionError:\n             IStatusMessage(self.request).addStatusMessage(\n-                _(\'Versioning for this file has been disabled because it is too large\'),\n-                type=\'warn\',\n+                _("Versioning for this file has been disabled because it is too large"),\n+                type="warn",\n             )\n         return self.success()\n \n@@ -60,25 +60,25 @@ def __call__(self):\n class FileDownloadVersionView(BrowserView):\n     def __call__(self):\n         context = aq_inner(self.context)\n-        version_id = int(self.request.get(\'version_id\', 1))\n+        version_id = int(self.request.get("version_id", 1))\n         RESPONSE = self.request.RESPONSE\n \n-        portal_repository = getToolByName(context, \'portal_repository\')\n+        portal_repository = getToolByName(context, "portal_repository")\n         obj = portal_repository.retrieve(context, version_id).object\n-        RESPONSE.setHeader(\'Content-Type\', obj.getContentType())\n-        RESPONSE.setHeader(\'Content-Length\', obj.get_size())\n+        RESPONSE.setHeader("Content-Type", obj.getContentType())\n+        RESPONSE.setHeader("Content-Length", obj.get_size())\n         RESPONSE.setHeader(\n-            \'Content-Disposition\', \'attachment;filename="%s"\' % (obj.getFilename())\n+            "Content-Disposition", \'attachment;filename="%s"\' % (obj.getFilename())\n         )\n         return obj.data\n \n \n class VersionImageTagView(BrowserView):\n     def __call__(self):\n-        version_id = int(self.request.get(\'version_id\', 1))\n-        here_url = self.request.get(\'here_url\', \'\')\n+        version_id = int(self.request.get("version_id", 1))\n+        here_url = self.request.get("here_url", "")\n         context = aq_inner(self.context)\n-        portal_repository = getToolByName(context, \'portal_repository\')\n+        portal_repository = getToolByName(context, "portal_repository")\n         obj = portal_repository.retrieve(context, version_id).object\n         working_copy_tag = obj.tag()\n         altPos = working_copy_tag.find("alt=")\ndiff --git a/Products/CMFEditions/exportimport/repository.py b/Products/CMFEditions/exportimport/repository.py\nindex 8d17783..72143bb 100644\n--- a/Products/CMFEditions/exportimport/repository.py\n+++ b/Products/CMFEditions/exportimport/repository.py\n@@ -10,14 +10,14 @@\n class RepositoryToolXMLAdapter(XMLAdapterBase):\n     """Mode in- and exporter for RepositoryTool."""\n \n-    name = \'repositorytool\'\n+    name = "repositorytool"\n \n     def _exportNode(self):\n         """Export the object as a DOM node."""\n-        node = self._doc.createElement(\'repositorytool\')\n+        node = self._doc.createElement("repositorytool")\n         node.appendChild(self._extractPolicies())\n         node.appendChild(self._extractTypePolicies())\n-        self._logger.info(\'RepositoryTool settings exported.\')\n+        self._logger.info("RepositoryTool settings exported.")\n         return node\n \n     def _importNode(self, node):\n@@ -26,13 +26,13 @@ def _importNode(self, node):\n             self._purgePolicies()\n         self._initPolicies(node)\n         self._initTypePolicies(node)\n-        self._logger.info(\'RepositoryTool settings imported.\')\n+        self._logger.info("RepositoryTool settings imported.")\n \n     def _shouldPurge(self, node):\n-        purge = node.getAttribute(\'purge\').lower() or \'false\'\n-        if purge == \'true\':\n+        purge = node.getAttribute("purge").lower() or "false"\n+        if purge == "true":\n             return True\n-        elif purge == \'false\':\n+        elif purge == "false":\n             return False\n         else:\n             raise ValueError("purge must be \'true\' or \'false\'")\n@@ -45,20 +45,20 @@ def _initPolicies(self, node):\n         tool = self.context\n         policynames = [p.getId() for p in tool.listPolicies()]\n         for child in node.childNodes:\n-            if child.nodeName == \'policies\':\n+            if child.nodeName == "policies":\n                 if self._shouldPurge(child):\n                     self._purgePolicies()\n                 for policy in child.childNodes:\n-                    if policy.nodeName == \'#text\':\n+                    if policy.nodeName == "#text":\n                         continue\n-                    if policy.nodeName != \'policy\':\n+                    if policy.nodeName != "policy":\n                         raise AssertionError(\n                             "<policies> must only contain <policy> tags, not <%s>.",\n                             policy.nodeName,\n                         )\n-                    policy_id = policy.getAttribute(\'name\')\n-                    policy_title = policy.getAttribute(\'title\')\n-                    class_id = policy.getAttribute(\'class\')\n+                    policy_id = policy.getAttribute("name")\n+                    policy_title = policy.getAttribute("title")\n+                    class_id = policy.getAttribute("class")\n                     if class_id:\n                         policy_class = resolve(class_id)\n                     else:\n@@ -66,16 +66,16 @@ def _initPolicies(self, node):\n                     tool.addPolicy(policy_id, policy_title, policy_class)\n \n     def _extractPolicies(self):\n-        node = self._doc.createElement(\'policies\')\n+        node = self._doc.createElement("policies")\n         policies = self.context.listPolicies()\n         policies.sort(key=lambda x: x.getId())\n         for policy in policies:\n-            p = self._doc.createElement(\'policy\')\n-            p.setAttribute(\'name\', policy.getId())\n-            p.setAttribute(\'title\', policy.Title())\n+            p = self._doc.createElement("policy")\n+            p.setAttribute("name", policy.getId())\n+            p.setAttribute("title", policy.Title())\n             klass = type(policy)\n             if klass is not VersionPolicy:\n-                p.setAttribute(\'class\', "%s.%s" % (klass.__module__, klass.__name__))\n+                p.setAttribute("class", "%s.%s" % (klass.__module__, klass.__name__))\n             node.appendChild(p)\n         return node\n \n@@ -86,31 +86,31 @@ def _purgeTypePolicies(self):\n     def _initTypePolicies(self, node):\n         tool = self.context\n         for child in node.childNodes:\n-            if child.nodeName == \'policymap\':\n+            if child.nodeName == "policymap":\n                 if self._shouldPurge(child):\n                     self._purgeTypePolicies()\n                 for p_type in child.childNodes:\n-                    if p_type.nodeName == \'#text\':\n+                    if p_type.nodeName == "#text":\n                         continue\n-                    if p_type.nodeName != \'type\':\n+                    if p_type.nodeName != "type":\n                         raise AssertionError(\n                             "<policymap> must only contain <type> tags, not <%s>.",\n                             p_type.nodeName,\n                         )\n-                    portal_type = p_type.getAttribute(\'name\')\n+                    portal_type = p_type.getAttribute("name")\n                     existing_policies = tool.getPolicyMap().get(portal_type, [])\n                     for policy_id in existing_policies:\n                         tool.removePolicyFromContentType(portal_type, policy_id)\n                     policies = []\n                     for policy in p_type.childNodes:\n-                        if policy.nodeName == \'#text\':\n+                        if policy.nodeName == "#text":\n                             continue\n-                        if policy.nodeName != \'policy\':\n+                        if policy.nodeName != "policy":\n                             raise AssertionError(\n                                 "<policymap><type> must only contain <policy> tags, not <%s>.",\n                                 policy.nodeName,\n                             )\n-                        policies.append(policy.getAttribute(\'name\'))\n+                        policies.append(policy.getAttribute("name"))\n                     versionable_types = tool.getVersionableContentTypes()\n                     if policies:\n                         if portal_type not in versionable_types:\n@@ -123,14 +123,14 @@ def _initTypePolicies(self, node):\n                     tool.setVersionableContentTypes(versionable_types)\n \n     def _extractTypePolicies(self):\n-        node = self._doc.createElement(\'policymap\')\n+        node = self._doc.createElement("policymap")\n         mapping = sorted(self.context.getPolicyMap().items())\n         for portal_type, policies in mapping:\n-            t = self._doc.createElement(\'type\')\n-            t.setAttribute(\'name\', portal_type)\n+            t = self._doc.createElement("type")\n+            t.setAttribute("name", portal_type)\n             for policyname in policies:\n-                p = self._doc.createElement(\'policy\')\n-                p.setAttribute(\'name\', policyname)\n+                p = self._doc.createElement("policy")\n+                p.setAttribute("name", policyname)\n                 t.appendChild(p)\n             node.appendChild(t)\n         return node\n@@ -139,22 +139,22 @@ def _extractTypePolicies(self):\n def importRepositoryTool(context):\n     """Import Repository Tool configuration."""\n     site = context.getSite()\n-    tool = getToolByName(site, \'portal_repository\', None)\n+    tool = getToolByName(site, "portal_repository", None)\n     if tool is None:\n         logger = context.getLogger("repositorytool")\n         logger.info("Nothing to import.")\n         return\n \n-    importObjects(tool, \'\', context)\n+    importObjects(tool, "", context)\n \n \n def exportRepositoryTool(context):\n     """Export Repository Tool configuration."""\n     site = context.getSite()\n-    tool = getToolByName(site, \'portal_repository\', None)\n+    tool = getToolByName(site, "portal_repository", None)\n     if tool is None:\n         logger = context.getLogger("repositorytool")\n         logger.info("Nothing to export.")\n         return\n \n-    exportObjects(tool, \'\', context)\n+    exportObjects(tool, "", context)\ndiff --git a/Products/CMFEditions/historyidhandlertool.py b/Products/CMFEditions/historyidhandlertool.py\nindex 74b315d..7c553f5 100644\n--- a/Products/CMFEditions/historyidhandlertool.py\n+++ b/Products/CMFEditions/historyidhandlertool.py\n@@ -23,4 +23,4 @@\n \n \n class HistoryIdHandlerTool(UniqueIdHandlerTool):\n-    id = \'portal_historyidhandler\'\n+    id = "portal_historyidhandler"\ndiff --git a/Products/CMFEditions/interfaces/IModifier.py b/Products/CMFEditions/interfaces/IModifier.py\nindex 8e1074f..30824bc 100644\n--- a/Products/CMFEditions/interfaces/IModifier.py\n+++ b/Products/CMFEditions/interfaces/IModifier.py\n@@ -198,7 +198,7 @@ class IConditionalModifier(Interface):\n     existing implicit condition evaluates to a true value.\n     """\n \n-    def __init__(id, modifier, title=\'\'):\n+    def __init__(id, modifier, title=""):\n         """Initialize with a modifier.\n \n         The conditional modifier is disabled by default.\ndiff --git a/Products/CMFEditions/interfaces/IRepository.py b/Products/CMFEditions/interfaces/IRepository.py\nindex a57849e..e60003b 100644\n--- a/Products/CMFEditions/interfaces/IRepository.py\n+++ b/Products/CMFEditions/interfaces/IRepository.py\n@@ -63,7 +63,7 @@ def setAutoApplyMode(autoapply):\n         The default value is True.\n         """\n \n-    def applyVersionControl(obj, comment=\'\', metadata={}):\n+    def applyVersionControl(obj, comment="", metadata={}):\n         """Register the content to the repository.\n \n         Must be called prior any of the other repository related methods.\n@@ -74,7 +74,7 @@ def applyVersionControl(obj, comment=\'\', metadata={}):\n         first version to the repository.\n         """\n \n-    def save(obj, comment=\'\', metadata={}):\n+    def save(obj, comment="", metadata={}):\n         """Saves the current version of the content.\n \n         \'comment\' preferably is a human readable string comment.\ndiff --git a/Products/CMFEditions/interfaces/__init__.py b/Products/CMFEditions/interfaces/__init__.py\nindex 030ea06..8cbe52f 100644\n--- a/Products/CMFEditions/interfaces/__init__.py\n+++ b/Products/CMFEditions/interfaces/__init__.py\n@@ -13,4 +13,4 @@ class IVersioned(interface.Interface):\n     thus versioned.\n     """\n \n-    version_id = interface.Attribute(\'The version id of this object.\')\n+    version_id = interface.Attribute("The version id of this object.")\ndiff --git a/Products/CMFEditions/setuphandlers.py b/Products/CMFEditions/setuphandlers.py\nindex 4d8f8f3..de372a9 100644\n--- a/Products/CMFEditions/setuphandlers.py\n+++ b/Products/CMFEditions/setuphandlers.py\n@@ -20,22 +20,22 @@ def importVarious(context):\n     care of by other handlers.\n     """\n     # Only run step if a flag file is present\n-    if context.readDataFile(\'cmfeditions_various.txt\') is None:\n+    if context.readDataFile("cmfeditions_various.txt") is None:\n         return\n     site = context.getSite()\n-    portal_modifier = getToolByName(site, \'portal_modifier\', None)\n+    portal_modifier = getToolByName(site, "portal_modifier", None)\n     if portal_modifier is None:\n         return\n     StandardModifiers.install(portal_modifier)\n-    portal_repository = getToolByName(site, \'portal_repository\')\n+    portal_repository = getToolByName(site, "portal_repository")\n     portal_repository.setAutoApplyMode(True)\n     portal_repository._migrateVersionPolicies()\n \n \n def installSkipRegistryBasesPointersModifier(context):\n     """Upgrade step to install the component registry bases modifier."""\n-    portal_modifier = getToolByName(context, \'portal_modifier\', None)\n-    StandardModifiers.install(portal_modifier, [\'SkipRegistryBasesPointers\'])\n+    portal_modifier = getToolByName(context, "portal_modifier", None)\n+    StandardModifiers.install(portal_modifier, ["SkipRegistryBasesPointers"])\n \n \n def removeBrokenModifiers(context):\n@@ -48,7 +48,7 @@ def removeBrokenModifiers(context):\n     """\n     from Products.CMFEditions.interfaces.IModifier import IConditionalModifier\n \n-    tool = getToolByName(context, \'portal_modifier\', None)\n+    tool = getToolByName(context, "portal_modifier", None)\n     for modifier_id, modifier in tool.objectItems():\n         if not IConditionalModifier.providedBy(modifier):\n             continue\ndiff --git a/Products/CMFEditions/subscriber.py b/Products/CMFEditions/subscriber.py\nindex 8b64f2c..a9f1745 100644\n--- a/Products/CMFEditions/subscriber.py\n+++ b/Products/CMFEditions/subscriber.py\n@@ -34,8 +34,8 @@ def object_removed(obj, event):\n     if not IContentish.providedBy(obj):\n         return\n     try:\n-        histories_storage = getToolByName(obj, \'portal_historiesstorage\')\n-        repo_tool = getToolByName(obj, \'portal_repository\')\n+        histories_storage = getToolByName(obj, "portal_historiesstorage")\n+        repo_tool = getToolByName(obj, "portal_repository")\n     except AttributeError:\n         # XXX If tools are missing, there is nothing we can do.\n         # This occurs in some Products.CMFDiffTool and\n@@ -54,10 +54,10 @@ def object_removed(obj, event):\n         # do nothing\n         return\n     current = metadata.retrieve(num_versions - 1)\n-    sys_metadata = current[\'metadata\'][\'sys_metadata\']\n-    if (\'parent\' in sys_metadata) and (sys_metadata[\'parent\'][\'history_id\'] != histid):\n+    sys_metadata = current["metadata"]["sys_metadata"]\n+    if ("parent" in sys_metadata) and (sys_metadata["parent"]["history_id"] != histid):\n         try:\n-            histories_storage.retrieve(history_id=sys_metadata[\'parent\'][\'history_id\'])\n+            histories_storage.retrieve(history_id=sys_metadata["parent"]["history_id"])\n             return\n         except StorageRetrieveError:\n             pass\n@@ -66,6 +66,6 @@ def object_removed(obj, event):\n         histories_storage.purge(\n             histid,\n             0,\n-            metadata={\'sys_metadata\': {\'comment\': \'purged\'}},\n+            metadata={"sys_metadata": {"comment": "purged"}},\n             countPurged=False,\n         )\ndiff --git a/Products/CMFEditions/testing.py b/Products/CMFEditions/testing.py\nindex 448454f..976f929 100644\n--- a/Products/CMFEditions/testing.py\n+++ b/Products/CMFEditions/testing.py\n@@ -21,15 +21,15 @@ def setUpZope(self, app, configurationContext):\n         self.loadZCML(package=Products.CMFEditions)\n \n     def setUpPloneSite(self, portal):\n-        applyProfile(portal, \'Products.CMFEditions:CMFEditions\')\n+        applyProfile(portal, "Products.CMFEditions:CMFEditions")\n         # with named AND dotted behaviors we need to take care of both\n         versioning_behavior = set(\n             [\n-                \'plone.app.versioningbehavior.behaviors.IVersionable\',\n-                \'plone.versioning\',\n+                "plone.app.versioningbehavior.behaviors.IVersionable",\n+                "plone.versioning",\n             ],\n         )\n-        for name in (\'Document\', \'Event\', \'Link\', \'News Item\'):\n+        for name in ("Document", "Event", "Link", "News Item"):\n             fti = portal.portal_types[name]\n             # write back the behaviors without the versioning behaviors\n             # using a Set to keep it simple\n@@ -46,13 +46,13 @@ def setUpPloneSite(self, portal):\n \n PRODUCTS_CMFEDITIONS_INTEGRATION_TESTING = IntegrationTesting(\n     bases=(PRODUCTS_CMFEDITIONS_FIXTURE,),\n-    name=\'ProductsCmfeditionsLayer:IntegrationTesting\',\n+    name="ProductsCmfeditionsLayer:IntegrationTesting",\n )\n \n \n PRODUCTS_CMFEDITIONS_FUNCTIONAL_TESTING = FunctionalTesting(\n     bases=(PRODUCTS_CMFEDITIONS_FIXTURE,),\n-    name=\'ProductsCmfeditionsLayer:FunctionalTesting\',\n+    name="ProductsCmfeditionsLayer:FunctionalTesting",\n )\n \n \n@@ -62,5 +62,5 @@ def setUpPloneSite(self, portal):\n         REMOTE_LIBRARY_BUNDLE_FIXTURE,\n         z2.ZSERVER_FIXTURE,\n     ),\n-    name=\'ProductsCmfeditionsLayer:AcceptanceTesting\',\n+    name="ProductsCmfeditionsLayer:AcceptanceTesting",\n )\ndiff --git a/Products/CMFEditions/tests/DummyTools.py b/Products/CMFEditions/tests/DummyTools.py\nindex d1dc6cd..f323601 100644\n--- a/Products/CMFEditions/tests/DummyTools.py\n+++ b/Products/CMFEditions/tests/DummyTools.py\n@@ -74,7 +74,7 @@ def notifyModified(obj):\n class DummyArchivist(SimpleItem):\n     """Archivist simulating modifiers and history storage."""\n \n-    id = \'portal_archivist\'\n+    id = "portal_archivist"\n \n     def getId(self):\n         return self.id\n@@ -83,7 +83,7 @@ def __init__(self):\n         self._archive = {}\n         self._counter = 0\n         self.reset_log()\n-        self.alog_indent = \'\'\n+        self.alog_indent = ""\n \n     def log(self, msg):\n         alog.append(msg)\n@@ -104,7 +104,7 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n             # (the current implementation isn\'t able yet to handle multiple\n             # locations. Nevertheless lets set the location id to a well\n             # known default value)\n-            portal_hidhandler = getToolByName(obj, \'portal_historyidhandler\')\n+            portal_hidhandler = getToolByName(obj, "portal_historyidhandler")\n             history_id = portal_hidhandler.register(obj)\n             version_id = obj.version_id = 0\n             obj.location_id = 0\n@@ -114,37 +114,37 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n             is_registered = True\n \n         base_obj = aq_base(obj)\n-        doc1_inside = getattr(base_obj, \'doc1_inside\', None)\n-        doc2_inside = getattr(base_obj, \'doc2_inside\', None)\n-        doc3_outside = getattr(base_obj, \'doc3_outside\', None)\n+        doc1_inside = getattr(base_obj, "doc1_inside", None)\n+        doc2_inside = getattr(base_obj, "doc2_inside", None)\n+        doc3_outside = getattr(base_obj, "doc3_outside", None)\n \n         # simulate clone modifiers\n         icrefs = []\n         ocrefs = []\n         clone = deepCopy(base_obj)\n         if doc1_inside is not None:\n-            icrefs.append(ObjectManagerStorageAdapter(clone, \'doc1_inside\'))\n+            icrefs.append(ObjectManagerStorageAdapter(clone, "doc1_inside"))\n         if doc2_inside is not None:\n-            icrefs.append(ObjectManagerStorageAdapter(clone, \'doc2_inside\'))\n+            icrefs.append(ObjectManagerStorageAdapter(clone, "doc2_inside"))\n         if doc3_outside is not None:\n-            ocrefs.append(ObjectManagerStorageAdapter(clone, \'doc3_outside\'))\n+            ocrefs.append(ObjectManagerStorageAdapter(clone, "doc3_outside"))\n         crefs = icrefs + ocrefs\n \n         # simulate before save modifier\n         iorefs = []\n         oorefs = []\n         if doc1_inside is not None:\n-            iorefs.append(getattr(obj, \'doc1_inside\'))\n+            iorefs.append(getattr(obj, "doc1_inside"))\n         if doc2_inside is not None:\n-            iorefs.append(getattr(obj, \'doc2_inside\'))\n+            iorefs.append(getattr(obj, "doc2_inside"))\n         if doc3_outside is not None:\n-            oorefs.append(getattr(obj, \'doc3_outside\'))\n+            oorefs.append(getattr(obj, "doc3_outside"))\n         orefs = iorefs + oorefs\n         for cref in crefs:\n             cref.setAttribute(VersionAwareReference())\n \n         # log\n-        if sys_metadata[\'originator\'] is None:\n+        if sys_metadata["originator"] is None:\n             self.log("")\n         if orefs:\n             self.log(\n@@ -153,14 +153,14 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n                     self.alog_indent,\n                     obj.getId(),\n                     history_id,\n-                    \', \'.join([ref.getId() for ref in orefs]),\n+                    ", ".join([ref.getId() for ref in orefs]),\n                 )\n             )\n         else:\n             self.log(\n                 "%sprepare %s: hid=%s" % (self.alog_indent, obj.getId(), history_id)\n             )\n-        self.alog_indent += \'  \'\n+        self.alog_indent += "  "\n \n         # prepare object structure\n         original_info = ObjectData(obj, iorefs, oorefs)\n@@ -209,10 +209,10 @@ def save(self, prepared_obj, autoregister=False):\n \n         irefs = [ref.getAttribute() for ref in prepared_obj.clone.inside_refs]\n         orefs = [ref.getAttribute() for ref in prepared_obj.clone.outside_refs]\n-        irefs_prep = [\'{hid:%s, vid:%s}\' % (r.history_id, r.version_id) for r in irefs]\n-        orefs_prep = [\'{hid:%s, vid:%s}\' % (r.history_id, r.version_id) for r in orefs]\n-        irefs = \', \'.join(irefs_prep)\n-        orefs = \', \'.join(orefs_prep)\n+        irefs_prep = ["{hid:%s, vid:%s}" % (r.history_id, r.version_id) for r in irefs]\n+        orefs_prep = ["{hid:%s, vid:%s}" % (r.history_id, r.version_id) for r in orefs]\n+        irefs = ", ".join(irefs_prep)\n+        orefs = ", ".join(orefs_prep)\n         if irefs:\n             irefs = "irefs=(%s), " % irefs\n         if orefs:\n@@ -232,9 +232,9 @@ def save(self, prepared_obj, autoregister=False):\n \n         # save in the format the data needs to be retrieved\n         svdata = {\n-            \'clone\': prepared_obj.clone,\n-            \'referenced_data\': prepared_obj.referenced_data,\n-            \'metadata\': prepared_obj.metadata,\n+            "clone": prepared_obj.clone,\n+            "referenced_data": prepared_obj.referenced_data,\n+            "metadata": prepared_obj.metadata,\n         }\n         # storage simulation\n         self._archive[prepared_obj.history_id].append(svdata)\n@@ -253,20 +253,20 @@ def retrieve(\n \n         data = self._archive[history_id][selector]\n         attr_handling_references = [\n-            \'_objects\',\n-            \'_tree\',\n-            \'_count\',\n-            \'_mt_index\',\n-            \'__annotations__\',\n+            "_objects",\n+            "_tree",\n+            "_count",\n+            "_mt_index",\n+            "__annotations__",\n         ]\n-        attr_handling_references.extend(data[\'clone\'].object.objectIds())\n+        attr_handling_references.extend(data["clone"].object.objectIds())\n         attr_handling_references.extend(obj.objectIds())\n         vdata = VersionData(\n-            data[\'clone\'],\n+            data["clone"],\n             [],\n             attr_handling_references,\n-            data[\'referenced_data\'],\n-            data[\'metadata\'],\n+            data["referenced_data"],\n+            data["metadata"],\n         )\n \n         return deepCopy(vdata)\n@@ -277,7 +277,7 @@ def getHistory(self, obj=None, history_id=None, preserve=()):\n \n     def getHistoryMetadata(self, obj=None, history_id=None):\n         obj, history_id = dereference(obj, history_id, self)\n-        return [item[\'metadata\'] for item in self._archive[history_id]]\n+        return [item["metadata"] for item in self._archive[history_id]]\n \n     def queryHistory(self, obj=None, history_id=None, preserve=(), default=None):\n         if default is None:\n@@ -303,12 +303,12 @@ def __init__(self, **info):\n         self.info = info\n \n     def setReference(self, target_obj, remove_info=True):\n-        portal_hidhandler = getToolByName(target_obj, \'portal_historyidhandler\')\n-        portal_archivist = getToolByName(target_obj, \'portal_archivist\')\n+        portal_hidhandler = getToolByName(target_obj, "portal_historyidhandler")\n+        portal_archivist = getToolByName(target_obj, "portal_archivist")\n         self.history_id = portal_hidhandler.queryUid(target_obj)\n         self.version_id = len(portal_archivist.queryHistory(target_obj)) - 1\n         self.location_id = 1  # only one location possible currently\n-        if remove_info and hasattr(self, \'info\'):\n+        if remove_info and hasattr(self, "info"):\n             self.info = None\n \n     def __of__(self, parent):\n@@ -316,7 +316,7 @@ def __of__(self, parent):\n \n \n class DummyModifier(DummyBaseTool):\n-    id = \'portal_modifier\'\n+    id = "portal_modifier"\n \n     def beforeSaveModifier(self, obj, clone):\n         return {}, [], []  # XXX 2nd and 3rd shall be lists\n@@ -342,12 +342,12 @@ def getOnCloneModifiers(self, obj):\n class FolderishContentObjectModifier(DummyBaseTool):\n     """This is a full fledged modifier."""\n \n-    id = \'portal_modifier\'\n+    id = "portal_modifier"\n \n     def getReferencedAttributes(self, obj):\n         # we declare the title beeing a big blob we don\'t want to be\n         # pickled and unpickled by the archivist\n-        return {\'title\': obj.title}\n+        return {"title": obj.title}\n \n     def getOnCloneModifiers(self, obj):\n         """Removes childrens ending with \'_inside\' or \'_outside\'.\n@@ -356,7 +356,7 @@ def getOnCloneModifiers(self, obj):\n         \'_outside\' by a uninitialzed \'IVersionAwareReference\'.\n         All other childrens get versioned with the parent.\n         """\n-        portal_archivist = getToolByName(obj, \'portal_archivist\')\n+        portal_archivist = getToolByName(obj, "portal_archivist")\n         VersionAwareReference = portal_archivist.classes.VersionAwareReference\n \n         # do not pickle the object managers subobjects\n@@ -365,10 +365,10 @@ def getOnCloneModifiers(self, obj):\n         inside_refs = []\n         for name, sub in obj.objectItems():\n             pyid = id(aq_base(sub))\n-            if name.endswith(\'_inside\'):\n+            if name.endswith("_inside"):\n                 inside_refs.append(sub)\n                 refs[pyid] = True\n-            elif name.endswith(\'_outside\'):\n+            elif name.endswith("_outside"):\n                 outside_refs.append(sub)\n                 refs[pyid] = True\n \n@@ -398,14 +398,14 @@ def persistent_load(pid):\n             # should never reach this!\n             assert False\n \n-        return persistent_id, persistent_load, inside_refs, outside_refs, \'\'\n+        return persistent_id, persistent_load, inside_refs, outside_refs, ""\n \n     def beforeSaveModifier(self, obj, clone):\n         """Returns all unititialized \'IVersionAwareReference\' objects.\n \n         This allways goes in conjunction with \'getOnCloneModifiers\'.\n         """\n-        portal_archivist = getToolByName(obj, \'portal_archivist\')\n+        portal_archivist = getToolByName(obj, "portal_archivist")\n         AttributeAdapter = portal_archivist.classes.AttributeAdapter\n \n         # just return adapters to the attributes that were replaced by\n@@ -413,9 +413,9 @@ def beforeSaveModifier(self, obj, clone):\n         outside_refs = []\n         inside_refs = []\n         for name in clone.objectIds():\n-            if name.endswith(\'_inside\'):\n+            if name.endswith("_inside"):\n                 inside_refs.append(AttributeAdapter(clone, name))\n-            elif name.endswith(\'_outside\'):\n+            elif name.endswith("_outside"):\n                 outside_refs.append(AttributeAdapter(clone, name))\n \n         return {}, inside_refs, outside_refs\n@@ -435,15 +435,15 @@ def reattachReferencedAttributes(self, object, referenced_data):\n             setattr(object, key, value)\n \n     def _getAttributeNamesHandlingSubObjects(self, obj):\n-        return [\'_objects\', \'_tree\', \'_count\', \'_mt_index\', \'__annotations__\'].extend(\n+        return ["_objects", "_tree", "_count", "_mt_index", "__annotations__"].extend(\n             obj.objectIds()\n         )\n \n \n class DummyHistoryIdHandler(DummyBaseTool):\n-    id = \'portal_historyidhandler\'\n+    id = "portal_historyidhandler"\n \n-    UID_ATTRIBUTE_NAME = \'editions_uhid\'\n+    UID_ATTRIBUTE_NAME = "editions_uhid"\n \n     uhid_counter = 0\n \n@@ -501,7 +501,7 @@ def __init__(self, reason, metadata):\n \n @implementer(IStorage, IPurgeSupport)\n class MemoryStorage(DummyBaseTool):\n-    id = \'portal_historiesstorage\'\n+    id = "portal_historiesstorage"\n \n     def __init__(self):\n         self._histories = {}\n@@ -515,7 +515,7 @@ def save(self, history_id, object, referenced_data={}, metadata=None):\n         # delegate the decission what to purge to the purge policy tool\n         # if it exists. If the call returns ``True`` do not save the current\n         # version.\n-        policy = getToolByName(self, \'portal_purgepolicy\', None)\n+        policy = getToolByName(self, "portal_purgepolicy", None)\n         if policy is not None:\n             if not policy.beforeSaveHook(history_id, metadata):\n                 return len(self._histories[history_id]) - 1\n@@ -567,7 +567,7 @@ def retrieve(self, history_id, selector=None, countPurged=True, substitute=True)\n             if substitute and isinstance(vdata.object, Removed):\n                 # delegate retrieving to purge policy if one is available\n                 # if none is available just return "the removed object"\n-                policy = getToolByName(self, \'portal_purgepolicy\', None)\n+                policy = getToolByName(self, "portal_purgepolicy", None)\n                 if policy is not None:\n                     vdata = policy.retrieveSubstitute(history_id, selector, vdata)\n             return vdata\n@@ -663,14 +663,14 @@ def __getitem__(self, selector):\n     def retrieve(self, selector, ignored=True):\n         """Faux metadata only retrieval"""\n         item = self[selector]\n-        return {\'metadata\': item.metadata}\n+        return {"metadata": item.metadata}\n \n \n @implementer(IPurgePolicy)\n class DummyPurgePolicy(DummyBaseTool):\n     """Dummy Purge Policy"""\n \n-    id = \'portal_purgepolicy\'\n+    id = "portal_purgepolicy"\n \n     def beforeSaveHook(self, history_id, obj, metadata={}):\n         """Purge old versions\n@@ -678,7 +678,7 @@ def beforeSaveHook(self, history_id, obj, metadata={}):\n         Purges old version so that at maximum two versions reside in\n         the history.\n         """\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+        storage = getToolByName(self, "portal_historiesstorage")\n         currentVersion = len(storage.getHistory(history_id))\n         while True:\n             length = len(storage.getHistory(history_id, countPurged=False))\n@@ -692,7 +692,7 @@ def beforeSaveHook(self, history_id, obj, metadata={}):\n \n     def retrieveSubstitute(self, history_id, selector, default=None):\n         """Retrives the next older version"""\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+        storage = getToolByName(self, "portal_historiesstorage")\n         while selector:\n             selector -= 1\n             data = storage.retrieve(history_id, selector, substitute=False)\n@@ -705,7 +705,7 @@ def retrieveSubstitute(self, history_id, selector, default=None):\n class PurgePolicyTestDummyStorage(DummyBaseTool):\n     """Partial Storage used for PurgePolicy Tetss"""\n \n-    id = \'portal_historiesstorage\'\n+    id = "portal_historiesstorage"\n \n     def __init__(self):\n         self.history = []\ndiff --git a/Products/CMFEditions/tests/base.py b/Products/CMFEditions/tests/base.py\nindex 3359c15..88f034e 100644\n--- a/Products/CMFEditions/tests/base.py\n+++ b/Products/CMFEditions/tests/base.py\n@@ -11,6 +11,6 @@ class CMFEditionsBaseTestCase(unittest.TestCase):\n     layer = PRODUCTS_CMFEDITIONS_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\ndiff --git a/Products/CMFEditions/tests/test_ArchivistTool.py b/Products/CMFEditions/tests/test_ArchivistTool.py\nindex d3b1b2d..7ba4d61 100644\n--- a/Products/CMFEditions/tests/test_ArchivistTool.py\n+++ b/Products/CMFEditions/tests/test_ArchivistTool.py\n@@ -39,12 +39,12 @@ class TestArchivistToolMemoryStorage(CMFEditionsBaseTestCase):\n     def setUp(self):\n         super(TestArchivistToolMemoryStorage, self).setUp()\n \n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\', [\'Manager\'], \'\')\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n-        self.portal.invokeFactory(\'Folder\', \'fol\')\n-        self.portal.fol.invokeFactory(\'Document\', \'doc1_inside\')\n-        self.portal.fol.invokeFactory(\'Document\', \'doc2_inside\')\n-        self.portal.fol.invokeFactory(\'Document\', \'doc3_outside\')\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n+        self.portal.invokeFactory("Document", "doc")\n+        self.portal.invokeFactory("Folder", "fol")\n+        self.portal.fol.invokeFactory("Document", "doc1_inside")\n+        self.portal.fol.invokeFactory("Document", "doc2_inside")\n+        self.portal.fol.invokeFactory("Document", "doc3_outside")\n         tools = (\n             DummyModifier(),\n             DummyHistoryIdHandler(),\n@@ -75,7 +75,7 @@ def test01_registerAttachesAHistoryId(self):\n         portal_archivist = self.portal.portal_archivist\n         portal_historyidhandler = self.portal.portal_historyidhandler\n         doc = self.portal.doc\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n         history_id = portal_historyidhandler.queryUid(doc)\n         self.assertTrue(history_id)\n@@ -84,14 +84,14 @@ def test02_retrieve(self):\n         portal_archivist = self.portal.portal_archivist\n         portal_historyidhandler = self.portal.portal_historyidhandler\n         doc = self.portal.doc\n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n         vdata = portal_archivist.retrieve(\n-            obj=doc, selector=0, preserve=(\'gaga\', \'gugus\')\n+            obj=doc, selector=0, preserve=("gaga", "gugus")\n         )\n         retr_doc = vdata.data.object\n         retr_meta = vdata.app_metadata\n@@ -99,95 +99,95 @@ def test02_retrieve(self):\n         retr_histid = portal_historyidhandler.queryUid(retr_doc)\n         self.assertEqual(doc_histid, retr_histid)\n         # check if correct version retrieved and working object unchanged\n-        self.assertEqual(retr_doc.text, \'text v1\')\n-        self.assertEqual(retr_meta, \'save number 1\')\n-        self.assertEqual(doc.text, \'text v2\')\n+        self.assertEqual(retr_doc.text, "text v1")\n+        self.assertEqual(retr_meta, "save number 1")\n+        self.assertEqual(doc.text, "text v2")\n         self.assertEqual(len(vdata.preserved_data), 2)\n-        self.assertEqual(vdata.preserved_data[\'gaga\'], \'gaga\')\n-        self.assertEqual(vdata.preserved_data[\'gugus\'], \'gugus\')\n+        self.assertEqual(vdata.preserved_data["gaga"], "gaga")\n+        self.assertEqual(vdata.preserved_data["gugus"], "gugus")\n \n     def test03_retrieveById(self):\n         portal_archivist = self.portal.portal_archivist\n         portal_historyidhandler = self.portal.portal_historyidhandler\n         doc = self.portal.doc\n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n         doc_histid = portal_historyidhandler.queryUid(doc)\n         vdata = portal_archivist.retrieve(\n-            history_id=doc_histid, selector=0, preserve=(\'gaga\', \'gugus\')\n+            history_id=doc_histid, selector=0, preserve=("gaga", "gugus")\n         )\n         retr_doc = vdata.data.object\n         retr_meta = vdata.app_metadata\n         # check if correct version retrieved and working object unchanged\n-        self.assertEqual(retr_doc.text, \'text v1\')\n-        self.assertEqual(retr_meta, \'save number 1\')\n-        self.assertEqual(doc.text, \'text v2\')\n+        self.assertEqual(retr_doc.text, "text v1")\n+        self.assertEqual(retr_meta, "save number 1")\n+        self.assertEqual(doc.text, "text v2")\n         self.assertEqual(len(vdata.preserved_data), 2)\n-        self.assertEqual(vdata.preserved_data[\'gaga\'], \'gaga\')\n-        self.assertEqual(vdata.preserved_data[\'gugus\'], \'gugus\')\n+        self.assertEqual(vdata.preserved_data["gaga"], "gaga")\n+        self.assertEqual(vdata.preserved_data["gugus"], "gugus")\n \n     def test04_getHistory(self):\n         portal_archivist = self.portal.portal_archivist\n         doc = self.portal.doc\n \n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n \n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n \n         history = portal_archivist.getHistory(doc)\n \n         self.assertEqual(len(history), 2)\n         # check if timestamp and principal available\n-        self.assertTrue(history[0].sys_metadata[\'timestamp\'])\n-        self.assertTrue(history[0].sys_metadata[\'principal\'])\n+        self.assertTrue(history[0].sys_metadata["timestamp"])\n+        self.assertTrue(history[0].sys_metadata["principal"])\n         # check if correct data and metadata retrieved\n-        self.assertEqual(history[0].data.object.text, \'text v1\')\n-        self.assertEqual(history[0].app_metadata, \'save number 1\')\n-        self.assertEqual(history[1].data.object.text, \'text v2\')\n-        self.assertEqual(history[1].app_metadata, \'save number 2\')\n+        self.assertEqual(history[0].data.object.text, "text v1")\n+        self.assertEqual(history[0].app_metadata, "save number 1")\n+        self.assertEqual(history[1].data.object.text, "text v2")\n+        self.assertEqual(history[1].app_metadata, "save number 2")\n \n     def test05_iterateOverHistory(self):\n         portal_archivist = self.portal.portal_archivist\n         doc = self.portal.doc\n \n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n \n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n \n-        doc.text = \'text v3\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 3\')\n+        doc.text = "text v3"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 3")\n         portal_archivist.save(prep)\n \n         counter = 0\n \n         for vdata in portal_archivist.getHistory(doc):\n             counter += 1\n-            self.assertEqual(vdata.data.object.text, \'text v%s\' % counter)\n-            self.assertEqual(vdata.app_metadata, \'save number %s\' % counter)\n+            self.assertEqual(vdata.data.object.text, "text v%s" % counter)\n+            self.assertEqual(vdata.app_metadata, "save number %s" % counter)\n \n     def test06_getHistoryById(self):\n         portal_archivist = self.portal.portal_archivist\n         portal_historyidhandler = self.portal.portal_historyidhandler\n         doc = self.portal.doc\n \n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n \n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n \n         doc_histid = portal_historyidhandler.queryUid(doc)\n@@ -195,13 +195,13 @@ def test06_getHistoryById(self):\n \n         self.assertEqual(len(history), 2)\n         # check if timestamp and principal available\n-        self.assertTrue(history[0].sys_metadata[\'timestamp\'])\n-        self.assertTrue(history[0].sys_metadata[\'principal\'])\n+        self.assertTrue(history[0].sys_metadata["timestamp"])\n+        self.assertTrue(history[0].sys_metadata["principal"])\n         # check if correct data and metadata retrieved\n-        self.assertEqual(history[0].data.object.text, \'text v1\')\n-        self.assertEqual(history[0].app_metadata, \'save number 1\')\n-        self.assertEqual(history[1].data.object.text, \'text v2\')\n-        self.assertEqual(history[1].app_metadata, \'save number 2\')\n+        self.assertEqual(history[0].data.object.text, "text v1")\n+        self.assertEqual(history[0].app_metadata, "save number 1")\n+        self.assertEqual(history[1].data.object.text, "text v2")\n+        self.assertEqual(history[1].app_metadata, "save number 2")\n \n     def test07_prepareObjectWithReferences(self):\n         # test with a different modifier\n@@ -215,11 +215,11 @@ def test07_prepareObjectWithReferences(self):\n         doc2_inside = fol.doc2_inside\n         doc3_outside = fol.doc3_outside\n \n-        doc1_inside.text = \'doc1_inside: inside reference\'\n-        doc2_inside.text = \'doc2_inside: inside reference\'\n-        doc3_outside.text = \'doc3_outside: outside reference\'\n+        doc1_inside.text = "doc1_inside: inside reference"\n+        doc2_inside.text = "doc2_inside: inside reference"\n+        doc3_outside.text = "doc3_outside: outside reference"\n \n-        prep = portal_archivist.prepare(fol, app_metadata=\'save number 1\')\n+        prep = portal_archivist.prepare(fol, app_metadata="save number 1")\n \n         self.assertEqual(fol, prep.original.object)\n \n@@ -256,11 +256,11 @@ def test07_prepareObjectWithReferences(self):\n         )\n \n         self.assertEqual(len(prep.referenced_data), 1)\n-        self.assertTrue(prep.referenced_data[\'title\'] is fol.title)\n+        self.assertTrue(prep.referenced_data["title"] is fol.title)\n \n-        self.assertEqual(prep.metadata[\'app_metadata\'], \'save number 1\')\n-        self.assertTrue(\'timestamp\' in prep.metadata[\'sys_metadata\'])\n-        self.assertTrue(\'principal\' in prep.metadata[\'sys_metadata\'])\n+        self.assertEqual(prep.metadata["app_metadata"], "save number 1")\n+        self.assertTrue("timestamp" in prep.metadata["sys_metadata"])\n+        self.assertTrue("principal" in prep.metadata["sys_metadata"])\n \n         self._setDummyTool(DummyModifier())\n \n@@ -276,11 +276,11 @@ def test08_retrieveWithReferences(self):\n         doc2_inside = fol.doc2_inside\n         doc3_outside = fol.doc3_outside\n \n-        doc1_inside.text = \'doc1_inside: inside reference\'\n-        doc2_inside.text = \'doc2_inside: inside reference\'\n-        doc3_outside.text = \'doc3_outside: outside reference\'\n+        doc1_inside.text = "doc1_inside: inside reference"\n+        doc2_inside.text = "doc2_inside: inside reference"\n+        doc3_outside.text = "doc3_outside: outside reference"\n \n-        prep = portal_archivist.prepare(fol, app_metadata=\'save number 1\')\n+        prep = portal_archivist.prepare(fol, app_metadata="save number 1")\n \n         # just set the info to some value before save to test if the\n         # reference stuff is saved and retrieved correctly\n@@ -295,9 +295,9 @@ def test08_retrieveWithReferences(self):\n         retr = portal_archivist.retrieve(fol)\n \n         # check metadata\n-        self.assertEqual(retr.app_metadata, \'save number 1\')\n-        self.assertTrue(\'timestamp\' in retr.sys_metadata)\n-        self.assertTrue(\'principal\' in retr.sys_metadata)\n+        self.assertEqual(retr.app_metadata, "save number 1")\n+        self.assertTrue("timestamp" in retr.sys_metadata)\n+        self.assertTrue("principal" in retr.sys_metadata)\n \n         # check the references\n         inside_refs = retr.data.inside_refs\n@@ -313,18 +313,18 @@ def test08_retrieveWithReferences(self):\n     def test09_isUpToDate(self):\n         doc = self.portal.doc\n         portal_archivist = self.portal.portal_archivist\n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         v1 = portal_archivist.register(prep)\n \n         self.assertTrue(portal_archivist.isUpToDate(obj=doc))\n         self.assertTrue(portal_archivist.isUpToDate(obj=doc, selector=v1))\n \n-        doc.text = \'text v2\'\n+        doc.text = "text v2"\n         notifyModified(doc)\n         self.assertFalse(portal_archivist.isUpToDate(obj=doc))\n \n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         v2 = portal_archivist.save(prep)\n \n         self.assertTrue(portal_archivist.isUpToDate(obj=doc))\n@@ -335,38 +335,38 @@ def test09_getHistoryMetadata(self):\n         portal_archivist = self.portal.portal_archivist\n         doc = self.portal.doc\n \n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n \n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n \n         history = portal_archivist.getHistoryMetadata(doc)\n \n         self.assertEqual(len(history), 2)\n         # check if timestamp and principal available\n-        self.assertTrue(history.retrieve(1)[\'metadata\'][\'sys_metadata\'][\'timestamp\'])\n-        self.assertTrue(history.retrieve(0)[\'metadata\'][\'sys_metadata\'][\'principal\'])\n+        self.assertTrue(history.retrieve(1)["metadata"]["sys_metadata"]["timestamp"])\n+        self.assertTrue(history.retrieve(0)["metadata"]["sys_metadata"]["principal"])\n         # check if correct data and metadata retrieved\n         self.assertEqual(\n-            history.retrieve(0)[\'metadata\'][\'app_metadata\'], \'save number 1\'\n+            history.retrieve(0)["metadata"]["app_metadata"], "save number 1"\n         )\n         self.assertEqual(\n-            history.retrieve(1)[\'metadata\'][\'app_metadata\'], \'save number 2\'\n+            history.retrieve(1)["metadata"]["app_metadata"], "save number 2"\n         )\n \n     def test09_getHistoryMetadata_byId(self):\n         portal_archivist = self.portal.portal_archivist\n         doc = self.portal.doc\n \n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n \n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n \n         # retrieve the history by history id\n@@ -374,14 +374,14 @@ def test09_getHistoryMetadata_byId(self):\n \n         self.assertEqual(len(history), 2)\n         # check if timestamp and principal available\n-        self.assertTrue(history.retrieve(1)[\'metadata\'][\'sys_metadata\'][\'timestamp\'])\n-        self.assertTrue(history.retrieve(0)[\'metadata\'][\'sys_metadata\'][\'principal\'])\n+        self.assertTrue(history.retrieve(1)["metadata"]["sys_metadata"]["timestamp"])\n+        self.assertTrue(history.retrieve(0)["metadata"]["sys_metadata"]["principal"])\n         # check if correct data and metadata retrieved\n         self.assertEqual(\n-            history.retrieve(0)[\'metadata\'][\'app_metadata\'], \'save number 1\'\n+            history.retrieve(0)["metadata"]["app_metadata"], "save number 1"\n         )\n         self.assertEqual(\n-            history.retrieve(1)[\'metadata\'][\'app_metadata\'], \'save number 2\'\n+            history.retrieve(1)["metadata"]["app_metadata"], "save number 2"\n         )\n \n \ndiff --git a/Products/CMFEditions/tests/test_ContentTypes.py b/Products/CMFEditions/tests/test_ContentTypes.py\nindex 1fcebbe..439ce5b 100644\n--- a/Products/CMFEditions/tests/test_ContentTypes.py\n+++ b/Products/CMFEditions/tests/test_ContentTypes.py\n@@ -11,7 +11,7 @@\n \n \n def read_image(file_path):\n-    with open(os.path.join(PACKAGE_HOME, file_path), \'rb\') as image:\n+    with open(os.path.join(PACKAGE_HOME, file_path), "rb") as image:\n         data = image.read()\n     return data\n \n@@ -24,111 +24,111 @@ def setUp(self):\n         self.workflow = self.portal.portal_workflow\n         self.portal_repository = self.portal.portal_repository\n         self.portal_archivist = self.portal.portal_archivist\n-        _createObjectByType(\'Folder\', self.portal, id=\'folder\')\n+        _createObjectByType("Folder", self.portal, id="folder")\n         self.folder = self.portal.folder\n \n     def getPermissionsOfRole(self, role):\n         perms = self.portal.permissionsOfRole(role)\n-        return [p[\'name\'] for p in perms if p[\'selected\']]\n+        return [p["name"] for p in perms if p["selected"]]\n \n     def metadata_test_one(self, obj):\n-        self.assertEqual(obj.Title(), \'content\')\n-        self.assertEqual(obj.Subject(), (\'content\',))\n-        self.assertEqual(obj.Description(), \'content\')\n-        self.assertEqual(obj.Contributors(), (\'content\',))\n-        self.assertEqual(obj.Language(), \'content\')\n-        self.assertEqual(obj.Rights(), \'content\')\n+        self.assertEqual(obj.Title(), "content")\n+        self.assertEqual(obj.Subject(), ("content",))\n+        self.assertEqual(obj.Description(), "content")\n+        self.assertEqual(obj.Contributors(), ("content",))\n+        self.assertEqual(obj.Language(), "content")\n+        self.assertEqual(obj.Rights(), "content")\n \n     def metadata_test_two(self, obj):\n-        self.assertEqual(obj.Title(), \'contentOK\')\n-        self.assertEqual(obj.Subject(), (\'contentOK\',))\n-        self.assertEqual(obj.Description(), \'contentOK\')\n-        self.assertEqual(obj.Contributors(), (\'contentOK\',))\n-        self.assertEqual(obj.Language(), \'contentOK\')\n-        self.assertEqual(obj.Rights(), \'contentOK\')\n+        self.assertEqual(obj.Title(), "contentOK")\n+        self.assertEqual(obj.Subject(), ("contentOK",))\n+        self.assertEqual(obj.Description(), "contentOK")\n+        self.assertEqual(obj.Contributors(), ("contentOK",))\n+        self.assertEqual(obj.Language(), "contentOK")\n+        self.assertEqual(obj.Rights(), "contentOK")\n \n     def testDocument(self):\n-        self.folder.invokeFactory(\'Document\', id=\'doc\')\n+        self.folder.invokeFactory("Document", id="doc")\n         portal_repository = self.portal_repository\n         content = self.folder.doc\n-        content.text = RichTextValue(u\'text v1\', \'text/plain\', \'text/plain\')\n-        content.title = u\'content\'\n-        content.subject = [u\'content\']\n-        content.description = u\'content\'\n-        content.contributors = [u\'content\']\n-        content.language = \'content\'\n-        content.rights = u\'content\'\n-        portal_repository.applyVersionControl(content, comment=\'save no 1\')\n-        content.text = RichTextValue(u\'text v2\', \'text/plain\', \'text/plain\')\n-        content.title = u\'contentOK\'\n-        content.subject = [u\'contentOK\']\n-        content.description = u\'contentOK\'\n-        content.contributors = [u\'contentOK\']\n-        content.language = \'contentOK\'\n-        content.rights = u\'contentOK\'\n-        portal_repository.save(content, comment=\'save no 2\')\n+        content.text = RichTextValue(u"text v1", "text/plain", "text/plain")\n+        content.title = u"content"\n+        content.subject = [u"content"]\n+        content.description = u"content"\n+        content.contributors = [u"content"]\n+        content.language = "content"\n+        content.rights = u"content"\n+        portal_repository.applyVersionControl(content, comment="save no 1")\n+        content.text = RichTextValue(u"text v2", "text/plain", "text/plain")\n+        content.title = u"contentOK"\n+        content.subject = [u"contentOK"]\n+        content.description = u"contentOK"\n+        content.contributors = [u"contentOK"]\n+        content.language = "contentOK"\n+        content.rights = u"contentOK"\n+        portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n-        self.assertEqual(obj.text.raw, \'text v1\')\n+        self.assertEqual(obj.text.raw, "text v1")\n         self.metadata_test_one(obj)\n         obj = portal_repository.retrieve(content, 1).object\n-        self.assertEqual(obj.text.raw, \'text v2\')\n+        self.assertEqual(obj.text.raw, "text v2")\n         self.metadata_test_two(obj)\n         portal_repository.revert(content, 0)\n-        self.assertEqual(content.text.raw, \'text v1\')\n+        self.assertEqual(content.text.raw, "text v1")\n         self.metadata_test_one(content)\n \n     def testNewsItem(self):\n-        self.folder.invokeFactory(\'News Item\', id=\'news_one\')\n+        self.folder.invokeFactory("News Item", id="news_one")\n         portal_repository = self.portal_repository\n         content = self.folder.news_one\n-        content.text = RichTextValue(u\'text v1\', \'text/plain\', \'text/plain\')\n-        content.title = u\'content\'\n-        content.subject = [u\'content\']\n-        content.description = u\'content\'\n-        content.contributors = [u\'content\']\n-        content.language = \'content\'\n-        content.rights = u\'content\'\n-        portal_repository.applyVersionControl(content, comment=\'save no 1\')\n-        content.text = RichTextValue(u\'text v2\', \'text/plain\', \'text/plain\')\n-        content.title = u\'contentOK\'\n-        content.subject = [u\'contentOK\']\n-        content.description = u\'contentOK\'\n-        content.contributors = [u\'contentOK\']\n-        content.language = \'contentOK\'\n-        content.rights = u\'contentOK\'\n-        portal_repository.save(content, comment=\'save no 2\')\n+        content.text = RichTextValue(u"text v1", "text/plain", "text/plain")\n+        content.title = u"content"\n+        content.subject = [u"content"]\n+        content.description = u"content"\n+        content.contributors = [u"content"]\n+        content.language = "content"\n+        content.rights = u"content"\n+        portal_repository.applyVersionControl(content, comment="save no 1")\n+        content.text = RichTextValue(u"text v2", "text/plain", "text/plain")\n+        content.title = u"contentOK"\n+        content.subject = [u"contentOK"]\n+        content.description = u"contentOK"\n+        content.contributors = [u"contentOK"]\n+        content.language = "contentOK"\n+        content.rights = u"contentOK"\n+        portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n-        self.assertEqual(obj.text.raw, \'text v1\')\n+        self.assertEqual(obj.text.raw, "text v1")\n         self.metadata_test_one(obj)\n         obj = portal_repository.retrieve(content, 1).object\n-        self.assertEqual(obj.text.raw, \'text v2\')\n+        self.assertEqual(obj.text.raw, "text v2")\n         self.metadata_test_two(obj)\n         portal_repository.revert(content, 0)\n-        self.assertEqual(content.text.raw, \'text v1\')\n+        self.assertEqual(content.text.raw, "text v1")\n         self.metadata_test_one(content)\n \n     def testImage(self):\n-        self.folder.invokeFactory(\'Image\', id=\'image\')\n+        self.folder.invokeFactory("Image", id="image")\n         portal_repository = self.portal_repository\n-        img1 = read_image(\'tests/images/img1.png\')\n-        img2 = read_image(\'tests/images/img2.png\')\n+        img1 = read_image("tests/images/img1.png")\n+        img2 = read_image("tests/images/img2.png")\n         content = self.folder.image\n-        content.image = NamedBlobImage(img1, u\'img1.png\', u\'image/png\')\n-        content.title = u\'content\'\n-        content.subject = [u\'content\']\n-        content.description = u\'content\'\n-        content.contributors = [u\'content\']\n-        content.language = \'content\'\n-        content.rights = u\'content\'\n-        portal_repository.applyVersionControl(content, comment=\'save no 1\')\n-        content.image = NamedBlobImage(img2, u\'img2.png\', u\'image/png\')\n-        content.title = u\'contentOK\'\n-        content.subject = [u\'contentOK\']\n-        content.description = u\'contentOK\'\n-        content.contributors = [u\'contentOK\']\n-        content.language = \'contentOK\'\n-        content.rights = u\'contentOK\'\n-        portal_repository.save(content, comment=\'save no 2\')\n+        content.image = NamedBlobImage(img1, u"img1.png", u"image/png")\n+        content.title = u"content"\n+        content.subject = [u"content"]\n+        content.description = u"content"\n+        content.contributors = [u"content"]\n+        content.language = "content"\n+        content.rights = u"content"\n+        portal_repository.applyVersionControl(content, comment="save no 1")\n+        content.image = NamedBlobImage(img2, u"img2.png", u"image/png")\n+        content.title = u"contentOK"\n+        content.subject = [u"contentOK"]\n+        content.description = u"contentOK"\n+        content.contributors = [u"contentOK"]\n+        content.language = "contentOK"\n+        content.rights = u"contentOK"\n+        portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n         self.assertEqual(obj.image.data, img1)\n         self.metadata_test_one(obj)\n@@ -140,27 +140,27 @@ def testImage(self):\n         self.metadata_test_one(content)\n \n     def testFile(self):\n-        self.folder.invokeFactory(\'File\', id=\'file\')\n-        file1 = read_image(\'tests/images/img1.png\')\n-        file2 = read_image(\'tests/images/img2.png\')\n+        self.folder.invokeFactory("File", id="file")\n+        file1 = read_image("tests/images/img1.png")\n+        file2 = read_image("tests/images/img2.png")\n         portal_repository = self.portal_repository\n         content = self.folder.file\n-        content.file = NamedBlobFile(file1, u\'img1.png\', u\'image/png\')\n-        content.title = u\'content\'\n-        content.subject = [u\'content\']\n-        content.description = u\'content\'\n-        content.contributors = [u\'content\']\n-        content.language = \'content\'\n-        content.rights = u\'content\'\n-        portal_repository.applyVersionControl(content, comment=\'save no 1\')\n-        content.file = NamedBlobImage(file2, u\'img2.png\', u\'image/png\')\n-        content.title = u\'contentOK\'\n-        content.subject = [u\'contentOK\']\n-        content.description = u\'contentOK\'\n-        content.contributors = [u\'contentOK\']\n-        content.language = \'contentOK\'\n-        content.rights = u\'contentOK\'\n-        portal_repository.save(content, comment=\'save no 2\')\n+        content.file = NamedBlobFile(file1, u"img1.png", u"image/png")\n+        content.title = u"content"\n+        content.subject = [u"content"]\n+        content.description = u"content"\n+        content.contributors = [u"content"]\n+        content.language = "content"\n+        content.rights = u"content"\n+        portal_repository.applyVersionControl(content, comment="save no 1")\n+        content.file = NamedBlobImage(file2, u"img2.png", u"image/png")\n+        content.title = u"contentOK"\n+        content.subject = [u"contentOK"]\n+        content.description = u"contentOK"\n+        content.contributors = [u"contentOK"]\n+        content.language = "contentOK"\n+        content.rights = u"contentOK"\n+        portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n         self.assertEqual(obj.file.data, file1)\n         self.metadata_test_one(obj)\n@@ -172,23 +172,23 @@ def testFile(self):\n         self.metadata_test_one(content)\n \n     def testFolder(self):\n-        self.folder.invokeFactory(\'Image\', id=\'folder\')\n+        self.folder.invokeFactory("Image", id="folder")\n         portal_repository = self.portal_repository\n         content = self.folder.folder\n-        content.title = u\'content\'\n-        content.subject = [u\'content\']\n-        content.description = u\'content\'\n-        content.contributors = [u\'content\']\n-        content.language = \'content\'\n-        content.rights = u\'content\'\n-        portal_repository.applyVersionControl(content, comment=\'save no 1\')\n-        content.title = u\'contentOK\'\n-        content.subject = [u\'contentOK\']\n-        content.description = u\'contentOK\'\n-        content.contributors = [u\'contentOK\']\n-        content.language = \'contentOK\'\n-        content.rights = u\'contentOK\'\n-        portal_repository.save(content, comment=\'save no 2\')\n+        content.title = u"content"\n+        content.subject = [u"content"]\n+        content.description = u"content"\n+        content.contributors = [u"content"]\n+        content.language = "content"\n+        content.rights = u"content"\n+        portal_repository.applyVersionControl(content, comment="save no 1")\n+        content.title = u"contentOK"\n+        content.subject = [u"contentOK"]\n+        content.description = u"contentOK"\n+        content.contributors = [u"contentOK"]\n+        content.language = "contentOK"\n+        content.rights = u"contentOK"\n+        portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n         self.metadata_test_one(obj)\n         obj = portal_repository.retrieve(content, 1).object\ndiff --git a/Products/CMFEditions/tests/test_IntegrationTests.py b/Products/CMFEditions/tests/test_IntegrationTests.py\nindex 8acda81..177b469 100644\n--- a/Products/CMFEditions/tests/test_IntegrationTests.py\n+++ b/Products/CMFEditions/tests/test_IntegrationTests.py\n@@ -43,21 +43,21 @@ def setUp(self):\n         super(TestIntegration, self).setUp()\n \n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\', [\'Manager\'], \'\')\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n         # add a document\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n+        self.portal.invokeFactory("Document", "doc")\n \n         # add a folder with two documents in it\n-        self.portal.invokeFactory(\'Folder\', \'fol\')\n-        self.portal.fol.invokeFactory(\'Document\', \'doc1\')\n-        self.portal.fol.invokeFactory(\'Document\', \'doc2\')\n+        self.portal.invokeFactory("Folder", "fol")\n+        self.portal.fol.invokeFactory("Document", "doc1")\n+        self.portal.fol.invokeFactory("Document", "doc2")\n \n     def test01_assertApplyVersionControlSavesOnlyOnce(self):\n         portal_repo = self.portal.portal_repository\n         doc = self.portal.doc\n \n-        doc.setTitle(\'doc title v1\')\n-        portal_repo.applyVersionControl(doc, comment=\'First version\')\n+        doc.setTitle("doc title v1")\n+        portal_repo.applyVersionControl(doc, comment="First version")\n \n         # there should be only one history entry and not two or more\n         self.assertEqual(len(portal_repo.getHistory(doc)), 1)\n@@ -144,7 +144,7 @@ def test06_retrieveSpecificVersion(self):\n         portal_repo = self.portal.portal_repository\n         doc = self.portal.doc\n \n-        review_state = self.portal.portal_workflow.getInfoFor(doc, \'review_state\')\n+        review_state = self.portal.portal_workflow.getInfoFor(doc, "review_state")\n \n         # store the work edition two times\n         doc.setTitle("v1")\n@@ -175,7 +175,7 @@ def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):\n         portal_repo.applyVersionControl(doc)\n \n         # copy\n-        self.portal.manage_pasteObjects(self.portal.manage_copyObjects(ids=[\'doc\']))\n+        self.portal.manage_pasteObjects(self.portal.manage_copyObjects(ids=["doc"]))\n         copy = self.portal.copy_of_doc\n \n         # the copy shall not have a history yet: that\'s correct\n@@ -221,7 +221,7 @@ def test09_retrieveAndRevertRetainWorkingCopiesWorkflowInfo(self):\n         # ----- retrieve\n         # check if retrieved object carries the working copies workflow info\n         retrieved_data = portal_repo.retrieve(\n-            doc, 0, preserve=[\'review_state\', \'workflow_history\']\n+            doc, 0, preserve=["review_state", "workflow_history"]\n         )\n         self.assertEqual(retrieved_data.object.review_state, "fake rev state v2")\n         self.assertEqual(\n@@ -233,9 +233,9 @@ def test09_retrieveAndRevertRetainWorkingCopiesWorkflowInfo(self):\n         self.assertEqual(doc.workflow_history[0], "fake wf history v2")\n \n         # check if the preserved data is returned correctly\n-        preserved_rvs = retrieved_data.preserved_data[\'review_state\']\n+        preserved_rvs = retrieved_data.preserved_data["review_state"]\n         self.assertEqual(preserved_rvs, "fake rev state v1")\n-        preserved_wfh = retrieved_data.preserved_data[\'workflow_history\'][0]\n+        preserved_wfh = retrieved_data.preserved_data["workflow_history"][0]\n         self.assertEqual(preserved_wfh, "fake wf history v1")\n \n         # ----- revert\n@@ -251,20 +251,20 @@ def test10_versionAStandardFolder(self):\n         doc2 = fol.doc2\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         # save change no 2\n-        fol.setTitle(\'v2 of fol\')\n+        fol.setTitle("v2 of fol")\n         doc1.setTitle("v2 of doc1")\n         doc2.setTitle("v2 of doc2")\n-        portal_repo.save(fol, comment=\'second save\')\n+        portal_repo.save(fol, comment="second save")\n \n         # change no 3 (without saving)\n-        fol.setTitle(\'v3 of fol\')\n+        fol.setTitle("v3 of fol")\n         doc1.setTitle("v3 of doc1")\n         doc2.setTitle("v3 of doc2")\n \n@@ -299,27 +299,27 @@ def test11_versionAFolderishObjectThatTreatsChildrensAsInsideRefs(self):\n         )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n         orig_uid1 = portal_historyidhandler.queryUid(doc1)\n         orig_uid2 = portal_historyidhandler.queryUid(doc2)\n \n         # save change no 2\n-        fol.setTitle(\'v2 of fol\')\n+        fol.setTitle("v2 of fol")\n         doc1.setTitle("v2 of doc1")\n         doc2.setTitle("v2 of doc2")\n-        portal_repo.save(fol, comment=\'second save after we deleted doc2\')\n+        portal_repo.save(fol, comment="second save after we deleted doc2")\n \n         # save change no 3\n-        fol.setTitle(\'v3 of fol\')\n+        fol.setTitle("v3 of fol")\n         doc1.setTitle("v3 of doc1")\n-        fol.manage_delObjects(ids=[\'doc2\'])\n-        fol.invokeFactory(\'Document\', \'doc3\')\n+        fol.manage_delObjects(ids=["doc2"])\n+        fol.invokeFactory("Document", "doc3")\n         doc3 = fol.doc3\n         doc3.setTitle("v1 of doc3")\n-        portal_repo.save(fol, comment=\'second save with new doc3\')\n+        portal_repo.save(fol, comment="second save with new doc3")\n \n         # revert to change no 1 (version idexes start with index 0)\n         portal_repo.revert(fol, selector=1)\n@@ -327,8 +327,8 @@ def test11_versionAFolderishObjectThatTreatsChildrensAsInsideRefs(self):\n         # check if revertion worked correctly\n         fol = self.portal.fol\n         doc1 = fol.doc1\n-        self.assertTrue(\'doc2\' in fol.objectIds())\n-        self.assertFalse(\'doc3\' in fol.objectIds())\n+        self.assertTrue("doc2" in fol.objectIds())\n+        self.assertFalse("doc3" in fol.objectIds())\n         doc2 = fol.doc2\n         self.assertEqual(fol.Title(), "v2 of fol")\n         self.assertEqual(doc1.Title(), "v2 of doc1")\n@@ -339,89 +339,89 @@ def test11_versionAFolderishObjectThatTreatsChildrensAsInsideRefs(self):\n     def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):\n         portal_repo = self.portal.portal_repository\n         doc = self.portal.doc\n-        perm = \'Access contents information\'\n-        member_role = \'permission_{0}role_{1}\'.format(\n-            _string_hash(perm), _string_hash(\'Member\')\n+        perm = "Access contents information"\n+        member_role = "permission_{0}role_{1}".format(\n+            _string_hash(perm), _string_hash("Member")\n         )\n \n-        doc.manage_permission(perm, (\'Manager\',), 0)\n+        doc.manage_permission(perm, ("Manager",), 0)\n \n         portal_repo.applyVersionControl(doc)\n \n-        doc.manage_permission(perm, (\'Manager\', \'Member\'), 1)\n+        doc.manage_permission(perm, ("Manager", "Member"), 1)\n         portal_repo.save(doc)\n \n         # just check the original is unchanged\n         settings = doc.permission_settings(perm)[0]\n-        self.assertTrue(settings[\'acquire\'])\n-        role_enabled = [r for r in settings[\'roles\'] if r[\'name\'] == member_role][0]\n-        self.assertTrue(role_enabled[\'checked\'])\n+        self.assertTrue(settings["acquire"])\n+        role_enabled = [r for r in settings["roles"] if r["name"] == member_role][0]\n+        self.assertTrue(role_enabled["checked"])\n \n         # ----- retrieve\n         # check if retrieved object carries the working copy\'s permissions\n         retrieved_data = portal_repo.retrieve(\n-            doc, 0, preserve=[\'_Access_contents_information_Permission\']\n+            doc, 0, preserve=["_Access_contents_information_Permission"]\n         )\n         settings = retrieved_data.object.permission_settings(perm)[0]\n-        self.assertTrue(settings[\'acquire\'])\n-        role_enabled = [r for r in settings[\'roles\'] if r[\'name\'] == member_role][0]\n-        self.assertTrue(role_enabled[\'checked\'])\n+        self.assertTrue(settings["acquire"])\n+        role_enabled = [r for r in settings["roles"] if r["name"] == member_role][0]\n+        self.assertTrue(role_enabled["checked"])\n \n         # check that the working copy\'s permissions are unchanged\n         settings = doc.permission_settings(perm)[0]\n-        self.assertTrue(settings[\'acquire\'])\n-        role_enabled = [r for r in settings[\'roles\'] if r[\'name\'] == member_role][0]\n-        self.assertTrue(role_enabled[\'checked\'])\n+        self.assertTrue(settings["acquire"])\n+        role_enabled = [r for r in settings["roles"] if r["name"] == member_role][0]\n+        self.assertTrue(role_enabled["checked"])\n \n         # check if the preserved data is returned correctly\n         preserved = retrieved_data.preserved_data[\n-            \'_Access_contents_information_Permission\'\n+            "_Access_contents_information_Permission"\n         ]  # noqa\n-        self.assertEqual(preserved, (\'Manager\',))\n+        self.assertEqual(preserved, ("Manager",))\n \n         # ----- revert\n         # check that the working copies permissions are unchanged after revert\n         portal_repo.revert(doc, 0)\n         settings = doc.permission_settings(perm)[0]\n-        self.assertTrue(settings[\'acquire\'])\n-        role_enabled = [r for r in settings[\'roles\'] if r[\'name\'] == member_role][0]\n-        self.assertTrue(role_enabled[\'checked\'])\n+        self.assertTrue(settings["acquire"])\n+        role_enabled = [r for r in settings["roles"] if r["name"] == member_role][0]\n+        self.assertTrue(role_enabled["checked"])\n \n     def test13_revertUpdatesCatalog(self):\n         portal_repo = self.portal.portal_repository\n         cat = self.portal.portal_catalog\n         doc = self.portal.doc\n \n-        doc.text = RichTextValue(u\'Plain text\', \'text/plain\', \'text/plain\')\n+        doc.text = RichTextValue(u"Plain text", "text/plain", "text/plain")\n         portal_repo.applyVersionControl(doc)\n-        doc.text = RichTextValue(u\'blahblah\', \'text/plain\', \'text/plain\')\n+        doc.text = RichTextValue(u"blahblah", "text/plain", "text/plain")\n         portal_repo.save(doc)\n         # Test that catalog has current value\n-        results = cat(SearchableText=\'Plain Text\')\n+        results = cat(SearchableText="Plain Text")\n         self.assertEqual(len(results), 0)\n-        results = cat(SearchableText=\'blahblah\')\n+        results = cat(SearchableText="blahblah")\n         self.assertEqual(len(results), 1)\n         self.assertEqual(results[0].getObject(), doc)\n \n         retrieved_data = portal_repo.retrieve(\n-            doc, 0, preserve=[\'_Access_contents_information_Permission\']\n+            doc, 0, preserve=["_Access_contents_information_Permission"]\n         )\n         retrieved_doc = retrieved_data.object\n-        self.assertTrue(\'Plain text\' in retrieved_doc.text.raw)\n+        self.assertTrue("Plain text" in retrieved_doc.text.raw)\n         # Test that basic retrieval did not alter the catalog\n-        results = cat(SearchableText=\'Plain Text\')\n+        results = cat(SearchableText="Plain Text")\n         self.assertEqual(len(results), 0)\n-        results = cat(SearchableText=\'blahblah\')\n+        results = cat(SearchableText="blahblah")\n         self.assertEqual(len(results), 1)\n         self.assertEqual(results[0].getObject(), doc)\n \n         portal_repo.revert(doc, 0)\n         # Test that the catalog is updated on revert\n-        results = cat(SearchableText=\'blahblah\')\n+        results = cat(SearchableText="blahblah")\n         self.assertEqual(len(results), 0)\n-        results = cat(SearchableText=\'Plain Text\')\n+        results = cat(SearchableText="Plain Text")\n         self.assertEqual(len(results), 1)\n-        self.assertEqual(results[0].getObject().text.raw, \'Plain text\')\n+        self.assertEqual(results[0].getObject().text.raw, "Plain text")\n \n     def test14_retrieveFolderWithAddedOrDeletedObjects(self):\n         portal_repo = self.portal.portal_repository\n@@ -430,11 +430,11 @@ def test14_retrieveFolderWithAddedOrDeletedObjects(self):\n         doc2 = fol.doc2\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n@@ -442,7 +442,7 @@ def test14_retrieveFolderWithAddedOrDeletedObjects(self):\n         self.assertEqual(tuple(ret_folder.objectValues()), tuple(fol.objectValues()))\n \n         # remove an item\n-        fol.manage_delObjects(\'doc2\')\n+        fol.manage_delObjects("doc2")\n \n         # retrieve should update sub-objects\n         retrieved_data = portal_repo.retrieve(fol, 0)\n@@ -451,28 +451,28 @@ def test14_retrieveFolderWithAddedOrDeletedObjects(self):\n         self.assertEqual(tuple(ret_folder.objectValues()), tuple(fol.objectValues()))\n \n         # add it back\n-        fol.invokeFactory(\'Document\', \'doc2\')\n+        fol.invokeFactory("Document", "doc2")\n         doc2 = fol.doc2\n-        doc2.setTitle(\'v2 of doc2\')\n+        doc2.setTitle("v2 of doc2")\n \n         # retrieve should update sub-objects\n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n         self.assertEqual(ret_folder.objectIds(), fol.objectIds())\n         self.assertEqual(tuple(ret_folder.objectValues()), tuple(fol.objectValues()))\n-        self.assertEqual(ret_folder.doc2.Title(), \'v2 of doc2\')\n+        self.assertEqual(ret_folder.doc2.Title(), "v2 of doc2")\n \n         # add new item\n-        fol.invokeFactory(\'Document\', \'doc3\')\n+        fol.invokeFactory("Document", "doc3")\n         doc3 = fol.doc3\n-        doc3.setTitle(\'v1 of doc3\')\n+        doc3.setTitle("v1 of doc3")\n \n         # retrieve should copy new sub-objects\n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n         self.assertEqual(ret_folder.objectIds(), fol.objectIds())\n         self.assertEqual(tuple(ret_folder.objectValues()), tuple(fol.objectValues()))\n-        self.assertEqual(ret_folder.doc3.Title(), \'v1 of doc3\')\n+        self.assertEqual(ret_folder.doc3.Title(), "v1 of doc3")\n \n         orig_ids = fol.objectIds()\n         orig_values = fol.objectValues()\n@@ -505,14 +505,14 @@ def test15_retrieveInsideRefsFolderWithAddedOrDeletedObjects(self):\n         )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n         orig_ids = fol.objectIds()\n         orig_values = fol.objectValues()\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n@@ -525,7 +525,7 @@ def test15_retrieveInsideRefsFolderWithAddedOrDeletedObjects(self):\n             self.assertEqual(ret_values[i].Title(), orig_values[i].Title())\n \n         # remove an item\n-        fol.manage_delObjects(\'doc2\')\n+        fol.manage_delObjects("doc2")\n         processQueue()\n \n         cur_ids = fol.objectIds()\n@@ -543,9 +543,9 @@ def test15_retrieveInsideRefsFolderWithAddedOrDeletedObjects(self):\n         self.assertEqual(fol.objectIds(), cur_ids)\n \n         # add new item\n-        fol.invokeFactory(\'Document\', \'doc3\')\n+        fol.invokeFactory("Document", "doc3")\n         doc3 = fol.doc3\n-        doc3.setTitle(\'v1 of doc3\')\n+        doc3.setTitle("v1 of doc3")\n \n         cur_ids = fol.objectIds()\n         self.assertEqual(len(cur_ids), 2)\n@@ -591,49 +591,49 @@ def test16_revertInsideRefsUpdatesCatalog(self):\n         )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc.setTitle("v1 of doc1")\n         fol.reindexObject()\n         doc.reindexObject()\n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         # save change no 2\n-        fol.setTitle(\'v2 of fol\')\n+        fol.setTitle("v2 of fol")\n         doc.setTitle("v2 of doc1")\n         fol.reindexObject()\n         doc.reindexObject()\n-        portal_repo.save(fol, comment=\'second save\')\n+        portal_repo.save(fol, comment="second save")\n \n         # Test that catalog has current value\n-        results = cat(SearchableText=\'v1\')\n+        results = cat(SearchableText="v1")\n         self.assertEqual(len(results), 0)\n-        results = cat(SearchableText=\'v2\', portal_type=\'Document\')\n+        results = cat(SearchableText="v2", portal_type="Document")\n         self.assertEqual(len(results), 1)\n         self.assertEqual(results[0].getObject(), doc)\n \n         retrieved_data = portal_repo.retrieve(\n-            fol, 0, preserve=[\'_Access_contents_information_Permission\']\n+            fol, 0, preserve=["_Access_contents_information_Permission"]\n         )\n         retrieved_doc = retrieved_data.object.doc1\n-        self.assertEqual(retrieved_doc.Title(), \'v1 of doc1\')\n+        self.assertEqual(retrieved_doc.Title(), "v1 of doc1")\n         # Test that basic retrieval did not alter the catalog\n         results = cat(\n-            SearchableText=\'v1\',\n+            SearchableText="v1",\n         )\n         self.assertEqual(len(results), 0)\n-        results = cat(SearchableText=\'v2\', portal_type=\'Document\')\n+        results = cat(SearchableText="v2", portal_type="Document")\n         self.assertEqual(len(results), 1)\n         self.assertEqual(results[0].getObject(), doc)\n \n         portal_repo.revert(fol, 0)\n         reverted_doc = self.portal.fol.doc1\n-        self.assertEqual(reverted_doc.Title(), \'v1 of doc1\')\n+        self.assertEqual(reverted_doc.Title(), "v1 of doc1")\n         # Test that the catalog is updated on revert\n-        results = cat(SearchableText=\'v2\')\n+        results = cat(SearchableText="v2")\n         self.assertEqual(len(results), 0)\n-        results = cat(SearchableText=\'v1\', portal_type=\'Document\')\n+        results = cat(SearchableText="v1", portal_type="Document")\n         self.assertEqual(len(results), 1)\n-        self.assertEqual(results[0].getObject().Title(), \'v1 of doc1\')\n+        self.assertEqual(results[0].getObject().Title(), "v1 of doc1")\n \n     def test17_moveInsideRefThenRevertChangesUid(self):\n         # When an object is contained in an \'Inside references folder\' and\n@@ -659,14 +659,14 @@ def test17_moveInsideRefThenRevertChangesUid(self):\n         )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n         orig_uid = portal_historyidhandler.queryUid(doc1)\n \n         transaction.savepoint(optimistic=True)\n-        self.portal.manage_pasteObjects(fol.manage_cutObjects(ids=[\'doc1\']))\n+        self.portal.manage_pasteObjects(fol.manage_cutObjects(ids=["doc1"]))\n         moved_doc = self.portal.doc1\n         self.assertEqual(portal_historyidhandler.queryUid(moved_doc), orig_uid)\n         transaction.savepoint(optimistic=True)\n@@ -699,34 +699,34 @@ def test18_retrieveObjectWhichHasBeenReplaced(self):\n         doc2 = fol.doc2\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n-        portal_repo.applyVersionControl(doc1, comment=\'first save\')\n-        portal_repo.applyVersionControl(doc2, comment=\'first save\')\n+        portal_repo.applyVersionControl(doc1, comment="first save")\n+        portal_repo.applyVersionControl(doc2, comment="first save")\n \n         transaction.savepoint(optimistic=True)\n-        fol.manage_renameObjects([\'doc1\', \'doc2\'], [\'doc1_renamed\', \'doc1\'])\n+        fol.manage_renameObjects(["doc1", "doc2"], ["doc1_renamed", "doc1"])\n \n         doc1 = fol.doc1_renamed\n         doc2 = fol.doc1\n \n-        doc1.setTitle(\'v2 of doc1_renamed\')\n-        doc2.setTitle(\'v2 of doc1 (was doc2)\')\n+        doc1.setTitle("v2 of doc1_renamed")\n+        doc2.setTitle("v2 of doc1 (was doc2)")\n \n-        portal_repo.save(doc1, comment=\'second save\')\n-        portal_repo.save(doc2, comment=\'second save\')\n+        portal_repo.save(doc1, comment="second save")\n+        portal_repo.save(doc2, comment="second save")\n \n         retrieved_data = portal_repo.retrieve(doc1, 0)\n         ret_doc = retrieved_data.object\n-        self.assertEqual(ret_doc.getId(), \'doc1\')\n-        self.assertEqual(ret_doc.Title(), \'v1 of doc1\')\n+        self.assertEqual(ret_doc.getId(), "doc1")\n+        self.assertEqual(ret_doc.Title(), "v1 of doc1")\n \n         portal_repo.revert(doc1, 0)\n         rev_doc = fol.doc1_renamed\n-        self.assertEqual(rev_doc.getId(), \'doc1_renamed\')\n-        self.assertEqual(rev_doc.Title(), \'v1 of doc1\')\n+        self.assertEqual(rev_doc.getId(), "doc1_renamed")\n+        self.assertEqual(rev_doc.Title(), "v1 of doc1")\n \n     def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolder(\n         self,\n@@ -753,42 +753,42 @@ def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolde\n         )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n-        fol.manage_delObjects([\'doc1\'])\n+        fol.manage_delObjects(["doc1"])\n         transaction.savepoint(optimistic=True)\n-        fol.manage_renameObjects([\'doc2\'], [\'doc1\'])\n+        fol.manage_renameObjects(["doc2"], ["doc1"])\n \n         doc2 = fol.doc1\n \n-        doc1.setTitle(\'v2 of doc1_renamed\')\n-        doc2.setTitle(\'v2 of doc1 (was doc2)\')\n+        doc1.setTitle("v2 of doc1_renamed")\n+        doc2.setTitle("v2 of doc1 (was doc2)")\n \n-        portal_repo.save(fol, comment=\'second save\')\n+        portal_repo.save(fol, comment="second save")\n \n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_fol = retrieved_data.object\n-        self.assertEqual(ret_fol.objectIds(), [\'doc1\', \'doc2\'])\n+        self.assertEqual(ret_fol.objectIds(), ["doc1", "doc2"])\n         ret_doc1 = ret_fol.doc1\n         ret_doc2 = ret_fol.doc2\n-        self.assertEqual(ret_doc1.getId(), \'doc1\')\n-        self.assertEqual(ret_doc1.Title(), \'v1 of doc1\')\n-        self.assertEqual(ret_doc2.getId(), \'doc2\')\n-        self.assertEqual(ret_doc2.Title(), \'v1 of doc2\')\n+        self.assertEqual(ret_doc1.getId(), "doc1")\n+        self.assertEqual(ret_doc1.Title(), "v1 of doc1")\n+        self.assertEqual(ret_doc2.getId(), "doc2")\n+        self.assertEqual(ret_doc2.Title(), "v1 of doc2")\n \n         portal_repo.revert(fol, 0)\n         rev_fol = self.portal.fol\n-        self.assertEqual(rev_fol.objectIds(), [\'doc1\', \'doc2\'])\n+        self.assertEqual(rev_fol.objectIds(), ["doc1", "doc2"])\n         rev_doc1 = rev_fol.doc1\n         rev_doc2 = rev_fol.doc2\n-        self.assertEqual(rev_doc1.getId(), \'doc1\')\n-        self.assertEqual(rev_doc1.Title(), \'v1 of doc1\')\n-        self.assertEqual(rev_doc2.getId(), \'doc2\')\n-        self.assertEqual(rev_doc2.Title(), \'v1 of doc2\')\n+        self.assertEqual(rev_doc1.getId(), "doc1")\n+        self.assertEqual(rev_doc1.Title(), "v1 of doc1")\n+        self.assertEqual(rev_doc2.getId(), "doc2")\n+        self.assertEqual(rev_doc2.Title(), "v1 of doc2")\n \n     def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(\n         self,\n@@ -815,43 +815,43 @@ def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(\n         )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         transaction.savepoint(optimistic=True)\n-        self.portal.manage_pasteObjects(fol.manage_cutObjects([\'doc1\']))\n-        fol.manage_renameObjects([\'doc2\'], [\'doc1\'])\n+        self.portal.manage_pasteObjects(fol.manage_cutObjects(["doc1"]))\n+        fol.manage_renameObjects(["doc2"], ["doc1"])\n \n         doc2 = fol.doc1\n         doc1 = self.portal.doc1\n \n-        doc1.setTitle(\'v2 of doc1 (now in portal root)\')\n-        doc2.setTitle(\'v2 of doc1 (was doc2)\')\n+        doc1.setTitle("v2 of doc1 (now in portal root)")\n+        doc2.setTitle("v2 of doc1 (was doc2)")\n \n-        portal_repo.save(fol, comment=\'second save\')\n+        portal_repo.save(fol, comment="second save")\n \n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_fol = retrieved_data.object\n-        self.assertEqual(ret_fol.objectIds(), [\'doc1\', \'doc2\'])\n+        self.assertEqual(ret_fol.objectIds(), ["doc1", "doc2"])\n         ret_doc1 = ret_fol.doc1\n         ret_doc2 = ret_fol.doc2\n-        self.assertEqual(ret_doc1.getId(), \'doc1\')\n-        self.assertEqual(ret_doc1.Title(), \'v1 of doc1\')\n-        self.assertEqual(ret_doc2.getId(), \'doc2\')\n-        self.assertEqual(ret_doc2.Title(), \'v1 of doc2\')\n+        self.assertEqual(ret_doc1.getId(), "doc1")\n+        self.assertEqual(ret_doc1.Title(), "v1 of doc1")\n+        self.assertEqual(ret_doc2.getId(), "doc2")\n+        self.assertEqual(ret_doc2.Title(), "v1 of doc2")\n \n         retrieved_data = portal_repo.revert(fol, 0)\n         rev_fol = self.portal.fol\n-        self.assertEqual(rev_fol.objectIds(), [\'doc1\', \'doc2\'])\n+        self.assertEqual(rev_fol.objectIds(), ["doc1", "doc2"])\n         rev_doc1 = rev_fol.doc1\n         rev_doc2 = rev_fol.doc2\n-        self.assertEqual(rev_doc1.getId(), \'doc1\')\n-        self.assertEqual(rev_doc1.Title(), \'v1 of doc1\')\n-        self.assertEqual(rev_doc2.getId(), \'doc2\')\n-        self.assertEqual(rev_doc2.Title(), \'v1 of doc2\')\n+        self.assertEqual(rev_doc1.getId(), "doc1")\n+        self.assertEqual(rev_doc1.Title(), "v1 of doc1")\n+        self.assertEqual(rev_doc2.getId(), "doc2")\n+        self.assertEqual(rev_doc2.Title(), "v1 of doc2")\n \n     def test21_DontLeaveDanglingCatalogEntriesWhenInvokingFactory(self):\n         portal_repo = self.portal.portal_repository\n@@ -871,29 +871,29 @@ def test21_DontLeaveDanglingCatalogEntriesWhenInvokingFactory(self):\n         )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n-        self.assertEqual(len(catalog(getId=\'doc1\')), 1)\n+        self.assertEqual(len(catalog(getId="doc1")), 1)\n \n-        fol.manage_delObjects([\'doc2\', \'doc1\'])\n+        fol.manage_delObjects(["doc2", "doc1"])\n \n-        self.assertEqual(len(catalog(getId=\'doc1\')), 0)\n+        self.assertEqual(len(catalog(getId="doc1")), 0)\n \n-        portal_repo.save(fol, comment=\'second save\')\n+        portal_repo.save(fol, comment="second save")\n \n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_fol = retrieved_data.object\n-        self.assertEqual(ret_fol.objectIds(), [\'doc1\', \'doc2\'])\n-        self.assertEqual(len(catalog(getId=\'doc1\')), 0)\n+        self.assertEqual(ret_fol.objectIds(), ["doc1", "doc2"])\n+        self.assertEqual(len(catalog(getId="doc1")), 0)\n \n         portal_repo.revert(fol, 0)\n         rev_fol = self.portal.fol\n-        self.assertEqual(rev_fol.objectIds(), [\'doc1\', \'doc2\'])\n-        self.assertEqual(len(catalog(getId=\'doc1\')), 1)\n+        self.assertEqual(rev_fol.objectIds(), ["doc1", "doc2"])\n+        self.assertEqual(len(catalog(getId="doc1")), 1)\n \n     def test21_RevertObjectWithChangedIdMaintainsConsistentCatalog(self):\n         portal_repo = self.portal.portal_repository\n@@ -904,27 +904,27 @@ def test21_RevertObjectWithChangedIdMaintainsConsistentCatalog(self):\n         # save change no 1\n         doc1.setTitle("v1 of doc1")\n \n-        portal_repo.applyVersionControl(doc1, comment=\'first save\')\n+        portal_repo.applyVersionControl(doc1, comment="first save")\n \n-        self.assertEqual(len(catalog(getId=\'doc1\')), 1)\n+        self.assertEqual(len(catalog(getId="doc1")), 1)\n \n         doc1.setTitle("v2 of doc1")\n         transaction.savepoint()\n-        fol.manage_renameObject(\'doc1\', \'doc1_changed\')\n+        fol.manage_renameObject("doc1", "doc1_changed")\n         doc1 = fol.doc1_changed\n         doc1.reindexObject()\n \n-        self.assertEqual(len(catalog(getId=\'doc1\')), 0)\n-        self.assertEqual(len(catalog(getId=\'doc1_changed\')), 1)\n+        self.assertEqual(len(catalog(getId="doc1")), 0)\n+        self.assertEqual(len(catalog(getId="doc1_changed")), 1)\n \n-        portal_repo.save(doc1, comment=\'second save\')\n+        portal_repo.save(doc1, comment="second save")\n \n         portal_repo.revert(doc1, 0)\n         rev_doc = fol.doc1_changed\n         self.assertEqual(rev_doc.Title(), "v1 of doc1")\n-        self.assertEqual(len(catalog(getId=\'doc1\')), 0)\n-        self.assertEqual(len(catalog(getId=\'doc1_changed\')), 1)\n-        self.assertEqual(len(catalog(Title=\'v1 of doc1\')), 1)\n+        self.assertEqual(len(catalog(getId="doc1")), 0)\n+        self.assertEqual(len(catalog(getId="doc1_changed")), 1)\n+        self.assertEqual(len(catalog(Title="v1 of doc1")), 1)\n \n     def test21_RestoreMovedObject(self):\n         portal_repo = self.portal.portal_repository\n@@ -936,29 +936,29 @@ def test21_RestoreMovedObject(self):\n         # save change no 1\n         doc1.setTitle("v1 of doc1")\n \n-        portal_repo.applyVersionControl(doc1, comment=\'first save\')\n+        portal_repo.applyVersionControl(doc1, comment="first save")\n         # save the ``history_id`` to be able to retrieve the object after\n         # it\'s deletion\n         history_id = portal_hidhandler.queryUid(doc1)\n \n         doc1.setTitle("v2 of doc1")\n         transaction.savepoint()\n-        fol.manage_renameObject(\'doc1\', \'doc1_changed\')\n+        fol.manage_renameObject("doc1", "doc1_changed")\n         doc1 = fol.doc1_changed\n         doc1.reindexObject()\n \n-        self.assertEqual(len(catalog(getId=\'doc1\')), 0)\n-        self.assertEqual(len(catalog(getId=\'doc1_changed\')), 1)\n+        self.assertEqual(len(catalog(getId="doc1")), 0)\n+        self.assertEqual(len(catalog(getId="doc1_changed")), 1)\n \n-        portal_repo.save(doc1, comment=\'second save\')\n+        portal_repo.save(doc1, comment="second save")\n         portal_repo.restore(history_id, selector=0, container=fol)\n         # Both documents should now be in place\n         res_doc = fol.doc1\n         self.assertEqual(res_doc.Title(), "v1 of doc1")\n-        self.assertEqual(len(catalog(getId=\'doc1\')), 1)\n-        self.assertEqual(len(catalog(getId=\'doc1_changed\')), 1)\n-        self.assertEqual(len(catalog(Title=\'v1 of doc1\')), 1)\n-        self.assertEqual(len(catalog(Title=\'v2 of doc1\')), 1)\n+        self.assertEqual(len(catalog(getId="doc1")), 1)\n+        self.assertEqual(len(catalog(getId="doc1_changed")), 1)\n+        self.assertEqual(len(catalog(Title="v1 of doc1")), 1)\n+        self.assertEqual(len(catalog(Title="v2 of doc1")), 1)\n         # The reverted document should have a new uid, because an object with\n         # the original uid exists\n         self.assertFalse(portal_hidhandler.queryUid(res_doc) == history_id)\n@@ -995,52 +995,52 @@ def test23_versioningPreservesFolderAnnotations(self):\n         fol = self.portal.fol\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n-        fol.__annotations__[\'something\'] = True\n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        fol.setTitle("v1 of fol")\n+        fol.__annotations__["something"] = True\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         # save change no 2\n-        fol.setTitle(\'v2 of fol\')\n-        fol.__annotations__[\'something\'] = False\n-        portal_repo.save(fol, comment=\'second save\')\n+        fol.setTitle("v2 of fol")\n+        fol.__annotations__["something"] = False\n+        portal_repo.save(fol, comment="second save")\n \n         # change no 3 (without saving)\n-        fol.setTitle(\'v3 of fol\')\n-        fol.__annotations__[\'something\'] = None\n-        fol.__annotations__[\'another_thing\'] = True\n+        fol.setTitle("v3 of fol")\n+        fol.__annotations__["something"] = None\n+        fol.__annotations__["another_thing"] = True\n \n         # retrieve change 1 and 2\n         repo_fol1 = portal_repo.retrieve(fol, 0).object\n         repo_fol2 = portal_repo.retrieve(fol, 1).object\n \n         # Test values on the repository copies and the working copy\n-        self.assertEqual(repo_fol1.__annotations__[\'something\'], True)\n-        self.assertEqual(repo_fol2.__annotations__[\'something\'], False)\n-        self.assertEqual(fol.__annotations__[\'something\'], None)\n-        self.assertEqual(repo_fol2.__annotations__.get(\'another_thing\', None), None)\n+        self.assertEqual(repo_fol1.__annotations__["something"], True)\n+        self.assertEqual(repo_fol2.__annotations__["something"], False)\n+        self.assertEqual(fol.__annotations__["something"], None)\n+        self.assertEqual(repo_fol2.__annotations__.get("another_thing", None), None)\n \n         # Test that revert brings in the original annotation\n         portal_repo.revert(fol)\n-        self.assertEqual(fol.__annotations__[\'something\'], False)\n-        self.assertEqual(fol.__annotations__.get(\'another_thing\', None), None)\n+        self.assertEqual(fol.__annotations__["something"], False)\n+        self.assertEqual(fol.__annotations__.get("another_thing", None), None)\n \n         portal_repo.revert(fol, 0)\n-        self.assertEqual(fol.__annotations__[\'something\'], True)\n+        self.assertEqual(fol.__annotations__["something"], True)\n \n     def test24_versioningPreservesFolderOrder(self):\n         portal_repo = self.portal.portal_repository\n         fol = self.portal.fol\n-        doc2 = fol[\'doc2\']\n+        doc2 = fol["doc2"]\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        fol.setTitle("v1 of fol")\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         # save change no 2\n-        fol.setTitle(\'v2 of fol\')\n-        fol.moveObjectsToTop([\'doc2\'])\n+        fol.setTitle("v2 of fol")\n+        fol.moveObjectsToTop(["doc2"])\n \n-        self.assertEqual(fol.objectIds()[0], \'doc2\')\n+        self.assertEqual(fol.objectIds()[0], "doc2")\n \n         working_ids = fol.objectIds()\n \n@@ -1054,28 +1054,28 @@ def test24_versioningPreservesFolderOrder(self):\n         self.assertEqual(fol.objectIds(), working_ids)\n \n         # See how we interact with delete\n-        fol.invokeFactory(\'Document\', \'doc3\')\n-        fol.moveObjectsToTop([\'doc3\'])\n-        fol.manage_delObjects([\'doc2\'])\n+        fol.invokeFactory("Document", "doc3")\n+        fol.moveObjectsToTop(["doc3"])\n+        fol.manage_delObjects(["doc2"])\n         transaction.savepoint(optimistic=True)\n \n         working_ids = fol.objectIds()\n-        doc3 = fol[\'doc3\']\n+        doc3 = fol["doc3"]\n         portal_repo.revert(fol)\n \n         # Test that we kept the ids from working copy, kept the new child\n         # restored the deleted child\n         self.assertEqual(fol.objectIds(), working_ids)\n-        self.assertEqual(fol.objectIds()[0], \'doc3\')\n-        self.assertEqual(getattr(fol, \'doc2\', None), None)\n-        self.assertEqual(fol[\'doc3\'], doc3)\n+        self.assertEqual(fol.objectIds()[0], "doc3")\n+        self.assertEqual(getattr(fol, "doc2", None), None)\n+        self.assertEqual(fol["doc3"], doc3)\n \n         # Test the BTreeFolder internals\n-        self.assertEqual(fol._tree.get(\'doc2\', None), None)\n-        self.assertEqual(fol._tree[\'doc3\'], doc3)\n+        self.assertEqual(fol._tree.get("doc2", None), None)\n+        self.assertEqual(fol._tree["doc3"], doc3)\n         self.assertEqual(fol._count(), 2)\n-        self.assertEqual(fol._mt_index[doc2.meta_type].get(\'doc2\', None), None)\n-        self.assertEqual(fol._mt_index[doc3.meta_type][\'doc3\'], 1)\n+        self.assertEqual(fol._mt_index[doc2.meta_type].get("doc2", None), None)\n+        self.assertEqual(fol._mt_index[doc3.meta_type]["doc3"], 1)\n \n     def test25_versioningRestoresInsideRefsFolderOrder(self):\n         # Enable OMInsideChildrensModifier\n@@ -1093,39 +1093,39 @@ def test25_versioningRestoresInsideRefsFolderOrder(self):\n         fol = self.portal.fol\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n-        fol.invokeFactory(\'Document\', \'doc3\')\n-        fol.invokeFactory(\'Document\', \'doc4\')\n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        fol.setTitle("v1 of fol")\n+        fol.invokeFactory("Document", "doc3")\n+        fol.invokeFactory("Document", "doc4")\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         orig_order = fol.objectIds()\n \n-        fol.setTitle(\'v2 of fol\')\n-        fol.moveObjectsToTop([\'doc2\'])\n+        fol.setTitle("v2 of fol")\n+        fol.moveObjectsToTop(["doc2"])\n \n-        self.assertEqual(fol.objectIds()[0], \'doc2\')\n+        self.assertEqual(fol.objectIds()[0], "doc2")\n \n         # Test that a retrieve uses the order from the repo copy\n         repo_fol1 = portal_repo.retrieve(fol, 0).object\n-        self.assertEqual(fol.objectIds()[0], \'doc2\')\n+        self.assertEqual(fol.objectIds()[0], "doc2")\n         self.assertNotEqual(fol.objectIds(), orig_order)\n-        self.assertEqual(repo_fol1.objectIds()[0], \'doc1\')\n+        self.assertEqual(repo_fol1.objectIds()[0], "doc1")\n \n         # Test that a revert restores the order and objects from the\n         # repo copy\n         portal_repo.revert(fol)\n-        self.assertEqual(fol.objectIds()[0], \'doc1\')\n+        self.assertEqual(fol.objectIds()[0], "doc1")\n         self.assertEqual(fol.objectIds(), orig_order)\n \n         # See how we interact with some adds deletes and reorders\n-        fol.invokeFactory(\'Document\', \'doc5\')\n-        fol.moveObjectsToTop([\'doc3\'])\n-        fol.moveObjectsToTop([\'doc4\'])\n-        fol.manage_delObjects([\'doc2\'])\n+        fol.invokeFactory("Document", "doc5")\n+        fol.moveObjectsToTop(["doc3"])\n+        fol.moveObjectsToTop(["doc4"])\n+        fol.manage_delObjects(["doc2"])\n         processQueue()\n         transaction.savepoint(optimistic=True)\n-        doc3 = fol[\'doc3\']\n-        doc4 = fol[\'doc4\']\n+        doc3 = fol["doc3"]\n+        doc4 = fol["doc4"]\n \n         self.assertNotEqual(fol.objectIds(), orig_order)\n \n@@ -1135,30 +1135,30 @@ def test25_versioningRestoresInsideRefsFolderOrder(self):\n         # but does not affect the working copy\n         repo_fol1 = portal_repo.retrieve(fol, 0).object\n         self.assertEqual(repo_fol1.objectIds(), orig_order)\n-        self.assertNotEqual(getattr(repo_fol1, \'doc2\', None), None)\n-        self.assertEqual(getattr(repo_fol1, \'doc5\', None), None)\n+        self.assertNotEqual(getattr(repo_fol1, "doc2", None), None)\n+        self.assertEqual(getattr(repo_fol1, "doc5", None), None)\n \n         self.assertNotEqual(fol.objectIds(), orig_order)\n-        self.assertEqual(fol.objectIds()[0], \'doc4\')\n-        self.assertEqual(fol.objectIds()[1], \'doc3\')\n-        self.assertEqual(fol[\'doc3\'], doc3)\n-        self.assertEqual(fol[\'doc4\'], doc4)\n-        self.assertEqual(getattr(fol, \'doc2\', None), None)\n-        self.assertNotEqual(getattr(fol, \'doc5\', None), None)\n+        self.assertEqual(fol.objectIds()[0], "doc4")\n+        self.assertEqual(fol.objectIds()[1], "doc3")\n+        self.assertEqual(fol["doc3"], doc3)\n+        self.assertEqual(fol["doc4"], doc4)\n+        self.assertEqual(getattr(fol, "doc2", None), None)\n+        self.assertNotEqual(getattr(fol, "doc5", None), None)\n \n         # Test that a revert restores the missing child from the repo\n         # copy, removed the newly created child and restored the order\n         portal_repo.revert(fol)\n \n         self.assertEqual(list(fol.objectIds()), orig_order)\n-        self.assertEqual(getattr(fol, \'doc5\', None), None)\n+        self.assertEqual(getattr(fol, "doc5", None), None)\n \n         # Test the BTreeFolder internals\n-        self.assertEqual(fol._tree.get(\'doc5\', None), None)\n+        self.assertEqual(fol._tree.get("doc5", None), None)\n         self.assertEqual(fol._count(), 4)\n-        self.assertEqual(fol._mt_index[doc3.meta_type].get(\'doc5\', None), None)\n-        self.assertEqual(fol._tree[\'doc3\'], fol[\'doc3\'].aq_base)\n-        self.assertEqual(fol._mt_index[doc3.meta_type][\'doc3\'], 1)\n+        self.assertEqual(fol._mt_index[doc3.meta_type].get("doc5", None), None)\n+        self.assertEqual(fol._tree["doc3"], fol["doc3"].aq_base)\n+        self.assertEqual(fol._mt_index[doc3.meta_type]["doc3"], 1)\n \n     def test26_RegistryBasesNotVersionedOrRestored(self):\n         portal_repo = self.portal.portal_repository\n@@ -1173,8 +1173,8 @@ def test26_RegistryBasesNotVersionedOrRestored(self):\n         portal_repo.applyVersionControl(fol)\n \n         broken_iface = broken.find_global(\n-            \'never_gonna_be_real\',\n-            \'IMissing\',\n+            "never_gonna_be_real",\n+            "IMissing",\n             Broken=ZODB.interfaces.IBroken,\n             type=InterfaceClass,\n         )\ndiff --git a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\nindex 967a2f8..c98ed3c 100644\n--- a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\n+++ b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\n@@ -35,7 +35,7 @@ class TestKeepLastNVersionsTool(CMFEditionsBaseTestCase):\n     def setUp(self):\n         super(TestKeepLastNVersionsTool, self).setUp()\n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\', [\'Manager\'], \'\')\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n \n         # install test storage\n         self._setDummyTool(PurgePolicyTestDummyStorage())\ndiff --git a/Products/CMFEditions/tests/test_ModifierRegistryTool.py b/Products/CMFEditions/tests/test_ModifierRegistryTool.py\nindex 3087799..6f78faf 100644\n--- a/Products/CMFEditions/tests/test_ModifierRegistryTool.py\n+++ b/Products/CMFEditions/tests/test_ModifierRegistryTool.py\n@@ -74,18 +74,18 @@ def afterRetrieveModifier(self, obj, repo_obj):\n \n \n class SimpleModifier1(SimpleModifierBase):\n-    beforeSaveModifierAttribute = \'beforeSave1\'\n-    afterRetrieveModifierAttribute = \'afterRetrieve1\'\n+    beforeSaveModifierAttribute = "beforeSave1"\n+    afterRetrieveModifierAttribute = "afterRetrieve1"\n \n \n class SimpleModifier2(SimpleModifierBase):\n-    beforeSaveModifierAttribute = \'beforeSave2\'\n-    afterRetrieveModifierAttribute = \'afterRetrieve2\'\n+    beforeSaveModifierAttribute = "beforeSave2"\n+    afterRetrieveModifierAttribute = "afterRetrieve2"\n \n \n class SimpleModifier3(SimpleModifierBase):\n-    beforeSaveModifierAttribute = \'beforeSave3\'\n-    afterRetrieveModifierAttribute = \'afterRetrieve3\'\n+    beforeSaveModifierAttribute = "beforeSave3"\n+    afterRetrieveModifierAttribute = "afterRetrieve3"\n \n \n class NonModifier(SimpleItem):\n@@ -101,15 +101,15 @@ def dictToString(dict):\n     keys.sort()\n     for k in keys:\n         dict_list.append("%s = %s" % (k, dict[k]))\n-    return \', \'.join(dict_list)\n+    return ", ".join(dict_list)\n \n \n @implementer(IAttributeModifier, ICloneModifier, ISaveRetrieveModifier)\n class LoggingModifierBase:\n     def getReferencedAttributes(self, obj):\n         referenced_data = {\n-            \'k1\': \'v1:\' + str(self.__class__.__name__),\n-            \'k2\': \'v2:\' + str(self.__class__.__name__),\n+            "k1": "v1:" + str(self.__class__.__name__),\n+            "k2": "v2:" + str(self.__class__.__name__),\n         }\n         mlog.append(\n             "%s.getReferencedAttributes: %s"\n@@ -127,7 +127,7 @@ def persistent_load(pid):\n             # should never reach this!\n             assert False\n \n-        return persistent_id, persistent_load, [], [], \'\'\n+        return persistent_id, persistent_load, [], [], ""\n \n     def beforeSaveModifier(self, obj, obj_clone):\n         mlog.append("%s.beforeSaveModifier" % (self.__class__.__name__))\n@@ -167,15 +167,15 @@ def setUp(self):\n         super(TestModifierRegistryTool, self).setUp()\n \n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\', [\'Manager\'], \'\')\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n         # add a document\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n+        self.portal.invokeFactory("Document", "doc")\n \n         # just unregister the standard modifiers for the unit tests\n-        portal_modifier = getToolByName(self.portal, \'portal_modifier\')\n+        portal_modifier = getToolByName(self.portal, "portal_modifier")\n         modifiers = portal_modifier.modules.StandardModifiers.modifiers\n         for m in modifiers:\n-            portal_modifier.unregister(m[\'id\'])\n+            portal_modifier.unregister(m["id"])\n \n     def test00_interface(self):\n         portal_modifier = self.portal.portal_modifier\n@@ -192,20 +192,20 @@ def test01_modifiersNotCalled(self):\n         doc = self.portal.doc\n         doc_copy = deepcopy(aq_base(doc))\n \n-        portal_modifier.register(\'1\', SimpleModifier1())\n-        portal_modifier.edit(\'1\', condition=\'python:True\')\n+        portal_modifier.register("1", SimpleModifier1())\n+        portal_modifier.edit("1", condition="python:True")\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         portal_modifier.afterRetrieveModifier(doc, doc_copy)\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'beforeSave1\')\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'afterRetrieve1\')\n+        self.assertRaises(AttributeError, getattr, doc_copy, "beforeSave1")\n+        self.assertRaises(AttributeError, getattr, doc_copy, "afterRetrieve1")\n \n     def test02_enabledModifierCalled(self):\n         portal_modifier = self.portal.portal_modifier\n         doc = self.portal.doc\n         doc_copy = deepcopy(aq_base(doc))\n \n-        portal_modifier.register(\'1\', SimpleModifier1())\n-        portal_modifier.edit(\'1\', enabled=True, condition=\'python:True\')\n+        portal_modifier.register("1", SimpleModifier1())\n+        portal_modifier.edit("1", enabled=True, condition="python:True")\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         portal_modifier.afterRetrieveModifier(doc, doc_copy)\n \n@@ -218,38 +218,38 @@ def test03_unregisteredModifiersNotCalled(self):\n         doc = self.portal.doc\n         doc_copy = deepcopy(aq_base(doc))\n \n-        portal_modifier.register(\'1\', SimpleModifier1())\n-        portal_modifier.edit(\'1\', enabled=True, condition=\'python:True\')\n+        portal_modifier.register("1", SimpleModifier1())\n+        portal_modifier.edit("1", enabled=True, condition="python:True")\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         self.assertEqual(doc_copy.beforeSave1, 1)\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'afterRetrieve1\')\n-        portal_modifier.unregister(\'1\')\n+        self.assertRaises(AttributeError, getattr, doc_copy, "afterRetrieve1")\n+        portal_modifier.unregister("1")\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         self.assertEqual(doc_copy.beforeSave1, 1)\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'afterRetrieve1\')\n+        self.assertRaises(AttributeError, getattr, doc_copy, "afterRetrieve1")\n \n     def test04_conditionEvaluated(self):\n         portal_modifier = self.portal.portal_modifier\n         doc = self.portal.doc\n         doc_copy = deepcopy(aq_base(doc))\n \n-        portal_modifier.register(\'1\', SimpleModifier1())\n-        portal_modifier.edit(\'1\', enabled=True, condition=\'python:False\')\n+        portal_modifier.register("1", SimpleModifier1())\n+        portal_modifier.edit("1", enabled=True, condition="python:False")\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         portal_modifier.afterRetrieveModifier(doc, doc_copy)\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'beforeSave1\')\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'afterRetrieve1\')\n+        self.assertRaises(AttributeError, getattr, doc_copy, "beforeSave1")\n+        self.assertRaises(AttributeError, getattr, doc_copy, "afterRetrieve1")\n \n     def test05_registerANonModifier(self):\n         portal_modifier = self.portal.portal_modifier\n         doc = self.portal.doc\n         doc_copy = deepcopy(aq_base(doc))\n \n-        portal_modifier._setObject(\'doc\', NonModifier())\n+        portal_modifier._setObject("doc", NonModifier())\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         portal_modifier.afterRetrieveModifier(doc, doc_copy)\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'beforeSave1\')\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'afterRetrieve1\')\n+        self.assertRaises(AttributeError, getattr, doc_copy, "beforeSave1")\n+        self.assertRaises(AttributeError, getattr, doc_copy, "afterRetrieve1")\n \n     def test06_modifierAddedToTheCorrectPosition(self):\n         portal_modifier = self.portal.portal_modifier\n@@ -260,9 +260,9 @@ def test06_modifierAddedToTheCorrectPosition(self):\n         m2 = SimpleModifier2()\n         m3 = SimpleModifier3()\n \n-        portal_modifier.register(\'1\', m1)\n-        portal_modifier.register(\'2\', m2)\n-        portal_modifier.register(\'3\', m3, pos=0)\n+        portal_modifier.register("1", m1)\n+        portal_modifier.register("2", m2)\n+        portal_modifier.register("3", m3, pos=0)\n \n         modifiers = [m.getModifier() for m in portal_modifier.objectValues()]\n         self.assertEqual(modifiers, [m3, m1, m2])\n@@ -276,11 +276,11 @@ def test07_unregisterModifer(self):\n         m2 = SimpleModifier2()\n         m3 = SimpleModifier3()\n \n-        portal_modifier.register(\'1\', m1)\n-        portal_modifier.register(\'2\', m2)\n-        portal_modifier.register(\'3\', m3, pos=0)\n+        portal_modifier.register("1", m1)\n+        portal_modifier.register("2", m2)\n+        portal_modifier.register("3", m3, pos=0)\n \n-        portal_modifier.unregister(\'1\')\n+        portal_modifier.unregister("1")\n \n         modifiers = [m.getModifier() for m in portal_modifier.objectValues()]\n         self.assertEqual(modifiers, [m3, m2])\n@@ -292,16 +292,16 @@ def test08_getModifiers(self):\n         m2 = SimpleModifier2()\n         m3 = SimpleModifier3()\n \n-        portal_modifier.register(\'1\', m1)\n-        portal_modifier.register(\'2\', m2)\n-        portal_modifier.register(\'3\', m3, pos=0)\n+        portal_modifier.register("1", m1)\n+        portal_modifier.register("2", m2)\n+        portal_modifier.register("3", m3, pos=0)\n \n-        portal_modifier.unregister(\'1\')\n+        portal_modifier.unregister("1")\n \n-        self.assertEqual(portal_modifier.get(\'2\').getModifier(), m2)\n-        self.assertEqual(portal_modifier.query(\'2\').getModifier(), m2)\n-        self.assertRaises(AttributeError, portal_modifier.get, \'1\')\n-        self.assertEqual(portal_modifier.query(\'1\', None), None)\n+        self.assertEqual(portal_modifier.get("2").getModifier(), m2)\n+        self.assertEqual(portal_modifier.query("2").getModifier(), m2)\n+        self.assertRaises(AttributeError, portal_modifier.get, "1")\n+        self.assertEqual(portal_modifier.query("1", None), None)\n \n     def test09_conditionContextSetUpCorretcly(self):\n         portal_modifier = self.portal.portal_modifier\n@@ -311,20 +311,20 @@ def test09_conditionContextSetUpCorretcly(self):\n         # just check if variables got defined\n         condition = (\n             \'python:"%s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s" % (\'\n-            \'object_url, \'\n-            \'folder_url, \'\n-            \'portal_url, \'\n-            \'object, \'\n-            \'folder, \'\n-            \'portal, \'\n-            \'nothing, \'\n-            \'request, \'\n-            \'modules, \'\n-            \'member,\'\n-            \')\'\n+            "object_url, "\n+            "folder_url, "\n+            "portal_url, "\n+            "object, "\n+            "folder, "\n+            "portal, "\n+            "nothing, "\n+            "request, "\n+            "modules, "\n+            "member,"\n+            ")"\n         )\n-        portal_modifier.register(\'1\', SimpleModifier1())\n-        portal_modifier.edit(\'1\', enabled=True, condition=condition)\n+        portal_modifier.register("1", SimpleModifier1())\n+        portal_modifier.edit("1", enabled=True, condition=condition)\n \n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         portal_modifier.afterRetrieveModifier(doc, doc_copy)\n@@ -344,19 +344,19 @@ def test10_callingOrder(self):\n         for m in loggingModifiers:\n             counter += 1\n             portal_modifier.register(str(counter), m)\n-            portal_modifier.edit(str(counter), enabled=True, condition=\'python:True\')\n+            portal_modifier.edit(str(counter), enabled=True, condition="python:True")\n \n-        mlog.append(\'<save>\')\n+        mlog.append("<save>")\n         portal_modifier.getReferencedAttributes(doc)\n         portal_modifier.getOnCloneModifiers(doc)\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n-        mlog.append(\'<retrieve>\')\n+        mlog.append("<retrieve>")\n \n         portal_modifier.afterRetrieveModifier(doc, doc_copy)\n-        mlog.append(\'<end>\')\n+        mlog.append("<end>")\n \n-        mlog_str = \'\\n\'.join(mlog).replace(\n-            \'__main__\', \'CMFEditions.tests.test_ModifierRegistryTool\'\n+        mlog_str = "\\n".join(mlog).replace(\n+            "__main__", "CMFEditions.tests.test_ModifierRegistryTool"\n         )\n         expected_result = """<save>\n %(class)s_A.getReferencedAttributes: k1 = v1:%(class)s_A, k2 = v2:%(class)s_A\n@@ -377,6 +377,6 @@ def test10_callingOrder(self):\n %(class)s_B.afterRetrieveModifier\n %(class)s_A.afterRetrieveModifier\n <end>""" % {\n-            \'class\': \'LoggingModifier\'\n+            "class": "LoggingModifier"\n         }\n         self.assertEqual(mlog_str, expected_result)\ndiff --git a/Products/CMFEditions/tests/test_ZVCStorageTool.py b/Products/CMFEditions/tests/test_ZVCStorageTool.py\nindex c581eb1..49004c6 100644\n--- a/Products/CMFEditions/tests/test_ZVCStorageTool.py\n+++ b/Products/CMFEditions/tests/test_ZVCStorageTool.py\n@@ -54,7 +54,7 @@ def __init__(self, id, cmfuid, effective=None, expires=None):\n         self.expires = expires\n \n     def getPortalTypeName(self):\n-        return \'Dummy\'\n+        return "Dummy"\n \n \n class TestZVCStorageTool(CMFEditionsBaseTestCase):\n@@ -62,7 +62,7 @@ def setUp(self):\n         super(TestZVCStorageTool, self).setUp()\n \n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\', [\'Manager\'], \'\')\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n \n         # eventually install another storage\n         self.installStorageTool()\n@@ -88,7 +88,7 @@ def _setDummyTool(self, tool):\n         setattr(self.portal, tool.getId(), tool)\n \n     def buildMetadata(self, comment):\n-        return {\'sys_metadata\': {\'comment\': comment}}\n+        return {"sys_metadata": {"comment": comment}}\n \n     def getComment(self, vdata):\n         return vdata.metadata["sys_metadata"]["comment"]\n@@ -105,11 +105,11 @@ def test01_saveAfterRegisteringDoesNotRaiseException(self):\n         obj = Dummy()\n \n         sel = portal_storage.register(\n-            1, ObjectData(obj), metadata=self.buildMetadata(\'saved\')\n+            1, ObjectData(obj), metadata=self.buildMetadata("saved")\n         )\n         self.assertEqual(sel, 0)\n         sel = portal_storage.save(\n-            1, ObjectData(obj), metadata=self.buildMetadata(\'saved\')\n+            1, ObjectData(obj), metadata=self.buildMetadata("saved")\n         )\n         self.assertEqual(sel, 1)\n \n@@ -122,53 +122,53 @@ def test02_saveUnregisteredObjectRaisesException(self):\n             portal_storage.save,\n             1,\n             ObjectData(obj),\n-            metadata=self.buildMetadata(\'saved\'),\n+            metadata=self.buildMetadata("saved"),\n         )\n \n     def test03_saveAndRetrieve(self):\n         portal_storage = self.portal.portal_historiesstorage\n \n         obj1 = Dummy()\n-        obj1.text = \'v1 of text\'\n+        obj1.text = "v1 of text"\n         portal_storage.register(\n-            1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n         )\n \n         obj2 = Dummy()\n-        obj2.text = \'v2 of text\'\n+        obj2.text = "v2 of text"\n         portal_storage.save(\n-            1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\')\n+            1, ObjectData(obj2), metadata=self.buildMetadata("saved v2")\n         )\n \n         # retrieve the state at registration time\n         retrieved_obj = portal_storage.retrieve(history_id=1, selector=0)\n-        self.assertEqual(retrieved_obj.object.object.text, \'v1 of text\')\n-        self.assertEqual(self.getComment(retrieved_obj), \'saved v1\')\n+        self.assertEqual(retrieved_obj.object.object.text, "v1 of text")\n+        self.assertEqual(self.getComment(retrieved_obj), "saved v1")\n \n         # just check if first save wasn\'t a double save\n         retrieved_obj = portal_storage.retrieve(history_id=1, selector=1)\n-        self.assertEqual(retrieved_obj.object.object.text, \'v2 of text\')\n-        self.assertEqual(self.getComment(retrieved_obj), \'saved v2\')\n+        self.assertEqual(retrieved_obj.object.object.text, "v2 of text")\n+        self.assertEqual(self.getComment(retrieved_obj), "saved v2")\n \n     def test05_getHistory(self):\n         portal_storage = self.portal.portal_historiesstorage\n \n         obj1 = Dummy()\n-        obj1.text = \'v1 of text\'\n+        obj1.text = "v1 of text"\n         portal_storage.register(\n-            1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n         )\n \n         obj2 = Dummy()\n-        obj2.text = \'v2 of text\'\n+        obj2.text = "v2 of text"\n         portal_storage.save(\n-            1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\')\n+            1, ObjectData(obj2), metadata=self.buildMetadata("saved v2")\n         )\n \n         obj3 = Dummy()\n-        obj3.text = \'v3 of text\'\n+        obj3.text = "v3 of text"\n         portal_storage.save(\n-            1, ObjectData(obj3), metadata=self.buildMetadata(\'saved v3\')\n+            1, ObjectData(obj3), metadata=self.buildMetadata("saved v3")\n         )\n \n         history = portal_storage.getHistory(history_id=1)\n@@ -179,11 +179,11 @@ def test05_getHistory(self):\n \n         # iterating over the history\n         for i, vdata in enumerate(history):\n-            expected_test = \'v%s of text\' % (i + 1)\n+            expected_test = "v%s of text" % (i + 1)\n             self.assertEquals(vdata.object.object.text, expected_test)\n             self.assertEquals(history[i].object.object.text, expected_test)\n \n-            expected_comment = \'saved v%s\' % (i + 1)\n+            expected_comment = "saved v%s" % (i + 1)\n             self.assertEqual(self.getComment(vdata), expected_comment)\n             self.assertEqual(self.getComment(history[i]), expected_comment)\n \n@@ -201,11 +201,11 @@ def test06_checkObjectManagerIntegrity(self):\n         om = DummyOM()\n         sub1 = Dummy()\n         sub2 = Dummy()\n-        om._setObject(\'sub1\', sub1)\n-        om._setObject(\'sub2\', sub2)\n+        om._setObject("sub1", sub1)\n+        om._setObject("sub2", sub2)\n         self.assertEqual(len(om.objectIds()), 2)\n         portal_storage.register(\n-            1, ObjectData(om), metadata=self.buildMetadata(\'saved v1\')\n+            1, ObjectData(om), metadata=self.buildMetadata("saved v1")\n         )\n         vdata = portal_storage.retrieve(history_id=1, selector=0)\n         retrieved_om = vdata.object\n@@ -218,7 +218,7 @@ def test07_getModificationDate(self):\n         v1 = portal_storage.register(\n             history_id=1,\n             object=ObjectData(obj),\n-            metadata=self.buildMetadata(\'saved v1\'),\n+            metadata=self.buildMetadata("saved v1"),\n         )\n \n         self.assertEqual(v1_modified, portal_storage.getModificationDate(history_id=1))\n@@ -236,7 +236,7 @@ def test07_getModificationDate(self):\n         v2 = portal_storage.save(\n             history_id=1,\n             object=ObjectData(obj),\n-            metadata=self.buildMetadata(\'saved v2\'),\n+            metadata=self.buildMetadata("saved v2"),\n         )\n         self.assertNotEquals(v1, v2)\n         self.assertEqual(v2_modified, portal_storage.getModificationDate(history_id=1))\n@@ -251,27 +251,27 @@ def _setupMinimalHistory(self):\n         portal_storage = self.portal.portal_historiesstorage\n \n         obj1 = Dummy()\n-        obj1.text = \'v1 of text\'\n+        obj1.text = "v1 of text"\n         portal_storage.register(\n-            1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n         )\n \n         obj2 = Dummy()\n-        obj2.text = \'v2 of text\'\n+        obj2.text = "v2 of text"\n         portal_storage.save(\n-            1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\')\n+            1, ObjectData(obj2), metadata=self.buildMetadata("saved v2")\n         )\n \n         obj3 = Dummy()\n-        obj3.text = \'v3 of text\'\n+        obj3.text = "v3 of text"\n         portal_storage.save(\n-            1, ObjectData(obj3), metadata=self.buildMetadata(\'saved v3\')\n+            1, ObjectData(obj3), metadata=self.buildMetadata("saved v3")\n         )\n \n         obj4 = Dummy()\n-        obj4.text = \'v4 of text\'\n+        obj4.text = "v4 of text"\n         portal_storage.save(\n-            1, ObjectData(obj4), metadata=self.buildMetadata(\'saved v4\')\n+            1, ObjectData(obj4), metadata=self.buildMetadata("saved v4")\n         )\n \n     def test08_lengthAfterHavingPurgedAVersion(self):\n@@ -321,8 +321,8 @@ def test09_retrievePurgedVersionsNoPolicyInstalled(self):\n             history_id=1, selector=2, countPurged=False\n         )\n         self.assertTrue(retrieved_obj.isValid())\n-        self.assertEqual(retrieved_obj.object.object.text, \'v4 of text\')\n-        self.assertEqual(self.getComment(retrieved_obj), \'saved v4\')\n+        self.assertEqual(retrieved_obj.object.object.text, "v4 of text")\n+        self.assertEqual(self.getComment(retrieved_obj), "saved v4")\n \n     def test10_retrievePurgedVersionsWithPolicyInstalled(self):\n         self._setupMinimalHistory()\n@@ -348,19 +348,19 @@ def test10_retrievePurgedVersionsWithPolicyInstalled(self):\n         # ``retrieve`` returns the next older object\n         retrieved_obj = portal_storage.retrieve(history_id=1, selector=1)\n         self.assertTrue(retrieved_obj.isValid())\n-        self.assertEqual(retrieved_obj.object.object.text, \'v1 of text\')\n-        self.assertEqual(self.getComment(retrieved_obj), \'saved v1\')\n+        self.assertEqual(retrieved_obj.object.object.text, "v1 of text")\n+        self.assertEqual(self.getComment(retrieved_obj), "saved v1")\n \n         retrieved_obj = portal_storage.retrieve(history_id=1, selector=2)\n         self.assertTrue(retrieved_obj.isValid())\n-        self.assertEqual(retrieved_obj.object.object.text, \'v1 of text\')\n-        self.assertEqual(self.getComment(retrieved_obj), \'saved v1\')\n+        self.assertEqual(retrieved_obj.object.object.text, "v1 of text")\n+        self.assertEqual(self.getComment(retrieved_obj), "saved v1")\n \n         # ``retrieve`` returns existing object\n         retrieved_obj = portal_storage.retrieve(history_id=1, selector=3)\n         self.assertTrue(retrieved_obj.isValid())\n-        self.assertEqual(retrieved_obj.object.object.text, \'v4 of text\')\n-        self.assertEqual(self.getComment(retrieved_obj), \'saved v4\')\n+        self.assertEqual(retrieved_obj.object.object.text, "v4 of text")\n+        self.assertEqual(self.getComment(retrieved_obj), "saved v4")\n \n         # check with substitute=False: should return the removed info\n         retrieved_obj = portal_storage.retrieve(\n@@ -384,88 +384,88 @@ def test11_purgeOnSave(self):\n \n         # save no 1\n         obj1 = Dummy()\n-        obj1.text = \'v1 of text\'\n+        obj1.text = "v1 of text"\n \n         sel = portal_storage.register(\n-            1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n         )\n         history = portal_storage.getHistory(1, countPurged=False)\n \n         self.assertEquals(sel, 0)\n         self.assertEquals(len(history), 1)\n-        self.assertEqual(history[0].object.object.text, \'v1 of text\')\n-        self.assertEqual(self.getComment(history[0]), \'saved v1\')\n+        self.assertEqual(history[0].object.object.text, "v1 of text")\n+        self.assertEqual(self.getComment(history[0]), "saved v1")\n \n         # save no 2\n         obj2 = Dummy()\n-        obj2.text = \'v2 of text\'\n+        obj2.text = "v2 of text"\n         sel = portal_storage.save(\n-            1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\')\n+            1, ObjectData(obj2), metadata=self.buildMetadata("saved v2")\n         )\n         history = portal_storage.getHistory(1, countPurged=False)\n \n         self.assertEquals(sel, 1)\n         self.assertEquals(len(history), 2)\n-        self.assertEqual(history[0].object.object.text, \'v1 of text\')\n-        self.assertEqual(self.getComment(history[0]), \'saved v1\')\n-        self.assertEqual(history[1].object.object.text, \'v2 of text\')\n-        self.assertEqual(self.getComment(history[1]), \'saved v2\')\n+        self.assertEqual(history[0].object.object.text, "v1 of text")\n+        self.assertEqual(self.getComment(history[0]), "saved v1")\n+        self.assertEqual(history[1].object.object.text, "v2 of text")\n+        self.assertEqual(self.getComment(history[1]), "saved v2")\n \n         # save no 3: purged oldest version\n         obj3 = Dummy()\n-        obj3.text = \'v3 of text\'\n+        obj3.text = "v3 of text"\n         sel = portal_storage.save(\n-            1, ObjectData(obj3), metadata=self.buildMetadata(\'saved v3\')\n+            1, ObjectData(obj3), metadata=self.buildMetadata("saved v3")\n         )\n         history = portal_storage.getHistory(1, countPurged=False)\n         length = len(history)\n \n         # iterating over the history\n         for i, vdata in enumerate(history):\n-            self.assertEquals(vdata.object.object.text, \'v%s of text\' % (i + 2))\n-            self.assertEqual(self.getComment(vdata), \'saved v%s\' % (i + 2))\n+            self.assertEquals(vdata.object.object.text, "v%s of text" % (i + 2))\n+            self.assertEqual(self.getComment(vdata), "saved v%s" % (i + 2))\n \n         self.assertEquals(sel, 2)\n         self.assertEquals(length, 2)\n-        self.assertEqual(history[0].object.object.text, \'v2 of text\')\n-        self.assertEqual(self.getComment(history[0]), \'saved v2\')\n-        self.assertEqual(history[1].object.object.text, \'v3 of text\')\n-        self.assertEqual(self.getComment(history[1]), \'saved v3\')\n+        self.assertEqual(history[0].object.object.text, "v2 of text")\n+        self.assertEqual(self.getComment(history[0]), "saved v2")\n+        self.assertEqual(history[1].object.object.text, "v3 of text")\n+        self.assertEqual(self.getComment(history[1]), "saved v3")\n \n         # save no 4: purged oldest version\n         obj4 = Dummy()\n-        obj4.text = \'v4 of text\'\n+        obj4.text = "v4 of text"\n         sel = portal_storage.save(\n-            1, ObjectData(obj4), metadata=self.buildMetadata(\'saved v4\')\n+            1, ObjectData(obj4), metadata=self.buildMetadata("saved v4")\n         )\n         history = portal_storage.getHistory(1, countPurged=False)\n         length = len(history)\n \n         # iterating over the history\n         for i, vdata in enumerate(history):\n-            self.assertEquals(vdata.object.object.text, \'v%s of text\' % (i + 3))\n-            self.assertEqual(self.getComment(vdata), \'saved v%s\' % (i + 3))\n+            self.assertEquals(vdata.object.object.text, "v%s of text" % (i + 3))\n+            self.assertEqual(self.getComment(vdata), "saved v%s" % (i + 3))\n \n         self.assertEquals(sel, 3)\n         self.assertEquals(length, 2)\n-        self.assertEqual(history[0].object.object.text, \'v3 of text\')\n-        self.assertEqual(self.getComment(history[0]), \'saved v3\')\n-        self.assertEqual(history[1].object.object.text, \'v4 of text\')\n-        self.assertEqual(self.getComment(history[1]), \'saved v4\')\n+        self.assertEqual(history[0].object.object.text, "v3 of text")\n+        self.assertEqual(self.getComment(history[0]), "saved v3")\n+        self.assertEqual(history[1].object.object.text, "v4 of text")\n+        self.assertEqual(self.getComment(history[1]), "saved v4")\n \n     def test12_retrieveNonExistentVersion(self):\n         portal_storage = self.portal.portal_historiesstorage\n \n         obj1 = Dummy()\n-        obj1.text = \'v1 of text\'\n+        obj1.text = "v1 of text"\n         portal_storage.register(\n-            1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n         )\n \n         obj2 = Dummy()\n-        obj2.text = \'v2 of text\'\n+        obj2.text = "v2 of text"\n         portal_storage.save(\n-            1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\')\n+            1, ObjectData(obj2), metadata=self.buildMetadata("saved v2")\n         )\n \n         # purge\n@@ -492,12 +492,12 @@ def test12_retrieveNonExistentVersion(self):\n     def test13_saveWithUnicodeComment(self):\n         portal_storage = self.portal.portal_historiesstorage\n         obj1 = Dummy()\n-        obj1.text = \'v1 of text\'\n+        obj1.text = "v1 of text"\n         portal_storage.register(\n-            1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n         )\n         portal_storage.save(\n-            1, ObjectData(obj1), metadata=self.buildMetadata(u\'saved v1\\xc3\\xa1\')\n+            1, ObjectData(obj1), metadata=self.buildMetadata(u"saved v1\\xc3\\xa1")\n         )\n \n     def test14_getHistoryMetadata(self):\n@@ -508,16 +508,16 @@ def test14_getHistoryMetadata(self):\n \n         # accessing the versions\n         self.assertEqual(\n-            history.retrieve(0)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v1"\n+            history.retrieve(0)["metadata"]["sys_metadata"]["comment"], "saved v1"\n         )\n         self.assertEqual(\n-            history.retrieve(1)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v2"\n+            history.retrieve(1)["metadata"]["sys_metadata"]["comment"], "saved v2"\n         )\n         self.assertEqual(\n-            history.retrieve(2)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v3"\n+            history.retrieve(2)["metadata"]["sys_metadata"]["comment"], "saved v3"\n         )\n         self.assertEqual(\n-            history.retrieve(3)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v4"\n+            history.retrieve(3)["metadata"]["sys_metadata"]["comment"], "saved v4"\n         )\n \n     def test15_storageStatistics(self):\n@@ -525,128 +525,128 @@ def test15_storageStatistics(self):\n         portal_storage = self.portal.portal_historiesstorage\n \n         cmf_uid = 1\n-        obj1 = CMFDummy(\'obj\', cmf_uid)\n-        obj1.text = \'v1 of text\'\n+        obj1 = CMFDummy("obj", cmf_uid)\n+        obj1.text = "v1 of text"\n         portal_storage.register(\n-            cmf_uid, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\')\n+            cmf_uid, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n         )\n \n-        obj2 = CMFDummy(\'obj\', cmf_uid)\n-        obj2.text = \'v2 of text\'\n+        obj2 = CMFDummy("obj", cmf_uid)\n+        obj2.text = "v2 of text"\n         portal_storage.save(\n-            cmf_uid, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\')\n+            cmf_uid, ObjectData(obj2), metadata=self.buildMetadata("saved v2")\n         )\n \n-        obj3 = CMFDummy(\'obj\', cmf_uid)\n-        obj3.text = \'v3 of text\'\n+        obj3 = CMFDummy("obj", cmf_uid)\n+        obj3.text = "v3 of text"\n         portal_storage.save(\n-            cmf_uid, ObjectData(obj3), metadata=self.buildMetadata(\'saved v3\')\n+            cmf_uid, ObjectData(obj3), metadata=self.buildMetadata("saved v3")\n         )\n \n-        obj4 = CMFDummy(\'obj\', cmf_uid)\n-        obj4.text = \'v4 of text\'\n-        self.portal._setObject(\'obj\', obj4)\n+        obj4 = CMFDummy("obj", cmf_uid)\n+        obj4.text = "v4 of text"\n+        self.portal._setObject("obj", obj4)\n         self.portal.portal_catalog.indexObject(self.portal.obj)\n         portal_storage.save(\n-            cmf_uid, ObjectData(obj4), metadata=self.buildMetadata(\'saved v4\')\n+            cmf_uid, ObjectData(obj4), metadata=self.buildMetadata("saved v4")\n         )\n \n         cmf_uid = 2\n         tomorrow = DateTime() + 1\n-        obj5 = CMFDummy(\'tomorrow\', cmf_uid, effective=tomorrow)\n-        obj5.allowedRolesAndUsers = [\'Anonymous\']\n-        self.portal._setObject(\'tomorrow\', obj5)\n+        obj5 = CMFDummy("tomorrow", cmf_uid, effective=tomorrow)\n+        obj5.allowedRolesAndUsers = ["Anonymous"]\n+        self.portal._setObject("tomorrow", obj5)\n         self.portal.portal_catalog.indexObject(self.portal.tomorrow)\n         portal_storage.register(\n-            cmf_uid, ObjectData(obj5), metadata=self.buildMetadata(\'effective tomorrow\')\n+            cmf_uid, ObjectData(obj5), metadata=self.buildMetadata("effective tomorrow")\n         )\n \n         cmf_uid = 3\n         yesterday = DateTime() - 1\n-        obj6 = CMFDummy(\'yesterday\', cmf_uid, expires=yesterday)\n-        obj6.allowedRolesAndUsers = [\'Anonymous\']\n-        self.portal._setObject(\'yesterday\', obj6)\n+        obj6 = CMFDummy("yesterday", cmf_uid, expires=yesterday)\n+        obj6.allowedRolesAndUsers = ["Anonymous"]\n+        self.portal._setObject("yesterday", obj6)\n         self.portal.portal_catalog.indexObject(self.portal.yesterday)\n         portal_storage.register(\n-            cmf_uid, ObjectData(obj6), metadata=self.buildMetadata(\'expired yesterday\')\n+            cmf_uid, ObjectData(obj6), metadata=self.buildMetadata("expired yesterday")\n         )\n \n         cmf_uid = 4\n-        obj7 = CMFDummy(\'public\', cmf_uid)\n-        obj7.text = \'visible for everyone\'\n-        obj7.allowedRolesAndUsers = [\'Anonymous\']\n-        self.portal._setObject(\'public\', obj7)\n+        obj7 = CMFDummy("public", cmf_uid)\n+        obj7.text = "visible for everyone"\n+        obj7.allowedRolesAndUsers = ["Anonymous"]\n+        self.portal._setObject("public", obj7)\n         self.portal.portal_catalog.indexObject(self.portal.public)\n         portal_storage.register(\n-            cmf_uid, ObjectData(obj7), metadata=self.buildMetadata(\'saved public\')\n+            cmf_uid, ObjectData(obj7), metadata=self.buildMetadata("saved public")\n         )\n \n         processQueue()\n         got = portal_storage.zmi_getStorageStatistics()\n         expected = {\n-            \'deleted\': [],\n-            \'summaries\': {\n-                \'totalHistories\': 4,\n-                \'deletedVersions\': 0,\n-                \'existingVersions\': 7,\n-                \'deletedHistories\': 0,\n+            "deleted": [],\n+            "summaries": {\n+                "totalHistories": 4,\n+                "deletedVersions": 0,\n+                "existingVersions": 7,\n+                "deletedHistories": 0,\n                 # time may easily be different\n                 # \'time\': \'0.00\',\n-                \'totalVersions\': 7,\n-                \'existingAverage\': \'1.8\',\n-                \'existingHistories\': 4,\n-                \'deletedAverage\': \'n/a\',\n-                \'totalAverage\': \'1.8\',\n+                "totalVersions": 7,\n+                "existingAverage": "1.8",\n+                "existingHistories": 4,\n+                "deletedAverage": "n/a",\n+                "totalAverage": "1.8",\n             },\n-            \'existing\': [\n+            "existing": [\n                 {\n-                    \'url\': \'http://nohost/plone/obj\',\n-                    \'history_id\': 1,\n-                    \'length\': 4,\n-                    \'path\': \'/obj\',\n-                    \'sizeState\': \'approximate\',\n-                    \'portal_type\': \'Dummy\',\n+                    "url": "http://nohost/plone/obj",\n+                    "history_id": 1,\n+                    "length": 4,\n+                    "path": "/obj",\n+                    "sizeState": "approximate",\n+                    "portal_type": "Dummy",\n                 },\n                 {\n-                    \'url\': \'http://nohost/plone/tomorrow\',\n-                    \'history_id\': 2,\n-                    \'length\': 1,\n-                    \'path\': \'/tomorrow\',\n-                    \'sizeState\': \'approximate\',\n-                    \'portal_type\': \'Dummy\',\n+                    "url": "http://nohost/plone/tomorrow",\n+                    "history_id": 2,\n+                    "length": 1,\n+                    "path": "/tomorrow",\n+                    "sizeState": "approximate",\n+                    "portal_type": "Dummy",\n                 },\n                 {\n-                    \'url\': \'http://nohost/plone/yesterday\',\n-                    \'history_id\': 3,\n-                    \'length\': 1,\n-                    \'path\': \'/yesterday\',\n-                    \'sizeState\': \'approximate\',\n-                    \'portal_type\': \'Dummy\',\n+                    "url": "http://nohost/plone/yesterday",\n+                    "history_id": 3,\n+                    "length": 1,\n+                    "path": "/yesterday",\n+                    "sizeState": "approximate",\n+                    "portal_type": "Dummy",\n                 },\n                 {\n-                    \'url\': \'http://nohost/plone/public\',\n-                    \'history_id\': 4,\n-                    \'length\': 1,\n-                    \'path\': \'/public\',\n-                    \'sizeState\': \'approximate\',\n-                    \'portal_type\': \'Dummy\',\n+                    "url": "http://nohost/plone/public",\n+                    "history_id": 4,\n+                    "length": 1,\n+                    "path": "/public",\n+                    "sizeState": "approximate",\n+                    "portal_type": "Dummy",\n                 },\n             ],\n         }\n-        self.assertEqual(expected[\'deleted\'], got[\'deleted\'])\n-        self.assertTrue(\'summaries\' in got)\n-        self.assertTrue(\'time\' in got[\'summaries\'])\n-        for key, value in expected[\'summaries\'].items():\n-            self.assertEqual(value, got[\'summaries\'][key])\n-        self.assertEqual(len(expected[\'existing\']), len(got[\'existing\']))\n-        for idx in range(len(expected[\'existing\'])):\n-            exp = expected[\'existing\'][idx]\n-            actual = got[\'existing\'][idx]\n+        self.assertEqual(expected["deleted"], got["deleted"])\n+        self.assertTrue("summaries" in got)\n+        self.assertTrue("time" in got["summaries"])\n+        for key, value in expected["summaries"].items():\n+            self.assertEqual(value, got["summaries"][key])\n+        self.assertEqual(len(expected["existing"]), len(got["existing"]))\n+        for idx in range(len(expected["existing"])):\n+            exp = expected["existing"][idx]\n+            actual = got["existing"][idx]\n             for key, value in exp.items():\n                 self.assertEqual(actual[key], value)\n             # The actual size is not important and we want robust tests,\n             # s. https://github.com/plone/Products.CMFEditions/issues/31\n-            self.assertTrue(actual[\'size\'] > 0)\n+            self.assertTrue(actual["size"] > 0)\n \n     def test16_delete_history_on_content_deletion(self):\n         """If a content item gets deleted, delete it\'s history\n@@ -654,43 +654,43 @@ def test16_delete_history_on_content_deletion(self):\n         """\n         portal_hidhandler = self.portal.portal_historyidhandler\n         portal_storage = self.portal.portal_historiesstorage\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n-        self.portal.invokeFactory(\'Link\', \'link\')\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n+        self.portal.invokeFactory("Document", "doc")\n+        self.portal.invokeFactory("Link", "link")\n+        self.portal.invokeFactory("Folder", "folder")\n         # the event subscriber should be able to handle unversioned content\n-        self.portal.invokeFactory(\'Document\', \'unversioned_doc\')\n+        self.portal.invokeFactory("Document", "unversioned_doc")\n         doc = self.portal.doc\n         doc_histid = portal_hidhandler.register(doc)\n         portal_storage.register(\n-            doc_histid, ObjectData(aq_base(doc)), metadata=self.buildMetadata(\'initial\')\n+            doc_histid, ObjectData(aq_base(doc)), metadata=self.buildMetadata("initial")\n         )\n         portal_storage.save(\n-            doc_histid, ObjectData(aq_base(doc)), metadata=self.buildMetadata(\'v2\')\n+            doc_histid, ObjectData(aq_base(doc)), metadata=self.buildMetadata("v2")\n         )\n         link = self.portal.link\n         link_histid = portal_hidhandler.register(link)\n         portal_storage.register(\n             link_histid,\n             ObjectData(aq_base(link)),\n-            metadata=self.buildMetadata(\'initial\'),\n+            metadata=self.buildMetadata("initial"),\n         )\n         folder = self.portal.folder\n         folder_histid = portal_hidhandler.register(folder)\n         portal_storage.register(\n             folder_histid,\n             ObjectData(aq_base(folder)),\n-            metadata=self.buildMetadata(\'first draft\'),\n+            metadata=self.buildMetadata("first draft"),\n         )\n         dochist = portal_storage.retrieve(doc_histid).object\n         doctype = dochist.object.portal_type\n-        self.assertEqual(\'Document\', doctype)\n+        self.assertEqual("Document", doctype)\n         linkhist = portal_storage.retrieve(link_histid).object\n         linktype = linkhist.object.portal_type\n-        self.assertEqual(\'Link\', linktype)\n+        self.assertEqual("Link", linktype)\n         folderhist = portal_storage.retrieve(folder_histid).object\n         foldertype = folderhist.object.portal_type\n-        self.assertEqual(\'Folder\', foldertype)\n-        self.portal.manage_delObjects(ids=[\'doc\', \'link\', \'folder\', \'unversioned_doc\'])\n+        self.assertEqual("Folder", foldertype)\n+        self.portal.manage_delObjects(ids=["doc", "link", "folder", "unversioned_doc"])\n         removed_doc = portal_storage.retrieve(history_id=doc_histid)\n         self.assertTrue(type(removed_doc.object) == Removed)\n         removed_link = portal_storage.retrieve(history_id=link_histid)\ndiff --git a/Products/CMFEditions/tests/test_doctests.py b/Products/CMFEditions/tests/test_doctests.py\nindex a06b1b8..4281076 100644\n--- a/Products/CMFEditions/tests/test_doctests.py\n+++ b/Products/CMFEditions/tests/test_doctests.py\n@@ -24,5 +24,5 @@ def __init__(self, obid):\n \n def test_suite():\n     suite = unittest.TestSuite()\n-    suite.addTest(doctest.DocFileSuite(\'large_file_modifiers.rst\'))\n+    suite.addTest(doctest.DocFileSuite("large_file_modifiers.rst"))\n     return suite\ndiff --git a/Products/CMFEditions/tests/test_versions_history_form.py b/Products/CMFEditions/tests/test_versions_history_form.py\nindex 495c72f..01f4125 100644\n--- a/Products/CMFEditions/tests/test_versions_history_form.py\n+++ b/Products/CMFEditions/tests/test_versions_history_form.py\n@@ -30,8 +30,8 @@\n from zope.publisher.interfaces.browser import IBrowserView\n \n \n-_TEXT_INITIAL = u\'Initial text.\'\n-_TEXT_NEW = u\'New text.\'\n+_TEXT_INITIAL = u"Initial text."\n+_TEXT_NEW = u"New text."\n \n \n class TestVersionsHistoryForm(CMFEditionsBaseTestCase):\n@@ -39,24 +39,24 @@ def setUp(self):\n         super(TestVersionsHistoryForm, self).setUp()\n         self.portal_repository = self.portal.portal_repository\n         self.portal.invokeFactory(\n-            \'Document\',\n-            \'doc\',\n-            title=\'Document 1\',\n-            text=RichTextValue(_TEXT_INITIAL, \'text/plain\', \'text/plain\'),\n+            "Document",\n+            "doc",\n+            title="Document 1",\n+            text=RichTextValue(_TEXT_INITIAL, "text/plain", "text/plain"),\n         )\n         self.doc = self.portal.doc\n-        self.portal_repository.applyVersionControl(self.doc, comment=\'save version 0\')\n+        self.portal_repository.applyVersionControl(self.doc, comment="save version 0")\n         self.request = self.portal.REQUEST\n \n     def test_versions_history_form(self):\n-        self.doc.text = RichTextValue(_TEXT_NEW, \'text/plain\', \'text/plain\')\n-        self.portal_repository.save(self.doc, comment=\'save version 1\')\n+        self.doc.text = RichTextValue(_TEXT_NEW, "text/plain", "text/plain")\n+        self.portal_repository.save(self.doc, comment="save version 1")\n \n-        html = self._render_versions_history_form(item=self.doc, version_id=\'0\')\n+        html = self._render_versions_history_form(item=self.doc, version_id="0")\n         self.assertTrue(_TEXT_INITIAL in html)\n         self.assertFalse(_TEXT_NEW in html)\n \n-        html = self._render_versions_history_form(item=self.doc, version_id=\'1\')\n+        html = self._render_versions_history_form(item=self.doc, version_id="1")\n         self.assertFalse(_TEXT_INITIAL in html)\n         self.assertTrue(_TEXT_NEW in html)\n \n@@ -64,7 +64,7 @@ def test_versions_history_form_custom_version_view(self):\n         """Assert that if we define an @@version-view then it will be used to\n         display the versions.\n         """\n-        dummy_str = \'Blah\'\n+        dummy_str = "Blah"\n \n         class DummyVersionView(BrowserView):\n             def __call__(self):\n@@ -74,13 +74,13 @@ def __call__(self):\n             factory=DummyVersionView,\n             adapts=(Interface, Interface),\n             provides=IBrowserView,\n-            name=\'version-view\',\n+            name="version-view",\n         )\n \n-        html = self._render_versions_history_form(item=self.doc, version_id=\'0\')\n+        html = self._render_versions_history_form(item=self.doc, version_id="0")\n         self.assertTrue(dummy_str in html)\n         self.assertFalse(_TEXT_INITIAL in html)\n \n     def _render_versions_history_form(self, item, version_id):\n-        self.request[\'version_id\'] = version_id\n-        return item.unrestrictedTraverse(\'versions_history_form\')()\n+        self.request["version_id"] = version_id\n+        return item.unrestrictedTraverse("versions_history_form")()\ndiff --git a/Products/CMFEditions/utilities.py b/Products/CMFEditions/utilities.py\nindex 47e43df..fd4cd2c 100644\n--- a/Products/CMFEditions/utilities.py\n+++ b/Products/CMFEditions/utilities.py\n@@ -30,7 +30,7 @@\n import random\n \n \n-STUB_OBJECT_PREFIX = \'_CMFEditionsTempId\'\n+STUB_OBJECT_PREFIX = "_CMFEditionsTempId"\n \n \n class KwAsAttributes(Persistent):\n@@ -63,7 +63,7 @@ def dereference(obj=None, history_id=None, zodb_hook=None):\n         # try to use the reference as zodb hook\n         zodb_hook = obj\n \n-    portal_uidhandler = getToolByName(zodb_hook, \'portal_historyidhandler\')\n+    portal_uidhandler = getToolByName(zodb_hook, "portal_historyidhandler")\n \n     if history_id is None:\n         if obj is None:\n@@ -80,10 +80,10 @@ def dereference(obj=None, history_id=None, zodb_hook=None):\n     return obj, history_id\n \n \n-def generateId(parent, prefix=\'\', volatile=False):\n+def generateId(parent, prefix="", volatile=False):\n     """Generate an unused id (optionaly a volatile one)."""\n     existingIds = parent.objectIds()\n-    idTemplate = \'%s%s_%%s\' % (volatile * \'__v_\', prefix + STUB_OBJECT_PREFIX)\n+    idTemplate = "%s%s_%%s" % (volatile * "__v_", prefix + STUB_OBJECT_PREFIX)\n     while 1:\n         id = idTemplate % random.randrange(1000000)\n         if id not in existingIds:\n@@ -92,16 +92,16 @@ def generateId(parent, prefix=\'\', volatile=False):\n \n def isObjectVersioned(obj):\n     """Return true iff object has a version_id."""\n-    return getattr(aq_base(obj), \'version_id\', None) is not None\n+    return getattr(aq_base(obj), "version_id", None) is not None\n \n \n def isObjectChanged(obj):\n-    pr = getToolByName(obj, \'portal_repository\', None)\n+    pr = getToolByName(obj, "portal_repository", None)\n     if pr is None:\n         return False\n \n     changed = False\n-    if getattr(aq_base(obj), \'version_id\', None) is None:\n+    if getattr(aq_base(obj), "version_id", None) is None:\n         changed = True\n     else:\n         try:\n@@ -114,8 +114,8 @@ def isObjectChanged(obj):\n     return changed\n \n \n-def maybeSaveVersion(obj, policy=\'at_edit_autoversion\', comment=\'\', force=False):\n-    pr = getToolByName(obj, \'portal_repository\', None)\n+def maybeSaveVersion(obj, policy="at_edit_autoversion", comment="", force=False):\n+    pr = getToolByName(obj, "portal_repository", None)\n     if pr is not None:\n         isVersionable = pr.isVersionable(obj)\n \ndiff --git a/Products/__init__.py b/Products/__init__.py\nindex eda5e9f..ca12a73 100644\n--- a/Products/__init__.py\n+++ b/Products/__init__.py\n@@ -1,7 +1,7 @@\n # -*- coding: utf-8 -*-\n # See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n try:\n-    __import__(\'pkg_resources\').declare_namespace(__name__)\n+    __import__("pkg_resources").declare_namespace(__name__)\n except ImportError:\n     from pkgutil import extend_path\n \ndiff --git a/setup.py b/setup.py\nindex a58cb35..01b0157 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -4,13 +4,13 @@\n \n \n with open("README.rst") as myfile:\n-    long_description = myfile.read() + \'\\n\'\n+    long_description = myfile.read() + "\\n"\n with open("CHANGES.rst") as myfile:\n     long_description += myfile.read()\n-version = \'4.0.0a2.dev0\'\n+version = "4.0.0a2.dev0"\n \n setup(\n-    name=\'Products.CMFEditions\',\n+    name="Products.CMFEditions",\n     version=version,\n     description="Versioning for Plone",\n     long_description=long_description,\n@@ -28,40 +28,40 @@\n         "Programming Language :: Python :: 3.8",\n         "Programming Language :: Python :: 3.9",\n     ],\n-    keywords=\'Versioning Plone\',\n-    author=\'CMFEditions contributers\',\n-    author_email=\'collective-versioning@lists.sourceforge.net\',\n-    url=\'https://pypi.org/project/Products.CMFEditions\',\n-    license=\'GPL\',\n+    keywords="Versioning Plone",\n+    author="CMFEditions contributers",\n+    author_email="collective-versioning@lists.sourceforge.net",\n+    url="https://pypi.org/project/Products.CMFEditions",\n+    license="GPL",\n     packages=find_packages(),\n-    namespace_packages=[\'Products\'],\n+    namespace_packages=["Products"],\n     include_package_data=True,\n     zip_safe=False,\n     extras_require=dict(\n         test=[\n-            \'plone.app.testing\',\n-            \'plone.app.textfield\',\n-            \'Products.CMFPlone\',\n-            \'Products.CMFDynamicViewFTI\',\n-            \'zope.testing\',\n+            "plone.app.testing",\n+            "plone.app.textfield",\n+            "Products.CMFPlone",\n+            "Products.CMFDynamicViewFTI",\n+            "zope.testing",\n         ]\n     ),\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'zope.copy\',\n-        \'zope.dottedname\',\n-        \'zope.i18nmessageid\',\n-        \'zope.interface\',\n-        \'Products.CMFCore >=2.1\',\n-        \'Products.CMFDiffTool\',  # dependency in diff template\n-        \'Products.CMFUid\',\n-        \'Products.GenericSetup >=1.4.0\',\n-        \'Products.ZopeVersionControl\',\n-        \'Acquisition\',\n-        \'DateTime\',\n-        \'transaction\',\n-        \'Zope2\',\n+        "setuptools",\n+        "six",\n+        "zope.copy",\n+        "zope.dottedname",\n+        "zope.i18nmessageid",\n+        "zope.interface",\n+        "Products.CMFCore >=2.1",\n+        "Products.CMFDiffTool",  # dependency in diff template\n+        "Products.CMFUid",\n+        "Products.GenericSetup >=1.4.0",\n+        "Products.ZopeVersionControl",\n+        "Acquisition",\n+        "DateTime",\n+        "transaction",\n+        "Zope2",\n     ],\n     entry_points="""\n     [z3c.autoinclude.plugin]\n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-16T23:38:03+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/82c94cc23b18a910deeb781e5e7ccb1e46e5decd

setup.cfg: do not create universal wheel. Not py 2 compatible.

Files changed:
M setup.cfg

b'diff --git a/setup.cfg b/setup.cfg\nindex 06aa277..526aeb2 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,6 +1,2 @@\n-[zest.releaser]\n-create-wheel = yes\n-\n-# When Python 2-3 compatible:\n [bdist_wheel]\n-universal = 1\n+universal = 0\n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-16T23:38:18+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/c409745ed10b02266f0485e7e657e3520e9d6ede

isort config

Files changed:
M setup.cfg

b'diff --git a/setup.cfg b/setup.cfg\nindex 526aeb2..965bc82 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,2 +1,9 @@\n [bdist_wheel]\n universal = 0\n+\n+[isort]\n+# black compatible isort rules:\n+profile = black\n+force_alphabetical_sort = True\n+force_single_line = True\n+lines_after_imports = 2\n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-16T23:39:26+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/5911b2c281badfc2b920c3484b8252f4bd2520ba

isort

Files changed:
M Products/CMFEditions/ArchivistTool.py
M Products/CMFEditions/CopyModifyMergeRepositoryTool.py
M Products/CMFEditions/ModifierRegistryTool.py
M Products/CMFEditions/Modifiers.py
M Products/CMFEditions/ReferenceFactoriesTool.py
M Products/CMFEditions/StandardModifiers.py
M Products/CMFEditions/interfaces/__init__.py

b'diff --git a/Products/CMFEditions/ArchivistTool.py b/Products/CMFEditions/ArchivistTool.py\nindex ab73573..50c960d 100644\n--- a/Products/CMFEditions/ArchivistTool.py\n+++ b/Products/CMFEditions/ArchivistTool.py\n@@ -25,10 +25,10 @@\n \n from AccessControl import ClassSecurityInfo\n from AccessControl import getSecurityManager\n+from AccessControl.class_init import InitializeClass\n from Acquisition import aq_base\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n-from AccessControl.class_init import InitializeClass\n from OFS.SimpleItem import SimpleItem\n from Persistence import Persistent\n from Products.CMFCore.utils import getToolByName\ndiff --git a/Products/CMFEditions/CopyModifyMergeRepositoryTool.py b/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\nindex 85d07e0..b7de428 100644\n--- a/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\n+++ b/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\n@@ -25,11 +25,11 @@\n \n from AccessControl import ClassSecurityInfo\n from AccessControl import Unauthorized\n+from AccessControl.class_init import InitializeClass\n from Acquisition import aq_base\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n from Acquisition import ImplicitAcquisitionWrapper\n-from AccessControl.class_init import InitializeClass\n from BTrees.OOBTree import OOBTree\n from OFS.SimpleItem import SimpleItem\n from Products.CMFCore.utils import _checkPermission\ndiff --git a/Products/CMFEditions/ModifierRegistryTool.py b/Products/CMFEditions/ModifierRegistryTool.py\nindex 8a35779..158497d 100644\n--- a/Products/CMFEditions/ModifierRegistryTool.py\n+++ b/Products/CMFEditions/ModifierRegistryTool.py\n@@ -24,8 +24,8 @@\n """\n \n from AccessControl import ClassSecurityInfo\n-from Acquisition import aq_base\n from AccessControl.class_init import InitializeClass\n+from Acquisition import aq_base\n from Missing import MV\n from OFS.OrderedFolder import OrderedFolder\n from Products.CMFCore.permissions import ManagePortal\ndiff --git a/Products/CMFEditions/Modifiers.py b/Products/CMFEditions/Modifiers.py\nindex 17fa2be..7552716 100644\n--- a/Products/CMFEditions/Modifiers.py\n+++ b/Products/CMFEditions/Modifiers.py\n@@ -23,10 +23,10 @@\n \n """\n \n+from AccessControl.class_init import InitializeClass\n from Acquisition import aq_base\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n-from AccessControl.class_init import InitializeClass\n from OFS.SimpleItem import SimpleItem\n from Products.CMFCore.Expression import Expression\n from Products.CMFCore.utils import getToolByName\n@@ -38,6 +38,7 @@\n from ZODB.broken import Broken\n from zope.interface import implementer\n \n+\n manage_addModifierForm = PageTemplateFile(\n     "www/modifierAddForm.pt", globals(), __name__="manage_addModifierForm"\n )\ndiff --git a/Products/CMFEditions/ReferenceFactoriesTool.py b/Products/CMFEditions/ReferenceFactoriesTool.py\nindex 2f67637..5055f6a 100644\n--- a/Products/CMFEditions/ReferenceFactoriesTool.py\n+++ b/Products/CMFEditions/ReferenceFactoriesTool.py\n@@ -24,9 +24,9 @@\n """\n \n from AccessControl import ClassSecurityInfo\n+from AccessControl.class_init import InitializeClass\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n-from AccessControl.class_init import InitializeClass\n from OFS.OrderedFolder import OrderedFolder\n from Products.CMFCore.utils import getToolByName\n from Products.CMFCore.utils import UniqueObject\ndiff --git a/Products/CMFEditions/StandardModifiers.py b/Products/CMFEditions/StandardModifiers.py\nindex f5f4042..d334e12 100644\n--- a/Products/CMFEditions/StandardModifiers.py\n+++ b/Products/CMFEditions/StandardModifiers.py\n@@ -25,8 +25,8 @@\n """Standard modifiers\n """\n \n-from Acquisition import aq_base\n from AccessControl.class_init import InitializeClass\n+from Acquisition import aq_base\n from OFS.ObjectManager import ObjectManager\n from plone.folder.default import DefaultOrdering\n from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base\ndiff --git a/Products/CMFEditions/interfaces/__init__.py b/Products/CMFEditions/interfaces/__init__.py\nindex 8cbe52f..f2654ed 100644\n--- a/Products/CMFEditions/interfaces/__init__.py\n+++ b/Products/CMFEditions/interfaces/__init__.py\n@@ -1,8 +1,8 @@\n # -*- coding: utf-8 -*-\n-from Products.CMFEditions.interfaces._tools import IArchivistTool  # noqa: F401\n-from Products.CMFEditions.interfaces._tools import (\n-    IPortalModifierTool,\n-)  # noqa: F401,E501\n+from Products.CMFEditions.interfaces._tools import (  # noqa: F401,E501; noqa: F401\n+    IArchivistTool,\n+)\n+from Products.CMFEditions.interfaces._tools import IPortalModifierTool\n from Products.CMFEditions.interfaces._tools import IPurgePolicyTool  # noqa: F401,E501\n from Products.CMFEditions.interfaces._tools import IStorageTool  # noqa: F401\n from zope import interface\n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-16T23:49:21+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/a55cdeced5a956b1513e78fb5c93694a8c5d5257

Various QA fixes.

Files changed:
M Products/CMFEditions/ModifierRegistryTool.py
M Products/CMFEditions/Modifiers.py
M Products/CMFEditions/ZVCStorageTool.py
M Products/CMFEditions/exportimport/repository.py
M Products/CMFEditions/interfaces/__init__.py
M Products/CMFEditions/tests/DummyTools.py

b'diff --git a/Products/CMFEditions/ModifierRegistryTool.py b/Products/CMFEditions/ModifierRegistryTool.py\nindex 158497d..ae25ee0 100644\n--- a/Products/CMFEditions/ModifierRegistryTool.py\n+++ b/Products/CMFEditions/ModifierRegistryTool.py\n@@ -151,7 +151,7 @@ def reattachReferencedAttributes(self, obj, referenced_data):\n \n         for id_name, data in referenced_data.items():\n             id, name = id_name.split("/", 1)\n-            if not id in data_by_modid:\n+            if id not in data_by_modid:\n                 data_by_modid[id] = {}\n             data_by_modid[id][name] = data\n \ndiff --git a/Products/CMFEditions/Modifiers.py b/Products/CMFEditions/Modifiers.py\nindex 7552716..7446dab 100644\n--- a/Products/CMFEditions/Modifiers.py\n+++ b/Products/CMFEditions/Modifiers.py\n@@ -71,7 +71,7 @@ def edit(self, enabled=None, title="", REQUEST=None):\n         """See IConditionalModifier."""\n         self.title = title\n \n-        if enabled is not None and (enabled == "True" or enabled == True):\n+        if enabled is not None and (enabled == "True" or (isinstance(enabled, bool) and enabled)):\n             self._enabled = enabled\n         else:\n             self._enabled = False\ndiff --git a/Products/CMFEditions/ZVCStorageTool.py b/Products/CMFEditions/ZVCStorageTool.py\nindex 0440006..9aab338 100644\n--- a/Products/CMFEditions/ZVCStorageTool.py\n+++ b/Products/CMFEditions/ZVCStorageTool.py\n@@ -84,7 +84,7 @@ def getSize(obj):\n         # check if to return zero (length is zero)\n         if len(obj) == 0:\n             return 0\n-    except:\n+    except:  # noqa E722\n         pass\n \n     try:\n@@ -93,14 +93,14 @@ def getSize(obj):\n             size = obj.getSize()\n             if size is not None:\n                 return size\n-    except:\n+    except:  # noqa E722\n         pass\n \n     try:\n         # string\n         if isinstance(obj, types.StringTypes):\n             return len(obj)\n-    except:\n+    except:  # noqa E722\n         pass\n \n     try:\n@@ -112,7 +112,7 @@ def getSize(obj):\n             size = obj.tell()\n             obj.seek(currentPos)\n             return size\n-    except:\n+    except:  # noqa E722\n         pass\n \n     try:\n@@ -121,7 +121,7 @@ def getSize(obj):\n         p = Pickler(stream, 1)\n         p.dump(obj)\n         size = stream.tell()\n-    except:\n+    except:  # noqa E722\n         size = None\n \n     return size\n@@ -941,7 +941,7 @@ def getVersionId(self, selector, countPurged):\n         if selector is not None:\n             selector = int(selector)\n \n-        ##### looking at special selectors first (None, negative)\n+        # looking at special selectors first (None, negative)\n         length = self.getLength(countPurged)\n         # checking for ``None`` selector (youngest version)\n         if selector is None:\n@@ -955,7 +955,7 @@ def getVersionId(self, selector, countPurged):\n             if selector < 0:\n                 return None\n \n-        #### normal cases (0 <= selectors < length)\n+        # normal cases (0 <= selectors < length)\n         if countPurged:\n             # selector is a normal selector\n             return selector\ndiff --git a/Products/CMFEditions/exportimport/repository.py b/Products/CMFEditions/exportimport/repository.py\nindex 72143bb..c6ac37b 100644\n--- a/Products/CMFEditions/exportimport/repository.py\n+++ b/Products/CMFEditions/exportimport/repository.py\n@@ -43,7 +43,6 @@ def _purgePolicies(self):\n \n     def _initPolicies(self, node):\n         tool = self.context\n-        policynames = [p.getId() for p in tool.listPolicies()]\n         for child in node.childNodes:\n             if child.nodeName == "policies":\n                 if self._shouldPurge(child):\ndiff --git a/Products/CMFEditions/interfaces/__init__.py b/Products/CMFEditions/interfaces/__init__.py\nindex f2654ed..af422ac 100644\n--- a/Products/CMFEditions/interfaces/__init__.py\n+++ b/Products/CMFEditions/interfaces/__init__.py\n@@ -1,9 +1,7 @@\n # -*- coding: utf-8 -*-\n-from Products.CMFEditions.interfaces._tools import (  # noqa: F401,E501; noqa: F401\n-    IArchivistTool,\n-)\n-from Products.CMFEditions.interfaces._tools import IPortalModifierTool\n-from Products.CMFEditions.interfaces._tools import IPurgePolicyTool  # noqa: F401,E501\n+from Products.CMFEditions.interfaces._tools import IArchivistTool  # noqa: F401\n+from Products.CMFEditions.interfaces._tools import IPortalModifierTool  # noqa: F401\n+from Products.CMFEditions.interfaces._tools import IPurgePolicyTool  # noqa: F401\n from Products.CMFEditions.interfaces._tools import IStorageTool  # noqa: F401\n from zope import interface\n \ndiff --git a/Products/CMFEditions/tests/DummyTools.py b/Products/CMFEditions/tests/DummyTools.py\nindex f323601..aa76a4b 100644\n--- a/Products/CMFEditions/tests/DummyTools.py\n+++ b/Products/CMFEditions/tests/DummyTools.py\n@@ -22,8 +22,6 @@\n from six.moves.cPickle import Unpickler\n from zope.interface import implementer\n \n-import types\n-\n \n # Make alog module level so that it survives transaction rollbacks\n alog = []\n@@ -106,11 +104,10 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n             # known default value)\n             portal_hidhandler = getToolByName(obj, "portal_historyidhandler")\n             history_id = portal_hidhandler.register(obj)\n-            version_id = obj.version_id = 0\n+            obj.version_id = 0\n             obj.location_id = 0\n             is_registered = False\n         else:\n-            version_id = len(self.queryHistory(obj))\n             is_registered = True\n \n         base_obj = aq_base(obj)\n@@ -520,7 +517,7 @@ def save(self, history_id, object, referenced_data={}, metadata=None):\n             if not policy.beforeSaveHook(history_id, metadata):\n                 return len(self._histories[history_id]) - 1\n \n-        if not history_id in self._histories:\n+        if history_id not in self._histories:\n             raise StorageUnregisteredError(\n                 "Saving or retrieving an unregistered object is not "\n                 "possible. Register the object with history id \'%s\' first. "\n@@ -632,11 +629,8 @@ def _getHistory(self, history_id):\n             )\n         return history\n \n-    #        return HistoryList(history)\n-\n     def _getLength(self, history_id, countPurged=True):\n         """Returns the length of the history"""\n-        histories = self._histories\n         history = self._getHistory(history_id)\n         if countPurged:\n             return len(history)\n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-16T23:51:24+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/b4f674ff40e8b65a88072b4aaba1002b307c1a6d

Removed Archetypes comment from readme.

Files changed:
M README.rst

b'diff --git a/README.rst b/README.rst\nindex 13fb7d3..3f2a5bb 100644\n--- a/README.rst\n+++ b/README.rst\n@@ -33,7 +33,6 @@ A content panel allows configuring the versioning policy by content type:\n \n By default the contents of a folder is versioned independently of the folder.\n This may be changed through the ZMI and for specific cases on python level.\n-Basic support for Archetypes references is built in.\n \n The current strategy is to save everything of the content item (incl. security\n information, workflow state, etc.). On retrieve some of these information are\n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-16T23:52:48+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/46780487dd6b2a25e91b95adc12bae07443569a4

Replaced deprecated assert statements.

Files changed:
M Products/CMFEditions/tests/test_ArchivistTool.py
M Products/CMFEditions/tests/test_IntegrationTests.py
M Products/CMFEditions/tests/test_KeepLastNVersionsTool.py
M Products/CMFEditions/tests/test_ZVCStorageTool.py

b'diff --git a/Products/CMFEditions/tests/test_ArchivistTool.py b/Products/CMFEditions/tests/test_ArchivistTool.py\nindex 7ba4d61..b38ef1d 100644\n--- a/Products/CMFEditions/tests/test_ArchivistTool.py\n+++ b/Products/CMFEditions/tests/test_ArchivistTool.py\n@@ -308,7 +308,7 @@ def test08_retrieveWithReferences(self):\n         for ref in refs:\n             self.assertTrue(IVersionAwareReference.providedBy(ref))\n             # check info value (see note above)\n-            self.assertEquals(ref.info, refs.index(ref))\n+            self.assertEqual(ref.info, refs.index(ref))\n \n     def test09_isUpToDate(self):\n         doc = self.portal.doc\ndiff --git a/Products/CMFEditions/tests/test_IntegrationTests.py b/Products/CMFEditions/tests/test_IntegrationTests.py\nindex 177b469..b249ce8 100644\n--- a/Products/CMFEditions/tests/test_IntegrationTests.py\n+++ b/Products/CMFEditions/tests/test_IntegrationTests.py\n@@ -199,7 +199,7 @@ def test08_loopOverHistory(self):\n             counter += 1\n \n         # check if history iterator returned just one element\n-        self.assertEquals(counter, 1)\n+        self.assertEqual(counter, 1)\n \n     def test09_retrieveAndRevertRetainWorkingCopiesWorkflowInfo(self):\n         portal_repo = self.portal.portal_repository\ndiff --git a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\nindex c98ed3c..4746864 100644\n--- a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\n+++ b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\n@@ -99,10 +99,10 @@ def test03_retrieveOlderSubstitute(self):\n \n         # next newer\n         data = purgepolicy.retrieveSubstitute(history_id=1, selector=0)\n-        self.assertEquals(data.data, 1)\n+        self.assertEqual(data.data, 1)\n         # next older\n         data = purgepolicy.retrieveSubstitute(history_id=1, selector=2)\n-        self.assertEquals(data.data, 1)\n+        self.assertEqual(data.data, 1)\n         # next older\n         data = purgepolicy.retrieveSubstitute(history_id=1, selector=3)\n-        self.assertEquals(data.data, 1)\n+        self.assertEqual(data.data, 1)\ndiff --git a/Products/CMFEditions/tests/test_ZVCStorageTool.py b/Products/CMFEditions/tests/test_ZVCStorageTool.py\nindex 49004c6..fec1a1f 100644\n--- a/Products/CMFEditions/tests/test_ZVCStorageTool.py\n+++ b/Products/CMFEditions/tests/test_ZVCStorageTool.py\n@@ -175,24 +175,24 @@ def test05_getHistory(self):\n         length = len(history)\n \n         # check length\n-        self.assertEquals(length, 3)\n+        self.assertEqual(length, 3)\n \n         # iterating over the history\n         for i, vdata in enumerate(history):\n             expected_test = "v%s of text" % (i + 1)\n-            self.assertEquals(vdata.object.object.text, expected_test)\n-            self.assertEquals(history[i].object.object.text, expected_test)\n+            self.assertEqual(vdata.object.object.text, expected_test)\n+            self.assertEqual(history[i].object.object.text, expected_test)\n \n             expected_comment = "saved v%s" % (i + 1)\n             self.assertEqual(self.getComment(vdata), expected_comment)\n             self.assertEqual(self.getComment(history[i]), expected_comment)\n \n         # accessing the versions\n-        self.assertEquals(history[0].object.object.text, "v1 of text")\n+        self.assertEqual(history[0].object.object.text, "v1 of text")\n         self.assertEqual(self.getComment(history[0]), "saved v1")\n-        self.assertEquals(history[1].object.object.text, "v2 of text")\n+        self.assertEqual(history[1].object.object.text, "v2 of text")\n         self.assertEqual(self.getComment(history[1]), "saved v2")\n-        self.assertEquals(history[2].object.object.text, "v3 of text")\n+        self.assertEqual(history[2].object.object.text, "v3 of text")\n         self.assertEqual(self.getComment(history[2]), "saved v3")\n \n     def test06_checkObjectManagerIntegrity(self):\n@@ -238,7 +238,7 @@ def test07_getModificationDate(self):\n             object=ObjectData(obj),\n             metadata=self.buildMetadata("saved v2"),\n         )\n-        self.assertNotEquals(v1, v2)\n+        self.assertNotEqual(v1, v2)\n         self.assertEqual(v2_modified, portal_storage.getModificationDate(history_id=1))\n         self.assertEqual(\n             v2_modified, portal_storage.getModificationDate(history_id=1, selector=v2)\n@@ -391,8 +391,8 @@ def test11_purgeOnSave(self):\n         )\n         history = portal_storage.getHistory(1, countPurged=False)\n \n-        self.assertEquals(sel, 0)\n-        self.assertEquals(len(history), 1)\n+        self.assertEqual(sel, 0)\n+        self.assertEqual(len(history), 1)\n         self.assertEqual(history[0].object.object.text, "v1 of text")\n         self.assertEqual(self.getComment(history[0]), "saved v1")\n \n@@ -404,8 +404,8 @@ def test11_purgeOnSave(self):\n         )\n         history = portal_storage.getHistory(1, countPurged=False)\n \n-        self.assertEquals(sel, 1)\n-        self.assertEquals(len(history), 2)\n+        self.assertEqual(sel, 1)\n+        self.assertEqual(len(history), 2)\n         self.assertEqual(history[0].object.object.text, "v1 of text")\n         self.assertEqual(self.getComment(history[0]), "saved v1")\n         self.assertEqual(history[1].object.object.text, "v2 of text")\n@@ -422,11 +422,11 @@ def test11_purgeOnSave(self):\n \n         # iterating over the history\n         for i, vdata in enumerate(history):\n-            self.assertEquals(vdata.object.object.text, "v%s of text" % (i + 2))\n+            self.assertEqual(vdata.object.object.text, "v%s of text" % (i + 2))\n             self.assertEqual(self.getComment(vdata), "saved v%s" % (i + 2))\n \n-        self.assertEquals(sel, 2)\n-        self.assertEquals(length, 2)\n+        self.assertEqual(sel, 2)\n+        self.assertEqual(length, 2)\n         self.assertEqual(history[0].object.object.text, "v2 of text")\n         self.assertEqual(self.getComment(history[0]), "saved v2")\n         self.assertEqual(history[1].object.object.text, "v3 of text")\n@@ -443,11 +443,11 @@ def test11_purgeOnSave(self):\n \n         # iterating over the history\n         for i, vdata in enumerate(history):\n-            self.assertEquals(vdata.object.object.text, "v%s of text" % (i + 3))\n+            self.assertEqual(vdata.object.object.text, "v%s of text" % (i + 3))\n             self.assertEqual(self.getComment(vdata), "saved v%s" % (i + 3))\n \n-        self.assertEquals(sel, 3)\n-        self.assertEquals(length, 2)\n+        self.assertEqual(sel, 3)\n+        self.assertEqual(length, 2)\n         self.assertEqual(history[0].object.object.text, "v3 of text")\n         self.assertEqual(self.getComment(history[0]), "saved v3")\n         self.assertEqual(history[1].object.object.text, "v4 of text")\n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-17T00:11:44+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/188bb3ece6de469b8e8051aabd0818db115b9f40

Fixed deprecation warnings in tests.

Files changed:
M Products/CMFEditions/Modifiers.py
M Products/CMFEditions/testing.py
M Products/CMFEditions/tests/test_IntegrationTests.py

b'diff --git a/Products/CMFEditions/Modifiers.py b/Products/CMFEditions/Modifiers.py\nindex 7446dab..1ca9091 100644\n--- a/Products/CMFEditions/Modifiers.py\n+++ b/Products/CMFEditions/Modifiers.py\n@@ -71,7 +71,9 @@ def edit(self, enabled=None, title="", REQUEST=None):\n         """See IConditionalModifier."""\n         self.title = title\n \n-        if enabled is not None and (enabled == "True" or (isinstance(enabled, bool) and enabled)):\n+        if enabled is not None and (\n+            enabled == "True" or (isinstance(enabled, bool) and enabled)\n+        ):\n             self._enabled = enabled\n         else:\n             self._enabled = False\ndiff --git a/Products/CMFEditions/testing.py b/Products/CMFEditions/testing.py\nindex 976f929..f0cdd6d 100644\n--- a/Products/CMFEditions/testing.py\n+++ b/Products/CMFEditions/testing.py\n@@ -5,7 +5,7 @@\n from plone.app.testing import FunctionalTesting\n from plone.app.testing import IntegrationTesting\n from plone.app.testing import PloneSandboxLayer\n-from plone.testing import z2\n+from plone.testing.zope import WSGI_SERVER_FIXTURE\n \n import Products.CMFEditions\n \n@@ -60,7 +60,7 @@ def setUpPloneSite(self, portal):\n     bases=(\n         PRODUCTS_CMFEDITIONS_FIXTURE,\n         REMOTE_LIBRARY_BUNDLE_FIXTURE,\n-        z2.ZSERVER_FIXTURE,\n+        WSGI_SERVER_FIXTURE,\n     ),\n     name="ProductsCmfeditionsLayer:AcceptanceTesting",\n )\ndiff --git a/Products/CMFEditions/tests/test_IntegrationTests.py b/Products/CMFEditions/tests/test_IntegrationTests.py\nindex b249ce8..b9e911f 100644\n--- a/Products/CMFEditions/tests/test_IntegrationTests.py\n+++ b/Products/CMFEditions/tests/test_IntegrationTests.py\n@@ -32,9 +32,9 @@\n from zope.component.persistentregistry import PersistentComponents\n from zope.interface.interface import InterfaceClass\n \n-import imp\n import sys\n import transaction\n+import types\n import ZODB.interfaces\n \n \n@@ -1178,7 +1178,7 @@ def test26_RegistryBasesNotVersionedOrRestored(self):\n             Broken=ZODB.interfaces.IBroken,\n             type=InterfaceClass,\n         )\n-        sys.modules[broken_iface.__module__] = module = imp.new_module(\n+        sys.modules[broken_iface.__module__] = module = types.ModuleType(\n             broken_iface.__module__\n         )\n         module.IMissing = broken_iface\n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-17T00:17:55+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/b7056ff080817d6f5f548fae29f3f80381eea4cf

Moved changes before 3.0 to docs/old-changelog.rst.

This means only about 10 percent is left in the main CHANGES.rst.

Files changed:
A doc/old-changelog.rst
M CHANGES.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex b9897a5..55435ed 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -181,1248 +181,4 @@ Breaking changes:\n   [tschorr]\n \n \n-2.2.23 (2016-12-05)\n--------------------\n-\n-Bug fixes:\n-\n-- In ShadowStorage\'s `isRegistered` and `getHistory` methods,\n-  avoid checking for a history_id of None in the storage\'s BTree.\n-  This fixes compatibility with BTrees 4.x,\n-  which disallows comparing keys to None.\n-  [davisagli]\n-\n-\n-2.2.22 (2016-11-17)\n--------------------\n-\n-Bug fixes:\n-\n-- Fix deprecated import from Globals that is changed in Zope4.\n-  [pbauer]\n-\n-- Do not log using plone restricted python logging script.\n-  [jensens]\n-\n-- Adapt tests to the new indexing operations queueing.\n-  Part of PLIP 1343: https://github.com/plone/Products.CMFPlone/issues/1343\n-  [gforcada]\n-\n-2.2.21 (2016-08-18)\n--------------------\n-\n-Bug fixes:\n-\n-- Use zope.interface decorator.\n-  [gforcada]\n-\n-\n-2.2.20 (2016-04-15)\n--------------------\n-\n-Fixes:\n-\n-- Fixed CloneBlobs modifier to only react on Archetypes.\n-  This fix allows Dexterity Blob-Types (e.g. File, Image) to be versioned.\n-  [iham]\n-\n-\n-2.2.19 (2016-02-14)\n--------------------\n-\n-Fixes:\n-\n-- Fixed sometimes failing test.  [maurits]\n-\n-\n-2.2.18 (2015-11-25)\n--------------------\n-\n-Fixes:\n-\n-- Removed executable bit from various files.  And do a quick release,\n-  as on a test server the previous release was somehow missing a file.\n-  [maurits]\n-\n-\n-2.2.17 (2015-11-25)\n--------------------\n-\n-Fixes:\n-\n-- Made storage statistics test more robust.\n-  See https://github.com/plone/Products.CMFEditions/issues/31\n-  [tschorr]\n-\n-\n-2.2.16 (2015-09-27)\n--------------------\n-\n-- Input sanitation for retrieveSubstitute()\n-  [zupo]\n-\n-\n-2.2.15 (2015-09-15)\n--------------------\n-\n-- use unrestricted search for storage statistics\n-  [tschorr]\n-\n-\n-2.2.14 (2015-08-13)\n--------------------\n-\n-- Do not call ndiff unless there is no html_diff.  Removed strange\n-  unicode space from template.  Related to\n-  https://github.com/plone/Products.CMFPlone/issues/820\n-  [maurits]\n-\n-\n-2.2.13 (2015-04-26)\n--------------------\n-\n-- Drop use of python:exists() in templates.\n-  [pbauer]\n-\n-- Replace deprecated JavaScript functions with their jQuery equivalents.\n-  [thet]\n-\n-\n-2.2.12 (2015-03-13)\n--------------------\n-\n-- Remove dependency on old Archetypes tests\n-  [tomgross]\n-\n-- Ported tests to plone.app.testing\n-  [tomgross]\n-\n-- Removed old FAQ testing code. Should go in a seperate product, if needed.\n-  [tomgross]\n-\n-- Frosted cleanups\n-  [tomgross]\n-\n-2.2.11 (2014-10-23)\n--------------------\n-\n-- Depend on ZODB3>=3.9.0 for blob support.\n-  [tomgross]\n-\n-- Fix AT tests to work with plone.app.blob plone.app.blob >=1.5.11\n-  [jensens]\n-\n-\n-2.2.10 (2014-09-07)\n--------------------\n-\n-- Fix #16: Allow developers to define a ``@@version-view`` to customize how a version of an item is\n-  displayed in ``versions_history_form.pt``.\n-  [rafaelbco]\n-\n-- Fix #14: Duplicate functionality in ``@@history`` and ``version_diff.pt``.\n-  Now ``version_diff.pt`` is deprecated.\n-  [rafaelbco]\n-\n-- Fix bug: ``CopyModifyMergeRepositoryTool.manage_setTypePolicies`` method\n-  modifies sequence while iterating over it.\n-  [rafaelbco]\n-\n-- Purging old versions did not properly remove all references\n-  to the blob fields, resulting in old blobs to stay there forever.\n-  [do3cc]\n-\n-2.2.9 (2013-12-07)\n-------------------\n-\n-- Use search_icon.png instead of search_icon.gif in version_image_view.pt.\n-  The page crashed because search_icon.gif couldn\'t be found.\n-  [vincentfretin]\n-\n-- Do not depend on the ``jq`` variable in the history view.\n-  [maurits]\n-\n-2.2.8 (2013-03-05)\n-------------------\n-\n-- Fix modifier check that made AT assumptions about Dexterity\n-  content.\n-  [rpatterson]\n-\n-- Remove hard dependency on Archetypes.\n-  [davisagli]\n-\n-2.2.7 (2013-01-01)\n-------------------\n-\n-- put back the history legend for compare/diff versions, fixes #9371\n-  [maartenkling]\n-\n-- Site administrators do revisioning\n-\n-2.2.6 (2012-10-16)\n-------------------\n-\n-- Update ``IPossibleSite`` import to ``zope.component``.\n-  [elro]\n-\n-2.2.5 (2012-08-11)\n-------------------\n-\n-- Fixed version file preview for empty files.\n-  [thomasdesvenain]\n-\n-- Fixed versions history form:\n-  title and description aren\'t displayed two times.\n-  [thomasdesvenain]\n-\n-- Fixed version file preview:\n-  some displayed values of a previous version were values of current version.\n-  [thomasdesvenain]\n-\n-- ArchivistTool.py, DummyTools.py, IArchivist.py, ModifierRegistryTool.py:\n-  Don\'t use list as default parameter value.\n-  [kleist]\n-\n-\n-2.2.4 (2012-06-27)\n-------------------\n-\n-- Add upgrade step to install the component registry bases modifier.\n-  [rossp]\n-\n-- Skip blob files from plone.namedfile even when they no longer\n-  extend the classes from z3c.blobfile.\n-  [davisagli]\n-\n-- Declare missing dependency on zope.copy.\n-  [hannosch]\n-\n-\n-2.2.3 (2012-01-26)\n-------------------\n-\n-- Changed the get_macros python skin script into a browser view.  This\n-  avoids an Unauthorized exception when viewing revisions when using\n-  five.pt (Chameleon).\n-  [maurits]\n-\n-- Implement a special base modifier that allows retention of specific\n-  annotation elements from the working copy.  Use this in the OM\n-  modifiers to ensure we don\'t stomp annotations for folders on retrieval.\n-  [alecm]\n-\n-- If an object has a component registry (AKA site manager), make sure\n-  the bases of that registry are not recursively copied when saving\n-  versions.\n-  [rossp]\n-\n-2.2.2 (2011-10-17)\n-------------------\n-\n-- Don\'t string convert blobs.  Fixes MemoryErrors or excessive memory\n-  consumption with large blobs.\n-  [rossp]\n-\n-- Protect against anonymous access to KwAsAttributes.\n-  [mj]\n-\n-2.2.1 (2011-09-19)\n-------------------\n-\n-- Merged changes from 2.1.5.\n-  [lentinj]\n-\n-2.2 (2011-08-23)\n-----------------\n-\n-- Make Zope 2 permissions available as Zope 3-style permissions.\n-  [rafaelbco]\n-\n-- Changed ``@@history`` to be protected by ``CMFEditions.AccessPreviousVersions`` instead of\n-  ``cmf.ModifyPortalContent``.\n-  [rafaelbco]\n-\n-- Only show the "Revert to this version" button if the user has the ``Revert to previous versions``\n-  permission in ``versions_history_form``.\n-  [rafaelbco]\n-\n-2.1.5 (2011-09-19)\n-------------------\n-\n-- Translate the commit message, so version id is substituted.\n-  [lentinj]\n-\n-- Only save an initial version before edit when content is not yet versioned,\n-  rather than every time there are unsaved changes. Otherwise there is an\n-  "Initial version" generated for every edit after publish/retract, as these\n-  change the publishing date without a new version being saved. Possibly a\n-  version should be saved on publish, but not sure the extra versioning noise\n-  is useful.\n-  [lentinj]\n-\n-2.1.4 (2011-08-31)\n-------------------\n-\n-- Remove references to blobs when cloning blob fields. They are handled as\n-  referenced attributes anyway. This eliminates the creation of an additional\n-  empty blob when cloning blob fields.\n-  [buchi]\n-\n-- No longer store references in the ZVC wrapper. They are stored in the shadow\n-  history and retrieved from there. This eliminates the creation of an\n-  additional empty blob when cloning blob fields.\n-  [buchi]\n-\n-- Allow to translate the string "current" in the diff view (``@@history``) and in the\n-  ``version_diff`` template.\n-  [rafaelbco]\n-\n-2.1.3 (2011-04-03)\n-------------------\n-\n-- Fixed: Unauthorized error on versions history form for non managers.\n-  [thomasdesvenain]\n-\n-2.1.2 (2011-03-25)\n-------------------\n-\n-- remove UniqueIdHandlerTool, it was not used anymore;\n-  nobody (including vds and hannosch) seems to remember what it was for.\n-  [gotcha]\n-\n-- fix portal_historyidhandler class to avoid issue where GenericSetup toolset\n-  import step tried to change the class default id\n-  [gotcha]\n-\n-- Skip z3c.blobfile File (notable subclasess plone.namedfile BlobFile and\n-  BlobImage) as blobfile versioning is not there yet.\n-  [elro]\n-\n-2.1.1 - 2011-02-25\n-------------------\n-\n-- Fix bug when loading GenericSetup profile with ``<policymap purge="true">``.\n-  [elro]\n-\n-2.1.0 - 2011-02-25\n-------------------\n-\n-- Generic Setup export/import support.\n-  [elro]\n-\n-2.0.5 - 2011-02-25\n-------------------\n-\n-- Workaround some potential issues with event handlers and\n-  transaction.savepoint which can cause exceptions when, for example,\n-  zope.sendmail is used to send mail in the same transaction as saving\n-  an edition.\n-  [rossp]\n-\n-2.0.4 - 2011-01-03\n-------------------\n-\n-- Depend on ``Products.CMFPlone`` instead of ``Plone``.\n-  [elro]\n-\n-- Do not provide "Compare to ... revision" link in versions history actions\n-  if content type has no diffable field.\n-  [thomasdesvenain]\n-\n-- Add Site Administrator role to various permissions, for forward compatibility\n-  with Plone 4.1.\n-  [davisagli]\n-\n-2.0.3 - 2010-11-06\n-------------------\n-\n-- Internationalized default version comments (\'Initial revision\', etc.).\n-  [thomasdesvenain]\n-\n-- Fixed: version comment was not considered when saving a content with\n-  automatic version policy. Closes http://dev.plone.org/plone/ticket/8535.\n-  [thomasdesvenain]\n-\n-- Fixed multiple chameleon incompatibilities.\n-  [swampmonkey]\n-\n-2.0.2 - 2010-09-09\n-------------------\n-\n-- Forward port of a i18n fix from branches/1.2. It\'s used to create a\n-  changeset, the message doesn\'t seem to appear on the history view though.\n-  [vincentfretin]\n-\n-- Added missing i18n markup to variables in ``update_version_before_edit.cpy``.\n-  [WouterVH]\n-\n-2.0.1 - 2010-08-08\n-------------------\n-\n-- Changed "version" to "revision" in portal messages.\n-  [kleist]\n-\n-2.0 - 2010-07-18\n-----------------\n-\n-- Changed the text in the `@@history` page to use the term revision instead of\n-  version. This fixes http://dev.plone.org/plone/ticket/10740.\n-  [hannosch]\n-\n-- Added dependency on plone.app.blob, to pull in the needed bits for\n-  handling blobs in the modifiers.\n-  [davidblewett]\n-\n-- Added event listeners for Archetypes\' ObjectInitializedEvent and\n-  ObjectEditedEvent events (to go along with the existing WebDAV ones).\n-  [davidblewett]\n-\n-- Changed Plone 3 backward compatible handling to also work with Chameleon.\n-  [do3cc]\n-\n-2.0b9 - 2010-06-13\n-------------------\n-\n-- Avoid dependency on zope.app.testing.\n-  [hannosch]\n-\n-2.0b8 - 2010-05-20\n-------------------\n-\n-- Added notification of changes on revert, via zope.lifecycle\'s\n-  ObjectModifiedEvent and Archetypes\' ObjectEditedEvent.\n-  [davidblewett]\n-\n-- Fixed revertversion.py so that it didn\'t tack on a lone / to the redirect\n-  URL.\n-  [davidblewett]\n-\n-- Fixed CloneBlob & company, so that they check that the field provides an\n-  interface instead of using isinstance.\n-  [davidblewett]\n-\n-- Fixed CloneBlob to not trample its local variables, allowing for multiple\n-  blob fields on a type.\n-  [davidblewett]\n-\n-- Updated i18n methods that used mappings.\n-  [davidblewett]\n-\n-2.0b7 - 2010-05-08\n-------------------\n-\n-- Fix BLOB history corruption\n-  http://dev.plone.org/plone/ticket/10503\n-  [do3cc]\n-\n-2.0b6 - 2010-04-20\n-------------------\n-\n-- Widen html diff display to work better with new layout.\n-  [alecm]\n-\n-- Fix issue with versioning of large folders.\n-  http://dev.plone.org/plone/ticket/10457\n-  [alecm]\n-\n-2.0b5 - 2010-04-12\n-------------------\n-\n-- Re-add title and description when viewing old versions in Plone 4.\n-  [davisagli]\n-\n-2.0b4 - 2010-03-04\n-------------------\n-\n-- Reverse order of diff listing on history view. Fixes\n-  http://dev.plone.org/plone/ticket/10119.\n-  [alecm]\n-\n-- Fix version display when history is non-existent. Fixes\n-  http://dev.plone.org/plone/ticket/9674.\n-  [alecm]\n-\n-2.0b3 - 2010-02-17\n-------------------\n-\n-- Updated templates to follow recent markup conventions.\n-  References http://dev.plone.org/old/plone/ticket/9981.\n-  [spliter]\n-\n-- Be more defensive in our importVarious step, to avoid issues while upgrading.\n-  [hannosch]\n-\n-- Workaround for http//dev.plone.org/plone/ticket/10120, "version_history_form"\n-  now renders "Preview is not available." instead of causing a traceback.\n-  [kleist]\n-\n-2.0b2 - 2009-12-27\n-------------------\n-\n-- Fixed test dependencies and removed unused test helper code.\n-  [hannosch]\n-\n-2.0b1 - 2009-12-02\n-------------------\n-\n-- Fix dependence on global_defines in diff.pt.\n-  https://dev.plone.org/plone/ticket/9804\n-  [alecm]\n-\n-2.0a1 - 2009-11-14\n-------------------\n-\n-- Fix ordering issues with versioned BTree folders.\n-  [alecm]\n-\n-- Make the Archetypes dependency a soft one.\n-  [alecm]\n-\n-- Only make a copy of a BLOB if it\'s changed since the last save.\n-  Otherwise, just reference the BLOB from the prior revision.\n-  [alecm]\n-\n-- Made the ZVCStorage store references directly in the shadow instead\n-  of simply passing them to ZVC.  This way real references can be used\n-  in the storage instead of copies, so that BLOB revisions can work.\n-  [alecm]\n-\n-- Add modifiers to handle AT blob fields from plone.app.blob.  One\n-  handler skips the blobs and the other copies them.\n-  [alecm]\n-\n-- Enable both inside and outside children modifiers by default for\n-  folder objects.  Using the INonStructuralFolder interface to determine\n-  which to use.\n-  [alecm]\n-\n-- Fixes for reference handling in plone.folder and other BTree based folder implementations.\n-  [alecm]\n-\n-- Added modifier that skips cloning of __parent__ pointers.\n-  [alecm]\n-\n-- Switched document_byline macro to plone.belowcontenttitle content provider.\n-  [hannosch]\n-\n-- Acquire plone_utils from context rather than assuming the putils global in\n-  templates.\n-  [erikrose]\n-\n-- Fixed tests which depended on specific uids for portal content.\n-  Added cmf_uid catalog index in install profile.\n-  [alecm]\n-\n-- Fixed missing i18n markup in versions_history_form.\n-  [hannosch]\n-\n-- No longer rely on base_properties.\n-  [hannosch]\n-\n-- Made some calls to portal_repository more defensive.\n-  [hannosch]\n-\n-- Added the z3c.autoinclude entry point so this package is automatically loaded\n-  on Plone 3.3 and above.\n-  [hannosch]\n-\n-- Use new import location for the package_home function.\n-  [hannosch]\n-\n-- Added the required profile bits for installing CMFUid.\n-  [hannosch]\n-\n-- Define dependency on Products.ZopeVersionControl.\n-  [hannosch]\n-\n-- Define dependency on CMFDiffTool (via template using portal_diff) and\n-  avoiding a test dependency on CMFDefault.\n-  [hannosch]\n-\n-- Define here_url in all templates and made get_macros not fail when\n-  encountering a browser view based template.\n-  [hannosch]\n-\n-- Cleaned up package metadata and code to remove the dependency on Plone.\n-  [hannosch]\n-\n-- Declare package dependencies and fixed deprecation warnings for use\n-  of Globals.\n-  [hannosch]\n-\n-- Catch WebDAVObjectInitializedEvent/WebDAVObjectEditedEvent and\n-  save versions as appropriate. This is part of the fix for\n-  http://dev.plone.org/plone/ticket/7338\n-  [sidnei]\n-\n-- Fixed the name of the file : is has to be the FileName not the Id [tbenita]\n-\n-- Purged old Zope 2 Interface interfaces for Zope 2.12 compatibility.\n-  [elro]\n-\n-- Fixed a bug in the file_download_version that prevented successful download\n-  of anterior version of files if the filename contained spaces. Anyway, the\n-  filename param of Content-Disposition header SHOULD NEVER come without\n-  double-quotes.\n-  [drjnut]\n-\n-- Register GenericSetup steps via ZCML.\n-  [wichert]\n-\n-- Use the new archetypes.edit.afterfieldsets viewlet manager to add our\n-  field to the AT edit template. The customized edit_macros is now no longer\n-  needed.\n-  [wichert]\n-\n-1.2.7 - Unreleased\n-------------------\n-\n-- Fix error in history storage selector calculation. Closes\n-  http://dev.plone.org/plone/ticket/8967.\n-  [alecm]\n-\n-- Make "Revert to this version" on the versions_history_form an input\n-  with HTTP POST, instead of a simple GET link.\n-  Fixes http://dev.plone.org/plone/ticket/6932\n-  [maurits]\n-\n-1.2.6 - December 2, 2009\n-------------------------\n-\n-- Check history permissions in the context of the versioned object not\n-  the repository tool.  See http://plone.org/products/cmfeditions/issues/55\n-  [alecm]\n-\n-- Fixed the html and javascript on the difference view so it works on\n-  more browsers.\n-  [vpretre, maurits]\n-\n-\n-1.2.5 - November 5, 2009\n-------------------------\n-\n-- Show ndiff (natural diff) when neither inline diff nor html diff are\n-  available.\n-  [maurits]\n-\n-\n-1.2.4 - July 4, 2009\n---------------------\n-\n-- Fixed missing i18n markup in versions_history_form.\n-  [hannosch]\n-\n-\n-1.2.3 - July 4, 2009\n---------------------\n-\n-- Fix form action in @@history view.\n-  [vincentfretin]\n-\n-\n-1.2.2 - June 11, 2009\n----------------------\n-\n-- Fix XHTML markup for diff view.\n-  See ticket http://dev.plone.org/plone/ticket/9227\n-  [alecm]\n-\n-1.2.1 - June 8, 2009\n---------------------\n-\n-- Add getHistoryMetadata method to allow efficient history display\n-  without full object retrieval.  Based on patches by Darryl Dixon on\n-  CMFEditions zvc_enfold_fixfailures branch r59908:60078.\n-  [alecm]\n-\n-\n-1.2 - May 16, 2009\n-------------------\n-\n-- Add missing PACKAGE_HOME in the init file according to tests\n-  [encolpe]\n-\n-- Add the encoding declaration (utf-8) in all python files\n-  [encolpe]\n-\n-- Internationalization of 7 strings in diff.pt (history view).\n-  [vincentfretin]\n-\n-- Fixed label_history_version msgid dynamic content in diff.pt (added i18n:name="version")\n-  [vincentfretin]\n-\n-\n-1.2b1 (March 7, 2009)\n----------------------\n-\n-- Register CMF skin layers via ZCML.\n-  [wichert]\n-\n-- Remove history action. Plone 3.3 has alternative implementations in the\n-  form of the content history viewlet so this should not be installed by\n-  default.\n-  [wichert]\n-\n-- Move import step registration to ZCML.\n-  [wichert]\n-\n-- Use the new archetypes.edit.afterfieldsets viewlet manager to add our\n-  field to the AT edit template. The customized edit_macros is now no longer\n-  needed.\n-  [wichert]\n-\n-- Some CMFEditions .py files use wrong MessageFactory (#8715)\n-  [encolpe]\n-\n-- Set some msgids to cmfeditions i18n domain in version_file_view.\n-  Renamed msgid label_existing_keywords by label_existing_categories in\n-  version_metadata_view.\n-  [vincentfretin]\n-\n-\n-1.1.8 (October 6, 2008)\n------------------------\n-\n-- Switch to egg-based distribution.\n-  [hannosch]\n-\n-- Fix on FileDownloadVersion : files retrieved didn\'t get their version name\n-  [tbenita]\n-\n-- Fix on FileDownloadVersion : files retrieved got corrupted at retrieval\n-  [drjnut]\n-\n-- Merge AT changes into replacement of \'edit_macros.pt\'.\n-  See ticket http://dev.plone.org/plone/ticket/7999.\n-  [rsantos]\n-\n-\n-1.1.7 (June 2, 2008)\n---------------------\n-\n-- Fix for issues with unicode version save comments.\n-  http://dev.plone.org/plone/ticket/7400\n-  [alecm]\n-\n-\n-1.1.6 (March 26, 2008)\n-----------------------\n-\n-- Some i18n fixes to version_diff.pt. This closes\n-  http://dev.plone.org/plone/ticket/7862.\n-  [hannosch]\n-\n-- Merge AT changes into our copy of \'edit_macros.pt\'.\n-  See: http://dev.plone.org/plone/ticket/6936\n-\n-\n-1.1.5 (March 8, 2008)\n----------------------\n-\n-- Fix bug in wrapper assignment for some modifiers.\n-  [encolpe, alecm]\n-\n-- Added metadata.xml file to the profile.\n-  [hannosch]\n-\n-\n-1.1.4 (December 6, 2007)\n-------------------------\n-\n-- Add modifiers to avoid pickling extremely large files.  The\n-  AbortVersioningOfLargeFilesAndImages modifier is enabled by default\n-  for Files and Images. It will skip saving versions of objects when\n-  they contain a large file (\'file\' or \'image\' field in Attribute or\n-  AnnotationStorage).  The SkipVersioningOfLargeFilesAndImages will\n-  simply not version the large file, but will version all other data.\n-  On retrieval it will put the file from the working copy in place.\n-  This is disabled by default, but can be enabled easily.\n-  Workaround for: http://dev.plone.org/plone/ticket/7223\n-  [alecm]\n-\n-\n-1.1.3 (December 2, 2007)\n-------------------------\n-\n-- Make sure that we attempt to handle Inside Refs which have no\n-  portal_type, as well as retrieving revisions that once used the\n-  InsideRefsModifier but now use the OutsideRefsModifier.\n-  Related to: http://dev.plone.org/plone/ticket/7295\n-  [alecm]\n-\n-- Fix issue on diff form where empty entries were being shown for\n-  unchanged files.  Related to http://dev.plone.org/plone/ticket/7253\n-  [alecm]\n-\n-- Fix issues with purge policy as reported in\n-  http://dev.plone.org/plone/ticket/7300\n-  [alecm]\n-\n-- Handle ArchivistUnregisteredErrors during save.  This occurs when an\n-  object has been imported, or when the version information has been\n-  destroyed.  Fixes http://dev.plone.org/plone/ticket/7334.\n-  [alecm]\n-\n-- Reflect changes in base_edit.cpt asnd edit_macros.pt in r8683 of\n-  Archetypes: Skip the \'metadata\' schema in base_edit, like we used to\n-  do it pre-1.5.  Also, do not render fieldset and legend elements\n-  when we\'re only displaying one fieldset, i.e. the \'default\' one.\n-  [nouri]\n-\n-\n-1.1.2 (October 5, 2007)\n------------------------\n-\n-- Added bits of missing i18n markup to versions_history_form.pt. This closes\n-  http://dev.plone.org/plone/ticket/7065.\n-  [hannosch, naro]\n-\n-- Added CMFEditionsMessageFactory and used it to i18n-ize a statusmessages in\n-  revertversion.py. This closes http://dev.plone.org/plone/ticket/7066.\n-  [hannosch, naro]\n-\n-\n-1.1.1 (September 10, 2007)\n---------------------------\n-\n-- Expose the extra_top, widgets and extra_bottom METAL hooks in edit_macros.\n-  [wichert]\n-\n-\n-1.1-final (August 16, 2007)\n----------------------------\n-\n-- Prevent future off by one errors in the ui by just starting our count from 0.\n-  [alecm]\n-\n-- Fix dumb acquisition issue in the default policy scripts.\n-  [alecm]\n-\n-- Removed overly aggressive logging from update_version_before_edit.cpy.\n-  [hannosch]\n-\n-\n-1.1-rc1 (July 8, 2007)\n-----------------------\n-\n-- Make text more consistent (use revision instead of version throughout the ui)\n-\n-- Add checks in versioning policy scripts to ensure we don\'t get duplicate\n-  revisions.\n-\n-- Add controller overrides so that the correct actions happen on\n-  cancel and reference upload.\n-\n-- Add an event listener that removes the `version_id` attribute from\n-  copies.\n-\n-- Removed i18n folder. Translations are shipped in PloneTranslations. [hannosch]\n-\n-- Minor template corrections. [hannosch]\n-\n-\n-1.1-beta4 (April 30, 2007)\n---------------------------\n-\n-- Updated permission mapping to account for new local roles (Editor/Contributor)\n-\n-\n-1.1-beta3 (April 29, 2007)\n---------------------------\n-\n-- No longer register tools as utilities, since it broke the tests among\n-  other things.\n-\n-\n-1.1-beta2 (March 26, 2007)\n---------------------------\n-\n-- Register tools as utilities\n-\n-\n-1.1-beta1 (March 5, 2007)\n--------------------------\n-\n-- Make the AT autoversion policy save a version before the save for more\n-   intuitive behavior.\n-\n-- Fixed numerous ui glitches on the versions history form and started using\n-   statusmessages.\n-\n-- Do not install the versioning control panel anymore. You can enable versioning\n-  for a content type on the new types control panel now.\n-\n-ToDo\n-\n-- Finish exportimport handlers for portal_repository and portal_modifier thus\n-  making setuphandlers importVarious unnecessary again.\n-\n-- Add back special portal_historyidhandler / portal_uidhandler handling. If a\n-  portal_uidhandler tool is found during install, it should be renamed to\n-  portal_historyidhandler. The missing tools should be created as normal then.\n-\n-\n-1.1-alpha2 (February 08, 2007)\n-------------------------------\n-\n-- Removed specialized document byline.\n-\n-- Switch to Plone control panel category\n-\n-\n-1.1-alpha1 (November 22, 2006)\n-------------------------------\n-\n-Internal Changes\n-\n-- Two minor updates for CMF 2.1 compatibility. [hannosch]\n-\n-- Use a GenericSetup Extension profile for installation instead of an external\n-  method. [hannosch]\n-\n-- Cleaned up tests. As these are based on PloneTestCase and Plone 3.0 we don\'t\n-  have to set up anything special anymore. [hannosch, alecm]\n-\n-- Removed ActionProviderBase as a base class from all tools. In CMF 2.1 actions\n-  are usually only stored on the actions tool. [hannosch]\n-\n-- Updated dependency information for Plone 3.0 inclusion. [hannosch]\n-\n-\n-1.0 (SVN)\n----------\n-\n-Bugs fixed\n-\n-- Fixed OMInsideChildrensModifier InitializeClass. [encolpe]\n-\n-Internal Changes\n-\n-- Replaced usage of zLOG with Python\'s logging framework. [hannosch]\n-\n-- Removed lots of unused import statements, found by pyflakes. [hannosch]\n-\n-- Removed BBB code for old transaction handling. [hannosch]\n-\n-- Removed some BBB code for ZClasses and CMF 1.4. [hannosch]\n-\n-CMFEditions 1.0rc1 (unreleased)\n--------------------------------\n-\n-ToDo\n-\n-- migration from CMFEditions 1.0alpha3 doesn\'t work correctly\n-- some translations are not yet updated: contact translators (for changes see\n-  below. Affected translations: fr, da, pl)\n-- Fix outstanding failing tests\n-- Some complex integration test with deleted version. (purge support)\n-- allow adding test hierarchy only if in debug mode\n-- allow migration in debug mode only\n-- fix issue #28\n-- fix issue #25\n-- fix issue #19\n-- fix issue #17\n-- fix issue #22\n-\n-1.0beta1 (2006-06-24)\n----------------------\n-\n-Bugs fixed\n-\n-- Fixed previewing (retrieving) files and images. [gregweb]\n-\n-- Security Policy was for ``manage_setPolicies`` but the method name\n-  was ``manage_setTypePolicies``. Corrected. [gregweb]\n-\n-- The storage now stores ZVC\'s ``__vc_info__`` for every version\n-  avoiding wrong information is attached to a working copy when\n-  previewing a version. Fix for ToDo.txt item #48. [gregweb]\n-\n-- Replaced all occurences of ``rollback`` with ``revert``. Brought into\n-  sync internal names with UI. Rollback may suggest a transaction\n-  rollback which is something different. Including i18n label\n-  ``label_rollback`` which is now ``label_revert``. Added backwards\n-  compatibility code for configuration. Translations not updated.\n-  [gregweb]\n-\n-- Minor refactorings of the version history view. Notably replaced\n-  ``(show below)`` by ``preview`` without jumping to the preview target\n-  on the page by default. Instead the link name of the previewed version\n-  changes to ``jump down``. [gregweb]\n-\n-- The storage is now more immune against non int selectors. [gregweb]\n-\n-\n-Features Added\n-\n-- The approximate size of a version is now recorded also at save time\n-  (and calculated at storage migartion).\n-  [gregweb]\n-\n-- Added size information to storage statistics ZMI view [gregweb]\n-\n-- Added German translations [gregweb]\n-\n-- Added Polish translations provided by Piotr Furman [Piotr Furman, gregweb]\n-\n-- ``RetainWorkflowStateAndHistory`` now adds the ``review_state`` to the\n-  ``sys_metadata`` at save time because at retreive time the workflow tool\n-  picks the working copies state. I didn\'t find any other way to do it\n-  without digging into workflows internals (which would have been a bad\n-  idea anyway). Had to extend the ``IModifier.ISaveRetrieveModifier``\n-  interface to allow a modifier enhance ``sys_metadata`` at save time.\n-  [gregweb]\n-\n-- Added purge support [gregweb]:\n-\n-  - Enhanced storage API with a ``purge`` method that inevitabely\n-    removes a version from the history. See added ``IPurgeSupport``\n-    and ``IPurgePolicy`` interfaces.\n-  - Purging raises an exception if no purge policy is installed. This\n-    will avoid a lot of future tracker items caused by people having\n-    removed the purge policy but nevertheless providing purge support\n-    to users. The reason is that the archivist and repo layer can\'t\n-    handle yet the empty placeholder object beeing returned by the\n-    storage for the purged version. This rule may be relaxed in future\n-    versions if the archivist and repo layer support handling of those\n-    empty placeholder objects.\n-  - The UI doesn\'t expose manual purge functionality. Through the ZMI a\n-    number n may be configured representing the maximum number of\n-    version per content item that have to be preserved. Older ones are\n-    automatically purged from the storage at save time.\n-  - There is a new purge permission that may be used to restrict purging\n-    to special roles if necessary (applicable to manual purging only).\n-  - On the repo layer (``portal_repository``) retrieving an object or\n-    iterating over the history always returns a valid (unpurged)\n-    version. The returned object may be a substitute. Two numbering\n-    schematas exist. Numbering counting purged versions and not\n-    counting purged versions (passing True or False to ``countPurged``).\n-    The default numbering schema is ``countPurged=True``. The UI\n-    history onyl shows unpurged versions (``countPurged=False``).\n-  - If the storage is asked to retreive a removed version it may be\n-    instructed to return a substitute for the removed version. The\n-    substitution policy itself is implemented in the new purge policy\n-    tool. This strategy allows to keep most purge implementation\n-    details out of the upper layers (archivist, modifiers, repository).\n-  - The new purge policy tool may be instructed to only keep n versions\n-    of a content item. Thus at save time the oldest version is purged\n-    if the save operation would result in more than n version reside in\n-    the storage.\n-  - The new purge policy tool substitutes a removed version with the\n-    next older version. If no other version is available the next\n-    newer is used as substitute. If none is available ... well this\n-    isn\'t yet tested :-)\n-  - The archivist and storage may be asked to also retreive the empty\n-    placeholder of a purged version. This functionality is yet exposed\n-    to the repo layer. This may change in a future release.\n-  - Added ``isValid`` method on the vdata object that allows to ask if\n-    the retrieved object it is valid or not (empty placeholder object\n-    or a real version).\n-\n-- At save time a version aware reference to the parent node is saved\n-  also. Without it would be very ineffective or even impossible to\n-  find out the parents which potentially would prevent adding usefull\n-  features like retrieving the a whole site from one object in the\n-  tree. [gregweb]\n-\n-- The histories default order has changed: It now returns the newest\n-  version as first item and the oldest as last item. The old behaviour\n-  is still available by passing ``oldestFirst=True``. [gregweb]\n-\n-- Inserted the ``oldestFirst`` parameter before the already existing\n-  ``preserve`` parameter. This will cause changes of 3rd party products\n-  that are using ``preserve`` (None know at the moment, it\'s better to\n-  change now than later). [gregweb]\n-\n-- Added two new i18n labels: ``label_preview_version_below``,\n-  ``label_preview_version`` (no translations yet) [gregweb]\n-\n-- Renamed i18n label: ``label_show_below`` to ``label_preview_version_link``\n-  (updated labels in po-files but not the translations) [gregweb]\n-\n-\n-Internal Changes\n-\n-- Now save all metadata also in shadow storage. But currently on retrieve\n-  the metadata is still feteched from the ZVC storage. [gregweb]\n-\n-- Added migration code for 1.0alpha3 --> 1.0beta1 storage migrations\n-  [gregweb]\n-\n-- Adding purge support caused heavy refactoring the version storage.\n-  ZVC is still used to store the contents history but now additional\n-  data is stored in a parallel shadow storage. The layout of the data\n-  in the ZVC didn\'t change, only ZVC and purge related metadata has\n-  been added to the parallel shadow storage. [gregweb]\n-\n-- Garbage collected a lot of code that was commented out, outdated\n-  triple-X\'s and items in ``ToDo.txt``. [gregweb]\n-\n-- The storage tests now tests ZVCSTorageTool only once and additionally\n-  tests the dummy memory storage. This was the intended behaviour but\n-  a bug prevented running the tests with the dummy storage and instead\n-  run the tests with ZVCStorageToll twice. [gregweb]\n-\n-\n-1.0alpha4 (2006-06-24)\n-----------------------\n-\n-Bugs fixed\n-\n-- fixed bug with AT references causing ref catalog having been inconsistent\n-  [sunew]\n-\n-\n-Features added\n-\n-- Comment is now taken from request if any. [sunew]\n-\n-- Added storage statistics ZMI view. [gregweb]\n-\n-- Added functionality to create a test hierarchy. [gregweb]\n-\n-\n-1.0alpha3 (2006-06-03)\n-----------------------\n-\n-Bugs fixed\n-\n-- Fixed tracker issue #15 [alecm, gregweb]\n-\n-- When previewing a version the expandable history link is removed as this\n-  doesn\'t make sense at all and caused double fetching of history items.\n-  [gregweb]\n-\n-- Use the default view of the retrieved object, as it may be different from\n-  that of the current object. [alecm]\n-\n-- The expandable version link is only shown for users having the permission\n-  to view the history. [rafrombrc]\n-\n-- Added RetainATRefs modifier [vds]\n-\n-- Fixed broken ``isUpToDate`` [gregweb]\n-\n-- ``version_id`` wasn\'t correctly set at the working copy at save time.\n-  Because of this it may happen that the wrong version info was saved\n-  with the version aware reference. The version_id is now set at the end\n-  of the save operation. [alecm, gregweb]\n-\n-- Handle usecase where an inside reference is moved outside its container.\n-  Still need to handle case where it has been replaced by another object\n-  with the same id.  [alecm]\n-\n-- Changed API for Archivist methods and the dereference utility method so\n-  that they now accept an optional history_id, rather than implicitly\n-  allowing the \'obj\' parameter to be a history_id. As side effect this\n-  will help in supporting multi location checkout in the future.\n-  [alecm, gregweb]\n-\n-- Fixed various UI issues. [rlemmi, vds, alecm]\n-\n-- Fixed SF issue #1376836. [alecm]\n-\n-- restored at\'s extra_buttons slot (some others slots are still missing\n-  because of this template override) [syt]\n-\n-- Totally refactored recursive retrieve of an ancient version of an object.\n-  Fixed a lot of folderish bugs with this refactoring. [gregweb]\n-\n-- Corrected a hairy acquisition bug that caused wrong security evaluations\n-  (ArchivistTool.py). Acquisition is a monster feature! [gregweb]\n-\n-- The storage now returns obj.modified() instead of\n-  obj.getModificationDate() because it\'s more fine graned. [gregweb]\n-\n-- Added ReferenceFactoriesTool.py which in essence knows how to\n-  instatiate a reference. The current implementation is inflexible and\n-  knows only how to instantiate object into an ObjectManager. This\n-  is the first step in preparation for AT reference handling. [gregweb]\n-\n-- Fixed tracker issue #16 RuntimeError: maximum recursion depth exceeded.\n-  I (gregweb) suspect it got fixed by: [alecm]\n-\n-- Fixed identical tracker issues #5, #6, #7, #8. I (gregweb) suspect it got\n-  fixed by: [alecm]\n-\n-- Added modifier to copy permissions from working copy onto retrieved\n-  versions, otherwise retaining workflow can have some very strange\n-  consequences. [alecm]\n-\n-- Fixed a number of bugs involving handling of adding and deleting subobjects\n-  of versioned folders.\n-  [alecm]\n-\n-- Fixed a permissions bug which made the versions_history_form inaccessible if\n-  any of the versions were saved while private (or otherwise had\n-  \'Access contents information\' disabled).\n-  [alecm]\n-\n-- Made quickinstalled product reinstall/uninstall work without issue.  Fixed\n-  unit tests for Plone 2.1.  Use mutators in templates and tests where\n-  applicable rather than direct attribute access. Was Issue #9, #10 and #11.\n-  Thanks to Andrew Lewis for the patches and reports. [Andrew Lewis, alecm]\n-\n-- Corrected bugs in ``RetainWorkflowStateAndHistory`` modifier and the\n-  modifier registry avoiding the review state and the workflow history\n-  from beeing retained on retrieve and revert.\n-\n-\n-Features added\n-\n-- Added danish translation. [stonor]\n-\n-- Retrieving an object just for preview (without replacing the working copy)\n-  caused a lot of headaches and got more and more complex und ununderstandable.\n-  Everything got much simpler by just using a savepoint/abort pair at the right\n-  place while retrieving. [alecm]\n-\n-- I18N tuned (diff-legend untested), french added\n-  [Gpgi, gotcha]\n-\n-- Added more tests to improve coverage. [azy, vds, alecm]\n-\n-- Added support for ATCT (Archetypes Content Types). [azy]\n-\n-- Added ZMI interface for modifiers. [rlemmi]\n-\n-- It\'s now possible to save a new version in the edit view. As soon as a\n-  version sahll be saved a comment field is inserted to add a comment.\n-  [rlemmi]\n-\n-- Added expandable version history to document_byline. [rlemmi]\n-\n-- Made the ModifierRegistryTool make use of any preserve dict passed back to\n-  it by afterRetrieveModifiers.\n-  [alecm]\n-\n-- Added optional CMFDiffTool support for generating diffs between object\n-  versions.  For this to work you need to setup the diffable fields on each\n-  type in portal_diff.  In the \'alecm-at-schema-diffs\' branch of CMFDiffTool\n-  there is a diff type that can be applied to any AT object which will\n-  automatically setup diffs for all fields in the schema (when using this\n-  any value can be entered for the field in portal_diff).\n-  [alecm]\n-\n-- Added a versioning policy (at_edit_autoversion) which automatically creates\n-  new versions on edit for AT types which are configured to support the policy\n-  in the configlet.  This is implemented using a simple macro override on\n-  AT\'s edit_macros, and a new entry in the AT edit form controller chain.\n-  [alecm]\n-\n-- Added new interface IContentTypeVersionPolicySupport and implemented it in\n-  portal_repository.  It allows products to register versioning policies\n-  (classes which implement IVersionPolicy), and to associate those policies\n-  with specific portal types.  IVersionPolicy objects may define methods\n-  (setupPolicyHook, removePolicyHook, enablePolicyOnTypeHook,\n-  disablePolicyOnTypeHook) which can be used to install/uninstall policy\n-  specific behavior in the portal, on adding/removing the policy, or enabling/\n-  disabling the policy on a specific type.\n-  [alecm]\n-\n-\n-1.0alpha2 (around June 2005)\n-----------------------------\n-\n-no changes recorded\n+For older changes, 2.2.23 and earlier, see ``docs/old-changelog.rst``.\ndiff --git a/doc/old-changelog.rst b/doc/old-changelog.rst\nnew file mode 100644\nindex 0000000..5f5dbfb\n--- /dev/null\n+++ b/doc/old-changelog.rst\n@@ -0,0 +1,1248 @@\n+For changes since 3.0, see CHANGES.rst\n+\n+\n+2.2.23 (2016-12-05)\n+-------------------\n+\n+Bug fixes:\n+\n+- In ShadowStorage\'s `isRegistered` and `getHistory` methods,\n+  avoid checking for a history_id of None in the storage\'s BTree.\n+  This fixes compatibility with BTrees 4.x,\n+  which disallows comparing keys to None.\n+  [davisagli]\n+\n+\n+2.2.22 (2016-11-17)\n+-------------------\n+\n+Bug fixes:\n+\n+- Fix deprecated import from Globals that is changed in Zope4.\n+  [pbauer]\n+\n+- Do not log using plone restricted python logging script.\n+  [jensens]\n+\n+- Adapt tests to the new indexing operations queueing.\n+  Part of PLIP 1343: https://github.com/plone/Products.CMFPlone/issues/1343\n+  [gforcada]\n+\n+2.2.21 (2016-08-18)\n+-------------------\n+\n+Bug fixes:\n+\n+- Use zope.interface decorator.\n+  [gforcada]\n+\n+\n+2.2.20 (2016-04-15)\n+-------------------\n+\n+Fixes:\n+\n+- Fixed CloneBlobs modifier to only react on Archetypes.\n+  This fix allows Dexterity Blob-Types (e.g. File, Image) to be versioned.\n+  [iham]\n+\n+\n+2.2.19 (2016-02-14)\n+-------------------\n+\n+Fixes:\n+\n+- Fixed sometimes failing test.  [maurits]\n+\n+\n+2.2.18 (2015-11-25)\n+-------------------\n+\n+Fixes:\n+\n+- Removed executable bit from various files.  And do a quick release,\n+  as on a test server the previous release was somehow missing a file.\n+  [maurits]\n+\n+\n+2.2.17 (2015-11-25)\n+-------------------\n+\n+Fixes:\n+\n+- Made storage statistics test more robust.\n+  See https://github.com/plone/Products.CMFEditions/issues/31\n+  [tschorr]\n+\n+\n+2.2.16 (2015-09-27)\n+-------------------\n+\n+- Input sanitation for retrieveSubstitute()\n+  [zupo]\n+\n+\n+2.2.15 (2015-09-15)\n+-------------------\n+\n+- use unrestricted search for storage statistics\n+  [tschorr]\n+\n+\n+2.2.14 (2015-08-13)\n+-------------------\n+\n+- Do not call ndiff unless there is no html_diff.  Removed strange\n+  unicode space from template.  Related to\n+  https://github.com/plone/Products.CMFPlone/issues/820\n+  [maurits]\n+\n+\n+2.2.13 (2015-04-26)\n+-------------------\n+\n+- Drop use of python:exists() in templates.\n+  [pbauer]\n+\n+- Replace deprecated JavaScript functions with their jQuery equivalents.\n+  [thet]\n+\n+\n+2.2.12 (2015-03-13)\n+-------------------\n+\n+- Remove dependency on old Archetypes tests\n+  [tomgross]\n+\n+- Ported tests to plone.app.testing\n+  [tomgross]\n+\n+- Removed old FAQ testing code. Should go in a seperate product, if needed.\n+  [tomgross]\n+\n+- Frosted cleanups\n+  [tomgross]\n+\n+2.2.11 (2014-10-23)\n+-------------------\n+\n+- Depend on ZODB3>=3.9.0 for blob support.\n+  [tomgross]\n+\n+- Fix AT tests to work with plone.app.blob plone.app.blob >=1.5.11\n+  [jensens]\n+\n+\n+2.2.10 (2014-09-07)\n+-------------------\n+\n+- Fix #16: Allow developers to define a ``@@version-view`` to customize how a version of an item is\n+  displayed in ``versions_history_form.pt``.\n+  [rafaelbco]\n+\n+- Fix #14: Duplicate functionality in ``@@history`` and ``version_diff.pt``.\n+  Now ``version_diff.pt`` is deprecated.\n+  [rafaelbco]\n+\n+- Fix bug: ``CopyModifyMergeRepositoryTool.manage_setTypePolicies`` method\n+  modifies sequence while iterating over it.\n+  [rafaelbco]\n+\n+- Purging old versions did not properly remove all references\n+  to the blob fields, resulting in old blobs to stay there forever.\n+  [do3cc]\n+\n+2.2.9 (2013-12-07)\n+------------------\n+\n+- Use search_icon.png instead of search_icon.gif in version_image_view.pt.\n+  The page crashed because search_icon.gif couldn\'t be found.\n+  [vincentfretin]\n+\n+- Do not depend on the ``jq`` variable in the history view.\n+  [maurits]\n+\n+2.2.8 (2013-03-05)\n+------------------\n+\n+- Fix modifier check that made AT assumptions about Dexterity\n+  content.\n+  [rpatterson]\n+\n+- Remove hard dependency on Archetypes.\n+  [davisagli]\n+\n+2.2.7 (2013-01-01)\n+------------------\n+\n+- put back the history legend for compare/diff versions, fixes #9371\n+  [maartenkling]\n+\n+- Site administrators do revisioning\n+\n+2.2.6 (2012-10-16)\n+------------------\n+\n+- Update ``IPossibleSite`` import to ``zope.component``.\n+  [elro]\n+\n+2.2.5 (2012-08-11)\n+------------------\n+\n+- Fixed version file preview for empty files.\n+  [thomasdesvenain]\n+\n+- Fixed versions history form:\n+  title and description aren\'t displayed two times.\n+  [thomasdesvenain]\n+\n+- Fixed version file preview:\n+  some displayed values of a previous version were values of current version.\n+  [thomasdesvenain]\n+\n+- ArchivistTool.py, DummyTools.py, IArchivist.py, ModifierRegistryTool.py:\n+  Don\'t use list as default parameter value.\n+  [kleist]\n+\n+\n+2.2.4 (2012-06-27)\n+------------------\n+\n+- Add upgrade step to install the component registry bases modifier.\n+  [rossp]\n+\n+- Skip blob files from plone.namedfile even when they no longer\n+  extend the classes from z3c.blobfile.\n+  [davisagli]\n+\n+- Declare missing dependency on zope.copy.\n+  [hannosch]\n+\n+\n+2.2.3 (2012-01-26)\n+------------------\n+\n+- Changed the get_macros python skin script into a browser view.  This\n+  avoids an Unauthorized exception when viewing revisions when using\n+  five.pt (Chameleon).\n+  [maurits]\n+\n+- Implement a special base modifier that allows retention of specific\n+  annotation elements from the working copy.  Use this in the OM\n+  modifiers to ensure we don\'t stomp annotations for folders on retrieval.\n+  [alecm]\n+\n+- If an object has a component registry (AKA site manager), make sure\n+  the bases of that registry are not recursively copied when saving\n+  versions.\n+  [rossp]\n+\n+2.2.2 (2011-10-17)\n+------------------\n+\n+- Don\'t string convert blobs.  Fixes MemoryErrors or excessive memory\n+  consumption with large blobs.\n+  [rossp]\n+\n+- Protect against anonymous access to KwAsAttributes.\n+  [mj]\n+\n+2.2.1 (2011-09-19)\n+------------------\n+\n+- Merged changes from 2.1.5.\n+  [lentinj]\n+\n+2.2 (2011-08-23)\n+----------------\n+\n+- Make Zope 2 permissions available as Zope 3-style permissions.\n+  [rafaelbco]\n+\n+- Changed ``@@history`` to be protected by ``CMFEditions.AccessPreviousVersions`` instead of\n+  ``cmf.ModifyPortalContent``.\n+  [rafaelbco]\n+\n+- Only show the "Revert to this version" button if the user has the ``Revert to previous versions``\n+  permission in ``versions_history_form``.\n+  [rafaelbco]\n+\n+2.1.5 (2011-09-19)\n+------------------\n+\n+- Translate the commit message, so version id is substituted.\n+  [lentinj]\n+\n+- Only save an initial version before edit when content is not yet versioned,\n+  rather than every time there are unsaved changes. Otherwise there is an\n+  "Initial version" generated for every edit after publish/retract, as these\n+  change the publishing date without a new version being saved. Possibly a\n+  version should be saved on publish, but not sure the extra versioning noise\n+  is useful.\n+  [lentinj]\n+\n+2.1.4 (2011-08-31)\n+------------------\n+\n+- Remove references to blobs when cloning blob fields. They are handled as\n+  referenced attributes anyway. This eliminates the creation of an additional\n+  empty blob when cloning blob fields.\n+  [buchi]\n+\n+- No longer store references in the ZVC wrapper. They are stored in the shadow\n+  history and retrieved from there. This eliminates the creation of an\n+  additional empty blob when cloning blob fields.\n+  [buchi]\n+\n+- Allow to translate the string "current" in the diff view (``@@history``) and in the\n+  ``version_diff`` template.\n+  [rafaelbco]\n+\n+2.1.3 (2011-04-03)\n+------------------\n+\n+- Fixed: Unauthorized error on versions history form for non managers.\n+  [thomasdesvenain]\n+\n+2.1.2 (2011-03-25)\n+------------------\n+\n+- remove UniqueIdHandlerTool, it was not used anymore;\n+  nobody (including vds and hannosch) seems to remember what it was for.\n+  [gotcha]\n+\n+- fix portal_historyidhandler class to avoid issue where GenericSetup toolset\n+  import step tried to change the class default id\n+  [gotcha]\n+\n+- Skip z3c.blobfile File (notable subclasess plone.namedfile BlobFile and\n+  BlobImage) as blobfile versioning is not there yet.\n+  [elro]\n+\n+2.1.1 - 2011-02-25\n+------------------\n+\n+- Fix bug when loading GenericSetup profile with ``<policymap purge="true">``.\n+  [elro]\n+\n+2.1.0 - 2011-02-25\n+------------------\n+\n+- Generic Setup export/import support.\n+  [elro]\n+\n+2.0.5 - 2011-02-25\n+------------------\n+\n+- Workaround some potential issues with event handlers and\n+  transaction.savepoint which can cause exceptions when, for example,\n+  zope.sendmail is used to send mail in the same transaction as saving\n+  an edition.\n+  [rossp]\n+\n+2.0.4 - 2011-01-03\n+------------------\n+\n+- Depend on ``Products.CMFPlone`` instead of ``Plone``.\n+  [elro]\n+\n+- Do not provide "Compare to ... revision" link in versions history actions\n+  if content type has no diffable field.\n+  [thomasdesvenain]\n+\n+- Add Site Administrator role to various permissions, for forward compatibility\n+  with Plone 4.1.\n+  [davisagli]\n+\n+2.0.3 - 2010-11-06\n+------------------\n+\n+- Internationalized default version comments (\'Initial revision\', etc.).\n+  [thomasdesvenain]\n+\n+- Fixed: version comment was not considered when saving a content with\n+  automatic version policy. Closes http://dev.plone.org/plone/ticket/8535.\n+  [thomasdesvenain]\n+\n+- Fixed multiple chameleon incompatibilities.\n+  [swampmonkey]\n+\n+2.0.2 - 2010-09-09\n+------------------\n+\n+- Forward port of a i18n fix from branches/1.2. It\'s used to create a\n+  changeset, the message doesn\'t seem to appear on the history view though.\n+  [vincentfretin]\n+\n+- Added missing i18n markup to variables in ``update_version_before_edit.cpy``.\n+  [WouterVH]\n+\n+2.0.1 - 2010-08-08\n+------------------\n+\n+- Changed "version" to "revision" in portal messages.\n+  [kleist]\n+\n+2.0 - 2010-07-18\n+----------------\n+\n+- Changed the text in the `@@history` page to use the term revision instead of\n+  version. This fixes http://dev.plone.org/plone/ticket/10740.\n+  [hannosch]\n+\n+- Added dependency on plone.app.blob, to pull in the needed bits for\n+  handling blobs in the modifiers.\n+  [davidblewett]\n+\n+- Added event listeners for Archetypes\' ObjectInitializedEvent and\n+  ObjectEditedEvent events (to go along with the existing WebDAV ones).\n+  [davidblewett]\n+\n+- Changed Plone 3 backward compatible handling to also work with Chameleon.\n+  [do3cc]\n+\n+2.0b9 - 2010-06-13\n+------------------\n+\n+- Avoid dependency on zope.app.testing.\n+  [hannosch]\n+\n+2.0b8 - 2010-05-20\n+------------------\n+\n+- Added notification of changes on revert, via zope.lifecycle\'s\n+  ObjectModifiedEvent and Archetypes\' ObjectEditedEvent.\n+  [davidblewett]\n+\n+- Fixed revertversion.py so that it didn\'t tack on a lone / to the redirect\n+  URL.\n+  [davidblewett]\n+\n+- Fixed CloneBlob & company, so that they check that the field provides an\n+  interface instead of using isinstance.\n+  [davidblewett]\n+\n+- Fixed CloneBlob to not trample its local variables, allowing for multiple\n+  blob fields on a type.\n+  [davidblewett]\n+\n+- Updated i18n methods that used mappings.\n+  [davidblewett]\n+\n+2.0b7 - 2010-05-08\n+------------------\n+\n+- Fix BLOB history corruption\n+  http://dev.plone.org/plone/ticket/10503\n+  [do3cc]\n+\n+2.0b6 - 2010-04-20\n+------------------\n+\n+- Widen html diff display to work better with new layout.\n+  [alecm]\n+\n+- Fix issue with versioning of large folders.\n+  http://dev.plone.org/plone/ticket/10457\n+  [alecm]\n+\n+2.0b5 - 2010-04-12\n+------------------\n+\n+- Re-add title and description when viewing old versions in Plone 4.\n+  [davisagli]\n+\n+2.0b4 - 2010-03-04\n+------------------\n+\n+- Reverse order of diff listing on history view. Fixes\n+  http://dev.plone.org/plone/ticket/10119.\n+  [alecm]\n+\n+- Fix version display when history is non-existent. Fixes\n+  http://dev.plone.org/plone/ticket/9674.\n+  [alecm]\n+\n+2.0b3 - 2010-02-17\n+------------------\n+\n+- Updated templates to follow recent markup conventions.\n+  References http://dev.plone.org/old/plone/ticket/9981.\n+  [spliter]\n+\n+- Be more defensive in our importVarious step, to avoid issues while upgrading.\n+  [hannosch]\n+\n+- Workaround for http//dev.plone.org/plone/ticket/10120, "version_history_form"\n+  now renders "Preview is not available." instead of causing a traceback.\n+  [kleist]\n+\n+2.0b2 - 2009-12-27\n+------------------\n+\n+- Fixed test dependencies and removed unused test helper code.\n+  [hannosch]\n+\n+2.0b1 - 2009-12-02\n+------------------\n+\n+- Fix dependence on global_defines in diff.pt.\n+  https://dev.plone.org/plone/ticket/9804\n+  [alecm]\n+\n+2.0a1 - 2009-11-14\n+------------------\n+\n+- Fix ordering issues with versioned BTree folders.\n+  [alecm]\n+\n+- Make the Archetypes dependency a soft one.\n+  [alecm]\n+\n+- Only make a copy of a BLOB if it\'s changed since the last save.\n+  Otherwise, just reference the BLOB from the prior revision.\n+  [alecm]\n+\n+- Made the ZVCStorage store references directly in the shadow instead\n+  of simply passing them to ZVC.  This way real references can be used\n+  in the storage instead of copies, so that BLOB revisions can work.\n+  [alecm]\n+\n+- Add modifiers to handle AT blob fields from plone.app.blob.  One\n+  handler skips the blobs and the other copies them.\n+  [alecm]\n+\n+- Enable both inside and outside children modifiers by default for\n+  folder objects.  Using the INonStructuralFolder interface to determine\n+  which to use.\n+  [alecm]\n+\n+- Fixes for reference handling in plone.folder and other BTree based folder implementations.\n+  [alecm]\n+\n+- Added modifier that skips cloning of __parent__ pointers.\n+  [alecm]\n+\n+- Switched document_byline macro to plone.belowcontenttitle content provider.\n+  [hannosch]\n+\n+- Acquire plone_utils from context rather than assuming the putils global in\n+  templates.\n+  [erikrose]\n+\n+- Fixed tests which depended on specific uids for portal content.\n+  Added cmf_uid catalog index in install profile.\n+  [alecm]\n+\n+- Fixed missing i18n markup in versions_history_form.\n+  [hannosch]\n+\n+- No longer rely on base_properties.\n+  [hannosch]\n+\n+- Made some calls to portal_repository more defensive.\n+  [hannosch]\n+\n+- Added the z3c.autoinclude entry point so this package is automatically loaded\n+  on Plone 3.3 and above.\n+  [hannosch]\n+\n+- Use new import location for the package_home function.\n+  [hannosch]\n+\n+- Added the required profile bits for installing CMFUid.\n+  [hannosch]\n+\n+- Define dependency on Products.ZopeVersionControl.\n+  [hannosch]\n+\n+- Define dependency on CMFDiffTool (via template using portal_diff) and\n+  avoiding a test dependency on CMFDefault.\n+  [hannosch]\n+\n+- Define here_url in all templates and made get_macros not fail when\n+  encountering a browser view based template.\n+  [hannosch]\n+\n+- Cleaned up package metadata and code to remove the dependency on Plone.\n+  [hannosch]\n+\n+- Declare package dependencies and fixed deprecation warnings for use\n+  of Globals.\n+  [hannosch]\n+\n+- Catch WebDAVObjectInitializedEvent/WebDAVObjectEditedEvent and\n+  save versions as appropriate. This is part of the fix for\n+  http://dev.plone.org/plone/ticket/7338\n+  [sidnei]\n+\n+- Fixed the name of the file : is has to be the FileName not the Id [tbenita]\n+\n+- Purged old Zope 2 Interface interfaces for Zope 2.12 compatibility.\n+  [elro]\n+\n+- Fixed a bug in the file_download_version that prevented successful download\n+  of anterior version of files if the filename contained spaces. Anyway, the\n+  filename param of Content-Disposition header SHOULD NEVER come without\n+  double-quotes.\n+  [drjnut]\n+\n+- Register GenericSetup steps via ZCML.\n+  [wichert]\n+\n+- Use the new archetypes.edit.afterfieldsets viewlet manager to add our\n+  field to the AT edit template. The customized edit_macros is now no longer\n+  needed.\n+  [wichert]\n+\n+1.2.7 - Unreleased\n+------------------\n+\n+- Fix error in history storage selector calculation. Closes\n+  http://dev.plone.org/plone/ticket/8967.\n+  [alecm]\n+\n+- Make "Revert to this version" on the versions_history_form an input\n+  with HTTP POST, instead of a simple GET link.\n+  Fixes http://dev.plone.org/plone/ticket/6932\n+  [maurits]\n+\n+1.2.6 - December 2, 2009\n+------------------------\n+\n+- Check history permissions in the context of the versioned object not\n+  the repository tool.  See http://plone.org/products/cmfeditions/issues/55\n+  [alecm]\n+\n+- Fixed the html and javascript on the difference view so it works on\n+  more browsers.\n+  [vpretre, maurits]\n+\n+\n+1.2.5 - November 5, 2009\n+------------------------\n+\n+- Show ndiff (natural diff) when neither inline diff nor html diff are\n+  available.\n+  [maurits]\n+\n+\n+1.2.4 - July 4, 2009\n+--------------------\n+\n+- Fixed missing i18n markup in versions_history_form.\n+  [hannosch]\n+\n+\n+1.2.3 - July 4, 2009\n+--------------------\n+\n+- Fix form action in @@history view.\n+  [vincentfretin]\n+\n+\n+1.2.2 - June 11, 2009\n+---------------------\n+\n+- Fix XHTML markup for diff view.\n+  See ticket http://dev.plone.org/plone/ticket/9227\n+  [alecm]\n+\n+1.2.1 - June 8, 2009\n+--------------------\n+\n+- Add getHistoryMetadata method to allow efficient history display\n+  without full object retrieval.  Based on patches by Darryl Dixon on\n+  CMFEditions zvc_enfold_fixfailures branch r59908:60078.\n+  [alecm]\n+\n+\n+1.2 - May 16, 2009\n+------------------\n+\n+- Add missing PACKAGE_HOME in the init file according to tests\n+  [encolpe]\n+\n+- Add the encoding declaration (utf-8) in all python files\n+  [encolpe]\n+\n+- Internationalization of 7 strings in diff.pt (history view).\n+  [vincentfretin]\n+\n+- Fixed label_history_version msgid dynamic content in diff.pt (added i18n:name="version")\n+  [vincentfretin]\n+\n+\n+1.2b1 (March 7, 2009)\n+---------------------\n+\n+- Register CMF skin layers via ZCML.\n+  [wichert]\n+\n+- Remove history action. Plone 3.3 has alternative implementations in the\n+  form of the content history viewlet so this should not be installed by\n+  default.\n+  [wichert]\n+\n+- Move import step registration to ZCML.\n+  [wichert]\n+\n+- Use the new archetypes.edit.afterfieldsets viewlet manager to add our\n+  field to the AT edit template. The customized edit_macros is now no longer\n+  needed.\n+  [wichert]\n+\n+- Some CMFEditions .py files use wrong MessageFactory (#8715)\n+  [encolpe]\n+\n+- Set some msgids to cmfeditions i18n domain in version_file_view.\n+  Renamed msgid label_existing_keywords by label_existing_categories in\n+  version_metadata_view.\n+  [vincentfretin]\n+\n+\n+1.1.8 (October 6, 2008)\n+-----------------------\n+\n+- Switch to egg-based distribution.\n+  [hannosch]\n+\n+- Fix on FileDownloadVersion : files retrieved didn\'t get their version name\n+  [tbenita]\n+\n+- Fix on FileDownloadVersion : files retrieved got corrupted at retrieval\n+  [drjnut]\n+\n+- Merge AT changes into replacement of \'edit_macros.pt\'.\n+  See ticket http://dev.plone.org/plone/ticket/7999.\n+  [rsantos]\n+\n+\n+1.1.7 (June 2, 2008)\n+--------------------\n+\n+- Fix for issues with unicode version save comments.\n+  http://dev.plone.org/plone/ticket/7400\n+  [alecm]\n+\n+\n+1.1.6 (March 26, 2008)\n+----------------------\n+\n+- Some i18n fixes to version_diff.pt. This closes\n+  http://dev.plone.org/plone/ticket/7862.\n+  [hannosch]\n+\n+- Merge AT changes into our copy of \'edit_macros.pt\'.\n+  See: http://dev.plone.org/plone/ticket/6936\n+\n+\n+1.1.5 (March 8, 2008)\n+---------------------\n+\n+- Fix bug in wrapper assignment for some modifiers.\n+  [encolpe, alecm]\n+\n+- Added metadata.xml file to the profile.\n+  [hannosch]\n+\n+\n+1.1.4 (December 6, 2007)\n+------------------------\n+\n+- Add modifiers to avoid pickling extremely large files.  The\n+  AbortVersioningOfLargeFilesAndImages modifier is enabled by default\n+  for Files and Images. It will skip saving versions of objects when\n+  they contain a large file (\'file\' or \'image\' field in Attribute or\n+  AnnotationStorage).  The SkipVersioningOfLargeFilesAndImages will\n+  simply not version the large file, but will version all other data.\n+  On retrieval it will put the file from the working copy in place.\n+  This is disabled by default, but can be enabled easily.\n+  Workaround for: http://dev.plone.org/plone/ticket/7223\n+  [alecm]\n+\n+\n+1.1.3 (December 2, 2007)\n+------------------------\n+\n+- Make sure that we attempt to handle Inside Refs which have no\n+  portal_type, as well as retrieving revisions that once used the\n+  InsideRefsModifier but now use the OutsideRefsModifier.\n+  Related to: http://dev.plone.org/plone/ticket/7295\n+  [alecm]\n+\n+- Fix issue on diff form where empty entries were being shown for\n+  unchanged files.  Related to http://dev.plone.org/plone/ticket/7253\n+  [alecm]\n+\n+- Fix issues with purge policy as reported in\n+  http://dev.plone.org/plone/ticket/7300\n+  [alecm]\n+\n+- Handle ArchivistUnregisteredErrors during save.  This occurs when an\n+  object has been imported, or when the version information has been\n+  destroyed.  Fixes http://dev.plone.org/plone/ticket/7334.\n+  [alecm]\n+\n+- Reflect changes in base_edit.cpt asnd edit_macros.pt in r8683 of\n+  Archetypes: Skip the \'metadata\' schema in base_edit, like we used to\n+  do it pre-1.5.  Also, do not render fieldset and legend elements\n+  when we\'re only displaying one fieldset, i.e. the \'default\' one.\n+  [nouri]\n+\n+\n+1.1.2 (October 5, 2007)\n+-----------------------\n+\n+- Added bits of missing i18n markup to versions_history_form.pt. This closes\n+  http://dev.plone.org/plone/ticket/7065.\n+  [hannosch, naro]\n+\n+- Added CMFEditionsMessageFactory and used it to i18n-ize a statusmessages in\n+  revertversion.py. This closes http://dev.plone.org/plone/ticket/7066.\n+  [hannosch, naro]\n+\n+\n+1.1.1 (September 10, 2007)\n+--------------------------\n+\n+- Expose the extra_top, widgets and extra_bottom METAL hooks in edit_macros.\n+  [wichert]\n+\n+\n+1.1-final (August 16, 2007)\n+---------------------------\n+\n+- Prevent future off by one errors in the ui by just starting our count from 0.\n+  [alecm]\n+\n+- Fix dumb acquisition issue in the default policy scripts.\n+  [alecm]\n+\n+- Removed overly aggressive logging from update_version_before_edit.cpy.\n+  [hannosch]\n+\n+\n+1.1-rc1 (July 8, 2007)\n+----------------------\n+\n+- Make text more consistent (use revision instead of version throughout the ui)\n+\n+- Add checks in versioning policy scripts to ensure we don\'t get duplicate\n+  revisions.\n+\n+- Add controller overrides so that the correct actions happen on\n+  cancel and reference upload.\n+\n+- Add an event listener that removes the `version_id` attribute from\n+  copies.\n+\n+- Removed i18n folder. Translations are shipped in PloneTranslations. [hannosch]\n+\n+- Minor template corrections. [hannosch]\n+\n+\n+1.1-beta4 (April 30, 2007)\n+--------------------------\n+\n+- Updated permission mapping to account for new local roles (Editor/Contributor)\n+\n+\n+1.1-beta3 (April 29, 2007)\n+--------------------------\n+\n+- No longer register tools as utilities, since it broke the tests among\n+  other things.\n+\n+\n+1.1-beta2 (March 26, 2007)\n+--------------------------\n+\n+- Register tools as utilities\n+\n+\n+1.1-beta1 (March 5, 2007)\n+-------------------------\n+\n+- Make the AT autoversion policy save a version before the save for more\n+   intuitive behavior.\n+\n+- Fixed numerous ui glitches on the versions history form and started using\n+   statusmessages.\n+\n+- Do not install the versioning control panel anymore. You can enable versioning\n+  for a content type on the new types control panel now.\n+\n+ToDo\n+\n+- Finish exportimport handlers for portal_repository and portal_modifier thus\n+  making setuphandlers importVarious unnecessary again.\n+\n+- Add back special portal_historyidhandler / portal_uidhandler handling. If a\n+  portal_uidhandler tool is found during install, it should be renamed to\n+  portal_historyidhandler. The missing tools should be created as normal then.\n+\n+\n+1.1-alpha2 (February 08, 2007)\n+------------------------------\n+\n+- Removed specialized document byline.\n+\n+- Switch to Plone control panel category\n+\n+\n+1.1-alpha1 (November 22, 2006)\n+------------------------------\n+\n+Internal Changes\n+\n+- Two minor updates for CMF 2.1 compatibility. [hannosch]\n+\n+- Use a GenericSetup Extension profile for installation instead of an external\n+  method. [hannosch]\n+\n+- Cleaned up tests. As these are based on PloneTestCase and Plone 3.0 we don\'t\n+  have to set up anything special anymore. [hannosch, alecm]\n+\n+- Removed ActionProviderBase as a base class from all tools. In CMF 2.1 actions\n+  are usually only stored on the actions tool. [hannosch]\n+\n+- Updated dependency information for Plone 3.0 inclusion. [hannosch]\n+\n+\n+1.0 (SVN)\n+---------\n+\n+Bugs fixed\n+\n+- Fixed OMInsideChildrensModifier InitializeClass. [encolpe]\n+\n+Internal Changes\n+\n+- Replaced usage of zLOG with Python\'s logging framework. [hannosch]\n+\n+- Removed lots of unused import statements, found by pyflakes. [hannosch]\n+\n+- Removed BBB code for old transaction handling. [hannosch]\n+\n+- Removed some BBB code for ZClasses and CMF 1.4. [hannosch]\n+\n+CMFEditions 1.0rc1 (unreleased)\n+-------------------------------\n+\n+ToDo\n+\n+- migration from CMFEditions 1.0alpha3 doesn\'t work correctly\n+- some translations are not yet updated: contact translators (for changes see\n+  below. Affected translations: fr, da, pl)\n+- Fix outstanding failing tests\n+- Some complex integration test with deleted version. (purge support)\n+- allow adding test hierarchy only if in debug mode\n+- allow migration in debug mode only\n+- fix issue #28\n+- fix issue #25\n+- fix issue #19\n+- fix issue #17\n+- fix issue #22\n+\n+1.0beta1 (2006-06-24)\n+---------------------\n+\n+Bugs fixed\n+\n+- Fixed previewing (retrieving) files and images. [gregweb]\n+\n+- Security Policy was for ``manage_setPolicies`` but the method name\n+  was ``manage_setTypePolicies``. Corrected. [gregweb]\n+\n+- The storage now stores ZVC\'s ``__vc_info__`` for every version\n+  avoiding wrong information is attached to a working copy when\n+  previewing a version. Fix for ToDo.txt item #48. [gregweb]\n+\n+- Replaced all occurences of ``rollback`` with ``revert``. Brought into\n+  sync internal names with UI. Rollback may suggest a transaction\n+  rollback which is something different. Including i18n label\n+  ``label_rollback`` which is now ``label_revert``. Added backwards\n+  compatibility code for configuration. Translations not updated.\n+  [gregweb]\n+\n+- Minor refactorings of the version history view. Notably replaced\n+  ``(show below)`` by ``preview`` without jumping to the preview target\n+  on the page by default. Instead the link name of the previewed version\n+  changes to ``jump down``. [gregweb]\n+\n+- The storage is now more immune against non int selectors. [gregweb]\n+\n+\n+Features Added\n+\n+- The approximate size of a version is now recorded also at save time\n+  (and calculated at storage migartion).\n+  [gregweb]\n+\n+- Added size information to storage statistics ZMI view [gregweb]\n+\n+- Added German translations [gregweb]\n+\n+- Added Polish translations provided by Piotr Furman [Piotr Furman, gregweb]\n+\n+- ``RetainWorkflowStateAndHistory`` now adds the ``review_state`` to the\n+  ``sys_metadata`` at save time because at retreive time the workflow tool\n+  picks the working copies state. I didn\'t find any other way to do it\n+  without digging into workflows internals (which would have been a bad\n+  idea anyway). Had to extend the ``IModifier.ISaveRetrieveModifier``\n+  interface to allow a modifier enhance ``sys_metadata`` at save time.\n+  [gregweb]\n+\n+- Added purge support [gregweb]:\n+\n+  - Enhanced storage API with a ``purge`` method that inevitabely\n+    removes a version from the history. See added ``IPurgeSupport``\n+    and ``IPurgePolicy`` interfaces.\n+  - Purging raises an exception if no purge policy is installed. This\n+    will avoid a lot of future tracker items caused by people having\n+    removed the purge policy but nevertheless providing purge support\n+    to users. The reason is that the archivist and repo layer can\'t\n+    handle yet the empty placeholder object beeing returned by the\n+    storage for the purged version. This rule may be relaxed in future\n+    versions if the archivist and repo layer support handling of those\n+    empty placeholder objects.\n+  - The UI doesn\'t expose manual purge functionality. Through the ZMI a\n+    number n may be configured representing the maximum number of\n+    version per content item that have to be preserved. Older ones are\n+    automatically purged from the storage at save time.\n+  - There is a new purge permission that may be used to restrict purging\n+    to special roles if necessary (applicable to manual purging only).\n+  - On the repo layer (``portal_repository``) retrieving an object or\n+    iterating over the history always returns a valid (unpurged)\n+    version. The returned object may be a substitute. Two numbering\n+    schematas exist. Numbering counting purged versions and not\n+    counting purged versions (passing True or False to ``countPurged``).\n+    The default numbering schema is ``countPurged=True``. The UI\n+    history onyl shows unpurged versions (``countPurged=False``).\n+  - If the storage is asked to retreive a removed version it may be\n+    instructed to return a substitute for the removed version. The\n+    substitution policy itself is implemented in the new purge policy\n+    tool. This strategy allows to keep most purge implementation\n+    details out of the upper layers (archivist, modifiers, repository).\n+  - The new purge policy tool may be instructed to only keep n versions\n+    of a content item. Thus at save time the oldest version is purged\n+    if the save operation would result in more than n version reside in\n+    the storage.\n+  - The new purge policy tool substitutes a removed version with the\n+    next older version. If no other version is available the next\n+    newer is used as substitute. If none is available ... well this\n+    isn\'t yet tested :-)\n+  - The archivist and storage may be asked to also retreive the empty\n+    placeholder of a purged version. This functionality is yet exposed\n+    to the repo layer. This may change in a future release.\n+  - Added ``isValid`` method on the vdata object that allows to ask if\n+    the retrieved object it is valid or not (empty placeholder object\n+    or a real version).\n+\n+- At save time a version aware reference to the parent node is saved\n+  also. Without it would be very ineffective or even impossible to\n+  find out the parents which potentially would prevent adding usefull\n+  features like retrieving the a whole site from one object in the\n+  tree. [gregweb]\n+\n+- The histories default order has changed: It now returns the newest\n+  version as first item and the oldest as last item. The old behaviour\n+  is still available by passing ``oldestFirst=True``. [gregweb]\n+\n+- Inserted the ``oldestFirst`` parameter before the already existing\n+  ``preserve`` parameter. This will cause changes of 3rd party products\n+  that are using ``preserve`` (None know at the moment, it\'s better to\n+  change now than later). [gregweb]\n+\n+- Added two new i18n labels: ``label_preview_version_below``,\n+  ``label_preview_version`` (no translations yet) [gregweb]\n+\n+- Renamed i18n label: ``label_show_below`` to ``label_preview_version_link``\n+  (updated labels in po-files but not the translations) [gregweb]\n+\n+\n+Internal Changes\n+\n+- Now save all metadata also in shadow storage. But currently on retrieve\n+  the metadata is still feteched from the ZVC storage. [gregweb]\n+\n+- Added migration code for 1.0alpha3 --> 1.0beta1 storage migrations\n+  [gregweb]\n+\n+- Adding purge support caused heavy refactoring the version storage.\n+  ZVC is still used to store the contents history but now additional\n+  data is stored in a parallel shadow storage. The layout of the data\n+  in the ZVC didn\'t change, only ZVC and purge related metadata has\n+  been added to the parallel shadow storage. [gregweb]\n+\n+- Garbage collected a lot of code that was commented out, outdated\n+  triple-X\'s and items in ``ToDo.txt``. [gregweb]\n+\n+- The storage tests now tests ZVCSTorageTool only once and additionally\n+  tests the dummy memory storage. This was the intended behaviour but\n+  a bug prevented running the tests with the dummy storage and instead\n+  run the tests with ZVCStorageToll twice. [gregweb]\n+\n+\n+1.0alpha4 (2006-06-24)\n+----------------------\n+\n+Bugs fixed\n+\n+- fixed bug with AT references causing ref catalog having been inconsistent\n+  [sunew]\n+\n+\n+Features added\n+\n+- Comment is now taken from request if any. [sunew]\n+\n+- Added storage statistics ZMI view. [gregweb]\n+\n+- Added functionality to create a test hierarchy. [gregweb]\n+\n+\n+1.0alpha3 (2006-06-03)\n+----------------------\n+\n+Bugs fixed\n+\n+- Fixed tracker issue #15 [alecm, gregweb]\n+\n+- When previewing a version the expandable history link is removed as this\n+  doesn\'t make sense at all and caused double fetching of history items.\n+  [gregweb]\n+\n+- Use the default view of the retrieved object, as it may be different from\n+  that of the current object. [alecm]\n+\n+- The expandable version link is only shown for users having the permission\n+  to view the history. [rafrombrc]\n+\n+- Added RetainATRefs modifier [vds]\n+\n+- Fixed broken ``isUpToDate`` [gregweb]\n+\n+- ``version_id`` wasn\'t correctly set at the working copy at save time.\n+  Because of this it may happen that the wrong version info was saved\n+  with the version aware reference. The version_id is now set at the end\n+  of the save operation. [alecm, gregweb]\n+\n+- Handle usecase where an inside reference is moved outside its container.\n+  Still need to handle case where it has been replaced by another object\n+  with the same id.  [alecm]\n+\n+- Changed API for Archivist methods and the dereference utility method so\n+  that they now accept an optional history_id, rather than implicitly\n+  allowing the \'obj\' parameter to be a history_id. As side effect this\n+  will help in supporting multi location checkout in the future.\n+  [alecm, gregweb]\n+\n+- Fixed various UI issues. [rlemmi, vds, alecm]\n+\n+- Fixed SF issue #1376836. [alecm]\n+\n+- restored at\'s extra_buttons slot (some others slots are still missing\n+  because of this template override) [syt]\n+\n+- Totally refactored recursive retrieve of an ancient version of an object.\n+  Fixed a lot of folderish bugs with this refactoring. [gregweb]\n+\n+- Corrected a hairy acquisition bug that caused wrong security evaluations\n+  (ArchivistTool.py). Acquisition is a monster feature! [gregweb]\n+\n+- The storage now returns obj.modified() instead of\n+  obj.getModificationDate() because it\'s more fine graned. [gregweb]\n+\n+- Added ReferenceFactoriesTool.py which in essence knows how to\n+  instatiate a reference. The current implementation is inflexible and\n+  knows only how to instantiate object into an ObjectManager. This\n+  is the first step in preparation for AT reference handling. [gregweb]\n+\n+- Fixed tracker issue #16 RuntimeError: maximum recursion depth exceeded.\n+  I (gregweb) suspect it got fixed by: [alecm]\n+\n+- Fixed identical tracker issues #5, #6, #7, #8. I (gregweb) suspect it got\n+  fixed by: [alecm]\n+\n+- Added modifier to copy permissions from working copy onto retrieved\n+  versions, otherwise retaining workflow can have some very strange\n+  consequences. [alecm]\n+\n+- Fixed a number of bugs involving handling of adding and deleting subobjects\n+  of versioned folders.\n+  [alecm]\n+\n+- Fixed a permissions bug which made the versions_history_form inaccessible if\n+  any of the versions were saved while private (or otherwise had\n+  \'Access contents information\' disabled).\n+  [alecm]\n+\n+- Made quickinstalled product reinstall/uninstall work without issue.  Fixed\n+  unit tests for Plone 2.1.  Use mutators in templates and tests where\n+  applicable rather than direct attribute access. Was Issue #9, #10 and #11.\n+  Thanks to Andrew Lewis for the patches and reports. [Andrew Lewis, alecm]\n+\n+- Corrected bugs in ``RetainWorkflowStateAndHistory`` modifier and the\n+  modifier registry avoiding the review state and the workflow history\n+  from beeing retained on retrieve and revert.\n+\n+\n+Features added\n+\n+- Added danish translation. [stonor]\n+\n+- Retrieving an object just for preview (without replacing the working copy)\n+  caused a lot of headaches and got more and more complex und ununderstandable.\n+  Everything got much simpler by just using a savepoint/abort pair at the right\n+  place while retrieving. [alecm]\n+\n+- I18N tuned (diff-legend untested), french added\n+  [Gpgi, gotcha]\n+\n+- Added more tests to improve coverage. [azy, vds, alecm]\n+\n+- Added support for ATCT (Archetypes Content Types). [azy]\n+\n+- Added ZMI interface for modifiers. [rlemmi]\n+\n+- It\'s now possible to save a new version in the edit view. As soon as a\n+  version sahll be saved a comment field is inserted to add a comment.\n+  [rlemmi]\n+\n+- Added expandable version history to document_byline. [rlemmi]\n+\n+- Made the ModifierRegistryTool make use of any preserve dict passed back to\n+  it by afterRetrieveModifiers.\n+  [alecm]\n+\n+- Added optional CMFDiffTool support for generating diffs between object\n+  versions.  For this to work you need to setup the diffable fields on each\n+  type in portal_diff.  In the \'alecm-at-schema-diffs\' branch of CMFDiffTool\n+  there is a diff type that can be applied to any AT object which will\n+  automatically setup diffs for all fields in the schema (when using this\n+  any value can be entered for the field in portal_diff).\n+  [alecm]\n+\n+- Added a versioning policy (at_edit_autoversion) which automatically creates\n+  new versions on edit for AT types which are configured to support the policy\n+  in the configlet.  This is implemented using a simple macro override on\n+  AT\'s edit_macros, and a new entry in the AT edit form controller chain.\n+  [alecm]\n+\n+- Added new interface IContentTypeVersionPolicySupport and implemented it in\n+  portal_repository.  It allows products to register versioning policies\n+  (classes which implement IVersionPolicy), and to associate those policies\n+  with specific portal types.  IVersionPolicy objects may define methods\n+  (setupPolicyHook, removePolicyHook, enablePolicyOnTypeHook,\n+  disablePolicyOnTypeHook) which can be used to install/uninstall policy\n+  specific behavior in the portal, on adding/removing the policy, or enabling/\n+  disabling the policy on a specific type.\n+  [alecm]\n+\n+\n+1.0alpha2 (around June 2005)\n+----------------------------\n+\n+no changes recorded\n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-17T00:23:07+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/57bc28f7b05a42226bf903ba466c898c727f47d4

pyupgrade --py37-plus

Files changed:
M Products/CMFEditions/ArchivistTool.py
M Products/CMFEditions/CopyModifyMergeRepositoryTool.py
M Products/CMFEditions/KeepLastNVersionsTool.py
M Products/CMFEditions/ModifierRegistryTool.py
M Products/CMFEditions/Modifiers.py
M Products/CMFEditions/Permissions.py
M Products/CMFEditions/ReferenceFactoriesTool.py
M Products/CMFEditions/StandardModifiers.py
M Products/CMFEditions/StorageMigrationSupport.py
M Products/CMFEditions/VersionPolicies.py
M Products/CMFEditions/ZVCStorageTool.py
M Products/CMFEditions/__init__.py
M Products/CMFEditions/browser/__init__.py
M Products/CMFEditions/browser/diff.py
M Products/CMFEditions/browser/utils.py
M Products/CMFEditions/browser/views.py
M Products/CMFEditions/exportimport/__init__.py
M Products/CMFEditions/exportimport/repository.py
M Products/CMFEditions/historyidhandlertool.py
M Products/CMFEditions/interfaces/IArchivist.py
M Products/CMFEditions/interfaces/IModifier.py
M Products/CMFEditions/interfaces/IPurgePolicy.py
M Products/CMFEditions/interfaces/IReferenceFactories.py
M Products/CMFEditions/interfaces/IRepository.py
M Products/CMFEditions/interfaces/IStorage.py
M Products/CMFEditions/interfaces/IVersionPolicy.py
M Products/CMFEditions/interfaces/__init__.py
M Products/CMFEditions/interfaces/_tools.py
M Products/CMFEditions/setuphandlers.py
M Products/CMFEditions/subscriber.py
M Products/CMFEditions/testing.py
M Products/CMFEditions/tests/DummyTools.py
M Products/CMFEditions/tests/__init__.py
M Products/CMFEditions/tests/test_ArchivistTool.py
M Products/CMFEditions/tests/test_ContentTypes.py
M Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py
M Products/CMFEditions/tests/test_IntegrationTests.py
M Products/CMFEditions/tests/test_KeepLastNVersionsTool.py
M Products/CMFEditions/tests/test_ModifierRegistryTool.py
M Products/CMFEditions/tests/test_ZVCStorageTool.py
M Products/CMFEditions/tests/test_doctests.py
M Products/CMFEditions/tests/test_versions_history_form.py
M Products/CMFEditions/utilities.py
M Products/__init__.py
M setup.py

b'diff --git a/Products/CMFEditions/ArchivistTool.py b/Products/CMFEditions/ArchivistTool.py\nindex 50c960d..3baa3c6 100644\n--- a/Products/CMFEditions/ArchivistTool.py\n+++ b/Products/CMFEditions/ArchivistTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/CopyModifyMergeRepositoryTool.py b/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\nindex b7de428..f9aafb0 100644\n--- a/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\n+++ b/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber,\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -231,9 +230,9 @@ def manage_changePolicyDefs(self, policy_list, **kwargs):\n                 raise AssertionError(\n                     "Each policy definition must contain a title and id: %s" % str(item)\n                 )\n-            if not isinstance(item[0], six.string_types):\n+            if not isinstance(item[0], str):\n                 raise AssertionError("Policy id must be a string: %s" % str(item[0]))\n-            if not isinstance(item[1], six.string_types):\n+            if not isinstance(item[1], str):\n                 raise AssertionError("Policy title must be a string: %s" % str(item[1]))\n             # Get optional Policy class and kwargs.\n             if len(item) >= 3:\n@@ -462,7 +461,7 @@ def _recursiveSave(self, obj, app_metadata, sys_metadata, autoapply):\n         # objects\n         if sys_metadata["originator"] is None:\n             clone = prep.clone.object\n-            sys_metadata["originator"] = "%s.%s.%s" % (\n+            sys_metadata["originator"] = "{}.{}.{}".format(\n                 prep.history_id,\n                 clone.version_id,\n                 clone.location_id,\n@@ -698,7 +697,7 @@ def _fixIds(self, obj):\n                     object_list = getattr(obj, "_objects", None)\n                     if object_list is not None:\n                         obj._objects = tuple(\n-                            [o for o in object_list if o["id"] != orig_id]\n+                            o for o in object_list if o["id"] != orig_id\n                         )  # noqa\n                     temp_ids.append((real_id, child))\n             # Make a second pass to move the objects into place if possible\ndiff --git a/Products/CMFEditions/KeepLastNVersionsTool.py b/Products/CMFEditions/KeepLastNVersionsTool.py\nindex a0340f7..d4f8924 100644\n--- a/Products/CMFEditions/KeepLastNVersionsTool.py\n+++ b/Products/CMFEditions/KeepLastNVersionsTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/ModifierRegistryTool.py b/Products/CMFEditions/ModifierRegistryTool.py\nindex ae25ee0..0f0bc02 100644\n--- a/Products/CMFEditions/ModifierRegistryTool.py\n+++ b/Products/CMFEditions/ModifierRegistryTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -196,7 +195,7 @@ def persistent_id(obj):\n                 pid = pers_id(obj)\n                 if pid is not None:\n                     # found a modifier, add the modifiers name to its pid\n-                    return "%s/%s" % (pers_id_nameByMeth[pers_id], pid)\n+                    return f"{pers_id_nameByMeth[pers_id]}/{pid}"\n \n         def persistent_load(named_pid):\n             # call the right modifiers persistent_load callback\ndiff --git a/Products/CMFEditions/Modifiers.py b/Products/CMFEditions/Modifiers.py\nindex 1ca9091..fb6df97 100644\n--- a/Products/CMFEditions/Modifiers.py\n+++ b/Products/CMFEditions/Modifiers.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/Permissions.py b/Products/CMFEditions/Permissions.py\nindex bb56e02..136097c 100644\n--- a/Products/CMFEditions/Permissions.py\n+++ b/Products/CMFEditions/Permissions.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/ReferenceFactoriesTool.py b/Products/CMFEditions/ReferenceFactoriesTool.py\nindex 5055f6a..c753380 100644\n--- a/Products/CMFEditions/ReferenceFactoriesTool.py\n+++ b/Products/CMFEditions/ReferenceFactoriesTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2005 Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/StandardModifiers.py b/Products/CMFEditions/StandardModifiers.py\nindex d334e12..417f558 100644\n--- a/Products/CMFEditions/StandardModifiers.py\n+++ b/Products/CMFEditions/StandardModifiers.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2005 Alberto Berti, Gregoire Weber,\n # Reflab(Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi),\n@@ -725,24 +724,24 @@ def getOnCloneModifiers(self, obj):\n             return\n \n         component_bases = dict(\n-            registry=dict(\n-                (id(aq_base(base)), aq_base(base)) for base in registry.__bases__\n-            ),\n-            utilities=dict(\n-                (id(aq_base(base)), aq_base(base))\n+            registry={\n+                id(aq_base(base)): aq_base(base) for base in registry.__bases__\n+            },\n+            utilities={\n+                id(aq_base(base)): aq_base(base)\n                 for base in registry.utilities.__bases__\n-            ),\n-            adapters=dict(\n-                (id(aq_base(base)), aq_base(base))\n+            },\n+            adapters={\n+                id(aq_base(base)): aq_base(base)\n                 for base in registry.adapters.__bases__\n-            ),\n+            },\n         )\n \n         def persistent_id(obj):\n             obj_id = id(aq_base(obj))\n-            for key, bases in six.iteritems(component_bases):\n+            for key, bases in component_bases.items():\n                 if obj_id in bases:\n-                    return "%s:%s" % (key, obj_id)\n+                    return f"{key}:{obj_id}"\n             return None\n \n         def persistent_load(obj):\n@@ -872,7 +871,7 @@ def _getFieldValues(self, obj):\n             # Skip linked Pdata chains too long for the pickler\n             if hasattr(aq_base(val), "getSize") and callable(val.getSize):\n                 size = val.getSize()\n-                if isinstance(size, six.integer_types) and size >= max_size:\n+                if isinstance(size, int) and size >= max_size:\n                     yield "attribute", name, val\n \n     def getOnCloneModifiers(self, obj):\n@@ -888,7 +887,7 @@ def getOnCloneModifiers(self, obj):\n _empty_marker = []\n \n \n-class LargeFilePlaceHolder(object):\n+class LargeFilePlaceHolder:\n     """PlaceHolder for a large object"""\n \n     @staticmethod\n@@ -972,11 +971,11 @@ def getOnCloneModifiers(self, obj):\n         if not blob_file_classes:\n             return\n \n-        blob_refs = set(\n+        blob_refs = {\n             id(v)\n-            for v in six.itervalues(obj.__dict__)\n+            for v in obj.__dict__.values()\n             if isinstance(v, blob_file_classes)\n-        )\n+        }\n \n         def persistent_id(obj):\n             if id(aq_base(obj)) in blob_refs:\n@@ -1001,7 +1000,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n \n         blob_fields = (\n             (k, v)\n-            for k, v in six.iteritems(obj.__dict__)\n+            for k, v in obj.__dict__.items()\n             if isinstance(v, blob_file_classes)\n         )\n \ndiff --git a/Products/CMFEditions/StorageMigrationSupport.py b/Products/CMFEditions/StorageMigrationSupport.py\nindex a647eef..7887324 100644\n--- a/Products/CMFEditions/StorageMigrationSupport.py\n+++ b/Products/CMFEditions/StorageMigrationSupport.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2006 Gregoire Weber\n # All Rights Reserved.\n@@ -61,10 +60,10 @@ def editEvent(context, version=0):\n         location = "0: %s event location" % name\n         contact = "0: %s event contact" % name\n     else:\n-        title = "%s%s" % (version, title[1:])\n-        desc = "%s%s" % (version, desc[1:])\n-        location = "%s%s" % (version, location[1:])\n-        contact = "%s%s" % (version, contact[1:])\n+        title = f"{version}{title[1:]}"\n+        desc = f"{version}{desc[1:]}"\n+        location = f"{version}{location[1:]}"\n+        contact = f"{version}{contact[1:]}"\n \n     context.update(\n         title=title,\n@@ -85,9 +84,9 @@ def editFile(context, version=0):\n         desc = "0: %s file description" % name\n         file = 100 * ("0: %s file body\\n" % name)\n     else:\n-        title = "%s%s" % (version, title[1:])\n-        desc = "%s%s" % (version, desc[1:])\n-        file = 100 * ("%s%s" % (version, ": %s file body\\n" % name))\n+        title = f"{version}{title[1:]}"\n+        desc = f"{version}{desc[1:]}"\n+        file = 100 * ("{}{}".format(version, ": %s file body\\n" % name))\n     context.update(title=title, description=desc, file=file)\n \n \n@@ -98,8 +97,8 @@ def editFolder(context, version=0):\n     if not title:\n         title = "0: %s folder title" % name\n         desc = "0: %s folder description" % name\n-    title = "%s%s" % (version, title[1:])\n-    desc = "%s%s" % (version, desc[1:])\n+    title = f"{version}{title[1:]}"\n+    desc = f"{version}{desc[1:]}"\n     context.folder_edit(title=title, description=desc)\n \n \n@@ -110,7 +109,7 @@ def editImage(context, version=0):\n     name = context.getId()\n     if name.endswith(".gif"):\n         name = name[:-4]\n-    filename = "%s_v%s.gif" % (name, version)\n+    filename = f"{name}_v{version}.gif"\n     path = os.path.join(PACKAGE_HOME, "tests", "images", filename)\n     with open(path) as image_handle:\n         image = image_handle.read()\n@@ -118,8 +117,8 @@ def editImage(context, version=0):\n         title = "0: %s image title" % name\n         desc = "0: %s image description" % name\n     else:\n-        title = "%s%s" % (version, title[1:])\n-        desc = "%s%s" % (version, desc[1:])\n+        title = f"{version}{title[1:]}"\n+        desc = f"{version}{desc[1:]}"\n     context.update(title=title, description=desc, image=image)\n \n \n@@ -133,9 +132,9 @@ def editLink(context, version=0):\n         desc = "0: %s link description" % name\n         remoteUrl = "http://www.plone.org/#%s_v0" % name\n     else:\n-        title = "%s%s" % (version, title[1:])\n-        desc = "%s%s" % (version, desc[1:])\n-        remoteUrl = "%s%s" % (remoteUrl[:-1], version)\n+        title = f"{version}{title[1:]}"\n+        desc = f"{version}{desc[1:]}"\n+        remoteUrl = f"{remoteUrl[:-1]}{version}"\n     context.update(title=title, description=desc, remoteUrl=remoteUrl)\n \n \n@@ -149,9 +148,9 @@ def editNewsItem(context, version=0):\n         desc = "0: %s news item description" % name\n         text = "0: %s news item body" % name\n     else:\n-        title = "%s%s" % (version, title[1:])\n-        desc = "%s%s" % (version, desc[1:])\n-        text = "%s%s" % (version, text[1:])\n+        title = f"{version}{title[1:]}"\n+        desc = f"{version}{desc[1:]}"\n+        text = f"{version}{text[1:]}"\n     context.update(title=title, description=desc, text=text)\n \n \n@@ -165,9 +164,9 @@ def editDocument(context, version=0):\n         desc = "0: %s document description" % name\n         text = "0: %s document body" % name\n     else:\n-        title = "%s%s" % (version, title[1:])\n-        desc = "%s%s" % (version, desc[1:])\n-        text = "%s%s" % (version, text[1:])\n+        title = f"{version}{title[1:]}"\n+        desc = f"{version}{desc[1:]}"\n+        text = f"{version}{text[1:]}"\n     context.update(title=title, description=desc, text=text)\n \n \n@@ -208,7 +207,7 @@ def createTestHierarchy(context):\n     for name, type in hierarchy.items():\n         logger.log(\n             logging.INFO,\n-            "createTestHierarchy: creating container %s(%s)" % (name, type[0]),\n+            f"createTestHierarchy: creating container {name}({type[0]})",\n         )\n         folder = create(testRoot, type[0], name)\n         nbrOfObjects += 1\n@@ -225,7 +224,7 @@ def createTestHierarchy(context):\n             objName = name[:-1] + str(i + 1) + ext\n             logger.log(\n                 logging.INFO,\n-                "createTestHierarchy: creating %s(%s)" % (objName, type[1]),\n+                f"createTestHierarchy: creating {objName}({type[1]})",\n             )\n             obj = create(folder, type[1], objName)\n             nbrOfObjects += 1\ndiff --git a/Products/CMFEditions/VersionPolicies.py b/Products/CMFEditions/VersionPolicies.py\nindex a77fd40..ac5da49 100644\n--- a/Products/CMFEditions/VersionPolicies.py\n+++ b/Products/CMFEditions/VersionPolicies.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alec Mitchell\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/ZVCStorageTool.py b/Products/CMFEditions/ZVCStorageTool.py\nindex 9aab338..6ff51d3 100644\n--- a/Products/CMFEditions/ZVCStorageTool.py\n+++ b/Products/CMFEditions/ZVCStorageTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005, 2006 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/__init__.py b/Products/CMFEditions/__init__.py\nindex 4fb5e6c..140db83 100644\n--- a/Products/CMFEditions/__init__.py\n+++ b/Products/CMFEditions/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2003, 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/browser/__init__.py b/Products/CMFEditions/browser/__init__.py\nindex 40a96af..e69de29 100644\n--- a/Products/CMFEditions/browser/__init__.py\n+++ b/Products/CMFEditions/browser/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/Products/CMFEditions/browser/diff.py b/Products/CMFEditions/browser/diff.py\nindex 217c9f4..8711c84 100644\n--- a/Products/CMFEditions/browser/diff.py\n+++ b/Products/CMFEditions/browser/diff.py\n@@ -1,11 +1,8 @@\n-# -*- coding: utf-8 -*-\n-\n from Acquisition import aq_inner\n from Products.CMFCore.utils import getToolByName\n from Products.CMFEditions import CMFEditionsMessageFactory as _\n from Products.Five.browser import BrowserView\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n-from six.moves import range\n from zope.i18n import translate\n \n \n@@ -13,7 +10,7 @@ class DiffView(BrowserView):\n     template = ViewPageTemplateFile("diff.pt")\n \n     def __init__(self, *args):\n-        super(DiffView, self).__init__(*args)\n+        super().__init__(*args)\n         self.repo_tool = getToolByName(self.context, "portal_repository")\n \n     def getVersion(self, version):\n@@ -34,7 +31,7 @@ def versionTitle(self, version):\n         version_name = self.versionName(version)\n \n         return translate(\n-            _(u"version ${version}", mapping=dict(version=version_name)),\n+            _("version ${version}", mapping=dict(version=version_name)),\n             context=self.request,\n         )\n \ndiff --git a/Products/CMFEditions/browser/utils.py b/Products/CMFEditions/browser/utils.py\nindex 703420b..c40f048 100644\n--- a/Products/CMFEditions/browser/utils.py\n+++ b/Products/CMFEditions/browser/utils.py\n@@ -51,7 +51,7 @@ def get_macros(self, vdata):\n             return versionPreviewTemplate.macros["main"]\n         except KeyError:\n             logger.warn(\n-                \'Missing TAL macros {0} in template "{1}".\'.format(\n+                \'Missing TAL macros {} in template "{}".\'.format(\n                     ", ".join(macro_names), versionPreviewMethodName\n                 )\n             )\ndiff --git a/Products/CMFEditions/browser/views.py b/Products/CMFEditions/browser/views.py\nindex 0da223c..23501f5 100644\n--- a/Products/CMFEditions/browser/views.py\n+++ b/Products/CMFEditions/browser/views.py\n@@ -82,7 +82,7 @@ def __call__(self):\n         obj = portal_repository.retrieve(context, version_id).object\n         working_copy_tag = obj.tag()\n         altPos = working_copy_tag.find("alt=")\n-        tag = \'<img src="%s/file_download_version?version_id=%s" %s\' % (\n+        tag = \'<img src="{}/file_download_version?version_id={}" {}\'.format(\n             here_url,\n             version_id,\n             working_copy_tag[altPos:],\ndiff --git a/Products/CMFEditions/exportimport/__init__.py b/Products/CMFEditions/exportimport/__init__.py\nindex ec51c5a..792d600 100644\n--- a/Products/CMFEditions/exportimport/__init__.py\n+++ b/Products/CMFEditions/exportimport/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n #\ndiff --git a/Products/CMFEditions/exportimport/repository.py b/Products/CMFEditions/exportimport/repository.py\nindex c6ac37b..c47a0a5 100644\n--- a/Products/CMFEditions/exportimport/repository.py\n+++ b/Products/CMFEditions/exportimport/repository.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Products.CMFCore.utils import getToolByName\n from Products.CMFEditions.VersionPolicies import VersionPolicy\n from Products.GenericSetup.utils import exportObjects\n@@ -74,7 +73,7 @@ def _extractPolicies(self):\n             p.setAttribute("title", policy.Title())\n             klass = type(policy)\n             if klass is not VersionPolicy:\n-                p.setAttribute("class", "%s.%s" % (klass.__module__, klass.__name__))\n+                p.setAttribute("class", f"{klass.__module__}.{klass.__name__}")\n             node.appendChild(p)\n         return node\n \ndiff --git a/Products/CMFEditions/historyidhandlertool.py b/Products/CMFEditions/historyidhandlertool.py\nindex 7c553f5..0cfa1e3 100644\n--- a/Products/CMFEditions/historyidhandlertool.py\n+++ b/Products/CMFEditions/historyidhandlertool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/interfaces/IArchivist.py b/Products/CMFEditions/interfaces/IArchivist.py\nindex 394289f..c47e727 100644\n--- a/Products/CMFEditions/interfaces/IArchivist.py\n+++ b/Products/CMFEditions/interfaces/IArchivist.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/interfaces/IModifier.py b/Products/CMFEditions/interfaces/IModifier.py\nindex 30824bc..e0a4444 100644\n--- a/Products/CMFEditions/interfaces/IModifier.py\n+++ b/Products/CMFEditions/interfaces/IModifier.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber,\n # Reflab(Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi),\ndiff --git a/Products/CMFEditions/interfaces/IPurgePolicy.py b/Products/CMFEditions/interfaces/IPurgePolicy.py\nindex b4637fb..1e9a52f 100644\n--- a/Products/CMFEditions/interfaces/IPurgePolicy.py\n+++ b/Products/CMFEditions/interfaces/IPurgePolicy.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2006 Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/interfaces/IReferenceFactories.py b/Products/CMFEditions/interfaces/IReferenceFactories.py\nindex c5d47e1..d7c3281 100644\n--- a/Products/CMFEditions/interfaces/IReferenceFactories.py\n+++ b/Products/CMFEditions/interfaces/IReferenceFactories.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2005 Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/interfaces/IRepository.py b/Products/CMFEditions/interfaces/IRepository.py\nindex e60003b..a8a4af8 100644\n--- a/Products/CMFEditions/interfaces/IRepository.py\n+++ b/Products/CMFEditions/interfaces/IRepository.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/interfaces/IStorage.py b/Products/CMFEditions/interfaces/IStorage.py\nindex 8f51b3e..45cf524 100644\n--- a/Products/CMFEditions/interfaces/IStorage.py\n+++ b/Products/CMFEditions/interfaces/IStorage.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/interfaces/IVersionPolicy.py b/Products/CMFEditions/interfaces/IVersionPolicy.py\nindex 79902e9..54ce938 100644\n--- a/Products/CMFEditions/interfaces/IVersionPolicy.py\n+++ b/Products/CMFEditions/interfaces/IVersionPolicy.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/interfaces/__init__.py b/Products/CMFEditions/interfaces/__init__.py\nindex af422ac..607490e 100644\n--- a/Products/CMFEditions/interfaces/__init__.py\n+++ b/Products/CMFEditions/interfaces/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Products.CMFEditions.interfaces._tools import IArchivistTool  # noqa: F401\n from Products.CMFEditions.interfaces._tools import IPortalModifierTool  # noqa: F401\n from Products.CMFEditions.interfaces._tools import IPurgePolicyTool  # noqa: F401\ndiff --git a/Products/CMFEditions/interfaces/_tools.py b/Products/CMFEditions/interfaces/_tools.py\nindex 7bb34a0..7737b1f 100644\n--- a/Products/CMFEditions/interfaces/_tools.py\n+++ b/Products/CMFEditions/interfaces/_tools.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Interface\n \n \ndiff --git a/Products/CMFEditions/setuphandlers.py b/Products/CMFEditions/setuphandlers.py\nindex de372a9..82da986 100644\n--- a/Products/CMFEditions/setuphandlers.py\n+++ b/Products/CMFEditions/setuphandlers.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """\n CMFEditions setup handlers.\n """\ndiff --git a/Products/CMFEditions/subscriber.py b/Products/CMFEditions/subscriber.py\nindex a9f1745..b5adfd7 100644\n--- a/Products/CMFEditions/subscriber.py\n+++ b/Products/CMFEditions/subscriber.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2008 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/testing.py b/Products/CMFEditions/testing.py\nindex f0cdd6d..a723bf2 100644\n--- a/Products/CMFEditions/testing.py\n+++ b/Products/CMFEditions/testing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FIXTURE\n from plone.app.robotframework.testing import REMOTE_LIBRARY_BUNDLE_FIXTURE\n from plone.app.testing import applyProfile\n@@ -23,12 +22,10 @@ def setUpZope(self, app, configurationContext):\n     def setUpPloneSite(self, portal):\n         applyProfile(portal, "Products.CMFEditions:CMFEditions")\n         # with named AND dotted behaviors we need to take care of both\n-        versioning_behavior = set(\n-            [\n+        versioning_behavior = {\n                 "plone.app.versioningbehavior.behaviors.IVersionable",\n                 "plone.versioning",\n-            ],\n-        )\n+        }\n         for name in ("Document", "Event", "Link", "News Item"):\n             fti = portal.portal_types[name]\n             # write back the behaviors without the versioning behaviors\ndiff --git a/Products/CMFEditions/tests/DummyTools.py b/Products/CMFEditions/tests/DummyTools.py\nindex aa76a4b..4fa13ab 100644\n--- a/Products/CMFEditions/tests/DummyTools.py\n+++ b/Products/CMFEditions/tests/DummyTools.py\n@@ -1,5 +1,3 @@\n-# -*- coding: utf-8 -*-\n-\n from Acquisition import aq_base\n from copy import deepcopy\n from DateTime import DateTime\n@@ -155,7 +153,7 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n             )\n         else:\n             self.log(\n-                "%sprepare %s: hid=%s" % (self.alog_indent, obj.getId(), history_id)\n+                f"{self.alog_indent}prepare {obj.getId()}: hid={history_id}"\n             )\n         self.alog_indent += "  "\n \n@@ -206,8 +204,8 @@ def save(self, prepared_obj, autoregister=False):\n \n         irefs = [ref.getAttribute() for ref in prepared_obj.clone.inside_refs]\n         orefs = [ref.getAttribute() for ref in prepared_obj.clone.outside_refs]\n-        irefs_prep = ["{hid:%s, vid:%s}" % (r.history_id, r.version_id) for r in irefs]\n-        orefs_prep = ["{hid:%s, vid:%s}" % (r.history_id, r.version_id) for r in orefs]\n+        irefs_prep = [f"{{hid:{r.history_id}, vid:{r.version_id}}}" for r in irefs]\n+        orefs_prep = [f"{{hid:{r.history_id}, vid:{r.version_id}}}" for r in orefs]\n         irefs = ", ".join(irefs_prep)\n         orefs = ", ".join(orefs_prep)\n         if irefs:\n@@ -719,7 +717,7 @@ def retrieve(self, history_id, selector=None, countPurged=True, substitute=True)\n         return self.history[selector]\n \n \n-class DummyData(object):\n+class DummyData:\n     def __init__(self, data):\n         self.data = data\n \n@@ -727,6 +725,6 @@ def isValid(self):\n         return True\n \n \n-class RemovedData(object):\n+class RemovedData:\n     def isValid(self):\n         return False\ndiff --git a/Products/CMFEditions/tests/__init__.py b/Products/CMFEditions/tests/__init__.py\nindex ba86dce..bbb5516 100644\n--- a/Products/CMFEditions/tests/__init__.py\n+++ b/Products/CMFEditions/tests/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """\\\n Unit test package for CMFEditions\n """\ndiff --git a/Products/CMFEditions/tests/test_ArchivistTool.py b/Products/CMFEditions/tests/test_ArchivistTool.py\nindex b38ef1d..c2de356 100644\n--- a/Products/CMFEditions/tests/test_ArchivistTool.py\n+++ b/Products/CMFEditions/tests/test_ArchivistTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -37,7 +36,7 @@\n \n class TestArchivistToolMemoryStorage(CMFEditionsBaseTestCase):\n     def setUp(self):\n-        super(TestArchivistToolMemoryStorage, self).setUp()\n+        super().setUp()\n \n         self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n         self.portal.invokeFactory("Document", "doc")\ndiff --git a/Products/CMFEditions/tests/test_ContentTypes.py b/Products/CMFEditions/tests/test_ContentTypes.py\nindex 439ce5b..68f1ebe 100644\n--- a/Products/CMFEditions/tests/test_ContentTypes.py\n+++ b/Products/CMFEditions/tests/test_ContentTypes.py\n@@ -1,5 +1,3 @@\n-# -*- coding: utf-8 -*-\n-\n from plone.app.textfield.value import RichTextValue\n from plone.namedfile.file import NamedBlobFile\n from plone.namedfile.file import NamedBlobImage\n@@ -18,7 +16,7 @@ def read_image(file_path):\n \n class TestPloneContents(CMFEditionsBaseTestCase):\n     def setUp(self):\n-        super(TestPloneContents, self).setUp()\n+        super().setUp()\n         self.membership = self.portal.portal_membership\n         self.catalog = self.portal.portal_catalog\n         self.workflow = self.portal.portal_workflow\n@@ -51,21 +49,21 @@ def testDocument(self):\n         self.folder.invokeFactory("Document", id="doc")\n         portal_repository = self.portal_repository\n         content = self.folder.doc\n-        content.text = RichTextValue(u"text v1", "text/plain", "text/plain")\n-        content.title = u"content"\n-        content.subject = [u"content"]\n-        content.description = u"content"\n-        content.contributors = [u"content"]\n+        content.text = RichTextValue("text v1", "text/plain", "text/plain")\n+        content.title = "content"\n+        content.subject = ["content"]\n+        content.description = "content"\n+        content.contributors = ["content"]\n         content.language = "content"\n-        content.rights = u"content"\n+        content.rights = "content"\n         portal_repository.applyVersionControl(content, comment="save no 1")\n-        content.text = RichTextValue(u"text v2", "text/plain", "text/plain")\n-        content.title = u"contentOK"\n-        content.subject = [u"contentOK"]\n-        content.description = u"contentOK"\n-        content.contributors = [u"contentOK"]\n+        content.text = RichTextValue("text v2", "text/plain", "text/plain")\n+        content.title = "contentOK"\n+        content.subject = ["contentOK"]\n+        content.description = "contentOK"\n+        content.contributors = ["contentOK"]\n         content.language = "contentOK"\n-        content.rights = u"contentOK"\n+        content.rights = "contentOK"\n         portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n         self.assertEqual(obj.text.raw, "text v1")\n@@ -81,21 +79,21 @@ def testNewsItem(self):\n         self.folder.invokeFactory("News Item", id="news_one")\n         portal_repository = self.portal_repository\n         content = self.folder.news_one\n-        content.text = RichTextValue(u"text v1", "text/plain", "text/plain")\n-        content.title = u"content"\n-        content.subject = [u"content"]\n-        content.description = u"content"\n-        content.contributors = [u"content"]\n+        content.text = RichTextValue("text v1", "text/plain", "text/plain")\n+        content.title = "content"\n+        content.subject = ["content"]\n+        content.description = "content"\n+        content.contributors = ["content"]\n         content.language = "content"\n-        content.rights = u"content"\n+        content.rights = "content"\n         portal_repository.applyVersionControl(content, comment="save no 1")\n-        content.text = RichTextValue(u"text v2", "text/plain", "text/plain")\n-        content.title = u"contentOK"\n-        content.subject = [u"contentOK"]\n-        content.description = u"contentOK"\n-        content.contributors = [u"contentOK"]\n+        content.text = RichTextValue("text v2", "text/plain", "text/plain")\n+        content.title = "contentOK"\n+        content.subject = ["contentOK"]\n+        content.description = "contentOK"\n+        content.contributors = ["contentOK"]\n         content.language = "contentOK"\n-        content.rights = u"contentOK"\n+        content.rights = "contentOK"\n         portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n         self.assertEqual(obj.text.raw, "text v1")\n@@ -113,21 +111,21 @@ def testImage(self):\n         img1 = read_image("tests/images/img1.png")\n         img2 = read_image("tests/images/img2.png")\n         content = self.folder.image\n-        content.image = NamedBlobImage(img1, u"img1.png", u"image/png")\n-        content.title = u"content"\n-        content.subject = [u"content"]\n-        content.description = u"content"\n-        content.contributors = [u"content"]\n+        content.image = NamedBlobImage(img1, "img1.png", "image/png")\n+        content.title = "content"\n+        content.subject = ["content"]\n+        content.description = "content"\n+        content.contributors = ["content"]\n         content.language = "content"\n-        content.rights = u"content"\n+        content.rights = "content"\n         portal_repository.applyVersionControl(content, comment="save no 1")\n-        content.image = NamedBlobImage(img2, u"img2.png", u"image/png")\n-        content.title = u"contentOK"\n-        content.subject = [u"contentOK"]\n-        content.description = u"contentOK"\n-        content.contributors = [u"contentOK"]\n+        content.image = NamedBlobImage(img2, "img2.png", "image/png")\n+        content.title = "contentOK"\n+        content.subject = ["contentOK"]\n+        content.description = "contentOK"\n+        content.contributors = ["contentOK"]\n         content.language = "contentOK"\n-        content.rights = u"contentOK"\n+        content.rights = "contentOK"\n         portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n         self.assertEqual(obj.image.data, img1)\n@@ -145,21 +143,21 @@ def testFile(self):\n         file2 = read_image("tests/images/img2.png")\n         portal_repository = self.portal_repository\n         content = self.folder.file\n-        content.file = NamedBlobFile(file1, u"img1.png", u"image/png")\n-        content.title = u"content"\n-        content.subject = [u"content"]\n-        content.description = u"content"\n-        content.contributors = [u"content"]\n+        content.file = NamedBlobFile(file1, "img1.png", "image/png")\n+        content.title = "content"\n+        content.subject = ["content"]\n+        content.description = "content"\n+        content.contributors = ["content"]\n         content.language = "content"\n-        content.rights = u"content"\n+        content.rights = "content"\n         portal_repository.applyVersionControl(content, comment="save no 1")\n-        content.file = NamedBlobImage(file2, u"img2.png", u"image/png")\n-        content.title = u"contentOK"\n-        content.subject = [u"contentOK"]\n-        content.description = u"contentOK"\n-        content.contributors = [u"contentOK"]\n+        content.file = NamedBlobImage(file2, "img2.png", "image/png")\n+        content.title = "contentOK"\n+        content.subject = ["contentOK"]\n+        content.description = "contentOK"\n+        content.contributors = ["contentOK"]\n         content.language = "contentOK"\n-        content.rights = u"contentOK"\n+        content.rights = "contentOK"\n         portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n         self.assertEqual(obj.file.data, file1)\n@@ -175,19 +173,19 @@ def testFolder(self):\n         self.folder.invokeFactory("Image", id="folder")\n         portal_repository = self.portal_repository\n         content = self.folder.folder\n-        content.title = u"content"\n-        content.subject = [u"content"]\n-        content.description = u"content"\n-        content.contributors = [u"content"]\n+        content.title = "content"\n+        content.subject = ["content"]\n+        content.description = "content"\n+        content.contributors = ["content"]\n         content.language = "content"\n-        content.rights = u"content"\n+        content.rights = "content"\n         portal_repository.applyVersionControl(content, comment="save no 1")\n-        content.title = u"contentOK"\n-        content.subject = [u"contentOK"]\n-        content.description = u"contentOK"\n-        content.contributors = [u"contentOK"]\n+        content.title = "contentOK"\n+        content.subject = ["contentOK"]\n+        content.description = "contentOK"\n+        content.contributors = ["contentOK"]\n         content.language = "contentOK"\n-        content.rights = u"contentOK"\n+        content.rights = "contentOK"\n         portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n         self.metadata_test_one(obj)\ndiff --git a/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py b/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py\nindex a1d0659..a49b913 100644\n--- a/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py\n+++ b/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -56,7 +55,7 @@ def disablePolicyOnTypeHook(self, portal, p_type, out):\n \n class TestCopyModifyMergeRepositoryToolBase(CMFEditionsBaseTestCase):\n     def setUp(self):\n-        super(TestCopyModifyMergeRepositoryToolBase, self).setUp()\n+        super().setUp()\n \n         # add an additional user\n         self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n@@ -314,23 +313,23 @@ def test01_recursiveSave(self):\n         # check if correctly recursing and setting reference data correctly\n         alog_str = portal_archivist.get_log()\n         expected = """\n-prepare fol: hid=%(fol_id)s, refs=(doc1_inside, doc2_inside, doc3_outside)\n-  prepare doc1_inside: hid=%(doc1_id)s\n-  save    doc1_inside: hid=%(doc1_id)s, isreg=False, auto=True\n-  prepare doc2_inside: hid=%(doc2_id)s\n-  save    doc2_inside: hid=%(doc2_id)s, isreg=False, auto=True\n-save    fol: hid=%(fol_id)s, irefs=({hid:%(doc1_id)s, vid:0}, {hid:%(doc2_id)s, vid:0}), orefs=({hid:None, vid:-1}), isreg=False, auto=True\n-\n-prepare fol: hid=%(fol_id)s, refs=(doc1_inside, doc2_inside, doc3_outside)\n-  prepare doc1_inside: hid=%(doc1_id)s\n-  save    doc1_inside: hid=%(doc1_id)s, isreg=True, auto=False\n-  prepare doc2_inside: hid=%(doc2_id)s\n-  save    doc2_inside: hid=%(doc2_id)s, isreg=True, auto=False\n-save    fol: hid=%(fol_id)s, irefs=({hid:%(doc1_id)s, vid:1}, {hid:%(doc2_id)s, vid:1}), orefs=({hid:None, vid:-1}), isreg=True, auto=False""" % {\n-            "fol_id": fol.cmf_uid(),\n-            "doc1_id": fol.doc1_inside.cmf_uid(),\n-            "doc2_id": fol.doc2_inside.cmf_uid(),\n-        }\n+prepare fol: hid={fol_id}, refs=(doc1_inside, doc2_inside, doc3_outside)\n+  prepare doc1_inside: hid={doc1_id}\n+  save    doc1_inside: hid={doc1_id}, isreg=False, auto=True\n+  prepare doc2_inside: hid={doc2_id}\n+  save    doc2_inside: hid={doc2_id}, isreg=False, auto=True\n+save    fol: hid={fol_id}, irefs=({{hid:{doc1_id}, vid:0}}, {{hid:{doc2_id}, vid:0}}), orefs=({{hid:None, vid:-1}}), isreg=False, auto=True\n+\n+prepare fol: hid={fol_id}, refs=(doc1_inside, doc2_inside, doc3_outside)\n+  prepare doc1_inside: hid={doc1_id}\n+  save    doc1_inside: hid={doc1_id}, isreg=True, auto=False\n+  prepare doc2_inside: hid={doc2_id}\n+  save    doc2_inside: hid={doc2_id}, isreg=True, auto=False\n+save    fol: hid={fol_id}, irefs=({{hid:{doc1_id}, vid:1}}, {{hid:{doc2_id}, vid:1}}), orefs=({{hid:None, vid:-1}}), isreg=True, auto=False""".format(\n+            fol_id=fol.cmf_uid(),\n+            doc1_id=fol.doc1_inside.cmf_uid(),\n+            doc2_id=fol.doc2_inside.cmf_uid(),\n+        )\n \n         self.assertEqual(alog_str, expected)\n \n@@ -358,13 +357,13 @@ def test02_recursiveRetrieve(self):\n         # check recursive retrieve\n         alog_str = portal_archivist.get_log()\n \n-        expected = """retrieve fol: hid=%(fol_id)s, selector=0\n-retrieve doc1_inside: hid=%(doc1_id)s, selector=0\n-retrieve doc2_inside: hid=%(doc2_id)s, selector=0""" % {\n-            "fol_id": fol.cmf_uid(),\n-            "doc1_id": fol.doc1_inside.cmf_uid(),\n-            "doc2_id": fol.doc2_inside.cmf_uid(),\n-        }\n+        expected = """retrieve fol: hid={fol_id}, selector=0\n+retrieve doc1_inside: hid={doc1_id}, selector=0\n+retrieve doc2_inside: hid={doc2_id}, selector=0""".format(\n+            fol_id=fol.cmf_uid(),\n+            doc1_id=fol.doc1_inside.cmf_uid(),\n+            doc2_id=fol.doc2_inside.cmf_uid(),\n+        )\n         self.assertEqual(alog_str, expected)\n \n         # check result\n@@ -376,7 +375,7 @@ def test02_recursiveRetrieve(self):\n \n class TestRegressionTests(CMFEditionsBaseTestCase):\n     def setUp(self):\n-        super(TestRegressionTests, self).setUp()\n+        super().setUp()\n         self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n \n         self.portal.invokeFactory("Document", "doc")\ndiff --git a/Products/CMFEditions/tests/test_IntegrationTests.py b/Products/CMFEditions/tests/test_IntegrationTests.py\nindex b9e911f..a0b384b 100644\n--- a/Products/CMFEditions/tests/test_IntegrationTests.py\n+++ b/Products/CMFEditions/tests/test_IntegrationTests.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -40,7 +39,7 @@\n \n class TestIntegration(CMFEditionsBaseTestCase):\n     def setUp(self):\n-        super(TestIntegration, self).setUp()\n+        super().setUp()\n \n         # add an additional user\n         self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n@@ -340,7 +339,7 @@ def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):\n         portal_repo = self.portal.portal_repository\n         doc = self.portal.doc\n         perm = "Access contents information"\n-        member_role = "permission_{0}role_{1}".format(\n+        member_role = "permission_{}role_{}".format(\n             _string_hash(perm), _string_hash("Member")\n         )\n \n@@ -392,9 +391,9 @@ def test13_revertUpdatesCatalog(self):\n         cat = self.portal.portal_catalog\n         doc = self.portal.doc\n \n-        doc.text = RichTextValue(u"Plain text", "text/plain", "text/plain")\n+        doc.text = RichTextValue("Plain text", "text/plain", "text/plain")\n         portal_repo.applyVersionControl(doc)\n-        doc.text = RichTextValue(u"blahblah", "text/plain", "text/plain")\n+        doc.text = RichTextValue("blahblah", "text/plain", "text/plain")\n         portal_repo.save(doc)\n         # Test that catalog has current value\n         results = cat(SearchableText="Plain Text")\ndiff --git a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\nindex 4746864..ef6aa65 100644\n--- a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\n+++ b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2006 Gregoire Weber\n # All Rights Reserved.\n@@ -33,7 +32,7 @@\n \n class TestKeepLastNVersionsTool(CMFEditionsBaseTestCase):\n     def setUp(self):\n-        super(TestKeepLastNVersionsTool, self).setUp()\n+        super().setUp()\n         # add an additional user\n         self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n \ndiff --git a/Products/CMFEditions/tests/test_ModifierRegistryTool.py b/Products/CMFEditions/tests/test_ModifierRegistryTool.py\nindex 6f78faf..11f1d1a 100644\n--- a/Products/CMFEditions/tests/test_ModifierRegistryTool.py\n+++ b/Products/CMFEditions/tests/test_ModifierRegistryTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -100,7 +99,7 @@ def dictToString(dict):\n     keys = [key for key in dict.keys()]\n     keys.sort()\n     for k in keys:\n-        dict_list.append("%s = %s" % (k, dict[k]))\n+        dict_list.append(f"{k} = {dict[k]}")\n     return ", ".join(dict_list)\n \n \n@@ -164,7 +163,7 @@ class LoggingModifier_D(LoggingModifierBase):\n \n class TestModifierRegistryTool(CMFEditionsBaseTestCase):\n     def setUp(self):\n-        super(TestModifierRegistryTool, self).setUp()\n+        super().setUp()\n \n         # add an additional user\n         self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\ndiff --git a/Products/CMFEditions/tests/test_ZVCStorageTool.py b/Products/CMFEditions/tests/test_ZVCStorageTool.py\nindex fec1a1f..1c4c8bb 100644\n--- a/Products/CMFEditions/tests/test_ZVCStorageTool.py\n+++ b/Products/CMFEditions/tests/test_ZVCStorageTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber,\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -47,7 +46,7 @@ class DummyOM(ObjectManager):\n \n class CMFDummy(Dummy):\n     def __init__(self, id, cmfuid, effective=None, expires=None):\n-        super(CMFDummy, self).__init__()\n+        super().__init__()\n         self.id = id\n         self.cmf_uid = cmfuid\n         self.effective = effective if effective is not None else self.modification_date\n@@ -59,7 +58,7 @@ def getPortalTypeName(self):\n \n class TestZVCStorageTool(CMFEditionsBaseTestCase):\n     def setUp(self):\n-        super(TestZVCStorageTool, self).setUp()\n+        super().setUp()\n \n         # add an additional user\n         self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n@@ -497,7 +496,7 @@ def test13_saveWithUnicodeComment(self):\n             1, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n         )\n         portal_storage.save(\n-            1, ObjectData(obj1), metadata=self.buildMetadata(u"saved v1\\xc3\\xa1")\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1\\xc3\\xa1")\n         )\n \n     def test14_getHistoryMetadata(self):\ndiff --git a/Products/CMFEditions/tests/test_doctests.py b/Products/CMFEditions/tests/test_doctests.py\nindex 4281076..203d262 100644\n--- a/Products/CMFEditions/tests/test_doctests.py\n+++ b/Products/CMFEditions/tests/test_doctests.py\n@@ -1,10 +1,9 @@\n-# -*- coding: utf-8 -*-\n import doctest\n import unittest\n \n \n # These two classes are needed in the doctest. Don\'t remove it\n-class DummyFile(object):\n+class DummyFile:\n     """A sized object"""\n \n     def __init__(self, size):\n@@ -14,7 +13,7 @@ def getSize(self):\n         return self.size\n \n \n-class DummyContent(object):\n+class DummyContent:\n     """An object with annotations"""\n \n     def __init__(self, obid):\ndiff --git a/Products/CMFEditions/tests/test_versions_history_form.py b/Products/CMFEditions/tests/test_versions_history_form.py\nindex 01f4125..08f5b06 100644\n--- a/Products/CMFEditions/tests/test_versions_history_form.py\n+++ b/Products/CMFEditions/tests/test_versions_history_form.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -30,13 +29,13 @@\n from zope.publisher.interfaces.browser import IBrowserView\n \n \n-_TEXT_INITIAL = u"Initial text."\n-_TEXT_NEW = u"New text."\n+_TEXT_INITIAL = "Initial text."\n+_TEXT_NEW = "New text."\n \n \n class TestVersionsHistoryForm(CMFEditionsBaseTestCase):\n     def setUp(self):\n-        super(TestVersionsHistoryForm, self).setUp()\n+        super().setUp()\n         self.portal_repository = self.portal.portal_repository\n         self.portal.invokeFactory(\n             "Document",\ndiff --git a/Products/CMFEditions/utilities.py b/Products/CMFEditions/utilities.py\nindex fd4cd2c..56bad8a 100644\n--- a/Products/CMFEditions/utilities.py\n+++ b/Products/CMFEditions/utilities.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -83,7 +82,7 @@ def dereference(obj=None, history_id=None, zodb_hook=None):\n def generateId(parent, prefix="", volatile=False):\n     """Generate an unused id (optionaly a volatile one)."""\n     existingIds = parent.objectIds()\n-    idTemplate = "%s%s_%%s" % (volatile * "__v_", prefix + STUB_OBJECT_PREFIX)\n+    idTemplate = "{}{}_%s".format(volatile * "__v_", prefix + STUB_OBJECT_PREFIX)\n     while 1:\n         id = idTemplate % random.randrange(1000000)\n         if id not in existingIds:\ndiff --git a/Products/__init__.py b/Products/__init__.py\nindex ca12a73..05f0beb 100644\n--- a/Products/__init__.py\n+++ b/Products/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n # See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n try:\n     __import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/setup.py b/setup.py\nindex 01b0157..070d771 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-17T00:24:10+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/36bead5762fd1e54431e7b9161cb3aefb464accb

black

Files changed:
M Products/CMFEditions/StandardModifiers.py
M Products/CMFEditions/testing.py
M Products/CMFEditions/tests/DummyTools.py

b'diff --git a/Products/CMFEditions/StandardModifiers.py b/Products/CMFEditions/StandardModifiers.py\nindex 417f558..78a68f7 100644\n--- a/Products/CMFEditions/StandardModifiers.py\n+++ b/Products/CMFEditions/StandardModifiers.py\n@@ -724,16 +724,13 @@ def getOnCloneModifiers(self, obj):\n             return\n \n         component_bases = dict(\n-            registry={\n-                id(aq_base(base)): aq_base(base) for base in registry.__bases__\n-            },\n+            registry={id(aq_base(base)): aq_base(base) for base in registry.__bases__},\n             utilities={\n                 id(aq_base(base)): aq_base(base)\n                 for base in registry.utilities.__bases__\n             },\n             adapters={\n-                id(aq_base(base)): aq_base(base)\n-                for base in registry.adapters.__bases__\n+                id(aq_base(base)): aq_base(base) for base in registry.adapters.__bases__\n             },\n         )\n \n@@ -972,9 +969,7 @@ def getOnCloneModifiers(self, obj):\n             return\n \n         blob_refs = {\n-            id(v)\n-            for v in obj.__dict__.values()\n-            if isinstance(v, blob_file_classes)\n+            id(v) for v in obj.__dict__.values() if isinstance(v, blob_file_classes)\n         }\n \n         def persistent_id(obj):\n@@ -999,9 +994,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n             return [], [], {}\n \n         blob_fields = (\n-            (k, v)\n-            for k, v in obj.__dict__.items()\n-            if isinstance(v, blob_file_classes)\n+            (k, v) for k, v in obj.__dict__.items() if isinstance(v, blob_file_classes)\n         )\n \n         for k, v in blob_fields:\ndiff --git a/Products/CMFEditions/testing.py b/Products/CMFEditions/testing.py\nindex a723bf2..3bdab1f 100644\n--- a/Products/CMFEditions/testing.py\n+++ b/Products/CMFEditions/testing.py\n@@ -23,8 +23,8 @@ def setUpPloneSite(self, portal):\n         applyProfile(portal, "Products.CMFEditions:CMFEditions")\n         # with named AND dotted behaviors we need to take care of both\n         versioning_behavior = {\n-                "plone.app.versioningbehavior.behaviors.IVersionable",\n-                "plone.versioning",\n+            "plone.app.versioningbehavior.behaviors.IVersionable",\n+            "plone.versioning",\n         }\n         for name in ("Document", "Event", "Link", "News Item"):\n             fti = portal.portal_types[name]\ndiff --git a/Products/CMFEditions/tests/DummyTools.py b/Products/CMFEditions/tests/DummyTools.py\nindex 4fa13ab..4f63cbe 100644\n--- a/Products/CMFEditions/tests/DummyTools.py\n+++ b/Products/CMFEditions/tests/DummyTools.py\n@@ -152,9 +152,7 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n                 )\n             )\n         else:\n-            self.log(\n-                f"{self.alog_indent}prepare {obj.getId()}: hid={history_id}"\n-            )\n+            self.log(f"{self.alog_indent}prepare {obj.getId()}: hid={history_id}")\n         self.alog_indent += "  "\n \n         # prepare object structure\n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-17T00:28:59+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/d63279a0e07bc86faf4c0668ccbfaa4c29c91810

Removed all use of the 'six' package.

Files changed:
M Products/CMFEditions/ArchivistTool.py
M Products/CMFEditions/CopyModifyMergeRepositoryTool.py
M Products/CMFEditions/StandardModifiers.py
M Products/CMFEditions/ZVCStorageTool.py
M Products/CMFEditions/tests/DummyTools.py
M setup.py

b'diff --git a/Products/CMFEditions/ArchivistTool.py b/Products/CMFEditions/ArchivistTool.py\nindex 3baa3c6..b088f64 100644\n--- a/Products/CMFEditions/ArchivistTool.py\n+++ b/Products/CMFEditions/ArchivistTool.py\n@@ -50,9 +50,9 @@\n from Products.CMFEditions.interfaces.IStorage import StorageUnregisteredError\n from Products.CMFEditions.utilities import dereference\n from Products.CMFEditions.utilities import KwAsAttributes\n-from six import BytesIO\n-from six.moves.cPickle import Pickler\n-from six.moves.cPickle import Unpickler\n+from io import BytesIO\n+from pickle import Pickler\n+from pickle import Unpickler\n from zope.interface import alsoProvides\n from zope.interface import implementer\n \ndiff --git a/Products/CMFEditions/CopyModifyMergeRepositoryTool.py b/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\nindex f9aafb0..520d1d7 100644\n--- a/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\n+++ b/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\n@@ -59,7 +59,6 @@\n from zope.lifecycleevent import ObjectModifiedEvent\n \n import logging\n-import six\n import time\n import transaction\n \ndiff --git a/Products/CMFEditions/StandardModifiers.py b/Products/CMFEditions/StandardModifiers.py\nindex 78a68f7..d196164 100644\n--- a/Products/CMFEditions/StandardModifiers.py\n+++ b/Products/CMFEditions/StandardModifiers.py\n@@ -46,7 +46,6 @@\n from zope.interface import implementer\n from zope.interface.interfaces import ComponentLookupError\n \n-import six\n import sys\n \n \ndiff --git a/Products/CMFEditions/ZVCStorageTool.py b/Products/CMFEditions/ZVCStorageTool.py\nindex 6ff51d3..2449489 100644\n--- a/Products/CMFEditions/ZVCStorageTool.py\n+++ b/Products/CMFEditions/ZVCStorageTool.py\n@@ -49,12 +49,12 @@\n from Products.ZopeVersionControl.EventLog import LogEntry\n from Products.ZopeVersionControl.Utility import VersionControlError\n from Products.ZopeVersionControl.ZopeRepository import ZopeRepository\n-from six import BytesIO\n-from six.moves.cPickle import dumps\n-from six.moves.cPickle import HIGHEST_PROTOCOL\n-from six.moves.cPickle import loads\n-from six.moves.cPickle import Pickler\n-from six.moves.cPickle import Unpickler\n+from io import BytesIO\n+from pickle import dumps\n+from pickle import HIGHEST_PROTOCOL\n+from pickle import loads\n+from pickle import Pickler\n+from pickle import Unpickler\n from zope.interface import implementer\n \n import logging\ndiff --git a/Products/CMFEditions/tests/DummyTools.py b/Products/CMFEditions/tests/DummyTools.py\nindex 4f63cbe..66c85d2 100644\n--- a/Products/CMFEditions/tests/DummyTools.py\n+++ b/Products/CMFEditions/tests/DummyTools.py\n@@ -15,9 +15,9 @@\n from Products.CMFEditions.interfaces.IStorage import StorageRetrieveError\n from Products.CMFEditions.interfaces.IStorage import StorageUnregisteredError\n from Products.CMFEditions.utilities import dereference\n-from six import BytesIO\n-from six.moves.cPickle import Pickler\n-from six.moves.cPickle import Unpickler\n+from io import BytesIO\n+from pickle import Pickler\n+from pickle import Unpickler\n from zope.interface import implementer\n \n \ndiff --git a/setup.py b/setup.py\nindex 070d771..acba995 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -47,7 +47,6 @@\n     ),\n     install_requires=[\n         "setuptools",\n-        "six",\n         "zope.copy",\n         "zope.dottedname",\n         "zope.i18nmessageid",\n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-17T00:30:41+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/595028abbb94ef1200a9d2054584269be81676ec

Added news snippet for QA fixes.

Files changed:
A news/80.bugfix

b'diff --git a/news/80.bugfix b/news/80.bugfix\nnew file mode 100644\nindex 0000000..9d11b72\n--- /dev/null\n+++ b/news/80.bugfix\n@@ -0,0 +1,2 @@\n+QA: black, isort, flake8, fix deprecation warnings, remove use of six, upgrade to Python 3.7-only syntax.\n+[maurits]\n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-17T00:31:06+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFEditions/commit/51e2fa76ec1f5654ceb7ac7b0125bdbec9e75038

isort5

Files changed:
M Products/CMFEditions/ArchivistTool.py
M Products/CMFEditions/ZVCStorageTool.py
M Products/CMFEditions/tests/DummyTools.py

b'diff --git a/Products/CMFEditions/ArchivistTool.py b/Products/CMFEditions/ArchivistTool.py\nindex b088f64..eb4029e 100644\n--- a/Products/CMFEditions/ArchivistTool.py\n+++ b/Products/CMFEditions/ArchivistTool.py\n@@ -28,8 +28,11 @@\n from Acquisition import aq_base\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n+from io import BytesIO\n from OFS.SimpleItem import SimpleItem\n from Persistence import Persistent\n+from pickle import Pickler\n+from pickle import Unpickler\n from Products.CMFCore.utils import getToolByName\n from Products.CMFCore.utils import UniqueObject\n from Products.CMFEditions.interfaces import IArchivistTool\n@@ -50,9 +53,6 @@\n from Products.CMFEditions.interfaces.IStorage import StorageUnregisteredError\n from Products.CMFEditions.utilities import dereference\n from Products.CMFEditions.utilities import KwAsAttributes\n-from io import BytesIO\n-from pickle import Pickler\n-from pickle import Unpickler\n from zope.interface import alsoProvides\n from zope.interface import implementer\n \ndiff --git a/Products/CMFEditions/ZVCStorageTool.py b/Products/CMFEditions/ZVCStorageTool.py\nindex 2449489..0909617 100644\n--- a/Products/CMFEditions/ZVCStorageTool.py\n+++ b/Products/CMFEditions/ZVCStorageTool.py\n@@ -27,8 +27,14 @@\n from AccessControl.class_init import InitializeClass\n from BTrees.IOBTree import IOBTree\n from BTrees.OOBTree import OOBTree\n+from io import BytesIO\n from OFS.SimpleItem import SimpleItem\n from Persistence import Persistent\n+from pickle import dumps\n+from pickle import HIGHEST_PROTOCOL\n+from pickle import loads\n+from pickle import Pickler\n+from pickle import Unpickler\n from Products.CMFCore.permissions import ManagePortal\n from Products.CMFCore.utils import getToolByName\n from Products.CMFCore.utils import UniqueObject\n@@ -49,12 +55,6 @@\n from Products.ZopeVersionControl.EventLog import LogEntry\n from Products.ZopeVersionControl.Utility import VersionControlError\n from Products.ZopeVersionControl.ZopeRepository import ZopeRepository\n-from io import BytesIO\n-from pickle import dumps\n-from pickle import HIGHEST_PROTOCOL\n-from pickle import loads\n-from pickle import Pickler\n-from pickle import Unpickler\n from zope.interface import implementer\n \n import logging\ndiff --git a/Products/CMFEditions/tests/DummyTools.py b/Products/CMFEditions/tests/DummyTools.py\nindex 66c85d2..d3ef61d 100644\n--- a/Products/CMFEditions/tests/DummyTools.py\n+++ b/Products/CMFEditions/tests/DummyTools.py\n@@ -1,7 +1,10 @@\n from Acquisition import aq_base\n from copy import deepcopy\n from DateTime import DateTime\n+from io import BytesIO\n from OFS.SimpleItem import SimpleItem\n+from pickle import Pickler\n+from pickle import Unpickler\n from Products.CMFCore.utils import getToolByName\n from Products.CMFEditions.ArchivistTool import ObjectData\n from Products.CMFEditions.ArchivistTool import ObjectManagerStorageAdapter\n@@ -15,9 +18,6 @@\n from Products.CMFEditions.interfaces.IStorage import StorageRetrieveError\n from Products.CMFEditions.interfaces.IStorage import StorageUnregisteredError\n from Products.CMFEditions.utilities import dereference\n-from io import BytesIO\n-from pickle import Pickler\n-from pickle import Unpickler\n from zope.interface import implementer\n \n \n'

Repository: Products.CMFEditions


Branch: refs/heads/master
Date: 2021-12-20T11:50:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFEditions/commit/a592a1efc154d219ec42df5f5903e6d0336fb911

Merge pull request #80 from plone/qa

QA: black, isort, flake8, deprecation warnings

Files changed:
A doc/old-changelog.rst
A news/80.bugfix
M CHANGES.rst
M Products/CMFEditions/ArchivistTool.py
M Products/CMFEditions/CopyModifyMergeRepositoryTool.py
M Products/CMFEditions/KeepLastNVersionsTool.py
M Products/CMFEditions/ModifierRegistryTool.py
M Products/CMFEditions/Modifiers.py
M Products/CMFEditions/Permissions.py
M Products/CMFEditions/ReferenceFactoriesTool.py
M Products/CMFEditions/StandardModifiers.py
M Products/CMFEditions/StorageMigrationSupport.py
M Products/CMFEditions/UniqueIdHandlerTool.py
M Products/CMFEditions/VersionPolicies.py
M Products/CMFEditions/ZVCStorageTool.py
M Products/CMFEditions/__init__.py
M Products/CMFEditions/browser/__init__.py
M Products/CMFEditions/browser/diff.py
M Products/CMFEditions/browser/utils.py
M Products/CMFEditions/browser/views.py
M Products/CMFEditions/exportimport/__init__.py
M Products/CMFEditions/exportimport/repository.py
M Products/CMFEditions/historyidhandlertool.py
M Products/CMFEditions/interfaces/IArchivist.py
M Products/CMFEditions/interfaces/IModifier.py
M Products/CMFEditions/interfaces/IPurgePolicy.py
M Products/CMFEditions/interfaces/IReferenceFactories.py
M Products/CMFEditions/interfaces/IRepository.py
M Products/CMFEditions/interfaces/IStorage.py
M Products/CMFEditions/interfaces/IVersionPolicy.py
M Products/CMFEditions/interfaces/__init__.py
M Products/CMFEditions/interfaces/_tools.py
M Products/CMFEditions/setuphandlers.py
M Products/CMFEditions/subscriber.py
M Products/CMFEditions/testing.py
M Products/CMFEditions/tests/DummyTools.py
M Products/CMFEditions/tests/__init__.py
M Products/CMFEditions/tests/base.py
M Products/CMFEditions/tests/test_ArchivistTool.py
M Products/CMFEditions/tests/test_ContentTypes.py
M Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py
M Products/CMFEditions/tests/test_IntegrationTests.py
M Products/CMFEditions/tests/test_KeepLastNVersionsTool.py
M Products/CMFEditions/tests/test_ModifierRegistryTool.py
M Products/CMFEditions/tests/test_ZVCStorageTool.py
M Products/CMFEditions/tests/test_doctests.py
M Products/CMFEditions/tests/test_versions_history_form.py
M Products/CMFEditions/utilities.py
M Products/__init__.py
M README.rst
M setup.cfg
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex b9897a5..55435ed 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -181,1248 +181,4 @@ Breaking changes:\n   [tschorr]\n \n \n-2.2.23 (2016-12-05)\n--------------------\n-\n-Bug fixes:\n-\n-- In ShadowStorage\'s `isRegistered` and `getHistory` methods,\n-  avoid checking for a history_id of None in the storage\'s BTree.\n-  This fixes compatibility with BTrees 4.x,\n-  which disallows comparing keys to None.\n-  [davisagli]\n-\n-\n-2.2.22 (2016-11-17)\n--------------------\n-\n-Bug fixes:\n-\n-- Fix deprecated import from Globals that is changed in Zope4.\n-  [pbauer]\n-\n-- Do not log using plone restricted python logging script.\n-  [jensens]\n-\n-- Adapt tests to the new indexing operations queueing.\n-  Part of PLIP 1343: https://github.com/plone/Products.CMFPlone/issues/1343\n-  [gforcada]\n-\n-2.2.21 (2016-08-18)\n--------------------\n-\n-Bug fixes:\n-\n-- Use zope.interface decorator.\n-  [gforcada]\n-\n-\n-2.2.20 (2016-04-15)\n--------------------\n-\n-Fixes:\n-\n-- Fixed CloneBlobs modifier to only react on Archetypes.\n-  This fix allows Dexterity Blob-Types (e.g. File, Image) to be versioned.\n-  [iham]\n-\n-\n-2.2.19 (2016-02-14)\n--------------------\n-\n-Fixes:\n-\n-- Fixed sometimes failing test.  [maurits]\n-\n-\n-2.2.18 (2015-11-25)\n--------------------\n-\n-Fixes:\n-\n-- Removed executable bit from various files.  And do a quick release,\n-  as on a test server the previous release was somehow missing a file.\n-  [maurits]\n-\n-\n-2.2.17 (2015-11-25)\n--------------------\n-\n-Fixes:\n-\n-- Made storage statistics test more robust.\n-  See https://github.com/plone/Products.CMFEditions/issues/31\n-  [tschorr]\n-\n-\n-2.2.16 (2015-09-27)\n--------------------\n-\n-- Input sanitation for retrieveSubstitute()\n-  [zupo]\n-\n-\n-2.2.15 (2015-09-15)\n--------------------\n-\n-- use unrestricted search for storage statistics\n-  [tschorr]\n-\n-\n-2.2.14 (2015-08-13)\n--------------------\n-\n-- Do not call ndiff unless there is no html_diff.  Removed strange\n-  unicode space from template.  Related to\n-  https://github.com/plone/Products.CMFPlone/issues/820\n-  [maurits]\n-\n-\n-2.2.13 (2015-04-26)\n--------------------\n-\n-- Drop use of python:exists() in templates.\n-  [pbauer]\n-\n-- Replace deprecated JavaScript functions with their jQuery equivalents.\n-  [thet]\n-\n-\n-2.2.12 (2015-03-13)\n--------------------\n-\n-- Remove dependency on old Archetypes tests\n-  [tomgross]\n-\n-- Ported tests to plone.app.testing\n-  [tomgross]\n-\n-- Removed old FAQ testing code. Should go in a seperate product, if needed.\n-  [tomgross]\n-\n-- Frosted cleanups\n-  [tomgross]\n-\n-2.2.11 (2014-10-23)\n--------------------\n-\n-- Depend on ZODB3>=3.9.0 for blob support.\n-  [tomgross]\n-\n-- Fix AT tests to work with plone.app.blob plone.app.blob >=1.5.11\n-  [jensens]\n-\n-\n-2.2.10 (2014-09-07)\n--------------------\n-\n-- Fix #16: Allow developers to define a ``@@version-view`` to customize how a version of an item is\n-  displayed in ``versions_history_form.pt``.\n-  [rafaelbco]\n-\n-- Fix #14: Duplicate functionality in ``@@history`` and ``version_diff.pt``.\n-  Now ``version_diff.pt`` is deprecated.\n-  [rafaelbco]\n-\n-- Fix bug: ``CopyModifyMergeRepositoryTool.manage_setTypePolicies`` method\n-  modifies sequence while iterating over it.\n-  [rafaelbco]\n-\n-- Purging old versions did not properly remove all references\n-  to the blob fields, resulting in old blobs to stay there forever.\n-  [do3cc]\n-\n-2.2.9 (2013-12-07)\n-------------------\n-\n-- Use search_icon.png instead of search_icon.gif in version_image_view.pt.\n-  The page crashed because search_icon.gif couldn\'t be found.\n-  [vincentfretin]\n-\n-- Do not depend on the ``jq`` variable in the history view.\n-  [maurits]\n-\n-2.2.8 (2013-03-05)\n-------------------\n-\n-- Fix modifier check that made AT assumptions about Dexterity\n-  content.\n-  [rpatterson]\n-\n-- Remove hard dependency on Archetypes.\n-  [davisagli]\n-\n-2.2.7 (2013-01-01)\n-------------------\n-\n-- put back the history legend for compare/diff versions, fixes #9371\n-  [maartenkling]\n-\n-- Site administrators do revisioning\n-\n-2.2.6 (2012-10-16)\n-------------------\n-\n-- Update ``IPossibleSite`` import to ``zope.component``.\n-  [elro]\n-\n-2.2.5 (2012-08-11)\n-------------------\n-\n-- Fixed version file preview for empty files.\n-  [thomasdesvenain]\n-\n-- Fixed versions history form:\n-  title and description aren\'t displayed two times.\n-  [thomasdesvenain]\n-\n-- Fixed version file preview:\n-  some displayed values of a previous version were values of current version.\n-  [thomasdesvenain]\n-\n-- ArchivistTool.py, DummyTools.py, IArchivist.py, ModifierRegistryTool.py:\n-  Don\'t use list as default parameter value.\n-  [kleist]\n-\n-\n-2.2.4 (2012-06-27)\n-------------------\n-\n-- Add upgrade step to install the component registry bases modifier.\n-  [rossp]\n-\n-- Skip blob files from plone.namedfile even when they no longer\n-  extend the classes from z3c.blobfile.\n-  [davisagli]\n-\n-- Declare missing dependency on zope.copy.\n-  [hannosch]\n-\n-\n-2.2.3 (2012-01-26)\n-------------------\n-\n-- Changed the get_macros python skin script into a browser view.  This\n-  avoids an Unauthorized exception when viewing revisions when using\n-  five.pt (Chameleon).\n-  [maurits]\n-\n-- Implement a special base modifier that allows retention of specific\n-  annotation elements from the working copy.  Use this in the OM\n-  modifiers to ensure we don\'t stomp annotations for folders on retrieval.\n-  [alecm]\n-\n-- If an object has a component registry (AKA site manager), make sure\n-  the bases of that registry are not recursively copied when saving\n-  versions.\n-  [rossp]\n-\n-2.2.2 (2011-10-17)\n-------------------\n-\n-- Don\'t string convert blobs.  Fixes MemoryErrors or excessive memory\n-  consumption with large blobs.\n-  [rossp]\n-\n-- Protect against anonymous access to KwAsAttributes.\n-  [mj]\n-\n-2.2.1 (2011-09-19)\n-------------------\n-\n-- Merged changes from 2.1.5.\n-  [lentinj]\n-\n-2.2 (2011-08-23)\n-----------------\n-\n-- Make Zope 2 permissions available as Zope 3-style permissions.\n-  [rafaelbco]\n-\n-- Changed ``@@history`` to be protected by ``CMFEditions.AccessPreviousVersions`` instead of\n-  ``cmf.ModifyPortalContent``.\n-  [rafaelbco]\n-\n-- Only show the "Revert to this version" button if the user has the ``Revert to previous versions``\n-  permission in ``versions_history_form``.\n-  [rafaelbco]\n-\n-2.1.5 (2011-09-19)\n-------------------\n-\n-- Translate the commit message, so version id is substituted.\n-  [lentinj]\n-\n-- Only save an initial version before edit when content is not yet versioned,\n-  rather than every time there are unsaved changes. Otherwise there is an\n-  "Initial version" generated for every edit after publish/retract, as these\n-  change the publishing date without a new version being saved. Possibly a\n-  version should be saved on publish, but not sure the extra versioning noise\n-  is useful.\n-  [lentinj]\n-\n-2.1.4 (2011-08-31)\n-------------------\n-\n-- Remove references to blobs when cloning blob fields. They are handled as\n-  referenced attributes anyway. This eliminates the creation of an additional\n-  empty blob when cloning blob fields.\n-  [buchi]\n-\n-- No longer store references in the ZVC wrapper. They are stored in the shadow\n-  history and retrieved from there. This eliminates the creation of an\n-  additional empty blob when cloning blob fields.\n-  [buchi]\n-\n-- Allow to translate the string "current" in the diff view (``@@history``) and in the\n-  ``version_diff`` template.\n-  [rafaelbco]\n-\n-2.1.3 (2011-04-03)\n-------------------\n-\n-- Fixed: Unauthorized error on versions history form for non managers.\n-  [thomasdesvenain]\n-\n-2.1.2 (2011-03-25)\n-------------------\n-\n-- remove UniqueIdHandlerTool, it was not used anymore;\n-  nobody (including vds and hannosch) seems to remember what it was for.\n-  [gotcha]\n-\n-- fix portal_historyidhandler class to avoid issue where GenericSetup toolset\n-  import step tried to change the class default id\n-  [gotcha]\n-\n-- Skip z3c.blobfile File (notable subclasess plone.namedfile BlobFile and\n-  BlobImage) as blobfile versioning is not there yet.\n-  [elro]\n-\n-2.1.1 - 2011-02-25\n-------------------\n-\n-- Fix bug when loading GenericSetup profile with ``<policymap purge="true">``.\n-  [elro]\n-\n-2.1.0 - 2011-02-25\n-------------------\n-\n-- Generic Setup export/import support.\n-  [elro]\n-\n-2.0.5 - 2011-02-25\n-------------------\n-\n-- Workaround some potential issues with event handlers and\n-  transaction.savepoint which can cause exceptions when, for example,\n-  zope.sendmail is used to send mail in the same transaction as saving\n-  an edition.\n-  [rossp]\n-\n-2.0.4 - 2011-01-03\n-------------------\n-\n-- Depend on ``Products.CMFPlone`` instead of ``Plone``.\n-  [elro]\n-\n-- Do not provide "Compare to ... revision" link in versions history actions\n-  if content type has no diffable field.\n-  [thomasdesvenain]\n-\n-- Add Site Administrator role to various permissions, for forward compatibility\n-  with Plone 4.1.\n-  [davisagli]\n-\n-2.0.3 - 2010-11-06\n-------------------\n-\n-- Internationalized default version comments (\'Initial revision\', etc.).\n-  [thomasdesvenain]\n-\n-- Fixed: version comment was not considered when saving a content with\n-  automatic version policy. Closes http://dev.plone.org/plone/ticket/8535.\n-  [thomasdesvenain]\n-\n-- Fixed multiple chameleon incompatibilities.\n-  [swampmonkey]\n-\n-2.0.2 - 2010-09-09\n-------------------\n-\n-- Forward port of a i18n fix from branches/1.2. It\'s used to create a\n-  changeset, the message doesn\'t seem to appear on the history view though.\n-  [vincentfretin]\n-\n-- Added missing i18n markup to variables in ``update_version_before_edit.cpy``.\n-  [WouterVH]\n-\n-2.0.1 - 2010-08-08\n-------------------\n-\n-- Changed "version" to "revision" in portal messages.\n-  [kleist]\n-\n-2.0 - 2010-07-18\n-----------------\n-\n-- Changed the text in the `@@history` page to use the term revision instead of\n-  version. This fixes http://dev.plone.org/plone/ticket/10740.\n-  [hannosch]\n-\n-- Added dependency on plone.app.blob, to pull in the needed bits for\n-  handling blobs in the modifiers.\n-  [davidblewett]\n-\n-- Added event listeners for Archetypes\' ObjectInitializedEvent and\n-  ObjectEditedEvent events (to go along with the existing WebDAV ones).\n-  [davidblewett]\n-\n-- Changed Plone 3 backward compatible handling to also work with Chameleon.\n-  [do3cc]\n-\n-2.0b9 - 2010-06-13\n-------------------\n-\n-- Avoid dependency on zope.app.testing.\n-  [hannosch]\n-\n-2.0b8 - 2010-05-20\n-------------------\n-\n-- Added notification of changes on revert, via zope.lifecycle\'s\n-  ObjectModifiedEvent and Archetypes\' ObjectEditedEvent.\n-  [davidblewett]\n-\n-- Fixed revertversion.py so that it didn\'t tack on a lone / to the redirect\n-  URL.\n-  [davidblewett]\n-\n-- Fixed CloneBlob & company, so that they check that the field provides an\n-  interface instead of using isinstance.\n-  [davidblewett]\n-\n-- Fixed CloneBlob to not trample its local variables, allowing for multiple\n-  blob fields on a type.\n-  [davidblewett]\n-\n-- Updated i18n methods that used mappings.\n-  [davidblewett]\n-\n-2.0b7 - 2010-05-08\n-------------------\n-\n-- Fix BLOB history corruption\n-  http://dev.plone.org/plone/ticket/10503\n-  [do3cc]\n-\n-2.0b6 - 2010-04-20\n-------------------\n-\n-- Widen html diff display to work better with new layout.\n-  [alecm]\n-\n-- Fix issue with versioning of large folders.\n-  http://dev.plone.org/plone/ticket/10457\n-  [alecm]\n-\n-2.0b5 - 2010-04-12\n-------------------\n-\n-- Re-add title and description when viewing old versions in Plone 4.\n-  [davisagli]\n-\n-2.0b4 - 2010-03-04\n-------------------\n-\n-- Reverse order of diff listing on history view. Fixes\n-  http://dev.plone.org/plone/ticket/10119.\n-  [alecm]\n-\n-- Fix version display when history is non-existent. Fixes\n-  http://dev.plone.org/plone/ticket/9674.\n-  [alecm]\n-\n-2.0b3 - 2010-02-17\n-------------------\n-\n-- Updated templates to follow recent markup conventions.\n-  References http://dev.plone.org/old/plone/ticket/9981.\n-  [spliter]\n-\n-- Be more defensive in our importVarious step, to avoid issues while upgrading.\n-  [hannosch]\n-\n-- Workaround for http//dev.plone.org/plone/ticket/10120, "version_history_form"\n-  now renders "Preview is not available." instead of causing a traceback.\n-  [kleist]\n-\n-2.0b2 - 2009-12-27\n-------------------\n-\n-- Fixed test dependencies and removed unused test helper code.\n-  [hannosch]\n-\n-2.0b1 - 2009-12-02\n-------------------\n-\n-- Fix dependence on global_defines in diff.pt.\n-  https://dev.plone.org/plone/ticket/9804\n-  [alecm]\n-\n-2.0a1 - 2009-11-14\n-------------------\n-\n-- Fix ordering issues with versioned BTree folders.\n-  [alecm]\n-\n-- Make the Archetypes dependency a soft one.\n-  [alecm]\n-\n-- Only make a copy of a BLOB if it\'s changed since the last save.\n-  Otherwise, just reference the BLOB from the prior revision.\n-  [alecm]\n-\n-- Made the ZVCStorage store references directly in the shadow instead\n-  of simply passing them to ZVC.  This way real references can be used\n-  in the storage instead of copies, so that BLOB revisions can work.\n-  [alecm]\n-\n-- Add modifiers to handle AT blob fields from plone.app.blob.  One\n-  handler skips the blobs and the other copies them.\n-  [alecm]\n-\n-- Enable both inside and outside children modifiers by default for\n-  folder objects.  Using the INonStructuralFolder interface to determine\n-  which to use.\n-  [alecm]\n-\n-- Fixes for reference handling in plone.folder and other BTree based folder implementations.\n-  [alecm]\n-\n-- Added modifier that skips cloning of __parent__ pointers.\n-  [alecm]\n-\n-- Switched document_byline macro to plone.belowcontenttitle content provider.\n-  [hannosch]\n-\n-- Acquire plone_utils from context rather than assuming the putils global in\n-  templates.\n-  [erikrose]\n-\n-- Fixed tests which depended on specific uids for portal content.\n-  Added cmf_uid catalog index in install profile.\n-  [alecm]\n-\n-- Fixed missing i18n markup in versions_history_form.\n-  [hannosch]\n-\n-- No longer rely on base_properties.\n-  [hannosch]\n-\n-- Made some calls to portal_repository more defensive.\n-  [hannosch]\n-\n-- Added the z3c.autoinclude entry point so this package is automatically loaded\n-  on Plone 3.3 and above.\n-  [hannosch]\n-\n-- Use new import location for the package_home function.\n-  [hannosch]\n-\n-- Added the required profile bits for installing CMFUid.\n-  [hannosch]\n-\n-- Define dependency on Products.ZopeVersionControl.\n-  [hannosch]\n-\n-- Define dependency on CMFDiffTool (via template using portal_diff) and\n-  avoiding a test dependency on CMFDefault.\n-  [hannosch]\n-\n-- Define here_url in all templates and made get_macros not fail when\n-  encountering a browser view based template.\n-  [hannosch]\n-\n-- Cleaned up package metadata and code to remove the dependency on Plone.\n-  [hannosch]\n-\n-- Declare package dependencies and fixed deprecation warnings for use\n-  of Globals.\n-  [hannosch]\n-\n-- Catch WebDAVObjectInitializedEvent/WebDAVObjectEditedEvent and\n-  save versions as appropriate. This is part of the fix for\n-  http://dev.plone.org/plone/ticket/7338\n-  [sidnei]\n-\n-- Fixed the name of the file : is has to be the FileName not the Id [tbenita]\n-\n-- Purged old Zope 2 Interface interfaces for Zope 2.12 compatibility.\n-  [elro]\n-\n-- Fixed a bug in the file_download_version that prevented successful download\n-  of anterior version of files if the filename contained spaces. Anyway, the\n-  filename param of Content-Disposition header SHOULD NEVER come without\n-  double-quotes.\n-  [drjnut]\n-\n-- Register GenericSetup steps via ZCML.\n-  [wichert]\n-\n-- Use the new archetypes.edit.afterfieldsets viewlet manager to add our\n-  field to the AT edit template. The customized edit_macros is now no longer\n-  needed.\n-  [wichert]\n-\n-1.2.7 - Unreleased\n-------------------\n-\n-- Fix error in history storage selector calculation. Closes\n-  http://dev.plone.org/plone/ticket/8967.\n-  [alecm]\n-\n-- Make "Revert to this version" on the versions_history_form an input\n-  with HTTP POST, instead of a simple GET link.\n-  Fixes http://dev.plone.org/plone/ticket/6932\n-  [maurits]\n-\n-1.2.6 - December 2, 2009\n-------------------------\n-\n-- Check history permissions in the context of the versioned object not\n-  the repository tool.  See http://plone.org/products/cmfeditions/issues/55\n-  [alecm]\n-\n-- Fixed the html and javascript on the difference view so it works on\n-  more browsers.\n-  [vpretre, maurits]\n-\n-\n-1.2.5 - November 5, 2009\n-------------------------\n-\n-- Show ndiff (natural diff) when neither inline diff nor html diff are\n-  available.\n-  [maurits]\n-\n-\n-1.2.4 - July 4, 2009\n---------------------\n-\n-- Fixed missing i18n markup in versions_history_form.\n-  [hannosch]\n-\n-\n-1.2.3 - July 4, 2009\n---------------------\n-\n-- Fix form action in @@history view.\n-  [vincentfretin]\n-\n-\n-1.2.2 - June 11, 2009\n----------------------\n-\n-- Fix XHTML markup for diff view.\n-  See ticket http://dev.plone.org/plone/ticket/9227\n-  [alecm]\n-\n-1.2.1 - June 8, 2009\n---------------------\n-\n-- Add getHistoryMetadata method to allow efficient history display\n-  without full object retrieval.  Based on patches by Darryl Dixon on\n-  CMFEditions zvc_enfold_fixfailures branch r59908:60078.\n-  [alecm]\n-\n-\n-1.2 - May 16, 2009\n-------------------\n-\n-- Add missing PACKAGE_HOME in the init file according to tests\n-  [encolpe]\n-\n-- Add the encoding declaration (utf-8) in all python files\n-  [encolpe]\n-\n-- Internationalization of 7 strings in diff.pt (history view).\n-  [vincentfretin]\n-\n-- Fixed label_history_version msgid dynamic content in diff.pt (added i18n:name="version")\n-  [vincentfretin]\n-\n-\n-1.2b1 (March 7, 2009)\n----------------------\n-\n-- Register CMF skin layers via ZCML.\n-  [wichert]\n-\n-- Remove history action. Plone 3.3 has alternative implementations in the\n-  form of the content history viewlet so this should not be installed by\n-  default.\n-  [wichert]\n-\n-- Move import step registration to ZCML.\n-  [wichert]\n-\n-- Use the new archetypes.edit.afterfieldsets viewlet manager to add our\n-  field to the AT edit template. The customized edit_macros is now no longer\n-  needed.\n-  [wichert]\n-\n-- Some CMFEditions .py files use wrong MessageFactory (#8715)\n-  [encolpe]\n-\n-- Set some msgids to cmfeditions i18n domain in version_file_view.\n-  Renamed msgid label_existing_keywords by label_existing_categories in\n-  version_metadata_view.\n-  [vincentfretin]\n-\n-\n-1.1.8 (October 6, 2008)\n------------------------\n-\n-- Switch to egg-based distribution.\n-  [hannosch]\n-\n-- Fix on FileDownloadVersion : files retrieved didn\'t get their version name\n-  [tbenita]\n-\n-- Fix on FileDownloadVersion : files retrieved got corrupted at retrieval\n-  [drjnut]\n-\n-- Merge AT changes into replacement of \'edit_macros.pt\'.\n-  See ticket http://dev.plone.org/plone/ticket/7999.\n-  [rsantos]\n-\n-\n-1.1.7 (June 2, 2008)\n---------------------\n-\n-- Fix for issues with unicode version save comments.\n-  http://dev.plone.org/plone/ticket/7400\n-  [alecm]\n-\n-\n-1.1.6 (March 26, 2008)\n-----------------------\n-\n-- Some i18n fixes to version_diff.pt. This closes\n-  http://dev.plone.org/plone/ticket/7862.\n-  [hannosch]\n-\n-- Merge AT changes into our copy of \'edit_macros.pt\'.\n-  See: http://dev.plone.org/plone/ticket/6936\n-\n-\n-1.1.5 (March 8, 2008)\n----------------------\n-\n-- Fix bug in wrapper assignment for some modifiers.\n-  [encolpe, alecm]\n-\n-- Added metadata.xml file to the profile.\n-  [hannosch]\n-\n-\n-1.1.4 (December 6, 2007)\n-------------------------\n-\n-- Add modifiers to avoid pickling extremely large files.  The\n-  AbortVersioningOfLargeFilesAndImages modifier is enabled by default\n-  for Files and Images. It will skip saving versions of objects when\n-  they contain a large file (\'file\' or \'image\' field in Attribute or\n-  AnnotationStorage).  The SkipVersioningOfLargeFilesAndImages will\n-  simply not version the large file, but will version all other data.\n-  On retrieval it will put the file from the working copy in place.\n-  This is disabled by default, but can be enabled easily.\n-  Workaround for: http://dev.plone.org/plone/ticket/7223\n-  [alecm]\n-\n-\n-1.1.3 (December 2, 2007)\n-------------------------\n-\n-- Make sure that we attempt to handle Inside Refs which have no\n-  portal_type, as well as retrieving revisions that once used the\n-  InsideRefsModifier but now use the OutsideRefsModifier.\n-  Related to: http://dev.plone.org/plone/ticket/7295\n-  [alecm]\n-\n-- Fix issue on diff form where empty entries were being shown for\n-  unchanged files.  Related to http://dev.plone.org/plone/ticket/7253\n-  [alecm]\n-\n-- Fix issues with purge policy as reported in\n-  http://dev.plone.org/plone/ticket/7300\n-  [alecm]\n-\n-- Handle ArchivistUnregisteredErrors during save.  This occurs when an\n-  object has been imported, or when the version information has been\n-  destroyed.  Fixes http://dev.plone.org/plone/ticket/7334.\n-  [alecm]\n-\n-- Reflect changes in base_edit.cpt asnd edit_macros.pt in r8683 of\n-  Archetypes: Skip the \'metadata\' schema in base_edit, like we used to\n-  do it pre-1.5.  Also, do not render fieldset and legend elements\n-  when we\'re only displaying one fieldset, i.e. the \'default\' one.\n-  [nouri]\n-\n-\n-1.1.2 (October 5, 2007)\n------------------------\n-\n-- Added bits of missing i18n markup to versions_history_form.pt. This closes\n-  http://dev.plone.org/plone/ticket/7065.\n-  [hannosch, naro]\n-\n-- Added CMFEditionsMessageFactory and used it to i18n-ize a statusmessages in\n-  revertversion.py. This closes http://dev.plone.org/plone/ticket/7066.\n-  [hannosch, naro]\n-\n-\n-1.1.1 (September 10, 2007)\n---------------------------\n-\n-- Expose the extra_top, widgets and extra_bottom METAL hooks in edit_macros.\n-  [wichert]\n-\n-\n-1.1-final (August 16, 2007)\n----------------------------\n-\n-- Prevent future off by one errors in the ui by just starting our count from 0.\n-  [alecm]\n-\n-- Fix dumb acquisition issue in the default policy scripts.\n-  [alecm]\n-\n-- Removed overly aggressive logging from update_version_before_edit.cpy.\n-  [hannosch]\n-\n-\n-1.1-rc1 (July 8, 2007)\n-----------------------\n-\n-- Make text more consistent (use revision instead of version throughout the ui)\n-\n-- Add checks in versioning policy scripts to ensure we don\'t get duplicate\n-  revisions.\n-\n-- Add controller overrides so that the correct actions happen on\n-  cancel and reference upload.\n-\n-- Add an event listener that removes the `version_id` attribute from\n-  copies.\n-\n-- Removed i18n folder. Translations are shipped in PloneTranslations. [hannosch]\n-\n-- Minor template corrections. [hannosch]\n-\n-\n-1.1-beta4 (April 30, 2007)\n---------------------------\n-\n-- Updated permission mapping to account for new local roles (Editor/Contributor)\n-\n-\n-1.1-beta3 (April 29, 2007)\n---------------------------\n-\n-- No longer register tools as utilities, since it broke the tests among\n-  other things.\n-\n-\n-1.1-beta2 (March 26, 2007)\n---------------------------\n-\n-- Register tools as utilities\n-\n-\n-1.1-beta1 (March 5, 2007)\n--------------------------\n-\n-- Make the AT autoversion policy save a version before the save for more\n-   intuitive behavior.\n-\n-- Fixed numerous ui glitches on the versions history form and started using\n-   statusmessages.\n-\n-- Do not install the versioning control panel anymore. You can enable versioning\n-  for a content type on the new types control panel now.\n-\n-ToDo\n-\n-- Finish exportimport handlers for portal_repository and portal_modifier thus\n-  making setuphandlers importVarious unnecessary again.\n-\n-- Add back special portal_historyidhandler / portal_uidhandler handling. If a\n-  portal_uidhandler tool is found during install, it should be renamed to\n-  portal_historyidhandler. The missing tools should be created as normal then.\n-\n-\n-1.1-alpha2 (February 08, 2007)\n-------------------------------\n-\n-- Removed specialized document byline.\n-\n-- Switch to Plone control panel category\n-\n-\n-1.1-alpha1 (November 22, 2006)\n-------------------------------\n-\n-Internal Changes\n-\n-- Two minor updates for CMF 2.1 compatibility. [hannosch]\n-\n-- Use a GenericSetup Extension profile for installation instead of an external\n-  method. [hannosch]\n-\n-- Cleaned up tests. As these are based on PloneTestCase and Plone 3.0 we don\'t\n-  have to set up anything special anymore. [hannosch, alecm]\n-\n-- Removed ActionProviderBase as a base class from all tools. In CMF 2.1 actions\n-  are usually only stored on the actions tool. [hannosch]\n-\n-- Updated dependency information for Plone 3.0 inclusion. [hannosch]\n-\n-\n-1.0 (SVN)\n----------\n-\n-Bugs fixed\n-\n-- Fixed OMInsideChildrensModifier InitializeClass. [encolpe]\n-\n-Internal Changes\n-\n-- Replaced usage of zLOG with Python\'s logging framework. [hannosch]\n-\n-- Removed lots of unused import statements, found by pyflakes. [hannosch]\n-\n-- Removed BBB code for old transaction handling. [hannosch]\n-\n-- Removed some BBB code for ZClasses and CMF 1.4. [hannosch]\n-\n-CMFEditions 1.0rc1 (unreleased)\n--------------------------------\n-\n-ToDo\n-\n-- migration from CMFEditions 1.0alpha3 doesn\'t work correctly\n-- some translations are not yet updated: contact translators (for changes see\n-  below. Affected translations: fr, da, pl)\n-- Fix outstanding failing tests\n-- Some complex integration test with deleted version. (purge support)\n-- allow adding test hierarchy only if in debug mode\n-- allow migration in debug mode only\n-- fix issue #28\n-- fix issue #25\n-- fix issue #19\n-- fix issue #17\n-- fix issue #22\n-\n-1.0beta1 (2006-06-24)\n----------------------\n-\n-Bugs fixed\n-\n-- Fixed previewing (retrieving) files and images. [gregweb]\n-\n-- Security Policy was for ``manage_setPolicies`` but the method name\n-  was ``manage_setTypePolicies``. Corrected. [gregweb]\n-\n-- The storage now stores ZVC\'s ``__vc_info__`` for every version\n-  avoiding wrong information is attached to a working copy when\n-  previewing a version. Fix for ToDo.txt item #48. [gregweb]\n-\n-- Replaced all occurences of ``rollback`` with ``revert``. Brought into\n-  sync internal names with UI. Rollback may suggest a transaction\n-  rollback which is something different. Including i18n label\n-  ``label_rollback`` which is now ``label_revert``. Added backwards\n-  compatibility code for configuration. Translations not updated.\n-  [gregweb]\n-\n-- Minor refactorings of the version history view. Notably replaced\n-  ``(show below)`` by ``preview`` without jumping to the preview target\n-  on the page by default. Instead the link name of the previewed version\n-  changes to ``jump down``. [gregweb]\n-\n-- The storage is now more immune against non int selectors. [gregweb]\n-\n-\n-Features Added\n-\n-- The approximate size of a version is now recorded also at save time\n-  (and calculated at storage migartion).\n-  [gregweb]\n-\n-- Added size information to storage statistics ZMI view [gregweb]\n-\n-- Added German translations [gregweb]\n-\n-- Added Polish translations provided by Piotr Furman [Piotr Furman, gregweb]\n-\n-- ``RetainWorkflowStateAndHistory`` now adds the ``review_state`` to the\n-  ``sys_metadata`` at save time because at retreive time the workflow tool\n-  picks the working copies state. I didn\'t find any other way to do it\n-  without digging into workflows internals (which would have been a bad\n-  idea anyway). Had to extend the ``IModifier.ISaveRetrieveModifier``\n-  interface to allow a modifier enhance ``sys_metadata`` at save time.\n-  [gregweb]\n-\n-- Added purge support [gregweb]:\n-\n-  - Enhanced storage API with a ``purge`` method that inevitabely\n-    removes a version from the history. See added ``IPurgeSupport``\n-    and ``IPurgePolicy`` interfaces.\n-  - Purging raises an exception if no purge policy is installed. This\n-    will avoid a lot of future tracker items caused by people having\n-    removed the purge policy but nevertheless providing purge support\n-    to users. The reason is that the archivist and repo layer can\'t\n-    handle yet the empty placeholder object beeing returned by the\n-    storage for the purged version. This rule may be relaxed in future\n-    versions if the archivist and repo layer support handling of those\n-    empty placeholder objects.\n-  - The UI doesn\'t expose manual purge functionality. Through the ZMI a\n-    number n may be configured representing the maximum number of\n-    version per content item that have to be preserved. Older ones are\n-    automatically purged from the storage at save time.\n-  - There is a new purge permission that may be used to restrict purging\n-    to special roles if necessary (applicable to manual purging only).\n-  - On the repo layer (``portal_repository``) retrieving an object or\n-    iterating over the history always returns a valid (unpurged)\n-    version. The returned object may be a substitute. Two numbering\n-    schematas exist. Numbering counting purged versions and not\n-    counting purged versions (passing True or False to ``countPurged``).\n-    The default numbering schema is ``countPurged=True``. The UI\n-    history onyl shows unpurged versions (``countPurged=False``).\n-  - If the storage is asked to retreive a removed version it may be\n-    instructed to return a substitute for the removed version. The\n-    substitution policy itself is implemented in the new purge policy\n-    tool. This strategy allows to keep most purge implementation\n-    details out of the upper layers (archivist, modifiers, repository).\n-  - The new purge policy tool may be instructed to only keep n versions\n-    of a content item. Thus at save time the oldest version is purged\n-    if the save operation would result in more than n version reside in\n-    the storage.\n-  - The new purge policy tool substitutes a removed version with the\n-    next older version. If no other version is available the next\n-    newer is used as substitute. If none is available ... well this\n-    isn\'t yet tested :-)\n-  - The archivist and storage may be asked to also retreive the empty\n-    placeholder of a purged version. This functionality is yet exposed\n-    to the repo layer. This may change in a future release.\n-  - Added ``isValid`` method on the vdata object that allows to ask if\n-    the retrieved object it is valid or not (empty placeholder object\n-    or a real version).\n-\n-- At save time a version aware reference to the parent node is saved\n-  also. Without it would be very ineffective or even impossible to\n-  find out the parents which potentially would prevent adding usefull\n-  features like retrieving the a whole site from one object in the\n-  tree. [gregweb]\n-\n-- The histories default order has changed: It now returns the newest\n-  version as first item and the oldest as last item. The old behaviour\n-  is still available by passing ``oldestFirst=True``. [gregweb]\n-\n-- Inserted the ``oldestFirst`` parameter before the already existing\n-  ``preserve`` parameter. This will cause changes of 3rd party products\n-  that are using ``preserve`` (None know at the moment, it\'s better to\n-  change now than later). [gregweb]\n-\n-- Added two new i18n labels: ``label_preview_version_below``,\n-  ``label_preview_version`` (no translations yet) [gregweb]\n-\n-- Renamed i18n label: ``label_show_below`` to ``label_preview_version_link``\n-  (updated labels in po-files but not the translations) [gregweb]\n-\n-\n-Internal Changes\n-\n-- Now save all metadata also in shadow storage. But currently on retrieve\n-  the metadata is still feteched from the ZVC storage. [gregweb]\n-\n-- Added migration code for 1.0alpha3 --> 1.0beta1 storage migrations\n-  [gregweb]\n-\n-- Adding purge support caused heavy refactoring the version storage.\n-  ZVC is still used to store the contents history but now additional\n-  data is stored in a parallel shadow storage. The layout of the data\n-  in the ZVC didn\'t change, only ZVC and purge related metadata has\n-  been added to the parallel shadow storage. [gregweb]\n-\n-- Garbage collected a lot of code that was commented out, outdated\n-  triple-X\'s and items in ``ToDo.txt``. [gregweb]\n-\n-- The storage tests now tests ZVCSTorageTool only once and additionally\n-  tests the dummy memory storage. This was the intended behaviour but\n-  a bug prevented running the tests with the dummy storage and instead\n-  run the tests with ZVCStorageToll twice. [gregweb]\n-\n-\n-1.0alpha4 (2006-06-24)\n-----------------------\n-\n-Bugs fixed\n-\n-- fixed bug with AT references causing ref catalog having been inconsistent\n-  [sunew]\n-\n-\n-Features added\n-\n-- Comment is now taken from request if any. [sunew]\n-\n-- Added storage statistics ZMI view. [gregweb]\n-\n-- Added functionality to create a test hierarchy. [gregweb]\n-\n-\n-1.0alpha3 (2006-06-03)\n-----------------------\n-\n-Bugs fixed\n-\n-- Fixed tracker issue #15 [alecm, gregweb]\n-\n-- When previewing a version the expandable history link is removed as this\n-  doesn\'t make sense at all and caused double fetching of history items.\n-  [gregweb]\n-\n-- Use the default view of the retrieved object, as it may be different from\n-  that of the current object. [alecm]\n-\n-- The expandable version link is only shown for users having the permission\n-  to view the history. [rafrombrc]\n-\n-- Added RetainATRefs modifier [vds]\n-\n-- Fixed broken ``isUpToDate`` [gregweb]\n-\n-- ``version_id`` wasn\'t correctly set at the working copy at save time.\n-  Because of this it may happen that the wrong version info was saved\n-  with the version aware reference. The version_id is now set at the end\n-  of the save operation. [alecm, gregweb]\n-\n-- Handle usecase where an inside reference is moved outside its container.\n-  Still need to handle case where it has been replaced by another object\n-  with the same id.  [alecm]\n-\n-- Changed API for Archivist methods and the dereference utility method so\n-  that they now accept an optional history_id, rather than implicitly\n-  allowing the \'obj\' parameter to be a history_id. As side effect this\n-  will help in supporting multi location checkout in the future.\n-  [alecm, gregweb]\n-\n-- Fixed various UI issues. [rlemmi, vds, alecm]\n-\n-- Fixed SF issue #1376836. [alecm]\n-\n-- restored at\'s extra_buttons slot (some others slots are still missing\n-  because of this template override) [syt]\n-\n-- Totally refactored recursive retrieve of an ancient version of an object.\n-  Fixed a lot of folderish bugs with this refactoring. [gregweb]\n-\n-- Corrected a hairy acquisition bug that caused wrong security evaluations\n-  (ArchivistTool.py). Acquisition is a monster feature! [gregweb]\n-\n-- The storage now returns obj.modified() instead of\n-  obj.getModificationDate() because it\'s more fine graned. [gregweb]\n-\n-- Added ReferenceFactoriesTool.py which in essence knows how to\n-  instatiate a reference. The current implementation is inflexible and\n-  knows only how to instantiate object into an ObjectManager. This\n-  is the first step in preparation for AT reference handling. [gregweb]\n-\n-- Fixed tracker issue #16 RuntimeError: maximum recursion depth exceeded.\n-  I (gregweb) suspect it got fixed by: [alecm]\n-\n-- Fixed identical tracker issues #5, #6, #7, #8. I (gregweb) suspect it got\n-  fixed by: [alecm]\n-\n-- Added modifier to copy permissions from working copy onto retrieved\n-  versions, otherwise retaining workflow can have some very strange\n-  consequences. [alecm]\n-\n-- Fixed a number of bugs involving handling of adding and deleting subobjects\n-  of versioned folders.\n-  [alecm]\n-\n-- Fixed a permissions bug which made the versions_history_form inaccessible if\n-  any of the versions were saved while private (or otherwise had\n-  \'Access contents information\' disabled).\n-  [alecm]\n-\n-- Made quickinstalled product reinstall/uninstall work without issue.  Fixed\n-  unit tests for Plone 2.1.  Use mutators in templates and tests where\n-  applicable rather than direct attribute access. Was Issue #9, #10 and #11.\n-  Thanks to Andrew Lewis for the patches and reports. [Andrew Lewis, alecm]\n-\n-- Corrected bugs in ``RetainWorkflowStateAndHistory`` modifier and the\n-  modifier registry avoiding the review state and the workflow history\n-  from beeing retained on retrieve and revert.\n-\n-\n-Features added\n-\n-- Added danish translation. [stonor]\n-\n-- Retrieving an object just for preview (without replacing the working copy)\n-  caused a lot of headaches and got more and more complex und ununderstandable.\n-  Everything got much simpler by just using a savepoint/abort pair at the right\n-  place while retrieving. [alecm]\n-\n-- I18N tuned (diff-legend untested), french added\n-  [Gpgi, gotcha]\n-\n-- Added more tests to improve coverage. [azy, vds, alecm]\n-\n-- Added support for ATCT (Archetypes Content Types). [azy]\n-\n-- Added ZMI interface for modifiers. [rlemmi]\n-\n-- It\'s now possible to save a new version in the edit view. As soon as a\n-  version sahll be saved a comment field is inserted to add a comment.\n-  [rlemmi]\n-\n-- Added expandable version history to document_byline. [rlemmi]\n-\n-- Made the ModifierRegistryTool make use of any preserve dict passed back to\n-  it by afterRetrieveModifiers.\n-  [alecm]\n-\n-- Added optional CMFDiffTool support for generating diffs between object\n-  versions.  For this to work you need to setup the diffable fields on each\n-  type in portal_diff.  In the \'alecm-at-schema-diffs\' branch of CMFDiffTool\n-  there is a diff type that can be applied to any AT object which will\n-  automatically setup diffs for all fields in the schema (when using this\n-  any value can be entered for the field in portal_diff).\n-  [alecm]\n-\n-- Added a versioning policy (at_edit_autoversion) which automatically creates\n-  new versions on edit for AT types which are configured to support the policy\n-  in the configlet.  This is implemented using a simple macro override on\n-  AT\'s edit_macros, and a new entry in the AT edit form controller chain.\n-  [alecm]\n-\n-- Added new interface IContentTypeVersionPolicySupport and implemented it in\n-  portal_repository.  It allows products to register versioning policies\n-  (classes which implement IVersionPolicy), and to associate those policies\n-  with specific portal types.  IVersionPolicy objects may define methods\n-  (setupPolicyHook, removePolicyHook, enablePolicyOnTypeHook,\n-  disablePolicyOnTypeHook) which can be used to install/uninstall policy\n-  specific behavior in the portal, on adding/removing the policy, or enabling/\n-  disabling the policy on a specific type.\n-  [alecm]\n-\n-\n-1.0alpha2 (around June 2005)\n-----------------------------\n-\n-no changes recorded\n+For older changes, 2.2.23 and earlier, see ``docs/old-changelog.rst``.\ndiff --git a/Products/CMFEditions/ArchivistTool.py b/Products/CMFEditions/ArchivistTool.py\nindex 14ade95..eb4029e 100644\n--- a/Products/CMFEditions/ArchivistTool.py\n+++ b/Products/CMFEditions/ArchivistTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -25,12 +24,15 @@\n \n from AccessControl import ClassSecurityInfo\n from AccessControl import getSecurityManager\n+from AccessControl.class_init import InitializeClass\n from Acquisition import aq_base\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n-from AccessControl.class_init import InitializeClass\n+from io import BytesIO\n from OFS.SimpleItem import SimpleItem\n from Persistence import Persistent\n+from pickle import Pickler\n+from pickle import Unpickler\n from Products.CMFCore.utils import getToolByName\n from Products.CMFCore.utils import UniqueObject\n from Products.CMFEditions.interfaces import IArchivistTool\n@@ -51,22 +53,20 @@\n from Products.CMFEditions.interfaces.IStorage import StorageUnregisteredError\n from Products.CMFEditions.utilities import dereference\n from Products.CMFEditions.utilities import KwAsAttributes\n-from six import BytesIO\n-from six.moves.cPickle import Pickler\n-from six.moves.cPickle import Unpickler\n from zope.interface import alsoProvides\n from zope.interface import implementer\n \n import time\n \n \n-RETRIEVING_UNREGISTERED_FAILED = \\\n-    "Retrieving a version of an unregistered object is not possible. " \\\n+RETRIEVING_UNREGISTERED_FAILED = (\n+    "Retrieving a version of an unregistered object is not possible. "\n     "Register the object \'%r\' first. "\n+)\n+\n \n def deepcopy(obj):\n-    """Makes a deep copy of the object using the pickle mechanism.\n-    """\n+    """Makes a deep copy of the object using the pickle mechanism."""\n     stream = BytesIO()\n     p = Pickler(stream, 1)\n     p.dump(aq_base(obj))\n@@ -74,24 +74,29 @@ def deepcopy(obj):\n     u = Unpickler(stream)\n     return u.load()\n \n+\n @implementer(IVersionData)\n class VersionData:\n-    """\n-    """\n-\n-    def __init__(self, data, refs_to_be_deleted, attr_handling_references,\n-                 preserved_data, metadata):\n+    """ """\n+\n+    def __init__(\n+        self,\n+        data,\n+        refs_to_be_deleted,\n+        attr_handling_references,\n+        preserved_data,\n+        metadata,\n+    ):\n         self.data = data\n         self.refs_to_be_deleted = refs_to_be_deleted\n         self.attr_handling_references = attr_handling_references\n         self.preserved_data = preserved_data\n-        self.sys_metadata = metadata[\'sys_metadata\']\n-        self.app_metadata = metadata[\'app_metadata\']\n+        self.sys_metadata = metadata["sys_metadata"]\n+        self.app_metadata = metadata["app_metadata"]\n \n \n @implementer(IAttributeAdapter)\n class AttributeAdapter(Persistent):\n-\n     def __init__(self, parent, attr_name, type=None):\n         self._parent = aq_base(parent)\n         self._name = attr_name\n@@ -111,9 +116,9 @@ def getAttributeName(self):\n     def getType(self):\n         return self._type\n \n+\n @implementer(IAttributeAdapter)\n class ObjectManagerStorageAdapter(Persistent):\n-\n     def __init__(self, parent, attr_name, type=None):\n         self._parent = aq_base(parent)\n         self._name = attr_name\n@@ -139,8 +144,7 @@ def getType(self):\n \n @implementer(IVersionAwareReference)\n class VersionAwareReference(Persistent):\n-    """A Reference that is version aware (and in future also location aware).\n-    """\n+    """A Reference that is version aware (and in future also location aware)."""\n \n     def __init__(self, **info):\n         self.history_id = None\n@@ -149,9 +153,8 @@ def __init__(self, **info):\n         self.info = info\n \n     def setReference(self, target_obj, remove_info=True):\n-        """See IVersionAwareReference\n-        """\n-        storage = getToolByName(target_obj, \'portal_historiesstorage\')\n+        """See IVersionAwareReference"""\n+        storage = getToolByName(target_obj, "portal_historiesstorage")\n \n         # save as much information as possible\n         # it may be that the target object is not yet registered with the\n@@ -160,13 +163,13 @@ def setReference(self, target_obj, remove_info=True):\n         if storage.isRegistered(self.history_id):\n             self.version_id = target_obj.version_id\n             # XXX the location id has to be gotten from the object directly\n-            self.location_id = 0 # XXX only one location possible currently\n+            self.location_id = 0  # XXX only one location possible currently\n             # XXX store the information if the referenced working copy\n             # was unchanged since the last checkin. In this case the\n             # the exact state of the referenced object may be retrieved also.\n             # XXX we really need a isUpToDate/isChanged methods!\n \n-        if remove_info and hasattr(self, \'info\'):\n+        if remove_info and hasattr(self, "info"):\n             del self.info\n \n     def __of__(self, obj):\n@@ -176,13 +179,12 @@ def __of__(self, obj):\n \n @implementer(IArchivistTool, IArchivist, IPurgeSupport)\n class ArchivistTool(UniqueObject, SimpleItem):\n-    """\n-    """\n+    """ """\n \n-    id = \'portal_archivist\'\n-    alternative_id = \'portal_standard_archivist\'\n+    id = "portal_archivist"\n+    alternative_id = "portal_standard_archivist"\n \n-    meta_type = \'CMFEditions Portal Archivist Tool\'\n+    meta_type = "CMFEditions Portal Archivist Tool"\n \n     # make interfaces, exceptions and classes available through the tool\n     interfaces = KwAsAttributes(\n@@ -202,14 +204,12 @@ class ArchivistTool(UniqueObject, SimpleItem):\n \n     security = ClassSecurityInfo()\n \n-\n     # -------------------------------------------------------------------\n     # private helper methods\n     # -------------------------------------------------------------------\n     def _cloneByPickle(self, obj):\n-        """Returns a deep copy of a ZODB object, loading ghosts as needed.\n-        """\n-        modifier = getToolByName(self, \'portal_modifier\')\n+        """Returns a deep copy of a ZODB object, loading ghosts as needed."""\n+        modifier = getToolByName(self, "portal_modifier")\n         callbacks = modifier.getOnCloneModifiers(obj)\n         if callbacks is not None:\n             pers_id, pers_load, inside_orefs, outside_orefs = callbacks[0:4]\n@@ -228,17 +228,16 @@ def _cloneByPickle(self, obj):\n             u.persistent_load = pers_load\n         return approxSize, u.load(), inside_orefs, outside_orefs\n \n-\n     # -------------------------------------------------------------------\n     # methods implementing IArchivist\n     # -------------------------------------------------------------------\n \n-    security.declarePrivate(\'prepare\')\n+    security.declarePrivate("prepare")\n+\n     def prepare(self, obj, app_metadata=None, sys_metadata={}):\n-        """See IArchivist.\n-        """\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n-        modifier = getToolByName(self, \'portal_modifier\')\n+        """See IArchivist."""\n+        storage = getToolByName(self, "portal_historiesstorage")\n+        modifier = getToolByName(self, "portal_modifier")\n \n         obj, history_id = dereference(obj, zodb_hook=self)\n         if storage.isRegistered(history_id):\n@@ -252,7 +251,7 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n             # (the current implementation isn\'t able yet to handle multiple\n             # locations. Nevertheless lets set the location id to a well\n             # known default value)\n-            uidhandler = getToolByName(self, \'portal_historyidhandler\')\n+            uidhandler = getToolByName(self, "portal_historyidhandler")\n             history_id = uidhandler.register(obj)\n             version_id = obj.version_id = 0\n             alsoProvides(obj, IVersioned)\n@@ -265,10 +264,8 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n         # 2. clone the object with some modifications\n         # 3. modify the clone further\n         referenced_data = modifier.getReferencedAttributes(obj)\n-        approxSize, clone, inside_orefs, outside_orefs = \\\n-            self._cloneByPickle(obj)\n-        metadata, inside_crefs, outside_crefs = \\\n-            modifier.beforeSaveModifier(obj, clone)\n+        approxSize, clone, inside_orefs, outside_orefs = self._cloneByPickle(obj)\n+        metadata, inside_crefs, outside_crefs = modifier.beforeSaveModifier(obj, clone)\n \n         # extend the ``sys_metadata`` by the metadata returned by the\n         # ``beforeSaveModifier`` modifier\n@@ -282,57 +279,71 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n         # return the prepared infos (clone, refs, etc.)\n         clone_info = ObjectData(clone, inside_crefs, outside_crefs)\n         obj_info = ObjectData(obj, inside_orefs, outside_orefs)\n-        return PreparedObject(history_id, obj_info, clone_info,\n-                              referenced_data, app_metadata,\n-                              sys_metadata, is_registered, approxSize)\n+        return PreparedObject(\n+            history_id,\n+            obj_info,\n+            clone_info,\n+            referenced_data,\n+            app_metadata,\n+            sys_metadata,\n+            is_registered,\n+            approxSize,\n+        )\n+\n+    security.declarePrivate("register")\n \n-    security.declarePrivate(\'register\')\n     def register(self, prepared_obj):\n-        """See IArchivist.\n-        """\n+        """See IArchivist."""\n         # only register at the storage layer if not yet registered\n         if not prepared_obj.is_registered:\n-            storage = getToolByName(self, \'portal_historiesstorage\')\n-            return storage.register(prepared_obj.history_id,\n-                                    prepared_obj.clone,\n-                                    prepared_obj.referenced_data,\n-                                    prepared_obj.metadata)\n+            storage = getToolByName(self, "portal_historiesstorage")\n+            return storage.register(\n+                prepared_obj.history_id,\n+                prepared_obj.clone,\n+                prepared_obj.referenced_data,\n+                prepared_obj.metadata,\n+            )\n+\n+    security.declarePrivate("save")\n \n-    security.declarePrivate(\'save\')\n     def save(self, prepared_obj, autoregister=None):\n-        """See IArchivist.\n-        """\n+        """See IArchivist."""\n         if not prepared_obj.is_registered:\n             if autoregister:\n                 return self.register(prepared_obj)\n             raise ArchivistSaveError(\n                 "Saving an unregistered object is not possible. Register "\n-                "the object \'%r\' first. "% prepared_obj.original.object)\n+                "the object \'%r\' first. " % prepared_obj.original.object\n+            )\n \n-        storage = getToolByName(self, \'portal_historiesstorage\')\n-        return storage.save(prepared_obj.history_id,\n-                            prepared_obj.clone,\n-                            prepared_obj.referenced_data,\n-                            prepared_obj.metadata)\n+        storage = getToolByName(self, "portal_historiesstorage")\n+        return storage.save(\n+            prepared_obj.history_id,\n+            prepared_obj.clone,\n+            prepared_obj.referenced_data,\n+            prepared_obj.metadata,\n+        )\n \n     # -------------------------------------------------------------------\n     # methods implementing IPurgeSupport\n     # -------------------------------------------------------------------\n \n-    security.declarePrivate(\'purge\')\n-    def purge(self, obj=None, history_id=None, selector=None, metadata={},\n-              countPurged=True):\n-        """See IPurgeSupport.\n-        """\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+    security.declarePrivate("purge")\n+\n+    def purge(\n+        self, obj=None, history_id=None, selector=None, metadata={}, countPurged=True\n+    ):\n+        """See IPurgeSupport."""\n+        storage = getToolByName(self, "portal_historiesstorage")\n         obj, history_id = dereference(obj, history_id, self)\n         storage.purge(history_id, selector, metadata, countPurged)\n \n-    security.declarePrivate(\'retrieve\')\n-    def retrieve(self, obj=None, history_id=None, selector=None, preserve=(),\n-                 countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+    security.declarePrivate("retrieve")\n+\n+    def retrieve(\n+        self, obj=None, history_id=None, selector=None, preserve=(), countPurged=True\n+    ):\n+        """See IPurgeSupport."""\n         # retrieve the object by accessing the right history entry\n         # (counting from the oldest version)\n         # the histories storage called by LazyHistory knows what to do\n@@ -343,41 +354,45 @@ def retrieve(self, obj=None, history_id=None, selector=None, preserve=(),\n         except StorageRetrieveError:\n             raise ArchivistRetrieveError(\n                 "Retrieving of \'%r\' failed. Version \'%s\' does not exist. "\n-                % (obj, selector))\n+                % (obj, selector)\n+            )\n \n-    security.declarePrivate(\'getHistory\')\n-    def getHistory(self, obj=None, history_id=None, preserve=(),\n-                   countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+    security.declarePrivate("getHistory")\n+\n+    def getHistory(self, obj=None, history_id=None, preserve=(), countPurged=True):\n+        """See IPurgeSupport."""\n         try:\n             return LazyHistory(self, obj, history_id, preserve, countPurged)\n         except StorageUnregisteredError:\n             raise ArchivistUnregisteredError(\n                 "Retrieving a version of an unregistered object is not "\n-                "possible. Register the object \'%r\' first. " % obj)\n+                "possible. Register the object \'%r\' first. " % obj\n+            )\n+\n+    security.declarePrivate("getHistoryMetadata")\n \n-    security.declarePrivate(\'getHistoryMetadata\')\n     def getHistoryMetadata(self, obj=None, history_id=None):\n-        """ Return the metadata blob for presenting summary\n-            information, etc. If obj is not supplied, history is found\n-            by history_id, if history_id is not supplied, history is\n-            found by obj. If neither, return None.\n+        """Return the metadata blob for presenting summary\n+        information, etc. If obj is not supplied, history is found\n+        by history_id, if history_id is not supplied, history is\n+        found by obj. If neither, return None.\n         """\n         obj, history_id = dereference(obj, history_id, self)\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+        storage = getToolByName(self, "portal_historiesstorage")\n         try:\n             return storage.getHistoryMetadata(history_id)\n         except StorageUnregisteredError:\n             raise ArchivistUnregisteredError(\n                 "Retrieving a version of an unregistered object is not "\n-                "possible. Register the object \'%r\' first. " % obj)\n+                "possible. Register the object \'%r\' first. " % obj\n+            )\n \n-    security.declarePrivate(\'queryHistory\')\n-    def queryHistory(self, obj=None, history_id=None, preserve=(), default=None,\n-                     countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+    security.declarePrivate("queryHistory")\n+\n+    def queryHistory(\n+        self, obj=None, history_id=None, preserve=(), default=None, countPurged=True\n+    ):\n+        """See IPurgeSupport."""\n         if default is None:\n             default = []\n         try:\n@@ -385,21 +400,19 @@ def queryHistory(self, obj=None, history_id=None, preserve=(), default=None,\n         except StorageUnregisteredError:\n             return default\n \n-    security.declarePrivate(\'isUpToDate\')\n-    def isUpToDate(self, obj=None, history_id=None, selector=None,\n-                   countPurged=True):\n-        """See IPurgeSupport.\n-        """\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+    security.declarePrivate("isUpToDate")\n+\n+    def isUpToDate(self, obj=None, history_id=None, selector=None, countPurged=True):\n+        """See IPurgeSupport."""\n+        storage = getToolByName(self, "portal_historiesstorage")\n         obj, history_id = dereference(obj, history_id, self)\n         if not storage.isRegistered(history_id):\n-            raise ArchivistUnregisteredError(\n-                "The object %r is not registered" % obj)\n+            raise ArchivistUnregisteredError("The object %r is not registered" % obj)\n \n-        modified = storage.getModificationDate(history_id, selector,\n-                                               countPurged)\n+        modified = storage.getModificationDate(history_id, selector, countPurged)\n         return modified == obj.modified()\n \n+\n InitializeClass(ArchivistTool)\n \n \n@@ -409,8 +422,7 @@ def getUserId():\n \n @implementer(IObjectData)\n class ObjectData(Persistent):\n-    """\n-    """\n+    """ """\n \n     def __init__(self, obj, inside_refs=(), outside_refs=()):\n         self.object = obj\n@@ -420,35 +432,42 @@ def __init__(self, obj, inside_refs=(), outside_refs=()):\n \n @implementer(IPreparedObject)\n class PreparedObject:\n-    """\n-    """\n-\n-    def __init__(self, history_id, original, clone, referenced_data,\n-                 app_metadata, sys_metadata, is_registered, approxSize):\n+    """ """\n+\n+    def __init__(\n+        self,\n+        history_id,\n+        original,\n+        clone,\n+        referenced_data,\n+        app_metadata,\n+        sys_metadata,\n+        is_registered,\n+        approxSize,\n+    ):\n \n         # parent reference (register the parent with the unique id handler)\n         # register with sys_metadata as there is no other possibility\n         obj = original.object\n         parent = aq_parent(aq_inner(obj))\n-        portal_uidhandler = getToolByName(obj, \'portal_historyidhandler\')\n+        portal_uidhandler = getToolByName(obj, "portal_historyidhandler")\n \n         # set defaults if missing\n-        sys_metadata[\'comment\'] = sys_metadata.get(\'comment\', \'\')\n-        sys_metadata[\'timestamp\'] = sys_metadata.get(\'timestamp\',\n-                                                     int(time.time()))\n-        sys_metadata[\'originator\'] = sys_metadata.get(\'originator\', None)\n-        sys_metadata[\'principal\'] = getUserId()\n-        sys_metadata[\'approxSize\'] = approxSize\n-        sys_metadata[\'parent\'] = {\n-            \'history_id\': portal_uidhandler.register(parent),\n-            \'version_id\': getattr(parent, "version_id", None),\n-            \'location_id\': getattr(parent, "location_id", None),\n+        sys_metadata["comment"] = sys_metadata.get("comment", "")\n+        sys_metadata["timestamp"] = sys_metadata.get("timestamp", int(time.time()))\n+        sys_metadata["originator"] = sys_metadata.get("originator", None)\n+        sys_metadata["principal"] = getUserId()\n+        sys_metadata["approxSize"] = approxSize\n+        sys_metadata["parent"] = {\n+            "history_id": portal_uidhandler.register(parent),\n+            "version_id": getattr(parent, "version_id", None),\n+            "location_id": getattr(parent, "location_id", None),\n         }\n \n         # bundle application and system metadata in different namespaces\n         metadata = {\n-            \'sys_metadata\': sys_metadata,\n-            \'app_metadata\': app_metadata,\n+            "sys_metadata": sys_metadata,\n+            "app_metadata": app_metadata,\n         }\n \n         self.history_id = history_id\n@@ -464,8 +483,7 @@ def copyVersionIdFromClone(self):\n \n @implementer(IHistory)\n class LazyHistory:\n-    """Lazy history.\n-    """\n+    """Lazy history."""\n \n     def __init__(self, archivist, obj, history_id, preserve, countPurged):\n         """Sets up a lazy history.\n@@ -476,20 +494,18 @@ def __init__(self, archivist, obj, history_id, preserve, countPurged):\n         the obj. If the obj is omitted, then the obj will be obtained by\n         dereferencing the history_id.\n         """\n-        self._modifier = getToolByName(archivist, \'portal_modifier\')\n-        storage = getToolByName(archivist, \'portal_historiesstorage\')\n+        self._modifier = getToolByName(archivist, "portal_modifier")\n+        storage = getToolByName(archivist, "portal_historiesstorage")\n         self._obj, history_id = dereference(obj, history_id, archivist)\n         self._preserve = preserve\n         self._history = storage.getHistory(history_id, countPurged)\n \n     def __len__(self):\n-        """See IHistory\n-        """\n+        """See IHistory"""\n         return len(self._history)\n \n     def __getitem__(self, selector):\n-        """See IHistory\n-        """\n+        """See IHistory"""\n         # To retrieve an object from the storage the following\n         # steps have to be carried out:\n         #\n@@ -507,28 +523,27 @@ def __getitem__(self, selector):\n         metadata = deepcopy(vdata.metadata)\n \n         # 5. reattach the separately saved attributes\n-        self._modifier.reattachReferencedAttributes(repo_clone,\n-                                                    referenced_data)\n+        self._modifier.reattachReferencedAttributes(repo_clone, referenced_data)\n \n         # 6. call the after retrieve modifier\n-        refs_to_be_deleted, attr_handling_references, preserved_data = \\\n-            self._modifier.afterRetrieveModifier(self._obj, repo_clone,\n-                                                 self._preserve)\n+        (\n+            refs_to_be_deleted,\n+            attr_handling_references,\n+            preserved_data,\n+        ) = self._modifier.afterRetrieveModifier(self._obj, repo_clone, self._preserve)\n \n-        return VersionData(data, refs_to_be_deleted,\n-                           attr_handling_references, preserved_data,\n-                           metadata)\n+        return VersionData(\n+            data, refs_to_be_deleted, attr_handling_references, preserved_data, metadata\n+        )\n \n     def __iter__(self):\n-        """See IHistory.\n-        """\n-        return GetItemIterator(self.__getitem__,\n-                               stopExceptions=(StorageRetrieveError,))\n+        """See IHistory."""\n+        return GetItemIterator(self.__getitem__, stopExceptions=(StorageRetrieveError,))\n \n \n class GetItemIterator:\n-    """Iterator object using a getitem implementation to iterate over.\n-    """\n+    """Iterator object using a getitem implementation to iterate over."""\n+\n     def __init__(self, getItem, stopExceptions):\n         self._getItem = getItem\n         self._stopExceptions = stopExceptions\n@@ -547,5 +562,5 @@ def __next__(self):\n \n \n def object_copied(obj, event):\n-    if getattr(aq_base(obj), \'version_id\', None) is not None:\n-        delattr(obj, \'version_id\')\n+    if getattr(aq_base(obj), "version_id", None) is not None:\n+        delattr(obj, "version_id")\ndiff --git a/Products/CMFEditions/CopyModifyMergeRepositoryTool.py b/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\nindex 0c2b4f1..520d1d7 100644\n--- a/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\n+++ b/Products/CMFEditions/CopyModifyMergeRepositoryTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber,\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -25,11 +24,11 @@\n \n from AccessControl import ClassSecurityInfo\n from AccessControl import Unauthorized\n+from AccessControl.class_init import InitializeClass\n from Acquisition import aq_base\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n from Acquisition import ImplicitAcquisitionWrapper\n-from AccessControl.class_init import InitializeClass\n from BTrees.OOBTree import OOBTree\n from OFS.SimpleItem import SimpleItem\n from Products.CMFCore.utils import _checkPermission\n@@ -37,12 +36,8 @@\n from Products.CMFCore.utils import UniqueObject\n from Products.CMFEditions.interfaces.IArchivist import ArchivistRetrieveError\n from Products.CMFEditions.interfaces.IModifier import ModifierException\n-from Products.CMFEditions.interfaces.IRepository import (\n-    IContentTypeVersionPolicySupport\n-)\n-from Products.CMFEditions.interfaces.IRepository import (\n-    ICopyModifyMergeRepository\n-)\n+from Products.CMFEditions.interfaces.IRepository import IContentTypeVersionPolicySupport\n+from Products.CMFEditions.interfaces.IRepository import ICopyModifyMergeRepository\n from Products.CMFEditions.interfaces.IRepository import IHistory\n from Products.CMFEditions.interfaces.IRepository import IPurgeSupport\n from Products.CMFEditions.interfaces.IRepository import IRepositoryTool\n@@ -64,7 +59,6 @@\n from zope.lifecycleevent import ObjectModifiedEvent\n \n import logging\n-import six\n import time\n import transaction\n \n@@ -89,8 +83,7 @@\n )\n class CopyModifyMergeRepositoryTool(UniqueObject, SimpleItem):\n \n-    """See ICopyModifyMergeRepository\n-    """\n+    """See ICopyModifyMergeRepository"""\n \n     id = "portal_repository"\n     alternative_id = "portal_copymergerepository"\n@@ -122,8 +115,7 @@ def _migrateVersionPolicies(self):\n \n     @security.public\n     def isVersionable(self, obj):\n-        """See interface.\n-        """\n+        """See interface."""\n         if hasattr(aq_base(obj), "versioning_enabled") and not getattr(\n             obj, "versioning_enabled"\n         ):\n@@ -140,9 +132,7 @@ def setVersionableContentTypes(self, new_content_types):\n \n     # XXX: There was a typo which mismatched the interface def, preserve it\n     # for backwards compatibility\n-    security.declareProtected(\n-        ManageVersioningPolicies, "setVersionableContentType"\n-    )\n+    security.declareProtected(ManageVersioningPolicies, "setVersionableContentType")\n     setVersionableContentType = setVersionableContentTypes\n \n     @security.protected(ManageVersioningPolicies)\n@@ -211,9 +201,7 @@ def listPolicies(self):\n         return policy_list\n \n     @security.protected(ManageVersioningPolicies)\n-    def addPolicy(\n-        self, policy_id, policy_title, policy_class=VersionPolicy, **kw\n-    ):\n+    def addPolicy(self, policy_id, policy_title, policy_class=VersionPolicy, **kw):\n         self._policy_defs[policy_id] = policy_class(policy_id, policy_title)\n         self._callPolicyHook("add", policy_id, **kw)\n \n@@ -239,12 +227,11 @@ def manage_changePolicyDefs(self, policy_list, **kwargs):\n                 raise AssertionError("List items must be tuples: %s" % str(item))\n             if len(item) not in (2, 3, 4):\n                 raise AssertionError(\n-                    "Each policy definition must contain a title and id: %s"\n-                    % str(item)\n+                    "Each policy definition must contain a title and id: %s" % str(item)\n                 )\n-            if not isinstance(item[0], six.string_types):\n+            if not isinstance(item[0], str):\n                 raise AssertionError("Policy id must be a string: %s" % str(item[0]))\n-            if not isinstance(item[1], six.string_types):\n+            if not isinstance(item[1], str):\n                 raise AssertionError("Policy title must be a string: %s" % str(item[1]))\n             # Get optional Policy class and kwargs.\n             if len(item) >= 3:\n@@ -286,14 +273,12 @@ def _callPolicyHook(self, action, policy_id, *args, **kw):\n \n     @security.protected(ApplyVersionControl)\n     def setAutoApplyMode(self, autoapply):\n-        """See ICopyModifyMergeRepository.\n-        """\n+        """See ICopyModifyMergeRepository."""\n         self.autoapply = autoapply\n \n     @security.public\n     def applyVersionControl(self, obj, comment="", metadata={}):\n-        """See ICopyModifyMergeRepository.\n-        """\n+        """See ICopyModifyMergeRepository."""\n         self._assertAuthorized(obj, ApplyVersionControl, "applyVersionControl")\n         sp = transaction.savepoint(optimistic=True)\n         try:\n@@ -310,8 +295,7 @@ def applyVersionControl(self, obj, comment="", metadata={}):\n \n     @security.public\n     def save(self, obj, comment="", metadata={}):\n-        """See ICopyModifyMergeRepository.\n-        """\n+        """See ICopyModifyMergeRepository."""\n         self._assertAuthorized(obj, SaveNewVersion, "save")\n         sp = transaction.savepoint(optimistic=True)\n         try:\n@@ -332,8 +316,7 @@ def save(self, obj, comment="", metadata={}):\n \n     @security.public\n     def purge(self, obj, selector, comment="", metadata={}, countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+        """See IPurgeSupport."""\n         self._assertAuthorized(obj, PurgeVersion, "purge")\n \n         # Trying to avoid mess with purged versions which we don\'t offer\n@@ -363,8 +346,7 @@ def purge(self, obj, selector, comment="", metadata={}, countPurged=True):\n \n     @security.public\n     def revert(self, obj, selector=None, countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+        """See IPurgeSupport."""\n         # XXX this should go away if _recursiveRetrieve is correctly\n         # implemented\n         original_id = obj.getId()\n@@ -390,17 +372,13 @@ def revert(self, obj, selector=None, countPurged=True):\n \n     @security.public\n     def retrieve(self, obj, selector=None, preserve=(), countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+        """See IPurgeSupport."""\n         self._assertAuthorized(obj, AccessPreviousVersions, "retrieve")\n         return self._retrieve(obj, selector, preserve, countPurged)\n \n     @security.public\n-    def restore(\n-        self, history_id, selector, container, new_id=None, countPurged=True\n-    ):\n-        """See IPurgeSupport.\n-        """\n+    def restore(self, history_id, selector, container, new_id=None, countPurged=True):\n+        """See IPurgeSupport."""\n \n         self._assertAuthorized(container, RevertToPreviousVersions, "revert")\n         fixup_queue = []\n@@ -426,21 +404,15 @@ def restore(\n         self._doInplaceFixups(fixup_queue, True)\n \n     @security.public\n-    def getHistory(\n-        self, obj, oldestFirst=False, preserve=(), countPurged=True\n-    ):\n-        """See IPurgeSupport.\n-        """\n+    def getHistory(self, obj, oldestFirst=False, preserve=(), countPurged=True):\n+        """See IPurgeSupport."""\n         self._assertAuthorized(obj, AccessPreviousVersions, "getHistory")\n         return LazyHistory(self, obj, oldestFirst, preserve, countPurged)\n \n     @security.public\n     def getHistoryMetadata(self, obj):\n-        """Returns the versioning metadata history.\n-        """\n-        self._assertAuthorized(\n-            obj, AccessPreviousVersions, "getHistoryMetadata"\n-        )\n+        """Returns the versioning metadata history."""\n+        self._assertAuthorized(obj, AccessPreviousVersions, "getHistoryMetadata")\n         portal_archivist = getToolByName(self, "portal_archivist")\n         hist = portal_archivist.getHistoryMetadata(obj)\n         if hist:\n@@ -449,8 +421,7 @@ def getHistoryMetadata(self, obj):\n \n     @security.public\n     def isUpToDate(self, obj, selector=None, countPurged=True):\n-        """See IPurgeSupport.\n-        """\n+        """See IPurgeSupport."""\n         portal_archivist = getToolByName(self, "portal_archivist")\n         return portal_archivist.isUpToDate(\n             obj=obj, selector=selector, countPurged=countPurged\n@@ -489,7 +460,7 @@ def _recursiveSave(self, obj, app_metadata, sys_metadata, autoapply):\n         # objects\n         if sys_metadata["originator"] is None:\n             clone = prep.clone.object\n-            sys_metadata["originator"] = "%s.%s.%s" % (\n+            sys_metadata["originator"] = "{}.{}.{}".format(\n                 prep.history_id,\n                 clone.version_id,\n                 clone.location_id,\n@@ -510,9 +481,7 @@ def _recursiveSave(self, obj, app_metadata, sys_metadata, autoapply):\n             prep.clone.inside_refs,\n         )\n         for orig_ref, clone_ref in inside_refs:\n-            self._recursiveSave(\n-                orig_ref, app_metadata, sys_metadata, autoapply\n-            )\n+            self._recursiveSave(orig_ref, app_metadata, sys_metadata, autoapply)\n             clone_ref.setReference(orig_ref, remove_info=True)\n \n         outside_refs = map(\n@@ -550,9 +519,7 @@ def _retrieve(self, obj, selector, preserve, countPurged):\n         )\n         saved.rollback()\n         wrapped = wrap(vd.data.object, aq_parent(aq_inner(obj)))\n-        return VersionData(\n-            wrapped, vd.preserved_data, vd.sys_metadata, vd.app_metadata\n-        )\n+        return VersionData(wrapped, vd.preserved_data, vd.sys_metadata, vd.app_metadata)\n \n     def _recursiveRetrieve(\n         self,\n@@ -566,8 +533,7 @@ def _recursiveRetrieve(\n         ignore_existing=False,\n         countPurged=True,\n     ):\n-        """This is the real workhorse pulling objects out recursively.\n-        """\n+        """This is the real workhorse pulling objects out recursively."""\n         portal_archivist = getToolByName(self, "portal_archivist")\n         portal_reffactories = getToolByName(self, "portal_referencefactories")\n         if ignore_existing:\n@@ -675,9 +641,7 @@ def _recursiveRetrieve(\n             if va_ref is None:\n                 continue\n             try:\n-                ref = dereference(\n-                    history_id=va_ref.history_id, zodb_hook=self\n-                )[0]\n+                ref = dereference(history_id=va_ref.history_id, zodb_hook=self)[0]\n             except (TypeError, AttributeError):\n                 # get the attribute from the working copy\n                 ref = cur_value\n@@ -694,7 +658,7 @@ def _recursiveRetrieve(\n         return vdata\n \n     def _doInplaceFixups(self, queue, inplace):\n-        """ Perform fixups to deal with implementation details\n+        """Perform fixups to deal with implementation details\n         (especially zodb and cmf details) which need to be done in\n         each retrieved object."""\n         for obj in queue:\n@@ -703,7 +667,7 @@ def _doInplaceFixups(self, queue, inplace):\n                 self._fixupCatalogData(obj)\n \n     def _fixupCatalogData(self, obj):\n-        """ Reindex the object, otherwise the catalog will certainly\n+        """Reindex the object, otherwise the catalog will certainly\n         be out of sync."""\n         portal_catalog = getToolByName(self, "portal_catalog")\n         portal_catalog.indexObject(obj)\n@@ -732,7 +696,7 @@ def _fixIds(self, obj):\n                     object_list = getattr(obj, "_objects", None)\n                     if object_list is not None:\n                         obj._objects = tuple(\n-                            [o for o in object_list if o["id"] != orig_id]\n+                            o for o in object_list if o["id"] != orig_id\n                         )  # noqa\n                     temp_ids.append((real_id, child))\n             # Make a second pass to move the objects into place if possible\n@@ -757,8 +721,7 @@ def _fixIds(self, obj):\n     # -------------------------------------------------------------------\n \n     def createTestHierarchy(self, context):\n-        """Create a Content Test Hierarchy\n-        """\n+        """Create a Content Test Hierarchy"""\n         # XXX to be allowed in test mode only\n         from StorageMigrationSupport import createTestHierarchy\n \n@@ -767,8 +730,7 @@ def createTestHierarchy(self, context):\n \n @implementer(IVersionData)\n class VersionData:\n-    """\n-    """\n+    """ """\n \n     security = ClassSecurityInfo()\n     security.declareObjectPublic()\n@@ -789,8 +751,7 @@ def __init__(self, object, preserved_data, sys_metadata, app_metadata):\n \n @implementer(IHistory)\n class LazyHistory:\n-    """Lazy history.\n-    """\n+    """Lazy history."""\n \n     __allow_access_to_unprotected_subobjects__ = 1\n \n@@ -803,20 +764,16 @@ def __init__(self, repository, obj, oldestFirst, preserve, countPurged):\n         self._countPurged = countPurged\n         self._retrieve = repository._retrieve\n         self._length = len(\n-            archivist.queryHistory(\n-                obj=obj, preserve=preserve, countPurged=countPurged\n-            )\n+            archivist.queryHistory(obj=obj, preserve=preserve, countPurged=countPurged)\n         )\n         self._cache = {}\n \n     def __len__(self):\n-        """See IHistory\n-        """\n+        """See IHistory"""\n         return self._length\n \n     def __getitem__(self, selector):\n-        """See IHistory\n-        """\n+        """See IHistory"""\n         if not self._oldestFirst and selector < self._length:\n             if selector >= 0:\n                 selector = self._length - 1 - selector\n@@ -831,24 +788,20 @@ def __getitem__(self, selector):\n         return result\n \n     def __iter__(self):\n-        """See IHistory.\n-        """\n+        """See IHistory."""\n         return GetItemIterator(\n             self.__getitem__, stopExceptions=(ArchivistRetrieveError,)\n         )\n \n \n class GetItemIterator:\n-    """Iterator object using a getitem implementation to iterate over.\n-    """\n+    """Iterator object using a getitem implementation to iterate over."""\n \n     def __init__(self, getItem, stopExceptions):\n         self._getItem = getItem\n         self._stopExceptions = stopExceptions\n         self._pos = -1\n-        self.next = (\n-            self.__next__\n-        )  # In order to keep compatibility with Python 2\n+        self.next = self.__next__  # In order to keep compatibility with Python 2\n \n     def __iter__(self):\n         return self\ndiff --git a/Products/CMFEditions/KeepLastNVersionsTool.py b/Products/CMFEditions/KeepLastNVersionsTool.py\nindex 28b9eda..d4f8924 100644\n--- a/Products/CMFEditions/KeepLastNVersionsTool.py\n+++ b/Products/CMFEditions/KeepLastNVersionsTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -36,22 +35,24 @@\n \n @implementer(IPurgePolicyTool, IPurgePolicy)\n class KeepLastNVersionsTool(UniqueObject, SimpleItem, PropertyManager):\n-    """\n-    """\n+    """ """\n \n-    id = \'portal_purgepolicy\'\n-    alternative_id = \'portal_keeplastnversions\'\n+    id = "portal_purgepolicy"\n+    alternative_id = "portal_keeplastnversions"\n \n     meta_type = "CMFEditions Purge Policy Keeping Only the n last Versions"\n \n-    manage_options = PropertyManager.manage_options \\\n-      + SimpleItem.manage_options\n+    manage_options = PropertyManager.manage_options + SimpleItem.manage_options\n \n-    maxNumberOfVersionsToKeep = -1 # disabled\n+    maxNumberOfVersionsToKeep = -1  # disabled\n \n     _properties = (\n-        {\'id\': \'maxNumberOfVersionsToKeep\', \'type\': \'int\', \'mode\': \'w\',\n-         \'label\': "maximum number of versions to keep in the storage (set to -1 for infinite)"},\n+        {\n+            "id": "maxNumberOfVersionsToKeep",\n+            "type": "int",\n+            "mode": "w",\n+            "label": "maximum number of versions to keep in the storage (set to -1 for infinite)",\n+        },\n     )\n     security = ClassSecurityInfo()\n \n@@ -70,17 +71,19 @@ def beforeSaveHook(self, history_id, obj, metadata={}):\n             # infinite: do nothing\n             return True\n \n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+        storage = getToolByName(self, "portal_historiesstorage")\n         currentVersion = len(storage.getHistory(history_id))\n         while True:\n             length = len(storage.getHistory(history_id, countPurged=False))\n             if length < self.maxNumberOfVersionsToKeep:\n                 break\n             comment = "purged on save of version %s" % currentVersion\n-            storage.purge(history_id, 0, metadata={\'sys_metadata\': {\n-                                                           \'comment\': comment}\n-                                                   },\n-                          countPurged=False)\n+            storage.purge(\n+                history_id,\n+                0,\n+                metadata={"sys_metadata": {"comment": comment}},\n+                countPurged=False,\n+            )\n \n         # save current version\n         return True\n@@ -94,7 +97,7 @@ def retrieveSubstitute(self, history_id, selector, default=None):\n             selector = 0\n         else:\n             selector = int(selector)\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+        storage = getToolByName(self, "portal_historiesstorage")\n         savedSelector = selector\n         while selector:\n             selector -= 1\n@@ -115,4 +118,5 @@ def retrieveSubstitute(self, history_id, selector, default=None):\n \n         return default\n \n+\n InitializeClass(KeepLastNVersionsTool)\ndiff --git a/Products/CMFEditions/ModifierRegistryTool.py b/Products/CMFEditions/ModifierRegistryTool.py\nindex 1efdcd8..0f0bc02 100644\n--- a/Products/CMFEditions/ModifierRegistryTool.py\n+++ b/Products/CMFEditions/ModifierRegistryTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -24,8 +23,8 @@\n """\n \n from AccessControl import ClassSecurityInfo\n-from Acquisition import aq_base\n from AccessControl.class_init import InitializeClass\n+from Acquisition import aq_base\n from Missing import MV\n from OFS.OrderedFolder import OrderedFolder\n from Products.CMFCore.permissions import ManagePortal\n@@ -47,26 +46,28 @@\n \n \n @implementer(\n-        IAttributeModifier, ISaveRetrieveModifier, ICloneModifier,\n-        IModifierRegistrySet,\n-        IModifierRegistryQuery,\n-#        IBulkEditableSubscriberRegistry,        # not yet implemented\n-        IPortalModifierTool,)\n+    IAttributeModifier,\n+    ISaveRetrieveModifier,\n+    ICloneModifier,\n+    IModifierRegistrySet,\n+    IModifierRegistryQuery,\n+    #        IBulkEditableSubscriberRegistry,        # not yet implemented\n+    IPortalModifierTool,\n+)\n class ModifierRegistryTool(UniqueObject, OrderedFolder):\n-    __doc__ = __doc__ # copy from module\n+    __doc__ = __doc__  # copy from module\n \n-    id = \'portal_modifier\'\n-    alternative_id = \'portal_modifierregistry\'\n+    id = "portal_modifier"\n+    alternative_id = "portal_modifierregistry"\n \n-    meta_type = \'Version Data Modifier Registry\'\n+    meta_type = "Version Data Modifier Registry"\n \n     # make interfaces, exceptions and classes available through the tool\n     interfaces = KwAsAttributes(\n         IConditionalModifier=IConditionalModifier,\n         IConditionalTalesModifier=IConditionalTalesModifier,\n     )\n-    exceptions = KwAsAttributes(\n-    )\n+    exceptions = KwAsAttributes()\n     classes = KwAsAttributes(\n         ConditionalModifier=ConditionalModifier,\n         ConditionalTalesModifier=ConditionalTalesModifier,\n@@ -78,35 +79,33 @@ class ModifierRegistryTool(UniqueObject, OrderedFolder):\n     security = ClassSecurityInfo()\n \n     def all_meta_types(self, interfaces=None):\n-        """Allow adding of objects implementing \'IConditionalModifier\' only.\n-        """\n+        """Allow adding of objects implementing \'IConditionalModifier\' only."""\n         if interfaces is None:\n-            interfaces = (IConditionalModifier, )\n+            interfaces = (IConditionalModifier,)\n         return OrderedFolder.all_meta_types(self, interfaces)\n \n     # be aware that the tool implements also the OrderedObjectManager API\n \n     orderedFolderSetObject = OrderedFolder._setObject\n+\n     def _setObject(self, id, object, roles=None, user=None, set_owner=1):\n-        """Wrap condition and modifier into one object if necessary.\n-        """\n+        """Wrap condition and modifier into one object if necessary."""\n \n         # wrap the object by a conditional tales modifier if it isn\'t one yet\n         if not IConditionalModifier.providedBy(object):\n             object = ConditionalTalesModifier(id, object)\n \n-        return self.orderedFolderSetObject(id, object, roles=roles,\n-                                           user=user, set_owner=set_owner)\n+        return self.orderedFolderSetObject(\n+            id, object, roles=roles, user=user, set_owner=set_owner\n+        )\n \n     def _collectModifiers(self, obj, interface, reversed=False):\n-        """ Returns a list of valid modifiers\n-        """\n+        """Returns a list of valid modifiers"""\n         modifier_list = []\n-        portal = getToolByName(self, \'portal_url\').getPortalObject()\n+        portal = getToolByName(self, "portal_url").getPortalObject()\n         for id, o in self.objectItems():\n             # collect objects modifier only when appropriate\n-            if IConditionalModifier.providedBy(o) \\\n-               and o.isApplicable(obj, portal):\n+            if IConditionalModifier.providedBy(o) and o.isApplicable(obj, portal):\n                 mod = o.getModifier()\n                 if interface.providedBy(mod):\n                     modifier_list.append((id, mod))\n@@ -123,15 +122,15 @@ def _collectModifiers(self, obj, interface, reversed=False):\n     #    an IModifier.\n     # -------------------------------------------------------------------\n \n-    security.declarePrivate(\'getReferencedAttributes\')\n+    security.declarePrivate("getReferencedAttributes")\n+\n     def getReferencedAttributes(self, obj):\n-        """See IModifier\n-        """\n+        """See IModifier"""\n         # just loop over all objects implementing the IModifier interface.\n         referenced_data = {}\n         for id, mod in self._collectModifiers(obj, IAttributeModifier):\n             # prepend the modifiers id to the attributes name\n-            template = \'%s/%%s\' % id\n+            template = "%s/%%s" % id\n             for name, attrs in mod.getReferencedAttributes(obj).items():\n                 referenced_data[template % name] = attrs\n \n@@ -139,10 +138,10 @@ def getReferencedAttributes(self, obj):\n         #     {\'<modifier_id>/<name>\': <refrenced_data>, ...}\n         return referenced_data\n \n-    security.declarePrivate(\'reattachReferencedAttributes\')\n+    security.declarePrivate("reattachReferencedAttributes")\n+\n     def reattachReferencedAttributes(self, obj, referenced_data):\n-        """\n-        """\n+        """ """\n         # the input of \'referenced_data\' is of the format:\n         #     {\'<modifier_id>/<name>\': <refrenced_data>, ...}\n         # build a structure by modifier id\n@@ -150,21 +149,23 @@ def reattachReferencedAttributes(self, obj, referenced_data):\n         data_by_modid = {}\n \n         for id_name, data in referenced_data.items():\n-            id, name = id_name.split(\'/\', 1)\n-            if not id in data_by_modid:\n+            id, name = id_name.split("/", 1)\n+            if id not in data_by_modid:\n                 data_by_modid[id] = {}\n             data_by_modid[id][name] = data\n \n         # loop over modifiers in reverse\n         if data_by_modid:\n-            for id, mod in self._collectModifiers(obj, IAttributeModifier, reversed=True):\n+            for id, mod in self._collectModifiers(\n+                obj, IAttributeModifier, reversed=True\n+            ):\n                 if id in data_by_modid:\n                     mod.reattachReferencedAttributes(obj, data_by_modid[id])\n \n-    security.declarePrivate(\'getOnCloneModifiers\')\n+    security.declarePrivate("getOnCloneModifiers")\n+\n     def getOnCloneModifiers(self, obj):\n-        """See IModifier\n-        """\n+        """See IModifier"""\n         # First check if there is at least one ICloneModifier to loop over.\n         # The clone operation is much fater if there are no \'persistent_id\'\n         # hooks to call.\n@@ -194,19 +195,19 @@ def persistent_id(obj):\n                 pid = pers_id(obj)\n                 if pid is not None:\n                     # found a modifier, add the modifiers name to its pid\n-                    return "%s/%s" % (pers_id_nameByMeth[pers_id], pid)\n+                    return f"{pers_id_nameByMeth[pers_id]}/{pid}"\n \n         def persistent_load(named_pid):\n             # call the right modifiers persistent_load callback\n-            name, pid = named_pid.split(\'/\', 1)\n+            name, pid = named_pid.split("/", 1)\n             return pers_load_byname[name](pid)\n \n-        return persistent_id, persistent_load, inside_orefs, outside_orefs, \'\'\n+        return persistent_id, persistent_load, inside_orefs, outside_orefs, ""\n+\n+    security.declarePrivate("beforeSaveModifier")\n \n-    security.declarePrivate(\'beforeSaveModifier\')\n     def beforeSaveModifier(self, obj, obj_clone):\n-        """See IModifier\n-        """\n+        """See IModifier"""\n         inside_crefs = []\n         outside_crefs = []\n         metadata = {}\n@@ -220,10 +221,10 @@ def beforeSaveModifier(self, obj, obj_clone):\n \n         return metadata, inside_crefs, outside_crefs\n \n-    security.declarePrivate(\'afterRetrieveModifier\')\n+    security.declarePrivate("afterRetrieveModifier")\n+\n     def afterRetrieveModifier(self, obj, repo_clone, preserve=None):\n-        """See IModifier\n-        """\n+        """See IModifier"""\n         if preserve is None:\n             preserve = []\n         # before letting the after retrieve modifiers replace\n@@ -238,7 +239,9 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=None):\n         # just loop over all modifiers in reverse order\n         refs_to_be_deleted = []\n         attrs_handling_subobjects = []\n-        for ignored_id, mod in self._collectModifiers(obj, ISaveRetrieveModifier, reversed=True):\n+        for ignored_id, mod in self._collectModifiers(\n+            obj, ISaveRetrieveModifier, reversed=True\n+        ):\n             to_be_del, attrs, preserve = mod.afterRetrieveModifier(obj, repo_clone)\n             refs_to_be_deleted.extend(to_be_del)\n             attrs_handling_subobjects.extend(attrs)\n@@ -255,10 +258,10 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=None):\n     #    The ModifierRegistryTool is also a registry of IModifier objects.\n     # -------------------------------------------------------------------\n \n-    security.declareProtected(ManagePortal, \'register\')\n+    security.declareProtected(ManagePortal, "register")\n+\n     def register(self, id, modifier, pos=-1):\n-        """See IModifierRegistrySet\n-        """\n+        """See IModifierRegistrySet"""\n         # add the modifier\n         id = self._setObject(id, modifier)\n \n@@ -269,43 +272,43 @@ def register(self, id, modifier, pos=-1):\n             pos += max(0, len(self.objectIds()) + 1)\n         self.moveObjectToPosition(id, pos)\n \n-    security.declareProtected(ManagePortal, \'unregister\')\n+    security.declareProtected(ManagePortal, "unregister")\n+\n     def unregister(self, id):\n-        """See IModifierRegistrySet\n-        """\n+        """See IModifierRegistrySet"""\n         self.manage_delObjects(ids=[id])\n \n-    security.declareProtected(ManagePortal, \'edit\')\n+    security.declareProtected(ManagePortal, "edit")\n+\n     def edit(self, id, enabled=None, condition=None):\n-        """See IModifierRegistrySet\n-        """\n+        """See IModifierRegistrySet"""\n         modifier = self.get(id)\n         if IConditionalTalesModifier.providedBy(modifier):\n             modifier.edit(enabled, condition)\n         else:\n             if condition:\n                 raise NotImplementedError(\n-                    \'%s does not implement conditions.\' % modifier)\n+                    "%s does not implement conditions." % modifier\n+                )\n             modifier.edit(enabled)\n \n-    security.declareProtected(ManagePortal, \'get\')\n+    security.declareProtected(ManagePortal, "get")\n+\n     def get(self, id):\n-        """See IModifierRegistryQuery\n-        """\n+        """See IModifierRegistryQuery"""\n         # raises the correct exception for us\n         getattr(aq_base(self), id)\n         return getattr(self, id)\n \n-    security.declareProtected(ManagePortal, \'query\')\n+    security.declareProtected(ManagePortal, "query")\n+\n     def query(self, id, default=None):\n-        """See IModifierRegistryQuery\n-        """\n+        """See IModifierRegistryQuery"""\n         try:\n             return self.get(id)\n         except AttributeError:\n             return default\n \n-\n     # -------------------------------------------------------------------\n     # methods implementing IBulkModifierRegistry\n     # -------------------------------------------------------------------\ndiff --git a/Products/CMFEditions/Modifiers.py b/Products/CMFEditions/Modifiers.py\nindex 1361214..fb6df97 100644\n--- a/Products/CMFEditions/Modifiers.py\n+++ b/Products/CMFEditions/Modifiers.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -23,10 +22,10 @@\n \n """\n \n+from AccessControl.class_init import InitializeClass\n from Acquisition import aq_base\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n-from AccessControl.class_init import InitializeClass\n from OFS.SimpleItem import SimpleItem\n from Products.CMFCore.Expression import Expression\n from Products.CMFCore.utils import getToolByName\n@@ -38,38 +37,42 @@\n from ZODB.broken import Broken\n from zope.interface import implementer\n \n-manage_addModifierForm = PageTemplateFile(\'www/modifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_addModifierForm\')\n+\n+manage_addModifierForm = PageTemplateFile(\n+    "www/modifierAddForm.pt", globals(), __name__="manage_addModifierForm"\n+)\n+\n \n @implementer(\n-        IConditionalModifier,)\n+    IConditionalModifier,\n+)\n class ConditionalModifier(SimpleItem):\n-    """This is a wrapper for a modifier.\n-    """\n+    """This is a wrapper for a modifier."""\n \n-    modifierEditForm = PageTemplateFile(\'www/modifierEditForm.pt\',\n-                                        globals(),\n-                                        __name__=\'modifierEditForm\')\n+    modifierEditForm = PageTemplateFile(\n+        "www/modifierEditForm.pt", globals(), __name__="modifierEditForm"\n+    )\n     modifierEditForm._owner = None\n     manage = manage_main = modifierEditForm\n-    manage_options = ({\'label\' : \'Edit\', \'action\' : \'modifierEditForm\'},) + SimpleItem.manage_options[:]\n+    manage_options = (\n+        {"label": "Edit", "action": "modifierEditForm"},\n+    ) + SimpleItem.manage_options[:]\n \n-    def __init__(self, id, modifier, title=\'\'):\n-        """See IConditionalModifier.\n-        """\n+    def __init__(self, id, modifier, title=""):\n+        """See IConditionalModifier."""\n         self.id = str(id)\n         self.title = str(title)\n-        self.meta_type = \'edmod_%s\' % id\n+        self.meta_type = "edmod_%s" % id\n         self._modifier = modifier\n         self._enabled = False\n \n-    def edit(self, enabled=None, title=\'\', REQUEST=None):\n-        """See IConditionalModifier.\n-        """\n+    def edit(self, enabled=None, title="", REQUEST=None):\n+        """See IConditionalModifier."""\n         self.title = title\n \n-        if enabled is not None and (enabled==\'True\' or enabled==True):\n+        if enabled is not None and (\n+            enabled == "True" or (isinstance(enabled, bool) and enabled)\n+        ):\n             self._enabled = enabled\n         else:\n             self._enabled = False\n@@ -86,49 +89,48 @@ def isBroken(self):\n         return isinstance(self.getModifier(), Broken)\n \n     def isApplicable(self, obj, portal=None):\n-        """See IConditionalModifier.\n-        """\n+        """See IConditionalModifier."""\n         # check if disabled or an empty condition and not broken\n         if self._enabled and not self.isBroken():\n             return True\n \n     def isEnabled(self):\n-        """See IConditionalModifier.\n-        """\n+        """See IConditionalModifier."""\n         return self._enabled\n \n     def getModifier(self):\n-        """See IConditionalModifier.\n-        """\n+        """See IConditionalModifier."""\n         return self._modifier\n \n+\n InitializeClass(ConditionalModifier)\n \n \n-manage_addTalesModifierForm = PageTemplateFile(\'www/talesModifierAddForm.pt\',\n-                                               globals(),\n-                                               __name__=\'manage_addTalesModifierForm\')\n+manage_addTalesModifierForm = PageTemplateFile(\n+    "www/talesModifierAddForm.pt", globals(), __name__="manage_addTalesModifierForm"\n+)\n+\n \n @implementer(\n-        IConditionalTalesModifier,)\n+    IConditionalTalesModifier,\n+)\n class ConditionalTalesModifier(ConditionalModifier):\n-    """This is a wrapper with a tales condition for a modifier.\n-    """\n+    """This is a wrapper with a tales condition for a modifier."""\n \n-    modifierEditForm = PageTemplateFile(\'www/talesModifierEditForm.pt\',\n-                                        globals(),\n-                                        __name__=\'modifierEditForm\')\n-    manage_options = ({\'label\' : \'Edit\', \'action\' : \'modifierEditForm\'},) + ConditionalModifier.manage_options[:]\n+    modifierEditForm = PageTemplateFile(\n+        "www/talesModifierEditForm.pt", globals(), __name__="modifierEditForm"\n+    )\n+    manage_options = (\n+        {"label": "Edit", "action": "modifierEditForm"},\n+    ) + ConditionalModifier.manage_options[:]\n \n-    def __init__(self, id, modifier, title=\'\'):\n-        """See IConditionalTalesModifier.\n-        """\n+    def __init__(self, id, modifier, title=""):\n+        """See IConditionalTalesModifier."""\n         ConditionalModifier.__init__(self, id, modifier, title)\n         self._condition = None\n \n-    def edit(self, enabled=None, condition=None, title=\'\', REQUEST=None):\n-        """See IConditionalTalesModifier.\n-        """\n+    def edit(self, enabled=None, condition=None, title="", REQUEST=None):\n+        """See IConditionalTalesModifier."""\n         ConditionalModifier.edit(self, enabled, title)\n         if condition is not None and condition != self.getTalesCondition():\n             self._condition = Expression(condition)\n@@ -138,8 +140,7 @@ def edit(self, enabled=None, condition=None, title=\'\', REQUEST=None):\n             return self.modifierEditForm(self, REQUEST)\n \n     def isApplicable(self, obj, portal=None):\n-        """See IConditionalTalesModifier.\n-        """\n+        """See IConditionalTalesModifier."""\n         # check if disabled or an empty condition or broken\n         if not self._enabled or not self.getTalesCondition() or self.isBroken():\n             return False\n@@ -149,9 +150,9 @@ def isApplicable(self, obj, portal=None):\n         return self._condition(context)\n \n     def getTalesCondition(self):\n-        """See IConditionalTalesModifier.\n-        """\n-        return getattr(self._condition, \'text\', \'\')\n+        """See IConditionalTalesModifier."""\n+        return getattr(self._condition, "text", "")\n+\n \n InitializeClass(ConditionalTalesModifier)\n \n@@ -181,14 +182,14 @@ def findNextFolderishParent(obj):\n         """\n         # XXX propose this check (should be the same):\n         #    if aq_base(obj) is obj:\n-        if obj is None or not hasattr(obj, \'aq_base\'):\n+        if obj is None or not hasattr(obj, "aq_base"):\n             folder = None\n         else:\n             folder = obj\n             # Search up the containment hierarchy until we find an\n             # obj that claims it\'s a folder.\n             while folder is not None:\n-                if getattr(aq_base(folder), \'isPrincipiaFolderish\', 0):\n+                if getattr(aq_base(folder), "isPrincipiaFolderish", 0):\n                     # found it.\n                     break\n                 else:\n@@ -198,12 +199,12 @@ def findNextFolderishParent(obj):\n     try:\n         obj_url = obj.absolute_url()\n     except AttributeError:\n-        obj_url = \'\'\n+        obj_url = ""\n \n     # use the portal if folder lookup fails due to an unwrapped obj\n     folder = findNextFolderishParent(obj) or portal\n \n-    pm = getToolByName(portal, \'portal_membership\', None)\n+    pm = getToolByName(portal, "portal_membership", None)\n     if pm is None or pm.isAnonymousUser():\n         member = None\n     else:\n@@ -217,21 +218,21 @@ def findNextFolderishParent(obj):\n     try:\n         portal_type = obj.getPortalTypeName()\n     except AttributeError:\n-        portal_type  = None\n+        portal_type = None\n \n     data = {\n-        \'object_url\':   obj_url,\n-        \'folder_url\':   folder is not None and folder.absolute_url() or \'\',\n-        \'portal_url\':   portal is not None and portal.absolute_url() or \'\',\n-        \'object\':       obj,\n-        \'folder\':       folder,\n-        \'portal\':       portal,\n-        \'nothing\':      None,\n-        \'request\':      getattr(obj, \'REQUEST\', None),\n-        \'modules\':      SecureModuleImporter,\n-        \'member\':       member,\n-        \'meta_type\':    meta_type,\n-        \'portal_type\':  portal_type,\n-        }\n+        "object_url": obj_url,\n+        "folder_url": folder is not None and folder.absolute_url() or "",\n+        "portal_url": portal is not None and portal.absolute_url() or "",\n+        "object": obj,\n+        "folder": folder,\n+        "portal": portal,\n+        "nothing": None,\n+        "request": getattr(obj, "REQUEST", None),\n+        "modules": SecureModuleImporter,\n+        "member": member,\n+        "meta_type": meta_type,\n+        "portal_type": portal_type,\n+    }\n     data.update(more_symbols)\n     return getEngine().getContext(data)\ndiff --git a/Products/CMFEditions/Permissions.py b/Products/CMFEditions/Permissions.py\nindex dcb9b81..136097c 100644\n--- a/Products/CMFEditions/Permissions.py\n+++ b/Products/CMFEditions/Permissions.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -26,23 +25,23 @@\n from AccessControl.Permission import addPermission\n \n \n-ApplyVersionControl = \'CMFEditions: Apply version control\'\n-addPermission(ApplyVersionControl, (\'Manager\', \'Site Administrator\'))\n+ApplyVersionControl = "CMFEditions: Apply version control"\n+addPermission(ApplyVersionControl, ("Manager", "Site Administrator"))\n \n-SaveNewVersion = \'CMFEditions: Save new version\'\n-addPermission(SaveNewVersion, (\'Manager\', \'Site Administrator\'))\n+SaveNewVersion = "CMFEditions: Save new version"\n+addPermission(SaveNewVersion, ("Manager", "Site Administrator"))\n \n-PurgeVersion = \'CMFEditions: Purge version\'\n-addPermission(PurgeVersion, (\'Manager\', \'Site Administrator\'))\n+PurgeVersion = "CMFEditions: Purge version"\n+addPermission(PurgeVersion, ("Manager", "Site Administrator"))\n \n-AccessPreviousVersions = \'CMFEditions: Access previous versions\'\n-addPermission(AccessPreviousVersions, (\'Manager\', \'Site Administrator\'))\n+AccessPreviousVersions = "CMFEditions: Access previous versions"\n+addPermission(AccessPreviousVersions, ("Manager", "Site Administrator"))\n \n-RevertToPreviousVersions = \'CMFEditions: Revert to previous versions\'\n-addPermission(RevertToPreviousVersions, (\'Manager\', \'Site Administrator\'))\n+RevertToPreviousVersions = "CMFEditions: Revert to previous versions"\n+addPermission(RevertToPreviousVersions, ("Manager", "Site Administrator"))\n \n-CheckoutToLocation = \'CMFEditions: Checkout to location\'\n-addPermission(CheckoutToLocation, (\'Manager\', \'Site Administrator\'))\n+CheckoutToLocation = "CMFEditions: Checkout to location"\n+addPermission(CheckoutToLocation, ("Manager", "Site Administrator"))\n \n-ManageVersioningPolicies = \'CMFEditions: Manage versioning policies\'\n-addPermission(ManageVersioningPolicies, (\'Manager\', \'Site Administrator\'))\n+ManageVersioningPolicies = "CMFEditions: Manage versioning policies"\n+addPermission(ManageVersioningPolicies, ("Manager", "Site Administrator"))\ndiff --git a/Products/CMFEditions/ReferenceFactoriesTool.py b/Products/CMFEditions/ReferenceFactoriesTool.py\nindex c38b237..c753380 100644\n--- a/Products/CMFEditions/ReferenceFactoriesTool.py\n+++ b/Products/CMFEditions/ReferenceFactoriesTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2005 Gregoire Weber.\n # All Rights Reserved.\n@@ -24,9 +23,9 @@\n """\n \n from AccessControl import ClassSecurityInfo\n+from AccessControl.class_init import InitializeClass\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n-from AccessControl.class_init import InitializeClass\n from OFS.OrderedFolder import OrderedFolder\n from Products.CMFCore.utils import getToolByName\n from Products.CMFCore.utils import UniqueObject\n@@ -36,14 +35,15 @@\n \n \n @implementer(\n-        IReferenceFactories,)\n+    IReferenceFactories,\n+)\n class ReferenceFactoriesTool(UniqueObject, OrderedFolder):\n-    __doc__ = __doc__ # copy from module\n+    __doc__ = __doc__  # copy from module\n \n-    id = \'portal_referencefactories\'\n-    alternative_id = \'portal_referencefactoryregistry\'\n+    id = "portal_referencefactories"\n+    alternative_id = "portal_referencefactoryregistry"\n \n-    meta_type = \'Reference Factory Registry\'\n+    meta_type = "Reference Factory Registry"\n \n     security = ClassSecurityInfo()\n \n@@ -53,12 +53,12 @@ class ReferenceFactoriesTool(UniqueObject, OrderedFolder):\n     # methods implementing IFactories\n     # -------------------------------------------------------------------\n \n-    security.declarePrivate(\'invokeFactory\')\n+    security.declarePrivate("invokeFactory")\n+\n     def invokeFactory(self, repo_clone, source, selector=None):\n-        """See IReferenceFactories\n-        """\n+        """See IReferenceFactories"""\n         # Just assuming ObjectManager behaviour for now\n-        portal_hidhandler = getToolByName(self, \'portal_historyidhandler\')\n+        portal_hidhandler = getToolByName(self, "portal_historyidhandler")\n         try:\n             portal_type = repo_clone.getPortalTypeName()\n         except AttributeError:\n@@ -79,11 +79,12 @@ def invokeFactory(self, repo_clone, source, selector=None):\n \n         return obj\n \n-    security.declarePrivate(\'hasBeenMoved\')\n+    security.declarePrivate("hasBeenMoved")\n+\n     def hasBeenMoved(self, obj, source):\n-        """See IReferenceFactories\n-        """\n+        """See IReferenceFactories"""\n         # Check that the path of the object\'s parent (by path) is the same as the source\n         return aq_parent(aq_inner(obj)).getPhysicalPath() != source.getPhysicalPath()\n \n+\n InitializeClass(ReferenceFactoriesTool)\ndiff --git a/Products/CMFEditions/StandardModifiers.py b/Products/CMFEditions/StandardModifiers.py\nindex 9e887d7..d196164 100644\n--- a/Products/CMFEditions/StandardModifiers.py\n+++ b/Products/CMFEditions/StandardModifiers.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2005 Alberto Berti, Gregoire Weber,\n # Reflab(Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi),\n@@ -25,8 +24,8 @@\n """Standard modifiers\n """\n \n-from Acquisition import aq_base\n from AccessControl.class_init import InitializeClass\n+from Acquisition import aq_base\n from OFS.ObjectManager import ObjectManager\n from plone.folder.default import DefaultOrdering\n from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base\n@@ -47,233 +46,244 @@\n from zope.interface import implementer\n from zope.interface.interfaces import ComponentLookupError\n \n-import six\n import sys\n \n \n _marker = []\n \n \n-#----------------------------------------------------------------------\n+# ----------------------------------------------------------------------\n # Product initialziation, installation and factory stuff\n-#----------------------------------------------------------------------\n+# ----------------------------------------------------------------------\n+\n \n def initialize(context):\n-    """Registers modifiers with zope (on zope startup).\n-    """\n+    """Registers modifiers with zope (on zope startup)."""\n     for m in modifiers:\n         context.registerClass(\n-            m[\'wrapper\'], m[\'id\'],\n-            permission = ManagePortal,\n-            constructors = (m[\'form\'], m[\'factory\']),\n-            icon = m[\'icon\'],\n+            m["wrapper"],\n+            m["id"],\n+            permission=ManagePortal,\n+            constructors=(m["form"], m["factory"]),\n+            icon=m["icon"],\n         )\n \n+\n def install(portal_modifier, ids=None):\n-    """Registers modifiers in the modifier registry (at tool install time).\n-    """\n+    """Registers modifiers in the modifier registry (at tool install time)."""\n     for m in modifiers:\n-        id = m[\'id\']\n+        id = m["id"]\n         if ids is not None and id not in ids:\n             continue\n         if id in portal_modifier.objectIds():\n             continue\n-        title = m[\'title\']\n-        modifier = m[\'modifier\']()\n-        wrapper = m[\'wrapper\'](id, modifier, title)\n-        enabled = m[\'enabled\']\n+        title = m["title"]\n+        modifier = m["modifier"]()\n+        wrapper = m["wrapper"](id, modifier, title)\n+        enabled = m["enabled"]\n         if IConditionalTalesModifier.providedBy(wrapper):\n-            wrapper.edit(enabled, m[\'condition\'])\n+            wrapper.edit(enabled, m["condition"])\n         else:\n             wrapper.edit(enabled)\n \n-        portal_modifier.register(m[\'id\'], wrapper)\n+        portal_modifier.register(m["id"], wrapper)\n \n \n-manage_OMOutsideChildrensModifierAddForm = PageTemplateFile(\'www/OMOutsideChildrensModifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_OMOutsideChildrensModifierAddForm\')\n+manage_OMOutsideChildrensModifierAddForm = PageTemplateFile(\n+    "www/OMOutsideChildrensModifierAddForm.pt",\n+    globals(),\n+    __name__="manage_OMOutsideChildrensModifierAddForm",\n+)\n+\n \n def manage_addOMOutsideChildrensModifier(self, id, title=None, REQUEST=None):\n-    """Add an object manager modifier treating childrens as outside refs\n-    """\n+    """Add an object manager modifier treating childrens as outside refs"""\n     modifier = OMOutsideChildrensModifier()\n     self._setObject(id, ConditionalTalesModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n-manage_OMInsideChildrensModifierAddForm = PageTemplateFile(\'www/OMInsideChildrensModifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_OMInsideChildrensModifierAddForm\')\n+manage_OMInsideChildrensModifierAddForm = PageTemplateFile(\n+    "www/OMInsideChildrensModifierAddForm.pt",\n+    globals(),\n+    __name__="manage_OMInsideChildrensModifierAddForm",\n+)\n \n-def manage_addOMInsideChildrensModifier(self, id, title=None,\n-                                        REQUEST=None):\n-    """Add an object manager modifier treating children as inside refs\n-    """\n+\n+def manage_addOMInsideChildrensModifier(self, id, title=None, REQUEST=None):\n+    """Add an object manager modifier treating children as inside refs"""\n     modifier = OMInsideChildrensModifier()\n     self._setObject(id, ConditionalTalesModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n-manage_RetainUIDsModifierAddForm =  \\\n-                         PageTemplateFile(\'www/RetainUIDsModifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_RetainUIDsModifierAddForm\')\n+manage_RetainUIDsModifierAddForm = PageTemplateFile(\n+    "www/RetainUIDsModifierAddForm.pt",\n+    globals(),\n+    __name__="manage_RetainUIDsModifierAddForm",\n+)\n+\n \n def manage_addRetainUIDs(self, id, title=None, REQUEST=None):\n-    """Add a modifier retaining UIDs upon retrieve.\n-    """\n+    """Add a modifier retaining UIDs upon retrieve."""\n     modifier = RetainUIDs()\n     self._setObject(id, ConditionalModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n-manage_RetainWorkflowStateAndHistoryModifierAddForm =  \\\n-                         PageTemplateFile(\'www/RetainWorkflowStateAndHistoryModifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_RetainWorkflowStateAndHistoryModifierAddForm\')\n+manage_RetainWorkflowStateAndHistoryModifierAddForm = PageTemplateFile(\n+    "www/RetainWorkflowStateAndHistoryModifierAddForm.pt",\n+    globals(),\n+    __name__="manage_RetainWorkflowStateAndHistoryModifierAddForm",\n+)\n \n-def manage_addRetainWorkflowStateAndHistory(self, id, title=None,\n-                                            REQUEST=None):\n-    """Add a modifier retaining workflow state upon retrieve.\n-    """\n+\n+def manage_addRetainWorkflowStateAndHistory(self, id, title=None, REQUEST=None):\n+    """Add a modifier retaining workflow state upon retrieve."""\n     modifier = RetainWorkflowStateAndHistory()\n     self._setObject(id, ConditionalModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n-manage_RetainPermissionsSettingsAddForm =  \\\n-                         PageTemplateFile(\'www/RetainPermissionsSettingsModifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_RetainPermissionsSettingsModifierAddForm\')\n+manage_RetainPermissionsSettingsAddForm = PageTemplateFile(\n+    "www/RetainPermissionsSettingsModifierAddForm.pt",\n+    globals(),\n+    __name__="manage_RetainPermissionsSettingsModifierAddForm",\n+)\n \n-def manage_addRetainPermissionsSettings(self, id, title=None,\n-                                            REQUEST=None):\n-    """Add a modifier retaining permissions upon retrieve.\n-    """\n+\n+def manage_addRetainPermissionsSettings(self, id, title=None, REQUEST=None):\n+    """Add a modifier retaining permissions upon retrieve."""\n     modifier = RetainPermissionsSettings()\n     self._setObject(id, ConditionalModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n-manage_SaveFileDataInFileTypeByReferenceModifierAddForm =  \\\n-                         PageTemplateFile(\'www/SaveFileDataInFileTypeByReferenceModifierAddForm.pt\',\n-                                          globals(),\n-                                          __name__=\'manage_SaveFileDataInFileTypeByReferenceModifierAddForm\')\n+manage_SaveFileDataInFileTypeByReferenceModifierAddForm = PageTemplateFile(\n+    "www/SaveFileDataInFileTypeByReferenceModifierAddForm.pt",\n+    globals(),\n+    __name__="manage_SaveFileDataInFileTypeByReferenceModifierAddForm",\n+)\n \n-def manage_addSaveFileDataInFileTypeByReference(self, id, title=None,\n-                                                REQUEST=None):\n-    """Add a modifier avoiding unnecessary cloning of file data.\n-    """\n+\n+def manage_addSaveFileDataInFileTypeByReference(self, id, title=None, REQUEST=None):\n+    """Add a modifier avoiding unnecessary cloning of file data."""\n     modifier = SaveFileDataInFileTypeByReference()\n     self._setObject(id, ConditionalTalesModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n+\n \n # silly modifier just for demos\n-manage_SillyDemoRetrieveModifierAddForm =  \\\n-    PageTemplateFile(\'www/SillyDemoRetrieveModifierAddForm.pt\', globals(),\n-                     __name__=\'manage_SillyDemoRetrieveModifierAddForm\')\n+manage_SillyDemoRetrieveModifierAddForm = PageTemplateFile(\n+    "www/SillyDemoRetrieveModifierAddForm.pt",\n+    globals(),\n+    __name__="manage_SillyDemoRetrieveModifierAddForm",\n+)\n \n-def manage_addSillyDemoRetrieveModifier(self, id, title=None,\n-                                            REQUEST=None):\n-    """Add a silly demo retrieve modifier\n-    """\n+\n+def manage_addSillyDemoRetrieveModifier(self, id, title=None, REQUEST=None):\n+    """Add a silly demo retrieve modifier"""\n     modifier = SillyDemoRetrieveModifier()\n     self._setObject(id, ConditionalTalesModifier(id, modifier, title))\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n-manage_AbortVersioningOfLargeFilesAndImagesAddForm =  \\\n-    PageTemplateFile(\'www/AbortVersioningOfLargeFilesAndImagesAddForm.pt\',\n-                  globals(),\n-                  __name__=\'manage_AbortVersioningOfLargeFilesAndImagesAddForm\')\n+manage_AbortVersioningOfLargeFilesAndImagesAddForm = PageTemplateFile(\n+    "www/AbortVersioningOfLargeFilesAndImagesAddForm.pt",\n+    globals(),\n+    __name__="manage_AbortVersioningOfLargeFilesAndImagesAddForm",\n+)\n \n-def manage_addAbortVersioningOfLargeFilesAndImages(self, id, title=None,\n-                                            REQUEST=None):\n-    """Add a silly demo retrieve modifier\n-    """\n+\n+def manage_addAbortVersioningOfLargeFilesAndImages(self, id, title=None, REQUEST=None):\n+    """Add a silly demo retrieve modifier"""\n     modifier = AbortVersioningOfLargeFilesAndImages(id, title)\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n-manage_SkipVersioningOfLargeFilesAndImagesAddForm =  \\\n-    PageTemplateFile(\'www/SkipVersioningOfLargeFilesAndImagesAddForm.pt\',\n-                   globals(),\n-                   __name__=\'manage_SkipVersioningOfLargeFilesAndImagesAddForm\')\n+manage_SkipVersioningOfLargeFilesAndImagesAddForm = PageTemplateFile(\n+    "www/SkipVersioningOfLargeFilesAndImagesAddForm.pt",\n+    globals(),\n+    __name__="manage_SkipVersioningOfLargeFilesAndImagesAddForm",\n+)\n \n-def manage_addSkipVersioningOfLargeFilesAndImages(self, id, title=None,\n-                                            REQUEST=None):\n-    """Add a silly demo retrieve modifier\n-    """\n+\n+def manage_addSkipVersioningOfLargeFilesAndImages(self, id, title=None, REQUEST=None):\n+    """Add a silly demo retrieve modifier"""\n     modifier = SkipVersioningOfLargeFilesAndImages(id, title)\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n+\n+\n+manage_SkipParentPointersAddForm = PageTemplateFile(\n+    "www/SkipParentPointersAddForm.pt",\n+    globals(),\n+    __name__="manage_SkipParentPointersAddForm",\n+)\n \n-manage_SkipParentPointersAddForm =  \\\n-    PageTemplateFile(\'www/SkipParentPointersAddForm.pt\',\n-                   globals(),\n-                   __name__=\'manage_SkipParentPointersAddForm\')\n \n def manage_addSkipParentPointers(self, id, title=None, REQUEST=None):\n-    """Add a skip parent pointers modifier\n-    """\n+    """Add a skip parent pointers modifier"""\n     modifier = SkipParentPointers(id, title)\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n+\n+\n+manage_SkipRegistryBasesPointersAddForm = PageTemplateFile(\n+    "www/SkipRegistryBasesPointersAddForm.pt",\n+    globals(),\n+    __name__="manage_SkipRegistryBasesPointersAddForm",\n+)\n \n-manage_SkipRegistryBasesPointersAddForm =  \\\n-    PageTemplateFile(\'www/SkipRegistryBasesPointersAddForm.pt\',\n-                   globals(),\n-                   __name__=\'manage_SkipRegistryBasesPointersAddForm\')\n \n def manage_addSkipRegistryBasesPointers(self, id, title=None, REQUEST=None):\n-    """Add a skip component registry bases modifier\n-    """\n+    """Add a skip component registry bases modifier"""\n     modifier = SkipRegistryBasesPointers(id, title)\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n+\n+\n+manage_Skip_z3c_blobfileAddForm = PageTemplateFile(\n+    "www/Skip_z3c_blobfile.pt", globals(), __name__="manage_Skip_z3c_blobfileAddForm"\n+)\n \n-manage_Skip_z3c_blobfileAddForm =  \\\n-    PageTemplateFile(\'www/Skip_z3c_blobfile.pt\',\n-                   globals(),\n-                   __name__=\'manage_Skip_z3c_blobfileAddForm\')\n \n def manage_addSkip_z3c_blobfile(self, id, title=None, REQUEST=None):\n-    """Add a skip z3c.blobfile modifier\n-    """\n+    """Add a skip z3c.blobfile modifier"""\n     modifier = Skip_z3c_blobfile(id, title)\n     self._setObject(id, modifier)\n \n     if REQUEST is not None:\n-        REQUEST[\'RESPONSE\'].redirect(self.absolute_url()+\'/manage_main\')\n+        REQUEST["RESPONSE"].redirect(self.absolute_url() + "/manage_main")\n \n \n-#----------------------------------------------------------------------\n+# ----------------------------------------------------------------------\n # Standard modifier implementation\n-#----------------------------------------------------------------------\n+# ----------------------------------------------------------------------\n+\n \n @implementer(ISaveRetrieveModifier)\n class RetainAttributeAnnotationItemsBase:\n@@ -285,8 +295,8 @@ class RetainAttributeAnnotationItemsBase:\n \n     def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         # replace specific annotation elements with those from the working copy\n-        repo_annotations = getattr(repo_clone, \'__annotations__\', None)\n-        obj_annotations = getattr(obj, \'__annotations__\', None)\n+        repo_annotations = getattr(repo_clone, "__annotations__", None)\n+        obj_annotations = getattr(obj, "__annotations__", None)\n \n         # check if the modifier is called with a valid working copy\n         # with annotations\n@@ -305,16 +315,13 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n \n \n class OMBaseModifier(RetainAttributeAnnotationItemsBase):\n-    """Base class for ObjectManager modifiers.\n-    """\n+    """Base class for ObjectManager modifiers."""\n \n-    PRESERVE_ANNOTATION_KEYS = (DefaultOrdering.ORDER_KEY,\n-                                DefaultOrdering.POS_KEY)\n+    PRESERVE_ANNOTATION_KEYS = (DefaultOrdering.ORDER_KEY, DefaultOrdering.POS_KEY)\n \n     def _getOnCloneModifiers(self, obj):\n-        """Removes all childrens and returns them as references.\n-        """\n-        portal_archivist = getToolByName(obj, \'portal_archivist\')\n+        """Removes all childrens and returns them as references."""\n+        portal_archivist = getToolByName(obj, "portal_archivist")\n         VersionAwareReference = portal_archivist.classes.VersionAwareReference\n \n         # do not pickle the object managers subobjects\n@@ -340,9 +347,8 @@ def persistent_load(ignored):\n         return persistent_id, persistent_load, result_refs\n \n     def _beforeSaveModifier(self, obj, clone):\n-        """Returns all unititialized \'IVersionAwareReference\' objects.\n-        """\n-        portal_archivist = getToolByName(obj, \'portal_archivist\')\n+        """Returns all unititialized \'IVersionAwareReference\' objects."""\n+        portal_archivist = getToolByName(obj, "portal_archivist")\n         adapter = portal_archivist.classes.ObjectManagerStorageAdapter\n \n         # just return adapters to the attributes that were replaced by\n@@ -354,15 +360,16 @@ def _beforeSaveModifier(self, obj, clone):\n         return result_refs\n \n     def _getAttributeNamesHandlingSubObjects(self, obj, repo_clone):\n-        attrs = list(set(tuple(repo_clone.objectIds())+tuple(obj.objectIds())))\n+        attrs = list(set(tuple(repo_clone.objectIds()) + tuple(obj.objectIds())))\n \n         if isinstance(obj, BTreeFolder2Base):\n-            attrs.extend([\'_tree\', \'_count\', \'_mt_index\'])\n+            attrs.extend(["_tree", "_count", "_mt_index"])\n         elif isinstance(obj, ObjectManager):\n-            attrs.extend([\'_objects\'])\n+            attrs.extend(["_objects"])\n \n         return attrs\n \n+\n @implementer(ICloneModifier, ISaveRetrieveModifier)\n class OMOutsideChildrensModifier(OMBaseModifier):\n     """ObjectManager modifier treating all childrens as outside refs\n@@ -372,10 +379,9 @@ class OMOutsideChildrensModifier(OMBaseModifier):\n     """\n \n     def getOnCloneModifiers(self, obj):\n-        """Removes all childrens and returns them as references.\n-        """\n+        """Removes all childrens and returns them as references."""\n         pers_id, pers_load, outside_refs = self._getOnCloneModifiers(obj)\n-        return pers_id, pers_load, [], outside_refs, \'\'\n+        return pers_id, pers_load, [], outside_refs, ""\n \n     def beforeSaveModifier(self, obj, clone):\n         """Returns all unititialized \'IVersionAwareReference\' objects.\n@@ -386,7 +392,7 @@ def beforeSaveModifier(self, obj, clone):\n         return {}, [], outside_refs\n \n     def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n-        portal_archivist = getToolByName(obj, \'portal_archivist\')\n+        portal_archivist = getToolByName(obj, "portal_archivist")\n         OMStorageAdapter = portal_archivist.classes.ObjectManagerStorageAdapter\n \n         ref_names = self._getAttributeNamesHandlingSubObjects(obj, repo_clone)\n@@ -415,12 +421,13 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n             if orig_objects is not _marker:\n                 setattr(repo_clone, attr_name, orig_objects)\n \n-        RetainAttributeAnnotationItemsBase.afterRetrieveModifier(self, obj,\n-                                                                 repo_clone,\n-                                                                 preserve)\n+        RetainAttributeAnnotationItemsBase.afterRetrieveModifier(\n+            self, obj, repo_clone, preserve\n+        )\n \n         return [], ref_names, {}\n \n+\n InitializeClass(OMOutsideChildrensModifier)\n \n \n@@ -433,10 +440,9 @@ class OMInsideChildrensModifier(OMBaseModifier):\n     """\n \n     def getOnCloneModifiers(self, obj):\n-        """Removes all childrens and returns them as references.\n-        """\n+        """Removes all childrens and returns them as references."""\n         pers_id, pers_load, inside_refs = self._getOnCloneModifiers(obj)\n-        return pers_id, pers_load, inside_refs, [], \'\'\n+        return pers_id, pers_load, inside_refs, [], ""\n \n     def beforeSaveModifier(self, obj, clone):\n         """Returns all unititialized \'IVersionAwareReference\' objects.\n@@ -451,7 +457,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         if obj is None:\n             return [], [], {}\n \n-        hidhandler = getToolByName(obj, \'portal_historyidhandler\')\n+        hidhandler = getToolByName(obj, "portal_historyidhandler")\n         queryUid = hidhandler.queryUid\n \n         # Inside refs from the original object that have no counterpart\n@@ -473,7 +479,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n             if histid is not None:\n                 orig_histids[histid] = id\n             else:\n-                orig_histids[\'no_history\'+id]=id\n+                orig_histids["no_history" + id] = id\n \n         # (2) evaluate the refs that get replaced anyway\n         for varef in repo_clone.objectValues():\n@@ -482,8 +488,9 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n                 del orig_histids[histid]\n \n         # (3) build the list of adapters to the references to be removed\n-        refs_to_be_deleted = \\\n-            [OMSubObjectAdapter(obj, name) for name in orig_histids.values()]\n+        refs_to_be_deleted = [\n+            OMSubObjectAdapter(obj, name) for name in orig_histids.values()\n+        ]\n \n         # return all attribute names that have something to do with\n         # referencing\n@@ -492,32 +499,29 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         # We copy the ordering annotations from the working copy to\n         # the repo clone, so that we don\'t have inconsistencies between the\n         # objectValues and objectIds.\n-        RetainAttributeAnnotationItemsBase.afterRetrieveModifier(self, obj,\n-                                                                 repo_clone)\n+        RetainAttributeAnnotationItemsBase.afterRetrieveModifier(self, obj, repo_clone)\n \n         return refs_to_be_deleted, ref_names, {}\n \n+\n InitializeClass(OMInsideChildrensModifier)\n \n+\n @implementer(IReferenceAdapter)\n class OMSubObjectAdapter:\n-    """Adapter to an object manager children.\n-    """\n+    """Adapter to an object manager children."""\n \n     def __init__(self, obj, name):\n-        """Initialize the adapter.\n-        """\n+        """Initialize the adapter."""\n         self._obj = obj\n         self._name = name\n \n     def save(self, dict):\n-        """See interface\n-        """\n+        """See interface"""\n         dict[self._name] = self._obj._getOb(self._name)\n \n     def remove(self, permanent=False):\n-        """See interface\n-        """\n+        """See interface"""\n         # XXX do we want there is the ``manage_afterDelete`` hook called?\n         # The decision has to go into the interface documentation.\n         # IM(alecm)O, we should update the catalog if the change is permanent\n@@ -563,22 +567,22 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n \n         # replace the workflow stuff of the repository clone by the\n         # one of the working copy or delete it\n-        if getattr(aq_base(obj), \'review_state\', _marker) is not _marker:\n+        if getattr(aq_base(obj), "review_state", _marker) is not _marker:\n             repo_clone.review_state = obj.review_state\n-        elif (getattr(aq_base(repo_clone), \'review_state\', _marker)\n-              is not _marker):\n+        elif getattr(aq_base(repo_clone), "review_state", _marker) is not _marker:\n             del repo_clone.review_state\n \n-        if getattr(aq_base(obj), \'workflow_history\', _marker) is not _marker:\n+        if getattr(aq_base(obj), "workflow_history", _marker) is not _marker:\n             repo_clone.workflow_history = obj.workflow_history\n-        elif (getattr(aq_base(repo_clone), \'workflow_history\', _marker)\n-              is not _marker):\n+        elif getattr(aq_base(repo_clone), "workflow_history", _marker) is not _marker:\n             del repo_clone.workflow_history\n \n         return [], [], {}\n \n+\n InitializeClass(RetainWorkflowStateAndHistory)\n \n+\n @implementer(ISaveRetrieveModifier)\n class RetainPermissionsSettings:\n     """Standard modifier retaining permissions settings\n@@ -598,17 +602,19 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         # one of the working copy or delete it\n         for key, val in obj.__dict__.items():\n             # Find permission settings\n-            if key.startswith(\'_\') and key.endswith(\'_Permission\'):\n+            if key.startswith("_") and key.endswith("_Permission"):\n                 setattr(repo_clone, key, val)\n \n         return [], [], {}\n \n+\n InitializeClass(RetainPermissionsSettings)\n \n+\n @implementer(ISaveRetrieveModifier)\n class RetainUIDs:\n     """Modifier which ensures uid consistency by retaining the uid from the working copy.  Ensuring\n-       that newly created objects are assigned an appropriate uid is a job for the repository tool.\n+    that newly created objects are assigned an appropriate uid is a job for the repository tool.\n     """\n \n     def beforeSaveModifier(self, obj, clone):\n@@ -619,16 +625,17 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         if obj is None:\n             return [], [], {}\n \n-        #Preserve CMFUid\n-        uid_tool = getToolByName(obj, \'portal_historyidhandler\', None)\n+        # Preserve CMFUid\n+        uid_tool = getToolByName(obj, "portal_historyidhandler", None)\n         if uid_tool is not None:\n             working_uid = uid_tool.queryUid(obj)\n-            anno_tool = getToolByName(obj, \'portal_uidannotation\')\n+            anno_tool = getToolByName(obj, "portal_uidannotation")\n             annotation = anno_tool(repo_clone, uid_tool.UID_ATTRIBUTE_NAME)\n             annotation.setUid(working_uid)\n \n         return [], [], {}\n \n+\n InitializeClass(RetainUIDs)\n \n \n@@ -640,7 +647,7 @@ class SaveFileDataInFileTypeByReference:\n     """\n \n     def getReferencedAttributes(self, obj):\n-        return {\'data\': getattr(aq_base(obj),\'data\', None)}\n+        return {"data": getattr(aq_base(obj), "data", None)}\n \n     def reattachReferencedAttributes(self, obj, attrs_dict):\n \n@@ -651,6 +658,7 @@ def reattachReferencedAttributes(self, obj, attrs_dict):\n \n InitializeClass(SaveFileDataInFileTypeByReference)\n \n+\n @implementer(ICloneModifier, ISaveRetrieveModifier)\n class SkipParentPointers:\n     """Standard modifier to avoid cloning of __parent__ pointers and\n@@ -658,9 +666,8 @@ class SkipParentPointers:\n     """\n \n     def getOnCloneModifiers(self, obj):\n-        """Removes parent pointers and stores a marker\n-        """\n-        parent = getattr(obj, \'__parent__\', _marker)\n+        """Removes parent pointers and stores a marker"""\n+        parent = getattr(obj, "__parent__", _marker)\n         if parent is _marker:\n             return None\n \n@@ -683,10 +690,14 @@ def beforeSaveModifier(self, obj, clone):\n \n     def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         """Install the parent from the working copy"""\n-        if (getattr(repo_clone, \'__parent__\', _marker) is None\n-            and getattr(obj, \'__parent__\', _marker) is not _marker):\n+        if (\n+            getattr(repo_clone, "__parent__", _marker) is None\n+            and getattr(obj, "__parent__", _marker) is not _marker\n+        ):\n             repo_clone.__parent__ = obj.__parent__\n         return [], [], {}\n+\n+\n InitializeClass(SkipParentPointers)\n \n \n@@ -706,29 +717,31 @@ def querySiteManager(self, obj):\n         return registry\n \n     def getOnCloneModifiers(self, obj):\n-        """Removes component registry bases pointers and stores a marker\n-        """\n+        """Removes component registry bases pointers and stores a marker"""\n         registry = self.querySiteManager(obj)\n         if registry is None:\n             return\n \n         component_bases = dict(\n-            registry=dict((id(aq_base(base)), aq_base(base))\n-                          for base in registry.__bases__),\n-            utilities=dict((id(aq_base(base)), aq_base(base))\n-                           for base in registry.utilities.__bases__),\n-            adapters=dict((id(aq_base(base)), aq_base(base))\n-                           for base in registry.adapters.__bases__))\n+            registry={id(aq_base(base)): aq_base(base) for base in registry.__bases__},\n+            utilities={\n+                id(aq_base(base)): aq_base(base)\n+                for base in registry.utilities.__bases__\n+            },\n+            adapters={\n+                id(aq_base(base)): aq_base(base) for base in registry.adapters.__bases__\n+            },\n+        )\n \n         def persistent_id(obj):\n             obj_id = id(aq_base(obj))\n-            for key, bases in six.iteritems(component_bases):\n+            for key, bases in component_bases.items():\n                 if obj_id in bases:\n-                    return \'%s:%s\' % (key, obj_id)\n+                    return f"{key}:{obj_id}"\n             return None\n \n         def persistent_load(obj):\n-            key, base_id = obj.split(\':\')\n+            key, base_id = obj.split(":")\n             return component_bases[key][int(base_id)]\n \n         return persistent_id, persistent_load, [], []\n@@ -747,6 +760,8 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n             obj_sm = obj.getSiteManager()\n             sm.__bases__ = obj_sm.__bases__\n         return [], [], {}\n+\n+\n InitializeClass(SkipRegistryBasesPointers)\n \n \n@@ -765,6 +780,7 @@ def beforeSaveModifier(self, obj, clone):\n \n     def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         from AccessControl import getSecurityManager\n+\n         if getSecurityManager().getUser().getUserName() != "gregweb":\n             return [], [], {}\n \n@@ -781,6 +797,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n \n         return [], [], {}\n \n+\n InitializeClass(SillyDemoRetrieveModifier)\n \n \n@@ -789,40 +806,47 @@ class AbortVersioningOfLargeFilesAndImages(ConditionalTalesModifier):\n     """Raises an error if a file or image attribute stored on the\n     object in a specified field is larger than a fixed default"""\n \n-    field_names = (\'file\', \'image\')\n-    max_size = 26214400 # This represents a 400 element long Pdata list\n+    field_names = ("file", "image")\n+    max_size = 26214400  # This represents a 400 element long Pdata list\n \n-    modifierEditForm = PageTemplateFile(\'www/fieldModifierEditForm.pt\',\n-                                        globals(),\n-                                        __name__=\'modifierEditForm\')\n+    modifierEditForm = PageTemplateFile(\n+        "www/fieldModifierEditForm.pt", globals(), __name__="modifierEditForm"\n+    )\n \n     _condition = Expression("python: portal_type in (\'Image\', \'File\')")\n \n-    def __init__(self, id=\'AbortVersioningOfLargeFilesAndImages\', modifier=None,\n-                 title=\'\'):\n+    def __init__(\n+        self, id="AbortVersioningOfLargeFilesAndImages", modifier=None, title=""\n+    ):\n         self.id = str(id)\n         self.title = str(title)\n-        self.meta_type = \'edmod_%s\' % id\n+        self.meta_type = "edmod_%s" % id\n         self._enabled = False\n \n-    def edit(self, enabled=None, condition=None, title=\'\', field_names=None,\n-             max_size=None, REQUEST=None):\n-        """See IConditionalTalesModifier.\n-        """\n+    def edit(\n+        self,\n+        enabled=None,\n+        condition=None,\n+        title="",\n+        field_names=None,\n+        max_size=None,\n+        REQUEST=None,\n+    ):\n+        """See IConditionalTalesModifier."""\n         if max_size is not None:\n             self.max_size = int(max_size)\n         if field_names is not None:\n-            field_names = tuple(s.strip() for s in field_names.split(\'\\n\') if s)\n+            field_names = tuple(s.strip() for s in field_names.split("\\n") if s)\n             if field_names != self.field_names:\n                 self.field_names = field_names\n         return ConditionalTalesModifier.edit(self, enabled, condition, title)\n \n     def getFieldNames(self):\n         """For the edit form"""\n-        return \'\\n\'.join(self.field_names)\n+        return "\\n".join(self.field_names)\n \n     def getModifier(self):\n-        """We are the modifier, not some silly wrapper. """\n+        """We are the modifier, not some silly wrapper."""\n         return self\n \n     def _getFieldValues(self, obj):\n@@ -835,44 +859,46 @@ def _getFieldValues(self, obj):\n         We used to also have \'annotation\', but that was only for\n         fields stored via Archetypes AnnotationStorage.\n         """\n-        max_size  = self.max_size\n+        max_size = self.max_size\n \n         # Search for fields stored via AttributeStorage\n         for name in self.field_names:\n             val = getattr(obj, name, None)\n             # Skip linked Pdata chains too long for the pickler\n-            if hasattr(aq_base(val), \'getSize\') and callable(val.getSize):\n+            if hasattr(aq_base(val), "getSize") and callable(val.getSize):\n                 size = val.getSize()\n-                if isinstance(size, six.integer_types) and size >= max_size:\n-                    yield \'attribute\', name, val\n+                if isinstance(size, int) and size >= max_size:\n+                    yield "attribute", name, val\n \n     def getOnCloneModifiers(self, obj):\n-        """Detects large file objects and raises an error\n-        """\n+        """Detects large file objects and raises an error"""\n         for storage, name, val in self._getFieldValues(obj):\n             # if we find a file that\'s too big, abort\n             raise FileTooLargeToVersionError\n-        return None # no effect otherwise\n+        return None  # no effect otherwise\n+\n \n InitializeClass(AbortVersioningOfLargeFilesAndImages)\n \n-_empty_marker =[]\n-class LargeFilePlaceHolder(object):\n+_empty_marker = []\n+\n+\n+class LargeFilePlaceHolder:\n     """PlaceHolder for a large object"""\n+\n     @staticmethod\n     def getSize():\n         return sys.maxsize\n \n-@implementer(IConditionalTalesModifier, ICloneModifier,\n-                      ISaveRetrieveModifier)\n+\n+@implementer(IConditionalTalesModifier, ICloneModifier, ISaveRetrieveModifier)\n class SkipVersioningOfLargeFilesAndImages(AbortVersioningOfLargeFilesAndImages):\n     """Replaces any excessively large file and images stored as\n     annotations or attributes on the object with a marker.  On\n     retrieve, the marker will be replaced with the current value.."""\n \n     def getOnCloneModifiers(self, obj):\n-        """Removes large file objects and returns them as references\n-        """\n+        """Removes large file objects and returns them as references"""\n         refs = {}\n         ref_list = []\n         for storage, name, val in self._getFieldValues(obj):\n@@ -880,7 +906,7 @@ def getOnCloneModifiers(self, obj):\n             refs[id(val)] = True\n \n         if not refs:\n-            return None # don\'t do anything\n+            return None  # don\'t do anything\n \n         def persistent_id(obj):\n             return refs.get(id(obj), None)\n@@ -908,6 +934,7 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n                     delattr(repo_clone, name)\n         return [], [], {}\n \n+\n InitializeClass(SkipVersioningOfLargeFilesAndImages)\n \n \n@@ -935,14 +962,14 @@ def _blob_file_classes(self):\n         return tuple(blob_file_classes)\n \n     def getOnCloneModifiers(self, obj):\n-        """Removes z3c.blobfile fields\n-        """\n+        """Removes z3c.blobfile fields"""\n         blob_file_classes = self._blob_file_classes()\n         if not blob_file_classes:\n             return\n \n-        blob_refs = set(id(v) for v in six.itervalues(obj.__dict__)\n-                        if isinstance(v, blob_file_classes))\n+        blob_refs = {\n+            id(v) for v in obj.__dict__.values() if isinstance(v, blob_file_classes)\n+        }\n \n         def persistent_id(obj):\n             if id(aq_base(obj)) in blob_refs:\n@@ -965,148 +992,150 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         if obj is None:\n             return [], [], {}\n \n-        blob_fields = ((k, v) for k, v in six.iteritems(obj.__dict__)\n-                        if isinstance(v, blob_file_classes))\n+        blob_fields = (\n+            (k, v) for k, v in obj.__dict__.items() if isinstance(v, blob_file_classes)\n+        )\n \n         for k, v in blob_fields:\n             setattr(repo_clone, k, v)\n \n         return [], [], {}\n \n+\n InitializeClass(Skip_z3c_blobfile)\n \n-#----------------------------------------------------------------------\n+# ----------------------------------------------------------------------\n # Standard modifier configuration\n-#----------------------------------------------------------------------\n+# ----------------------------------------------------------------------\n \n modifiers = (\n     {\n-        \'id\': \'OMInsideChildrensModifier\',\n-        \'title\': "Modifier for object managers treating children as inside objects.",\n-        \'enabled\': True,\n-        \'condition\': \'python: object and path("object/isPrincipiaFolderish|nothing") and not path("object/@@plone/isStructuralFolder|nothing")\',\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': OMInsideChildrensModifier,\n-        \'form\': manage_OMInsideChildrensModifierAddForm,\n-        \'factory\': manage_addOMInsideChildrensModifier,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "OMInsideChildrensModifier",\n+        "title": "Modifier for object managers treating children as inside objects.",\n+        "enabled": True,\n+        "condition": \'python: object and path("object/isPrincipiaFolderish|nothing") and not path("object/@@plone/isStructuralFolder|nothing")\',\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": OMInsideChildrensModifier,\n+        "form": manage_OMInsideChildrensModifierAddForm,\n+        "factory": manage_addOMInsideChildrensModifier,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'OMOutsideChildrensModifier\',\n-        \'title\': "Modifier for object managers (like standard folders) treating children as outside objects.",\n-        \'enabled\': True,\n-        \'condition\': "python:path(\'object/@@plone/isStructuralFolder|nothing\') or portal_type == \'Folder\'",\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': OMOutsideChildrensModifier,\n-        \'form\': manage_OMOutsideChildrensModifierAddForm,\n-        \'factory\': manage_addOMOutsideChildrensModifier,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "OMOutsideChildrensModifier",\n+        "title": "Modifier for object managers (like standard folders) treating children as outside objects.",\n+        "enabled": True,\n+        "condition": "python:path(\'object/@@plone/isStructuralFolder|nothing\') or portal_type == \'Folder\'",\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": OMOutsideChildrensModifier,\n+        "form": manage_OMOutsideChildrensModifierAddForm,\n+        "factory": manage_addOMOutsideChildrensModifier,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'RetainUIDs\',\n-        \'title\': "Retains the CMF UIDs from the working copy",\n-        \'enabled\': True,\n-        \'wrapper\': ConditionalModifier,\n-        \'modifier\': RetainUIDs,\n-        \'form\': manage_RetainUIDsModifierAddForm,\n-        \'factory\': manage_addRetainUIDs,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "RetainUIDs",\n+        "title": "Retains the CMF UIDs from the working copy",\n+        "enabled": True,\n+        "wrapper": ConditionalModifier,\n+        "modifier": RetainUIDs,\n+        "form": manage_RetainUIDsModifierAddForm,\n+        "factory": manage_addRetainUIDs,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'RetainWorkflowStateAndHistory\',\n-        \'title\': "Retains the working copies workflow state upon retrieval/revertion.",\n-        \'enabled\': True,\n-        \'wrapper\': ConditionalModifier,\n-        \'modifier\': RetainWorkflowStateAndHistory,\n-        \'form\': manage_RetainWorkflowStateAndHistoryModifierAddForm,\n-        \'factory\': manage_addRetainWorkflowStateAndHistory,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "RetainWorkflowStateAndHistory",\n+        "title": "Retains the working copies workflow state upon retrieval/revertion.",\n+        "enabled": True,\n+        "wrapper": ConditionalModifier,\n+        "modifier": RetainWorkflowStateAndHistory,\n+        "form": manage_RetainWorkflowStateAndHistoryModifierAddForm,\n+        "factory": manage_addRetainWorkflowStateAndHistory,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'RetainPermissionsSettings\',\n-        \'title\': "Retains the permission settings upon retrieval/revertion.",\n-        \'enabled\': True,\n-        \'wrapper\': ConditionalModifier,\n-        \'modifier\': RetainPermissionsSettings,\n-        \'form\': manage_RetainPermissionsSettingsAddForm ,\n-        \'factory\': manage_addRetainPermissionsSettings,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "RetainPermissionsSettings",\n+        "title": "Retains the permission settings upon retrieval/revertion.",\n+        "enabled": True,\n+        "wrapper": ConditionalModifier,\n+        "modifier": RetainPermissionsSettings,\n+        "form": manage_RetainPermissionsSettingsAddForm,\n+        "factory": manage_addRetainPermissionsSettings,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'SaveFileDataInFileTypeByReference\',\n-        \'title\': "Let\'s the storage optimize cloning of file data.",\n-        \'enabled\': False,\n-        \'condition\': "python: meta_type==\'Portal File\'",\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': SaveFileDataInFileTypeByReference,\n-        \'form\': manage_SaveFileDataInFileTypeByReferenceModifierAddForm,\n-        \'factory\': manage_addSaveFileDataInFileTypeByReference,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "SaveFileDataInFileTypeByReference",\n+        "title": "Let\'s the storage optimize cloning of file data.",\n+        "enabled": False,\n+        "condition": "python: meta_type==\'Portal File\'",\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": SaveFileDataInFileTypeByReference,\n+        "form": manage_SaveFileDataInFileTypeByReferenceModifierAddForm,\n+        "factory": manage_addSaveFileDataInFileTypeByReference,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'SillyDemoRetrieveModifier\',\n-        \'title\': "Silly retrive modifier for demos only.",\n-        \'enabled\': False,\n-        \'condition\': "python: True",\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': SillyDemoRetrieveModifier,\n-        \'form\': manage_SillyDemoRetrieveModifierAddForm,\n-        \'factory\': manage_addSillyDemoRetrieveModifier,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "SillyDemoRetrieveModifier",\n+        "title": "Silly retrive modifier for demos only.",\n+        "enabled": False,\n+        "condition": "python: True",\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": SillyDemoRetrieveModifier,\n+        "form": manage_SillyDemoRetrieveModifierAddForm,\n+        "factory": manage_addSillyDemoRetrieveModifier,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'SkipParentPointers\',\n-        \'title\': "Skip Saving of Parent Pointers",\n-        \'enabled\': True,\n-        \'condition\': "python: True",\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': SkipParentPointers,\n-        \'form\': manage_SkipParentPointersAddForm,\n-        \'factory\': manage_addSkipParentPointers,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "SkipParentPointers",\n+        "title": "Skip Saving of Parent Pointers",\n+        "enabled": True,\n+        "condition": "python: True",\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": SkipParentPointers,\n+        "form": manage_SkipParentPointersAddForm,\n+        "factory": manage_addSkipParentPointers,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'SkipRegistryBasesPointers\',\n-        \'title\': "Skip Saving of Component Registry Bases",\n-        \'enabled\': True,\n-        \'condition\': "python: True",\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': SkipRegistryBasesPointers,\n-        \'form\': manage_SkipRegistryBasesPointersAddForm,\n-        \'factory\': manage_addSkipRegistryBasesPointers,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "SkipRegistryBasesPointers",\n+        "title": "Skip Saving of Component Registry Bases",\n+        "enabled": True,\n+        "condition": "python: True",\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": SkipRegistryBasesPointers,\n+        "form": manage_SkipRegistryBasesPointersAddForm,\n+        "factory": manage_addSkipRegistryBasesPointers,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'AbortVersioningOfLargeFilesAndImages\',\n-        \'title\': "Abort versioning of objects if file data if it\'s too large",\n-        \'enabled\': True,\n-        \'condition\': "python: portal_type in (\'Image\', \'File\')",\n-        \'wrapper\': AbortVersioningOfLargeFilesAndImages,\n-        \'modifier\': AbortVersioningOfLargeFilesAndImages,\n-        \'form\': manage_AbortVersioningOfLargeFilesAndImagesAddForm,\n-        \'factory\': manage_addAbortVersioningOfLargeFilesAndImages,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "AbortVersioningOfLargeFilesAndImages",\n+        "title": "Abort versioning of objects if file data if it\'s too large",\n+        "enabled": True,\n+        "condition": "python: portal_type in (\'Image\', \'File\')",\n+        "wrapper": AbortVersioningOfLargeFilesAndImages,\n+        "modifier": AbortVersioningOfLargeFilesAndImages,\n+        "form": manage_AbortVersioningOfLargeFilesAndImagesAddForm,\n+        "factory": manage_addAbortVersioningOfLargeFilesAndImages,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'SkipVersioningOfLargeFilesAndImages\',\n-        \'title\': "Skip versioning of objects if file data if it\'s too large",\n-        \'enabled\': False,\n-        \'condition\': "python: portal_type in (\'Image\', \'File\')",\n-        \'wrapper\': SkipVersioningOfLargeFilesAndImages,\n-        \'modifier\': SkipVersioningOfLargeFilesAndImages,\n-        \'form\': manage_SkipVersioningOfLargeFilesAndImagesAddForm,\n-        \'factory\': manage_addSkipVersioningOfLargeFilesAndImages,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "SkipVersioningOfLargeFilesAndImages",\n+        "title": "Skip versioning of objects if file data if it\'s too large",\n+        "enabled": False,\n+        "condition": "python: portal_type in (\'Image\', \'File\')",\n+        "wrapper": SkipVersioningOfLargeFilesAndImages,\n+        "modifier": SkipVersioningOfLargeFilesAndImages,\n+        "form": manage_SkipVersioningOfLargeFilesAndImagesAddForm,\n+        "factory": manage_addSkipVersioningOfLargeFilesAndImages,\n+        "icon": "www/modifier.gif",\n     },\n     {\n-        \'id\': \'Skip_z3c_blobfile\',\n-        \'title\': "Skip storing z3c.blobfile.file.File fields on objects",\n-        \'enabled\': True,\n-        \'condition\': "python:True",\n-        \'wrapper\': ConditionalTalesModifier,\n-        \'modifier\': Skip_z3c_blobfile,\n-        \'form\': manage_Skip_z3c_blobfileAddForm,\n-        \'factory\': manage_addSkip_z3c_blobfile,\n-        \'icon\': \'www/modifier.gif\',\n+        "id": "Skip_z3c_blobfile",\n+        "title": "Skip storing z3c.blobfile.file.File fields on objects",\n+        "enabled": True,\n+        "condition": "python:True",\n+        "wrapper": ConditionalTalesModifier,\n+        "modifier": Skip_z3c_blobfile,\n+        "form": manage_Skip_z3c_blobfileAddForm,\n+        "factory": manage_addSkip_z3c_blobfile,\n+        "icon": "www/modifier.gif",\n     },\n )\ndiff --git a/Products/CMFEditions/StorageMigrationSupport.py b/Products/CMFEditions/StorageMigrationSupport.py\nindex e8f5ad8..7887324 100644\n--- a/Products/CMFEditions/StorageMigrationSupport.py\n+++ b/Products/CMFEditions/StorageMigrationSupport.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2006 Gregoire Weber\n # All Rights Reserved.\n@@ -32,7 +31,8 @@\n import time\n \n \n-logger = logging.getLogger(\'CMFEditions\')\n+logger = logging.getLogger("CMFEditions")\n+\n \n def create(context, type, name):\n     context.invokeFactory(type, name)\n@@ -40,10 +40,12 @@ def create(context, type, name):\n     editMethods[type](obj, version=0)\n     return obj\n \n+\n def edit(obj, version):\n     type = obj.getPortalTypeName()\n     editMethods[type](obj, version)\n \n+\n def editEvent(context, version=0):\n     title = context.Title()\n     desc = context.Description()\n@@ -58,14 +60,19 @@ def editEvent(context, version=0):\n         location = "0: %s event location" % name\n         contact = "0: %s event contact" % name\n     else:\n-        title = "%s%s" % (version, title[1:])\n-        desc = "%s%s" % (version, desc[1:])\n-        location = "%s%s" % (version, location[1:])\n-        contact = "%s%s" % (version, contact[1:])\n+        title = f"{version}{title[1:]}"\n+        desc = f"{version}{desc[1:]}"\n+        location = f"{version}{location[1:]}"\n+        contact = f"{version}{contact[1:]}"\n+\n+    context.update(\n+        title=title,\n+        description=desc,\n+        eventType=eventType,\n+        location=location,\n+        contactName=contact,\n+    )\n \n-    context.update(title=title, description=desc,\n-                   eventType=eventType, location=location,\n-                   contactName=contact)\n \n def editFile(context, version=0):\n     title = context.Title()\n@@ -77,11 +84,12 @@ def editFile(context, version=0):\n         desc = "0: %s file description" % name\n         file = 100 * ("0: %s file body\\n" % name)\n     else:\n-        title = "%s%s" % (version, title[1:])\n-        desc = "%s%s" % (version, desc[1:])\n-        file = 100 * ("%s%s" % (version, ": %s file body\\n" % name))\n+        title = f"{version}{title[1:]}"\n+        desc = f"{version}{desc[1:]}"\n+        file = 100 * ("{}{}".format(version, ": %s file body\\n" % name))\n     context.update(title=title, description=desc, file=file)\n \n+\n def editFolder(context, version=0):\n     title = context.Title()\n     desc = context.Description()\n@@ -89,10 +97,11 @@ def editFolder(context, version=0):\n     if not title:\n         title = "0: %s folder title" % name\n         desc = "0: %s folder description" % name\n-    title = "%s%s" % (version, title[1:])\n-    desc = "%s%s" % (version, desc[1:])\n+    title = f"{version}{title[1:]}"\n+    desc = f"{version}{desc[1:]}"\n     context.folder_edit(title=title, description=desc)\n \n+\n def editImage(context, version=0):\n     title = context.Title()\n     desc = context.Description()\n@@ -100,7 +109,7 @@ def editImage(context, version=0):\n     name = context.getId()\n     if name.endswith(".gif"):\n         name = name[:-4]\n-    filename = "%s_v%s.gif" % (name, version)\n+    filename = f"{name}_v{version}.gif"\n     path = os.path.join(PACKAGE_HOME, "tests", "images", filename)\n     with open(path) as image_handle:\n         image = image_handle.read()\n@@ -108,10 +117,11 @@ def editImage(context, version=0):\n         title = "0: %s image title" % name\n         desc = "0: %s image description" % name\n     else:\n-        title = "%s%s" % (version, title[1:])\n-        desc = "%s%s" % (version, desc[1:])\n+        title = f"{version}{title[1:]}"\n+        desc = f"{version}{desc[1:]}"\n     context.update(title=title, description=desc, image=image)\n \n+\n def editLink(context, version=0):\n     title = context.Title()\n     desc = context.Description()\n@@ -122,11 +132,12 @@ def editLink(context, version=0):\n         desc = "0: %s link description" % name\n         remoteUrl = "http://www.plone.org/#%s_v0" % name\n     else:\n-        title = "%s%s" % (version, title[1:])\n-        desc = "%s%s" % (version, desc[1:])\n-        remoteUrl = "%s%s" % (remoteUrl[:-1], version)\n+        title = f"{version}{title[1:]}"\n+        desc = f"{version}{desc[1:]}"\n+        remoteUrl = f"{remoteUrl[:-1]}{version}"\n     context.update(title=title, description=desc, remoteUrl=remoteUrl)\n \n+\n def editNewsItem(context, version=0):\n     title = context.Title()\n     desc = context.Description()\n@@ -137,11 +148,12 @@ def editNewsItem(context, version=0):\n         desc = "0: %s news item description" % name\n         text = "0: %s news item body" % name\n     else:\n-        title = "%s%s" % (version, title[1:])\n-        desc = "%s%s" % (version, desc[1:])\n-        text = "%s%s" % (version, text[1:])\n+        title = f"{version}{title[1:]}"\n+        desc = f"{version}{desc[1:]}"\n+        text = f"{version}{text[1:]}"\n     context.update(title=title, description=desc, text=text)\n \n+\n def editDocument(context, version=0):\n     title = context.Title()\n     desc = context.Description()\n@@ -152,15 +164,16 @@ def editDocument(context, version=0):\n         desc = "0: %s document description" % name\n         text = "0: %s document body" % name\n     else:\n-        title = "%s%s" % (version, title[1:])\n-        desc = "%s%s" % (version, desc[1:])\n-        text = "%s%s" % (version, text[1:])\n+        title = f"{version}{title[1:]}"\n+        desc = f"{version}{desc[1:]}"\n+        text = f"{version}{text[1:]}"\n     context.update(title=title, description=desc, text=text)\n \n \n def editTopic(context, version=0):\n     pass\n \n+\n editMethods = {\n     "Event": editEvent,\n     "File": editFile,\n@@ -183,16 +196,19 @@ def editTopic(context, version=0):\n     "topics": ("Folder", "Topic", 0, 0),\n }\n \n+\n def createTestHierarchy(context):\n     startTime = time.time()\n     repo = getToolByName(context, "portal_repository")\n-    testRoot = create(context,  "Folder", "CMFEditionsTestHierarchy")\n+    testRoot = create(context, "Folder", "CMFEditionsTestHierarchy")\n     nbrOfObjects = 0\n     nbrOfEdits = 0\n     nbrOfSaves = 0\n     for name, type in hierarchy.items():\n-        logger.log(logging.INFO, "createTestHierarchy: creating container %s(%s)" \\\n-            % (name, type[0]))\n+        logger.log(\n+            logging.INFO,\n+            f"createTestHierarchy: creating container {name}({type[0]})",\n+        )\n         folder = create(testRoot, type[0], name)\n         nbrOfObjects += 1\n         logger.log(logging.INFO, "createTestHierarchy: save #0")\n@@ -205,9 +221,11 @@ def createTestHierarchy(context):\n                 ext = ""\n \n             # create and save\n-            objName = name[:-1]+str(i+1)+ext\n-            logger.log(logging.INFO, "createTestHierarchy: creating %s(%s)" \\\n-                % (objName, type[1]))\n+            objName = name[:-1] + str(i + 1) + ext\n+            logger.log(\n+                logging.INFO,\n+                f"createTestHierarchy: creating {objName}({type[1]})",\n+            )\n             obj = create(folder, type[1], objName)\n             nbrOfObjects += 1\n             logger.log(logging.INFO, "createTestHierarchy: save #0")\n@@ -223,7 +241,7 @@ def createTestHierarchy(context):\n                 repo.save(obj, comment="save #%s" % j)\n                 nbrOfSaves += 1\n \n-                vers = j + i*(type[3]-1)\n+                vers = j + i * (type[3] - 1)\n                 logger.log(logging.INFO, "createTestHierarchy: editing parent")\n                 edit(folder, vers)\n                 nbrOfEdits += 1\n@@ -232,8 +250,10 @@ def createTestHierarchy(context):\n                 nbrOfSaves += 1\n \n     totalTime = time.time() - startTime\n-    logger.log(logging.INFO,\n-        "createTestHierarchy: created %s objects, edited them %s times and saved %s versions in total in %.1f seconds" \\\n-        % (nbrOfObjects, nbrOfEdits, nbrOfSaves, round(totalTime, 1)))\n+    logger.log(\n+        logging.INFO,\n+        "createTestHierarchy: created %s objects, edited them %s times and saved %s versions in total in %.1f seconds"\n+        % (nbrOfObjects, nbrOfEdits, nbrOfSaves, round(totalTime, 1)),\n+    )\n \n     return testRoot\ndiff --git a/Products/CMFEditions/UniqueIdHandlerTool.py b/Products/CMFEditions/UniqueIdHandlerTool.py\nindex 483ef51..4b16e80 100644\n--- a/Products/CMFEditions/UniqueIdHandlerTool.py\n+++ b/Products/CMFEditions/UniqueIdHandlerTool.py\n@@ -1,9 +1,9 @@\n from zope.deferredimport import deprecated\n \n \n-deprecated("UniqueIdHandlerTool has been removed; "\n+deprecated(\n+    "UniqueIdHandlerTool has been removed; "\n     "use Products.CMFEditions.historyidhandlertool.HistoryIdHandlerTool or "\n     "Products.CMFUid.UniqueIdHandlerTool.UniqueIdHandlerTool",\n-    UniqueIdHandlerTool=(\n-        \'Products.CMFUid.UniqueIdHandlerTool:UniqueIdHandlerTool\'),\n-    )\n+    UniqueIdHandlerTool=("Products.CMFUid.UniqueIdHandlerTool:UniqueIdHandlerTool"),\n+)\ndiff --git a/Products/CMFEditions/VersionPolicies.py b/Products/CMFEditions/VersionPolicies.py\nindex de1c7a3..ac5da49 100644\n--- a/Products/CMFEditions/VersionPolicies.py\n+++ b/Products/CMFEditions/VersionPolicies.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alec Mitchell\n # All Rights Reserved.\n@@ -39,7 +38,8 @@ def __init__(self, obj_id, title, **kw):\n         self.id = obj_id\n         self.title = title\n \n-    security.declarePublic(\'Title\')\n+    security.declarePublic("Title")\n+\n     def Title(self):\n         return self.title\n \n@@ -61,4 +61,5 @@ class ATVersionOnEditPolicy(VersionPolicy):\n     Most importantly: if a policy with this id is enabled for a portal_type,\n     no matter which class is behind it, a new version is stored on edit.\n     """\n+\n     pass\ndiff --git a/Products/CMFEditions/ZVCStorageTool.py b/Products/CMFEditions/ZVCStorageTool.py\nindex b83aaa5..0909617 100644\n--- a/Products/CMFEditions/ZVCStorageTool.py\n+++ b/Products/CMFEditions/ZVCStorageTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005, 2006 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -28,8 +27,14 @@\n from AccessControl.class_init import InitializeClass\n from BTrees.IOBTree import IOBTree\n from BTrees.OOBTree import OOBTree\n+from io import BytesIO\n from OFS.SimpleItem import SimpleItem\n from Persistence import Persistent\n+from pickle import dumps\n+from pickle import HIGHEST_PROTOCOL\n+from pickle import loads\n+from pickle import Pickler\n+from pickle import Unpickler\n from Products.CMFCore.permissions import ManagePortal\n from Products.CMFCore.utils import getToolByName\n from Products.CMFCore.utils import UniqueObject\n@@ -50,12 +55,6 @@\n from Products.ZopeVersionControl.EventLog import LogEntry\n from Products.ZopeVersionControl.Utility import VersionControlError\n from Products.ZopeVersionControl.ZopeRepository import ZopeRepository\n-from six import BytesIO\n-from six.moves.cPickle import dumps\n-from six.moves.cPickle import HIGHEST_PROTOCOL\n-from six.moves.cPickle import loads\n-from six.moves.cPickle import Pickler\n-from six.moves.cPickle import Unpickler\n from zope.interface import implementer\n \n import logging\n@@ -63,7 +62,8 @@\n import types\n \n \n-logger = logging.getLogger(\'CMFEditions\')\n+logger = logging.getLogger("CMFEditions")\n+\n \n def deepCopy(obj):\n     stream = BytesIO()\n@@ -73,9 +73,9 @@ def deepCopy(obj):\n     u = Unpickler(stream)\n     return u.load()\n \n+\n def getSize(obj):\n-    """Calculate the size as cheap as possible\n-    """\n+    """Calculate the size as cheap as possible"""\n     # Try the cheap variants first.\n     # Actually the checks ensure the code never fails but beeing sure\n     # is better.\n@@ -83,7 +83,7 @@ def getSize(obj):\n         # check if to return zero (length is zero)\n         if len(obj) == 0:\n             return 0\n-    except:\n+    except:  # noqa E722\n         pass\n \n     try:\n@@ -92,14 +92,14 @@ def getSize(obj):\n             size = obj.getSize()\n             if size is not None:\n                 return size\n-    except:\n+    except:  # noqa E722\n         pass\n \n     try:\n         # string\n         if isinstance(obj, types.StringTypes):\n             return len(obj)\n-    except:\n+    except:  # noqa E722\n         pass\n \n     try:\n@@ -111,7 +111,7 @@ def getSize(obj):\n             size = obj.tell()\n             obj.seek(currentPos)\n             return size\n-    except:\n+    except:  # noqa E722\n         pass\n \n     try:\n@@ -120,16 +120,17 @@ def getSize(obj):\n         p = Pickler(stream, 1)\n         p.dump(obj)\n         size = stream.tell()\n-    except:\n+    except:  # noqa E722\n         size = None\n \n     return size\n \n \n @implementer(\n-        IPurgeSupport,\n-        IStorage,\n-        IStorageTool,)\n+    IPurgeSupport,\n+    IStorage,\n+    IStorageTool,\n+)\n class ZVCStorageTool(UniqueObject, SimpleItem):\n     """Zope Version Control Based Version Storage\n \n@@ -151,16 +152,17 @@ class ZVCStorageTool(UniqueObject, SimpleItem):\n       objects.\n     """\n \n-    id = \'portal_historiesstorage\'\n-    alternative_id = \'portal_zvcstorage\'\n+    id = "portal_historiesstorage"\n+    alternative_id = "portal_zvcstorage"\n \n-    meta_type = \'CMFEditions Portal ZVC based Histories Storage Tool\'\n+    meta_type = "CMFEditions Portal ZVC based Histories Storage Tool"\n \n-    storageStatistics = PageTemplateFile(\'www/storageStatistics.pt\',\n-                                         globals(),\n-                                         __name__=\'modifierEditForm\')\n-    manage_options = ({\'label\' : \'Statistics (may take time)\', \'action\' : \'storageStatistics\'}, ) \\\n-                     + SimpleItem.manage_options[:]\n+    storageStatistics = PageTemplateFile(\n+        "www/storageStatistics.pt", globals(), __name__="modifierEditForm"\n+    )\n+    manage_options = (\n+        {"label": "Statistics (may take time)", "action": "storageStatistics"},\n+    ) + SimpleItem.manage_options[:]\n \n     # make exceptions available trough the tool\n     StorageError = StorageError\n@@ -179,10 +181,10 @@ class ZVCStorageTool(UniqueObject, SimpleItem):\n     # methods implementing IStorage\n     # -------------------------------------------------------------------\n \n-    security.declarePrivate(\'isRegistered\')\n+    security.declarePrivate("isRegistered")\n+\n     def isRegistered(self, history_id):\n-        """See IStorage.\n-        """\n+        """See IStorage."""\n         # Do not wake up the ZODB (aka write to it) if there wasn\'t any\n         # version saved yet.\n         shadow_storage = self._getShadowStorage(autoAdd=False)\n@@ -190,10 +192,10 @@ def isRegistered(self, history_id):\n             return False\n         return shadow_storage.isRegistered(history_id)\n \n-    security.declarePrivate(\'register\')\n+    security.declarePrivate("register")\n+\n     def register(self, history_id, object, referenced_data={}, metadata=None):\n-        """See IStorage.\n-        """\n+        """See IStorage."""\n         # check if already registered\n         if self.isRegistered(history_id):\n             return\n@@ -202,24 +204,25 @@ def register(self, history_id, object, referenced_data={}, metadata=None):\n         shadowInfo = {"vc_info": None}\n         zvc_method = self._getZVCRepo().applyVersionControl\n         try:\n-            return self._applyOrCheckin(zvc_method, history_id, shadowInfo,\n-                                        object, referenced_data, metadata)\n+            return self._applyOrCheckin(\n+                zvc_method, history_id, shadowInfo, object, referenced_data, metadata\n+            )\n         except VersionControlError:\n             raise StorageRegisterError(\n                 "Registering the object with history id \'%s\' failed. "\n-                "The underlying storage implementation reported an error."\n-                % history_id)\n+                "The underlying storage implementation reported an error." % history_id\n+            )\n+\n+    security.declarePrivate("save")\n \n-    security.declarePrivate(\'save\')\n     def save(self, history_id, object, referenced_data={}, metadata=None):\n-        """See IStorage.\n-        """\n+        """See IStorage."""\n         # check if already registered\n         if not self.isRegistered(history_id):\n             raise StorageUnregisteredError(\n                 "Saving an unregistered object is not possible. "\n-                "Register the object with history id \'%s\' first. "\n-                % history_id)\n+                "Register the object with history id \'%s\' first. " % history_id\n+            )\n \n         # retrieve the ZVC info from the youngest version\n         history = self._getShadowHistory(history_id, autoAdd=True)\n@@ -227,35 +230,37 @@ def save(self, history_id, object, referenced_data={}, metadata=None):\n \n         zvc_method = self._getZVCRepo().checkinResource\n         try:\n-            return self._applyOrCheckin(zvc_method, history_id, shadowInfo,\n-                                        object, referenced_data, metadata)\n+            return self._applyOrCheckin(\n+                zvc_method, history_id, shadowInfo, object, referenced_data, metadata\n+            )\n         except VersionControlError:\n             # this shouldn\'t really happen\n             raise StorageSaveError(\n                 "Saving the object with history id \'%s\' failed. "\n-                "The underlying storage implementation reported an error."\n-                % history_id)\n+                "The underlying storage implementation reported an error." % history_id\n+            )\n \n-    security.declarePrivate(\'retrieve\')\n-    def retrieve(self, history_id, selector=None,\n-                 countPurged=True, substitute=True):\n-        """See ``IStorage`` and Comments in ``IPurgePolicy``\n-        """\n+    security.declarePrivate("retrieve")\n+\n+    def retrieve(self, history_id, selector=None, countPurged=True, substitute=True):\n+        """See ``IStorage`` and Comments in ``IPurgePolicy``"""\n         zvc_repo = self._getZVCRepo()\n-        zvc_histid, zvc_selector = \\\n-            self._getZVCAccessInfo(history_id, selector, countPurged)\n+        zvc_histid, zvc_selector = self._getZVCAccessInfo(\n+            history_id, selector, countPurged\n+        )\n \n         if zvc_histid is None:\n             raise StorageRetrieveError(\n                 "Retrieving version \'%s\' of object with history id \'%s\' "\n                 "failed. A history with the given history id does not exist."\n-                % (selector, history_id))\n+                % (selector, history_id)\n+            )\n \n         if zvc_selector is None:\n             raise StorageRetrieveError(\n                 "Retrieving version \'%s\' of object with history id \'%s\' "\n-                "failed. The version does not exist."\n-                % (selector, history_id))\n+                "failed. The version does not exist." % (selector, history_id)\n+            )\n \n         # retrieve the object\n         try:\n@@ -265,7 +270,8 @@ def retrieve(self, history_id, selector=None,\n             raise StorageRetrieveError(\n                 "Retrieving version \'%s\' of object with history id \'%s\' "\n                 "failed. The underlying storage implementation reported "\n-                "an error." % (selector, history_id))\n+                "an error." % (selector, history_id)\n+            )\n \n         # retrieve metadata\n         # TODO: read this from the shadow storage directly\n@@ -275,7 +281,7 @@ def retrieve(self, history_id, selector=None,\n         object = zvc_obj.getWrappedObject()\n         # Get referenced data from shadow history\n         history = self._getShadowHistory(history_id)\n-        referenced_data = history.retrieve(selector).get(\'referenced_data\', {})\n+        referenced_data = history.retrieve(selector).get("referenced_data", {})\n         data = VersionData(object, referenced_data, metadata)\n \n         # check if retrieved a replacement for a removed object and\n@@ -284,49 +290,50 @@ def retrieve(self, history_id, selector=None,\n             # delegate retrieving to purge policy if one is available\n             # if none is available just return the replacement for the\n             # removed object\n-            policy = getToolByName(self, \'portal_purgepolicy\', None)\n+            policy = getToolByName(self, "portal_purgepolicy", None)\n             if policy is not None:\n-                data = policy.retrieveSubstitute(history_id, selector,\n-                                                 default=data)\n+                data = policy.retrieveSubstitute(history_id, selector, default=data)\n         return data\n \n-    security.declarePrivate(\'getHistory\')\n+    security.declarePrivate("getHistory")\n+\n     def getHistory(self, history_id, countPurged=True, substitute=True):\n-        """See IStorage.\n-        """\n+        """See IStorage."""\n         return LazyHistory(self, history_id, countPurged, substitute)\n \n-    security.declarePrivate(\'getModificationDate\')\n-    def getModificationDate(self, history_id, selector=None,\n-                            countPurged=True, substitute=True):\n-        """See IStorage.\n-        """\n+    security.declarePrivate("getModificationDate")\n+\n+    def getModificationDate(\n+        self, history_id, selector=None, countPurged=True, substitute=True\n+    ):\n+        """See IStorage."""\n         vdata = self.retrieve(history_id, selector, countPurged, substitute)\n         return vdata.object.object.modified()\n \n-\n     # -------------------------------------------------------------------\n     # methods implementing IPurgeSupport\n     # -------------------------------------------------------------------\n \n-    security.declarePrivate(\'purge\')\n+    security.declarePrivate("purge")\n+\n     def purge(self, history_id, selector, metadata={}, countPurged=True):\n-        """See ``IPurgeSupport``\n-        """\n+        """See ``IPurgeSupport``"""\n         zvc_repo = self._getZVCRepo()\n-        zvc_histid, zvc_selector = \\\n-            self._getZVCAccessInfo(history_id, selector, countPurged)\n+        zvc_histid, zvc_selector = self._getZVCAccessInfo(\n+            history_id, selector, countPurged\n+        )\n         if zvc_histid is None:\n             raise StoragePurgeError(\n                 "Purging version \'%s\' of object with history id \'%s\' "\n                 "failed. A history with the given history id does not exist."\n-                % (selector, history_id))\n+                % (selector, history_id)\n+            )\n \n         if zvc_selector is None:\n             raise StoragePurgeError(\n                 "Purging version \'%s\' of object with history id \'%s\' "\n-                "failed. The version does not exist."\n-                % (selector, history_id))\n+                "failed. The version does not exist." % (selector, history_id)\n+            )\n \n         # digging into ZVC internals:\n         # Get a reference to the version stored in the ZVC history storage\n@@ -357,19 +364,18 @@ def purge(self, history_id, selector, metadata={}, countPurged=True):\n             logEntry = self._retrieveZVCLogEntry(zvc_histid, zvc_selector)\n             logEntry.message = self._encodeMetadata(metadata)\n \n-\n     # -------------------------------------------------------------------\n     # private helper methods\n     # -------------------------------------------------------------------\n \n-    def _applyOrCheckin(self, zvc_method, history_id, shadowInfo,\n-                        object, referenced_data, metadata):\n-        """Just centralizing similar code.\n-        """\n+    def _applyOrCheckin(\n+        self, zvc_method, history_id, shadowInfo, object, referenced_data, metadata\n+    ):\n+        """Just centralizing similar code."""\n         # delegate the decision if and what to purge to the purge policy\n         # tool if one exists. If the call returns ``False`` do not save\n         # or register the current version.\n-        policy = getToolByName(self, \'portal_purgepolicy\', None)\n+        policy = getToolByName(self, "portal_purgepolicy", None)\n         if policy is not None:\n             if not policy.beforeSaveHook(history_id, object, metadata):\n                 # returning None signalizes that the version wasn\'t saved\n@@ -387,8 +393,7 @@ def _applyOrCheckin(self, zvc_method, history_id, shadowInfo,\n         #   (selector=None).\n         # - Wrap the object, the referenced data and metadata\n         vc_info = self._getVcInfo(object, shadowInfo)\n-        zvc_obj = ZVCAwareWrapper(object, metadata,\n-                                  vc_info)\n+        zvc_obj = ZVCAwareWrapper(object, metadata, vc_info)\n         message = self._encodeMetadata(metadata)\n \n         # call appropriate ZVC method\n@@ -415,10 +420,11 @@ def _getShadowStorage(self, autoAdd=True):\n             self._shadowStorage = ShadowStorage()\n         return self._shadowStorage\n \n-    security.declarePrivate(\'getHistoryMetadata\')\n+    security.declarePrivate("getHistoryMetadata")\n+\n     def getHistoryMetadata(self, history_id):\n-        """ Return the metadata blob from ShadowHistory for presenting\n-            summary information, etc.\n+        """Return the metadata blob from ShadowHistory for presenting\n+        summary information, etc.\n         """\n         if history_id is None:\n             return []\n@@ -428,8 +434,7 @@ def getHistoryMetadata(self, history_id):\n         return hist\n \n     def _getShadowHistory(self, history_id, autoAdd=False):\n-        """Returns a History from the Shadow Storage\n-        """\n+        """Returns a History from the Shadow Storage"""\n         return self._getShadowStorage().getHistory(history_id, autoAdd)\n \n     def _getZVCRepo(self):\n@@ -438,7 +443,7 @@ def _getZVCRepo(self):\n         Instantiates one with the first call.\n         """\n         if self.zvc_repo is None:\n-            self.zvc_repo = ZopeRepository(\'repo\', \'ZVC Storage\')\n+            self.zvc_repo = ZopeRepository("repo", "ZVC Storage")\n         return self.zvc_repo\n \n     def _getZVCAccessInfo(self, history_id, selector, countPurged):\n@@ -464,8 +469,7 @@ def _getZVCAccessInfo(self, history_id, selector, countPurged):\n         return zvc_hid, zvc_vid\n \n     def _getVcInfo(self, obj, shadowInfo, set_checked_in=False):\n-        """Recalls ZVC Related Informations and Attaches them to the Object\n-        """\n+        """Recalls ZVC Related Informations and Attaches them to the Object"""\n         vc_info = deepCopy(shadowInfo["vc_info"])\n         if vc_info is None:\n             return None\n@@ -498,13 +502,18 @@ def _retrieveZVCLogEntry(self, zvc_histid, zvc_selector):\n         zvc_repo = self._getZVCRepo()\n         log = zvc_repo.getVersionHistory(zvc_histid).getLogEntries()\n         checkin = LogEntry.ACTION_CHECKIN\n-        entries = [e for e in log if e.version_id==zvc_selector and e.action==checkin]\n+        entries = [\n+            e for e in log if e.version_id == zvc_selector and e.action == checkin\n+        ]\n \n         # just make a log entry if something wrong happened\n         if len(entries) != 1:\n-            logger.log(logging.INFO, "CMFEditions ASSERT:"\n-                     "Uups, an object has been stored %s times with the same "\n-                     "history \'%s\'!!!" % (len(entries), zvc_selector))\n+            logger.log(\n+                logging.INFO,\n+                "CMFEditions ASSERT:"\n+                "Uups, an object has been stored %s times with the same "\n+                "history \'%s\'!!!" % (len(entries), zvc_selector),\n+            )\n \n         return entries[0]\n \n@@ -513,18 +522,17 @@ def _encodeMetadata(self, metadata):\n         #    - first line with trailing \\x00: comment or empty comment\n         #    - then: pickled metadata (incl. comment)\n         try:\n-            comment = metadata[\'sys_metadata\'][\'comment\']\n+            comment = metadata["sys_metadata"]["comment"]\n             comment = dumps(comment)\n         except KeyError:\n-            comment = \'\'\n-        return b\'\\x00\\n\'.join((comment, dumps(metadata, HIGHEST_PROTOCOL)))\n+            comment = ""\n+        return b"\\x00\\n".join((comment, dumps(metadata, HIGHEST_PROTOCOL)))\n \n     def _retrieveMetadataFromZVC(self, zvc_histid, zvc_selector):\n         logEntry = self._retrieveZVCLogEntry(zvc_histid, zvc_selector)\n-        metadata = loads(logEntry.message.split(b\'\\x00\\n\', 1)[1])\n+        metadata = loads(logEntry.message.split(b"\\x00\\n", 1)[1])\n         return metadata\n \n-\n     # -------------------------------------------------------------------\n     # Migration Support\n     #\n@@ -532,37 +540,47 @@ def _retrieveMetadataFromZVC(self, zvc_histid, zvc_selector):\n     # -------------------------------------------------------------------\n \n     def _is10alpha3Layout(self):\n-        """Returns True if Storage is of 1.0alpha3 layout\n-        """\n+        """Returns True if Storage is of 1.0alpha3 layout"""\n         return getattr(self, "_history_id_mapping", None) is not None\n \n     def migrateStorage(self):\n-        """Migrate the Storage to Newest Layout\n-        """\n+        """Migrate the Storage to Newest Layout"""\n         # check if already done\n         if not self._is10alpha3Layout():\n-            logger.log(logging.INFO, "CMFEditions storage migration:"\n-                "Storage already migrated.")\n+            logger.log(\n+                logging.INFO,\n+                "CMFEditions storage migration:" "Storage already migrated.",\n+            )\n             return None\n \n         startTime = time.time()\n-        logger.log(logging.INFO, "CMFEditions storage migration:"\n-            "started migrating the whole storage")\n+        logger.log(\n+            logging.INFO,\n+            "CMFEditions storage migration:" "started migrating the whole storage",\n+        )\n         from Products.ZopeVersionControl.Utility import VersionInfo\n \n         # build reverse mapping: zvc history id --> CMFEditions history id\n-        logger.log(logging.INFO, "CMFEditions storage migration:"\n-            "preparing history mapping CMFEditions <--> ZVC")\n+        logger.log(\n+            logging.INFO,\n+            "CMFEditions storage migration:"\n+            "preparing history mapping CMFEditions <--> ZVC",\n+        )\n         hidMapping = self._history_id_mapping\n         hidReverseMapping = {}\n         for hid, zvcHid in hidMapping.items():\n             hidReverseMapping[zvcHid.history_id] = hid\n-            logger.log(logging.INFO, "CMFEditions storage migration:"\n-                " %6i <--> %s" % (hid, zvcHid.history_id))\n+            logger.log(\n+                logging.INFO,\n+                "CMFEditions storage migration:"\n+                " %6i <--> %s" % (hid, zvcHid.history_id),\n+            )\n \n         # iterate over all histories\n-        logger.log(logging.INFO, "CMFEditions storage migration:"\n-            "iterating over all histories:")\n+        logger.log(\n+            logging.INFO,\n+            "CMFEditions storage migration:" "iterating over all histories:",\n+        )\n         nbrOfMigratedHistories = 0\n         nbrOfMigratedVersions = 0\n         repo = self._getZVCRepo()\n@@ -571,9 +589,12 @@ def migrateStorage(self):\n             zvcVersionIds = zvcHistory.getVersionIds()\n             history_id = hidReverseMapping[zvcHid]\n             history = self._getShadowHistory(history_id, autoAdd=True)\n-            logger.log(logging.INFO, "CMFEditions storage migration:"\n+            logger.log(\n+                logging.INFO,\n+                "CMFEditions storage migration:"\n                 " migrating %s versions of history %s (ZVC: %s)"\n-                % (len(zvcVersionIds), history_id, zvcHid))\n+                % (len(zvcVersionIds), history_id, zvcHid),\n+            )\n             nbrOfMigratedHistories += 1\n \n             # iterate over all versions\n@@ -600,24 +621,35 @@ def migrateStorage(self):\n                 }\n \n                 # save metadata in shadow history\n-                logger.log(logging.INFO, "CMFEditions storage migration:"\n-                    " migrating version %s:" % (int(zvcVid)-1))\n+                logger.log(\n+                    logging.INFO,\n+                    "CMFEditions storage migration:"\n+                    " migrating version %s:" % (int(zvcVid) - 1),\n+                )\n                 history.save(shadowInfo)\n \n                 app_metadata = metadata.get("app_metadata", {})\n                 if app_metadata:\n-                    logger.log(logging.INFO, "CMFEditions storage migration:"\n-                        " application metadata:")\n+                    logger.log(\n+                        logging.INFO,\n+                        "CMFEditions storage migration:" " application metadata:",\n+                    )\n                     for item in app_metadata.items():\n-                        logger.log(logging.INFO,\n-                            "CMFEditions storage migration: %s = %s" % item)\n+                        logger.log(\n+                            logging.INFO,\n+                            "CMFEditions storage migration: %s = %s" % item,\n+                        )\n                 sys_metadata = metadata.get("sys_metadata", {})\n                 if sys_metadata:\n-                    logger.log(logging.INFO, "CMFEditions storage migration:"\n-                        " system metadata:")\n+                    logger.log(\n+                        logging.INFO,\n+                        "CMFEditions storage migration:" " system metadata:",\n+                    )\n                     for item in sys_metadata.items():\n-                        logger.log(logging.INFO,\n-                            "CMFEditions storage migration: %s = %s" % item)\n+                        logger.log(\n+                            logging.INFO,\n+                            "CMFEditions storage migration: %s = %s" % item,\n+                        )\n                 nbrOfMigratedVersions += 1\n \n         # delete the old metadata\n@@ -625,9 +657,12 @@ def migrateStorage(self):\n \n         # log a summary\n         totalTime = round(time.time() - startTime, 2)\n-        logger.log(logging.INFO, "CMFEditions storage migration:"\n+        logger.log(\n+            logging.INFO,\n+            "CMFEditions storage migration:"\n             "migrated %s histories and a total of %s versions in %.2f seconds"\n-            % (nbrOfMigratedHistories, nbrOfMigratedVersions, totalTime))\n+            % (nbrOfMigratedHistories, nbrOfMigratedVersions, totalTime),\n+        )\n \n         # XXX have to add purge policy\n \n@@ -637,10 +672,10 @@ def migrateStorage(self):\n     # ZMI methods\n     # -------------------------------------------------------------------\n \n-    security.declareProtected(ManagePortal, \'zmi_getStorageStatistics\')\n+    security.declareProtected(ManagePortal, "zmi_getStorageStatistics")\n+\n     def zmi_getStorageStatistics(self):\n-        """\n-        """\n+        """ """\n         startTime = time.time()\n         # get all history ids (incl. such that were deleted in the portal)\n         storage = self._getShadowStorage(autoAdd=False)\n@@ -672,7 +707,7 @@ def zmi_getStorageStatistics(self):\n                 url = None\n                 object_ = self.retrieve(hid).object\n                 if isinstance(object_, Removed):\n-                    portal_type = \'Removed\'\n+                    portal_type = "Removed"\n                 else:\n                     portal_type = object_.object.getPortalTypeName()\n             histData = {\n@@ -700,31 +735,33 @@ def zmi_getStorageStatistics(self):\n                 deleted.append(histData)\n                 deletedHistories += 1\n                 deletedVersions += histData["length"]\n-                deletedSize += 0 # TODO\n+                deletedSize += 0  # TODO\n             else:\n                 existing.append(histData)\n                 existingHistories += 1\n                 existingVersions += histData["length"]\n-                existingSize += 0 # TODO\n+                existingSize += 0  # TODO\n \n         processingTime = "%.2f" % round(time.time() - startTime, 2)\n-        histories = existingHistories+deletedHistories\n-        versions = existingVersions+deletedVersions\n+        histories = existingHistories + deletedHistories\n+        versions = existingVersions + deletedVersions\n \n         if histories:\n-            totalAverage = "%.1f" % round(float(versions)/histories, 1)\n+            totalAverage = "%.1f" % round(float(versions) / histories, 1)\n         else:\n             totalAverage = "n/a"\n \n         if existingHistories:\n-            existingAverage = "%.1f" % \\\n-                round(float(existingVersions)/existingHistories, 1)\n+            existingAverage = "%.1f" % round(\n+                float(existingVersions) / existingHistories, 1\n+            )\n         else:\n             existingAverage = "n/a"\n \n         if deletedHistories:\n-            deletedAverage = "%.1f" % \\\n-                round(float(deletedVersions)/deletedHistories, 1)\n+            deletedAverage = "%.1f" % round(\n+                float(deletedVersions) / deletedHistories, 1\n+            )\n         else:\n             deletedAverage = "n/a"\n \n@@ -742,9 +779,10 @@ def zmi_getStorageStatistics(self):\n                 "deletedHistories": deletedHistories,\n                 "deletedVersions": deletedVersions,\n                 "deletedAverage": deletedAverage,\n-            }\n+            },\n         }\n \n+\n InitializeClass(ZVCStorageTool)\n \n \n@@ -753,6 +791,7 @@ class ShadowStorage(Persistent):\n \n     Only cares about containerish operations.\n     """\n+\n     def __init__(self):\n         # Using an OOBtree to allow history ids of any type. The type\n         # of the history ids highly depends on the unique id tool which\n@@ -760,8 +799,7 @@ def __init__(self):\n         self._storage = OOBTree()\n \n     def isRegistered(self, history_id):\n-        """Returns True if a History With the Given History id Exists\n-        """\n+        """Returns True if a History With the Given History id Exists"""\n         if history_id is None:\n             return False\n         return history_id in self._storage\n@@ -779,12 +817,13 @@ def getHistory(self, history_id, autoAdd=False):\n             self._storage[history_id] = ShadowHistory()\n         return self._storage.get(history_id, None)\n \n+\n InitializeClass(ShadowStorage)\n \n \n class ShadowHistory(Persistent):\n-    """Purge Aware History for Storage Related Metadata\n-    """\n+    """Purge Aware History for Storage Related Metadata"""\n+\n     security = ClassSecurityInfo()\n \n     def __init__(self):\n@@ -809,11 +848,11 @@ def save(self, data):\n         version_id = self.nextVersionId\n         referenced = {}\n         # Store referenced data as is\n-        if \'referenced_data\' in data:\n-            referenced = data[\'referenced_data\']\n-            del data[\'referenced_data\']\n+        if "referenced_data" in data:\n+            referenced = data["referenced_data"]\n+            del data["referenced_data"]\n         self._full[version_id] = deepCopy(data)\n-        self._full[version_id][\'referenced_data\'] = referenced\n+        self._full[version_id]["referenced_data"] = referenced\n         self._available.append(version_id)\n         # Provokes a write conflict if two saves happen the same\n         # time. That\'s exactly what\'s desired.\n@@ -828,7 +867,8 @@ def save(self, data):\n \n         return version_id\n \n-    security.declareProtected(AccessPreviousVersions, \'retrieve\')\n+    security.declareProtected(AccessPreviousVersions, "retrieve")\n+\n     def retrieve(self, selector, countPurged=True):\n         """Retrieves the Selected Data From the History\n \n@@ -843,8 +883,7 @@ def retrieve(self, selector, countPurged=True):\n         return self._full[version_id]\n \n     def purge(self, selector, data, countPurged):\n-        """Purge selected version from the history\n-        """\n+        """Purge selected version from the history"""\n         # find the position to purge\n         version_pos = self._getVersionPos(selector, countPurged)\n         version_id = self._available[version_pos]\n@@ -870,10 +909,10 @@ def purge(self, selector, data, countPurged):\n         except KeyError:\n             pass\n \n-    security.declareProtected(AccessPreviousVersions, \'getLength\')\n+    security.declareProtected(AccessPreviousVersions, "getLength")\n+\n     def getLength(self, countPurged):\n-        """Length of the History Either Counting Purged Versions or Not\n-        """\n+        """Length of the History Either Counting Purged Versions or Not"""\n         if countPurged:\n             return self.nextVersionId\n         else:\n@@ -884,8 +923,7 @@ def __len__(self):\n         return self.getLength(True)\n \n     def getSize(self):\n-        """Returns the size including the quality of the size\n-        """\n+        """Returns the size including the quality of the size"""\n         # don\'t like exceptions taking down CMFEditions\n         if getattr(self, "_sizeInaccurate", None) is None:\n             return 0, "not available"\n@@ -902,7 +940,7 @@ def getVersionId(self, selector, countPurged):\n         if selector is not None:\n             selector = int(selector)\n \n-        ##### looking at special selectors first (None, negative)\n+        # looking at special selectors first (None, negative)\n         length = self.getLength(countPurged)\n         # checking for ``None`` selector (youngest version)\n         if selector is None:\n@@ -916,7 +954,7 @@ def getVersionId(self, selector, countPurged):\n             if selector < 0:\n                 return None\n \n-        #### normal cases (0 <= selectors < length)\n+        # normal cases (0 <= selectors < length)\n         if countPurged:\n             # selector is a normal selector\n             return selector\n@@ -947,6 +985,7 @@ def _getVersionPos(self, selector, countPurged):\n             selector = None\n         return selector\n \n+\n InitializeClass(ShadowHistory)\n \n \n@@ -955,10 +994,10 @@ class ZVCAwareWrapper(Persistent):\n \n     ZVC, arghh ...\n     """\n+\n     def __init__(self, object, metadata, vc_info=None):\n         self._object = object\n-        self._physicalPath = \\\n-            metadata[\'sys_metadata\'].get(\'physicalPath\', ())[:] # copy\n+        self._physicalPath = metadata["sys_metadata"].get("physicalPath", ())[:]  # copy\n         if vc_info is not None:\n             self.__vc_info__ = vc_info\n \n@@ -968,42 +1007,39 @@ def getWrappedObject(self):\n     def getPhysicalPath(self):\n         return self._physicalPath\n \n+\n InitializeClass(ZVCAwareWrapper)\n \n \n class Removed(Persistent):\n-    """Indicates that removement of data\n-    """\n+    """Indicates that removement of data"""\n \n     def __init__(self, reason, metadata):\n-        """Store Removed Info\n-        """\n+        """Store Removed Info"""\n         self.reason = reason\n         self.metadata = metadata\n \n \n @implementer(IVersionData)\n class VersionData:\n-\n     def __init__(self, object, referenced_data, metadata):\n         self.object = object\n         self.referenced_data = referenced_data\n         self.metadata = metadata\n \n     def isValid(self):\n-        """Returns True if Valid (not Purged)\n-        """\n+        """Returns True if Valid (not Purged)"""\n         return not isinstance(self.object, Removed)\n \n+\n @implementer(\n-        IHistory,)\n+    IHistory,\n+)\n class LazyHistory:\n-    """Lazy history adapter.\n-    """\n+    """Lazy history adapter."""\n \n     def __init__(self, storage, history_id, countPurged=True, substitute=True):\n-        """See IHistory.\n-        """\n+        """See IHistory."""\n         history = storage._getShadowHistory(history_id)\n         if history is None:\n             self._length = 0\n@@ -1015,26 +1051,23 @@ def __init__(self, storage, history_id, countPurged=True, substitute=True):\n         self._retrieve = storage.retrieve\n \n     def __len__(self):\n-        """See IHistory.\n-        """\n+        """See IHistory."""\n         return self._length\n \n     def __getitem__(self, selector):\n-        """See IHistory.\n-        """\n-        return self._retrieve(self._history_id, selector, self._countPurged,\n-                              self._substitute)\n+        """See IHistory."""\n+        return self._retrieve(\n+            self._history_id, selector, self._countPurged, self._substitute\n+        )\n \n     def __iter__(self):\n-        """See IHistory.\n-        """\n-        return GetItemIterator(self.__getitem__,\n-                               stopExceptions=(StorageRetrieveError,))\n+        """See IHistory."""\n+        return GetItemIterator(self.__getitem__, stopExceptions=(StorageRetrieveError,))\n \n \n class GetItemIterator:\n-    """Iterator object using a getitem implementation to iterate over.\n-    """\n+    """Iterator object using a getitem implementation to iterate over."""\n+\n     def __init__(self, getItem, stopExceptions):\n         self._getItem = getItem\n         self._stopExceptions = stopExceptions\ndiff --git a/Products/CMFEditions/__init__.py b/Products/CMFEditions/__init__.py\nindex c9fc51c..140db83 100644\n--- a/Products/CMFEditions/__init__.py\n+++ b/Products/CMFEditions/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2003, 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -34,6 +33,7 @@\n from Products.CMFEditions import ReferenceFactoriesTool\n from Products.CMFEditions import StandardModifiers\n from Products.CMFEditions import ZVCStorageTool\n+\n # Set up a MessageFactory for the cmfeditions domain\n from zope.i18nmessageid import MessageFactory\n \n@@ -49,21 +49,27 @@\n     CopyModifyMergeRepositoryTool.CopyModifyMergeRepositoryTool,\n     ReferenceFactoriesTool.ReferenceFactoriesTool,\n     KeepLastNVersionsTool.KeepLastNVersionsTool,\n-    )\n+)\n+\n \n+CMFEditionsMessageFactory = MessageFactory("cmfeditions")\n \n-CMFEditionsMessageFactory = MessageFactory(\'cmfeditions\')\n+ModuleSecurityInfo("Products.CMFEditions").declarePublic("CMFEditionsMessageFactory")\n+ModuleSecurityInfo("Products.CMFEditions.interfaces.IArchivist").declarePublic(\n+    "ArchivistUnregisteredError"\n+)\n+ModuleSecurityInfo("Products.CMFEditions.interfaces.IModifier").declarePublic(\n+    "FileTooLargeToVersionError"\n+)\n+ModuleSecurityInfo("Products.CMFEditions.utilities").declarePublic("isObjectChanged")\n+ModuleSecurityInfo("Products.CMFEditions.utilities").declarePublic("isObjectVersioned")\n+ModuleSecurityInfo("Products.CMFEditions.utilities").declarePublic("maybeSaveVersion")\n \n-ModuleSecurityInfo(\'Products.CMFEditions\').declarePublic(\'CMFEditionsMessageFactory\')\n-ModuleSecurityInfo(\'Products.CMFEditions.interfaces.IArchivist\').declarePublic(\'ArchivistUnregisteredError\')\n-ModuleSecurityInfo(\'Products.CMFEditions.interfaces.IModifier\').declarePublic(\'FileTooLargeToVersionError\')\n-ModuleSecurityInfo(\'Products.CMFEditions.utilities\').declarePublic(\'isObjectChanged\')\n-ModuleSecurityInfo(\'Products.CMFEditions.utilities\').declarePublic(\'isObjectVersioned\')\n-ModuleSecurityInfo(\'Products.CMFEditions.utilities\').declarePublic(\'maybeSaveVersion\')\n \n def initialize(context):\n-    utils.ToolInit(meta_type=\'CMF Editions Tool\', tools=tools,\n-                   icon=\'tool.gif\').initialize(context)\n+    utils.ToolInit(\n+        meta_type="CMF Editions Tool", tools=tools, icon="tool.gif"\n+    ).initialize(context)\n \n     # initialize standard modifiers to make them addable through the ZMI\n     StandardModifiers.initialize(context)\ndiff --git a/Products/CMFEditions/browser/__init__.py b/Products/CMFEditions/browser/__init__.py\nindex 40a96af..e69de29 100644\n--- a/Products/CMFEditions/browser/__init__.py\n+++ b/Products/CMFEditions/browser/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/Products/CMFEditions/browser/diff.py b/Products/CMFEditions/browser/diff.py\nindex 4ef23a2..8711c84 100644\n--- a/Products/CMFEditions/browser/diff.py\n+++ b/Products/CMFEditions/browser/diff.py\n@@ -1,11 +1,8 @@\n-# -*- coding: utf-8 -*-\n-\n from Acquisition import aq_inner\n from Products.CMFCore.utils import getToolByName\n from Products.CMFEditions import CMFEditionsMessageFactory as _\n from Products.Five.browser import BrowserView\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n-from six.moves import range\n from zope.i18n import translate\n \n \n@@ -13,7 +10,7 @@ class DiffView(BrowserView):\n     template = ViewPageTemplateFile("diff.pt")\n \n     def __init__(self, *args):\n-        super(DiffView, self).__init__(*args)\n+        super().__init__(*args)\n         self.repo_tool = getToolByName(self.context, "portal_repository")\n \n     def getVersion(self, version):\n@@ -34,9 +31,8 @@ def versionTitle(self, version):\n         version_name = self.versionName(version)\n \n         return translate(\n-            _(u"version ${version}",\n-              mapping=dict(version=version_name)),\n-            context=self.request\n+            _("version ${version}", mapping=dict(version=version_name)),\n+            context=self.request,\n         )\n \n     def __call__(self):\n@@ -49,27 +45,29 @@ def __call__(self):\n         history = self.history = []\n         # Count backwards from most recent to least recent\n         for i in range(history_metadata.getLength(countPurged=False) - 1, -1, -1):\n-            version = retrieve(i, countPurged=False)[\'metadata\'].copy()\n-            version[\'version_id\'] = getId(i, countPurged=False)\n+            version = retrieve(i, countPurged=False)["metadata"].copy()\n+            version["version_id"] = getId(i, countPurged=False)\n             history.append(version)\n         dt = getToolByName(self.context, "portal_diff")\n         self.changeset = dt.createChangeSet(\n             self.getVersion(version2),\n             self.getVersion(version1),\n             id1=self.versionTitle(version2),\n-            id2=self.versionTitle(version1))\n-        self.changes = [change for change in self.changeset.getDiffs()\n-                        if not change.same]\n+            id2=self.versionTitle(version1),\n+        )\n+        self.changes = [\n+            change for change in self.changeset.getDiffs() if not change.same\n+        ]\n \n         return self.template()\n \n \n class CanDiff(BrowserView):\n-\n     def can_diff(self):\n-        """Return True if content is diffable\n-        """\n+        """Return True if content is diffable"""\n         context = self.context\n-        portal_diff = getToolByName(context, \'portal_diff\', None)\n-        return portal_diff \\\n+        portal_diff = getToolByName(context, "portal_diff", None)\n+        return (\n+            portal_diff\n             and len(portal_diff.getDiffForPortalType(context.portal_type)) > 0\n+        )\ndiff --git a/Products/CMFEditions/browser/utils.py b/Products/CMFEditions/browser/utils.py\nindex 6b1f1d1..c40f048 100644\n--- a/Products/CMFEditions/browser/utils.py\n+++ b/Products/CMFEditions/browser/utils.py\n@@ -23,38 +23,35 @@ def get_macros(self, vdata):\n         type_info = context.portal_types.getTypeInfo(vdata.object)\n \n         # build the name of special versions views\n-        if getattr(type_info, \'getViewMethod\', None) is not None:\n+        if getattr(type_info, "getViewMethod", None) is not None:\n             # Should use IBrowserDefault.getLayout ?\n             def_method_name = type_info.getViewMethod(context)\n         else:\n-            def_method_name = type_info.getActionInfo(\n-                \'object/view\')[\'url\'].split(\'/\')[-1] or \\\n-                getattr(type_info, \'default_view\', \'view\')\n-        versionPreviewMethodName = \'version_%s\' % def_method_name\n-        versionPreviewTemplate = getattr(\n-            context, versionPreviewMethodName, None)\n+            def_method_name = type_info.getActionInfo("object/view")["url"].split("/")[\n+                -1\n+            ] or getattr(type_info, "default_view", "view")\n+        versionPreviewMethodName = "version_%s" % def_method_name\n+        versionPreviewTemplate = getattr(context, versionPreviewMethodName, None)\n \n         # check if a special version view exists\n-        if getattr(versionPreviewTemplate, \'macros\', None) is None:\n+        if getattr(versionPreviewTemplate, "macros", None) is None:\n             # Use the Plone\'s default view template\n-            versionPreviewTemplate = context.restrictedTraverse(\n-                def_method_name)\n+            versionPreviewTemplate = context.restrictedTraverse(def_method_name)\n \n-        if getattr(versionPreviewTemplate, \'macros\', None) is None:\n+        if getattr(versionPreviewTemplate, "macros", None) is None:\n             return None\n \n-        macro_names = [\'content-core\', \'main\']\n+        macro_names = ["content-core", "main"]\n \n         try:\n-            return versionPreviewTemplate.macros[\'content-core\']\n+            return versionPreviewTemplate.macros["content-core"]\n         except KeyError:\n             pass  # No content-core macro could mean that we are in plone3 land\n         try:\n-            return versionPreviewTemplate.macros[\'main\']\n+            return versionPreviewTemplate.macros["main"]\n         except KeyError:\n             logger.warn(\n-                \'Missing TAL macros {0} in template "{1}".\' .format(\n-                    \', \'.join(macro_names),\n-                    versionPreviewMethodName\n+                \'Missing TAL macros {} in template "{}".\'.format(\n+                    ", ".join(macro_names), versionPreviewMethodName\n                 )\n             )\ndiff --git a/Products/CMFEditions/browser/views.py b/Products/CMFEditions/browser/views.py\nindex 64507d6..23501f5 100644\n--- a/Products/CMFEditions/browser/views.py\n+++ b/Products/CMFEditions/browser/views.py\n@@ -11,13 +11,12 @@\n \n \n class UpdateVersionOnEditView(BrowserView):\n-\n     def success(self):\n-        self.request.response.redirect(\'view\')\n+        self.request.response.redirect("view")\n \n     def __call__(self):\n         context = aq_inner(self.context)\n-        pf = getToolByName(context, \'portal_factory\')\n+        pf = getToolByName(context, "portal_factory")\n \n         if pf.isTemporary(context):\n             # don\'t do anything if we\'re in the factory\n@@ -31,20 +30,19 @@ def __call__(self):\n         try:\n             maybeSaveVersion(context, comment=comment, force=False)\n         except FileTooLargeToVersionError:\n-            pass # the on edit save will emit a warning\n+            pass  # the on edit save will emit a warning\n \n         return self.success()\n \n \n class UpdateVersionBeforeEditView(BrowserView):\n-\n     def success(self):\n-        return self.context.restrictedTraverse(\'content_edit\')\n+        return self.context.restrictedTraverse("content_edit")\n \n     def __call__(self):\n         context = aq_inner(self.context)\n-        comment = self.request.get(\'cmfeditions_version_comment\', \'\')\n-        force = self.request.get(\'cmfeditions_save_new_version\', None) is not None\n+        comment = self.request.get("cmfeditions_version_comment", "")\n+        force = self.request.get("cmfeditions_save_new_version", None) is not None\n \n         if not (isObjectChanged(context) or force):\n             return self.success()\n@@ -53,44 +51,45 @@ def __call__(self):\n             maybeSaveVersion(context, comment=comment, force=force)\n         except FileTooLargeToVersionError:\n             IStatusMessage(self.request).addStatusMessage(\n-                _(\'Versioning for this file has been disabled because it is too large\'),\n-                type=\'warn\'\n-                )\n+                _("Versioning for this file has been disabled because it is too large"),\n+                type="warn",\n+            )\n         return self.success()\n \n \n class FileDownloadVersionView(BrowserView):\n-\n     def __call__(self):\n         context = aq_inner(self.context)\n-        version_id = int(self.request.get(\'version_id\', 1))\n+        version_id = int(self.request.get("version_id", 1))\n         RESPONSE = self.request.RESPONSE\n \n-        portal_repository = getToolByName(context, \'portal_repository\')\n+        portal_repository = getToolByName(context, "portal_repository")\n         obj = portal_repository.retrieve(context, version_id).object\n-        RESPONSE.setHeader(\'Content-Type\', obj.getContentType())\n-        RESPONSE.setHeader(\'Content-Length\', obj.get_size())\n-        RESPONSE.setHeader(\'Content-Disposition\',\n-                           \'attachment;filename="%s"\'%(obj.getFilename()))\n+        RESPONSE.setHeader("Content-Type", obj.getContentType())\n+        RESPONSE.setHeader("Content-Length", obj.get_size())\n+        RESPONSE.setHeader(\n+            "Content-Disposition", \'attachment;filename="%s"\' % (obj.getFilename())\n+        )\n         return obj.data\n \n \n class VersionImageTagView(BrowserView):\n-\n     def __call__(self):\n-        version_id = int(self.request.get(\'version_id\', 1))\n-        here_url = self.request.get(\'here_url\', \'\')\n+        version_id = int(self.request.get("version_id", 1))\n+        here_url = self.request.get("here_url", "")\n         context = aq_inner(self.context)\n-        portal_repository = getToolByName(context, \'portal_repository\')\n+        portal_repository = getToolByName(context, "portal_repository")\n         obj = portal_repository.retrieve(context, version_id).object\n         working_copy_tag = obj.tag()\n         altPos = working_copy_tag.find("alt=")\n-        tag = \'<img src="%s/file_download_version?version_id=%s" %s\' % \\\n-              (here_url, version_id, working_copy_tag[altPos:])\n+        tag = \'<img src="{}/file_download_version?version_id={}" {}\'.format(\n+            here_url,\n+            version_id,\n+            working_copy_tag[altPos:],\n+        )\n         return tag\n \n \n class VersionView(BrowserView):\n-\n     def human_readable_size(self):\n         return human_readable_size\ndiff --git a/Products/CMFEditions/exportimport/__init__.py b/Products/CMFEditions/exportimport/__init__.py\nindex ec51c5a..792d600 100644\n--- a/Products/CMFEditions/exportimport/__init__.py\n+++ b/Products/CMFEditions/exportimport/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n #\ndiff --git a/Products/CMFEditions/exportimport/repository.py b/Products/CMFEditions/exportimport/repository.py\nindex 91e052f..c47a0a5 100644\n--- a/Products/CMFEditions/exportimport/repository.py\n+++ b/Products/CMFEditions/exportimport/repository.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Products.CMFCore.utils import getToolByName\n from Products.CMFEditions.VersionPolicies import VersionPolicy\n from Products.GenericSetup.utils import exportObjects\n@@ -8,34 +7,31 @@\n \n \n class RepositoryToolXMLAdapter(XMLAdapterBase):\n-    """Mode in- and exporter for RepositoryTool.\n-    """\n+    """Mode in- and exporter for RepositoryTool."""\n \n-    name = \'repositorytool\'\n+    name = "repositorytool"\n \n     def _exportNode(self):\n-        """Export the object as a DOM node.\n-        """\n-        node=self._doc.createElement(\'repositorytool\')\n+        """Export the object as a DOM node."""\n+        node = self._doc.createElement("repositorytool")\n         node.appendChild(self._extractPolicies())\n         node.appendChild(self._extractTypePolicies())\n-        self._logger.info(\'RepositoryTool settings exported.\')\n+        self._logger.info("RepositoryTool settings exported.")\n         return node\n \n-\n     def _importNode(self, node):\n         if self.environ.shouldPurge():\n             self._purgeTypePolicies()\n             self._purgePolicies()\n         self._initPolicies(node)\n         self._initTypePolicies(node)\n-        self._logger.info(\'RepositoryTool settings imported.\')\n+        self._logger.info("RepositoryTool settings imported.")\n \n     def _shouldPurge(self, node):\n-        purge = node.getAttribute(\'purge\').lower() or \'false\'\n-        if purge == \'true\':\n+        purge = node.getAttribute("purge").lower() or "false"\n+        if purge == "true":\n             return True\n-        elif purge == \'false\':\n+        elif purge == "false":\n             return False\n         else:\n             raise ValueError("purge must be \'true\' or \'false\'")\n@@ -46,22 +42,21 @@ def _purgePolicies(self):\n \n     def _initPolicies(self, node):\n         tool = self.context\n-        policynames = [p.getId() for p in tool.listPolicies()]\n         for child in node.childNodes:\n-            if child.nodeName == \'policies\':\n+            if child.nodeName == "policies":\n                 if self._shouldPurge(child):\n                     self._purgePolicies()\n                 for policy in child.childNodes:\n-                    if policy.nodeName == \'#text\':\n+                    if policy.nodeName == "#text":\n                         continue\n-                    if policy.nodeName != \'policy\':\n+                    if policy.nodeName != "policy":\n                         raise AssertionError(\n                             "<policies> must only contain <policy> tags, not <%s>.",\n-                            policy.nodeName\n+                            policy.nodeName,\n                         )\n-                    policy_id = policy.getAttribute(\'name\')\n-                    policy_title = policy.getAttribute(\'title\')\n-                    class_id = policy.getAttribute(\'class\')\n+                    policy_id = policy.getAttribute("name")\n+                    policy_title = policy.getAttribute("title")\n+                    class_id = policy.getAttribute("class")\n                     if class_id:\n                         policy_class = resolve(class_id)\n                     else:\n@@ -69,16 +64,16 @@ def _initPolicies(self, node):\n                     tool.addPolicy(policy_id, policy_title, policy_class)\n \n     def _extractPolicies(self):\n-        node = self._doc.createElement(\'policies\')\n+        node = self._doc.createElement("policies")\n         policies = self.context.listPolicies()\n         policies.sort(key=lambda x: x.getId())\n         for policy in policies:\n-            p = self._doc.createElement(\'policy\')\n-            p.setAttribute(\'name\', policy.getId())\n-            p.setAttribute(\'title\', policy.Title())\n+            p = self._doc.createElement("policy")\n+            p.setAttribute("name", policy.getId())\n+            p.setAttribute("title", policy.Title())\n             klass = type(policy)\n             if klass is not VersionPolicy:\n-                p.setAttribute(\'class\', "%s.%s" % (klass.__module__, klass.__name__))\n+                p.setAttribute("class", f"{klass.__module__}.{klass.__name__}")\n             node.appendChild(p)\n         return node\n \n@@ -89,31 +84,31 @@ def _purgeTypePolicies(self):\n     def _initTypePolicies(self, node):\n         tool = self.context\n         for child in node.childNodes:\n-            if child.nodeName == \'policymap\':\n+            if child.nodeName == "policymap":\n                 if self._shouldPurge(child):\n                     self._purgeTypePolicies()\n                 for p_type in child.childNodes:\n-                    if p_type.nodeName == \'#text\':\n+                    if p_type.nodeName == "#text":\n                         continue\n-                    if p_type.nodeName != \'type\':\n+                    if p_type.nodeName != "type":\n                         raise AssertionError(\n                             "<policymap> must only contain <type> tags, not <%s>.",\n-                            p_type.nodeName\n+                            p_type.nodeName,\n                         )\n-                    portal_type = p_type.getAttribute(\'name\')\n+                    portal_type = p_type.getAttribute("name")\n                     existing_policies = tool.getPolicyMap().get(portal_type, [])\n                     for policy_id in existing_policies:\n                         tool.removePolicyFromContentType(portal_type, policy_id)\n                     policies = []\n                     for policy in p_type.childNodes:\n-                        if policy.nodeName == \'#text\':\n+                        if policy.nodeName == "#text":\n                             continue\n-                        if policy.nodeName != \'policy\':\n+                        if policy.nodeName != "policy":\n                             raise AssertionError(\n                                 "<policymap><type> must only contain <policy> tags, not <%s>.",\n-                                policy.nodeName\n+                                policy.nodeName,\n                             )\n-                        policies.append(policy.getAttribute(\'name\'))\n+                        policies.append(policy.getAttribute("name"))\n                     versionable_types = tool.getVersionableContentTypes()\n                     if policies:\n                         if portal_type not in versionable_types:\n@@ -125,41 +120,39 @@ def _initTypePolicies(self, node):\n                             versionable_types.remove(portal_type)\n                     tool.setVersionableContentTypes(versionable_types)\n \n-\n     def _extractTypePolicies(self):\n-        node = self._doc.createElement(\'policymap\')\n+        node = self._doc.createElement("policymap")\n         mapping = sorted(self.context.getPolicyMap().items())\n         for portal_type, policies in mapping:\n-            t = self._doc.createElement(\'type\')\n-            t.setAttribute(\'name\', portal_type)\n+            t = self._doc.createElement("type")\n+            t.setAttribute("name", portal_type)\n             for policyname in policies:\n-                p = self._doc.createElement(\'policy\')\n-                p.setAttribute(\'name\', policyname)\n+                p = self._doc.createElement("policy")\n+                p.setAttribute("name", policyname)\n                 t.appendChild(p)\n             node.appendChild(t)\n         return node\n \n \n def importRepositoryTool(context):\n-    """Import Repository Tool configuration.\n-    """\n+    """Import Repository Tool configuration."""\n     site = context.getSite()\n-    tool = getToolByName(site, \'portal_repository\', None)\n+    tool = getToolByName(site, "portal_repository", None)\n     if tool is None:\n         logger = context.getLogger("repositorytool")\n         logger.info("Nothing to import.")\n         return\n \n-    importObjects(tool, \'\', context)\n+    importObjects(tool, "", context)\n+\n \n def exportRepositoryTool(context):\n-    """Export Repository Tool configuration.\n-    """\n+    """Export Repository Tool configuration."""\n     site = context.getSite()\n-    tool = getToolByName(site, \'portal_repository\', None)\n+    tool = getToolByName(site, "portal_repository", None)\n     if tool is None:\n         logger = context.getLogger("repositorytool")\n         logger.info("Nothing to export.")\n         return\n \n-    exportObjects(tool, \'\', context)\n+    exportObjects(tool, "", context)\ndiff --git a/Products/CMFEditions/historyidhandlertool.py b/Products/CMFEditions/historyidhandlertool.py\nindex 74b315d..0cfa1e3 100644\n--- a/Products/CMFEditions/historyidhandlertool.py\n+++ b/Products/CMFEditions/historyidhandlertool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -23,4 +22,4 @@\n \n \n class HistoryIdHandlerTool(UniqueIdHandlerTool):\n-    id = \'portal_historyidhandler\'\n+    id = "portal_historyidhandler"\ndiff --git a/Products/CMFEditions/interfaces/IArchivist.py b/Products/CMFEditions/interfaces/IArchivist.py\nindex c403bc0..c47e727 100644\n--- a/Products/CMFEditions/interfaces/IArchivist.py\n+++ b/Products/CMFEditions/interfaces/IArchivist.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -127,8 +126,7 @@ def queryHistory(obj=None, history_id=None, preserve=(), default=None):\n         """\n \n     def getHistoryMetadata(obj=None, history_id=None):\n-        """Returns the versioning metadata history.\n-        """\n+        """Returns the versioning metadata history."""\n \n \n class IPurgeSupport(Interface):\n@@ -168,8 +166,7 @@ class IPurgeSupport(Interface):\n         version retrieved: 0, 1, 2, 5, 6, 7, 8, 9, e, e\n     """\n \n-    def purge(obj=None, history_id=None, selector=None, metadata={},\n-              countPurged=True):\n+    def purge(obj=None, history_id=None, selector=None, metadata={}, countPurged=True):\n         """Purge a version of a content object.\n \n         Requires either an object which is the working copy, or a history_id\n@@ -183,8 +180,7 @@ def purge(obj=None, history_id=None, selector=None, metadata={},\n         (see interface documentation for details).\n         """\n \n-    def isUpToDate(obj=None, history_id=None, selector=None,\n-                   countPurged=True):\n+    def isUpToDate(obj=None, history_id=None, selector=None, countPurged=True):\n         """Check if the corking copy is up to date.\n \n         Returns True if the working copy has changed since the last save\n@@ -198,8 +194,9 @@ def isUpToDate(obj=None, history_id=None, selector=None,\n         (see interface documentation for details).\n         """\n \n-    def retrieve(obj=None, history_id=None, selector=None, preserve=(),\n-                 countPurged=True):\n+    def retrieve(\n+        obj=None, history_id=None, selector=None, preserve=(), countPurged=True\n+    ):\n         """Retrieve a former state of an object.\n \n         Requires either an object which is the working copy, or a history_id\n@@ -245,8 +242,9 @@ def getHistory(obj=None, history_id=None, preserve=(), countPurged=True):\n         (see interface documentation for details).\n         """\n \n-    def queryHistory(obj=None, history_id=None, preserve=(), default=None,\n-                     countPurged=True):\n+    def queryHistory(\n+        obj=None, history_id=None, preserve=(), default=None, countPurged=True\n+    ):\n         """Return the history of an object.\n \n         Does the same as ``getHistory`` with the difference of returning\n@@ -258,12 +256,12 @@ def queryHistory(obj=None, history_id=None, preserve=(), default=None,\n \n \n class IPreparedObject(Interface):\n-    """Contains data prepared for save or register.\n-    """\n+    """Contains data prepared for save or register."""\n \n     history_id = Attribute(\n         """The id of the objects history.\n-        """)\n+        """\n+    )\n \n     original = Attribute(\n         """The unaltered original object before the modifiers were applied.\n@@ -271,13 +269,15 @@ class IPreparedObject(Interface):\n         This is a \'IObjectData\' object.\n \n         The original object shall not be modified!\n-        """)\n+        """\n+    )\n \n     clone = Attribute(\n         """The cloned object and version aware reference info.\n \n         This is a \'IObjectData\' object.\n-        """)\n+        """\n+    )\n \n     referenced_data = Attribute(\n         """Data that is passed to the storage by reference.\n@@ -289,44 +289,50 @@ class IPreparedObject(Interface):\n         Returns a dictionary of the following format:\n \n             {\'name\': pyref_to_object, ...}\n-        """)\n+        """\n+    )\n \n     metadata = Attribute(\n         """Metadata to be passed to history storage.\n-        """)\n+        """\n+    )\n \n     is_registered = Attribute(\n         """True if already registered by the Archivist.\n-        """)\n+        """\n+    )\n \n \n class IVersionData(Interface):\n-    """\n-    """\n+    """ """\n \n     data = Attribute(\n         """The previously saved object.\n \n         This is a \'IObjectData\' object.\n-        """)\n+        """\n+    )\n \n     refs_to_be_deleted = Attribute(\n         """List of references to be deleted on revert.\n \n         The items (containing the reference informations) are of\n         ``IReferenceAdapter``.\n-        """)\n+        """\n+    )\n \n     attr_handling_references = Attribute(\n         """List of names of attributes handling references.\n-        """)\n+        """\n+    )\n \n     preserved_data = Attribute(\n         """Returns data beeing preserved from beeing overwritten by modifiers.\n \n         The preserved data is a flat dictionary. With the example from above:\n         nick_name = obj.preserved_data[\'nick_name\']\n-        """)\n+        """\n+    )\n \n     sys_metadata = Attribute(\n         """System related metadata.\n@@ -337,16 +343,17 @@ class IVersionData(Interface):\n         - principal: the actor that did the save\n         - parent: Dictionary with ``history_id``, ``version_id`` and\n           ``location_id``\n-        """)\n+        """\n+    )\n \n     app_metadata = Attribute(\n         """Metadata stored alongside when the objects state was saved.\n-        """)\n+        """\n+    )\n \n \n class IHistory(Interface):\n-    """Iterable version history.\n-    """\n+    """Iterable version history."""\n \n     def __init__(archivist, obj):\n         """Instantiates a lazy iterable history.\n@@ -356,8 +363,7 @@ def __init__(archivist, obj):\n         """\n \n     def __len__():\n-        """Returns the length of the history.\n-        """\n+        """Returns the length of the history."""\n \n     def __getattr__(version_id):\n         """Returns the version of an object corresponding to the version id.\n@@ -373,23 +379,25 @@ def __iter__():\n \n \n class IObjectData(Interface):\n-    """The object including informations about outgoing references.\n-    """\n+    """The object including informations about outgoing references."""\n \n     object = Attribute(\n         """The object with some of the python references replaced by\n            version aware references.\n-        """)\n+        """\n+    )\n \n     inside_refs = Attribute(\n         """List of \'IAttributeAdapter\' objects adapting "object inside"\n            \'IVersionAwareReference\'.\n-        """)\n+        """\n+    )\n \n     outside_refs = Attribute(\n         """List of \'IAttributeAdapter\' objects adapting "object outside"\n            \'IVersionAwareReference\'.\n-        """)\n+        """\n+    )\n \n \n class IAttributeAdapter(Interface):\n@@ -400,24 +408,19 @@ class IAttributeAdapter(Interface):\n     """\n \n     def __init__(parent, attr_name, type=None):\n-        """Store the attributes "coordinates".\n-        """\n+        """Store the attributes "coordinates"."""\n \n     def setAttribute(obj):\n-        """Sets the given object as attribute.\n-        """\n+        """Sets the given object as attribute."""\n \n     def getAttribute(alternate=None):\n-        """Returns the current attribute.\n-        """\n+        """Returns the current attribute."""\n \n     def getAttributeName():\n-        """Returns the attributes name.\n-        """\n+        """Returns the attributes name."""\n \n     def getType():\n-        """Returns the attributes type.\n-        """\n+        """Returns the attributes type."""\n \n \n class IVersionAwareReference(Interface):\n@@ -452,8 +455,7 @@ def __init__(**info):\n         """\n \n     def setReference(target_obj, remove_info=True):\n-        """Set a reference to the given target object.\n-        """\n+        """Set a reference to the given target object."""\n \n     history_id = Attribute(\n         """The history id of the referenced resource.\n@@ -462,48 +464,56 @@ def setReference(target_obj, remove_info=True):\n \n         May be None. In this case the reference isn\'t set yet or the\n         target object isn\'t referenceable.\n-        """)\n+        """\n+    )\n \n     version_id = Attribute(\n         """The version id of the referenced resource.\n \n         May be None. For the interpretation see above.\n-        """)\n+        """\n+    )\n \n     location_id = Attribute(\n         """The location id of the working copy of the referenced resource.\n \n         May be None. For the interpretation see above.\n-        """)\n+        """\n+    )\n \n     info = Attribute(\n         """The info stored alongside on instantiation time.\n \n         May not exist.\n-        """)\n+        """\n+    )\n \n \n class ArchivistError(Exception):\n-    """Archivist exception\n-    """\n+    """Archivist exception"""\n+\n     pass\n \n+\n class ArchivistRetrieveError(ArchivistError):\n-    """Raised if tried to retrieve a non existent version of a resource.\n-    """\n+    """Raised if tried to retrieve a non existent version of a resource."""\n+\n     pass\n \n+\n class ArchivistRegisterError(ArchivistError):\n-    """Raised if registering the resource failed.\n-    """\n+    """Raised if registering the resource failed."""\n+\n     pass\n \n+\n class ArchivistSaveError(ArchivistError):\n-    """Raised if saving a new version of a resource failed.\n-    """\n+    """Raised if saving a new version of a resource failed."""\n+\n     pass\n \n+\n class ArchivistUnregisteredError(ArchivistError):\n-    """Raised if trying to save an unregistered resource.\n-    """\n+    """Raised if trying to save an unregistered resource."""\n+\n     pass\ndiff --git a/Products/CMFEditions/interfaces/IModifier.py b/Products/CMFEditions/interfaces/IModifier.py\nindex f099726..e0a4444 100644\n--- a/Products/CMFEditions/interfaces/IModifier.py\n+++ b/Products/CMFEditions/interfaces/IModifier.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber,\n # Reflab(Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi),\n@@ -31,8 +30,8 @@\n \n class IAttributeModifier(Interface):\n     """The simplest possible modifier, it indicates, which attributes\n-       shouldn\'t be copied by the archivist, but be passed to the the storage\n-       by reference.\n+    shouldn\'t be copied by the archivist, but be passed to the the storage\n+    by reference.\n \n     """\n \n@@ -44,9 +43,10 @@ def getReferencedAttributes(obj):\n \n     def reattachReferencedAttributes(obj, attrs_dict):\n         """Giving an obj and and an attribute dict composed by\n-           attribute names and values, reattach them to the obj.\n+        attribute names and values, reattach them to the obj.\n         """\n \n+\n class ICloneModifier(Interface):\n     """Modifies an object on save to or retrieval from a repository storage.\n \n@@ -72,7 +72,6 @@ def getOnCloneModifiers(obj):\n         """\n \n \n-\n class ISaveRetrieveModifier(Interface):\n     """Modifies an object on save to or retrieval from a repository storage.\n \n@@ -134,6 +133,7 @@ def afterRetrieveModifier(obj, repo_clone, preserve=()):\n           overwritten.\n         """\n \n+\n class IReferenceAdapter(Interface):\n     """Adapts to a references.\n \n@@ -142,13 +142,11 @@ class IReferenceAdapter(Interface):\n     """\n \n     def remove():\n-        """Removes the refrence adapted to.\n-        """\n+        """Removes the refrence adapted to."""\n \n \n class IModifierRegistrySet(Interface):\n-    """Registring and editing a modifier registry.\n-    """\n+    """Registring and editing a modifier registry."""\n \n     def register(id, modifier, pos=-1):\n         """Registers a before save and after retrieve modifier.\n@@ -175,8 +173,7 @@ def edit(id, enabled=None, condition=None):\n \n \n class IModifierRegistryQuery(Interface):\n-    """Querying a modifier registry.\n-    """\n+    """Querying a modifier registry."""\n \n     def get(id):\n         """Returns the conditional modifier with the given id.\n@@ -200,7 +197,7 @@ class IConditionalModifier(Interface):\n     existing implicit condition evaluates to a true value.\n     """\n \n-    def __init__(id, modifier, title=\'\'):\n+    def __init__(id, modifier, title=""):\n         """Initialize with a modifier.\n \n         The conditional modifier is disabled by default.\n@@ -220,12 +217,10 @@ def isApplicable(obj, portal=None):\n         """\n \n     def isEnabled():\n-        """Returns the enable status.\n-        """\n+        """Returns the enable status."""\n \n     def getModifier():\n-        """Returns the modifier.\n-        """\n+        """Returns the modifier."""\n \n \n class IConditionalTalesModifier(IConditionalModifier):\n@@ -244,8 +239,7 @@ def edit(enabled=None, condition=None):\n         """\n \n     def getTalesCondition():\n-        """Returns the TALES expression.\n-        """\n+        """Returns the TALES expression."""\n \n \n # not yet implemented stuff, subject to change\n@@ -278,13 +272,17 @@ def setModifiers(ids, pos, before_save, after_retrieve, on_clone):\n         Use this to set all subscribers at once from a form.\n         """\n \n+\n class ModifierException(Exception):\n     """A base class for exceptions thrown by modifiers which wish to abort\n     a save operation"""\n+\n     pass\n \n+\n class FileTooLargeToVersionError(ModifierException):\n     """A simple exception indicating that an object contained a file\n     object that was too large to support versioning, and that versioning\n     will be aborted as a result"""\n+\n     pass\ndiff --git a/Products/CMFEditions/interfaces/IPurgePolicy.py b/Products/CMFEditions/interfaces/IPurgePolicy.py\nindex b4637fb..1e9a52f 100644\n--- a/Products/CMFEditions/interfaces/IPurgePolicy.py\n+++ b/Products/CMFEditions/interfaces/IPurgePolicy.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2006 Gregoire Weber.\n # All Rights Reserved.\ndiff --git a/Products/CMFEditions/interfaces/IReferenceFactories.py b/Products/CMFEditions/interfaces/IReferenceFactories.py\nindex 4e62e19..d7c3281 100644\n--- a/Products/CMFEditions/interfaces/IReferenceFactories.py\n+++ b/Products/CMFEditions/interfaces/IReferenceFactories.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2005 Gregoire Weber.\n # All Rights Reserved.\n@@ -44,5 +43,4 @@ def invokeFactory(repo_clone, source, selector=None):\n         """\n \n     def hasBeenMoved(obj, source):\n-        """Returns True if the object has been moved away from ``source``.\n-        """\n+        """Returns True if the object has been moved away from ``source``."""\ndiff --git a/Products/CMFEditions/interfaces/IRepository.py b/Products/CMFEditions/interfaces/IRepository.py\nindex eae31be..a8a4af8 100644\n--- a/Products/CMFEditions/interfaces/IRepository.py\n+++ b/Products/CMFEditions/interfaces/IRepository.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -51,8 +50,7 @@ class ICopyModifyMergeRepository(Interface):\n     """\n \n     def isVersionable(obj):\n-        """Return True if the content type is versionable.\n-        """\n+        """Return True if the content type is versionable."""\n \n     def setAutoApplyMode(autoapply):\n         """Sets the autoapply mode.\n@@ -64,7 +62,7 @@ def setAutoApplyMode(autoapply):\n         The default value is True.\n         """\n \n-    def applyVersionControl(obj, comment=\'\', metadata={}):\n+    def applyVersionControl(obj, comment="", metadata={}):\n         """Register the content to the repository.\n \n         Must be called prior any of the other repository related methods.\n@@ -75,7 +73,7 @@ def applyVersionControl(obj, comment=\'\', metadata={}):\n         first version to the repository.\n         """\n \n-    def save(obj, comment=\'\', metadata={}):\n+    def save(obj, comment="", metadata={}):\n         """Saves the current version of the content.\n \n         \'comment\' preferably is a human readable string comment.\n@@ -124,8 +122,7 @@ def getHistory(obj, oldestFirst=False, preserve=()):\n         """\n \n     def getHistoryMetadata(obj):\n-        """Returns the versioning metadata history.\n-        """\n+        """Returns the versioning metadata history."""\n \n \n class IPurgeSupport(Interface):\n@@ -209,8 +206,7 @@ def retrieve(obj, selector=None, preserve=(), countPurged=True):\n         (see interface documentation for details).\n         """\n \n-    def restore(history_id, selector, container, new_id=None,\n-                countPurged=True):\n+    def restore(history_id, selector, container, new_id=None, countPurged=True):\n         """Restore a Specific version of an Object into a Container\n \n         Usage Hint:\n@@ -246,29 +242,25 @@ def getHistory(obj, oldestFirst=False, preserve=(), countPurged=True):\n \n \n class IVersionSupport(Interface):\n-    """Check if versioning is supported for a specific content.\n-    """\n+    """Check if versioning is supported for a specific content."""\n \n     def isVersionable(obj):\n-        """Returns True if the object is versionable\n-        """\n+        """Returns True if the object is versionable"""\n \n \n class IContentTypeVersionSupport(IVersionSupport):\n-    """Registry for versionable content types\n-    """\n+    """Registry for versionable content types"""\n \n     def getVersionableContentTypes():\n-        """Returns a list of Versionable content types\n-        """\n+        """Returns a list of Versionable content types"""\n \n     def setVersionableContentTypes(new_content_types):\n-        """Set the list of Versionable content types\n-        """\n+        """Set the list of Versionable content types"""\n+\n \n class IContentTypeVersionPolicySupport(IContentTypeVersionSupport):\n     """Determine if a type supports a particular versioning method, the policy\n-       parameter is simply a string representing the policy"""\n+    parameter is simply a string representing the policy"""\n \n     def addPolicyForContentType(content_type, policy):\n         """Sets a content type to use a specific policy"""\n@@ -277,8 +269,7 @@ def removePolicyFromContentType(content_type, policy):\n         """Sets a content type to use a specific policy"""\n \n     def supportsPolicy(obj, policy):\n-        """Determine if an object is set to use a specific versioning policy\n-        """\n+        """Determine if an object is set to use a specific versioning policy"""\n \n     def hasPolicy(obj):\n         """Determine if an object has any assigned versioning policies"""\n@@ -293,31 +284,31 @@ def listPolicies():\n \n     def addPolicy(policy_id, policy_title, policy_class):\n         """Add a new versioning policy, can optionally use an alternate\n-           policy class."""\n+        policy class."""\n \n     def removePolicy(policy_id):\n         """Removes a versioning policy from the tool and all types which\n-           support it"""\n+        support it"""\n \n     def manage_changePolicyDefs(policy_list):\n         """Update the policy structure with a list of tuples [(id, title),...]\n-           The tuples may optionally contain a policy class and a dict of\n-           kwargs to pass to the policy add hook. e.g.:\n-          [(id, title, klass, {\'arg1\': val1}), ...]\n+         The tuples may optionally contain a policy class and a dict of\n+         kwargs to pass to the policy add hook. e.g.:\n+        [(id, title, klass, {\'arg1\': val1}), ...]\n         """\n \n     def getPolicyMap():\n         """Return a mapping of types to the lists of policies they support,\n-           for use in config screen."""\n+        for use in config screen."""\n \n \n class IVersionData(Interface):\n-    """ Used to store the versioned content plus additional data.\n-    """\n+    """Used to store the versioned content plus additional data."""\n \n     object = Attribute(\n         """The retrieved version of the content.\n-        """)\n+        """\n+    )\n \n     preserved_data = Attribute(\n         """It is the data preserved from overwriting during the\n@@ -326,15 +317,18 @@ class IVersionData(Interface):\n         The preserved data is a flat dictionary.\n         With the example from above:\n                 nick_name = vdata.preserved_data[\'nick_name\']\n-        """)\n+        """\n+    )\n \n     comment = Attribute(\n         """The comment stored when the working copies version was saved.\n-        """)\n+        """\n+    )\n \n     metadata = Attribute(\n         """Metadata stored when the working copies version was saved.\n-        """)\n+        """\n+    )\n \n     sys_metadata = Attribute(\n         """System related metadata.\n@@ -342,20 +336,20 @@ class IVersionData(Interface):\n         A Dictionary with the following keys:\n         - timestamp: save time\n         - principal: the actor that did the save\n-        """)\n+        """\n+    )\n \n     version_id = Attribute(\n         """The version_id of the object.\n-        """)\n+        """\n+    )\n \n \n class IHistory(Interface):\n-    """Iterable version history.\n-    """\n+    """Iterable version history."""\n \n     def __len__():\n-        """Returns the length of the history.\n-        """\n+        """Returns the length of the history."""\n \n     def __getitem__(selector):\n         """Returns the selected version of a content.\n@@ -364,21 +358,18 @@ def __getitem__(selector):\n         """\n \n     def __iter__():\n-        """ Returns an iterator returning \'IVersionData\' object.\n-        """\n+        """Returns an iterator returning \'IVersionData\' object."""\n \n \n class IRepositoryTool(Interface):\n     """Marker interface for the repository tool used in GenericSetup\n-       exportimport handlers.\n+    exportimport handlers.\n     """\n \n \n class RepositoryError(Exception):\n-    """Repository exception.\n-    """\n+    """Repository exception."""\n \n \n class RepositoryPurgeError(RepositoryError):\n-    """Purge is only possible with a purge policy installed.\n-    """\n+    """Purge is only possible with a purge policy installed."""\ndiff --git a/Products/CMFEditions/interfaces/IStorage.py b/Products/CMFEditions/interfaces/IStorage.py\nindex f70b382..45cf524 100644\n--- a/Products/CMFEditions/interfaces/IStorage.py\n+++ b/Products/CMFEditions/interfaces/IStorage.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -101,11 +100,10 @@ def getHistory(history_id):\n         """\n \n     def getHistoryMetadata(history_id):\n-        """Returns the versioning metadata history.\n-        """\n+        """Returns the versioning metadata history."""\n \n     def getModificationDate(history_id, selector=None):\n-        """ Returns the modification date of the selected version of object\n+        """Returns the modification date of the selected version of object\n             which has the given history id.\n \n         If selected is None, the most recent version (HEAD) is taken.\n@@ -185,9 +183,10 @@ def getHistory(history_id, countPurged=True, substitute=True):\n         Return a ``IHistory`` object.\n         """\n \n-    def getModificationDate(history_id, selector=None, countPurged=True,\n-                            substitute=True):\n-        """ Returns the modification date of the selected version of object\n+    def getModificationDate(\n+        history_id, selector=None, countPurged=True, substitute=True\n+    ):\n+        """Returns the modification date of the selected version of object\n             which has the given history id.\n \n         If ``countPurged`` is ``True`` purged versions are returned also.\n@@ -201,12 +200,10 @@ def getModificationDate(history_id, selector=None, countPurged=True,\n \n \n class IHistory(Interface):\n-    """Iterable version history.\n-    """\n+    """Iterable version history."""\n \n     def __len__():\n-        """Return the length of the history.\n-        """\n+        """Return the length of the history."""\n \n     def __getattr__(version_id):\n         """Return the version of an object corresponding to the version id.\n@@ -222,28 +219,31 @@ def __iter__():\n \n \n class IVersionData(Interface):\n-    """\n-    """\n+    """ """\n+\n     object = Attribute(\n         """The objects state at save time.\n \n         To avoid temporal problems (by changing the history) this\n         object has to be cloned before any change.\n-        """)\n+        """\n+    )\n \n     referenced_data = Attribute(\n         """Data beeing passed by reference at save time.\n \n         Needs not be cloned before allowing write access. Cloning was\n         already done by the storage layer.\n-        """)\n+        """\n+    )\n \n     metadata = Attribute(\n         """Metadata stored alongside when the objects state was saved.\n \n         Metadata has to be cloned before any write change to avoid\n         temporal problems (by changing the history).\n-        """)\n+        """\n+    )\n \n \n class IStreamableReference(Interface):\n@@ -255,37 +255,34 @@ class IStreamableReference(Interface):\n     """\n \n     def __init__(self, obj):\n-        """Wrap the object to be passed to the storage\n-        """\n+        """Wrap the object to be passed to the storage"""\n \n     def getObject(self):\n-        """Return the object\n-        """\n+        """Return the object"""\n \n     def getSize(self):\n-        """Return the size of the streamable object or None\n-        """\n+        """Return the size of the streamable object or None"""\n+\n \n class StorageError(Exception):\n-    """History storage exception.\n-    """\n+    """History storage exception."""\n+\n \n class StorageRetrieveError(StorageError):\n-    """Raised if tried to retrieve a non existent version of a resource.\n-    """\n+    """Raised if tried to retrieve a non existent version of a resource."""\n+\n \n class StorageRegisterError(StorageError):\n-    """Raised if registering the resource failed.\n-    """\n+    """Raised if registering the resource failed."""\n+\n \n class StorageSaveError(StorageError):\n-    """Raised if saving a new version of a resource failed.\n-    """\n+    """Raised if saving a new version of a resource failed."""\n+\n \n class StorageUnregisteredError(StorageError):\n-    """Raised if trying to save an unregistered resource.\n-    """\n+    """Raised if trying to save an unregistered resource."""\n+\n \n class StoragePurgeError(StorageError):\n-    """Raised if tried to purge a non existent version of a resource.\n-    """\n+    """Raised if tried to purge a non existent version of a resource."""\ndiff --git a/Products/CMFEditions/interfaces/IVersionPolicy.py b/Products/CMFEditions/interfaces/IVersionPolicy.py\nindex 7d9e654..54ce938 100644\n--- a/Products/CMFEditions/interfaces/IVersionPolicy.py\n+++ b/Products/CMFEditions/interfaces/IVersionPolicy.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -26,7 +25,7 @@\n \n class IVersionPolicy(Interface):\n     """A version policy object, which describes and sets up a versioning\n-       policy\n+    policy\n     """\n \n     def Title():\ndiff --git a/Products/CMFEditions/interfaces/__init__.py b/Products/CMFEditions/interfaces/__init__.py\nindex 4dabd71..607490e 100644\n--- a/Products/CMFEditions/interfaces/__init__.py\n+++ b/Products/CMFEditions/interfaces/__init__.py\n@@ -1,7 +1,6 @@\n-# -*- coding: utf-8 -*-\n from Products.CMFEditions.interfaces._tools import IArchivistTool  # noqa: F401\n-from Products.CMFEditions.interfaces._tools import IPortalModifierTool  # noqa: F401,E501\n-from Products.CMFEditions.interfaces._tools import IPurgePolicyTool  # noqa: F401,E501\n+from Products.CMFEditions.interfaces._tools import IPortalModifierTool  # noqa: F401\n+from Products.CMFEditions.interfaces._tools import IPurgePolicyTool  # noqa: F401\n from Products.CMFEditions.interfaces._tools import IStorageTool  # noqa: F401\n from zope import interface\n \n@@ -10,4 +9,5 @@ class IVersioned(interface.Interface):\n     """Marker interface for objects that carry a version id, and are\n     thus versioned.\n     """\n-    version_id = interface.Attribute(\'The version id of this object.\')\n+\n+    version_id = interface.Attribute("The version id of this object.")\ndiff --git a/Products/CMFEditions/interfaces/_tools.py b/Products/CMFEditions/interfaces/_tools.py\nindex 13d62fc..7737b1f 100644\n--- a/Products/CMFEditions/interfaces/_tools.py\n+++ b/Products/CMFEditions/interfaces/_tools.py\n@@ -1,22 +1,17 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Interface\n \n \n class IArchivistTool(Interface):\n-    """Marker interface for the portal_archivist tool.\n-    """\n+    """Marker interface for the portal_archivist tool."""\n \n \n class IPortalModifierTool(Interface):\n-    """Marker interface for the portal_modifier tool.\n-    """\n+    """Marker interface for the portal_modifier tool."""\n \n \n class IPurgePolicyTool(Interface):\n-    """Marker interface for the portal_purgepolicy tool.\n-    """\n+    """Marker interface for the portal_purgepolicy tool."""\n \n \n class IStorageTool(Interface):\n-    """Marker interface for the portal_historiesstorage tool.\n-    """\n+    """Marker interface for the portal_historiesstorage tool."""\ndiff --git a/Products/CMFEditions/setuphandlers.py b/Products/CMFEditions/setuphandlers.py\nindex 4d8f8f3..82da986 100644\n--- a/Products/CMFEditions/setuphandlers.py\n+++ b/Products/CMFEditions/setuphandlers.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """\n CMFEditions setup handlers.\n """\n@@ -20,22 +19,22 @@ def importVarious(context):\n     care of by other handlers.\n     """\n     # Only run step if a flag file is present\n-    if context.readDataFile(\'cmfeditions_various.txt\') is None:\n+    if context.readDataFile("cmfeditions_various.txt") is None:\n         return\n     site = context.getSite()\n-    portal_modifier = getToolByName(site, \'portal_modifier\', None)\n+    portal_modifier = getToolByName(site, "portal_modifier", None)\n     if portal_modifier is None:\n         return\n     StandardModifiers.install(portal_modifier)\n-    portal_repository = getToolByName(site, \'portal_repository\')\n+    portal_repository = getToolByName(site, "portal_repository")\n     portal_repository.setAutoApplyMode(True)\n     portal_repository._migrateVersionPolicies()\n \n \n def installSkipRegistryBasesPointersModifier(context):\n     """Upgrade step to install the component registry bases modifier."""\n-    portal_modifier = getToolByName(context, \'portal_modifier\', None)\n-    StandardModifiers.install(portal_modifier, [\'SkipRegistryBasesPointers\'])\n+    portal_modifier = getToolByName(context, "portal_modifier", None)\n+    StandardModifiers.install(portal_modifier, ["SkipRegistryBasesPointers"])\n \n \n def removeBrokenModifiers(context):\n@@ -48,7 +47,7 @@ def removeBrokenModifiers(context):\n     """\n     from Products.CMFEditions.interfaces.IModifier import IConditionalModifier\n \n-    tool = getToolByName(context, \'portal_modifier\', None)\n+    tool = getToolByName(context, "portal_modifier", None)\n     for modifier_id, modifier in tool.objectItems():\n         if not IConditionalModifier.providedBy(modifier):\n             continue\ndiff --git a/Products/CMFEditions/subscriber.py b/Products/CMFEditions/subscriber.py\nindex d3a6161..b5adfd7 100644\n--- a/Products/CMFEditions/subscriber.py\n+++ b/Products/CMFEditions/subscriber.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2008 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -28,14 +27,14 @@\n \n \n def object_removed(obj, event):\n-    """ an object is being deleted -\n+    """an object is being deleted -\n     also delete it\'s history\n     """\n     if not IContentish.providedBy(obj):\n         return\n     try:\n-        histories_storage = getToolByName(obj, \'portal_historiesstorage\')\n-        repo_tool = getToolByName(obj, \'portal_repository\')\n+        histories_storage = getToolByName(obj, "portal_historiesstorage")\n+        repo_tool = getToolByName(obj, "portal_repository")\n     except AttributeError:\n         # XXX If tools are missing, there is nothing we can do.\n         # This occurs in some Products.CMFDiffTool and\n@@ -54,12 +53,10 @@ def object_removed(obj, event):\n         # do nothing\n         return\n     current = metadata.retrieve(num_versions - 1)\n-    sys_metadata = current[\'metadata\'][\'sys_metadata\']\n-    if (\'parent\' in sys_metadata) and \\\n-            (sys_metadata[\'parent\'][\'history_id\'] != histid):\n+    sys_metadata = current["metadata"]["sys_metadata"]\n+    if ("parent" in sys_metadata) and (sys_metadata["parent"]["history_id"] != histid):\n         try:\n-            histories_storage.retrieve(\n-                history_id=sys_metadata[\'parent\'][\'history_id\'])\n+            histories_storage.retrieve(history_id=sys_metadata["parent"]["history_id"])\n             return\n         except StorageRetrieveError:\n             pass\n@@ -68,5 +65,6 @@ def object_removed(obj, event):\n         histories_storage.purge(\n             histid,\n             0,\n-            metadata={\'sys_metadata\': {\'comment\': \'purged\'}},\n-            countPurged=False)\n+            metadata={"sys_metadata": {"comment": "purged"}},\n+            countPurged=False,\n+        )\ndiff --git a/Products/CMFEditions/testing.py b/Products/CMFEditions/testing.py\nindex 448454f..3bdab1f 100644\n--- a/Products/CMFEditions/testing.py\n+++ b/Products/CMFEditions/testing.py\n@@ -1,11 +1,10 @@\n-# -*- coding: utf-8 -*-\n from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FIXTURE\n from plone.app.robotframework.testing import REMOTE_LIBRARY_BUNDLE_FIXTURE\n from plone.app.testing import applyProfile\n from plone.app.testing import FunctionalTesting\n from plone.app.testing import IntegrationTesting\n from plone.app.testing import PloneSandboxLayer\n-from plone.testing import z2\n+from plone.testing.zope import WSGI_SERVER_FIXTURE\n \n import Products.CMFEditions\n \n@@ -21,15 +20,13 @@ def setUpZope(self, app, configurationContext):\n         self.loadZCML(package=Products.CMFEditions)\n \n     def setUpPloneSite(self, portal):\n-        applyProfile(portal, \'Products.CMFEditions:CMFEditions\')\n+        applyProfile(portal, "Products.CMFEditions:CMFEditions")\n         # with named AND dotted behaviors we need to take care of both\n-        versioning_behavior = set(\n-            [\n-                \'plone.app.versioningbehavior.behaviors.IVersionable\',\n-                \'plone.versioning\',\n-            ],\n-        )\n-        for name in (\'Document\', \'Event\', \'Link\', \'News Item\'):\n+        versioning_behavior = {\n+            "plone.app.versioningbehavior.behaviors.IVersionable",\n+            "plone.versioning",\n+        }\n+        for name in ("Document", "Event", "Link", "News Item"):\n             fti = portal.portal_types[name]\n             # write back the behaviors without the versioning behaviors\n             # using a Set to keep it simple\n@@ -46,13 +43,13 @@ def setUpPloneSite(self, portal):\n \n PRODUCTS_CMFEDITIONS_INTEGRATION_TESTING = IntegrationTesting(\n     bases=(PRODUCTS_CMFEDITIONS_FIXTURE,),\n-    name=\'ProductsCmfeditionsLayer:IntegrationTesting\',\n+    name="ProductsCmfeditionsLayer:IntegrationTesting",\n )\n \n \n PRODUCTS_CMFEDITIONS_FUNCTIONAL_TESTING = FunctionalTesting(\n     bases=(PRODUCTS_CMFEDITIONS_FIXTURE,),\n-    name=\'ProductsCmfeditionsLayer:FunctionalTesting\',\n+    name="ProductsCmfeditionsLayer:FunctionalTesting",\n )\n \n \n@@ -60,7 +57,7 @@ def setUpPloneSite(self, portal):\n     bases=(\n         PRODUCTS_CMFEDITIONS_FIXTURE,\n         REMOTE_LIBRARY_BUNDLE_FIXTURE,\n-        z2.ZSERVER_FIXTURE,\n+        WSGI_SERVER_FIXTURE,\n     ),\n-    name=\'ProductsCmfeditionsLayer:AcceptanceTesting\',\n+    name="ProductsCmfeditionsLayer:AcceptanceTesting",\n )\ndiff --git a/Products/CMFEditions/tests/DummyTools.py b/Products/CMFEditions/tests/DummyTools.py\nindex 67e0bda..d3ef61d 100644\n--- a/Products/CMFEditions/tests/DummyTools.py\n+++ b/Products/CMFEditions/tests/DummyTools.py\n@@ -1,9 +1,10 @@\n-# -*- coding: utf-8 -*-\n-\n from Acquisition import aq_base\n from copy import deepcopy\n from DateTime import DateTime\n+from io import BytesIO\n from OFS.SimpleItem import SimpleItem\n+from pickle import Pickler\n+from pickle import Unpickler\n from Products.CMFCore.utils import getToolByName\n from Products.CMFEditions.ArchivistTool import ObjectData\n from Products.CMFEditions.ArchivistTool import ObjectManagerStorageAdapter\n@@ -17,20 +18,14 @@\n from Products.CMFEditions.interfaces.IStorage import StorageRetrieveError\n from Products.CMFEditions.interfaces.IStorage import StorageUnregisteredError\n from Products.CMFEditions.utilities import dereference\n-from six import BytesIO\n-from six.moves.cPickle import Pickler\n-from six.moves.cPickle import Unpickler\n from zope.interface import implementer\n \n-import types\n-\n \n # Make alog module level so that it survives transaction rollbacks\n alog = []\n \n \n class Dummy(SimpleItem):\n-\n     def __init__(self):\n         now = DateTime()\n         self.modification_date = now\n@@ -45,10 +40,12 @@ def notifyModified(self):\n class UniqueIdError(Exception):\n     pass\n \n+\n class DummyBaseTool(SimpleItem):\n     def getId(self):\n         return self.id\n \n+\n def deepCopy(obj):\n     stream = BytesIO()\n     p = Pickler(stream, 1)\n@@ -57,6 +54,7 @@ def deepCopy(obj):\n     u = Unpickler(stream)\n     return u.load()\n \n+\n def notifyModified(obj):\n     """Notify the object as modified.\n \n@@ -64,14 +62,15 @@ def notifyModified(obj):\n     notifies the object as modified (faster than time.sleep(2)).\n     """\n     t = obj.modified()\n-    while t == DateTime(): pass\n+    while t == DateTime():\n+        pass\n     obj.notifyModified()\n \n \n class DummyArchivist(SimpleItem):\n-    """Archivist simulating modifiers and history storage.\n-    """\n-    id = \'portal_archivist\'\n+    """Archivist simulating modifiers and history storage."""\n+\n+    id = "portal_archivist"\n \n     def getId(self):\n         return self.id\n@@ -80,7 +79,7 @@ def __init__(self):\n         self._archive = {}\n         self._counter = 0\n         self.reset_log()\n-        self.alog_indent = \'\'\n+        self.alog_indent = ""\n \n     def log(self, msg):\n         alog.append(msg)\n@@ -101,58 +100,60 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n             # (the current implementation isn\'t able yet to handle multiple\n             # locations. Nevertheless lets set the location id to a well\n             # known default value)\n-            portal_hidhandler = getToolByName(obj, \'portal_historyidhandler\')\n+            portal_hidhandler = getToolByName(obj, "portal_historyidhandler")\n             history_id = portal_hidhandler.register(obj)\n-            version_id = obj.version_id = 0\n+            obj.version_id = 0\n             obj.location_id = 0\n             is_registered = False\n         else:\n-            version_id = len(self.queryHistory(obj))\n             is_registered = True\n \n         base_obj = aq_base(obj)\n-        doc1_inside = getattr(base_obj, \'doc1_inside\', None)\n-        doc2_inside = getattr(base_obj, \'doc2_inside\', None)\n-        doc3_outside = getattr(base_obj, \'doc3_outside\', None)\n+        doc1_inside = getattr(base_obj, "doc1_inside", None)\n+        doc2_inside = getattr(base_obj, "doc2_inside", None)\n+        doc3_outside = getattr(base_obj, "doc3_outside", None)\n \n         # simulate clone modifiers\n         icrefs = []\n         ocrefs = []\n         clone = deepCopy(base_obj)\n         if doc1_inside is not None:\n-            icrefs.append(ObjectManagerStorageAdapter(clone, \'doc1_inside\'))\n+            icrefs.append(ObjectManagerStorageAdapter(clone, "doc1_inside"))\n         if doc2_inside is not None:\n-            icrefs.append(ObjectManagerStorageAdapter(clone, \'doc2_inside\'))\n+            icrefs.append(ObjectManagerStorageAdapter(clone, "doc2_inside"))\n         if doc3_outside is not None:\n-            ocrefs.append(ObjectManagerStorageAdapter(clone, \'doc3_outside\'))\n+            ocrefs.append(ObjectManagerStorageAdapter(clone, "doc3_outside"))\n         crefs = icrefs + ocrefs\n \n         # simulate before save modifier\n         iorefs = []\n         oorefs = []\n         if doc1_inside is not None:\n-            iorefs.append(getattr(obj, \'doc1_inside\'))\n+            iorefs.append(getattr(obj, "doc1_inside"))\n         if doc2_inside is not None:\n-            iorefs.append(getattr(obj, \'doc2_inside\'))\n+            iorefs.append(getattr(obj, "doc2_inside"))\n         if doc3_outside is not None:\n-            oorefs.append(getattr(obj, \'doc3_outside\'))\n+            oorefs.append(getattr(obj, "doc3_outside"))\n         orefs = iorefs + oorefs\n         for cref in crefs:\n             cref.setAttribute(VersionAwareReference())\n \n         # log\n-        if sys_metadata[\'originator\'] is None:\n+        if sys_metadata["originator"] is None:\n             self.log("")\n         if orefs:\n-            self.log("%sprepare %s: hid=%s, refs=(%s)"\n-                        % (self.alog_indent,\n-                           obj.getId(),\n-                           history_id,\n-                           \', \'.join([ref.getId() for ref in orefs])))\n+            self.log(\n+                "%sprepare %s: hid=%s, refs=(%s)"\n+                % (\n+                    self.alog_indent,\n+                    obj.getId(),\n+                    history_id,\n+                    ", ".join([ref.getId() for ref in orefs]),\n+                )\n+            )\n         else:\n-            self.log("%sprepare %s: hid=%s"\n-                        % (self.alog_indent, obj.getId(), history_id))\n-        self.alog_indent += \'  \'\n+            self.log(f"{self.alog_indent}prepare {obj.getId()}: hid={history_id}")\n+        self.alog_indent += "  "\n \n         # prepare object structure\n         original_info = ObjectData(obj, iorefs, oorefs)\n@@ -160,16 +161,28 @@ def prepare(self, obj, app_metadata=None, sys_metadata={}):\n \n         approxSize = None\n \n-        return PreparedObject(history_id, original_info, clone_info, (),\n-                              app_metadata, sys_metadata, is_registered, approxSize)\n+        return PreparedObject(\n+            history_id,\n+            original_info,\n+            clone_info,\n+            (),\n+            app_metadata,\n+            sys_metadata,\n+            is_registered,\n+            approxSize,\n+        )\n \n     def register(self, prepared_obj):\n         # log\n-        self.log("%sregister %s: hid=%s, is_registered=%s"\n-                    % (self.alog_indent,\n-                       prepared_obj.original.object.getId(),\n-                       prepared_obj.history_id,\n-                       prepared_obj.is_registered))\n+        self.log(\n+            "%sregister %s: hid=%s, is_registered=%s"\n+            % (\n+                self.alog_indent,\n+                prepared_obj.original.object.getId(),\n+                prepared_obj.history_id,\n+                prepared_obj.is_registered,\n+            )\n+        )\n \n         if not prepared_obj.is_registered:\n             # new empty history\n@@ -179,7 +192,9 @@ def register(self, prepared_obj):\n     def save(self, prepared_obj, autoregister=False):\n         if not prepared_obj.is_registered:\n             if not autoregister:\n-                raise ArchivistError("not registered: %s " % prepared_obj.original.object)\n+                raise ArchivistError(\n+                    "not registered: %s " % prepared_obj.original.object\n+                )\n             self._archive[prepared_obj.history_id] = []\n \n         # log\n@@ -187,52 +202,65 @@ def save(self, prepared_obj, autoregister=False):\n \n         irefs = [ref.getAttribute() for ref in prepared_obj.clone.inside_refs]\n         orefs = [ref.getAttribute() for ref in prepared_obj.clone.outside_refs]\n-        irefs_prep = [\'{hid:%s, vid:%s}\' % (r.history_id, r.version_id)\n-                      for r in irefs]\n-        orefs_prep = [\'{hid:%s, vid:%s}\' % (r.history_id, r.version_id)\n-                      for r in orefs]\n-        irefs = \', \'.join(irefs_prep)\n-        orefs = \', \'.join(orefs_prep)\n+        irefs_prep = [f"{{hid:{r.history_id}, vid:{r.version_id}}}" for r in irefs]\n+        orefs_prep = [f"{{hid:{r.history_id}, vid:{r.version_id}}}" for r in orefs]\n+        irefs = ", ".join(irefs_prep)\n+        orefs = ", ".join(orefs_prep)\n         if irefs:\n             irefs = "irefs=(%s), " % irefs\n         if orefs:\n             orefs = "orefs=(%s), " % orefs\n         refs = irefs + orefs\n-        self.log("%ssave    %s: hid=%s, %sisreg=%s, auto=%s"\n-                    % (self.alog_indent,\n-                       prepared_obj.original.object.getId(),\n-                       prepared_obj.history_id,\n-                       refs,\n-                       prepared_obj.is_registered,\n-                       autoregister))\n+        self.log(\n+            "%ssave    %s: hid=%s, %sisreg=%s, auto=%s"\n+            % (\n+                self.alog_indent,\n+                prepared_obj.original.object.getId(),\n+                prepared_obj.history_id,\n+                refs,\n+                prepared_obj.is_registered,\n+                autoregister,\n+            )\n+        )\n \n         # save in the format the data needs to be retrieved\n         svdata = {\n-            \'clone\': prepared_obj.clone,\n-            \'referenced_data\': prepared_obj.referenced_data,\n-            \'metadata\': prepared_obj.metadata,\n+            "clone": prepared_obj.clone,\n+            "referenced_data": prepared_obj.referenced_data,\n+            "metadata": prepared_obj.metadata,\n         }\n         # storage simulation\n         self._archive[prepared_obj.history_id].append(svdata)\n \n-    def retrieve(self, obj=None, history_id=None, selector=None, preserve=(),\n-                 countPurged=True):\n+    def retrieve(\n+        self, obj=None, history_id=None, selector=None, preserve=(), countPurged=True\n+    ):\n         obj, history_id = dereference(obj, history_id, self)\n         if selector is None:\n-            selector = len(self._archive[history_id]) - 1  #HEAD\n+            selector = len(self._archive[history_id]) - 1  # HEAD\n \n-        self.log("%sretrieve %s: hid=%s, selector=%s"\n-                    % (self.alog_indent, obj.getId(), history_id, selector))\n+        self.log(\n+            "%sretrieve %s: hid=%s, selector=%s"\n+            % (self.alog_indent, obj.getId(), history_id, selector)\n+        )\n \n         data = self._archive[history_id][selector]\n-        attr_handling_references = [\'_objects\',\'_tree\',\'_count\',\'_mt_index\', \'__annotations__\']\n-        attr_handling_references.extend(data[\'clone\'].object.objectIds())\n+        attr_handling_references = [\n+            "_objects",\n+            "_tree",\n+            "_count",\n+            "_mt_index",\n+            "__annotations__",\n+        ]\n+        attr_handling_references.extend(data["clone"].object.objectIds())\n         attr_handling_references.extend(obj.objectIds())\n-        vdata = VersionData(data[\'clone\'],\n-                    [],\n-                    attr_handling_references,\n-                    data[\'referenced_data\'],\n-                    data[\'metadata\'])\n+        vdata = VersionData(\n+            data["clone"],\n+            [],\n+            attr_handling_references,\n+            data["referenced_data"],\n+            data["metadata"],\n+        )\n \n         return deepCopy(vdata)\n \n@@ -242,10 +270,9 @@ def getHistory(self, obj=None, history_id=None, preserve=()):\n \n     def getHistoryMetadata(self, obj=None, history_id=None):\n         obj, history_id = dereference(obj, history_id, self)\n-        return [item[\'metadata\'] for item in self._archive[history_id]]\n+        return [item["metadata"] for item in self._archive[history_id]]\n \n-    def queryHistory(self, obj=None, history_id=None,\n-                     preserve=(), default=None):\n+    def queryHistory(self, obj=None, history_id=None, preserve=(), default=None):\n         if default is None:\n             default = []\n         try:\n@@ -269,12 +296,12 @@ def __init__(self, **info):\n         self.info = info\n \n     def setReference(self, target_obj, remove_info=True):\n-        portal_hidhandler = getToolByName(target_obj, \'portal_historyidhandler\')\n-        portal_archivist = getToolByName(target_obj, \'portal_archivist\')\n+        portal_hidhandler = getToolByName(target_obj, "portal_historyidhandler")\n+        portal_archivist = getToolByName(target_obj, "portal_archivist")\n         self.history_id = portal_hidhandler.queryUid(target_obj)\n-        self.version_id = len(portal_archivist.queryHistory(target_obj))-1\n-        self.location_id = 1 # only one location possible currently\n-        if remove_info and hasattr(self, \'info\'):\n+        self.version_id = len(portal_archivist.queryHistory(target_obj)) - 1\n+        self.location_id = 1  # only one location possible currently\n+        if remove_info and hasattr(self, "info"):\n             self.info = None\n \n     def __of__(self, parent):\n@@ -282,10 +309,10 @@ def __of__(self, parent):\n \n \n class DummyModifier(DummyBaseTool):\n-    id = \'portal_modifier\'\n+    id = "portal_modifier"\n \n     def beforeSaveModifier(self, obj, clone):\n-        return {}, [], [] # XXX 2nd and 3rd shall be lists\n+        return {}, [], []  # XXX 2nd and 3rd shall be lists\n \n     def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         preserved = {}\n@@ -304,16 +331,16 @@ def reattachReferencedAttributes(self, object, referenced_data):\n     def getOnCloneModifiers(self, obj):\n         return None\n \n+\n class FolderishContentObjectModifier(DummyBaseTool):\n-    """This is a full fledged modifier.\n-    """\n+    """This is a full fledged modifier."""\n \n-    id = \'portal_modifier\'\n+    id = "portal_modifier"\n \n     def getReferencedAttributes(self, obj):\n         # we declare the title beeing a big blob we don\'t want to be\n         # pickled and unpickled by the archivist\n-        return {\'title\': obj.title}\n+        return {"title": obj.title}\n \n     def getOnCloneModifiers(self, obj):\n         """Removes childrens ending with \'_inside\' or \'_outside\'.\n@@ -322,7 +349,7 @@ def getOnCloneModifiers(self, obj):\n         \'_outside\' by a uninitialzed \'IVersionAwareReference\'.\n         All other childrens get versioned with the parent.\n         """\n-        portal_archivist = getToolByName(obj, \'portal_archivist\')\n+        portal_archivist = getToolByName(obj, "portal_archivist")\n         VersionAwareReference = portal_archivist.classes.VersionAwareReference\n \n         # do not pickle the object managers subobjects\n@@ -331,10 +358,10 @@ def getOnCloneModifiers(self, obj):\n         inside_refs = []\n         for name, sub in obj.objectItems():\n             pyid = id(aq_base(sub))\n-            if name.endswith(\'_inside\'):\n+            if name.endswith("_inside"):\n                 inside_refs.append(sub)\n                 refs[pyid] = True\n-            elif name.endswith(\'_outside\'):\n+            elif name.endswith("_outside"):\n                 outside_refs.append(sub)\n                 refs[pyid] = True\n \n@@ -364,14 +391,14 @@ def persistent_load(pid):\n             # should never reach this!\n             assert False\n \n-        return persistent_id, persistent_load, inside_refs, outside_refs, \'\'\n+        return persistent_id, persistent_load, inside_refs, outside_refs, ""\n \n     def beforeSaveModifier(self, obj, clone):\n         """Returns all unititialized \'IVersionAwareReference\' objects.\n \n         This allways goes in conjunction with \'getOnCloneModifiers\'.\n         """\n-        portal_archivist = getToolByName(obj, \'portal_archivist\')\n+        portal_archivist = getToolByName(obj, "portal_archivist")\n         AttributeAdapter = portal_archivist.classes.AttributeAdapter\n \n         # just return adapters to the attributes that were replaced by\n@@ -379,9 +406,9 @@ def beforeSaveModifier(self, obj, clone):\n         outside_refs = []\n         inside_refs = []\n         for name in clone.objectIds():\n-            if name.endswith(\'_inside\'):\n+            if name.endswith("_inside"):\n                 inside_refs.append(AttributeAdapter(clone, name))\n-            elif name.endswith(\'_outside\'):\n+            elif name.endswith("_outside"):\n                 outside_refs.append(AttributeAdapter(clone, name))\n \n         return {}, inside_refs, outside_refs\n@@ -401,13 +428,15 @@ def reattachReferencedAttributes(self, object, referenced_data):\n             setattr(object, key, value)\n \n     def _getAttributeNamesHandlingSubObjects(self, obj):\n-        return [\'_objects\', \'_tree\', \'_count\', \'_mt_index\', \'__annotations__\'].extend(obj.objectIds())\n+        return ["_objects", "_tree", "_count", "_mt_index", "__annotations__"].extend(\n+            obj.objectIds()\n+        )\n \n \n class DummyHistoryIdHandler(DummyBaseTool):\n-    id = \'portal_historyidhandler\'\n+    id = "portal_historyidhandler"\n \n-    UID_ATTRIBUTE_NAME = \'editions_uhid\'\n+    UID_ATTRIBUTE_NAME = "editions_uhid"\n \n     uhid_counter = 0\n \n@@ -439,31 +468,33 @@ def queryObject(self, uid, default=None):\n         except KeyError:\n             return default\n \n+\n #    def setUid(self, obj, uid, check_uniqueness=True):\n #        setattr(obj, self.UID_ATTRIBUTE_NAME, uid)\n \n+\n class StorageVersionData:\n     def __init__(self, object, referenced_data, metadata):\n         self.object = object\n         self.referenced_data = referenced_data\n         self.metadata = metadata\n+\n     def isValid(self):\n         return not isinstance(self.object, Removed)\n \n+\n class Removed:\n-    """Indicates that removement of data\n-    """\n+    """Indicates that removement of data"""\n \n     def __init__(self, reason, metadata):\n-        """Store Removed Info\n-        """\n+        """Store Removed Info"""\n         self.reason = reason\n         self.metadata = metadata\n \n+\n @implementer(IStorage, IPurgeSupport)\n class MemoryStorage(DummyBaseTool):\n-    id = \'portal_historiesstorage\'\n-\n+    id = "portal_historiesstorage"\n \n     def __init__(self):\n         self._histories = {}\n@@ -471,26 +502,26 @@ def __init__(self):\n     def register(self, history_id, object, referenced_data={}, metadata=None):\n         histories = self._histories\n         if history_id not in histories.keys():\n-           return self._save(history_id, object, referenced_data, metadata)\n+            return self._save(history_id, object, referenced_data, metadata)\n \n     def save(self, history_id, object, referenced_data={}, metadata=None):\n         # delegate the decission what to purge to the purge policy tool\n         # if it exists. If the call returns ``True`` do not save the current\n         # version.\n-        policy = getToolByName(self, \'portal_purgepolicy\', None)\n+        policy = getToolByName(self, "portal_purgepolicy", None)\n         if policy is not None:\n             if not policy.beforeSaveHook(history_id, metadata):\n                 return len(self._histories[history_id]) - 1\n \n-        if not history_id in self._histories:\n+        if history_id not in self._histories:\n             raise StorageUnregisteredError(\n                 "Saving or retrieving an unregistered object is not "\n                 "possible. Register the object with history id \'%s\' first. "\n-                % history_id)\n+                % history_id\n+            )\n \n         return self._save(history_id, object, referenced_data, metadata)\n \n-\n     def _save(self, history_id, object, referenced_data={}, metadata=None):\n         histories = self._histories\n         cloned_referenced_data = {}\n@@ -501,9 +532,11 @@ def _save(self, history_id, object, referenced_data={}, metadata=None):\n                 cloned_referenced_data[key] = deepCopy(ref.getObject())\n             else:\n                 cloned_referenced_data[key] = deepCopy(ref)\n-        vdata = StorageVersionData(object=deepCopy(object),\n-                                   referenced_data=cloned_referenced_data,\n-                                   metadata=metadata)\n+        vdata = StorageVersionData(\n+            object=deepCopy(object),\n+            referenced_data=cloned_referenced_data,\n+            metadata=metadata,\n+        )\n         if history_id in histories.keys():\n             histories[history_id].append(vdata)\n         else:\n@@ -511,8 +544,7 @@ def _save(self, history_id, object, referenced_data={}, metadata=None):\n \n         return len(histories[history_id]) - 1\n \n-    def retrieve(self, history_id, selector=None,\n-                 countPurged=True, substitute=True):\n+    def retrieve(self, history_id, selector=None, countPurged=True, substitute=True):\n         if selector is None:\n             selector = len(self._getHistory(history_id)) - 1\n \n@@ -520,14 +552,15 @@ def retrieve(self, history_id, selector=None,\n             try:\n                 vdata = self._getHistory(history_id)[selector]\n             except IndexError:\n-                raise StorageRetrieveError("Retrieving non existing version %s"\n-                                           % selector)\n+                raise StorageRetrieveError(\n+                    "Retrieving non existing version %s" % selector\n+                )\n \n             vdata.referenced_data = deepcopy(vdata.referenced_data)\n             if substitute and isinstance(vdata.object, Removed):\n                 # delegate retrieving to purge policy if one is available\n                 # if none is available just return "the removed object"\n-                policy = getToolByName(self, \'portal_purgepolicy\', None)\n+                policy = getToolByName(self, "portal_purgepolicy", None)\n                 if policy is not None:\n                     vdata = policy.retrieveSubstitute(history_id, selector, vdata)\n             return vdata\n@@ -540,11 +573,9 @@ def retrieve(self, history_id, selector=None,\n                 if valid == selector:\n                     return vdata\n                 valid += 1\n-            raise StorageRetrieveError("Retrieving non existing version %s"\n-                                       % selector)\n+            raise StorageRetrieveError("Retrieving non existing version %s" % selector)\n \n-    def getHistory(self, history_id, preserve=(), countPurged=True,\n-                   substitute=True):\n+    def getHistory(self, history_id, preserve=(), countPurged=True, substitute=True):\n         history = []\n         sel = 0\n \n@@ -564,18 +595,17 @@ def getHistoryMetadata(self, history_id):\n     def isRegistered(self, history_id):\n         return history_id in self._histories\n \n-    def getModificationDate(self, history_id, selector=None,\n-                            countPurged=True, substitute=True):\n+    def getModificationDate(\n+        self, history_id, selector=None, countPurged=True, substitute=True\n+    ):\n         vdata = self.retrieve(history_id, selector, countPurged, substitute)\n         return vdata.object.object.modified()\n \n     def purge(self, history_id, selector, metadata={}, countPurged=True):\n-        """See ``IPurgeSupport``\n-        """\n+        """See ``IPurgeSupport``"""\n         histories = self._histories\n         history = histories[history_id]\n-        vdata = self.retrieve(history_id, selector, countPurged,\n-                              substitute=False)\n+        vdata = self.retrieve(history_id, selector, countPurged, substitute=False)\n         selector = history.index(vdata)\n         if not isinstance(vdata.object, Removed):\n             # prepare replacement for the deleted object and metadata\n@@ -591,14 +621,12 @@ def _getHistory(self, history_id):\n             raise StorageUnregisteredError(\n                 "Saving or retrieving an unregistered object is not "\n                 "possible. Register the object with history id \'%s\' first. "\n-                % history_id)\n+                % history_id\n+            )\n         return history\n-#        return HistoryList(history)\n \n     def _getLength(self, history_id, countPurged=True):\n-        """Returns the length of the history\n-        """\n-        histories = self._histories\n+        """Returns the length of the history"""\n         history = self._getHistory(history_id)\n         if countPurged:\n             return len(history)\n@@ -612,26 +640,27 @@ def _getLength(self, history_id, countPurged=True):\n \n \n class HistoryList(list):\n-    """\n-    """\n+    """ """\n+\n     def __getitem__(self, selector):\n         if selector is None:\n             selector = -1\n         try:\n-           return list.__getitem__(self, selector)\n+            return list.__getitem__(self, selector)\n         except IndexError:\n             raise StorageRetrieveError("Retrieving non existing version %s" % selector)\n \n     def retrieve(self, selector, ignored=True):\n-       """Faux metadata only retrieval"""\n-       item = self[selector]\n-       return {\'metadata\': item.metadata}\n+        """Faux metadata only retrieval"""\n+        item = self[selector]\n+        return {"metadata": item.metadata}\n+\n \n @implementer(IPurgePolicy)\n class DummyPurgePolicy(DummyBaseTool):\n-    """Dummy Purge Policy\n-    """\n-    id = \'portal_purgepolicy\'\n+    """Dummy Purge Policy"""\n+\n+    id = "portal_purgepolicy"\n \n     def beforeSaveHook(self, history_id, obj, metadata={}):\n         """Purge old versions\n@@ -639,7 +668,7 @@ def beforeSaveHook(self, history_id, obj, metadata={}):\n         Purges old version so that at maximum two versions reside in\n         the history.\n         """\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+        storage = getToolByName(self, "portal_historiesstorage")\n         currentVersion = len(storage.getHistory(history_id))\n         while True:\n             length = len(storage.getHistory(history_id, countPurged=False))\n@@ -652,9 +681,8 @@ def beforeSaveHook(self, history_id, obj, metadata={}):\n         return True\n \n     def retrieveSubstitute(self, history_id, selector, default=None):\n-        """Retrives the next older version\n-        """\n-        storage = getToolByName(self, \'portal_historiesstorage\')\n+        """Retrives the next older version"""\n+        storage = getToolByName(self, "portal_historiesstorage")\n         while selector:\n             selector -= 1\n             data = storage.retrieve(history_id, selector, substitute=False)\n@@ -665,9 +693,9 @@ def retrieveSubstitute(self, history_id, selector, default=None):\n \n @implementer(IStorage, IPurgeSupport)\n class PurgePolicyTestDummyStorage(DummyBaseTool):\n-    """Partial Storage used for PurgePolicy Tetss\n-    """\n-    id = \'portal_historiesstorage\'\n+    """Partial Storage used for PurgePolicy Tetss"""\n+\n+    id = "portal_historiesstorage"\n \n     def __init__(self):\n         self.history = []\n@@ -675,22 +703,19 @@ def __init__(self):\n     def save(self, history_id, obj):\n         self.history.append(obj)\n \n-    def getHistory(self, history_id, preserve=(), countPurged=True,\n-                   substitute=True):\n+    def getHistory(self, history_id, preserve=(), countPurged=True, substitute=True):\n         return self.history\n \n-    def purge(self, history_id, selector, metadata={},\n-              countPurged=True):\n+    def purge(self, history_id, selector, metadata={}, countPurged=True):\n         del self.history[selector]\n \n-    def retrieve(self, history_id, selector=None,\n-                 countPurged=True, substitute=True):\n+    def retrieve(self, history_id, selector=None, countPurged=True, substitute=True):\n         if selector >= len(self.history):\n             raise StorageRetrieveError()\n         return self.history[selector]\n \n \n-class DummyData(object):\n+class DummyData:\n     def __init__(self, data):\n         self.data = data\n \n@@ -698,6 +723,6 @@ def isValid(self):\n         return True\n \n \n-class RemovedData(object):\n+class RemovedData:\n     def isValid(self):\n         return False\ndiff --git a/Products/CMFEditions/tests/__init__.py b/Products/CMFEditions/tests/__init__.py\nindex ba86dce..bbb5516 100644\n--- a/Products/CMFEditions/tests/__init__.py\n+++ b/Products/CMFEditions/tests/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """\\\n Unit test package for CMFEditions\n """\ndiff --git a/Products/CMFEditions/tests/base.py b/Products/CMFEditions/tests/base.py\nindex 86bdef3..88f034e 100644\n--- a/Products/CMFEditions/tests/base.py\n+++ b/Products/CMFEditions/tests/base.py\n@@ -6,11 +6,11 @@\n \n \n class CMFEditionsBaseTestCase(unittest.TestCase):\n-    """ A base class for Products.CMFEditions testing """\n+    """A base class for Products.CMFEditions testing"""\n \n     layer = PRODUCTS_CMFEDITIONS_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\ndiff --git a/Products/CMFEditions/tests/test_ArchivistTool.py b/Products/CMFEditions/tests/test_ArchivistTool.py\nindex 56cfac6..c2de356 100644\n--- a/Products/CMFEditions/tests/test_ArchivistTool.py\n+++ b/Products/CMFEditions/tests/test_ArchivistTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -36,21 +35,19 @@\n \n \n class TestArchivistToolMemoryStorage(CMFEditionsBaseTestCase):\n-\n     def setUp(self):\n-        super(TestArchivistToolMemoryStorage, self).setUp()\n-\n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\',\n-                                                [\'Manager\'], \'\')\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n-        self.portal.invokeFactory(\'Folder\', \'fol\')\n-        self.portal.fol.invokeFactory(\'Document\', \'doc1_inside\')\n-        self.portal.fol.invokeFactory(\'Document\', \'doc2_inside\')\n-        self.portal.fol.invokeFactory(\'Document\', \'doc3_outside\')\n+        super().setUp()\n+\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n+        self.portal.invokeFactory("Document", "doc")\n+        self.portal.invokeFactory("Folder", "fol")\n+        self.portal.fol.invokeFactory("Document", "doc1_inside")\n+        self.portal.fol.invokeFactory("Document", "doc2_inside")\n+        self.portal.fol.invokeFactory("Document", "doc3_outside")\n         tools = (\n             DummyModifier(),\n             DummyHistoryIdHandler(),\n-            )\n+        )\n         for tool in tools:\n             self._setDummyTool(tool)\n \n@@ -77,7 +74,7 @@ def test01_registerAttachesAHistoryId(self):\n         portal_archivist = self.portal.portal_archivist\n         portal_historyidhandler = self.portal.portal_historyidhandler\n         doc = self.portal.doc\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n         history_id = portal_historyidhandler.queryUid(doc)\n         self.assertTrue(history_id)\n@@ -86,107 +83,110 @@ def test02_retrieve(self):\n         portal_archivist = self.portal.portal_archivist\n         portal_historyidhandler = self.portal.portal_historyidhandler\n         doc = self.portal.doc\n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n-        vdata = portal_archivist.retrieve(obj=doc, selector=0, preserve=(\'gaga\', \'gugus\'))\n+        vdata = portal_archivist.retrieve(\n+            obj=doc, selector=0, preserve=("gaga", "gugus")\n+        )\n         retr_doc = vdata.data.object\n         retr_meta = vdata.app_metadata\n         doc_histid = portal_historyidhandler.queryUid(doc)\n         retr_histid = portal_historyidhandler.queryUid(retr_doc)\n         self.assertEqual(doc_histid, retr_histid)\n         # check if correct version retrieved and working object unchanged\n-        self.assertEqual(retr_doc.text , \'text v1\')\n-        self.assertEqual(retr_meta , \'save number 1\')\n-        self.assertEqual(doc.text , \'text v2\')\n+        self.assertEqual(retr_doc.text, "text v1")\n+        self.assertEqual(retr_meta, "save number 1")\n+        self.assertEqual(doc.text, "text v2")\n         self.assertEqual(len(vdata.preserved_data), 2)\n-        self.assertEqual(vdata.preserved_data[\'gaga\'], \'gaga\')\n-        self.assertEqual(vdata.preserved_data[\'gugus\'], \'gugus\')\n+        self.assertEqual(vdata.preserved_data["gaga"], "gaga")\n+        self.assertEqual(vdata.preserved_data["gugus"], "gugus")\n \n     def test03_retrieveById(self):\n         portal_archivist = self.portal.portal_archivist\n         portal_historyidhandler = self.portal.portal_historyidhandler\n         doc = self.portal.doc\n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n         doc_histid = portal_historyidhandler.queryUid(doc)\n-        vdata = portal_archivist.retrieve(history_id=doc_histid, selector=0,\n-                                          preserve=(\'gaga\', \'gugus\'))\n+        vdata = portal_archivist.retrieve(\n+            history_id=doc_histid, selector=0, preserve=("gaga", "gugus")\n+        )\n         retr_doc = vdata.data.object\n         retr_meta = vdata.app_metadata\n         # check if correct version retrieved and working object unchanged\n-        self.assertEqual(retr_doc.text , \'text v1\')\n-        self.assertEqual(retr_meta , \'save number 1\')\n-        self.assertEqual(doc.text , \'text v2\')\n+        self.assertEqual(retr_doc.text, "text v1")\n+        self.assertEqual(retr_meta, "save number 1")\n+        self.assertEqual(doc.text, "text v2")\n         self.assertEqual(len(vdata.preserved_data), 2)\n-        self.assertEqual(vdata.preserved_data[\'gaga\'], \'gaga\')\n-        self.assertEqual(vdata.preserved_data[\'gugus\'], \'gugus\')\n+        self.assertEqual(vdata.preserved_data["gaga"], "gaga")\n+        self.assertEqual(vdata.preserved_data["gugus"], "gugus")\n \n     def test04_getHistory(self):\n         portal_archivist = self.portal.portal_archivist\n         doc = self.portal.doc\n \n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n \n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n \n         history = portal_archivist.getHistory(doc)\n \n         self.assertEqual(len(history), 2)\n         # check if timestamp and principal available\n-        self.assertTrue(history[0].sys_metadata[\'timestamp\'])\n-        self.assertTrue(history[0].sys_metadata[\'principal\'])\n+        self.assertTrue(history[0].sys_metadata["timestamp"])\n+        self.assertTrue(history[0].sys_metadata["principal"])\n         # check if correct data and metadata retrieved\n-        self.assertEqual(history[0].data.object.text, \'text v1\')\n-        self.assertEqual(history[0].app_metadata, \'save number 1\')\n-        self.assertEqual(history[1].data.object.text, \'text v2\')\n-        self.assertEqual(history[1].app_metadata, \'save number 2\')\n+        self.assertEqual(history[0].data.object.text, "text v1")\n+        self.assertEqual(history[0].app_metadata, "save number 1")\n+        self.assertEqual(history[1].data.object.text, "text v2")\n+        self.assertEqual(history[1].app_metadata, "save number 2")\n \n     def test05_iterateOverHistory(self):\n         portal_archivist = self.portal.portal_archivist\n         doc = self.portal.doc\n \n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n \n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n \n-        doc.text = \'text v3\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 3\')\n+        doc.text = "text v3"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 3")\n         portal_archivist.save(prep)\n \n         counter = 0\n \n         for vdata in portal_archivist.getHistory(doc):\n             counter += 1\n-            self.assertEqual(vdata.data.object.text, \'text v%s\' % counter)\n-            self.assertEqual(vdata.app_metadata, \'save number %s\' % counter)\n+            self.assertEqual(vdata.data.object.text, "text v%s" % counter)\n+            self.assertEqual(vdata.app_metadata, "save number %s" % counter)\n \n     def test06_getHistoryById(self):\n         portal_archivist = self.portal.portal_archivist\n         portal_historyidhandler = self.portal.portal_historyidhandler\n         doc = self.portal.doc\n \n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n \n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n \n         doc_histid = portal_historyidhandler.queryUid(doc)\n@@ -194,13 +194,13 @@ def test06_getHistoryById(self):\n \n         self.assertEqual(len(history), 2)\n         # check if timestamp and principal available\n-        self.assertTrue(history[0].sys_metadata[\'timestamp\'])\n-        self.assertTrue(history[0].sys_metadata[\'principal\'])\n+        self.assertTrue(history[0].sys_metadata["timestamp"])\n+        self.assertTrue(history[0].sys_metadata["principal"])\n         # check if correct data and metadata retrieved\n-        self.assertEqual(history[0].data.object.text, \'text v1\')\n-        self.assertEqual(history[0].app_metadata, \'save number 1\')\n-        self.assertEqual(history[1].data.object.text, \'text v2\')\n-        self.assertEqual(history[1].app_metadata, \'save number 2\')\n+        self.assertEqual(history[0].data.object.text, "text v1")\n+        self.assertEqual(history[0].app_metadata, "save number 1")\n+        self.assertEqual(history[1].data.object.text, "text v2")\n+        self.assertEqual(history[1].app_metadata, "save number 2")\n \n     def test07_prepareObjectWithReferences(self):\n         # test with a different modifier\n@@ -214,11 +214,11 @@ def test07_prepareObjectWithReferences(self):\n         doc2_inside = fol.doc2_inside\n         doc3_outside = fol.doc3_outside\n \n-        doc1_inside.text = \'doc1_inside: inside reference\'\n-        doc2_inside.text = \'doc2_inside: inside reference\'\n-        doc3_outside.text = \'doc3_outside: outside reference\'\n+        doc1_inside.text = "doc1_inside: inside reference"\n+        doc2_inside.text = "doc2_inside: inside reference"\n+        doc3_outside.text = "doc3_outside: outside reference"\n \n-        prep = portal_archivist.prepare(fol, app_metadata=\'save number 1\')\n+        prep = portal_archivist.prepare(fol, app_metadata="save number 1")\n \n         self.assertEqual(fol, prep.original.object)\n \n@@ -229,7 +229,7 @@ def test07_prepareObjectWithReferences(self):\n         outside_refs = prep.clone.outside_refs\n         self.assertEqual(len(inside_refs), 2)\n         self.assertEqual(len(outside_refs), 1)\n-        refs = [ref.getAttribute() for ref in inside_refs+outside_refs]\n+        refs = [ref.getAttribute() for ref in inside_refs + outside_refs]\n         for ref in refs:\n             self.assertTrue(IVersionAwareReference.providedBy(ref))\n         cloneValues = prep.clone.object.objectValues()\n@@ -242,7 +242,7 @@ def test07_prepareObjectWithReferences(self):\n         outside_orefs = prep.original.outside_refs\n         self.assertEqual(len(inside_orefs), 2)\n         self.assertEqual(len(outside_orefs), 1)\n-        refs = inside_orefs+outside_orefs\n+        refs = inside_orefs + outside_orefs\n         originalValues = prep.original.object.objectValues()\n \n         for sub in originalValues:\n@@ -250,15 +250,16 @@ def test07_prepareObjectWithReferences(self):\n \n         # the clones and the originals refs must also reference the\n         # "same" object\n-        self.assertEqual(prep.clone.object.objectIds(),\n-                         prep.original.object.objectIds())\n+        self.assertEqual(\n+            prep.clone.object.objectIds(), prep.original.object.objectIds()\n+        )\n \n         self.assertEqual(len(prep.referenced_data), 1)\n-        self.assertTrue(prep.referenced_data[\'title\'] is fol.title)\n+        self.assertTrue(prep.referenced_data["title"] is fol.title)\n \n-        self.assertEqual(prep.metadata[\'app_metadata\'], \'save number 1\')\n-        self.assertTrue(\'timestamp\' in prep.metadata[\'sys_metadata\'])\n-        self.assertTrue(\'principal\' in prep.metadata[\'sys_metadata\'])\n+        self.assertEqual(prep.metadata["app_metadata"], "save number 1")\n+        self.assertTrue("timestamp" in prep.metadata["sys_metadata"])\n+        self.assertTrue("principal" in prep.metadata["sys_metadata"])\n \n         self._setDummyTool(DummyModifier())\n \n@@ -274,17 +275,17 @@ def test08_retrieveWithReferences(self):\n         doc2_inside = fol.doc2_inside\n         doc3_outside = fol.doc3_outside\n \n-        doc1_inside.text = \'doc1_inside: inside reference\'\n-        doc2_inside.text = \'doc2_inside: inside reference\'\n-        doc3_outside.text = \'doc3_outside: outside reference\'\n+        doc1_inside.text = "doc1_inside: inside reference"\n+        doc2_inside.text = "doc2_inside: inside reference"\n+        doc3_outside.text = "doc3_outside: outside reference"\n \n-        prep = portal_archivist.prepare(fol, app_metadata=\'save number 1\')\n+        prep = portal_archivist.prepare(fol, app_metadata="save number 1")\n \n         # just set the info to some value before save to test if the\n         # reference stuff is saved and retrieved correctly\n         inside_refs = prep.clone.inside_refs\n         outside_refs = prep.clone.outside_refs\n-        refs = [ref.getAttribute() for ref in inside_refs+outside_refs]\n+        refs = [ref.getAttribute() for ref in inside_refs + outside_refs]\n         for ref in refs:\n             ref.info = refs.index(ref)\n \n@@ -293,36 +294,36 @@ def test08_retrieveWithReferences(self):\n         retr = portal_archivist.retrieve(fol)\n \n         # check metadata\n-        self.assertEqual(retr.app_metadata, \'save number 1\')\n-        self.assertTrue(\'timestamp\' in retr.sys_metadata)\n-        self.assertTrue(\'principal\' in retr.sys_metadata)\n+        self.assertEqual(retr.app_metadata, "save number 1")\n+        self.assertTrue("timestamp" in retr.sys_metadata)\n+        self.assertTrue("principal" in retr.sys_metadata)\n \n         # check the references\n         inside_refs = retr.data.inside_refs\n         outside_refs = retr.data.outside_refs\n         self.assertEqual(len(inside_refs), 2)\n         self.assertEqual(len(outside_refs), 1)\n-        refs = [ref.getAttribute() for ref in inside_refs+outside_refs]\n+        refs = [ref.getAttribute() for ref in inside_refs + outside_refs]\n         for ref in refs:\n             self.assertTrue(IVersionAwareReference.providedBy(ref))\n             # check info value (see note above)\n-            self.assertEquals(ref.info, refs.index(ref))\n+            self.assertEqual(ref.info, refs.index(ref))\n \n     def test09_isUpToDate(self):\n         doc = self.portal.doc\n         portal_archivist = self.portal.portal_archivist\n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         v1 = portal_archivist.register(prep)\n \n         self.assertTrue(portal_archivist.isUpToDate(obj=doc))\n         self.assertTrue(portal_archivist.isUpToDate(obj=doc, selector=v1))\n \n-        doc.text = \'text v2\'\n+        doc.text = "text v2"\n         notifyModified(doc)\n         self.assertFalse(portal_archivist.isUpToDate(obj=doc))\n \n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         v2 = portal_archivist.save(prep)\n \n         self.assertTrue(portal_archivist.isUpToDate(obj=doc))\n@@ -333,34 +334,38 @@ def test09_getHistoryMetadata(self):\n         portal_archivist = self.portal.portal_archivist\n         doc = self.portal.doc\n \n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n \n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n \n         history = portal_archivist.getHistoryMetadata(doc)\n \n         self.assertEqual(len(history), 2)\n         # check if timestamp and principal available\n-        self.assertTrue(history.retrieve(1)[\'metadata\'][\'sys_metadata\'][\'timestamp\'])\n-        self.assertTrue(history.retrieve(0)[\'metadata\'][\'sys_metadata\'][\'principal\'])\n+        self.assertTrue(history.retrieve(1)["metadata"]["sys_metadata"]["timestamp"])\n+        self.assertTrue(history.retrieve(0)["metadata"]["sys_metadata"]["principal"])\n         # check if correct data and metadata retrieved\n-        self.assertEqual(history.retrieve(0)[\'metadata\'][\'app_metadata\'], \'save number 1\')\n-        self.assertEqual(history.retrieve(1)[\'metadata\'][\'app_metadata\'], \'save number 2\')\n+        self.assertEqual(\n+            history.retrieve(0)["metadata"]["app_metadata"], "save number 1"\n+        )\n+        self.assertEqual(\n+            history.retrieve(1)["metadata"]["app_metadata"], "save number 2"\n+        )\n \n     def test09_getHistoryMetadata_byId(self):\n         portal_archivist = self.portal.portal_archivist\n         doc = self.portal.doc\n \n-        doc.text = \'text v1\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 1\')\n+        doc.text = "text v1"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 1")\n         portal_archivist.register(prep)\n \n-        doc.text = \'text v2\'\n-        prep = portal_archivist.prepare(doc, app_metadata=\'save number 2\')\n+        doc.text = "text v2"\n+        prep = portal_archivist.prepare(doc, app_metadata="save number 2")\n         portal_archivist.save(prep)\n \n         # retrieve the history by history id\n@@ -368,18 +373,22 @@ def test09_getHistoryMetadata_byId(self):\n \n         self.assertEqual(len(history), 2)\n         # check if timestamp and principal available\n-        self.assertTrue(history.retrieve(1)[\'metadata\'][\'sys_metadata\'][\'timestamp\'])\n-        self.assertTrue(history.retrieve(0)[\'metadata\'][\'sys_metadata\'][\'principal\'])\n+        self.assertTrue(history.retrieve(1)["metadata"]["sys_metadata"]["timestamp"])\n+        self.assertTrue(history.retrieve(0)["metadata"]["sys_metadata"]["principal"])\n         # check if correct data and metadata retrieved\n-        self.assertEqual(history.retrieve(0)[\'metadata\'][\'app_metadata\'], \'save number 1\')\n-        self.assertEqual(history.retrieve(1)[\'metadata\'][\'app_metadata\'], \'save number 2\')\n+        self.assertEqual(\n+            history.retrieve(0)["metadata"]["app_metadata"], "save number 1"\n+        )\n+        self.assertEqual(\n+            history.retrieve(1)["metadata"]["app_metadata"], "save number 2"\n+        )\n \n-class TestArchivistToolZStorage(TestArchivistToolMemoryStorage):\n \n-   def installStorageTool(self):\n-       """Test with a real ZODB storage overriding the storage installation\n-          in the super class.\n-       """\n-       # reset the shadow storage to avoid the effect of any versions created\n-       # during portal setup\n-       self.portal.portal_historiesstorage._shadowStorage = None\n+class TestArchivistToolZStorage(TestArchivistToolMemoryStorage):\n+    def installStorageTool(self):\n+        """Test with a real ZODB storage overriding the storage installation\n+        in the super class.\n+        """\n+        # reset the shadow storage to avoid the effect of any versions created\n+        # during portal setup\n+        self.portal.portal_historiesstorage._shadowStorage = None\ndiff --git a/Products/CMFEditions/tests/test_ContentTypes.py b/Products/CMFEditions/tests/test_ContentTypes.py\nindex fcaaa02..68f1ebe 100644\n--- a/Products/CMFEditions/tests/test_ContentTypes.py\n+++ b/Products/CMFEditions/tests/test_ContentTypes.py\n@@ -1,5 +1,3 @@\n-# -*- coding: utf-8 -*-\n-\n from plone.app.textfield.value import RichTextValue\n from plone.namedfile.file import NamedBlobFile\n from plone.namedfile.file import NamedBlobImage\n@@ -11,125 +9,124 @@\n \n \n def read_image(file_path):\n-    with open(os.path.join(PACKAGE_HOME, file_path), \'rb\') as image:\n+    with open(os.path.join(PACKAGE_HOME, file_path), "rb") as image:\n         data = image.read()\n     return data\n \n \n class TestPloneContents(CMFEditionsBaseTestCase):\n-\n     def setUp(self):\n-        super(TestPloneContents, self).setUp()\n+        super().setUp()\n         self.membership = self.portal.portal_membership\n         self.catalog = self.portal.portal_catalog\n         self.workflow = self.portal.portal_workflow\n         self.portal_repository = self.portal.portal_repository\n         self.portal_archivist = self.portal.portal_archivist\n-        _createObjectByType(\'Folder\', self.portal, id=\'folder\')\n+        _createObjectByType("Folder", self.portal, id="folder")\n         self.folder = self.portal.folder\n \n     def getPermissionsOfRole(self, role):\n         perms = self.portal.permissionsOfRole(role)\n-        return [p[\'name\'] for p in perms if p[\'selected\']]\n+        return [p["name"] for p in perms if p["selected"]]\n \n     def metadata_test_one(self, obj):\n-        self.assertEqual(obj.Title(), \'content\')\n-        self.assertEqual(obj.Subject(), (\'content\',))\n-        self.assertEqual(obj.Description(), \'content\')\n-        self.assertEqual(obj.Contributors(), (\'content\',))\n-        self.assertEqual(obj.Language(), \'content\')\n-        self.assertEqual(obj.Rights(), \'content\')\n+        self.assertEqual(obj.Title(), "content")\n+        self.assertEqual(obj.Subject(), ("content",))\n+        self.assertEqual(obj.Description(), "content")\n+        self.assertEqual(obj.Contributors(), ("content",))\n+        self.assertEqual(obj.Language(), "content")\n+        self.assertEqual(obj.Rights(), "content")\n \n     def metadata_test_two(self, obj):\n-        self.assertEqual(obj.Title(), \'contentOK\')\n-        self.assertEqual(obj.Subject(), (\'contentOK\',))\n-        self.assertEqual(obj.Description(), \'contentOK\')\n-        self.assertEqual(obj.Contributors(), (\'contentOK\',))\n-        self.assertEqual(obj.Language(), \'contentOK\')\n-        self.assertEqual(obj.Rights(), \'contentOK\')\n+        self.assertEqual(obj.Title(), "contentOK")\n+        self.assertEqual(obj.Subject(), ("contentOK",))\n+        self.assertEqual(obj.Description(), "contentOK")\n+        self.assertEqual(obj.Contributors(), ("contentOK",))\n+        self.assertEqual(obj.Language(), "contentOK")\n+        self.assertEqual(obj.Rights(), "contentOK")\n \n     def testDocument(self):\n-        self.folder.invokeFactory(\'Document\', id=\'doc\')\n+        self.folder.invokeFactory("Document", id="doc")\n         portal_repository = self.portal_repository\n         content = self.folder.doc\n-        content.text = RichTextValue(u\'text v1\', \'text/plain\', \'text/plain\')\n-        content.title = u\'content\'\n-        content.subject = [u\'content\']\n-        content.description = u\'content\'\n-        content.contributors = [u\'content\']\n-        content.language = \'content\'\n-        content.rights = u\'content\'\n-        portal_repository.applyVersionControl(content, comment=\'save no 1\')\n-        content.text = RichTextValue(u\'text v2\', \'text/plain\', \'text/plain\')\n-        content.title = u\'contentOK\'\n-        content.subject = [u\'contentOK\']\n-        content.description = u\'contentOK\'\n-        content.contributors = [u\'contentOK\']\n-        content.language = \'contentOK\'\n-        content.rights = u\'contentOK\'\n-        portal_repository.save(content, comment=\'save no 2\')\n+        content.text = RichTextValue("text v1", "text/plain", "text/plain")\n+        content.title = "content"\n+        content.subject = ["content"]\n+        content.description = "content"\n+        content.contributors = ["content"]\n+        content.language = "content"\n+        content.rights = "content"\n+        portal_repository.applyVersionControl(content, comment="save no 1")\n+        content.text = RichTextValue("text v2", "text/plain", "text/plain")\n+        content.title = "contentOK"\n+        content.subject = ["contentOK"]\n+        content.description = "contentOK"\n+        content.contributors = ["contentOK"]\n+        content.language = "contentOK"\n+        content.rights = "contentOK"\n+        portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n-        self.assertEqual(obj.text.raw, \'text v1\')\n+        self.assertEqual(obj.text.raw, "text v1")\n         self.metadata_test_one(obj)\n         obj = portal_repository.retrieve(content, 1).object\n-        self.assertEqual(obj.text.raw, \'text v2\')\n+        self.assertEqual(obj.text.raw, "text v2")\n         self.metadata_test_two(obj)\n         portal_repository.revert(content, 0)\n-        self.assertEqual(content.text.raw, \'text v1\')\n+        self.assertEqual(content.text.raw, "text v1")\n         self.metadata_test_one(content)\n \n     def testNewsItem(self):\n-        self.folder.invokeFactory(\'News Item\', id=\'news_one\')\n+        self.folder.invokeFactory("News Item", id="news_one")\n         portal_repository = self.portal_repository\n         content = self.folder.news_one\n-        content.text = RichTextValue(u\'text v1\', \'text/plain\', \'text/plain\')\n-        content.title = u\'content\'\n-        content.subject = [u\'content\']\n-        content.description = u\'content\'\n-        content.contributors = [u\'content\']\n-        content.language = \'content\'\n-        content.rights = u\'content\'\n-        portal_repository.applyVersionControl(content, comment=\'save no 1\')\n-        content.text = RichTextValue(u\'text v2\', \'text/plain\', \'text/plain\')\n-        content.title = u\'contentOK\'\n-        content.subject = [u\'contentOK\']\n-        content.description = u\'contentOK\'\n-        content.contributors = [u\'contentOK\']\n-        content.language = \'contentOK\'\n-        content.rights = u\'contentOK\'\n-        portal_repository.save(content, comment=\'save no 2\')\n+        content.text = RichTextValue("text v1", "text/plain", "text/plain")\n+        content.title = "content"\n+        content.subject = ["content"]\n+        content.description = "content"\n+        content.contributors = ["content"]\n+        content.language = "content"\n+        content.rights = "content"\n+        portal_repository.applyVersionControl(content, comment="save no 1")\n+        content.text = RichTextValue("text v2", "text/plain", "text/plain")\n+        content.title = "contentOK"\n+        content.subject = ["contentOK"]\n+        content.description = "contentOK"\n+        content.contributors = ["contentOK"]\n+        content.language = "contentOK"\n+        content.rights = "contentOK"\n+        portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n-        self.assertEqual(obj.text.raw, \'text v1\')\n+        self.assertEqual(obj.text.raw, "text v1")\n         self.metadata_test_one(obj)\n         obj = portal_repository.retrieve(content, 1).object\n-        self.assertEqual(obj.text.raw, \'text v2\')\n+        self.assertEqual(obj.text.raw, "text v2")\n         self.metadata_test_two(obj)\n         portal_repository.revert(content, 0)\n-        self.assertEqual(content.text.raw, \'text v1\')\n+        self.assertEqual(content.text.raw, "text v1")\n         self.metadata_test_one(content)\n \n     def testImage(self):\n-        self.folder.invokeFactory(\'Image\', id=\'image\')\n+        self.folder.invokeFactory("Image", id="image")\n         portal_repository = self.portal_repository\n-        img1 = read_image(\'tests/images/img1.png\')\n-        img2 = read_image(\'tests/images/img2.png\')\n+        img1 = read_image("tests/images/img1.png")\n+        img2 = read_image("tests/images/img2.png")\n         content = self.folder.image\n-        content.image = NamedBlobImage(img1, u\'img1.png\', u\'image/png\')\n-        content.title = u\'content\'\n-        content.subject = [u\'content\']\n-        content.description = u\'content\'\n-        content.contributors = [u\'content\']\n-        content.language = \'content\'\n-        content.rights = u\'content\'\n-        portal_repository.applyVersionControl(content, comment=\'save no 1\')\n-        content.image = NamedBlobImage(img2, u\'img2.png\', u\'image/png\')\n-        content.title = u\'contentOK\'\n-        content.subject = [u\'contentOK\']\n-        content.description = u\'contentOK\'\n-        content.contributors = [u\'contentOK\']\n-        content.language = \'contentOK\'\n-        content.rights = u\'contentOK\'\n-        portal_repository.save(content, comment=\'save no 2\')\n+        content.image = NamedBlobImage(img1, "img1.png", "image/png")\n+        content.title = "content"\n+        content.subject = ["content"]\n+        content.description = "content"\n+        content.contributors = ["content"]\n+        content.language = "content"\n+        content.rights = "content"\n+        portal_repository.applyVersionControl(content, comment="save no 1")\n+        content.image = NamedBlobImage(img2, "img2.png", "image/png")\n+        content.title = "contentOK"\n+        content.subject = ["contentOK"]\n+        content.description = "contentOK"\n+        content.contributors = ["contentOK"]\n+        content.language = "contentOK"\n+        content.rights = "contentOK"\n+        portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n         self.assertEqual(obj.image.data, img1)\n         self.metadata_test_one(obj)\n@@ -141,27 +138,27 @@ def testImage(self):\n         self.metadata_test_one(content)\n \n     def testFile(self):\n-        self.folder.invokeFactory(\'File\', id=\'file\')\n-        file1 = read_image(\'tests/images/img1.png\')\n-        file2 = read_image(\'tests/images/img2.png\')\n+        self.folder.invokeFactory("File", id="file")\n+        file1 = read_image("tests/images/img1.png")\n+        file2 = read_image("tests/images/img2.png")\n         portal_repository = self.portal_repository\n         content = self.folder.file\n-        content.file = NamedBlobFile(file1, u\'img1.png\', u\'image/png\')\n-        content.title = u\'content\'\n-        content.subject = [u\'content\']\n-        content.description = u\'content\'\n-        content.contributors = [u\'content\']\n-        content.language = \'content\'\n-        content.rights = u\'content\'\n-        portal_repository.applyVersionControl(content, comment=\'save no 1\')\n-        content.file = NamedBlobImage(file2, u\'img2.png\', u\'image/png\')\n-        content.title = u\'contentOK\'\n-        content.subject = [u\'contentOK\']\n-        content.description = u\'contentOK\'\n-        content.contributors = [u\'contentOK\']\n-        content.language = \'contentOK\'\n-        content.rights = u\'contentOK\'\n-        portal_repository.save(content, comment=\'save no 2\')\n+        content.file = NamedBlobFile(file1, "img1.png", "image/png")\n+        content.title = "content"\n+        content.subject = ["content"]\n+        content.description = "content"\n+        content.contributors = ["content"]\n+        content.language = "content"\n+        content.rights = "content"\n+        portal_repository.applyVersionControl(content, comment="save no 1")\n+        content.file = NamedBlobImage(file2, "img2.png", "image/png")\n+        content.title = "contentOK"\n+        content.subject = ["contentOK"]\n+        content.description = "contentOK"\n+        content.contributors = ["contentOK"]\n+        content.language = "contentOK"\n+        content.rights = "contentOK"\n+        portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n         self.assertEqual(obj.file.data, file1)\n         self.metadata_test_one(obj)\n@@ -173,23 +170,23 @@ def testFile(self):\n         self.metadata_test_one(content)\n \n     def testFolder(self):\n-        self.folder.invokeFactory(\'Image\', id=\'folder\')\n+        self.folder.invokeFactory("Image", id="folder")\n         portal_repository = self.portal_repository\n         content = self.folder.folder\n-        content.title = u\'content\'\n-        content.subject = [u\'content\']\n-        content.description = u\'content\'\n-        content.contributors = [u\'content\']\n-        content.language = \'content\'\n-        content.rights = u\'content\'\n-        portal_repository.applyVersionControl(content, comment=\'save no 1\')\n-        content.title = u\'contentOK\'\n-        content.subject = [u\'contentOK\']\n-        content.description = u\'contentOK\'\n-        content.contributors = [u\'contentOK\']\n-        content.language = \'contentOK\'\n-        content.rights = u\'contentOK\'\n-        portal_repository.save(content, comment=\'save no 2\')\n+        content.title = "content"\n+        content.subject = ["content"]\n+        content.description = "content"\n+        content.contributors = ["content"]\n+        content.language = "content"\n+        content.rights = "content"\n+        portal_repository.applyVersionControl(content, comment="save no 1")\n+        content.title = "contentOK"\n+        content.subject = ["contentOK"]\n+        content.description = "contentOK"\n+        content.contributors = ["contentOK"]\n+        content.language = "contentOK"\n+        content.rights = "contentOK"\n+        portal_repository.save(content, comment="save no 2")\n         obj = portal_repository.retrieve(content, 0).object\n         self.metadata_test_one(obj)\n         obj = portal_repository.retrieve(content, 1).object\ndiff --git a/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py b/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py\nindex 28b06b2..a49b913 100644\n--- a/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py\n+++ b/Products/CMFEditions/tests/test_CopyModifyMergeRepositoryTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -26,12 +25,8 @@\n \n from .DummyTools import DummyArchivist\n from .DummyTools import notifyModified\n-from Products.CMFEditions.interfaces.IRepository import (\n-    IContentTypeVersionPolicySupport\n-)\n-from Products.CMFEditions.interfaces.IRepository import (\n-    ICopyModifyMergeRepository\n-)\n+from Products.CMFEditions.interfaces.IRepository import IContentTypeVersionPolicySupport\n+from Products.CMFEditions.interfaces.IRepository import ICopyModifyMergeRepository\n from Products.CMFEditions.interfaces.IRepository import IPurgeSupport\n from Products.CMFEditions.interfaces.IRepository import IVersionData\n from Products.CMFEditions.interfaces.IRepository import RepositoryPurgeError\n@@ -60,12 +55,10 @@ def disablePolicyOnTypeHook(self, portal, p_type, out):\n \n class TestCopyModifyMergeRepositoryToolBase(CMFEditionsBaseTestCase):\n     def setUp(self):\n-        super(TestCopyModifyMergeRepositoryToolBase, self).setUp()\n+        super().setUp()\n \n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\n-            "reviewer", "reviewer", ["Manager"], ""\n-        )\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n \n         # add test data\n         self.portal.invokeFactory("Document", "doc")\n@@ -225,9 +218,7 @@ def test07_restoreDeletedObject(self):\n         self.portal.manage_delObjects(ids=["doc"])\n         self.assertFalse("doc" in self.portal.objectIds())\n         with self.assertRaises(AttributeError):\n-            portal_repository.restore(\n-                history_id, selector=0, container=self.portal\n-            )\n+            portal_repository.restore(history_id, selector=0, container=self.portal)\n         # portal_repository.restore(history_id, selector=0, container=self.portal)  # noqa: E501\n         # self.assertTrue(\'doc\' in self.portal.objectIds())\n         # restored = self.portal.doc\n@@ -289,12 +280,8 @@ def test09_getHistoryMetadata(self):\n         # The history is acquisition wrapped\n         self.assertEqual(history.aq_parent, doc)\n         # check if timestamp and principal available\n-        self.assertTrue(\n-            history.retrieve(1)["metadata"]["sys_metadata"]["timestamp"]\n-        )\n-        self.assertTrue(\n-            history.retrieve(0)["metadata"]["sys_metadata"]["principal"]\n-        )\n+        self.assertTrue(history.retrieve(1)["metadata"]["sys_metadata"]["timestamp"])\n+        self.assertTrue(history.retrieve(0)["metadata"]["sys_metadata"]["principal"])\n         # check if correct data and metadata retrieved\n         self.assertEqual(\n             history.retrieve(0)["metadata"]["sys_metadata"]["comment"],\n@@ -326,23 +313,23 @@ def test01_recursiveSave(self):\n         # check if correctly recursing and setting reference data correctly\n         alog_str = portal_archivist.get_log()\n         expected = """\n-prepare fol: hid=%(fol_id)s, refs=(doc1_inside, doc2_inside, doc3_outside)\n-  prepare doc1_inside: hid=%(doc1_id)s\n-  save    doc1_inside: hid=%(doc1_id)s, isreg=False, auto=True\n-  prepare doc2_inside: hid=%(doc2_id)s\n-  save    doc2_inside: hid=%(doc2_id)s, isreg=False, auto=True\n-save    fol: hid=%(fol_id)s, irefs=({hid:%(doc1_id)s, vid:0}, {hid:%(doc2_id)s, vid:0}), orefs=({hid:None, vid:-1}), isreg=False, auto=True\n-\n-prepare fol: hid=%(fol_id)s, refs=(doc1_inside, doc2_inside, doc3_outside)\n-  prepare doc1_inside: hid=%(doc1_id)s\n-  save    doc1_inside: hid=%(doc1_id)s, isreg=True, auto=False\n-  prepare doc2_inside: hid=%(doc2_id)s\n-  save    doc2_inside: hid=%(doc2_id)s, isreg=True, auto=False\n-save    fol: hid=%(fol_id)s, irefs=({hid:%(doc1_id)s, vid:1}, {hid:%(doc2_id)s, vid:1}), orefs=({hid:None, vid:-1}), isreg=True, auto=False""" % {\n-            "fol_id": fol.cmf_uid(),\n-            "doc1_id": fol.doc1_inside.cmf_uid(),\n-            "doc2_id": fol.doc2_inside.cmf_uid(),\n-        }\n+prepare fol: hid={fol_id}, refs=(doc1_inside, doc2_inside, doc3_outside)\n+  prepare doc1_inside: hid={doc1_id}\n+  save    doc1_inside: hid={doc1_id}, isreg=False, auto=True\n+  prepare doc2_inside: hid={doc2_id}\n+  save    doc2_inside: hid={doc2_id}, isreg=False, auto=True\n+save    fol: hid={fol_id}, irefs=({{hid:{doc1_id}, vid:0}}, {{hid:{doc2_id}, vid:0}}), orefs=({{hid:None, vid:-1}}), isreg=False, auto=True\n+\n+prepare fol: hid={fol_id}, refs=(doc1_inside, doc2_inside, doc3_outside)\n+  prepare doc1_inside: hid={doc1_id}\n+  save    doc1_inside: hid={doc1_id}, isreg=True, auto=False\n+  prepare doc2_inside: hid={doc2_id}\n+  save    doc2_inside: hid={doc2_id}, isreg=True, auto=False\n+save    fol: hid={fol_id}, irefs=({{hid:{doc1_id}, vid:1}}, {{hid:{doc2_id}, vid:1}}), orefs=({{hid:None, vid:-1}}), isreg=True, auto=False""".format(\n+            fol_id=fol.cmf_uid(),\n+            doc1_id=fol.doc1_inside.cmf_uid(),\n+            doc2_id=fol.doc2_inside.cmf_uid(),\n+        )\n \n         self.assertEqual(alog_str, expected)\n \n@@ -370,34 +357,26 @@ def test02_recursiveRetrieve(self):\n         # check recursive retrieve\n         alog_str = portal_archivist.get_log()\n \n-        expected = """retrieve fol: hid=%(fol_id)s, selector=0\n-retrieve doc1_inside: hid=%(doc1_id)s, selector=0\n-retrieve doc2_inside: hid=%(doc2_id)s, selector=0""" % {\n-            "fol_id": fol.cmf_uid(),\n-            "doc1_id": fol.doc1_inside.cmf_uid(),\n-            "doc2_id": fol.doc2_inside.cmf_uid(),\n-        }\n+        expected = """retrieve fol: hid={fol_id}, selector=0\n+retrieve doc1_inside: hid={doc1_id}, selector=0\n+retrieve doc2_inside: hid={doc2_id}, selector=0""".format(\n+            fol_id=fol.cmf_uid(),\n+            doc1_id=fol.doc1_inside.cmf_uid(),\n+            doc2_id=fol.doc2_inside.cmf_uid(),\n+        )\n         self.assertEqual(alog_str, expected)\n \n         # check result\n         self.assertEqual(retr.object.title, "fol title v1")\n-        self.assertEqual(\n-            retr.object.doc1_inside.title, "doc1_inside title text v1"\n-        )\n-        self.assertEqual(\n-            retr.object.doc2_inside.title, "doc2_inside title text v1"\n-        )\n-        self.assertEqual(\n-            retr.object.doc3_outside.title, "doc3_outside title text v2"\n-        )\n+        self.assertEqual(retr.object.doc1_inside.title, "doc1_inside title text v1")\n+        self.assertEqual(retr.object.doc2_inside.title, "doc2_inside title text v1")\n+        self.assertEqual(retr.object.doc3_outside.title, "doc3_outside title text v2")\n \n \n class TestRegressionTests(CMFEditionsBaseTestCase):\n     def setUp(self):\n-        super(TestRegressionTests, self).setUp()\n-        self.portal.acl_users.userFolderAddUser(\n-            "reviewer", "reviewer", ["Manager"], ""\n-        )\n+        super().setUp()\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n \n         self.portal.invokeFactory("Document", "doc")\n         self.portal.invokeFactory("Folder", "fol")\n@@ -439,66 +418,40 @@ def test01_remove_policy_from_type(self):\n         portal_repository = self.portal.portal_repository\n         # Set it twice to ensure that duplicates aren\'t created\n         self.assertTrue(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n-        )\n-        portal_repository.removePolicyFromContentType(\n-            "Document", "at_edit_autoversion"\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n+        portal_repository.removePolicyFromContentType("Document", "at_edit_autoversion")\n         self.assertFalse(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n         # Calling it twice should not fail.\n-        portal_repository.removePolicyFromContentType(\n-            "Document", "at_edit_autoversion"\n-        )\n+        portal_repository.removePolicyFromContentType("Document", "at_edit_autoversion")\n \n     def test02_set_policy_on_type(self):\n         # test that policies can be set and retrieved\n         portal_repository = self.portal.portal_repository\n         self.assertTrue(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n-        )\n-        portal_repository.removePolicyFromContentType(\n-            "Document", "at_edit_autoversion"\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n+        portal_repository.removePolicyFromContentType("Document", "at_edit_autoversion")\n         self.assertFalse(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n-        )\n-        portal_repository.addPolicyForContentType(\n-            "Document", "at_edit_autoversion"\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n+        portal_repository.addPolicyForContentType("Document", "at_edit_autoversion")\n         self.assertTrue(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n \n     def test03_set_policy_types_map(self):\n         # test the mapping of policies to types\n         portal_repository = self.portal.portal_repository\n         # Get something in place first\n-        portal_repository.addPolicyForContentType(\n-            "Document", "at_edit_autoversion"\n-        )\n-        portal_repository.removePolicyFromContentType(\n-            "Document", "at_edit_autoversion"\n-        )\n+        portal_repository.addPolicyForContentType("Document", "at_edit_autoversion")\n+        portal_repository.removePolicyFromContentType("Document", "at_edit_autoversion")\n         # update the mapping\n-        portal_repository.manage_setTypePolicies(\n-            {"Document": ["at_edit_autoversion"]}\n-        )\n+        portal_repository.manage_setTypePolicies({"Document": ["at_edit_autoversion"]})\n         self.assertTrue(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n \n         # assign two policies and then unassign them.\n@@ -512,14 +465,10 @@ def test03_set_policy_types_map(self):\n         )\n         portal_repository.manage_setTypePolicies({"Document": []})\n         self.assertFalse(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "at_edit_autoversion"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "at_edit_autoversion")\n         )\n         self.assertFalse(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "version_on_publish"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "version_on_publish")\n         )\n \n     def test04_add_policy(self):\n@@ -548,15 +497,11 @@ def test05_remove_policy(self):\n         portal_repository.addPolicy(\n             "version_on_publish", "Create version when published"\n         )\n-        portal_repository.addPolicyForContentType(\n-            "Document", "version_on_publish"\n-        )\n+        portal_repository.addPolicyForContentType("Document", "version_on_publish")\n         portal_repository.removePolicy("version_on_publish")\n         self.assertEqual(len(portal_repository.listPolicies()), self.np)\n         self.assertFalse(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "version_on_publish"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "version_on_publish")\n         )\n \n     def test07_set_policy_defs(self):\n@@ -645,22 +590,16 @@ def test09_policy_hooks(self):\n             "Document", "my_bogus_policy", out=out\n         )\n         self.assertTrue(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "my_bogus_policy"\n-            )\n+            portal_repository.supportsPolicy(self.portal.doc, "my_bogus_policy")\n         )\n         self.assertEqual(out, ["added", "enabled Document"])\n         portal_repository.removePolicyFromContentType(\n             "Document", "my_bogus_policy", out=out\n         )\n         self.assertFalse(\n-            portal_repository.supportsPolicy(\n-                self.portal.doc, "my_bogus_policy"\n-            )\n-        )\n-        self.assertEqual(\n-            out, ["added", "enabled Document", "disabled Document"]\n+            portal_repository.supportsPolicy(self.portal.doc, "my_bogus_policy")\n         )\n+        self.assertEqual(out, ["added", "enabled Document", "disabled Document"])\n         portal_repository.removePolicy("my_bogus_policy", out=out)\n         self.assertEqual(\n             out, ["added", "enabled Document", "disabled Document", "removed"]\n@@ -743,12 +682,8 @@ def test14_has_policy(self):\n         portal_repository = self.portal.portal_repository\n         # We already have two policies by default\n         self.assertTrue(portal_repository.hasPolicy(self.portal.doc))\n-        portal_repository.removePolicyFromContentType(\n-            "Document", "at_edit_autoversion"\n-        )\n-        portal_repository.removePolicyFromContentType(\n-            "Document", "version_on_revert"\n-        )\n+        portal_repository.removePolicyFromContentType("Document", "at_edit_autoversion")\n+        portal_repository.removePolicyFromContentType("Document", "version_on_revert")\n         self.assertFalse(portal_repository.hasPolicy(self.portal.doc))\n \n     def test15_remove_policy_twice(self):\ndiff --git a/Products/CMFEditions/tests/test_IntegrationTests.py b/Products/CMFEditions/tests/test_IntegrationTests.py\nindex 07d64db..a0b384b 100644\n--- a/Products/CMFEditions/tests/test_IntegrationTests.py\n+++ b/Products/CMFEditions/tests/test_IntegrationTests.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -32,34 +31,32 @@\n from zope.component.persistentregistry import PersistentComponents\n from zope.interface.interface import InterfaceClass\n \n-import imp\n import sys\n import transaction\n+import types\n import ZODB.interfaces\n \n \n class TestIntegration(CMFEditionsBaseTestCase):\n-\n     def setUp(self):\n-        super(TestIntegration, self).setUp()\n+        super().setUp()\n \n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\',\n-                                                [\'Manager\'], \'\')\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n         # add a document\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n+        self.portal.invokeFactory("Document", "doc")\n \n         # add a folder with two documents in it\n-        self.portal.invokeFactory(\'Folder\', \'fol\')\n-        self.portal.fol.invokeFactory(\'Document\', \'doc1\')\n-        self.portal.fol.invokeFactory(\'Document\', \'doc2\')\n+        self.portal.invokeFactory("Folder", "fol")\n+        self.portal.fol.invokeFactory("Document", "doc1")\n+        self.portal.fol.invokeFactory("Document", "doc2")\n \n     def test01_assertApplyVersionControlSavesOnlyOnce(self):\n         portal_repo = self.portal.portal_repository\n         doc = self.portal.doc\n \n-        doc.setTitle(\'doc title v1\')\n-        portal_repo.applyVersionControl(doc, comment=\'First version\')\n+        doc.setTitle("doc title v1")\n+        portal_repo.applyVersionControl(doc, comment="First version")\n \n         # there should be only one history entry and not two or more\n         self.assertEqual(len(portal_repo.getHistory(doc)), 1)\n@@ -146,8 +143,7 @@ def test06_retrieveSpecificVersion(self):\n         portal_repo = self.portal.portal_repository\n         doc = self.portal.doc\n \n-        review_state = self.portal.portal_workflow.getInfoFor(\n-            doc, \'review_state\')\n+        review_state = self.portal.portal_workflow.getInfoFor(doc, "review_state")\n \n         # store the work edition two times\n         doc.setTitle("v1")\n@@ -167,8 +163,7 @@ def test06_retrieveSpecificVersion(self):\n \n         # since 1.0beta1 the workflows review state is saved to the\n         # system metadata by a modifier.\n-        self.assertEqual(\n-            retrieved_doc.sys_metadata["review_state"], review_state)\n+        self.assertEqual(retrieved_doc.sys_metadata["review_state"], review_state)\n \n     def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):\n         portal_repo = self.portal.portal_repository\n@@ -179,8 +174,7 @@ def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):\n         portal_repo.applyVersionControl(doc)\n \n         # copy\n-        self.portal.manage_pasteObjects(\n-            self.portal.manage_copyObjects(ids=[\'doc\']))\n+        self.portal.manage_pasteObjects(self.portal.manage_copyObjects(ids=["doc"]))\n         copy = self.portal.copy_of_doc\n \n         # the copy shall not have a history yet: that\'s correct\n@@ -189,7 +183,8 @@ def test07_cloneObjectUnderVersionControlRemovesOriginalsHistory(self):\n         # just to be sure the history is definitivels different\n         self.assertNotEqual(\n             portal_historyidhandler.queryUid(doc),\n-            portal_historyidhandler.queryUid(copy))  # may be None\n+            portal_historyidhandler.queryUid(copy),\n+        )  # may be None\n \n     def test08_loopOverHistory(self):\n         portal_repo = self.portal.portal_repository\n@@ -203,7 +198,7 @@ def test08_loopOverHistory(self):\n             counter += 1\n \n         # check if history iterator returned just one element\n-        self.assertEquals(counter, 1)\n+        self.assertEqual(counter, 1)\n \n     def test09_retrieveAndRevertRetainWorkingCopiesWorkflowInfo(self):\n         portal_repo = self.portal.portal_repository\n@@ -225,20 +220,21 @@ def test09_retrieveAndRevertRetainWorkingCopiesWorkflowInfo(self):\n         # ----- retrieve\n         # check if retrieved object carries the working copies workflow info\n         retrieved_data = portal_repo.retrieve(\n-            doc, 0, preserve=[\'review_state\', \'workflow_history\'])\n-        self.assertEqual(retrieved_data.object.review_state,\n-                         "fake rev state v2")\n-        self.assertEqual(retrieved_data.object.workflow_history[0],\n-                         "fake wf history v2")\n+            doc, 0, preserve=["review_state", "workflow_history"]\n+        )\n+        self.assertEqual(retrieved_data.object.review_state, "fake rev state v2")\n+        self.assertEqual(\n+            retrieved_data.object.workflow_history[0], "fake wf history v2"\n+        )\n \n         # check that the working copies workflow info is unchanged\n         self.assertEqual(doc.review_state, "fake rev state v2")\n         self.assertEqual(doc.workflow_history[0], "fake wf history v2")\n \n         # check if the preserved data is returned correctly\n-        preserved_rvs = retrieved_data.preserved_data[\'review_state\']\n+        preserved_rvs = retrieved_data.preserved_data["review_state"]\n         self.assertEqual(preserved_rvs, "fake rev state v1")\n-        preserved_wfh = retrieved_data.preserved_data[\'workflow_history\'][0]\n+        preserved_wfh = retrieved_data.preserved_data["workflow_history"][0]\n         self.assertEqual(preserved_wfh, "fake wf history v1")\n \n         # ----- revert\n@@ -254,20 +250,20 @@ def test10_versionAStandardFolder(self):\n         doc2 = fol.doc2\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         # save change no 2\n-        fol.setTitle(\'v2 of fol\')\n+        fol.setTitle("v2 of fol")\n         doc1.setTitle("v2 of doc1")\n         doc2.setTitle("v2 of doc2")\n-        portal_repo.save(fol, comment=\'second save\')\n+        portal_repo.save(fol, comment="second save")\n \n         # change no 3 (without saving)\n-        fol.setTitle(\'v3 of fol\')\n+        fol.setTitle("v3 of fol")\n         doc1.setTitle("v3 of doc1")\n         doc2.setTitle("v3 of doc2")\n \n@@ -292,33 +288,37 @@ def test11_versionAFolderishObjectThatTreatsChildrensAsInsideRefs(self):\n         # just configure the standard folder to treat the childrens as\n         # inside refrences. For this we reconfigure the standard modifiers.\n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n         orig_uid1 = portal_historyidhandler.queryUid(doc1)\n         orig_uid2 = portal_historyidhandler.queryUid(doc2)\n \n         # save change no 2\n-        fol.setTitle(\'v2 of fol\')\n+        fol.setTitle("v2 of fol")\n         doc1.setTitle("v2 of doc1")\n         doc2.setTitle("v2 of doc2")\n-        portal_repo.save(fol, comment=\'second save after we deleted doc2\')\n+        portal_repo.save(fol, comment="second save after we deleted doc2")\n \n         # save change no 3\n-        fol.setTitle(\'v3 of fol\')\n+        fol.setTitle("v3 of fol")\n         doc1.setTitle("v3 of doc1")\n-        fol.manage_delObjects(ids=[\'doc2\'])\n-        fol.invokeFactory(\'Document\', \'doc3\')\n+        fol.manage_delObjects(ids=["doc2"])\n+        fol.invokeFactory("Document", "doc3")\n         doc3 = fol.doc3\n         doc3.setTitle("v1 of doc3")\n-        portal_repo.save(fol, comment=\'second save with new doc3\')\n+        portal_repo.save(fol, comment="second save with new doc3")\n \n         # revert to change no 1 (version idexes start with index 0)\n         portal_repo.revert(fol, selector=1)\n@@ -326,8 +326,8 @@ def test11_versionAFolderishObjectThatTreatsChildrensAsInsideRefs(self):\n         # check if revertion worked correctly\n         fol = self.portal.fol\n         doc1 = fol.doc1\n-        self.assertTrue(\'doc2\' in fol.objectIds())\n-        self.assertFalse(\'doc3\' in fol.objectIds())\n+        self.assertTrue("doc2" in fol.objectIds())\n+        self.assertFalse("doc3" in fol.objectIds())\n         doc2 = fol.doc2\n         self.assertEqual(fol.Title(), "v2 of fol")\n         self.assertEqual(doc1.Title(), "v2 of doc1")\n@@ -338,94 +338,89 @@ def test11_versionAFolderishObjectThatTreatsChildrensAsInsideRefs(self):\n     def test12_retrieveAndRevertRetainWorkingCopiesPermissions(self):\n         portal_repo = self.portal.portal_repository\n         doc = self.portal.doc\n-        perm = \'Access contents information\'\n-        member_role = \'permission_{0}role_{1}\'.format(\n-            _string_hash(perm),\n-            _string_hash(\'Member\')\n+        perm = "Access contents information"\n+        member_role = "permission_{}role_{}".format(\n+            _string_hash(perm), _string_hash("Member")\n         )\n \n-        doc.manage_permission(perm, (\'Manager\',), 0)\n+        doc.manage_permission(perm, ("Manager",), 0)\n \n         portal_repo.applyVersionControl(doc)\n \n-        doc.manage_permission(perm, (\'Manager\', \'Member\'), 1)\n+        doc.manage_permission(perm, ("Manager", "Member"), 1)\n         portal_repo.save(doc)\n \n         # just check the original is unchanged\n         settings = doc.permission_settings(perm)[0]\n-        self.assertTrue(settings[\'acquire\'])\n-        role_enabled = [r for r in settings[\'roles\']\n-                        if r[\'name\'] == member_role][0]\n-        self.assertTrue(role_enabled[\'checked\'])\n+        self.assertTrue(settings["acquire"])\n+        role_enabled = [r for r in settings["roles"] if r["name"] == member_role][0]\n+        self.assertTrue(role_enabled["checked"])\n \n         # ----- retrieve\n         # check if retrieved object carries the working copy\'s permissions\n         retrieved_data = portal_repo.retrieve(\n-            doc, 0, preserve=[\'_Access_contents_information_Permission\'])\n+            doc, 0, preserve=["_Access_contents_information_Permission"]\n+        )\n         settings = retrieved_data.object.permission_settings(perm)[0]\n-        self.assertTrue(settings[\'acquire\'])\n-        role_enabled = [\n-            r for r in settings[\'roles\']\n-            if r[\'name\'] == member_role\n-        ][0]\n-        self.assertTrue(role_enabled[\'checked\'])\n+        self.assertTrue(settings["acquire"])\n+        role_enabled = [r for r in settings["roles"] if r["name"] == member_role][0]\n+        self.assertTrue(role_enabled["checked"])\n \n         # check that the working copy\'s permissions are unchanged\n         settings = doc.permission_settings(perm)[0]\n-        self.assertTrue(settings[\'acquire\'])\n-        role_enabled = [\n-            r for r in settings[\'roles\']\n-            if r[\'name\'] == member_role\n-        ][0]\n-        self.assertTrue(role_enabled[\'checked\'])\n+        self.assertTrue(settings["acquire"])\n+        role_enabled = [r for r in settings["roles"] if r["name"] == member_role][0]\n+        self.assertTrue(role_enabled["checked"])\n \n         # check if the preserved data is returned correctly\n-        preserved = retrieved_data.preserved_data[\'_Access_contents_information_Permission\']  # noqa\n-        self.assertEqual(preserved, (\'Manager\',))\n+        preserved = retrieved_data.preserved_data[\n+            "_Access_contents_information_Permission"\n+        ]  # noqa\n+        self.assertEqual(preserved, ("Manager",))\n \n         # ----- revert\n         # check that the working copies permissions are unchanged after revert\n         portal_repo.revert(doc, 0)\n         settings = doc.permission_settings(perm)[0]\n-        self.assertTrue(settings[\'acquire\'])\n-        role_enabled = [r for r in settings[\'roles\']\n-                        if r[\'name\'] == member_role][0]\n-        self.assertTrue(role_enabled[\'checked\'])\n+        self.assertTrue(settings["acquire"])\n+        role_enabled = [r for r in settings["roles"] if r["name"] == member_role][0]\n+        self.assertTrue(role_enabled["checked"])\n \n     def test13_revertUpdatesCatalog(self):\n         portal_repo = self.portal.portal_repository\n         cat = self.portal.portal_catalog\n         doc = self.portal.doc\n \n-        doc.text = RichTextValue(u\'Plain text\', \'text/plain\', \'text/plain\')\n+        doc.text = RichTextValue("Plain text", "text/plain", "text/plain")\n         portal_repo.applyVersionControl(doc)\n-        doc.text = RichTextValue(u\'blahblah\', \'text/plain\', \'text/plain\')\n+        doc.text = RichTextValue("blahblah", "text/plain", "text/plain")\n         portal_repo.save(doc)\n         # Test that catalog has current value\n-        results = cat(SearchableText=\'Plain Text\')\n+        results = cat(SearchableText="Plain Text")\n         self.assertEqual(len(results), 0)\n-        results = cat(SearchableText=\'blahblah\')\n+        results = cat(SearchableText="blahblah")\n         self.assertEqual(len(results), 1)\n         self.assertEqual(results[0].getObject(), doc)\n \n         retrieved_data = portal_repo.retrieve(\n-            doc, 0, preserve=[\'_Access_contents_information_Permission\'])\n+            doc, 0, preserve=["_Access_contents_information_Permission"]\n+        )\n         retrieved_doc = retrieved_data.object\n-        self.assertTrue(\'Plain text\' in retrieved_doc.text.raw)\n+        self.assertTrue("Plain text" in retrieved_doc.text.raw)\n         # Test that basic retrieval did not alter the catalog\n-        results = cat(SearchableText=\'Plain Text\')\n+        results = cat(SearchableText="Plain Text")\n         self.assertEqual(len(results), 0)\n-        results = cat(SearchableText=\'blahblah\')\n+        results = cat(SearchableText="blahblah")\n         self.assertEqual(len(results), 1)\n         self.assertEqual(results[0].getObject(), doc)\n \n         portal_repo.revert(doc, 0)\n         # Test that the catalog is updated on revert\n-        results = cat(SearchableText=\'blahblah\')\n+        results = cat(SearchableText="blahblah")\n         self.assertEqual(len(results), 0)\n-        results = cat(SearchableText=\'Plain Text\')\n+        results = cat(SearchableText="Plain Text")\n         self.assertEqual(len(results), 1)\n-        self.assertEqual(results[0].getObject().text.raw, \'Plain text\')\n+        self.assertEqual(results[0].getObject().text.raw, "Plain text")\n \n     def test14_retrieveFolderWithAddedOrDeletedObjects(self):\n         portal_repo = self.portal.portal_repository\n@@ -434,53 +429,49 @@ def test14_retrieveFolderWithAddedOrDeletedObjects(self):\n         doc2 = fol.doc2\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n         self.assertEqual(ret_folder.objectIds(), fol.objectIds())\n-        self.assertEqual(tuple(ret_folder.objectValues()),\n-                         tuple(fol.objectValues()))\n+        self.assertEqual(tuple(ret_folder.objectValues()), tuple(fol.objectValues()))\n \n         # remove an item\n-        fol.manage_delObjects(\'doc2\')\n+        fol.manage_delObjects("doc2")\n \n         # retrieve should update sub-objects\n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n         self.assertEqual(ret_folder.objectIds(), fol.objectIds())\n-        self.assertEqual(tuple(ret_folder.objectValues()),\n-                         tuple(fol.objectValues()))\n+        self.assertEqual(tuple(ret_folder.objectValues()), tuple(fol.objectValues()))\n \n         # add it back\n-        fol.invokeFactory(\'Document\', \'doc2\')\n+        fol.invokeFactory("Document", "doc2")\n         doc2 = fol.doc2\n-        doc2.setTitle(\'v2 of doc2\')\n+        doc2.setTitle("v2 of doc2")\n \n         # retrieve should update sub-objects\n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n         self.assertEqual(ret_folder.objectIds(), fol.objectIds())\n-        self.assertEqual(tuple(ret_folder.objectValues()),\n-                         tuple(fol.objectValues()))\n-        self.assertEqual(ret_folder.doc2.Title(), \'v2 of doc2\')\n+        self.assertEqual(tuple(ret_folder.objectValues()), tuple(fol.objectValues()))\n+        self.assertEqual(ret_folder.doc2.Title(), "v2 of doc2")\n \n         # add new item\n-        fol.invokeFactory(\'Document\', \'doc3\')\n+        fol.invokeFactory("Document", "doc3")\n         doc3 = fol.doc3\n-        doc3.setTitle(\'v1 of doc3\')\n+        doc3.setTitle("v1 of doc3")\n \n         # retrieve should copy new sub-objects\n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n         self.assertEqual(ret_folder.objectIds(), fol.objectIds())\n-        self.assertEqual(tuple(ret_folder.objectValues()),\n-                         tuple(fol.objectValues()))\n-        self.assertEqual(ret_folder.doc3.Title(), \'v1 of doc3\')\n+        self.assertEqual(tuple(ret_folder.objectValues()), tuple(fol.objectValues()))\n+        self.assertEqual(ret_folder.doc3.Title(), "v1 of doc3")\n \n         orig_ids = fol.objectIds()\n         orig_values = fol.objectValues()\n@@ -503,20 +494,24 @@ def test15_retrieveInsideRefsFolderWithAddedOrDeletedObjects(self):\n         # just configure the standard folder to treat the children as\n         # inside references. For this we reconfigure the standard modifiers.\n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n         orig_ids = fol.objectIds()\n         orig_values = fol.objectValues()\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n@@ -529,7 +524,7 @@ def test15_retrieveInsideRefsFolderWithAddedOrDeletedObjects(self):\n             self.assertEqual(ret_values[i].Title(), orig_values[i].Title())\n \n         # remove an item\n-        fol.manage_delObjects(\'doc2\')\n+        fol.manage_delObjects("doc2")\n         processQueue()\n \n         cur_ids = fol.objectIds()\n@@ -547,9 +542,9 @@ def test15_retrieveInsideRefsFolderWithAddedOrDeletedObjects(self):\n         self.assertEqual(fol.objectIds(), cur_ids)\n \n         # add new item\n-        fol.invokeFactory(\'Document\', \'doc3\')\n+        fol.invokeFactory("Document", "doc3")\n         doc3 = fol.doc3\n-        doc3.setTitle(\'v1 of doc3\')\n+        doc3.setTitle("v1 of doc3")\n \n         cur_ids = fol.objectIds()\n         self.assertEqual(len(cur_ids), 2)\n@@ -585,52 +580,59 @@ def test16_revertInsideRefsUpdatesCatalog(self):\n         # just configure the standard folder to treat the childrens as\n         # inside refrences. For this we reconfigure the standard modifiers.\n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc.setTitle("v1 of doc1")\n         fol.reindexObject()\n         doc.reindexObject()\n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         # save change no 2\n-        fol.setTitle(\'v2 of fol\')\n+        fol.setTitle("v2 of fol")\n         doc.setTitle("v2 of doc1")\n         fol.reindexObject()\n         doc.reindexObject()\n-        portal_repo.save(fol, comment=\'second save\')\n+        portal_repo.save(fol, comment="second save")\n \n         # Test that catalog has current value\n-        results = cat(SearchableText=\'v1\')\n+        results = cat(SearchableText="v1")\n         self.assertEqual(len(results), 0)\n-        results = cat(SearchableText=\'v2\', portal_type=\'Document\')\n+        results = cat(SearchableText="v2", portal_type="Document")\n         self.assertEqual(len(results), 1)\n         self.assertEqual(results[0].getObject(), doc)\n \n         retrieved_data = portal_repo.retrieve(\n-            fol, 0, preserve=[\'_Access_contents_information_Permission\'])\n+            fol, 0, preserve=["_Access_contents_information_Permission"]\n+        )\n         retrieved_doc = retrieved_data.object.doc1\n-        self.assertEqual(retrieved_doc.Title(), \'v1 of doc1\')\n+        self.assertEqual(retrieved_doc.Title(), "v1 of doc1")\n         # Test that basic retrieval did not alter the catalog\n-        results = cat(SearchableText=\'v1\', )\n+        results = cat(\n+            SearchableText="v1",\n+        )\n         self.assertEqual(len(results), 0)\n-        results = cat(SearchableText=\'v2\', portal_type=\'Document\')\n+        results = cat(SearchableText="v2", portal_type="Document")\n         self.assertEqual(len(results), 1)\n         self.assertEqual(results[0].getObject(), doc)\n \n         portal_repo.revert(fol, 0)\n         reverted_doc = self.portal.fol.doc1\n-        self.assertEqual(reverted_doc.Title(), \'v1 of doc1\')\n+        self.assertEqual(reverted_doc.Title(), "v1 of doc1")\n         # Test that the catalog is updated on revert\n-        results = cat(SearchableText=\'v2\')\n+        results = cat(SearchableText="v2")\n         self.assertEqual(len(results), 0)\n-        results = cat(SearchableText=\'v1\', portal_type=\'Document\')\n+        results = cat(SearchableText="v1", portal_type="Document")\n         self.assertEqual(len(results), 1)\n-        self.assertEqual(results[0].getObject().Title(), \'v1 of doc1\')\n+        self.assertEqual(results[0].getObject().Title(), "v1 of doc1")\n \n     def test17_moveInsideRefThenRevertChangesUid(self):\n         # When an object is contained in an \'Inside references folder\' and\n@@ -646,20 +648,24 @@ def test17_moveInsideRefThenRevertChangesUid(self):\n         # just configure the standard folder to treat the childrens as\n         # inside refrences. For this we reconfigure the standard modifiers.\n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n         orig_uid = portal_historyidhandler.queryUid(doc1)\n \n         transaction.savepoint(optimistic=True)\n-        self.portal.manage_pasteObjects(fol.manage_cutObjects(ids=[\'doc1\']))\n+        self.portal.manage_pasteObjects(fol.manage_cutObjects(ids=["doc1"]))\n         moved_doc = self.portal.doc1\n         self.assertEqual(portal_historyidhandler.queryUid(moved_doc), orig_uid)\n         transaction.savepoint(optimistic=True)\n@@ -668,8 +674,10 @@ def test17_moveInsideRefThenRevertChangesUid(self):\n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_folder = retrieved_data.object\n         ret_doc = ret_folder.doc1\n-        self.assertFalse(portal_historyidhandler.queryUid(ret_doc) == orig_uid,\n-                    "UIDs should not be equal, current value: %s" % orig_uid)\n+        self.assertFalse(\n+            portal_historyidhandler.queryUid(ret_doc) == orig_uid,\n+            "UIDs should not be equal, current value: %s" % orig_uid,\n+        )\n \n         # revert to original state, ensure that subobject changes are\n         # reverted and that uid is changed\n@@ -678,8 +686,10 @@ def test17_moveInsideRefThenRevertChangesUid(self):\n         reverted_doc = fol.doc1\n \n         # check if reversion worked correctly\n-        self.assertFalse(portal_historyidhandler.queryUid(reverted_doc) == orig_uid,\n-                    "UIDs should not be equal, current value: %s" % orig_uid)\n+        self.assertFalse(\n+            portal_historyidhandler.queryUid(reverted_doc) == orig_uid,\n+            "UIDs should not be equal, current value: %s" % orig_uid,\n+        )\n \n     def test18_retrieveObjectWhichHasBeenReplaced(self):\n         portal_repo = self.portal.portal_repository\n@@ -688,36 +698,38 @@ def test18_retrieveObjectWhichHasBeenReplaced(self):\n         doc2 = fol.doc2\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n-        portal_repo.applyVersionControl(doc1, comment=\'first save\')\n-        portal_repo.applyVersionControl(doc2, comment=\'first save\')\n+        portal_repo.applyVersionControl(doc1, comment="first save")\n+        portal_repo.applyVersionControl(doc2, comment="first save")\n \n         transaction.savepoint(optimistic=True)\n-        fol.manage_renameObjects([\'doc1\', \'doc2\'], [\'doc1_renamed\', \'doc1\'])\n+        fol.manage_renameObjects(["doc1", "doc2"], ["doc1_renamed", "doc1"])\n \n         doc1 = fol.doc1_renamed\n         doc2 = fol.doc1\n \n-        doc1.setTitle(\'v2 of doc1_renamed\')\n-        doc2.setTitle(\'v2 of doc1 (was doc2)\')\n+        doc1.setTitle("v2 of doc1_renamed")\n+        doc2.setTitle("v2 of doc1 (was doc2)")\n \n-        portal_repo.save(doc1, comment=\'second save\')\n-        portal_repo.save(doc2, comment=\'second save\')\n+        portal_repo.save(doc1, comment="second save")\n+        portal_repo.save(doc2, comment="second save")\n \n         retrieved_data = portal_repo.retrieve(doc1, 0)\n         ret_doc = retrieved_data.object\n-        self.assertEqual(ret_doc.getId(), \'doc1\')\n-        self.assertEqual(ret_doc.Title(), \'v1 of doc1\')\n+        self.assertEqual(ret_doc.getId(), "doc1")\n+        self.assertEqual(ret_doc.Title(), "v1 of doc1")\n \n         portal_repo.revert(doc1, 0)\n         rev_doc = fol.doc1_renamed\n-        self.assertEqual(rev_doc.getId(), \'doc1_renamed\')\n-        self.assertEqual(rev_doc.Title(), \'v1 of doc1\')\n+        self.assertEqual(rev_doc.getId(), "doc1_renamed")\n+        self.assertEqual(rev_doc.Title(), "v1 of doc1")\n \n-    def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolder(self):  # noqa\n+    def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolder(\n+        self,\n+    ):  # noqa\n         # disabled by gregweb/21-10-2006\n         # reason: Needs concentrated and deeper look.\n         # --> Ideas exist, pleas contact us on the list if you like to work\n@@ -730,50 +742,56 @@ def disabled_test19_retrieveDeletedObjectWhichHasBeenReplacedInAnInsideRefsFolde\n         doc2 = fol.doc2\n \n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n-        fol.manage_delObjects([\'doc1\'])\n+        fol.manage_delObjects(["doc1"])\n         transaction.savepoint(optimistic=True)\n-        fol.manage_renameObjects([\'doc2\'], [\'doc1\'])\n+        fol.manage_renameObjects(["doc2"], ["doc1"])\n \n         doc2 = fol.doc1\n \n-        doc1.setTitle(\'v2 of doc1_renamed\')\n-        doc2.setTitle(\'v2 of doc1 (was doc2)\')\n+        doc1.setTitle("v2 of doc1_renamed")\n+        doc2.setTitle("v2 of doc1 (was doc2)")\n \n-        portal_repo.save(fol, comment=\'second save\')\n+        portal_repo.save(fol, comment="second save")\n \n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_fol = retrieved_data.object\n-        self.assertEqual(ret_fol.objectIds(), [\'doc1\', \'doc2\'])\n+        self.assertEqual(ret_fol.objectIds(), ["doc1", "doc2"])\n         ret_doc1 = ret_fol.doc1\n         ret_doc2 = ret_fol.doc2\n-        self.assertEqual(ret_doc1.getId(), \'doc1\')\n-        self.assertEqual(ret_doc1.Title(), \'v1 of doc1\')\n-        self.assertEqual(ret_doc2.getId(), \'doc2\')\n-        self.assertEqual(ret_doc2.Title(), \'v1 of doc2\')\n+        self.assertEqual(ret_doc1.getId(), "doc1")\n+        self.assertEqual(ret_doc1.Title(), "v1 of doc1")\n+        self.assertEqual(ret_doc2.getId(), "doc2")\n+        self.assertEqual(ret_doc2.Title(), "v1 of doc2")\n \n         portal_repo.revert(fol, 0)\n         rev_fol = self.portal.fol\n-        self.assertEqual(rev_fol.objectIds(), [\'doc1\', \'doc2\'])\n+        self.assertEqual(rev_fol.objectIds(), ["doc1", "doc2"])\n         rev_doc1 = rev_fol.doc1\n         rev_doc2 = rev_fol.doc2\n-        self.assertEqual(rev_doc1.getId(), \'doc1\')\n-        self.assertEqual(rev_doc1.Title(), \'v1 of doc1\')\n-        self.assertEqual(rev_doc2.getId(), \'doc2\')\n-        self.assertEqual(rev_doc2.Title(), \'v1 of doc2\')\n-\n-    def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(self):  # noqa\n+        self.assertEqual(rev_doc1.getId(), "doc1")\n+        self.assertEqual(rev_doc1.Title(), "v1 of doc1")\n+        self.assertEqual(rev_doc2.getId(), "doc2")\n+        self.assertEqual(rev_doc2.Title(), "v1 of doc2")\n+\n+    def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(\n+        self,\n+    ):  # noqa\n         # disabled by gregweb/21-10-2006\n         # reason: Needs concentrated and deeper look.\n         # --> Ideas exist, pleas contact us on the list if you like to work\n@@ -786,49 +804,53 @@ def disabled_test20_retrieveMovedObjectWhichHasBeenReplacedInAnInsideRefsFolder(\n         doc2 = fol.doc2\n \n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         transaction.savepoint(optimistic=True)\n-        self.portal.manage_pasteObjects(fol.manage_cutObjects([\'doc1\']))\n-        fol.manage_renameObjects([\'doc2\'], [\'doc1\'])\n+        self.portal.manage_pasteObjects(fol.manage_cutObjects(["doc1"]))\n+        fol.manage_renameObjects(["doc2"], ["doc1"])\n \n         doc2 = fol.doc1\n         doc1 = self.portal.doc1\n \n-        doc1.setTitle(\'v2 of doc1 (now in portal root)\')\n-        doc2.setTitle(\'v2 of doc1 (was doc2)\')\n+        doc1.setTitle("v2 of doc1 (now in portal root)")\n+        doc2.setTitle("v2 of doc1 (was doc2)")\n \n-        portal_repo.save(fol, comment=\'second save\')\n+        portal_repo.save(fol, comment="second save")\n \n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_fol = retrieved_data.object\n-        self.assertEqual(ret_fol.objectIds(), [\'doc1\', \'doc2\'])\n+        self.assertEqual(ret_fol.objectIds(), ["doc1", "doc2"])\n         ret_doc1 = ret_fol.doc1\n         ret_doc2 = ret_fol.doc2\n-        self.assertEqual(ret_doc1.getId(), \'doc1\')\n-        self.assertEqual(ret_doc1.Title(), \'v1 of doc1\')\n-        self.assertEqual(ret_doc2.getId(), \'doc2\')\n-        self.assertEqual(ret_doc2.Title(), \'v1 of doc2\')\n+        self.assertEqual(ret_doc1.getId(), "doc1")\n+        self.assertEqual(ret_doc1.Title(), "v1 of doc1")\n+        self.assertEqual(ret_doc2.getId(), "doc2")\n+        self.assertEqual(ret_doc2.Title(), "v1 of doc2")\n \n         retrieved_data = portal_repo.revert(fol, 0)\n         rev_fol = self.portal.fol\n-        self.assertEqual(rev_fol.objectIds(), [\'doc1\', \'doc2\'])\n+        self.assertEqual(rev_fol.objectIds(), ["doc1", "doc2"])\n         rev_doc1 = rev_fol.doc1\n         rev_doc2 = rev_fol.doc2\n-        self.assertEqual(rev_doc1.getId(), \'doc1\')\n-        self.assertEqual(rev_doc1.Title(), \'v1 of doc1\')\n-        self.assertEqual(rev_doc2.getId(), \'doc2\')\n-        self.assertEqual(rev_doc2.Title(), \'v1 of doc2\')\n+        self.assertEqual(rev_doc1.getId(), "doc1")\n+        self.assertEqual(rev_doc1.Title(), "v1 of doc1")\n+        self.assertEqual(rev_doc2.getId(), "doc2")\n+        self.assertEqual(rev_doc2.Title(), "v1 of doc2")\n \n     def test21_DontLeaveDanglingCatalogEntriesWhenInvokingFactory(self):\n         portal_repo = self.portal.portal_repository\n@@ -838,35 +860,39 @@ def test21_DontLeaveDanglingCatalogEntriesWhenInvokingFactory(self):\n         doc2 = fol.doc2\n \n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n+        fol.setTitle("v1 of fol")\n         doc1.setTitle("v1 of doc1")\n         doc2.setTitle("v1 of doc2")\n \n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n-        self.assertEqual(len(catalog(getId=\'doc1\')), 1)\n+        self.assertEqual(len(catalog(getId="doc1")), 1)\n \n-        fol.manage_delObjects([\'doc2\', \'doc1\'])\n+        fol.manage_delObjects(["doc2", "doc1"])\n \n-        self.assertEqual(len(catalog(getId=\'doc1\')), 0)\n+        self.assertEqual(len(catalog(getId="doc1")), 0)\n \n-        portal_repo.save(fol, comment=\'second save\')\n+        portal_repo.save(fol, comment="second save")\n \n         retrieved_data = portal_repo.retrieve(fol, 0)\n         ret_fol = retrieved_data.object\n-        self.assertEqual(ret_fol.objectIds(), [\'doc1\', \'doc2\'])\n-        self.assertEqual(len(catalog(getId=\'doc1\')), 0)\n+        self.assertEqual(ret_fol.objectIds(), ["doc1", "doc2"])\n+        self.assertEqual(len(catalog(getId="doc1")), 0)\n \n         portal_repo.revert(fol, 0)\n         rev_fol = self.portal.fol\n-        self.assertEqual(rev_fol.objectIds(), [\'doc1\', \'doc2\'])\n-        self.assertEqual(len(catalog(getId=\'doc1\')), 1)\n+        self.assertEqual(rev_fol.objectIds(), ["doc1", "doc2"])\n+        self.assertEqual(len(catalog(getId="doc1")), 1)\n \n     def test21_RevertObjectWithChangedIdMaintainsConsistentCatalog(self):\n         portal_repo = self.portal.portal_repository\n@@ -877,27 +903,27 @@ def test21_RevertObjectWithChangedIdMaintainsConsistentCatalog(self):\n         # save change no 1\n         doc1.setTitle("v1 of doc1")\n \n-        portal_repo.applyVersionControl(doc1, comment=\'first save\')\n+        portal_repo.applyVersionControl(doc1, comment="first save")\n \n-        self.assertEqual(len(catalog(getId=\'doc1\')), 1)\n+        self.assertEqual(len(catalog(getId="doc1")), 1)\n \n         doc1.setTitle("v2 of doc1")\n         transaction.savepoint()\n-        fol.manage_renameObject(\'doc1\', \'doc1_changed\')\n+        fol.manage_renameObject("doc1", "doc1_changed")\n         doc1 = fol.doc1_changed\n         doc1.reindexObject()\n \n-        self.assertEqual(len(catalog(getId=\'doc1\')), 0)\n-        self.assertEqual(len(catalog(getId=\'doc1_changed\')), 1)\n+        self.assertEqual(len(catalog(getId="doc1")), 0)\n+        self.assertEqual(len(catalog(getId="doc1_changed")), 1)\n \n-        portal_repo.save(doc1, comment=\'second save\')\n+        portal_repo.save(doc1, comment="second save")\n \n         portal_repo.revert(doc1, 0)\n         rev_doc = fol.doc1_changed\n         self.assertEqual(rev_doc.Title(), "v1 of doc1")\n-        self.assertEqual(len(catalog(getId=\'doc1\')), 0)\n-        self.assertEqual(len(catalog(getId=\'doc1_changed\')), 1)\n-        self.assertEqual(len(catalog(Title=\'v1 of doc1\')), 1)\n+        self.assertEqual(len(catalog(getId="doc1")), 0)\n+        self.assertEqual(len(catalog(getId="doc1_changed")), 1)\n+        self.assertEqual(len(catalog(Title="v1 of doc1")), 1)\n \n     def test21_RestoreMovedObject(self):\n         portal_repo = self.portal.portal_repository\n@@ -909,29 +935,29 @@ def test21_RestoreMovedObject(self):\n         # save change no 1\n         doc1.setTitle("v1 of doc1")\n \n-        portal_repo.applyVersionControl(doc1, comment=\'first save\')\n+        portal_repo.applyVersionControl(doc1, comment="first save")\n         # save the ``history_id`` to be able to retrieve the object after\n         # it\'s deletion\n         history_id = portal_hidhandler.queryUid(doc1)\n \n         doc1.setTitle("v2 of doc1")\n         transaction.savepoint()\n-        fol.manage_renameObject(\'doc1\', \'doc1_changed\')\n+        fol.manage_renameObject("doc1", "doc1_changed")\n         doc1 = fol.doc1_changed\n         doc1.reindexObject()\n \n-        self.assertEqual(len(catalog(getId=\'doc1\')), 0)\n-        self.assertEqual(len(catalog(getId=\'doc1_changed\')), 1)\n+        self.assertEqual(len(catalog(getId="doc1")), 0)\n+        self.assertEqual(len(catalog(getId="doc1_changed")), 1)\n \n-        portal_repo.save(doc1, comment=\'second save\')\n+        portal_repo.save(doc1, comment="second save")\n         portal_repo.restore(history_id, selector=0, container=fol)\n         # Both documents should now be in place\n         res_doc = fol.doc1\n         self.assertEqual(res_doc.Title(), "v1 of doc1")\n-        self.assertEqual(len(catalog(getId=\'doc1\')), 1)\n-        self.assertEqual(len(catalog(getId=\'doc1_changed\')), 1)\n-        self.assertEqual(len(catalog(Title=\'v1 of doc1\')), 1)\n-        self.assertEqual(len(catalog(Title=\'v2 of doc1\')), 1)\n+        self.assertEqual(len(catalog(getId="doc1")), 1)\n+        self.assertEqual(len(catalog(getId="doc1_changed")), 1)\n+        self.assertEqual(len(catalog(Title="v1 of doc1")), 1)\n+        self.assertEqual(len(catalog(Title="v2 of doc1")), 1)\n         # The reverted document should have a new uid, because an object with\n         # the original uid exists\n         self.assertFalse(portal_hidhandler.queryUid(res_doc) == history_id)\n@@ -968,54 +994,52 @@ def test23_versioningPreservesFolderAnnotations(self):\n         fol = self.portal.fol\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n-        fol.__annotations__[\'something\'] = True\n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        fol.setTitle("v1 of fol")\n+        fol.__annotations__["something"] = True\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         # save change no 2\n-        fol.setTitle(\'v2 of fol\')\n-        fol.__annotations__[\'something\'] = False\n-        portal_repo.save(fol, comment=\'second save\')\n+        fol.setTitle("v2 of fol")\n+        fol.__annotations__["something"] = False\n+        portal_repo.save(fol, comment="second save")\n \n         # change no 3 (without saving)\n-        fol.setTitle(\'v3 of fol\')\n-        fol.__annotations__[\'something\'] = None\n-        fol.__annotations__[\'another_thing\'] = True\n+        fol.setTitle("v3 of fol")\n+        fol.__annotations__["something"] = None\n+        fol.__annotations__["another_thing"] = True\n \n         # retrieve change 1 and 2\n         repo_fol1 = portal_repo.retrieve(fol, 0).object\n         repo_fol2 = portal_repo.retrieve(fol, 1).object\n \n         # Test values on the repository copies and the working copy\n-        self.assertEqual(repo_fol1.__annotations__[\'something\'], True)\n-        self.assertEqual(repo_fol2.__annotations__[\'something\'], False)\n-        self.assertEqual(fol.__annotations__[\'something\'], None)\n-        self.assertEqual(repo_fol2.__annotations__.get(\'another_thing\',\n-                                                           None), None)\n+        self.assertEqual(repo_fol1.__annotations__["something"], True)\n+        self.assertEqual(repo_fol2.__annotations__["something"], False)\n+        self.assertEqual(fol.__annotations__["something"], None)\n+        self.assertEqual(repo_fol2.__annotations__.get("another_thing", None), None)\n \n         # Test that revert brings in the original annotation\n         portal_repo.revert(fol)\n-        self.assertEqual(fol.__annotations__[\'something\'], False)\n-        self.assertEqual(fol.__annotations__.get(\'another_thing\', None),\n-                             None)\n+        self.assertEqual(fol.__annotations__["something"], False)\n+        self.assertEqual(fol.__annotations__.get("another_thing", None), None)\n \n         portal_repo.revert(fol, 0)\n-        self.assertEqual(fol.__annotations__[\'something\'], True)\n+        self.assertEqual(fol.__annotations__["something"], True)\n \n     def test24_versioningPreservesFolderOrder(self):\n         portal_repo = self.portal.portal_repository\n         fol = self.portal.fol\n-        doc2 = fol[\'doc2\']\n+        doc2 = fol["doc2"]\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        fol.setTitle("v1 of fol")\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         # save change no 2\n-        fol.setTitle(\'v2 of fol\')\n-        fol.moveObjectsToTop([\'doc2\'])\n+        fol.setTitle("v2 of fol")\n+        fol.moveObjectsToTop(["doc2"])\n \n-        self.assertEqual(fol.objectIds()[0], \'doc2\')\n+        self.assertEqual(fol.objectIds()[0], "doc2")\n \n         working_ids = fol.objectIds()\n \n@@ -1029,75 +1053,78 @@ def test24_versioningPreservesFolderOrder(self):\n         self.assertEqual(fol.objectIds(), working_ids)\n \n         # See how we interact with delete\n-        fol.invokeFactory(\'Document\', \'doc3\')\n-        fol.moveObjectsToTop([\'doc3\'])\n-        fol.manage_delObjects([\'doc2\'])\n+        fol.invokeFactory("Document", "doc3")\n+        fol.moveObjectsToTop(["doc3"])\n+        fol.manage_delObjects(["doc2"])\n         transaction.savepoint(optimistic=True)\n \n         working_ids = fol.objectIds()\n-        doc3 = fol[\'doc3\']\n+        doc3 = fol["doc3"]\n         portal_repo.revert(fol)\n \n         # Test that we kept the ids from working copy, kept the new child\n         # restored the deleted child\n         self.assertEqual(fol.objectIds(), working_ids)\n-        self.assertEqual(fol.objectIds()[0], \'doc3\')\n-        self.assertEqual(getattr(fol, \'doc2\', None), None)\n-        self.assertEqual(fol[\'doc3\'], doc3)\n+        self.assertEqual(fol.objectIds()[0], "doc3")\n+        self.assertEqual(getattr(fol, "doc2", None), None)\n+        self.assertEqual(fol["doc3"], doc3)\n \n         # Test the BTreeFolder internals\n-        self.assertEqual(fol._tree.get(\'doc2\', None), None)\n-        self.assertEqual(fol._tree[\'doc3\'], doc3)\n+        self.assertEqual(fol._tree.get("doc2", None), None)\n+        self.assertEqual(fol._tree["doc3"], doc3)\n         self.assertEqual(fol._count(), 2)\n-        self.assertEqual(fol._mt_index[doc2.meta_type].get(\'doc2\', None),\n-                             None)\n-        self.assertEqual(fol._mt_index[doc3.meta_type][\'doc3\'], 1)\n+        self.assertEqual(fol._mt_index[doc2.meta_type].get("doc2", None), None)\n+        self.assertEqual(fol._mt_index[doc3.meta_type]["doc3"], 1)\n \n     def test25_versioningRestoresInsideRefsFolderOrder(self):\n         # Enable OMInsideChildrensModifier\n         portal_modifier = self.portal.portal_modifier\n-        portal_modifier.edit("OMOutsideChildrensModifier", enabled=False,\n-                             condition="python: False")\n-        portal_modifier.edit("OMInsideChildrensModifier", enabled=True,\n-                             condition="python: portal_type==\'Folder\'")\n+        portal_modifier.edit(\n+            "OMOutsideChildrensModifier", enabled=False, condition="python: False"\n+        )\n+        portal_modifier.edit(\n+            "OMInsideChildrensModifier",\n+            enabled=True,\n+            condition="python: portal_type==\'Folder\'",\n+        )\n \n         portal_repo = self.portal.portal_repository\n         fol = self.portal.fol\n \n         # save change no 1\n-        fol.setTitle(\'v1 of fol\')\n-        fol.invokeFactory(\'Document\', \'doc3\')\n-        fol.invokeFactory(\'Document\', \'doc4\')\n-        portal_repo.applyVersionControl(fol, comment=\'first save\')\n+        fol.setTitle("v1 of fol")\n+        fol.invokeFactory("Document", "doc3")\n+        fol.invokeFactory("Document", "doc4")\n+        portal_repo.applyVersionControl(fol, comment="first save")\n \n         orig_order = fol.objectIds()\n \n-        fol.setTitle(\'v2 of fol\')\n-        fol.moveObjectsToTop([\'doc2\'])\n+        fol.setTitle("v2 of fol")\n+        fol.moveObjectsToTop(["doc2"])\n \n-        self.assertEqual(fol.objectIds()[0], \'doc2\')\n+        self.assertEqual(fol.objectIds()[0], "doc2")\n \n         # Test that a retrieve uses the order from the repo copy\n         repo_fol1 = portal_repo.retrieve(fol, 0).object\n-        self.assertEqual(fol.objectIds()[0], \'doc2\')\n+        self.assertEqual(fol.objectIds()[0], "doc2")\n         self.assertNotEqual(fol.objectIds(), orig_order)\n-        self.assertEqual(repo_fol1.objectIds()[0], \'doc1\')\n+        self.assertEqual(repo_fol1.objectIds()[0], "doc1")\n \n         # Test that a revert restores the order and objects from the\n         # repo copy\n         portal_repo.revert(fol)\n-        self.assertEqual(fol.objectIds()[0], \'doc1\')\n+        self.assertEqual(fol.objectIds()[0], "doc1")\n         self.assertEqual(fol.objectIds(), orig_order)\n \n         # See how we interact with some adds deletes and reorders\n-        fol.invokeFactory(\'Document\', \'doc5\')\n-        fol.moveObjectsToTop([\'doc3\'])\n-        fol.moveObjectsToTop([\'doc4\'])\n-        fol.manage_delObjects([\'doc2\'])\n+        fol.invokeFactory("Document", "doc5")\n+        fol.moveObjectsToTop(["doc3"])\n+        fol.moveObjectsToTop(["doc4"])\n+        fol.manage_delObjects(["doc2"])\n         processQueue()\n         transaction.savepoint(optimistic=True)\n-        doc3 = fol[\'doc3\']\n-        doc4 = fol[\'doc4\']\n+        doc3 = fol["doc3"]\n+        doc4 = fol["doc4"]\n \n         self.assertNotEqual(fol.objectIds(), orig_order)\n \n@@ -1107,31 +1134,30 @@ def test25_versioningRestoresInsideRefsFolderOrder(self):\n         # but does not affect the working copy\n         repo_fol1 = portal_repo.retrieve(fol, 0).object\n         self.assertEqual(repo_fol1.objectIds(), orig_order)\n-        self.assertNotEqual(getattr(repo_fol1, \'doc2\', None), None)\n-        self.assertEqual(getattr(repo_fol1, \'doc5\', None), None)\n+        self.assertNotEqual(getattr(repo_fol1, "doc2", None), None)\n+        self.assertEqual(getattr(repo_fol1, "doc5", None), None)\n \n         self.assertNotEqual(fol.objectIds(), orig_order)\n-        self.assertEqual(fol.objectIds()[0], \'doc4\')\n-        self.assertEqual(fol.objectIds()[1], \'doc3\')\n-        self.assertEqual(fol[\'doc3\'], doc3)\n-        self.assertEqual(fol[\'doc4\'], doc4)\n-        self.assertEqual(getattr(fol, \'doc2\', None), None)\n-        self.assertNotEqual(getattr(fol, \'doc5\', None), None)\n+        self.assertEqual(fol.objectIds()[0], "doc4")\n+        self.assertEqual(fol.objectIds()[1], "doc3")\n+        self.assertEqual(fol["doc3"], doc3)\n+        self.assertEqual(fol["doc4"], doc4)\n+        self.assertEqual(getattr(fol, "doc2", None), None)\n+        self.assertNotEqual(getattr(fol, "doc5", None), None)\n \n         # Test that a revert restores the missing child from the repo\n         # copy, removed the newly created child and restored the order\n         portal_repo.revert(fol)\n \n         self.assertEqual(list(fol.objectIds()), orig_order)\n-        self.assertEqual(getattr(fol, \'doc5\', None), None)\n+        self.assertEqual(getattr(fol, "doc5", None), None)\n \n         # Test the BTreeFolder internals\n-        self.assertEqual(fol._tree.get(\'doc5\', None), None)\n+        self.assertEqual(fol._tree.get("doc5", None), None)\n         self.assertEqual(fol._count(), 4)\n-        self.assertEqual(fol._mt_index[doc3.meta_type].get(\'doc5\', None),\n-                             None)\n-        self.assertEqual(fol._tree[\'doc3\'], fol[\'doc3\'].aq_base)\n-        self.assertEqual(fol._mt_index[doc3.meta_type][\'doc3\'], 1)\n+        self.assertEqual(fol._mt_index[doc3.meta_type].get("doc5", None), None)\n+        self.assertEqual(fol._tree["doc3"], fol["doc3"].aq_base)\n+        self.assertEqual(fol._mt_index[doc3.meta_type]["doc3"], 1)\n \n     def test26_RegistryBasesNotVersionedOrRestored(self):\n         portal_repo = self.portal.portal_repository\n@@ -1146,10 +1172,14 @@ def test26_RegistryBasesNotVersionedOrRestored(self):\n         portal_repo.applyVersionControl(fol)\n \n         broken_iface = broken.find_global(\n-            \'never_gonna_be_real\', \'IMissing\',\n-            Broken=ZODB.interfaces.IBroken, type=InterfaceClass)\n-        sys.modules[broken_iface.__module__] = module = imp.new_module(\n-            broken_iface.__module__)\n+            "never_gonna_be_real",\n+            "IMissing",\n+            Broken=ZODB.interfaces.IBroken,\n+            type=InterfaceClass,\n+        )\n+        sys.modules[broken_iface.__module__] = module = types.ModuleType(\n+            broken_iface.__module__\n+        )\n         module.IMissing = broken_iface\n \n         # add a broken registrsation but do a savepoint before\n@@ -1167,5 +1197,4 @@ def test26_RegistryBasesNotVersionedOrRestored(self):\n         portal_archivist._cloneByPickle(fol)\n \n         self.assertEqual(self.portal.fol.Title(), "v2")\n-        self.assertTrue(\n-            self.portal.fol.getSiteManager().__bases__[0] is base)\n+        self.assertTrue(self.portal.fol.getSiteManager().__bases__[0] is base)\ndiff --git a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\nindex af24006..ef6aa65 100644\n--- a/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\n+++ b/Products/CMFEditions/tests/test_KeepLastNVersionsTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2006 Gregoire Weber\n # All Rights Reserved.\n@@ -32,12 +31,10 @@\n \n \n class TestKeepLastNVersionsTool(CMFEditionsBaseTestCase):\n-\n     def setUp(self):\n-        super(TestKeepLastNVersionsTool, self).setUp()\n+        super().setUp()\n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\',\n-                                                [\'Manager\'], \'\')\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n \n         # install test storage\n         self._setDummyTool(PurgePolicyTestDummyStorage())\n@@ -101,10 +98,10 @@ def test03_retrieveOlderSubstitute(self):\n \n         # next newer\n         data = purgepolicy.retrieveSubstitute(history_id=1, selector=0)\n-        self.assertEquals(data.data, 1)\n+        self.assertEqual(data.data, 1)\n         # next older\n         data = purgepolicy.retrieveSubstitute(history_id=1, selector=2)\n-        self.assertEquals(data.data, 1)\n+        self.assertEqual(data.data, 1)\n         # next older\n         data = purgepolicy.retrieveSubstitute(history_id=1, selector=3)\n-        self.assertEquals(data.data, 1)\n+        self.assertEqual(data.data, 1)\ndiff --git a/Products/CMFEditions/tests/test_ModifierRegistryTool.py b/Products/CMFEditions/tests/test_ModifierRegistryTool.py\nindex c5f9963..11f1d1a 100644\n--- a/Products/CMFEditions/tests/test_ModifierRegistryTool.py\n+++ b/Products/CMFEditions/tests/test_ModifierRegistryTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -24,6 +23,7 @@\n """\n \n from Acquisition import aq_base\n+\n # provoke the warning messages before the first test\n from OFS.SimpleItem import SimpleItem\n from pickle import dumps\n@@ -42,14 +42,17 @@\n \n class Dummy(SimpleItem):\n     pass\n+\n+\n def deepcopy(obj):\n     return loads(dumps(obj, HIGHEST_PROTOCOL))\n+\n+\n deepcopy(Dummy())\n \n \n @implementer(ISaveRetrieveModifier)\n class SimpleModifierBase:\n-\n     def beforeSaveModifier(self, obj, copy_obj):\n         try:\n             bsm = getattr(copy_obj, self.beforeSaveModifierAttribute)\n@@ -68,41 +71,49 @@ def afterRetrieveModifier(self, obj, repo_obj):\n         setattr(repo_obj, self.afterRetrieveModifierAttribute, arm)\n         return [], [], {}\n \n+\n class SimpleModifier1(SimpleModifierBase):\n-    beforeSaveModifierAttribute = \'beforeSave1\'\n-    afterRetrieveModifierAttribute = \'afterRetrieve1\'\n+    beforeSaveModifierAttribute = "beforeSave1"\n+    afterRetrieveModifierAttribute = "afterRetrieve1"\n+\n \n class SimpleModifier2(SimpleModifierBase):\n-    beforeSaveModifierAttribute = \'beforeSave2\'\n-    afterRetrieveModifierAttribute = \'afterRetrieve2\'\n+    beforeSaveModifierAttribute = "beforeSave2"\n+    afterRetrieveModifierAttribute = "afterRetrieve2"\n+\n \n class SimpleModifier3(SimpleModifierBase):\n-    beforeSaveModifierAttribute = \'beforeSave3\'\n-    afterRetrieveModifierAttribute = \'afterRetrieve3\'\n+    beforeSaveModifierAttribute = "beforeSave3"\n+    afterRetrieveModifierAttribute = "afterRetrieve3"\n+\n \n class NonModifier(SimpleItem):\n     pass\n \n+\n mlog = []\n \n+\n def dictToString(dict):\n     dict_list = []\n     keys = [key for key in dict.keys()]\n     keys.sort()\n     for k in keys:\n-        dict_list.append("%s = %s" % (k, dict[k]))\n-    return \', \'.join(dict_list)\n+        dict_list.append(f"{k} = {dict[k]}")\n+    return ", ".join(dict_list)\n+\n \n @implementer(IAttributeModifier, ICloneModifier, ISaveRetrieveModifier)\n class LoggingModifierBase:\n-\n     def getReferencedAttributes(self, obj):\n         referenced_data = {\n-            \'k1\': \'v1:\'+str(self.__class__.__name__),\n-            \'k2\': \'v2:\'+str(self.__class__.__name__),\n+            "k1": "v1:" + str(self.__class__.__name__),\n+            "k2": "v2:" + str(self.__class__.__name__),\n         }\n-        mlog.append("%s.getReferencedAttributes: %s" %\n-                    (self.__class__.__name__, dictToString(referenced_data)))\n+        mlog.append(\n+            "%s.getReferencedAttributes: %s"\n+            % (self.__class__.__name__, dictToString(referenced_data))\n+        )\n         return referenced_data\n \n     def getOnCloneModifiers(self, obj):\n@@ -115,7 +126,7 @@ def persistent_load(pid):\n             # should never reach this!\n             assert False\n \n-        return persistent_id, persistent_load, [], [], \'\'\n+        return persistent_id, persistent_load, [], [], ""\n \n     def beforeSaveModifier(self, obj, obj_clone):\n         mlog.append("%s.beforeSaveModifier" % (self.__class__.__name__))\n@@ -125,18 +136,23 @@ def afterRetrieveModifier(self, obj, repo_clone, preserve=()):\n         mlog.append("%s.afterRetrieveModifier" % (self.__class__.__name__))\n         return [], [], {}\n \n+\n class LoggingModifier_A(LoggingModifierBase):\n     pass\n \n+\n class LoggingModifier_B(LoggingModifierBase):\n     pass\n \n+\n class LoggingModifier_C(LoggingModifierBase):\n     pass\n \n+\n class LoggingModifier_D(LoggingModifierBase):\n     pass\n \n+\n loggingModifiers = (\n     LoggingModifier_A(),\n     LoggingModifier_B(),\n@@ -144,51 +160,51 @@ class LoggingModifier_D(LoggingModifierBase):\n     LoggingModifier_D(),\n )\n \n-class TestModifierRegistryTool(CMFEditionsBaseTestCase):\n \n+class TestModifierRegistryTool(CMFEditionsBaseTestCase):\n     def setUp(self):\n-        super(TestModifierRegistryTool, self).setUp()\n+        super().setUp()\n \n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\',\n-                                                [\'Manager\'], \'\')\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n         # add a document\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n+        self.portal.invokeFactory("Document", "doc")\n \n         # just unregister the standard modifiers for the unit tests\n-        portal_modifier = getToolByName(self.portal, \'portal_modifier\')\n+        portal_modifier = getToolByName(self.portal, "portal_modifier")\n         modifiers = portal_modifier.modules.StandardModifiers.modifiers\n         for m in modifiers:\n-            portal_modifier.unregister(m[\'id\'])\n+            portal_modifier.unregister(m["id"])\n \n     def test00_interface(self):\n         portal_modifier = self.portal.portal_modifier\n \n         # test interface conformance\n-        #verifyObject(IModifier, portal_modifier)\n+        # verifyObject(IModifier, portal_modifier)\n         verifyObject(IModifierRegistrySet, portal_modifier)\n         verifyObject(IModifierRegistryQuery, portal_modifier)\n-#        verifyObject(IBulkEditableSubscriberRegistry, portal_modifier)\n+\n+    #        verifyObject(IBulkEditableSubscriberRegistry, portal_modifier)\n \n     def test01_modifiersNotCalled(self):\n         portal_modifier = self.portal.portal_modifier\n         doc = self.portal.doc\n         doc_copy = deepcopy(aq_base(doc))\n \n-        portal_modifier.register(\'1\', SimpleModifier1())\n-        portal_modifier.edit(\'1\', condition=\'python:True\')\n+        portal_modifier.register("1", SimpleModifier1())\n+        portal_modifier.edit("1", condition="python:True")\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         portal_modifier.afterRetrieveModifier(doc, doc_copy)\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'beforeSave1\')\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'afterRetrieve1\')\n+        self.assertRaises(AttributeError, getattr, doc_copy, "beforeSave1")\n+        self.assertRaises(AttributeError, getattr, doc_copy, "afterRetrieve1")\n \n     def test02_enabledModifierCalled(self):\n         portal_modifier = self.portal.portal_modifier\n         doc = self.portal.doc\n         doc_copy = deepcopy(aq_base(doc))\n \n-        portal_modifier.register(\'1\', SimpleModifier1())\n-        portal_modifier.edit(\'1\', enabled=True, condition=\'python:True\')\n+        portal_modifier.register("1", SimpleModifier1())\n+        portal_modifier.edit("1", enabled=True, condition="python:True")\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         portal_modifier.afterRetrieveModifier(doc, doc_copy)\n \n@@ -201,38 +217,38 @@ def test03_unregisteredModifiersNotCalled(self):\n         doc = self.portal.doc\n         doc_copy = deepcopy(aq_base(doc))\n \n-        portal_modifier.register(\'1\', SimpleModifier1())\n-        portal_modifier.edit(\'1\', enabled=True, condition=\'python:True\')\n+        portal_modifier.register("1", SimpleModifier1())\n+        portal_modifier.edit("1", enabled=True, condition="python:True")\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         self.assertEqual(doc_copy.beforeSave1, 1)\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'afterRetrieve1\')\n-        portal_modifier.unregister(\'1\')\n+        self.assertRaises(AttributeError, getattr, doc_copy, "afterRetrieve1")\n+        portal_modifier.unregister("1")\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         self.assertEqual(doc_copy.beforeSave1, 1)\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'afterRetrieve1\')\n+        self.assertRaises(AttributeError, getattr, doc_copy, "afterRetrieve1")\n \n     def test04_conditionEvaluated(self):\n         portal_modifier = self.portal.portal_modifier\n         doc = self.portal.doc\n         doc_copy = deepcopy(aq_base(doc))\n \n-        portal_modifier.register(\'1\', SimpleModifier1())\n-        portal_modifier.edit(\'1\', enabled=True, condition=\'python:False\')\n+        portal_modifier.register("1", SimpleModifier1())\n+        portal_modifier.edit("1", enabled=True, condition="python:False")\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         portal_modifier.afterRetrieveModifier(doc, doc_copy)\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'beforeSave1\')\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'afterRetrieve1\')\n+        self.assertRaises(AttributeError, getattr, doc_copy, "beforeSave1")\n+        self.assertRaises(AttributeError, getattr, doc_copy, "afterRetrieve1")\n \n     def test05_registerANonModifier(self):\n         portal_modifier = self.portal.portal_modifier\n         doc = self.portal.doc\n         doc_copy = deepcopy(aq_base(doc))\n \n-        portal_modifier._setObject(\'doc\', NonModifier())\n+        portal_modifier._setObject("doc", NonModifier())\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         portal_modifier.afterRetrieveModifier(doc, doc_copy)\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'beforeSave1\')\n-        self.assertRaises(AttributeError, getattr, doc_copy, \'afterRetrieve1\')\n+        self.assertRaises(AttributeError, getattr, doc_copy, "beforeSave1")\n+        self.assertRaises(AttributeError, getattr, doc_copy, "afterRetrieve1")\n \n     def test06_modifierAddedToTheCorrectPosition(self):\n         portal_modifier = self.portal.portal_modifier\n@@ -243,9 +259,9 @@ def test06_modifierAddedToTheCorrectPosition(self):\n         m2 = SimpleModifier2()\n         m3 = SimpleModifier3()\n \n-        portal_modifier.register(\'1\', m1)\n-        portal_modifier.register(\'2\', m2)\n-        portal_modifier.register(\'3\', m3, pos=0)\n+        portal_modifier.register("1", m1)\n+        portal_modifier.register("2", m2)\n+        portal_modifier.register("3", m3, pos=0)\n \n         modifiers = [m.getModifier() for m in portal_modifier.objectValues()]\n         self.assertEqual(modifiers, [m3, m1, m2])\n@@ -259,11 +275,11 @@ def test07_unregisterModifer(self):\n         m2 = SimpleModifier2()\n         m3 = SimpleModifier3()\n \n-        portal_modifier.register(\'1\', m1)\n-        portal_modifier.register(\'2\', m2)\n-        portal_modifier.register(\'3\', m3, pos=0)\n+        portal_modifier.register("1", m1)\n+        portal_modifier.register("2", m2)\n+        portal_modifier.register("3", m3, pos=0)\n \n-        portal_modifier.unregister(\'1\')\n+        portal_modifier.unregister("1")\n \n         modifiers = [m.getModifier() for m in portal_modifier.objectValues()]\n         self.assertEqual(modifiers, [m3, m2])\n@@ -275,16 +291,16 @@ def test08_getModifiers(self):\n         m2 = SimpleModifier2()\n         m3 = SimpleModifier3()\n \n-        portal_modifier.register(\'1\', m1)\n-        portal_modifier.register(\'2\', m2)\n-        portal_modifier.register(\'3\', m3, pos=0)\n+        portal_modifier.register("1", m1)\n+        portal_modifier.register("2", m2)\n+        portal_modifier.register("3", m3, pos=0)\n \n-        portal_modifier.unregister(\'1\')\n+        portal_modifier.unregister("1")\n \n-        self.assertEqual(portal_modifier.get(\'2\').getModifier(), m2)\n-        self.assertEqual(portal_modifier.query(\'2\').getModifier(), m2)\n-        self.assertRaises(AttributeError, portal_modifier.get, \'1\')\n-        self.assertEqual(portal_modifier.query(\'1\', None), None)\n+        self.assertEqual(portal_modifier.get("2").getModifier(), m2)\n+        self.assertEqual(portal_modifier.query("2").getModifier(), m2)\n+        self.assertRaises(AttributeError, portal_modifier.get, "1")\n+        self.assertEqual(portal_modifier.query("1", None), None)\n \n     def test09_conditionContextSetUpCorretcly(self):\n         portal_modifier = self.portal.portal_modifier\n@@ -292,20 +308,22 @@ def test09_conditionContextSetUpCorretcly(self):\n         doc_copy = deepcopy(aq_base(doc))\n \n         # just check if variables got defined\n-        condition = \'python:"%s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s" % (\' \\\n-                    \'object_url, \' \\\n-                    \'folder_url, \' \\\n-                    \'portal_url, \' \\\n-                    \'object, \' \\\n-                    \'folder, \' \\\n-                    \'portal, \' \\\n-                    \'nothing, \' \\\n-                    \'request, \' \\\n-                    \'modules, \' \\\n-                    \'member,\' \\\n-                    \')\'\n-        portal_modifier.register(\'1\', SimpleModifier1())\n-        portal_modifier.edit(\'1\', enabled=True, condition=condition)\n+        condition = (\n+            \'python:"%s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s\\n %s" % (\'\n+            "object_url, "\n+            "folder_url, "\n+            "portal_url, "\n+            "object, "\n+            "folder, "\n+            "portal, "\n+            "nothing, "\n+            "request, "\n+            "modules, "\n+            "member,"\n+            ")"\n+        )\n+        portal_modifier.register("1", SimpleModifier1())\n+        portal_modifier.edit("1", enabled=True, condition=condition)\n \n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n         portal_modifier.afterRetrieveModifier(doc, doc_copy)\n@@ -325,22 +343,21 @@ def test10_callingOrder(self):\n         for m in loggingModifiers:\n             counter += 1\n             portal_modifier.register(str(counter), m)\n-            portal_modifier.edit(str(counter),\n-                                 enabled=True,\n-                                 condition=\'python:True\')\n+            portal_modifier.edit(str(counter), enabled=True, condition="python:True")\n \n-        mlog.append(\'<save>\')\n+        mlog.append("<save>")\n         portal_modifier.getReferencedAttributes(doc)\n         portal_modifier.getOnCloneModifiers(doc)\n         portal_modifier.beforeSaveModifier(doc, doc_copy)\n-        mlog.append(\'<retrieve>\')\n+        mlog.append("<retrieve>")\n \n         portal_modifier.afterRetrieveModifier(doc, doc_copy)\n-        mlog.append(\'<end>\')\n+        mlog.append("<end>")\n \n-        mlog_str = \'\\n\'.join(mlog).replace(\'__main__\', \'CMFEditions.tests.test_ModifierRegistryTool\')\n-        expected_result = \\\n-"""<save>\n+        mlog_str = "\\n".join(mlog).replace(\n+            "__main__", "CMFEditions.tests.test_ModifierRegistryTool"\n+        )\n+        expected_result = """<save>\n %(class)s_A.getReferencedAttributes: k1 = v1:%(class)s_A, k2 = v2:%(class)s_A\n %(class)s_B.getReferencedAttributes: k1 = v1:%(class)s_B, k2 = v2:%(class)s_B\n %(class)s_C.getReferencedAttributes: k1 = v1:%(class)s_C, k2 = v2:%(class)s_C\n@@ -358,5 +375,7 @@ def test10_callingOrder(self):\n %(class)s_C.afterRetrieveModifier\n %(class)s_B.afterRetrieveModifier\n %(class)s_A.afterRetrieveModifier\n-<end>"""%{\'class\':\'LoggingModifier\'}\n+<end>""" % {\n+            "class": "LoggingModifier"\n+        }\n         self.assertEqual(mlog_str, expected_result)\ndiff --git a/Products/CMFEditions/tests/test_ZVCStorageTool.py b/Products/CMFEditions/tests/test_ZVCStorageTool.py\nindex 120ae41..1c4c8bb 100644\n--- a/Products/CMFEditions/tests/test_ZVCStorageTool.py\n+++ b/Products/CMFEditions/tests/test_ZVCStorageTool.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber,\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -46,27 +45,23 @@ class DummyOM(ObjectManager):\n \n \n class CMFDummy(Dummy):\n-\n     def __init__(self, id, cmfuid, effective=None, expires=None):\n-        super(CMFDummy, self).__init__()\n+        super().__init__()\n         self.id = id\n         self.cmf_uid = cmfuid\n-        self.effective = \\\n-            effective if effective is not None else self.modification_date\n+        self.effective = effective if effective is not None else self.modification_date\n         self.expires = expires\n \n     def getPortalTypeName(self):\n-        return \'Dummy\'\n+        return "Dummy"\n \n \n class TestZVCStorageTool(CMFEditionsBaseTestCase):\n-\n     def setUp(self):\n-        super(TestZVCStorageTool, self).setUp()\n+        super().setUp()\n \n         # add an additional user\n-        self.portal.acl_users.userFolderAddUser(\'reviewer\', \'reviewer\',\n-                                                [\'Manager\'], \'\')\n+        self.portal.acl_users.userFolderAddUser("reviewer", "reviewer", ["Manager"], "")\n \n         # eventually install another storage\n         self.installStorageTool()\n@@ -92,7 +87,7 @@ def _setDummyTool(self, tool):\n         setattr(self.portal, tool.getId(), tool)\n \n     def buildMetadata(self, comment):\n-        return {\'sys_metadata\': {\'comment\': comment}}\n+        return {"sys_metadata": {"comment": comment}}\n \n     def getComment(self, vdata):\n         return vdata.metadata["sys_metadata"]["comment"]\n@@ -108,82 +103,95 @@ def test01_saveAfterRegisteringDoesNotRaiseException(self):\n         portal_storage = self.portal.portal_historiesstorage\n         obj = Dummy()\n \n-        sel = portal_storage.register(1, ObjectData(obj),\n-                                      metadata=self.buildMetadata(\'saved\'))\n+        sel = portal_storage.register(\n+            1, ObjectData(obj), metadata=self.buildMetadata("saved")\n+        )\n         self.assertEqual(sel, 0)\n-        sel = portal_storage.save(1, ObjectData(obj),\n-                                  metadata=self.buildMetadata(\'saved\'))\n+        sel = portal_storage.save(\n+            1, ObjectData(obj), metadata=self.buildMetadata("saved")\n+        )\n         self.assertEqual(sel, 1)\n \n     def test02_saveUnregisteredObjectRaisesException(self):\n         portal_storage = self.portal.portal_historiesstorage\n         obj = Dummy()\n \n-        self.assertRaises(StorageUnregisteredError,\n-                          portal_storage.save,\n-                          1, ObjectData(obj), metadata=self.buildMetadata(\'saved\'))\n+        self.assertRaises(\n+            StorageUnregisteredError,\n+            portal_storage.save,\n+            1,\n+            ObjectData(obj),\n+            metadata=self.buildMetadata("saved"),\n+        )\n \n     def test03_saveAndRetrieve(self):\n         portal_storage = self.portal.portal_historiesstorage\n \n         obj1 = Dummy()\n-        obj1.text = \'v1 of text\'\n-        portal_storage.register(1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\'))\n+        obj1.text = "v1 of text"\n+        portal_storage.register(\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n+        )\n \n         obj2 = Dummy()\n-        obj2.text = \'v2 of text\'\n-        portal_storage.save(1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\'))\n+        obj2.text = "v2 of text"\n+        portal_storage.save(\n+            1, ObjectData(obj2), metadata=self.buildMetadata("saved v2")\n+        )\n \n         # retrieve the state at registration time\n         retrieved_obj = portal_storage.retrieve(history_id=1, selector=0)\n-        self.assertEqual(retrieved_obj.object.object.text, \'v1 of text\')\n-        self.assertEqual(self.getComment(retrieved_obj), \'saved v1\')\n+        self.assertEqual(retrieved_obj.object.object.text, "v1 of text")\n+        self.assertEqual(self.getComment(retrieved_obj), "saved v1")\n \n         # just check if first save wasn\'t a double save\n         retrieved_obj = portal_storage.retrieve(history_id=1, selector=1)\n-        self.assertEqual(retrieved_obj.object.object.text, \'v2 of text\')\n-        self.assertEqual(self.getComment(retrieved_obj), \'saved v2\')\n+        self.assertEqual(retrieved_obj.object.object.text, "v2 of text")\n+        self.assertEqual(self.getComment(retrieved_obj), "saved v2")\n \n     def test05_getHistory(self):\n         portal_storage = self.portal.portal_historiesstorage\n \n         obj1 = Dummy()\n-        obj1.text = \'v1 of text\'\n-        portal_storage.register(1, ObjectData(obj1),\n-                                metadata=self.buildMetadata(\'saved v1\'))\n+        obj1.text = "v1 of text"\n+        portal_storage.register(\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n+        )\n \n         obj2 = Dummy()\n-        obj2.text = \'v2 of text\'\n-        portal_storage.save(1, ObjectData(obj2),\n-                            metadata=self.buildMetadata(\'saved v2\'))\n+        obj2.text = "v2 of text"\n+        portal_storage.save(\n+            1, ObjectData(obj2), metadata=self.buildMetadata("saved v2")\n+        )\n \n         obj3 = Dummy()\n-        obj3.text = \'v3 of text\'\n-        portal_storage.save(1, ObjectData(obj3),\n-                            metadata=self.buildMetadata(\'saved v3\'))\n+        obj3.text = "v3 of text"\n+        portal_storage.save(\n+            1, ObjectData(obj3), metadata=self.buildMetadata("saved v3")\n+        )\n \n         history = portal_storage.getHistory(history_id=1)\n         length = len(history)\n \n         # check length\n-        self.assertEquals(length, 3)\n+        self.assertEqual(length, 3)\n \n         # iterating over the history\n         for i, vdata in enumerate(history):\n-            expected_test = \'v%s of text\' % (i+1)\n-            self.assertEquals(vdata.object.object.text, expected_test)\n-            self.assertEquals(history[i].object.object.text, expected_test)\n+            expected_test = "v%s of text" % (i + 1)\n+            self.assertEqual(vdata.object.object.text, expected_test)\n+            self.assertEqual(history[i].object.object.text, expected_test)\n \n-            expected_comment = \'saved v%s\' % (i+1)\n+            expected_comment = "saved v%s" % (i + 1)\n             self.assertEqual(self.getComment(vdata), expected_comment)\n             self.assertEqual(self.getComment(history[i]), expected_comment)\n \n         # accessing the versions\n-        self.assertEquals(history[0].object.object.text, "v1 of text")\n+        self.assertEqual(history[0].object.object.text, "v1 of text")\n         self.assertEqual(self.getComment(history[0]), "saved v1")\n-        self.assertEquals(history[1].object.object.text, "v2 of text")\n+        self.assertEqual(history[1].object.object.text, "v2 of text")\n         self.assertEqual(self.getComment(history[1]), "saved v2")\n-        self.assertEquals(history[2].object.object.text, "v3 of text")\n+        self.assertEqual(history[2].object.object.text, "v3 of text")\n         self.assertEqual(self.getComment(history[2]), "saved v3")\n \n     def test06_checkObjectManagerIntegrity(self):\n@@ -192,10 +200,12 @@ def test06_checkObjectManagerIntegrity(self):\n         om = DummyOM()\n         sub1 = Dummy()\n         sub2 = Dummy()\n-        om._setObject(\'sub1\', sub1)\n-        om._setObject(\'sub2\', sub2)\n+        om._setObject("sub1", sub1)\n+        om._setObject("sub2", sub2)\n         self.assertEqual(len(om.objectIds()), 2)\n-        portal_storage.register(1, ObjectData(om), metadata=self.buildMetadata(\'saved v1\'))\n+        portal_storage.register(\n+            1, ObjectData(om), metadata=self.buildMetadata("saved v1")\n+        )\n         vdata = portal_storage.retrieve(history_id=1, selector=0)\n         retrieved_om = vdata.object\n         self.assertEqual(len(retrieved_om.object.objectIds()), 2)\n@@ -204,42 +214,64 @@ def test07_getModificationDate(self):\n         portal_storage = self.portal.portal_historiesstorage\n         obj = Dummy()\n         v1_modified = obj.modified()\n-        v1 = portal_storage.register(history_id=1, object=ObjectData(obj), metadata=self.buildMetadata(\'saved v1\'))\n+        v1 = portal_storage.register(\n+            history_id=1,\n+            object=ObjectData(obj),\n+            metadata=self.buildMetadata("saved v1"),\n+        )\n \n         self.assertEqual(v1_modified, portal_storage.getModificationDate(history_id=1))\n-        self.assertEqual(v1_modified, portal_storage.getModificationDate(history_id=1, selector=v1))\n+        self.assertEqual(\n+            v1_modified, portal_storage.getModificationDate(history_id=1, selector=v1)\n+        )\n \n-        #storage never gets the same object twice, because the archivist always generates another copy on save,\n-        #which then have a diffrent python id.\n+        # storage never gets the same object twice, because the archivist always generates another copy on save,\n+        # which then have a diffrent python id.\n \n-        #simulate object copy\n+        # simulate object copy\n         notifyModified(obj)\n         obj = Dummy()\n         v2_modified = obj.modified()\n-        v2 = portal_storage.save(history_id=1, object=ObjectData(obj), metadata=self.buildMetadata(\'saved v2\'))\n-        self.assertNotEquals(v1, v2)\n+        v2 = portal_storage.save(\n+            history_id=1,\n+            object=ObjectData(obj),\n+            metadata=self.buildMetadata("saved v2"),\n+        )\n+        self.assertNotEqual(v1, v2)\n         self.assertEqual(v2_modified, portal_storage.getModificationDate(history_id=1))\n-        self.assertEqual(v2_modified, portal_storage.getModificationDate(history_id=1, selector=v2))\n-        self.assertEqual(v1_modified, portal_storage.getModificationDate(history_id=1, selector=v1))\n+        self.assertEqual(\n+            v2_modified, portal_storage.getModificationDate(history_id=1, selector=v2)\n+        )\n+        self.assertEqual(\n+            v1_modified, portal_storage.getModificationDate(history_id=1, selector=v1)\n+        )\n \n     def _setupMinimalHistory(self):\n         portal_storage = self.portal.portal_historiesstorage\n \n         obj1 = Dummy()\n-        obj1.text = \'v1 of text\'\n-        portal_storage.register(1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\'))\n+        obj1.text = "v1 of text"\n+        portal_storage.register(\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n+        )\n \n         obj2 = Dummy()\n-        obj2.text = \'v2 of text\'\n-        portal_storage.save(1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\'))\n+        obj2.text = "v2 of text"\n+        portal_storage.save(\n+            1, ObjectData(obj2), metadata=self.buildMetadata("saved v2")\n+        )\n \n         obj3 = Dummy()\n-        obj3.text = \'v3 of text\'\n-        portal_storage.save(1, ObjectData(obj3), metadata=self.buildMetadata(\'saved v3\'))\n+        obj3.text = "v3 of text"\n+        portal_storage.save(\n+            1, ObjectData(obj3), metadata=self.buildMetadata("saved v3")\n+        )\n \n         obj4 = Dummy()\n-        obj4.text = \'v4 of text\'\n-        portal_storage.save(1, ObjectData(obj4), metadata=self.buildMetadata(\'saved v4\'))\n+        obj4.text = "v4 of text"\n+        portal_storage.save(\n+            1, ObjectData(obj4), metadata=self.buildMetadata("saved v4")\n+        )\n \n     def test08_lengthAfterHavingPurgedAVersion(self):\n         self._setupMinimalHistory()\n@@ -277,17 +309,19 @@ def test09_retrievePurgedVersionsNoPolicyInstalled(self):\n         self.assertEqual(retrieved_obj.object.reason, "purged")\n         self.assertEqual(self.getComment(retrieved_obj), "purged v3")\n \n-        retrieved_obj = portal_storage.retrieve(history_id=1, selector=2,\n-                                                substitute=False)\n+        retrieved_obj = portal_storage.retrieve(\n+            history_id=1, selector=2, substitute=False\n+        )\n         self.assertFalse(retrieved_obj.isValid())\n         self.assertEqual(retrieved_obj.object.reason, "purged")\n         self.assertEqual(self.getComment(retrieved_obj), "purged v3")\n \n-        retrieved_obj = portal_storage.retrieve(history_id=1, selector=2,\n-                                                countPurged=False)\n+        retrieved_obj = portal_storage.retrieve(\n+            history_id=1, selector=2, countPurged=False\n+        )\n         self.assertTrue(retrieved_obj.isValid())\n-        self.assertEqual(retrieved_obj.object.object.text, \'v4 of text\')\n-        self.assertEqual(self.getComment(retrieved_obj), \'saved v4\')\n+        self.assertEqual(retrieved_obj.object.object.text, "v4 of text")\n+        self.assertEqual(self.getComment(retrieved_obj), "saved v4")\n \n     def test10_retrievePurgedVersionsWithPolicyInstalled(self):\n         self._setupMinimalHistory()\n@@ -313,28 +347,30 @@ def test10_retrievePurgedVersionsWithPolicyInstalled(self):\n         # ``retrieve`` returns the next older object\n         retrieved_obj = portal_storage.retrieve(history_id=1, selector=1)\n         self.assertTrue(retrieved_obj.isValid())\n-        self.assertEqual(retrieved_obj.object.object.text, \'v1 of text\')\n-        self.assertEqual(self.getComment(retrieved_obj), \'saved v1\')\n+        self.assertEqual(retrieved_obj.object.object.text, "v1 of text")\n+        self.assertEqual(self.getComment(retrieved_obj), "saved v1")\n \n         retrieved_obj = portal_storage.retrieve(history_id=1, selector=2)\n         self.assertTrue(retrieved_obj.isValid())\n-        self.assertEqual(retrieved_obj.object.object.text, \'v1 of text\')\n-        self.assertEqual(self.getComment(retrieved_obj), \'saved v1\')\n+        self.assertEqual(retrieved_obj.object.object.text, "v1 of text")\n+        self.assertEqual(self.getComment(retrieved_obj), "saved v1")\n \n         # ``retrieve`` returns existing object\n         retrieved_obj = portal_storage.retrieve(history_id=1, selector=3)\n         self.assertTrue(retrieved_obj.isValid())\n-        self.assertEqual(retrieved_obj.object.object.text, \'v4 of text\')\n-        self.assertEqual(self.getComment(retrieved_obj), \'saved v4\')\n+        self.assertEqual(retrieved_obj.object.object.text, "v4 of text")\n+        self.assertEqual(self.getComment(retrieved_obj), "saved v4")\n \n         # check with substitute=False: should return the removed info\n-        retrieved_obj = portal_storage.retrieve(history_id=1, selector=1,\n-                                                substitute=False)\n+        retrieved_obj = portal_storage.retrieve(\n+            history_id=1, selector=1, substitute=False\n+        )\n         self.assertFalse(retrieved_obj.isValid())\n         self.assertEqual(retrieved_obj.object.reason, "purged")\n         self.assertEqual(self.getComment(retrieved_obj), "purged v2")\n-        retrieved_obj = portal_storage.retrieve(history_id=1, selector=2,\n-                                                substitute=False)\n+        retrieved_obj = portal_storage.retrieve(\n+            history_id=1, selector=2, substitute=False\n+        )\n         self.assertFalse(retrieved_obj.isValid())\n         self.assertEqual(retrieved_obj.object.reason, "purged")\n         self.assertEqual(self.getComment(retrieved_obj), "purged v3")\n@@ -347,106 +383,121 @@ def test11_purgeOnSave(self):\n \n         # save no 1\n         obj1 = Dummy()\n-        obj1.text = \'v1 of text\'\n+        obj1.text = "v1 of text"\n \n-        sel = portal_storage.register(1, ObjectData(obj1),\n-                                      metadata=self.buildMetadata(\'saved v1\'))\n+        sel = portal_storage.register(\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n+        )\n         history = portal_storage.getHistory(1, countPurged=False)\n \n-        self.assertEquals(sel, 0)\n-        self.assertEquals(len(history), 1)\n-        self.assertEqual(history[0].object.object.text, \'v1 of text\')\n-        self.assertEqual(self.getComment(history[0]), \'saved v1\')\n+        self.assertEqual(sel, 0)\n+        self.assertEqual(len(history), 1)\n+        self.assertEqual(history[0].object.object.text, "v1 of text")\n+        self.assertEqual(self.getComment(history[0]), "saved v1")\n \n         # save no 2\n         obj2 = Dummy()\n-        obj2.text = \'v2 of text\'\n-        sel = portal_storage.save(1, ObjectData(obj2),\n-                                  metadata=self.buildMetadata(\'saved v2\'))\n+        obj2.text = "v2 of text"\n+        sel = portal_storage.save(\n+            1, ObjectData(obj2), metadata=self.buildMetadata("saved v2")\n+        )\n         history = portal_storage.getHistory(1, countPurged=False)\n \n-        self.assertEquals(sel, 1)\n-        self.assertEquals(len(history), 2)\n-        self.assertEqual(history[0].object.object.text, \'v1 of text\')\n-        self.assertEqual(self.getComment(history[0]), \'saved v1\')\n-        self.assertEqual(history[1].object.object.text, \'v2 of text\')\n-        self.assertEqual(self.getComment(history[1]), \'saved v2\')\n+        self.assertEqual(sel, 1)\n+        self.assertEqual(len(history), 2)\n+        self.assertEqual(history[0].object.object.text, "v1 of text")\n+        self.assertEqual(self.getComment(history[0]), "saved v1")\n+        self.assertEqual(history[1].object.object.text, "v2 of text")\n+        self.assertEqual(self.getComment(history[1]), "saved v2")\n \n         # save no 3: purged oldest version\n         obj3 = Dummy()\n-        obj3.text = \'v3 of text\'\n-        sel = portal_storage.save(1, ObjectData(obj3),\n-                                  metadata=self.buildMetadata(\'saved v3\'))\n+        obj3.text = "v3 of text"\n+        sel = portal_storage.save(\n+            1, ObjectData(obj3), metadata=self.buildMetadata("saved v3")\n+        )\n         history = portal_storage.getHistory(1, countPurged=False)\n         length = len(history)\n \n         # iterating over the history\n         for i, vdata in enumerate(history):\n-            self.assertEquals(vdata.object.object.text,\n-                              \'v%s of text\' % (i+2))\n-            self.assertEqual(self.getComment(vdata),\n-                             \'saved v%s\' % (i+2))\n-\n-        self.assertEquals(sel, 2)\n-        self.assertEquals(length, 2)\n-        self.assertEqual(history[0].object.object.text, \'v2 of text\')\n-        self.assertEqual(self.getComment(history[0]), \'saved v2\')\n-        self.assertEqual(history[1].object.object.text, \'v3 of text\')\n-        self.assertEqual(self.getComment(history[1]), \'saved v3\')\n+            self.assertEqual(vdata.object.object.text, "v%s of text" % (i + 2))\n+            self.assertEqual(self.getComment(vdata), "saved v%s" % (i + 2))\n+\n+        self.assertEqual(sel, 2)\n+        self.assertEqual(length, 2)\n+        self.assertEqual(history[0].object.object.text, "v2 of text")\n+        self.assertEqual(self.getComment(history[0]), "saved v2")\n+        self.assertEqual(history[1].object.object.text, "v3 of text")\n+        self.assertEqual(self.getComment(history[1]), "saved v3")\n \n         # save no 4: purged oldest version\n         obj4 = Dummy()\n-        obj4.text = \'v4 of text\'\n-        sel = portal_storage.save(1, ObjectData(obj4),\n-                                  metadata=self.buildMetadata(\'saved v4\'))\n+        obj4.text = "v4 of text"\n+        sel = portal_storage.save(\n+            1, ObjectData(obj4), metadata=self.buildMetadata("saved v4")\n+        )\n         history = portal_storage.getHistory(1, countPurged=False)\n         length = len(history)\n \n         # iterating over the history\n         for i, vdata in enumerate(history):\n-            self.assertEquals(vdata.object.object.text,\n-                              \'v%s of text\' % (i+3))\n-            self.assertEqual(self.getComment(vdata),\n-                             \'saved v%s\' % (i+3))\n-\n-        self.assertEquals(sel, 3)\n-        self.assertEquals(length, 2)\n-        self.assertEqual(history[0].object.object.text, \'v3 of text\')\n-        self.assertEqual(self.getComment(history[0]), \'saved v3\')\n-        self.assertEqual(history[1].object.object.text, \'v4 of text\')\n-        self.assertEqual(self.getComment(history[1]), \'saved v4\')\n+            self.assertEqual(vdata.object.object.text, "v%s of text" % (i + 3))\n+            self.assertEqual(self.getComment(vdata), "saved v%s" % (i + 3))\n+\n+        self.assertEqual(sel, 3)\n+        self.assertEqual(length, 2)\n+        self.assertEqual(history[0].object.object.text, "v3 of text")\n+        self.assertEqual(self.getComment(history[0]), "saved v3")\n+        self.assertEqual(history[1].object.object.text, "v4 of text")\n+        self.assertEqual(self.getComment(history[1]), "saved v4")\n \n     def test12_retrieveNonExistentVersion(self):\n         portal_storage = self.portal.portal_historiesstorage\n \n         obj1 = Dummy()\n-        obj1.text = \'v1 of text\'\n-        portal_storage.register(1, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\'))\n+        obj1.text = "v1 of text"\n+        portal_storage.register(\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n+        )\n \n         obj2 = Dummy()\n-        obj2.text = \'v2 of text\'\n-        portal_storage.save(1, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\'))\n+        obj2.text = "v2 of text"\n+        portal_storage.save(\n+            1, ObjectData(obj2), metadata=self.buildMetadata("saved v2")\n+        )\n \n         # purge\n         portal_storage.purge(1, 0, metadata=self.buildMetadata("purged v1"))\n \n         # retrieve non existing version\n-        self.assertRaises(StorageRetrieveError,\n-                          portal_storage.retrieve, history_id=1, selector=2,\n-                          countPurged=True, substitute=True)\n-\n-        self.assertRaises(StorageRetrieveError,\n-                          portal_storage.retrieve, history_id=1, selector=1,\n-                          countPurged=False)\n+        self.assertRaises(\n+            StorageRetrieveError,\n+            portal_storage.retrieve,\n+            history_id=1,\n+            selector=2,\n+            countPurged=True,\n+            substitute=True,\n+        )\n+\n+        self.assertRaises(\n+            StorageRetrieveError,\n+            portal_storage.retrieve,\n+            history_id=1,\n+            selector=1,\n+            countPurged=False,\n+        )\n \n     def test13_saveWithUnicodeComment(self):\n         portal_storage = self.portal.portal_historiesstorage\n         obj1 = Dummy()\n-        obj1.text = \'v1 of text\'\n-        portal_storage.register(1, ObjectData(obj1),\n-                                metadata=self.buildMetadata(\'saved v1\'))\n-        portal_storage.save(1, ObjectData(obj1),\n-                            metadata=self.buildMetadata(u\'saved v1\\xc3\\xa1\'))\n+        obj1.text = "v1 of text"\n+        portal_storage.register(\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n+        )\n+        portal_storage.save(\n+            1, ObjectData(obj1), metadata=self.buildMetadata("saved v1\\xc3\\xa1")\n+        )\n \n     def test14_getHistoryMetadata(self):\n         portal_storage = self.portal.portal_historiesstorage\n@@ -455,159 +506,190 @@ def test14_getHistoryMetadata(self):\n         self.assertEqual(len(history), 4)\n \n         # accessing the versions\n-        self.assertEqual(history.retrieve(0)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v1")\n-        self.assertEqual(history.retrieve(1)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v2")\n-        self.assertEqual(history.retrieve(2)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v3")\n-        self.assertEqual(history.retrieve(3)[\'metadata\'][\'sys_metadata\'][\'comment\'], "saved v4")\n+        self.assertEqual(\n+            history.retrieve(0)["metadata"]["sys_metadata"]["comment"], "saved v1"\n+        )\n+        self.assertEqual(\n+            history.retrieve(1)["metadata"]["sys_metadata"]["comment"], "saved v2"\n+        )\n+        self.assertEqual(\n+            history.retrieve(2)["metadata"]["sys_metadata"]["comment"], "saved v3"\n+        )\n+        self.assertEqual(\n+            history.retrieve(3)["metadata"]["sys_metadata"]["comment"], "saved v4"\n+        )\n \n     def test15_storageStatistics(self):\n         self.maxDiff = None\n         portal_storage = self.portal.portal_historiesstorage\n \n         cmf_uid = 1\n-        obj1 = CMFDummy(\'obj\', cmf_uid)\n-        obj1.text = \'v1 of text\'\n-        portal_storage.register(cmf_uid, ObjectData(obj1), metadata=self.buildMetadata(\'saved v1\'))\n+        obj1 = CMFDummy("obj", cmf_uid)\n+        obj1.text = "v1 of text"\n+        portal_storage.register(\n+            cmf_uid, ObjectData(obj1), metadata=self.buildMetadata("saved v1")\n+        )\n \n-        obj2 = CMFDummy(\'obj\', cmf_uid)\n-        obj2.text = \'v2 of text\'\n-        portal_storage.save(cmf_uid, ObjectData(obj2), metadata=self.buildMetadata(\'saved v2\'))\n+        obj2 = CMFDummy("obj", cmf_uid)\n+        obj2.text = "v2 of text"\n+        portal_storage.save(\n+            cmf_uid, ObjectData(obj2), metadata=self.buildMetadata("saved v2")\n+        )\n \n-        obj3 = CMFDummy(\'obj\', cmf_uid)\n-        obj3.text = \'v3 of text\'\n-        portal_storage.save(cmf_uid, ObjectData(obj3), metadata=self.buildMetadata(\'saved v3\'))\n+        obj3 = CMFDummy("obj", cmf_uid)\n+        obj3.text = "v3 of text"\n+        portal_storage.save(\n+            cmf_uid, ObjectData(obj3), metadata=self.buildMetadata("saved v3")\n+        )\n \n-        obj4 = CMFDummy(\'obj\', cmf_uid)\n-        obj4.text = \'v4 of text\'\n-        self.portal._setObject(\'obj\', obj4)\n+        obj4 = CMFDummy("obj", cmf_uid)\n+        obj4.text = "v4 of text"\n+        self.portal._setObject("obj", obj4)\n         self.portal.portal_catalog.indexObject(self.portal.obj)\n-        portal_storage.save(cmf_uid, ObjectData(obj4), metadata=self.buildMetadata(\'saved v4\'))\n+        portal_storage.save(\n+            cmf_uid, ObjectData(obj4), metadata=self.buildMetadata("saved v4")\n+        )\n \n         cmf_uid = 2\n         tomorrow = DateTime() + 1\n-        obj5 = CMFDummy(\'tomorrow\', cmf_uid, effective=tomorrow)\n-        obj5.allowedRolesAndUsers = [\'Anonymous\']\n-        self.portal._setObject(\'tomorrow\', obj5)\n+        obj5 = CMFDummy("tomorrow", cmf_uid, effective=tomorrow)\n+        obj5.allowedRolesAndUsers = ["Anonymous"]\n+        self.portal._setObject("tomorrow", obj5)\n         self.portal.portal_catalog.indexObject(self.portal.tomorrow)\n-        portal_storage.register(cmf_uid, ObjectData(obj5), metadata=self.buildMetadata(\'effective tomorrow\'))\n+        portal_storage.register(\n+            cmf_uid, ObjectData(obj5), metadata=self.buildMetadata("effective tomorrow")\n+        )\n \n         cmf_uid = 3\n         yesterday = DateTime() - 1\n-        obj6 = CMFDummy(\'yesterday\', cmf_uid, expires=yesterday)\n-        obj6.allowedRolesAndUsers = [\'Anonymous\']\n-        self.portal._setObject(\'yesterday\', obj6)\n+        obj6 = CMFDummy("yesterday", cmf_uid, expires=yesterday)\n+        obj6.allowedRolesAndUsers = ["Anonymous"]\n+        self.portal._setObject("yesterday", obj6)\n         self.portal.portal_catalog.indexObject(self.portal.yesterday)\n-        portal_storage.register(cmf_uid, ObjectData(obj6), metadata=self.buildMetadata(\'expired yesterday\'))\n+        portal_storage.register(\n+            cmf_uid, ObjectData(obj6), metadata=self.buildMetadata("expired yesterday")\n+        )\n \n         cmf_uid = 4\n-        obj7 = CMFDummy(\'public\', cmf_uid)\n-        obj7.text = \'visible for everyone\'\n-        obj7.allowedRolesAndUsers = [\'Anonymous\']\n-        self.portal._setObject(\'public\', obj7)\n+        obj7 = CMFDummy("public", cmf_uid)\n+        obj7.text = "visible for everyone"\n+        obj7.allowedRolesAndUsers = ["Anonymous"]\n+        self.portal._setObject("public", obj7)\n         self.portal.portal_catalog.indexObject(self.portal.public)\n-        portal_storage.register(cmf_uid, ObjectData(obj7), metadata=self.buildMetadata(\'saved public\'))\n+        portal_storage.register(\n+            cmf_uid, ObjectData(obj7), metadata=self.buildMetadata("saved public")\n+        )\n \n         processQueue()\n         got = portal_storage.zmi_getStorageStatistics()\n-        expected = {\'deleted\': [],\n-                    \'summaries\': {\n-                        \'totalHistories\': 4,\n-                        \'deletedVersions\': 0,\n-                        \'existingVersions\': 7,\n-                        \'deletedHistories\': 0,\n-                        # time may easily be different\n-                        # \'time\': \'0.00\',\n-                        \'totalVersions\': 7,\n-                        \'existingAverage\': \'1.8\',\n-                        \'existingHistories\': 4,\n-                        \'deletedAverage\': \'n/a\',\n-                        \'totalAverage\': \'1.8\'},\n-                    \'existing\': [\n-                        {\n-                            \'url\': \'http://nohost/plone/obj\',\n-                            \'history_id\': 1,\n-                            \'length\': 4,\n-                            \'path\': \'/obj\',\n-                            \'sizeState\': \'approximate\',\n-                            \'portal_type\': \'Dummy\',\n-                        }, {\n-                            \'url\': \'http://nohost/plone/tomorrow\',\n-                            \'history_id\': 2,\n-                            \'length\': 1,\n-                            \'path\': \'/tomorrow\',\n-                            \'sizeState\': \'approximate\',\n-                            \'portal_type\': \'Dummy\',\n-                        }, {\n-                            \'url\': \'http://nohost/plone/yesterday\',\n-                            \'history_id\': 3,\n-                            \'length\': 1,\n-                            \'path\': \'/yesterday\',\n-                            \'sizeState\': \'approximate\',\n-                            \'portal_type\': \'Dummy\',\n-                        }, {\n-                            \'url\': \'http://nohost/plone/public\',\n-                            \'history_id\': 4,\n-                            \'length\': 1,\n-                            \'path\': \'/public\',\n-                            \'sizeState\': \'approximate\',\n-                            \'portal_type\': \'Dummy\',\n-                        }]}\n-        self.assertEqual(expected[\'deleted\'], got[\'deleted\'])\n-        self.assertTrue(\'summaries\' in got)\n-        self.assertTrue(\'time\' in got[\'summaries\'])\n-        for key, value in expected[\'summaries\'].items():\n-            self.assertEqual(value, got[\'summaries\'][key])\n-        self.assertEqual(len(expected[\'existing\']), len(got[\'existing\']))\n-        for idx in range(len(expected[\'existing\'])):\n-            exp = expected[\'existing\'][idx]\n-            actual = got[\'existing\'][idx]\n+        expected = {\n+            "deleted": [],\n+            "summaries": {\n+                "totalHistories": 4,\n+                "deletedVersions": 0,\n+                "existingVersions": 7,\n+                "deletedHistories": 0,\n+                # time may easily be different\n+                # \'time\': \'0.00\',\n+                "totalVersions": 7,\n+                "existingAverage": "1.8",\n+                "existingHistories": 4,\n+                "deletedAverage": "n/a",\n+                "totalAverage": "1.8",\n+            },\n+            "existing": [\n+                {\n+                    "url": "http://nohost/plone/obj",\n+                    "history_id": 1,\n+                    "length": 4,\n+                    "path": "/obj",\n+                    "sizeState": "approximate",\n+                    "portal_type": "Dummy",\n+                },\n+                {\n+                    "url": "http://nohost/plone/tomorrow",\n+                    "history_id": 2,\n+                    "length": 1,\n+                    "path": "/tomorrow",\n+                    "sizeState": "approximate",\n+                    "portal_type": "Dummy",\n+                },\n+                {\n+                    "url": "http://nohost/plone/yesterday",\n+                    "history_id": 3,\n+                    "length": 1,\n+                    "path": "/yesterday",\n+                    "sizeState": "approximate",\n+                    "portal_type": "Dummy",\n+                },\n+                {\n+                    "url": "http://nohost/plone/public",\n+                    "history_id": 4,\n+                    "length": 1,\n+                    "path": "/public",\n+                    "sizeState": "approximate",\n+                    "portal_type": "Dummy",\n+                },\n+            ],\n+        }\n+        self.assertEqual(expected["deleted"], got["deleted"])\n+        self.assertTrue("summaries" in got)\n+        self.assertTrue("time" in got["summaries"])\n+        for key, value in expected["summaries"].items():\n+            self.assertEqual(value, got["summaries"][key])\n+        self.assertEqual(len(expected["existing"]), len(got["existing"]))\n+        for idx in range(len(expected["existing"])):\n+            exp = expected["existing"][idx]\n+            actual = got["existing"][idx]\n             for key, value in exp.items():\n                 self.assertEqual(actual[key], value)\n             # The actual size is not important and we want robust tests,\n             # s. https://github.com/plone/Products.CMFEditions/issues/31\n-            self.assertTrue(actual[\'size\'] > 0)\n+            self.assertTrue(actual["size"] > 0)\n \n     def test16_delete_history_on_content_deletion(self):\n-        """ If a content item gets deleted, delete it\'s history\n+        """If a content item gets deleted, delete it\'s history\n         as well\n         """\n         portal_hidhandler = self.portal.portal_historyidhandler\n         portal_storage = self.portal.portal_historiesstorage\n-        self.portal.invokeFactory(\'Document\', \'doc\')\n-        self.portal.invokeFactory(\'Link\', \'link\')\n-        self.portal.invokeFactory(\'Folder\', \'folder\')\n+        self.portal.invokeFactory("Document", "doc")\n+        self.portal.invokeFactory("Link", "link")\n+        self.portal.invokeFactory("Folder", "folder")\n         # the event subscriber should be able to handle unversioned content\n-        self.portal.invokeFactory(\'Document\', \'unversioned_doc\')\n+        self.portal.invokeFactory("Document", "unversioned_doc")\n         doc = self.portal.doc\n         doc_histid = portal_hidhandler.register(doc)\n         portal_storage.register(\n-            doc_histid, ObjectData(aq_base(doc)),\n-            metadata=self.buildMetadata(\'initial\'))\n+            doc_histid, ObjectData(aq_base(doc)), metadata=self.buildMetadata("initial")\n+        )\n         portal_storage.save(\n-            doc_histid,\n-            ObjectData(aq_base(doc)),\n-            metadata=self.buildMetadata(\'v2\'))\n+            doc_histid, ObjectData(aq_base(doc)), metadata=self.buildMetadata("v2")\n+        )\n         link = self.portal.link\n         link_histid = portal_hidhandler.register(link)\n         portal_storage.register(\n-            link_histid, ObjectData(aq_base(link)),\n-            metadata=self.buildMetadata(\'initial\'))\n+            link_histid,\n+            ObjectData(aq_base(link)),\n+            metadata=self.buildMetadata("initial"),\n+        )\n         folder = self.portal.folder\n         folder_histid = portal_hidhandler.register(folder)\n         portal_storage.register(\n-            folder_histid, ObjectData(aq_base(folder)),\n-            metadata=self.buildMetadata(\'first draft\'))\n+            folder_histid,\n+            ObjectData(aq_base(folder)),\n+            metadata=self.buildMetadata("first draft"),\n+        )\n         dochist = portal_storage.retrieve(doc_histid).object\n         doctype = dochist.object.portal_type\n-        self.assertEqual(\'Document\', doctype)\n+        self.assertEqual("Document", doctype)\n         linkhist = portal_storage.retrieve(link_histid).object\n         linktype = linkhist.object.portal_type\n-        self.assertEqual(\'Link\', linktype)\n+        self.assertEqual("Link", linktype)\n         folderhist = portal_storage.retrieve(folder_histid).object\n         foldertype = folderhist.object.portal_type\n-        self.assertEqual(\'Folder\', foldertype)\n-        self.portal.manage_delObjects(\n-            ids=[\'doc\', \'link\', \'folder\', \'unversioned_doc\'])\n+        self.assertEqual("Folder", foldertype)\n+        self.portal.manage_delObjects(ids=["doc", "link", "folder", "unversioned_doc"])\n         removed_doc = portal_storage.retrieve(history_id=doc_histid)\n         self.assertTrue(type(removed_doc.object) == Removed)\n         removed_link = portal_storage.retrieve(history_id=link_histid)\n@@ -617,18 +699,15 @@ def test16_delete_history_on_content_deletion(self):\n \n \n class TestMemoryStorage(TestZVCStorageTool):\n-\n     def installStorageTool(self):\n         # install the memory storage\n         tool = MemoryStorage()\n         setattr(self.portal, tool.getId(), tool)\n \n     def test15_storageStatistics(self):\n-        """ MemoryStorage does not implement zmi_getStorageStatistics\n-        """\n+        """MemoryStorage does not implement zmi_getStorageStatistics"""\n         pass\n \n     def test16_delete_history_on_content_deletion(self):\n-        """ MemoryStorage does not implement _getZVCRepo\n-        """\n+        """MemoryStorage does not implement _getZVCRepo"""\n         pass\ndiff --git a/Products/CMFEditions/tests/test_doctests.py b/Products/CMFEditions/tests/test_doctests.py\nindex 2f361fb..203d262 100644\n--- a/Products/CMFEditions/tests/test_doctests.py\n+++ b/Products/CMFEditions/tests/test_doctests.py\n@@ -1,11 +1,11 @@\n-# -*- coding: utf-8 -*-\n import doctest\n import unittest\n \n \n # These two classes are needed in the doctest. Don\'t remove it\n-class DummyFile(object):\n+class DummyFile:\n     """A sized object"""\n+\n     def __init__(self, size):\n         self.size = size\n \n@@ -13,7 +13,7 @@ def getSize(self):\n         return self.size\n \n \n-class DummyContent(object):\n+class DummyContent:\n     """An object with annotations"""\n \n     def __init__(self, obid):\n@@ -23,5 +23,5 @@ def __init__(self, obid):\n \n def test_suite():\n     suite = unittest.TestSuite()\n-    suite.addTest(doctest.DocFileSuite(\'large_file_modifiers.rst\'))\n+    suite.addTest(doctest.DocFileSuite("large_file_modifiers.rst"))\n     return suite\ndiff --git a/Products/CMFEditions/tests/test_versions_history_form.py b/Products/CMFEditions/tests/test_versions_history_form.py\nindex eda9a6a..08f5b06 100644\n--- a/Products/CMFEditions/tests/test_versions_history_form.py\n+++ b/Products/CMFEditions/tests/test_versions_history_form.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # Reflab (Vincenzo Di Somma, Francesco Ciriaci, Riccardo Lemmi)\n@@ -30,37 +29,33 @@\n from zope.publisher.interfaces.browser import IBrowserView\n \n \n-_TEXT_INITIAL = u\'Initial text.\'\n-_TEXT_NEW = u\'New text.\'\n+_TEXT_INITIAL = "Initial text."\n+_TEXT_NEW = "New text."\n \n \n class TestVersionsHistoryForm(CMFEditionsBaseTestCase):\n-\n     def setUp(self):\n-        super(TestVersionsHistoryForm, self).setUp()\n+        super().setUp()\n         self.portal_repository = self.portal.portal_repository\n         self.portal.invokeFactory(\n-            \'Document\',\n-            \'doc\',\n-            title=\'Document 1\',\n-            text=RichTextValue(_TEXT_INITIAL, \'text/plain\', \'text/plain\'),\n+            "Document",\n+            "doc",\n+            title="Document 1",\n+            text=RichTextValue(_TEXT_INITIAL, "text/plain", "text/plain"),\n         )\n         self.doc = self.portal.doc\n-        self.portal_repository.applyVersionControl(\n-            self.doc,\n-            comment=\'save version 0\'\n-        )\n+        self.portal_repository.applyVersionControl(self.doc, comment="save version 0")\n         self.request = self.portal.REQUEST\n \n     def test_versions_history_form(self):\n-        self.doc.text = RichTextValue(_TEXT_NEW, \'text/plain\', \'text/plain\')\n-        self.portal_repository.save(self.doc, comment=\'save version 1\')\n+        self.doc.text = RichTextValue(_TEXT_NEW, "text/plain", "text/plain")\n+        self.portal_repository.save(self.doc, comment="save version 1")\n \n-        html = self._render_versions_history_form(item=self.doc, version_id=\'0\')\n+        html = self._render_versions_history_form(item=self.doc, version_id="0")\n         self.assertTrue(_TEXT_INITIAL in html)\n         self.assertFalse(_TEXT_NEW in html)\n \n-        html = self._render_versions_history_form(item=self.doc, version_id=\'1\')\n+        html = self._render_versions_history_form(item=self.doc, version_id="1")\n         self.assertFalse(_TEXT_INITIAL in html)\n         self.assertTrue(_TEXT_NEW in html)\n \n@@ -68,7 +63,7 @@ def test_versions_history_form_custom_version_view(self):\n         """Assert that if we define an @@version-view then it will be used to\n         display the versions.\n         """\n-        dummy_str = \'Blah\'\n+        dummy_str = "Blah"\n \n         class DummyVersionView(BrowserView):\n             def __call__(self):\n@@ -78,13 +73,13 @@ def __call__(self):\n             factory=DummyVersionView,\n             adapts=(Interface, Interface),\n             provides=IBrowserView,\n-            name=\'version-view\',\n+            name="version-view",\n         )\n \n-        html = self._render_versions_history_form(item=self.doc, version_id=\'0\')\n+        html = self._render_versions_history_form(item=self.doc, version_id="0")\n         self.assertTrue(dummy_str in html)\n         self.assertFalse(_TEXT_INITIAL in html)\n \n     def _render_versions_history_form(self, item, version_id):\n-        self.request[\'version_id\'] = version_id\n-        return item.unrestrictedTraverse(\'versions_history_form\')()\n+        self.request["version_id"] = version_id\n+        return item.unrestrictedTraverse("versions_history_form")()\ndiff --git a/Products/CMFEditions/utilities.py b/Products/CMFEditions/utilities.py\nindex dfb1f98..56bad8a 100644\n--- a/Products/CMFEditions/utilities.py\n+++ b/Products/CMFEditions/utilities.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n #########################################################################\n # Copyright (c) 2004, 2005 Alberto Berti, Gregoire Weber.\n # All Rights Reserved.\n@@ -30,11 +29,11 @@\n import random\n \n \n-STUB_OBJECT_PREFIX = \'_CMFEditionsTempId\'\n+STUB_OBJECT_PREFIX = "_CMFEditionsTempId"\n+\n \n class KwAsAttributes(Persistent):\n-    """Class attaching to itself passed keyword attributes.\n-    """\n+    """Class attaching to itself passed keyword attributes."""\n \n     # Not web accessable\n     __roles__ = ()\n@@ -63,7 +62,7 @@ def dereference(obj=None, history_id=None, zodb_hook=None):\n         # try to use the reference as zodb hook\n         zodb_hook = obj\n \n-    portal_uidhandler = getToolByName(zodb_hook, \'portal_historyidhandler\')\n+    portal_uidhandler = getToolByName(zodb_hook, "portal_historyidhandler")\n \n     if history_id is None:\n         if obj is None:\n@@ -80,28 +79,28 @@ def dereference(obj=None, history_id=None, zodb_hook=None):\n     return obj, history_id\n \n \n-def generateId(parent, prefix=\'\', volatile=False):\n-    """Generate an unused id (optionaly a volatile one).\n-    """\n+def generateId(parent, prefix="", volatile=False):\n+    """Generate an unused id (optionaly a volatile one)."""\n     existingIds = parent.objectIds()\n-    idTemplate = \'%s%s_%%s\' % (volatile * \'__v_\', prefix + STUB_OBJECT_PREFIX)\n+    idTemplate = "{}{}_%s".format(volatile * "__v_", prefix + STUB_OBJECT_PREFIX)\n     while 1:\n-        id =  idTemplate % random.randrange(1000000)\n+        id = idTemplate % random.randrange(1000000)\n         if id not in existingIds:\n             return id\n \n+\n def isObjectVersioned(obj):\n-    """Return true iff object has a version_id.\n-    """\n-    return getattr(aq_base(obj), \'version_id\', None) is not None\n+    """Return true iff object has a version_id."""\n+    return getattr(aq_base(obj), "version_id", None) is not None\n+\n \n def isObjectChanged(obj):\n-    pr = getToolByName(obj, \'portal_repository\', None)\n+    pr = getToolByName(obj, "portal_repository", None)\n     if pr is None:\n         return False\n \n     changed = False\n-    if getattr(aq_base(obj), \'version_id\', None) is None:\n+    if getattr(aq_base(obj), "version_id", None) is None:\n         changed = True\n     else:\n         try:\n@@ -114,8 +113,8 @@ def isObjectChanged(obj):\n     return changed\n \n \n-def maybeSaveVersion(obj, policy=\'at_edit_autoversion\', comment=\'\', force=False):\n-    pr = getToolByName(obj, \'portal_repository\', None)\n+def maybeSaveVersion(obj, policy="at_edit_autoversion", comment="", force=False):\n+    pr = getToolByName(obj, "portal_repository", None)\n     if pr is not None:\n         isVersionable = pr.isVersionable(obj)\n \ndiff --git a/Products/__init__.py b/Products/__init__.py\nindex 85880ef..05f0beb 100644\n--- a/Products/__init__.py\n+++ b/Products/__init__.py\n@@ -1,7 +1,7 @@\n-# -*- coding: utf-8 -*-\n # See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n try:\n-    __import__(\'pkg_resources\').declare_namespace(__name__)\n+    __import__("pkg_resources").declare_namespace(__name__)\n except ImportError:\n     from pkgutil import extend_path\n+\n     __path__ = extend_path(__path__, __name__)\ndiff --git a/README.rst b/README.rst\nindex 13fb7d3..3f2a5bb 100644\n--- a/README.rst\n+++ b/README.rst\n@@ -33,7 +33,6 @@ A content panel allows configuring the versioning policy by content type:\n \n By default the contents of a folder is versioned independently of the folder.\n This may be changed through the ZMI and for specific cases on python level.\n-Basic support for Archetypes references is built in.\n \n The current strategy is to save everything of the content item (incl. security\n information, workflow state, etc.). On retrieve some of these information are\ndiff --git a/doc/old-changelog.rst b/doc/old-changelog.rst\nnew file mode 100644\nindex 0000000..5f5dbfb\n--- /dev/null\n+++ b/doc/old-changelog.rst\n@@ -0,0 +1,1248 @@\n+For changes since 3.0, see CHANGES.rst\n+\n+\n+2.2.23 (2016-12-05)\n+-------------------\n+\n+Bug fixes:\n+\n+- In ShadowStorage\'s `isRegistered` and `getHistory` methods,\n+  avoid checking for a history_id of None in the storage\'s BTree.\n+  This fixes compatibility with BTrees 4.x,\n+  which disallows comparing keys to None.\n+  [davisagli]\n+\n+\n+2.2.22 (2016-11-17)\n+-------------------\n+\n+Bug fixes:\n+\n+- Fix deprecated import from Globals that is changed in Zope4.\n+  [pbauer]\n+\n+- Do not log using plone restricted python logging script.\n+  [jensens]\n+\n+- Adapt tests to the new indexing operations queueing.\n+  Part of PLIP 1343: https://github.com/plone/Products.CMFPlone/issues/1343\n+  [gforcada]\n+\n+2.2.21 (2016-08-18)\n+-------------------\n+\n+Bug fixes:\n+\n+- Use zope.interface decorator.\n+  [gforcada]\n+\n+\n+2.2.20 (2016-04-15)\n+-------------------\n+\n+Fixes:\n+\n+- Fixed CloneBlobs modifier to only react on Archetypes.\n+  This fix allows Dexterity Blob-Types (e.g. File, Image) to be versioned.\n+  [iham]\n+\n+\n+2.2.19 (2016-02-14)\n+-------------------\n+\n+Fixes:\n+\n+- Fixed sometimes failing test.  [maurits]\n+\n+\n+2.2.18 (2015-11-25)\n+-------------------\n+\n+Fixes:\n+\n+- Removed executable bit from various files.  And do a quick release,\n+  as on a test server the previous release was somehow missing a file.\n+  [maurits]\n+\n+\n+2.2.17 (2015-11-25)\n+-------------------\n+\n+Fixes:\n+\n+- Made storage statistics test more robust.\n+  See https://github.com/plone/Products.CMFEditions/issues/31\n+  [tschorr]\n+\n+\n+2.2.16 (2015-09-27)\n+-------------------\n+\n+- Input sanitation for retrieveSubstitute()\n+  [zupo]\n+\n+\n+2.2.15 (2015-09-15)\n+-------------------\n+\n+- use unrestricted search for storage statistics\n+  [tschorr]\n+\n+\n+2.2.14 (2015-08-13)\n+-------------------\n+\n+- Do not call ndiff unless there is no html_diff.  Removed strange\n+  unicode space from template.  Related to\n+  https://github.com/plone/Products.CMFPlone/issues/820\n+  [maurits]\n+\n+\n+2.2.13 (2015-04-26)\n+-------------------\n+\n+- Drop use of python:exists() in templates.\n+  [pbauer]\n+\n+- Replace deprecated JavaScript functions with their jQuery equivalents.\n+  [thet]\n+\n+\n+2.2.12 (2015-03-13)\n+-------------------\n+\n+- Remove dependency on old Archetypes tests\n+  [tomgross]\n+\n+- Ported tests to plone.app.testing\n+  [tomgross]\n+\n+- Removed old FAQ testing code. Should go in a seperate product, if needed.\n+  [tomgross]\n+\n+- Frosted cleanups\n+  [tomgross]\n+\n+2.2.11 (2014-10-23)\n+-------------------\n+\n+- Depend on ZODB3>=3.9.0 for blob support.\n+  [tomgross]\n+\n+- Fix AT tests to work with plone.app.blob plone.app.blob >=1.5.11\n+  [jensens]\n+\n+\n+2.2.10 (2014-09-07)\n+-------------------\n+\n+- Fix #16: Allow developers to define a ``@@version-view`` to customize how a version of an item is\n+  displayed in ``versions_history_form.pt``.\n+  [rafaelbco]\n+\n+- Fix #14: Duplicate functionality in ``@@history`` and ``version_diff.pt``.\n+  Now ``version_diff.pt`` is deprecated.\n+  [rafaelbco]\n+\n+- Fix bug: ``CopyModifyMergeRepositoryTool.manage_setTypePolicies`` method\n+  modifies sequence while iterating over it.\n+  [rafaelbco]\n+\n+- Purging old versions did not properly remove all references\n+  to the blob fields, resulting in old blobs to stay there forever.\n+  [do3cc]\n+\n+2.2.9 (2013-12-07)\n+------------------\n+\n+- Use search_icon.png instead of search_icon.gif in version_image_view.pt.\n+  The page crashed because search_icon.gif couldn\'t be found.\n+  [vincentfretin]\n+\n+- Do not depend on the ``jq`` variable in the history view.\n+  [maurits]\n+\n+2.2.8 (2013-03-05)\n+------------------\n+\n+- Fix modifier check that made AT assumptions about Dexterity\n+  content.\n+  [rpatterson]\n+\n+- Remove hard dependency on Archetypes.\n+  [davisagli]\n+\n+2.2.7 (2013-01-01)\n+------------------\n+\n+- put back the history legend for compare/diff versions, fixes #9371\n+  [maartenkling]\n+\n+- Site administrators do revisioning\n+\n+2.2.6 (2012-10-16)\n+------------------\n+\n+- Update ``IPossibleSite`` import to ``zope.component``.\n+  [elro]\n+\n+2.2.5 (2012-08-11)\n+------------------\n+\n+- Fixed version file preview for empty files.\n+  [thomasdesvenain]\n+\n+- Fixed versions history form:\n+  title and description aren\'t displayed two times.\n+  [thomasdesvenain]\n+\n+- Fixed version file preview:\n+  some displayed values of a previous version were values of current version.\n+  [thomasdesvenain]\n+\n+- ArchivistTool.py, DummyTools.py, IArchivist.py, ModifierRegistryTool.py:\n+  Don\'t use list as default parameter value.\n+  [kleist]\n+\n+\n+2.2.4 (2012-06-27)\n+------------------\n+\n+- Add upgrade step to install the component registry bases modifier.\n+  [rossp]\n+\n+- Skip blob files from plone.namedfile even when they no longer\n+  extend the classes from z3c.blobfile.\n+  [davisagli]\n+\n+- Declare missing dependency on zope.copy.\n+  [hannosch]\n+\n+\n+2.2.3 (2012-01-26)\n+------------------\n+\n+- Changed the get_macros python skin script into a browser view.  This\n+  avoids an Unauthorized exception when viewing revisions when using\n+  five.pt (Chameleon).\n+  [maurits]\n+\n+- Implement a special base modifier that allows retention of specific\n+  annotation elements from the working copy.  Use this in the OM\n+  modifiers to ensure we don\'t stomp annotations for folders on retrieval.\n+  [alecm]\n+\n+- If an object has a component registry (AKA site manager), make sure\n+  the bases of that registry are not recursively copied when saving\n+  versions.\n+  [rossp]\n+\n+2.2.2 (2011-10-17)\n+------------------\n+\n+- Don\'t string convert blobs.  Fixes MemoryErrors or excessive memory\n+  consumption with large blobs.\n+  [rossp]\n+\n+- Protect against anonymous access to KwAsAttributes.\n+  [mj]\n+\n+2.2.1 (2011-09-19)\n+------------------\n+\n+- Merged changes from 2.1.5.\n+  [lentinj]\n+\n+2.2 (2011-08-23)\n+----------------\n+\n+- Make Zope 2 permissions available as Zope 3-style permissions.\n+  [rafaelbco]\n+\n+- Changed ``@@history`` to be protected by ``CMFEditions.AccessPreviousVersions`` instead of\n+  ``cmf.ModifyPortalContent``.\n+  [rafaelbco]\n+\n+- Only show the "Revert to this version" button if the user has the ``Revert to previous versions``\n+  permission in ``versions_history_form``.\n+  [rafaelbco]\n+\n+2.1.5 (2011-09-19)\n+------------------\n+\n+- Translate the commit message, so version id is substituted.\n+  [lentinj]\n+\n+- Only save an initial version before edit when content is not yet versioned,\n+  rather than every time there are unsaved changes. Otherwise there is an\n+  "Initial version" generated for every edit after publish/retract, as these\n+  change the publishing date without a new version being saved. Possibly a\n+  version should be saved on publish, but not sure the extra versioning noise\n+  is useful.\n+  [lentinj]\n+\n+2.1.4 (2011-08-31)\n+------------------\n+\n+- Remove references to blobs when cloning blob fields. They are handled as\n+  referenced attributes anyway. This eliminates the creation of an additional\n+  empty blob when cloning blob fields.\n+  [buchi]\n+\n+- No longer store references in the ZVC wrapper. They are stored in the shadow\n+  history and retrieved from there. This eliminates the creation of an\n+  additional empty blob when cloning blob fields.\n+  [buchi]\n+\n+- Allow to translate the string "current" in the diff view (``@@history``) and in the\n+  ``version_diff`` template.\n+  [rafaelbco]\n+\n+2.1.3 (2011-04-03)\n+------------------\n+\n+- Fixed: Unauthorized error on versions history form for non managers.\n+  [thomasdesvenain]\n+\n+2.1.2 (2011-03-25)\n+------------------\n+\n+- remove UniqueIdHandlerTool, it was not used anymore;\n+  nobody (including vds and hannosch) seems to remember what it was for.\n+  [gotcha]\n+\n+- fix portal_historyidhandler class to avoid issue where GenericSetup toolset\n+  import step tried to change the class default id\n+  [gotcha]\n+\n+- Skip z3c.blobfile File (notable subclasess plone.namedfile BlobFile and\n+  BlobImage) as blobfile versioning is not there yet.\n+  [elro]\n+\n+2.1.1 - 2011-02-25\n+------------------\n+\n+- Fix bug when loading GenericSetup profile with ``<policymap purge="true">``.\n+  [elro]\n+\n+2.1.0 - 2011-02-25\n+------------------\n+\n+- Generic Setup export/import support.\n+  [elro]\n+\n+2.0.5 - 2011-02-25\n+------------------\n+\n+- Workaround some potential issues with event handlers and\n+  transaction.savepoint which can cause exceptions when, for example,\n+  zope.sendmail is used to send mail in the same transaction as saving\n+  an edition.\n+  [rossp]\n+\n+2.0.4 - 2011-01-03\n+------------------\n+\n+- Depend on ``Products.CMFPlone`` instead of ``Plone``.\n+  [elro]\n+\n+- Do not provide "Compare to ... revision" link in versions history actions\n+  if content type has no diffable field.\n+  [thomasdesvenain]\n+\n+- Add Site Administrator role to various permissions, for forward compatibility\n+  with Plone 4.1.\n+  [davisagli]\n+\n+2.0.3 - 2010-11-06\n+------------------\n+\n+- Internationalized default version comments (\'Initial revision\', etc.).\n+  [thomasdesvenain]\n+\n+- Fixed: version comment was not considered when saving a content with\n+  automatic version policy. Closes http://dev.plone.org/plone/ticket/8535.\n+  [thomasdesvenain]\n+\n+- Fixed multiple chameleon incompatibilities.\n+  [swampmonkey]\n+\n+2.0.2 - 2010-09-09\n+------------------\n+\n+- Forward port of a i18n fix from branches/1.2. It\'s used to create a\n+  changeset, the message doesn\'t seem to appear on the history view though.\n+  [vincentfretin]\n+\n+- Added missing i18n markup to variables in ``update_version_before_edit.cpy``.\n+  [WouterVH]\n+\n+2.0.1 - 2010-08-08\n+------------------\n+\n+- Changed "version" to "revision" in portal messages.\n+  [kleist]\n+\n+2.0 - 2010-07-18\n+----------------\n+\n+- Changed the text in the `@@history` page to use the term revision instead of\n+  version. This fixes http://dev.plone.org/plone/ticket/10740.\n+  [hannosch]\n+\n+- Added dependency on plone.app.blob, to pull in the needed bits for\n+  handling blobs in the modifiers.\n+  [davidblewett]\n+\n+- Added event listeners for Archetypes\' ObjectInitializedEvent and\n+  ObjectEditedEvent events (to go along with the existing WebDAV ones).\n+  [davidblewett]\n+\n+- Changed Plone 3 backward compatible handling to also work with Chameleon.\n+  [do3cc]\n+\n+2.0b9 - 2010-06-13\n+------------------\n+\n+- Avoid dependency on zope.app.testing.\n+  [hannosch]\n+\n+2.0b8 - 2010-05-20\n+------------------\n+\n+- Added notification of changes on revert, via zope.lifecycle\'s\n+  ObjectModifiedEvent and Archetypes\' ObjectEditedEvent.\n+  [davidblewett]\n+\n+- Fixed revertversion.py so that it didn\'t tack on a lone / to the redirect\n+  URL.\n+  [davidblewett]\n+\n+- Fixed CloneBlob & company, so that they check that the field provides an\n+  interface instead of using isinstance.\n+  [davidblewett]\n+\n+- Fixed CloneBlob to not trample its local variables, allowing for multiple\n+  blob fields on a type.\n+  [davidblewett]\n+\n+- Updated i18n methods that used mappings.\n+  [davidblewett]\n+\n+2.0b7 - 2010-05-08\n+------------------\n+\n+- Fix BLOB history corruption\n+  http://dev.plone.org/plone/ticket/10503\n+  [do3cc]\n+\n+2.0b6 - 2010-04-20\n+------------------\n+\n+- Widen html diff display to work better with new layout.\n+  [alecm]\n+\n+- Fix issue with versioning of large folders.\n+  http://dev.plone.org/plone/ticket/10457\n+  [alecm]\n+\n+2.0b5 - 2010-04-12\n+------------------\n+\n+- Re-add title and description when viewing old versions in Plone 4.\n+  [davisagli]\n+\n+2.0b4 - 2010-03-04\n+------------------\n+\n+- Reverse order of diff listing on history view. Fixes\n+  http://dev.plone.org/plone/ticket/10119.\n+  [alecm]\n+\n+- Fix version display when history is non-existent. Fixes\n+  http://dev.plone.org/plone/ticket/9674.\n+  [alecm]\n+\n+2.0b3 - 2010-02-17\n+------------------\n+\n+- Updated templates to follow recent markup conventions.\n+  References http://dev.plone.org/old/plone/ticket/9981.\n+  [spliter]\n+\n+- Be more defensive in our importVarious step, to avoid issues while upgrading.\n+  [hannosch]\n+\n+- Workaround for http//dev.plone.org/plone/ticket/10120, "version_history_form"\n+  now renders "Preview is not available." instead of causing a traceback.\n+  [kleist]\n+\n+2.0b2 - 2009-12-27\n+------------------\n+\n+- Fixed test dependencies and removed unused test helper code.\n+  [hannosch]\n+\n+2.0b1 - 2009-12-02\n+------------------\n+\n+- Fix dependence on global_defines in diff.pt.\n+  https://dev.plone.org/plone/ticket/9804\n+  [alecm]\n+\n+2.0a1 - 2009-11-14\n+------------------\n+\n+- Fix ordering issues with versioned BTree folders.\n+  [alecm]\n+\n+- Make the Archetypes dependency a soft one.\n+  [alecm]\n+\n+- Only make a copy of a BLOB if it\'s changed since the last save.\n+  Otherwise, just reference the BLOB from the prior revision.\n+  [alecm]\n+\n+- Made the ZVCStorage store references directly in the shadow instead\n+  of simply passing them to ZVC.  This way real references can be used\n+  in the storage instead of copies, so that BLOB revisions can work.\n+  [alecm]\n+\n+- Add modifiers to handle AT blob fields from plone.app.blob.  One\n+  handler skips the blobs and the other copies them.\n+  [alecm]\n+\n+- Enable both inside and outside children modifiers by default for\n+  folder objects.  Using the INonStructuralFolder interface to determine\n+  which to use.\n+  [alecm]\n+\n+- Fixes for reference handling in plone.folder and other BTree based folder implementations.\n+  [alecm]\n+\n+- Added modifier that skips cloning of __parent__ pointers.\n+  [alecm]\n+\n+- Switched document_byline macro to plone.belowcontenttitle content provider.\n+  [hannosch]\n+\n+- Acquire plone_utils from context rather than assuming the putils global in\n+  templates.\n+  [erikrose]\n+\n+- Fixed tests which depended on specific uids for portal content.\n+  Added cmf_uid catalog index in install profile.\n+  [alecm]\n+\n+- Fixed missing i18n markup in versions_history_form.\n+  [hannosch]\n+\n+- No longer rely on base_properties.\n+  [hannosch]\n+\n+- Made some calls to portal_repository more defensive.\n+  [hannosch]\n+\n+- Added the z3c.autoinclude entry point so this package is automatically loaded\n+  on Plone 3.3 and above.\n+  [hannosch]\n+\n+- Use new import location for the package_home function.\n+  [hannosch]\n+\n+- Added the required profile bits for installing CMFUid.\n+  [hannosch]\n+\n+- Define dependency on Products.ZopeVersionControl.\n+  [hannosch]\n+\n+- Define dependency on CMFDiffTool (via template using portal_diff) and\n+  avoiding a test dependency on CMFDefault.\n+  [hannosch]\n+\n+- Define here_url in all templates and made get_macros not fail when\n+  encountering a browser view based template.\n+  [hannosch]\n+\n+- Cleaned up package metadata and code to remove the dependency on Plone.\n+  [hannosch]\n+\n+- Declare package dependencies and fixed deprecation warnings for use\n+  of Globals.\n+  [hannosch]\n+\n+- Catch WebDAVObjectInitializedEvent/WebDAVObjectEditedEvent and\n+  save versions as appropriate. This is part of the fix for\n+  http://dev.plone.org/plone/ticket/7338\n+  [sidnei]\n+\n+- Fixed the name of the file : is has to be the FileName not the Id [tbenita]\n+\n+- Purged old Zope 2 Interface interfaces for Zope 2.12 compatibility.\n+  [elro]\n+\n+- Fixed a bug in the file_download_version that prevented successful download\n+  of anterior version of files if the filename contained spaces. Anyway, the\n+  filename param of Content-Disposition header SHOULD NEVER come without\n+  double-quotes.\n+  [drjnut]\n+\n+- Register GenericSetup steps via ZCML.\n+  [wichert]\n+\n+- Use the new archetypes.edit.afterfieldsets viewlet manager to add our\n+  field to the AT edit template. The customized edit_macros is now no longer\n+  needed.\n+  [wichert]\n+\n+1.2.7 - Unreleased\n+------------------\n+\n+- Fix error in history storage selector calculation. Closes\n+  http://dev.plone.org/plone/ticket/8967.\n+  [alecm]\n+\n+- Make "Revert to this version" on the versions_history_form an input\n+  with HTTP POST, instead of a simple GET link.\n+  Fixes http://dev.plone.org/plone/ticket/6932\n+  [maurits]\n+\n+1.2.6 - December 2, 2009\n+------------------------\n+\n+- Check history permissions in the context of the versioned object not\n+  the repository tool.  See http://plone.org/products/cmfeditions/issues/55\n+  [alecm]\n+\n+- Fixed the html and javascript on the difference view so it works on\n+  more browsers.\n+  [vpretre, maurits]\n+\n+\n+1.2.5 - November 5, 2009\n+------------------------\n+\n+- Show ndiff (natural diff) when neither inline diff nor html diff are\n+  available.\n+  [maurits]\n+\n+\n+1.2.4 - July 4, 2009\n+--------------------\n+\n+- Fixed missing i18n markup in versions_history_form.\n+  [hannosch]\n+\n+\n+1.2.3 - July 4, 2009\n+--------------------\n+\n+- Fix form action in @@history view.\n+  [vincentfretin]\n+\n+\n+1.2.2 - June 11, 2009\n+---------------------\n+\n+- Fix XHTML markup for diff view.\n+  See ticket http://dev.plone.org/plone/ticket/9227\n+  [alecm]\n+\n+1.2.1 - June 8, 2009\n+--------------------\n+\n+- Add getHistoryMetadata method to allow efficient history display\n+  without full object retrieval.  Based on patches by Darryl Dixon on\n+  CMFEditions zvc_enfold_fixfailures branch r59908:60078.\n+  [alecm]\n+\n+\n+1.2 - May 16, 2009\n+------------------\n+\n+- Add missing PACKAGE_HOME in the init file according to tests\n+  [encolpe]\n+\n+- Add the encoding declaration (utf-8) in all python files\n+  [encolpe]\n+\n+- Internationalization of 7 strings in diff.pt (history view).\n+  [vincentfretin]\n+\n+- Fixed label_history_version msgid dynamic content in diff.pt (added i18n:name="version")\n+  [vincentfretin]\n+\n+\n+1.2b1 (March 7, 2009)\n+---------------------\n+\n+- Register CMF skin layers via ZCML.\n+  [wichert]\n+\n+- Remove history action. Plone 3.3 has alternative implementations in the\n+  form of the content history viewlet so this should not be installed by\n+  default.\n+  [wichert]\n+\n+- Move import step registration to ZCML.\n+  [wichert]\n+\n+- Use the new archetypes.edit.afterfieldsets viewlet manager to add our\n+  field to the AT edit template. The customized edit_macros is now no longer\n+  needed.\n+  [wichert]\n+\n+- Some CMFEditions .py files use wrong MessageFactory (#8715)\n+  [encolpe]\n+\n+- Set some msgids to cmfeditions i18n domain in version_file_view.\n+  Renamed msgid label_existing_keywords by label_existing_categories in\n+  version_metadata_view.\n+  [vincentfretin]\n+\n+\n+1.1.8 (October 6, 2008)\n+-----------------------\n+\n+- Switch to egg-based distribution.\n+  [hannosch]\n+\n+- Fix on FileDownloadVersion : files retrieved didn\'t get their version name\n+  [tbenita]\n+\n+- Fix on FileDownloadVersion : files retrieved got corrupted at retrieval\n+  [drjnut]\n+\n+- Merge AT changes into replacement of \'edit_macros.pt\'.\n+  See ticket http://dev.plone.org/plone/ticket/7999.\n+  [rsantos]\n+\n+\n+1.1.7 (June 2, 2008)\n+--------------------\n+\n+- Fix for issues with unicode version save comments.\n+  http://dev.plone.org/plone/ticket/7400\n+  [alecm]\n+\n+\n+1.1.6 (March 26, 2008)\n+----------------------\n+\n+- Some i18n fixes to version_diff.pt. This closes\n+  http://dev.plone.org/plone/ticket/7862.\n+  [hannosch]\n+\n+- Merge AT changes into our copy of \'edit_macros.pt\'.\n+  See: http://dev.plone.org/plone/ticket/6936\n+\n+\n+1.1.5 (March 8, 2008)\n+---------------------\n+\n+- Fix bug in wrapper assignment for some modifiers.\n+  [encolpe, alecm]\n+\n+- Added metadata.xml file to the profile.\n+  [hannosch]\n+\n+\n+1.1.4 (December 6, 2007)\n+------------------------\n+\n+- Add modifiers to avoid pickling extremely large files.  The\n+  AbortVersioningOfLargeFilesAndImages modifier is enabled by default\n+  for Files and Images. It will skip saving versions of objects when\n+  they contain a large file (\'file\' or \'image\' field in Attribute or\n+  AnnotationStorage).  The SkipVersioningOfLargeFilesAndImages will\n+  simply not version the large file, but will version all other data.\n+  On retrieval it will put the file from the working copy in place.\n+  This is disabled by default, but can be enabled easily.\n+  Workaround for: http://dev.plone.org/plone/ticket/7223\n+  [alecm]\n+\n+\n+1.1.3 (December 2, 2007)\n+------------------------\n+\n+- Make sure that we attempt to handle Inside Refs which have no\n+  portal_type, as well as retrieving revisions that once used the\n+  InsideRefsModifier but now use the OutsideRefsModifier.\n+  Related to: http://dev.plone.org/plone/ticket/7295\n+  [alecm]\n+\n+- Fix issue on diff form where empty entries were being shown for\n+  unchanged files.  Related to http://dev.plone.org/plone/ticket/7253\n+  [alecm]\n+\n+- Fix issues with purge policy as reported in\n+  http://dev.plone.org/plone/ticket/7300\n+  [alecm]\n+\n+- Handle ArchivistUnregisteredErrors during save.  This occurs when an\n+  object has been imported, or when the version information has been\n+  destroyed.  Fixes http://dev.plone.org/plone/ticket/7334.\n+  [alecm]\n+\n+- Reflect changes in base_edit.cpt asnd edit_macros.pt in r8683 of\n+  Archetypes: Skip the \'metadata\' schema in base_edit, like we used to\n+  do it pre-1.5.  Also, do not render fieldset and legend elements\n+  when we\'re only displaying one fieldset, i.e. the \'default\' one.\n+  [nouri]\n+\n+\n+1.1.2 (October 5, 2007)\n+-----------------------\n+\n+- Added bits of missing i18n markup to versions_history_form.pt. This closes\n+  http://dev.plone.org/plone/ticket/7065.\n+  [hannosch, naro]\n+\n+- Added CMFEditionsMessageFactory and used it to i18n-ize a statusmessages in\n+  revertversion.py. This closes http://dev.plone.org/plone/ticket/7066.\n+  [hannosch, naro]\n+\n+\n+1.1.1 (September 10, 2007)\n+--------------------------\n+\n+- Expose the extra_top, widgets and extra_bottom METAL hooks in edit_macros.\n+  [wichert]\n+\n+\n+1.1-final (August 16, 2007)\n+---------------------------\n+\n+- Prevent future off by one errors in the ui by just starting our count from 0.\n+  [alecm]\n+\n+- Fix dumb acquisition issue in the default policy scripts.\n+  [alecm]\n+\n+- Removed overly aggressive logging from update_version_before_edit.cpy.\n+  [hannosch]\n+\n+\n+1.1-rc1 (July 8, 2007)\n+----------------------\n+\n+- Make text more consistent (use revision instead of version throughout the ui)\n+\n+- Add checks in versioning policy scripts to ensure we don\'t get duplicate\n+  revisions.\n+\n+- Add controller overrides so that the correct actions happen on\n+  cancel and reference upload.\n+\n+- Add an event listener that removes the `version_id` attribute from\n+  copies.\n+\n+- Removed i18n folder. Translations are shipped in PloneTranslations. [hannosch]\n+\n+- Minor template corrections. [hannosch]\n+\n+\n+1.1-beta4 (April 30, 2007)\n+--------------------------\n+\n+- Updated permission mapping to account for new local roles (Editor/Contributor)\n+\n+\n+1.1-beta3 (April 29, 2007)\n+--------------------------\n+\n+- No longer register tools as utilities, since it broke the tests among\n+  other things.\n+\n+\n+1.1-beta2 (March 26, 2007)\n+--------------------------\n+\n+- Register tools as utilities\n+\n+\n+1.1-beta1 (March 5, 2007)\n+-------------------------\n+\n+- Make the AT autoversion policy save a version before the save for more\n+   intuitive behavior.\n+\n+- Fixed numerous ui glitches on the versions history form and started using\n+   statusmessages.\n+\n+- Do not install the versioning control panel anymore. You can enable versioning\n+  for a content type on the new types control panel now.\n+\n+ToDo\n+\n+- Finish exportimport handlers for portal_repository and portal_modifier thus\n+  making setuphandlers importVarious unnecessary again.\n+\n+- Add back special portal_historyidhandler / portal_uidhandler handling. If a\n+  portal_uidhandler tool is found during install, it should be renamed to\n+  portal_historyidhandler. The missing tools should be created as normal then.\n+\n+\n+1.1-alpha2 (February 08, 2007)\n+------------------------------\n+\n+- Removed specialized document byline.\n+\n+- Switch to Plone control panel category\n+\n+\n+1.1-alpha1 (November 22, 2006)\n+------------------------------\n+\n+Internal Changes\n+\n+- Two minor updates for CMF 2.1 compatibility. [hannosch]\n+\n+- Use a GenericSetup Extension profile for installation instead of an external\n+  method. [hannosch]\n+\n+- Cleaned up tests. As these are based on PloneTestCase and Plone 3.0 we don\'t\n+  have to set up anything special anymore. [hannosch, alecm]\n+\n+- Removed ActionProviderBase as a base class from all tools. In CMF 2.1 actions\n+  are usually only stored on the actions tool. [hannosch]\n+\n+- Updated dependency information for Plone 3.0 inclusion. [hannosch]\n+\n+\n+1.0 (SVN)\n+---------\n+\n+Bugs fixed\n+\n+- Fixed OMInsideChildrensModifier InitializeClass. [encolpe]\n+\n+Internal Changes\n+\n+- Replaced usage of zLOG with Python\'s logging framework. [hannosch]\n+\n+- Removed lots of unused import statements, found by pyflakes. [hannosch]\n+\n+- Removed BBB code for old transaction handling. [hannosch]\n+\n+- Removed some BBB code for ZClasses and CMF 1.4. [hannosch]\n+\n+CMFEditions 1.0rc1 (unreleased)\n+-------------------------------\n+\n+ToDo\n+\n+- migration from CMFEditions 1.0alpha3 doesn\'t work correctly\n+- some translations are not yet updated: contact translators (for changes see\n+  below. Affected translations: fr, da, pl)\n+- Fix outstanding failing tests\n+- Some complex integration test with deleted version. (purge support)\n+- allow adding test hierarchy only if in debug mode\n+- allow migration in debug mode only\n+- fix issue #28\n+- fix issue #25\n+- fix issue #19\n+- fix issue #17\n+- fix issue #22\n+\n+1.0beta1 (2006-06-24)\n+---------------------\n+\n+Bugs fixed\n+\n+- Fixed previewing (retrieving) files and images. [gregweb]\n+\n+- Security Policy was for ``manage_setPolicies`` but the method name\n+  was ``manage_setTypePolicies``. Corrected. [gregweb]\n+\n+- The storage now stores ZVC\'s ``__vc_info__`` for every version\n+  avoiding wrong information is attached to a working copy when\n+  previewing a version. Fix for ToDo.txt item #48. [gregweb]\n+\n+- Replaced all occurences of ``rollback`` with ``revert``. Brought into\n+  sync internal names with UI. Rollback may suggest a transaction\n+  rollback which is something different. Including i18n label\n+  ``label_rollback`` which is now ``label_revert``. Added backwards\n+  compatibility code for configuration. Translations not updated.\n+  [gregweb]\n+\n+- Minor refactorings of the version history view. Notably replaced\n+  ``(show below)`` by ``preview`` without jumping to the preview target\n+  on the page by default. Instead the link name of the previewed version\n+  changes to ``jump down``. [gregweb]\n+\n+- The storage is now more immune against non int selectors. [gregweb]\n+\n+\n+Features Added\n+\n+- The approximate size of a version is now recorded also at save time\n+  (and calculated at storage migartion).\n+  [gregweb]\n+\n+- Added size information to storage statistics ZMI view [gregweb]\n+\n+- Added German translations [gregweb]\n+\n+- Added Polish translations provided by Piotr Furman [Piotr Furman, gregweb]\n+\n+- ``RetainWorkflowStateAndHistory`` now adds the ``review_state`` to the\n+  ``sys_metadata`` at save time because at retreive time the workflow tool\n+  picks the working copies state. I didn\'t find any other way to do it\n+  without digging into workflows internals (which would have been a bad\n+  idea anyway). Had to extend the ``IModifier.ISaveRetrieveModifier``\n+  interface to allow a modifier enhance ``sys_metadata`` at save time.\n+  [gregweb]\n+\n+- Added purge support [gregweb]:\n+\n+  - Enhanced storage API with a ``purge`` method that inevitabely\n+    removes a version from the history. See added ``IPurgeSupport``\n+    and ``IPurgePolicy`` interfaces.\n+  - Purging raises an exception if no purge policy is installed. This\n+    will avoid a lot of future tracker items caused by people having\n+    removed the purge policy but nevertheless providing purge support\n+    to users. The reason is that the archivist and repo layer can\'t\n+    handle yet the empty placeholder object beeing returned by the\n+    storage for the purged version. This rule may be relaxed in future\n+    versions if the archivist and repo layer support handling of those\n+    empty placeholder objects.\n+  - The UI doesn\'t expose manual purge functionality. Through the ZMI a\n+    number n may be configured representing the maximum number of\n+    version per content item that have to be preserved. Older ones are\n+    automatically purged from the storage at save time.\n+  - There is a new purge permission that may be used to restrict purging\n+    to special roles if necessary (applicable to manual purging only).\n+  - On the repo layer (``portal_repository``) retrieving an object or\n+    iterating over the history always returns a valid (unpurged)\n+    version. The returned object may be a substitute. Two numbering\n+    schematas exist. Numbering counting purged versions and not\n+    counting purged versions (passing True or False to ``countPurged``).\n+    The default numbering schema is ``countPurged=True``. The UI\n+    history onyl shows unpurged versions (``countPurged=False``).\n+  - If the storage is asked to retreive a removed version it may be\n+    instructed to return a substitute for the removed version. The\n+    substitution policy itself is implemented in the new purge policy\n+    tool. This strategy allows to keep most purge implementation\n+    details out of the upper layers (archivist, modifiers, repository).\n+  - The new purge policy tool may be instructed to only keep n versions\n+    of a content item. Thus at save time the oldest version is purged\n+    if the save operation would result in more than n version reside in\n+    the storage.\n+  - The new purge policy tool substitutes a removed version with the\n+    next older version. If no other version is available the next\n+    newer is used as substitute. If none is available ... well this\n+    isn\'t yet tested :-)\n+  - The archivist and storage may be asked to also retreive the empty\n+    placeholder of a purged version. This functionality is yet exposed\n+    to the repo layer. This may change in a future release.\n+  - Added ``isValid`` method on the vdata object that allows to ask if\n+    the retrieved object it is valid or not (empty placeholder object\n+    or a real version).\n+\n+- At save time a version aware reference to the parent node is saved\n+  also. Without it would be very ineffective or even impossible to\n+  find out the parents which potentially would prevent adding usefull\n+  features like retrieving the a whole site from one object in the\n+  tree. [gregweb]\n+\n+- The histories default order has changed: It now returns the newest\n+  version as first item and the oldest as last item. The old behaviour\n+  is still available by passing ``oldestFirst=True``. [gregweb]\n+\n+- Inserted the ``oldestFirst`` parameter before the already existing\n+  ``preserve`` parameter. This will cause changes of 3rd party products\n+  that are using ``preserve`` (None know at the moment, it\'s better to\n+  change now than later). [gregweb]\n+\n+- Added two new i18n labels: ``label_preview_version_below``,\n+  ``label_preview_version`` (no translations yet) [gregweb]\n+\n+- Renamed i18n label: ``label_show_below`` to ``label_preview_version_link``\n+  (updated labels in po-files but not the translations) [gregweb]\n+\n+\n+Internal Changes\n+\n+- Now save all metadata also in shadow storage. But currently on retrieve\n+  the metadata is still feteched from the ZVC storage. [gregweb]\n+\n+- Added migration code for 1.0alpha3 --> 1.0beta1 storage migrations\n+  [gregweb]\n+\n+- Adding purge support caused heavy refactoring the version storage.\n+  ZVC is still used to store the contents history but now additional\n+  data is stored in a parallel shadow storage. The layout of the data\n+  in the ZVC didn\'t change, only ZVC and purge related metadata has\n+  been added to the parallel shadow storage. [gregweb]\n+\n+- Garbage collected a lot of code that was commented out, outdated\n+  triple-X\'s and items in ``ToDo.txt``. [gregweb]\n+\n+- The storage tests now tests ZVCSTorageTool only once and additionally\n+  tests the dummy memory storage. This was the intended behaviour but\n+  a bug prevented running the tests with the dummy storage and instead\n+  run the tests with ZVCStorageToll twice. [gregweb]\n+\n+\n+1.0alpha4 (2006-06-24)\n+----------------------\n+\n+Bugs fixed\n+\n+- fixed bug with AT references causing ref catalog having been inconsistent\n+  [sunew]\n+\n+\n+Features added\n+\n+- Comment is now taken from request if any. [sunew]\n+\n+- Added storage statistics ZMI view. [gregweb]\n+\n+- Added functionality to create a test hierarchy. [gregweb]\n+\n+\n+1.0alpha3 (2006-06-03)\n+----------------------\n+\n+Bugs fixed\n+\n+- Fixed tracker issue #15 [alecm, gregweb]\n+\n+- When previewing a version the expandable history link is removed as this\n+  doesn\'t make sense at all and caused double fetching of history items.\n+  [gregweb]\n+\n+- Use the default view of the retrieved object, as it may be different from\n+  that of the current object. [alecm]\n+\n+- The expandable version link is only shown for users having the permission\n+  to view the history. [rafrombrc]\n+\n+- Added RetainATRefs modifier [vds]\n+\n+- Fixed broken ``isUpToDate`` [gregweb]\n+\n+- ``version_id`` wasn\'t correctly set at the working copy at save time.\n+  Because of this it may happen that the wrong version info was saved\n+  with the version aware reference. The version_id is now set at the end\n+  of the save operation. [alecm, gregweb]\n+\n+- Handle usecase where an inside reference is moved outside its container.\n+  Still need to handle case where it has been replaced by another object\n+  with the same id.  [alecm]\n+\n+- Changed API for Archivist methods and the dereference utility method so\n+  that they now accept an optional history_id, rather than implicitly\n+  allowing the \'obj\' parameter to be a history_id. As side effect this\n+  will help in supporting multi location checkout in the future.\n+  [alecm, gregweb]\n+\n+- Fixed various UI issues. [rlemmi, vds, alecm]\n+\n+- Fixed SF issue #1376836. [alecm]\n+\n+- restored at\'s extra_buttons slot (some others slots are still missing\n+  because of this template override) [syt]\n+\n+- Totally refactored recursive retrieve of an ancient version of an object.\n+  Fixed a lot of folderish bugs with this refactoring. [gregweb]\n+\n+- Corrected a hairy acquisition bug that caused wrong security evaluations\n+  (ArchivistTool.py). Acquisition is a monster feature! [gregweb]\n+\n+- The storage now returns obj.modified() instead of\n+  obj.getModificationDate() because it\'s more fine graned. [gregweb]\n+\n+- Added ReferenceFactoriesTool.py which in essence knows how to\n+  instatiate a reference. The current implementation is inflexible and\n+  knows only how to instantiate object into an ObjectManager. This\n+  is the first step in preparation for AT reference handling. [gregweb]\n+\n+- Fixed tracker issue #16 RuntimeError: maximum recursion depth exceeded.\n+  I (gregweb) suspect it got fixed by: [alecm]\n+\n+- Fixed identical tracker issues #5, #6, #7, #8. I (gregweb) suspect it got\n+  fixed by: [alecm]\n+\n+- Added modifier to copy permissions from working copy onto retrieved\n+  versions, otherwise retaining workflow can have some very strange\n+  consequences. [alecm]\n+\n+- Fixed a number of bugs involving handling of adding and deleting subobjects\n+  of versioned folders.\n+  [alecm]\n+\n+- Fixed a permissions bug which made the versions_history_form inaccessible if\n+  any of the versions were saved while private (or otherwise had\n+  \'Access contents information\' disabled).\n+  [alecm]\n+\n+- Made quickinstalled product reinstall/uninstall work without issue.  Fixed\n+  unit tests for Plone 2.1.  Use mutators in templates and tests where\n+  applicable rather than direct attribute access. Was Issue #9, #10 and #11.\n+  Thanks to Andrew Lewis for the patches and reports. [Andrew Lewis, alecm]\n+\n+- Corrected bugs in ``RetainWorkflowStateAndHistory`` modifier and the\n+  modifier registry avoiding the review state and the workflow history\n+  from beeing retained on retrieve and revert.\n+\n+\n+Features added\n+\n+- Added danish translation. [stonor]\n+\n+- Retrieving an object just for preview (without replacing the working copy)\n+  caused a lot of headaches and got more and more complex und ununderstandable.\n+  Everything got much simpler by just using a savepoint/abort pair at the right\n+  place while retrieving. [alecm]\n+\n+- I18N tuned (diff-legend untested), french added\n+  [Gpgi, gotcha]\n+\n+- Added more tests to improve coverage. [azy, vds, alecm]\n+\n+- Added support for ATCT (Archetypes Content Types). [azy]\n+\n+- Added ZMI interface for modifiers. [rlemmi]\n+\n+- It\'s now possible to save a new version in the edit view. As soon as a\n+  version sahll be saved a comment field is inserted to add a comment.\n+  [rlemmi]\n+\n+- Added expandable version history to document_byline. [rlemmi]\n+\n+- Made the ModifierRegistryTool make use of any preserve dict passed back to\n+  it by afterRetrieveModifiers.\n+  [alecm]\n+\n+- Added optional CMFDiffTool support for generating diffs between object\n+  versions.  For this to work you need to setup the diffable fields on each\n+  type in portal_diff.  In the \'alecm-at-schema-diffs\' branch of CMFDiffTool\n+  there is a diff type that can be applied to any AT object which will\n+  automatically setup diffs for all fields in the schema (when using this\n+  any value can be entered for the field in portal_diff).\n+  [alecm]\n+\n+- Added a versioning policy (at_edit_autoversion) which automatically creates\n+  new versions on edit for AT types which are configured to support the policy\n+  in the configlet.  This is implemented using a simple macro override on\n+  AT\'s edit_macros, and a new entry in the AT edit form controller chain.\n+  [alecm]\n+\n+- Added new interface IContentTypeVersionPolicySupport and implemented it in\n+  portal_repository.  It allows products to register versioning policies\n+  (classes which implement IVersionPolicy), and to associate those policies\n+  with specific portal types.  IVersionPolicy objects may define methods\n+  (setupPolicyHook, removePolicyHook, enablePolicyOnTypeHook,\n+  disablePolicyOnTypeHook) which can be used to install/uninstall policy\n+  specific behavior in the portal, on adding/removing the policy, or enabling/\n+  disabling the policy on a specific type.\n+  [alecm]\n+\n+\n+1.0alpha2 (around June 2005)\n+----------------------------\n+\n+no changes recorded\ndiff --git a/news/80.bugfix b/news/80.bugfix\nnew file mode 100644\nindex 0000000..9d11b72\n--- /dev/null\n+++ b/news/80.bugfix\n@@ -0,0 +1,2 @@\n+QA: black, isort, flake8, fix deprecation warnings, remove use of six, upgrade to Python 3.7-only syntax.\n+[maurits]\ndiff --git a/setup.cfg b/setup.cfg\nindex 06aa277..965bc82 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,6 +1,9 @@\n-[zest.releaser]\n-create-wheel = yes\n-\n-# When Python 2-3 compatible:\n [bdist_wheel]\n-universal = 1\n+universal = 0\n+\n+[isort]\n+# black compatible isort rules:\n+profile = black\n+force_alphabetical_sort = True\n+force_single_line = True\n+lines_after_imports = 2\ndiff --git a/setup.py b/setup.py\nindex a58cb35..acba995 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,16 +1,15 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n \n with open("README.rst") as myfile:\n-    long_description = myfile.read() + \'\\n\'\n+    long_description = myfile.read() + "\\n"\n with open("CHANGES.rst") as myfile:\n     long_description += myfile.read()\n-version = \'4.0.0a2.dev0\'\n+version = "4.0.0a2.dev0"\n \n setup(\n-    name=\'Products.CMFEditions\',\n+    name="Products.CMFEditions",\n     version=version,\n     description="Versioning for Plone",\n     long_description=long_description,\n@@ -28,40 +27,39 @@\n         "Programming Language :: Python :: 3.8",\n         "Programming Language :: Python :: 3.9",\n     ],\n-    keywords=\'Versioning Plone\',\n-    author=\'CMFEditions contributers\',\n-    author_email=\'collective-versioning@lists.sourceforge.net\',\n-    url=\'https://pypi.org/project/Products.CMFEditions\',\n-    license=\'GPL\',\n+    keywords="Versioning Plone",\n+    author="CMFEditions contributers",\n+    author_email="collective-versioning@lists.sourceforge.net",\n+    url="https://pypi.org/project/Products.CMFEditions",\n+    license="GPL",\n     packages=find_packages(),\n-    namespace_packages=[\'Products\'],\n+    namespace_packages=["Products"],\n     include_package_data=True,\n     zip_safe=False,\n     extras_require=dict(\n         test=[\n-            \'plone.app.testing\',\n-            \'plone.app.textfield\',\n-            \'Products.CMFPlone\',\n-            \'Products.CMFDynamicViewFTI\',\n-            \'zope.testing\',\n+            "plone.app.testing",\n+            "plone.app.textfield",\n+            "Products.CMFPlone",\n+            "Products.CMFDynamicViewFTI",\n+            "zope.testing",\n         ]\n     ),\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'zope.copy\',\n-        \'zope.dottedname\',\n-        \'zope.i18nmessageid\',\n-        \'zope.interface\',\n-        \'Products.CMFCore >=2.1\',\n-        \'Products.CMFDiffTool\',  # dependency in diff template\n-        \'Products.CMFUid\',\n-        \'Products.GenericSetup >=1.4.0\',\n-        \'Products.ZopeVersionControl\',\n-        \'Acquisition\',\n-        \'DateTime\',\n-        \'transaction\',\n-        \'Zope2\',\n+        "setuptools",\n+        "zope.copy",\n+        "zope.dottedname",\n+        "zope.i18nmessageid",\n+        "zope.interface",\n+        "Products.CMFCore >=2.1",\n+        "Products.CMFDiffTool",  # dependency in diff template\n+        "Products.CMFUid",\n+        "Products.GenericSetup >=1.4.0",\n+        "Products.ZopeVersionControl",\n+        "Acquisition",\n+        "DateTime",\n+        "transaction",\n+        "Zope2",\n     ],\n     entry_points="""\n     [z3c.autoinclude.plugin]\n'

