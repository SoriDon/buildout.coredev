Repository: borg.localrole


Branch: refs/heads/master
Date: 2023-02-08T17:58:42+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/borg.localrole/commit/85ede248d6052dda76d12b6cb6e44a2b89b0be57

Configuring with plone/meta

Files changed:
A .editorconfig
A .github/workflows/linting.yml
A .meta.toml
A lint-requirements.txt
A tox.ini
M pyproject.toml
M setup.cfg

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.github/workflows/linting.yml b/.github/workflows/linting.yml\nnew file mode 100644\nindex 0000000..5ea3292\n--- /dev/null\n+++ b/.github/workflows/linting.yml\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+name: Linting\n+on:\n+  push:\n+    branches: [master]\n+  pull_request:\n+    branches: [master]\n+  workflow_dispatch:\n+\n+jobs:\n+  lint:\n+    name: Format and lint code\n+    runs-on: ${{ matrix.os }}\n+    strategy:\n+      matrix:\n+        python-version: ["3.8"]\n+        os: ["ubuntu-22.04"]\n+    steps:\n+      - uses: actions/checkout@v3\n+      - name: Set up Python\n+        uses: actions/setup-python@v4\n+        with:\n+          python-version: ${{ matrix.python-version }}\n+      - name: Cache packages\n+        uses: actions/cache@v3\n+        with:\n+          path: ~/.cache/pip\n+          key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles(\'lint-requirements.txt\', \'tox.ini\') }}\n+          restore-keys: |\n+            ${{ runner.os }}-pip-${{ matrix.python-version }}-\n+            ${{ runner.os }}-pip-\n+      - name: Install dependencies\n+        run: python -m pip install tox\n+      - name: Run formatters\n+        run: tox -e format\n+      # linters\n+      - name: QA\n+        run: tox -e lint\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..2d5b403\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "68486a87"\ndiff --git a/lint-requirements.txt b/lint-requirements.txt\nnew file mode 100644\nindex 0000000..2a91911\n--- /dev/null\n+++ b/lint-requirements.txt\n@@ -0,0 +1,12 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+black==22.12.0\n+check-manifest==0.49\n+codespell==2.2.2\n+flake8==6.0.0\n+isort==5.11.4\n+pipdeptree==2.3.3\n+pyroma==4.1\n+pyupgrade==3.3.1\n+z3c.dependencychecker==2.10\n+zpretty==2.4.1\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..0f96c85 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,24 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "internal"\n+name = "Internal:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "documentation"\n+name = "Documentation:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "tests"\n+name = "Tests"\n+showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\ndiff --git a/setup.cfg b/setup.cfg\nindex aecfa92..8849fbc 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,9 +1,23 @@\n-[check-manifest]\n-ignore =\n-    *.cfg\n-    bootstrap.py\n-\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[bdist_wheel]\n+universal = 0\n \n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n \n-[bdist_wheel]\n-universal = 1\n+[check-manifest]\n+ignore =\n+    .editorconfig\n+    .meta.toml\n+    tox.ini\n+    lint-requirements.txt\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..5a29bed\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,75 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[tox]\n+envlist =\n+    format\n+    lint\n+\n+[testenv]\n+py_files = git ls-files "*.py"\n+text_files = git ls-files "*.rst" "*.md"\n+xml_files = git ls-files "*.xml"\n+zcml_files = git ls-files "*.zcml"\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat python code\n+skip_install = true\n+deps =\n+    pyupgrade\n+    isort\n+    black\n+    zpretty\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'{[testenv]py_files} | xargs pyupgrade --py38-plus\'\n+    sh -c \'{[testenv]py_files} | xargs isort\'\n+    sh -c \'{[testenv]py_files} | xargs black\'\n+    sh -c \'{[testenv]xml_files} | xargs zpretty -x -i || true\'\n+    sh -c \'{[testenv]zcml_files} | xargs zpretty -z -i || true\'\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    flake8\n+    codespell\n+    tomli  # needed for codespell to read pyproject.toml\n+    check-manifest\n+    pyroma\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'{[testenv]py_files} | xargs flake8\'\n+    sh -c \'{[testenv]py_files} | xargs codespell\'\n+    sh -c \'{[testenv]text_files} | xargs codespell\'\n+    check-manifest\n+    pyroma -n 10 .\n+\n+[testenv:dependencies]\n+description = check if the package defines all its dependencies\n+deps =\n+    z3c.dependencychecker\n+    -c lint-requirements.txt\n+commands =\n+    dependencychecker\n+\n+[testenv:dependencies-graph]\n+description = generate a graph with the distribution dependencies\n+deps =\n+    pipdeptree\n+    graphviz  # optional dependency of pipdeptree\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'pipdeptree --exclude setuptools,pipdeptree,wheel --graph-output svg > dependencies.svg\'\n+\n+[testenv:test]\n+description = run the distribution\'s tests\n+deps =\n+    borg.localrole[test]\n+    pytest\n+    gocept.pytestlayer\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    pip install -e .\n+    pytest\n'

Repository: borg.localrole


Branch: refs/heads/master
Date: 2023-02-08T18:10:46+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/borg.localrole/commit/9c01c2f246ea87b3275b80b97b2277a3f9078db8

chore: pyupgrade

Files changed:
M borg/__init__.py
M borg/localrole/__init__.py
M borg/localrole/bbb/__init__.py
M borg/localrole/bbb/interfaces.py
M borg/localrole/config.py
M borg/localrole/default_adapter.py
M borg/localrole/factory_adapter.py
M borg/localrole/interfaces.py
M borg/localrole/setuphandlers.py
M borg/localrole/tests.py
M borg/localrole/utils.py
M borg/localrole/workspace.py
M setup.py

b'diff --git a/borg/__init__.py b/borg/__init__.py\nindex ab2575f..de40ea7 100644\n--- a/borg/__init__.py\n+++ b/borg/__init__.py\n@@ -1,8 +1 @@\n-# -*- coding: utf-8 -*-\n-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n-try:\n-    __import__(\'pkg_resources\').declare_namespace(__name__)\n-except ImportError:\n-    from pkgutil import extend_path\n-    __path__ = locals()[\'__path__\']  # make pyflakes happy...\n-    __path__ = extend_path(__path__, __name__)\n+__import__(\'pkg_resources\').declare_namespace(__name__)\ndiff --git a/borg/localrole/__init__.py b/borg/localrole/__init__.py\nindex 70aa109..fb97253 100644\n--- a/borg/localrole/__init__.py\n+++ b/borg/localrole/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from AccessControl.Permissions import add_user_folders\n from borg.localrole import workspace\n from Products.PluggableAuthService import registerMultiPlugin\ndiff --git a/borg/localrole/bbb/__init__.py b/borg/localrole/bbb/__init__.py\nindex 40a96af..e69de29 100644\n--- a/borg/localrole/bbb/__init__.py\n+++ b/borg/localrole/bbb/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/borg/localrole/bbb/interfaces.py b/borg/localrole/bbb/interfaces.py\nindex 94969aa..95bd9b9 100644\n--- a/borg/localrole/bbb/interfaces.py\n+++ b/borg/localrole/bbb/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Interface\n \n \ndiff --git a/borg/localrole/config.py b/borg/localrole/config.py\nindex 994dd88..1bb272e 100644\n--- a/borg/localrole/config.py\n+++ b/borg/localrole/config.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n # Configuration constants\n \n LOCALROLE_PLUGIN_NAME = \'borg_localroles\'\ndiff --git a/borg/localrole/default_adapter.py b/borg/localrole/default_adapter.py\nindex 1ab7847..04b9874 100644\n--- a/borg/localrole/default_adapter.py\n+++ b/borg/localrole/default_adapter.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from borg.localrole.interfaces import ILocalRoleProvider\n from zope.component import adapter\n from zope.interface import implementer\n@@ -9,7 +8,7 @@\n \n @implementer(ILocalRoleProvider)\n @adapter(Interface)\n-class DefaultLocalRoleAdapter(object):\n+class DefaultLocalRoleAdapter:\n     """Looks at __ac_local_roles__ to find local roles stored\n     persistently on an object::\n \n@@ -77,4 +76,4 @@ def getRoles(self, principal_id):\n     def getAllRoles(self):\n         """Returns all the local roles assigned in this context:\n         (principal_id, [role1, role2])"""\n-        return six.iteritems(self._rolemap)\n+        return self._rolemap.items()\ndiff --git a/borg/localrole/factory_adapter.py b/borg/localrole/factory_adapter.py\nindex da0c66b..ddb0608 100644\n--- a/borg/localrole/factory_adapter.py\n+++ b/borg/localrole/factory_adapter.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n from borg.localrole.interfaces import IFactoryTempFolder\n@@ -10,7 +9,7 @@\n \n @implementer(ILocalRoleProvider)\n @adapter(IFactoryTempFolder)\n-class FactoryTempFolderProvider(object):\n+class FactoryTempFolderProvider:\n     """A simple local role provider which just gathers the roles from\n     the desired context::\n \ndiff --git a/borg/localrole/interfaces.py b/borg/localrole/interfaces.py\nindex 9bd2f2e..42b729f 100644\n--- a/borg/localrole/interfaces.py\n+++ b/borg/localrole/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.deferredimport import deprecated\n from zope.interface import Interface\n \ndiff --git a/borg/localrole/setuphandlers.py b/borg/localrole/setuphandlers.py\nindex 05e3089..bd29f33 100644\n--- a/borg/localrole/setuphandlers.py\n+++ b/borg/localrole/setuphandlers.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from borg.localrole.utils import setup_localrole_plugin\n \n \ndiff --git a/borg/localrole/tests.py b/borg/localrole/tests.py\nindex b659583..ad91721 100644\n--- a/borg/localrole/tests.py\n+++ b/borg/localrole/tests.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from borg.localrole import default_adapter\n from borg.localrole import factory_adapter\n from plone.app.testing import PLONE_INTEGRATION_TESTING\n@@ -14,7 +13,7 @@\n \n \n @implementer(borg.localrole.interfaces.ILocalRoleProvider)\n-class SimpleLocalRoleProvider(object):\n+class SimpleLocalRoleProvider:\n \n     def __init__(self, context):\n         self.context = context\n@@ -29,7 +28,7 @@ def getAllRoles(self):\n         yield (\'bogus_user\', (\'Foo\', ))\n \n \n-class DummyUser(object):\n+class DummyUser:\n     def __init__(self, uid, group_ids=()):\n         self.id = uid\n         self._groups = group_ids\n@@ -50,7 +49,7 @@ def getRoles(self):\n class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n         if six.PY2:\n-            got = re.sub("set\\(\\[(.*?)\\]\\)", "{\\\\1}", got)\n+            got = re.sub(r"set\\(\\[(.*?)\\]\\)", "{\\\\1}", got)\n             want = re.sub(\n                 \'plone.memoize.volatile.DontCache\',\n                 \'DontCache\', want\ndiff --git a/borg/localrole/utils.py b/borg/localrole/utils.py\nindex d69854e..ed5bed4 100644\n--- a/borg/localrole/utils.py\n+++ b/borg/localrole/utils.py\n@@ -1,12 +1,10 @@\n-# -*- coding: utf-8 -*-\n-from __future__ import print_function\n from Acquisition import aq_base\n from borg.localrole.config import LOCALROLE_PLUGIN_NAME\n from borg.localrole.workspace import manage_addWorkspaceLocalRoleManager\n from Products.CMFCore.utils import getToolByName\n from Products.PlonePAS.plugins.local_role import LocalRolesManager\n from Products.PlonePAS.setuphandlers import activatePluginInterfaces\n-from six import StringIO\n+from io import StringIO\n \n \n def setup_localrole_plugin(portal):\ndiff --git a/borg/localrole/workspace.py b/borg/localrole/workspace.py\nindex 91247bb..1f8c82d 100644\n--- a/borg/localrole/workspace.py\n+++ b/borg/localrole/workspace.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from AccessControl import ClassSecurityInfo\n from Acquisition import aq_get\n from Acquisition import aq_inner\n@@ -39,7 +38,7 @@ def manage_addWorkspaceLocalRoleManager(\n \n     if REQUEST is not None:\n         REQUEST.RESPONSE.redirect(\n-            \'{0}/manage_workspace?\'\n+            \'{}/manage_workspace?\'\n             \'manage_tabs_message=WorkspaceLocalRoleManager+added.\'.format(\n                 dispatcher.absolute_url()\n             )\ndiff --git a/setup.py b/setup.py\nindex a1614c3..26a4d9e 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n'

Repository: borg.localrole


Branch: refs/heads/master
Date: 2023-02-08T18:10:47+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/borg.localrole/commit/f6bb099b82d2ab1fedbf0a674205a6d5f7ae25a6

chore: isort + black

Files changed:
M borg/__init__.py
M borg/localrole/__init__.py
M borg/localrole/bbb/interfaces.py
M borg/localrole/config.py
M borg/localrole/default_adapter.py
M borg/localrole/factory_adapter.py
M borg/localrole/interfaces.py
M borg/localrole/setuphandlers.py
M borg/localrole/tests.py
M borg/localrole/utils.py
M borg/localrole/workspace.py
M setup.py

b'diff --git a/borg/__init__.py b/borg/__init__.py\nindex de40ea7..5284146 100644\n--- a/borg/__init__.py\n+++ b/borg/__init__.py\n@@ -1 +1 @@\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/borg/localrole/__init__.py b/borg/localrole/__init__.py\nindex fb97253..66dcaa4 100644\n--- a/borg/localrole/__init__.py\n+++ b/borg/localrole/__init__.py\n@@ -16,5 +16,5 @@ def initialize(context):\n             workspace.manage_addWorkspaceLocalRoleManagerForm,\n             workspace.manage_addWorkspaceLocalRoleManager,\n         ),\n-        visibility=None\n+        visibility=None,\n     )\ndiff --git a/borg/localrole/bbb/interfaces.py b/borg/localrole/bbb/interfaces.py\nindex 95bd9b9..86747ce 100644\n--- a/borg/localrole/bbb/interfaces.py\n+++ b/borg/localrole/bbb/interfaces.py\n@@ -4,6 +4,7 @@\n # BBB: These interfaces will be removed in a later version of borg.locarole.\n # You should use the interfaces in borg.localrole.interfaces instead!\n \n+\n class IWorkspace(Interface):\n     """A workspace in which custom local roles are needed\n \n@@ -13,8 +14,7 @@ class IWorkspace(Interface):\n     """\n \n     def getLocalRolesForPrincipal(principal):\n-        """Return a sequence of all local roles for a principal.\n-        """\n+        """Return a sequence of all local roles for a principal."""\n \n     def getLocalRoles():\n         """Return a dictonary mapping principals to their roles within\ndiff --git a/borg/localrole/config.py b/borg/localrole/config.py\nindex 1bb272e..40d52ac 100644\n--- a/borg/localrole/config.py\n+++ b/borg/localrole/config.py\n@@ -1,3 +1,3 @@\n # Configuration constants\n \n-LOCALROLE_PLUGIN_NAME = \'borg_localroles\'\n+LOCALROLE_PLUGIN_NAME = "borg_localroles"\ndiff --git a/borg/localrole/default_adapter.py b/borg/localrole/default_adapter.py\nindex 04b9874..9edda13 100644\n--- a/borg/localrole/default_adapter.py\n+++ b/borg/localrole/default_adapter.py\n@@ -61,7 +61,7 @@ def __init__(self, context):\n \n     @property\n     def _rolemap(self):\n-        rolemap = getattr(self.context, \'__ac_local_roles__\', {})\n+        rolemap = getattr(self.context, "__ac_local_roles__", {})\n         # None is the default value from AccessControl.Role.RoleMananger\n         if rolemap is None:\n             return {}\ndiff --git a/borg/localrole/factory_adapter.py b/borg/localrole/factory_adapter.py\nindex ddb0608..18e773c 100644\n--- a/borg/localrole/factory_adapter.py\n+++ b/borg/localrole/factory_adapter.py\n@@ -97,7 +97,7 @@ def __init__(self, obj):\n         self.folder = obj\n \n     def getRoles(self, principal_id):\n-        uf = aq_inner(getToolByName(self.folder, \'acl_users\'))\n+        uf = aq_inner(getToolByName(self.folder, "acl_users"))\n         user = aq_inner(uf.getUserById(principal_id, default=None))\n         # use the folder we are creating in as role generating context\n         source = aq_parent(aq_parent(self.folder))\ndiff --git a/borg/localrole/interfaces.py b/borg/localrole/interfaces.py\nindex 42b729f..ca4dfbb 100644\n--- a/borg/localrole/interfaces.py\n+++ b/borg/localrole/interfaces.py\n@@ -3,13 +3,13 @@\n \n \n deprecated(\n-    \'Please use borg.localrole.interfaces.ILocalRoleProvider instead\',\n-    IWorkspace=\'borg.localrole.bbb.interfaces:IWorkspace\'\n+    "Please use borg.localrole.interfaces.ILocalRoleProvider instead",\n+    IWorkspace="borg.localrole.bbb.interfaces:IWorkspace",\n )\n \n deprecated(\n-    \'Please use borg.localrole.interfaces.ILocalRoleProvider instead\',\n-    IGroupAwareWorkspace=\'borg.localrole.bbb.interfaces:IGroupAwareWorkspace\'\n+    "Please use borg.localrole.interfaces.ILocalRoleProvider instead",\n+    IGroupAwareWorkspace="borg.localrole.bbb.interfaces:IGroupAwareWorkspace",\n )\n \n \n@@ -17,12 +17,11 @@ class ILocalRoleProvider(Interface):\n     """An interface which allows querying the local roles on an object"""\n \n     def getRoles(principal_id):\n-        """Returns an iterable of roles granted to the specified user object\n-        """\n+        """Returns an iterable of roles granted to the specified user object"""\n \n     def getAllRoles():\n         """Returns an iterable consisting of tuples of the form:\n-            (principal_id, sequence_of_roles)\n+        (principal_id, sequence_of_roles)\n         """\n \n \ndiff --git a/borg/localrole/setuphandlers.py b/borg/localrole/setuphandlers.py\nindex bd29f33..f30b14d 100644\n--- a/borg/localrole/setuphandlers.py\n+++ b/borg/localrole/setuphandlers.py\n@@ -3,7 +3,7 @@\n \n def importVarious(context):\n \n-    if context.readDataFile(\'borg.localrole_various.txt\') is None:\n+    if context.readDataFile("borg.localrole_various.txt") is None:\n         return\n \n     portal = context.getSite()\ndiff --git a/borg/localrole/tests.py b/borg/localrole/tests.py\nindex ad91721..1dab7bb 100644\n--- a/borg/localrole/tests.py\n+++ b/borg/localrole/tests.py\n@@ -14,18 +14,17 @@\n \n @implementer(borg.localrole.interfaces.ILocalRoleProvider)\n class SimpleLocalRoleProvider:\n-\n     def __init__(self, context):\n         self.context = context\n \n     def getRoles(self, user):\n         """Grant everyone the \'Foo\' role"""\n-        return (\'Foo\', )\n+        return ("Foo",)\n \n     def getAllRoles(self):\n         """In the real world we would enumerate all users and\n         grant the \'Foo\' role to each, but we won\'t"""\n-        yield (\'bogus_user\', (\'Foo\', ))\n+        yield ("bogus_user", ("Foo",))\n \n \n class DummyUser:\n@@ -50,10 +49,7 @@ class Py23DocChecker(doctest.OutputChecker):\n     def check_output(self, want, got, optionflags):\n         if six.PY2:\n             got = re.sub(r"set\\(\\[(.*?)\\]\\)", "{\\\\1}", got)\n-            want = re.sub(\n-                \'plone.memoize.volatile.DontCache\',\n-                \'DontCache\', want\n-            )\n+            want = re.sub("plone.memoize.volatile.DontCache", "DontCache", want)\n         return doctest.OutputChecker.check_output(self, want, got, optionflags)\n \n \n@@ -61,25 +57,26 @@ def test_suite():\n     suite = [\n         layered(\n             doctest.DocFileSuite(\n-                \'README.txt\',\n-                package=\'borg.localrole\',\n-                optionflags=(doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE)\n+                "README.txt",\n+                package="borg.localrole",\n+                optionflags=(doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE),\n             ),\n-            layer=PLONE_INTEGRATION_TESTING),\n+            layer=PLONE_INTEGRATION_TESTING,\n+        ),\n         layered(\n             doctest.DocTestSuite(\n                 borg.localrole.workspace,\n                 optionflags=(doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE),\n                 checker=Py23DocChecker(),\n             ),\n-            layer=zca.UNIT_TESTING\n+            layer=zca.UNIT_TESTING,\n         ),\n         layered(\n             doctest.DocTestSuite(\n                 factory_adapter,\n-                optionflags=(doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE)\n+                optionflags=(doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE),\n             ),\n-            layer=zca.UNIT_TESTING\n+            layer=zca.UNIT_TESTING,\n         ),\n         doctest.DocTestSuite(default_adapter),\n     ]\ndiff --git a/borg/localrole/utils.py b/borg/localrole/utils.py\nindex ed5bed4..abf4d06 100644\n--- a/borg/localrole/utils.py\n+++ b/borg/localrole/utils.py\n@@ -1,18 +1,17 @@\n from Acquisition import aq_base\n from borg.localrole.config import LOCALROLE_PLUGIN_NAME\n from borg.localrole.workspace import manage_addWorkspaceLocalRoleManager\n+from io import StringIO\n from Products.CMFCore.utils import getToolByName\n from Products.PlonePAS.plugins.local_role import LocalRolesManager\n from Products.PlonePAS.setuphandlers import activatePluginInterfaces\n-from io import StringIO\n \n \n def setup_localrole_plugin(portal):\n-    """Install and prioritize the local-role PAS plug-in\n-    """\n+    """Install and prioritize the local-role PAS plug-in"""\n     out = StringIO()\n \n-    uf = getToolByName(portal, \'acl_users\')\n+    uf = getToolByName(portal, "acl_users")\n \n     existing = uf.objectIds()\n \n@@ -28,13 +27,13 @@ def setup_localrole_plugin(portal):\n def replace_local_role_manager(portal):\n     """Installs the borg local role manager in place of the standard one from\n     PlonePAS"""\n-    uf = getToolByName(portal, \'acl_users\', None)\n+    uf = getToolByName(portal, "acl_users", None)\n     # Make sure we have a PAS user folder\n-    if uf is not None and hasattr(aq_base(uf), \'plugins\'):\n+    if uf is not None and hasattr(aq_base(uf), "plugins"):\n         # Remove the original plugin if it\'s there\n-        if \'local_roles\' in uf.objectIds():\n-            orig_lr = getattr(uf, \'local_roles\')\n+        if "local_roles" in uf.objectIds():\n+            orig_lr = getattr(uf, "local_roles")\n             if isinstance(orig_lr, LocalRolesManager):\n-                uf.plugins.removePluginById(\'local_roles\')\n+                uf.plugins.removePluginById("local_roles")\n         # Install the borg.localrole plugin if it\'s not already there\n         setup_localrole_plugin(portal)\ndiff --git a/borg/localrole/workspace.py b/borg/localrole/workspace.py\nindex 1f8c82d..fb1ad2f 100644\n--- a/borg/localrole/workspace.py\n+++ b/borg/localrole/workspace.py\n@@ -1,8 +1,9 @@\n from AccessControl import ClassSecurityInfo\n+from AccessControl.class_init import InitializeClass\n from Acquisition import aq_get\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n-from AccessControl.class_init import InitializeClass\n+\n # BBB interfaces, to be removed\n from borg.localrole.bbb.interfaces import IGroupAwareWorkspace\n from borg.localrole.bbb.interfaces import IWorkspace\n@@ -20,16 +21,11 @@\n manage_addWorkspaceLocalRoleManagerForm = PageTemplateFile(\n     "zmi/WorkspaceLocalRoleManagerForm.pt",\n     globals(),\n-    __name__="manage_addWorkspaceRoleManagerForm"\n+    __name__="manage_addWorkspaceRoleManagerForm",\n )\n \n \n-def manage_addWorkspaceLocalRoleManager(\n-    dispatcher,\n-    id,\n-    title=None,\n-    REQUEST=None\n-):\n+def manage_addWorkspaceLocalRoleManager(dispatcher, id, title=None, REQUEST=None):\n     """Add a WorkspaceLocalRoleManager to a Pluggable Authentication\n     Services.\n     """\n@@ -38,8 +34,8 @@ def manage_addWorkspaceLocalRoleManager(\n \n     if REQUEST is not None:\n         REQUEST.RESPONSE.redirect(\n-            \'{}/manage_workspace?\'\n-            \'manage_tabs_message=WorkspaceLocalRoleManager+added.\'.format(\n+            "{}/manage_workspace?"\n+            "manage_tabs_message=WorkspaceLocalRoleManager+added.".format(\n                 dispatcher.absolute_url()\n             )\n         )\n@@ -47,94 +43,94 @@ def manage_addWorkspaceLocalRoleManager(\n \n # memoize support for `checkLocalRolesAllowed`\n def clra_cache_key(method, self, user, obj, object_roles):\n-    """ The cache key needs to include all arguments when caching allowed\n-        local roles, but the key function also needs to decide whether\n-        `volatile.cache` can cache or not by checking if it\'s possible to\n-        get a request instance from the object.\n-\n-        To test we\'ll nee an adaptable object, a user and the method which\n-        results\' we\'d like to cache:\n-\n-          >>> from zope.interface import implementer, Interface\n-          >>> @implementer(Interface)\n-          ... class DummyObject(object):\n-          ...     pass\n-          >>> obj = DummyObject()\n-\n-          >>> from borg.localrole.tests import DummyUser\n-          >>> john = DummyUser(\'john\')\n-\n-          >>> rm = WorkspaceLocalRoleManager(\'rm\', \'A Role Manager\')\n-          >>> fun = rm.__class__.checkLocalRolesAllowed\n-\n-        The dummy object doesn\'t have an acquired request, so no caching\n-        can be done:\n-\n-          >>> clra_cache_key(fun, \'me\', john, obj, [\'foo\', \'bar\'])\n-          Traceback (most recent call last):\n-          ...\n-          plone.memoize.volatile.DontCache\n-\n-        So let\'s add one and try again.  Before we also need to mark it as\n-        being annotatable, which normally happens elsewhere:\n-\n-          >>> from ZPublisher.HTTPRequest import HTTPRequest\n-          >>> request = HTTPRequest(\'\', dict(HTTP_HOST=\'nohost:8080\'), {})\n-\n-          >>> try:\n-          ...     from Zope2.App.zcml import load_config\n-          ... except ImportError:\n-          ...     from Products.Five.zcml import load_config\n-          >>> import zope.component\n-          >>> import zope.annotation\n-          >>> load_config(\'meta.zcml\', zope.component)\n-          >>> load_config(\'configure.zcml\', zope.annotation)\n-          >>> from zope.interface import classImplements\n-          >>> from zope.annotation.interfaces import IAttributeAnnotatable\n-          >>> classImplements(HTTPRequest, IAttributeAnnotatable)\n-\n-          >>> obj.REQUEST = request\n-          >>> clra_cache_key(fun, \'hmm\', john, obj, [\'foo\', \'bar\'])\n-          (\'john\', ..., (\'foo\', \'bar\'))\n-\n-        If the objects happens to have a `getPhysicalPath` method, that should\n-        be used instead of the hash:\n-\n-          >>> class DummyObjectWithPath(DummyObject):\n-          ...     def getPhysicalPath(self):\n-          ...         return \'42!\'\n-          >>> obj = DummyObjectWithPath()\n-          >>> obj.REQUEST = request\n-          >>> clra_cache_key(fun, \'hmm\', john, obj, [\'foo\', \'bar\'])\n-          (\'john\', \'42!\', (\'foo\', \'bar\'))\n-\n-        Now let\'s check if the results of a call to `checkLocalRolesAllowed`\n-        is indeed cached, i.e. is the request was annotated correctly.  First\n-        try to log the method invocation, though.  As monkey patching in\n-        something between the original method and the already applied cache\n-        decorator is tricky, we abuse `_get_userfolder`, which is called\n-        first thing in `checkLocalRolesAllowed`:\n-\n-          >>> original = rm._get_userfolder\n-          >>> def logger(self, *args, **kw):\n-          ...     print(\'checkLocalRolesAllowed called...\')\n-          ...     return original(self, *args, **kw)\n-          >>> rm._get_userfolder = logger\n-\n-          >>> print(rm.checkLocalRolesAllowed(john, obj, [\'foo\', \'bar\']))\n-          checkLocalRolesAllowed called...\n-          None\n-          >>> [i for i in IAnnotations(request)]\n-          ["borg.localrole.workspace.checkLocalRolesAllowed:(\'john\', \'42!\', (\'foo\', \'bar\'))"]\n-\n-        Calling the method a second time should directly return the cached\n-        value, i.e. the logger shouldn\'t print anything:\n-\n-          >>> print(rm.checkLocalRolesAllowed(john, obj, [\'foo\', \'bar\']))\n-          None\n+    """The cache key needs to include all arguments when caching allowed\n+    local roles, but the key function also needs to decide whether\n+    `volatile.cache` can cache or not by checking if it\'s possible to\n+    get a request instance from the object.\n+\n+    To test we\'ll nee an adaptable object, a user and the method which\n+    results\' we\'d like to cache:\n+\n+      >>> from zope.interface import implementer, Interface\n+      >>> @implementer(Interface)\n+      ... class DummyObject(object):\n+      ...     pass\n+      >>> obj = DummyObject()\n+\n+      >>> from borg.localrole.tests import DummyUser\n+      >>> john = DummyUser(\'john\')\n+\n+      >>> rm = WorkspaceLocalRoleManager(\'rm\', \'A Role Manager\')\n+      >>> fun = rm.__class__.checkLocalRolesAllowed\n+\n+    The dummy object doesn\'t have an acquired request, so no caching\n+    can be done:\n+\n+      >>> clra_cache_key(fun, \'me\', john, obj, [\'foo\', \'bar\'])\n+      Traceback (most recent call last):\n+      ...\n+      plone.memoize.volatile.DontCache\n+\n+    So let\'s add one and try again.  Before we also need to mark it as\n+    being annotatable, which normally happens elsewhere:\n+\n+      >>> from ZPublisher.HTTPRequest import HTTPRequest\n+      >>> request = HTTPRequest(\'\', dict(HTTP_HOST=\'nohost:8080\'), {})\n+\n+      >>> try:\n+      ...     from Zope2.App.zcml import load_config\n+      ... except ImportError:\n+      ...     from Products.Five.zcml import load_config\n+      >>> import zope.component\n+      >>> import zope.annotation\n+      >>> load_config(\'meta.zcml\', zope.component)\n+      >>> load_config(\'configure.zcml\', zope.annotation)\n+      >>> from zope.interface import classImplements\n+      >>> from zope.annotation.interfaces import IAttributeAnnotatable\n+      >>> classImplements(HTTPRequest, IAttributeAnnotatable)\n+\n+      >>> obj.REQUEST = request\n+      >>> clra_cache_key(fun, \'hmm\', john, obj, [\'foo\', \'bar\'])\n+      (\'john\', ..., (\'foo\', \'bar\'))\n+\n+    If the objects happens to have a `getPhysicalPath` method, that should\n+    be used instead of the hash:\n+\n+      >>> class DummyObjectWithPath(DummyObject):\n+      ...     def getPhysicalPath(self):\n+      ...         return \'42!\'\n+      >>> obj = DummyObjectWithPath()\n+      >>> obj.REQUEST = request\n+      >>> clra_cache_key(fun, \'hmm\', john, obj, [\'foo\', \'bar\'])\n+      (\'john\', \'42!\', (\'foo\', \'bar\'))\n+\n+    Now let\'s check if the results of a call to `checkLocalRolesAllowed`\n+    is indeed cached, i.e. is the request was annotated correctly.  First\n+    try to log the method invocation, though.  As monkey patching in\n+    something between the original method and the already applied cache\n+    decorator is tricky, we abuse `_get_userfolder`, which is called\n+    first thing in `checkLocalRolesAllowed`:\n+\n+      >>> original = rm._get_userfolder\n+      >>> def logger(self, *args, **kw):\n+      ...     print(\'checkLocalRolesAllowed called...\')\n+      ...     return original(self, *args, **kw)\n+      >>> rm._get_userfolder = logger\n+\n+      >>> print(rm.checkLocalRolesAllowed(john, obj, [\'foo\', \'bar\']))\n+      checkLocalRolesAllowed called...\n+      None\n+      >>> [i for i in IAnnotations(request)]\n+      ["borg.localrole.workspace.checkLocalRolesAllowed:(\'john\', \'42!\', (\'foo\', \'bar\'))"]\n+\n+    Calling the method a second time should directly return the cached\n+    value, i.e. the logger shouldn\'t print anything:\n+\n+      >>> print(rm.checkLocalRolesAllowed(john, obj, [\'foo\', \'bar\']))\n+      None\n \n     """  # noqa: E501\n-    request = aq_get(obj, \'REQUEST\', None)\n+    request = aq_get(obj, "REQUEST", None)\n     if IAnnotations(request, None) is None:\n         raise DontCache\n     try:\n@@ -145,235 +141,236 @@ def clra_cache_key(method, self, user, obj, object_roles):\n \n \n def store_on_request(method, self, user, obj, object_roles):\n-    """ helper for caching local roles on the request """\n-    return IAnnotations(aq_get(obj, \'REQUEST\'))\n+    """helper for caching local roles on the request"""\n+    return IAnnotations(aq_get(obj, "REQUEST"))\n \n \n class WorkspaceLocalRoleManager(BasePlugin):\n     """This is the actual plug-in. It takes care of looking up\n-    ILocalRolesProvider adapters (when available) and granting local roles\n-    appropriately.\n-\n-    First we need to make and register an adapter to provide some roles::\n-\n-        >>> from zope.interface import implementer, Interface\n-        >>> from zope.component import adapter\n-        >>> from borg.localrole.tests import SimpleLocalRoleProvider\n-        >>> from borg.localrole.tests import DummyUser\n-        >>> from zope.component import provideAdapter\n-        >>> provideAdapter(SimpleLocalRoleProvider, adapts=(Interface,))\n-\n-\n-    We need an object to adapt, we require nothing of this object,\n-    except it must be adaptable (e.g. have an interface)::\n-\n-        >>> @implementer(Interface)\n-        ... class DummyObject(object):\n-        ...     pass\n-        >>> ob = DummyObject()\n-\n-    And we need some users that we\'ll check the permissions of::\n-\n-        >>> user1 = DummyUser(\'bogus_user\')\n-        >>> user2 = DummyUser(\'bogus_user2\')\n-\n-    Now we\'re ready to make one of our RoleManagers and try it out.\n-    First we\'ll verify that our users have the \'Foo\' role, then we\'ll\n-    make sure they can access objects which require that role, but not\n-    others::\n-\n-        >>> rm = WorkspaceLocalRoleManager(\'rm\', \'A Role Manager\')\n-        >>> rm.getRolesInContext(user1, ob)\n-        [\'Foo\']\n-        >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Foo\', \'Baz\'])\n-        1\n-        >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Baz\']) is None\n-        True\n-        >>> rm.getAllLocalRolesInContext(ob)\n-        {\'bogus_user\': {\'Foo\'}}\n-\n-\n-    Multiple Role Providers\n-    -----------------------\n-\n-    It is a bit more interesting when we have more than one adapter\n-    registered.  We register it with a name so that it supplements,\n-    rather than conflict with or override the existing adapter::\n-\n-        >>> class LessSimpleLocalRoleProvider(SimpleLocalRoleProvider):\n-        ...     userid = \'bogus_user2\'\n-        ...     roles = (\'Foo\', \'Baz\')\n-        ...     def getRoles(self, userid):\n-        ...         \'\'\'Grant bogus_user2 the \'Foo\' and \'Baz\' roles\'\'\'\n-        ...         if userid == self.userid:\n-        ...             return self.roles\n-        ...         return ()\n-        ...\n-        ...     def getAllRoles(self):\n-        ...         yield (self.userid, self.roles)\n-\n-        >>> provideAdapter(LessSimpleLocalRoleProvider, adapts=(Interface,),\n-        ...                name=\'adapter2\')\n-\n-   This should have no effect on our first user::\n-\n-        >>> rm.getRolesInContext(user1, ob)\n-        [\'Foo\']\n-        >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Foo\', \'Baz\'])\n-        1\n-        >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Baz\']) is None\n-        True\n-        >>> expected = {\'bogus_user\': {\'Foo\'}, \'bogus_user2\': {\'Foo\', \'Baz\'}}\n-        >>> rm.getAllLocalRolesInContext(ob) == expected\n-        True\n-\n-    But our second user notices the change, note that even though two\n-    of our local role providers grant the role \'Foo\', it is not duplicated::\n-\n-        >>> set(rm.getRolesInContext(user2, ob)) == {\'Foo\', \'Baz\'}\n-        True\n-        >>> rm.checkLocalRolesAllowed(user2, ob, [\'Bar\', \'Foo\', \'Baz\'])\n-        1\n-        >>> rm.checkLocalRolesAllowed(user2, ob, [\'Bar\', \'Baz\'])\n-        1\n-        >>> rm.checkLocalRolesAllowed(user2, ob, [\'Bar\']) is None\n-        True\n-\n-\n-    Role Acquisition and Blocking\n-    -----------------------------\n-\n-    This plugin will acquire role definitions from parent objects,\n-    unless explicitly blocked.  To test this, we need some objects\n-    which support acquisition::\n-\n-        >>> from Acquisition import Implicit\n-        >>> class DummyImplicit(DummyObject, Implicit):\n-        ...     def stupid_method(self):\n-        ...         return 1\n-        >>> root = DummyImplicit()\n-        >>> next = DummyImplicit().__of__(root)\n-        >>> last = DummyImplicit().__of__(next)\n-        >>> other = DummyImplicit().__of__(root)\n-\n-    So we now have /root/next/last and /root/other, we\'ll create and\n-    register special adapters for our next and other objects.\n-\n-        >>> class ISpecial1(Interface):\n-        ...     pass\n-        >>> class ISpecial2(Interface):\n-        ...     pass\n-        >>> from zope.interface import directlyProvides\n-        >>> directlyProvides(next, ISpecial1)\n-        >>> directlyProvides(other, ISpecial2)\n-        >>> @adapter(ISpecial1)\n-        ... class Adapter1(LessSimpleLocalRoleProvider):\n-        ...\n-        ...     userid = \'bogus_user\'\n-        ...     roles = (\'Bar\',)\n-        >>> @adapter(ISpecial2)\n-        ... class Adapter2(LessSimpleLocalRoleProvider):\n-        ...\n-        ...     userid = \'bogus_user3\'\n-        ...     roles = (\'Foobar\',)\n-        >>> user3 = DummyUser(\'bogus_user3\')\n-\n-    We\'ll register these to override the existing unnamed adapter:\n-\n-        >>> provideAdapter(Adapter1)\n-        >>> provideAdapter(Adapter2)\n-\n-    Now we can show how acquisition of roles works, first we look at the\n-    \'last\' item, which should have roles provided by\n-    SimpleLocalRoleProvider, and LessSimpleLocalRoleProvider, as well\n-    as acquired from Adapter1 on \'next\':\n-\n-        >>> set(rm.getRolesInContext(user1, last)) == {\'Foo\', \'Bar\'}\n-        True\n-\n-        >>> set(rm.getRolesInContext(user2, last)) == {\'Foo\', \'Baz\'}\n-        True\n-\n-    If we look at the parent, we get the same results, because the\n-    SimpleLocalRoleProvider adapter also applies to the \'root\'\n-    object. However, if we enable local role blocking on \'next\' we\n-    won\'t see the roles from the \'root\'::\n-\n-        >>> set(rm.getRolesInContext(user1, next)) == {\'Foo\', \'Bar\'}\n-        True\n-        >>> next.__ac_local_roles_block__ = True\n-        >>> rm.getRolesInContext(user1, next)\n-        [\'Bar\']\n-\n-    The checkLocalRolesAllowed and getAllLocalRolesInContext methods\n-    take acquisition and blocking into account as well::\n-\n-        >>> rm.checkLocalRolesAllowed(user1, last,  [\'Bar\'])\n-        1\n-        >>> rm.checkLocalRolesAllowed(user1, next,  [\'Foo\', \'Baz\']) is None\n-        True\n-        >>> expected = {\'bogus_user\': {\'Foo\', \'Bar\'}, \'bogus_user2\': {\'Foo\', \'Baz\'}}\n-        >>> rm.getAllLocalRolesInContext(last) == expected\n-        True\n-\n-    It\'s important to note, that roles are acquired only by\n-    containment.  Additional wrapping cannot change the security on an\n-    object.  For example if we were to wrap \'last\' in the context of\n-    other, which provides a special role for \'user3\', we should see no\n-    effect::\n-\n-        >>> rm.getRolesInContext(user3, last)\n-        [\'Foo\']\n-        >>> set(rm.getRolesInContext(user3, other)) == {\'Foobar\', \'Foo\'}\n-        True\n-        >>> rm.getRolesInContext(user3, last.__of__(other))\n-        [\'Foo\']\n-\n-    It\'s also important that methods of objects yield the same local\n-    roles as the objects would\n-\n-        >>> set(rm.getRolesInContext(user3, other.stupid_method)) == {\'Foobar\', \'Foo\'}\n-        True\n-\n-    Group Support\n-    -------------\n-\n-    This plugin also handles roles granted to user groups, calling up\n-    the adapters to get roles for any groups the user might belong\n-    to::\n-\n-        >>> user4 = DummyUser(\'bogus_user4\', (\'Group1\', \'Group2\'))\n-        >>> user4.getGroups()\n-        (\'Group1\', \'Group2\')\n-        >>> rm.getRolesInContext(user4, last)\n-        [\'Foo\']\n-        >>> class Adapter3(LessSimpleLocalRoleProvider):\n-        ...     userid = \'Group2\'\n-        ...     roles = (\'Foobar\',)\n-\n-        >>> provideAdapter(Adapter3, adapts=(Interface,), name=\'group_adapter\')\n-        >>> set(rm.getRolesInContext(user4, last)) == {\'Foobar\', \'Foo\'}\n-        True\n-\n-\n-    Wrong User Folder\n-    -----------------\n-\n-    Finally, to ensure full test coverage, we provide a user object\n-    which pretends to be wrapped in such a way that the user folder\n-    does not recognize it.  We check that it always gets an empty set\n-    of roles and a special 0 value when checking access::\n-\n-        >>> class BadUser(DummyUser):\n-        ...     def _check_context(self, obj):\n-        ...         return False\n-        >>> bad_user = BadUser(\'bad_user\')\n-        >>> rm.getRolesInContext(bad_user, ob)\n-        []\n-        >>> rm.checkLocalRolesAllowed(bad_user, ob, [\'Bar\', \'Foo\', \'Baz\'])\n-        0\n+     ILocalRolesProvider adapters (when available) and granting local roles\n+     appropriately.\n+\n+     First we need to make and register an adapter to provide some roles::\n+\n+         >>> from zope.interface import implementer, Interface\n+         >>> from zope.component import adapter\n+         >>> from borg.localrole.tests import SimpleLocalRoleProvider\n+         >>> from borg.localrole.tests import DummyUser\n+         >>> from zope.component import provideAdapter\n+         >>> provideAdapter(SimpleLocalRoleProvider, adapts=(Interface,))\n+\n+\n+     We need an object to adapt, we require nothing of this object,\n+     except it must be adaptable (e.g. have an interface)::\n+\n+         >>> @implementer(Interface)\n+         ... class DummyObject(object):\n+         ...     pass\n+         >>> ob = DummyObject()\n+\n+     And we need some users that we\'ll check the permissions of::\n+\n+         >>> user1 = DummyUser(\'bogus_user\')\n+         >>> user2 = DummyUser(\'bogus_user2\')\n+\n+     Now we\'re ready to make one of our RoleManagers and try it out.\n+     First we\'ll verify that our users have the \'Foo\' role, then we\'ll\n+     make sure they can access objects which require that role, but not\n+     others::\n+\n+         >>> rm = WorkspaceLocalRoleManager(\'rm\', \'A Role Manager\')\n+         >>> rm.getRolesInContext(user1, ob)\n+         [\'Foo\']\n+         >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Foo\', \'Baz\'])\n+         1\n+         >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Baz\']) is None\n+         True\n+         >>> rm.getAllLocalRolesInContext(ob)\n+         {\'bogus_user\': {\'Foo\'}}\n+\n+\n+     Multiple Role Providers\n+     -----------------------\n+\n+     It is a bit more interesting when we have more than one adapter\n+     registered.  We register it with a name so that it supplements,\n+     rather than conflict with or override the existing adapter::\n+\n+         >>> class LessSimpleLocalRoleProvider(SimpleLocalRoleProvider):\n+         ...     userid = \'bogus_user2\'\n+         ...     roles = (\'Foo\', \'Baz\')\n+         ...     def getRoles(self, userid):\n+         ...         \'\'\'Grant bogus_user2 the \'Foo\' and \'Baz\' roles\'\'\'\n+         ...         if userid == self.userid:\n+         ...             return self.roles\n+         ...         return ()\n+         ...\n+         ...     def getAllRoles(self):\n+         ...         yield (self.userid, self.roles)\n+\n+         >>> provideAdapter(LessSimpleLocalRoleProvider, adapts=(Interface,),\n+         ...                name=\'adapter2\')\n+\n+    This should have no effect on our first user::\n+\n+         >>> rm.getRolesInContext(user1, ob)\n+         [\'Foo\']\n+         >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Foo\', \'Baz\'])\n+         1\n+         >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Baz\']) is None\n+         True\n+         >>> expected = {\'bogus_user\': {\'Foo\'}, \'bogus_user2\': {\'Foo\', \'Baz\'}}\n+         >>> rm.getAllLocalRolesInContext(ob) == expected\n+         True\n+\n+     But our second user notices the change, note that even though two\n+     of our local role providers grant the role \'Foo\', it is not duplicated::\n+\n+         >>> set(rm.getRolesInContext(user2, ob)) == {\'Foo\', \'Baz\'}\n+         True\n+         >>> rm.checkLocalRolesAllowed(user2, ob, [\'Bar\', \'Foo\', \'Baz\'])\n+         1\n+         >>> rm.checkLocalRolesAllowed(user2, ob, [\'Bar\', \'Baz\'])\n+         1\n+         >>> rm.checkLocalRolesAllowed(user2, ob, [\'Bar\']) is None\n+         True\n+\n+\n+     Role Acquisition and Blocking\n+     -----------------------------\n+\n+     This plugin will acquire role definitions from parent objects,\n+     unless explicitly blocked.  To test this, we need some objects\n+     which support acquisition::\n+\n+         >>> from Acquisition import Implicit\n+         >>> class DummyImplicit(DummyObject, Implicit):\n+         ...     def stupid_method(self):\n+         ...         return 1\n+         >>> root = DummyImplicit()\n+         >>> next = DummyImplicit().__of__(root)\n+         >>> last = DummyImplicit().__of__(next)\n+         >>> other = DummyImplicit().__of__(root)\n+\n+     So we now have /root/next/last and /root/other, we\'ll create and\n+     register special adapters for our next and other objects.\n+\n+         >>> class ISpecial1(Interface):\n+         ...     pass\n+         >>> class ISpecial2(Interface):\n+         ...     pass\n+         >>> from zope.interface import directlyProvides\n+         >>> directlyProvides(next, ISpecial1)\n+         >>> directlyProvides(other, ISpecial2)\n+         >>> @adapter(ISpecial1)\n+         ... class Adapter1(LessSimpleLocalRoleProvider):\n+         ...\n+         ...     userid = \'bogus_user\'\n+         ...     roles = (\'Bar\',)\n+         >>> @adapter(ISpecial2)\n+         ... class Adapter2(LessSimpleLocalRoleProvider):\n+         ...\n+         ...     userid = \'bogus_user3\'\n+         ...     roles = (\'Foobar\',)\n+         >>> user3 = DummyUser(\'bogus_user3\')\n+\n+     We\'ll register these to override the existing unnamed adapter:\n+\n+         >>> provideAdapter(Adapter1)\n+         >>> provideAdapter(Adapter2)\n+\n+     Now we can show how acquisition of roles works, first we look at the\n+     \'last\' item, which should have roles provided by\n+     SimpleLocalRoleProvider, and LessSimpleLocalRoleProvider, as well\n+     as acquired from Adapter1 on \'next\':\n+\n+         >>> set(rm.getRolesInContext(user1, last)) == {\'Foo\', \'Bar\'}\n+         True\n+\n+         >>> set(rm.getRolesInContext(user2, last)) == {\'Foo\', \'Baz\'}\n+         True\n+\n+     If we look at the parent, we get the same results, because the\n+     SimpleLocalRoleProvider adapter also applies to the \'root\'\n+     object. However, if we enable local role blocking on \'next\' we\n+     won\'t see the roles from the \'root\'::\n+\n+         >>> set(rm.getRolesInContext(user1, next)) == {\'Foo\', \'Bar\'}\n+         True\n+         >>> next.__ac_local_roles_block__ = True\n+         >>> rm.getRolesInContext(user1, next)\n+         [\'Bar\']\n+\n+     The checkLocalRolesAllowed and getAllLocalRolesInContext methods\n+     take acquisition and blocking into account as well::\n+\n+         >>> rm.checkLocalRolesAllowed(user1, last,  [\'Bar\'])\n+         1\n+         >>> rm.checkLocalRolesAllowed(user1, next,  [\'Foo\', \'Baz\']) is None\n+         True\n+         >>> expected = {\'bogus_user\': {\'Foo\', \'Bar\'}, \'bogus_user2\': {\'Foo\', \'Baz\'}}\n+         >>> rm.getAllLocalRolesInContext(last) == expected\n+         True\n+\n+     It\'s important to note, that roles are acquired only by\n+     containment.  Additional wrapping cannot change the security on an\n+     object.  For example if we were to wrap \'last\' in the context of\n+     other, which provides a special role for \'user3\', we should see no\n+     effect::\n+\n+         >>> rm.getRolesInContext(user3, last)\n+         [\'Foo\']\n+         >>> set(rm.getRolesInContext(user3, other)) == {\'Foobar\', \'Foo\'}\n+         True\n+         >>> rm.getRolesInContext(user3, last.__of__(other))\n+         [\'Foo\']\n+\n+     It\'s also important that methods of objects yield the same local\n+     roles as the objects would\n+\n+         >>> set(rm.getRolesInContext(user3, other.stupid_method)) == {\'Foobar\', \'Foo\'}\n+         True\n+\n+     Group Support\n+     -------------\n+\n+     This plugin also handles roles granted to user groups, calling up\n+     the adapters to get roles for any groups the user might belong\n+     to::\n+\n+         >>> user4 = DummyUser(\'bogus_user4\', (\'Group1\', \'Group2\'))\n+         >>> user4.getGroups()\n+         (\'Group1\', \'Group2\')\n+         >>> rm.getRolesInContext(user4, last)\n+         [\'Foo\']\n+         >>> class Adapter3(LessSimpleLocalRoleProvider):\n+         ...     userid = \'Group2\'\n+         ...     roles = (\'Foobar\',)\n+\n+         >>> provideAdapter(Adapter3, adapts=(Interface,), name=\'group_adapter\')\n+         >>> set(rm.getRolesInContext(user4, last)) == {\'Foobar\', \'Foo\'}\n+         True\n+\n+\n+     Wrong User Folder\n+     -----------------\n+\n+     Finally, to ensure full test coverage, we provide a user object\n+     which pretends to be wrapped in such a way that the user folder\n+     does not recognize it.  We check that it always gets an empty set\n+     of roles and a special 0 value when checking access::\n+\n+         >>> class BadUser(DummyUser):\n+         ...     def _check_context(self, obj):\n+         ...         return False\n+         >>> bad_user = BadUser(\'bad_user\')\n+         >>> rm.getRolesInContext(bad_user, ob)\n+         []\n+         >>> rm.checkLocalRolesAllowed(bad_user, ob, [\'Bar\', \'Foo\', \'Baz\'])\n+         0\n \n     """\n+\n     meta_type = "Workspace Roles Manager"\n     security = ClassSecurityInfo()\n \n@@ -386,19 +383,20 @@ def _get_userfolder(user, obj):\n         need to rewrap"""\n         context = user\n         while context is not None:\n-            if hasattr(context, \'getId\'):\n-                if context.getId() == \'acl_users\':\n+            if hasattr(context, "getId"):\n+                if context.getId() == "acl_users":\n                     break\n             context = aq_parent(aq_inner(context))\n         else:\n             return None\n         return aq_inner(context)\n+\n     #\n     # ILocalRolesPlugin implementation\n     #\n \n     def _getAdapters(self, obj):\n-        adapters = getAdapters((obj, ), ILocalRoleProvider)\n+        adapters = getAdapters((obj,), ILocalRoleProvider)\n         # this is sequence of tuples of the form (name, adapter),\n         # we don\'t really care about the names\n         return (a[1] for a in adapters)\n@@ -408,11 +406,11 @@ def _parent_chain(self, obj):\n         local role blocker"""\n         while obj is not None:\n             yield obj\n-            if getattr(obj, \'__ac_local_roles_block__\', None):\n+            if getattr(obj, "__ac_local_roles_block__", None):\n                 return\n             new = aq_parent(aq_inner(obj))\n             # if the obj is a method we get the class\n-            obj = getattr(obj, \'__self__\', new)\n+            obj = getattr(obj, "__self__", new)\n \n     def _get_principal_ids(self, user):\n         """Returns a list of the ids of all involved security\n@@ -442,16 +440,11 @@ def getRolesInContext(self, user, object):\n                         roles.update(a.getRoles(pid))\n                 # XXX: BBB code, kicks in only if there\'s no proper adapter\n                 if count == -1:\n-                    workspace = IGroupAwareWorkspace(\n-                        obj,\n-                        IWorkspace(obj, None)\n-                    )\n+                    workspace = IGroupAwareWorkspace(obj, IWorkspace(obj, None))\n                     if workspace is not None:\n                         roles.update(workspace.getLocalRolesForPrincipal(user))\n                         for group in self._groups(obj, user, workspace):\n-                            roles.update(\n-                                workspace.getLocalRolesForPrincipal(group)\n-                            )\n+                            roles.update(workspace.getLocalRolesForPrincipal(group))\n         return list(roles)\n \n     @security.private\n@@ -512,6 +505,7 @@ def getAllLocalRolesInContext(self, object):\n                     rolemap.update(workspace.getLocalRoles())\n \n         return rolemap\n+\n     # XXX: for BBB only\n \n     @security.private\n@@ -520,7 +514,7 @@ def _groups(self, obj, user, workspace):\n         a getGroups() method, yield each group_id returned by that method.\n         """\n         if IGroupAwareWorkspace.providedBy(workspace):\n-            getGroups = getattr(user, \'getGroups\', None)\n+            getGroups = getattr(user, "getGroups", None)\n             if getGroups is not None:\n                 acl_users = aq_parent(aq_inner(self))\n                 for group_id in getGroups():\ndiff --git a/setup.py b/setup.py\nindex 26a4d9e..a7f13ec 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -2,69 +2,69 @@\n from setuptools import setup\n \n \n-name = \'borg.localrole\'\n-version = \'3.1.10.dev0\'\n+name = "borg.localrole"\n+version = "3.1.10.dev0"\n \n-readme = open(\'README.rst\').read()\n-history = open(\'CHANGES.rst\').read()\n+readme = open("README.rst").read()\n+history = open("CHANGES.rst").read()\n \n setup(\n     name=name,\n     version=version,\n-    description=\'A PAS plugin which can manage local roles via an \'\n-                \'adapter lookup on the current context\',\n-    long_description=readme + \'\\n\' + history,\n-    keywords=\'Plone PAS local roles\',\n-    author=\'Borg Collective\',\n-    author_email=\'borg@plone.org\',\n-    url=\'https://pypi.org/project/borg.localrole\',\n-    license=\'LGPL\',\n+    description="A PAS plugin which can manage local roles via an "\n+    "adapter lookup on the current context",\n+    long_description=readme + "\\n" + history,\n+    keywords="Plone PAS local roles",\n+    author="Borg Collective",\n+    author_email="borg@plone.org",\n+    url="https://pypi.org/project/borg.localrole",\n+    license="LGPL",\n     packages=find_packages(),\n-    namespace_packages=[\'borg\'],\n+    namespace_packages=["borg"],\n     include_package_data=True,\n-    platforms=\'Any\',\n+    platforms="Any",\n     zip_safe=False,\n     extras_require=dict(\n         test=[\n-            \'plone.app.testing\',\n+            "plone.app.testing",\n         ],\n     ),\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'zope.annotation\',\n-        \'zope.component\',\n-        \'zope.deferredimport\',\n-        \'zope.interface\',\n-        \'Products.CMFCore\',\n-        \'Products.GenericSetup\',\n-        \'Products.PlonePAS >= 5.0.1\',\n-        \'Products.PluggableAuthService\',\n-        \'plone.memoize\',\n-        \'Acquisition\',\n+        "setuptools",\n+        "six",\n+        "zope.annotation",\n+        "zope.component",\n+        "zope.deferredimport",\n+        "zope.interface",\n+        "Products.CMFCore",\n+        "Products.GenericSetup",\n+        "Products.PlonePAS >= 5.0.1",\n+        "Products.PluggableAuthService",\n+        "plone.memoize",\n+        "Acquisition",\n         "Zope2;python_version<\'3\'",\n         "Zope;python_version>=\'3.6\'",\n     ],\n     classifiers=[\n-        \'Development Status :: 5 - Production/Stable\',\n-        \'Environment :: Web Environment\',\n-        \'Framework :: Plone\',\n-        \'Framework :: Plone :: 5.0\',\n-        \'Framework :: Plone :: 5.1\',\n-        \'Framework :: Plone :: 5.2\',\n-        \'Framework :: Plone :: Core\',\n-        \'Intended Audience :: Other Audience\',\n-        \'Intended Audience :: System Administrators\',\n-        \'License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)\',  # noqa\n-        \'Operating System :: OS Independent\',\n-        \'Programming Language :: Python\',\n-        \'Programming Language :: Python :: 2.7\',\n-        \'Programming Language :: Python :: 3.6\',\n-        \'Programming Language :: Python :: 3.7\',\n-        \'Programming Language :: Python :: 3.8\',\n-        \'Programming Language :: Python :: 3.9\',\n-        \'Programming Language :: Python :: 3.10\',\n-        \'Programming Language :: Python :: 3.11\',\n-        \'Topic :: Software Development :: Libraries :: Python Modules\',\n+        "Development Status :: 5 - Production/Stable",\n+        "Environment :: Web Environment",\n+        "Framework :: Plone",\n+        "Framework :: Plone :: 5.0",\n+        "Framework :: Plone :: 5.1",\n+        "Framework :: Plone :: 5.2",\n+        "Framework :: Plone :: Core",\n+        "Intended Audience :: Other Audience",\n+        "Intended Audience :: System Administrators",\n+        "License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)",  # noqa\n+        "Operating System :: OS Independent",\n+        "Programming Language :: Python",\n+        "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.6",\n+        "Programming Language :: Python :: 3.7",\n+        "Programming Language :: Python :: 3.8",\n+        "Programming Language :: Python :: 3.9",\n+        "Programming Language :: Python :: 3.10",\n+        "Programming Language :: Python :: 3.11",\n+        "Topic :: Software Development :: Libraries :: Python Modules",\n     ],\n )\n'

Repository: borg.localrole


Branch: refs/heads/master
Date: 2023-02-08T18:10:47+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/borg.localrole/commit/6d7a090f69985925d0c6277e0239828f26477dc7

chore: zpretty

Files changed:
M borg/localrole/configure.zcml
M borg/localrole/default.zcml
M borg/localrole/exportimport.zcml
M borg/localrole/profiles/default/import_steps.xml

b'diff --git a/borg/localrole/configure.zcml b/borg/localrole/configure.zcml\nindex fdff392..84dff78 100644\n--- a/borg/localrole/configure.zcml\n+++ b/borg/localrole/configure.zcml\n@@ -1,33 +1,40 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    xmlns:zcml="http://namespaces.zope.org/zcml"\n     xmlns:five="http://namespaces.zope.org/five"\n     xmlns:genericsetup="http://namespaces.zope.org/genericsetup"\n-    i18n_domain="borg.localrole">\n+    xmlns:zcml="http://namespaces.zope.org/zcml"\n+    i18n_domain="borg.localrole"\n+    >\n \n-    <five:registerPackage package="." initialize=".initialize" />\n+  <five:registerPackage\n+      package="."\n+      initialize=".initialize"\n+      />\n \n-    <!-- Register GenericSetup profile used for installation -->\n-    <genericsetup:registerProfile\n-        name="default"\n-        title="b-org local role plug-in"\n-        directory="profiles/default"\n-        description="This is a PAS plug-in that makes it easy to determine local roles via an adapter lookup"\n-        provides="Products.GenericSetup.interfaces.EXTENSION"\n-        />\n+  <!-- Register GenericSetup profile used for installation -->\n+  <genericsetup:registerProfile\n+      name="default"\n+      title="b-org local role plug-in"\n+      description="This is a PAS plug-in that makes it easy to determine local roles via an adapter lookup"\n+      provides="Products.GenericSetup.interfaces.EXTENSION"\n+      directory="profiles/default"\n+      />\n \n-    <!-- Installs the Factory Tool adapter if Plone is installed -->\n-    <class class="Products.ATContentTypes.tool.factory.TempFolder"\n-           zcml:condition="installed Products.ATContentTypes">\n-      <implements interface=".interfaces.IFactoryTempFolder" />\n-    </class>\n+  <!-- Installs the Factory Tool adapter if Plone is installed -->\n+  <class\n+      class="Products.ATContentTypes.tool.factory.TempFolder"\n+      zcml:condition="installed Products.ATContentTypes"\n+      >\n+    <implements interface=".interfaces.IFactoryTempFolder" />\n+  </class>\n \n-    <adapter zcml:condition="installed Products.ATContentTypes"\n-             factory=".factory_adapter.FactoryTempFolderProvider"\n-             />\n+  <adapter\n+      factory=".factory_adapter.FactoryTempFolderProvider"\n+      zcml:condition="installed Products.ATContentTypes"\n+      />\n \n-    <include file="exportimport.zcml" />\n+  <include file="exportimport.zcml" />\n \n-    <include package="plone.memoize" />\n+  <include package="plone.memoize" />\n \n </configure>\ndiff --git a/borg/localrole/default.zcml b/borg/localrole/default.zcml\nindex 1c720d8..ff8608f 100644\n--- a/borg/localrole/default.zcml\n+++ b/borg/localrole/default.zcml\n@@ -1,6 +1,7 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    xmlns:zcml="http://namespaces.zope.org/zcml">\n+    xmlns:zcml="http://namespaces.zope.org/zcml"\n+    >\n \n   <adapter\n       factory=".default_adapter.DefaultLocalRoleAdapter"\ndiff --git a/borg/localrole/exportimport.zcml b/borg/localrole/exportimport.zcml\nindex a61ab5a..feb1dd9 100644\n--- a/borg/localrole/exportimport.zcml\n+++ b/borg/localrole/exportimport.zcml\n@@ -5,14 +5,15 @@\n            the \'for\' value -->\n \n   <adapter\n-     factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"\n-     provides="Products.GenericSetup.interfaces.IFilesystemExporter"\n-     for="borg.localrole.workspace.WorkspaceLocalRoleManager" />\n+      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"\n+      provides="Products.GenericSetup.interfaces.IFilesystemExporter"\n+      for="borg.localrole.workspace.WorkspaceLocalRoleManager"\n+      />\n \n   <adapter\n-     factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"\n-     provides="Products.GenericSetup.interfaces.IFilesystemImporter"\n-     for="borg.localrole.workspace.WorkspaceLocalRoleManager"\n-     />\n+      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"\n+      provides="Products.GenericSetup.interfaces.IFilesystemImporter"\n+      for="borg.localrole.workspace.WorkspaceLocalRoleManager"\n+      />\n \n </configure>\ndiff --git a/borg/localrole/profiles/default/import_steps.xml b/borg/localrole/profiles/default/import_steps.xml\nindex ae05212..b32c8c6 100644\n--- a/borg/localrole/profiles/default/import_steps.xml\n+++ b/borg/localrole/profiles/default/import_steps.xml\n@@ -1,7 +1,9 @@\n-<?xml version="1.0"?>\n+<?xml version="1.0" encoding="utf-8"?>\n <import-steps>\n-  <import-step id="borg_localrole_various" version="20071003-01"\n+  <import-step id="borg_localrole_various"\n                handler="borg.localrole.setuphandlers.importVarious"\n-               title="borg.localrole plug-in installation">\n- </import-step>\n+               title="borg.localrole plug-in installation"\n+               version="20071003-01"\n+  >\n+</import-step>\n </import-steps>\n'

Repository: borg.localrole


Branch: refs/heads/master
Date: 2023-02-08T18:10:47+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/borg.localrole/commit/6c518a1a8636cf8ede7f0c99d0037169059e8c53

chore: codespell typos

Files changed:
M borg/localrole/bbb/interfaces.py

b'diff --git a/borg/localrole/bbb/interfaces.py b/borg/localrole/bbb/interfaces.py\nindex 86747ce..20120da 100644\n--- a/borg/localrole/bbb/interfaces.py\n+++ b/borg/localrole/bbb/interfaces.py\n@@ -17,7 +17,7 @@ def getLocalRolesForPrincipal(principal):\n         """Return a sequence of all local roles for a principal."""\n \n     def getLocalRoles():\n-        """Return a dictonary mapping principals to their roles within\n+        """Return a dictionary mapping principals to their roles within\n         a workspace.\n         """\n \n'

Repository: borg.localrole


Branch: refs/heads/master
Date: 2023-02-08T18:10:47+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/borg.localrole/commit/67826ff3cd6e199bbcb0ae7f15183323e35406d6

chore: flake8

Files changed:
M borg/localrole/default_adapter.py

b'diff --git a/borg/localrole/default_adapter.py b/borg/localrole/default_adapter.py\nindex 9edda13..7ddd0d8 100644\n--- a/borg/localrole/default_adapter.py\n+++ b/borg/localrole/default_adapter.py\n@@ -3,8 +3,6 @@\n from zope.interface import implementer\n from zope.interface import Interface\n \n-import six\n-\n \n @implementer(ILocalRoleProvider)\n @adapter(Interface)\n'

Repository: borg.localrole


Branch: refs/heads/master
Date: 2023-02-08T18:10:47+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/borg.localrole/commit/4a83ae9c81527bfa0c7f52509d3605a34a8d0204

chore: pyroma

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex a7f13ec..0320855 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -24,6 +24,7 @@\n     include_package_data=True,\n     platforms="Any",\n     zip_safe=False,\n+    python_requires=">=3.8",\n     extras_require=dict(\n         test=[\n             "plone.app.testing",\n'

Repository: borg.localrole


Branch: refs/heads/master
Date: 2023-02-08T18:23:33+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/borg.localrole/commit/3becbbf9d9684b92be5ee0cb441d36ef317547a1

feat: fix dependencies

Files changed:
M .meta.toml
M borg/localrole/tests.py
M pyproject.toml
M setup.py

b'diff --git a/.meta.toml b/.meta.toml\nindex 2d5b403..642e0d7 100644\n--- a/.meta.toml\n+++ b/.meta.toml\n@@ -3,3 +3,8 @@\n [meta]\n template = "default"\n commit-id = "68486a87"\n+\n+[dependencies]\n+mappings = [\n+    "Zope = [\'Products.PageTemplates\', \'ZPublisher\', ]",\n+    ]\ndiff --git a/borg/localrole/tests.py b/borg/localrole/tests.py\nindex 1dab7bb..efaf773 100644\n--- a/borg/localrole/tests.py\n+++ b/borg/localrole/tests.py\n@@ -8,7 +8,6 @@\n import borg.localrole\n import doctest\n import re\n-import six\n import unittest\n \n \n@@ -45,14 +44,6 @@ def getRoles(self):\n         return ()\n \n \n-class Py23DocChecker(doctest.OutputChecker):\n-    def check_output(self, want, got, optionflags):\n-        if six.PY2:\n-            got = re.sub(r"set\\(\\[(.*?)\\]\\)", "{\\\\1}", got)\n-            want = re.sub("plone.memoize.volatile.DontCache", "DontCache", want)\n-        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n-\n-\n def test_suite():\n     suite = [\n         layered(\n@@ -67,7 +58,6 @@ def test_suite():\n             doctest.DocTestSuite(\n                 borg.localrole.workspace,\n                 optionflags=(doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE),\n-                checker=Py23DocChecker(),\n             ),\n             layer=zca.UNIT_TESTING,\n         ),\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 0f96c85..7ff4077 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -41,3 +41,6 @@ profile = "plone"\n \n [tool.black]\n target-version = ["py38"]\n+\n+[tool.dependencychecker]\n+Zope = [\'Products.PageTemplates\', \'ZPublisher\', ]\ndiff --git a/setup.py b/setup.py\nindex 0320855..e3ecec9 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -28,11 +28,12 @@\n     extras_require=dict(\n         test=[\n             "plone.app.testing",\n+            "plone.testing",\n         ],\n     ),\n     install_requires=[\n+        "AccessControl",\n         "setuptools",\n-        "six",\n         "zope.annotation",\n         "zope.component",\n         "zope.deferredimport",\n@@ -43,8 +44,7 @@\n         "Products.PluggableAuthService",\n         "plone.memoize",\n         "Acquisition",\n-        "Zope2;python_version<\'3\'",\n-        "Zope;python_version>=\'3.6\'",\n+        "Zope",\n     ],\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n'

Repository: borg.localrole


Branch: refs/heads/master
Date: 2023-02-08T18:23:37+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/borg.localrole/commit/0bcd3fe753698578cbf5bb1da759898e2c492c26

Add news entry

Files changed:
A news/1.bugfix

b'diff --git a/news/1.bugfix b/news/1.bugfix\nnew file mode 100644\nindex 0000000..e844e2b\n--- /dev/null\n+++ b/news/1.bugfix\n@@ -0,0 +1,2 @@\n+Add configuration with plone/meta.\n+[gforcada]\n'

Repository: borg.localrole


Branch: refs/heads/master
Date: 2023-02-08T21:47:12+01:00
Author: Gil Forcada Codinachs (gforcada) <gil.gnome@gmail.com>
Commit: https://github.com/plone/borg.localrole/commit/0c07151beecd64d465f15016ddb02911df9db59f

Use global workflow

Files changed:
D .github/workflows/linting.yml

b'diff --git a/.github/workflows/linting.yml b/.github/workflows/linting.yml\ndeleted file mode 100644\nindex 5ea3292..0000000\n--- a/.github/workflows/linting.yml\n+++ /dev/null\n@@ -1,39 +0,0 @@\n-# Generated from:\n-# https://github.com/plone/meta/tree/master/config/default\n-name: Linting\n-on:\n-  push:\n-    branches: [master]\n-  pull_request:\n-    branches: [master]\n-  workflow_dispatch:\n-\n-jobs:\n-  lint:\n-    name: Format and lint code\n-    runs-on: ${{ matrix.os }}\n-    strategy:\n-      matrix:\n-        python-version: ["3.8"]\n-        os: ["ubuntu-22.04"]\n-    steps:\n-      - uses: actions/checkout@v3\n-      - name: Set up Python\n-        uses: actions/setup-python@v4\n-        with:\n-          python-version: ${{ matrix.python-version }}\n-      - name: Cache packages\n-        uses: actions/cache@v3\n-        with:\n-          path: ~/.cache/pip\n-          key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles(\'lint-requirements.txt\', \'tox.ini\') }}\n-          restore-keys: |\n-            ${{ runner.os }}-pip-${{ matrix.python-version }}-\n-            ${{ runner.os }}-pip-\n-      - name: Install dependencies\n-        run: python -m pip install tox\n-      - name: Run formatters\n-        run: tox -e format\n-      # linters\n-      - name: QA\n-        run: tox -e lint\n'

Repository: borg.localrole


Branch: refs/heads/master
Date: 2023-02-09T02:02:18+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/borg.localrole/commit/bc294b71dfbd0c6a054df1c975a15d48ed854451

Merge pull request #14 from plone/config-with-default-template-2d21bb8c

Config with default template

Files changed:
A .editorconfig
A .meta.toml
A lint-requirements.txt
A news/1.bugfix
A tox.ini
M borg/__init__.py
M borg/localrole/__init__.py
M borg/localrole/bbb/__init__.py
M borg/localrole/bbb/interfaces.py
M borg/localrole/config.py
M borg/localrole/configure.zcml
M borg/localrole/default.zcml
M borg/localrole/default_adapter.py
M borg/localrole/exportimport.zcml
M borg/localrole/factory_adapter.py
M borg/localrole/interfaces.py
M borg/localrole/profiles/default/import_steps.xml
M borg/localrole/setuphandlers.py
M borg/localrole/tests.py
M borg/localrole/utils.py
M borg/localrole/workspace.py
M pyproject.toml
M setup.cfg
M setup.py

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..b4158b8\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,39 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..642e0d7\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,10 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[meta]\n+template = "default"\n+commit-id = "68486a87"\n+\n+[dependencies]\n+mappings = [\n+    "Zope = [\'Products.PageTemplates\', \'ZPublisher\', ]",\n+    ]\ndiff --git a/borg/__init__.py b/borg/__init__.py\nindex ab2575f..5284146 100644\n--- a/borg/__init__.py\n+++ b/borg/__init__.py\n@@ -1,8 +1 @@\n-# -*- coding: utf-8 -*-\n-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n-try:\n-    __import__(\'pkg_resources\').declare_namespace(__name__)\n-except ImportError:\n-    from pkgutil import extend_path\n-    __path__ = locals()[\'__path__\']  # make pyflakes happy...\n-    __path__ = extend_path(__path__, __name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/borg/localrole/__init__.py b/borg/localrole/__init__.py\nindex 70aa109..66dcaa4 100644\n--- a/borg/localrole/__init__.py\n+++ b/borg/localrole/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from AccessControl.Permissions import add_user_folders\n from borg.localrole import workspace\n from Products.PluggableAuthService import registerMultiPlugin\n@@ -17,5 +16,5 @@ def initialize(context):\n             workspace.manage_addWorkspaceLocalRoleManagerForm,\n             workspace.manage_addWorkspaceLocalRoleManager,\n         ),\n-        visibility=None\n+        visibility=None,\n     )\ndiff --git a/borg/localrole/bbb/__init__.py b/borg/localrole/bbb/__init__.py\nindex 40a96af..e69de29 100644\n--- a/borg/localrole/bbb/__init__.py\n+++ b/borg/localrole/bbb/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/borg/localrole/bbb/interfaces.py b/borg/localrole/bbb/interfaces.py\nindex 94969aa..20120da 100644\n--- a/borg/localrole/bbb/interfaces.py\n+++ b/borg/localrole/bbb/interfaces.py\n@@ -1,10 +1,10 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Interface\n \n \n # BBB: These interfaces will be removed in a later version of borg.locarole.\n # You should use the interfaces in borg.localrole.interfaces instead!\n \n+\n class IWorkspace(Interface):\n     """A workspace in which custom local roles are needed\n \n@@ -14,11 +14,10 @@ class IWorkspace(Interface):\n     """\n \n     def getLocalRolesForPrincipal(principal):\n-        """Return a sequence of all local roles for a principal.\n-        """\n+        """Return a sequence of all local roles for a principal."""\n \n     def getLocalRoles():\n-        """Return a dictonary mapping principals to their roles within\n+        """Return a dictionary mapping principals to their roles within\n         a workspace.\n         """\n \ndiff --git a/borg/localrole/config.py b/borg/localrole/config.py\nindex 994dd88..40d52ac 100644\n--- a/borg/localrole/config.py\n+++ b/borg/localrole/config.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n # Configuration constants\n \n-LOCALROLE_PLUGIN_NAME = \'borg_localroles\'\n+LOCALROLE_PLUGIN_NAME = "borg_localroles"\ndiff --git a/borg/localrole/configure.zcml b/borg/localrole/configure.zcml\nindex fdff392..84dff78 100644\n--- a/borg/localrole/configure.zcml\n+++ b/borg/localrole/configure.zcml\n@@ -1,33 +1,40 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    xmlns:zcml="http://namespaces.zope.org/zcml"\n     xmlns:five="http://namespaces.zope.org/five"\n     xmlns:genericsetup="http://namespaces.zope.org/genericsetup"\n-    i18n_domain="borg.localrole">\n+    xmlns:zcml="http://namespaces.zope.org/zcml"\n+    i18n_domain="borg.localrole"\n+    >\n \n-    <five:registerPackage package="." initialize=".initialize" />\n+  <five:registerPackage\n+      package="."\n+      initialize=".initialize"\n+      />\n \n-    <!-- Register GenericSetup profile used for installation -->\n-    <genericsetup:registerProfile\n-        name="default"\n-        title="b-org local role plug-in"\n-        directory="profiles/default"\n-        description="This is a PAS plug-in that makes it easy to determine local roles via an adapter lookup"\n-        provides="Products.GenericSetup.interfaces.EXTENSION"\n-        />\n+  <!-- Register GenericSetup profile used for installation -->\n+  <genericsetup:registerProfile\n+      name="default"\n+      title="b-org local role plug-in"\n+      description="This is a PAS plug-in that makes it easy to determine local roles via an adapter lookup"\n+      provides="Products.GenericSetup.interfaces.EXTENSION"\n+      directory="profiles/default"\n+      />\n \n-    <!-- Installs the Factory Tool adapter if Plone is installed -->\n-    <class class="Products.ATContentTypes.tool.factory.TempFolder"\n-           zcml:condition="installed Products.ATContentTypes">\n-      <implements interface=".interfaces.IFactoryTempFolder" />\n-    </class>\n+  <!-- Installs the Factory Tool adapter if Plone is installed -->\n+  <class\n+      class="Products.ATContentTypes.tool.factory.TempFolder"\n+      zcml:condition="installed Products.ATContentTypes"\n+      >\n+    <implements interface=".interfaces.IFactoryTempFolder" />\n+  </class>\n \n-    <adapter zcml:condition="installed Products.ATContentTypes"\n-             factory=".factory_adapter.FactoryTempFolderProvider"\n-             />\n+  <adapter\n+      factory=".factory_adapter.FactoryTempFolderProvider"\n+      zcml:condition="installed Products.ATContentTypes"\n+      />\n \n-    <include file="exportimport.zcml" />\n+  <include file="exportimport.zcml" />\n \n-    <include package="plone.memoize" />\n+  <include package="plone.memoize" />\n \n </configure>\ndiff --git a/borg/localrole/default.zcml b/borg/localrole/default.zcml\nindex 1c720d8..ff8608f 100644\n--- a/borg/localrole/default.zcml\n+++ b/borg/localrole/default.zcml\n@@ -1,6 +1,7 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    xmlns:zcml="http://namespaces.zope.org/zcml">\n+    xmlns:zcml="http://namespaces.zope.org/zcml"\n+    >\n \n   <adapter\n       factory=".default_adapter.DefaultLocalRoleAdapter"\ndiff --git a/borg/localrole/default_adapter.py b/borg/localrole/default_adapter.py\nindex 1ab7847..7ddd0d8 100644\n--- a/borg/localrole/default_adapter.py\n+++ b/borg/localrole/default_adapter.py\n@@ -1,15 +1,12 @@\n-# -*- coding: utf-8 -*-\n from borg.localrole.interfaces import ILocalRoleProvider\n from zope.component import adapter\n from zope.interface import implementer\n from zope.interface import Interface\n \n-import six\n-\n \n @implementer(ILocalRoleProvider)\n @adapter(Interface)\n-class DefaultLocalRoleAdapter(object):\n+class DefaultLocalRoleAdapter:\n     """Looks at __ac_local_roles__ to find local roles stored\n     persistently on an object::\n \n@@ -62,7 +59,7 @@ def __init__(self, context):\n \n     @property\n     def _rolemap(self):\n-        rolemap = getattr(self.context, \'__ac_local_roles__\', {})\n+        rolemap = getattr(self.context, "__ac_local_roles__", {})\n         # None is the default value from AccessControl.Role.RoleMananger\n         if rolemap is None:\n             return {}\n@@ -77,4 +74,4 @@ def getRoles(self, principal_id):\n     def getAllRoles(self):\n         """Returns all the local roles assigned in this context:\n         (principal_id, [role1, role2])"""\n-        return six.iteritems(self._rolemap)\n+        return self._rolemap.items()\ndiff --git a/borg/localrole/exportimport.zcml b/borg/localrole/exportimport.zcml\nindex a61ab5a..feb1dd9 100644\n--- a/borg/localrole/exportimport.zcml\n+++ b/borg/localrole/exportimport.zcml\n@@ -5,14 +5,15 @@\n            the \'for\' value -->\n \n   <adapter\n-     factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"\n-     provides="Products.GenericSetup.interfaces.IFilesystemExporter"\n-     for="borg.localrole.workspace.WorkspaceLocalRoleManager" />\n+      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"\n+      provides="Products.GenericSetup.interfaces.IFilesystemExporter"\n+      for="borg.localrole.workspace.WorkspaceLocalRoleManager"\n+      />\n \n   <adapter\n-     factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"\n-     provides="Products.GenericSetup.interfaces.IFilesystemImporter"\n-     for="borg.localrole.workspace.WorkspaceLocalRoleManager"\n-     />\n+      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"\n+      provides="Products.GenericSetup.interfaces.IFilesystemImporter"\n+      for="borg.localrole.workspace.WorkspaceLocalRoleManager"\n+      />\n \n </configure>\ndiff --git a/borg/localrole/factory_adapter.py b/borg/localrole/factory_adapter.py\nindex da0c66b..18e773c 100644\n--- a/borg/localrole/factory_adapter.py\n+++ b/borg/localrole/factory_adapter.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n from borg.localrole.interfaces import IFactoryTempFolder\n@@ -10,7 +9,7 @@\n \n @implementer(ILocalRoleProvider)\n @adapter(IFactoryTempFolder)\n-class FactoryTempFolderProvider(object):\n+class FactoryTempFolderProvider:\n     """A simple local role provider which just gathers the roles from\n     the desired context::\n \n@@ -98,7 +97,7 @@ def __init__(self, obj):\n         self.folder = obj\n \n     def getRoles(self, principal_id):\n-        uf = aq_inner(getToolByName(self.folder, \'acl_users\'))\n+        uf = aq_inner(getToolByName(self.folder, "acl_users"))\n         user = aq_inner(uf.getUserById(principal_id, default=None))\n         # use the folder we are creating in as role generating context\n         source = aq_parent(aq_parent(self.folder))\ndiff --git a/borg/localrole/interfaces.py b/borg/localrole/interfaces.py\nindex 9bd2f2e..ca4dfbb 100644\n--- a/borg/localrole/interfaces.py\n+++ b/borg/localrole/interfaces.py\n@@ -1,16 +1,15 @@\n-# -*- coding: utf-8 -*-\n from zope.deferredimport import deprecated\n from zope.interface import Interface\n \n \n deprecated(\n-    \'Please use borg.localrole.interfaces.ILocalRoleProvider instead\',\n-    IWorkspace=\'borg.localrole.bbb.interfaces:IWorkspace\'\n+    "Please use borg.localrole.interfaces.ILocalRoleProvider instead",\n+    IWorkspace="borg.localrole.bbb.interfaces:IWorkspace",\n )\n \n deprecated(\n-    \'Please use borg.localrole.interfaces.ILocalRoleProvider instead\',\n-    IGroupAwareWorkspace=\'borg.localrole.bbb.interfaces:IGroupAwareWorkspace\'\n+    "Please use borg.localrole.interfaces.ILocalRoleProvider instead",\n+    IGroupAwareWorkspace="borg.localrole.bbb.interfaces:IGroupAwareWorkspace",\n )\n \n \n@@ -18,12 +17,11 @@ class ILocalRoleProvider(Interface):\n     """An interface which allows querying the local roles on an object"""\n \n     def getRoles(principal_id):\n-        """Returns an iterable of roles granted to the specified user object\n-        """\n+        """Returns an iterable of roles granted to the specified user object"""\n \n     def getAllRoles():\n         """Returns an iterable consisting of tuples of the form:\n-            (principal_id, sequence_of_roles)\n+        (principal_id, sequence_of_roles)\n         """\n \n \ndiff --git a/borg/localrole/profiles/default/import_steps.xml b/borg/localrole/profiles/default/import_steps.xml\nindex ae05212..b32c8c6 100644\n--- a/borg/localrole/profiles/default/import_steps.xml\n+++ b/borg/localrole/profiles/default/import_steps.xml\n@@ -1,7 +1,9 @@\n-<?xml version="1.0"?>\n+<?xml version="1.0" encoding="utf-8"?>\n <import-steps>\n-  <import-step id="borg_localrole_various" version="20071003-01"\n+  <import-step id="borg_localrole_various"\n                handler="borg.localrole.setuphandlers.importVarious"\n-               title="borg.localrole plug-in installation">\n- </import-step>\n+               title="borg.localrole plug-in installation"\n+               version="20071003-01"\n+  >\n+</import-step>\n </import-steps>\ndiff --git a/borg/localrole/setuphandlers.py b/borg/localrole/setuphandlers.py\nindex 05e3089..f30b14d 100644\n--- a/borg/localrole/setuphandlers.py\n+++ b/borg/localrole/setuphandlers.py\n@@ -1,10 +1,9 @@\n-# -*- coding: utf-8 -*-\n from borg.localrole.utils import setup_localrole_plugin\n \n \n def importVarious(context):\n \n-    if context.readDataFile(\'borg.localrole_various.txt\') is None:\n+    if context.readDataFile("borg.localrole_various.txt") is None:\n         return\n \n     portal = context.getSite()\ndiff --git a/borg/localrole/tests.py b/borg/localrole/tests.py\nindex b659583..efaf773 100644\n--- a/borg/localrole/tests.py\n+++ b/borg/localrole/tests.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from borg.localrole import default_adapter\n from borg.localrole import factory_adapter\n from plone.app.testing import PLONE_INTEGRATION_TESTING\n@@ -9,27 +8,25 @@\n import borg.localrole\n import doctest\n import re\n-import six\n import unittest\n \n \n @implementer(borg.localrole.interfaces.ILocalRoleProvider)\n-class SimpleLocalRoleProvider(object):\n-\n+class SimpleLocalRoleProvider:\n     def __init__(self, context):\n         self.context = context\n \n     def getRoles(self, user):\n         """Grant everyone the \'Foo\' role"""\n-        return (\'Foo\', )\n+        return ("Foo",)\n \n     def getAllRoles(self):\n         """In the real world we would enumerate all users and\n         grant the \'Foo\' role to each, but we won\'t"""\n-        yield (\'bogus_user\', (\'Foo\', ))\n+        yield ("bogus_user", ("Foo",))\n \n \n-class DummyUser(object):\n+class DummyUser:\n     def __init__(self, uid, group_ids=()):\n         self.id = uid\n         self._groups = group_ids\n@@ -47,40 +44,29 @@ def getRoles(self):\n         return ()\n \n \n-class Py23DocChecker(doctest.OutputChecker):\n-    def check_output(self, want, got, optionflags):\n-        if six.PY2:\n-            got = re.sub("set\\(\\[(.*?)\\]\\)", "{\\\\1}", got)\n-            want = re.sub(\n-                \'plone.memoize.volatile.DontCache\',\n-                \'DontCache\', want\n-            )\n-        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n-\n-\n def test_suite():\n     suite = [\n         layered(\n             doctest.DocFileSuite(\n-                \'README.txt\',\n-                package=\'borg.localrole\',\n-                optionflags=(doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE)\n+                "README.txt",\n+                package="borg.localrole",\n+                optionflags=(doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE),\n             ),\n-            layer=PLONE_INTEGRATION_TESTING),\n+            layer=PLONE_INTEGRATION_TESTING,\n+        ),\n         layered(\n             doctest.DocTestSuite(\n                 borg.localrole.workspace,\n                 optionflags=(doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE),\n-                checker=Py23DocChecker(),\n             ),\n-            layer=zca.UNIT_TESTING\n+            layer=zca.UNIT_TESTING,\n         ),\n         layered(\n             doctest.DocTestSuite(\n                 factory_adapter,\n-                optionflags=(doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE)\n+                optionflags=(doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE),\n             ),\n-            layer=zca.UNIT_TESTING\n+            layer=zca.UNIT_TESTING,\n         ),\n         doctest.DocTestSuite(default_adapter),\n     ]\ndiff --git a/borg/localrole/utils.py b/borg/localrole/utils.py\nindex d69854e..abf4d06 100644\n--- a/borg/localrole/utils.py\n+++ b/borg/localrole/utils.py\n@@ -1,20 +1,17 @@\n-# -*- coding: utf-8 -*-\n-from __future__ import print_function\n from Acquisition import aq_base\n from borg.localrole.config import LOCALROLE_PLUGIN_NAME\n from borg.localrole.workspace import manage_addWorkspaceLocalRoleManager\n+from io import StringIO\n from Products.CMFCore.utils import getToolByName\n from Products.PlonePAS.plugins.local_role import LocalRolesManager\n from Products.PlonePAS.setuphandlers import activatePluginInterfaces\n-from six import StringIO\n \n \n def setup_localrole_plugin(portal):\n-    """Install and prioritize the local-role PAS plug-in\n-    """\n+    """Install and prioritize the local-role PAS plug-in"""\n     out = StringIO()\n \n-    uf = getToolByName(portal, \'acl_users\')\n+    uf = getToolByName(portal, "acl_users")\n \n     existing = uf.objectIds()\n \n@@ -30,13 +27,13 @@ def setup_localrole_plugin(portal):\n def replace_local_role_manager(portal):\n     """Installs the borg local role manager in place of the standard one from\n     PlonePAS"""\n-    uf = getToolByName(portal, \'acl_users\', None)\n+    uf = getToolByName(portal, "acl_users", None)\n     # Make sure we have a PAS user folder\n-    if uf is not None and hasattr(aq_base(uf), \'plugins\'):\n+    if uf is not None and hasattr(aq_base(uf), "plugins"):\n         # Remove the original plugin if it\'s there\n-        if \'local_roles\' in uf.objectIds():\n-            orig_lr = getattr(uf, \'local_roles\')\n+        if "local_roles" in uf.objectIds():\n+            orig_lr = getattr(uf, "local_roles")\n             if isinstance(orig_lr, LocalRolesManager):\n-                uf.plugins.removePluginById(\'local_roles\')\n+                uf.plugins.removePluginById("local_roles")\n         # Install the borg.localrole plugin if it\'s not already there\n         setup_localrole_plugin(portal)\ndiff --git a/borg/localrole/workspace.py b/borg/localrole/workspace.py\nindex 91247bb..fb1ad2f 100644\n--- a/borg/localrole/workspace.py\n+++ b/borg/localrole/workspace.py\n@@ -1,9 +1,9 @@\n-# -*- coding: utf-8 -*-\n from AccessControl import ClassSecurityInfo\n+from AccessControl.class_init import InitializeClass\n from Acquisition import aq_get\n from Acquisition import aq_inner\n from Acquisition import aq_parent\n-from AccessControl.class_init import InitializeClass\n+\n # BBB interfaces, to be removed\n from borg.localrole.bbb.interfaces import IGroupAwareWorkspace\n from borg.localrole.bbb.interfaces import IWorkspace\n@@ -21,16 +21,11 @@\n manage_addWorkspaceLocalRoleManagerForm = PageTemplateFile(\n     "zmi/WorkspaceLocalRoleManagerForm.pt",\n     globals(),\n-    __name__="manage_addWorkspaceRoleManagerForm"\n+    __name__="manage_addWorkspaceRoleManagerForm",\n )\n \n \n-def manage_addWorkspaceLocalRoleManager(\n-    dispatcher,\n-    id,\n-    title=None,\n-    REQUEST=None\n-):\n+def manage_addWorkspaceLocalRoleManager(dispatcher, id, title=None, REQUEST=None):\n     """Add a WorkspaceLocalRoleManager to a Pluggable Authentication\n     Services.\n     """\n@@ -39,8 +34,8 @@ def manage_addWorkspaceLocalRoleManager(\n \n     if REQUEST is not None:\n         REQUEST.RESPONSE.redirect(\n-            \'{0}/manage_workspace?\'\n-            \'manage_tabs_message=WorkspaceLocalRoleManager+added.\'.format(\n+            "{}/manage_workspace?"\n+            "manage_tabs_message=WorkspaceLocalRoleManager+added.".format(\n                 dispatcher.absolute_url()\n             )\n         )\n@@ -48,94 +43,94 @@ def manage_addWorkspaceLocalRoleManager(\n \n # memoize support for `checkLocalRolesAllowed`\n def clra_cache_key(method, self, user, obj, object_roles):\n-    """ The cache key needs to include all arguments when caching allowed\n-        local roles, but the key function also needs to decide whether\n-        `volatile.cache` can cache or not by checking if it\'s possible to\n-        get a request instance from the object.\n-\n-        To test we\'ll nee an adaptable object, a user and the method which\n-        results\' we\'d like to cache:\n-\n-          >>> from zope.interface import implementer, Interface\n-          >>> @implementer(Interface)\n-          ... class DummyObject(object):\n-          ...     pass\n-          >>> obj = DummyObject()\n-\n-          >>> from borg.localrole.tests import DummyUser\n-          >>> john = DummyUser(\'john\')\n-\n-          >>> rm = WorkspaceLocalRoleManager(\'rm\', \'A Role Manager\')\n-          >>> fun = rm.__class__.checkLocalRolesAllowed\n-\n-        The dummy object doesn\'t have an acquired request, so no caching\n-        can be done:\n-\n-          >>> clra_cache_key(fun, \'me\', john, obj, [\'foo\', \'bar\'])\n-          Traceback (most recent call last):\n-          ...\n-          plone.memoize.volatile.DontCache\n-\n-        So let\'s add one and try again.  Before we also need to mark it as\n-        being annotatable, which normally happens elsewhere:\n-\n-          >>> from ZPublisher.HTTPRequest import HTTPRequest\n-          >>> request = HTTPRequest(\'\', dict(HTTP_HOST=\'nohost:8080\'), {})\n-\n-          >>> try:\n-          ...     from Zope2.App.zcml import load_config\n-          ... except ImportError:\n-          ...     from Products.Five.zcml import load_config\n-          >>> import zope.component\n-          >>> import zope.annotation\n-          >>> load_config(\'meta.zcml\', zope.component)\n-          >>> load_config(\'configure.zcml\', zope.annotation)\n-          >>> from zope.interface import classImplements\n-          >>> from zope.annotation.interfaces import IAttributeAnnotatable\n-          >>> classImplements(HTTPRequest, IAttributeAnnotatable)\n-\n-          >>> obj.REQUEST = request\n-          >>> clra_cache_key(fun, \'hmm\', john, obj, [\'foo\', \'bar\'])\n-          (\'john\', ..., (\'foo\', \'bar\'))\n-\n-        If the objects happens to have a `getPhysicalPath` method, that should\n-        be used instead of the hash:\n-\n-          >>> class DummyObjectWithPath(DummyObject):\n-          ...     def getPhysicalPath(self):\n-          ...         return \'42!\'\n-          >>> obj = DummyObjectWithPath()\n-          >>> obj.REQUEST = request\n-          >>> clra_cache_key(fun, \'hmm\', john, obj, [\'foo\', \'bar\'])\n-          (\'john\', \'42!\', (\'foo\', \'bar\'))\n-\n-        Now let\'s check if the results of a call to `checkLocalRolesAllowed`\n-        is indeed cached, i.e. is the request was annotated correctly.  First\n-        try to log the method invocation, though.  As monkey patching in\n-        something between the original method and the already applied cache\n-        decorator is tricky, we abuse `_get_userfolder`, which is called\n-        first thing in `checkLocalRolesAllowed`:\n-\n-          >>> original = rm._get_userfolder\n-          >>> def logger(self, *args, **kw):\n-          ...     print(\'checkLocalRolesAllowed called...\')\n-          ...     return original(self, *args, **kw)\n-          >>> rm._get_userfolder = logger\n-\n-          >>> print(rm.checkLocalRolesAllowed(john, obj, [\'foo\', \'bar\']))\n-          checkLocalRolesAllowed called...\n-          None\n-          >>> [i for i in IAnnotations(request)]\n-          ["borg.localrole.workspace.checkLocalRolesAllowed:(\'john\', \'42!\', (\'foo\', \'bar\'))"]\n-\n-        Calling the method a second time should directly return the cached\n-        value, i.e. the logger shouldn\'t print anything:\n-\n-          >>> print(rm.checkLocalRolesAllowed(john, obj, [\'foo\', \'bar\']))\n-          None\n+    """The cache key needs to include all arguments when caching allowed\n+    local roles, but the key function also needs to decide whether\n+    `volatile.cache` can cache or not by checking if it\'s possible to\n+    get a request instance from the object.\n+\n+    To test we\'ll nee an adaptable object, a user and the method which\n+    results\' we\'d like to cache:\n+\n+      >>> from zope.interface import implementer, Interface\n+      >>> @implementer(Interface)\n+      ... class DummyObject(object):\n+      ...     pass\n+      >>> obj = DummyObject()\n+\n+      >>> from borg.localrole.tests import DummyUser\n+      >>> john = DummyUser(\'john\')\n+\n+      >>> rm = WorkspaceLocalRoleManager(\'rm\', \'A Role Manager\')\n+      >>> fun = rm.__class__.checkLocalRolesAllowed\n+\n+    The dummy object doesn\'t have an acquired request, so no caching\n+    can be done:\n+\n+      >>> clra_cache_key(fun, \'me\', john, obj, [\'foo\', \'bar\'])\n+      Traceback (most recent call last):\n+      ...\n+      plone.memoize.volatile.DontCache\n+\n+    So let\'s add one and try again.  Before we also need to mark it as\n+    being annotatable, which normally happens elsewhere:\n+\n+      >>> from ZPublisher.HTTPRequest import HTTPRequest\n+      >>> request = HTTPRequest(\'\', dict(HTTP_HOST=\'nohost:8080\'), {})\n+\n+      >>> try:\n+      ...     from Zope2.App.zcml import load_config\n+      ... except ImportError:\n+      ...     from Products.Five.zcml import load_config\n+      >>> import zope.component\n+      >>> import zope.annotation\n+      >>> load_config(\'meta.zcml\', zope.component)\n+      >>> load_config(\'configure.zcml\', zope.annotation)\n+      >>> from zope.interface import classImplements\n+      >>> from zope.annotation.interfaces import IAttributeAnnotatable\n+      >>> classImplements(HTTPRequest, IAttributeAnnotatable)\n+\n+      >>> obj.REQUEST = request\n+      >>> clra_cache_key(fun, \'hmm\', john, obj, [\'foo\', \'bar\'])\n+      (\'john\', ..., (\'foo\', \'bar\'))\n+\n+    If the objects happens to have a `getPhysicalPath` method, that should\n+    be used instead of the hash:\n+\n+      >>> class DummyObjectWithPath(DummyObject):\n+      ...     def getPhysicalPath(self):\n+      ...         return \'42!\'\n+      >>> obj = DummyObjectWithPath()\n+      >>> obj.REQUEST = request\n+      >>> clra_cache_key(fun, \'hmm\', john, obj, [\'foo\', \'bar\'])\n+      (\'john\', \'42!\', (\'foo\', \'bar\'))\n+\n+    Now let\'s check if the results of a call to `checkLocalRolesAllowed`\n+    is indeed cached, i.e. is the request was annotated correctly.  First\n+    try to log the method invocation, though.  As monkey patching in\n+    something between the original method and the already applied cache\n+    decorator is tricky, we abuse `_get_userfolder`, which is called\n+    first thing in `checkLocalRolesAllowed`:\n+\n+      >>> original = rm._get_userfolder\n+      >>> def logger(self, *args, **kw):\n+      ...     print(\'checkLocalRolesAllowed called...\')\n+      ...     return original(self, *args, **kw)\n+      >>> rm._get_userfolder = logger\n+\n+      >>> print(rm.checkLocalRolesAllowed(john, obj, [\'foo\', \'bar\']))\n+      checkLocalRolesAllowed called...\n+      None\n+      >>> [i for i in IAnnotations(request)]\n+      ["borg.localrole.workspace.checkLocalRolesAllowed:(\'john\', \'42!\', (\'foo\', \'bar\'))"]\n+\n+    Calling the method a second time should directly return the cached\n+    value, i.e. the logger shouldn\'t print anything:\n+\n+      >>> print(rm.checkLocalRolesAllowed(john, obj, [\'foo\', \'bar\']))\n+      None\n \n     """  # noqa: E501\n-    request = aq_get(obj, \'REQUEST\', None)\n+    request = aq_get(obj, "REQUEST", None)\n     if IAnnotations(request, None) is None:\n         raise DontCache\n     try:\n@@ -146,235 +141,236 @@ def clra_cache_key(method, self, user, obj, object_roles):\n \n \n def store_on_request(method, self, user, obj, object_roles):\n-    """ helper for caching local roles on the request """\n-    return IAnnotations(aq_get(obj, \'REQUEST\'))\n+    """helper for caching local roles on the request"""\n+    return IAnnotations(aq_get(obj, "REQUEST"))\n \n \n class WorkspaceLocalRoleManager(BasePlugin):\n     """This is the actual plug-in. It takes care of looking up\n-    ILocalRolesProvider adapters (when available) and granting local roles\n-    appropriately.\n-\n-    First we need to make and register an adapter to provide some roles::\n-\n-        >>> from zope.interface import implementer, Interface\n-        >>> from zope.component import adapter\n-        >>> from borg.localrole.tests import SimpleLocalRoleProvider\n-        >>> from borg.localrole.tests import DummyUser\n-        >>> from zope.component import provideAdapter\n-        >>> provideAdapter(SimpleLocalRoleProvider, adapts=(Interface,))\n-\n-\n-    We need an object to adapt, we require nothing of this object,\n-    except it must be adaptable (e.g. have an interface)::\n-\n-        >>> @implementer(Interface)\n-        ... class DummyObject(object):\n-        ...     pass\n-        >>> ob = DummyObject()\n-\n-    And we need some users that we\'ll check the permissions of::\n-\n-        >>> user1 = DummyUser(\'bogus_user\')\n-        >>> user2 = DummyUser(\'bogus_user2\')\n-\n-    Now we\'re ready to make one of our RoleManagers and try it out.\n-    First we\'ll verify that our users have the \'Foo\' role, then we\'ll\n-    make sure they can access objects which require that role, but not\n-    others::\n-\n-        >>> rm = WorkspaceLocalRoleManager(\'rm\', \'A Role Manager\')\n-        >>> rm.getRolesInContext(user1, ob)\n-        [\'Foo\']\n-        >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Foo\', \'Baz\'])\n-        1\n-        >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Baz\']) is None\n-        True\n-        >>> rm.getAllLocalRolesInContext(ob)\n-        {\'bogus_user\': {\'Foo\'}}\n-\n-\n-    Multiple Role Providers\n-    -----------------------\n-\n-    It is a bit more interesting when we have more than one adapter\n-    registered.  We register it with a name so that it supplements,\n-    rather than conflict with or override the existing adapter::\n-\n-        >>> class LessSimpleLocalRoleProvider(SimpleLocalRoleProvider):\n-        ...     userid = \'bogus_user2\'\n-        ...     roles = (\'Foo\', \'Baz\')\n-        ...     def getRoles(self, userid):\n-        ...         \'\'\'Grant bogus_user2 the \'Foo\' and \'Baz\' roles\'\'\'\n-        ...         if userid == self.userid:\n-        ...             return self.roles\n-        ...         return ()\n-        ...\n-        ...     def getAllRoles(self):\n-        ...         yield (self.userid, self.roles)\n-\n-        >>> provideAdapter(LessSimpleLocalRoleProvider, adapts=(Interface,),\n-        ...                name=\'adapter2\')\n-\n-   This should have no effect on our first user::\n-\n-        >>> rm.getRolesInContext(user1, ob)\n-        [\'Foo\']\n-        >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Foo\', \'Baz\'])\n-        1\n-        >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Baz\']) is None\n-        True\n-        >>> expected = {\'bogus_user\': {\'Foo\'}, \'bogus_user2\': {\'Foo\', \'Baz\'}}\n-        >>> rm.getAllLocalRolesInContext(ob) == expected\n-        True\n-\n-    But our second user notices the change, note that even though two\n-    of our local role providers grant the role \'Foo\', it is not duplicated::\n-\n-        >>> set(rm.getRolesInContext(user2, ob)) == {\'Foo\', \'Baz\'}\n-        True\n-        >>> rm.checkLocalRolesAllowed(user2, ob, [\'Bar\', \'Foo\', \'Baz\'])\n-        1\n-        >>> rm.checkLocalRolesAllowed(user2, ob, [\'Bar\', \'Baz\'])\n-        1\n-        >>> rm.checkLocalRolesAllowed(user2, ob, [\'Bar\']) is None\n-        True\n-\n-\n-    Role Acquisition and Blocking\n-    -----------------------------\n-\n-    This plugin will acquire role definitions from parent objects,\n-    unless explicitly blocked.  To test this, we need some objects\n-    which support acquisition::\n-\n-        >>> from Acquisition import Implicit\n-        >>> class DummyImplicit(DummyObject, Implicit):\n-        ...     def stupid_method(self):\n-        ...         return 1\n-        >>> root = DummyImplicit()\n-        >>> next = DummyImplicit().__of__(root)\n-        >>> last = DummyImplicit().__of__(next)\n-        >>> other = DummyImplicit().__of__(root)\n-\n-    So we now have /root/next/last and /root/other, we\'ll create and\n-    register special adapters for our next and other objects.\n-\n-        >>> class ISpecial1(Interface):\n-        ...     pass\n-        >>> class ISpecial2(Interface):\n-        ...     pass\n-        >>> from zope.interface import directlyProvides\n-        >>> directlyProvides(next, ISpecial1)\n-        >>> directlyProvides(other, ISpecial2)\n-        >>> @adapter(ISpecial1)\n-        ... class Adapter1(LessSimpleLocalRoleProvider):\n-        ...\n-        ...     userid = \'bogus_user\'\n-        ...     roles = (\'Bar\',)\n-        >>> @adapter(ISpecial2)\n-        ... class Adapter2(LessSimpleLocalRoleProvider):\n-        ...\n-        ...     userid = \'bogus_user3\'\n-        ...     roles = (\'Foobar\',)\n-        >>> user3 = DummyUser(\'bogus_user3\')\n-\n-    We\'ll register these to override the existing unnamed adapter:\n-\n-        >>> provideAdapter(Adapter1)\n-        >>> provideAdapter(Adapter2)\n-\n-    Now we can show how acquisition of roles works, first we look at the\n-    \'last\' item, which should have roles provided by\n-    SimpleLocalRoleProvider, and LessSimpleLocalRoleProvider, as well\n-    as acquired from Adapter1 on \'next\':\n-\n-        >>> set(rm.getRolesInContext(user1, last)) == {\'Foo\', \'Bar\'}\n-        True\n-\n-        >>> set(rm.getRolesInContext(user2, last)) == {\'Foo\', \'Baz\'}\n-        True\n-\n-    If we look at the parent, we get the same results, because the\n-    SimpleLocalRoleProvider adapter also applies to the \'root\'\n-    object. However, if we enable local role blocking on \'next\' we\n-    won\'t see the roles from the \'root\'::\n-\n-        >>> set(rm.getRolesInContext(user1, next)) == {\'Foo\', \'Bar\'}\n-        True\n-        >>> next.__ac_local_roles_block__ = True\n-        >>> rm.getRolesInContext(user1, next)\n-        [\'Bar\']\n-\n-    The checkLocalRolesAllowed and getAllLocalRolesInContext methods\n-    take acquisition and blocking into account as well::\n-\n-        >>> rm.checkLocalRolesAllowed(user1, last,  [\'Bar\'])\n-        1\n-        >>> rm.checkLocalRolesAllowed(user1, next,  [\'Foo\', \'Baz\']) is None\n-        True\n-        >>> expected = {\'bogus_user\': {\'Foo\', \'Bar\'}, \'bogus_user2\': {\'Foo\', \'Baz\'}}\n-        >>> rm.getAllLocalRolesInContext(last) == expected\n-        True\n-\n-    It\'s important to note, that roles are acquired only by\n-    containment.  Additional wrapping cannot change the security on an\n-    object.  For example if we were to wrap \'last\' in the context of\n-    other, which provides a special role for \'user3\', we should see no\n-    effect::\n-\n-        >>> rm.getRolesInContext(user3, last)\n-        [\'Foo\']\n-        >>> set(rm.getRolesInContext(user3, other)) == {\'Foobar\', \'Foo\'}\n-        True\n-        >>> rm.getRolesInContext(user3, last.__of__(other))\n-        [\'Foo\']\n-\n-    It\'s also important that methods of objects yield the same local\n-    roles as the objects would\n-\n-        >>> set(rm.getRolesInContext(user3, other.stupid_method)) == {\'Foobar\', \'Foo\'}\n-        True\n-\n-    Group Support\n-    -------------\n-\n-    This plugin also handles roles granted to user groups, calling up\n-    the adapters to get roles for any groups the user might belong\n-    to::\n-\n-        >>> user4 = DummyUser(\'bogus_user4\', (\'Group1\', \'Group2\'))\n-        >>> user4.getGroups()\n-        (\'Group1\', \'Group2\')\n-        >>> rm.getRolesInContext(user4, last)\n-        [\'Foo\']\n-        >>> class Adapter3(LessSimpleLocalRoleProvider):\n-        ...     userid = \'Group2\'\n-        ...     roles = (\'Foobar\',)\n-\n-        >>> provideAdapter(Adapter3, adapts=(Interface,), name=\'group_adapter\')\n-        >>> set(rm.getRolesInContext(user4, last)) == {\'Foobar\', \'Foo\'}\n-        True\n-\n-\n-    Wrong User Folder\n-    -----------------\n-\n-    Finally, to ensure full test coverage, we provide a user object\n-    which pretends to be wrapped in such a way that the user folder\n-    does not recognize it.  We check that it always gets an empty set\n-    of roles and a special 0 value when checking access::\n-\n-        >>> class BadUser(DummyUser):\n-        ...     def _check_context(self, obj):\n-        ...         return False\n-        >>> bad_user = BadUser(\'bad_user\')\n-        >>> rm.getRolesInContext(bad_user, ob)\n-        []\n-        >>> rm.checkLocalRolesAllowed(bad_user, ob, [\'Bar\', \'Foo\', \'Baz\'])\n-        0\n+     ILocalRolesProvider adapters (when available) and granting local roles\n+     appropriately.\n+\n+     First we need to make and register an adapter to provide some roles::\n+\n+         >>> from zope.interface import implementer, Interface\n+         >>> from zope.component import adapter\n+         >>> from borg.localrole.tests import SimpleLocalRoleProvider\n+         >>> from borg.localrole.tests import DummyUser\n+         >>> from zope.component import provideAdapter\n+         >>> provideAdapter(SimpleLocalRoleProvider, adapts=(Interface,))\n+\n+\n+     We need an object to adapt, we require nothing of this object,\n+     except it must be adaptable (e.g. have an interface)::\n+\n+         >>> @implementer(Interface)\n+         ... class DummyObject(object):\n+         ...     pass\n+         >>> ob = DummyObject()\n+\n+     And we need some users that we\'ll check the permissions of::\n+\n+         >>> user1 = DummyUser(\'bogus_user\')\n+         >>> user2 = DummyUser(\'bogus_user2\')\n+\n+     Now we\'re ready to make one of our RoleManagers and try it out.\n+     First we\'ll verify that our users have the \'Foo\' role, then we\'ll\n+     make sure they can access objects which require that role, but not\n+     others::\n+\n+         >>> rm = WorkspaceLocalRoleManager(\'rm\', \'A Role Manager\')\n+         >>> rm.getRolesInContext(user1, ob)\n+         [\'Foo\']\n+         >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Foo\', \'Baz\'])\n+         1\n+         >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Baz\']) is None\n+         True\n+         >>> rm.getAllLocalRolesInContext(ob)\n+         {\'bogus_user\': {\'Foo\'}}\n+\n+\n+     Multiple Role Providers\n+     -----------------------\n+\n+     It is a bit more interesting when we have more than one adapter\n+     registered.  We register it with a name so that it supplements,\n+     rather than conflict with or override the existing adapter::\n+\n+         >>> class LessSimpleLocalRoleProvider(SimpleLocalRoleProvider):\n+         ...     userid = \'bogus_user2\'\n+         ...     roles = (\'Foo\', \'Baz\')\n+         ...     def getRoles(self, userid):\n+         ...         \'\'\'Grant bogus_user2 the \'Foo\' and \'Baz\' roles\'\'\'\n+         ...         if userid == self.userid:\n+         ...             return self.roles\n+         ...         return ()\n+         ...\n+         ...     def getAllRoles(self):\n+         ...         yield (self.userid, self.roles)\n+\n+         >>> provideAdapter(LessSimpleLocalRoleProvider, adapts=(Interface,),\n+         ...                name=\'adapter2\')\n+\n+    This should have no effect on our first user::\n+\n+         >>> rm.getRolesInContext(user1, ob)\n+         [\'Foo\']\n+         >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Foo\', \'Baz\'])\n+         1\n+         >>> rm.checkLocalRolesAllowed(user1, ob, [\'Bar\', \'Baz\']) is None\n+         True\n+         >>> expected = {\'bogus_user\': {\'Foo\'}, \'bogus_user2\': {\'Foo\', \'Baz\'}}\n+         >>> rm.getAllLocalRolesInContext(ob) == expected\n+         True\n+\n+     But our second user notices the change, note that even though two\n+     of our local role providers grant the role \'Foo\', it is not duplicated::\n+\n+         >>> set(rm.getRolesInContext(user2, ob)) == {\'Foo\', \'Baz\'}\n+         True\n+         >>> rm.checkLocalRolesAllowed(user2, ob, [\'Bar\', \'Foo\', \'Baz\'])\n+         1\n+         >>> rm.checkLocalRolesAllowed(user2, ob, [\'Bar\', \'Baz\'])\n+         1\n+         >>> rm.checkLocalRolesAllowed(user2, ob, [\'Bar\']) is None\n+         True\n+\n+\n+     Role Acquisition and Blocking\n+     -----------------------------\n+\n+     This plugin will acquire role definitions from parent objects,\n+     unless explicitly blocked.  To test this, we need some objects\n+     which support acquisition::\n+\n+         >>> from Acquisition import Implicit\n+         >>> class DummyImplicit(DummyObject, Implicit):\n+         ...     def stupid_method(self):\n+         ...         return 1\n+         >>> root = DummyImplicit()\n+         >>> next = DummyImplicit().__of__(root)\n+         >>> last = DummyImplicit().__of__(next)\n+         >>> other = DummyImplicit().__of__(root)\n+\n+     So we now have /root/next/last and /root/other, we\'ll create and\n+     register special adapters for our next and other objects.\n+\n+         >>> class ISpecial1(Interface):\n+         ...     pass\n+         >>> class ISpecial2(Interface):\n+         ...     pass\n+         >>> from zope.interface import directlyProvides\n+         >>> directlyProvides(next, ISpecial1)\n+         >>> directlyProvides(other, ISpecial2)\n+         >>> @adapter(ISpecial1)\n+         ... class Adapter1(LessSimpleLocalRoleProvider):\n+         ...\n+         ...     userid = \'bogus_user\'\n+         ...     roles = (\'Bar\',)\n+         >>> @adapter(ISpecial2)\n+         ... class Adapter2(LessSimpleLocalRoleProvider):\n+         ...\n+         ...     userid = \'bogus_user3\'\n+         ...     roles = (\'Foobar\',)\n+         >>> user3 = DummyUser(\'bogus_user3\')\n+\n+     We\'ll register these to override the existing unnamed adapter:\n+\n+         >>> provideAdapter(Adapter1)\n+         >>> provideAdapter(Adapter2)\n+\n+     Now we can show how acquisition of roles works, first we look at the\n+     \'last\' item, which should have roles provided by\n+     SimpleLocalRoleProvider, and LessSimpleLocalRoleProvider, as well\n+     as acquired from Adapter1 on \'next\':\n+\n+         >>> set(rm.getRolesInContext(user1, last)) == {\'Foo\', \'Bar\'}\n+         True\n+\n+         >>> set(rm.getRolesInContext(user2, last)) == {\'Foo\', \'Baz\'}\n+         True\n+\n+     If we look at the parent, we get the same results, because the\n+     SimpleLocalRoleProvider adapter also applies to the \'root\'\n+     object. However, if we enable local role blocking on \'next\' we\n+     won\'t see the roles from the \'root\'::\n+\n+         >>> set(rm.getRolesInContext(user1, next)) == {\'Foo\', \'Bar\'}\n+         True\n+         >>> next.__ac_local_roles_block__ = True\n+         >>> rm.getRolesInContext(user1, next)\n+         [\'Bar\']\n+\n+     The checkLocalRolesAllowed and getAllLocalRolesInContext methods\n+     take acquisition and blocking into account as well::\n+\n+         >>> rm.checkLocalRolesAllowed(user1, last,  [\'Bar\'])\n+         1\n+         >>> rm.checkLocalRolesAllowed(user1, next,  [\'Foo\', \'Baz\']) is None\n+         True\n+         >>> expected = {\'bogus_user\': {\'Foo\', \'Bar\'}, \'bogus_user2\': {\'Foo\', \'Baz\'}}\n+         >>> rm.getAllLocalRolesInContext(last) == expected\n+         True\n+\n+     It\'s important to note, that roles are acquired only by\n+     containment.  Additional wrapping cannot change the security on an\n+     object.  For example if we were to wrap \'last\' in the context of\n+     other, which provides a special role for \'user3\', we should see no\n+     effect::\n+\n+         >>> rm.getRolesInContext(user3, last)\n+         [\'Foo\']\n+         >>> set(rm.getRolesInContext(user3, other)) == {\'Foobar\', \'Foo\'}\n+         True\n+         >>> rm.getRolesInContext(user3, last.__of__(other))\n+         [\'Foo\']\n+\n+     It\'s also important that methods of objects yield the same local\n+     roles as the objects would\n+\n+         >>> set(rm.getRolesInContext(user3, other.stupid_method)) == {\'Foobar\', \'Foo\'}\n+         True\n+\n+     Group Support\n+     -------------\n+\n+     This plugin also handles roles granted to user groups, calling up\n+     the adapters to get roles for any groups the user might belong\n+     to::\n+\n+         >>> user4 = DummyUser(\'bogus_user4\', (\'Group1\', \'Group2\'))\n+         >>> user4.getGroups()\n+         (\'Group1\', \'Group2\')\n+         >>> rm.getRolesInContext(user4, last)\n+         [\'Foo\']\n+         >>> class Adapter3(LessSimpleLocalRoleProvider):\n+         ...     userid = \'Group2\'\n+         ...     roles = (\'Foobar\',)\n+\n+         >>> provideAdapter(Adapter3, adapts=(Interface,), name=\'group_adapter\')\n+         >>> set(rm.getRolesInContext(user4, last)) == {\'Foobar\', \'Foo\'}\n+         True\n+\n+\n+     Wrong User Folder\n+     -----------------\n+\n+     Finally, to ensure full test coverage, we provide a user object\n+     which pretends to be wrapped in such a way that the user folder\n+     does not recognize it.  We check that it always gets an empty set\n+     of roles and a special 0 value when checking access::\n+\n+         >>> class BadUser(DummyUser):\n+         ...     def _check_context(self, obj):\n+         ...         return False\n+         >>> bad_user = BadUser(\'bad_user\')\n+         >>> rm.getRolesInContext(bad_user, ob)\n+         []\n+         >>> rm.checkLocalRolesAllowed(bad_user, ob, [\'Bar\', \'Foo\', \'Baz\'])\n+         0\n \n     """\n+\n     meta_type = "Workspace Roles Manager"\n     security = ClassSecurityInfo()\n \n@@ -387,19 +383,20 @@ def _get_userfolder(user, obj):\n         need to rewrap"""\n         context = user\n         while context is not None:\n-            if hasattr(context, \'getId\'):\n-                if context.getId() == \'acl_users\':\n+            if hasattr(context, "getId"):\n+                if context.getId() == "acl_users":\n                     break\n             context = aq_parent(aq_inner(context))\n         else:\n             return None\n         return aq_inner(context)\n+\n     #\n     # ILocalRolesPlugin implementation\n     #\n \n     def _getAdapters(self, obj):\n-        adapters = getAdapters((obj, ), ILocalRoleProvider)\n+        adapters = getAdapters((obj,), ILocalRoleProvider)\n         # this is sequence of tuples of the form (name, adapter),\n         # we don\'t really care about the names\n         return (a[1] for a in adapters)\n@@ -409,11 +406,11 @@ def _parent_chain(self, obj):\n         local role blocker"""\n         while obj is not None:\n             yield obj\n-            if getattr(obj, \'__ac_local_roles_block__\', None):\n+            if getattr(obj, "__ac_local_roles_block__", None):\n                 return\n             new = aq_parent(aq_inner(obj))\n             # if the obj is a method we get the class\n-            obj = getattr(obj, \'__self__\', new)\n+            obj = getattr(obj, "__self__", new)\n \n     def _get_principal_ids(self, user):\n         """Returns a list of the ids of all involved security\n@@ -443,16 +440,11 @@ def getRolesInContext(self, user, object):\n                         roles.update(a.getRoles(pid))\n                 # XXX: BBB code, kicks in only if there\'s no proper adapter\n                 if count == -1:\n-                    workspace = IGroupAwareWorkspace(\n-                        obj,\n-                        IWorkspace(obj, None)\n-                    )\n+                    workspace = IGroupAwareWorkspace(obj, IWorkspace(obj, None))\n                     if workspace is not None:\n                         roles.update(workspace.getLocalRolesForPrincipal(user))\n                         for group in self._groups(obj, user, workspace):\n-                            roles.update(\n-                                workspace.getLocalRolesForPrincipal(group)\n-                            )\n+                            roles.update(workspace.getLocalRolesForPrincipal(group))\n         return list(roles)\n \n     @security.private\n@@ -513,6 +505,7 @@ def getAllLocalRolesInContext(self, object):\n                     rolemap.update(workspace.getLocalRoles())\n \n         return rolemap\n+\n     # XXX: for BBB only\n \n     @security.private\n@@ -521,7 +514,7 @@ def _groups(self, obj, user, workspace):\n         a getGroups() method, yield each group_id returned by that method.\n         """\n         if IGroupAwareWorkspace.providedBy(workspace):\n-            getGroups = getattr(user, \'getGroups\', None)\n+            getGroups = getattr(user, "getGroups", None)\n             if getGroups is not None:\n                 acl_users = aq_parent(aq_inner(self))\n                 for group_id in getGroups():\ndiff --git a/lint-requirements.txt b/lint-requirements.txt\nnew file mode 100644\nindex 0000000..2a91911\n--- /dev/null\n+++ b/lint-requirements.txt\n@@ -0,0 +1,12 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+black==22.12.0\n+check-manifest==0.49\n+codespell==2.2.2\n+flake8==6.0.0\n+isort==5.11.4\n+pipdeptree==2.3.3\n+pyroma==4.1\n+pyupgrade==3.3.1\n+z3c.dependencychecker==2.10\n+zpretty==2.4.1\ndiff --git a/news/1.bugfix b/news/1.bugfix\nnew file mode 100644\nindex 0000000..e844e2b\n--- /dev/null\n+++ b/news/1.bugfix\n@@ -0,0 +1,2 @@\n+Add configuration with plone/meta.\n+[gforcada]\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..7ff4077 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,3 +1,5 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n [tool.towncrier]\n filename = "CHANGES.rst"\n directory = "news/"\n@@ -18,3 +20,27 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "internal"\n+name = "Internal:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "documentation"\n+name = "Documentation:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "tests"\n+name = "Tests"\n+showcontent = true\n+\n+[tool.isort]\n+profile = "plone"\n+\n+[tool.black]\n+target-version = ["py38"]\n+\n+[tool.dependencychecker]\n+Zope = [\'Products.PageTemplates\', \'ZPublisher\', ]\ndiff --git a/setup.cfg b/setup.cfg\nindex aecfa92..8849fbc 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,9 +1,23 @@\n-[check-manifest]\n-ignore =\n-    *.cfg\n-    bootstrap.py\n-\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[bdist_wheel]\n+universal = 0\n \n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n \n-[bdist_wheel]\n-universal = 1\n+[check-manifest]\n+ignore =\n+    .editorconfig\n+    .meta.toml\n+    tox.ini\n+    lint-requirements.txt\ndiff --git a/setup.py b/setup.py\nindex a1614c3..e3ecec9 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,71 +1,71 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n \n-name = \'borg.localrole\'\n-version = \'3.1.10.dev0\'\n+name = "borg.localrole"\n+version = "3.1.10.dev0"\n \n-readme = open(\'README.rst\').read()\n-history = open(\'CHANGES.rst\').read()\n+readme = open("README.rst").read()\n+history = open("CHANGES.rst").read()\n \n setup(\n     name=name,\n     version=version,\n-    description=\'A PAS plugin which can manage local roles via an \'\n-                \'adapter lookup on the current context\',\n-    long_description=readme + \'\\n\' + history,\n-    keywords=\'Plone PAS local roles\',\n-    author=\'Borg Collective\',\n-    author_email=\'borg@plone.org\',\n-    url=\'https://pypi.org/project/borg.localrole\',\n-    license=\'LGPL\',\n+    description="A PAS plugin which can manage local roles via an "\n+    "adapter lookup on the current context",\n+    long_description=readme + "\\n" + history,\n+    keywords="Plone PAS local roles",\n+    author="Borg Collective",\n+    author_email="borg@plone.org",\n+    url="https://pypi.org/project/borg.localrole",\n+    license="LGPL",\n     packages=find_packages(),\n-    namespace_packages=[\'borg\'],\n+    namespace_packages=["borg"],\n     include_package_data=True,\n-    platforms=\'Any\',\n+    platforms="Any",\n     zip_safe=False,\n+    python_requires=">=3.8",\n     extras_require=dict(\n         test=[\n-            \'plone.app.testing\',\n+            "plone.app.testing",\n+            "plone.testing",\n         ],\n     ),\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'zope.annotation\',\n-        \'zope.component\',\n-        \'zope.deferredimport\',\n-        \'zope.interface\',\n-        \'Products.CMFCore\',\n-        \'Products.GenericSetup\',\n-        \'Products.PlonePAS >= 5.0.1\',\n-        \'Products.PluggableAuthService\',\n-        \'plone.memoize\',\n-        \'Acquisition\',\n-        "Zope2;python_version<\'3\'",\n-        "Zope;python_version>=\'3.6\'",\n+        "AccessControl",\n+        "setuptools",\n+        "zope.annotation",\n+        "zope.component",\n+        "zope.deferredimport",\n+        "zope.interface",\n+        "Products.CMFCore",\n+        "Products.GenericSetup",\n+        "Products.PlonePAS >= 5.0.1",\n+        "Products.PluggableAuthService",\n+        "plone.memoize",\n+        "Acquisition",\n+        "Zope",\n     ],\n     classifiers=[\n-        \'Development Status :: 5 - Production/Stable\',\n-        \'Environment :: Web Environment\',\n-        \'Framework :: Plone\',\n-        \'Framework :: Plone :: 5.0\',\n-        \'Framework :: Plone :: 5.1\',\n-        \'Framework :: Plone :: 5.2\',\n-        \'Framework :: Plone :: Core\',\n-        \'Intended Audience :: Other Audience\',\n-        \'Intended Audience :: System Administrators\',\n-        \'License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)\',  # noqa\n-        \'Operating System :: OS Independent\',\n-        \'Programming Language :: Python\',\n-        \'Programming Language :: Python :: 2.7\',\n-        \'Programming Language :: Python :: 3.6\',\n-        \'Programming Language :: Python :: 3.7\',\n-        \'Programming Language :: Python :: 3.8\',\n-        \'Programming Language :: Python :: 3.9\',\n-        \'Programming Language :: Python :: 3.10\',\n-        \'Programming Language :: Python :: 3.11\',\n-        \'Topic :: Software Development :: Libraries :: Python Modules\',\n+        "Development Status :: 5 - Production/Stable",\n+        "Environment :: Web Environment",\n+        "Framework :: Plone",\n+        "Framework :: Plone :: 5.0",\n+        "Framework :: Plone :: 5.1",\n+        "Framework :: Plone :: 5.2",\n+        "Framework :: Plone :: Core",\n+        "Intended Audience :: Other Audience",\n+        "Intended Audience :: System Administrators",\n+        "License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)",  # noqa\n+        "Operating System :: OS Independent",\n+        "Programming Language :: Python",\n+        "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.6",\n+        "Programming Language :: Python :: 3.7",\n+        "Programming Language :: Python :: 3.8",\n+        "Programming Language :: Python :: 3.9",\n+        "Programming Language :: Python :: 3.10",\n+        "Programming Language :: Python :: 3.11",\n+        "Topic :: Software Development :: Libraries :: Python Modules",\n     ],\n )\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..5a29bed\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,75 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/master/config/default\n+[tox]\n+envlist =\n+    format\n+    lint\n+\n+[testenv]\n+py_files = git ls-files "*.py"\n+text_files = git ls-files "*.rst" "*.md"\n+xml_files = git ls-files "*.xml"\n+zcml_files = git ls-files "*.zcml"\n+allowlist_externals =\n+    sh\n+\n+[testenv:format]\n+description = automatically reformat python code\n+skip_install = true\n+deps =\n+    pyupgrade\n+    isort\n+    black\n+    zpretty\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'{[testenv]py_files} | xargs pyupgrade --py38-plus\'\n+    sh -c \'{[testenv]py_files} | xargs isort\'\n+    sh -c \'{[testenv]py_files} | xargs black\'\n+    sh -c \'{[testenv]xml_files} | xargs zpretty -x -i || true\'\n+    sh -c \'{[testenv]zcml_files} | xargs zpretty -z -i || true\'\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    flake8\n+    codespell\n+    tomli  # needed for codespell to read pyproject.toml\n+    check-manifest\n+    pyroma\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'{[testenv]py_files} | xargs flake8\'\n+    sh -c \'{[testenv]py_files} | xargs codespell\'\n+    sh -c \'{[testenv]text_files} | xargs codespell\'\n+    check-manifest\n+    pyroma -n 10 .\n+\n+[testenv:dependencies]\n+description = check if the package defines all its dependencies\n+deps =\n+    z3c.dependencychecker\n+    -c lint-requirements.txt\n+commands =\n+    dependencychecker\n+\n+[testenv:dependencies-graph]\n+description = generate a graph with the distribution dependencies\n+deps =\n+    pipdeptree\n+    graphviz  # optional dependency of pipdeptree\n+    -c lint-requirements.txt\n+commands =\n+    sh -c \'pipdeptree --exclude setuptools,pipdeptree,wheel --graph-output svg > dependencies.svg\'\n+\n+[testenv:test]\n+description = run the distribution\'s tests\n+deps =\n+    borg.localrole[test]\n+    pytest\n+    gocept.pytestlayer\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    pip install -e .\n+    pytest\n'

