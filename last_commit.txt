Repository: plone.supermodel


Branch: refs/heads/master
Date: 2018-07-31T00:36:35+02:00
Author: Roel Bruggink (jaroel) <roel@jaroel.nl>
Commit: https://github.com/plone/plone.supermodel/commit/87d66da496c911fbb4152709a9bad5be81708bff

Somehow plone.dexterity makes an InterfaceClass with an &lt;implementedBy ?&gt; with a VerifyingAdapterLookup, which doesn't have a dependents attribute. Not sure why tf this is happening.

Files changed:
M plone/supermodel/model.py

b"diff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex 37fc620..791e313 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -106,10 +106,12 @@ def finalizeSchemas(parent=Schema):\n         )\n \n     def walk(schema):\n-        yield schema\n-        for child in schema.dependents.keys():\n-            for s in walk(child):\n-                yield s\n+        if isinstance(schema, SchemaClass):\n+            yield schema\n+            for child in schema.dependents.keys():\n+                for s in walk(child):\n+                    yield s\n+\n     schemas = set(walk(parent))\n     for schema in schemas:\n         if hasattr(schema, '_SchemaClass_finalize'):\n"

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2019-02-11T22:11:48+01:00
Author: Roel Bruggink (jaroel) <roel@jaroel.nl>
Commit: https://github.com/plone/plone.supermodel/commit/5e1105203ba459b32a524cb67bcee441dd1ae2aa

Merge remote-tracking branch 'origin/master' into dx-siteroot

Files changed:
A news/.gitkeep
A pyproject.toml
M CHANGES.rst
M MANIFEST.in
M plone/supermodel/__init__.py
M plone/supermodel/configure.zcml
M plone/supermodel/converters.py
M plone/supermodel/directives.py
M plone/supermodel/directives.rst
M plone/supermodel/exportimport.py
M plone/supermodel/fields.rst
M plone/supermodel/model.py
M plone/supermodel/parser.py
M plone/supermodel/schema.rst
M plone/supermodel/schemaclass.rst
M plone/supermodel/tests.py
M plone/supermodel/utils.py
M setup.cfg
M setup.py
D .gitattributes

b'diff --git a/.gitattributes b/.gitattributes\ndeleted file mode 100644\nindex 6f9ff67..0000000\n--- a/.gitattributes\n+++ /dev/null\n@@ -1 +0,0 @@\n-CHANGES.rst merge=union\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex 34e2530..4db0d29 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -1,20 +1,20 @@\n Changelog\n =========\n \n-1.3.5 (unreleased)\n-------------------\n+.. You should *NOT* be adding new change log entries to this file.\n+   You should create a file in the news directory instead.\n+   For helpful instructions, please see:\n+   https://github.com/plone/plone.releaser/blob/master/ADD-A-NEWS-ITEM.rst\n \n-Breaking changes:\n+.. towncrier release notes start\n \n-- *add item here*\n+1.4.0 (2018-09-28)\n+------------------\n \n New features:\n \n-- *add item here*\n-\n-Bug fixes:\n-\n-- *add item here*\n+- Python 3 compatibility.\n+  [pbauer, davilima6, dhavlik, ale-rt]\n \n \n 1.3.4 (2017-11-24)\ndiff --git a/MANIFEST.in b/MANIFEST.in\nindex 2d4d0de..ed8c573 100644\n--- a/MANIFEST.in\n+++ b/MANIFEST.in\n@@ -1,6 +1,10 @@\n include *.txt *.rst\n+include pyproject.toml\n \n recursive-include docs *\n recursive-include plone *\n \n global-exclude *pyc\n+\n+recursive-exclude news *\n+exclude news\ndiff --git a/news/.gitkeep b/news/.gitkeep\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/plone/supermodel/__init__.py b/plone/supermodel/__init__.py\nindex 5b3a582..6ccce91 100644\n--- a/plone/supermodel/__init__.py\n+++ b/plone/supermodel/__init__.py\n@@ -1,13 +1,15 @@\n # -*- coding: utf-8 -*-\n+from io import BytesIO\n from plone.supermodel import model\n from plone.supermodel import parser\n from plone.supermodel import serializer\n from plone.supermodel import utils\n from plone.supermodel.interfaces import FILENAME_KEY\n from plone.supermodel.interfaces import IXMLToSchema\n-from six import StringIO\n from zope.interface import moduleProvides\n \n+import six\n+\n \n # Cache models by absolute filename\n _model_cache = {}\n@@ -30,7 +32,9 @@ def loadFile(filename, reload=False, policy=u"", _frame=2):\n \n \n def loadString(model, policy=u""):\n-    return parser.parse(StringIO(model), policy=policy)\n+    if not isinstance(model, six.binary_type):\n+        model = model.encode()\n+    return parser.parse(BytesIO(model), policy=policy)\n \n \n def serializeSchema(schema, name=u""):\ndiff --git a/plone/supermodel/configure.zcml b/plone/supermodel/configure.zcml\nindex cd8491c..adee0b7 100644\n--- a/plone/supermodel/configure.zcml\n+++ b/plone/supermodel/configure.zcml\n@@ -40,6 +40,7 @@\n \n     <adapter factory=".converters.ObjectFromUnicode" />\n \n+    <adapter factory=".converters.BytesToUnicode" />\n \n     <!-- Field handlers for all of zope.schema -->\n \ndiff --git a/plone/supermodel/converters.py b/plone/supermodel/converters.py\nindex dbe9004..1458a46 100644\n--- a/plone/supermodel/converters.py\n+++ b/plone/supermodel/converters.py\n@@ -4,6 +4,7 @@\n from zope.component import adapter\n from zope.dottedname.resolve import resolve\n from zope.interface import implementer\n+from zope.schema.interfaces import IBytes\n from zope.schema.interfaces import IDate\n from zope.schema.interfaces import IDatetime\n from zope.schema.interfaces import IField\n@@ -37,6 +38,8 @@ def __init__(self, context):\n         self.context = context\n \n     def toUnicode(self, value):\n+        if isinstance(value, six.binary_type):\n+            return value.decode()\n         return six.text_type(value)\n \n \n@@ -116,3 +119,16 @@ def fromUnicode(self, value):\n         obj = resolve(value)\n         self.context.validate(obj)\n         return obj\n+\n+\n+@implementer(IToUnicode)\n+@adapter(IBytes)\n+class BytesToUnicode(object):\n+\n+    def __init__(self, context):\n+        self.context = context\n+\n+    def toUnicode(self, value):\n+        if isinstance(value, six.binary_type):\n+            return value.decode()\n+        return six.text_type(value)\ndiff --git a/plone/supermodel/directives.py b/plone/supermodel/directives.py\nindex 3591b46..77cda7a 100644\n--- a/plone/supermodel/directives.py\n+++ b/plone/supermodel/directives.py\n@@ -81,8 +81,8 @@ def check(self):\n         for fieldName in self.fieldNames():\n             if fieldName not in schema:\n                 raise ValueError(\n-                    u"The directive {0} applied to interface {1} "\n-                    u"refers to unknown field name {2}".format(\n+                    u\'The directive {0} applied to interface {1} \'\n+                    u\'refers to unknown field name {2}\'.format(\n                         self.key,\n                         schema.__identifier__,\n                         fieldName\n@@ -130,10 +130,10 @@ class load(Directive):\n     """\n \n     def store(self, tags, value):\n-        tags[FILENAME_KEY] = value["filename"]\n-        tags[SCHEMA_NAME_KEY] = value["schema"]\n+        tags[FILENAME_KEY] = value[\'filename\']\n+        tags[SCHEMA_NAME_KEY] = value[\'schema\']\n \n-    def factory(self, filename, schema=u""):\n+    def factory(self, filename, schema=u\'\'):\n         return dict(filename=filename, schema=schema)\n \n \n@@ -151,7 +151,7 @@ def __call__(self):\n         filename = interface.queryTaggedValue(FILENAME_KEY, None)\n         if filename is None:\n             return\n-        schema = interface.queryTaggedValue(SCHEMA_NAME_KEY, u"")\n+        schema = interface.queryTaggedValue(SCHEMA_NAME_KEY, u\'\')\n \n         moduleName = interface.__module__\n         module = sys.modules.get(moduleName, None)\n@@ -161,7 +161,7 @@ def __call__(self):\n         if hasattr(module, \'__path__\'):\n             directory = module.__path__[0]\n         else:\n-            while "." in moduleName:\n+            while \'.\' in moduleName:\n                 moduleName, _ = moduleName.rsplit(\'.\', 1)\n                 module = sys.modules.get(moduleName, None)\n                 if hasattr(module, \'__path__\'):\n@@ -176,8 +176,8 @@ def __call__(self):\n         model = loadFile(filename)\n         if schema not in model.schemata:\n             raise ValueError(\n-                u"Schema \'{0}\' specified for interface {1} does not exist "\n-                "in {2}.".format(\n+                \'Schema "{0}" specified for interface {1} does not exist \'\n+                \'in {2}.\'.format(\n                     schema,\n                     interface.__identifier__,\n                     filename,\ndiff --git a/plone/supermodel/directives.rst b/plone/supermodel/directives.rst\nindex dc967a7..24117e1 100644\n--- a/plone/supermodel/directives.rst\n+++ b/plone/supermodel/directives.rst\n@@ -13,7 +13,7 @@ Setup\n \n First, load this package\'s configuration:\n \n-    >>> configuration = """\\\n+    >>> configuration = b"""\\\n     ... <configure\n     ...      xmlns="http://namespaces.zope.org/zope"\n     ...      i18n_domain="plone.supermodel.tests">\n@@ -25,9 +25,9 @@ First, load this package\'s configuration:\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from io import BytesIO\n     >>> from zope.configuration import xmlconfig\n-    >>> xmlconfig.xmlconfig(StringIO(configuration))\n+    >>> xmlconfig.xmlconfig(BytesIO(configuration))\n \n We will also need a temporary directory for storing test schema files.\n \n@@ -76,7 +76,7 @@ temporary directory created above.\n \n     >>> schema_filename = os.path.join(tmpdir, "schema.xml")\n     >>> schema_file = open(schema_filename, "w")\n-    >>> schema_file.write(schema)\n+    >>> _ = schema_file.write(schema)  # On Python 3 this returns the length\n     >>> schema_file.close()\n \n We can now define a schema, using the directives defined in this package:\n@@ -108,7 +108,7 @@ We can also use a different, named schema:\n     >>> class ITestMetadata(model.Schema):\n     ...     """Test metadata schema, built from XML\n     ...     """\n-    ...     model.load(schema_filename, schema=u"metadata")\n+    ...     model.load(schema_filename, schema=u\'metadata\')\n \n     >>> getFieldNamesInOrder(ITestMetadata)\n     [\'created\', \'creator\']\ndiff --git a/plone/supermodel/exportimport.py b/plone/supermodel/exportimport.py\nindex 0270c03..0694f61 100644\n--- a/plone/supermodel/exportimport.py\n+++ b/plone/supermodel/exportimport.py\n@@ -23,7 +23,7 @@\n \n try:\n     from collections import OrderedDict\n-except:\n+except ImportError:\n     from zope.schema.vocabulary import OrderedDict  # <py27\n \n \n@@ -398,8 +398,8 @@ def write(self, field, name, type, elementName=\'field\'):\n             value = []\n             for term in field.vocabulary:\n                 if (\n-                    not isinstance(term.value, six.string_types, ) or\n-                    term.token != term.value.encode(\'unicode_escape\')\n+                    not isinstance(term.value, six.string_types) or\n+                    six.b(term.token) != term.value.encode(\'unicode_escape\')\n                 ):\n                     raise NotImplementedError(\n                         u"Cannot export a vocabulary that is not "\ndiff --git a/plone/supermodel/fields.rst b/plone/supermodel/fields.rst\nindex b245cea..3f1544c 100644\n--- a/plone/supermodel/fields.rst\n+++ b/plone/supermodel/fields.rst\n@@ -18,7 +18,7 @@ limitations:\n \n First, let\'s wire up the package.\n \n-    >>> configuration = """\\\n+    >>> configuration = b"""\\\n     ... <configure\n     ...      xmlns="http://namespaces.zope.org/zope"\n     ...      i18n_domain="plone.behavior.tests">\n@@ -30,35 +30,36 @@ First, let\'s wire up the package.\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from io import BytesIO\n     >>> from zope.configuration import xmlconfig\n-    >>> xmlconfig.xmlconfig(StringIO(configuration))\n+    >>> xmlconfig.xmlconfig(BytesIO(configuration))\n \n Then, let\'s test each field in turn.\n \n-    >>> from zope.component import getUtility\n-    >>> from zope import schema\n-\n+    >>> from lxml import etree\n     >>> from plone.supermodel.interfaces import IFieldExportImportHandler\n     >>> from plone.supermodel.interfaces import IFieldNameExtractor\n     >>> from plone.supermodel.utils import prettyXML\n+    >>> from zope import schema\n+    >>> from zope.component import getUtility\n \n     >>> import datetime\n     >>> import plone.supermodel.tests\n+    >>> import six\n \n-    >>> from lxml import etree\n \n Bytes\n -----\n \n     >>> field = schema.Bytes(__name__="dummy", title=u"Test",\n     ...     description=u"Test desc", required=False, readonly=True,\n-    ...     default=\'abc\', missing_value=\'m\',\n+    ...     default=b\'abc\', missing_value=b\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> from __future__ import print_function\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Bytes">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -83,10 +84,10 @@ Bytes\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n-    \'abc\'\n-    >>> reciprocal.missing_value\n-    \'m\'\n+    >>> reciprocal.default.decode(\'latin-1\')\n+    u\'abc\'\n+    >>> reciprocal.missing_value.decode(\'latin-1\')\n+    u\'m\'\n     >>> reciprocal.min_length\n     2\n     >>> reciprocal.max_length\n@@ -99,12 +100,12 @@ BytesLine\n \n     >>> field = schema.BytesLine(__name__="dummy", title=u"Test",\n     ...     description=u"Test desc", required=False, readonly=True,\n-    ...     default=\'abc\', missing_value=\'m\',\n+    ...     default=b\'abc\', missing_value=b\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.BytesLine">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -129,10 +130,10 @@ BytesLine\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n-    \'abc\'\n-    >>> reciprocal.missing_value\n-    \'m\'\n+    >>> reciprocal.default.decode(\'latin-1\')\n+    u\'abc\'\n+    >>> reciprocal.missing_value.decode(\'latin-1\')\n+    u\'m\'\n     >>> reciprocal.min_length\n     2\n     >>> reciprocal.max_length\n@@ -143,14 +144,14 @@ BytesLine\n ASCII\n -----\n \n-    >>> field = schema.ASCII(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.ASCII(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'abc\', missing_value=\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.ASCII">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -189,14 +190,14 @@ ASCII\n ASCIILine\n ---------\n \n-    >>> field = schema.ASCIILine(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.ASCIILine(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'abc\', missing_value=\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.ASCIILine">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -235,14 +236,14 @@ ASCIILine\n Text\n ----\n \n-    >>> field = schema.Text(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Text(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=u\'abc\', missing_value=u\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Text">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -281,14 +282,14 @@ Text\n TextLine\n --------\n \n-    >>> field = schema.TextLine(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.TextLine(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=u\'abc\', missing_value=u\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.TextLine">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -327,14 +328,14 @@ TextLine\n SourceText\n ----------\n \n-    >>> field = schema.SourceText(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.SourceText(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=u\'abc\', missing_value=u\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.SourceText">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -373,14 +374,14 @@ SourceText\n URI\n ---\n \n-    >>> field = schema.URI(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.URI(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'http://plone.org\', missing_value=\'m\',\n     ...     min_length=2, max_length=100)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.URI">\n       <default>http://plone.org</default>\n       <description>Test desc</description>\n@@ -419,14 +420,14 @@ URI\n Id\n --\n \n-    >>> field = schema.Id(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Id(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a.b.c\', missing_value=\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Id">\n       <default>a.b.c</default>\n       <description>Test desc</description>\n@@ -465,14 +466,14 @@ Id\n DottedName\n -----------\n \n-    >>> field = schema.DottedName(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.DottedName(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a.b.c\', missing_value=\'m\',\n     ...     min_length=2, max_length=10, min_dots=2, max_dots=4)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.DottedName">\n       <default>a.b.c</default>\n       <description>Test desc</description>\n@@ -517,14 +518,14 @@ DottedName\n Password\n --------\n \n-    >>> field = schema.Password(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Password(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=u\'abc\', missing_value=u\'m\',\n     ...     min_length=2, max_length=10)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Password">\n       <default>abc</default>\n       <description>Test desc</description>\n@@ -563,13 +564,13 @@ Password\n Bool\n ----\n \n-    >>> field = schema.Bool(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Bool(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=False, missing_value=True)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Bool">\n       <default>False</default>\n       <description>Test desc</description>\n@@ -602,14 +603,14 @@ Bool\n Int\n ---\n \n-    >>> field = schema.Int(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Int(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=12, missing_value=-1,\n     ...     min=1, max=99)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Int">\n       <default>12</default>\n       <description>Test desc</description>\n@@ -648,14 +649,14 @@ Int\n Float\n -----\n \n-    >>> field = schema.Float(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Float(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=12.1, missing_value=-1.0,\n     ...     min=1.123, max=99.5)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Float">\n       <default>12.1</default>\n       <description>Test desc</description>\n@@ -695,14 +696,14 @@ Decimal\n -------\n \n     >>> import decimal\n-    >>> field = schema.Decimal(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Decimal(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=decimal.Decimal("12.1"), missing_value=decimal.Decimal("-1.0"),\n     ...     min=decimal.Decimal("1.123"), max=decimal.Decimal("99.5"))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Decimal">\n       <default>12.1</default>\n       <description>Test desc</description>\n@@ -741,14 +742,14 @@ Decimal\n Date\n ----\n \n-    >>> field = schema.Date(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Date(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=datetime.date(2001,1,2), missing_value=datetime.date(2000,1,1),\n     ...     min=datetime.date(2000,10,12), max=datetime.date(2099,12,31))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Date">\n       <default>2001-01-02</default>\n       <description>Test desc</description>\n@@ -787,14 +788,14 @@ Date\n Datetime\n ---------\n \n-    >>> field = schema.Datetime(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Datetime(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=datetime.datetime(2001,1,2,1,2,3), missing_value=datetime.datetime(2000,1,1,2,3,4),\n     ...     min=datetime.datetime(2000,10,12,0,0,2), max=datetime.datetime(2099,12,31,1,2,2))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Datetime">\n       <default>2001-01-02 01:02:03</default>\n       <description>Test desc</description>\n@@ -833,14 +834,14 @@ Datetime\n InterfaceField\n ---------------\n \n-    >>> field = schema.InterfaceField(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.InterfaceField(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=plone.supermodel.tests.IDummy,\n     ...     missing_value=plone.supermodel.tests.IDummy)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.InterfaceField">\n       <default>plone.supermodel.tests.IDummy</default>\n       <description>Test desc</description>\n@@ -873,15 +874,15 @@ InterfaceField\n Tuple\n -----\n \n-    >>> field = schema.Tuple(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Tuple(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=(1,2), missing_value=(),\n     ...     min_length=2, max_length=10,\n     ...     value_type=schema.Int(title=u"Val"))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Tuple">\n       <default>\n         <element>1</element>\n@@ -922,23 +923,23 @@ Tuple\n     10\n     >>> reciprocal.value_type.__class__\n     <class \'zope.schema._bootstrapfields.Int\'>\n-    >>> reciprocal.value_type.title\n-    u\'Val\'\n+    >>> reciprocal.value_type.title == u\'Val\'\n+    True\n     >>> reciprocal._init_field\n     False\n \n List\n ----\n \n-    >>> field = schema.List(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.List(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=[1,2], missing_value=[],\n     ...     min_length=2, max_length=10,\n     ...     value_type=schema.Int(title=u"Val"))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.List">\n       <default>\n         <element>1</element>\n@@ -961,10 +962,10 @@ List\n     <class \'zope.schema._field.List\'>\n     >>> reciprocal.__name__\n     \'dummy\'\n-    >>> reciprocal.title\n-    u\'Test\'\n-    >>> reciprocal.description\n-    u\'Test desc\'\n+    >>> reciprocal.title == u\'Test\'\n+    True\n+    >>> reciprocal.description == u\'Test desc\'\n+    True\n     >>> reciprocal.required\n     False\n     >>> reciprocal.readonly\n@@ -987,15 +988,15 @@ List\n Set\n ---\n \n-    >>> field = schema.Set(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Set(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=set((1,2)), missing_value=set(),\n     ...     min_length=2, max_length=10,\n     ...     value_type=schema.Int(title=u"Val"))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Set">\n       <default>\n         <element>1</element>\n@@ -1026,10 +1027,10 @@ Set\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n-    set([1, 2])\n-    >>> reciprocal.missing_value\n-    set([])\n+    >>> reciprocal.default == {1, 2}\n+    True\n+    >>> reciprocal.missing_value == set()\n+    True\n     >>> reciprocal.min_length\n     2\n     >>> reciprocal.max_length\n@@ -1044,15 +1045,15 @@ Set\n FrozenSet\n ---------\n \n-    >>> field = schema.FrozenSet(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.FrozenSet(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=frozenset((1,2)), missing_value=frozenset(),\n     ...     min_length=2, max_length=10,\n     ...     value_type=schema.Int(title=u"Val"))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.FrozenSet">\n       <default>\n         <element>1</element>\n@@ -1083,10 +1084,14 @@ FrozenSet\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n-    frozenset([1, 2])\n-    >>> reciprocal.missing_value\n-    frozenset([])\n+    >>> isinstance(reciprocal.default, frozenset)\n+    True\n+    >>> list(reciprocal.default)\n+    [1, 2]\n+    >>> isinstance(reciprocal.missing_value, frozenset)\n+    True\n+    >>> len(reciprocal.missing_value)\n+    0\n     >>> reciprocal.min_length\n     2\n     >>> reciprocal.max_length\n@@ -1101,16 +1106,16 @@ FrozenSet\n Dict\n ----\n \n-    >>> field = schema.Dict(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Dict(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default={\'a\':1, \'b\':2}, missing_value={},\n     ...     min_length=2, max_length=10,\n-    ...     key_type=schema.ASCIILine(title=u"Key"),\n-    ...     value_type=schema.Int(title=u"Val"))\n+    ...     key_type=schema.ASCIILine(title=u\'Key\'),\n+    ...     value_type=schema.Int(title=u\'Val\'))\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Dict">\n       <default>\n         <element key="a">1</element>\n@@ -1144,8 +1149,12 @@ Dict\n     False\n     >>> reciprocal.readonly\n     True\n-    >>> reciprocal.default\n-    {\'a\': 1, \'b\': 2}\n+    >>> reciprocal.default[\'a\']\n+    1\n+    >>> reciprocal.default[\'b\']\n+    2\n+    >>> sorted(reciprocal.default.keys())\n+    [\'a\', \'b\']\n     >>> reciprocal.missing_value\n     {}\n     >>> reciprocal.min_length\n@@ -1172,14 +1181,14 @@ fields will be omitted, as there is no way to write these reliably.\n     >>> dummy1 = plone.supermodel.tests.Dummy()\n     >>> dummy2 = plone.supermodel.tests.Dummy()\n \n-    >>> field = schema.Object(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Object(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=dummy1, missing_value=dummy2,\n     ...     schema=plone.supermodel.tests.IDummy)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType) #doctest: +ELLIPSIS\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Object">\n       <description>Test desc</description>\n       <readonly>True</readonly>\n@@ -1204,8 +1213,8 @@ object field that references a particular dotted name.\n     ... """)\n \n     >>> reciprocal = handler.read(element)\n-    >>> reciprocal.__class__\n-    <class \'zope.schema._field.Object\'>\n+    >>> isinstance(reciprocal, schema._field.Object)\n+    True\n     >>> reciprocal.__name__\n     \'dummy\'\n     >>> reciprocal.title\n@@ -1237,14 +1246,14 @@ dotted name.\n \n These can be both exported and imported.\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a\', missing_value=\'\', vocabulary=u\'dummy.vocab\')\n \n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Choice">\n       <default>a</default>\n       <description>Test desc</description>\n@@ -1284,14 +1293,14 @@ These can be both exported and imported.\n These can be both imported and exported, but note that the value is always\n a unicode string when importing.\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a\', missing_value=\'\', values=[\'a\', \'b\', \'c\'])\n \n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Choice">\n       <default>a</default>\n       <description>Test desc</description>\n@@ -1323,8 +1332,8 @@ a unicode string when importing.\n     \'a\'\n     >>> reciprocal.missing_value\n     \'\'\n-    >>> [t.value for t in reciprocal.vocabulary]\n-    [u\'a\', u\'b\', u\'c\']\n+    >>> [t.value for t in reciprocal.vocabulary] == [u\'a\', u\'b\', u\'c\']\n+    True\n     >>> reciprocal.vocabularyName is None\n     True\n \n@@ -1333,27 +1342,28 @@ sure it hasn\'t regressed.\n \n     >>> from plone.supermodel.interfaces import XML_NAMESPACE\n     >>> element.set(\'xmlns\', XML_NAMESPACE)\n-    >>> element = etree.parse(StringIO(prettyXML(element))).getroot()\n+    >>> from io import BytesIO\n+    >>> element = etree.parse(BytesIO(prettyXML(element).encode())).getroot()\n     >>> reciprocal = handler.read(element)\n-    >>> [t.value for t in reciprocal.vocabulary]\n-    [u\'a\', u\'b\', u\'c\']\n+    >>> [t.value for t in reciprocal.vocabulary] == [u\'a\', u\'b\', u\'c\']\n+    True\n \n Also, make sure we can handle terms with unicode values (as long as their\n tokens are the utf8-encoded values).\n \n     >>> from zope.schema.vocabulary import SimpleVocabulary, SimpleTerm\n     >>> vocab = SimpleVocabulary([\n-    ...     SimpleTerm(token=\'a\', value=u\'a\', title=u\'a\'),\n+    ...     SimpleTerm(token=b\'a\', value=u\'a\', title=u\'a\'),\n     ...     SimpleTerm(token=r\'\\xe7\', value=u\'\\xe7\', title=u\'\\xe7\'), # c with cedilla\n     ...     ])\n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     default=\'a\', missing_value=\'\', vocabulary=vocab)\n \n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Choice">\n       <default>a</default>\n       <description>Test desc</description>\n@@ -1368,8 +1378,8 @@ tokens are the utf8-encoded values).\n     </field>\n \n     >>> reciprocal = handler.read(element)\n-    >>> [t.value for t in reciprocal.vocabulary]\n-    [u\'a\', u\'\\xe7\']\n+    >>> [t.value for t in reciprocal.vocabulary] == [u\'a\', u\'\\xe7\']\n+    True\n \n \n Additionally, it is possible for Choice fields with a values vocabulary\n@@ -1384,13 +1394,13 @@ with how Dict fields are output, only for Choices, order is guaranteed).\n     ...     SimpleTerm(value=u\'b\', title=u\'B\'),\n     ...     ])\n     >>> field = schema.Choice(\n-    ...     __name__="dummy",\n-    ...     title=u"Test",\n+    ...     __name__=\'dummy\',\n+    ...     title=u\'Test\',\n     ...     vocabulary=vocab,\n     ...     )\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, \'dummy\', fieldType)\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="zope.schema.Choice">\n       <title>Test</title>\n       <values>\n@@ -1403,8 +1413,8 @@ with how Dict fields are output, only for Choices, order is guaranteed).\n \n We cannot export choice fields with a source or context source binder:\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     vocabulary=plone.supermodel.tests.dummy_vocabulary_instance)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n@@ -1413,8 +1423,8 @@ We cannot export choice fields with a source or context source binder:\n     ...\n     NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     source=plone.supermodel.tests.dummy_vocabulary_instance)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n@@ -1423,8 +1433,8 @@ We cannot export choice fields with a source or context source binder:\n     ...\n     NotImplementedError: Cannot export a vocabulary that is not based on a simple list of values\n \n-    >>> field = schema.Choice(__name__="dummy", title=u"Test",\n-    ...     description=u"Test desc", required=False, readonly=True,\n+    >>> field = schema.Choice(__name__=\'dummy\', title=u\'Test\',\n+    ...     description=u\'Test desc\', required=False, readonly=True,\n     ...     source=plone.supermodel.tests.dummy_binder)\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\ndiff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex 791e313..b2cbdcd 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -89,6 +89,7 @@ def _SchemaClass_finalize(self):\n         for order, name, adapter in adapters:\n             adapter()\n \n+\n Schema = SchemaClass(\n     \'Schema\',\n     (Interface,),\n@@ -113,7 +114,7 @@ def walk(schema):\n                     yield s\n \n     schemas = set(walk(parent))\n-    for schema in schemas:\n+    for schema in sorted(schemas):\n         if hasattr(schema, \'_SchemaClass_finalize\'):\n             schema._SchemaClass_finalize()\n         elif isinstance(schema, InterfaceClass):\ndiff --git a/plone/supermodel/parser.py b/plone/supermodel/parser.py\nindex 10ba2eb..13a1088 100644\n--- a/plone/supermodel/parser.py\n+++ b/plone/supermodel/parser.py\n@@ -24,27 +24,27 @@\n import linecache\n import six\n import sys\n+import traceback\n \n \n # Exception\n-\n-\n class SupermodelParseError(Exception):\n \n-    def __init__(self, orig_exc, fname, element):\n+    def __init__(self, orig_exc, fname, element, tb):\n         msg = str(orig_exc)\n-\n         lineno = None\n         if hasattr(orig_exc, \'lineno\'):\n             lineno = orig_exc.lineno\n         elif element is not None:\n             lineno = getattr(element, \'sourceline\', \'unknown\')\n-\n         if fname or lineno != \'unknown\':\n             msg += \'\\n  File "%s", line %s\' % (fname or \'<unknown>\', lineno)\n         if fname and lineno:\n             line = linecache.getline(fname, lineno).strip()\n             msg += \'\\n    %s\' % line\n+        msg += \'\\n\'\n+        msg += \'\'.join(traceback.format_tb(tb))\n+        msg += \'\\n\'\n         self.args = [msg]\n \n \n@@ -75,11 +75,8 @@ def parse(source, policy=u""):\n         # the filename and line number of the element that caused the problem.\n         # Keep the original traceback so the developer can debug where the\n         # problem happened.\n-        six.reraise(SupermodelParseError(\n-            e,\n-            fname,\n-            parseinfo.stack[-1]\n-        ), None, sys.exc_info()[2])\n+        raise SupermodelParseError(\n+            e, fname, parseinfo.stack[-1], sys.exc_info()[2])\n \n \n def _parse(source, policy):\n@@ -110,7 +107,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                 \'<field /> element\'\n             )\n \n-        handler = handlers.get(fieldType, None)\n+        handler = handlers.get(fieldType)\n         if handler is None:\n             handler = handlers[fieldType] = queryUtility(\n                 IFieldExportImportHandler,\n@@ -126,7 +123,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n \n         # Preserve order from base interfaces if this field is an override\n         # of a field with the same name in a base interface\n-        base_field = baseFields.get(fieldName, None)\n+        base_field = baseFields.get(fieldName)\n         if base_field is not None:\n             field.order = base_field.order\n \n@@ -180,6 +177,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                     fieldElements,\n                     baseFields\n                 )\n+\n             elif subelement.tag == ns(\'fieldset\'):\n \n                 fieldset_name = subelement.get(\'name\')\n@@ -190,7 +188,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                         )\n                     )\n \n-                fieldset = fieldsets_by_name.get(fieldset_name, None)\n+                fieldset = fieldsets_by_name.get(fieldset_name)\n                 if fieldset is None:\n                     fieldset_label = subelement.get(\'label\')\n                     fieldset_description = subelement.get(\'description\')\n@@ -219,6 +217,7 @@ def readField(fieldElement, schemaAttributes, fieldElements, baseFields):\n                     if parsed_fieldName:\n                         fieldset.fields.append(parsed_fieldName)\n                     parseinfo.stack.pop()\n+\n             elif subelement.tag == ns(\'invariant\'):\n                 dotted = subelement.text\n                 invariant = resolve(dotted)\ndiff --git a/plone/supermodel/schema.rst b/plone/supermodel/schema.rst\nindex 4826284..bcf9e48 100644\n--- a/plone/supermodel/schema.rst\n+++ b/plone/supermodel/schema.rst\n@@ -14,7 +14,7 @@ Before we can begin, we must register the field handlers that know how to\n import and export fields from/to XML. These are registered as named utilities,\n and can be loaded from the configure.zcml file of plone.supermodel.\n \n-    >>> configuration = """\\\n+    >>> configuration = b"""\\\n     ... <configure\n     ...      xmlns="http://namespaces.zope.org/zope"\n     ...      i18n_domain="plone.supermodel.tests">\n@@ -26,9 +26,9 @@ and can be loaded from the configure.zcml file of plone.supermodel.\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from io import BytesIO\n     >>> from zope.configuration import xmlconfig\n-    >>> xmlconfig.xmlconfig(StringIO(configuration))\n+    >>> xmlconfig.xmlconfig(BytesIO(configuration))\n \n Next, let\'s define a sample model with a single, unnamed schema.\n \n@@ -58,27 +58,27 @@ We can parse this model using the loadString() function:\n \n This will load one schema, with the default name u"":\n \n-    >>> model.schemata.keys()\n-    [u\'\']\n+    >>> list(model.schemata.keys()) == [u\'\']\n+    True\n \n We can inspect this schema and see that it contains zope.schema fields with\n attributes corresponding to the values set in XML.\n \n-    >>> schema = model.schema # shortcut to model.schemata[u""]\n+    >>> schema = model.schema  # shortcut to model.schemata[u""]\n \n     >>> from zope.schema import getFieldNamesInOrder\n     >>> getFieldNamesInOrder(schema)\n     [\'title\', \'description\']\n \n-    >>> schema[\'title\'].title\n-    u\'Title\'\n+    >>> schema[\'title\'].title == u\'Title\'\n+    True\n     >>> schema[\'title\'].required\n     True\n \n-    >>> schema[\'description\'].title\n-    u\'Description\'\n-    >>> schema[\'description\'].description\n-    u\'A short summary\'\n+    >>> schema[\'description\'].title == u\'Description\'\n+    True\n+    >>> schema[\'description\'].description == u\'A short summary\'\n+    True\n     >>> schema[\'description\'].required\n     False\n     >>> schema[\'description\'].min_length\n@@ -106,7 +106,8 @@ lxml.)\n In addition to parsing, we can serialize a model to an XML representation:\n \n     >>> from plone.supermodel import serializeModel\n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> from __future__ import print_function\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -164,10 +165,9 @@ directory.\n \n     >>> import tempfile, os.path, shutil\n     >>> tmpdir = tempfile.mkdtemp()\n-    >>> schema_filename = os.path.join(tmpdir, "schema.xml")\n-    >>> schema_file = open(schema_filename, "w")\n-    >>> schema_file.write(schema)\n-    >>> schema_file.close()\n+    >>> schema_filename = os.path.join(tmpdir, \'schema.xml\')\n+    >>> with open(schema_filename, \'w\') as fd:\n+    ...     _ = fd.write(schema)  # On Py3 write resturns the schema len\n \n We can define interfaces from this using a helper function:\n \n@@ -185,7 +185,7 @@ After being loaded, the interface should have the fields of the default\n \n We can also use a different, named schema:\n \n-    >>> ITestMetadata = xmlSchema(schema_filename, schema=u"metadata")\n+    >>> ITestMetadata = xmlSchema(schema_filename, schema=u\'metadata\')\n     >>> getFieldNamesInOrder(ITestMetadata)\n     [\'created\', \'creator\']\n \n@@ -194,7 +194,7 @@ dict as per the serializeModel() method seen above, or you can write a model\n of just a single schema using serializeSchema():\n \n     >>> from plone.supermodel import serializeSchema\n-    >>> print serializeSchema(ITestContent) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeSchema(ITestContent)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -207,7 +207,7 @@ of just a single schema using serializeSchema():\n       </schema>\n     </model>\n \n-    >>> print serializeSchema(ITestMetadata, name=u"metadata") # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeSchema(ITestMetadata, name=u"metadata")) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema name="metadata">\n         <field name="created" type="zope.schema.Datetime">\n@@ -238,9 +238,9 @@ resolver needs to have a proper module path. The interface looks like this\n though:\n \n     class IBase(Interface):\n-        title = zope.schema.TextLine(title=u"Title")\n-        description = zope.schema.TextLine(title=u"Description")\n-        name = zope.schema.TextLine(title=u"Name")\n+        title = zope.schema.TextLine(title=u\'Title\')\n+        description = zope.schema.TextLine(title=u\'Description\')\n+        name = zope.schema.TextLine(title=u\'Name\')\n \n In real life, you\'d more likely have a dotted name like\n my.package.interfaces.IBase, of course.\n@@ -265,7 +265,7 @@ Then, let\'s define a schema that is based on this interface.\n Here, notice the use of the \'based-on\' attribute, which specifies a dotted\n name to the base interface. It is possible to specify multiple interfaces\n as a space-separated list. However, if you find that you need this, you\n-may want to ask yourself why. :) Inside the schema proper, we override the\n+may want to ask yourself why. :) Inside the proper schema, we override the\n \'description\' field and add a new field, \'age\'.\n \n When we load this model, we should find that the __bases__ list of the\n@@ -290,7 +290,7 @@ We should also verify that the description field was indeed overridden:\n \n Finally, let\'s verify that bases are preserved upon serialisation:\n \n-    >>> print serializeSchema(model.schema) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeSchema(model.schema)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema based-on="plone.supermodel.tests.IBase">\n         <field name="description" type="zope.schema.Text">\n@@ -397,13 +397,12 @@ default schema above is unrelated to the one in the metadata schema.\n     >>> model.schema.getTaggedValue(FIELDSETS_KEY)\n     [<Fieldset \'dates\' order 1 of publication_date, expiry_date, notification_date>]\n \n-    >>> model.schemata[u"metadata"].getTaggedValue(FIELDSETS_KEY)\n+    >>> model.schemata[u\'metadata\'].getTaggedValue(FIELDSETS_KEY)\n     [<Fieldset \'standard\' order 9999 of creator>, <Fieldset \'dates\' order 9999 of created>, <Fieldset \'author\' order 9999 of >]\n \n-When we serialise a schema with fieldsets, fields will be grouped by\n-fieldset.\n+When we serialise a schema with fieldsets, fields will be grouped by fieldset.\n \n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -472,8 +471,8 @@ a dotted name for the invariant function.\n     >>> model.schema.getTaggedValue(\'invariants\')\n     [<function dummy_invariant at ...>, <function dummy_invariant_prime at ...>]\n \n-When invariants are checked for our model.schema, we\'ll see our invariant\n-in action.\n+When invariants are checked for our model.schema, we\'ll see our invariant in\n+action.\n \n     >>> model.schema.validateInvariants(object())\n     Traceback (most recent call last):\n@@ -482,7 +481,7 @@ in action.\n \n The model\'s serialization should include the invariant.\n \n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema>\n         <invariant>plone.supermodel.tests.dummy_invariant</invariant>\n@@ -526,9 +525,9 @@ or we won\'t accept them.\n Internationalization\n --------------------\n \n-Translation domains and message ids can be specified for text\n-that is interpreted as unicode. This will result in deserialization\n-as a zope.i18nmessageid message id rather than a basic Unicode string::\n+Translation domains and message ids can be specified for text that is\n+interpreted as unicode. This will result in deserialization as a\n+zope.i18nmessageid message id rather than a basic Unicode string::\n \n     >>> schema = """\\\n     ... <?xml version="1.0" encoding="UTF-8"?>\n@@ -555,13 +554,13 @@ as a zope.i18nmessageid message id rather than a basic Unicode string::\n     ... """\n     >>> model = loadString(schema)\n     >>> msgid = model.schema[\'title\'].title\n-    >>> msgid\n-    u\'supermodel_test_title\'\n+    >>> msgid == u\'supermodel_test_title\'\n+    True\n     >>> type(msgid)\n     <... \'zope.i18nmessageid.message.Message\'>\n-    >>> msgid.default\n-    u\'Title\'\n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> msgid.default == u\'Title\'\n+    True\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns="http://namespaces.plone.org/supermodel/schema" i18n:domain="plone.supermodel">\n       <schema>\n         <field name="title" type="zope.schema.TextLine">\n@@ -610,17 +609,17 @@ may expect to be able to parse a format like this:\n We can register schema and field metadata handlers as named utilities.\n Metadata handlers should be able to reciprocally read and write metadata.\n \n-    >>> from zope.interface import implements\n+    >>> from zope.interface import implementer\n     >>> from zope.component import provideUtility\n \n     >>> from plone.supermodel.interfaces import ISchemaMetadataHandler\n     >>> from plone.supermodel.utils import ns\n \n-    >>> class FormLayoutMetadata(object):\n-    ...     implements(ISchemaMetadataHandler)\n+    >>> @implementer(ISchemaMetadataHandler)\n+    ... class FormLayoutMetadata(object):\n     ...\n-    ...     namespace = "http://namespaces.acme.com/ui"\n-    ...     prefix = "ui"\n+    ...     namespace = \'http://namespaces.acme.com/ui\'\n+    ...     prefix = \'ui\'\n     ...\n     ...     def read(self, schemaNode, schema):\n     ...         layout = schemaNode.get(ns(\'layout\', self.namespace))\n@@ -635,11 +634,11 @@ Metadata handlers should be able to reciprocally read and write metadata.\n     >>> provideUtility(component=FormLayoutMetadata(), name=\'acme.ui.schema\')\n \n     >>> from plone.supermodel.interfaces import IFieldMetadataHandler\n-    >>> class FieldWidgetMetadata(object):\n-    ...     implements(IFieldMetadataHandler)\n+    >>> @implementer(IFieldMetadataHandler)\n+    ... class FieldWidgetMetadata(object):\n     ...\n-    ...     namespace = "http://namespaces.acme.com/ui"\n-    ...     prefix = "ui"\n+    ...     namespace = \'http://namespaces.acme.com/ui\'\n+    ...     prefix = \'ui\'\n     ...\n     ...     def read(self, fieldNode, schema, field):\n     ...         name = field.__name__\n@@ -671,7 +670,7 @@ and each field, respectively.\n Of course, we can also serialize the schema back to XML. Here, the \'prefix\'\n set in the utility (if any) will be used by default.\n \n-    >>> print serializeModel(model) # doctest: +NORMALIZE_WHITESPACE\n+    >>> print(serializeModel(model)) # doctest: +NORMALIZE_WHITESPACE\n     <model xmlns:i18n="http://xml.zope.org/namespaces/i18n" xmlns:ui="http://namespaces.acme.com/ui" xmlns="http://namespaces.plone.org/supermodel/schema">\n       <schema ui:layout="horizontal">\n         <field name="title" type="zope.schema.TextLine" ui:widget="largetype">\ndiff --git a/plone/supermodel/schemaclass.rst b/plone/supermodel/schemaclass.rst\nindex a909c7e..66dee60 100644\n--- a/plone/supermodel/schemaclass.rst\n+++ b/plone/supermodel/schemaclass.rst\n@@ -4,28 +4,32 @@ plone.supermodel: SchemaClass\n \n     >>> from plone.supermodel.model import Schema, SchemaClass\n     >>> from plone.supermodel import interfaces\n-    >>> from zope.interface import Interface, implements\n-    >>> from zope.component import adapts, provideAdapter\n+    >>> from zope.interface import Interface, implementer\n+    >>> from zope.component import adapter, provideAdapter\n \n Schema plugins are registered as named adapters. They may optionally contain\n an order attribute, which defaults to 0.\n \n-    >>> class TestPlugin(object):\n-    ...     adapts(interfaces.ISchema)\n-    ...     implements(interfaces.ISchemaPlugin)\n+    >>> adapter_calls = []\n+    >>> @implementer(interfaces.ISchemaPlugin)\n+    ... @adapter(interfaces.ISchema)\n+    ... class TestPlugin(object):\n+    ...\n     ...     order = 1\n     ...     def __init__(self, schema):\n     ...         self.schema = schema\n     ...     def __call__(self):\n-    ...         print("%s: %r" % (self.__class__.__name__, self.schema))\n+    ...         adapter_calls.append(\n+    ...             (self.__class__.__name__,self.schema.__name__))\n     ...\n     >>> provideAdapter(TestPlugin, name=u"plone.supermodel.tests.TestPlugin")\n \n Schema plugins are executed at schema declaration.\n \n-    >>> class IA(Schema):\n+    >>> class IA(Schema):  # doctest: +ELLIPSIS\n     ...     pass\n-    TestPlugin: <SchemaClass __builtin__.IA>\n+    >>> adapter_calls == [(\'TestPlugin\', \'IA\')]\n+    True\n \n Any class descending from Schema becomes an instance of SchemaClass and has any\n schema plugins called.\n@@ -35,35 +39,50 @@ https://bugs.launchpad.net/zope.interface/+bug/791218 is resolved, this\n inheritance only works if the *first* base class is an instance of SchemaClass.\n So below I\'ve commented out the output that we hope for once that issue is\n resolved.\n+Somehow the issue got solved when using python 3, so we need to check python\n+version to get expected results here.\n \n+    >>> import six\n     >>> class ISomeInterface(Interface):\n     ...     pass\n \n+    >>> adapter_calls = []\n     >>> class IB(ISomeInterface, IA):\n     ...     pass\n+    >>> adapter_calls == ([] if six.PY2 else [(\'TestPlugin\', \'IB\')])\n+    True\n \n-#    TestPlugin: <SchemaClass __builtin__.IB>\n-\n+    >>> adapter_calls = []\n     >>> class IC(IB):\n     ...     pass\n-\n-#    TestPlugin: <SchemaClass __builtin__.IC>\n+    >>> adapter_calls == ([] if six.PY2 else [(\'TestPlugin\', \'IC\')])\n+    True\n \n To support the registration of schema plugins in ZCML, plugins are\n additionally executed at zope.configuration time with a ZCML order of 1000. To\n simulate this we will define another adapter and call the configuration action\n directly.\n \n+    >>> adapter_calls = []\n     >>> class TestPlugin2(TestPlugin):\n     ...     order = 0\n \n     >>> provideAdapter(TestPlugin2, name=u"plone.supermodel.tests.TestPlugin2")\n     >>> from plone.supermodel.model import finalizeSchemas\n-    >>> finalizeSchemas(IA)\n-    TestPlugin2: <SchemaClass __builtin__.IA>\n-    TestPlugin: <SchemaClass __builtin__.IA>\n \n-#    TestPlugin2: <SchemaClass __builtin__.IB>\n-#    TestPlugin: <SchemaClass __builtin__.IB>\n-#    TestPlugin2: <SchemaClass __builtin__.IC>\n-#    TestPlugin: <SchemaClass __builtin__.IC>\n+    >>> finalizeSchemas(IA)\n+    >>> adapter_calls == (\n+    ...     [\n+    ...         (\'TestPlugin2\', \'IA\'),\n+    ...         (\'TestPlugin\', \'IA\'),\n+    ...     ] if six.PY2 else [\n+    ...         (\'TestPlugin2\', \'IA\'),\n+    ...         (\'TestPlugin\', \'IA\'),\n+    ...         (\'TestPlugin2\', \'IB\'),\n+    ...         (\'TestPlugin\', \'IB\'),\n+    ...         (\'TestPlugin2\', \'IC\'),\n+    ...         (\'TestPlugin\', \'IC\'),\n+    ...     ]\n+    ... )\n+    True\n+    >>> adapter_calls = []\ndiff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py\nindex 46d8b5c..75f3c4b 100644\n--- a/plone/supermodel/tests.py\n+++ b/plone/supermodel/tests.py\n@@ -4,7 +4,8 @@\n from plone.supermodel.exportimport import ChoiceHandler\n from plone.supermodel.interfaces import IDefaultFactory\n from plone.supermodel.interfaces import IInvariant\n-from six.moves import cStringIO as StringIO\n+from six import BytesIO\n+from six import StringIO\n from zope import schema\n from zope.interface import alsoProvides\n from zope.interface import implementer\n@@ -18,13 +19,15 @@\n from zope.schema.vocabulary import SimpleVocabulary\n \n import doctest\n+import re\n+import six\n import unittest\n import zope.component.testing\n \n \n def configure():\n     zope.component.testing.setUp()\n-    configuration = """\\\n+    configuration = u"""\\\n     <configure\n          xmlns="http://namespaces.zope.org/zope"\n          i18n_domain="plone.supermodel.tests">\n@@ -332,7 +335,7 @@ class ISchema(IBase1, IBase2, IBase3):\n             pass\n \n         IBase1.setTaggedValue(u"foo", {1: 1, 2: 1})      # more specific than IBase2 and IBase3\n-        IBase3.setTaggedValue(u"foo", {3: 3, 2: 3, 4: 3}) # least specific of the bases\n+        IBase3.setTaggedValue(u"foo", {3: 3, 2: 3, 4: 3})  # least specific of the bases\n         ISchema.setTaggedValue(u"foo", {4: 4, 5: 4})      # most specific\n \n         self.assertEqual({1: 1, 2: 1, 3: 3, 4: 4, 5: 4}, utils.mergedTaggedValueDict(ISchema, u"foo"))\n@@ -346,8 +349,8 @@ def setUp(self):\n     tearDown = zope.component.testing.tearDown\n \n     def _assertSerialized(self, field, value, expected):\n-        element = utils.valueToElement(field, value, \'value\')\n-        sio = StringIO()\n+        element = utils.valueToElement(field, value, b\'value\')\n+        sio = StringIO() if six.PY2 else BytesIO()\n         etree.ElementTree(element).write(sio)\n         self.assertEqual(sio.getvalue(), expected)\n         unserialized = utils.elementToValue(field, element)\n@@ -356,57 +359,58 @@ def _assertSerialized(self, field, value, expected):\n     def test_lists(self):\n         field = schema.List(value_type=schema.Int())\n         value = []\n-        self._assertSerialized(field, value, \'<value/>\')\n+        self._assertSerialized(field, value, b\'<value/>\')\n         value = [1, 2]\n-        self._assertSerialized(field, value,\n-            \'<value>\'\n-            \'<element>1</element>\'\n-            \'<element>2</element>\'\n-            \'</value>\'\n-            )\n+        self._assertSerialized(\n+            field, value,\n+            b\'<value>\'\n+            b\'<element>1</element>\'\n+            b\'<element>2</element>\'\n+            b\'</value>\'\n+        )\n \n     def test_nested_lists(self):\n         field = schema.List(value_type=schema.List(value_type=schema.Int()))\n         value = []\n-        self._assertSerialized(field, value, \'<value/>\')\n+        self._assertSerialized(field, value, b\'<value/>\')\n         value = [[1], [1, 2], []]\n         self._assertSerialized(field, value,\n-            \'<value>\'\n-            \'<element><element>1</element></element>\'\n-            \'<element><element>1</element><element>2</element></element>\'\n-            \'<element/>\'\n-            \'</value>\'\n-            )\n+            b\'<value>\'\n+            b\'<element><element>1</element></element>\'\n+            b\'<element><element>1</element><element>2</element></element>\'\n+            b\'<element/>\'\n+            b\'</value>\'\n+        )\n \n     def test_dicts(self):\n         field = schema.Dict(key_type=schema.Int(), value_type=schema.TextLine())\n         value = {}\n-        self._assertSerialized(field, value, \'<value/>\')\n+        self._assertSerialized(field, value, b\'<value/>\')\n         value = {1: \'one\', 2: \'two\'}\n         self._assertSerialized(field, value,\n-            \'<value>\'\n-            \'<element key="1">one</element>\'\n-            \'<element key="2">two</element>\'\n-            \'</value>\'\n-            )\n+            b\'<value>\'\n+            b\'<element key="1">one</element>\'\n+            b\'<element key="2">two</element>\'\n+            b\'</value>\'\n+        )\n \n     def test_nested_dicts(self):\n         field = schema.Dict(key_type=schema.Int(),\n             value_type=schema.Dict(\n                 key_type=schema.Int(),\n                 value_type=schema.TextLine(),\n-                ),\n-            )\n+            ),\n+        )\n         value = {}\n-        self._assertSerialized(field, value, \'<value/>\')\n+        self._assertSerialized(field, value, b\'<value/>\')\n         value = {1: {2: \'two\'}, 3: {4: \'four\', 5: \'five\'}, 6: {}}\n         self._assertSerialized(field, value,\n-            \'<value>\'\n-            \'<element key="1"><element key="2">two</element></element>\'\n-            \'<element key="3"><element key="4">four</element><element key="5">five</element></element>\'\n-            \'<element key="6"/>\'\n-            \'</value>\'\n-            )\n+            b\'<value>\'\n+            b\'<element key="1"><element key="2">two</element></element>\'\n+            b\'<element key="3"><element key="4">four</element><element key="5">five</element></element>\'\n+            b\'<element key="6"/>\'\n+            b\'</value>\'\n+        )\n \n \n class TestChoiceHandling(unittest.TestCase):\n@@ -469,17 +473,18 @@ def _choice_with_term_titles_and_ns(self):\n         return (schema.Choice(vocabulary=vocab), expected)\n \n     def test_choice_serialized(self):\n-        field, expected = self._choice()\n-        el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-        self.assertEquals(etree.tostring(el), expected)\n-        # now with an empty string term in vocab:\n-        field, expected = self._choice_with_empty()\n-        el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-        self.assertEquals(etree.tostring(el), expected)\n-        # now with terms that have titles:\n-        field, expected = self._choice_with_term_titles()\n-        el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n-        self.assertEquals(etree.tostring(el), expected)\n+        """ Tests a regular choice, one with empty string term in vocab,\n+        and another with terms that have titles\n+        """\n+        choice = self._choice()\n+        choice_with_empty = self._choice_with_empty()\n+        choice_with_term_titles = self._choice_with_term_titles()\n+        for case in (choice, choice_with_empty, choice_with_term_titles):\n+            field, expected = case\n+            expected = six.binary_type(expected) if six.PY2 \\\n+                else six.binary_type(expected, encoding=\'latin-1\')\n+            el = self.handler.write(field, \'myfield\', \'zope.schema.Choice\')\n+            self.assertEquals(etree.tostring(el), expected)\n \n     def test_choice_parsing(self):\n         def _termvalues(vocab):\n@@ -493,35 +498,68 @@ def _termvalues(vocab):\n         for field, expected in cases:\n             el = etree.fromstring(expected)\n             imported_field = self.handler.read(el)\n-            self.assertEquals(\n+            self.assertEqual(\n                 _termvalues(imported_field.vocabulary),\n                 _termvalues(field.vocabulary),\n             )\n \n \n+class Py23DocChecker(doctest.OutputChecker):\n+    def check_output(self, want, got, optionflags):\n+        if six.PY2:\n+            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n+        else:\n+            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+            got = re.sub(\n+                \'plone.supermodel.parser.SupermodelParseError\',\n+                \'SupermodelParseError\', got)\n+            got = re.sub(\n+                \'zope.interface.exceptions.Invalid\',\n+                \'Invalid\', got)\n+            got = re.sub(\n+                "(Import|ModuleNotFound)Error: No module named "\n+                "\'plone.supermodel.tests.nonExistentFactory\'; "\n+                "\'plone.supermodel.tests\' is not a package",\n+                \'ImportError: No module named nonExistentFactory\', got)\n+        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n+\n+\n+optionflags = doctest.ELLIPSIS | \\\n+    doctest.REPORT_UDIFF | \\\n+    doctest.NORMALIZE_WHITESPACE | \\\n+    doctest.REPORT_ONLY_FIRST_FAILURE\n+\n+\n def test_suite():\n     return unittest.TestSuite((\n         unittest.makeSuite(TestUtils),\n         unittest.makeSuite(TestValueToElement),\n         unittest.makeSuite(TestChoiceHandling),\n         doctest.DocFileSuite(\n-            \'schema.rst\',\n+            \'fields.rst\',\n             setUp=zope.component.testing.setUp,\n             tearDown=zope.component.testing.tearDown,\n-            optionflags=doctest.ELLIPSIS),\n+            optionflags=optionflags,\n+            checker=Py23DocChecker()),\n         doctest.DocFileSuite(\n-            \'fields.rst\',\n+            \'directives.rst\',\n             setUp=zope.component.testing.setUp,\n             tearDown=zope.component.testing.tearDown,\n-            optionflags=doctest.ELLIPSIS),\n+            optionflags=optionflags,\n+            checker=Py23DocChecker()),\n         doctest.DocFileSuite(\n-            \'schemaclass.rst\',\n+            \'schema.rst\',\n             setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown),\n+            tearDown=zope.component.testing.tearDown,\n+            optionflags=optionflags,\n+            checker=Py23DocChecker()),\n         doctest.DocFileSuite(\n-            \'directives.rst\',\n+            \'schemaclass.rst\',\n             setUp=zope.component.testing.setUp,\n-            tearDown=zope.component.testing.tearDown),\n+            tearDown=zope.component.testing.tearDown,\n+            optionflags=optionflags,\n+            checker=Py23DocChecker()),\n     ))\n \n \ndiff --git a/plone/supermodel/utils.py b/plone/supermodel/utils.py\nindex 246bde1..bbca1d0 100644\n--- a/plone/supermodel/utils.py\n+++ b/plone/supermodel/utils.py\n@@ -13,7 +13,6 @@\n from zope.schema.interfaces import IDict\n from zope.schema.interfaces import IField\n from zope.schema.interfaces import IFromUnicode\n-from zope.schema.interfaces import IVocabularyFactory\n \n import os.path\n import re\n@@ -23,7 +22,7 @@\n \n try:\n     from collections import OrderedDict\n-except:\n+except ImportError:\n     from zope.schema.vocabulary import OrderedDict  # <py27\n \n \n@@ -35,7 +34,7 @@ def ns(name, prefix=XML_NAMESPACE):\n     """Return the element or attribute name with the given prefix\n     """\n \n-    return u"{%s}%s" % (prefix, name)\n+    return u\'{%s}%s\' % (prefix, name)\n \n \n def noNS(name):\n@@ -46,15 +45,16 @@ def noNS(name):\n \n def indent(node, level=0):\n \n-    node_indent = level * "  "\n-    child_indent = (level + 1) * "  "\n+    INDENT_SIZE = 2\n+    node_indent = level * (\' \' * INDENT_SIZE)\n+    child_indent = (level + 1) * (\' \' * INDENT_SIZE)\n \n     # node has childen\n     if len(node):\n \n         # add indent before first child node\n         if not node.text or not node.text.strip():\n-            node.text = "\\n" + child_indent\n+            node.text = \'\\n\' + child_indent\n \n         # let each child indent itself\n         last_idx = len(node) - 1\n@@ -64,16 +64,19 @@ def indent(node, level=0):\n             # add a tail for the next child node...\n             if idx != last_idx:\n                 if not child.tail or not child.tail.strip():\n-                    child.tail = "\\n" + child_indent\n+                    child.tail = \'\\n\' + child_indent\n             # ... or for the closing element of this node\n             else:\n                 if not child.tail or not child.tail.strip():\n-                    child.tail = "\\n" + node_indent\n+                    child.tail = \'\\n\' + node_indent\n \n \n def prettyXML(tree):\n     indent(tree)\n-    return etree.tostring(tree)\n+    xml = etree.tostring(tree)\n+    if six.PY2:\n+        return xml\n+    return xml.decode()\n \n \n def fieldTypecast(field, value):\n@@ -100,7 +103,6 @@ def elementToValue(field, element, default=_marker):\n     If not, the field will be adapted to this interface to obtain a converter.\n     """\n     value = default\n-\n     if IDict.providedBy(field):\n         key_converter = IFromUnicode(field.key_type)\n         value = OrderedDict()\n@@ -109,7 +111,7 @@ def elementToValue(field, element, default=_marker):\n                 continue\n             parseinfo.stack.append(child)\n \n-            key_text = child.attrib.get(\'key\', None)\n+            key_text = child.attrib.get(\'key\')\n             if key_text is None:\n                 k = None\n             else:\n@@ -153,10 +155,15 @@ def elementToValue(field, element, default=_marker):\n             value = field.missing_value\n         else:\n             converter = IFromUnicode(field)\n-            value = converter.fromUnicode(six.text_type(text))\n+            if isinstance(text, six.binary_type):\n+                text = text.decode()\n+            else:\n+                text = six.text_type(text)\n+            value = converter.fromUnicode(text)\n \n         # handle i18n\n-        if isinstance(value, six.text_type) and parseinfo.i18n_domain is not None:\n+        if isinstance(value, six.string_types) and \\\n+                parseinfo.i18n_domain is not None:\n             translate_attr = ns(\'translate\', I18N_NAMESPACE)\n             domain_attr = ns(\'domain\', I18N_NAMESPACE)\n             msgid = element.attrib.get(translate_attr)\n@@ -189,14 +196,16 @@ def valueToElement(field, value, name=None, force=False):\n \n         if IDict.providedBy(field):\n             key_converter = IToUnicode(field.key_type)\n-            for k, v in value.items():\n-                list_element = valueToElement(field.value_type, v, \'element\', force)\n+            for k, v in sorted(value.items()):\n+                list_element = valueToElement(\n+                    field.value_type, v, \'element\', force)\n                 list_element.attrib[\'key\'] = key_converter.toUnicode(k)\n                 child.append(list_element)\n \n         elif ICollection.providedBy(field):\n             for v in value:\n-                list_element = valueToElement(field.value_type, v, \'element\', force)\n+                list_element = valueToElement(\n+                    field.value_type, v, \'element\', force)\n                 child.append(list_element)\n \n         else:\ndiff --git a/pyproject.toml b/pyproject.toml\nnew file mode 100644\nindex 0000000..05b615d\n--- /dev/null\n+++ b/pyproject.toml\n@@ -0,0 +1,20 @@\n+[tool.towncrier]\n+filename = "CHANGES.rst"\n+directory = "news/"\n+title_format = "{version} ({project_date})"\n+underlines = ["-", ""]\n+\n+[[tool.towncrier.type]]\n+directory = "breaking"\n+name = "Breaking changes:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "feature"\n+name = "New features:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "bugfix"\n+name = "Bug fixes:"\n+showcontent = true\ndiff --git a/setup.cfg b/setup.cfg\nindex d80c466..2a9acf1 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,6 +1,2 @@\n-[zest.releaser]\n-create-wheel = yes\n-\n-# When Python 2-3 compatible:\n-# [bdist_wheel]\n-# universal = 1\n+[bdist_wheel]\n+universal = 1\ndiff --git a/setup.py b/setup.py\nindex 74f3ffa..eb1dc1b 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -7,7 +7,7 @@\n def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n-version = \'1.3.5.dev0\'\n+version = \'1.4.1.dev0\'\n \n long_description = (\n     read(\'README.rst\') + \'\\n\' +\n@@ -20,13 +20,17 @@ def read(*rnames):\n     description="Serialize Zope schema definitions to and from XML",\n     long_description=long_description,\n     # Get more strings from\n-    # https://pypi.python.org/pypi?%3Aaction=list_classifiers\n+    # https://pypi.org/classifiers/\n     classifiers=[\n         "Framework :: Plone",\n         "Framework :: Plone :: 5.0",\n         "Framework :: Plone :: 5.1",\n+        "Framework :: Plone :: 5.2",\n         "Programming Language :: Python",\n         "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.5",\n+        "Programming Language :: Python :: 3.6",\n+        "Programming Language :: Python :: 3.7",\n         "Topic :: Software Development :: Libraries :: Python Modules",\n         "License :: OSI Approved :: BSD License",\n     ],\n@@ -35,7 +39,7 @@ def read(*rnames):\n     author_email=\'optilude@gmail.com\',\n     url=\'https://github.com/plone/plone.supermodel\',\n     license=\'BSD\',\n-    packages=find_packages(exclude=[\'ez_setup\']),\n+    packages=find_packages(),\n     namespace_packages=[\'plone\'],\n     include_package_data=True,\n     zip_safe=False,\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2019-12-10T11:00:36+01:00
Author: Roel Bruggink (jaroel) <roel@jaroel.nl>
Commit: https://github.com/plone/plone.supermodel/commit/4a7e3d3a4751f51aebef1f06fef129b4418afa29

Merge remote-tracking branch 'origin/master' into dx-siteroot

Files changed:
M CHANGES.rst
M plone/supermodel/exportimport.py
M plone/supermodel/tests.py
M plone/supermodel/utils.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 4db0d29..bbb755d 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -8,6 +8,18 @@ Changelog\n \n .. towncrier release notes start\n \n+1.4.1 (2019-11-25)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- tests to ensure schema.Set is serialized consistently (#30)\n+\n+- Add support for choices of integers for improved registry.xml export.\n+  [jone]\n+\n+\n 1.4.0 (2018-09-28)\n ------------------\n \ndiff --git a/plone/supermodel/exportimport.py b/plone/supermodel/exportimport.py\nindex 0694f61..247de45 100644\n--- a/plone/supermodel/exportimport.py\n+++ b/plone/supermodel/exportimport.py\n@@ -398,17 +398,21 @@ def write(self, field, name, type, elementName=\'field\'):\n             value = []\n             for term in field.vocabulary:\n                 if (\n-                    not isinstance(term.value, six.string_types) or\n-                    six.b(term.token) != term.value.encode(\'unicode_escape\')\n+                    isinstance(term.value, six.integer_types)\n+                    or (\n+                        isinstance(term.value, six.string_types)\n+                        and six.b(term.token) == term.value.encode(\'unicode_escape\')\n+                    )\n                 ):\n+                    if term.title and term.title != term.value:\n+                        value.append((term.value, term.title))\n+                    else:\n+                        value.append(term.value)\n+                else:\n                     raise NotImplementedError(\n                         u"Cannot export a vocabulary that is not "\n                         u"based on a simple list of values"\n                     )\n-                if term.title and term.title != term.value:\n-                    value.append((term.value, term.title))\n-                else:\n-                    value.append(term.value)\n \n             attributeField = self.fieldAttributes[\'values\']\n             if any(map(lambda v: isinstance(v, tuple), value)):\ndiff --git a/plone/supermodel/tests.py b/plone/supermodel/tests.py\nindex 75f3c4b..ccd45d8 100644\n--- a/plone/supermodel/tests.py\n+++ b/plone/supermodel/tests.py\n@@ -369,6 +369,34 @@ def test_lists(self):\n             b\'</value>\'\n         )\n \n+    def test_sets(self):\n+        field = schema.Set(value_type=schema.Int(),\n+        )\n+        value = set([])\n+        self._assertSerialized(field, value, b\'<value/>\')\n+        value = set([3, 4, 2, 1])\n+        # Sets should be sorted to ensure nice diffs\n+        self._assertSerialized(\n+            field, value,\n+            b\'<value>\'\n+            b\'<element>1</element>\'\n+            b\'<element>2</element>\'\n+            b\'<element>3</element>\'\n+            b\'<element>4</element>\'\n+            b\'</value>\'\n+        )\n+\n+        field = schema.Set(value_type=schema.Choice([\'a\',\'b\',\'c\']),)\n+        value = set([\'b\', \'a\'])\n+        # Sets should be sorted to ensure nice diffs\n+        self._assertSerialized(\n+            field, value,\n+            b\'<value>\'\n+            b\'<element>a</element>\'\n+            b\'<element>b</element>\'\n+            b\'</value>\'\n+        )\n+\n     def test_nested_lists(self):\n         field = schema.List(value_type=schema.List(value_type=schema.Int()))\n         value = []\n@@ -413,6 +441,9 @@ def test_nested_dicts(self):\n         )\n \n \n+\n+\n+\n class TestChoiceHandling(unittest.TestCase):\n \n     def setUp(self):\n@@ -472,6 +503,15 @@ def _choice_with_term_titles_and_ns(self):\n             \'</field>\'\n         return (schema.Choice(vocabulary=vocab), expected)\n \n+    def _choice_with_integers(self):\n+        vocab = SimpleVocabulary([SimpleTerm(1, title=u\'One\')])\n+        expected = \'<field name="myfield" type="zope.schema.Choice">\'\\\n+            \'<values>\'\\\n+            \'<element key="1">One</element>\'\\\n+            \'</values>\'\\\n+            \'</field>\'\n+        return (schema.Choice(vocabulary=vocab), expected)\n+\n     def test_choice_serialized(self):\n         """ Tests a regular choice, one with empty string term in vocab,\n         and another with terms that have titles\n@@ -479,7 +519,8 @@ def test_choice_serialized(self):\n         choice = self._choice()\n         choice_with_empty = self._choice_with_empty()\n         choice_with_term_titles = self._choice_with_term_titles()\n-        for case in (choice, choice_with_empty, choice_with_term_titles):\n+        choice_with_integers = self._choice_with_integers()\n+        for case in (choice, choice_with_empty, choice_with_term_titles, choice_with_integers):\n             field, expected = case\n             expected = six.binary_type(expected) if six.PY2 \\\n                 else six.binary_type(expected, encoding=\'latin-1\')\ndiff --git a/plone/supermodel/utils.py b/plone/supermodel/utils.py\nindex bbca1d0..78f4119 100644\n--- a/plone/supermodel/utils.py\n+++ b/plone/supermodel/utils.py\n@@ -13,6 +13,7 @@\n from zope.schema.interfaces import IDict\n from zope.schema.interfaces import IField\n from zope.schema.interfaces import IFromUnicode\n+from zope.schema.interfaces import ISet\n \n import os.path\n import re\n@@ -203,6 +204,9 @@ def valueToElement(field, value, name=None, force=False):\n                 child.append(list_element)\n \n         elif ICollection.providedBy(field):\n+            if ISet.providedBy(field):\n+                # Serliazation should be consistent even if value was not really a set\n+                value = sorted(value)\n             for v in value:\n                 list_element = valueToElement(\n                     field.value_type, v, \'element\', force)\ndiff --git a/setup.py b/setup.py\nindex eb1dc1b..6b455f4 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -7,7 +7,7 @@\n def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n-version = \'1.4.1.dev0\'\n+version = \'1.4.2.dev0\'\n \n long_description = (\n     read(\'README.rst\') + \'\\n\' +\n@@ -22,6 +22,7 @@ def read(*rnames):\n     # Get more strings from\n     # https://pypi.org/classifiers/\n     classifiers=[\n+        "Development Status :: 5 - Production/Stable",\n         "Framework :: Plone",\n         "Framework :: Plone :: 5.0",\n         "Framework :: Plone :: 5.1",\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2020-02-24T20:57:11+01:00
Author: Roel Bruggink (jaroel) <roel@jaroel.nl>
Commit: https://github.com/plone/plone.supermodel/commit/c92267672723120cfbc317b937b5c27321d74ce2

Merge remote-tracking branch 'origin/master' into dx-siteroot

Files changed:
A news/33.feature
A news/34.feature
M CHANGES.rst
M plone/supermodel/directives.py
M plone/supermodel/utils.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex bbb755d..16276ab 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -8,16 +8,23 @@ Changelog\n \n .. towncrier release notes start\n \n+1.5.0 (2019-12-11)\n+------------------\n+\n+New features:\n+\n+\n+- Add support for choices of integers for improved registry.xml export.\n+  [jone] (#32)\n+\n+\n 1.4.1 (2019-11-25)\n ------------------\n \n Bug fixes:\n \n-\n - tests to ensure schema.Set is serialized consistently (#30)\n \n-- Add support for choices of integers for improved registry.xml export.\n-  [jone]\n \n \n 1.4.0 (2018-09-28)\ndiff --git a/news/33.feature b/news/33.feature\nnew file mode 100644\nindex 0000000..2970198\n--- /dev/null\n+++ b/news/33.feature\n@@ -0,0 +1,2 @@\n+zope.interface master, upcoming v5.0, initializes ``_v_attrs`` with ``None`` to save memory and creates the dict upon first usage.\n+So we need to do so in order to support the new version.\n\\ No newline at end of file\ndiff --git a/news/34.feature b/news/34.feature\nnew file mode 100644\nindex 0000000..b22bb9a\n--- /dev/null\n+++ b/news/34.feature\n@@ -0,0 +1 @@\n+Support for zope.interface 4.7+ [jensens]\n\\ No newline at end of file\ndiff --git a/plone/supermodel/directives.py b/plone/supermodel/directives.py\nindex 77cda7a..02b57cc 100644\n--- a/plone/supermodel/directives.py\n+++ b/plone/supermodel/directives.py\n@@ -12,6 +12,7 @@\n from zope.component import adapter\n from zope.interface import alsoProvides\n from zope.interface import implementer\n+from zope.interface.interface import Element\n from zope.interface.interface import TAGGED_DATA\n \n import os.path\n@@ -71,7 +72,7 @@ class CheckerPlugin(object):\n \n     def __init__(self, schema):\n         self.schema = schema\n-        self.value = schema.queryTaggedValue(self.key, None)\n+        self.value = Element.queryTaggedValue(schema, self.key, default=None)\n \n     def fieldNames(self):\n         raise NotImplementedError()\n@@ -148,10 +149,18 @@ def __init__(self, interface):\n \n     def __call__(self):\n         interface = self.interface\n-        filename = interface.queryTaggedValue(FILENAME_KEY, None)\n+        filename = Element.queryTaggedValue(\n+            interface,\n+            FILENAME_KEY,\n+            default=None,\n+        )\n         if filename is None:\n             return\n-        schema = interface.queryTaggedValue(SCHEMA_NAME_KEY, u\'\')\n+        schema = Element.queryTaggedValue(\n+            interface,\n+            SCHEMA_NAME_KEY,\n+            default=u\'\',\n+        )\n \n         moduleName = interface.__module__\n         module = sys.modules.get(moduleName, None)\ndiff --git a/plone/supermodel/utils.py b/plone/supermodel/utils.py\nindex 78f4119..9fd8919 100644\n--- a/plone/supermodel/utils.py\n+++ b/plone/supermodel/utils.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from collections import OrderedDict\n from lxml import etree\n from plone.supermodel.debug import parseinfo\n from plone.supermodel.interfaces import I18N_NAMESPACE\n@@ -8,6 +9,7 @@\n from zope.i18nmessageid import Message\n from zope.interface import directlyProvidedBy\n from zope.interface import directlyProvides\n+from zope.interface.interface import Element\n from zope.schema.interfaces import IChoice\n from zope.schema.interfaces import ICollection\n from zope.schema.interfaces import IDict\n@@ -21,12 +23,6 @@\n import sys\n \n \n-try:\n-    from collections import OrderedDict\n-except ImportError:\n-    from zope.schema.vocabulary import OrderedDict  # <py27\n-\n-\n _marker = object()\n noNS_re = re.compile(\'^{\\S+}\')\n \n@@ -269,7 +265,7 @@ def mergedTaggedValueDict(schema, name):\n     """\n     tv = {}\n     for iface in reversed(schema.__iro__):\n-        tv.update(iface.queryTaggedValue(name, {}))\n+        tv.update(Element.queryTaggedValue(iface, name, default={}))\n     return tv\n \n \n@@ -281,7 +277,7 @@ def mergedTaggedValueList(schema, name):\n     """\n     tv = []\n     for iface in reversed(schema.__iro__):\n-        tv.extend(iface.queryTaggedValue(name, []))\n+        tv.extend(Element.queryTaggedValue(iface, name, default=[]))\n     return tv\n \n \n@@ -302,7 +298,7 @@ def syncSchema(source, dest, overwrite=False, sync_bases=False):\n         for name in to_delete:\n             # delattr(dest, name)\n             del dest._InterfaceClass__attrs[name]\n-            if hasattr(dest, \'_v_attrs\'):\n+            if hasattr(dest, \'_v_attrs\') and dest._v_attrs is not None:\n                 del dest._v_attrs[name]\n \n     # Add fields that are in source, but not in dest\n@@ -321,6 +317,8 @@ def syncSchema(source, dest, overwrite=False, sync_bases=False):\n             # setattr(dest, name, clone)\n             dest._InterfaceClass__attrs[name] = clone\n             if hasattr(dest, \'_v_attrs\'):\n+                if dest._v_attrs is None:\n+                    dest._v_attrs = {}\n                 dest._v_attrs[name] = clone\n \n     # Copy tagged values\ndiff --git a/setup.py b/setup.py\nindex 6b455f4..cab4a0d 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -7,7 +7,7 @@\n def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n-version = \'1.4.2.dev0\'\n+version = \'1.5.1.dev0\'\n \n long_description = (\n     read(\'README.rst\') + \'\\n\' +\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2020-03-29T21:11:29+02:00
Author: Roel Bruggink (jaroel) <roel@jaroel.nl>
Commit: https://github.com/plone/plone.supermodel/commit/871631964167fd4e44be972548708f2d014e10a0

revert back to original implementation to see what was going wrong

Files changed:
M plone/supermodel/model.py

b'diff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex b2cbdcd..6353f4a 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -107,11 +107,10 @@ def finalizeSchemas(parent=Schema):\n         )\n \n     def walk(schema):\n-        if isinstance(schema, SchemaClass):\n-            yield schema\n-            for child in schema.dependents.keys():\n-                for s in walk(child):\n-                    yield s\n+        yield schema\n+        for child in schema.dependents.keys():\n+            for s in walk(child):\n+                yield s\n \n     schemas = set(walk(parent))\n     for schema in sorted(schemas):\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2020-03-29T21:58:48+02:00
Author: Roel Bruggink (jaroel) <roel@jaroel.nl>
Commit: https://github.com/plone/plone.supermodel/commit/1b1e8ce77c38da9ecd092a7f41564a1430f1c78e

Merge remote-tracking branch 'origin/master' into dx-siteroot

Files changed:
M CHANGES.rst
M setup.py
D news/33.feature
D news/34.feature

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 16276ab..c3d1c36 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -8,6 +8,17 @@ Changelog\n \n .. towncrier release notes start\n \n+1.6.0 (2020-03-09)\n+------------------\n+\n+New features:\n+\n+\n+- zope.interface master, upcoming v5.0, initializes ``_v_attrs`` with ``None`` to save memory and creates the dict upon first usage.\n+  So we need to do so in order to support the new version. (#33)\n+- Support for zope.interface 4.7+ [jensens] (#34)\n+\n+\n 1.5.0 (2019-12-11)\n ------------------\n \ndiff --git a/news/33.feature b/news/33.feature\ndeleted file mode 100644\nindex 2970198..0000000\n--- a/news/33.feature\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-zope.interface master, upcoming v5.0, initializes ``_v_attrs`` with ``None`` to save memory and creates the dict upon first usage.\n-So we need to do so in order to support the new version.\n\\ No newline at end of file\ndiff --git a/news/34.feature b/news/34.feature\ndeleted file mode 100644\nindex b22bb9a..0000000\n--- a/news/34.feature\n+++ /dev/null\n@@ -1 +0,0 @@\n-Support for zope.interface 4.7+ [jensens]\n\\ No newline at end of file\ndiff --git a/setup.py b/setup.py\nindex cab4a0d..2bd8bb4 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -7,7 +7,7 @@\n def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n-version = \'1.5.1.dev0\'\n+version = \'1.6.1.dev0\'\n \n long_description = (\n     read(\'README.rst\') + \'\\n\' +\n@@ -24,14 +24,14 @@ def read(*rnames):\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Framework :: Plone",\n-        "Framework :: Plone :: 5.0",\n-        "Framework :: Plone :: 5.1",\n         "Framework :: Plone :: 5.2",\n+        "Framework :: Plone :: Core",\n         "Programming Language :: Python",\n         "Programming Language :: Python :: 2.7",\n         "Programming Language :: Python :: 3.5",\n         "Programming Language :: Python :: 3.6",\n         "Programming Language :: Python :: 3.7",\n+        "Programming Language :: Python :: 3.8",\n         "Topic :: Software Development :: Libraries :: Python Modules",\n         "License :: OSI Approved :: BSD License",\n     ],\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2020-05-27T20:15:30+02:00
Author: Roel Bruggink (jaroel) <roel@jaroel.nl>
Commit: https://github.com/plone/plone.supermodel/commit/feab80129dca696e8adfb31d771068718ff1a33e

Merge remote-tracking branch 'origin/master' into dx-siteroot

Files changed:
A news/37.bugfix
A news/38.bugfix
M CHANGES.rst
M plone/supermodel/fields.rst
M plone/supermodel/utils.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex c3d1c36..cc74797 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -8,6 +8,15 @@ Changelog\n \n .. towncrier release notes start\n \n+1.6.1 (2020-04-22)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- Minor packaging updates. (#1)\n+\n+\n 1.6.0 (2020-03-09)\n ------------------\n \ndiff --git a/news/37.bugfix b/news/37.bugfix\nnew file mode 100644\nindex 0000000..2db13d7\n--- /dev/null\n+++ b/news/37.bugfix\n@@ -0,0 +1,2 @@\n+Decimal field moved in zope.schema, do not depend on specific dotted name in test b/c it does not matter. \n+[jensens]\ndiff --git a/news/38.bugfix b/news/38.bugfix\nnew file mode 100644\nindex 0000000..58963d7\n--- /dev/null\n+++ b/news/38.bugfix\n@@ -0,0 +1 @@\n+Fix a deprecation warning on a regular expression [ale-rt]\ndiff --git a/plone/supermodel/fields.rst b/plone/supermodel/fields.rst\nindex 3f1544c..6c5a256 100644\n--- a/plone/supermodel/fields.rst\n+++ b/plone/supermodel/fields.rst\n@@ -18,6 +18,8 @@ limitations:\n \n First, let\'s wire up the package.\n \n+::\n+\n     >>> configuration = b"""\\\n     ... <configure\n     ...      xmlns="http://namespaces.zope.org/zope"\n@@ -36,6 +38,8 @@ First, let\'s wire up the package.\n \n Then, let\'s test each field in turn.\n \n+::\n+\n     >>> from lxml import etree\n     >>> from plone.supermodel.interfaces import IFieldExportImportHandler\n     >>> from plone.supermodel.interfaces import IFieldNameExtractor\n@@ -717,7 +721,7 @@ Decimal\n \n     >>> reciprocal = handler.read(element)\n     >>> reciprocal.__class__\n-    <class \'zope.schema._field.Decimal\'>\n+    <class \'zope.schema...Decimal\'>\n     >>> reciprocal.__name__\n     \'dummy\'\n     >>> reciprocal.title\ndiff --git a/plone/supermodel/utils.py b/plone/supermodel/utils.py\nindex 9fd8919..c3b35a4 100644\n--- a/plone/supermodel/utils.py\n+++ b/plone/supermodel/utils.py\n@@ -24,7 +24,7 @@\n \n \n _marker = object()\n-noNS_re = re.compile(\'^{\\S+}\')\n+noNS_re = re.compile(r\'^{\\S+}\')\n \n \n def ns(name, prefix=XML_NAMESPACE):\ndiff --git a/setup.py b/setup.py\nindex 2bd8bb4..68794a3 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -7,7 +7,7 @@\n def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n-version = \'1.6.1.dev0\'\n+version = \'1.6.2.dev0\'\n \n long_description = (\n     read(\'README.rst\') + \'\\n\' +\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2020-05-30T17:49:49+02:00
Author: Roel Bruggink (jaroel) <roel@jaroel.nl>
Commit: https://github.com/plone/plone.supermodel/commit/5ef3cf5a6a3976f0f4189fc2d1ba377291f81ecc

add workaround for 'VerifyingAdapterLookup' object has no attribute 'dependents'

Files changed:
M plone/supermodel/model.py

b'diff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex 6353f4a..affb1e5 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -108,7 +108,18 @@ def finalizeSchemas(parent=Schema):\n \n     def walk(schema):\n         yield schema\n-        for child in schema.dependents.keys():\n+        # This try..except is to handle AttributeError:\n+        # \'VerifyingAdapterLookup\' object has no attribute \'dependents\'.\n+        # afaik this happens in tests only.\n+        # We have issue https://github.com/plone/plone.supermodel/issues/14\n+        # to find out why this is happening in the first place.\n+        try:\n+            children = schema.dependents.keys()\n+        except AttributeError:\n+            logger.exception(f"Got {schema} which has no .dependents.")\n+            children = ()\n+\n+        for child in children:\n             for s in walk(child):\n                 yield s\n \n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2020-06-01T10:59:30+02:00
Author: Roel Bruggink (jaroel) <roel@jaroel.nl>
Commit: https://github.com/plone/plone.supermodel/commit/5dd659a9cf9b80d6904fabddd054d4f18668f476

hu-weh

Files changed:
M plone/supermodel/model.py

b'diff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex affb1e5..3c3ba3c 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -107,7 +107,11 @@ def finalizeSchemas(parent=Schema):\n         )\n \n     def walk(schema):\n-        yield schema\n+        if isinstance(schema, SchemaClass):\n+            yield schema\n+        else:\n+            logger.error("Got non-SchemaClass {}.", schema)\n+\n         # This try..except is to handle AttributeError:\n         # \'VerifyingAdapterLookup\' object has no attribute \'dependents\'.\n         # afaik this happens in tests only.\n@@ -116,7 +120,7 @@ def walk(schema):\n         try:\n             children = schema.dependents.keys()\n         except AttributeError:\n-            logger.exception(f"Got {schema} which has no .dependents.")\n+            logger.exception("Got {} which has no .dependents.", schema)\n             children = ()\n \n         for child in children:\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2020-06-14T15:33:30+02:00
Author: Roel Bruggink (jaroel) <roel@jaroel.nl>
Commit: https://github.com/plone/plone.supermodel/commit/9472f870ebb52084caa45d05564547e7ffc59ac6

it's log! from blammo!

Files changed:
M plone/supermodel/model.py

b'diff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex 3c3ba3c..baaa597 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -110,7 +110,11 @@ def walk(schema):\n         if isinstance(schema, SchemaClass):\n             yield schema\n         else:\n-            logger.error("Got non-SchemaClass {}.", schema)\n+            logger.exception(f"Got non-SchemaClass {schema}.")\n+            # logger.error("Got non-SchemaClass {}.", schema)\n+            # On startup I got:\n+            # Message: \'Got non-SchemaClass {}.\'\n+            # Arguments: (<implementedBy plone.app.contenttypes.behaviors.richtext.RichText>,)\n \n         # This try..except is to handle AttributeError:\n         # \'VerifyingAdapterLookup\' object has no attribute \'dependents\'.\n@@ -120,7 +124,7 @@ def walk(schema):\n         try:\n             children = schema.dependents.keys()\n         except AttributeError:\n-            logger.exception("Got {} which has no .dependents.", schema)\n+            logger.exception(f"Got {schema} which has no .dependents(.keys)")\n             children = ()\n \n         for child in children:\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2020-07-19T12:26:01+02:00
Author: Roel Bruggink (jaroel) <roel@jaroel.nl>
Commit: https://github.com/plone/plone.supermodel/commit/3042a8520932c43857bed5e8594ce051328bd535

Merge remote-tracking branch 'origin/master' into dx-siteroot

Files changed:
M CHANGES.rst
M setup.py
D news/37.bugfix
D news/38.bugfix

b"diff --git a/CHANGES.rst b/CHANGES.rst\nindex cc74797..dfe8bf1 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -8,6 +8,17 @@ Changelog\n \n .. towncrier release notes start\n \n+1.6.2 (2020-06-24)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- Decimal field moved in zope.schema, do not depend on specific dotted name in test b/c it does not matter. \n+  [jensens] (#37)\n+- Fix a deprecation warning on a regular expression [ale-rt] (#38)\n+\n+\n 1.6.1 (2020-04-22)\n ------------------\n \ndiff --git a/news/37.bugfix b/news/37.bugfix\ndeleted file mode 100644\nindex 2db13d7..0000000\n--- a/news/37.bugfix\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-Decimal field moved in zope.schema, do not depend on specific dotted name in test b/c it does not matter. \n-[jensens]\ndiff --git a/news/38.bugfix b/news/38.bugfix\ndeleted file mode 100644\nindex 58963d7..0000000\n--- a/news/38.bugfix\n+++ /dev/null\n@@ -1 +0,0 @@\n-Fix a deprecation warning on a regular expression [ale-rt]\ndiff --git a/setup.py b/setup.py\nindex 68794a3..d65384e 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -7,7 +7,7 @@\n def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n-version = '1.6.2.dev0'\n+version = '1.6.3.dev0'\n \n long_description = (\n     read('README.rst') + '\\n' +\n"

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2020-12-09T20:10:22+01:00
Author: Roel Bruggink (jaroel) <roel@jaroel.nl>
Commit: https://github.com/plone/plone.supermodel/commit/6b9b95b9a85edd3f902975f5079bbe44b67f37cd

Merge remote-tracking branch 'origin/master' into dx-siteroot

Files changed:
M CHANGES.rst
M plone/supermodel/parser.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex dfe8bf1..4279dec 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -8,6 +8,16 @@ Changelog\n \n .. towncrier release notes start\n \n+1.6.3 (2020-11-17)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- For increased security, in the xml parser do not resolve entities, and remove processing instructions.\n+  [maurits] (#3209)\n+\n+\n 1.6.2 (2020-06-24)\n ------------------\n \ndiff --git a/plone/supermodel/parser.py b/plone/supermodel/parser.py\nindex 13a1088..8a5c55d 100644\n--- a/plone/supermodel/parser.py\n+++ b/plone/supermodel/parser.py\n@@ -80,7 +80,11 @@ def parse(source, policy=u""):\n \n \n def _parse(source, policy):\n-    tree = etree.parse(source)\n+    # Some safety measures.\n+    # We do not want to load entities, especially file:/// entities.\n+    # Also discard processing instructions.\n+    parser = etree.XMLParser(resolve_entities=False, remove_pis=True)\n+    tree = etree.parse(source, parser=parser)\n     root = tree.getroot()\n \n     parseinfo.i18n_domain = root.attrib.get(\ndiff --git a/setup.py b/setup.py\nindex d65384e..08cb550 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -7,7 +7,7 @@\n def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n-version = \'1.6.3.dev0\'\n+version = \'1.6.4.dev0\'\n \n long_description = (\n     read(\'README.rst\') + \'\\n\' +\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2021-02-12T11:19:26+01:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.supermodel/commit/1c397bcd9c1f807e652d1b82c5440fd434f0f11d

Changed logging and documentation

Files changed:
M plone/supermodel/model.py

b'diff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex baaa597..2ac7ce8 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -107,14 +107,12 @@ def finalizeSchemas(parent=Schema):\n         )\n \n     def walk(schema):\n+        # When we have behaviors on the Plone site root we got some shcmeas that \n+        # are not SchemaClasses\n         if isinstance(schema, SchemaClass):\n             yield schema\n         else:\n-            logger.exception(f"Got non-SchemaClass {schema}.")\n-            # logger.error("Got non-SchemaClass {}.", schema)\n-            # On startup I got:\n-            # Message: \'Got non-SchemaClass {}.\'\n-            # Arguments: (<implementedBy plone.app.contenttypes.behaviors.richtext.RichText>,)\n+            logger.warning("Got non-SchemaClass %r", schema)\n \n         # This try..except is to handle AttributeError:\n         # \'VerifyingAdapterLookup\' object has no attribute \'dependents\'.\n@@ -124,7 +122,7 @@ def walk(schema):\n         try:\n             children = schema.dependents.keys()\n         except AttributeError:\n-            logger.exception(f"Got {schema} which has no .dependents(.keys)")\n+            logger.warning("Got %r which has no .dependents.keys())", schema)\n             children = ()\n \n         for child in children:\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2021-02-12T11:25:30+01:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.supermodel/commit/e46da91dae9c22c279bb518d23b1b9b604aa5d1c

Remove the warnings

Files changed:
M plone/supermodel/model.py

b'diff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex 2ac7ce8..a3fca34 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -111,8 +111,6 @@ def walk(schema):\n         # are not SchemaClasses\n         if isinstance(schema, SchemaClass):\n             yield schema\n-        else:\n-            logger.warning("Got non-SchemaClass %r", schema)\n \n         # This try..except is to handle AttributeError:\n         # \'VerifyingAdapterLookup\' object has no attribute \'dependents\'.\n@@ -122,7 +120,6 @@ def walk(schema):\n         try:\n             children = schema.dependents.keys()\n         except AttributeError:\n-            logger.warning("Got %r which has no .dependents.keys())", schema)\n             children = ()\n \n         for child in children:\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2021-02-12T11:28:18+01:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.supermodel/commit/d99d51da4223779831593c65d05379c6472ea314

Added a towncrier entry

Files changed:
A news/27.breaking

b'diff --git a/news/27.breaking b/news/27.breaking\nnew file mode 100644\nindex 0000000..a2251ca\n--- /dev/null\n+++ b/news/27.breaking\n@@ -0,0 +1 @@\n+Make finalizeSchema more robust by not handling behavior schema classes\n'

Repository: plone.supermodel


Branch: refs/heads/master
Date: 2021-08-26T18:31:04+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.supermodel/commit/e9bdb78e4162e03b0839dd3362c4986b63e58cea

Merge pull request #27 from plone/dx-siteroot

Dx siteroot

Files changed:
A news/27.breaking
M plone/supermodel/model.py

b"diff --git a/news/27.breaking b/news/27.breaking\nnew file mode 100644\nindex 0000000..a2251ca\n--- /dev/null\n+++ b/news/27.breaking\n@@ -0,0 +1 @@\n+Make finalizeSchema more robust by not handling behavior schema classes\ndiff --git a/plone/supermodel/model.py b/plone/supermodel/model.py\nindex 6353f4a..a3fca34 100644\n--- a/plone/supermodel/model.py\n+++ b/plone/supermodel/model.py\n@@ -107,8 +107,22 @@ def finalizeSchemas(parent=Schema):\n         )\n \n     def walk(schema):\n-        yield schema\n-        for child in schema.dependents.keys():\n+        # When we have behaviors on the Plone site root we got some shcmeas that \n+        # are not SchemaClasses\n+        if isinstance(schema, SchemaClass):\n+            yield schema\n+\n+        # This try..except is to handle AttributeError:\n+        # 'VerifyingAdapterLookup' object has no attribute 'dependents'.\n+        # afaik this happens in tests only.\n+        # We have issue https://github.com/plone/plone.supermodel/issues/14\n+        # to find out why this is happening in the first place.\n+        try:\n+            children = schema.dependents.keys()\n+        except AttributeError:\n+            children = ()\n+\n+        for child in children:\n             for s in walk(child):\n                 yield s\n \n"

