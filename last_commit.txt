Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/8d8d0d0c35c0fdfa708a268bb37fb74d11d83d3a

Add very preliminary docs/relation.rst.

Files changed:
A docs/relation.rst

b'diff --git a/docs/relation.rst b/docs/relation.rst\nnew file mode 100644\nindex 0000000..8a2eadd\n--- /dev/null\n+++ b/docs/relation.rst\n@@ -0,0 +1,63 @@\n+.. admonition:: GitHub-only\n+\n+    WARNING: If you are reading this on GitHub, DON\'T!\n+    Read the documentation at `docs.plone.org <http://docs.plone.org/develop/plone.api/docs/env.html>`_\n+    so you have working references and proper formatting.\n+\n+\n+.. module:: plone\n+\n+.. _chapter_relation:\n+\n+=========\n+Relations\n+=========\n+\n+.. _relation_create_example:\n+\n+Create relation\n+===============\n+\n+To create a relation between source object and target object, use :meth:`api.relation.create`.\n+\n+.. code-block:: python\n+\n+    from plone import api\n+\n+    portal = api.portal.get()\n+    source = portal.bob\n+    target = portal.bobby\n+    api.relation.create(source=source, target=target, relationship="friend")\n+\n+Delete relation\n+===============\n+\n+.. code-block:: python\n+\n+    api.relation.delete(source=source, target=target, relationship="friend")\n+\n+\n+Get relations\n+=============\n+\n+.. code-block:: python\n+\n+    api.relation.get(source=source, target=target, relationship="friend")\n+\n+You must provide either source or target.\n+Both is fine too.\n+\n+If source, target and relationship are all given, returns a single item.\n+Otherwise returns a list.\n+\n+To get back relations, so relations pointing to an item, use:\n+\n+.. code-block:: python\n+\n+    api.relation.get(target=target)\n+\n+\n+Further reading\n+===============\n+\n+For more information on possible flags and usage options please see the full :ref:`plone-api-relation` specification.\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/15d661c95d9a8545572df6535d300b22a7546ca2

Add basic relation.py structure.

Copied unchecked from collective.relationhelpers.

Files changed:
A src/plone/api/relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nnew file mode 100644\nindex 0000000..2db596c\n--- /dev/null\n+++ b/src/plone/api/relation.py\n@@ -0,0 +1,219 @@\n+# -*- coding: utf-8 -*-\n+"""Module that provides functionality for relations.\n+\n+Heavily inspired by collective.relationhelpers.\n+"""\n+from AccessControl.SecurityManagement import getSecurityManager\n+from collections import Counter\n+from collections import defaultdict\n+from five.intid.intid import addIntIdSubscriber\n+from plone import api\n+from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n+from plone.app.iterate.dexterity.relation import StagingRelationValue\n+from plone.app.linkintegrity.handlers import modifiedContent\n+from plone.app.linkintegrity.utils import referencedRelationship\n+from plone.app.relationfield.event import update_behavior_relations\n+from plone.app.uuid.utils import uuidToObject\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.dexterity.interfaces import IDexterityFTI\n+from plone.dexterity.utils import iterSchemataForType\n+from Products.CMFCore.interfaces import IContentish\n+from Products.Five.browser import BrowserView\n+from z3c.relationfield import event\n+from z3c.relationfield import RelationValue\n+from z3c.relationfield.event import updateRelations\n+from z3c.relationfield.schema import Relation\n+from z3c.relationfield.schema import RelationChoice\n+from z3c.relationfield.schema import RelationList\n+from zc.relation.interfaces import ICatalog\n+from zope.annotation.interfaces import IAnnotations\n+from zope.component import getUtility\n+from zope.component import queryUtility\n+from zope.intid.interfaces import IIntIds\n+from zope.lifecycleevent import modified\n+\n+import json\n+import logging\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+def _get_field_and_schema_for_fieldname(field_id, fti):\n+    """Get field and its schema from a fti.\n+    """\n+    # Turn form.widgets.IDublinCore.title into title\n+    field_id = field_id.split(\'.\')[-1]\n+    for schema in iterSchemataForType(fti):\n+        field = schema.get(field_id, None)\n+        if field is not None:\n+            return (field, schema)\n+\n+\n+def create(source=None, target=None, relationship=""):\n+    """Create a relation from source to target using zc.relation\n+\n+    For RelationChoice or RelationList it will add the relation as attribute.\n+    Other relations they will only be added to the relation-catalog.\n+\n+    Copied from collective.relationhelpers link_objects.\n+    """\n+    if not IDexterityContent.providedBy(source):\n+        logger.info(u\'{} is no dexterity content\'.format(source.portal_type))\n+        return\n+\n+    if not IDexterityContent.providedBy(target):\n+        logger.info(u\'{} is no dexterity content\'.format(target.portal_type))\n+        return\n+\n+    relation_catalog = getUtility(ICatalog)\n+    intids = getUtility(IIntIds)\n+    to_id = intids.getId(target)\n+    from_id = intids.getId(source)\n+    from_attribute = relationship\n+\n+    # Check if there is exactly this relation.\n+    # If so remove it and create a fresh one.\n+    query = {\n+        \'from_attribute\': from_attribute,\n+        \'from_id\': from_id,\n+        \'to_id\': to_id,\n+    }\n+    for rel in relation_catalog.findRelations(query):\n+        relation_catalog.unindex(rel)\n+\n+    if from_attribute == referencedRelationship:\n+        # Don\'t mess with linkintegrity-relations!\n+        # Refresh them by triggering this subscriber.\n+        modifiedContent(source, None)\n+        return\n+\n+    if from_attribute == ITERATE_RELATION_NAME:\n+        # Iterate relations use a subclass of RelationValue\n+        relation = StagingRelationValue(to_id)\n+        event._setRelation(source, ITERATE_RELATION_NAME, relation)\n+        return\n+\n+    fti = queryUtility(IDexterityFTI, name=source.portal_type)\n+    if not fti:\n+        logger.info(u\'{} is no dexterity content\'.format(source.portal_type))\n+        return\n+    field_and_schema = _get_field_and_schema_for_fieldname(from_attribute, fti)\n+\n+    if field_and_schema is None:\n+        # The relationship is not the name of a field. Only create a relation.\n+        logger.info(u\'No field. Setting relation {} from {} to {}\'.format(\n+            source.absolute_url(), target.absolute_url(), relationship))\n+        event._setRelation(source, from_attribute, RelationValue(to_id))\n+        return\n+\n+    field, schema = field_and_schema\n+\n+    if isinstance(field, RelationList):\n+        logger.info(\'Add relation to relationlist {} from {} to {}\'.format(\n+            from_attribute, source.absolute_url(), target.absolute_url()))\n+        existing_relations = getattr(source, from_attribute, [])\n+        existing_relations.append(RelationValue(to_id))\n+        setattr(source, from_attribute, existing_relations)\n+        modified(source)\n+        return\n+\n+    elif isinstance(field, (Relation, RelationChoice)):\n+        logger.info(\'Add relation {} from {} to {}\'.format(\n+            from_attribute, source.absolute_url(), target.absolute_url()))\n+        setattr(source, from_attribute, RelationValue(to_id))\n+        modified(source)\n+        return\n+\n+    # We should never end up here!\n+    logger.info(\'Warning: Unexpected relation {} from {} to {}\'.format(\n+        from_attribute, source.absolute_url(), target.absolute_url()))\n+\n+\n+def delete(source=None, target=None, relationship=""):\n+    """Delete relation or relations."""\n+    pass\n+\n+\n+def _get_intid(obj):\n+    """Intid from intid-catalog"""\n+    intids = queryUtility(IIntIds)\n+    if intids is None:\n+        return\n+    # check that the object has an intid, otherwise there\'s nothing to be done\n+    try:\n+        return intids.getId(obj)\n+    except KeyError:  # noqa\n+        # The object has not been added to the ZODB yet\n+        return\n+\n+\n+def get(obj, attribute=None, backrels=False, restricted=True, as_dict=False):\n+    """Get specific relations or backrelations for a content object\n+\n+    Copied from collective.relationhelpers get_relations.\n+    We may want to have these keyword arguments instead:\n+    source=None, target=None, relationship=""\n+    """\n+    if not IDexterityContent.providedBy(obj):\n+        logger.info(u\'{} is no dexterity content\'.format(obj))\n+        return\n+\n+    results = []\n+    if as_dict:\n+        results = defaultdict(list)\n+    int_id = _get_intid(obj)\n+    if not int_id:\n+        return results\n+\n+    relation_catalog = getUtility(ICatalog)\n+    if not relation_catalog:\n+        return results\n+\n+    query = {}\n+    if backrels:\n+        query[\'to_id\'] = int_id\n+    else:\n+        query[\'from_id\'] = int_id\n+\n+    if restricted:\n+        checkPermission = getSecurityManager().checkPermission\n+\n+    if attribute and isinstance(attribute, (list, tuple)):\n+        # The relation-catalog does not support queries for multiple from_attributes\n+        # We make multiple queries to support this use-case.\n+        relations = []\n+        for from_attribute in attribute:\n+            query[\'from_attribute\'] = from_attribute\n+            relations.extend(relation_catalog.findRelations(query))\n+    elif attribute:\n+        # query with one attribute\n+        query[\'from_attribute\'] = attribute\n+        relations = relation_catalog.findRelations(query)\n+    else:\n+        # query without constraint on a attribute\n+        relations = relation_catalog.findRelations(query)\n+\n+    for relation in relations:\n+        if relation.isBroken():\n+            continue\n+\n+        if backrels:\n+            obj = relation.from_object\n+        else:\n+            obj = relation.to_object\n+\n+        if as_dict:\n+            if restricted:\n+                if checkPermission(\'View\', obj):\n+                    results[relation.from_attribute].append(obj)\n+                else:\n+                    results[relation.from_attribute].append(None)\n+            else:\n+                results[relation.from_attribute].append(obj)\n+        else:\n+            if restricted:\n+                if checkPermission(\'View\', obj):\n+                    results.append(obj)\n+            else:\n+                results.append(obj)\n+    return results\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/358ae287c462819a4162b4c055b8dff4bbe3c213

Import relation in init.

Files changed:
M src/plone/api/__init__.py

b'diff --git a/src/plone/api/__init__.py b/src/plone/api/__init__.py\nindex 59d677c..fc65182 100644\n--- a/src/plone/api/__init__.py\n+++ b/src/plone/api/__init__.py\n@@ -4,4 +4,5 @@\n from plone.api import env\n from plone.api import group\n from plone.api import portal\n+from plone.api import relation\n from plone.api import user\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/fec73f6516c5d330b958532f61170052735ceb7c

relation.create: require all parameters.

Add tests for this.

Files changed:
A src/plone/api/tests/test_relation.py
M src/plone/api/relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 2db596c..e603e0c 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -8,6 +8,10 @@\n from collections import defaultdict\n from five.intid.intid import addIntIdSubscriber\n from plone import api\n+from plone.api.exc import InvalidParameterError\n+from plone.api.validation import at_least_one_of\n+from plone.api.validation import mutually_exclusive_parameters\n+from plone.api.validation import required_parameters\n from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n from plone.app.iterate.dexterity.relation import StagingRelationValue\n from plone.app.linkintegrity.handlers import modifiedContent\n@@ -34,6 +38,7 @@\n \n import json\n import logging\n+import six\n \n logger = logging.getLogger(__name__)\n \n@@ -49,7 +54,8 @@ def _get_field_and_schema_for_fieldname(field_id, fti):\n             return (field, schema)\n \n \n-def create(source=None, target=None, relationship=""):\n+@required_parameters(\'source\', \'target\', \'relationship\')\n+def create(source=None, target=None, relationship=None):\n     """Create a relation from source to target using zc.relation\n \n     For RelationChoice or RelationList it will add the relation as attribute.\n@@ -58,12 +64,13 @@ def create(source=None, target=None, relationship=""):\n     Copied from collective.relationhelpers link_objects.\n     """\n     if not IDexterityContent.providedBy(source):\n-        logger.info(u\'{} is no dexterity content\'.format(source.portal_type))\n-        return\n+        raise InvalidParameterError(\'{} is no dexterity content\'.format(source))\n \n     if not IDexterityContent.providedBy(target):\n-        logger.info(u\'{} is no dexterity content\'.format(target.portal_type))\n-        return\n+        raise InvalidParameterError(\'{} is no dexterity content\'.format(target))\n+\n+    if not isinstance(relationship, six.string_types):\n+        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n \n     relation_catalog = getUtility(ICatalog)\n     intids = getUtility(IIntIds)\ndiff --git a/src/plone/api/tests/test_relation.py b/src/plone/api/tests/test_relation.py\nnew file mode 100644\nindex 0000000..d34a1ec\n--- /dev/null\n+++ b/src/plone/api/tests/test_relation.py\n@@ -0,0 +1,172 @@\n+# -*- coding: utf-8 -*-\n+"""Tests for plone.api.content."""\n+\n+from Acquisition import aq_base\n+from OFS.CopySupport import CopyError\n+from OFS.event import ObjectWillBeMovedEvent\n+from OFS.interfaces import IObjectWillBeMovedEvent\n+from plone import api\n+from plone.api.content import NEW_LINKINTEGRITY\n+from plone.api.tests.base import INTEGRATION_TESTING\n+from plone.app.layout.navigation.interfaces import INavigationRoot\n+from plone.app.linkintegrity.exceptions import LinkIntegrityNotificationException  # NOQA: E501\n+from plone.app.textfield import RichTextValue\n+from plone.dexterity.interfaces import IDexterityContent\n+from plone.indexer import indexer\n+from plone.uuid.interfaces import IMutableUUID\n+from plone.uuid.interfaces import IUUIDGenerator\n+from Products.CMFCore.interfaces import IContentish\n+from Products.CMFCore.WorkflowCore import WorkflowException\n+from Products.ZCatalog.interfaces import IZCatalog\n+from zExceptions import BadRequest\n+from zope.component import getGlobalSiteManager\n+from zope.component import getUtility\n+from zope.container.contained import ContainerModifiedEvent\n+from zope.interface import alsoProvides\n+from zope.lifecycleevent import IObjectModifiedEvent\n+from zope.lifecycleevent import IObjectMovedEvent\n+from zope.lifecycleevent import modified\n+from zope.lifecycleevent import ObjectMovedEvent\n+\n+import mock\n+import pkg_resources\n+import six\n+import unittest\n+\n+\n+try:\n+    pkg_resources.get_distribution(\'plone.app.contenttypes\')\n+except pkg_resources.DistributionNotFound:\n+    HAS_PACONTENTYPES = False\n+else:\n+    HAS_PACONTENTYPES = True\n+\n+\n+class TestPloneApiRelation(unittest.TestCase):\n+    """Unit tests for relations using plone.api"""\n+\n+    layer = INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        """Create a portal structure which we can test against.\n+\n+        Plone (portal root)\n+        |-- image\n+        |-- blog\n+        |-- about\n+        |   |-- team\n+        |   `-- contact\n+        `-- events\n+            |-- training\n+            |-- conference\n+            `-- sprint\n+\n+        This is copied from test_content.py.\n+        We may want to simplify.  But could be okay.\n+        """\n+        self.portal = self.layer[\'portal\']\n+\n+        self.blog = api.content.create(\n+            type=\'Link\',\n+            id=\'blog\',\n+            container=self.portal,\n+        )\n+        self.about = api.content.create(\n+            type=\'Folder\',\n+            id=\'about\',\n+            container=self.portal,\n+        )\n+        self.events = api.content.create(\n+            type=\'Folder\',\n+            id=\'events\',\n+            container=self.portal,\n+        )\n+\n+        self.team = api.content.create(\n+            container=self.about,\n+            type=\'Document\',\n+            id=\'team\',\n+        )\n+        self.contact = api.content.create(\n+            container=self.about,\n+            type=\'Document\',\n+            id=\'contact\',\n+        )\n+\n+        self.training = api.content.create(\n+            container=self.events,\n+            type=\'Event\',\n+            id=\'training\',\n+        )\n+        self.conference = api.content.create(\n+            container=self.events,\n+            type=\'Event\',\n+            id=\'conference\',\n+        )\n+        self.sprint = api.content.create(\n+            container=self.events,\n+            type=\'Event\',\n+            id=\'sprint\',\n+        )\n+\n+        self.image = api.content.create(\n+            container=self.portal,\n+            type=\'Image\',\n+            id=\'image\',\n+        )\n+\n+    def test_create_constraints(self):\n+        """Test the constraints when creating relations."""\n+        from plone.api.exc import InvalidParameterError\n+        from plone.api.exc import MissingParameterError\n+\n+        # This will definitely fail\n+        with self.assertRaises(MissingParameterError):\n+            api.relation.create()\n+\n+        # Check the constraints for the source parameter\n+        with self.assertRaises(MissingParameterError):\n+            api.relation.create(\n+                target=self.blog,\n+                relationship=\'link\',\n+            )\n+\n+        # Check the constraints for the target parameter\n+        with self.assertRaises(MissingParameterError):\n+            api.relation.create(\n+                source=self.about,\n+                relationship=\'link\',\n+            )\n+\n+        # Check the constraints for the relationship parameter\n+        with self.assertRaises(MissingParameterError):\n+            api.relation.create(\n+                source=self.about,\n+                target=self.blog,\n+            )\n+\n+        # We require a dexterity source\n+        app = self.layer["app"]\n+        app.portal_type = "ZopeRoot"\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.create(\n+                source=app,\n+                target=self.blog,\n+                relationship=\'link\',\n+            )\n+\n+        # We require a dexterity target\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.create(\n+                source=self.about,\n+                target=app,\n+                relationship=\'link\',\n+            )\n+\n+        # We require a string relationship\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.create(\n+                source=self.about,\n+                target=self.blog,\n+                relationship=42,\n+            )\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/dbf425b8a1c2306e855a08818b486ff29e1b10bd

Add first test for really adding a relation.

Files changed:
M src/plone/api/tests/test_relation.py

b'diff --git a/src/plone/api/tests/test_relation.py b/src/plone/api/tests/test_relation.py\nindex d34a1ec..9df2d57 100644\n--- a/src/plone/api/tests/test_relation.py\n+++ b/src/plone/api/tests/test_relation.py\n@@ -170,3 +170,21 @@ def test_create_constraints(self):\n                 target=self.blog,\n                 relationship=42,\n             )\n+\n+    def test_create_relation(self):\n+        """Test creating a relation."""\n+        # Check that there are no relations at first for the two objects we will test.\n+        self.assertEqual(len(api.relation.get(self.about)), 0)\n+        self.assertEqual(len(api.relation.get(self.blog, backrels=True)), 0)\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        self.assertEqual(len(api.relation.get(self.about)), 1)\n+        self.assertEqual(len(api.relation.get(self.blog, backrels=True)), 1)\n+        self.assertEqual(api.relation.get(self.about)[0], self.blog)\n+        self.assertEqual(api.relation.get(self.blog, backrels=True)[0], self.about)\n+        # The relation goes one way.\n+        self.assertEqual(len(api.relation.get(self.about, backrels=True)), 0)\n+        self.assertEqual(len(api.relation.get(self.blog)), 0)\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Petchesi-Iulian (Petchesi-Iulian) <iamnotacat12@gmail.com>
Commit: https://github.com/plone/plone.api/commit/ebc464f5298aa39c4765f0f3192471f5ac1842af

Modified relations.GET to better correspond with docs (WIP).

Files changed:
M src/plone/api/relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex e603e0c..7ef5855 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -153,74 +153,59 @@ def _get_intid(obj):\n         # The object has not been added to the ZODB yet\n         return\n \n-\n-def get(obj, attribute=None, backrels=False, restricted=True, as_dict=False):\n+def get(source=None, target=None, relationship="",\n+        unrestricted=False, as_dict=False):\n     """Get specific relations or backrelations for a content object\n \n     Copied from collective.relationhelpers get_relations.\n     We may want to have these keyword arguments instead:\n     source=None, target=None, relationship=""\n     """\n-    if not IDexterityContent.providedBy(obj):\n-        logger.info(u\'{} is no dexterity content\'.format(obj))\n-        return\n+    # No longer needed since you can query by relationship alone\n+    # if not IDexterityContent.providedBy(obj):\n+    #     logger.info(u\'{} is no dexterity content\'.format(obj))\n+    #     return\n \n+    intids = getUtility(IIntIds)\n+    to_id = intids.getId(target)\n+    from_id = intids.getId(source)\n+    from_attribute = relationship\n+    relation_catalog = getUtility(ICatalog)\n     results = []\n+\n     if as_dict:\n         results = defaultdict(list)\n-    int_id = _get_intid(obj)\n-    if not int_id:\n-        return results\n \n-    relation_catalog = getUtility(ICatalog)\n     if not relation_catalog:\n         return results\n \n-    query = {}\n-    if backrels:\n-        query[\'to_id\'] = int_id\n-    else:\n-        query[\'from_id\'] = int_id\n-\n-    if restricted:\n+    if not unrestricted:\n         checkPermission = getSecurityManager().checkPermission\n \n-    if attribute and isinstance(attribute, (list, tuple)):\n-        # The relation-catalog does not support queries for multiple from_attributes\n-        # We make multiple queries to support this use-case.\n-        relations = []\n-        for from_attribute in attribute:\n-            query[\'from_attribute\'] = from_attribute\n-            relations.extend(relation_catalog.findRelations(query))\n-    elif attribute:\n-        # query with one attribute\n-        query[\'from_attribute\'] = attribute\n-        relations = relation_catalog.findRelations(query)\n-    else:\n-        # query without constraint on a attribute\n-        relations = relation_catalog.findRelations(query)\n-\n-    for relation in relations:\n+    query = {\n+        \'from_attribute\': from_attribute,\n+        \'from_id\': from_id,\n+        \'to_id\': to_id,\n+    }\n+\n+    for relation in relation_catalog.findRelations(query):\n         if relation.isBroken():\n             continue\n \n-        if backrels:\n-            obj = relation.from_object\n-        else:\n-            obj = relation.to_object\n+        if not unrestricted:\n+            source_obj = relation.from_object\n+            target_obj = relation.to_object\n \n-        if as_dict:\n-            if restricted:\n-                if checkPermission(\'View\', obj):\n-                    results[relation.from_attribute].append(obj)\n+            if checkPermission(\'View\', source_obj) and checkPermission(\'View\', target_obj):\n+                if as_dict:\n+                    results[relation.__hash__].append(relation)\n                 else:\n-                    results[relation.from_attribute].append(None)\n+                    results.append(relation)\n             else:\n-                results[relation.from_attribute].append(obj)\n+                continue\n         else:\n-            if restricted:\n-                if checkPermission(\'View\', obj):\n-                    results.append(obj)\n+            if as_dict:\n+                results[relation.__hash__].append(relation)\n             else:\n-                results.append(obj)\n+                results.append(relation)\n     return results\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/b37435e39a80fb43b91635908c5c12f2273bfe8b

Implement relation.delete.

Files changed:
M src/plone/api/relation.py
M src/plone/api/tests/test_relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 7ef5855..022b81b 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -136,9 +136,35 @@ def create(source=None, target=None, relationship=None):\n         from_attribute, source.absolute_url(), target.absolute_url()))\n \n \n+# @at_least_one_of(\'source\', \'target\', \'relationship\')\n def delete(source=None, target=None, relationship=""):\n-    """Delete relation or relations."""\n-    pass\n+    """Delete relation or relations.\n+\n+    If you do not specify any parameters, we delete all relations.\n+\n+    TODO: do we want to remove RelationValues from content objects?\n+    """\n+    if source is not None and not IDexterityContent.providedBy(source):\n+        raise InvalidParameterError(\'{} is no dexterity content\'.format(source))\n+\n+    if target is not None and not IDexterityContent.providedBy(target):\n+        raise InvalidParameterError(\'{} is no dexterity content\'.format(target))\n+\n+    if relationship is not None and not isinstance(relationship, six.string_types):\n+        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n+\n+    query = {}\n+    relation_catalog = getUtility(ICatalog)\n+    intids = getUtility(IIntIds)\n+    if source is not None:\n+        query[\'from_id\'] = intids.getId(source)\n+    if target is not None:\n+        query[\'to_id\'] = intids.getId(target)\n+    if relationship is not None:\n+        query[\'from_attribute\'] = relationship\n+    # If the query is empty, we could do relation_catalog.clear().\n+    for rel in relation_catalog.findRelations(query):\n+        relation_catalog.unindex(rel)\n \n \n def _get_intid(obj):\ndiff --git a/src/plone/api/tests/test_relation.py b/src/plone/api/tests/test_relation.py\nindex 9df2d57..89094e5 100644\n--- a/src/plone/api/tests/test_relation.py\n+++ b/src/plone/api/tests/test_relation.py\n@@ -188,3 +188,36 @@ def test_create_relation(self):\n         # The relation goes one way.\n         self.assertEqual(len(api.relation.get(self.about, backrels=True)), 0)\n         self.assertEqual(len(api.relation.get(self.blog)), 0)\n+\n+    def test_delete_constraints(self):\n+        """Test the constraints when deleting relations."""\n+        from plone.api.exc import InvalidParameterError\n+\n+        # If source is given, it must be dexterity.\n+        app = self.layer["app"]\n+        app.portal_type = "ZopeRoot"\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.delete(source=app)\n+\n+        # If target is given, it must be dexterity.\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.delete(target=app)\n+\n+        # If relationship is given, it must be a string.\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.delete(relationship=42)\n+\n+    def test_delete_relation(self):\n+        """Test deleting a relation."""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.delete(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        self.assertEqual(len(api.relation.get(self.about)), 0)\n+        self.assertEqual(len(api.relation.get(self.blog, backrels=True)), 0)\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/688a8b89f309be98dfbd8b8a3de0034b37ec5ce5

relation: do not require plone.app.iterate.

Files changed:
M src/plone/api/relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 022b81b..b978336 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -12,8 +12,6 @@\n from plone.api.validation import at_least_one_of\n from plone.api.validation import mutually_exclusive_parameters\n from plone.api.validation import required_parameters\n-from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n-from plone.app.iterate.dexterity.relation import StagingRelationValue\n from plone.app.linkintegrity.handlers import modifiedContent\n from plone.app.linkintegrity.utils import referencedRelationship\n from plone.app.relationfield.event import update_behavior_relations\n@@ -40,6 +38,13 @@\n import logging\n import six\n \n+try:\n+    from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n+    from plone.app.iterate.dexterity.relation import StagingRelationValue\n+except ImportError:\n+    ITERATE_RELATION_NAME = None\n+    StagingRelationValue = None\n+\n logger = logging.getLogger(__name__)\n \n \n@@ -94,7 +99,7 @@ def create(source=None, target=None, relationship=None):\n         modifiedContent(source, None)\n         return\n \n-    if from_attribute == ITERATE_RELATION_NAME:\n+    if ITERATE_RELATION_NAME is not None and from_attribute == ITERATE_RELATION_NAME:\n         # Iterate relations use a subclass of RelationValue\n         relation = StagingRelationValue(to_id)\n         event._setRelation(source, ITERATE_RELATION_NAME, relation)\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/43d940b471e8c50defd434fefcfac1f5ef6b741c

relation: do not import api.

Strangely this passes on Plone 6 but fails on 5.2 Python 2.

Files changed:
M src/plone/api/relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex b978336..f9fa4ed 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -7,7 +7,6 @@\n from collections import Counter\n from collections import defaultdict\n from five.intid.intid import addIntIdSubscriber\n-from plone import api\n from plone.api.exc import InvalidParameterError\n from plone.api.validation import at_least_one_of\n from plone.api.validation import mutually_exclusive_parameters\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Petchesi-Iulian (Petchesi-Iulian) <iamnotacat12@gmail.com>
Commit: https://github.com/plone/plone.api/commit/600e37cac6cc2367db1d69329de4bd8abb98a881

Improve relations.get (WIP).

Files changed:
M src/plone/api/relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex f9fa4ed..3674263 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -183,24 +183,25 @@ def _get_intid(obj):\n         # The object has not been added to the ZODB yet\n         return\n \n+\n def get(source=None, target=None, relationship="",\n         unrestricted=False, as_dict=False):\n-    """Get specific relations or backrelations for a content object\n+    """Get specific relations given a source/target and/or relationship\n \n     Copied from collective.relationhelpers get_relations.\n-    We may want to have these keyword arguments instead:\n-    source=None, target=None, relationship=""\n     """\n-    # No longer needed since you can query by relationship alone\n-    # if not IDexterityContent.providedBy(obj):\n-    #     logger.info(u\'{} is no dexterity content\'.format(obj))\n-    #     return\n+    if source is not None and not IDexterityContent.providedBy(source):\n+        raise InvalidParameterError(\'{} is no dexterity content\'.format(source))\n+\n+    if target is not None and not IDexterityContent.providedBy(target):\n+        raise InvalidParameterError(\'{} is no dexterity content\'.format(target))\n+\n+    if relationship is not None and not isinstance(relationship, six.string_types):\n+        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n \n     intids = getUtility(IIntIds)\n-    to_id = intids.getId(target)\n-    from_id = intids.getId(source)\n-    from_attribute = relationship\n     relation_catalog = getUtility(ICatalog)\n+    query = {}\n     results = []\n \n     if as_dict:\n@@ -212,11 +213,12 @@ def get(source=None, target=None, relationship="",\n     if not unrestricted:\n         checkPermission = getSecurityManager().checkPermission\n \n-    query = {\n-        \'from_attribute\': from_attribute,\n-        \'from_id\': from_id,\n-        \'to_id\': to_id,\n-    }\n+    if source is not None:\n+        query[\'from_id\'] = intids.getId(source)\n+    if target is not None:\n+        query[\'to_id\'] = intids.getId(target)\n+    if relationship is not None:\n+        query[\'from_attribute\'] = relationship\n \n     for relation in relation_catalog.findRelations(query):\n         if relation.isBroken():\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/eb4ece254495757af7510ca037239f9bc603f547

Fixed relation.create/delete tests to use newer relation.get.

Files changed:
M src/plone/api/tests/test_relation.py

b'diff --git a/src/plone/api/tests/test_relation.py b/src/plone/api/tests/test_relation.py\nindex 89094e5..56af1e1 100644\n--- a/src/plone/api/tests/test_relation.py\n+++ b/src/plone/api/tests/test_relation.py\n@@ -174,20 +174,18 @@ def test_create_constraints(self):\n     def test_create_relation(self):\n         """Test creating a relation."""\n         # Check that there are no relations at first for the two objects we will test.\n-        self.assertEqual(len(api.relation.get(self.about)), 0)\n-        self.assertEqual(len(api.relation.get(self.blog, backrels=True)), 0)\n+        relations = api.relation.get(source=self.about, target=self.blog, relationship="link")\n+        self.assertEqual(len(relations), 0)\n         api.relation.create(\n             source=self.about,\n             target=self.blog,\n             relationship=\'link\',\n         )\n-        self.assertEqual(len(api.relation.get(self.about)), 1)\n-        self.assertEqual(len(api.relation.get(self.blog, backrels=True)), 1)\n-        self.assertEqual(api.relation.get(self.about)[0], self.blog)\n-        self.assertEqual(api.relation.get(self.blog, backrels=True)[0], self.about)\n-        # The relation goes one way.\n-        self.assertEqual(len(api.relation.get(self.about, backrels=True)), 0)\n-        self.assertEqual(len(api.relation.get(self.blog)), 0)\n+        relations = api.relation.get(source=self.about, target=self.blog, relationship="link")\n+        self.assertEqual(len(relations), 1)\n+        relation = relations[0]\n+        self.assertEqual(relation.from_object, self.about)\n+        self.assertEqual(relation.to_object, self.blog)\n \n     def test_delete_constraints(self):\n         """Test the constraints when deleting relations."""\n@@ -219,5 +217,5 @@ def test_delete_relation(self):\n             target=self.blog,\n             relationship=\'link\',\n         )\n-        self.assertEqual(len(api.relation.get(self.about)), 0)\n-        self.assertEqual(len(api.relation.get(self.blog, backrels=True)), 0)\n+        relations = api.relation.get(source=self.about, target=self.blog, relationship="link")\n+        self.assertEqual(len(relations), 0)\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Petchesi-Iulian (Petchesi-Iulian) <iamnotacat12@gmail.com>
Commit: https://github.com/plone/plone.api/commit/274fa21de77521577d103bc0ec571277dd14a9fb

Fix relationship parameter for relations.get

Files changed:
M src/plone/api/relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 3674263..7783a48 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -184,7 +184,7 @@ def _get_intid(obj):\n         return\n \n \n-def get(source=None, target=None, relationship="",\n+def get(source=None, target=None, relationship=None,\n         unrestricted=False, as_dict=False):\n     """Get specific relations given a source/target and/or relationship\n \n@@ -230,14 +230,14 @@ def get(source=None, target=None, relationship="",\n \n             if checkPermission(\'View\', source_obj) and checkPermission(\'View\', target_obj):\n                 if as_dict:\n-                    results[relation.__hash__].append(relation)\n+                    results[relation.__hash__()].append(relation)\n                 else:\n                     results.append(relation)\n             else:\n                 continue\n         else:\n             if as_dict:\n-                results[relation.__hash__].append(relation)\n+                results[relation.__hash__()].append(relation)\n             else:\n                 results.append(relation)\n     return results\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Petchesi-Iulian (Petchesi-Iulian) <iamnotacat12@gmail.com>
Commit: https://github.com/plone/plone.api/commit/b111cd9b8095f7747ea272cc0db95894edec61c6

Added tests for relations.get

Files changed:
M src/plone/api/relation.py
M src/plone/api/tests/test_relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 7783a48..50e3e29 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -230,14 +230,14 @@ def get(source=None, target=None, relationship=None,\n \n             if checkPermission(\'View\', source_obj) and checkPermission(\'View\', target_obj):\n                 if as_dict:\n-                    results[relation.__hash__()].append(relation)\n+                    results[relation.from_attribute].append(relation)\n                 else:\n                     results.append(relation)\n             else:\n                 continue\n         else:\n             if as_dict:\n-                results[relation.__hash__()].append(relation)\n+                results[relation.from_attribute].append(relation)\n             else:\n                 results.append(relation)\n     return results\ndiff --git a/src/plone/api/tests/test_relation.py b/src/plone/api/tests/test_relation.py\nindex 56af1e1..897efe8 100644\n--- a/src/plone/api/tests/test_relation.py\n+++ b/src/plone/api/tests/test_relation.py\n@@ -219,3 +219,51 @@ def test_delete_relation(self):\n         )\n         relations = api.relation.get(source=self.about, target=self.blog, relationship="link")\n         self.assertEqual(len(relations), 0)\n+\n+\n+    def test_get_constraints(self):\n+        """Test the constraints when getting relations."""\n+        from plone.api.exc import InvalidParameterError\n+\n+        # If source is given, it must be dexterity.\n+        app = self.layer["app"]\n+        app.portal_type = "ZopeRoot"\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.get(source=app)\n+\n+        # If target is given, it must be dexterity.\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.get(target=app)\n+\n+        # If relationship is given, it must be a string.\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.get(relationship=42)\n+\n+    def test_get_relation(self):\n+        """Test getting a relation."""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.events,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.about.team,\n+            target=self.events,\n+            relationship=\'team\',\n+        )\n+        api.relation.create(\n+            source=self.events,\n+            target=self.portal.image,\n+            relationship=\'link\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 1)\n+        self.assertEqual(len(api.relation.get(target=self.blog)), 2)\n+        self.assertEqual(len(api.relation.get(relationship="link")), 3)\n+\n+        self.assertEqual(len(api.relation.get(source=self.events)), 2)\n+        self.assertEqual(len(api.relation.get(relationship="team")), 1)\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Petchesi-Iulian (Petchesi-Iulian) <iamnotacat12@gmail.com>
Commit: https://github.com/plone/plone.api/commit/63391570bafa5572a168cbad650a464ddc4528b4

Updated documentation for relations + cleanup

Files changed:
M docs/relation.rst
M src/plone/api/relation.py
M src/plone/api/tests/test_relation.py

b'diff --git a/docs/relation.rst b/docs/relation.rst\nindex 8a2eadd..0bf0141 100644\n--- a/docs/relation.rst\n+++ b/docs/relation.rst\n@@ -42,13 +42,15 @@ Get relations\n \n .. code-block:: python\n \n-    api.relation.get(source=source, target=target, relationship="friend")\n+    api.relation.get(source=source, target=target, relationship="friend", unrestricted=False, as_dict=False)\n \n-You must provide either source or target.\n-Both is fine too.\n+You must provide either source, target or relationship, ``unrestricted`` and ``as_dict`` are optional.\n \n-If source, target and relationship are all given, returns a single item.\n-Otherwise returns a list.\n+Use the ``as_dict`` parameter if you want the result to be returned as a dictionary.\n+Use the ``unrestricted`` parameter if you want to bypass the View permission check.\n+\n+By default it returns a list.\n+If source, target and relationship are all given, returns a list with a single item.\n \n To get back relations, so relations pointing to an item, use:\n \ndiff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 50e3e29..a95ddf6 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -4,30 +4,21 @@\n Heavily inspired by collective.relationhelpers.\n """\n from AccessControl.SecurityManagement import getSecurityManager\n-from collections import Counter\n from collections import defaultdict\n-from five.intid.intid import addIntIdSubscriber\n from plone.api.exc import InvalidParameterError\n from plone.api.validation import at_least_one_of\n-from plone.api.validation import mutually_exclusive_parameters\n from plone.api.validation import required_parameters\n from plone.app.linkintegrity.handlers import modifiedContent\n from plone.app.linkintegrity.utils import referencedRelationship\n-from plone.app.relationfield.event import update_behavior_relations\n-from plone.app.uuid.utils import uuidToObject\n from plone.dexterity.interfaces import IDexterityContent\n from plone.dexterity.interfaces import IDexterityFTI\n from plone.dexterity.utils import iterSchemataForType\n-from Products.CMFCore.interfaces import IContentish\n-from Products.Five.browser import BrowserView\n from z3c.relationfield import event\n from z3c.relationfield import RelationValue\n-from z3c.relationfield.event import updateRelations\n from z3c.relationfield.schema import Relation\n from z3c.relationfield.schema import RelationChoice\n from z3c.relationfield.schema import RelationList\n from zc.relation.interfaces import ICatalog\n-from zope.annotation.interfaces import IAnnotations\n from zope.component import getUtility\n from zope.component import queryUtility\n from zope.intid.interfaces import IIntIds\n@@ -171,24 +162,12 @@ def delete(source=None, target=None, relationship=""):\n         relation_catalog.unindex(rel)\n \n \n-def _get_intid(obj):\n-    """Intid from intid-catalog"""\n-    intids = queryUtility(IIntIds)\n-    if intids is None:\n-        return\n-    # check that the object has an intid, otherwise there\'s nothing to be done\n-    try:\n-        return intids.getId(obj)\n-    except KeyError:  # noqa\n-        # The object has not been added to the ZODB yet\n-        return\n-\n-\n+@at_least_one_of(\'source\', \'target\', \'relationship\')\n def get(source=None, target=None, relationship=None,\n         unrestricted=False, as_dict=False):\n-    """Get specific relations given a source/target and/or relationship\n+    """Get specific relations given a source/target/relationship\n \n-    Copied from collective.relationhelpers get_relations.\n+    Copied and modified from collective.relationhelpers get_relations.\n     """\n     if source is not None and not IDexterityContent.providedBy(source):\n         raise InvalidParameterError(\'{} is no dexterity content\'.format(source))\n@@ -228,7 +207,8 @@ def get(source=None, target=None, relationship=None,\n             source_obj = relation.from_object\n             target_obj = relation.to_object\n \n-            if checkPermission(\'View\', source_obj) and checkPermission(\'View\', target_obj):\n+            if checkPermission(\'View\', source_obj) and checkPermission(\'View\',\n+                    target_obj):\n                 if as_dict:\n                     results[relation.from_attribute].append(relation)\n                 else:\ndiff --git a/src/plone/api/tests/test_relation.py b/src/plone/api/tests/test_relation.py\nindex 897efe8..4875c39 100644\n--- a/src/plone/api/tests/test_relation.py\n+++ b/src/plone/api/tests/test_relation.py\n@@ -1,32 +1,8 @@\n # -*- coding: utf-8 -*-\n """Tests for plone.api.content."""\n \n-from Acquisition import aq_base\n-from OFS.CopySupport import CopyError\n-from OFS.event import ObjectWillBeMovedEvent\n-from OFS.interfaces import IObjectWillBeMovedEvent\n from plone import api\n-from plone.api.content import NEW_LINKINTEGRITY\n from plone.api.tests.base import INTEGRATION_TESTING\n-from plone.app.layout.navigation.interfaces import INavigationRoot\n-from plone.app.linkintegrity.exceptions import LinkIntegrityNotificationException  # NOQA: E501\n-from plone.app.textfield import RichTextValue\n-from plone.dexterity.interfaces import IDexterityContent\n-from plone.indexer import indexer\n-from plone.uuid.interfaces import IMutableUUID\n-from plone.uuid.interfaces import IUUIDGenerator\n-from Products.CMFCore.interfaces import IContentish\n-from Products.CMFCore.WorkflowCore import WorkflowException\n-from Products.ZCatalog.interfaces import IZCatalog\n-from zExceptions import BadRequest\n-from zope.component import getGlobalSiteManager\n-from zope.component import getUtility\n-from zope.container.contained import ContainerModifiedEvent\n-from zope.interface import alsoProvides\n-from zope.lifecycleevent import IObjectModifiedEvent\n-from zope.lifecycleevent import IObjectMovedEvent\n-from zope.lifecycleevent import modified\n-from zope.lifecycleevent import ObjectMovedEvent\n \n import mock\n import pkg_resources\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Petchesi-Iulian (Petchesi-Iulian) <iamnotacat12@gmail.com>
Commit: https://github.com/plone/plone.api/commit/46731b358ff709f36c33e6b56274166e48698454

Extra space in relation doc.

Files changed:
M docs/relation.rst

b'diff --git a/docs/relation.rst b/docs/relation.rst\nindex 0bf0141..b281712 100644\n--- a/docs/relation.rst\n+++ b/docs/relation.rst\n@@ -47,7 +47,8 @@ Get relations\n You must provide either source, target or relationship, ``unrestricted`` and ``as_dict`` are optional.\n \n Use the ``as_dict`` parameter if you want the result to be returned as a dictionary.\n-Use the ``unrestricted`` parameter if you want to bypass the View permission check.\n+\n+Use the ``unrestricted`` parameter if you want to bypass the View permission check on the relation objects(to/from_object).\n \n By default it returns a list.\n If source, target and relationship are all given, returns a list with a single item.\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Petchesi-Iulian (Petchesi-Iulian) <iamnotacat12@gmail.com>
Commit: https://github.com/plone/plone.api/commit/58443e901f854dfc865a9ce497b18a61388bd0cd

Plone 4 import fixes and corrected delete parameter.

Files changed:
M src/plone/api/relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex a95ddf6..8f55358 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -8,8 +8,6 @@\n from plone.api.exc import InvalidParameterError\n from plone.api.validation import at_least_one_of\n from plone.api.validation import required_parameters\n-from plone.app.linkintegrity.handlers import modifiedContent\n-from plone.app.linkintegrity.utils import referencedRelationship\n from plone.dexterity.interfaces import IDexterityContent\n from plone.dexterity.interfaces import IDexterityFTI\n from plone.dexterity.utils import iterSchemataForType\n@@ -31,10 +29,20 @@\n try:\n     from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n     from plone.app.iterate.dexterity.relation import StagingRelationValue\n+\n+    # Plone 4 import error\n+    from plone.app.linkintegrity.handlers import modifiedContent\n+    from plone.app.linkintegrity.utils import referencedRelationship\n except ImportError:\n     ITERATE_RELATION_NAME = None\n     StagingRelationValue = None\n \n+    # Plone 4 corrected paths\n+    from plone.app.linkintegrity.handlers import modifiedDexterity as modifiedContent\n+    from plone.app.linkintegrity.handlers import referencedRelationship\n+\n+\n+\n logger = logging.getLogger(__name__)\n \n \n@@ -132,7 +140,7 @@ def create(source=None, target=None, relationship=None):\n \n \n # @at_least_one_of(\'source\', \'target\', \'relationship\')\n-def delete(source=None, target=None, relationship=""):\n+def delete(source=None, target=None, relationship=None):\n     """Delete relation or relations.\n \n     If you do not specify any parameters, we delete all relations.\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Petchesi-Iulian (Petchesi-Iulian) <iamnotacat12@gmail.com>
Commit: https://github.com/plone/plone.api/commit/c86da2fee8afe903e23fc13b1bca057763a60549

Update relation docs

Files changed:
M docs/relation.rst
M src/plone/api/relation.py

b'diff --git a/docs/relation.rst b/docs/relation.rst\nindex b281712..4034963 100644\n--- a/docs/relation.rst\n+++ b/docs/relation.rst\n@@ -36,6 +36,7 @@ Delete relation\n \n     api.relation.delete(source=source, target=target, relationship="friend")\n \n+In order to delete relation(s), you must provide either the ``source``, ``target`` or ``relationship``.\n \n Get relations\n =============\ndiff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 8f55358..ba0adbf 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -42,7 +42,6 @@\n     from plone.app.linkintegrity.handlers import referencedRelationship\n \n \n-\n logger = logging.getLogger(__name__)\n \n \n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/004fc5513f805b80af8272267ab359442cc6e863

Relation doc: clarify what result you get.

It is always a list, unless you use as_dict=True.

Files changed:
M docs/relation.rst

b'diff --git a/docs/relation.rst b/docs/relation.rst\nindex 4034963..9809614 100644\n--- a/docs/relation.rst\n+++ b/docs/relation.rst\n@@ -45,14 +45,15 @@ Get relations\n \n     api.relation.get(source=source, target=target, relationship="friend", unrestricted=False, as_dict=False)\n \n-You must provide either source, target or relationship, ``unrestricted`` and ``as_dict`` are optional.\n+You must provide either source, target or relationship, or a combination of those.\n+``unrestricted`` and ``as_dict`` are optional.\n \n-Use the ``as_dict`` parameter if you want the result to be returned as a dictionary.\n+By default the result is a list of objects.\n+If you set ``as_dict=True`` it will return a dictionary with the names of the relations as keys and lists of objects as values.\n \n-Use the ``unrestricted`` parameter if you want to bypass the View permission check on the relation objects(to/from_object).\n-\n-By default it returns a list.\n-If source, target and relationship are all given, returns a list with a single item.\n+By default the View permission is checked on the relation objects.\n+You only get objects that you are allowed to see.\n+Use the ``unrestricted`` parameter if you want to bypass this check.\n \n To get back relations, so relations pointing to an item, use:\n \n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/483cd0c5dbdb87598d35b6f42231d95038a0cde4

Note: the relations code only works for Dexterity content, not for Archetypes.

Files changed:
M docs/relation.rst

b'diff --git a/docs/relation.rst b/docs/relation.rst\nindex 9809614..df9f516 100644\n--- a/docs/relation.rst\n+++ b/docs/relation.rst\n@@ -13,6 +13,8 @@\n Relations\n =========\n \n+Note: the relations code only works for Dexterity content, not for Archetypes.\n+\n .. _relation_create_example:\n \n Create relation\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/215380674ab6525de34521555d6456095e83bfda

Call iterSchemata with portal_type instead of first getting FTI utility.

With portal_type, iterSchemata can use its cache, which is faster than a utility lookup.
Tip from Jens.

Files changed:
M src/plone/api/relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex ba0adbf..1e345b4 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -9,7 +9,6 @@\n from plone.api.validation import at_least_one_of\n from plone.api.validation import required_parameters\n from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.interfaces import IDexterityFTI\n from plone.dexterity.utils import iterSchemataForType\n from z3c.relationfield import event\n from z3c.relationfield import RelationValue\n@@ -45,12 +44,12 @@\n logger = logging.getLogger(__name__)\n \n \n-def _get_field_and_schema_for_fieldname(field_id, fti):\n-    """Get field and its schema from a fti.\n+def _get_field_and_schema_for_fieldname(field_id, portal_type):\n+    """Get field and its schema from a portal_type.\n     """\n     # Turn form.widgets.IDublinCore.title into title\n     field_id = field_id.split(\'.\')[-1]\n-    for schema in iterSchemataForType(fti):\n+    for schema in iterSchemataForType(portal_type):\n         field = schema.get(field_id, None)\n         if field is not None:\n             return (field, schema)\n@@ -102,11 +101,7 @@ def create(source=None, target=None, relationship=None):\n         event._setRelation(source, ITERATE_RELATION_NAME, relation)\n         return\n \n-    fti = queryUtility(IDexterityFTI, name=source.portal_type)\n-    if not fti:\n-        logger.info(u\'{} is no dexterity content\'.format(source.portal_type))\n-        return\n-    field_and_schema = _get_field_and_schema_for_fieldname(from_attribute, fti)\n+    field_and_schema = _get_field_and_schema_for_fieldname(from_attribute, source.portal_type)\n \n     if field_and_schema is None:\n         # The relationship is not the name of a field. Only create a relation.\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:34:11+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/ebeae5c3b2929858f0552b7dd649329024acb8b9

Document relation.delete. Add delete_all parameter.

Files changed:
M docs/relation.rst
M src/plone/api/relation.py

b'diff --git a/docs/relation.rst b/docs/relation.rst\nindex df9f516..574e13d 100644\n--- a/docs/relation.rst\n+++ b/docs/relation.rst\n@@ -34,11 +34,50 @@ To create a relation between source object and target object, use :meth:`api.rel\n Delete relation\n ===============\n \n+Delete one specific relationship:\n+\n .. code-block:: python\n \n     api.relation.delete(source=source, target=target, relationship="friend")\n \n-In order to delete relation(s), you must provide either the ``source``, ``target`` or ``relationship``.\n+You can delete all relations by explicitly asking:\n+\n+.. code-block:: python\n+\n+    api.relation.delete(delete_all=True)\n+\n+In all other cases, in order to delete relation(s), you must provide either ``source``, ``target`` or ``relationship``.\n+You can mix and match.\n+\n+Delete all relations from source to any target:\n+\n+.. code-block:: python\n+\n+    api.relation.delete(source=source)\n+\n+Delete all relations from any source to this target:\n+\n+.. code-block:: python\n+\n+    api.relation.delete(target=target)\n+\n+Delete relations with name "friend" from source to any target:\n+\n+.. code-block:: python\n+\n+    api.relation.delete(source=source, relationship="friend")\n+\n+Delete relations with name "uncle" from any source to this target:\n+\n+.. code-block:: python\n+\n+    api.relation.delete(target=target, relationship="uncle")\n+\n+Delete relations with name "enemy" from any source to any target:\n+\n+.. code-block:: python\n+\n+    api.relation.delete(relationship="enemy")\n \n Get relations\n =============\ndiff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 1e345b4..19a8537 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -133,11 +133,12 @@ def create(source=None, target=None, relationship=None):\n         from_attribute, source.absolute_url(), target.absolute_url()))\n \n \n-# @at_least_one_of(\'source\', \'target\', \'relationship\')\n-def delete(source=None, target=None, relationship=None):\n+@at_least_one_of(\'source\', \'target\', \'relationship\', \'delete_all\')\n+def delete(source=None, target=None, relationship=None, delete_all=False):\n     """Delete relation or relations.\n \n-    If you do not specify any parameters, we delete all relations.\n+    If you specify \'delete_all=True\' and none of the other parameters,\n+    we delete all relations.\n \n     TODO: do we want to remove RelationValues from content objects?\n     """\n@@ -150,6 +151,9 @@ def delete(source=None, target=None, relationship=None):\n     if relationship is not None and not isinstance(relationship, six.string_types):\n         raise InvalidParameterError(\'{} is no string\'.format(relationship))\n \n+    if delete_all and (source or target or relationship is not None):\n+        raise InvalidParameterError(\'When you use delete_all, you must not specify any other parameters\')\n+\n     query = {}\n     relation_catalog = getUtility(ICatalog)\n     intids = getUtility(IIntIds)\n@@ -159,7 +163,9 @@ def delete(source=None, target=None, relationship=None):\n         query[\'to_id\'] = intids.getId(target)\n     if relationship is not None:\n         query[\'from_attribute\'] = relationship\n-    # If the query is empty, we could do relation_catalog.clear().\n+    if not query:\n+        relation_catalog.clear()\n+        return\n     for rel in relation_catalog.findRelations(query):\n         relation_catalog.unindex(rel)\n \n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:35:41+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/565afce3fba29c34a626d5c53d4ce0906130fd15

Add z3c.relationfield dependency.

Files changed:
M docs/relation.rst
M setup.py

b"diff --git a/docs/relation.rst b/docs/relation.rst\nindex 574e13d..45993ed 100644\n--- a/docs/relation.rst\n+++ b/docs/relation.rst\n@@ -15,6 +15,8 @@ Relations\n \n Note: the relations code only works for Dexterity content, not for Archetypes.\n \n+To use the relations code, you should include `plone.api[relations]` in the dependencies of your project.\n+\n .. _relation_create_example:\n \n Create relation\ndiff --git a/setup.py b/setup.py\nindex e37f424..7723b02 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -48,6 +48,7 @@ def read(*rnames):\n             'plone.app.testing',\n             'plone.indexer',\n             'plone.registry',\n+            'z3c.relationfield',\n         ],\n     },\n     classifiers=[\n"

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:36:06+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/a795e450a0c05e4e37722904639c236f1a8215da

Handle case of relationship with same name as non-relation field.

Files changed:
M src/plone/api/relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 19a8537..7f2c170 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -60,7 +60,7 @@ def create(source=None, target=None, relationship=None):\n     """Create a relation from source to target using zc.relation\n \n     For RelationChoice or RelationList it will add the relation as attribute.\n-    Other relations they will only be added to the relation-catalog.\n+    Other relations will only be added to the relation-catalog.\n \n     Copied from collective.relationhelpers link_objects.\n     """\n@@ -110,7 +110,7 @@ def create(source=None, target=None, relationship=None):\n         event._setRelation(source, from_attribute, RelationValue(to_id))\n         return\n \n-    field, schema = field_and_schema\n+    field, _schema = field_and_schema\n \n     if isinstance(field, RelationList):\n         logger.info(\'Add relation to relationlist {} from {} to {}\'.format(\n@@ -128,9 +128,19 @@ def create(source=None, target=None, relationship=None):\n         modified(source)\n         return\n \n-    # We should never end up here!\n-    logger.info(\'Warning: Unexpected relation {} from {} to {}\'.format(\n-        from_attribute, source.absolute_url(), target.absolute_url()))\n+    # If we end up here, someone is making a relationship that\n+    # has the same name as a non-relation field.\n+    # This can be harmless coincidence, and this could be an error,\n+    # indicating that the field is of the wrong type.\n+    # Let\'s create the relationship and log a warning.\n+    event._setRelation(source, from_attribute, RelationValue(to_id))\n+    logger.warning(\n+        \'Created relation {} on an item that has a field with the same name \'\n+        \'which is not a relation field. Is this what you wanted? \'\n+        \'Relation points from {} to {}\'.format(\n+            from_attribute, source.absolute_url(), target.absolute_url()\n+        )\n+    )\n \n \n @at_least_one_of(\'source\', \'target\', \'relationship\', \'delete_all\')\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:36:06+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/5e117e74cdbe2692c6460009ae9a35214af045a6

Looks like relation source/target can be Archetypes.

The only difference with dexterity is that in Archetypes we do not find a field with the name of the relation.
So we set no attribute on the source, but we do create a relation.
Source and target just need a portal_type, and need to have an intid.

Files changed:
M docs/relation.rst
M setup.py
M src/plone/api/profiles/testfixture/metadata.xml
M src/plone/api/relation.py
M src/plone/api/tests/test_relation.py

b'diff --git a/docs/relation.rst b/docs/relation.rst\nindex 45993ed..bdbe3e6 100644\n--- a/docs/relation.rst\n+++ b/docs/relation.rst\n@@ -13,8 +13,6 @@\n Relations\n =========\n \n-Note: the relations code only works for Dexterity content, not for Archetypes.\n-\n To use the relations code, you should include `plone.api[relations]` in the dependencies of your project.\n \n .. _relation_create_example:\ndiff --git a/setup.py b/setup.py\nindex 7723b02..02acd7d 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -45,6 +45,7 @@ def read(*rnames):\n             \'manuel\',\n             \'mock\',\n             \'plone.app.dexterity\',\n+            \'plone.app.intid\',\n             \'plone.app.testing\',\n             \'plone.indexer\',\n             \'plone.registry\',\ndiff --git a/src/plone/api/profiles/testfixture/metadata.xml b/src/plone/api/profiles/testfixture/metadata.xml\nindex 7030086..9f02b5e 100644\n--- a/src/plone/api/profiles/testfixture/metadata.xml\n+++ b/src/plone/api/profiles/testfixture/metadata.xml\n@@ -3,5 +3,6 @@\n   <version>1</version>\n   <dependencies>\n     <dependency>profile-plone.app.dexterity:default</dependency>\n+    <dependency>profile-plone.app.intid:default</dependency>\n   </dependencies>\n </metadata>\ndiff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 7f2c170..df01c3a 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -8,8 +8,8 @@\n from plone.api.exc import InvalidParameterError\n from plone.api.validation import at_least_one_of\n from plone.api.validation import required_parameters\n-from plone.dexterity.interfaces import IDexterityContent\n from plone.dexterity.utils import iterSchemataForType\n+from Products.CMFPlone.utils import base_hasattr\n from z3c.relationfield import event\n from z3c.relationfield import RelationValue\n from z3c.relationfield.schema import Relation\n@@ -59,16 +59,19 @@ def _get_field_and_schema_for_fieldname(field_id, portal_type):\n def create(source=None, target=None, relationship=None):\n     """Create a relation from source to target using zc.relation\n \n-    For RelationChoice or RelationList it will add the relation as attribute.\n+    If source is dexterity content, and the relationship name is the same\n+    as a field name, and this field is a RelationChoice/RelationList/Relation,\n+    we will add the relation as attribute.\n+\n     Other relations will only be added to the relation-catalog.\n \n-    Copied from collective.relationhelpers link_objects.\n+    Adapted from collective.relationhelpers link_objects.\n     """\n-    if not IDexterityContent.providedBy(source):\n-        raise InvalidParameterError(\'{} is no dexterity content\'.format(source))\n+    if source is not None and not base_hasattr(source, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n \n-    if not IDexterityContent.providedBy(target):\n-        raise InvalidParameterError(\'{} is no dexterity content\'.format(target))\n+    if target is not None and not base_hasattr(target, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n \n     if not isinstance(relationship, six.string_types):\n         raise InvalidParameterError(\'{} is no string\'.format(relationship))\n@@ -101,11 +104,13 @@ def create(source=None, target=None, relationship=None):\n         event._setRelation(source, ITERATE_RELATION_NAME, relation)\n         return\n \n+    # This can only get a field from a dexterity item.\n     field_and_schema = _get_field_and_schema_for_fieldname(from_attribute, source.portal_type)\n \n     if field_and_schema is None:\n-        # The relationship is not the name of a field. Only create a relation.\n-        logger.info(u\'No field. Setting relation {} from {} to {}\'.format(\n+        # The relationship is not the name of a dexterity field.\n+        # Only create a relation.\n+        logger.debug(u\'No dexterity field. Setting relation {} from {} to {}\'.format(\n             source.absolute_url(), target.absolute_url(), relationship))\n         event._setRelation(source, from_attribute, RelationValue(to_id))\n         return\n@@ -152,11 +157,11 @@ def delete(source=None, target=None, relationship=None, delete_all=False):\n \n     TODO: do we want to remove RelationValues from content objects?\n     """\n-    if source is not None and not IDexterityContent.providedBy(source):\n-        raise InvalidParameterError(\'{} is no dexterity content\'.format(source))\n+    if source is not None and not base_hasattr(source, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n \n-    if target is not None and not IDexterityContent.providedBy(target):\n-        raise InvalidParameterError(\'{} is no dexterity content\'.format(target))\n+    if target is not None and not base_hasattr(target, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n \n     if relationship is not None and not isinstance(relationship, six.string_types):\n         raise InvalidParameterError(\'{} is no string\'.format(relationship))\n@@ -187,11 +192,11 @@ def get(source=None, target=None, relationship=None,\n \n     Copied and modified from collective.relationhelpers get_relations.\n     """\n-    if source is not None and not IDexterityContent.providedBy(source):\n-        raise InvalidParameterError(\'{} is no dexterity content\'.format(source))\n+    if source is not None and not base_hasattr(source, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n \n-    if target is not None and not IDexterityContent.providedBy(target):\n-        raise InvalidParameterError(\'{} is no dexterity content\'.format(target))\n+    if target is not None and not base_hasattr(target, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n \n     if relationship is not None and not isinstance(relationship, six.string_types):\n         raise InvalidParameterError(\'{} is no string\'.format(relationship))\ndiff --git a/src/plone/api/tests/test_relation.py b/src/plone/api/tests/test_relation.py\nindex 4875c39..0e4ddb7 100644\n--- a/src/plone/api/tests/test_relation.py\n+++ b/src/plone/api/tests/test_relation.py\n@@ -121,9 +121,8 @@ def test_create_constraints(self):\n                 target=self.blog,\n             )\n \n-        # We require a dexterity source\n+        # We require a source with portal_type\n         app = self.layer["app"]\n-        app.portal_type = "ZopeRoot"\n         with self.assertRaises(InvalidParameterError):\n             api.relation.create(\n                 source=app,\n@@ -131,7 +130,7 @@ def test_create_constraints(self):\n                 relationship=\'link\',\n             )\n \n-        # We require a dexterity target\n+        # We require a target with portal_type\n         with self.assertRaises(InvalidParameterError):\n             api.relation.create(\n                 source=self.about,\n@@ -167,13 +166,12 @@ def test_delete_constraints(self):\n         """Test the constraints when deleting relations."""\n         from plone.api.exc import InvalidParameterError\n \n-        # If source is given, it must be dexterity.\n+        # If source is given, it must have a portal_type.\n         app = self.layer["app"]\n-        app.portal_type = "ZopeRoot"\n         with self.assertRaises(InvalidParameterError):\n             api.relation.delete(source=app)\n \n-        # If target is given, it must be dexterity.\n+        # If target is given, it must have a portal_type.\n         with self.assertRaises(InvalidParameterError):\n             api.relation.delete(target=app)\n \n@@ -201,13 +199,12 @@ def test_get_constraints(self):\n         """Test the constraints when getting relations."""\n         from plone.api.exc import InvalidParameterError\n \n-        # If source is given, it must be dexterity.\n+        # If source is given, it must have a portal_type.\n         app = self.layer["app"]\n-        app.portal_type = "ZopeRoot"\n         with self.assertRaises(InvalidParameterError):\n             api.relation.get(source=app)\n \n-        # If target is given, it must be dexterity.\n+        # If target is given, it must have a portal_type.\n         with self.assertRaises(InvalidParameterError):\n             api.relation.get(target=app)\n \n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:36:06+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/92528973d839f96ae9c87ceb9700442befee1336

Ran 'tox -e black-enforce' on relation code.

Files changed:
M src/plone/api/relation.py
M src/plone/api/tests/test_relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex df01c3a..34bd28d 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -37,7 +37,9 @@\n     StagingRelationValue = None\n \n     # Plone 4 corrected paths\n-    from plone.app.linkintegrity.handlers import modifiedDexterity as modifiedContent\n+    from plone.app.linkintegrity.handlers import (\n+        modifiedDexterity as modifiedContent,\n+    )\n     from plone.app.linkintegrity.handlers import referencedRelationship\n \n \n@@ -45,8 +47,7 @@\n \n \n def _get_field_and_schema_for_fieldname(field_id, portal_type):\n-    """Get field and its schema from a portal_type.\n-    """\n+    """Get field and its schema from a portal_type."""\n     # Turn form.widgets.IDublinCore.title into title\n     field_id = field_id.split(\'.\')[-1]\n     for schema in iterSchemataForType(portal_type):\n@@ -98,28 +99,39 @@ def create(source=None, target=None, relationship=None):\n         modifiedContent(source, None)\n         return\n \n-    if ITERATE_RELATION_NAME is not None and from_attribute == ITERATE_RELATION_NAME:\n+    if (\n+        ITERATE_RELATION_NAME is not None\n+        and from_attribute == ITERATE_RELATION_NAME\n+    ):\n         # Iterate relations use a subclass of RelationValue\n         relation = StagingRelationValue(to_id)\n         event._setRelation(source, ITERATE_RELATION_NAME, relation)\n         return\n \n     # This can only get a field from a dexterity item.\n-    field_and_schema = _get_field_and_schema_for_fieldname(from_attribute, source.portal_type)\n+    field_and_schema = _get_field_and_schema_for_fieldname(\n+        from_attribute, source.portal_type\n+    )\n \n     if field_and_schema is None:\n         # The relationship is not the name of a dexterity field.\n         # Only create a relation.\n-        logger.debug(u\'No dexterity field. Setting relation {} from {} to {}\'.format(\n-            source.absolute_url(), target.absolute_url(), relationship))\n+        logger.debug(\n+            u\'No dexterity field. Setting relation {} from {} to {}\'.format(\n+                source.absolute_url(), target.absolute_url(), relationship\n+            )\n+        )\n         event._setRelation(source, from_attribute, RelationValue(to_id))\n         return\n \n     field, _schema = field_and_schema\n \n     if isinstance(field, RelationList):\n-        logger.info(\'Add relation to relationlist {} from {} to {}\'.format(\n-            from_attribute, source.absolute_url(), target.absolute_url()))\n+        logger.info(\n+            \'Add relation to relationlist {} from {} to {}\'.format(\n+                from_attribute, source.absolute_url(), target.absolute_url()\n+            )\n+        )\n         existing_relations = getattr(source, from_attribute, [])\n         existing_relations.append(RelationValue(to_id))\n         setattr(source, from_attribute, existing_relations)\n@@ -127,8 +139,11 @@ def create(source=None, target=None, relationship=None):\n         return\n \n     elif isinstance(field, (Relation, RelationChoice)):\n-        logger.info(\'Add relation {} from {} to {}\'.format(\n-            from_attribute, source.absolute_url(), target.absolute_url()))\n+        logger.info(\n+            \'Add relation {} from {} to {}\'.format(\n+                from_attribute, source.absolute_url(), target.absolute_url()\n+            )\n+        )\n         setattr(source, from_attribute, RelationValue(to_id))\n         modified(source)\n         return\n@@ -163,11 +178,15 @@ def delete(source=None, target=None, relationship=None, delete_all=False):\n     if target is not None and not base_hasattr(target, \'portal_type\'):\n         raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n \n-    if relationship is not None and not isinstance(relationship, six.string_types):\n+    if relationship is not None and not isinstance(\n+        relationship, six.string_types\n+    ):\n         raise InvalidParameterError(\'{} is no string\'.format(relationship))\n \n     if delete_all and (source or target or relationship is not None):\n-        raise InvalidParameterError(\'When you use delete_all, you must not specify any other parameters\')\n+        raise InvalidParameterError(\n+            \'When you use delete_all, you must not specify any other parameters\'\n+        )\n \n     query = {}\n     relation_catalog = getUtility(ICatalog)\n@@ -186,8 +205,13 @@ def delete(source=None, target=None, relationship=None, delete_all=False):\n \n \n @at_least_one_of(\'source\', \'target\', \'relationship\')\n-def get(source=None, target=None, relationship=None,\n-        unrestricted=False, as_dict=False):\n+def get(\n+    source=None,\n+    target=None,\n+    relationship=None,\n+    unrestricted=False,\n+    as_dict=False,\n+):\n     """Get specific relations given a source/target/relationship\n \n     Copied and modified from collective.relationhelpers get_relations.\n@@ -198,7 +222,9 @@ def get(source=None, target=None, relationship=None,\n     if target is not None and not base_hasattr(target, \'portal_type\'):\n         raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n \n-    if relationship is not None and not isinstance(relationship, six.string_types):\n+    if relationship is not None and not isinstance(\n+        relationship, six.string_types\n+    ):\n         raise InvalidParameterError(\'{} is no string\'.format(relationship))\n \n     intids = getUtility(IIntIds)\n@@ -230,8 +256,9 @@ def get(source=None, target=None, relationship=None,\n             source_obj = relation.from_object\n             target_obj = relation.to_object\n \n-            if checkPermission(\'View\', source_obj) and checkPermission(\'View\',\n-                    target_obj):\n+            if checkPermission(\'View\', source_obj) and checkPermission(\n+                \'View\', target_obj\n+            ):\n                 if as_dict:\n                     results[relation.from_attribute].append(relation)\n                 else:\ndiff --git a/src/plone/api/tests/test_relation.py b/src/plone/api/tests/test_relation.py\nindex 0e4ddb7..2f1cbc8 100644\n--- a/src/plone/api/tests/test_relation.py\n+++ b/src/plone/api/tests/test_relation.py\n@@ -149,14 +149,18 @@ def test_create_constraints(self):\n     def test_create_relation(self):\n         """Test creating a relation."""\n         # Check that there are no relations at first for the two objects we will test.\n-        relations = api.relation.get(source=self.about, target=self.blog, relationship="link")\n+        relations = api.relation.get(\n+            source=self.about, target=self.blog, relationship="link"\n+        )\n         self.assertEqual(len(relations), 0)\n         api.relation.create(\n             source=self.about,\n             target=self.blog,\n             relationship=\'link\',\n         )\n-        relations = api.relation.get(source=self.about, target=self.blog, relationship="link")\n+        relations = api.relation.get(\n+            source=self.about, target=self.blog, relationship="link"\n+        )\n         self.assertEqual(len(relations), 1)\n         relation = relations[0]\n         self.assertEqual(relation.from_object, self.about)\n@@ -191,10 +195,11 @@ def test_delete_relation(self):\n             target=self.blog,\n             relationship=\'link\',\n         )\n-        relations = api.relation.get(source=self.about, target=self.blog, relationship="link")\n+        relations = api.relation.get(\n+            source=self.about, target=self.blog, relationship="link"\n+        )\n         self.assertEqual(len(relations), 0)\n \n-\n     def test_get_constraints(self):\n         """Test the constraints when getting relations."""\n         from plone.api.exc import InvalidParameterError\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:36:06+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/fda05d2e4414b6d5c89229bdcc86712d32f23965

Removed Plone 4 imports from relation code.

Files changed:
M src/plone/api/relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 34bd28d..16cd29f 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -8,6 +8,10 @@\n from plone.api.exc import InvalidParameterError\n from plone.api.validation import at_least_one_of\n from plone.api.validation import required_parameters\n+from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n+from plone.app.iterate.dexterity.relation import StagingRelationValue\n+from plone.app.linkintegrity.handlers import modifiedContent\n+from plone.app.linkintegrity.utils import referencedRelationship\n from plone.dexterity.utils import iterSchemataForType\n from Products.CMFPlone.utils import base_hasattr\n from z3c.relationfield import event\n@@ -25,23 +29,6 @@\n import logging\n import six\n \n-try:\n-    from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n-    from plone.app.iterate.dexterity.relation import StagingRelationValue\n-\n-    # Plone 4 import error\n-    from plone.app.linkintegrity.handlers import modifiedContent\n-    from plone.app.linkintegrity.utils import referencedRelationship\n-except ImportError:\n-    ITERATE_RELATION_NAME = None\n-    StagingRelationValue = None\n-\n-    # Plone 4 corrected paths\n-    from plone.app.linkintegrity.handlers import (\n-        modifiedDexterity as modifiedContent,\n-    )\n-    from plone.app.linkintegrity.handlers import referencedRelationship\n-\n \n logger = logging.getLogger(__name__)\n \n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:36:06+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.api/commit/63fb6acaf5c41a5c7cf80c899b2480a67cdd9877

Fixed warnings from tox lint in relation code.

But some are caused by black, so we may need to change something in the confif.

Files changed:
M src/plone/api/relation.py
M src/plone/api/tests/test_relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 16cd29f..35253db 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -21,11 +21,9 @@\n from z3c.relationfield.schema import RelationList\n from zc.relation.interfaces import ICatalog\n from zope.component import getUtility\n-from zope.component import queryUtility\n from zope.intid.interfaces import IIntIds\n from zope.lifecycleevent import modified\n \n-import json\n import logging\n import six\n \n@@ -56,13 +54,13 @@ def create(source=None, target=None, relationship=None):\n     Adapted from collective.relationhelpers link_objects.\n     """\n     if source is not None and not base_hasattr(source, \'portal_type\'):\n-        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n+        raise InvalidParameterError(\'{0} has no portal_type\'.format(source))\n \n     if target is not None and not base_hasattr(target, \'portal_type\'):\n-        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n+        raise InvalidParameterError(\'{0} has no portal_type\'.format(target))\n \n     if not isinstance(relationship, six.string_types):\n-        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n+        raise InvalidParameterError(\'{0} is no string\'.format(relationship))\n \n     relation_catalog = getUtility(ICatalog)\n     intids = getUtility(IIntIds)\n@@ -97,16 +95,18 @@ def create(source=None, target=None, relationship=None):\n \n     # This can only get a field from a dexterity item.\n     field_and_schema = _get_field_and_schema_for_fieldname(\n-        from_attribute, source.portal_type\n+        from_attribute,\n+        source.portal_type,\n     )\n \n     if field_and_schema is None:\n         # The relationship is not the name of a dexterity field.\n         # Only create a relation.\n         logger.debug(\n-            u\'No dexterity field. Setting relation {} from {} to {}\'.format(\n-                source.absolute_url(), target.absolute_url(), relationship\n-            )\n+            u\'No dexterity field. Setting relation %s from %s to %s\',\n+            source.absolute_url(),\n+            target.absolute_url(),\n+            relationship,\n         )\n         event._setRelation(source, from_attribute, RelationValue(to_id))\n         return\n@@ -115,9 +115,10 @@ def create(source=None, target=None, relationship=None):\n \n     if isinstance(field, RelationList):\n         logger.info(\n-            \'Add relation to relationlist {} from {} to {}\'.format(\n-                from_attribute, source.absolute_url(), target.absolute_url()\n-            )\n+            \'Add relation to relationlist %s from %s to %s\',\n+            from_attribute,\n+            source.absolute_url(),\n+            target.absolute_url(),\n         )\n         existing_relations = getattr(source, from_attribute, [])\n         existing_relations.append(RelationValue(to_id))\n@@ -127,9 +128,10 @@ def create(source=None, target=None, relationship=None):\n \n     elif isinstance(field, (Relation, RelationChoice)):\n         logger.info(\n-            \'Add relation {} from {} to {}\'.format(\n-                from_attribute, source.absolute_url(), target.absolute_url()\n-            )\n+            \'Add relation %s from %s to %s\',\n+            from_attribute,\n+            source.absolute_url(),\n+            target.absolute_url(),\n         )\n         setattr(source, from_attribute, RelationValue(to_id))\n         modified(source)\n@@ -142,11 +144,12 @@ def create(source=None, target=None, relationship=None):\n     # Let\'s create the relationship and log a warning.\n     event._setRelation(source, from_attribute, RelationValue(to_id))\n     logger.warning(\n-        \'Created relation {} on an item that has a field with the same name \'\n+        \'Created relation %s on an item that has a field with the same name \'\n         \'which is not a relation field. Is this what you wanted? \'\n-        \'Relation points from {} to {}\'.format(\n-            from_attribute, source.absolute_url(), target.absolute_url()\n-        )\n+        \'Relation points from %s to %s\',\n+        from_attribute,\n+        source.absolute_url(),\n+        target.absolute_url(),\n     )\n \n \n@@ -160,19 +163,20 @@ def delete(source=None, target=None, relationship=None, delete_all=False):\n     TODO: do we want to remove RelationValues from content objects?\n     """\n     if source is not None and not base_hasattr(source, \'portal_type\'):\n-        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n+        raise InvalidParameterError(\'{0} has no portal_type\'.format(source))\n \n     if target is not None and not base_hasattr(target, \'portal_type\'):\n-        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n+        raise InvalidParameterError(\'{0} has no portal_type\'.format(target))\n \n     if relationship is not None and not isinstance(\n-        relationship, six.string_types\n+        relationship,\n+        six.string_types,\n     ):\n-        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n+        raise InvalidParameterError(\'{0} is no string\'.format(relationship))\n \n     if delete_all and (source or target or relationship is not None):\n         raise InvalidParameterError(\n-            \'When you use delete_all, you must not specify any other parameters\'\n+            \'When you use delete_all, you must not use any other parameters.\',\n         )\n \n     query = {}\n@@ -204,15 +208,16 @@ def get(\n     Copied and modified from collective.relationhelpers get_relations.\n     """\n     if source is not None and not base_hasattr(source, \'portal_type\'):\n-        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n+        raise InvalidParameterError(\'{0} has no portal_type\'.format(source))\n \n     if target is not None and not base_hasattr(target, \'portal_type\'):\n-        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n+        raise InvalidParameterError(\'{0} has no portal_type\'.format(target))\n \n     if relationship is not None and not isinstance(\n-        relationship, six.string_types\n+        relationship,\n+        six.string_types,\n     ):\n-        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n+        raise InvalidParameterError(\'{0} is no string\'.format(relationship))\n \n     intids = getUtility(IIntIds)\n     relation_catalog = getUtility(ICatalog)\n@@ -244,7 +249,8 @@ def get(\n             target_obj = relation.to_object\n \n             if checkPermission(\'View\', source_obj) and checkPermission(\n-                \'View\', target_obj\n+                \'View\',\n+                target_obj,\n             ):\n                 if as_dict:\n                     results[relation.from_attribute].append(relation)\ndiff --git a/src/plone/api/tests/test_relation.py b/src/plone/api/tests/test_relation.py\nindex 2f1cbc8..d5909e5 100644\n--- a/src/plone/api/tests/test_relation.py\n+++ b/src/plone/api/tests/test_relation.py\n@@ -4,20 +4,9 @@\n from plone import api\n from plone.api.tests.base import INTEGRATION_TESTING\n \n-import mock\n-import pkg_resources\n-import six\n import unittest\n \n \n-try:\n-    pkg_resources.get_distribution(\'plone.app.contenttypes\')\n-except pkg_resources.DistributionNotFound:\n-    HAS_PACONTENTYPES = False\n-else:\n-    HAS_PACONTENTYPES = True\n-\n-\n class TestPloneApiRelation(unittest.TestCase):\n     """Unit tests for relations using plone.api"""\n \n@@ -122,7 +111,7 @@ def test_create_constraints(self):\n             )\n \n         # We require a source with portal_type\n-        app = self.layer["app"]\n+        app = self.layer[\'app\']\n         with self.assertRaises(InvalidParameterError):\n             api.relation.create(\n                 source=app,\n@@ -148,9 +137,12 @@ def test_create_constraints(self):\n \n     def test_create_relation(self):\n         """Test creating a relation."""\n-        # Check that there are no relations at first for the two objects we will test.\n+        # Check that there are no relations at first\n+        # for the two objects we will test.\n         relations = api.relation.get(\n-            source=self.about, target=self.blog, relationship="link"\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n         )\n         self.assertEqual(len(relations), 0)\n         api.relation.create(\n@@ -159,7 +151,9 @@ def test_create_relation(self):\n             relationship=\'link\',\n         )\n         relations = api.relation.get(\n-            source=self.about, target=self.blog, relationship="link"\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n         )\n         self.assertEqual(len(relations), 1)\n         relation = relations[0]\n@@ -171,7 +165,7 @@ def test_delete_constraints(self):\n         from plone.api.exc import InvalidParameterError\n \n         # If source is given, it must have a portal_type.\n-        app = self.layer["app"]\n+        app = self.layer[\'app\']\n         with self.assertRaises(InvalidParameterError):\n             api.relation.delete(source=app)\n \n@@ -196,7 +190,9 @@ def test_delete_relation(self):\n             relationship=\'link\',\n         )\n         relations = api.relation.get(\n-            source=self.about, target=self.blog, relationship="link"\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n         )\n         self.assertEqual(len(relations), 0)\n \n@@ -205,7 +201,7 @@ def test_get_constraints(self):\n         from plone.api.exc import InvalidParameterError\n \n         # If source is given, it must have a portal_type.\n-        app = self.layer["app"]\n+        app = self.layer[\'app\']\n         with self.assertRaises(InvalidParameterError):\n             api.relation.get(source=app)\n \n@@ -241,7 +237,7 @@ def test_get_relation(self):\n         )\n         self.assertEqual(len(api.relation.get(source=self.about)), 1)\n         self.assertEqual(len(api.relation.get(target=self.blog)), 2)\n-        self.assertEqual(len(api.relation.get(relationship="link")), 3)\n+        self.assertEqual(len(api.relation.get(relationship=\'link\')), 3)\n \n         self.assertEqual(len(api.relation.get(source=self.events)), 2)\n-        self.assertEqual(len(api.relation.get(relationship="team")), 1)\n+        self.assertEqual(len(api.relation.get(relationship=\'team\')), 1)\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T15:38:35+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.api/commit/5b3169275f8b34f9a931c102d9141ba64ae1f82c

pyupgrade

Files changed:
M src/plone/api/relation.py
M src/plone/api/tests/test_relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 35253db..680f69f 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """Module that provides functionality for relations.\n \n Heavily inspired by collective.relationhelpers.\n@@ -25,7 +24,6 @@\n from zope.lifecycleevent import modified\n \n import logging\n-import six\n \n \n logger = logging.getLogger(__name__)\n@@ -54,13 +52,13 @@ def create(source=None, target=None, relationship=None):\n     Adapted from collective.relationhelpers link_objects.\n     """\n     if source is not None and not base_hasattr(source, \'portal_type\'):\n-        raise InvalidParameterError(\'{0} has no portal_type\'.format(source))\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n \n     if target is not None and not base_hasattr(target, \'portal_type\'):\n-        raise InvalidParameterError(\'{0} has no portal_type\'.format(target))\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n \n-    if not isinstance(relationship, six.string_types):\n-        raise InvalidParameterError(\'{0} is no string\'.format(relationship))\n+    if not isinstance(relationship, str):\n+        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n \n     relation_catalog = getUtility(ICatalog)\n     intids = getUtility(IIntIds)\n@@ -103,7 +101,7 @@ def create(source=None, target=None, relationship=None):\n         # The relationship is not the name of a dexterity field.\n         # Only create a relation.\n         logger.debug(\n-            u\'No dexterity field. Setting relation %s from %s to %s\',\n+            \'No dexterity field. Setting relation %s from %s to %s\',\n             source.absolute_url(),\n             target.absolute_url(),\n             relationship,\n@@ -163,16 +161,16 @@ def delete(source=None, target=None, relationship=None, delete_all=False):\n     TODO: do we want to remove RelationValues from content objects?\n     """\n     if source is not None and not base_hasattr(source, \'portal_type\'):\n-        raise InvalidParameterError(\'{0} has no portal_type\'.format(source))\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n \n     if target is not None and not base_hasattr(target, \'portal_type\'):\n-        raise InvalidParameterError(\'{0} has no portal_type\'.format(target))\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n \n     if relationship is not None and not isinstance(\n         relationship,\n-        six.string_types,\n+        str,\n     ):\n-        raise InvalidParameterError(\'{0} is no string\'.format(relationship))\n+        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n \n     if delete_all and (source or target or relationship is not None):\n         raise InvalidParameterError(\n@@ -208,16 +206,16 @@ def get(\n     Copied and modified from collective.relationhelpers get_relations.\n     """\n     if source is not None and not base_hasattr(source, \'portal_type\'):\n-        raise InvalidParameterError(\'{0} has no portal_type\'.format(source))\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n \n     if target is not None and not base_hasattr(target, \'portal_type\'):\n-        raise InvalidParameterError(\'{0} has no portal_type\'.format(target))\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n \n     if relationship is not None and not isinstance(\n         relationship,\n-        six.string_types,\n+        str,\n     ):\n-        raise InvalidParameterError(\'{0} is no string\'.format(relationship))\n+        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n \n     intids = getUtility(IIntIds)\n     relation_catalog = getUtility(ICatalog)\ndiff --git a/src/plone/api/tests/test_relation.py b/src/plone/api/tests/test_relation.py\nindex d5909e5..c26172f 100644\n--- a/src/plone/api/tests/test_relation.py\n+++ b/src/plone/api/tests/test_relation.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n """Tests for plone.api.content."""\n \n from plone import api\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T16:36:24+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.api/commit/a273e3a61e1aae4bb229abb0249c5ae3f5720cb2

add more tests for api.relation.get()

Files changed:
M src/plone/api/tests/test_relation.py

b'diff --git a/src/plone/api/tests/test_relation.py b/src/plone/api/tests/test_relation.py\nindex c26172f..9d48fcf 100644\n--- a/src/plone/api/tests/test_relation.py\n+++ b/src/plone/api/tests/test_relation.py\n@@ -2,6 +2,10 @@\n \n from plone import api\n from plone.api.tests.base import INTEGRATION_TESTING\n+from plone.app.testing import login\n+from plone.app.testing import logout\n+from plone.app.testing import setRoles\n+from z3c.relationfield import RelationValue\n \n import unittest\n \n@@ -235,8 +239,88 @@ def test_get_relation(self):\n             relationship=\'link\',\n         )\n         self.assertEqual(len(api.relation.get(source=self.about)), 1)\n+        self.assertIsInstance(api.relation.get(source=self.about), list)\n+        self.assertIsInstance(api.relation.get(source=self.about)[0], RelationValue)\n+\n         self.assertEqual(len(api.relation.get(target=self.blog)), 2)\n         self.assertEqual(len(api.relation.get(relationship=\'link\')), 3)\n \n+        self.assertEqual(len(api.relation.get(source=self.about, relationship=\'link\')), 1)\n+        self.assertEqual(len(api.relation.get(source=self.about, target=self.events)), 0)\n+        self.assertEqual(len(api.relation.get(source=self.about, target=self.blog)), 1)\n+\n         self.assertEqual(len(api.relation.get(source=self.events)), 2)\n         self.assertEqual(len(api.relation.get(relationship=\'team\')), 1)\n+\n+    def test_get_relation_as_dict(self):\n+        """Test getting relations as dicts"""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.events,\n+            target=self.blog,\n+            relationship=\'bloglink\',\n+        )\n+        self.assertEqual(len(api.relation.get(relationship=\'link\', as_dict=True)[\'link\']), 1)\n+        rels = api.relation.get(target=self.blog, as_dict=True)\n+        self.assertEqual(len(rels[\'link\']), 1)\n+        self.assertEqual(len(rels[\'bloglink\']), 1)\n+\n+    def test_get_broken_relation(self):\n+        """Test that broken relations are ignored."""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.events,\n+            target=self.portal.image,\n+            relationship=\'link\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 1)\n+        self.assertEqual(len(api.relation.get(relationship=\'link\')), 2)\n+\n+        # break a relation\n+        self.portal._delObject(\'blog\')\n+\n+        self.assertEqual(len(api.relation.get(source=self.about)), 0)\n+        self.assertEqual(len(api.relation.get(relationship=\'link\')), 1)\n+\n+    def test_restricted_relation(self):\n+        """Test that rels between inaccessible items are ignored."""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.events,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.about.team,\n+            target=self.events,\n+            relationship=\'team\',\n+        )\n+        api.relation.create(\n+            source=self.events,\n+            target=self.portal.image,\n+            relationship=\'link\',\n+        )\n+        api.content.transition(self.events, to_state=\'published\')\n+        api.content.transition(self.blog, to_state=\'published\')\n+        self.assertEqual(len(api.relation.get(relationship=\'link\')), 3)\n+\n+        # Switch user\n+        api.user.create(email=\'bob@plone.org\', username=\'bob\')\n+        setRoles(self.portal, \'bob\', [\'Member\'])\n+        logout()\n+        login(self.portal, \'bob\')\n+\n+        self.assertEqual(len(api.relation.get(relationship=\'link\')), 2)\n+        self.assertEqual(len(api.relation.get(relationship=\'link\', unrestricted=True)), 3)\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T20:04:48+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.api/commit/bdf9666b0468bdfca2c75ce4addceaecc71cbc53

Remove RelationValues from content objects

Files changed:
M src/plone/api/relation.py

b'diff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex 680f69f..c9be550 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -151,14 +151,9 @@ def create(source=None, target=None, relationship=None):\n     )\n \n \n-@at_least_one_of(\'source\', \'target\', \'relationship\', \'delete_all\')\n-def delete(source=None, target=None, relationship=None, delete_all=False):\n+@at_least_one_of(\'source\', \'target\', \'relationship\')\n+def delete(source=None, target=None, relationship=None):\n     """Delete relation or relations.\n-\n-    If you specify \'delete_all=True\' and none of the other parameters,\n-    we delete all relations.\n-\n-    TODO: do we want to remove RelationValues from content objects?\n     """\n     if source is not None and not base_hasattr(source, \'portal_type\'):\n         raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n@@ -172,11 +167,6 @@ def delete(source=None, target=None, relationship=None, delete_all=False):\n     ):\n         raise InvalidParameterError(\'{} is no string\'.format(relationship))\n \n-    if delete_all and (source or target or relationship is not None):\n-        raise InvalidParameterError(\n-            \'When you use delete_all, you must not use any other parameters.\',\n-        )\n-\n     query = {}\n     relation_catalog = getUtility(ICatalog)\n     intids = getUtility(IIntIds)\n@@ -186,13 +176,45 @@ def delete(source=None, target=None, relationship=None, delete_all=False):\n         query[\'to_id\'] = intids.getId(target)\n     if relationship is not None:\n         query[\'from_attribute\'] = relationship\n-    if not query:\n-        relation_catalog.clear()\n-        return\n     for rel in relation_catalog.findRelations(query):\n+        source = rel.from_object\n+        from_attribute = rel.from_attribute\n+        field_and_schema = _get_field_and_schema_for_fieldname(\n+            from_attribute,\n+            source.portal_type,\n+        )\n+        if field_and_schema is None:\n+            # The relationship is not the name of a dexterity field.\n+            # Only purge relation from relation-catalog.\n+            relation_catalog.unindex(rel)\n+            return\n+\n+        target = rel.to_object\n+        field, _schema = field_and_schema\n+        if isinstance(field, RelationList):\n+            logger.info(\n+                \'Remove relation from %s to %s from relationlist %s\',\n+                source.absolute_url(),\n+                target.absolute_url(),\n+                from_attribute,\n+            )\n+            existing = getattr(source, from_attribute, [])\n+            updated_relations = [i for i in existing if i.to_object != target]\n+            setattr(source, from_attribute, updated_relations)\n+            modified(source)\n+\n+        elif isinstance(field, (Relation, RelationChoice)):\n+            logger.info(\n+                \'Remove relation %s from %s to %s\',\n+                from_attribute,\n+                source.absolute_url(),\n+                target.absolute_url(),\n+            )\n+            delattr(source, from_attribute)\n+            modified(source)\n+        # unindex in case something went wrong with the automatic unindex\n         relation_catalog.unindex(rel)\n \n-\n @at_least_one_of(\'source\', \'target\', \'relationship\')\n def get(\n     source=None,\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-22T20:05:36+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.api/commit/ecdb62c77e99a661efcf8be88b64d763fae13739

test deleting relations

Files changed:
M src/plone/api/tests/test_relation.py

b'diff --git a/src/plone/api/tests/test_relation.py b/src/plone/api/tests/test_relation.py\nindex 9d48fcf..16c9257 100644\n--- a/src/plone/api/tests/test_relation.py\n+++ b/src/plone/api/tests/test_relation.py\n@@ -6,6 +6,8 @@\n from plone.app.testing import logout\n from plone.app.testing import setRoles\n from z3c.relationfield import RelationValue\n+from zc.relation.interfaces import ICatalog\n+from zope.component import getUtility\n \n import unittest\n \n@@ -163,6 +165,27 @@ def test_create_relation(self):\n         self.assertEqual(relation.from_object, self.about)\n         self.assertEqual(relation.to_object, self.blog)\n \n+        # create relation that uses a field\n+        self.assertEqual(self.about.relatedItems, [])\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'relatedItems\',\n+        )\n+        self.assertEqual(len(self.about.relatedItems), 1)\n+        self.assertIsInstance(self.about.relatedItems[0], RelationValue)\n+\n+        # create relation with a fieldname that is no relationfield\n+        self.assertEqual(self.about.description, \'\')\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'description\',\n+        )\n+        self.assertEqual(self.about.description, \'\')\n+        self.assertEqual(len(api.relation.get(source=self.about, target=self.blog)), 3)\n+\n+\n     def test_delete_constraints(self):\n         """Test the constraints when deleting relations."""\n         from plone.api.exc import InvalidParameterError\n@@ -199,6 +222,80 @@ def test_delete_relation(self):\n         )\n         self.assertEqual(len(relations), 0)\n \n+    def test_delete_fieldrelation(self):\n+        """Test deleting a relation that uses a relationlistfield."""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'relatedItems\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 2)\n+        self.assertIsInstance(self.about.relatedItems[0], RelationValue)\n+\n+        api.relation.delete(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'relatedItems\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 1)\n+        self.assertEqual(len(self.about.relatedItems), 0)\n+\n+    def test_delete_one_fieldrelation(self):\n+        """Test deleting a relation from a relationlistfield retains the others."""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'relatedItems\',\n+        )\n+        api.relation.create(\n+            source=self.about,\n+            target=self.events,\n+            relationship=\'relatedItems\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 3)\n+        self.assertIsInstance(self.about.relatedItems[0], RelationValue)\n+\n+        api.relation.delete(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'relatedItems\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 2)\n+        self.assertEqual(len(self.about.relatedItems), 1)\n+\n+    def test_deleted_relation_is_purged(self):\n+        """Test that relations that have the name of a non-relation-field are purged."""\n+        relation_catalog = getUtility(ICatalog)\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'description\',\n+        )\n+        self.assertEqual(self.about.description, \'\')\n+        self.assertEqual(len(api.relation.get(source=self.about)), 1)\n+        rels = relation_catalog.findRelations({\'from_attribute\': \'description\'})\n+        self.assertEqual(len([i for i in rels]), 1)\n+\n+        api.relation.delete(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'description\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 0)\n+        self.assertEqual(self.about.description, \'\')\n+        rels = relation_catalog.findRelations({\'from_attribute\': \'description\'})\n+        self.assertEqual(len([i for i in rels]), 0)\n+\n     def test_get_constraints(self):\n         """Test the constraints when getting relations."""\n         from plone.api.exc import InvalidParameterError\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-24T12:19:33+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.api/commit/32f41ead8370d5356f8b6857b499f07e7c73e7b1

Update docs, docstrings and auto-docs. Move get to top (because get is used most frequently)

Files changed:
A docs/api/relation.rst
M docs/api/index.rst
M docs/relation.rst
M src/plone/api/relation.py

b'diff --git a/docs/api/index.rst b/docs/api/index.rst\nindex 28d1fdf..2c70040 100644\n--- a/docs/api/index.rst\n+++ b/docs/api/index.rst\n@@ -85,6 +85,16 @@ api.env\n     api.env.test_mode\n \n \n+api.relation\n+---------\n+\n+.. autosummary::\n+\n+    api.relation.get\n+    api.relation.create\n+    api.relation.delete\n+\n+\n Exceptions and errors\n ---------------------\n \ndiff --git a/docs/api/relation.rst b/docs/api/relation.rst\nnew file mode 100644\nindex 0000000..0cd0e1b\n--- /dev/null\n+++ b/docs/api/relation.rst\n@@ -0,0 +1,14 @@\n+.. admonition:: GitHub-only\n+\n+    WARNING: If you are reading this on GitHub, DON\'T!\n+    Read the documentation at `docs.plone.org <http://docs.plone.org/develop/plone.api/docs/api/relation.html>`_\n+    so you have working references and proper formatting.\n+\n+\n+.. _plone-api-user:\n+\n+plone.api.user\n+==============\n+\n+.. automodule:: plone.api.relation\n+    :members:\ndiff --git a/docs/relation.rst b/docs/relation.rst\nindex bdbe3e6..56a5cc1 100644\n--- a/docs/relation.rst\n+++ b/docs/relation.rst\n@@ -13,7 +13,42 @@\n Relations\n =========\n \n-To use the relations code, you should include `plone.api[relations]` in the dependencies of your project.\n+\n+.. _relation_get_example:\n+\n+Get relations\n+=============\n+\n+.. code-block:: python\n+\n+    api.relation.get(source=source, target=target, relationship="friend", unrestricted=False, as_dict=False)\n+\n+You must provide either source, target or relationship, or a combination of those.\n+``unrestricted`` and ``as_dict`` are optional.\n+\n+By default the result is a list of ``RelationValue`` objects.\n+\n+If you set ``as_dict=True`` it will return a dictionary with the names of the relations as keys and lists of objects as values.\n+\n+By default the View permission is checked on the relation objects.\n+You only get objects that you are allowed to see.\n+Use the ``unrestricted`` parameter if you want to bypass this check.\n+\n+To get back relations, so relations pointing to an item, use:\n+\n+.. code-block:: python\n+\n+    api.relation.get(target=target)\n+\n+To get the objects connected by relations you can use the api of these return values:\n+\n+.. code-block:: python\n+\n+    for relation in api.relation.get(source=source):\n+        source = relation.from_object\n+        target = relation.to_object\n+        relationship = relation.from_attribute\n+\n \n .. _relation_create_example:\n \n@@ -31,22 +66,21 @@ To create a relation between source object and target object, use :meth:`api.rel\n     target = portal.bobby\n     api.relation.create(source=source, target=target, relationship="friend")\n \n-Delete relation\n-===============\n+If the relation is based on a ``RelationChoice`` or ``RelationList`` field on the source object, the value of that field is created/updated accordingly.\n \n-Delete one specific relationship:\n \n-.. code-block:: python\n+.. _relation_delete_example:\n \n-    api.relation.delete(source=source, target=target, relationship="friend")\n+Delete relation\n+===============\n \n-You can delete all relations by explicitly asking:\n+Delete one or more relations:\n \n .. code-block:: python\n \n-    api.relation.delete(delete_all=True)\n+    api.relation.delete(source=source, target=target, relationship="friend")\n \n-In all other cases, in order to delete relation(s), you must provide either ``source``, ``target`` or ``relationship``.\n+In order to delete relation(s), you must provide either ``source``, ``target`` or ``relationship``.\n You can mix and match.\n \n Delete all relations from source to any target:\n@@ -79,31 +113,11 @@ Delete relations with name "enemy" from any source to any target:\n \n     api.relation.delete(relationship="enemy")\n \n-Get relations\n-=============\n-\n-.. code-block:: python\n-\n-    api.relation.get(source=source, target=target, relationship="friend", unrestricted=False, as_dict=False)\n-\n-You must provide either source, target or relationship, or a combination of those.\n-``unrestricted`` and ``as_dict`` are optional.\n-\n-By default the result is a list of objects.\n-If you set ``as_dict=True`` it will return a dictionary with the names of the relations as keys and lists of objects as values.\n-\n-By default the View permission is checked on the relation objects.\n-You only get objects that you are allowed to see.\n-Use the ``unrestricted`` parameter if you want to bypass this check.\n-\n-To get back relations, so relations pointing to an item, use:\n-\n-.. code-block:: python\n-\n-    api.relation.get(target=target)\n+If a deleted relation is based on a ``RelationChoice`` or ``RelationList`` field on the source object, the value of the field is removed/updated accordingly.\n \n \n Further reading\n ===============\n \n For more information on possible flags and usage options please see the full :ref:`plone-api-relation` specification.\n+For more information on relations read the relevant `chapter in the Mastering Plone training <https://training.plone.org/5/mastering-plone/relations.html>`_.\ndiff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nindex c9be550..a34c0ad 100644\n--- a/src/plone/api/relation.py\n+++ b/src/plone/api/relation.py\n@@ -39,17 +39,104 @@ def _get_field_and_schema_for_fieldname(field_id, portal_type):\n             return (field, schema)\n \n \n+@at_least_one_of(\'source\', \'target\', \'relationship\')\n+def get(\n+    source=None,\n+    target=None,\n+    relationship=None,\n+    unrestricted=False,\n+    as_dict=False,\n+):\n+    """Get specific relations given a source/target/relationship\n+\n+    :param source: Object that the relations originate from.\n+    :type source: Content object\n+    :param target: Object that the relations point to.\n+    :type target: Content object\n+    :param relationship: Relationship name.\n+    :type id: string\n+    :param unrestricted: If true bypass permission-check on source and target.\n+    :type id: boolean\n+    :param as_dict: If true, return a dictionary with the relationship\n+        name as keys.\n+    :type id: bool\n+    :returns: A list of relations\n+    :rtype: List of RelationValue objects\n+\n+    :Example: :ref:`relation_get_example`\n+    """\n+    if source is not None and not base_hasattr(source, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n+\n+    if target is not None and not base_hasattr(target, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n+\n+    if relationship is not None and not isinstance(\n+        relationship,\n+        str,\n+    ):\n+        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n+\n+    intids = getUtility(IIntIds)\n+    relation_catalog = getUtility(ICatalog)\n+    query = {}\n+    results = []\n+\n+    if as_dict:\n+        results = defaultdict(list)\n+\n+    if not relation_catalog:\n+        return results\n+\n+    if not unrestricted:\n+        checkPermission = getSecurityManager().checkPermission\n+\n+    if source is not None:\n+        query[\'from_id\'] = intids.getId(source)\n+    if target is not None:\n+        query[\'to_id\'] = intids.getId(target)\n+    if relationship is not None:\n+        query[\'from_attribute\'] = relationship\n+\n+    for relation in relation_catalog.findRelations(query):\n+        if relation.isBroken():\n+            continue\n+\n+        if not unrestricted:\n+            source_obj = relation.from_object\n+            target_obj = relation.to_object\n+\n+            if checkPermission(\'View\', source_obj) and checkPermission(\n+                \'View\',\n+                target_obj,\n+            ):\n+                if as_dict:\n+                    results[relation.from_attribute].append(relation)\n+                else:\n+                    results.append(relation)\n+            else:\n+                continue\n+        else:\n+            if as_dict:\n+                results[relation.from_attribute].append(relation)\n+            else:\n+                results.append(relation)\n+    return results\n+\n+\n @required_parameters(\'source\', \'target\', \'relationship\')\n def create(source=None, target=None, relationship=None):\n     """Create a relation from source to target using zc.relation\n \n-    If source is dexterity content, and the relationship name is the same\n-    as a field name, and this field is a RelationChoice/RelationList/Relation,\n-    we will add the relation as attribute.\n-\n-    Other relations will only be added to the relation-catalog.\n-\n-    Adapted from collective.relationhelpers link_objects.\n+    :param source: [required] Object that the relation will originate from.\n+    :type source: Content object\n+    :param target: [required] Object that the relation will point to.\n+    :type target: Content object\n+    :param relationship: [required] Relationship name. If that name is the same\n+    as a field name and this field is a RelationChoice/RelationList we will\n+    update the field-value accordingly.\n+    :type id: string\n+    :Example: :ref:`relation_create_example`\n     """\n     if source is not None and not base_hasattr(source, \'portal_type\'):\n         raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n@@ -154,6 +241,16 @@ def create(source=None, target=None, relationship=None):\n @at_least_one_of(\'source\', \'target\', \'relationship\')\n def delete(source=None, target=None, relationship=None):\n     """Delete relation or relations.\n+\n+    :param source: Object that the relation originates from.\n+    :type source: Content object\n+    :param target: Object that the relation points to.\n+    :type target: Content object\n+    :param relationship: Relationship name. If that name is the same\n+        as a field name and this field is a RelationChoice/RelationList we\n+        will delete/update the field-value accordingly.\n+    :type id: string\n+    :Example: :ref:`relation_delete_example`\n     """\n     if source is not None and not base_hasattr(source, \'portal_type\'):\n         raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n@@ -214,73 +311,3 @@ def delete(source=None, target=None, relationship=None):\n             modified(source)\n         # unindex in case something went wrong with the automatic unindex\n         relation_catalog.unindex(rel)\n-\n-@at_least_one_of(\'source\', \'target\', \'relationship\')\n-def get(\n-    source=None,\n-    target=None,\n-    relationship=None,\n-    unrestricted=False,\n-    as_dict=False,\n-):\n-    """Get specific relations given a source/target/relationship\n-\n-    Copied and modified from collective.relationhelpers get_relations.\n-    """\n-    if source is not None and not base_hasattr(source, \'portal_type\'):\n-        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n-\n-    if target is not None and not base_hasattr(target, \'portal_type\'):\n-        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n-\n-    if relationship is not None and not isinstance(\n-        relationship,\n-        str,\n-    ):\n-        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n-\n-    intids = getUtility(IIntIds)\n-    relation_catalog = getUtility(ICatalog)\n-    query = {}\n-    results = []\n-\n-    if as_dict:\n-        results = defaultdict(list)\n-\n-    if not relation_catalog:\n-        return results\n-\n-    if not unrestricted:\n-        checkPermission = getSecurityManager().checkPermission\n-\n-    if source is not None:\n-        query[\'from_id\'] = intids.getId(source)\n-    if target is not None:\n-        query[\'to_id\'] = intids.getId(target)\n-    if relationship is not None:\n-        query[\'from_attribute\'] = relationship\n-\n-    for relation in relation_catalog.findRelations(query):\n-        if relation.isBroken():\n-            continue\n-\n-        if not unrestricted:\n-            source_obj = relation.from_object\n-            target_obj = relation.to_object\n-\n-            if checkPermission(\'View\', source_obj) and checkPermission(\n-                \'View\',\n-                target_obj,\n-            ):\n-                if as_dict:\n-                    results[relation.from_attribute].append(relation)\n-                else:\n-                    results.append(relation)\n-            else:\n-                continue\n-        else:\n-            if as_dict:\n-                results[relation.from_attribute].append(relation)\n-            else:\n-                results.append(relation)\n-    return results\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-30T09:02:42+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.api/commit/5d84e93b8d38b15a939ee194b12d847947229d06

Merge remote-tracking branch 'origin/master' into relation

Files changed:
M setup.py
M src/plone/api/tests/test_content.py
M src/plone/api/tests/test_group.py
M src/plone/api/tests/test_portal.py

b'diff --git a/setup.py b/setup.py\nindex 02acd7d..171b1ea 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -43,7 +43,6 @@ def read(*rnames):\n         \'test\': [\n             \'Products.CMFPlone\',\n             \'manuel\',\n-            \'mock\',\n             \'plone.app.dexterity\',\n             \'plone.app.intid\',\n             \'plone.app.testing\',\ndiff --git a/src/plone/api/tests/test_content.py b/src/plone/api/tests/test_content.py\nindex abd0ae6..6c0c092 100644\n--- a/src/plone/api/tests/test_content.py\n+++ b/src/plone/api/tests/test_content.py\n@@ -17,6 +17,7 @@\n from Products.CMFCore.interfaces import IContentish\n from Products.CMFCore.WorkflowCore import WorkflowException\n from Products.ZCatalog.interfaces import IZCatalog\n+from unittest import mock\n from zExceptions import BadRequest\n from zope.component import getGlobalSiteManager\n from zope.component import getUtility\n@@ -27,7 +28,6 @@\n from zope.lifecycleevent import modified\n from zope.lifecycleevent import ObjectMovedEvent\n \n-from unittest import mock\n import pkg_resources\n import unittest\n \n@@ -410,6 +410,25 @@ def test_create_collection(self):\n         )\n         self.assertEqual(collection.Title(), \'Mandelbrot set\')\n \n+    def test_create_event(self):\n+        """Test create a event."""\n+        import datetime\n+        today = datetime.datetime.now()\n+        tomorrow = today + datetime.timedelta(days=1)\n+        event = api.content.create(\n+            container=self.portal,\n+            type=\'Event\',\n+            title=\'My event\',\n+            start=today,\n+            end=tomorrow,\n+        )\n+        self.assertEqual(event.start, today)\n+        self.assertEqual(event.end, tomorrow)\n+        results = api.content.find(Title=\'My event\')\n+        self.assertEqual(len(results), 1)\n+        self.assertEqual(results[0].start, today)\n+        self.assertEqual(results[0].end, tomorrow)\n+\n     def test_get_constraints(self):\n         """Test the constraints when content is fetched with get."""\n \ndiff --git a/src/plone/api/tests/test_group.py b/src/plone/api/tests/test_group.py\nindex ca4c8f2..4ef54ae 100644\n--- a/src/plone/api/tests/test_group.py\n+++ b/src/plone/api/tests/test_group.py\n@@ -4,13 +4,13 @@\n from plone import api\n from plone.api.tests.base import INTEGRATION_TESTING\n from Products.CMFCore.utils import getToolByName\n+from unittest import mock\n from zope.component import adapter\n from zope.component import getGlobalSiteManager\n from zope.component import provideAdapter\n from zope.interface import implementer\n from zope.interface import Interface\n \n-from unittest import mock\n import unittest\n \n \ndiff --git a/src/plone/api/tests/test_portal.py b/src/plone/api/tests/test_portal.py\nindex b264852..998aeed 100644\n--- a/src/plone/api/tests/test_portal.py\n+++ b/src/plone/api/tests/test_portal.py\n@@ -14,6 +14,7 @@\n from Products.CMFCore.utils import getToolByName\n from Products.CMFPlone.tests.utils import MockMailHost\n from Products.MailHost.interfaces import IMailHost\n+from unittest import mock\n from zope import schema\n from zope.component import getUtility\n from zope.component.hooks import setSite\n@@ -21,7 +22,6 @@\n from zope.site import LocalSiteManager\n \n import DateTime\n-from unittest import mock\n import unittest\n \n \n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-30T09:04:05+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.api/commit/7a478dc0e763a974f96817e75122afeb7ec27621

Fix copy/paste error

Files changed:
M docs/api/relation.rst

b'diff --git a/docs/api/relation.rst b/docs/api/relation.rst\nindex 0cd0e1b..9769464 100644\n--- a/docs/api/relation.rst\n+++ b/docs/api/relation.rst\n@@ -5,10 +5,10 @@\n     so you have working references and proper formatting.\n \n \n-.. _plone-api-user:\n+.. _plone-api-relation:\n \n-plone.api.user\n-==============\n+plone.api.relation\n+==================\n \n .. automodule:: plone.api.relation\n     :members:\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-30T09:07:40+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.api/commit/ac7116edef0f040f36812c6edc5d100d4ff42fab

Changelog

Files changed:
A news/449.feature

b'diff --git a/news/449.feature b/news/449.feature\nnew file mode 100644\nindex 0000000..b7dead3\n--- /dev/null\n+++ b/news/449.feature\n@@ -0,0 +1,2 @@\n+There is now a ``plone.api.relation`` module that make it easier to work with relations.\n+[pbauer]\n'

Repository: plone.api


Branch: refs/heads/master
Date: 2021-08-30T20:19:03+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.api/commit/623de8d057558fccdc8fd2cb53438bb4e900193d

Merge pull request #449 from plone/relation

Add module to handle relations

Files changed:
A docs/api/relation.rst
A docs/relation.rst
A news/449.feature
A src/plone/api/relation.py
A src/plone/api/tests/test_relation.py
M docs/api/index.rst
M setup.py
M src/plone/api/__init__.py
M src/plone/api/profiles/testfixture/metadata.xml

b'diff --git a/docs/api/index.rst b/docs/api/index.rst\nindex 28d1fdf..2c70040 100644\n--- a/docs/api/index.rst\n+++ b/docs/api/index.rst\n@@ -85,6 +85,16 @@ api.env\n     api.env.test_mode\n \n \n+api.relation\n+---------\n+\n+.. autosummary::\n+\n+    api.relation.get\n+    api.relation.create\n+    api.relation.delete\n+\n+\n Exceptions and errors\n ---------------------\n \ndiff --git a/docs/api/relation.rst b/docs/api/relation.rst\nnew file mode 100644\nindex 0000000..9769464\n--- /dev/null\n+++ b/docs/api/relation.rst\n@@ -0,0 +1,14 @@\n+.. admonition:: GitHub-only\n+\n+    WARNING: If you are reading this on GitHub, DON\'T!\n+    Read the documentation at `docs.plone.org <http://docs.plone.org/develop/plone.api/docs/api/relation.html>`_\n+    so you have working references and proper formatting.\n+\n+\n+.. _plone-api-relation:\n+\n+plone.api.relation\n+==================\n+\n+.. automodule:: plone.api.relation\n+    :members:\ndiff --git a/docs/relation.rst b/docs/relation.rst\nnew file mode 100644\nindex 0000000..56a5cc1\n--- /dev/null\n+++ b/docs/relation.rst\n@@ -0,0 +1,123 @@\n+.. admonition:: GitHub-only\n+\n+    WARNING: If you are reading this on GitHub, DON\'T!\n+    Read the documentation at `docs.plone.org <http://docs.plone.org/develop/plone.api/docs/env.html>`_\n+    so you have working references and proper formatting.\n+\n+\n+.. module:: plone\n+\n+.. _chapter_relation:\n+\n+=========\n+Relations\n+=========\n+\n+\n+.. _relation_get_example:\n+\n+Get relations\n+=============\n+\n+.. code-block:: python\n+\n+    api.relation.get(source=source, target=target, relationship="friend", unrestricted=False, as_dict=False)\n+\n+You must provide either source, target or relationship, or a combination of those.\n+``unrestricted`` and ``as_dict`` are optional.\n+\n+By default the result is a list of ``RelationValue`` objects.\n+\n+If you set ``as_dict=True`` it will return a dictionary with the names of the relations as keys and lists of objects as values.\n+\n+By default the View permission is checked on the relation objects.\n+You only get objects that you are allowed to see.\n+Use the ``unrestricted`` parameter if you want to bypass this check.\n+\n+To get back relations, so relations pointing to an item, use:\n+\n+.. code-block:: python\n+\n+    api.relation.get(target=target)\n+\n+To get the objects connected by relations you can use the api of these return values:\n+\n+.. code-block:: python\n+\n+    for relation in api.relation.get(source=source):\n+        source = relation.from_object\n+        target = relation.to_object\n+        relationship = relation.from_attribute\n+\n+\n+.. _relation_create_example:\n+\n+Create relation\n+===============\n+\n+To create a relation between source object and target object, use :meth:`api.relation.create`.\n+\n+.. code-block:: python\n+\n+    from plone import api\n+\n+    portal = api.portal.get()\n+    source = portal.bob\n+    target = portal.bobby\n+    api.relation.create(source=source, target=target, relationship="friend")\n+\n+If the relation is based on a ``RelationChoice`` or ``RelationList`` field on the source object, the value of that field is created/updated accordingly.\n+\n+\n+.. _relation_delete_example:\n+\n+Delete relation\n+===============\n+\n+Delete one or more relations:\n+\n+.. code-block:: python\n+\n+    api.relation.delete(source=source, target=target, relationship="friend")\n+\n+In order to delete relation(s), you must provide either ``source``, ``target`` or ``relationship``.\n+You can mix and match.\n+\n+Delete all relations from source to any target:\n+\n+.. code-block:: python\n+\n+    api.relation.delete(source=source)\n+\n+Delete all relations from any source to this target:\n+\n+.. code-block:: python\n+\n+    api.relation.delete(target=target)\n+\n+Delete relations with name "friend" from source to any target:\n+\n+.. code-block:: python\n+\n+    api.relation.delete(source=source, relationship="friend")\n+\n+Delete relations with name "uncle" from any source to this target:\n+\n+.. code-block:: python\n+\n+    api.relation.delete(target=target, relationship="uncle")\n+\n+Delete relations with name "enemy" from any source to any target:\n+\n+.. code-block:: python\n+\n+    api.relation.delete(relationship="enemy")\n+\n+If a deleted relation is based on a ``RelationChoice`` or ``RelationList`` field on the source object, the value of the field is removed/updated accordingly.\n+\n+\n+Further reading\n+===============\n+\n+For more information on possible flags and usage options please see the full :ref:`plone-api-relation` specification.\n+For more information on relations read the relevant `chapter in the Mastering Plone training <https://training.plone.org/5/mastering-plone/relations.html>`_.\ndiff --git a/news/449.feature b/news/449.feature\nnew file mode 100644\nindex 0000000..b7dead3\n--- /dev/null\n+++ b/news/449.feature\n@@ -0,0 +1,2 @@\n+There is now a ``plone.api.relation`` module that make it easier to work with relations.\n+[pbauer]\ndiff --git a/setup.py b/setup.py\nindex e28576e..171b1ea 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -44,9 +44,11 @@ def read(*rnames):\n             \'Products.CMFPlone\',\n             \'manuel\',\n             \'plone.app.dexterity\',\n+            \'plone.app.intid\',\n             \'plone.app.testing\',\n             \'plone.indexer\',\n             \'plone.registry\',\n+            \'z3c.relationfield\',\n         ],\n     },\n     classifiers=[\ndiff --git a/src/plone/api/__init__.py b/src/plone/api/__init__.py\nindex 59d677c..fc65182 100644\n--- a/src/plone/api/__init__.py\n+++ b/src/plone/api/__init__.py\n@@ -4,4 +4,5 @@\n from plone.api import env\n from plone.api import group\n from plone.api import portal\n+from plone.api import relation\n from plone.api import user\ndiff --git a/src/plone/api/profiles/testfixture/metadata.xml b/src/plone/api/profiles/testfixture/metadata.xml\nindex 7030086..9f02b5e 100644\n--- a/src/plone/api/profiles/testfixture/metadata.xml\n+++ b/src/plone/api/profiles/testfixture/metadata.xml\n@@ -3,5 +3,6 @@\n   <version>1</version>\n   <dependencies>\n     <dependency>profile-plone.app.dexterity:default</dependency>\n+    <dependency>profile-plone.app.intid:default</dependency>\n   </dependencies>\n </metadata>\ndiff --git a/src/plone/api/relation.py b/src/plone/api/relation.py\nnew file mode 100644\nindex 0000000..a34c0ad\n--- /dev/null\n+++ b/src/plone/api/relation.py\n@@ -0,0 +1,313 @@\n+"""Module that provides functionality for relations.\n+\n+Heavily inspired by collective.relationhelpers.\n+"""\n+from AccessControl.SecurityManagement import getSecurityManager\n+from collections import defaultdict\n+from plone.api.exc import InvalidParameterError\n+from plone.api.validation import at_least_one_of\n+from plone.api.validation import required_parameters\n+from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n+from plone.app.iterate.dexterity.relation import StagingRelationValue\n+from plone.app.linkintegrity.handlers import modifiedContent\n+from plone.app.linkintegrity.utils import referencedRelationship\n+from plone.dexterity.utils import iterSchemataForType\n+from Products.CMFPlone.utils import base_hasattr\n+from z3c.relationfield import event\n+from z3c.relationfield import RelationValue\n+from z3c.relationfield.schema import Relation\n+from z3c.relationfield.schema import RelationChoice\n+from z3c.relationfield.schema import RelationList\n+from zc.relation.interfaces import ICatalog\n+from zope.component import getUtility\n+from zope.intid.interfaces import IIntIds\n+from zope.lifecycleevent import modified\n+\n+import logging\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+def _get_field_and_schema_for_fieldname(field_id, portal_type):\n+    """Get field and its schema from a portal_type."""\n+    # Turn form.widgets.IDublinCore.title into title\n+    field_id = field_id.split(\'.\')[-1]\n+    for schema in iterSchemataForType(portal_type):\n+        field = schema.get(field_id, None)\n+        if field is not None:\n+            return (field, schema)\n+\n+\n+@at_least_one_of(\'source\', \'target\', \'relationship\')\n+def get(\n+    source=None,\n+    target=None,\n+    relationship=None,\n+    unrestricted=False,\n+    as_dict=False,\n+):\n+    """Get specific relations given a source/target/relationship\n+\n+    :param source: Object that the relations originate from.\n+    :type source: Content object\n+    :param target: Object that the relations point to.\n+    :type target: Content object\n+    :param relationship: Relationship name.\n+    :type id: string\n+    :param unrestricted: If true bypass permission-check on source and target.\n+    :type id: boolean\n+    :param as_dict: If true, return a dictionary with the relationship\n+        name as keys.\n+    :type id: bool\n+    :returns: A list of relations\n+    :rtype: List of RelationValue objects\n+\n+    :Example: :ref:`relation_get_example`\n+    """\n+    if source is not None and not base_hasattr(source, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n+\n+    if target is not None and not base_hasattr(target, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n+\n+    if relationship is not None and not isinstance(\n+        relationship,\n+        str,\n+    ):\n+        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n+\n+    intids = getUtility(IIntIds)\n+    relation_catalog = getUtility(ICatalog)\n+    query = {}\n+    results = []\n+\n+    if as_dict:\n+        results = defaultdict(list)\n+\n+    if not relation_catalog:\n+        return results\n+\n+    if not unrestricted:\n+        checkPermission = getSecurityManager().checkPermission\n+\n+    if source is not None:\n+        query[\'from_id\'] = intids.getId(source)\n+    if target is not None:\n+        query[\'to_id\'] = intids.getId(target)\n+    if relationship is not None:\n+        query[\'from_attribute\'] = relationship\n+\n+    for relation in relation_catalog.findRelations(query):\n+        if relation.isBroken():\n+            continue\n+\n+        if not unrestricted:\n+            source_obj = relation.from_object\n+            target_obj = relation.to_object\n+\n+            if checkPermission(\'View\', source_obj) and checkPermission(\n+                \'View\',\n+                target_obj,\n+            ):\n+                if as_dict:\n+                    results[relation.from_attribute].append(relation)\n+                else:\n+                    results.append(relation)\n+            else:\n+                continue\n+        else:\n+            if as_dict:\n+                results[relation.from_attribute].append(relation)\n+            else:\n+                results.append(relation)\n+    return results\n+\n+\n+@required_parameters(\'source\', \'target\', \'relationship\')\n+def create(source=None, target=None, relationship=None):\n+    """Create a relation from source to target using zc.relation\n+\n+    :param source: [required] Object that the relation will originate from.\n+    :type source: Content object\n+    :param target: [required] Object that the relation will point to.\n+    :type target: Content object\n+    :param relationship: [required] Relationship name. If that name is the same\n+    as a field name and this field is a RelationChoice/RelationList we will\n+    update the field-value accordingly.\n+    :type id: string\n+    :Example: :ref:`relation_create_example`\n+    """\n+    if source is not None and not base_hasattr(source, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n+\n+    if target is not None and not base_hasattr(target, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n+\n+    if not isinstance(relationship, str):\n+        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n+\n+    relation_catalog = getUtility(ICatalog)\n+    intids = getUtility(IIntIds)\n+    to_id = intids.getId(target)\n+    from_id = intids.getId(source)\n+    from_attribute = relationship\n+\n+    # Check if there is exactly this relation.\n+    # If so remove it and create a fresh one.\n+    query = {\n+        \'from_attribute\': from_attribute,\n+        \'from_id\': from_id,\n+        \'to_id\': to_id,\n+    }\n+    for rel in relation_catalog.findRelations(query):\n+        relation_catalog.unindex(rel)\n+\n+    if from_attribute == referencedRelationship:\n+        # Don\'t mess with linkintegrity-relations!\n+        # Refresh them by triggering this subscriber.\n+        modifiedContent(source, None)\n+        return\n+\n+    if (\n+        ITERATE_RELATION_NAME is not None\n+        and from_attribute == ITERATE_RELATION_NAME\n+    ):\n+        # Iterate relations use a subclass of RelationValue\n+        relation = StagingRelationValue(to_id)\n+        event._setRelation(source, ITERATE_RELATION_NAME, relation)\n+        return\n+\n+    # This can only get a field from a dexterity item.\n+    field_and_schema = _get_field_and_schema_for_fieldname(\n+        from_attribute,\n+        source.portal_type,\n+    )\n+\n+    if field_and_schema is None:\n+        # The relationship is not the name of a dexterity field.\n+        # Only create a relation.\n+        logger.debug(\n+            \'No dexterity field. Setting relation %s from %s to %s\',\n+            source.absolute_url(),\n+            target.absolute_url(),\n+            relationship,\n+        )\n+        event._setRelation(source, from_attribute, RelationValue(to_id))\n+        return\n+\n+    field, _schema = field_and_schema\n+\n+    if isinstance(field, RelationList):\n+        logger.info(\n+            \'Add relation to relationlist %s from %s to %s\',\n+            from_attribute,\n+            source.absolute_url(),\n+            target.absolute_url(),\n+        )\n+        existing_relations = getattr(source, from_attribute, [])\n+        existing_relations.append(RelationValue(to_id))\n+        setattr(source, from_attribute, existing_relations)\n+        modified(source)\n+        return\n+\n+    elif isinstance(field, (Relation, RelationChoice)):\n+        logger.info(\n+            \'Add relation %s from %s to %s\',\n+            from_attribute,\n+            source.absolute_url(),\n+            target.absolute_url(),\n+        )\n+        setattr(source, from_attribute, RelationValue(to_id))\n+        modified(source)\n+        return\n+\n+    # If we end up here, someone is making a relationship that\n+    # has the same name as a non-relation field.\n+    # This can be harmless coincidence, and this could be an error,\n+    # indicating that the field is of the wrong type.\n+    # Let\'s create the relationship and log a warning.\n+    event._setRelation(source, from_attribute, RelationValue(to_id))\n+    logger.warning(\n+        \'Created relation %s on an item that has a field with the same name \'\n+        \'which is not a relation field. Is this what you wanted? \'\n+        \'Relation points from %s to %s\',\n+        from_attribute,\n+        source.absolute_url(),\n+        target.absolute_url(),\n+    )\n+\n+\n+@at_least_one_of(\'source\', \'target\', \'relationship\')\n+def delete(source=None, target=None, relationship=None):\n+    """Delete relation or relations.\n+\n+    :param source: Object that the relation originates from.\n+    :type source: Content object\n+    :param target: Object that the relation points to.\n+    :type target: Content object\n+    :param relationship: Relationship name. If that name is the same\n+        as a field name and this field is a RelationChoice/RelationList we\n+        will delete/update the field-value accordingly.\n+    :type id: string\n+    :Example: :ref:`relation_delete_example`\n+    """\n+    if source is not None and not base_hasattr(source, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(source))\n+\n+    if target is not None and not base_hasattr(target, \'portal_type\'):\n+        raise InvalidParameterError(\'{} has no portal_type\'.format(target))\n+\n+    if relationship is not None and not isinstance(\n+        relationship,\n+        str,\n+    ):\n+        raise InvalidParameterError(\'{} is no string\'.format(relationship))\n+\n+    query = {}\n+    relation_catalog = getUtility(ICatalog)\n+    intids = getUtility(IIntIds)\n+    if source is not None:\n+        query[\'from_id\'] = intids.getId(source)\n+    if target is not None:\n+        query[\'to_id\'] = intids.getId(target)\n+    if relationship is not None:\n+        query[\'from_attribute\'] = relationship\n+    for rel in relation_catalog.findRelations(query):\n+        source = rel.from_object\n+        from_attribute = rel.from_attribute\n+        field_and_schema = _get_field_and_schema_for_fieldname(\n+            from_attribute,\n+            source.portal_type,\n+        )\n+        if field_and_schema is None:\n+            # The relationship is not the name of a dexterity field.\n+            # Only purge relation from relation-catalog.\n+            relation_catalog.unindex(rel)\n+            return\n+\n+        target = rel.to_object\n+        field, _schema = field_and_schema\n+        if isinstance(field, RelationList):\n+            logger.info(\n+                \'Remove relation from %s to %s from relationlist %s\',\n+                source.absolute_url(),\n+                target.absolute_url(),\n+                from_attribute,\n+            )\n+            existing = getattr(source, from_attribute, [])\n+            updated_relations = [i for i in existing if i.to_object != target]\n+            setattr(source, from_attribute, updated_relations)\n+            modified(source)\n+\n+        elif isinstance(field, (Relation, RelationChoice)):\n+            logger.info(\n+                \'Remove relation %s from %s to %s\',\n+                from_attribute,\n+                source.absolute_url(),\n+                target.absolute_url(),\n+            )\n+            delattr(source, from_attribute)\n+            modified(source)\n+        # unindex in case something went wrong with the automatic unindex\n+        relation_catalog.unindex(rel)\ndiff --git a/src/plone/api/tests/test_relation.py b/src/plone/api/tests/test_relation.py\nnew file mode 100644\nindex 0000000..16c9257\n--- /dev/null\n+++ b/src/plone/api/tests/test_relation.py\n@@ -0,0 +1,423 @@\n+"""Tests for plone.api.content."""\n+\n+from plone import api\n+from plone.api.tests.base import INTEGRATION_TESTING\n+from plone.app.testing import login\n+from plone.app.testing import logout\n+from plone.app.testing import setRoles\n+from z3c.relationfield import RelationValue\n+from zc.relation.interfaces import ICatalog\n+from zope.component import getUtility\n+\n+import unittest\n+\n+\n+class TestPloneApiRelation(unittest.TestCase):\n+    """Unit tests for relations using plone.api"""\n+\n+    layer = INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        """Create a portal structure which we can test against.\n+\n+        Plone (portal root)\n+        |-- image\n+        |-- blog\n+        |-- about\n+        |   |-- team\n+        |   `-- contact\n+        `-- events\n+            |-- training\n+            |-- conference\n+            `-- sprint\n+\n+        This is copied from test_content.py.\n+        We may want to simplify.  But could be okay.\n+        """\n+        self.portal = self.layer[\'portal\']\n+\n+        self.blog = api.content.create(\n+            type=\'Link\',\n+            id=\'blog\',\n+            container=self.portal,\n+        )\n+        self.about = api.content.create(\n+            type=\'Folder\',\n+            id=\'about\',\n+            container=self.portal,\n+        )\n+        self.events = api.content.create(\n+            type=\'Folder\',\n+            id=\'events\',\n+            container=self.portal,\n+        )\n+\n+        self.team = api.content.create(\n+            container=self.about,\n+            type=\'Document\',\n+            id=\'team\',\n+        )\n+        self.contact = api.content.create(\n+            container=self.about,\n+            type=\'Document\',\n+            id=\'contact\',\n+        )\n+\n+        self.training = api.content.create(\n+            container=self.events,\n+            type=\'Event\',\n+            id=\'training\',\n+        )\n+        self.conference = api.content.create(\n+            container=self.events,\n+            type=\'Event\',\n+            id=\'conference\',\n+        )\n+        self.sprint = api.content.create(\n+            container=self.events,\n+            type=\'Event\',\n+            id=\'sprint\',\n+        )\n+\n+        self.image = api.content.create(\n+            container=self.portal,\n+            type=\'Image\',\n+            id=\'image\',\n+        )\n+\n+    def test_create_constraints(self):\n+        """Test the constraints when creating relations."""\n+        from plone.api.exc import InvalidParameterError\n+        from plone.api.exc import MissingParameterError\n+\n+        # This will definitely fail\n+        with self.assertRaises(MissingParameterError):\n+            api.relation.create()\n+\n+        # Check the constraints for the source parameter\n+        with self.assertRaises(MissingParameterError):\n+            api.relation.create(\n+                target=self.blog,\n+                relationship=\'link\',\n+            )\n+\n+        # Check the constraints for the target parameter\n+        with self.assertRaises(MissingParameterError):\n+            api.relation.create(\n+                source=self.about,\n+                relationship=\'link\',\n+            )\n+\n+        # Check the constraints for the relationship parameter\n+        with self.assertRaises(MissingParameterError):\n+            api.relation.create(\n+                source=self.about,\n+                target=self.blog,\n+            )\n+\n+        # We require a source with portal_type\n+        app = self.layer[\'app\']\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.create(\n+                source=app,\n+                target=self.blog,\n+                relationship=\'link\',\n+            )\n+\n+        # We require a target with portal_type\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.create(\n+                source=self.about,\n+                target=app,\n+                relationship=\'link\',\n+            )\n+\n+        # We require a string relationship\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.create(\n+                source=self.about,\n+                target=self.blog,\n+                relationship=42,\n+            )\n+\n+    def test_create_relation(self):\n+        """Test creating a relation."""\n+        # Check that there are no relations at first\n+        # for the two objects we will test.\n+        relations = api.relation.get(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        self.assertEqual(len(relations), 0)\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        relations = api.relation.get(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        self.assertEqual(len(relations), 1)\n+        relation = relations[0]\n+        self.assertEqual(relation.from_object, self.about)\n+        self.assertEqual(relation.to_object, self.blog)\n+\n+        # create relation that uses a field\n+        self.assertEqual(self.about.relatedItems, [])\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'relatedItems\',\n+        )\n+        self.assertEqual(len(self.about.relatedItems), 1)\n+        self.assertIsInstance(self.about.relatedItems[0], RelationValue)\n+\n+        # create relation with a fieldname that is no relationfield\n+        self.assertEqual(self.about.description, \'\')\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'description\',\n+        )\n+        self.assertEqual(self.about.description, \'\')\n+        self.assertEqual(len(api.relation.get(source=self.about, target=self.blog)), 3)\n+\n+\n+    def test_delete_constraints(self):\n+        """Test the constraints when deleting relations."""\n+        from plone.api.exc import InvalidParameterError\n+\n+        # If source is given, it must have a portal_type.\n+        app = self.layer[\'app\']\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.delete(source=app)\n+\n+        # If target is given, it must have a portal_type.\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.delete(target=app)\n+\n+        # If relationship is given, it must be a string.\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.delete(relationship=42)\n+\n+    def test_delete_relation(self):\n+        """Test deleting a relation."""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.delete(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        relations = api.relation.get(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        self.assertEqual(len(relations), 0)\n+\n+    def test_delete_fieldrelation(self):\n+        """Test deleting a relation that uses a relationlistfield."""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'relatedItems\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 2)\n+        self.assertIsInstance(self.about.relatedItems[0], RelationValue)\n+\n+        api.relation.delete(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'relatedItems\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 1)\n+        self.assertEqual(len(self.about.relatedItems), 0)\n+\n+    def test_delete_one_fieldrelation(self):\n+        """Test deleting a relation from a relationlistfield retains the others."""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'relatedItems\',\n+        )\n+        api.relation.create(\n+            source=self.about,\n+            target=self.events,\n+            relationship=\'relatedItems\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 3)\n+        self.assertIsInstance(self.about.relatedItems[0], RelationValue)\n+\n+        api.relation.delete(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'relatedItems\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 2)\n+        self.assertEqual(len(self.about.relatedItems), 1)\n+\n+    def test_deleted_relation_is_purged(self):\n+        """Test that relations that have the name of a non-relation-field are purged."""\n+        relation_catalog = getUtility(ICatalog)\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'description\',\n+        )\n+        self.assertEqual(self.about.description, \'\')\n+        self.assertEqual(len(api.relation.get(source=self.about)), 1)\n+        rels = relation_catalog.findRelations({\'from_attribute\': \'description\'})\n+        self.assertEqual(len([i for i in rels]), 1)\n+\n+        api.relation.delete(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'description\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 0)\n+        self.assertEqual(self.about.description, \'\')\n+        rels = relation_catalog.findRelations({\'from_attribute\': \'description\'})\n+        self.assertEqual(len([i for i in rels]), 0)\n+\n+    def test_get_constraints(self):\n+        """Test the constraints when getting relations."""\n+        from plone.api.exc import InvalidParameterError\n+\n+        # If source is given, it must have a portal_type.\n+        app = self.layer[\'app\']\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.get(source=app)\n+\n+        # If target is given, it must have a portal_type.\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.get(target=app)\n+\n+        # If relationship is given, it must be a string.\n+        with self.assertRaises(InvalidParameterError):\n+            api.relation.get(relationship=42)\n+\n+    def test_get_relation(self):\n+        """Test getting a relation."""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.events,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.about.team,\n+            target=self.events,\n+            relationship=\'team\',\n+        )\n+        api.relation.create(\n+            source=self.events,\n+            target=self.portal.image,\n+            relationship=\'link\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 1)\n+        self.assertIsInstance(api.relation.get(source=self.about), list)\n+        self.assertIsInstance(api.relation.get(source=self.about)[0], RelationValue)\n+\n+        self.assertEqual(len(api.relation.get(target=self.blog)), 2)\n+        self.assertEqual(len(api.relation.get(relationship=\'link\')), 3)\n+\n+        self.assertEqual(len(api.relation.get(source=self.about, relationship=\'link\')), 1)\n+        self.assertEqual(len(api.relation.get(source=self.about, target=self.events)), 0)\n+        self.assertEqual(len(api.relation.get(source=self.about, target=self.blog)), 1)\n+\n+        self.assertEqual(len(api.relation.get(source=self.events)), 2)\n+        self.assertEqual(len(api.relation.get(relationship=\'team\')), 1)\n+\n+    def test_get_relation_as_dict(self):\n+        """Test getting relations as dicts"""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.events,\n+            target=self.blog,\n+            relationship=\'bloglink\',\n+        )\n+        self.assertEqual(len(api.relation.get(relationship=\'link\', as_dict=True)[\'link\']), 1)\n+        rels = api.relation.get(target=self.blog, as_dict=True)\n+        self.assertEqual(len(rels[\'link\']), 1)\n+        self.assertEqual(len(rels[\'bloglink\']), 1)\n+\n+    def test_get_broken_relation(self):\n+        """Test that broken relations are ignored."""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.events,\n+            target=self.portal.image,\n+            relationship=\'link\',\n+        )\n+        self.assertEqual(len(api.relation.get(source=self.about)), 1)\n+        self.assertEqual(len(api.relation.get(relationship=\'link\')), 2)\n+\n+        # break a relation\n+        self.portal._delObject(\'blog\')\n+\n+        self.assertEqual(len(api.relation.get(source=self.about)), 0)\n+        self.assertEqual(len(api.relation.get(relationship=\'link\')), 1)\n+\n+    def test_restricted_relation(self):\n+        """Test that rels between inaccessible items are ignored."""\n+        api.relation.create(\n+            source=self.about,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.events,\n+            target=self.blog,\n+            relationship=\'link\',\n+        )\n+        api.relation.create(\n+            source=self.about.team,\n+            target=self.events,\n+            relationship=\'team\',\n+        )\n+        api.relation.create(\n+            source=self.events,\n+            target=self.portal.image,\n+            relationship=\'link\',\n+        )\n+        api.content.transition(self.events, to_state=\'published\')\n+        api.content.transition(self.blog, to_state=\'published\')\n+        self.assertEqual(len(api.relation.get(relationship=\'link\')), 3)\n+\n+        # Switch user\n+        api.user.create(email=\'bob@plone.org\', username=\'bob\')\n+        setRoles(self.portal, \'bob\', [\'Member\'])\n+        logout()\n+        login(self.portal, \'bob\')\n+\n+        self.assertEqual(len(api.relation.get(relationship=\'link\')), 2)\n+        self.assertEqual(len(api.relation.get(relationship=\'link\', unrestricted=True)), 3)\n'

