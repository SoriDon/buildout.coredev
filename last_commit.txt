Repository: plone.app.textfield


Branch: refs/heads/master
Date: 2018-05-09T09:15:14+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.textfield/commit/62b2ca04f9e957406bcb48b4046a069974bce3e9

fix transform for py3

Files changed:
M plone/app/textfield/transform.py

b"diff --git a/plone/app/textfield/transform.py b/plone/app/textfield/transform.py\nindex 5bbc1d6..771df3b 100644\n--- a/plone/app/textfield/transform.py\n+++ b/plone/app/textfield/transform.py\n@@ -7,6 +7,7 @@\n from zope.interface import implementer\n \n import logging\n+import six\n \n \n LOG = logging.getLogger('plone.app.textfield')\n@@ -60,7 +61,9 @@ def __call__(self, value, mimeType):\n \n             else:\n                 output = data.getData()\n-                return output.decode(value.encoding)\n+                if six.PY2:\n+                    return output.decode(value.encoding)\n+                return output\n         except ConflictError:\n             raise\n         except Exception as e:\n"

Repository: plone.app.textfield


Branch: refs/heads/master
Date: 2018-05-25T15:39:31+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.textfield/commit/cc4d28d0c4e153eb9e4ca84dc1ab695b7b412b8f

in py3 always output text and send text to transforms

Files changed:
M plone/app/textfield/transform.py
M plone/app/textfield/value.py

b'diff --git a/plone/app/textfield/transform.py b/plone/app/textfield/transform.py\nindex 771df3b..744f29f 100644\n--- a/plone/app/textfield/transform.py\n+++ b/plone/app/textfield/transform.py\n@@ -37,9 +37,15 @@ def __call__(self, value, mimeType):\n         if transforms is None:\n             raise TransformError("Cannot find portal_transforms tool")\n \n+        if six.PY2:\n+            # in Python 2 transforms expect str\n+            source_value = value.raw_encoded\n+        else:# in Python 3 we pass text\n+            source_value = value.raw\n+\n         try:\n             data = transforms.convertTo(mimeType,\n-                                        value.raw_encoded,\n+                                        source_value,\n                                         mimetype=value.mimeType,\n                                         context=self.context,\n                                         # portal_transforms caches on this\ndiff --git a/plone/app/textfield/value.py b/plone/app/textfield/value.py\nindex 80185ac..4c038fa 100644\n--- a/plone/app/textfield/value.py\n+++ b/plone/app/textfield/value.py\n@@ -7,6 +7,7 @@\n from zope.interface import implementer\n \n import logging\n+import six\n \n \n LOG = logging.getLogger(\'plone.app.textfield\')\n@@ -98,7 +99,10 @@ def output_relative_to(self, context):\n         transformer with the site as a context is used instead.\n         """\n         if self.mimeType == self.outputMimeType:\n-            return self.raw_encoded\n+            if six.PY2:\n+                return self.raw_encoded\n+            else:\n+                return self.raw\n \n         transformer = ITransformer(context, None)\n         if transformer is None:\n'

Repository: plone.app.textfield


Branch: refs/heads/master
Date: 2018-05-25T15:39:53+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.textfield/commit/d3834a05efdebfd28a093bcbc12ea016d90351f3

fix most tests in py3

Files changed:
M plone/app/textfield/field.rst
M plone/app/textfield/handler.rst
M plone/app/textfield/marshaler.py
M plone/app/textfield/marshaler.rst
M plone/app/textfield/tests.py

b'diff --git a/plone/app/textfield/field.rst b/plone/app/textfield/field.rst\nindex 9f6b5ef..d608170 100644\n--- a/plone/app/textfield/field.rst\n+++ b/plone/app/textfield/field.rst\n@@ -113,7 +113,7 @@ Or to get the value encoded:\n     >>> value.encoding\n     \'utf-8\'\n     >>> value.raw_encoded\n-    \'Some plain text\'\n+    b\'Some plain text\'\n \n Values are equal as long as they have the same `raw`, `mimeType`, `outputMimeType`,\n and `encoding`:\n@@ -153,7 +153,7 @@ default MIME types set on the field.\n     >>> value.raw\n     u\'A plain text string\'\n     >>> value.raw_encoded\n-    \'A plain text string\'\n+    b\'A plain text string\'\n     >>> value.output\n     u\'A PLAIN TEXT STRING\'\n \ndiff --git a/plone/app/textfield/handler.rst b/plone/app/textfield/handler.rst\nindex 144ddee..9725d5f 100644\n--- a/plone/app/textfield/handler.rst\n+++ b/plone/app/textfield/handler.rst\n@@ -23,7 +23,8 @@ First, let\'s wire up the package.\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> import six\n+    >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -48,7 +49,7 @@ Then, let\'s test the field\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, u\'dummy\', fieldType) #doctest: +ELLIPSIS\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="plone.app.textfield.RichText">\n       <allowed_mime_types>\n         <element>text/plain</element>\ndiff --git a/plone/app/textfield/marshaler.py b/plone/app/textfield/marshaler.py\nindex 8457035..ec00e21 100644\n--- a/plone/app/textfield/marshaler.py\n+++ b/plone/app/textfield/marshaler.py\n@@ -5,6 +5,8 @@\n from zope.component import adapter\n from zope.interface import Interface\n \n+import six\n+\n \n @adapter(Interface, IRichText)\n class RichTextFieldMarshaler(BaseFieldMarshaler):\n@@ -25,12 +27,11 @@ def decode(\n             charset=\'utf-8\',\n             contentType=None,\n             primary=False):\n-        try:\n-            unicode_value = value.decode(charset)\n-        except UnicodeEncodeError:\n-            unicode_value = value  # was already unicode\n+\n+        if isinstance(value, six.binary_type):\n+            value = value.decode(charset)\n         return RichTextValue(\n-            raw=unicode_value,\n+            raw=value,\n             mimeType=contentType or self.field.default_mime_type,\n             outputMimeType=self.field.output_mime_type,\n             encoding=charset\ndiff --git a/plone/app/textfield/marshaler.rst b/plone/app/textfield/marshaler.rst\nindex f6e122a..83ebbf2 100644\n--- a/plone/app/textfield/marshaler.rst\n+++ b/plone/app/textfield/marshaler.rst\n@@ -18,7 +18,8 @@ To test this, we must first load some configuration:\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> import six\n+    >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -50,8 +51,8 @@ We can now look up and test the marshaler:\n \n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_text\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    \'Some \\xc3\\x98 plain text\'\n-    >>> decoded = marshaler.decode(\'Some \\xc3\\x98 plain text\', charset=\'utf-8\', contentType=\'text/plain\')\n+    b\'Some \\xc3\\x98 plain text\'\n+    >>> decoded = marshaler.decode(b\'Some \\xc3\\x98 plain text\', charset=\'utf-8\', contentType=\'text/plain\')\n     >>> decoded.raw\n     u\'Some \\xd8 plain text\'\n     >>> decoded.mimeType\n@@ -70,7 +71,7 @@ We can now look up and test the marshaler:\n If we omit the content type (e.g. this is a non-primary field), the field\'s\n default type is used.\n \n-    >>> decoded = marshaler.decode(\'Some \\xc3\\x98 plain text\')\n+    >>> decoded = marshaler.decode(b\'Some \\xc3\\x98 plain text\')\n     >>> decoded.raw\n     u\'Some \\xd8 plain text\'\n     >>> decoded.mimeType\n@@ -92,7 +93,7 @@ primary field so that it is encoded in the content body.\n \n     >>> message = constructMessageFromSchema(t, ITestContent)\n     >>> messageBody = renderMessage(message)\n-    >>> print messageBody\n+    >>> print(messageBody)\n     MIME-Version: 1.0\n     Content-Type: text/plain; charset="utf-8"\n     <BLANKLINE>\ndiff --git a/plone/app/textfield/tests.py b/plone/app/textfield/tests.py\nindex 64e02bf..e557101 100644\n--- a/plone/app/textfield/tests.py\n+++ b/plone/app/textfield/tests.py\n@@ -1,10 +1,13 @@\n # -*- coding: utf-8 -*-\n from plone.app import testing\n-from plone.app.testing.bbb import PloneTestCase\n+# from plone.app.testing.bbb import PloneTestCase\n+from plone.app.testing import PLONE_FIXTURE\n from plone.testing import layered\n \n import doctest\n import plone.app.textfield\n+import re\n+import six\n import unittest\n \n \n@@ -20,10 +23,13 @@ def setUpZope(self, app, configurationContext):\n     bases=(PTC_FIXTURE, ), name=\'PloneAppTextfieldTest:Functional\')\n \n \n-class TestIntegration(PloneTestCase):\n+class TestIntegration(unittest.TestCase):\n \n     layer = IntegrationLayer\n \n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+\n     def testTransformPlain(self):\n         from zope.interface import Interface\n         from plone.app.textfield import RichText\n@@ -42,7 +48,10 @@ def testTransformNone(self):\n         value = RichTextValue()\n         # Mostly, these calls simply should not give an error.\n         self.assertEquals(None, value.raw)\n-        self.assertEquals(u\'\', value.output)\n+        if six.PY2:\n+            self.assertEquals(u\'\', value.output)\n+        else:\n+            self.assertEquals(None, value.output)\n \n     def testTransformStructured(self):\n         from zope.interface import Interface\n@@ -196,10 +205,10 @@ class IWithText(Interface):\n         self.assertTrue(converter.toWidgetValue(None) is None)\n \n         # Test with string input.\n-        self.assertRaises(ValueError, converter.toFieldValue, \'\')\n-        self.assertRaises(ValueError, converter.toFieldValue, \'Foo\')\n-        self.assertRaises(ValueError, converter.toWidgetValue, \'\')\n-        self.assertRaises(ValueError, converter.toWidgetValue, \'Foo\')\n+        self.assertRaises(ValueError, converter.toFieldValue, b\'\')\n+        self.assertRaises(ValueError, converter.toFieldValue, b\'Foo\')\n+        self.assertRaises(ValueError, converter.toWidgetValue, b\'\')\n+        self.assertRaises(ValueError, converter.toWidgetValue, b\'Foo\')\n \n         # Test with unicode input.\n         self.assertTrue(converter.toFieldValue(u\'\') is _marker)\n@@ -246,9 +255,9 @@ class IWithText(Interface):\n \n         # Test with string input.\n         self.assertTrue(converter.toFieldValue(\'\') is _marker)\n-        self.assertRaises(ValueError, converter.toFieldValue, \'Foo\')\n-        self.assertRaises(ValueError, converter.toWidgetValue, \'\')\n-        self.assertRaises(ValueError, converter.toWidgetValue, \'Foo\')\n+        self.assertRaises(ValueError, converter.toFieldValue, b\'Foo\')\n+        self.assertRaises(ValueError, converter.toWidgetValue, b\'\')\n+        self.assertRaises(ValueError, converter.toWidgetValue, b\'Foo\')\n \n         # Test with unicode input.\n         self.assertTrue(converter.toFieldValue(u\'\') is _marker)\n@@ -333,10 +342,35 @@ class Context(PortalContent):\n         self.failUnless(\'text/structured\' in allowed)\n \n \n+class Py23DocChecker(doctest.OutputChecker):\n+\n+    def check_output(self, want, got, optionflags):\n+        if six.PY2:\n+            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n+        else:\n+            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+            got = re.sub(\n+                \'zope.schema._bootstrapinterfaces.WrongType\',\n+                \'WrongType\', got)\n+            got = re.sub(\n+                \'zope.interface.exceptions.Invalid\',\n+                \'Invalid\', got)\n+            got = re.sub(\n+                \'zope.schema._bootstrapinterfaces.ConstraintNotSatisfied\',\n+                \'ConstraintNotSatisfied\', got)\n+\n+        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n+\n+\n def test_suite():\n     suite = unittest.makeSuite(TestIntegration)\n     for doctestfile in [\'field.rst\', \'handler.rst\', \'marshaler.rst\']:\n         suite.addTest(layered(\n-            doctest.DocFileSuite(doctestfile, optionflags=doctest.ELLIPSIS),\n+            doctest.DocFileSuite(\n+                doctestfile,\n+                optionflags=doctest.ELLIPSIS,\n+                checker=Py23DocChecker(),\n+            ),\n             layer=testing.PLONE_FIXTURE))\n     return suite\n'

Repository: plone.app.textfield


Branch: refs/heads/master
Date: 2018-07-02T12:07:12+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.textfield/commit/e1ebf17596c1c9c54fd9e667e3339a0f257a1953

more Python3 compat

Files changed:
M plone/app/textfield/marshaler.py
M plone/app/textfield/marshaler.rst
M plone/app/textfield/tests.py

b'diff --git a/plone/app/textfield/marshaler.py b/plone/app/textfield/marshaler.py\nindex ec00e21..462830c 100644\n--- a/plone/app/textfield/marshaler.py\n+++ b/plone/app/textfield/marshaler.py\n@@ -21,12 +21,13 @@ def encode(self, value, charset=\'utf-8\', primary=False):\n         return value.raw.encode(charset)\n \n     def decode(\n-            self,\n-            value,\n-            message=None,\n-            charset=\'utf-8\',\n-            contentType=None,\n-            primary=False):\n+        self,\n+        value,\n+        message=None,\n+        charset=\'utf-8\',\n+        contentType=None,\n+        primary=False\n+    ):\n \n         if isinstance(value, six.binary_type):\n             value = value.decode(charset)\n@@ -34,7 +35,7 @@ def decode(\n             raw=value,\n             mimeType=contentType or self.field.default_mime_type,\n             outputMimeType=self.field.output_mime_type,\n-            encoding=charset\n+            encoding=charset,\n         )\n \n     def getContentType(self):\ndiff --git a/plone/app/textfield/marshaler.rst b/plone/app/textfield/marshaler.rst\nindex 83ebbf2..dc0606a 100644\n--- a/plone/app/textfield/marshaler.rst\n+++ b/plone/app/textfield/marshaler.rst\n@@ -1,10 +1,10 @@\n plone.rfc822 marshaler\n ======================\n \n-This package includes a field marshaler for ``plone.rfc822``, which will be\n-installed if that package is installed.\n+This package includes a field marshaler for ``plone.rfc822``,\n+which will be installed if that package is installed.\n \n-To test this, we must first load some configuration:\n+To test this, we must first load some configuration::\n \n     >>> configuration = """\\\n     ... <configure\n@@ -18,12 +18,11 @@ To test this, we must first load some configuration:\n     ... </configure>\n     ... """\n \n-    >>> import six\n     >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n-Next, we will create a simple schema with which to test the marshaler\n+Next, we will create a simple schema with which to test the marshaler::\n \n     >>> from zope.interface import Interface\n     >>> from plone.app.textfield import RichText\n@@ -33,8 +32,9 @@ Next, we will create a simple schema with which to test the marshaler\n     ...                     output_mime_type=\'text/html\',\n     ...                     default_mime_type=\'text/plain\')\n \n-We\'ll create an instance with some data, too. To avoid having to set up a\n-transformation utility, we\'ll simply provide the output value directly.\n+We\'ll create an instance with some data, too.\n+To avoid having to set up a transformation utility,\n+we\'ll simply provide the output value directly::\n \n     >>> from plone.app.textfield.value import RichTextValue\n     >>> from zope.interface import implementer\n@@ -44,7 +44,7 @@ transformation utility, we\'ll simply provide the output value directly.\n \n     >>> t = TestContent()\n \n-We can now look up and test the marshaler:\n+We can now look up and test the marshaler::\n \n     >>> from zope.component import getMultiAdapter\n     >>> from plone.rfc822.interfaces import IFieldMarshaler\n@@ -52,9 +52,12 @@ We can now look up and test the marshaler:\n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_text\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n     b\'Some \\xc3\\x98 plain text\'\n-    >>> decoded = marshaler.decode(b\'Some \\xc3\\x98 plain text\', charset=\'utf-8\', contentType=\'text/plain\')\n+\n+The other way around::\n+\n+    >>> decoded = marshaler.decode(b\'Some nei\\xc3\\x9f plain text\', charset=\'utf-8\', contentType=\'text/plain\')\n     >>> decoded.raw\n-    u\'Some \\xd8 plain text\'\n+    \'Some nei\xc3\x9f plain text\'\n     >>> decoded.mimeType\n     \'text/plain\'\n     >>> decoded.outputMimeType\n@@ -68,12 +71,12 @@ We can now look up and test the marshaler:\n     >>> marshaler.ascii\n     False\n \n-If we omit the content type (e.g. this is a non-primary field), the field\'s\n-default type is used.\n+If we omit the content type (e.g. this is a non-primary field),\n+the field\'s default type is used::\n \n-    >>> decoded = marshaler.decode(b\'Some \\xc3\\x98 plain text\')\n+    >>> decoded = marshaler.decode(b\'Some nei\\xc3\\x9f plain text\')\n     >>> decoded.raw\n-    u\'Some \\xd8 plain text\'\n+    \'Some nei\xc3\x9f plain text\'\n     >>> decoded.mimeType\n     \'text/plain\'\n     >>> decoded.outputMimeType\n@@ -81,25 +84,23 @@ default type is used.\n     >>> decoded.encoding\n     \'utf-8\'\n \n-Let\'s see how this looks in a message. We will mark the text field as a\n-primary field so that it is encoded in the content body.\n+Let\'s see how this looks in a message.\n+We will mark the text field as a primary field so that it is encoded in the content body::\n \n     >>> from plone.rfc822.interfaces import IPrimaryField\n-    >>> from plone.rfc822 import constructMessageFromSchema\n-    >>> from plone.rfc822 import renderMessage\n-\n     >>> from zope.interface import alsoProvides\n     >>> alsoProvides(ITestContent[\'_text\'], IPrimaryField)\n \n+    >>> from plone.rfc822 import constructMessageFromSchema\n     >>> message = constructMessageFromSchema(t, ITestContent)\n-    >>> messageBody = renderMessage(message)\n+    >>> messageBody = message.as_string()\n     >>> print(messageBody)\n     MIME-Version: 1.0\n     Content-Type: text/plain; charset="utf-8"\n     <BLANKLINE>\n     Some \xc3\x98 plain text\n \n-Let\'s now use this message to construct a new object.\n+Let\'s now use this message to construct a new object::\n \n     >>> from email import message_from_string\n     >>> inputMessage = message_from_string(messageBody)\ndiff --git a/plone/app/textfield/tests.py b/plone/app/textfield/tests.py\nindex e557101..e487a5e 100644\n--- a/plone/app/textfield/tests.py\n+++ b/plone/app/textfield/tests.py\n@@ -1,7 +1,5 @@\n # -*- coding: utf-8 -*-\n from plone.app import testing\n-# from plone.app.testing.bbb import PloneTestCase\n-from plone.app.testing import PLONE_FIXTURE\n from plone.testing import layered\n \n import doctest\n@@ -18,6 +16,7 @@ class IntegrationFixture(testing.PloneSandboxLayer):\n     def setUpZope(self, app, configurationContext):\n         self.loadZCML(package=plone.app.textfield)\n \n+\n PTC_FIXTURE = IntegrationFixture()\n IntegrationLayer = testing.FunctionalTesting(\n     bases=(PTC_FIXTURE, ), name=\'PloneAppTextfieldTest:Functional\')\n@@ -213,7 +212,9 @@ class IWithText(Interface):\n         # Test with unicode input.\n         self.assertTrue(converter.toFieldValue(u\'\') is _marker)\n         self.assertEqual(converter.toFieldValue(u\'Foo\').raw, u\'Foo\')\n-        self.assertTrue(isinstance(converter.toFieldValue(u\'Foo\'), RichTextValue))\n+        self.assertTrue(\n+            isinstance(converter.toFieldValue(u\'Foo\'), RichTextValue)\n+        )\n         self.assertEqual(converter.toWidgetValue(u\'\').raw, u\'\')\n         self.assertEqual(converter.toWidgetValue(u\'Foo\').raw, u\'Foo\')\n \n@@ -262,7 +263,9 @@ class IWithText(Interface):\n         # Test with unicode input.\n         self.assertTrue(converter.toFieldValue(u\'\') is _marker)\n         self.assertEqual(converter.toFieldValue(u\'Foo\').raw, u\'Foo\')\n-        self.assertTrue(isinstance(converter.toFieldValue(u\'Foo\'), RichTextValue))\n+        self.assertTrue(\n+            isinstance(converter.toFieldValue(u\'Foo\'), RichTextValue)\n+        )\n         self.assertEqual(converter.toWidgetValue(u\'\'), u\'\')\n         self.assertEqual(converter.toWidgetValue(u\'Foo\'), u\'Foo\')\n \n'

Repository: plone.app.textfield


Branch: refs/heads/master
Date: 2018-07-02T15:39:04+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.textfield/commit/1debc39282fadafff130b219ebc3e98894f68306

docs

Files changed:
M CHANGES.rst
M README.rst

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 19aa364..7433a76 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -1,8 +1,8 @@\n Changelog\n =========\n \n-1.2.12 (unreleased)\n--------------------\n+1.3.0 (unreleased)\n+------------------\n \n Breaking changes:\n \n@@ -10,7 +10,8 @@ Breaking changes:\n \n New features:\n \n-- *add item here*\n+- Python 3 fixes, needs plone.rfc322>=4.0b1.\n+  [jensens]\n \n Bug fixes:\n \ndiff --git a/README.rst b/README.rst\nindex 4622d59..9b0f31d 100644\n--- a/README.rst\n+++ b/README.rst\n@@ -1,7 +1,7 @@\n Introduction\n ============\n \n-This package provides a zope.schema style field type called RichText which can be used to store a value with a related MIME type.\n+This package provides a ``zope.schema`` style field type called ``RichText`` which can be used to store a value with a related MIME type.\n The value can be transformed to an output MIME type, for example to transform from structured text to HTML.\n \n Basic Usage\n@@ -15,12 +15,12 @@ To use the field, place it in a schema like so::\n     class ITest(Interface):\n \n         bodyText = RichText(\n-                title=u"Body text",\n-                default_mime_type=\'text/structured\',\n-                output_mime_type=\'text/html\',\n-                allowed_mime_types=(\'text/structured\', \'text/plain\',),\n-                default=u"Default value"\n-            )\n+            title=u"Body text",\n+            default_mime_type=\'text/structured\',\n+            output_mime_type=\'text/html\',\n+            allowed_mime_types=(\'text/structured\', \'text/plain\',),\n+            default=u"Default value"\n+        )\n \n This specifies the default MIME type of text content as well as the default output type,\n and a tuple of allowed types.\n@@ -138,3 +138,24 @@ Further Reading\n \n See field.txt for more details about the field\'s behavior,\n and handler.txt for more details about the plone.supermodel handler.\n+\n+Issue tracker\n+=============\n+\n+Please report issues via the `Plone issue tracker`_.\n+\n+.. _`Plone issue tracker`: https://github.com/plone/plone.namedfile/issues\n+\n+Support\n+=======\n+\n+Questions may be answered via `Plone\'s support channels`_.\n+\n+.. _`Plone\'s support channels`: http://plone.org/support\n+\n+Contributing\n+============\n+\n+Sources are at the `Plone code repository hosted at Github <https://github.com/plone/plone.namedfile>`_.\n+\n+Contributors please read the document `Process for Plone core\'s development <http://docs.plone.org/develop/plone-coredev/index.html>`_\n'

Repository: plone.app.textfield


Branch: refs/heads/master
Date: 2018-07-02T15:46:01+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.textfield/commit/002c5310657b95fc61bfce8a268f41699db51c87

remove self-contained buildout left overs

Files changed:
D bootstrap.py
D buildout.cfg

b'diff --git a/bootstrap.py b/bootstrap.py\ndeleted file mode 100644\nindex 506a75f..0000000\n--- a/bootstrap.py\n+++ /dev/null\n@@ -1,178 +0,0 @@\n-##############################################################################\n-#\n-# Copyright (c) 2006 Zope Foundation and Contributors.\n-# All Rights Reserved.\n-#\n-# This software is subject to the provisions of the Zope Public License,\n-# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n-# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED\n-# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n-# FOR A PARTICULAR PURPOSE.\n-#\n-##############################################################################\n-"""Bootstrap a buildout-based project\n-\n-Simply run this script in a directory containing a buildout.cfg.\n-The script accepts buildout command-line options, so you can\n-use the -c option to specify an alternate configuration file.\n-"""\n-\n-import os\n-import shutil\n-import sys\n-import tempfile\n-\n-from optparse import OptionParser\n-\n-tmpeggs = tempfile.mkdtemp()\n-\n-usage = \'\'\'\\\n-[DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]\n-\n-Bootstraps a buildout-based project.\n-\n-Simply run this script in a directory containing a buildout.cfg, using the\n-Python that you want bin/buildout to use.\n-\n-Note that by using --find-links to point to local resources, you can keep\n-this script from going over the network.\n-\'\'\'\n-\n-parser = OptionParser(usage=usage)\n-parser.add_option("-v", "--version", help="use a specific zc.buildout version")\n-\n-parser.add_option("-t", "--accept-buildout-test-releases",\n-                  dest=\'accept_buildout_test_releases\',\n-                  action="store_true", default=False,\n-                  help=("Normally, if you do not specify a --version, the "\n-                        "bootstrap script and buildout gets the newest "\n-                        "*final* versions of zc.buildout and its recipes and "\n-                        "extensions for you.  If you use this flag, "\n-                        "bootstrap and buildout will get the newest releases "\n-                        "even if they are alphas or betas."))\n-parser.add_option("-c", "--config-file",\n-                  help=("Specify the path to the buildout configuration "\n-                        "file to be used."))\n-parser.add_option("-f", "--find-links",\n-                  help=("Specify a URL to search for buildout releases"))\n-parser.add_option("--allow-site-packages",\n-                  action="store_true", default=False,\n-                  help=("Let bootstrap.py use existing site packages"))\n-\n-\n-options, args = parser.parse_args()\n-\n-######################################################################\n-# load/install setuptools\n-\n-try:\n-    if options.allow_site_packages:\n-        import setuptools\n-        import pkg_resources\n-    from urllib.request import urlopen\n-except ImportError:\n-    from urllib2 import urlopen\n-\n-ez = {}\n-exec(urlopen(\'https://bootstrap.pypa.io/ez_setup.py\').read(), ez)\n-\n-if not options.allow_site_packages:\n-    # ez_setup imports site, which adds site packages\n-    # this will remove them from the path to ensure that incompatible versions\n-    # of setuptools are not in the path\n-    import site\n-    # inside a virtualenv, there is no \'getsitepackages\'.\n-    # We can\'t remove these reliably\n-    if hasattr(site, \'getsitepackages\'):\n-        for sitepackage_path in site.getsitepackages():\n-            sys.path[:] = [x for x in sys.path if sitepackage_path not in x]\n-\n-setup_args = dict(to_dir=tmpeggs, download_delay=0)\n-ez[\'use_setuptools\'](**setup_args)\n-import setuptools\n-import pkg_resources\n-\n-# This does not (always?) update the default working set.  We will\n-# do it.\n-for path in sys.path:\n-    if path not in pkg_resources.working_set.entries:\n-        pkg_resources.working_set.add_entry(path)\n-\n-######################################################################\n-# Install buildout\n-\n-ws = pkg_resources.working_set\n-\n-cmd = [sys.executable, \'-c\',\n-       \'from setuptools.command.easy_install import main; main()\',\n-       \'-mZqNxd\', tmpeggs]\n-\n-find_links = os.environ.get(\n-    \'bootstrap-testing-find-links\',\n-    options.find_links or\n-    (\'http://downloads.buildout.org/\'\n-     if options.accept_buildout_test_releases else None)\n-    )\n-if find_links:\n-    cmd.extend([\'-f\', find_links])\n-\n-setuptools_path = ws.find(\n-    pkg_resources.Requirement.parse(\'setuptools\')).location\n-\n-requirement = \'zc.buildout\'\n-version = options.version\n-if version is None and not options.accept_buildout_test_releases:\n-    # Figure out the most recent final version of zc.buildout.\n-    import setuptools.package_index\n-    _final_parts = \'*final-\', \'*final\'\n-\n-    def _final_version(parsed_version):\n-        for part in parsed_version:\n-            if (part[:1] == \'*\') and (part not in _final_parts):\n-                return False\n-        return True\n-    index = setuptools.package_index.PackageIndex(\n-        search_path=[setuptools_path])\n-    if find_links:\n-        index.add_find_links((find_links,))\n-    req = pkg_resources.Requirement.parse(requirement)\n-    if index.obtain(req) is not None:\n-        best = []\n-        bestv = None\n-        for dist in index[req.project_name]:\n-            distv = dist.parsed_version\n-            if _final_version(distv):\n-                if bestv is None or distv > bestv:\n-                    best = [dist]\n-                    bestv = distv\n-                elif distv == bestv:\n-                    best.append(dist)\n-        if best:\n-            best.sort()\n-            version = best[-1].version\n-if version:\n-    requirement = \'==\'.join((requirement, version))\n-cmd.append(requirement)\n-\n-import subprocess\n-if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:\n-    raise Exception(\n-        "Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n-\n-######################################################################\n-# Import and run buildout\n-\n-ws.add_entry(tmpeggs)\n-ws.require(requirement)\n-import zc.buildout.buildout\n-\n-if not [a for a in args if \'=\' not in a]:\n-    args.append(\'bootstrap\')\n-\n-# if -c was provided, we push it back into args for buildout\' main function\n-if options.config_file is not None:\n-    args[0:0] = [\'-c\', options.config_file]\n-\n-zc.buildout.buildout.main(args)\n-shutil.rmtree(tmpeggs)\ndiff --git a/buildout.cfg b/buildout.cfg\ndeleted file mode 100644\nindex b7f58cf..0000000\n--- a/buildout.cfg\n+++ /dev/null\n@@ -1,7 +0,0 @@\n-[buildout]\n-extends = https://raw.githubusercontent.com/collective/buildout.plonetest/master/test-5.x.cfg\n-package-name = plone.app.textfield\n-package-extras = [tests]\n-\n-[versions]\n-plone.app.textfield =\n'

Repository: plone.app.textfield


Branch: refs/heads/master
Date: 2018-07-31T13:31:06+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.app.textfield/commit/839c4f93cc4c7fa0b9fc80011766177b50a92503

Merge branch 'master' into python3

Files changed:
M CHANGES.rst
M plone/app/textfield/transform.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex 7433a76..95a8e7c 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -18,6 +18,16 @@ Bug fixes:\n - *add item here*\n \n \n+1.2.12 (unreleased)\n+-------------------\n+\n+Bug fixes:\n+\n+- purge transform cache when a uid referenced image\n+  gets updated. this fixes `issue CMFPLone#2465 <https://github.com/plone/Products.CMFPlone/issues/2465>`_\n+  [petschki]\n+\n+\n 1.2.11 (2018-04-08)\n -------------------\n \ndiff --git a/plone/app/textfield/transform.py b/plone/app/textfield/transform.py\nindex 744f29f..38ffb13 100644\n--- a/plone/app/textfield/transform.py\n+++ b/plone/app/textfield/transform.py\n@@ -1,16 +1,18 @@\n # -*- coding: utf-8 -*-\n-from plone.app.textfield.interfaces import ITransformer\n-from plone.app.textfield.interfaces import TransformError\n from Products.CMFCore.utils import getToolByName\n+from Products.PortalTransforms.cache import Cache\n from ZODB.POSException import ConflictError\n+from plone.app.textfield.interfaces import ITransformer\n+from plone.app.textfield.interfaces import TransformError\n from zope.component.hooks import getSite\n from zope.interface import implementer\n \n import logging\n+import re\n import six\n \n-\n LOG = logging.getLogger(\'plone.app.textfield\')\n+imguid_re = re.compile(r\'src="[^/]*/resolve[uU]id/([^/"]*)\')\n \n \n @implementer(ITransformer)\n@@ -19,8 +21,11 @@ class PortalTransformsTransformer(object):\n     """Invoke portal_transforms to perform a conversion\n     """\n \n+    _ccounter_id = \'_v_catalog_counter\'\n+\n     def __init__(self, context):\n         self.context = context\n+        self.catalog = getToolByName(getSite(), \'portal_catalog\')\n \n     def __call__(self, value, mimeType):\n         # shortcut it we have no data\n@@ -40,9 +45,13 @@ def __call__(self, value, mimeType):\n         if six.PY2:\n             # in Python 2 transforms expect str\n             source_value = value.raw_encoded\n-        else:# in Python 3 we pass text\n+        else:\n+            # in Python 3 we pass text\n             source_value = value.raw\n \n+        # check for modified referenced images\n+        self.check_referenced_images(source_value, mimeType, value._raw_holder)\n+\n         try:\n             data = transforms.convertTo(mimeType,\n                                         source_value,\n@@ -76,3 +85,35 @@ def __call__(self, value, mimeType):\n             # log the traceback of the original exception\n             LOG.error("Transform exception", exc_info=True)\n             raise TransformError(\'Error during transformation\', e)\n+\n+    def check_referenced_images(self, value, target_mimetype, cache_obj):\n+        # check catalog counter for changes first.\n+        counter = self.catalog.getCounter()\n+        cached_counter = getattr(cache_obj, self._ccounter_id, -1)\n+        if cached_counter == counter:\n+            # no changes made since last visit\n+            return\n+        # safe counter state\n+        setattr(cache_obj, self._ccounter_id, counter)\n+\n+        # extract all image src uuids\n+        uids = imguid_re.findall(value)\n+        if len(uids) == 0:\n+            # no uuid here at all\n+            return\n+\n+        # referenced image scale urls get outdated if the images are modified.\n+        # purging the transform cache updates those urls.\n+        cache = Cache(cache_obj, context=self.context)\n+        data = cache.getCache(target_mimetype)\n+        if data is None:\n+            # data is not cached\n+            return\n+\n+        # get the original save time from the cached data dict\n+        orig_time = getattr(cache_obj, cache._id).values()[0][0]\n+        modified_imgs = self.catalog(\n+            UID=uids, modified=dict(query=orig_time, range="min"))\n+\n+        if len(modified_imgs) > 0:\n+            cache.purgeCache()\n'

Repository: plone.app.textfield


Branch: refs/heads/master
Date: 2018-08-01T11:17:45+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.app.textfield/commit/04351bf2a1f66324a87cf72b44222e461c9039df

fix doctests

Files changed:
M CHANGES.rst
M plone/app/textfield/marshaler.rst

b"diff --git a/CHANGES.rst b/CHANGES.rst\nindex 95a8e7c..497c825 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -10,7 +10,7 @@ Breaking changes:\n \n New features:\n \n-- Python 3 fixes, needs plone.rfc322>=4.0b1.\n+- Python 3 fixes, needs plone.rfc822>=2.0b1.\n   [jensens]\n \n Bug fixes:\ndiff --git a/plone/app/textfield/marshaler.rst b/plone/app/textfield/marshaler.rst\nindex dc0606a..d048636 100644\n--- a/plone/app/textfield/marshaler.rst\n+++ b/plone/app/textfield/marshaler.rst\n@@ -57,7 +57,7 @@ The other way around::\n \n     >>> decoded = marshaler.decode(b'Some nei\\xc3\\x9f plain text', charset='utf-8', contentType='text/plain')\n     >>> decoded.raw\n-    'Some nei\xc3\x9f plain text'\n+    u'Some nei\\xdf plain text'\n     >>> decoded.mimeType\n     'text/plain'\n     >>> decoded.outputMimeType\n@@ -76,7 +76,7 @@ the field's default type is used::\n \n     >>> decoded = marshaler.decode(b'Some nei\\xc3\\x9f plain text')\n     >>> decoded.raw\n-    'Some nei\xc3\x9f plain text'\n+    u'Some nei\\xdf plain text'\n     >>> decoded.mimeType\n     'text/plain'\n     >>> decoded.outputMimeType\n"

Repository: plone.app.textfield


Branch: refs/heads/master
Date: 2018-08-02T16:42:35+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.textfield/commit/0c8a1fd9943751694436a3d7d67b8ec86e6704be

Merge pull request #29 from plone/python3

Python3

Files changed:
M CHANGES.rst
M README.rst
M plone/app/textfield/field.rst
M plone/app/textfield/handler.rst
M plone/app/textfield/marshaler.py
M plone/app/textfield/marshaler.rst
M plone/app/textfield/tests.py
M plone/app/textfield/transform.py
M plone/app/textfield/value.py
D bootstrap.py
D buildout.cfg

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex e743655..497c825 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -1,8 +1,8 @@\n Changelog\n =========\n \n-1.2.12 (unreleased)\n--------------------\n+1.3.0 (unreleased)\n+------------------\n \n Breaking changes:\n \n@@ -10,8 +10,17 @@ Breaking changes:\n \n New features:\n \n+- Python 3 fixes, needs plone.rfc822>=2.0b1.\n+  [jensens]\n+\n+Bug fixes:\n+\n - *add item here*\n \n+\n+1.2.12 (unreleased)\n+-------------------\n+\n Bug fixes:\n \n - purge transform cache when a uid referenced image\ndiff --git a/README.rst b/README.rst\nindex 4622d59..9b0f31d 100644\n--- a/README.rst\n+++ b/README.rst\n@@ -1,7 +1,7 @@\n Introduction\n ============\n \n-This package provides a zope.schema style field type called RichText which can be used to store a value with a related MIME type.\n+This package provides a ``zope.schema`` style field type called ``RichText`` which can be used to store a value with a related MIME type.\n The value can be transformed to an output MIME type, for example to transform from structured text to HTML.\n \n Basic Usage\n@@ -15,12 +15,12 @@ To use the field, place it in a schema like so::\n     class ITest(Interface):\n \n         bodyText = RichText(\n-                title=u"Body text",\n-                default_mime_type=\'text/structured\',\n-                output_mime_type=\'text/html\',\n-                allowed_mime_types=(\'text/structured\', \'text/plain\',),\n-                default=u"Default value"\n-            )\n+            title=u"Body text",\n+            default_mime_type=\'text/structured\',\n+            output_mime_type=\'text/html\',\n+            allowed_mime_types=(\'text/structured\', \'text/plain\',),\n+            default=u"Default value"\n+        )\n \n This specifies the default MIME type of text content as well as the default output type,\n and a tuple of allowed types.\n@@ -138,3 +138,24 @@ Further Reading\n \n See field.txt for more details about the field\'s behavior,\n and handler.txt for more details about the plone.supermodel handler.\n+\n+Issue tracker\n+=============\n+\n+Please report issues via the `Plone issue tracker`_.\n+\n+.. _`Plone issue tracker`: https://github.com/plone/plone.namedfile/issues\n+\n+Support\n+=======\n+\n+Questions may be answered via `Plone\'s support channels`_.\n+\n+.. _`Plone\'s support channels`: http://plone.org/support\n+\n+Contributing\n+============\n+\n+Sources are at the `Plone code repository hosted at Github <https://github.com/plone/plone.namedfile>`_.\n+\n+Contributors please read the document `Process for Plone core\'s development <http://docs.plone.org/develop/plone-coredev/index.html>`_\ndiff --git a/bootstrap.py b/bootstrap.py\ndeleted file mode 100644\nindex 506a75f..0000000\n--- a/bootstrap.py\n+++ /dev/null\n@@ -1,178 +0,0 @@\n-##############################################################################\n-#\n-# Copyright (c) 2006 Zope Foundation and Contributors.\n-# All Rights Reserved.\n-#\n-# This software is subject to the provisions of the Zope Public License,\n-# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n-# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED\n-# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n-# FOR A PARTICULAR PURPOSE.\n-#\n-##############################################################################\n-"""Bootstrap a buildout-based project\n-\n-Simply run this script in a directory containing a buildout.cfg.\n-The script accepts buildout command-line options, so you can\n-use the -c option to specify an alternate configuration file.\n-"""\n-\n-import os\n-import shutil\n-import sys\n-import tempfile\n-\n-from optparse import OptionParser\n-\n-tmpeggs = tempfile.mkdtemp()\n-\n-usage = \'\'\'\\\n-[DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]\n-\n-Bootstraps a buildout-based project.\n-\n-Simply run this script in a directory containing a buildout.cfg, using the\n-Python that you want bin/buildout to use.\n-\n-Note that by using --find-links to point to local resources, you can keep\n-this script from going over the network.\n-\'\'\'\n-\n-parser = OptionParser(usage=usage)\n-parser.add_option("-v", "--version", help="use a specific zc.buildout version")\n-\n-parser.add_option("-t", "--accept-buildout-test-releases",\n-                  dest=\'accept_buildout_test_releases\',\n-                  action="store_true", default=False,\n-                  help=("Normally, if you do not specify a --version, the "\n-                        "bootstrap script and buildout gets the newest "\n-                        "*final* versions of zc.buildout and its recipes and "\n-                        "extensions for you.  If you use this flag, "\n-                        "bootstrap and buildout will get the newest releases "\n-                        "even if they are alphas or betas."))\n-parser.add_option("-c", "--config-file",\n-                  help=("Specify the path to the buildout configuration "\n-                        "file to be used."))\n-parser.add_option("-f", "--find-links",\n-                  help=("Specify a URL to search for buildout releases"))\n-parser.add_option("--allow-site-packages",\n-                  action="store_true", default=False,\n-                  help=("Let bootstrap.py use existing site packages"))\n-\n-\n-options, args = parser.parse_args()\n-\n-######################################################################\n-# load/install setuptools\n-\n-try:\n-    if options.allow_site_packages:\n-        import setuptools\n-        import pkg_resources\n-    from urllib.request import urlopen\n-except ImportError:\n-    from urllib2 import urlopen\n-\n-ez = {}\n-exec(urlopen(\'https://bootstrap.pypa.io/ez_setup.py\').read(), ez)\n-\n-if not options.allow_site_packages:\n-    # ez_setup imports site, which adds site packages\n-    # this will remove them from the path to ensure that incompatible versions\n-    # of setuptools are not in the path\n-    import site\n-    # inside a virtualenv, there is no \'getsitepackages\'.\n-    # We can\'t remove these reliably\n-    if hasattr(site, \'getsitepackages\'):\n-        for sitepackage_path in site.getsitepackages():\n-            sys.path[:] = [x for x in sys.path if sitepackage_path not in x]\n-\n-setup_args = dict(to_dir=tmpeggs, download_delay=0)\n-ez[\'use_setuptools\'](**setup_args)\n-import setuptools\n-import pkg_resources\n-\n-# This does not (always?) update the default working set.  We will\n-# do it.\n-for path in sys.path:\n-    if path not in pkg_resources.working_set.entries:\n-        pkg_resources.working_set.add_entry(path)\n-\n-######################################################################\n-# Install buildout\n-\n-ws = pkg_resources.working_set\n-\n-cmd = [sys.executable, \'-c\',\n-       \'from setuptools.command.easy_install import main; main()\',\n-       \'-mZqNxd\', tmpeggs]\n-\n-find_links = os.environ.get(\n-    \'bootstrap-testing-find-links\',\n-    options.find_links or\n-    (\'http://downloads.buildout.org/\'\n-     if options.accept_buildout_test_releases else None)\n-    )\n-if find_links:\n-    cmd.extend([\'-f\', find_links])\n-\n-setuptools_path = ws.find(\n-    pkg_resources.Requirement.parse(\'setuptools\')).location\n-\n-requirement = \'zc.buildout\'\n-version = options.version\n-if version is None and not options.accept_buildout_test_releases:\n-    # Figure out the most recent final version of zc.buildout.\n-    import setuptools.package_index\n-    _final_parts = \'*final-\', \'*final\'\n-\n-    def _final_version(parsed_version):\n-        for part in parsed_version:\n-            if (part[:1] == \'*\') and (part not in _final_parts):\n-                return False\n-        return True\n-    index = setuptools.package_index.PackageIndex(\n-        search_path=[setuptools_path])\n-    if find_links:\n-        index.add_find_links((find_links,))\n-    req = pkg_resources.Requirement.parse(requirement)\n-    if index.obtain(req) is not None:\n-        best = []\n-        bestv = None\n-        for dist in index[req.project_name]:\n-            distv = dist.parsed_version\n-            if _final_version(distv):\n-                if bestv is None or distv > bestv:\n-                    best = [dist]\n-                    bestv = distv\n-                elif distv == bestv:\n-                    best.append(dist)\n-        if best:\n-            best.sort()\n-            version = best[-1].version\n-if version:\n-    requirement = \'==\'.join((requirement, version))\n-cmd.append(requirement)\n-\n-import subprocess\n-if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:\n-    raise Exception(\n-        "Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n-\n-######################################################################\n-# Import and run buildout\n-\n-ws.add_entry(tmpeggs)\n-ws.require(requirement)\n-import zc.buildout.buildout\n-\n-if not [a for a in args if \'=\' not in a]:\n-    args.append(\'bootstrap\')\n-\n-# if -c was provided, we push it back into args for buildout\' main function\n-if options.config_file is not None:\n-    args[0:0] = [\'-c\', options.config_file]\n-\n-zc.buildout.buildout.main(args)\n-shutil.rmtree(tmpeggs)\ndiff --git a/buildout.cfg b/buildout.cfg\ndeleted file mode 100644\nindex b7f58cf..0000000\n--- a/buildout.cfg\n+++ /dev/null\n@@ -1,7 +0,0 @@\n-[buildout]\n-extends = https://raw.githubusercontent.com/collective/buildout.plonetest/master/test-5.x.cfg\n-package-name = plone.app.textfield\n-package-extras = [tests]\n-\n-[versions]\n-plone.app.textfield =\ndiff --git a/plone/app/textfield/field.rst b/plone/app/textfield/field.rst\nindex 9f6b5ef..d608170 100644\n--- a/plone/app/textfield/field.rst\n+++ b/plone/app/textfield/field.rst\n@@ -113,7 +113,7 @@ Or to get the value encoded:\n     >>> value.encoding\n     \'utf-8\'\n     >>> value.raw_encoded\n-    \'Some plain text\'\n+    b\'Some plain text\'\n \n Values are equal as long as they have the same `raw`, `mimeType`, `outputMimeType`,\n and `encoding`:\n@@ -153,7 +153,7 @@ default MIME types set on the field.\n     >>> value.raw\n     u\'A plain text string\'\n     >>> value.raw_encoded\n-    \'A plain text string\'\n+    b\'A plain text string\'\n     >>> value.output\n     u\'A PLAIN TEXT STRING\'\n \ndiff --git a/plone/app/textfield/handler.rst b/plone/app/textfield/handler.rst\nindex 144ddee..9725d5f 100644\n--- a/plone/app/textfield/handler.rst\n+++ b/plone/app/textfield/handler.rst\n@@ -23,7 +23,8 @@ First, let\'s wire up the package.\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> import six\n+    >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n@@ -48,7 +49,7 @@ Then, let\'s test the field\n     >>> fieldType = IFieldNameExtractor(field)()\n     >>> handler = getUtility(IFieldExportImportHandler, name=fieldType)\n     >>> element = handler.write(field, u\'dummy\', fieldType) #doctest: +ELLIPSIS\n-    >>> print prettyXML(element)\n+    >>> print(prettyXML(element))\n     <field name="dummy" type="plone.app.textfield.RichText">\n       <allowed_mime_types>\n         <element>text/plain</element>\ndiff --git a/plone/app/textfield/marshaler.py b/plone/app/textfield/marshaler.py\nindex 8457035..462830c 100644\n--- a/plone/app/textfield/marshaler.py\n+++ b/plone/app/textfield/marshaler.py\n@@ -5,6 +5,8 @@\n from zope.component import adapter\n from zope.interface import Interface\n \n+import six\n+\n \n @adapter(Interface, IRichText)\n class RichTextFieldMarshaler(BaseFieldMarshaler):\n@@ -19,21 +21,21 @@ def encode(self, value, charset=\'utf-8\', primary=False):\n         return value.raw.encode(charset)\n \n     def decode(\n-            self,\n-            value,\n-            message=None,\n-            charset=\'utf-8\',\n-            contentType=None,\n-            primary=False):\n-        try:\n-            unicode_value = value.decode(charset)\n-        except UnicodeEncodeError:\n-            unicode_value = value  # was already unicode\n+        self,\n+        value,\n+        message=None,\n+        charset=\'utf-8\',\n+        contentType=None,\n+        primary=False\n+    ):\n+\n+        if isinstance(value, six.binary_type):\n+            value = value.decode(charset)\n         return RichTextValue(\n-            raw=unicode_value,\n+            raw=value,\n             mimeType=contentType or self.field.default_mime_type,\n             outputMimeType=self.field.output_mime_type,\n-            encoding=charset\n+            encoding=charset,\n         )\n \n     def getContentType(self):\ndiff --git a/plone/app/textfield/marshaler.rst b/plone/app/textfield/marshaler.rst\nindex f6e122a..d048636 100644\n--- a/plone/app/textfield/marshaler.rst\n+++ b/plone/app/textfield/marshaler.rst\n@@ -1,10 +1,10 @@\n plone.rfc822 marshaler\n ======================\n \n-This package includes a field marshaler for ``plone.rfc822``, which will be\n-installed if that package is installed.\n+This package includes a field marshaler for ``plone.rfc822``,\n+which will be installed if that package is installed.\n \n-To test this, we must first load some configuration:\n+To test this, we must first load some configuration::\n \n     >>> configuration = """\\\n     ... <configure\n@@ -18,11 +18,11 @@ To test this, we must first load some configuration:\n     ... </configure>\n     ... """\n \n-    >>> from StringIO import StringIO\n+    >>> from six import StringIO\n     >>> from zope.configuration import xmlconfig\n     >>> xmlconfig.xmlconfig(StringIO(configuration))\n \n-Next, we will create a simple schema with which to test the marshaler\n+Next, we will create a simple schema with which to test the marshaler::\n \n     >>> from zope.interface import Interface\n     >>> from plone.app.textfield import RichText\n@@ -32,8 +32,9 @@ Next, we will create a simple schema with which to test the marshaler\n     ...                     output_mime_type=\'text/html\',\n     ...                     default_mime_type=\'text/plain\')\n \n-We\'ll create an instance with some data, too. To avoid having to set up a\n-transformation utility, we\'ll simply provide the output value directly.\n+We\'ll create an instance with some data, too.\n+To avoid having to set up a transformation utility,\n+we\'ll simply provide the output value directly::\n \n     >>> from plone.app.textfield.value import RichTextValue\n     >>> from zope.interface import implementer\n@@ -43,17 +44,20 @@ transformation utility, we\'ll simply provide the output value directly.\n \n     >>> t = TestContent()\n \n-We can now look up and test the marshaler:\n+We can now look up and test the marshaler::\n \n     >>> from zope.component import getMultiAdapter\n     >>> from plone.rfc822.interfaces import IFieldMarshaler\n \n     >>> marshaler = getMultiAdapter((t, ITestContent[\'_text\']), IFieldMarshaler)\n     >>> marshaler.marshal()\n-    \'Some \\xc3\\x98 plain text\'\n-    >>> decoded = marshaler.decode(\'Some \\xc3\\x98 plain text\', charset=\'utf-8\', contentType=\'text/plain\')\n+    b\'Some \\xc3\\x98 plain text\'\n+\n+The other way around::\n+\n+    >>> decoded = marshaler.decode(b\'Some nei\\xc3\\x9f plain text\', charset=\'utf-8\', contentType=\'text/plain\')\n     >>> decoded.raw\n-    u\'Some \\xd8 plain text\'\n+    u\'Some nei\\xdf plain text\'\n     >>> decoded.mimeType\n     \'text/plain\'\n     >>> decoded.outputMimeType\n@@ -67,12 +71,12 @@ We can now look up and test the marshaler:\n     >>> marshaler.ascii\n     False\n \n-If we omit the content type (e.g. this is a non-primary field), the field\'s\n-default type is used.\n+If we omit the content type (e.g. this is a non-primary field),\n+the field\'s default type is used::\n \n-    >>> decoded = marshaler.decode(\'Some \\xc3\\x98 plain text\')\n+    >>> decoded = marshaler.decode(b\'Some nei\\xc3\\x9f plain text\')\n     >>> decoded.raw\n-    u\'Some \\xd8 plain text\'\n+    u\'Some nei\\xdf plain text\'\n     >>> decoded.mimeType\n     \'text/plain\'\n     >>> decoded.outputMimeType\n@@ -80,25 +84,23 @@ default type is used.\n     >>> decoded.encoding\n     \'utf-8\'\n \n-Let\'s see how this looks in a message. We will mark the text field as a\n-primary field so that it is encoded in the content body.\n+Let\'s see how this looks in a message.\n+We will mark the text field as a primary field so that it is encoded in the content body::\n \n     >>> from plone.rfc822.interfaces import IPrimaryField\n-    >>> from plone.rfc822 import constructMessageFromSchema\n-    >>> from plone.rfc822 import renderMessage\n-\n     >>> from zope.interface import alsoProvides\n     >>> alsoProvides(ITestContent[\'_text\'], IPrimaryField)\n \n+    >>> from plone.rfc822 import constructMessageFromSchema\n     >>> message = constructMessageFromSchema(t, ITestContent)\n-    >>> messageBody = renderMessage(message)\n-    >>> print messageBody\n+    >>> messageBody = message.as_string()\n+    >>> print(messageBody)\n     MIME-Version: 1.0\n     Content-Type: text/plain; charset="utf-8"\n     <BLANKLINE>\n     Some \xc3\x98 plain text\n \n-Let\'s now use this message to construct a new object.\n+Let\'s now use this message to construct a new object::\n \n     >>> from email import message_from_string\n     >>> inputMessage = message_from_string(messageBody)\ndiff --git a/plone/app/textfield/tests.py b/plone/app/textfield/tests.py\nindex 64e02bf..e487a5e 100644\n--- a/plone/app/textfield/tests.py\n+++ b/plone/app/textfield/tests.py\n@@ -1,10 +1,11 @@\n # -*- coding: utf-8 -*-\n from plone.app import testing\n-from plone.app.testing.bbb import PloneTestCase\n from plone.testing import layered\n \n import doctest\n import plone.app.textfield\n+import re\n+import six\n import unittest\n \n \n@@ -15,15 +16,19 @@ class IntegrationFixture(testing.PloneSandboxLayer):\n     def setUpZope(self, app, configurationContext):\n         self.loadZCML(package=plone.app.textfield)\n \n+\n PTC_FIXTURE = IntegrationFixture()\n IntegrationLayer = testing.FunctionalTesting(\n     bases=(PTC_FIXTURE, ), name=\'PloneAppTextfieldTest:Functional\')\n \n \n-class TestIntegration(PloneTestCase):\n+class TestIntegration(unittest.TestCase):\n \n     layer = IntegrationLayer\n \n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+\n     def testTransformPlain(self):\n         from zope.interface import Interface\n         from plone.app.textfield import RichText\n@@ -42,7 +47,10 @@ def testTransformNone(self):\n         value = RichTextValue()\n         # Mostly, these calls simply should not give an error.\n         self.assertEquals(None, value.raw)\n-        self.assertEquals(u\'\', value.output)\n+        if six.PY2:\n+            self.assertEquals(u\'\', value.output)\n+        else:\n+            self.assertEquals(None, value.output)\n \n     def testTransformStructured(self):\n         from zope.interface import Interface\n@@ -196,15 +204,17 @@ class IWithText(Interface):\n         self.assertTrue(converter.toWidgetValue(None) is None)\n \n         # Test with string input.\n-        self.assertRaises(ValueError, converter.toFieldValue, \'\')\n-        self.assertRaises(ValueError, converter.toFieldValue, \'Foo\')\n-        self.assertRaises(ValueError, converter.toWidgetValue, \'\')\n-        self.assertRaises(ValueError, converter.toWidgetValue, \'Foo\')\n+        self.assertRaises(ValueError, converter.toFieldValue, b\'\')\n+        self.assertRaises(ValueError, converter.toFieldValue, b\'Foo\')\n+        self.assertRaises(ValueError, converter.toWidgetValue, b\'\')\n+        self.assertRaises(ValueError, converter.toWidgetValue, b\'Foo\')\n \n         # Test with unicode input.\n         self.assertTrue(converter.toFieldValue(u\'\') is _marker)\n         self.assertEqual(converter.toFieldValue(u\'Foo\').raw, u\'Foo\')\n-        self.assertTrue(isinstance(converter.toFieldValue(u\'Foo\'), RichTextValue))\n+        self.assertTrue(\n+            isinstance(converter.toFieldValue(u\'Foo\'), RichTextValue)\n+        )\n         self.assertEqual(converter.toWidgetValue(u\'\').raw, u\'\')\n         self.assertEqual(converter.toWidgetValue(u\'Foo\').raw, u\'Foo\')\n \n@@ -246,14 +256,16 @@ class IWithText(Interface):\n \n         # Test with string input.\n         self.assertTrue(converter.toFieldValue(\'\') is _marker)\n-        self.assertRaises(ValueError, converter.toFieldValue, \'Foo\')\n-        self.assertRaises(ValueError, converter.toWidgetValue, \'\')\n-        self.assertRaises(ValueError, converter.toWidgetValue, \'Foo\')\n+        self.assertRaises(ValueError, converter.toFieldValue, b\'Foo\')\n+        self.assertRaises(ValueError, converter.toWidgetValue, b\'\')\n+        self.assertRaises(ValueError, converter.toWidgetValue, b\'Foo\')\n \n         # Test with unicode input.\n         self.assertTrue(converter.toFieldValue(u\'\') is _marker)\n         self.assertEqual(converter.toFieldValue(u\'Foo\').raw, u\'Foo\')\n-        self.assertTrue(isinstance(converter.toFieldValue(u\'Foo\'), RichTextValue))\n+        self.assertTrue(\n+            isinstance(converter.toFieldValue(u\'Foo\'), RichTextValue)\n+        )\n         self.assertEqual(converter.toWidgetValue(u\'\'), u\'\')\n         self.assertEqual(converter.toWidgetValue(u\'Foo\'), u\'Foo\')\n \n@@ -333,10 +345,35 @@ class Context(PortalContent):\n         self.failUnless(\'text/structured\' in allowed)\n \n \n+class Py23DocChecker(doctest.OutputChecker):\n+\n+    def check_output(self, want, got, optionflags):\n+        if six.PY2:\n+            want = re.sub("b\'(.*?)\'", "\'\\\\1\'", want)\n+        else:\n+            want = re.sub("u\'(.*?)\'", "\'\\\\1\'", want)\n+            want = re.sub(\'u"(.*?)"\', \'"\\\\1"\', want)\n+            got = re.sub(\n+                \'zope.schema._bootstrapinterfaces.WrongType\',\n+                \'WrongType\', got)\n+            got = re.sub(\n+                \'zope.interface.exceptions.Invalid\',\n+                \'Invalid\', got)\n+            got = re.sub(\n+                \'zope.schema._bootstrapinterfaces.ConstraintNotSatisfied\',\n+                \'ConstraintNotSatisfied\', got)\n+\n+        return doctest.OutputChecker.check_output(self, want, got, optionflags)\n+\n+\n def test_suite():\n     suite = unittest.makeSuite(TestIntegration)\n     for doctestfile in [\'field.rst\', \'handler.rst\', \'marshaler.rst\']:\n         suite.addTest(layered(\n-            doctest.DocFileSuite(doctestfile, optionflags=doctest.ELLIPSIS),\n+            doctest.DocFileSuite(\n+                doctestfile,\n+                optionflags=doctest.ELLIPSIS,\n+                checker=Py23DocChecker(),\n+            ),\n             layer=testing.PLONE_FIXTURE))\n     return suite\ndiff --git a/plone/app/textfield/transform.py b/plone/app/textfield/transform.py\nindex 2ccc61c..38ffb13 100644\n--- a/plone/app/textfield/transform.py\n+++ b/plone/app/textfield/transform.py\n@@ -9,6 +9,7 @@\n \n import logging\n import re\n+import six\n \n LOG = logging.getLogger(\'plone.app.textfield\')\n imguid_re = re.compile(r\'src="[^/]*/resolve[uU]id/([^/"]*)\')\n@@ -41,12 +42,19 @@ def __call__(self, value, mimeType):\n         if transforms is None:\n             raise TransformError("Cannot find portal_transforms tool")\n \n+        if six.PY2:\n+            # in Python 2 transforms expect str\n+            source_value = value.raw_encoded\n+        else:\n+            # in Python 3 we pass text\n+            source_value = value.raw\n+\n         # check for modified referenced images\n-        self.check_referenced_images(mimeType, value._raw_holder)\n+        self.check_referenced_images(source_value, mimeType, value._raw_holder)\n \n         try:\n             data = transforms.convertTo(mimeType,\n-                                        value.raw_encoded,\n+                                        source_value,\n                                         mimetype=value.mimeType,\n                                         context=self.context,\n                                         # portal_transforms caches on this\n@@ -68,7 +76,9 @@ def __call__(self, value, mimeType):\n \n             else:\n                 output = data.getData()\n-                return output.decode(value.encoding)\n+                if six.PY2:\n+                    return output.decode(value.encoding)\n+                return output\n         except ConflictError:\n             raise\n         except Exception as e:\n@@ -76,7 +86,7 @@ def __call__(self, value, mimeType):\n             LOG.error("Transform exception", exc_info=True)\n             raise TransformError(\'Error during transformation\', e)\n \n-    def check_referenced_images(self, target_mimetype, cache_obj):\n+    def check_referenced_images(self, value, target_mimetype, cache_obj):\n         # check catalog counter for changes first.\n         counter = self.catalog.getCounter()\n         cached_counter = getattr(cache_obj, self._ccounter_id, -1)\n@@ -87,7 +97,7 @@ def check_referenced_images(self, target_mimetype, cache_obj):\n         setattr(cache_obj, self._ccounter_id, counter)\n \n         # extract all image src uuids\n-        uids = imguid_re.findall(cache_obj.value)\n+        uids = imguid_re.findall(value)\n         if len(uids) == 0:\n             # no uuid here at all\n             return\ndiff --git a/plone/app/textfield/value.py b/plone/app/textfield/value.py\nindex 80185ac..4c038fa 100644\n--- a/plone/app/textfield/value.py\n+++ b/plone/app/textfield/value.py\n@@ -7,6 +7,7 @@\n from zope.interface import implementer\n \n import logging\n+import six\n \n \n LOG = logging.getLogger(\'plone.app.textfield\')\n@@ -98,7 +99,10 @@ def output_relative_to(self, context):\n         transformer with the site as a context is used instead.\n         """\n         if self.mimeType == self.outputMimeType:\n-            return self.raw_encoded\n+            if six.PY2:\n+                return self.raw_encoded\n+            else:\n+                return self.raw\n \n         transformer = ITransformer(context, None)\n         if transformer is None:\n'

