Repository: plone.restapi


Branch: refs/heads/master
Date: 2022-11-29T21:47:19-08:00
Author: Mikel Larreategi (erral) <mlarreategi@codesyntax.com>
Commit: https://github.com/plone/plone.restapi/commit/44ab23cac1632c4583d4617320bb2311e9a48acf

handle sort_on and sort_order parameters to allow both lists and strings (#1533)

* handle sort_on and sort_order parameters to allow both lists and strings

* changelog

* docs

* fix

* fix doc changes

* quotes

Co-authored-by: Jens W. Klein &lt;jk@kleinundpartner.at&gt;

Files changed:
A news/1532.bugfix
A src/plone/restapi/tests/http-examples/search_sort_multiple_indexes.req
A src/plone/restapi/tests/http-examples/search_sort_multiple_indexes.resp
M docs/source/endpoints/searching.md
M src/plone/restapi/search/query.py
M src/plone/restapi/tests/test_documentation.py

b'diff --git a/docs/source/endpoints/searching.md b/docs/source/endpoints/searching.md\nindex 93ee581cb..6faf81a6b 100644\n--- a/docs/source/endpoints/searching.md\n+++ b/docs/source/endpoints/searching.md\n@@ -60,7 +60,6 @@ The `plone.restapi` `@search` endpoint will not do that for you.\n You will have to add it if you want to keep this feature.\n ```\n \n-\n ## Query format\n \n Queries and query-wide options, such as `sort_on`, are submitted as query string parameters to the `/@search` request:\n@@ -73,7 +72,6 @@ This is nearly identical to the way that queries are passed to the Plone `@@sear\n \n For general information on how to query the Plone catalog, please refer to the [Plone Documentation on Querying](https://docs.plone.org/develop/plone/searching_and_indexing/query.html).\n \n-\n ### Query options\n \n In case you want to supply query options to a query against a particular index, you will need to flatten the corresponding query dictionary and use a dotted notation to indicate nesting.\n@@ -98,7 +96,6 @@ This dictionary will need to be flattened in dotted notation to pass it into a q\n \n Again this is very similar to how [Record Arguments](https://zope.readthedocs.io/en/latest/zdgbook/ObjectPublishing.html#an-aggregator-in-detail-the-record-argument) are parsed by ZPublisher, except that you can omit the `:record` suffix.\n \n-\n ### Restricting search to multiple paths\n \n To restrict a search to multiple paths, the original query as a Python dictionary would look like this, with an optional `depth` and `sort_on`:\n@@ -122,6 +119,14 @@ The `requests` module will automatically do this for you if you pass it a list o\n :language: http\n ```\n \n+### Sorting on multiple indexes\n+\n+Sorting can happen on multiple indexes, as the underlying catalog supports it. To do so the query has to contain the list of indexes to be used for sorting in the `sort_on` parameter. If wanted the ordering of the sorting can also be added in the query in the `sort_order` parameter.\n+\n+```{eval-rst}\n+..  http:example:: curl httpie python-requests\n+    :request: ../../../src/plone/restapi/tests/http-examples/search_sort_multiple_indexes.req\n+```\n \n ### Data types in queries\n \n@@ -142,7 +147,6 @@ Accept: application/json\n \n Please refer to the [Documentation on Argument Conversion in ZPublisher](https://zope.readthedocs.io/en/latest/zdgbook/ObjectPublishing.html#argument-conversion) for details.\n \n-\n (retrieving-additional-metadata)=\n \n ## Retrieving additional metadata\n@@ -174,7 +178,6 @@ Doing so will result in a TypeError `"No converter for making <...> JSON compati\n In [ZCatalog](https://zope.readthedocs.io/en/latest/zopebook/SearchingZCatalog.html) terms, this reflects the difference between *catalog brains* and objects that have been *woken up*.\n ```\n \n-\n ## Retrieving full objects\n \n If the data provided as metadata is not enough, you can retrieve search results as full serialized objects equivalent to what the resource `GET` request would produce.\n@@ -195,7 +198,6 @@ Be aware that this might induce performance issues when retrieving a lot of reso\n Normally the search just serializes catalog brains, but with `fullobjects`, we wake up all the returned objects.\n ```\n \n-\n ## Restrict search results to Plone\'s search settings\n \n By default, the search endpoint does not exclude any types from its results.\ndiff --git a/news/1532.bugfix b/news/1532.bugfix\nnew file mode 100644\nindex 000000000..dd1baf532\n--- /dev/null\n+++ b/news/1532.bugfix\n@@ -0,0 +1,2 @@\n+allow multiple values for sort_on and sort_order parameters in @search\n+[erral]\ndiff --git a/src/plone/restapi/search/query.py b/src/plone/restapi/search/query.py\nindex ad89461b0..976143730 100644\n--- a/src/plone/restapi/search/query.py\n+++ b/src/plone/restapi/search/query.py\n@@ -68,13 +68,16 @@ class ZCatalogCompatibleQueryAdapter:\n     """\n \n     global_query_params = {\n-        "sort_on": str,\n-        "sort_order": str,\n         "sort_limit": int,\n         "b_start": int,\n         "b_size": int,\n     }\n \n+    multiple_types_global_query_params = {\n+        "sort_on": {list: list, tuple: list, str: str},\n+        "sort_order": {list: list, tuple: list, str: str},\n+    }\n+\n     ignore_query_params = ["metadata_fields"]\n \n     def __init__(self, context, request):\n@@ -89,6 +92,13 @@ def parse_query_param(self, idx_name, idx_query):\n         _type = self.global_query_params[idx_name]\n         return _type(idx_query)\n \n+    def parse_multiple_types_param(self, idx_name, idx_query):\n+        """these indexes can contain single str values or a list of strings"""\n+        possible_values = self.multiple_types_global_query_params[idx_name]\n+        for current_value, future_value in possible_values.items():\n+            if isinstance(idx_query, current_value):\n+                return future_value(idx_query)\n+\n     def __call__(self, query):\n         for idx_name, idx_query in query.items():\n             if idx_name in self.global_query_params:\n@@ -96,6 +106,9 @@ def __call__(self, query):\n                 query[idx_name] = self.parse_query_param(idx_name, idx_query)\n                 continue\n \n+            if idx_name in self.multiple_types_global_query_params:\n+                query[idx_name] = self.parse_multiple_types_param(idx_name, idx_query)\n+\n             # Then check for each index present in the query if there is an\n             # IIndexQueryParser that knows how to deserialize any values\n             # that could not be serialized in a query string or JSON\ndiff --git a/src/plone/restapi/tests/http-examples/search_sort_multiple_indexes.req b/src/plone/restapi/tests/http-examples/search_sort_multiple_indexes.req\nnew file mode 100644\nindex 000000000..5481a31be\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/search_sort_multiple_indexes.req\n@@ -0,0 +1,3 @@\n+GET /plone/@search?sort_on=portal_type&sort_on=sortable_title HTTP/1.1\n+Accept: application/json\n+Authorization: Basic YWRtaW46c2VjcmV0\ndiff --git a/src/plone/restapi/tests/http-examples/search_sort_multiple_indexes.resp b/src/plone/restapi/tests/http-examples/search_sort_multiple_indexes.resp\nnew file mode 100644\nindex 000000000..0d578fd83\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/search_sort_multiple_indexes.resp\n@@ -0,0 +1,51 @@\n+HTTP/1.1 200 OK\n+Content-Type: application/json\n+\n+{\n+    "@id": "http://localhost:55001/plone/@search",\n+    "items": [\n+        {\n+            "@id": "http://localhost:55001/plone/doc1",\n+            "@type": "Document",\n+            "description": "",\n+            "review_state": "private",\n+            "title": "Lorem Ipsum"\n+        },\n+        {\n+            "@id": "http://localhost:55001/plone/doc2",\n+            "@type": "Document",\n+            "description": "",\n+            "review_state": "private",\n+            "title": "Lorem Ipsum"\n+        },\n+        {\n+            "@id": "http://localhost:55001/plone/front-page",\n+            "@type": "Document",\n+            "description": "Congratulations! You have successfully installed Plone.",\n+            "review_state": "private",\n+            "title": "Welcome to Plone"\n+        },\n+        {\n+            "@id": "http://localhost:55001/plone/folder1",\n+            "@type": "Folder",\n+            "description": "",\n+            "review_state": "private",\n+            "title": "Folder 1"\n+        },\n+        {\n+            "@id": "http://localhost:55001/plone/folder2",\n+            "@type": "Folder",\n+            "description": "",\n+            "review_state": "private",\n+            "title": "Folder 2"\n+        },\n+        {\n+            "@id": "http://localhost:55001/plone",\n+            "@type": "Plone Site",\n+            "description": "",\n+            "review_state": null,\n+            "title": "Plone site"\n+        }\n+    ],\n+    "items_total": 6\n+}\ndiff --git a/src/plone/restapi/tests/test_documentation.py b/src/plone/restapi/tests/test_documentation.py\nindex 9d6535386..b6010ee8f 100644\n--- a/src/plone/restapi/tests/test_documentation.py\n+++ b/src/plone/restapi/tests/test_documentation.py\n@@ -440,6 +440,18 @@ def test_documentation_search_multiple_paths(self):\n         response = self.api_session.get("/@search", params=query)\n         save_request_and_response_for_docs("search_multiple_paths", response)\n \n+    def test_documentation_search_sort_multiple_indexes(self):\n+        self.portal.invokeFactory("Folder", id="folder1", title="Folder 1")\n+        self.portal.invokeFactory("Document", id="doc1", title="Lorem Ipsum")\n+        self.portal.invokeFactory("Folder", id="folder2", title="Folder 2")\n+        self.portal.invokeFactory("Document", id="doc2", title="Lorem Ipsum")\n+        transaction.commit()\n+        query = {\n+            "sort_on": ["portal_type", "sortable_title"],\n+        }\n+        response = self.api_session.get("/@search", params=query)\n+        save_request_and_response_for_docs("search_sort_multiple_indexes", response)\n+\n     def test_documentation_search_metadata_fields(self):\n         self.portal.invokeFactory("Document", id="doc1", title="Lorem Ipsum")\n         transaction.commit()\n'

